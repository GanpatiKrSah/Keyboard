			Arrays.asList('secret'));
	private static final Map<String, List<String>> COOKIE_HEADER = Map.of(HttpHeaders.COOKIE,
			Arrays.asList('test=test'));
	private static final Map<String, List<String>> SET_COOKIE_HEADER = Map.of(HttpHeaders.SET_COOKIE,
			Arrays.asList('test=test'));
	private static final Supplier<Principal> NO_PRINCIPAL = () -> null;
	private static final Supplier<String> NO_SESSION_ID = () -> null;
	private static final Supplier<Principal> WITH_PRINCIPAL = () -> {
		Principal principal = mock(Principal.class);
		given(principal.getName()).willReturn('alice');
		return principal;
	};
	private static final Supplier<String> WITH_SESSION_ID = () -> 'JSESSION_123';
	@Test
	void getTimestampReturnsTimestamp() {
		Instant now = Instant.now();
		Clock clock = Clock.fixed(now, ZoneId.systemDefault());
		HttpExchange exchange = HttpExchange.start(clock, createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getTimestamp()).isEqualTo(now);
	}
	@Test
	void getRequestUriReturnsUri() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getRequest().getUri()).isEqualTo(URI.create('https://api.example.com'));
	}
	@Test
	void getRequestRemoteAddressWhenUsingDefaultIncludesReturnsNull() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getRequest().getRemoteAddress()).isNull();
	}
	@Test
	void getRequestRemoteAddressWhenIncludedReturnsRemoteAddress() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.REMOTE_ADDRESS);
		assertThat(exchange.getRequest().getRemoteAddress()).isEqualTo('127.0.0.1');
	}
	@Test
	void getRequestMethodReturnsHttpMethod() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getRequest().getMethod()).isEqualTo('GET');
	}
	@Test
	void getRequestHeadersWhenUsingDefaultIncludesReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getRequest().getHeaders()).containsOnlyKeys(HttpHeaders.ACCEPT);
	}
	@Test
	void getRequestHeadersWhenIncludedReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.REQUEST_HEADERS);
		assertThat(exchange.getRequest().getHeaders()).containsOnlyKeys(HttpHeaders.ACCEPT);
	}
	@Test
	void getRequestHeadersWhenNotIncludedReturnsEmptyHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID);
		assertThat(exchange.getRequest().getHeaders()).isEmpty();
	}
	@Test
	void getRequestHeadersWhenUsingDefaultIncludesFiltersAuthorizeHeader() {
		HttpExchange exchange = HttpExchange.start(createRequest(AUTHORIZATION_HEADER))
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getRequest().getHeaders()).isEmpty();
	}
	@Test
	void getRequestHeadersWhenIncludesAuthorizationHeaderReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest(AUTHORIZATION_HEADER))
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.REQUEST_HEADERS,
					Include.AUTHORIZATION_HEADER);
		assertThat(exchange.getRequest().getHeaders()).containsOnlyKeys(HttpHeaders.AUTHORIZATION);
	}
	@Test
	void getRequestHeadersWhenIncludesAuthorizationHeaderAndInDifferentCaseReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest(mixedCase(AUTHORIZATION_HEADER)))
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.REQUEST_HEADERS,
					Include.AUTHORIZATION_HEADER);
		assertThat(exchange.getRequest().getHeaders()).containsOnlyKeys(mixedCase(HttpHeaders.AUTHORIZATION));
	}
	@Test
	void getRequestHeadersWhenUsingDefaultIncludesFiltersCookieHeader() {
		HttpExchange exchange = HttpExchange.start(createRequest(COOKIE_HEADER))
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getRequest().getHeaders()).isEmpty();
	}
	@Test
	void getRequestHeadersWhenIncludesCookieHeaderReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest(COOKIE_HEADER))
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.REQUEST_HEADERS, Include.COOKIE_HEADERS);
		assertThat(exchange.getRequest().getHeaders()).containsOnlyKeys(HttpHeaders.COOKIE);
	}
	@Test
	void getRequestHeadersWhenIncludesCookieHeaderAndInDifferentCaseReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest(mixedCase(COOKIE_HEADER)))
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.REQUEST_HEADERS, Include.COOKIE_HEADERS);
		assertThat(exchange.getRequest().getHeaders()).containsOnlyKeys(mixedCase(HttpHeaders.COOKIE));
	}
	@Test
	void getResponseStatusReturnsStatus() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.REMOTE_ADDRESS);
		assertThat(exchange.getResponse().getStatus()).isEqualTo(204);
	}
	@Test
	void getResponseHeadersWhenUsingDefaultIncludesReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getResponse().getHeaders()).containsOnlyKeys(HttpHeaders.CONTENT_TYPE);
	}
	@Test
	void getResponseHeadersWhenNotIncludedReturnsEmptyHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID);
		assertThat(exchange.getResponse().getHeaders()).isEmpty();
	}
	@Test
	void getResponseHeadersIncludedReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.RESPONSE_HEADERS);
		assertThat(exchange.getResponse().getHeaders()).containsOnlyKeys(HttpHeaders.CONTENT_TYPE);
	}
	@Test
	void getResponseHeadersWhenUsingDefaultIncludesFiltersSetCookieHeader() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(SET_COOKIE_HEADER), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getResponse().getHeaders()).isEmpty();
	}
	@Test
	void getResponseHeadersWhenIncludesCookieHeaderReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(SET_COOKIE_HEADER), NO_PRINCIPAL, NO_SESSION_ID, Include.RESPONSE_HEADERS,
					Include.COOKIE_HEADERS);
		assertThat(exchange.getResponse().getHeaders()).containsKey(HttpHeaders.SET_COOKIE);
	}
	@Test
	void getResponseHeadersWhenIncludesCookieHeaderAndInDifferentCaseReturnsHeaders() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(mixedCase(SET_COOKIE_HEADER)), NO_PRINCIPAL, NO_SESSION_ID, Include.RESPONSE_HEADERS,
					Include.COOKIE_HEADERS);
		assertThat(exchange.getResponse().getHeaders()).containsKey(mixedCase(HttpHeaders.SET_COOKIE));
	}
	@Test
	void getPrincipalWhenUsingDefaultIncludesReturnsNull() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), WITH_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getPrincipal()).isNull();
	}
	@Test
	void getPrincipalWhenIncludesPrincipalReturnsPrincipal() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), WITH_PRINCIPAL, NO_SESSION_ID, Include.PRINCIPAL);
		assertThat(exchange.getPrincipal()).isNotNull();
		assertThat(exchange.getPrincipal().getName()).isEqualTo('alice');
	}
	@Test
	void getSessionIdWhenUsingDefaultIncludesReturnsNull() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, WITH_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getSession()).isNull();
	}
	@Test
	void getSessionIdWhenIncludesSessionReturnsSessionId() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, WITH_SESSION_ID, Include.SESSION_ID);
		assertThat(exchange.getSession()).isNotNull();
		assertThat(exchange.getSession().getId()).isEqualTo('JSESSION_123');
	}
	@Test
	void getTimeTakenWhenUsingDefaultIncludesReturnsTimeTaken() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getTimeTaken()).isNotNull();
	}
	@Test
	void getTimeTakenWhenNotIncludedReturnsNull() {
		HttpExchange exchange = HttpExchange.start(createRequest())
			.finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID);
		assertThat(exchange.getTimeTaken()).isNull();
	}
	@Test
	void getTimeTakenWhenIncludesTimeTakenReturnsTimeTaken() {
		Duration duration = Duration.ofSeconds(1);
		Clock startClock = Clock.fixed(Instant.now(), ZoneId.systemDefault());
		Clock finishClock = Clock.offset(startClock, duration);
		HttpExchange exchange = HttpExchange.start(startClock, createRequest())
			.finish(finishClock, createResponse(), NO_PRINCIPAL, NO_SESSION_ID, Include.TIME_TAKEN);
		assertThat(exchange.getTimeTaken()).isEqualTo(duration);
	}
	@Test
	void defaultIncludes() {
		HttpHeaders requestHeaders = new HttpHeaders();
		requestHeaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
		requestHeaders.set(HttpHeaders.COOKIE, 'value');
		requestHeaders.set(HttpHeaders.AUTHORIZATION, 'secret');
		HttpHeaders responseHeaders = new HttpHeaders();
		responseHeaders.set(HttpHeaders.SET_COOKIE, 'test=test');
		responseHeaders.setContentLength(0);
		HttpExchange exchange = HttpExchange.start(createRequest(requestHeaders))
			.finish(createResponse(responseHeaders), NO_PRINCIPAL, NO_SESSION_ID, Include.defaultIncludes());
		assertThat(exchange.getTimeTaken()).isNotNull();
		assertThat(exchange.getPrincipal()).isNull();
		assertThat(exchange.getSession()).isNull();
		assertThat(exchange.getTimestamp()).isNotNull();
		assertThat(exchange.getRequest().getMethod()).isEqualTo('GET');
		assertThat(exchange.getRequest().getRemoteAddress()).isNull();
		assertThat(exchange.getResponse().getStatus()).isEqualTo(204);
		assertThat(exchange.getRequest().getHeaders()).containsOnlyKeys(HttpHeaders.ACCEPT);
		assertThat(exchange.getResponse().getHeaders()).containsOnlyKeys(HttpHeaders.CONTENT_LENGTH);
	}
	private RecordableHttpRequest createRequest() {
		return createRequest(Collections.singletonMap(HttpHeaders.ACCEPT, Arrays.asList('application/json')));
	}
	private RecordableHttpRequest createRequest(Map<String, List<String>> headers) {
		RecordableHttpRequest request = mock(RecordableHttpRequest.class);
		given(request.getMethod()).willReturn('GET');
		given(request.getUri()).willReturn(URI.create('https://api.example.com'));
		given(request.getHeaders()).willReturn(new HashMap<>(headers));
		given(request.getRemoteAddress()).willReturn('127.0.0.1');
		return request;
	}
	private RecordableHttpResponse createResponse() {
		return createResponse(Collections.singletonMap(HttpHeaders.CONTENT_TYPE, Arrays.asList('application/json')));
	}
	private RecordableHttpResponse createResponse(Map<String, List<String>> headers) {
		RecordableHttpResponse response = mock(RecordableHttpResponse.class);
		given(response.getStatus()).willReturn(204);
		given(response.getHeaders()).willReturn(new HashMap<>(headers));
		return response;
	}
	private Map<String, List<String>> mixedCase(Map<String, List<String>> headers) {
		Map<String, List<String>> result = new LinkedHashMap<>();
		headers.forEach((key, value) -> result.put(mixedCase(key), value));
		return result;
	}
	private String mixedCase(String input) {
		StringBuilder output = new StringBuilder();
		for (int i = 0; i < input.length(); i++) {
			char ch = input.charAt(i);
			output.append((i % 2 != 0) ? Character.toUpperCase(ch) : Character.toLowerCase(ch));
		}
		return output.toString();
	}
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
class HttpExchangesEndpointTests {
	private static final Supplier<Principal> NO_PRINCIPAL = () -> null;
	private static final Supplier<String> NO_SESSION_ID = () -> null;
	@Test
	void httpExchanges() {
		HttpExchangeRepository repository = new InMemoryHttpExchangeRepository();
		repository.add(HttpExchange.start(createRequest('GET')).finish(createResponse(), NO_PRINCIPAL, NO_SESSION_ID));
		List<HttpExchange> httpExchanges = new HttpExchangesEndpoint(repository).httpExchanges().getExchanges();
		assertThat(httpExchanges).hasSize(1);
		HttpExchange exchange = httpExchanges.get(0);
		assertThat(exchange.getRequest().getMethod()).isEqualTo('GET');
	}
	private RecordableHttpRequest createRequest(String method) {
		RecordableHttpRequest request = mock(RecordableHttpRequest.class);
		given(request.getMethod()).willReturn(method);
		return request;
	}
	private RecordableHttpResponse createResponse() {
		return mock(RecordableHttpResponse.class);
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.reactive;
/**
class RecordableServerHttpRequestTests {
	private ServerWebExchange exchange;
	private ServerHttpRequest request;
	@BeforeEach
	void setUp() {
		this.exchange = mock(ServerWebExchange.class);
		this.request = mock(ServerHttpRequest.class);
		given(this.exchange.getRequest()).willReturn(this.request);
		given(this.request.getMethod()).willReturn(HttpMethod.GET);
	}
	@Test
	void getMethod() {
		RecordableServerHttpRequest sourceRequest = new RecordableServerHttpRequest(this.request);
		assertThat(sourceRequest.getMethod()).isEqualTo('GET');
	}
	@Test
	void getUri() {
		URI uri = URI.create('http://localhost:8080/');
		given(this.request.getURI()).willReturn(uri);
		RecordableServerHttpRequest sourceRequest = new RecordableServerHttpRequest(this.request);
		assertThat(sourceRequest.getUri()).isSameAs(uri);
	}
	@Test
	void getHeaders() {
		HttpHeaders httpHeaders = new HttpHeaders();
		httpHeaders.add('name', 'value');
		given(this.request.getHeaders()).willReturn(httpHeaders);
		RecordableServerHttpRequest sourceRequest = new RecordableServerHttpRequest(this.request);
		assertThat(sourceRequest.getHeaders()).containsOnly(entry('name', Collections.singletonList('value')));
	}
	@Test
	void getUnresolvedRemoteAddress() {
		InetSocketAddress socketAddress = InetSocketAddress.createUnresolved('unresolved.example.com', 8080);
		given(this.request.getRemoteAddress()).willReturn(socketAddress);
		RecordableServerHttpRequest sourceRequest = new RecordableServerHttpRequest(this.request);
		assertThat(sourceRequest.getRemoteAddress()).isNull();
	}
	@Test
	void getRemoteAddress() {
		InetSocketAddress socketAddress = new InetSocketAddress(0);
		given(this.request.getRemoteAddress()).willReturn(socketAddress);
		RecordableServerHttpRequest sourceRequest = new RecordableServerHttpRequest(this.request);
		assertThat(sourceRequest.getRemoteAddress()).isEqualTo(socketAddress.getAddress().toString());
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.reactive;
/**
class HttpExchangesWebFilterTests {
	private final InMemoryHttpExchangeRepository repository = new InMemoryHttpExchangeRepository();
	private final HttpExchangesWebFilter filter = new HttpExchangesWebFilter(this.repository,
			EnumSet.allOf(Include.class));
	@Test
	void filterRecordsExchange() {
		executeFilter(MockServerWebExchange.from(MockServerHttpRequest.get('https://api.example.com')),
				(exchange) -> Mono.empty());
		assertThat(this.repository.findAll()).hasSize(1);
	}
	@Test
	void filterRecordsSessionIdWhenSessionIsUsed() {
		executeFilter(MockServerWebExchange.from(MockServerHttpRequest.get('https://api.example.com')),
				(exchange) -> exchange.getSession()
					.doOnNext((session) -> session.getAttributes().put('a', 'alpha'))
					.then());
		assertThat(this.repository.findAll()).hasSize(1);
		Session session = this.repository.findAll().get(0).getSession();
		assertThat(session).isNotNull();
		assertThat(session.getId()).isNotNull();
	}
	@Test
	void filterDoesNotRecordIdOfUnusedSession() {
		executeFilter(MockServerWebExchange.from(MockServerHttpRequest.get('https://api.example.com')),
				(exchange) -> exchange.getSession().then());
		assertThat(this.repository.findAll()).hasSize(1);
		Session session = this.repository.findAll().get(0).getSession();
		assertThat(session).isNull();
	}
	@Test
	void filterRecordsPrincipal() {
		Principal principal = mock(Principal.class);
		given(principal.getName()).willReturn('alice');
		executeFilter(new ServerWebExchangeDecorator(
				MockServerWebExchange.from(MockServerHttpRequest.get('https://api.example.com'))) {
			@SuppressWarnings('unchecked')
			@Override
			public <T extends Principal> Mono<T> getPrincipal() {
				return Mono.just((T) principal);
			}
		}, (exchange) -> exchange.getSession().doOnNext((session) -> session.getAttributes().put('a', 'alpha')).then());
		assertThat(this.repository.findAll()).hasSize(1);
		org.springframework.boot.actuate.web.exchanges.HttpExchange.Principal recordedPrincipal = this.repository
			.findAll()
			.get(0)
			.getPrincipal();
		assertThat(recordedPrincipal).isNotNull();
		assertThat(recordedPrincipal.getName()).isEqualTo('alice');
	}
	private void executeFilter(ServerWebExchange exchange, WebFilterChain chain) {
		StepVerifier
			.create(this.filter.filter(exchange, chain).then(Mono.defer(() -> exchange.getResponse().setComplete())))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.reactive;
/**
class HttpExchangesWebFilterIntegrationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withUserConfiguration(Config.class);
	@Test
	void exchangeForNotFoundResponseHas404Status() {
		this.contextRunner.run((context) -> {
			WebTestClient.bindToApplicationContext(context)
				.build()
				.get()
				.uri('/')
				.exchange()
				.expectStatus()
				.isNotFound();
			HttpExchangeRepository repository = context.getBean(HttpExchangeRepository.class);
			assertThat(repository.findAll()).hasSize(1);
			assertThat(repository.findAll().get(0).getResponse().getStatus()).isEqualTo(404);
		});
	}
	@Test
	void exchangeForMonoErrorWithRuntimeExceptionHas500Status() {
		this.contextRunner.run((context) -> {
			WebTestClient.bindToApplicationContext(context)
				.build()
				.get()
				.uri('/mono-error')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
			HttpExchangeRepository repository = context.getBean(HttpExchangeRepository.class);
			assertThat(repository.findAll()).hasSize(1);
			assertThat(repository.findAll().get(0).getResponse().getStatus()).isEqualTo(500);
		});
	}
	@Test
	void exchangeForThrownRuntimeExceptionHas500Status() {
		this.contextRunner.run((context) -> {
			WebTestClient.bindToApplicationContext(context)
				.build()
				.get()
				.uri('/thrown')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
			HttpExchangeRepository repository = context.getBean(HttpExchangeRepository.class);
			assertThat(repository.findAll()).hasSize(1);
			assertThat(repository.findAll().get(0).getResponse().getStatus()).isEqualTo(500);
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebFlux
	static class Config {
		@Bean
		HttpExchangesWebFilter httpExchangesWebFilter(HttpExchangeRepository repository) {
			return new HttpExchangesWebFilter(repository, EnumSet.allOf(Include.class));
		}
		@Bean
		HttpExchangeRepository httpExchangeRepository() {
			return new InMemoryHttpExchangeRepository();
		}
		@Bean
		HttpHandler httpHandler(ApplicationContext applicationContext) {
			return WebHttpHandlerBuilder.applicationContext(applicationContext).build();
		}
		@Bean
		RouterFunction<ServerResponse> router() {
			return route(GET('/mono-error'), (request) -> Mono.error(new RuntimeException())).andRoute(GET('/thrown'),
					(HandlerFunction<ServerResponse>) (request) -> {
						throw new RuntimeException();
					});
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings;
/**
class MappingsEndpointTests {
	@Test
	void servletWebMappings() {
		Supplier<ConfigurableWebApplicationContext> contextSupplier = prepareContextSupplier();
		new WebApplicationContextRunner(contextSupplier)
			.withUserConfiguration(EndpointConfiguration.class, ServletWebConfiguration.class)
			.run((context) -> {
				ContextMappingsDescriptor contextMappings = contextMappings(context);
				assertThat(contextMappings.getParentId()).isNull();
				assertThat(contextMappings.getMappings()).containsOnlyKeys('dispatcherServlets', 'servletFilters',
						'servlets');
				Map<String, List<DispatcherServletMappingDescription>> dispatcherServlets = mappings(contextMappings,
						'dispatcherServlets');
				assertThat(dispatcherServlets).containsOnlyKeys('dispatcherServlet');
				List<DispatcherServletMappingDescription> handlerMappings = dispatcherServlets.get('dispatcherServlet');
				assertThat(handlerMappings).hasSize(1);
				List<ServletRegistrationMappingDescription> servlets = mappings(contextMappings, 'servlets');
				assertThat(servlets).hasSize(1);
				List<FilterRegistrationMappingDescription> filters = mappings(contextMappings, 'servletFilters');
				assertThat(filters).hasSize(1);
			});
	}
	@Test
	void servletWebMappingsWithPathPatternParser() {
		Supplier<ConfigurableWebApplicationContext> contextSupplier = prepareContextSupplier();
		new WebApplicationContextRunner(contextSupplier)
			.withUserConfiguration(EndpointConfiguration.class, ServletWebConfiguration.class,
					PathPatternParserConfiguration.class)
			.run((context) -> {
				ContextMappingsDescriptor contextMappings = contextMappings(context);
				assertThat(contextMappings.getParentId()).isNull();
				assertThat(contextMappings.getMappings()).containsOnlyKeys('dispatcherServlets', 'servletFilters',
						'servlets');
				Map<String, List<DispatcherServletMappingDescription>> dispatcherServlets = mappings(contextMappings,
						'dispatcherServlets');
				assertThat(dispatcherServlets).containsOnlyKeys('dispatcherServlet');
				List<DispatcherServletMappingDescription> handlerMappings = dispatcherServlets.get('dispatcherServlet');
				assertThat(handlerMappings).hasSize(1);
				List<ServletRegistrationMappingDescription> servlets = mappings(contextMappings, 'servlets');
				assertThat(servlets).hasSize(1);
				List<FilterRegistrationMappingDescription> filters = mappings(contextMappings, 'servletFilters');
				assertThat(filters).hasSize(1);
			});
	}
	@Test
	void servletWebMappingsWithAdditionalDispatcherServlets() {
		Supplier<ConfigurableWebApplicationContext> contextSupplier = prepareContextSupplier();
		new WebApplicationContextRunner(contextSupplier)
			.withUserConfiguration(EndpointConfiguration.class, ServletWebConfiguration.class,
					CustomDispatcherServletConfiguration.class)
			.run((context) -> {
				ContextMappingsDescriptor contextMappings = contextMappings(context);
				Map<String, List<DispatcherServletMappingDescription>> dispatcherServlets = mappings(contextMappings,
						'dispatcherServlets');
				assertThat(dispatcherServlets).containsOnlyKeys('dispatcherServlet',
						'customDispatcherServletRegistration', 'anotherDispatcherServletRegistration');
				assertThat(dispatcherServlets.get('dispatcherServlet')).hasSize(1);
				assertThat(dispatcherServlets.get('customDispatcherServletRegistration')).hasSize(1);
				assertThat(dispatcherServlets.get('anotherDispatcherServletRegistration')).hasSize(1);
			});
	}
	@SuppressWarnings('unchecked')
	private Supplier<ConfigurableWebApplicationContext> prepareContextSupplier() {
		ServletContext servletContext = mock(ServletContext.class);
		given(servletContext.getInitParameterNames()).willReturn(Collections.emptyEnumeration());
		given(servletContext.getAttributeNames()).willReturn(Collections.emptyEnumeration());
		FilterRegistration filterRegistration = mock(FilterRegistration.class);
		given((Map<String, FilterRegistration>) servletContext.getFilterRegistrations())
			.willReturn(Collections.singletonMap('testFilter', filterRegistration));
		ServletRegistration servletRegistration = mock(ServletRegistration.class);
		given((Map<String, ServletRegistration>) servletContext.getServletRegistrations())
			.willReturn(Collections.singletonMap('testServlet', servletRegistration));
		return () -> {
			AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext();
			context.setServletContext(servletContext);
			return context;
		};
	}
	@Test
	void reactiveWebMappings() {
		new ReactiveWebApplicationContextRunner()
			.withUserConfiguration(EndpointConfiguration.class, ReactiveWebConfiguration.class)
			.run((context) -> {
				ContextMappingsDescriptor contextMappings = contextMappings(context);
				assertThat(contextMappings.getParentId()).isNull();
				assertThat(contextMappings.getMappings()).containsOnlyKeys('dispatcherHandlers');
				Map<String, List<DispatcherHandlerMappingDescription>> dispatcherHandlers = mappings(contextMappings,
						'dispatcherHandlers');
				assertThat(dispatcherHandlers).containsOnlyKeys('webHandler');
				List<DispatcherHandlerMappingDescription> handlerMappings = dispatcherHandlers.get('webHandler');
				assertThat(handlerMappings).hasSize(4);
			});
	}
	private ContextMappingsDescriptor contextMappings(ApplicationContext context) {
		ApplicationMappingsDescriptor applicationMappings = context.getBean(MappingsEndpoint.class).mappings();
		assertThat(applicationMappings.getContexts()).containsOnlyKeys(context.getId());
		return applicationMappings.getContexts().get(context.getId());
	}
	@SuppressWarnings('unchecked')
	private <T> T mappings(ContextMappingsDescriptor contextMappings, String key) {
		return (T) contextMappings.getMappings().get(key);
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointConfiguration {
		@Bean
		MappingsEndpoint mappingsEndpoint(Collection<MappingDescriptionProvider> descriptionProviders,
				ApplicationContext context) {
			return new MappingsEndpoint(descriptionProviders, context);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebFlux
	@Controller
	static class ReactiveWebConfiguration {
		@Bean
		DispatcherHandlersMappingDescriptionProvider dispatcherHandlersMappingDescriptionProvider() {
			return new DispatcherHandlersMappingDescriptionProvider();
		}
		@Bean
		RouterFunction<ServerResponse> routerFunction() {
			return route(GET('/one'), (request) -> ServerResponse.ok().build()).andRoute(POST('/two'),
					(request) -> ServerResponse.ok().build());
		}
		@RequestMapping('/three')
		void three() {
		}
		@Bean
		RouterFunction<ServerResponse> routerFunctionWithAttributes() {
			return route(GET('/four'), (request) -> ServerResponse.ok().build()).withAttribute('test', 'test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	@Controller
	static class ServletWebConfiguration {
		@Bean
		DispatcherServletsMappingDescriptionProvider dispatcherServletsMappingDescriptionProvider() {
			return new DispatcherServletsMappingDescriptionProvider();
		}
		@Bean
		ServletsMappingDescriptionProvider servletsMappingDescriptionProvider() {
			return new ServletsMappingDescriptionProvider();
		}
		@Bean
		FiltersMappingDescriptionProvider filtersMappingDescriptionProvider() {
			return new FiltersMappingDescriptionProvider();
		}
		@Bean
		DispatcherServlet dispatcherServlet(WebApplicationContext context) throws ServletException {
			DispatcherServlet dispatcherServlet = new DispatcherServlet(context);
			dispatcherServlet.init(new MockServletConfig());
			return dispatcherServlet;
		}
		@RequestMapping('/three')
		void three() {
		}
	}
	@Configuration
	static class CustomDispatcherServletConfiguration {
		@Bean
		ServletRegistrationBean<DispatcherServlet> customDispatcherServletRegistration(WebApplicationContext context) {
			ServletRegistrationBean<DispatcherServlet> registration = new ServletRegistrationBean<>(
					createTestDispatcherServlet(context));
			registration.setName('customDispatcherServletRegistration');
			return registration;
		}
		@Bean
		DispatcherServlet anotherDispatcherServlet(WebApplicationContext context) {
			return createTestDispatcherServlet(context);
		}
		@Bean
		ServletRegistrationBean<DispatcherServlet> anotherDispatcherServletRegistration(
				DispatcherServlet dispatcherServlet, WebApplicationContext context) {
			ServletRegistrationBean<DispatcherServlet> registrationBean = new ServletRegistrationBean<>(
					anotherDispatcherServlet(context));
			registrationBean.setName('anotherDispatcherServletRegistration');
			return registrationBean;
		}
		private DispatcherServlet createTestDispatcherServlet(WebApplicationContext context) {
			try {
				DispatcherServlet dispatcherServlet = new DispatcherServlet(context);
				dispatcherServlet.init(new MockServletConfig());
				return dispatcherServlet;
			}
			catch (ServletException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
	@Configuration
	static class PathPatternParserConfiguration {
		@Bean
		WebMvcConfigurer pathPatternParserConfigurer() {
			return new WebMvcConfigurer() {
				@Override
				public void configurePathMatch(PathMatchConfigurer configurer) {
					configurer.setPatternParser(new PathPatternParser());
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
class ServletsMappingDescriptionProviderTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new ServletsMappingDescriptionProviderRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(ServletRegistrationMappingDescription.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
class DispatcherServletsMappingDescriptionProviderTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new DispatcherServletsMappingDescriptionProviderRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(DispatcherServletMappingDescription.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
class FiltersMappingDescriptionProviderTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new FiltersMappingDescriptionProviderRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(FilterRegistrationMappingDescription.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.web.mappings.reactive;
/**
class DispatcherHandlersMappingDescriptionProviderTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new DispatcherHandlersMappingDescriptionProviderRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(DispatcherHandlerMappingDescription.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.integration;
/**
class IntegrationGraphEndpointWebIntegrationTests {
	@WebEndpointTest
	void graph(WebTestClient client) {
		client.get()
			.uri('/actuator/integrationgraph')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('contentDescriptor.providerVersion')
			.isNotEmpty()
			.jsonPath('contentDescriptor.providerFormatVersion')
			.isEqualTo(1.2f)
			.jsonPath('contentDescriptor.provider')
			.isEqualTo('spring-integration');
	}
	@WebEndpointTest
	void rebuild(WebTestClient client) {
		client.post()
			.uri('/actuator/integrationgraph')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isNoContent();
	}
	@Configuration(proxyBeanMethods = false)
	@EnableIntegration
	static class TestConfiguration {
		@Bean
		IntegrationGraphEndpoint endpoint(IntegrationGraphServer integrationGraphServer) {
			return new IntegrationGraphEndpoint(integrationGraphServer);
		}
		@Bean
		IntegrationGraphServer integrationGraphServer() {
			return new IntegrationGraphServer();
		}
	}
}
/*
package org.springframework.boot.actuate.integration;
/**
class IntegrationGraphEndpointTests {
	private final IntegrationGraphServer server = mock(IntegrationGraphServer.class);
	private final IntegrationGraphEndpoint endpoint = new IntegrationGraphEndpoint(this.server);
	@Test
	void readOperationShouldReturnGraph() {
		Graph graph = mock(Graph.class);
		Map<String, Object> contentDescriptor = new LinkedHashMap<>();
		Collection<IntegrationNode> nodes = new ArrayList<>();
		Collection<LinkNode> links = new ArrayList<>();
		given(graph.getContentDescriptor()).willReturn(contentDescriptor);
		given(graph.getNodes()).willReturn(nodes);
		given(graph.getLinks()).willReturn(links);
		given(this.server.getGraph()).willReturn(graph);
		GraphDescriptor descriptor = this.endpoint.graph();
		then(this.server).should().getGraph();
		assertThat(descriptor.getContentDescriptor()).isSameAs(contentDescriptor);
		assertThat(descriptor.getNodes()).isSameAs(nodes);
		assertThat(descriptor.getLinks()).isSameAs(links);
	}
	@Test
	void writeOperationShouldRebuildGraph() {
		this.endpoint.rebuild();
		then(this.server).should().rebuild();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@ExtendWith(OutputCaptureExtension.class)
class AbstractHealthIndicatorTests {
	@Test
	void healthCheckWhenUpDoesNotLogHealthCheckFailedMessage(CapturedOutput output) {
		TestHealthIndicator indicator = new TestHealthIndicator('Test message', Builder::up);
		Health heath = indicator.health();
		assertThat(heath.getStatus()).isEqualTo(Status.UP);
		assertThat(output).doesNotContain('Test message');
	}
	@Test
	void healthCheckWhenDownWithExceptionThrownLogsHealthCheckFailedMessage(CapturedOutput output) {
		TestHealthIndicator indicator = new TestHealthIndicator('Test message', (builder) -> {
			throw new IllegalStateException('Test exception');
		});
		Health heath = indicator.health();
		assertThat(heath.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Test message').contains('Test exception');
	}
	@Test
	void healthCheckWhenDownWithExceptionConfiguredLogsHealthCheckFailedMessage(CapturedOutput output) {
		Health heath = new TestHealthIndicator('Test message',
				(builder) -> builder.down().withException(new IllegalStateException('Test exception')))
			.health();
		assertThat(heath.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Test message').contains('Test exception');
	}
	@Test
	void healthCheckWhenDownWithExceptionConfiguredDoesNotLogHealthCheckFailedMessageTwice(CapturedOutput output) {
		TestHealthIndicator indicator = new TestHealthIndicator('Test message', (builder) -> {
			IllegalStateException ex = new IllegalStateException('Test exception');
			builder.down().withException(ex);
			throw ex;
		});
		Health heath = indicator.health();
		assertThat(heath.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Test message').containsOnlyOnce('Test exception');
	}
	@Test
	void healthCheckWhenDownWithExceptionAndNoFailureMessageLogsDefaultMessage(CapturedOutput output) {
		TestHealthIndicator indicator = new TestHealthIndicator(
				(builder) -> builder.down().withException(new IllegalStateException('Test exception')));
		Health heath = indicator.health();
		assertThat(heath.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Health check failed').contains('Test exception');
	}
	@Test
	void healthCheckWhenDownWithErrorLogsDefaultMessage(CapturedOutput output) {
		TestHealthIndicator indicator = new TestHealthIndicator('Test Message',
				(builder) -> builder.down().withException(new Error('Test error')));
		Health heath = indicator.health();
		assertThat(heath.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Health check failed').contains('Test error');
	}
	static class TestHealthIndicator extends AbstractHealthIndicator {
		private final Consumer<Builder> action;
		TestHealthIndicator(String message, Consumer<Builder> action) {
			super(message);
			this.action = action;
		}
		TestHealthIndicator(Consumer<Builder> action) {
			this.action = action;
		}
		@Override
		protected void doHealthCheck(Builder builder) throws Exception {
			this.action.accept(builder);
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class CompositeHealthTests {
	@Test
	void createWhenStatusIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new CompositeHealth(ApiVersion.V3, null, Collections.emptyMap()))
			.withMessage('Status must not be null');
	}
	@Test
	void getStatusReturnsStatus() {
		CompositeHealth health = new CompositeHealth(ApiVersion.V3, Status.UP, Collections.emptyMap());
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void getComponentReturnsComponents() {
		Map<String, HealthComponent> components = new LinkedHashMap<>();
		components.put('a', Health.up().build());
		CompositeHealth health = new CompositeHealth(ApiVersion.V3, Status.UP, components);
		assertThat(health.getComponents()).isEqualTo(components);
	}
	@Test
	void serializeV3WithJacksonReturnsValidJson() throws Exception {
		Map<String, HealthComponent> components = new LinkedHashMap<>();
		components.put('db1', Health.up().build());
		components.put('db2', Health.down().withDetail('a', 'b').build());
		CompositeHealth health = new CompositeHealth(ApiVersion.V3, Status.UP, components);
		ObjectMapper mapper = new ObjectMapper();
		String json = mapper.writeValueAsString(health);
		assertThat(json).isEqualTo('{\'status\':\'UP\',\'components\':{\'db1\':{\'status\':\'UP\'},'
				+ '\'db2\':{\'status\':\'DOWN\',\'details\':{\'a\':\'b\'}}}}');
	}
	@Test
	void serializeV2WithJacksonReturnsValidJson() throws Exception {
		Map<String, HealthComponent> components = new LinkedHashMap<>();
		components.put('db1', Health.up().build());
		components.put('db2', Health.down().withDetail('a', 'b').build());
		CompositeHealth health = new CompositeHealth(ApiVersion.V2, Status.UP, components);
		ObjectMapper mapper = new ObjectMapper();
		String json = mapper.writeValueAsString(health);
		assertThat(json).isEqualTo('{\'status\':\'UP\',\'details\':{\'db1\':{\'status\':\'UP\'},'
				+ '\'db2\':{\'status\':\'DOWN\',\'details\':{\'a\':\'b\'}}}}');
	}
	@Test // gh-26797
	void serializeV2WithJacksonAndDisabledCanOverrideAccessModifiersReturnsValidJson() throws Exception {
		Map<String, HealthComponent> components = new LinkedHashMap<>();
		components.put('db1', Health.up().build());
		components.put('db2', Health.down().withDetail('a', 'b').build());
		CompositeHealth health = new CompositeHealth(ApiVersion.V2, Status.UP, components);
		JsonMapper mapper = JsonMapper.builder().disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS).build();
		String json = mapper.writeValueAsString(health);
		assertThat(json).isEqualTo('{\'status\':\'UP\',\'details\':{\'db1\':{\'status\':\'UP\'},'
				+ '\'db2\':{\'status\':\'DOWN\',\'details\':{\'a\':\'b\'}}}}');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class CompositeHealthContributorReactiveAdapterTests {
	@Test
	void createWhenDelegateIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new CompositeHealthContributorReactiveAdapter(null))
			.withMessage('Delegate must not be null');
	}
	@Test
	void iteratorWhenDelegateContainsHealthIndicatorAdaptsDelegate() {
		HealthIndicator indicator = () -> Health.up().withDetail('spring', 'boot').build();
		CompositeHealthContributor delegate = CompositeHealthContributor
			.fromMap(Collections.singletonMap('test', indicator));
		CompositeHealthContributorReactiveAdapter adapter = new CompositeHealthContributorReactiveAdapter(delegate);
		Iterator<NamedContributor<ReactiveHealthContributor>> iterator = adapter.iterator();
		assertThat(iterator.hasNext()).isTrue();
		NamedContributor<ReactiveHealthContributor> adapted = iterator.next();
		assertThat(adapted.getName()).isEqualTo('test');
		assertThat(adapted.getContributor()).isInstanceOf(ReactiveHealthIndicator.class);
		Health health = ((ReactiveHealthIndicator) adapted.getContributor()).getHealth(true).block();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('spring', 'boot');
	}
	@Test
	void iteratorWhenDelegateContainsCompositeHealthContributorAdaptsDelegate() {
		HealthIndicator indicator = () -> Health.up().withDetail('spring', 'boot').build();
		CompositeHealthContributor composite = CompositeHealthContributor
			.fromMap(Collections.singletonMap('test1', indicator));
		CompositeHealthContributor delegate = CompositeHealthContributor
			.fromMap(Collections.singletonMap('test2', composite));
		CompositeHealthContributorReactiveAdapter adapter = new CompositeHealthContributorReactiveAdapter(delegate);
		Iterator<NamedContributor<ReactiveHealthContributor>> iterator = adapter.iterator();
		assertThat(iterator.hasNext()).isTrue();
		NamedContributor<ReactiveHealthContributor> adapted = iterator.next();
		assertThat(adapted.getName()).isEqualTo('test2');
		assertThat(adapted.getContributor()).isInstanceOf(CompositeReactiveHealthContributor.class);
		ReactiveHealthContributor nested = ((CompositeReactiveHealthContributor) adapted.getContributor())
			.getContributor('test1');
		Health health = ((ReactiveHealthIndicator) nested).getHealth(true).block();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('spring', 'boot');
	}
	@Test
	void getContributorAdaptsDelegate() {
		HealthIndicator indicator = () -> Health.up().withDetail('spring', 'boot').build();
		CompositeHealthContributor delegate = CompositeHealthContributor
			.fromMap(Collections.singletonMap('test', indicator));
		CompositeHealthContributorReactiveAdapter adapter = new CompositeHealthContributorReactiveAdapter(delegate);
		ReactiveHealthContributor adapted = adapter.getContributor('test');
		Health health = ((ReactiveHealthIndicator) adapted).getHealth(true).block();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('spring', 'boot');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class ReactiveHealthContributorTests {
	@Test
	void adaptWhenNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ReactiveHealthContributor.adapt(null))
			.withMessage('HealthContributor must not be null');
	}
	@Test
	void adaptWhenHealthIndicatorReturnsHealthIndicatorReactiveAdapter() {
		HealthIndicator indicator = () -> Health.outOfService().build();
		ReactiveHealthContributor adapted = ReactiveHealthContributor.adapt(indicator);
		assertThat(adapted).isInstanceOf(HealthIndicatorReactiveAdapter.class);
		assertThat(((ReactiveHealthIndicator) adapted).health().block().getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
	}
	@Test
	void adaptWhenCompositeHealthContributorReturnsCompositeHealthContributorReactiveAdapter() {
		HealthIndicator indicator = () -> Health.outOfService().build();
		CompositeHealthContributor contributor = CompositeHealthContributor
			.fromMap(Collections.singletonMap('a', indicator));
		ReactiveHealthContributor adapted = ReactiveHealthContributor.adapt(contributor);
		assertThat(adapted).isInstanceOf(CompositeHealthContributorReactiveAdapter.class);
		ReactiveHealthContributor contained = ((CompositeReactiveHealthContributor) adapted).getContributor('a');
		assertThat(((ReactiveHealthIndicator) contained).health().block().getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
	}
	@Test
	void adaptWhenUnknownThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> ReactiveHealthContributor.adapt(mock(HealthContributor.class)))
			.withMessage('Unknown HealthContributor type');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
abstract class HealthEndpointSupportTests<S extends HealthEndpointSupport<C, T>, R extends ContributorRegistry<C>, C, T> {
	final R registry;
	final Health up = Health.up().withDetail('spring', 'boot').build();
	final Health down = Health.down().build();
	final TestHealthEndpointGroup primaryGroup = new TestHealthEndpointGroup();
	final TestHealthEndpointGroup allTheAs = new TestHealthEndpointGroup((name) -> name.startsWith('a'));
	final HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
			Collections.singletonMap('alltheas', this.allTheAs));
	HealthEndpointSupportTests() {
		this.registry = createRegistry();
	}
	@Test
	void createWhenRegistryIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> create(null, this.groups))
			.withMessage('Registry must not be null');
	}
	@Test
	void createWhenGroupsIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> create(this.registry, null))
			.withMessage('Groups must not be null');
	}
	@Test
	void getHealthWhenPathIsEmptyUsesPrimaryGroup() {
		this.registry.registerContributor('test', createContributor(this.up));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false);
		assertThat(result.getGroup()).isEqualTo(this.primaryGroup);
		assertThat(getHealth(result)).isNotSameAs(this.up);
		assertThat(getHealth(result).getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void getHealthWhenPathIsNotGroupReturnsResultFromPrimaryGroup() {
		this.registry.registerContributor('test', createContributor(this.up));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'test');
		assertThat(result.getGroup()).isEqualTo(this.primaryGroup);
		assertThat(getHealth(result)).isEqualTo(this.up);
	}
	@Test
	void getHealthWhenPathIsGroupReturnsResultFromGroup() {
		this.registry.registerContributor('atest', createContributor(this.up));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'alltheas', 'atest');
		assertThat(result.getGroup()).isEqualTo(this.allTheAs);
		assertThat(getHealth(result)).isEqualTo(this.up);
	}
	@Test
	void getHealthWhenAlwaysShowIsFalseAndGroupIsTrueShowsComponents() {
		C contributor = createContributor(this.up);
		C compositeContributor = createCompositeContributor(Collections.singletonMap('spring', contributor));
		this.registry.registerContributor('test', compositeContributor);
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'test');
		CompositeHealth health = (CompositeHealth) getHealth(result);
		assertThat(health.getComponents()).containsKey('spring');
	}
	@Test
	void getHealthWhenAlwaysShowIsFalseAndGroupIsFalseCannotAccessComponent() {
		this.primaryGroup.setShowComponents(false);
		C contributor = createContributor(this.up);
		C compositeContributor = createCompositeContributor(Collections.singletonMap('spring', contributor));
		this.registry.registerContributor('test', compositeContributor);
		HealthEndpointSupport<C, T> endpoint = create(this.registry, this.groups);
		HealthResult<T> rootResult = endpoint.getHealth(ApiVersion.V3, null, SecurityContext.NONE, false);
		assertThat(((CompositeHealth) getHealth(rootResult)).getComponents()).isNullOrEmpty();
		HealthResult<T> componentResult = endpoint.getHealth(ApiVersion.V3, null, SecurityContext.NONE, false, 'test');
		assertThat(componentResult).isNull();
	}
	@Test
	void getHealthWhenAlwaysShowIsTrueShowsComponents() {
		this.primaryGroup.setShowComponents(true);
		C contributor = createContributor(this.up);
		C compositeContributor = createCompositeContributor(Collections.singletonMap('spring', contributor));
		this.registry.registerContributor('test', compositeContributor);
		HealthEndpointSupport<C, T> endpoint = create(this.registry, this.groups);
		HealthResult<T> rootResult = endpoint.getHealth(ApiVersion.V3, null, SecurityContext.NONE, false);
		assertThat(((CompositeHealth) getHealth(rootResult)).getComponents()).containsKey('test');
		HealthResult<T> componentResult = endpoint.getHealth(ApiVersion.V3, null, SecurityContext.NONE, false, 'test');
		assertThat(((CompositeHealth) getHealth(componentResult)).getComponents()).containsKey('spring');
	}
	@Test
	void getHealthWhenAlwaysShowIsFalseAndGroupIsTrueShowsDetails() {
		this.registry.registerContributor('test', createContributor(this.up));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'test');
		assertThat(((Health) getHealth(result)).getDetails()).containsEntry('spring', 'boot');
	}
	@Test
	void getHealthWhenAlwaysShowIsFalseAndGroupIsFalseShowsNoDetails() {
		this.primaryGroup.setShowDetails(false);
		this.registry.registerContributor('test', createContributor(this.up));
		HealthEndpointSupport<C, T> endpoint = create(this.registry, this.groups);
		HealthResult<T> rootResult = endpoint.getHealth(ApiVersion.V3, null, SecurityContext.NONE, false);
		HealthResult<T> componentResult = endpoint.getHealth(ApiVersion.V3, null, SecurityContext.NONE, false, 'test');
		assertThat(((CompositeHealth) getHealth(rootResult)).getStatus()).isEqualTo(Status.UP);
		assertThat(componentResult).isNull();
	}
	@Test
	void getHealthWhenAlwaysShowIsTrueShowsDetails() {
		this.primaryGroup.setShowDetails(false);
		this.registry.registerContributor('test', createContributor(this.up));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				true, 'test');
		assertThat(((Health) getHealth(result)).getDetails()).containsEntry('spring', 'boot');
	}
	@Test
	void getHealthWhenCompositeReturnsAggregateResult() {
		Map<String, C> contributors = new LinkedHashMap<>();
		contributors.put('a', createContributor(this.up));
		contributors.put('b', createContributor(this.down));
		this.registry.registerContributor('test', createCompositeContributor(contributors));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false);
		CompositeHealth root = (CompositeHealth) getHealth(result);
		CompositeHealth component = (CompositeHealth) root.getComponents().get('test');
		assertThat(root.getStatus()).isEqualTo(Status.DOWN);
		assertThat(component.getStatus()).isEqualTo(Status.DOWN);
		assertThat(component.getComponents()).containsOnlyKeys('a', 'b');
	}
	@Test
	void getHealthWhenPathDoesNotExistReturnsNull() {
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'missing');
		assertThat(result).isNull();
	}
	@Test
	void getHealthWhenPathIsEmptyIncludesGroups() {
		this.registry.registerContributor('test', createContributor(this.up));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false);
		assertThat(((SystemHealth) getHealth(result)).getGroups()).containsOnly('alltheas');
	}
	@Test
	void getHealthWhenPathIsGroupDoesNotIncludesGroups() {
		this.registry.registerContributor('atest', createContributor(this.up));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'alltheas');
		assertThat(getHealth(result)).isNotInstanceOf(SystemHealth.class);
	}
	@Test
	void getHealthWithEmptyCompositeReturnsNullResult() { // gh-18687
		this.registry.registerContributor('test', createCompositeContributor(Collections.emptyMap()));
		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false);
		assertThat(result).isNull();
	}
	@Test
	void getHealthWhenGroupContainsCompositeContributorReturnsHealth() {
		C contributor = createContributor(this.up);
		C compositeContributor = createCompositeContributor(Collections.singletonMap('spring', contributor));
		this.registry.registerContributor('test', compositeContributor);
		TestHealthEndpointGroup testGroup = new TestHealthEndpointGroup((name) -> name.startsWith('test'));
		HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
				Collections.singletonMap('testGroup', testGroup));
		HealthResult<T> result = create(this.registry, groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'testGroup');
		CompositeHealth health = (CompositeHealth) getHealth(result);
		assertThat(health.getComponents()).containsKey('test');
	}
	@Test
	void getHealthWhenGroupContainsComponentOfCompositeContributorReturnsHealth() {
		CompositeHealth health = getCompositeHealth((name) -> name.equals('test/spring-1'));
		assertThat(health.getComponents()).containsKey('test');
		CompositeHealth test = (CompositeHealth) health.getComponents().get('test');
		assertThat(test.getComponents()).containsKey('spring-1');
		assertThat(test.getComponents()).doesNotContainKey('spring-2');
		assertThat(test.getComponents()).doesNotContainKey('test');
	}
	@Test
	void getHealthWhenGroupExcludesComponentOfCompositeContributorReturnsHealth() {
		CompositeHealth health = getCompositeHealth(
				(name) -> name.startsWith('test/') && !name.equals('test/spring-2'));
		assertThat(health.getComponents()).containsKey('test');
		CompositeHealth test = (CompositeHealth) health.getComponents().get('test');
		assertThat(test.getComponents()).containsKey('spring-1');
		assertThat(test.getComponents()).doesNotContainKey('spring-2');
	}
	@Test
	void getHealthForPathWhenGroupContainsComponentOfCompositeContributorReturnsHealth() {
		Map<String, C> contributors = new LinkedHashMap<>();
		contributors.put('spring-1', createNestedHealthContributor('spring-1'));
		contributors.put('spring-2', createNestedHealthContributor('spring-2'));
		C compositeContributor = createCompositeContributor(contributors);
		this.registry.registerContributor('test', compositeContributor);
		TestHealthEndpointGroup testGroup = new TestHealthEndpointGroup(
				(name) -> name.startsWith('test') && !name.equals('test/spring-1/b'));
		HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
				Collections.singletonMap('testGroup', testGroup));
		HealthResult<T> result = create(this.registry, groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'testGroup', 'test');
		CompositeHealth health = (CompositeHealth) getHealth(result);
		assertThat(health.getComponents()).containsKey('spring-1');
		assertThat(health.getComponents()).containsKey('spring-2');
		CompositeHealth spring1 = (CompositeHealth) health.getComponents().get('spring-1');
		CompositeHealth spring2 = (CompositeHealth) health.getComponents().get('spring-2');
		assertThat(spring1.getComponents()).containsKey('a');
		assertThat(spring1.getComponents()).containsKey('c');
		assertThat(spring1.getComponents()).doesNotContainKey('b');
		assertThat(spring2.getComponents()).containsKey('a');
		assertThat(spring2.getComponents()).containsKey('c');
		assertThat(spring2.getComponents()).containsKey('b');
	}
	@Test
	void getHealthForComponentPathWhenNotPartOfGroup() {
		Map<String, C> contributors = new LinkedHashMap<>();
		contributors.put('spring-1', createNestedHealthContributor('spring-1'));
		contributors.put('spring-2', createNestedHealthContributor('spring-2'));
		C compositeContributor = createCompositeContributor(contributors);
		this.registry.registerContributor('test', compositeContributor);
		TestHealthEndpointGroup testGroup = new TestHealthEndpointGroup(
				(name) -> name.startsWith('test') && !name.equals('test/spring-1/b'));
		HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
				Collections.singletonMap('testGroup', testGroup));
		HealthResult<T> result = create(this.registry, groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'testGroup', 'test', 'spring-1', 'b');
		assertThat(result).isNull();
	}
	private CompositeHealth getCompositeHealth(Predicate<String> memberPredicate) {
		C contributor1 = createContributor(this.up);
		C contributor2 = createContributor(this.down);
		Map<String, C> contributors = new LinkedHashMap<>();
		contributors.put('spring-1', contributor1);
		contributors.put('spring-2', contributor2);
		C compositeContributor = createCompositeContributor(contributors);
		this.registry.registerContributor('test', compositeContributor);
		TestHealthEndpointGroup testGroup = new TestHealthEndpointGroup(memberPredicate);
		HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
				Collections.singletonMap('testGroup', testGroup));
		HealthResult<T> result = create(this.registry, groups).getHealth(ApiVersion.V3, null, SecurityContext.NONE,
				false, 'testGroup');
		return (CompositeHealth) getHealth(result);
	}
	private C createNestedHealthContributor(String name) {
		Map<String, C> map = new LinkedHashMap<>();
		map.put('a', createContributor(Health.up().withDetail('hello', name + '-a').build()));
		map.put('b', createContributor(Health.up().withDetail('hello', name + '-b').build()));
		map.put('c', createContributor(Health.up().withDetail('hello', name + '-c').build()));
		return createCompositeContributor(map);
	}
	@Test
	void getHealthWhenGroupHasAdditionalPath() {
		this.registry.registerContributor('test', createContributor(this.up));
		TestHealthEndpointGroup testGroup = new TestHealthEndpointGroup((name) -> name.startsWith('test'));
		testGroup.setAdditionalPath(AdditionalHealthEndpointPath.from('server:/healthz'));
		HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
				Collections.singletonMap('testGroup', testGroup));
		HealthResult<T> result = create(this.registry, groups).getHealth(ApiVersion.V3, WebServerNamespace.SERVER,
				SecurityContext.NONE, false, 'healthz');
		CompositeHealth health = (CompositeHealth) getHealth(result);
		assertThat(health.getComponents()).containsKey('test');
	}
	@Test
	void getHealthWhenGroupHasAdditionalPathAndShowComponentsFalse() {
		this.registry.registerContributor('test', createContributor(this.up));
		TestHealthEndpointGroup testGroup = new TestHealthEndpointGroup((name) -> name.startsWith('test'));
		testGroup.setAdditionalPath(AdditionalHealthEndpointPath.from('server:/healthz'));
		testGroup.setShowComponents(false);
		HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
				Collections.singletonMap('testGroup', testGroup));
		HealthResult<T> result = create(this.registry, groups).getHealth(ApiVersion.V3, WebServerNamespace.SERVER,
				SecurityContext.NONE, false, 'healthz');
		CompositeHealth health = (CompositeHealth) getHealth(result);
		assertThat(health.getStatus().getCode()).isEqualTo('UP');
		assertThat(health.getComponents()).isNull();
	}
	@Test
	void getComponentHealthWhenGroupHasAdditionalPathAndShowComponentsFalse() {
		this.registry.registerContributor('test', createContributor(this.up));
		TestHealthEndpointGroup testGroup = new TestHealthEndpointGroup((name) -> name.startsWith('test'));
		testGroup.setAdditionalPath(AdditionalHealthEndpointPath.from('server:/healthz'));
		testGroup.setShowComponents(false);
		HealthEndpointGroups groups = HealthEndpointGroups.of(this.primaryGroup,
				Collections.singletonMap('testGroup', testGroup));
		HealthResult<T> result = create(this.registry, groups).getHealth(ApiVersion.V3, WebServerNamespace.SERVER,
				SecurityContext.NONE, false, 'healthz', 'test');
		assertThat(result).isNull();
	}
	protected final S create(R registry, HealthEndpointGroups groups) {
		return create(registry, groups, null);
	}
	protected abstract S create(R registry, HealthEndpointGroups groups, Duration slowIndicatorLoggingThreshold);
	protected abstract R createRegistry();
	protected abstract C createContributor(Health health);
	protected abstract C createCompositeContributor(Map<String, C> contributors);
	protected abstract HealthComponent getHealth(HealthResult<T> result);
}
/*
package org.springframework.boot.actuate.health;
/**
class StatusTests {
	@Test
	void createWhenCodeIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Status(null, ''))
			.withMessage('Code must not be null');
	}
	@Test
	void createWhenDescriptionIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Status('code', null))
			.withMessage('Description must not be null');
	}
	@Test
	void getCodeReturnsCode() {
		Status status = new Status('spring', 'boot');
		assertThat(status.getCode()).isEqualTo('spring');
	}
	@Test
	void getDescriptionReturnsDescription() {
		Status status = new Status('spring', 'boot');
		assertThat(status.getDescription()).isEqualTo('boot');
	}
	@Test
	void equalsAndHashCode() {
		Status one = new Status('spring', 'boot');
		Status two = new Status('spring', 'framework');
		Status three = new Status('spock', 'framework');
		assertThat(one).isEqualTo(one).isEqualTo(two).isNotEqualTo(three);
		assertThat(one).hasSameHashCodeAs(two);
	}
	@Test
	void toStringReturnsCode() {
		assertThat(Status.OUT_OF_SERVICE.getCode()).isEqualTo('OUT_OF_SERVICE');
	}
	@Test
	void serializeWithJacksonReturnsValidJson() throws Exception {
		Status status = new Status('spring', 'boot');
		ObjectMapper mapper = new ObjectMapper();
		String json = mapper.writeValueAsString(status);
		assertThat(json).isEqualTo('{\'description\':\'boot\',\'status\':\'spring\'}');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class AdditionalHealthEndpointPathTests {
	@Test
	void fromValidPathShouldCreatePath() {
		AdditionalHealthEndpointPath path = AdditionalHealthEndpointPath.from('server:/my-path');
		assertThat(path.getValue()).isEqualTo('/my-path');
		assertThat(path.getNamespace()).isEqualTo(WebServerNamespace.SERVER);
	}
	@Test
	void fromValidPathWithoutSlashShouldCreatePath() {
		AdditionalHealthEndpointPath path = AdditionalHealthEndpointPath.from('server:my-path');
		assertThat(path.getValue()).isEqualTo('my-path');
		assertThat(path.getNamespace()).isEqualTo(WebServerNamespace.SERVER);
	}
	@Test
	void fromNullPathShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> AdditionalHealthEndpointPath.from(null));
	}
	@Test
	void fromEmptyPathShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> AdditionalHealthEndpointPath.from(''));
	}
	@Test
	void fromPathWithNoNamespaceShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> AdditionalHealthEndpointPath.from('my-path'));
	}
	@Test
	void fromPathWithEmptyNamespaceShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> AdditionalHealthEndpointPath.from(':my-path'));
	}
	@Test
	void fromPathWithMultipleSegmentsShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> AdditionalHealthEndpointPath.from('server:/my-path/my-sub-path'));
	}
	@Test
	void fromPathWithMultipleSegmentsNotStartingWithSlashShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> AdditionalHealthEndpointPath.from('server:my-path/my-sub-path'));
	}
	@Test
	void pathsWithTheSameNamespaceAndValueAreEqual() {
		assertThat(AdditionalHealthEndpointPath.from('server:/my-path'))
			.isEqualTo(AdditionalHealthEndpointPath.from('server:/my-path'));
	}
	@Test
	void pathsWithTheDifferentNamespaceAndSameValueAreNotEqual() {
		assertThat(AdditionalHealthEndpointPath.from('server:/my-path'))
			.isNotEqualTo((AdditionalHealthEndpointPath.from('management:/my-path')));
	}
	@Test
	void pathsWithTheSameNamespaceAndValuesWithNoSlashAreEqual() {
		assertThat(AdditionalHealthEndpointPath.from('server:/my-path'))
			.isEqualTo((AdditionalHealthEndpointPath.from('server:my-path')));
	}
	@Test
	void ofWithNullNamespaceShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> AdditionalHealthEndpointPath.of(null, 'my-sub-path'));
	}
	@Test
	void ofWithNullPathShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> AdditionalHealthEndpointPath.of(WebServerNamespace.SERVER, null));
	}
	@Test
	void ofWithMultipleSegmentValueShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> AdditionalHealthEndpointPath.of(WebServerNamespace.SERVER, '/my-path/my-subpath'));
	}
	@Test
	void ofShouldCreatePath() {
		AdditionalHealthEndpointPath additionalPath = AdditionalHealthEndpointPath.of(WebServerNamespace.SERVER,
				'my-path');
		assertThat(additionalPath.getValue()).isEqualTo('my-path');
		assertThat(additionalPath.getNamespace()).isEqualTo(WebServerNamespace.SERVER);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthTests {
	@Test
	void statusMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Health.Builder(null, null))
			.withMessageContaining('Status must not be null');
	}
	@Test
	void createWithStatus() {
		Health health = Health.status(Status.UP).build();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).isEmpty();
	}
	@Test
	void createWithDetails() {
		Health health = new Health.Builder(Status.UP, Collections.singletonMap('a', 'b')).build();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsOnly(entry('a', 'b'));
	}
	@Test
	void equalsAndHashCode() {
		Health h1 = new Health.Builder(Status.UP, Collections.singletonMap('a', 'b')).build();
		Health h2 = new Health.Builder(Status.UP, Collections.singletonMap('a', 'b')).build();
		Health h3 = new Health.Builder(Status.UP).build();
		assertThat(h1).isEqualTo(h1);
		assertThat(h1).isEqualTo(h2);
		assertThat(h1).isNotEqualTo(h3);
		assertThat(h1).hasSameHashCodeAs(h1);
		assertThat(h1).hasSameHashCodeAs(h2);
		assertThat(h1.hashCode()).isNotEqualTo(h3.hashCode());
	}
	@Test
	void withException() {
		RuntimeException ex = new RuntimeException('bang');
		Health health = new Health.Builder(Status.UP, Collections.singletonMap('a', 'b')).withException(ex).build();
		assertThat(health.getDetails()).containsOnly(entry('a', 'b'),
				entry('error', 'java.lang.RuntimeException: bang'));
	}
	@Test
	void withDetails() {
		Health health = new Health.Builder(Status.UP, Collections.singletonMap('a', 'b')).withDetail('c', 'd').build();
		assertThat(health.getDetails()).containsOnly(entry('a', 'b'), entry('c', 'd'));
	}
	@Test
	void withDetailsMap() {
		Map<String, Object> details = new LinkedHashMap<>();
		details.put('a', 'b');
		details.put('c', 'd');
		Health health = Health.up().withDetails(details).build();
		assertThat(health.getDetails()).containsOnly(entry('a', 'b'), entry('c', 'd'));
	}
	@Test
	void withDetailsMapDuplicateKeys() {
		Map<String, Object> details = new LinkedHashMap<>();
		details.put('c', 'd');
		details.put('a', 'e');
		Health health = Health.up().withDetail('a', 'b').withDetails(details).build();
		assertThat(health.getDetails()).containsOnly(entry('a', 'e'), entry('c', 'd'));
	}
	@Test
	void withDetailsMultipleMaps() {
		Map<String, Object> details1 = new LinkedHashMap<>();
		details1.put('a', 'b');
		details1.put('c', 'd');
		Map<String, Object> details2 = new LinkedHashMap<>();
		details1.put('a', 'e');
		details1.put('1', '2');
		Health health = Health.up().withDetails(details1).withDetails(details2).build();
		assertThat(health.getDetails()).containsOnly(entry('a', 'e'), entry('c', 'd'), entry('1', '2'));
	}
	@Test
	void unknownWithDetails() {
		Health health = new Health.Builder().unknown().withDetail('a', 'b').build();
		assertThat(health.getStatus()).isEqualTo(Status.UNKNOWN);
		assertThat(health.getDetails()).containsOnly(entry('a', 'b'));
	}
	@Test
	void unknown() {
		Health health = new Health.Builder().unknown().build();
		assertThat(health.getStatus()).isEqualTo(Status.UNKNOWN);
		assertThat(health.getDetails()).isEmpty();
	}
	@Test
	void upWithDetails() {
		Health health = new Health.Builder().up().withDetail('a', 'b').build();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsOnly(entry('a', 'b'));
	}
	@Test
	void up() {
		Health health = new Health.Builder().up().build();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).isEmpty();
	}
	@Test
	void downWithException() {
		RuntimeException ex = new RuntimeException('bang');
		Health health = Health.down(ex).build();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsOnly(entry('error', 'java.lang.RuntimeException: bang'));
	}
	@Test
	void down() {
		Health health = Health.down().build();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).isEmpty();
	}
	@Test
	void outOfService() {
		Health health = Health.outOfService().build();
		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
		assertThat(health.getDetails()).isEmpty();
	}
	@Test
	void statusCode() {
		Health health = Health.status('UP').build();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).isEmpty();
	}
	@Test
	void status() {
		Health health = Health.status(Status.UP).build();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).isEmpty();
	}
	@Test
	void serializeWithJacksonReturnsValidJson() throws Exception {
		Health health = Health.down().withDetail('a', 'b').build();
		ObjectMapper mapper = new ObjectMapper();
		String json = mapper.writeValueAsString(health);
		assertThat(json).isEqualTo('{\'status\':\'DOWN\',\'details\':{\'a\':\'b\'}}');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthIndicatorReactiveAdapterTests {
	@Test
	void delegateReturnsHealth() {
		HealthIndicator delegate = mock(HealthIndicator.class);
		HealthIndicatorReactiveAdapter adapter = new HealthIndicatorReactiveAdapter(delegate);
		Health status = Health.up().build();
		given(delegate.health()).willReturn(status);
		StepVerifier.create(adapter.health()).expectNext(status).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void delegateThrowError() {
		HealthIndicator delegate = mock(HealthIndicator.class);
		HealthIndicatorReactiveAdapter adapter = new HealthIndicatorReactiveAdapter(delegate);
		given(delegate.health()).willThrow(new IllegalStateException('Expected'));
		StepVerifier.create(adapter.health()).expectError(IllegalStateException.class).verify(Duration.ofSeconds(10));
	}
	@Test
	void delegateRunsOnTheElasticScheduler() {
		String currentThread = Thread.currentThread().getName();
		HealthIndicator delegate = () -> Health
			.status(Thread.currentThread().getName().equals(currentThread) ? Status.DOWN : Status.UP)
			.build();
		HealthIndicatorReactiveAdapter adapter = new HealthIndicatorReactiveAdapter(delegate);
		StepVerifier.create(adapter.health())
			.expectNext(Health.status(Status.UP).build())
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthContributorNameFactoryTests {
	@Test
	void applyWhenNameDoesNotEndWithSuffixReturnsName() {
		assertThat(HealthContributorNameFactory.INSTANCE.apply('test')).isEqualTo('test');
	}
	@Test
	void applyWhenNameEndsWithSuffixReturnsNewName() {
		assertThat(HealthContributorNameFactory.INSTANCE.apply('testHealthIndicator')).isEqualTo('test');
		assertThat(HealthContributorNameFactory.INSTANCE.apply('testHealthContributor')).isEqualTo('test');
	}
	@Test
	void applyWhenNameEndsWithSuffixInDifferentReturnsNewName() {
		assertThat(HealthContributorNameFactory.INSTANCE.apply('testHEALTHindicator')).isEqualTo('test');
		assertThat(HealthContributorNameFactory.INSTANCE.apply('testHEALTHcontributor')).isEqualTo('test');
	}
	@Test
	void applyWhenNameContainsSuffixReturnsName() {
		assertThat(HealthContributorNameFactory.INSTANCE.apply('testHealthIndicatorTest'))
			.isEqualTo('testHealthIndicatorTest');
		assertThat(HealthContributorNameFactory.INSTANCE.apply('testHealthContributorTest'))
			.isEqualTo('testHealthContributorTest');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class ReactiveHealthEndpointWebExtensionTests extends
		HealthEndpointSupportTests<ReactiveHealthEndpointWebExtension, ReactiveHealthContributorRegistry, ReactiveHealthContributor, Mono<? extends HealthComponent>> {
	@Test
	void healthReturnsSystemHealth() {
		this.registry.registerContributor('test', createContributor(this.up));
		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups)
			.health(ApiVersion.LATEST, null, SecurityContext.NONE)
			.block();
		HealthComponent health = response.getBody();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health).isInstanceOf(SystemHealth.class);
		assertThat(response.getStatus()).isEqualTo(200);
	}
	@Test
	void healthWithNoContributorReturnsUp() {
		assertThat(this.registry).isEmpty();
		WebEndpointResponse<? extends HealthComponent> response = create(this.registry,
				HealthEndpointGroups.of(mock(HealthEndpointGroup.class), Collections.emptyMap()))
			.health(ApiVersion.LATEST, null, SecurityContext.NONE)
			.block();
		assertThat(response.getStatus()).isEqualTo(200);
		HealthComponent health = response.getBody();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health).isInstanceOf(Health.class);
	}
	@Test
	void healthWhenPathDoesNotExistReturnsHttp404() {
		this.registry.registerContributor('test', createContributor(this.up));
		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups)
			.health(ApiVersion.LATEST, null, SecurityContext.NONE, 'missing')
			.block();
		assertThat(response.getBody()).isNull();
		assertThat(response.getStatus()).isEqualTo(404);
	}
	@Test
	void healthWhenPathExistsReturnsHealth() {
		this.registry.registerContributor('test', createContributor(this.up));
		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups)
			.health(ApiVersion.LATEST, null, SecurityContext.NONE, 'test')
			.block();
		assertThat(response.getBody()).isEqualTo(this.up);
		assertThat(response.getStatus()).isEqualTo(200);
	}
	@Override
	protected ReactiveHealthEndpointWebExtension create(ReactiveHealthContributorRegistry registry,
			HealthEndpointGroups groups, Duration slowIndicatorLoggingThreshold) {
		return new ReactiveHealthEndpointWebExtension(registry, groups, slowIndicatorLoggingThreshold);
	}
	@Override
	protected ReactiveHealthContributorRegistry createRegistry() {
		return new DefaultReactiveHealthContributorRegistry();
	}
	@Override
	protected ReactiveHealthContributor createContributor(Health health) {
		return (ReactiveHealthIndicator) () -> Mono.just(health);
	}
	@Override
	protected ReactiveHealthContributor createCompositeContributor(
			Map<String, ReactiveHealthContributor> contributors) {
		return CompositeReactiveHealthContributor.fromMap(contributors);
	}
	@Override
	protected HealthComponent getHealth(HealthResult<Mono<? extends HealthComponent>> result) {
		return result.getHealth().block();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class SystemHealthTests {
	@Test
	void serializeWithJacksonReturnsValidJson() throws Exception {
		Map<String, HealthComponent> components = new LinkedHashMap<>();
		components.put('db1', Health.up().build());
		components.put('db2', Health.down().withDetail('a', 'b').build());
		Set<String> groups = new LinkedHashSet<>(Arrays.asList('liveness', 'readiness'));
		CompositeHealth health = new SystemHealth(ApiVersion.V3, Status.UP, components, groups);
		ObjectMapper mapper = new ObjectMapper();
		String json = mapper.writeValueAsString(health);
		assertThat(json).isEqualTo('{\'status\':\'UP\',\'components\':{\'db1\':{\'status\':\'UP\'},'
				+ '\'db2\':{\'status\':\'DOWN\',\'details\':{\'a\':\'b\'}}},'
				+ '\'groups\':[\'liveness\',\'readiness\']}');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthIndicatorTests {
	private final HealthIndicator indicator = () -> Health.up().withDetail('spring', 'boot').build();
	@Test
	void getHealthWhenIncludeDetailsIsTrueReturnsHealthWithDetails() {
		Health health = this.indicator.getHealth(true);
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('spring', 'boot');
	}
	@Test
	void getHealthWhenIncludeDetailsIsFalseReturnsHealthWithoutDetails() {
		Health health = this.indicator.getHealth(false);
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).isEmpty();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthEndpointWebExtensionTests extends
		HealthEndpointSupportTests<HealthEndpointWebExtension, HealthContributorRegistry, HealthContributor, HealthComponent> {
	@Test
	void healthReturnsSystemHealth() {
		this.registry.registerContributor('test', createContributor(this.up));
		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(ApiVersion.LATEST,
				WebServerNamespace.SERVER, SecurityContext.NONE);
		HealthComponent health = response.getBody();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health).isInstanceOf(SystemHealth.class);
		assertThat(response.getStatus()).isEqualTo(200);
	}
	@Test
	void healthWithNoContributorReturnsUp() {
		assertThat(this.registry).isEmpty();
		WebEndpointResponse<HealthComponent> response = create(this.registry,
				HealthEndpointGroups.of(mock(HealthEndpointGroup.class), Collections.emptyMap()))
			.health(ApiVersion.LATEST, WebServerNamespace.SERVER, SecurityContext.NONE);
		assertThat(response.getStatus()).isEqualTo(200);
		HealthComponent health = response.getBody();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health).isInstanceOf(Health.class);
	}
	@Test
	void healthWhenPathDoesNotExistReturnsHttp404() {
		this.registry.registerContributor('test', createContributor(this.up));
		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(ApiVersion.LATEST,
				WebServerNamespace.SERVER, SecurityContext.NONE, 'missing');
		assertThat(response.getBody()).isNull();
		assertThat(response.getStatus()).isEqualTo(404);
	}
	@Test
	void healthWhenPathExistsReturnsHealth() {
		this.registry.registerContributor('test', createContributor(this.up));
		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(ApiVersion.LATEST,
				WebServerNamespace.SERVER, SecurityContext.NONE, 'test');
		assertThat(response.getBody()).isEqualTo(this.up);
		assertThat(response.getStatus()).isEqualTo(200);
	}
	@Override
	protected HealthEndpointWebExtension create(HealthContributorRegistry registry, HealthEndpointGroups groups,
			Duration slowIndicatorLoggingThreshold) {
		return new HealthEndpointWebExtension(registry, groups, slowIndicatorLoggingThreshold);
	}
	@Override
	protected HealthContributorRegistry createRegistry() {
		return new DefaultHealthContributorRegistry();
	}
	@Override
	protected HealthContributor createContributor(Health health) {
		return (HealthIndicator) () -> health;
	}
	@Override
	protected HealthContributor createCompositeContributor(Map<String, HealthContributor> contributors) {
		return CompositeHealthContributor.fromMap(contributors);
	}
	@Override
	protected HealthComponent getHealth(HealthResult<HealthComponent> result) {
		return result.getHealth();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class CompositeHealthContributorTests {
	@Test
	void fromMapReturnsCompositeHealthContributorMapAdapter() {
		Map<String, HealthContributor> map = new LinkedHashMap<>();
		HealthIndicator indicator = () -> Health.down().build();
		map.put('test', indicator);
		CompositeHealthContributor composite = CompositeHealthContributor.fromMap(map);
		assertThat(composite).isInstanceOf(CompositeHealthContributorMapAdapter.class);
		NamedContributor<HealthContributor> namedContributor = composite.iterator().next();
		assertThat(namedContributor.getName()).isEqualTo('test');
		assertThat(namedContributor.getContributor()).isSameAs(indicator);
	}
	@Test
	void fromMapWithAdapterReturnsCompositeHealthContributorMapAdapter() {
		Map<String, HealthContributor> map = new LinkedHashMap<>();
		HealthIndicator downIndicator = () -> Health.down().build();
		HealthIndicator upIndicator = () -> Health.up().build();
		map.put('test', downIndicator);
		CompositeHealthContributor composite = CompositeHealthContributor.fromMap(map, (value) -> upIndicator);
		assertThat(composite).isInstanceOf(CompositeHealthContributorMapAdapter.class);
		NamedContributor<HealthContributor> namedContributor = composite.iterator().next();
		assertThat(namedContributor.getName()).isEqualTo('test');
		assertThat(namedContributor.getContributor()).isSameAs(upIndicator);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@ExtendWith(OutputCaptureExtension.class)
class AbstractReactiveHealthIndicatorTests {
	@Test
	void healthCheckWhenUpDoesNotLogHealthCheckFailedMessage(CapturedOutput output) {
		Health health = new AbstractReactiveHealthIndicator('Test message') {
			@Override
			protected Mono<Health> doHealthCheck(Builder builder) {
				return Mono.just(builder.up().build());
			}
		}.health().block();
		assertThat(health).isNotNull();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(output).doesNotContain('Test message');
	}
	@Test
	void healthCheckWhenDownWithExceptionThrownLogsHealthCheckFailedMessage(CapturedOutput output) {
		Health health = new AbstractReactiveHealthIndicator('Test message') {
			@Override
			protected Mono<Health> doHealthCheck(Builder builder) {
				throw new IllegalStateException('Test exception');
			}
		}.health().block();
		assertThat(health).isNotNull();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Test message').contains('Test exception');
	}
	@Test
	void healthCheckWhenDownWithExceptionConfiguredLogsHealthCheckFailedMessage(CapturedOutput output) {
		Health health = new AbstractReactiveHealthIndicator('Test message') {
			@Override
			protected Mono<Health> doHealthCheck(Builder builder) {
				return Mono.just(builder.down().withException(new IllegalStateException('Test exception')).build());
			}
		}.health().block();
		assertThat(health).isNotNull();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Test message').contains('Test exception');
	}
	@Test
	void healthCheckWhenDownWithExceptionConfiguredDoesNotLogHealthCheckFailedMessageTwice(CapturedOutput output) {
		Health health = new AbstractReactiveHealthIndicator('Test message') {
			@Override
			protected Mono<Health> doHealthCheck(Builder builder) {
				IllegalStateException ex = new IllegalStateException('Test exception');
				builder.down().withException(ex);
				throw ex;
			}
		}.health().block();
		assertThat(health).isNotNull();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Test message').containsOnlyOnce('Test exception');
	}
	@Test
	void healthCheckWhenDownWithExceptionAndNoFailureMessageLogsDefaultMessage(CapturedOutput output) {
		Health health = new AbstractReactiveHealthIndicator() {
			@Override
			protected Mono<Health> doHealthCheck(Builder builder) {
				return Mono.just(builder.down().withException(new IllegalStateException('Test exception')).build());
			}
		}.health().block();
		assertThat(health).isNotNull();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Health check failed').contains('Test exception');
	}
	@Test
	void healthCheckWhenDownWithErrorLogsDefaultMessage(CapturedOutput output) {
		Health health = new AbstractReactiveHealthIndicator('Test Message') {
			@Override
			protected Mono<Health> doHealthCheck(Builder builder) {
				return Mono.just(builder.down().withException(new Error('Test error')).build());
			}
		}.health().block();
		assertThat(health).isNotNull();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(output).contains('Health check failed').contains('Test error');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class PingHealthIndicatorTests {
	@Test
	void indicatesUp() {
		PingHealthIndicator healthIndicator = new PingHealthIndicator();
		assertThat(healthIndicator.health().getStatus()).isEqualTo(Status.UP);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class NamedContributorsMapAdapterTests {
	@Test
	void createWhenMapIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestNamedContributorsMapAdapter<>(null, Function.identity()))
			.withMessage('Map must not be null');
	}
	@Test
	void createWhenValueAdapterIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestNamedContributorsMapAdapter<>(Collections.emptyMap(), null))
			.withMessage('ValueAdapter must not be null');
	}
	@Test
	void createWhenMapContainsNullValueThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestNamedContributorsMapAdapter<>(Collections.singletonMap('test', null),
					Function.identity()))
			.withMessage('Map must not contain null values');
	}
	@Test
	void createWhenMapContainsNullKeyThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestNamedContributorsMapAdapter<>(Collections.singletonMap(null, 'test'),
					Function.identity()))
			.withMessage('Map must not contain null keys');
	}
	@Test
	void createWhenMapContainsKeyWithSlashThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestNamedContributorsMapAdapter<>(Collections.singletonMap('test/key', 'test'),
					Function.identity()))
			.withMessage('Map keys must not contain a "/"');
	}
	@Test
	void iterateReturnsAdaptedEntries() {
		TestNamedContributorsMapAdapter<String> adapter = createAdapter();
		Iterator<NamedContributor<String>> iterator = adapter.iterator();
		NamedContributor<String> one = iterator.next();
		NamedContributor<String> two = iterator.next();
		assertThat(iterator.hasNext()).isFalse();
		assertThat(one.getName()).isEqualTo('one');
		assertThat(one.getContributor()).isEqualTo('eno');
		assertThat(two.getName()).isEqualTo('two');
		assertThat(two.getContributor()).isEqualTo('owt');
	}
	@Test
	void getContributorReturnsAdaptedEntry() {
		TestNamedContributorsMapAdapter<String> adapter = createAdapter();
		assertThat(adapter.getContributor('one')).isEqualTo('eno');
		assertThat(adapter.getContributor('two')).isEqualTo('owt');
	}
	@Test
	void getContributorCallsAdaptersOnlyOnce() {
		Map<String, String> map = new LinkedHashMap<>();
		map.put('one', 'one');
		map.put('two', 'two');
		int callCount = map.size();
		AtomicInteger counter = new AtomicInteger(0);
		TestNamedContributorsMapAdapter<String> adapter = new TestNamedContributorsMapAdapter<>(map,
				(name) -> count(name, counter));
		assertThat(adapter.getContributor('one')).isEqualTo('eno');
		assertThat(counter.get()).isEqualTo(callCount);
		assertThat(adapter.getContributor('two')).isEqualTo('owt');
		assertThat(counter.get()).isEqualTo(callCount);
	}
	@Test
	void getContributorWhenNotInMapReturnsNull() {
		TestNamedContributorsMapAdapter<String> adapter = createAdapter();
		assertThat(adapter.getContributor('missing')).isNull();
	}
	private TestNamedContributorsMapAdapter<String> createAdapter() {
		Map<String, String> map = new LinkedHashMap<>();
		map.put('one', 'one');
		map.put('two', 'two');
		TestNamedContributorsMapAdapter<String> adapter = new TestNamedContributorsMapAdapter<>(map, this::reverse);
		return adapter;
	}
	private String count(CharSequence charSequence, AtomicInteger counter) {
		counter.incrementAndGet();
		return reverse(charSequence);
	}
	private String reverse(CharSequence charSequence) {
		return new StringBuilder(charSequence).reverse().toString();
	}
	static class TestNamedContributorsMapAdapter<V> extends NamedContributorsMapAdapter<V, String> {
		TestNamedContributorsMapAdapter(Map<String, V> map, Function<V, ? extends String> valueAdapter) {
			super(map, valueAdapter);
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@ExtendWith(OutputCaptureExtension.class)
class HealthEndpointTests extends
		HealthEndpointSupportTests<HealthEndpoint, HealthContributorRegistry, HealthContributor, HealthComponent> {
	@Test
	void healthReturnsSystemHealth() {
		this.registry.registerContributor('test', createContributor(this.up));
		HealthComponent health = create(this.registry, this.groups).health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health).isInstanceOf(SystemHealth.class);
	}
	@Test
	void healthWithNoContributorReturnsUp() {
		assertThat(this.registry).isEmpty();
		HealthComponent health = create(this.registry,
				HealthEndpointGroups.of(mock(HealthEndpointGroup.class), Collections.emptyMap()))
			.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health).isInstanceOf(Health.class);
	}
	@Test
	void healthWhenPathDoesNotExistReturnsNull() {
		this.registry.registerContributor('test', createContributor(this.up));
		HealthComponent health = create(this.registry, this.groups).healthForPath('missing');
		assertThat(health).isNull();
	}
	@Test
	void healthWhenPathExistsReturnsHealth() {
		this.registry.registerContributor('test', createContributor(this.up));
		HealthComponent health = create(this.registry, this.groups).healthForPath('test');
		assertThat(health).isEqualTo(this.up);
	}
	@Test
	void healthWhenIndicatorIsSlow(CapturedOutput output) {
		HealthIndicator indicator = () -> {
			try {
				Thread.sleep(100);
			}
			catch (InterruptedException ex) {
				// Ignore
			}
			return this.up;
		};
		this.registry.registerContributor('test', indicator);
		create(this.registry, this.groups, Duration.ofMillis(10)).health();
		assertThat(output).contains('Health contributor');
		assertThat(output).contains('to respond');
	}
	@Override
	protected HealthEndpoint create(HealthContributorRegistry registry, HealthEndpointGroups groups,
			Duration slowIndicatorLoggingThreshold) {
		return new HealthEndpoint(registry, groups, slowIndicatorLoggingThreshold);
	}
	@Override
	protected HealthContributorRegistry createRegistry() {
		return new DefaultHealthContributorRegistry();
	}
	@Override
	protected HealthContributor createContributor(Health health) {
		return (HealthIndicator) () -> health;
	}
	@Override
	protected HealthContributor createCompositeContributor(Map<String, HealthContributor> contributors) {
		return CompositeHealthContributor.fromMap(contributors);
	}
	@Override
	protected HealthComponent getHealth(HealthResult<HealthComponent> result) {
		return result.getHealth();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class TestHealthEndpointGroup implements HealthEndpointGroup {
	private final StatusAggregator statusAggregator = new SimpleStatusAggregator();
	private final HttpCodeStatusMapper httpCodeStatusMapper = new SimpleHttpCodeStatusMapper();
	private final Predicate<String> memberPredicate;
	private Boolean showComponents;
	private boolean showDetails = true;
	private AdditionalHealthEndpointPath additionalPath;
	TestHealthEndpointGroup() {
		this((name) -> true);
	}
	TestHealthEndpointGroup(Predicate<String> memberPredicate) {
		this.memberPredicate = memberPredicate;
	}
	@Override
	public boolean isMember(String name) {
		return this.memberPredicate.test(name);
	}
	@Override
	public boolean showComponents(SecurityContext securityContext) {
		return (this.showComponents != null) ? this.showComponents : this.showDetails;
	}
	void setShowComponents(Boolean showComponents) {
		this.showComponents = showComponents;
	}
	@Override
	public boolean showDetails(SecurityContext securityContext) {
		return this.showDetails;
	}
	void setShowDetails(boolean includeDetails) {
		this.showDetails = includeDetails;
	}
	@Override
	public StatusAggregator getStatusAggregator() {
		return this.statusAggregator;
	}
	@Override
	public HttpCodeStatusMapper getHttpCodeStatusMapper() {
		return this.httpCodeStatusMapper;
	}
	@Override
	public AdditionalHealthEndpointPath getAdditionalPath() {
		return this.additionalPath;
	}
	void setAdditionalPath(AdditionalHealthEndpointPath additionalPath) {
		this.additionalPath = additionalPath;
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class SimpleStatusAggregatorTests {
	@Test
	void getAggregateStatusWhenUsingDefaultInstance() {
		StatusAggregator aggregator = StatusAggregator.getDefault();
		Status status = aggregator.getAggregateStatus(Status.DOWN, Status.UP, Status.UNKNOWN, Status.OUT_OF_SERVICE);
		assertThat(status).isEqualTo(Status.DOWN);
	}
	@Test
	void getAggregateStatusWhenUsingNewDefaultOrder() {
		SimpleStatusAggregator aggregator = new SimpleStatusAggregator();
		Status status = aggregator.getAggregateStatus(Status.DOWN, Status.UP, Status.UNKNOWN, Status.OUT_OF_SERVICE);
		assertThat(status).isEqualTo(Status.DOWN);
	}
	@Test
	void getAggregateStatusWhenUsingCustomOrder() {
		SimpleStatusAggregator aggregator = new SimpleStatusAggregator(Status.UNKNOWN, Status.UP, Status.OUT_OF_SERVICE,
				Status.DOWN);
		Status status = aggregator.getAggregateStatus(Status.DOWN, Status.UP, Status.UNKNOWN, Status.OUT_OF_SERVICE);
		assertThat(status).isEqualTo(Status.UNKNOWN);
	}
	@Test
	void getAggregateStatusWhenHasCustomStatusAndUsingDefaultOrder() {
		SimpleStatusAggregator aggregator = new SimpleStatusAggregator();
		Status status = aggregator.getAggregateStatus(Status.DOWN, Status.UP, Status.UNKNOWN, Status.OUT_OF_SERVICE,
				new Status('CUSTOM'));
		assertThat(status).isEqualTo(Status.DOWN);
	}
	@Test
	void getAggregateStatusWhenHasCustomStatusAndUsingCustomOrder() {
		SimpleStatusAggregator aggregator = new SimpleStatusAggregator('DOWN', 'OUT_OF_SERVICE', 'UP', 'UNKNOWN',
				'CUSTOM');
		Status status = aggregator.getAggregateStatus(Status.DOWN, Status.UP, Status.UNKNOWN, Status.OUT_OF_SERVICE,
				new Status('CUSTOM'));
		assertThat(status).isEqualTo(Status.DOWN);
	}
	@Test
	void createWithNonUniformCodes() {
		SimpleStatusAggregator aggregator = new SimpleStatusAggregator('out-of-service', 'up');
		Status status = aggregator.getAggregateStatus(Status.UP, Status.OUT_OF_SERVICE);
		assertThat(status).isEqualTo(Status.OUT_OF_SERVICE);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class CompositeReactiveHealthContributorTests {
	@Test
	void fromMapReturnsCompositeReactiveHealthContributorMapAdapter() {
		Map<String, ReactiveHealthContributor> map = new LinkedHashMap<>();
		ReactiveHealthIndicator indicator = () -> Mono.just(Health.down().build());
		map.put('test', indicator);
		CompositeReactiveHealthContributor composite = CompositeReactiveHealthContributor.fromMap(map);
		assertThat(composite).isInstanceOf(CompositeReactiveHealthContributorMapAdapter.class);
		NamedContributor<ReactiveHealthContributor> namedContributor = composite.iterator().next();
		assertThat(namedContributor.getName()).isEqualTo('test');
		assertThat(namedContributor.getContributor()).isSameAs(indicator);
	}
	@Test
	void fromMapWithAdapterReturnsCompositeReactiveHealthContributorMapAdapter() {
		Map<String, ReactiveHealthContributor> map = new LinkedHashMap<>();
		ReactiveHealthIndicator downIndicator = () -> Mono.just(Health.down().build());
		ReactiveHealthIndicator upIndicator = () -> Mono.just(Health.up().build());
		map.put('test', downIndicator);
		CompositeReactiveHealthContributor composite = CompositeReactiveHealthContributor.fromMap(map,
				(value) -> upIndicator);
		assertThat(composite).isInstanceOf(CompositeReactiveHealthContributorMapAdapter.class);
		NamedContributor<ReactiveHealthContributor> namedContributor = composite.iterator().next();
		assertThat(namedContributor.getName()).isEqualTo('test');
		assertThat(namedContributor.getContributor()).isSameAs(upIndicator);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class NamedContributorTests {
	@Test
	void ofNameAndContributorCreatesContributor() {
		NamedContributor<String> contributor = NamedContributor.of('one', 'two');
		assertThat(contributor.getName()).isEqualTo('one');
		assertThat(contributor.getContributor()).isEqualTo('two');
	}
	@Test
	void ofWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> NamedContributor.of(null, 'two'))
			.withMessage('Name must not be null');
	}
	@Test
	void ofWhenContributorIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> NamedContributor.of('one', null))
			.withMessage('Contributor must not be null');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
abstract class DefaultContributorRegistryTests {
	private final HealthIndicator one = mock(HealthIndicator.class);
	private final HealthIndicator two = mock(HealthIndicator.class);
	private ContributorRegistry<HealthIndicator> registry;
	@BeforeEach
	void setUp() {
		given(this.one.health()).willReturn(new Health.Builder().unknown().withDetail('1', '1').build());
		given(this.two.health()).willReturn(new Health.Builder().unknown().withDetail('2', '2').build());
		this.registry = new DefaultContributorRegistry<>();
	}
	@Test
	void createWhenContributorsIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DefaultContributorRegistry<>(null))
			.withMessage('Contributors must not be null');
	}
	@Test
	void createWhenNameFactoryIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DefaultContributorRegistry<>(Collections.emptyMap(), null))
			.withMessage('NameFactory must not be null');
	}
	@Test
	void createUsesHealthIndicatorNameFactoryByDefault() {
		this.registry = new DefaultContributorRegistry<>(Collections.singletonMap('oneHealthIndicator', this.one));
		assertThat(this.registry.getContributor('oneHealthIndicator')).isNull();
		assertThat(this.registry.getContributor('one')).isNotNull();
	}
	@Test
	void createWithCustomNameFactoryAppliesFunctionToName() {
		this.registry = new DefaultContributorRegistry<>(Collections.singletonMap('one', this.one), this::reverse);
		assertThat(this.registry.getContributor('one')).isNull();
		assertThat(this.registry.getContributor('eno')).isNotNull();
	}
	@Test
	void registerContributorWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.registry.registerContributor(null, this.one))
			.withMessage('Name must not be null');
	}
	@Test
	void registerContributorWhenContributorIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.registry.registerContributor('one', null))
			.withMessage('Contributor must not be null');
	}
	@Test
	void registerContributorRegistersContributors() {
		this.registry.registerContributor('one', this.one);
		this.registry.registerContributor('two', this.two);
		assertThat(this.registry).hasSize(2);
		assertThat(this.registry.getContributor('one')).isSameAs(this.one);
		assertThat(this.registry.getContributor('two')).isSameAs(this.two);
	}
	@Test
	void registerContributorWhenNameAlreadyUsedThrowsException() {
		this.registry.registerContributor('one', this.one);
		assertThatIllegalStateException().isThrownBy(() -> this.registry.registerContributor('one', this.two))
			.withMessageContaining('A contributor named \'one\' has already been registered');
	}
	@Test
	void registerContributorUsesNameFactory() {
		this.registry.registerContributor('oneHealthIndicator', this.one);
		assertThat(this.registry.getContributor('oneHealthIndicator')).isNull();
		assertThat(this.registry.getContributor('one')).isNotNull();
	}
	@Test
	void unregisterContributorUnregistersContributor() {
		this.registry.registerContributor('one', this.one);
		this.registry.registerContributor('two', this.two);
		assertThat(this.registry).hasSize(2);
		HealthIndicator two = this.registry.unregisterContributor('two');
		assertThat(two).isSameAs(this.two);
		assertThat(this.registry).hasSize(1);
	}
	@Test
	void unregisterContributorWhenUnknownReturnsNull() {
		this.registry.registerContributor('one', this.one);
		assertThat(this.registry).hasSize(1);
		HealthIndicator two = this.registry.unregisterContributor('two');
		assertThat(two).isNull();
		assertThat(this.registry).hasSize(1);
	}
	@Test
	void unregisterContributorUsesNameFactory() {
		this.registry.registerContributor('oneHealthIndicator', this.one);
		assertThat(this.registry.getContributor('oneHealthIndicator')).isNull();
		assertThat(this.registry.getContributor('one')).isNotNull();
	}
	@Test
	void getContributorReturnsContributor() {
		this.registry.registerContributor('one', this.one);
		assertThat(this.registry.getContributor('one')).isEqualTo(this.one);
	}
	@Test
	void iteratorIteratesContributors() {
		this.registry.registerContributor('one', this.one);
		this.registry.registerContributor('two', this.two);
		Iterator<NamedContributor<HealthIndicator>> iterator = this.registry.iterator();
		NamedContributor<HealthIndicator> first = iterator.next();
		NamedContributor<HealthIndicator> second = iterator.next();
		assertThat(iterator.hasNext()).isFalse();
		assertThat(first.getName()).isEqualTo('one');
		assertThat(first.getContributor()).isEqualTo(this.one);
		assertThat(second.getName()).isEqualTo('two');
		assertThat(second.getContributor()).isEqualTo(this.two);
	}
	private String reverse(String name) {
		return new StringBuilder(name).reverse().toString();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthEndpointWebIntegrationTests {
	private static final String V2_JSON = ApiVersion.V2.getProducedMimeType().toString();
	private static final String V3_JSON = ApiVersion.V3.getProducedMimeType().toString();
	@WebEndpointTest
	void whenHealthIsUp200ResponseIsReturned(WebTestClient client) {
		client.get()
			.uri('/actuator/health')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('status')
			.isEqualTo('UP')
			.jsonPath('components.alpha.status')
			.isEqualTo('UP')
			.jsonPath('components.bravo.status')
			.isEqualTo('UP');
	}
	@WebEndpointTest
	void whenHealthIsUpAndAcceptsV3Request200ResponseIsReturned(WebTestClient client) {
		client.get()
			.uri('/actuator/health')
			.headers((headers) -> headers.set(HttpHeaders.ACCEPT, V3_JSON))
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('status')
			.isEqualTo('UP')
			.jsonPath('components.alpha.status')
			.isEqualTo('UP')
			.jsonPath('components.bravo.status')
			.isEqualTo('UP');
	}
	@WebEndpointTest
	void whenHealthIsUpAndAcceptsAllRequest200ResponseIsReturned(WebTestClient client) {
		client.get()
			.uri('/actuator/health')
			.headers((headers) -> headers.set(HttpHeaders.ACCEPT, '*/*'))
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('status')
			.isEqualTo('UP')
			.jsonPath('components.alpha.status')
			.isEqualTo('UP')
			.jsonPath('components.bravo.status')
			.isEqualTo('UP');
	}
	@WebEndpointTest
	void whenHealthIsUpAndV2Request200ResponseIsReturnedInV2Format(WebTestClient client) {
		client.get()
			.uri('/actuator/health')
			.headers((headers) -> headers.set(HttpHeaders.ACCEPT, V2_JSON))
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('status')
			.isEqualTo('UP')
			.jsonPath('details.alpha.status')
			.isEqualTo('UP')
			.jsonPath('details.bravo.status')
			.isEqualTo('UP');
	}
	@WebEndpointTest
	void whenHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) {
		HealthIndicator healthIndicator = () -> Health.down().build();
		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build());
		withHealthContributor(context, 'charlie', healthIndicator, reactiveHealthIndicator,
				() -> client.get()
					.uri('/actuator/health')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('DOWN')
					.jsonPath('components.alpha.status')
					.isEqualTo('UP')
					.jsonPath('components.bravo.status')
					.isEqualTo('UP')
					.jsonPath('components.charlie.status')
					.isEqualTo('DOWN'));
	}
	@WebEndpointTest
	void whenComponentHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) {
		HealthIndicator healthIndicator = () -> Health.down().build();
		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build());
		withHealthContributor(context, 'charlie', healthIndicator, reactiveHealthIndicator,
				() -> client.get()
					.uri('/actuator/health/charlie')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('DOWN'));
	}
	@WebEndpointTest
	void whenComponentInstanceHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) {
		HealthIndicator healthIndicator = () -> Health.down().build();
		CompositeHealthContributor composite = CompositeHealthContributor
			.fromMap(Collections.singletonMap('one', healthIndicator));
		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build());
		CompositeReactiveHealthContributor reactiveComposite = CompositeReactiveHealthContributor
			.fromMap(Collections.singletonMap('one', reactiveHealthIndicator));
		withHealthContributor(context, 'charlie', composite, reactiveComposite,
				() -> client.get()
					.uri('/actuator/health/charlie/one')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('DOWN'));
	}
	private void withHealthContributor(ApplicationContext context, String name, HealthContributor healthContributor,
			ReactiveHealthContributor reactiveHealthContributor, ThrowingCallable callable) {
		HealthContributorRegistry healthContributorRegistry = getContributorRegistry(context,
				HealthContributorRegistry.class);
		healthContributorRegistry.registerContributor(name, healthContributor);
		ReactiveHealthContributorRegistry reactiveHealthContributorRegistry = getContributorRegistry(context,
				ReactiveHealthContributorRegistry.class);
		if (reactiveHealthContributorRegistry != null) {
			reactiveHealthContributorRegistry.registerContributor(name, reactiveHealthContributor);
		}
		try {
			callable.call();
		}
		catch (Throwable ex) {
			ReflectionUtils.rethrowRuntimeException(ex);
		}
		finally {
			healthContributorRegistry.unregisterContributor(name);
			if (reactiveHealthContributorRegistry != null) {
				reactiveHealthContributorRegistry.unregisterContributor(name);
			}
		}
	}
	private <R extends ContributorRegistry<?>> R getContributorRegistry(ApplicationContext context,
			Class<R> registryType) {
		return context.getBeanProvider(registryType).getIfAvailable();
	}
	@WebEndpointTest
	void whenHealthIndicatorIsRemovedResponseIsAltered(WebTestClient client, ApplicationContext context) {
		String name = 'bravo';
		HealthContributorRegistry healthContributorRegistry = getContributorRegistry(context,
				HealthContributorRegistry.class);
		HealthContributor bravo = healthContributorRegistry.unregisterContributor(name);
		ReactiveHealthContributorRegistry reactiveHealthContributorRegistry = getContributorRegistry(context,
				ReactiveHealthContributorRegistry.class);
		ReactiveHealthContributor reactiveBravo = (reactiveHealthContributorRegistry != null)
				? reactiveHealthContributorRegistry.unregisterContributor(name) : null;
		try {
			client.get()
				.uri('/actuator/health')
				.accept(MediaType.APPLICATION_JSON)
				.exchange()
				.expectStatus()
				.isOk()
				.expectBody()
				.jsonPath('status')
				.isEqualTo('UP')
				.jsonPath('components.alpha.status')
				.isEqualTo('UP')
				.jsonPath('components.bravo.status')
				.doesNotExist();
		}
		finally {
			healthContributorRegistry.registerContributor(name, bravo);
			if (reactiveHealthContributorRegistry != null && reactiveBravo != null) {
				reactiveHealthContributorRegistry.registerContributor(name, reactiveBravo);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		HealthContributorRegistry healthContributorRegistry(Map<String, HealthContributor> healthContributorBeans) {
			return new DefaultHealthContributorRegistry(healthContributorBeans);
		}
		@Bean
		@ConditionalOnWebApplication(type = Type.REACTIVE)
		ReactiveHealthContributorRegistry reactiveHealthContributorRegistry(
				Map<String, HealthContributor> healthContributorBeans,
				Map<String, ReactiveHealthContributor> reactiveHealthContributorBeans) {
			Map<String, ReactiveHealthContributor> allIndicators = new LinkedHashMap<>(reactiveHealthContributorBeans);
			healthContributorBeans.forEach((name, contributor) -> allIndicators.computeIfAbsent(name,
					(key) -> ReactiveHealthContributor.adapt(contributor)));
			return new DefaultReactiveHealthContributorRegistry(allIndicators);
		}
		@Bean
		HealthEndpoint healthEndpoint(HealthContributorRegistry healthContributorRegistry,
				HealthEndpointGroups healthEndpointGroups) {
			return new HealthEndpoint(healthContributorRegistry, healthEndpointGroups, null);
		}
		@Bean
		@ConditionalOnWebApplication(type = Type.SERVLET)
		HealthEndpointWebExtension healthWebEndpointExtension(HealthContributorRegistry healthContributorRegistry,
				HealthEndpointGroups healthEndpointGroups) {
			return new HealthEndpointWebExtension(healthContributorRegistry, healthEndpointGroups, null);
		}
		@Bean
		@ConditionalOnWebApplication(type = Type.REACTIVE)
		ReactiveHealthEndpointWebExtension reactiveHealthWebEndpointExtension(
				ReactiveHealthContributorRegistry reactiveHealthContributorRegistry,
				HealthEndpointGroups healthEndpointGroups) {
			return new ReactiveHealthEndpointWebExtension(reactiveHealthContributorRegistry, healthEndpointGroups,
					null);
		}
		@Bean
		HealthEndpointGroups healthEndpointGroups() {
			TestHealthEndpointGroup primary = new TestHealthEndpointGroup();
			TestHealthEndpointGroup allTheAs = new TestHealthEndpointGroup((name) -> name.startsWith('a'));
			return HealthEndpointGroups.of(primary, Collections.singletonMap('alltheas', allTheAs));
		}
		@Bean
		HealthIndicator alphaHealthIndicator() {
			return () -> Health.up().build();
		}
		@Bean
		HealthIndicator bravoHealthIndicator() {
			return () -> Health.up().build();
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthEndpointWebExtensionRuntimeHintsTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new HealthEndpointWebExtensionRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		Set<Class<?>> bindingTypes = Set.of(Health.class, SystemHealth.class, CompositeHealth.class);
		for (Class<?> bindingType : bindingTypes) {
			assertThat(RuntimeHintsPredicates.reflection()
				.onType(bindingType)
				.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
				.accepts(runtimeHints);
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class SimpleHttpCodeStatusMapperTests {
	@Test
	void createWhenMappingsAreNullUsesDefaultMappings() {
		SimpleHttpCodeStatusMapper mapper = new SimpleHttpCodeStatusMapper(null);
		assertThat(mapper.getStatusCode(Status.UNKNOWN)).isEqualTo(WebEndpointResponse.STATUS_OK);
		assertThat(mapper.getStatusCode(Status.UP)).isEqualTo(WebEndpointResponse.STATUS_OK);
		assertThat(mapper.getStatusCode(Status.DOWN)).isEqualTo(WebEndpointResponse.STATUS_SERVICE_UNAVAILABLE);
		assertThat(mapper.getStatusCode(Status.OUT_OF_SERVICE))
			.isEqualTo(WebEndpointResponse.STATUS_SERVICE_UNAVAILABLE);
	}
	@Test
	void getStatusCodeReturnsMappedStatus() {
		Map<String, Integer> map = new LinkedHashMap<>();
		map.put('up', 123);
		map.put('down', 456);
		SimpleHttpCodeStatusMapper mapper = new SimpleHttpCodeStatusMapper(map);
		assertThat(mapper.getStatusCode(Status.UP)).isEqualTo(123);
		assertThat(mapper.getStatusCode(Status.DOWN)).isEqualTo(456);
		assertThat(mapper.getStatusCode(Status.OUT_OF_SERVICE)).isEqualTo(200);
	}
	@Test
	void getStatusCodeWhenMappingsAreNotUniformReturnsMappedStatus() {
		Map<String, Integer> map = new LinkedHashMap<>();
		map.put('out-of-service', 123);
		SimpleHttpCodeStatusMapper mapper = new SimpleHttpCodeStatusMapper(map);
		assertThat(mapper.getStatusCode(Status.OUT_OF_SERVICE)).isEqualTo(123);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class ReactiveHealthIndicatorTests {
	private final ReactiveHealthIndicator indicator = () -> Mono.just(Health.up().withDetail('spring', 'boot').build());
	@Test
	void getHealthWhenIncludeDetailsIsTrueReturnsHealthWithDetails() {
		Health health = this.indicator.getHealth(true).block();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('spring', 'boot');
	}
	@Test
	void getHealthWhenIncludeDetailsIsFalseReturnsHealthWithoutDetails() {
		Health health = this.indicator.getHealth(false).block();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).isEmpty();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@ExtendWith(OutputCaptureExtension.class)
class ReactiveHealthIndicatorImplementationTests {
	@Test
	void healthUp(CapturedOutput output) {
		StepVerifier.create(new SimpleReactiveHealthIndicator().health())
			.consumeNextWith((health) -> assertThat(health).isEqualTo(Health.up().build()))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		assertThat(output).doesNotContain('Health check failed for simple');
	}
	@Test
	void healthDownWithCustomErrorMessage(CapturedOutput output) {
		StepVerifier.create(new CustomErrorMessageReactiveHealthIndicator().health())
			.consumeNextWith(
					(health) -> assertThat(health).isEqualTo(Health.down(new UnsupportedOperationException()).build()))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		assertThat(output).contains('Health check failed for custom');
	}
	@Test
	void healthDownWithCustomErrorMessageFunction(CapturedOutput output) {
		StepVerifier.create(new CustomErrorMessageFunctionReactiveHealthIndicator().health())
			.consumeNextWith((health) -> assertThat(health).isEqualTo(Health.down(new RuntimeException()).build()))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		assertThat(output).contains('Health check failed with RuntimeException');
	}
	private static final class SimpleReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
		SimpleReactiveHealthIndicator() {
			super('Health check failed for simple');
		}
		@Override
		protected Mono<Health> doHealthCheck(Builder builder) {
			return Mono.just(builder.up().build());
		}
	}
	private static final class CustomErrorMessageReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
		CustomErrorMessageReactiveHealthIndicator() {
			super('Health check failed for custom');
		}
		@Override
		protected Mono<Health> doHealthCheck(Builder builder) {
			return Mono.error(new UnsupportedOperationException());
		}
	}
	private static final class CustomErrorMessageFunctionReactiveHealthIndicator
			extends AbstractReactiveHealthIndicator {
		CustomErrorMessageFunctionReactiveHealthIndicator() {
			super((ex) -> 'Health check failed with ' + ex.getClass().getSimpleName());
		}
		@Override
		protected Mono<Health> doHealthCheck(Builder builder) {
			throw new RuntimeException();
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthEndpointGroupsTests {
	@Test
	void ofWhenPrimaryIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> HealthEndpointGroups.of(null, Collections.emptyMap()))
			.withMessage('Primary must not be null');
	}
	@Test
	void ofWhenAdditionalIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> HealthEndpointGroups.of(mock(HealthEndpointGroup.class), null))
			.withMessage('Additional must not be null');
	}
	@Test
	void ofReturnsHealthEndpointGroupsInstance() {
		HealthEndpointGroup primary = mock(HealthEndpointGroup.class);
		HealthEndpointGroup group = mock(HealthEndpointGroup.class);
		HealthEndpointGroups groups = HealthEndpointGroups.of(primary, Collections.singletonMap('group', group));
		assertThat(groups.getPrimary()).isSameAs(primary);
		assertThat(groups.getNames()).containsExactly('group');
		assertThat(groups.get('group')).isSameAs(group);
		assertThat(groups.get('missing')).isNull();
	}
}
/*
package org.springframework.boot.actuate.metrics;
/**
class MetricsEndpointTests {
	private final MeterRegistry registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, new MockClock());
	private final MetricsEndpoint endpoint = new MetricsEndpoint(this.registry);
	@Test
	void listNamesHandlesEmptyListOfMeters() {
		MetricsEndpoint.MetricNamesDescriptor result = this.endpoint.listNames();
		assertThat(result.getNames()).isEmpty();
	}
	@Test
	void listNamesProducesListOfUniqueMeterNames() {
		this.registry.counter('com.example.alpha');
		this.registry.counter('com.example.charlie');
		this.registry.counter('com.example.bravo');
		this.registry.counter('com.example.delta');
		this.registry.counter('com.example.delta');
		this.registry.counter('com.example.echo');
		this.registry.counter('com.example.bravo');
		MetricsEndpoint.MetricNamesDescriptor result = this.endpoint.listNames();
		assertThat(result.getNames()).containsExactly('com.example.alpha', 'com.example.bravo', 'com.example.charlie',
				'com.example.delta', 'com.example.echo');
	}
	@Test
	void listNamesResponseOverCompositeRegistries() {
		CompositeMeterRegistry composite = new CompositeMeterRegistry();
		SimpleMeterRegistry reg1 = new SimpleMeterRegistry();
		SimpleMeterRegistry reg2 = new SimpleMeterRegistry();
		composite.add(reg1);
		composite.add(reg2);
		reg1.counter('counter1').increment();
		reg2.counter('counter2').increment();
		MetricsEndpoint endpoint = new MetricsEndpoint(composite);
		assertThat(endpoint.listNames().getNames()).containsExactly('counter1', 'counter2');
	}
	@Test
	void metricValuesAreTheSumOfAllTimeSeriesMatchingTags() {
		this.registry.counter('cache', 'result', 'hit', 'host', '1').increment(2);
		this.registry.counter('cache', 'result', 'miss', 'host', '1').increment(2);
		this.registry.counter('cache', 'result', 'hit', 'host', '2').increment(2);
		MetricsEndpoint.MetricDescriptor response = this.endpoint.metric('cache', Collections.emptyList());
		assertThat(response.getName()).isEqualTo('cache');
		assertThat(availableTagKeys(response)).containsExactly('result', 'host');
		assertThat(getCount(response)).hasValue(6.0);
		response = this.endpoint.metric('cache', Collections.singletonList('result:hit'));
		assertThat(availableTagKeys(response)).containsExactly('host');
		assertThat(getCount(response)).hasValue(4.0);
	}
	@Test
	void findFirstMatchingMetersFromNestedRegistries() {
		CompositeMeterRegistry composite = new CompositeMeterRegistry();
		SimpleMeterRegistry firstLevel0 = new SimpleMeterRegistry();
		CompositeMeterRegistry firstLevel1 = new CompositeMeterRegistry();
		SimpleMeterRegistry secondLevel = new SimpleMeterRegistry();
		composite.add(firstLevel0);
		composite.add(firstLevel1);
		firstLevel1.add(secondLevel);
		secondLevel.counter('cache', 'result', 'hit', 'host', '1').increment(2);
		secondLevel.counter('cache', 'result', 'miss', 'host', '1').increment(2);
		secondLevel.counter('cache', 'result', 'hit', 'host', '2').increment(2);
		MetricsEndpoint endpoint = new MetricsEndpoint(composite);
		MetricsEndpoint.MetricDescriptor response = endpoint.metric('cache', Collections.emptyList());
		assertThat(response.getName()).isEqualTo('cache');
		assertThat(availableTagKeys(response)).containsExactly('result', 'host');
		assertThat(getCount(response)).hasValue(6.0);
		response = endpoint.metric('cache', Collections.singletonList('result:hit'));
		assertThat(availableTagKeys(response)).containsExactly('host');
		assertThat(getCount(response)).hasValue(4.0);
	}
	@Test
	void matchingMeterNotFoundInNestedRegistries() {
		CompositeMeterRegistry composite = new CompositeMeterRegistry();
		CompositeMeterRegistry firstLevel = new CompositeMeterRegistry();
		SimpleMeterRegistry secondLevel = new SimpleMeterRegistry();
		composite.add(firstLevel);
		firstLevel.add(secondLevel);
		MetricsEndpoint endpoint = new MetricsEndpoint(composite);
		MetricsEndpoint.MetricDescriptor response = endpoint.metric('invalid.metric.name', Collections.emptyList());
		assertThat(response).isNull();
	}
	@Test
	void metricTagValuesAreDeduplicated() {
		this.registry.counter('cache', 'host', '1', 'region', 'east', 'result', 'hit');
		this.registry.counter('cache', 'host', '1', 'region', 'east', 'result', 'miss');
		MetricsEndpoint.MetricDescriptor response = this.endpoint.metric('cache', Collections.singletonList('host:1'));
		assertThat(response.getAvailableTags()
			.stream()
			.filter((t) -> t.getTag().equals('region'))
			.flatMap((t) -> t.getValues().stream())).containsExactly('east');
	}
	@Test
	void metricWithSpaceInTagValue() {
		this.registry.counter('counter', 'key', 'a space').increment(2);
		MetricsEndpoint.MetricDescriptor response = this.endpoint.metric('counter',
				Collections.singletonList('key:a space'));
		assertThat(response.getName()).isEqualTo('counter');
		assertThat(availableTagKeys(response)).isEmpty();
		assertThat(getCount(response)).hasValue(2.0);
	}
	@Test
	void metricWithInvalidTag() {
		assertThatExceptionOfType(InvalidEndpointRequestException.class)
			.isThrownBy(() -> this.endpoint.metric('counter', Collections.singletonList('key')));
	}
	@Test
	void metricPresentInOneRegistryOfACompositeAndNotAnother() {
		CompositeMeterRegistry composite = new CompositeMeterRegistry();
		SimpleMeterRegistry reg1 = new SimpleMeterRegistry();
		SimpleMeterRegistry reg2 = new SimpleMeterRegistry();
		composite.add(reg1);
		composite.add(reg2);
		reg1.counter('counter1').increment();
		reg2.counter('counter2').increment();
		MetricsEndpoint endpoint = new MetricsEndpoint(composite);
		assertThat(endpoint.metric('counter1', Collections.emptyList())).isNotNull();
		assertThat(endpoint.metric('counter2', Collections.emptyList())).isNotNull();
	}
	@Test
	void nonExistentMetric() {
		MetricsEndpoint.MetricDescriptor response = this.endpoint.metric('does.not.exist', Collections.emptyList());
		assertThat(response).isNull();
	}
	@Test
	void maxAggregation() {
		SimpleMeterRegistry reg = new SimpleMeterRegistry();
		reg.timer('timer', 'k', 'v1').record(1, TimeUnit.SECONDS);
		reg.timer('timer', 'k', 'v2').record(2, TimeUnit.SECONDS);
		assertMetricHasStatisticEqualTo(reg, 'timer', Statistic.MAX, 2.0);
	}
	@Test
	void countAggregation() {
		SimpleMeterRegistry reg = new SimpleMeterRegistry();
		reg.counter('counter', 'k', 'v1').increment();
		reg.counter('counter', 'k', 'v2').increment();
		assertMetricHasStatisticEqualTo(reg, 'counter', Statistic.COUNT, 2.0);
	}
	private void assertMetricHasStatisticEqualTo(MeterRegistry registry, String metricName, Statistic stat,
			Double value) {
		MetricsEndpoint endpoint = new MetricsEndpoint(registry);
		assertThat(endpoint.metric(metricName, Collections.emptyList())
			.getMeasurements()
			.stream()
			.filter((sample) -> sample.getStatistic().equals(stat))
			.findAny()).hasValueSatisfying((sample) -> assertThat(sample.getValue()).isEqualTo(value));
	}
	private Optional<Double> getCount(MetricsEndpoint.MetricDescriptor response) {
		return response.getMeasurements()
			.stream()
			.filter((sample) -> sample.getStatistic().equals(Statistic.COUNT))
			.findAny()
			.map(MetricsEndpoint.Sample::getValue);
	}
	private Stream<String> availableTagKeys(MetricsEndpoint.MetricDescriptor response) {
		return response.getAvailableTags().stream().map(MetricsEndpoint.AvailableTag::getTag);
	}
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
class SecondCustomPrometheusScrapeEndpointIntegrationTests {
	@WebEndpointTest
	void scrapeHasContentTypeText004ByDefault(WebTestClient client) {
		scrapeHasContentTypeText004ByDefault(client, '/actuator/prometheus');
		scrapeHasContentTypeText004ByDefault(client, '/actuator/prometheussc');
	}
	private void scrapeHasContentTypeText004ByDefault(WebTestClient client, String uri) {
		String expectedContentType = PrometheusTextFormatWriter.CONTENT_TYPE;
		client.get()
			.uri(uri)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(expectedContentType))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapeHasContentTypeText004ByDefaultWhenClientAcceptsWildcardWithParameter(WebTestClient client) {
		scrapeHasContentTypeText004ByDefaultWhenClientAcceptsWildcardWithParameter(client, '/actuator/prometheus');
		scrapeHasContentTypeText004ByDefaultWhenClientAcceptsWildcardWithParameter(client, '/actuator/prometheussc');
	}
	private void scrapeHasContentTypeText004ByDefaultWhenClientAcceptsWildcardWithParameter(WebTestClient client,
			String uri) {
		String expectedContentType = PrometheusTextFormatWriter.CONTENT_TYPE;
		String accept = '*/*;q=0.8';
		client.get()
			.uri(uri)
			.accept(MediaType.parseMediaType(accept))
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(expectedContentType))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapeCanProduceOpenMetrics100(WebTestClient client) {
		scrapeCanProduceOpenMetrics100(client, '/actuator/prometheus');
		scrapeCanProduceOpenMetrics100(client, '/actuator/prometheussc');
	}
	private void scrapeCanProduceOpenMetrics100(WebTestClient client, String uri) {
		MediaType openMetrics = MediaType.parseMediaType(OpenMetricsTextFormatWriter.CONTENT_TYPE);
		client.get()
			.uri(uri)
			.accept(openMetrics)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(openMetrics)
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapePrefersToProduceOpenMetrics100(WebTestClient client) {
		scrapePrefersToProduceOpenMetrics100(client, '/actuator/prometheus');
		scrapePrefersToProduceOpenMetrics100(client, '/actuator/prometheussc');
	}
	private void scrapePrefersToProduceOpenMetrics100(WebTestClient client, String uri) {
		MediaType openMetrics = MediaType.parseMediaType(OpenMetricsTextFormatWriter.CONTENT_TYPE);
		MediaType textPlain = MediaType.parseMediaType(PrometheusTextFormatWriter.CONTENT_TYPE);
		client.get()
			.uri(uri)
			.accept(openMetrics, textPlain)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(openMetrics);
	}
	@WebEndpointTest
	void scrapeWithIncludedNames(WebTestClient client) {
		scrapeWithIncludedNames(client, '/actuator/prometheus?includedNames=counter1,counter2');
		scrapeWithIncludedNames(client, '/actuator/prometheussc?includedNames=counter1_total,counter2_total');
	}
	private void scrapeWithIncludedNames(WebTestClient client, String uri) {
		client.get()
			.uri(uri)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(PrometheusTextFormatWriter.CONTENT_TYPE))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.doesNotContain('counter3_total'));
	}
	@SuppressWarnings({ 'deprecation', 'removal' })
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		PrometheusScrapeEndpoint prometheusScrapeEndpoint(PrometheusRegistry prometheusRegistry) {
			return new PrometheusScrapeEndpoint(prometheusRegistry, new Properties());
		}
		@Bean
		CustomPrometheusScrapeEndpoint customPrometheusScrapeEndpoint(CollectorRegistry collectorRegistry) {
			return new CustomPrometheusScrapeEndpoint(collectorRegistry);
		}
		@Bean
		PrometheusRegistry prometheusRegistry() {
			return new PrometheusRegistry();
		}
		@Bean
		CollectorRegistry collectorRegistry() {
			return new CollectorRegistry(true);
		}
		@Bean
		PrometheusMeterRegistry registry(PrometheusRegistry prometheusRegistry) {
			return new PrometheusMeterRegistry((k) -> null, prometheusRegistry, Clock.SYSTEM);
		}
		@Bean
		io.micrometer.prometheus.PrometheusMeterRegistry oldRegistry(CollectorRegistry collectorRegistry) {
			return new io.micrometer.prometheus.PrometheusMeterRegistry((k) -> null, collectorRegistry, Clock.SYSTEM);
		}
		@Bean
		CompositeMeterRegistry compositeMeterRegistry(PrometheusMeterRegistry prometheusMeterRegistry,
				io.micrometer.prometheus.PrometheusMeterRegistry prometheusSCMeterRegistry) {
			CompositeMeterRegistry composite = new CompositeMeterRegistry();
			composite.add(prometheusMeterRegistry).add(prometheusSCMeterRegistry);
			Counter.builder('counter1').register(composite);
			Counter.builder('counter2').register(composite);
			Counter.builder('counter3').register(composite);
			return composite;
		}
		@WebEndpoint(id = 'prometheussc')
		static class CustomPrometheusScrapeEndpoint extends PrometheusSimpleclientScrapeEndpoint {
			CustomPrometheusScrapeEndpoint(CollectorRegistry collectorRegistry) {
				super(collectorRegistry);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
@ExtendWith(MockitoExtension.class)
class PrometheusPushGatewayManagerTests {
	@Mock
	private PushGateway pushGateway;
	@Mock
	private CollectorRegistry registry;
	@Mock
	private TaskScheduler scheduler;
	private final Duration pushRate = Duration.ofSeconds(1);
	private final Map<String, String> groupingKey = Collections.singletonMap('foo', 'bar');
	@Captor
	private ArgumentCaptor<Runnable> task;
	@Mock
	private ScheduledFuture<Object> future;
	@Test
	void createWhenPushGatewayIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PrometheusPushGatewayManager(null, this.registry, this.scheduler, this.pushRate,
					'job', this.groupingKey, null))
			.withMessage('PushGateway must not be null');
	}
	@Test
	void createWhenCollectorRegistryIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PrometheusPushGatewayManager(this.pushGateway, null, this.scheduler, this.pushRate,
					'job', this.groupingKey, null))
			.withMessage('Registry must not be null');
	}
	@Test
	void createWhenSchedulerIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PrometheusPushGatewayManager(this.pushGateway, this.registry, null, this.pushRate,
					'job', this.groupingKey, null))
			.withMessage('Scheduler must not be null');
	}
	@Test
	void createWhenPushRateIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, null,
					'job', this.groupingKey, null))
			.withMessage('PushRate must not be null');
	}
	@Test
	void createWhenJobIsEmptyThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler,
					this.pushRate, '', this.groupingKey, null))
			.withMessage('Job must not be empty');
	}
	@Test
	void createShouldSchedulePushAsFixedRate() throws Exception {
		new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, 'job',
				this.groupingKey, null);
		then(this.scheduler).should().scheduleAtFixedRate(this.task.capture(), eq(this.pushRate));
		this.task.getValue().run();
		then(this.pushGateway).should().pushAdd(this.registry, 'job', this.groupingKey);
	}
	@Test
	void shutdownWhenOwnsSchedulerDoesShutdownScheduler() {
		PushGatewayTaskScheduler ownedScheduler = givenScheduleAtFixedRateWillReturnFuture(
				mock(PushGatewayTaskScheduler.class));
		PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,
				ownedScheduler, this.pushRate, 'job', this.groupingKey, null);
		manager.shutdown();
		then(ownedScheduler).should().shutdown();
	}
	@Test
	void shutdownWhenDoesNotOwnSchedulerDoesNotShutdownScheduler() {
		ThreadPoolTaskScheduler otherScheduler = givenScheduleAtFixedRateWillReturnFuture(
				mock(ThreadPoolTaskScheduler.class));
		PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,
				otherScheduler, this.pushRate, 'job', this.groupingKey, null);
		manager.shutdown();
		then(otherScheduler).should(never()).shutdown();
	}
	@Test
	void shutdownWhenShutdownOperationIsPostPerformsPushAddOnShutdown() throws Exception {
		givenScheduleAtFixedRateWithReturnFuture();
		PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,
				this.scheduler, this.pushRate, 'job', this.groupingKey, ShutdownOperation.POST);
		manager.shutdown();
		then(this.future).should().cancel(false);
		then(this.pushGateway).should().pushAdd(this.registry, 'job', this.groupingKey);
	}
	@Test
	void shutdownWhenShutdownOperationIsPutPerformsPushOnShutdown() throws Exception {
		givenScheduleAtFixedRateWithReturnFuture();
		PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,
				this.scheduler, this.pushRate, 'job', this.groupingKey, ShutdownOperation.PUT);
		manager.shutdown();
		then(this.future).should().cancel(false);
		then(this.pushGateway).should().push(this.registry, 'job', this.groupingKey);
	}
	@Test
	void shutdownWhenShutdownOperationIsDeletePerformsDeleteOnShutdown() throws Exception {
		givenScheduleAtFixedRateWithReturnFuture();
		PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,
				this.scheduler, this.pushRate, 'job', this.groupingKey, ShutdownOperation.DELETE);
		manager.shutdown();
		then(this.future).should().cancel(false);
		then(this.pushGateway).should().delete('job', this.groupingKey);
	}
	@Test
	void shutdownWhenShutdownOperationIsNoneDoesNothing() {
		givenScheduleAtFixedRateWithReturnFuture();
		PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,
				this.scheduler, this.pushRate, 'job', this.groupingKey, ShutdownOperation.NONE);
		manager.shutdown();
		then(this.future).should().cancel(false);
		then(this.pushGateway).shouldHaveNoInteractions();
	}
	@Test
	void pushDoesNotThrowException() throws Exception {
		new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, 'job',
				this.groupingKey, null);
		then(this.scheduler).should().scheduleAtFixedRate(this.task.capture(), eq(this.pushRate));
		willThrow(RuntimeException.class).given(this.pushGateway).pushAdd(this.registry, 'job', this.groupingKey);
		this.task.getValue().run();
	}
	private void givenScheduleAtFixedRateWithReturnFuture() {
		givenScheduleAtFixedRateWillReturnFuture(this.scheduler);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private <T extends TaskScheduler> T givenScheduleAtFixedRateWillReturnFuture(T scheduler) {
		given(scheduler.scheduleAtFixedRate(isA(Runnable.class), isA(Duration.class)))
			.willReturn((ScheduledFuture) this.future);
		return scheduler;
	}
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
class PrometheusScrapeEndpointIntegrationTests {
	@WebEndpointTest
	void scrapeHasContentTypeText004ByDefault(WebTestClient client) {
		String expectedContentType = PrometheusTextFormatWriter.CONTENT_TYPE;
		client.get()
			.uri('/actuator/prometheus')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(expectedContentType))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapeHasContentTypeText004ByDefaultWhenClientAcceptsWildcardWithParameter(WebTestClient client) {
		String expectedContentType = PrometheusTextFormatWriter.CONTENT_TYPE;
		String accept = '*/*;q=0.8';
		client.get()
			.uri('/actuator/prometheus')
			.accept(MediaType.parseMediaType(accept))
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(expectedContentType))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapeCanProduceOpenMetrics100(WebTestClient client) {
		MediaType openMetrics = MediaType.parseMediaType(OpenMetricsTextFormatWriter.CONTENT_TYPE);
		client.get()
			.uri('/actuator/prometheus')
			.accept(openMetrics)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(openMetrics)
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapePrefersToProduceOpenMetrics100(WebTestClient client) {
		MediaType openMetrics = MediaType.parseMediaType(OpenMetricsTextFormatWriter.CONTENT_TYPE);
		MediaType textPlain = MediaType.parseMediaType(PrometheusTextFormatWriter.CONTENT_TYPE);
		client.get()
			.uri('/actuator/prometheus')
			.accept(openMetrics, textPlain)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(openMetrics);
	}
	@WebEndpointTest
	void scrapeWithIncludedNames(WebTestClient client) {
		client.get()
			.uri('/actuator/prometheus?includedNames=counter1,counter2')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(PrometheusTextFormatWriter.CONTENT_TYPE))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.doesNotContain('counter3_total'));
	}
	@WebEndpointTest
	void scrapeCanProducePrometheusProtobuf(WebTestClient client) {
		MediaType prometheusProtobuf = MediaType.parseMediaType(PrometheusProtobufWriter.CONTENT_TYPE);
		client.get()
			.uri('/actuator/prometheus')
			.accept(prometheusProtobuf)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(prometheusProtobuf)
			.expectBody(byte[].class)
			.value((body) -> assertThat(body).isNotEmpty());
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		PrometheusScrapeEndpoint prometheusScrapeEndpoint(PrometheusRegistry prometheusRegistry) {
			return new PrometheusScrapeEndpoint(prometheusRegistry, new Properties());
		}
		@Bean
		PrometheusRegistry prometheusRegistry() {
			return new PrometheusRegistry();
		}
		@Bean
		MeterRegistry registry(PrometheusRegistry prometheusRegistry) {
			PrometheusMeterRegistry meterRegistry = new PrometheusMeterRegistry((k) -> null, prometheusRegistry,
					Clock.SYSTEM);
			Counter.builder('counter1').register(meterRegistry);
			Counter.builder('counter2').register(meterRegistry);
			Counter.builder('counter3').register(meterRegistry);
			return meterRegistry;
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class PrometheusSimpleclientScrapeEndpointIntegrationTests {
	@WebEndpointTest
	void scrapeHasContentTypeText004ByDefault(WebTestClient client) {
		String expectedContentType = TextFormat.CONTENT_TYPE_004;
		assertThat(TextFormat.chooseContentType(null)).isEqualTo(expectedContentType);
		client.get()
			.uri('/actuator/prometheus')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(expectedContentType))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapeHasContentTypeText004ByDefaultWhenClientAcceptsWildcardWithParameter(WebTestClient client) {
		String expectedContentType = TextFormat.CONTENT_TYPE_004;
		String accept = '*/*;q=0.8';
		assertThat(TextFormat.chooseContentType(accept)).isEqualTo(expectedContentType);
		client.get()
			.uri('/actuator/prometheus')
			.accept(MediaType.parseMediaType(accept))
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(expectedContentType))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapeCanProduceOpenMetrics100(WebTestClient client) {
		MediaType openMetrics = MediaType.parseMediaType(TextFormat.CONTENT_TYPE_OPENMETRICS_100);
		client.get()
			.uri('/actuator/prometheus')
			.accept(openMetrics)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(openMetrics)
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.contains('counter3_total'));
	}
	@WebEndpointTest
	void scrapePrefersToProduceOpenMetrics100(WebTestClient client) {
		MediaType openMetrics = MediaType.parseMediaType(TextFormat.CONTENT_TYPE_OPENMETRICS_100);
		MediaType textPlain = MediaType.parseMediaType(TextFormat.CONTENT_TYPE_004);
		client.get()
			.uri('/actuator/prometheus')
			.accept(openMetrics, textPlain)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(openMetrics);
	}
	@WebEndpointTest
	void scrapeWithIncludedNames(WebTestClient client) {
		client.get()
			.uri('/actuator/prometheus?includedNames=counter1_total,counter2_total')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType(TextFormat.CONTENT_TYPE_004))
			.expectBody(String.class)
			.value((body) -> assertThat(body).contains('counter1_total')
				.contains('counter2_total')
				.doesNotContain('counter3_total'));
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		PrometheusSimpleclientScrapeEndpoint prometheusScrapeEndpoint(CollectorRegistry collectorRegistry) {
			return new PrometheusSimpleclientScrapeEndpoint(collectorRegistry);
		}
		@Bean
		CollectorRegistry collectorRegistry() {
			return new CollectorRegistry(true);
		}
		@Bean
		@SuppressWarnings('deprecation')
		MeterRegistry registry(CollectorRegistry registry) {
			io.micrometer.prometheus.PrometheusMeterRegistry meterRegistry = new io.micrometer.prometheus.PrometheusMeterRegistry(
					(k) -> null, registry, Clock.SYSTEM);
			Counter.builder('counter1').register(meterRegistry);
			Counter.builder('counter2').register(meterRegistry);
			Counter.builder('counter3').register(meterRegistry);
			return meterRegistry;
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.jdbc;
/**
class DataSourcePoolMetricsTests {
	@Test
	void dataSourceIsInstrumented() {
		new ApplicationContextRunner().withUserConfiguration(DataSourceConfig.class, MetricsApp.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('spring.datasource.generate-unique-name=true', 'metrics.use-global-registry=false')
			.run((context) -> {
				context.getBean(DataSource.class).getConnection().getMetaData();
				context.getBean(MeterRegistry.class).get('jdbc.connections.max').meter();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class MetricsApp {
		@Bean
		MeterRegistry registry() {
			return new SimpleMeterRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataSourceConfig {
		DataSourceConfig(DataSource dataSource, Collection<DataSourcePoolMetadataProvider> metadataProviders,
				MeterRegistry registry) {
			new DataSourcePoolMetrics(dataSource, metadataProviders, 'data.source', Collections.emptyList())
				.bindTo(registry);
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
class RedisCacheMeterBinderProviderTests {
	@Test
	void redisCacheProvider() {
		RedisCache cache = mock(RedisCache.class);
		given(cache.getName()).willReturn('test');
		MeterBinder meterBinder = new RedisCacheMeterBinderProvider().getMeterBinder(cache, Collections.emptyList());
		assertThat(meterBinder).isInstanceOf(RedisCacheMetrics.class);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
class CaffeineCacheMeterBinderProviderTests {
	@Test
	void caffeineCacheProvider() {
		CaffeineCache cache = new CaffeineCache('test', Caffeine.newBuilder().build());
		MeterBinder meterBinder = new CaffeineCacheMeterBinderProvider().getMeterBinder(cache, Collections.emptyList());
		assertThat(meterBinder).isInstanceOf(CaffeineCacheMetrics.class);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
class Cache2kCacheMeterBinderProviderTests {
	@Test
	void cache2kCacheProvider() {
		SpringCache2kCacheManager cacheManager = new SpringCache2kCacheManager()
			.addCaches((builder) -> builder.name('test'));
		MeterBinder meterBinder = new Cache2kCacheMeterBinderProvider().getMeterBinder(cacheManager.getCache('test'),
				Collections.emptyList());
		assertThat(meterBinder).isInstanceOf(Cache2kCacheMetrics.class);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
@ExtendWith(MockitoExtension.class)
class JCacheCacheMeterBinderProviderTests {
	@Mock
	private javax.cache.Cache<Object, Object> nativeCache;
	@Test
	void jCacheCacheProvider() throws URISyntaxException {
		javax.cache.CacheManager cacheManager = mock(javax.cache.CacheManager.class);
		given(cacheManager.getURI()).willReturn(new URI('/test'));
		given(this.nativeCache.getCacheManager()).willReturn(cacheManager);
		given(this.nativeCache.getName()).willReturn('test');
		JCacheCache cache = new JCacheCache(this.nativeCache);
		MeterBinder meterBinder = new JCacheCacheMeterBinderProvider().getMeterBinder(cache, Collections.emptyList());
		assertThat(meterBinder).isInstanceOf(JCacheMetrics.class);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
class CacheMetricsRegistrarTests {
	private final MeterRegistry meterRegistry = new SimpleMeterRegistry();
	@Test
	void bindToSupportedCache() {
		CacheMetricsRegistrar registrar = new CacheMetricsRegistrar(this.meterRegistry,
				Collections.singleton(new CaffeineCacheMeterBinderProvider()));
		assertThat(
				registrar.bindCacheToRegistry(new CaffeineCache('test', Caffeine.newBuilder().recordStats().build())))
			.isTrue();
		assertThat(this.meterRegistry.get('cache.gets').tags('name', 'test').meter()).isNotNull();
	}
	@Test
	void bindToSupportedCacheWrappedInTransactionProxy() {
		CacheMetricsRegistrar registrar = new CacheMetricsRegistrar(this.meterRegistry,
				Collections.singleton(new CaffeineCacheMeterBinderProvider()));
		assertThat(registrar.bindCacheToRegistry(new TransactionAwareCacheDecorator(
				new CaffeineCache('test', Caffeine.newBuilder().recordStats().build()))))
			.isTrue();
		assertThat(this.meterRegistry.get('cache.gets').tags('name', 'test').meter()).isNotNull();
	}
	@Test
	void bindToUnsupportedCache() {
		CacheMetricsRegistrar registrar = new CacheMetricsRegistrar(this.meterRegistry, Collections.emptyList());
		assertThat(
				registrar.bindCacheToRegistry(new CaffeineCache('test', Caffeine.newBuilder().recordStats().build())))
			.isFalse();
		assertThat(this.meterRegistry.find('cache.gets').tags('name', 'test').meter()).isNull();
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
class HazelcastCacheMeterBinderProviderTests {
	@SuppressWarnings('unchecked')
	@Test
	void hazelcastCacheProvider() {
		IMap<Object, Object> nativeCache = mock(IMap.class);
		given(nativeCache.getName()).willReturn('test');
		HazelcastCache cache = new HazelcastCache(nativeCache);
		MeterBinder meterBinder = new HazelcastCacheMeterBinderProvider().getMeterBinder(cache,
				Collections.emptyList());
		assertThat(meterBinder).isInstanceOf(HazelcastCacheMetrics.class);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new HazelcastCacheMeterBinderProviderRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onMethod(HazelcastCache.class, 'getNativeCache'))
			.accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(HazelcastCacheMetrics.class)).accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.metrics.annotation;
/**
class TimedAnnotationsTests {
	@Test
	void getWhenNoneReturnsEmptySet() {
		Object bean = new None();
		Method method = ReflectionUtils.findMethod(bean.getClass(), 'handle');
		Set<Timed> annotations = TimedAnnotations.get(method, bean.getClass());
		assertThat(annotations).isEmpty();
	}
	@Test
	void getWhenOnMethodReturnsMethodAnnotations() {
		Object bean = new OnMethod();
		Method method = ReflectionUtils.findMethod(bean.getClass(), 'handle');
		Set<Timed> annotations = TimedAnnotations.get(method, bean.getClass());
		assertThat(annotations).extracting(Timed::value).containsOnly('y', 'z');
	}
	@Test
	void getWhenNonOnMethodReturnsBeanAnnotations() {
		Object bean = new OnBean();
		Method method = ReflectionUtils.findMethod(bean.getClass(), 'handle');
		Set<Timed> annotations = TimedAnnotations.get(method, bean.getClass());
		assertThat(annotations).extracting(Timed::value).containsOnly('y', 'z');
	}
	static class None {
		void handle() {
		}
	}
	@Timed('x')
	static class OnMethod {
		@Timed('y')
		@Timed('z')
		void handle() {
		}
	}
	@Timed('y')
	@Timed('z')
	static class OnBean {
		void handle() {
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.web.client;
/**
class ObservationRestClientCustomizerTests {
	private static final String TEST_METRIC_NAME = 'http.test.metric.name';
	private final ObservationRegistry observationRegistry = TestObservationRegistry.create();
	private final RestClient.Builder restClientBuilder = RestClient.builder();
	private final ObservationRestClientCustomizer customizer = new ObservationRestClientCustomizer(
			this.observationRegistry, new DefaultClientRequestObservationConvention(TEST_METRIC_NAME));
	@Test
	void shouldCustomizeObservationConfiguration() {
		this.customizer.customize(this.restClientBuilder);
		assertThat(this.restClientBuilder).hasFieldOrPropertyWithValue('observationRegistry', this.observationRegistry);
		assertThat(this.restClientBuilder).extracting('observationConvention')
			.isInstanceOf(DefaultClientRequestObservationConvention.class)
			.hasFieldOrPropertyWithValue('name', TEST_METRIC_NAME);
	}
}
/*
package org.springframework.boot.actuate.metrics.web.client;
/**
class ObservationRestTemplateCustomizerTests {
	private static final String TEST_METRIC_NAME = 'http.test.metric.name';
	private final ObservationRegistry observationRegistry = TestObservationRegistry.create();
	private final RestTemplate restTemplate = new RestTemplate();
	private final ObservationRestTemplateCustomizer customizer = new ObservationRestTemplateCustomizer(
			this.observationRegistry, new DefaultClientRequestObservationConvention(TEST_METRIC_NAME));
	@Test
	void shouldCustomizeObservationConfiguration() {
		this.customizer.customize(this.restTemplate);
		assertThat(this.restTemplate).hasFieldOrPropertyWithValue('observationRegistry', this.observationRegistry);
		assertThat(this.restTemplate).extracting('observationConvention')
			.isInstanceOf(DefaultClientRequestObservationConvention.class)
			.hasFieldOrPropertyWithValue('name', TEST_METRIC_NAME);
	}
}
/*
package org.springframework.boot.actuate.metrics.web.tomcat;
/**
class TomcatMetricsBinderTests {
	private final MeterRegistry meterRegistry = mock(MeterRegistry.class);
	@Test
	void destroySucceedsWhenCalledBeforeApplicationHasStarted() {
		new TomcatMetricsBinder(this.meterRegistry).destroy();
	}
}
/*
package org.springframework.boot.actuate.metrics.web.reactive.client;
/**
class ObservationWebClientCustomizerTests {
	private static final String TEST_METRIC_NAME = 'http.test.metric.name';
	private final TestObservationRegistry observationRegistry = TestObservationRegistry.create();
	private final ClientRequestObservationConvention observationConvention = new DefaultClientRequestObservationConvention(
			TEST_METRIC_NAME);
	private final ObservationWebClientCustomizer customizer = new ObservationWebClientCustomizer(
			this.observationRegistry, this.observationConvention);
	private final WebClient.Builder clientBuilder = WebClient.builder();
	@Test
	void shouldCustomizeObservationConfiguration() {
		this.customizer.customize(this.clientBuilder);
		assertThat(this.clientBuilder).hasFieldOrPropertyWithValue('observationRegistry', this.observationRegistry);
		assertThat(this.clientBuilder).extracting('observationConvention')
			.isInstanceOf(DefaultClientRequestObservationConvention.class)
			.hasFieldOrPropertyWithValue('name', TEST_METRIC_NAME);
	}
}
/*
package org.springframework.boot.actuate.metrics.data;
/**
class MetricsRepositoryMethodInvocationListenerTests {
	private static final String REQUEST_METRICS_NAME = 'repository.invocations';
	private SimpleMeterRegistry registry;
	private MetricsRepositoryMethodInvocationListener listener;
	@BeforeEach
	void setup() {
		MockClock clock = new MockClock();
		this.registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, clock);
		this.listener = new MetricsRepositoryMethodInvocationListener(() -> this.registry,
				new DefaultRepositoryTagsProvider(), REQUEST_METRICS_NAME, AutoTimer.ENABLED);
	}
	@Test
	void afterInvocationWhenNoTimerAnnotationsAndNoAutoTimerDoesNothing() {
		this.listener = new MetricsRepositoryMethodInvocationListener(() -> this.registry,
				new DefaultRepositoryTagsProvider(), REQUEST_METRICS_NAME, null);
		this.listener.afterInvocation(createInvocation(NoAnnotationsRepository.class));
		assertThat(this.registry.find(REQUEST_METRICS_NAME).timers()).isEmpty();
	}
	@Test
	void afterInvocationWhenTimedMethodRecordsMetrics() {
		this.listener.afterInvocation(createInvocation(TimedMethodRepository.class));
		assertMetricsContainsTag('state', 'SUCCESS');
		assertMetricsContainsTag('tag1', 'value1');
	}
	@Test
	void afterInvocationWhenTimedClassRecordsMetrics() {
		this.listener.afterInvocation(createInvocation(TimedClassRepository.class));
		assertMetricsContainsTag('state', 'SUCCESS');
		assertMetricsContainsTag('taga', 'valuea');
	}
	@Test
	void afterInvocationWhenAutoTimedRecordsMetrics() {
		this.listener.afterInvocation(createInvocation(NoAnnotationsRepository.class));
		assertMetricsContainsTag('state', 'SUCCESS');
	}
	private void assertMetricsContainsTag(String tagKey, String tagValue) {
		assertThat(this.registry.get(REQUEST_METRICS_NAME).tag(tagKey, tagValue).timer().count()).isOne();
	}
	private RepositoryMethodInvocation createInvocation(Class<?> repositoryInterface) {
		Method method = ReflectionUtils.findMethod(repositoryInterface, 'findById', long.class);
		RepositoryMethodInvocationResult result = mock(RepositoryMethodInvocationResult.class);
		given(result.getState()).willReturn(State.SUCCESS);
		return new RepositoryMethodInvocation(repositoryInterface, method, result, 0);
	}
	interface NoAnnotationsRepository extends Repository<Example, Long> {
		Example findById(long id);
	}
	interface TimedMethodRepository extends Repository<Example, Long> {
		@Timed(extraTags = { 'tag1', 'value1' })
		Example findById(long id);
	}
	@Timed(extraTags = { 'taga', 'valuea' })
	interface TimedClassRepository extends Repository<Example, Long> {
		Example findById(long id);
	}
	static class Example {
	}
}
/*
package org.springframework.boot.actuate.metrics.data;
/**
class DefaultRepositoryTagsProviderTests {
	private final DefaultRepositoryTagsProvider provider = new DefaultRepositoryTagsProvider();
	@Test
	void repositoryTagsIncludesRepository() {
		RepositoryMethodInvocation invocation = createInvocation();
		Iterable<Tag> tags = this.provider.repositoryTags(invocation);
		assertThat(tags).contains(Tag.of('repository', 'ExampleRepository'));
	}
	@Test
	void repositoryTagsIncludesMethod() {
		RepositoryMethodInvocation invocation = createInvocation();
		Iterable<Tag> tags = this.provider.repositoryTags(invocation);
		assertThat(tags).contains(Tag.of('method', 'findById'));
	}
	@Test
	void repositoryTagsIncludesState() {
		RepositoryMethodInvocation invocation = createInvocation();
		Iterable<Tag> tags = this.provider.repositoryTags(invocation);
		assertThat(tags).contains(Tag.of('state', 'SUCCESS'));
	}
	@Test
	void repositoryTagsIncludesException() {
		RepositoryMethodInvocation invocation = createInvocation(new IOException());
		Iterable<Tag> tags = this.provider.repositoryTags(invocation);
		assertThat(tags).contains(Tag.of('exception', 'IOException'));
	}
	@Test
	void repositoryTagsWhenNoExceptionIncludesExceptionTagWithNone() {
		RepositoryMethodInvocation invocation = createInvocation();
		Iterable<Tag> tags = this.provider.repositoryTags(invocation);
		assertThat(tags).contains(Tag.of('exception', 'None'));
	}
	private RepositoryMethodInvocation createInvocation() {
		return createInvocation(null);
	}
	private RepositoryMethodInvocation createInvocation(Throwable error) {
		Class<?> repositoryInterface = ExampleRepository.class;
		Method method = ReflectionUtils.findMethod(repositoryInterface, 'findById', long.class);
		RepositoryMethodInvocationResult result = mock(RepositoryMethodInvocationResult.class);
		given(result.getState()).willReturn((error != null) ? State.ERROR : State.SUCCESS);
		given(result.getError()).willReturn(error);
		return new RepositoryMethodInvocation(repositoryInterface, method, result, 0);
	}
	interface ExampleRepository extends Repository<Example, Long> {
		Example findById(long id);
	}
	static class Example {
	}
}
/*
package org.springframework.boot.actuate.metrics.system;
/**
class DiskSpaceMetricsBinderTests {
	@Test
	void diskSpaceMetricsWithSinglePath() {
		MeterRegistry meterRegistry = new SimpleMeterRegistry();
		File path = new File('.');
		DiskSpaceMetricsBinder metricsBinder = new DiskSpaceMetricsBinder(Collections.singletonList(path),
				Tags.empty());
		metricsBinder.bindTo(meterRegistry);
		Tags tags = Tags.of('path', path.getAbsolutePath());
		assertThat(meterRegistry.get('disk.free').tags(tags).gauge()).isNotNull();
		assertThat(meterRegistry.get('disk.total').tags(tags).gauge()).isNotNull();
	}
	@Test
	void diskSpaceMetricsWithMultiplePaths() {
		MeterRegistry meterRegistry = new SimpleMeterRegistry();
		File path1 = new File('.');
		File path2 = new File('..');
		DiskSpaceMetricsBinder metricsBinder = new DiskSpaceMetricsBinder(Arrays.asList(path1, path2), Tags.empty());
		metricsBinder.bindTo(meterRegistry);
		Tags tags = Tags.of('path', path1.getAbsolutePath());
		assertThat(meterRegistry.get('disk.free').tags(tags).gauge()).isNotNull();
		assertThat(meterRegistry.get('disk.total').tags(tags).gauge()).isNotNull();
		tags = Tags.of('path', path2.getAbsolutePath());
		assertThat(meterRegistry.get('disk.free').tags(tags).gauge()).isNotNull();
		assertThat(meterRegistry.get('disk.total').tags(tags).gauge()).isNotNull();
	}
	@Test
	void diskSpaceMetricsWithCustomTags() {
		MeterRegistry meterRegistry = new SimpleMeterRegistry();
		File path = new File('.');
		Tags customTags = Tags.of('foo', 'bar');
		DiskSpaceMetricsBinder metricsBinder = new DiskSpaceMetricsBinder(Collections.singletonList(path), customTags);
		metricsBinder.bindTo(meterRegistry);
		Tags tags = Tags.of('path', path.getAbsolutePath(), 'foo', 'bar');
		assertThat(meterRegistry.get('disk.free').tags(tags).gauge()).isNotNull();
		assertThat(meterRegistry.get('disk.total').tags(tags).gauge()).isNotNull();
	}
}
/*
package org.springframework.boot.actuate.metrics;
/**
class MetricsEndpointWebIntegrationTests {
	private static final MeterRegistry registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, new MockClock());
	private final ObjectMapper mapper = new ObjectMapper();
	@WebEndpointTest
	@SuppressWarnings('unchecked')
	void listNames(WebTestClient client) throws IOException {
		String responseBody = client.get()
			.uri('/actuator/metrics')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.returnResult()
			.getResponseBody();
		Map<String, List<String>> names = this.mapper.readValue(responseBody, Map.class);
		assertThat(names.get('names')).containsOnlyOnce('jvm.memory.used');
	}
	@WebEndpointTest
	void selectByName(WebTestClient client) {
		client.get()
			.uri('/actuator/metrics/jvm.memory.used')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$.name')
			.isEqualTo('jvm.memory.used');
	}
	@WebEndpointTest
	void selectByTag(WebTestClient client) {
		client.get()
			.uri('/actuator/metrics/jvm.memory.used?tag=id:Compressed%20Class%20Space')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$.name')
			.isEqualTo('jvm.memory.used');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		MeterRegistry registry() {
			return registry;
		}
		@Bean
		MetricsEndpoint metricsEndpoint(MeterRegistry meterRegistry) {
			return new MetricsEndpoint(meterRegistry);
		}
		@Bean
		JvmMemoryMetrics jvmMemoryMetrics(MeterRegistry meterRegistry) {
			JvmMemoryMetrics memoryMetrics = new JvmMemoryMetrics();
			memoryMetrics.bindTo(meterRegistry);
			return memoryMetrics;
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.amqp;
/**
class RabbitMetricsTests {
	@Test
	void connectionFactoryIsInstrumented() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		SimpleMeterRegistry registry = new SimpleMeterRegistry();
		new RabbitMetrics(connectionFactory, null).bindTo(registry);
		registry.get('rabbitmq.connections');
	}
	@Test
	void connectionFactoryWithTagsIsInstrumented() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		SimpleMeterRegistry registry = new SimpleMeterRegistry();
		new RabbitMetrics(connectionFactory, Tags.of('env', 'prod')).bindTo(registry);
		assertThat(registry.get('rabbitmq.connections').tags('env', 'prod').meter()).isNotNull();
		assertThat(registry.find('rabbitmq.connections').tags('env', 'dev').meter()).isNull();
	}
}
/*
package org.springframework.boot.actuate.metrics.startup;
/**
class StartupTimeMetricsListenerTests {
	private MeterRegistry registry;
	private StartupTimeMetricsListener listener;
	@BeforeEach
	void setup() {
		this.registry = new SimpleMeterRegistry();
		this.listener = new StartupTimeMetricsListener(this.registry);
	}
	@Test
	void metricsRecordedWithoutCustomTags() {
		this.listener.onApplicationEvent(applicationStartedEvent(2000L));
		this.listener.onApplicationEvent(applicationReadyEvent(2200L));
		assertMetricExistsWithValue('application.started.time', 2000L);
		assertMetricExistsWithValue('application.ready.time', 2200L);
	}
	@Test
	void metricsRecordedWithCustomTagsAndMetricNames() {
		Tags tags = Tags.of('foo', 'bar');
		this.listener = new StartupTimeMetricsListener(this.registry, 'm1', 'm2', tags);
		this.listener.onApplicationEvent(applicationStartedEvent(1000L));
		this.listener.onApplicationEvent(applicationReadyEvent(1050L));
		assertMetricExistsWithCustomTagsAndValue('m1', tags, 1000L);
		assertMetricExistsWithCustomTagsAndValue('m2', tags, 1050L);
	}
	@Test
	void metricRecordedWithoutMainAppClassTag() {
		SpringApplication application = mock(SpringApplication.class);
		this.listener.onApplicationEvent(new ApplicationStartedEvent(application, null, null, Duration.ofSeconds(2)));
		TimeGauge applicationStartedGauge = this.registry.find('application.started.time').timeGauge();
		assertThat(applicationStartedGauge).isNotNull();
		assertThat(applicationStartedGauge.getId().getTags()).isEmpty();
	}
	@Test
	void metricRecordedWithoutMainAppClassTagAndAdditionalTags() {
		SpringApplication application = mock(SpringApplication.class);
		Tags tags = Tags.of('foo', 'bar');
		this.listener = new StartupTimeMetricsListener(this.registry, 'started', 'ready', tags);
		this.listener.onApplicationEvent(new ApplicationReadyEvent(application, null, null, Duration.ofSeconds(2)));
		TimeGauge applicationReadyGauge = this.registry.find('ready').timeGauge();
		assertThat(applicationReadyGauge).isNotNull();
		assertThat(applicationReadyGauge.getId().getTags()).containsExactlyElementsOf(tags);
	}
	@Test
	void metricsNotRecordedWhenStartupTimeNotAvailable() {
		this.listener.onApplicationEvent(applicationStartedEvent(null));
		this.listener.onApplicationEvent(applicationReadyEvent(null));
		assertThat(this.registry.find('application.started.time').timeGauge()).isNull();
		assertThat(this.registry.find('application.ready.time').timeGauge()).isNull();
	}
	private ApplicationStartedEvent applicationStartedEvent(Long startupTimeMs) {
		SpringApplication application = mock(SpringApplication.class);
		given(application.getMainApplicationClass()).willAnswer((invocation) -> TestMainApplication.class);
		return new ApplicationStartedEvent(application, null, null,
				(startupTimeMs != null) ? Duration.ofMillis(startupTimeMs) : null);
	}
	private ApplicationReadyEvent applicationReadyEvent(Long startupTimeMs) {
		SpringApplication application = mock(SpringApplication.class);
		given(application.getMainApplicationClass()).willAnswer((invocation) -> TestMainApplication.class);
		return new ApplicationReadyEvent(application, null, null,
				(startupTimeMs != null) ? Duration.ofMillis(startupTimeMs) : null);
	}
	private void assertMetricExistsWithValue(String metricName, long expectedValueInMillis) {
		assertMetricExistsWithCustomTagsAndValue(metricName, Tags.empty(), expectedValueInMillis);
	}
	private void assertMetricExistsWithCustomTagsAndValue(String metricName, Tags expectedCustomTags,
			Long expectedValueInMillis) {
		assertThat(this.registry.find(metricName)
			.tags(Tags.concat(expectedCustomTags, 'main.application.class', TestMainApplication.class.getName()))
			.timeGauge()).isNotNull()
			.extracting((m) -> m.value(TimeUnit.MILLISECONDS))
			.isEqualTo(expectedValueInMillis.doubleValue());
	}
	static class TestMainApplication {
	}
}
/*
package org.springframework.boot.actuate.metrics.r2dbc;
/**
class ConnectionPoolMetricsTests {
	private static final Tag testTag = Tag.of('test', 'yes');
	private static final Tag regionTag = Tag.of('region', 'eu-2');
	private CloseableConnectionFactory connectionFactory;
	@BeforeEach
	void init() {
		this.connectionFactory = H2ConnectionFactory.inMemory('db-' + UUID.randomUUID(), 'sa', '',
				Collections.singletonMap(H2ConnectionOption.DB_CLOSE_DELAY, '-1'));
	}
	@AfterEach
	void close() {
		if (this.connectionFactory != null) {
			StepVerifier.create(this.connectionFactory.close()).expectComplete().verify(Duration.ofSeconds(30));
		}
	}
	@Test
	void connectionFactoryIsInstrumented() {
		SimpleMeterRegistry registry = new SimpleMeterRegistry();
		ConnectionPool connectionPool = new ConnectionPool(
				ConnectionPoolConfiguration.builder(this.connectionFactory).initialSize(3).maxSize(7).build());
		ConnectionPoolMetrics metrics = new ConnectionPoolMetrics(connectionPool, 'test-pool',
				Tags.of(testTag, regionTag));
		metrics.bindTo(registry);
		connectionPool.warmup().as(StepVerifier::create).expectNext(3).expectComplete().verify(Duration.ofSeconds(30));
		// acquire two connections
		connectionPool.create()
			.as(StepVerifier::create)
			.expectNextCount(1)
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		connectionPool.create()
			.as(StepVerifier::create)
			.expectNextCount(1)
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		assertGauge(registry, 'r2dbc.pool.acquired', 2);
		assertGauge(registry, 'r2dbc.pool.allocated', 3);
		assertGauge(registry, 'r2dbc.pool.idle', 1);
		assertGauge(registry, 'r2dbc.pool.pending', 0);
		assertGauge(registry, 'r2dbc.pool.max.allocated', 7);
		assertGauge(registry, 'r2dbc.pool.max.pending', Integer.MAX_VALUE);
	}
	private void assertGauge(SimpleMeterRegistry registry, String metric, int expectedValue) {
		Gauge gauge = registry.get(metric).gauge();
		assertThat(gauge.value()).isEqualTo(expectedValue);
		assertThat(gauge.getId().getTags()).containsExactlyInAnyOrder(Tag.of('name', 'test-pool'), testTag, regionTag);
	}
}
/*
package org.springframework.boot.actuate.metrics.http;
/**
class OutcomeTests {
	@Test
	void outcomeForInformationalStatusIsInformational() {
		for (int status = 100; status < 200; status++) {
			assertThat(Outcome.forStatus(status)).isEqualTo(Outcome.INFORMATIONAL);
		}
	}
	@Test
	void outcomeForSuccessStatusIsSuccess() {
		for (int status = 200; status < 300; status++) {
			assertThat(Outcome.forStatus(status)).isEqualTo(Outcome.SUCCESS);
		}
	}
	@Test
	void outcomeForRedirectionStatusIsRedirection() {
		for (int status = 300; status < 400; status++) {
			assertThat(Outcome.forStatus(status)).isEqualTo(Outcome.REDIRECTION);
		}
	}
	@Test
	void outcomeForClientErrorStatusIsClientError() {
		for (int status = 400; status < 500; status++) {
			assertThat(Outcome.forStatus(status)).isEqualTo(Outcome.CLIENT_ERROR);
		}
	}
	@Test
	void outcomeForServerErrorStatusIsServerError() {
		for (int status = 500; status < 600; status++) {
			assertThat(Outcome.forStatus(status)).isEqualTo(Outcome.SERVER_ERROR);
		}
	}
	@Test
	void outcomeForStatusBelowLowestKnownSeriesIsUnknown() {
		assertThat(Outcome.forStatus(99)).isEqualTo(Outcome.UNKNOWN);
	}
	@Test
	void outcomeForStatusAboveHighestKnownSeriesIsUnknown() {
		assertThat(Outcome.forStatus(600)).isEqualTo(Outcome.UNKNOWN);
	}
}
/*
package org.springframework.boot.actuate.cassandra;
/**
class CassandraDriverHealthIndicatorTests {
	@Test
	void createWhenCqlSessionIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new CassandraDriverHealthIndicator(null));
	}
	@Test
	void healthWithOneHealthyNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void healthWithOneUnhealthyNodeShouldReturnDown() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.DOWN);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
	}
	@Test
	void healthWithOneUnknownNodeShouldReturnDown() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UNKNOWN);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
	}
	@Test
	void healthWithOneForcedDownNodeShouldReturnDown() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.FORCED_DOWN);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
	}
	@Test
	void healthWithOneHealthyNodeAndOneUnhealthyNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP, NodeState.DOWN);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void healthWithOneHealthyNodeAndOneUnknownNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP, NodeState.UNKNOWN);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void healthWithOneHealthyNodeAndOneForcedDownNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP, NodeState.FORCED_DOWN);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void healthWithNodeVersionShouldAddVersionDetail() {
		CqlSession session = mock(CqlSession.class);
		Metadata metadata = mock(Metadata.class);
		given(session.getMetadata()).willReturn(metadata);
		Node node = mock(Node.class);
		given(node.getState()).willReturn(NodeState.UP);
		given(node.getCassandraVersion()).willReturn(Version.V4_0_0);
		given(metadata.getNodes()).willReturn(createNodesWithRandomUUID(Collections.singletonList(node)));
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('version', Version.V4_0_0);
	}
	@Test
	void healthWithoutNodeVersionShouldNotAddVersionDetail() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP);
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).doesNotContainKey('version');
	}
	@Test
	void healthWithCassandraDownShouldReturnDown() {
		CqlSession session = mock(CqlSession.class);
		given(session.getMetadata()).willThrow(new DriverTimeoutException('Test Exception'));
		CassandraDriverHealthIndicator healthIndicator = new CassandraDriverHealthIndicator(session);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('error',
				DriverTimeoutException.class.getName() + ': Test Exception');
	}
	private CqlSession mockCqlSessionWithNodeState(NodeState... nodeStates) {
		CqlSession session = mock(CqlSession.class);
		Metadata metadata = mock(Metadata.class);
		List<Node> nodes = new ArrayList<>();
		for (NodeState nodeState : nodeStates) {
			Node node = mock(Node.class);
			given(node.getState()).willReturn(nodeState);
			nodes.add(node);
		}
		given(session.getMetadata()).willReturn(metadata);
		given(metadata.getNodes()).willReturn(createNodesWithRandomUUID(nodes));
		return session;
	}
	private Map<UUID, Node> createNodesWithRandomUUID(List<Node> nodes) {
		Map<UUID, Node> indexedNodes = new HashMap<>();
		nodes.forEach((node) -> indexedNodes.put(UUID.randomUUID(), node));
		return indexedNodes;
	}
}
/*
package org.springframework.boot.actuate.cassandra;
/**
class CassandraDriverReactiveHealthIndicatorTests {
	@Test
	void createWhenCqlSessionIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new CassandraDriverReactiveHealthIndicator(null));
	}
	@Test
	void healthWithOneHealthyNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.UP))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithOneUnhealthyNodeShouldReturnDown() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.DOWN);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.DOWN))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithOneUnknownNodeShouldReturnDown() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UNKNOWN);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.DOWN))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithOneForcedDownNodeShouldReturnDown() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.FORCED_DOWN);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.DOWN))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithOneHealthyNodeAndOneUnhealthyNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP, NodeState.DOWN);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.UP))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithOneHealthyNodeAndOneUnknownNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP, NodeState.UNKNOWN);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.UP))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithOneHealthyNodeAndOneForcedDownNodeShouldReturnUp() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP, NodeState.FORCED_DOWN);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.UP))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithNodeVersionShouldAddVersionDetail() {
		CqlSession session = mock(CqlSession.class);
		Metadata metadata = mock(Metadata.class);
		given(session.getMetadata()).willReturn(metadata);
		Node node = mock(Node.class);
		given(node.getState()).willReturn(NodeState.UP);
		given(node.getCassandraVersion()).willReturn(Version.V4_0_0);
		given(metadata.getNodes()).willReturn(createNodesWithRandomUUID(Collections.singletonList(node)));
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.UP);
			assertThat(h.getDetails()).containsOnlyKeys('version');
			assertThat(h.getDetails()).containsEntry('version', Version.V4_0_0);
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithoutNodeVersionShouldNotAddVersionDetail() {
		CqlSession session = mockCqlSessionWithNodeState(NodeState.UP);
		CassandraDriverReactiveHealthIndicator healthIndicator = new CassandraDriverReactiveHealthIndicator(session);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.UP);
			assertThat(h.getDetails()).doesNotContainKey('version');
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWithCassandraDownShouldReturnDown() {
		CqlSession session = mock(CqlSession.class);
		given(session.getMetadata()).willThrow(new DriverTimeoutException('Test Exception'));
		CassandraDriverReactiveHealthIndicator cassandraReactiveHealthIndicator = new CassandraDriverReactiveHealthIndicator(
				session);
		Mono<Health> health = cassandraReactiveHealthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.DOWN);
			assertThat(h.getDetails()).containsOnlyKeys('error');
			assertThat(h.getDetails()).containsEntry('error',
					DriverTimeoutException.class.getName() + ': Test Exception');
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	private CqlSession mockCqlSessionWithNodeState(NodeState... nodeStates) {
		CqlSession session = mock(CqlSession.class);
		Metadata metadata = mock(Metadata.class);
		List<Node> nodes = new ArrayList<>();
		for (NodeState nodeState : nodeStates) {
			Node node = mock(Node.class);
			given(node.getState()).willReturn(nodeState);
			nodes.add(node);
		}
		given(session.getMetadata()).willReturn(metadata);
		given(metadata.getNodes()).willReturn(createNodesWithRandomUUID(nodes));
		return session;
	}
	private Map<UUID, Node> createNodesWithRandomUUID(List<Node> nodes) {
		Map<UUID, Node> indexedNodes = new HashMap<>();
		nodes.forEach((node) -> indexedNodes.put(UUID.randomUUID(), node));
		return indexedNodes;
	}
}
/*
package org.springframework.boot.actuate.audit;
/**
class AuditEventsEndpointTests {
	private final AuditEventRepository repository = mock(AuditEventRepository.class);
	private final AuditEventsEndpoint endpoint = new AuditEventsEndpoint(this.repository);
	private final AuditEvent event = new AuditEvent('principal', 'type', Collections.singletonMap('a', 'alpha'));
	@Test
	void eventsWithType() {
		given(this.repository.find(null, null, 'type')).willReturn(Collections.singletonList(this.event));
		List<AuditEvent> result = this.endpoint.events(null, null, 'type').getEvents();
		assertThat(result).isEqualTo(Collections.singletonList(this.event));
	}
	@Test
	void eventsCreatedAfter() {
		OffsetDateTime now = OffsetDateTime.now();
		given(this.repository.find(null, now.toInstant(), null)).willReturn(Collections.singletonList(this.event));
		List<AuditEvent> result = this.endpoint.events(null, now, null).getEvents();
		assertThat(result).isEqualTo(Collections.singletonList(this.event));
	}
	@Test
	void eventsWithPrincipal() {
		given(this.repository.find('Joan', null, null)).willReturn(Collections.singletonList(this.event));
		List<AuditEvent> result = this.endpoint.events('Joan', null, null).getEvents();
		assertThat(result).isEqualTo(Collections.singletonList(this.event));
	}
}
/*
package org.springframework.boot.actuate.audit;
/**
class AuditEventTests {
	@Test
	void nowEvent() {
		AuditEvent event = new AuditEvent('phil', 'UNKNOWN', Collections.singletonMap('a', 'b'));
		assertThat(event.getData()).containsEntry('a', 'b');
		assertThat(event.getType()).isEqualTo('UNKNOWN');
		assertThat(event.getPrincipal()).isEqualTo('phil');
		assertThat(event.getTimestamp()).isNotNull();
	}
	@Test
	void convertStringsToData() {
		AuditEvent event = new AuditEvent('phil', 'UNKNOWN', 'a=b', 'c=d');
		assertThat(event.getData()).containsEntry('a', 'b');
		assertThat(event.getData()).containsEntry('c', 'd');
	}
	@Test
	void nullPrincipalIsMappedToEmptyString() {
		AuditEvent auditEvent = new AuditEvent(null, 'UNKNOWN', Collections.singletonMap('a', 'b'));
		assertThat(auditEvent.getPrincipal()).isEmpty();
	}
	@Test
	void nullTimestamp() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new AuditEvent(null, 'phil', 'UNKNOWN', Collections.singletonMap('a', 'b')))
			.withMessageContaining('Timestamp must not be null');
	}
	@Test
	void nullType() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new AuditEvent('phil', null, Collections.singletonMap('a', 'b')))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void jsonFormat() throws Exception {
		AuditEvent event = new AuditEvent('johannes', 'UNKNOWN',
				Collections.singletonMap('type', (Object) 'BadCredentials'));
		String json = Jackson2ObjectMapperBuilder.json().build().writeValueAsString(event);
		JSONObject jsonObject = new JSONObject(json);
		assertThat(jsonObject.getString('type')).isEqualTo('UNKNOWN');
		assertThat(jsonObject.getJSONObject('data').getString('type')).isEqualTo('BadCredentials');
	}
}
/*
package org.springframework.boot.actuate.audit;
/**
class AuditEventsEndpointWebIntegrationTests {
	@WebEndpointTest
	void allEvents(WebTestClient client) {
		client.get()
			.uri((builder) -> builder.path('/actuator/auditevents').build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('events.[*].principal')
			.isEqualTo(new JSONArray().appendElement('admin').appendElement('admin').appendElement('user'));
	}
	@WebEndpointTest
	void eventsAfter(WebTestClient client) {
		client.get()
			.uri((builder) -> builder.path('/actuator/auditevents')
				.queryParam('after', '2016-11-01T13:00:00%2B00:00')
				.build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('events')
			.isEmpty();
	}
	@WebEndpointTest
	void eventsWithPrincipal(WebTestClient client) {
		client.get()
			.uri((builder) -> builder.path('/actuator/auditevents').queryParam('principal', 'user').build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('events.[*].principal')
			.isEqualTo(new JSONArray().appendElement('user'));
	}
	@WebEndpointTest
	void eventsWithType(WebTestClient client) {
		client.get()
			.uri((builder) -> builder.path('/actuator/auditevents').queryParam('type', 'logout').build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('events.[*].principal')
			.isEqualTo(new JSONArray().appendElement('admin'))
			.jsonPath('events.[*].type')
			.isEqualTo(new JSONArray().appendElement('logout'));
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		AuditEventRepository auditEventsRepository() {
			AuditEventRepository repository = new InMemoryAuditEventRepository(3);
			repository.add(createEvent('2016-11-01T11:00:00Z', 'admin', 'login'));
			repository.add(createEvent('2016-11-01T12:00:00Z', 'admin', 'logout'));
			repository.add(createEvent('2016-11-01T12:00:00Z', 'user', 'login'));
			return repository;
		}
		@Bean
		AuditEventsEndpoint auditEventsEndpoint(AuditEventRepository auditEventRepository) {
			return new AuditEventsEndpoint(auditEventRepository);
		}
		private AuditEvent createEvent(String instant, String principal, String type) {
			return new AuditEvent(Instant.parse(instant), principal, type, Collections.emptyMap());
		}
	}
}
/*
package org.springframework.boot.actuate.audit;
/**
class InMemoryAuditEventRepositoryTests {
	@Test
	void lessThanCapacity() {
		InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();
		repository.add(new AuditEvent('dave', 'a'));
		repository.add(new AuditEvent('dave', 'b'));
		List<AuditEvent> events = repository.find('dave', null, null);
		assertThat(events).hasSize(2);
		assertThat(events.get(0).getType()).isEqualTo('a');
		assertThat(events.get(1).getType()).isEqualTo('b');
	}
	@Test
	void capacity() {
		InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository(2);
		repository.add(new AuditEvent('dave', 'a'));
		repository.add(new AuditEvent('dave', 'b'));
		repository.add(new AuditEvent('dave', 'c'));
		List<AuditEvent> events = repository.find('dave', null, null);
		assertThat(events).hasSize(2);
		assertThat(events.get(0).getType()).isEqualTo('b');
		assertThat(events.get(1).getType()).isEqualTo('c');
	}
	@Test
	void addNullAuditEvent() {
		InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();
		assertThatIllegalArgumentException().isThrownBy(() -> repository.add(null))
			.withMessageContaining('AuditEvent must not be null');
	}
	@Test
	void findByPrincipal() {
		InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();
		repository.add(new AuditEvent('dave', 'a'));
		repository.add(new AuditEvent('phil', 'b'));
		repository.add(new AuditEvent('dave', 'c'));
		repository.add(new AuditEvent('phil', 'd'));
		List<AuditEvent> events = repository.find('dave', null, null);
		assertThat(events).hasSize(2);
		assertThat(events.get(0).getType()).isEqualTo('a');
		assertThat(events.get(1).getType()).isEqualTo('c');
	}
	@Test
	void findByPrincipalAndType() {
		InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();
		repository.add(new AuditEvent('dave', 'a'));
		repository.add(new AuditEvent('phil', 'b'));
		repository.add(new AuditEvent('dave', 'c'));
		repository.add(new AuditEvent('phil', 'd'));
		List<AuditEvent> events = repository.find('dave', null, 'a');
		assertThat(events).hasSize(1);
		assertThat(events.get(0).getPrincipal()).isEqualTo('dave');
		assertThat(events.get(0).getType()).isEqualTo('a');
	}
	@Test
	void findByDate() {
		Instant instant = Instant.now();
		Map<String, Object> data = new HashMap<>();
		InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();
		repository.add(new AuditEvent(instant, 'dave', 'a', data));
		repository.add(new AuditEvent(instant.plus(1, ChronoUnit.DAYS), 'phil', 'b', data));
		repository.add(new AuditEvent(instant.plus(2, ChronoUnit.DAYS), 'dave', 'c', data));
		repository.add(new AuditEvent(instant.plus(3, ChronoUnit.DAYS), 'phil', 'd', data));
		Instant after = instant.plus(1, ChronoUnit.DAYS);
		List<AuditEvent> events = repository.find(null, after, null);
		assertThat(events).hasSize(2);
		assertThat(events.get(0).getType()).isEqualTo('c');
		assertThat(events.get(1).getType()).isEqualTo('d');
		events = repository.find('dave', after, null);
		assertThat(events).hasSize(1);
		assertThat(events.get(0).getType()).isEqualTo('c');
	}
}
/*
package org.springframework.boot.actuate.audit.listener;
/**
class AuditListenerTests {
	@Test
	void testStoredEvents() {
		AuditEventRepository repository = mock(AuditEventRepository.class);
		AuditEvent event = new AuditEvent('principal', 'type', Collections.emptyMap());
		AuditListener listener = new AuditListener(repository);
		listener.onApplicationEvent(new AuditApplicationEvent(event));
		then(repository).should().add(event);
	}
}
/*
package org.springframework.boot.actuate.availability;
/**
class LivenessStateHealthIndicatorTests {
	private ApplicationAvailability availability;
	private LivenessStateHealthIndicator healthIndicator;
	@BeforeEach
	void setUp() {
		this.availability = mock(ApplicationAvailability.class);
		this.healthIndicator = new LivenessStateHealthIndicator(this.availability);
	}
	@Test
	void livenessIsLive() {
		given(this.availability.getLivenessState()).willReturn(LivenessState.CORRECT);
		assertThat(this.healthIndicator.health().getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void livenessIsBroken() {
		given(this.availability.getLivenessState()).willReturn(LivenessState.BROKEN);
		assertThat(this.healthIndicator.health().getStatus()).isEqualTo(Status.DOWN);
	}
}
/*
package org.springframework.boot.actuate.availability;
/**
class ReadinessStateHealthIndicatorTests {
	private ApplicationAvailability availability;
	private ReadinessStateHealthIndicator healthIndicator;
	@BeforeEach
	void setUp() {
		this.availability = mock(ApplicationAvailability.class);
		this.healthIndicator = new ReadinessStateHealthIndicator(this.availability);
	}
	@Test
	void readinessIsReady() {
		given(this.availability.getReadinessState()).willReturn(ReadinessState.ACCEPTING_TRAFFIC);
		assertThat(this.healthIndicator.health().getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void readinessIsUnready() {
		given(this.availability.getReadinessState()).willReturn(ReadinessState.REFUSING_TRAFFIC);
		assertThat(this.healthIndicator.health().getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
	}
}
/*
package org.springframework.boot.actuate.availability;
/**
@ExtendWith(MockitoExtension.class)
class AvailabilityStateHealthIndicatorTests {
	@Mock
	private ApplicationAvailability applicationAvailability;
	@Test
	void createWhenApplicationAvailabilityIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new AvailabilityStateHealthIndicator(null, LivenessState.class, (statusMappings) -> {
			}))
			.withMessage('ApplicationAvailability must not be null');
	}
	@Test
	void createWhenStateTypeIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(
				() -> new AvailabilityStateHealthIndicator(this.applicationAvailability, null, (statusMappings) -> {
				}))
			.withMessage('StateType must not be null');
	}
	@Test
	void createWhenStatusMappingIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new AvailabilityStateHealthIndicator(this.applicationAvailability, LivenessState.class, null))
			.withMessage('StatusMappings must not be null');
	}
	@Test
	void createWhenStatusMappingDoesNotCoverAllEnumsThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new AvailabilityStateHealthIndicator(this.applicationAvailability, LivenessState.class,
					(statusMappings) -> statusMappings.add(LivenessState.CORRECT, Status.UP)))
			.withMessage('StatusMappings does not include BROKEN');
	}
	@Test
	void healthReturnsMappedStatus() {
		AvailabilityStateHealthIndicator indicator = new AvailabilityStateHealthIndicator(this.applicationAvailability,
				LivenessState.class, (statusMappings) -> {
					statusMappings.add(LivenessState.CORRECT, Status.UP);
					statusMappings.add(LivenessState.BROKEN, Status.DOWN);
				});
		given(this.applicationAvailability.getState(LivenessState.class)).willReturn(LivenessState.BROKEN);
		assertThat(indicator.getHealth(false).getStatus()).isEqualTo(Status.DOWN);
	}
	@Test
	void healthReturnsDefaultStatus() {
		AvailabilityStateHealthIndicator indicator = new AvailabilityStateHealthIndicator(this.applicationAvailability,
				LivenessState.class, (statusMappings) -> {
					statusMappings.add(LivenessState.CORRECT, Status.UP);
					statusMappings.addDefaultStatus(Status.UNKNOWN);
				});
		given(this.applicationAvailability.getState(LivenessState.class)).willReturn(LivenessState.BROKEN);
		assertThat(indicator.getHealth(false).getStatus()).isEqualTo(Status.UNKNOWN);
	}
	@Test
	void healthWhenNotEnumReturnsMappedStatus() {
		AvailabilityStateHealthIndicator indicator = new AvailabilityStateHealthIndicator(this.applicationAvailability,
				TestAvailabilityState.class, (statusMappings) -> {
					statusMappings.add(TestAvailabilityState.ONE, Status.UP);
					statusMappings.addDefaultStatus(Status.DOWN);
				});
		given(this.applicationAvailability.getState(TestAvailabilityState.class)).willReturn(TestAvailabilityState.TWO);
		assertThat(indicator.getHealth(false).getStatus()).isEqualTo(Status.DOWN);
	}
	static class TestAvailabilityState implements AvailabilityState {
		static final TestAvailabilityState ONE = new TestAvailabilityState();
		static final TestAvailabilityState TWO = new TestAvailabilityState();
	}
}
/*
package org.springframework.boot.actuate.mail;
/**
class MailHealthIndicatorTests {
	private JavaMailSenderImpl mailSender;
	private MailHealthIndicator indicator;
	@BeforeEach
	void setup() {
		Session session = Session.getDefaultInstance(new Properties());
		session.addProvider(new Provider(Type.TRANSPORT, 'success', SuccessTransport.class.getName(), 'Test', '1.0.0'));
		this.mailSender = mock(JavaMailSenderImpl.class);
		given(this.mailSender.getHost()).willReturn('smtp.acme.org');
		given(this.mailSender.getSession()).willReturn(session);
		this.indicator = new MailHealthIndicator(this.mailSender);
	}
	@Test
	void smtpOnDefaultHostAndPortIsUp() {
		given(this.mailSender.getHost()).willReturn(null);
		given(this.mailSender.getPort()).willReturn(-1);
		given(this.mailSender.getProtocol()).willReturn('success');
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).doesNotContainKey('location');
	}
	@Test
	void smtpOnDefaultHostAndPortIsDown() throws MessagingException {
		given(this.mailSender.getHost()).willReturn(null);
		given(this.mailSender.getPort()).willReturn(-1);
		willThrow(new MessagingException('A test exception')).given(this.mailSender).testConnection();
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).doesNotContainKey('location');
		Object errorMessage = health.getDetails().get('error');
		assertThat(errorMessage).isNotNull();
		assertThat(errorMessage.toString()).contains('A test exception');
	}
	@Test
	void smtpOnDefaultHostAndCustomPortIsUp() {
		given(this.mailSender.getHost()).willReturn(null);
		given(this.mailSender.getPort()).willReturn(1234);
		given(this.mailSender.getProtocol()).willReturn('success');
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails().get('location')).isEqualTo(':1234');
	}
	@Test
	void smtpOnDefaultHostAndCustomPortIsDown() throws MessagingException {
		given(this.mailSender.getHost()).willReturn(null);
		given(this.mailSender.getPort()).willReturn(1234);
		willThrow(new MessagingException('A test exception')).given(this.mailSender).testConnection();
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails().get('location')).isEqualTo(':1234');
		Object errorMessage = health.getDetails().get('error');
		assertThat(errorMessage).isNotNull();
		assertThat(errorMessage.toString()).contains('A test exception');
	}
	@Test
	void smtpOnDefaultPortIsUp() {
		given(this.mailSender.getPort()).willReturn(-1);
		given(this.mailSender.getProtocol()).willReturn('success');
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('location', 'smtp.acme.org');
	}
	@Test
	void smtpOnDefaultPortIsDown() throws MessagingException {
		given(this.mailSender.getPort()).willReturn(-1);
		willThrow(new MessagingException('A test exception')).given(this.mailSender).testConnection();
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('location', 'smtp.acme.org');
		Object errorMessage = health.getDetails().get('error');
		assertThat(errorMessage).isNotNull();
		assertThat(errorMessage.toString()).contains('A test exception');
	}
	@Test
	void smtpOnCustomPortIsUp() {
		given(this.mailSender.getPort()).willReturn(1234);
		given(this.mailSender.getProtocol()).willReturn('success');
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('location', 'smtp.acme.org:1234');
	}
	@Test
	void smtpOnCustomPortIsDown() throws MessagingException {
		given(this.mailSender.getPort()).willReturn(1234);
		willThrow(new MessagingException('A test exception')).given(this.mailSender).testConnection();
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('location', 'smtp.acme.org:1234');
		Object errorMessage = health.getDetails().get('error');
		assertThat(errorMessage).isNotNull();
		assertThat(errorMessage.toString()).contains('A test exception');
	}
	static class SuccessTransport extends Transport {
		SuccessTransport(Session session, URLName urlName) {
			super(session, urlName);
		}
		@Override
		public void connect(String host, int port, String user, String password) {
		}
		@Override
		public void sendMessage(Message msg, Address[] addresses) {
		}
	}
}
/*
package org.springframework.boot.actuate.security;
/**
class AuthorizationAuditListenerTests {
	private final AuthorizationAuditListener listener = new AuthorizationAuditListener();
	private final ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
	@BeforeEach
	void init() {
		this.listener.setApplicationEventPublisher(this.publisher);
	}
	@Test
	void authorizationDeniedEvent() {
		AuthorizationResult decision = new AuthorizationDecision(false);
		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken('spring',
				'password');
		authentication.setDetails('details');
		AuthorizationDeniedEvent<?> authorizationEvent = new AuthorizationDeniedEvent<>(() -> authentication, '',
				decision);
		AuditEvent auditEvent = handleAuthorizationEvent(authorizationEvent).getAuditEvent();
		assertThat(auditEvent.getPrincipal()).isEqualTo('spring');
		assertThat(auditEvent.getType()).isEqualTo(AuthorizationAuditListener.AUTHORIZATION_FAILURE);
		assertThat(auditEvent.getData()).containsEntry('details', 'details');
	}
	@Test
	void authorizationDeniedEventWhenAuthenticationIsNotAvailable() {
		AuthorizationResult decision = new AuthorizationDecision(false);
		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken('spring',
				'password');
		authentication.setDetails('details');
		AuthorizationDeniedEvent<?> authorizationEvent = new AuthorizationDeniedEvent<>(() -> {
			throw new RuntimeException('No authentication');
		}, '', decision);
		AuditEvent auditEvent = handleAuthorizationEvent(authorizationEvent).getAuditEvent();
		assertThat(auditEvent.getPrincipal()).isEqualTo('<unknown>');
		assertThat(auditEvent.getType()).isEqualTo(AuthorizationAuditListener.AUTHORIZATION_FAILURE);
		assertThat(auditEvent.getData()).doesNotContainKey('details');
	}
	@Test
	void authorizationDeniedEventWhenAuthenticationDoesNotHaveDetails() {
		AuthorizationResult decision = new AuthorizationDecision(false);
		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken('spring',
				'password');
		AuthorizationDeniedEvent<?> authorizationEvent = new AuthorizationDeniedEvent<>(() -> authentication, '',
				decision);
		AuditEvent auditEvent = handleAuthorizationEvent(authorizationEvent).getAuditEvent();
		assertThat(auditEvent.getPrincipal()).isEqualTo('spring');
		assertThat(auditEvent.getType()).isEqualTo(AuthorizationAuditListener.AUTHORIZATION_FAILURE);
		assertThat(auditEvent.getData()).doesNotContainKey('details');
	}
	private AuditApplicationEvent handleAuthorizationEvent(AuthorizationEvent event) {
		ArgumentCaptor<AuditApplicationEvent> eventCaptor = ArgumentCaptor.forClass(AuditApplicationEvent.class);
		this.listener.onApplicationEvent(event);
		then(this.publisher).should().publishEvent(eventCaptor.capture());
		return eventCaptor.getValue();
	}
}
/*
package org.springframework.boot.actuate.security;
/**
class AuthenticationAuditListenerTests {
	private final AuthenticationAuditListener listener = new AuthenticationAuditListener();
	private final ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
	@BeforeEach
	void init() {
		this.listener.setApplicationEventPublisher(this.publisher);
	}
	@Test
	void testAuthenticationSuccess() {
		AuditApplicationEvent event = handleAuthenticationEvent(
				new AuthenticationSuccessEvent(new UsernamePasswordAuthenticationToken('user', 'password')));
		assertThat(event.getAuditEvent().getType()).isEqualTo(AuthenticationAuditListener.AUTHENTICATION_SUCCESS);
	}
	@Test
	void testLogoutSuccess() {
		AuditApplicationEvent event = handleAuthenticationEvent(
				new LogoutSuccessEvent(new UsernamePasswordAuthenticationToken('user', 'password')));
		assertThat(event.getAuditEvent().getType()).isEqualTo(AuthenticationAuditListener.LOGOUT_SUCCESS);
	}
	@Test
	void testOtherAuthenticationSuccess() {
		this.listener.onApplicationEvent(new InteractiveAuthenticationSuccessEvent(
				new UsernamePasswordAuthenticationToken('user', 'password'), getClass()));
		// No need to audit this one (it shadows a regular AuthenticationSuccessEvent)
		then(this.publisher).should(never()).publishEvent(any(ApplicationEvent.class));
	}
	@Test
	void testAuthenticationFailed() {
		AuditApplicationEvent event = handleAuthenticationEvent(new AuthenticationFailureExpiredEvent(
				new UsernamePasswordAuthenticationToken('user', 'password'), new BadCredentialsException('Bad user')));
		assertThat(event.getAuditEvent().getType()).isEqualTo(AuthenticationAuditListener.AUTHENTICATION_FAILURE);
	}
	@Test
	void testAuthenticationSwitch() {
		AuditApplicationEvent event = handleAuthenticationEvent(
				new AuthenticationSwitchUserEvent(new UsernamePasswordAuthenticationToken('user', 'password'),
						new User('user', 'password', AuthorityUtils.commaSeparatedStringToAuthorityList('USER'))));
		assertThat(event.getAuditEvent().getType()).isEqualTo(AuthenticationAuditListener.AUTHENTICATION_SWITCH);
	}
	@Test
	void testAuthenticationSwitchBackToAnonymous() {
		AuditApplicationEvent event = handleAuthenticationEvent(
				new AuthenticationSwitchUserEvent(new UsernamePasswordAuthenticationToken('user', 'password'), null));
		assertThat(event.getAuditEvent().getType()).isEqualTo(AuthenticationAuditListener.AUTHENTICATION_SWITCH);
	}
	@Test
	void testDetailsAreIncludedInAuditEvent() {
		Object details = new Object();
		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken('user',
				'password');
		authentication.setDetails(details);
		AuditApplicationEvent event = handleAuthenticationEvent(
				new AuthenticationFailureExpiredEvent(authentication, new BadCredentialsException('Bad user')));
		assertThat(event.getAuditEvent().getType()).isEqualTo(AuthenticationAuditListener.AUTHENTICATION_FAILURE);
		assertThat(event.getAuditEvent().getData()).containsEntry('details', details);
	}
	private AuditApplicationEvent handleAuthenticationEvent(AbstractAuthenticationEvent event) {
		ArgumentCaptor<AuditApplicationEvent> eventCaptor = ArgumentCaptor.forClass(AuditApplicationEvent.class);
		this.listener.onApplicationEvent(event);
		then(this.publisher).should().publishEvent(eventCaptor.capture());
		return eventCaptor.getValue();
	}
}
/*
package org.springframework.boot.actuate.couchbase;
/**
class CouchbaseReactiveHealthIndicatorTests {
	@Test
	@SuppressWarnings('unchecked')
	void couchbaseClusterIsUp() {
		Cluster cluster = mock(Cluster.class);
		CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster);
		Map<ServiceType, List<EndpointDiagnostics>> endpoints = Collections.singletonMap(ServiceType.KV,
				Collections.singletonList(new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTED,
						CircuitBreaker.State.DISABLED, '127.0.0.1', '127.0.0.1', Optional.empty(), Optional.of(1234L),
						Optional.of('endpoint-1'), Optional.empty())));
		DiagnosticsResult diagnostics = new DiagnosticsResult(endpoints, 'test-sdk', 'test-id');
		ReactiveCluster reactiveCluster = mock(ReactiveCluster.class);
		given(reactiveCluster.diagnostics()).willReturn(Mono.just(diagnostics));
		given(cluster.reactive()).willReturn(reactiveCluster);
		Health health = healthIndicator.health().block(Duration.ofSeconds(30));
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('sdk', 'test-sdk');
		assertThat(health.getDetails()).containsKey('endpoints');
		assertThat((List<Map<String, Object>>) health.getDetails().get('endpoints')).hasSize(1);
		then(reactiveCluster).should().diagnostics();
	}
	@Test
	@SuppressWarnings('unchecked')
	void couchbaseClusterIsDown() {
		Cluster cluster = mock(Cluster.class);
		CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster);
		Map<ServiceType, List<EndpointDiagnostics>> endpoints = Collections.singletonMap(ServiceType.KV,
				Arrays.asList(
						new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTED, CircuitBreaker.State.DISABLED,
								'127.0.0.1', '127.0.0.1', Optional.empty(), Optional.of(1234L),
								Optional.of('endpoint-1'), Optional.empty()),
						new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTING, CircuitBreaker.State.DISABLED,
								'127.0.0.1', '127.0.0.1', Optional.empty(), Optional.of(1234L),
								Optional.of('endpoint-2'), Optional.empty())));
		DiagnosticsResult diagnostics = new DiagnosticsResult(endpoints, 'test-sdk', 'test-id');
		ReactiveCluster reactiveCluster = mock(ReactiveCluster.class);
		given(reactiveCluster.diagnostics()).willReturn(Mono.just(diagnostics));
		given(cluster.reactive()).willReturn(reactiveCluster);
		Health health = healthIndicator.health().block(Duration.ofSeconds(30));
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('sdk', 'test-sdk');
		assertThat(health.getDetails()).containsKey('endpoints');
		assertThat((List<Map<String, Object>>) health.getDetails().get('endpoints')).hasSize(2);
		then(reactiveCluster).should().diagnostics();
	}
}
/*
package org.springframework.boot.actuate.couchbase;
/**
class CouchbaseHealthIndicatorTests {
	@Test
	@SuppressWarnings('unchecked')
	void couchbaseClusterIsUp() {
		Cluster cluster = mock(Cluster.class);
		CouchbaseHealthIndicator healthIndicator = new CouchbaseHealthIndicator(cluster);
		Map<ServiceType, List<EndpointDiagnostics>> endpoints = Collections.singletonMap(ServiceType.KV,
				Collections.singletonList(new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTED,
						CircuitBreaker.State.DISABLED, '127.0.0.1', '127.0.0.1', Optional.empty(), Optional.of(1234L),
						Optional.of('endpoint-1'), Optional.empty())));
		DiagnosticsResult diagnostics = new DiagnosticsResult(endpoints, 'test-sdk', 'test-id');
		given(cluster.diagnostics()).willReturn(diagnostics);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('sdk', 'test-sdk');
		assertThat(health.getDetails()).containsKey('endpoints');
		assertThat((List<Map<String, Object>>) health.getDetails().get('endpoints')).hasSize(1);
		then(cluster).should().diagnostics();
	}
	@Test
	@SuppressWarnings('unchecked')
	void couchbaseClusterIsDown() {
		Cluster cluster = mock(Cluster.class);
		CouchbaseHealthIndicator healthIndicator = new CouchbaseHealthIndicator(cluster);
		Map<ServiceType, List<EndpointDiagnostics>> endpoints = Collections.singletonMap(ServiceType.KV,
				Arrays.asList(
						new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTED, CircuitBreaker.State.DISABLED,
								'127.0.0.1', '127.0.0.1', Optional.empty(), Optional.of(1234L),
								Optional.of('endpoint-1'), Optional.empty()),
						new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTING, CircuitBreaker.State.DISABLED,
								'127.0.0.1', '127.0.0.1', Optional.empty(), Optional.of(1234L),
								Optional.of('endpoint-2'), Optional.empty())));
		DiagnosticsResult diagnostics = new DiagnosticsResult(endpoints, 'test-sdk', 'test-id');
		given(cluster.diagnostics()).willReturn(diagnostics);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('sdk', 'test-sdk');
		assertThat(health.getDetails()).containsKey('endpoints');
		assertThat((List<Map<String, Object>>) health.getDetails().get('endpoints')).hasSize(2);
		then(cluster).should().diagnostics();
	}
}
/*
package org.springframework.boot.actuate.session;
/**
class SessionsEndpointWebIntegrationTests {
	private static final Session session = new MapSession();
	@SuppressWarnings('unchecked')
	private static final FindByIndexNameSessionRepository<Session> repository = mock(
			FindByIndexNameSessionRepository.class);
	@WebEndpointTest(infrastructure = { Infrastructure.JERSEY, Infrastructure.MVC })
	void sessionsForUsernameWithoutUsernameParam(WebTestClient client) {
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions').build())
			.exchange()
			.expectStatus()
			.isBadRequest();
	}
	@WebEndpointTest(infrastructure = { Infrastructure.JERSEY, Infrastructure.MVC })
	void sessionsForUsernameNoResults(WebTestClient client) {
		given(repository.findByPrincipalName('user')).willReturn(Collections.emptyMap());
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions').queryParam('username', 'user').build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('sessions')
			.isEmpty();
	}
	@WebEndpointTest(infrastructure = { Infrastructure.JERSEY, Infrastructure.MVC })
	void sessionsForUsernameFound(WebTestClient client) {
		given(repository.findByPrincipalName('user')).willReturn(Collections.singletonMap(session.getId(), session));
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions').queryParam('username', 'user').build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('sessions.[*].id')
			.isEqualTo(new JSONArray().appendElement(session.getId()));
	}
	@WebEndpointTest(infrastructure = { Infrastructure.JERSEY, Infrastructure.MVC })
	void sessionForIdNotFound(WebTestClient client) {
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions/session-id-not-found').build())
			.exchange()
			.expectStatus()
			.isNotFound();
	}
	@WebEndpointTest(infrastructure = { Infrastructure.JERSEY, Infrastructure.MVC })
	void deleteSession(WebTestClient client) {
		client.delete()
			.uri((builder) -> builder.path('/actuator/sessions/{id}').build(session.getId()))
			.exchange()
			.expectStatus()
			.isNoContent();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		SessionsEndpoint sessionsEndpoint() {
			return new SessionsEndpoint(repository, repository);
		}
	}
}
/*
package org.springframework.boot.actuate.session;
/**
class ReactiveSessionsEndpointWebIntegrationTests {
	private static final Session session = new MapSession();
	@SuppressWarnings('unchecked')
	private static final ReactiveSessionRepository<Session> sessionRepository = mock(ReactiveSessionRepository.class);
	@SuppressWarnings('unchecked')
	private static final ReactiveFindByIndexNameSessionRepository<Session> indexedSessionRepository = mock(
			ReactiveFindByIndexNameSessionRepository.class);
	@WebEndpointTest(infrastructure = Infrastructure.WEBFLUX)
	void sessionsForUsernameWithoutUsernameParam(WebTestClient client) {
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions').build())
			.exchange()
			.expectStatus()
			.is4xxClientError();
	}
	@WebEndpointTest(infrastructure = Infrastructure.WEBFLUX)
	void sessionsForUsernameNoResults(WebTestClient client) {
		given(indexedSessionRepository.findByPrincipalName('user')).willReturn(Mono.just(Collections.emptyMap()));
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions').queryParam('username', 'user').build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('sessions')
			.isEmpty();
	}
	@WebEndpointTest(infrastructure = Infrastructure.WEBFLUX)
	void sessionsForUsernameFound(WebTestClient client) {
		given(indexedSessionRepository.findByPrincipalName('user'))
			.willReturn(Mono.just(Collections.singletonMap(session.getId(), session)));
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions').queryParam('username', 'user').build())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('sessions.[*].id')
			.isEqualTo(new JSONArray().appendElement(session.getId()));
	}
	@WebEndpointTest(infrastructure = Infrastructure.WEBFLUX)
	void sessionForIdFound(WebTestClient client) {
		given(sessionRepository.findById(session.getId())).willReturn(Mono.just(session));
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions/{id}').build(session.getId()))
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('id')
			.isEqualTo(session.getId());
	}
	@WebEndpointTest(infrastructure = Infrastructure.WEBFLUX)
	void sessionForIdNotFound(WebTestClient client) {
		given(sessionRepository.findById('not-found')).willReturn(Mono.empty());
		client.get()
			.uri((builder) -> builder.path('/actuator/sessions/not-found').build())
			.exchange()
			.expectStatus()
			.isNotFound();
	}
	@WebEndpointTest(infrastructure = Infrastructure.WEBFLUX)
	void deleteSession(WebTestClient client) {
		given(sessionRepository.deleteById(session.getId())).willReturn(Mono.empty());
		client.delete()
			.uri((builder) -> builder.path('/actuator/sessions/{id}').build(session.getId()))
			.exchange()
			.expectStatus()
			.isNoContent();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		ReactiveSessionsEndpoint sessionsEndpoint() {
			return new ReactiveSessionsEndpoint(sessionRepository, indexedSessionRepository);
		}
	}
}
/*
package org.springframework.boot.actuate.session;
/**
class SessionsEndpointTests {
	private static final Session session = new MapSession();
	@SuppressWarnings('unchecked')
	private final SessionRepository<Session> sessionRepository = mock(SessionRepository.class);
	@SuppressWarnings('unchecked')
	private final FindByIndexNameSessionRepository<Session> indexedSessionRepository = mock(
			FindByIndexNameSessionRepository.class);
	private final SessionsEndpoint endpoint = new SessionsEndpoint(this.sessionRepository,
			this.indexedSessionRepository);
	@Test
	void sessionsForUsername() {
		given(this.indexedSessionRepository.findByPrincipalName('user'))
			.willReturn(Collections.singletonMap(session.getId(), session));
		List<SessionDescriptor> result = this.endpoint.sessionsForUsername('user').getSessions();
		assertThat(result).hasSize(1);
		assertThat(result.get(0).getId()).isEqualTo(session.getId());
		assertThat(result.get(0).getAttributeNames()).isEqualTo(session.getAttributeNames());
		assertThat(result.get(0).getCreationTime()).isEqualTo(session.getCreationTime());
		assertThat(result.get(0).getLastAccessedTime()).isEqualTo(session.getLastAccessedTime());
		assertThat(result.get(0).getMaxInactiveInterval()).isEqualTo(session.getMaxInactiveInterval().getSeconds());
		assertThat(result.get(0).isExpired()).isEqualTo(session.isExpired());
		then(this.indexedSessionRepository).should().findByPrincipalName('user');
	}
	@Test
	void sessionsForUsernameWhenNoIndexedRepository() {
		SessionsEndpoint endpoint = new SessionsEndpoint(this.sessionRepository, null);
		assertThat(endpoint.sessionsForUsername('user')).isNull();
	}
	@Test
	void getSession() {
		given(this.sessionRepository.findById(session.getId())).willReturn(session);
		SessionDescriptor result = this.endpoint.getSession(session.getId());
		assertThat(result.getId()).isEqualTo(session.getId());
		assertThat(result.getAttributeNames()).isEqualTo(session.getAttributeNames());
		assertThat(result.getCreationTime()).isEqualTo(session.getCreationTime());
		assertThat(result.getLastAccessedTime()).isEqualTo(session.getLastAccessedTime());
		assertThat(result.getMaxInactiveInterval()).isEqualTo(session.getMaxInactiveInterval().getSeconds());
		assertThat(result.isExpired()).isEqualTo(session.isExpired());
		then(this.sessionRepository).should().findById(session.getId());
	}
	@Test
	void getSessionWithIdNotFound() {
		given(this.sessionRepository.findById('not-found')).willReturn(null);
		assertThat(this.endpoint.getSession('not-found')).isNull();
		then(this.sessionRepository).should().findById('not-found');
	}
	@Test
	void deleteSession() {
		this.endpoint.deleteSession(session.getId());
		then(this.sessionRepository).should().deleteById(session.getId());
	}
}
/*
package org.springframework.boot.actuate.session;
/**
class ReactiveSessionsEndpointTests {
	private static final Session session = new MapSession();
	@SuppressWarnings('unchecked')
	private final ReactiveSessionRepository<Session> sessionRepository = mock(ReactiveSessionRepository.class);
	@SuppressWarnings('unchecked')
	private final ReactiveFindByIndexNameSessionRepository<Session> indexedSessionRepository = mock(
			ReactiveFindByIndexNameSessionRepository.class);
	private final ReactiveSessionsEndpoint endpoint = new ReactiveSessionsEndpoint(this.sessionRepository,
			this.indexedSessionRepository);
	@Test
	void sessionsForUsername() {
		given(this.indexedSessionRepository.findByPrincipalName('user'))
			.willReturn(Mono.just(Collections.singletonMap(session.getId(), session)));
		StepVerifier.create(this.endpoint.sessionsForUsername('user')).consumeNextWith((sessions) -> {
			List<SessionDescriptor> result = sessions.getSessions();
			assertThat(result).hasSize(1);
			assertThat(result.get(0).getId()).isEqualTo(session.getId());
			assertThat(result.get(0).getAttributeNames()).isEqualTo(session.getAttributeNames());
			assertThat(result.get(0).getCreationTime()).isEqualTo(session.getCreationTime());
			assertThat(result.get(0).getLastAccessedTime()).isEqualTo(session.getLastAccessedTime());
			assertThat(result.get(0).getMaxInactiveInterval()).isEqualTo(session.getMaxInactiveInterval().getSeconds());
			assertThat(result.get(0).isExpired()).isEqualTo(session.isExpired());
		}).expectComplete().verify(Duration.ofSeconds(1));
		then(this.indexedSessionRepository).should().findByPrincipalName('user');
	}
	@Test
	void sessionsForUsernameWhenNoIndexedRepository() {
		ReactiveSessionsEndpoint endpoint = new ReactiveSessionsEndpoint(this.sessionRepository, null);
		StepVerifier.create(endpoint.sessionsForUsername('user')).expectComplete().verify(Duration.ofSeconds(1));
	}
	@Test
	void getSession() {
		given(this.sessionRepository.findById(session.getId())).willReturn(Mono.just(session));
		StepVerifier.create(this.endpoint.getSession(session.getId())).consumeNextWith((result) -> {
			assertThat(result.getId()).isEqualTo(session.getId());
			assertThat(result.getAttributeNames()).isEqualTo(session.getAttributeNames());
			assertThat(result.getCreationTime()).isEqualTo(session.getCreationTime());
			assertThat(result.getLastAccessedTime()).isEqualTo(session.getLastAccessedTime());
			assertThat(result.getMaxInactiveInterval()).isEqualTo(session.getMaxInactiveInterval().getSeconds());
			assertThat(result.isExpired()).isEqualTo(session.isExpired());
		}).expectComplete().verify(Duration.ofSeconds(1));
		then(this.sessionRepository).should().findById(session.getId());
	}
	@Test
	void getSessionWithIdNotFound() {
		given(this.sessionRepository.findById('not-found')).willReturn(Mono.empty());
		StepVerifier.create(this.endpoint.getSession('not-found')).expectComplete().verify(Duration.ofSeconds(1));
		then(this.sessionRepository).should().findById('not-found');
	}
	@Test
	void deleteSession() {
		given(this.sessionRepository.deleteById(session.getId())).willReturn(Mono.empty());
		StepVerifier.create(this.endpoint.deleteSession(session.getId()))
			.expectComplete()
			.verify(Duration.ofSeconds(1));
		then(this.sessionRepository).should().deleteById(session.getId());
	}
}
/*
package org.springframework.boot.actuate.logging;
/**
class LogFileWebEndpointTests {
	private final MockEnvironment environment = new MockEnvironment();
	private File logFile;
	@BeforeEach
	void before(@TempDir Path temp) throws IOException {
		this.logFile = Files.createTempFile(temp, 'junit', null).toFile();
		FileCopyUtils.copy('--TEST--'.getBytes(), this.logFile);
	}
	@Test
	void nullResponseWithoutLogFile() {
		LogFileWebEndpoint endpoint = new LogFileWebEndpoint(null, null);
		assertThat(endpoint.logFile()).isNull();
	}
	@Test
	void nullResponseWithMissingLogFile() {
		this.environment.setProperty('logging.file.name', 'no_test.log');
		LogFileWebEndpoint endpoint = new LogFileWebEndpoint(LogFile.get(this.environment), null);
		assertThat(endpoint.logFile()).isNull();
	}
	@Test
	void resourceResponseWithLogFile() throws Exception {
		this.environment.setProperty('logging.file.name', this.logFile.getAbsolutePath());
		LogFileWebEndpoint endpoint = new LogFileWebEndpoint(LogFile.get(this.environment), null);
		Resource resource = endpoint.logFile();
		assertThat(resource).isNotNull();
		assertThat(contentOf(resource.getFile())).isEqualTo('--TEST--');
	}
	@Test
	void resourceResponseWithExternalLogFile() throws Exception {
		LogFileWebEndpoint endpoint = new LogFileWebEndpoint(null, this.logFile);
		Resource resource = endpoint.logFile();
		assertThat(resource).isNotNull();
		assertThat(contentOf(resource.getFile())).isEqualTo('--TEST--');
	}
}
/*
package org.springframework.boot.actuate.logging;
/**
class LoggersEndpointTests {
	private final LoggingSystem loggingSystem = mock(LoggingSystem.class);
	private LoggerGroups loggerGroups;
	@BeforeEach
	void setup() {
		Map<String, List<String>> groups = Collections.singletonMap('test', Collections.singletonList('test.member'));
		this.loggerGroups = new LoggerGroups(groups);
		this.loggerGroups.get('test').configureLogLevel(LogLevel.DEBUG, (a, b) -> {
		});
	}
	@Test
	void loggersShouldReturnLoggerConfigurationsWithNoLoggerGroups() {
		given(this.loggingSystem.getLoggerConfigurations())
			.willReturn(Collections.singletonList(new LoggerConfiguration('ROOT', null, LogLevel.DEBUG)));
		given(this.loggingSystem.getSupportedLogLevels()).willReturn(EnumSet.allOf(LogLevel.class));
		LoggersDescriptor result = new LoggersEndpoint(this.loggingSystem, new LoggerGroups()).loggers();
		Map<String, LoggerLevelsDescriptor> loggers = result.getLoggers();
		Set<LogLevel> levels = result.getLevels();
		SingleLoggerLevelsDescriptor rootLevels = (SingleLoggerLevelsDescriptor) loggers.get('ROOT');
		assertThat(rootLevels.getConfiguredLevel()).isNull();
		assertThat(rootLevels.getEffectiveLevel()).isEqualTo('DEBUG');
		assertThat(levels).containsExactly(LogLevel.OFF, LogLevel.FATAL, LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO,
				LogLevel.DEBUG, LogLevel.TRACE);
		Map<String, GroupLoggerLevelsDescriptor> groups = result.getGroups();
		assertThat(groups).isEmpty();
	}
	@Test
	void loggersShouldReturnLoggerConfigurationsWithLoggerGroups() {
		given(this.loggingSystem.getLoggerConfigurations())
			.willReturn(Collections.singletonList(new LoggerConfiguration('ROOT', null, LogLevel.DEBUG)));
		given(this.loggingSystem.getSupportedLogLevels()).willReturn(EnumSet.allOf(LogLevel.class));
		LoggersDescriptor result = new LoggersEndpoint(this.loggingSystem, this.loggerGroups).loggers();
		Map<String, GroupLoggerLevelsDescriptor> loggerGroups = result.getGroups();
		GroupLoggerLevelsDescriptor groupLevel = loggerGroups.get('test');
		Map<String, LoggerLevelsDescriptor> loggers = result.getLoggers();
		Set<LogLevel> levels = result.getLevels();
		SingleLoggerLevelsDescriptor rootLevels = (SingleLoggerLevelsDescriptor) loggers.get('ROOT');
		assertThat(rootLevels.getConfiguredLevel()).isNull();
		assertThat(rootLevels.getEffectiveLevel()).isEqualTo('DEBUG');
		assertThat(levels).containsExactly(LogLevel.OFF, LogLevel.FATAL, LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO,
				LogLevel.DEBUG, LogLevel.TRACE);
		assertThat(loggerGroups).isNotNull();
		assertThat(groupLevel.getConfiguredLevel()).isEqualTo('DEBUG');
		assertThat(groupLevel.getMembers()).containsExactly('test.member');
	}
	@Test
	void loggerLevelsWhenNameSpecifiedShouldReturnLevels() {
		given(this.loggingSystem.getLoggerConfiguration('ROOT'))
			.willReturn(new LoggerConfiguration('ROOT', null, LogLevel.DEBUG));
		SingleLoggerLevelsDescriptor levels = (SingleLoggerLevelsDescriptor) new LoggersEndpoint(this.loggingSystem,
				this.loggerGroups)
			.loggerLevels('ROOT');
		assertThat(levels.getConfiguredLevel()).isNull();
		assertThat(levels.getEffectiveLevel()).isEqualTo('DEBUG');
	}
	@Test // gh-35227
	void loggerLevelsWhenCustomLevelShouldReturnLevels() {
		given(this.loggingSystem.getLoggerConfiguration('ROOT'))
			.willReturn(new LoggerConfiguration('ROOT', null, LevelConfiguration.ofCustom('FINEST')));
		SingleLoggerLevelsDescriptor levels = (SingleLoggerLevelsDescriptor) new LoggersEndpoint(this.loggingSystem,
				this.loggerGroups)
			.loggerLevels('ROOT');
		assertThat(levels.getConfiguredLevel()).isNull();
		assertThat(levels.getEffectiveLevel()).isEqualTo('FINEST');
	}
	@Test
	void groupNameSpecifiedShouldReturnConfiguredLevelAndMembers() {
		GroupLoggerLevelsDescriptor levels = (GroupLoggerLevelsDescriptor) new LoggersEndpoint(this.loggingSystem,
				this.loggerGroups)
			.loggerLevels('test');
		assertThat(levels.getConfiguredLevel()).isEqualTo('DEBUG');
		assertThat(levels.getMembers()).isEqualTo(Collections.singletonList('test.member'));
	}
	@Test
	void configureLogLevelShouldSetLevelOnLoggingSystem() {
		new LoggersEndpoint(this.loggingSystem, this.loggerGroups).configureLogLevel('ROOT', LogLevel.DEBUG);
		then(this.loggingSystem).should().setLogLevel('ROOT', LogLevel.DEBUG);
	}
	@Test
	void configureLogLevelWithNullSetsLevelOnLoggingSystemToNull() {
		new LoggersEndpoint(this.loggingSystem, this.loggerGroups).configureLogLevel('ROOT', null);
		then(this.loggingSystem).should().setLogLevel('ROOT', null);
	}
	@Test
	void configureLogLevelInLoggerGroupShouldSetLevelOnLoggingSystem() {
		new LoggersEndpoint(this.loggingSystem, this.loggerGroups).configureLogLevel('test', LogLevel.DEBUG);
		then(this.loggingSystem).should().setLogLevel('test.member', LogLevel.DEBUG);
	}
	@Test
	void configureLogLevelWithNullInLoggerGroupShouldSetLevelOnLoggingSystem() {
		new LoggersEndpoint(this.loggingSystem, this.loggerGroups).configureLogLevel('test', null);
		then(this.loggingSystem).should().setLogLevel('test.member', null);
	}
	@Test
	void registersRuntimeHintsForClassesSerializedToJson() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new ReflectiveRuntimeHintsRegistrar().registerRuntimeHints(runtimeHints, LoggersEndpoint.class);
		ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
		assertThat(reflection.onType(LoggerLevelsDescriptor.class)).accepts(runtimeHints);
		assertThat(reflection.onMethod(LoggerLevelsDescriptor.class, 'getConfiguredLevel')).accepts(runtimeHints);
		assertThat(reflection.onType(SingleLoggerLevelsDescriptor.class)).accepts(runtimeHints);
		assertThat(reflection.onMethod(SingleLoggerLevelsDescriptor.class, 'getEffectiveLevel')).accepts(runtimeHints);
		assertThat(reflection.onMethod(SingleLoggerLevelsDescriptor.class, 'getConfiguredLevel')).accepts(runtimeHints);
		assertThat(reflection.onType(GroupLoggerLevelsDescriptor.class)).accepts(runtimeHints);
		assertThat(reflection.onMethod(GroupLoggerLevelsDescriptor.class, 'getMembers')).accepts(runtimeHints);
		assertThat(reflection.onMethod(GroupLoggerLevelsDescriptor.class, 'getConfiguredLevel')).accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.logging;
/**
class LoggersEndpointWebIntegrationTests {
	private static final String V2_JSON = ApiVersion.V2.getProducedMimeType().toString();
	private static final String V3_JSON = ApiVersion.V3.getProducedMimeType().toString();
	private WebTestClient client;
	private LoggingSystem loggingSystem;
	private LoggerGroups loggerGroups;
	@BeforeEach
	@AfterEach
	void resetMocks(ConfigurableApplicationContext context, WebTestClient client) {
		this.client = client;
		this.loggingSystem = context.getBean(LoggingSystem.class);
		this.loggerGroups = context.getBean(LoggerGroups.class);
		Mockito.reset(this.loggingSystem);
		given(this.loggingSystem.getSupportedLogLevels()).willReturn(EnumSet.allOf(LogLevel.class));
	}
	@WebEndpointTest
	void getLoggerShouldReturnAllLoggerConfigurationsWithLoggerGroups() {
		setLogLevelToDebug('test');
		given(this.loggingSystem.getLoggerConfigurations())
			.willReturn(Collections.singletonList(new LoggerConfiguration('ROOT', null, LogLevel.DEBUG)));
		this.client.get()
			.uri('/actuator/loggers')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$.length()')
			.isEqualTo(3)
			.jsonPath('levels')
			.isEqualTo(jsonArrayOf('OFF', 'FATAL', 'ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE'))
			.jsonPath('loggers.length()')
			.isEqualTo(1)
			.jsonPath('loggers.ROOT.length()')
			.isEqualTo(2)
			.jsonPath('loggers.ROOT.configuredLevel')
			.isEqualTo(null)
			.jsonPath('loggers.ROOT.effectiveLevel')
			.isEqualTo('DEBUG')
			.jsonPath('groups.length()')
			.isEqualTo(2)
			.jsonPath('groups.test.configuredLevel')
			.isEqualTo('DEBUG');
	}
	@WebEndpointTest
	void getLoggerShouldReturnLogLevels() {
		setLogLevelToDebug('test');
		given(this.loggingSystem.getLoggerConfiguration('ROOT'))
			.willReturn(new LoggerConfiguration('ROOT', null, LogLevel.DEBUG));
		this.client.get()
			.uri('/actuator/loggers/ROOT')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$.length()')
			.isEqualTo(2)
			.jsonPath('configuredLevel')
			.isEqualTo(null)
			.jsonPath('effectiveLevel')
			.isEqualTo('DEBUG');
	}
	@WebEndpointTest
	void getLoggersWhenLoggerAndLoggerGroupNotFoundShouldReturnNotFound() {
		this.client.get().uri('/actuator/loggers/com.does.not.exist').exchange().expectStatus().isNotFound();
	}
	@WebEndpointTest
	void getLoggerGroupShouldReturnConfiguredLogLevelAndMembers() {
		setLogLevelToDebug('test');
		this.client.get()
			.uri('actuator/loggers/test')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$.length()')
			.isEqualTo(2)
			.jsonPath('members')
			.value(IsIterableContainingInAnyOrder.containsInAnyOrder('test.member1', 'test.member2'))
			.jsonPath('configuredLevel')
			.isEqualTo('DEBUG');
	}
	@WebEndpointTest
	void setLoggerUsingApplicationJsonShouldSetLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/ROOT')
			.contentType(MediaType.APPLICATION_JSON)
			.bodyValue(Collections.singletonMap('configuredLevel', 'debug'))
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('ROOT', LogLevel.DEBUG);
	}
	@WebEndpointTest
	void setLoggerUsingActuatorV2JsonShouldSetLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/ROOT')
			.contentType(MediaType.parseMediaType(V2_JSON))
			.bodyValue(Collections.singletonMap('configuredLevel', 'debug'))
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('ROOT', LogLevel.DEBUG);
	}
	@WebEndpointTest
	void setLoggerUsingActuatorV3JsonShouldSetLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/ROOT')
			.contentType(MediaType.parseMediaType(V3_JSON))
			.bodyValue(Collections.singletonMap('configuredLevel', 'debug'))
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('ROOT', LogLevel.DEBUG);
	}
	@WebEndpointTest
	void setLoggerGroupUsingActuatorV2JsonShouldSetLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/test')
			.contentType(MediaType.parseMediaType(V2_JSON))
			.bodyValue(Collections.singletonMap('configuredLevel', 'debug'))
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('test.member1', LogLevel.DEBUG);
		then(this.loggingSystem).should().setLogLevel('test.member2', LogLevel.DEBUG);
	}
	@WebEndpointTest
	void setLoggerGroupUsingApplicationJsonShouldSetLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/test')
			.contentType(MediaType.APPLICATION_JSON)
			.bodyValue(Collections.singletonMap('configuredLevel', 'debug'))
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('test.member1', LogLevel.DEBUG);
		then(this.loggingSystem).should().setLogLevel('test.member2', LogLevel.DEBUG);
	}
	@WebEndpointTest
	void setLoggerOrLoggerGroupWithWrongLogLevelResultInBadRequestResponse() {
		this.client.post()
			.uri('/actuator/loggers/ROOT')
			.contentType(MediaType.APPLICATION_JSON)
			.bodyValue(Collections.singletonMap('configuredLevel', 'other'))
			.exchange()
			.expectStatus()
			.isBadRequest();
		then(this.loggingSystem).shouldHaveNoInteractions();
	}
	@WebEndpointTest
	void setLoggerWithNullLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/ROOT')
			.contentType(MediaType.parseMediaType(V3_JSON))
			.bodyValue(Collections.singletonMap('configuredLevel', null))
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('ROOT', null);
	}
	@WebEndpointTest
	void setLoggerWithNoLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/ROOT')
			.contentType(MediaType.parseMediaType(V3_JSON))
			.bodyValue(Collections.emptyMap())
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('ROOT', null);
	}
	@WebEndpointTest
	void setLoggerGroupWithNullLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/test')
			.contentType(MediaType.parseMediaType(V3_JSON))
			.bodyValue(Collections.singletonMap('configuredLevel', null))
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('test.member1', null);
		then(this.loggingSystem).should().setLogLevel('test.member2', null);
	}
	@WebEndpointTest
	void setLoggerGroupWithNoLogLevel() {
		this.client.post()
			.uri('/actuator/loggers/test')
			.contentType(MediaType.parseMediaType(V3_JSON))
			.bodyValue(Collections.emptyMap())
			.exchange()
			.expectStatus()
			.isNoContent();
		then(this.loggingSystem).should().setLogLevel('test.member1', null);
		then(this.loggingSystem).should().setLogLevel('test.member2', null);
	}
	@WebEndpointTest
	void logLevelForLoggerWithNameThatCouldBeMistakenForAPathExtension() {
		given(this.loggingSystem.getLoggerConfiguration('com.png'))
			.willReturn(new LoggerConfiguration('com.png', null, LogLevel.DEBUG));
		this.client.get()
			.uri('/actuator/loggers/com.png')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$.length()')
			.isEqualTo(2)
			.jsonPath('configuredLevel')
			.isEqualTo(null)
			.jsonPath('effectiveLevel')
			.isEqualTo('DEBUG');
	}
	@WebEndpointTest
	void logLevelForLoggerGroupWithNameThatCouldBeMistakenForAPathExtension() {
		setLogLevelToDebug('group.png');
		this.client.get()
			.uri('/actuator/loggers/group.png')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$.length()')
			.isEqualTo(2)
			.jsonPath('configuredLevel')
			.isEqualTo('DEBUG')
			.jsonPath('members')
			.value(IsIterableContainingInAnyOrder.containsInAnyOrder('png.member1', 'png.member2'));
	}
	private void setLogLevelToDebug(String name) {
		this.loggerGroups.get(name).configureLogLevel(LogLevel.DEBUG, (a, b) -> {
		});
	}
	private JSONArray jsonArrayOf(Object... entries) {
		JSONArray array = new JSONArray();
		array.addAll(Arrays.asList(entries));
		return array;
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		LoggingSystem loggingSystem() {
			return mock(LoggingSystem.class);
		}
		@Bean
		LoggerGroups loggingGroups() {
			return getLoggerGroups();
		}
		private LoggerGroups getLoggerGroups() {
			Map<String, List<String>> groups = new LinkedHashMap<>();
			groups.put('test', Arrays.asList('test.member1', 'test.member2'));
			groups.put('group.png', Arrays.asList('png.member1', 'png.member2'));
			return new LoggerGroups(groups);
		}
		@Bean
		LoggersEndpoint endpoint(LoggingSystem loggingSystem,
				ObjectProvider<LoggerGroups> loggingGroupsObjectProvider) {
			return new LoggersEndpoint(loggingSystem, loggingGroupsObjectProvider.getIfAvailable());
		}
	}
}
/*
package org.springframework.boot.actuate.logging;
/**
class LogFileWebEndpointWebIntegrationTests {
	private WebTestClient client;
	private static File tempFile;
	@BeforeEach
	void setUp(WebTestClient client) {
		this.client = client;
	}
	@BeforeAll
	static void setup(@TempDir File temp) {
		tempFile = temp;
	}
	@WebEndpointTest
	void getRequestProducesResponseWithLogFile() {
		this.client.get()
			.uri('/actuator/logfile')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType('text/plain; charset=UTF-8')
			.expectBody(String.class)
			.isEqualTo('--TEST--');
	}
	@WebEndpointTest
	void getRequestThatAcceptsTextPlainProducesResponseWithLogFile() {
		this.client.get()
			.uri('/actuator/logfile')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType('text/plain; charset=UTF-8')
			.expectBody(String.class)
			.isEqualTo('--TEST--');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		LogFileWebEndpoint logFileEndpoint() throws IOException {
			File logFile = new File(tempFile, 'test.log');
			FileCopyUtils.copy('--TEST--'.getBytes(), logFile);
			MockEnvironment environment = new MockEnvironment();
			environment.setProperty('logging.file.name', logFile.getAbsolutePath());
			return new LogFileWebEndpoint(LogFile.get(environment), null);
		}
	}
}
/*
package org.springframework.boot.actuate.hazelcast;
/**
class HazelcastHealthIndicatorTests {
	@Test
	void hazelcastUp() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class))
			.withPropertyValues('spring.hazelcast.config=hazelcast.xml')
			.run((context) -> {
				HazelcastInstance hazelcast = context.getBean(HazelcastInstance.class);
				Health health = new HazelcastHealthIndicator(hazelcast).health();
				assertThat(health.getStatus()).isEqualTo(Status.UP);
				assertThat(health.getDetails()).containsOnlyKeys('name', 'uuid')
					.containsEntry('name', 'actuator-hazelcast');
				assertThat(health.getDetails().get('uuid')).asString().isNotEmpty();
			});
	}
	@Test
	void hazelcastDown() {
		HazelcastInstance hazelcast = mock(HazelcastInstance.class);
		given(hazelcast.executeTransaction(any())).willThrow(new HazelcastException());
		Health health = new HazelcastHealthIndicator(hazelcast).health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class SimpleInfoContributorTests {
	@Test
	void prefixIsMandatory() {
		assertThatIllegalArgumentException().isThrownBy(() -> new SimpleInfoContributor(null, new Object()));
	}
	@Test
	void mapSimpleObject() {
		Object o = new Object();
		Info info = contributeFrom('test', o);
		assertThat(info.get('test')).isSameAs(o);
	}
	private static Info contributeFrom(String prefix, Object detail) {
		SimpleInfoContributor contributor = new SimpleInfoContributor(prefix, detail);
		Info.Builder builder = new Info.Builder();
		contributor.contribute(builder);
		return builder.build();
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class ProcessInfoContributorTests {
	@Test
	void processInfoShouldBeAdded() {
		ProcessInfoContributor processInfoContributor = new ProcessInfoContributor();
		Info.Builder builder = new Info.Builder();
		processInfoContributor.contribute(builder);
		Info info = builder.build();
		assertThat(info.get('process')).isInstanceOf(ProcessInfo.class);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new ProcessInfoContributorRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(ProcessInfo.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class InfoEndpointTests {
	@Test
	void info() {
		InfoEndpoint endpoint = new InfoEndpoint(Arrays.asList((builder) -> builder.withDetail('key1', 'value1'),
				(builder) -> builder.withDetail('key2', 'value2')));
		Map<String, Object> info = endpoint.info();
		assertThat(info).hasSize(2);
		assertThat(info).containsEntry('key1', 'value1');
		assertThat(info).containsEntry('key2', 'value2');
	}
	@Test
	void infoWithNoContributorsProducesEmptyMap() {
		InfoEndpoint endpoint = new InfoEndpoint(Collections.emptyList());
		Map<String, Object> info = endpoint.info();
		assertThat(info).isEmpty();
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class SslInfoContributorTests {
	@Test
	void sslInfoShouldBeAdded() {
		SslBundles sslBundles = new DefaultSslBundleRegistry('test', mock(SslBundle.class));
		SslInfo sslInfo = new SslInfo(sslBundles, Duration.ofDays(14));
		SslInfoContributor sslInfoContributor = new SslInfoContributor(sslInfo);
		Info.Builder builder = new Info.Builder();
		sslInfoContributor.contribute(builder);
		Info info = builder.build();
		assertThat(info.getDetails().get('ssl')).isInstanceOf(SslInfo.class);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new SslInfoContributorRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(SslInfo.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class OsInfoContributorTests {
	@Test
	void osInfoShouldBeAdded() {
		OsInfoContributor osInfoContributor = new OsInfoContributor();
		Info.Builder builder = new Info.Builder();
		osInfoContributor.contribute(builder);
		Info info = builder.build();
		assertThat(info.getDetails().get('os')).isInstanceOf(OsInfo.class);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new OsInfoContributorRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(OsInfo.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class InfoTests {
	@Test
	void infoIsImmutable() {
		Info info = new Info.Builder().withDetail('foo', 'bar').build();
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(info.getDetails()::clear);
	}
	@Test
	void infoTakesCopyOfMap() {
		Info.Builder builder = new Info.Builder();
		builder.withDetail('foo', 'bar');
		Info build = builder.build();
		builder.withDetail('biz', 'bar');
		assertThat(build.getDetails()).containsOnly(entry('foo', 'bar'));
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class GitInfoContributorTests {
	@Test
	@SuppressWarnings('unchecked')
	void coerceDate() {
		Properties properties = new Properties();
		properties.put('branch', 'master');
		properties.put('commit.time', '2016-03-04T14:36:33+0100');
		GitInfoContributor contributor = new GitInfoContributor(new GitProperties(properties));
		Map<String, Object> content = contributor.generateContent();
		assertThat(content.get('commit')).isInstanceOf(Map.class);
		Map<String, Object> commit = (Map<String, Object>) content.get('commit');
		Object commitTime = commit.get('time');
		assertThat(commitTime).isInstanceOf(Instant.class);
		assertThat(((Instant) commitTime).toEpochMilli()).isEqualTo(1457098593000L);
	}
	@Test
	@SuppressWarnings('unchecked')
	void shortenCommitId() {
		Properties properties = new Properties();
		properties.put('branch', 'master');
		properties.put('commit.id', '8e29a0b0d423d2665c6ee5171947c101a5c15681');
		GitInfoContributor contributor = new GitInfoContributor(new GitProperties(properties));
		Map<String, Object> content = contributor.generateContent();
		assertThat(content.get('commit')).isInstanceOf(Map.class);
		Map<String, Object> commit = (Map<String, Object>) content.get('commit');
		assertThat(commit).containsEntry('id', '8e29a0b');
	}
	@Test
	@SuppressWarnings('unchecked')
	void withGitIdAndAbbrev() {
		// gh-11892
		Properties properties = new Properties();
		properties.put('branch', 'master');
		properties.put('commit.id', '1b3cec34f7ca0a021244452f2cae07a80497a7c7');
		properties.put('commit.id.abbrev', '1b3cec3');
		GitInfoContributor contributor = new GitInfoContributor(new GitProperties(properties), Mode.FULL);
		Map<String, Object> content = contributor.generateContent();
		Map<String, Object> commit = (Map<String, Object>) content.get('commit');
		assertThat(commit.get('id')).isInstanceOf(Map.class);
		Map<String, Object> id = (Map<String, Object>) commit.get('id');
		assertThat(id).containsEntry('full', '1b3cec34f7ca0a021244452f2cae07a80497a7c7');
		assertThat(id).containsEntry('abbrev', '1b3cec3');
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new GitInfoContributorRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(GitProperties.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class BuildInfoContributorTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new BuildInfoContributorRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(BuildProperties.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@TestPropertySource(properties = { 'info.app.name=MyService' })
class InfoEndpointWebIntegrationTests {
	@WebEndpointTest
	void info(WebTestClient client) {
		client.get()
			.uri('/actuator/info')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('beanName1.key11')
			.isEqualTo('value11')
			.jsonPath('beanName1.key12')
			.isEqualTo('value12')
			.jsonPath('beanName2.key21')
			.isEqualTo('value21')
			.jsonPath('beanName2.key22')
			.isEqualTo('value22');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		InfoEndpoint endpoint(ObjectProvider<InfoContributor> infoContributors) {
			return new InfoEndpoint(infoContributors.orderedStream().toList());
		}
		@Bean
		InfoContributor beanName1() {
			return (builder) -> {
				Map<String, Object> content = new LinkedHashMap<>();
				content.put('key11', 'value11');
				content.put('key12', 'value12');
				builder.withDetail('beanName1', content);
			};
		}
		@Bean
		InfoContributor beanName2() {
			return (builder) -> {
				Map<String, Object> content = new LinkedHashMap<>();
				content.put('key21', 'value21');
				content.put('key22', 'value22');
				builder.withDetail('beanName2', content);
			};
		}
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class EnvironmentInfoContributorTests {
	private final StandardEnvironment environment = new StandardEnvironment();
	@Test
	void extractOnlyInfoProperty() {
		TestPropertyValues.of('info.app=my app', 'info.version=1.0.0', 'foo=bar').applyTo(this.environment);
		Info actual = contributeFrom(this.environment);
		assertThat(actual.get('app', String.class)).isEqualTo('my app');
		assertThat(actual.get('version', String.class)).isEqualTo('1.0.0');
		assertThat(actual.getDetails()).hasSize(2);
	}
	@Test
	void extractNoEntry() {
		TestPropertyValues.of('foo=bar').applyTo(this.environment);
		Info actual = contributeFrom(this.environment);
		assertThat(actual.getDetails()).isEmpty();
	}
	@Test
	@SuppressWarnings('unchecked')
	void propertiesFromEnvironmentShouldBindCorrectly() {
		TestPropertyValues.of('INFO_ENVIRONMENT_FOO=green').applyTo(this.environment, Type.SYSTEM_ENVIRONMENT);
		Info actual = contributeFrom(this.environment);
		assertThat(actual.get('environment', Map.class)).containsEntry('foo', 'green');
	}
	private static Info contributeFrom(ConfigurableEnvironment environment) {
		EnvironmentInfoContributor contributor = new EnvironmentInfoContributor(environment);
		Info.Builder builder = new Info.Builder();
		contributor.contribute(builder);
		return builder.build();
	}
}
/*
package org.springframework.boot.actuate.info;
/**
class JavaInfoContributorTests {
	@Test
	void javaInfoShouldBeAdded() {
		JavaInfoContributor javaInfoContributor = new JavaInfoContributor();
		Info.Builder builder = new Info.Builder();
		javaInfoContributor.contribute(builder);
		Info info = builder.build();
		assertThat(info.getDetails().get('java')).isInstanceOf(JavaInfo.class);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new JavaInfoContributorRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(JavaInfo.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.system;
/**
@ExtendWith(MockitoExtension.class)
class DiskSpaceHealthIndicatorTests {
	private static final DataSize THRESHOLD = DataSize.ofKilobytes(1);
	private static final DataSize TOTAL_SPACE = DataSize.ofKilobytes(10);
	@Mock
	private File fileMock;
	private HealthIndicator healthIndicator;
	@BeforeEach
	void setUp() {
		this.healthIndicator = new DiskSpaceHealthIndicator(this.fileMock, THRESHOLD);
	}
	@Test
	void diskSpaceIsUp() {
		given(this.fileMock.exists()).willReturn(true);
		long freeSpace = THRESHOLD.toBytes() + 10;
		given(this.fileMock.getUsableSpace()).willReturn(freeSpace);
		given(this.fileMock.getTotalSpace()).willReturn(TOTAL_SPACE.toBytes());
		given(this.fileMock.getAbsolutePath()).willReturn('/absolute-path');
		Health health = this.healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('threshold', THRESHOLD.toBytes());
		assertThat(health.getDetails()).containsEntry('free', freeSpace);
		assertThat(health.getDetails()).containsEntry('total', TOTAL_SPACE.toBytes());
		assertThat(health.getDetails()).containsEntry('path', '/absolute-path');
		assertThat(health.getDetails()).containsEntry('exists', true);
	}
	@Test
	void diskSpaceIsDown() {
		given(this.fileMock.exists()).willReturn(true);
		long freeSpace = THRESHOLD.toBytes() - 10;
		given(this.fileMock.getUsableSpace()).willReturn(freeSpace);
		given(this.fileMock.getTotalSpace()).willReturn(TOTAL_SPACE.toBytes());
		given(this.fileMock.getAbsolutePath()).willReturn('/absolute-path');
		Health health = this.healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('threshold', THRESHOLD.toBytes());
		assertThat(health.getDetails()).containsEntry('free', freeSpace);
		assertThat(health.getDetails()).containsEntry('total', TOTAL_SPACE.toBytes());
		assertThat(health.getDetails()).containsEntry('path', '/absolute-path');
		assertThat(health.getDetails()).containsEntry('exists', true);
	}
	@Test
	void whenPathDoesNotExistDiskSpaceIsDown() {
		Health health = new DiskSpaceHealthIndicator(new File('does/not/exist'), THRESHOLD).health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('free', 0L);
		assertThat(health.getDetails()).containsEntry('total', 0L);
		assertThat(health.getDetails()).containsEntry('exists', false);
	}
}
/*
package org.springframework.boot.actuate.neo4j;
/**
final class ResultSummaryMock {
	private ResultSummaryMock() {
	}
	static ResultSummary createResultSummary(String serverAddress, String databaseName) {
		ServerInfo serverInfo = mock(ServerInfo.class);
		given(serverInfo.address()).willReturn(serverAddress);
		DatabaseInfo databaseInfo = mock(DatabaseInfo.class);
		given(databaseInfo.name()).willReturn(databaseName);
		ResultSummary resultSummary = mock(ResultSummary.class);
		given(resultSummary.server()).willReturn(serverInfo);
		given(resultSummary.database()).willReturn(databaseInfo);
		return resultSummary;
	}
}
/*
package org.springframework.boot.actuate.neo4j;
/**
class Neo4jReactiveHealthIndicatorTests {
	@Test
	void neo4jIsUp() {
		ResultSummary resultSummary = ResultSummaryMock.createResultSummary('My Home', 'test');
		Driver driver = mockDriver(resultSummary, '4711', 'ultimate collectors edition');
		Neo4jReactiveHealthIndicator healthIndicator = new Neo4jReactiveHealthIndicator(driver);
		healthIndicator.health().as(StepVerifier::create).consumeNextWith((health) -> {
			assertThat(health.getStatus()).isEqualTo(Status.UP);
			assertThat(health.getDetails()).containsEntry('server', '4711@My Home');
			assertThat(health.getDetails()).containsEntry('edition', 'ultimate collectors edition');
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void neo4jIsUpWithOneSessionExpiredException() {
		ResultSummary resultSummary = ResultSummaryMock.createResultSummary('My Home', '');
		ReactiveSession session = mock(ReactiveSession.class);
		ReactiveResult statementResult = mockStatementResult(resultSummary, '4711', 'some edition');
		AtomicInteger count = new AtomicInteger();
		given(session.run(anyString())).will((invocation) -> {
			if (count.compareAndSet(0, 1)) {
				return Flux.error(new SessionExpiredException('Session expired'));
			}
			return Flux.just(statementResult);
		});
		Driver driver = mock(Driver.class);
		given(driver.session(eq(ReactiveSession.class), any(SessionConfig.class))).willReturn(session);
		Neo4jReactiveHealthIndicator healthIndicator = new Neo4jReactiveHealthIndicator(driver);
		healthIndicator.health().as(StepVerifier::create).consumeNextWith((health) -> {
			assertThat(health.getStatus()).isEqualTo(Status.UP);
			assertThat(health.getDetails()).containsEntry('server', '4711@My Home');
			assertThat(health.getDetails()).containsEntry('edition', 'some edition');
		}).expectComplete().verify(Duration.ofSeconds(30));
		then(session).should(times(2)).close();
	}
	@Test
	void neo4jIsDown() {
		Driver driver = mock(Driver.class);
		given(driver.session(eq(ReactiveSession.class), any(SessionConfig.class)))
			.willThrow(ServiceUnavailableException.class);
		Neo4jReactiveHealthIndicator healthIndicator = new Neo4jReactiveHealthIndicator(driver);
		healthIndicator.health().as(StepVerifier::create).consumeNextWith((health) -> {
			assertThat(health.getStatus()).isEqualTo(Status.DOWN);
			assertThat(health.getDetails()).containsKeys('error');
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	private ReactiveResult mockStatementResult(ResultSummary resultSummary, String version, String edition) {
		Record record = mock(Record.class);
		given(record.get('edition')).willReturn(Values.value(edition));
		given(record.get('version')).willReturn(Values.value(version));
		ReactiveResult statementResult = mock(ReactiveResult.class);
		given(statementResult.records()).willReturn(Mono.just(record));
		given(statementResult.consume()).willReturn(Mono.just(resultSummary));
		return statementResult;
	}
	private Driver mockDriver(ResultSummary resultSummary, String version, String edition) {
		ReactiveResult statementResult = mockStatementResult(resultSummary, version, edition);
		ReactiveSession session = mock(ReactiveSession.class);
		given(session.run(anyString())).willReturn(Mono.just(statementResult));
		Driver driver = mock(Driver.class);
		given(driver.session(eq(ReactiveSession.class), any(SessionConfig.class))).willReturn(session);
		return driver;
	}
}
/*
package org.springframework.boot.actuate.neo4j;
/**
class Neo4jHealthIndicatorTests {
	@Test
	void neo4jIsUp() {
		ResultSummary resultSummary = ResultSummaryMock.createResultSummary('My Home', 'test');
		Driver driver = mockDriver(resultSummary, '4711', 'ultimate collectors edition');
		Health health = new Neo4jHealthIndicator(driver).health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('server', '4711@My Home');
		assertThat(health.getDetails()).containsEntry('database', 'test');
		assertThat(health.getDetails()).containsEntry('edition', 'ultimate collectors edition');
	}
	@Test
	void neo4jIsUpWithoutDatabaseName() {
		ResultSummary resultSummary = ResultSummaryMock.createResultSummary('My Home', null);
		Driver driver = mockDriver(resultSummary, '4711', 'some edition');
		Health health = new Neo4jHealthIndicator(driver).health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('server', '4711@My Home');
		assertThat(health.getDetails()).doesNotContainKey('database');
		assertThat(health.getDetails()).containsEntry('edition', 'some edition');
	}
	@Test
	void neo4jIsUpWithEmptyDatabaseName() {
		ResultSummary resultSummary = ResultSummaryMock.createResultSummary('My Home', '');
		Driver driver = mockDriver(resultSummary, '4711', 'some edition');
		Health health = new Neo4jHealthIndicator(driver).health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('server', '4711@My Home');
		assertThat(health.getDetails()).doesNotContainKey('database');
		assertThat(health.getDetails()).containsEntry('edition', 'some edition');
	}
	@Test
	void neo4jIsUpWithOneSessionExpiredException() {
		ResultSummary resultSummary = ResultSummaryMock.createResultSummary('My Home', '');
		Session session = mock(Session.class);
		Result statementResult = mockStatementResult(resultSummary, '4711', 'some edition');
		AtomicInteger count = new AtomicInteger();
		given(session.run(anyString())).will((invocation) -> {
			if (count.compareAndSet(0, 1)) {
				throw new SessionExpiredException('Session expired');
			}
			return statementResult;
		});
		Driver driver = mock(Driver.class);
		given(driver.session(any(SessionConfig.class))).willReturn(session);
		Neo4jHealthIndicator healthIndicator = new Neo4jHealthIndicator(driver);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('server', '4711@My Home');
		then(session).should(times(2)).close();
	}
	@Test
	void neo4jIsDown() {
		Driver driver = mock(Driver.class);
		given(driver.session(any(SessionConfig.class))).willThrow(ServiceUnavailableException.class);
		Health health = new Neo4jHealthIndicator(driver).health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsKeys('error');
	}
	private Result mockStatementResult(ResultSummary resultSummary, String version, String edition) {
		Record record = mock(Record.class);
		given(record.get('edition')).willReturn(Values.value(edition));
		given(record.get('version')).willReturn(Values.value(version));
		Result statementResult = mock(Result.class);
		given(statementResult.single()).willReturn(record);
		given(statementResult.consume()).willReturn(resultSummary);
		return statementResult;
	}
	private Driver mockDriver(ResultSummary resultSummary, String version, String edition) {
		Result statementResult = mockStatementResult(resultSummary, version, edition);
		Session session = mock(Session.class);
		given(session.run(anyString())).willReturn(statementResult);
		Driver driver = mock(Driver.class);
		given(driver.session(any(SessionConfig.class))).willReturn(session);
		return driver;
	}
}
/*
package org.springframework.boot.actuate.amqp;
/**
@ExtendWith(MockitoExtension.class)
class RabbitHealthIndicatorTests {
	@Mock
	private RabbitTemplate rabbitTemplate;
	@Mock
	private Channel channel;
	@Test
	void createWhenRabbitTemplateIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new RabbitHealthIndicator(null))
			.withMessageContaining('RabbitTemplate must not be null');
	}
	@Test
	void healthWhenConnectionSucceedsShouldReturnUpWithVersion() {
		givenTemplateExecutionWillInvokeCallback();
		Connection connection = mock(Connection.class);
		given(this.channel.getConnection()).willReturn(connection);
		given(connection.getServerProperties()).willReturn(Collections.singletonMap('version', '123'));
		Health health = new RabbitHealthIndicator(this.rabbitTemplate).health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('version', '123');
	}
	@Test
	void healthWhenConnectionFailsShouldReturnDown() {
		givenTemplateExecutionWillInvokeCallback();
		given(this.channel.getConnection()).willThrow(new RuntimeException());
		Health health = new RabbitHealthIndicator(this.rabbitTemplate).health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
	}
	private void givenTemplateExecutionWillInvokeCallback() {
		given(this.rabbitTemplate.execute(any())).willAnswer((invocation) -> {
			ChannelCallback<?> callback = invocation.getArgument(0);
			return callback.doInRabbit(this.channel);
		});
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
class TestJmxOperationResponseMapper implements JmxOperationResponseMapper {
	@Override
	public Object mapResponse(Object response) {
		return response;
	}
	@Override
	public Class<?> mapResponseType(Class<?> responseType) {
		return responseType;
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
class DiscoveredJmxOperationTests {
	@Test
	void getNameShouldReturnMethodName() {
		DiscoveredJmxOperation operation = getOperation('getEnum');
		assertThat(operation.getName()).isEqualTo('getEnum');
	}
	@Test
	void getOutputTypeShouldReturnJmxType() {
		assertThat(getOperation('getEnum').getOutputType()).isEqualTo(String.class);
		assertThat(getOperation('getDate').getOutputType()).isEqualTo(String.class);
		assertThat(getOperation('getInstant').getOutputType()).isEqualTo(String.class);
		assertThat(getOperation('getInteger').getOutputType()).isEqualTo(Integer.class);
		assertThat(getOperation('getVoid').getOutputType()).isEqualTo(void.class);
		assertThat(getOperation('getApplicationContext').getOutputType()).isEqualTo(Object.class);
	}
	@Test
	void getDescriptionWhenHasManagedOperationDescriptionShouldUseValueFromAnnotation() {
		DiscoveredJmxOperation operation = getOperation('withManagedOperationDescription');
		assertThat(operation.getDescription()).isEqualTo('fromannotation');
	}
	@Test
	void getDescriptionWhenHasNoManagedOperationShouldGenerateDescription() {
		DiscoveredJmxOperation operation = getOperation('getEnum');
		assertThat(operation.getDescription()).isEqualTo('Invoke getEnum for endpoint test');
	}
	@Test
	void getParametersWhenHasNoParametersShouldReturnEmptyList() {
		DiscoveredJmxOperation operation = getOperation('getEnum');
		assertThat(operation.getParameters()).isEmpty();
	}
	@Test
	void getParametersShouldReturnJmxTypes() {
		DiscoveredJmxOperation operation = getOperation('params');
		List<JmxOperationParameter> parameters = operation.getParameters();
		assertThat(parameters.get(0).getType()).isEqualTo(String.class);
		assertThat(parameters.get(1).getType()).isEqualTo(String.class);
		assertThat(parameters.get(2).getType()).isEqualTo(String.class);
		assertThat(parameters.get(3).getType()).isEqualTo(Integer.class);
		assertThat(parameters.get(4).getType()).isEqualTo(Object.class);
	}
	@Test
	void getParametersWhenHasManagedOperationParameterShouldUseValuesFromAnnotation() {
		DiscoveredJmxOperation operation = getOperation('withManagedOperationParameters');
		List<JmxOperationParameter> parameters = operation.getParameters();
		assertThat(parameters.get(0).getName()).isEqualTo('a1');
		assertThat(parameters.get(1).getName()).isEqualTo('a2');
		assertThat(parameters.get(0).getDescription()).isEqualTo('d1');
		assertThat(parameters.get(1).getDescription()).isEqualTo('d2');
	}
	@Test
	void getParametersWhenHasNoManagedOperationParameterShouldDeducedValuesName() {
		DiscoveredJmxOperation operation = getOperation('params');
		List<JmxOperationParameter> parameters = operation.getParameters();
		assertThat(parameters.get(0).getName()).isEqualTo('enumParam');
		assertThat(parameters.get(1).getName()).isEqualTo('dateParam');
		assertThat(parameters.get(2).getName()).isEqualTo('instantParam');
		assertThat(parameters.get(3).getName()).isEqualTo('integerParam');
		assertThat(parameters.get(4).getName()).isEqualTo('applicationContextParam');
		assertThat(parameters.get(0).getDescription()).isNull();
		assertThat(parameters.get(1).getDescription()).isNull();
		assertThat(parameters.get(2).getDescription()).isNull();
		assertThat(parameters.get(3).getDescription()).isNull();
		assertThat(parameters.get(4).getDescription()).isNull();
	}
	private DiscoveredJmxOperation getOperation(String methodName) {
		Method method = findMethod(methodName);
		AnnotationAttributes annotationAttributes = new AnnotationAttributes();
		annotationAttributes.put('produces', 'application/xml');
		DiscoveredOperationMethod operationMethod = new DiscoveredOperationMethod(method, OperationType.READ,
				annotationAttributes);
		return new DiscoveredJmxOperation(EndpointId.of('test'), operationMethod, mock(OperationInvoker.class));
	}
	private Method findMethod(String methodName) {
		Map<String, Method> methods = new HashMap<>();
		ReflectionUtils.doWithMethods(Example.class, (method) -> methods.put(method.getName(), method));
		return methods.get(methodName);
	}
	interface Example {
		OperationType getEnum();
		Date getDate();
		Instant getInstant();
		Integer getInteger();
		void getVoid();
		ApplicationContext getApplicationContext();
		Object params(OperationType enumParam, Date dateParam, Instant instantParam, Integer integerParam,
				ApplicationContext applicationContextParam);
		@ManagedOperation(description = 'fromannotation')
		Object withManagedOperationDescription();
		@ManagedOperationParameters({ @ManagedOperationParameter(name = 'a1', description = 'd1'),
				@ManagedOperationParameter(name = 'a2', description = 'd2') })
		Object withManagedOperationParameters(Object one, Object two);
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
class JmxEndpointDiscovererTests {
	@Test
	void getEndpointsWhenNoEndpointBeansShouldReturnEmptyCollection() {
		load(EmptyConfiguration.class, (discoverer) -> assertThat(discoverer.getEndpoints()).isEmpty());
	}
	@Test
	void getEndpointsShouldDiscoverStandardEndpoints() {
		load(TestEndpoint.class, (discoverer) -> {
			Map<EndpointId, ExposableJmxEndpoint> endpoints = discover(discoverer);
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<String, JmxOperation> operationByName = mapOperations(
					endpoints.get(EndpointId.of('test')).getOperations());
			assertThat(operationByName).containsOnlyKeys('getAll', 'getSomething', 'update', 'deleteSomething');
			JmxOperation getAll = operationByName.get('getAll');
			assertThat(getAll.getDescription()).isEqualTo('Invoke getAll for endpoint test');
			assertThat(getAll.getOutputType()).isEqualTo(Object.class);
			assertThat(getAll.getParameters()).isEmpty();
			JmxOperation getSomething = operationByName.get('getSomething');
			assertThat(getSomething.getDescription()).isEqualTo('Invoke getSomething for endpoint test');
			assertThat(getSomething.getOutputType()).isEqualTo(String.class);
			assertThat(getSomething.getParameters()).hasSize(1);
			assertThat(getSomething.getParameters().get(0).getType()).isEqualTo(String.class);
			JmxOperation update = operationByName.get('update');
			assertThat(update.getDescription()).isEqualTo('Invoke update for endpoint test');
			assertThat(update.getOutputType()).isEqualTo(Void.TYPE);
			assertThat(update.getParameters()).hasSize(2);
			assertThat(update.getParameters().get(0).getType()).isEqualTo(String.class);
			assertThat(update.getParameters().get(1).getType()).isEqualTo(String.class);
			JmxOperation deleteSomething = operationByName.get('deleteSomething');
			assertThat(deleteSomething.getDescription()).isEqualTo('Invoke deleteSomething for endpoint test');
			assertThat(deleteSomething.getOutputType()).isEqualTo(Void.TYPE);
			assertThat(deleteSomething.getParameters()).hasSize(1);
			assertThat(deleteSomething.getParameters().get(0).getType()).isEqualTo(String.class);
		});
	}
	@Test
	void getEndpointsWhenHasFilteredEndpointShouldOnlyDiscoverJmxEndpoints() {
		load(MultipleEndpointsConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableJmxEndpoint> endpoints = discover(discoverer);
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'), EndpointId.of('jmx'));
		});
	}
	@Test
	void getEndpointsWhenJmxExtensionIsMissingEndpointShouldThrowException() {
		load(TestJmxEndpointExtension.class, (discoverer) -> assertThatIllegalStateException()
			.isThrownBy(discoverer::getEndpoints)
			.withMessageContaining(
					'Invalid extension "jmxEndpointDiscovererTests.TestJmxEndpointExtension": no endpoint found with id "test"'));
	}
	@Test
	void getEndpointsWhenHasJmxExtensionShouldOverrideStandardEndpoint() {
		load(OverriddenOperationJmxEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableJmxEndpoint> endpoints = discover(discoverer);
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			assertJmxTestEndpoint(endpoints.get(EndpointId.of('test')));
		});
	}
	@Test
	void getEndpointsWhenHasJmxExtensionWithNewOperationAddsExtraOperation() {
		load(AdditionalOperationJmxEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableJmxEndpoint> endpoints = discover(discoverer);
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<String, JmxOperation> operationByName = mapOperations(
					endpoints.get(EndpointId.of('test')).getOperations());
			assertThat(operationByName).containsOnlyKeys('getAll', 'getSomething', 'update', 'deleteSomething',
					'getAnother');
			JmxOperation getAnother = operationByName.get('getAnother');
			assertThat(getAnother.getDescription()).isEqualTo('Get another thing');
			assertThat(getAnother.getOutputType()).isEqualTo(Object.class);
			assertThat(getAnother.getParameters()).isEmpty();
		});
	}
	@Test
	void getEndpointsWhenHasCacheWithTtlShouldCacheReadOperationWithTtlValue() {
		load(TestEndpoint.class, (id) -> 500L, (discoverer) -> {
			Map<EndpointId, ExposableJmxEndpoint> endpoints = discover(discoverer);
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<String, JmxOperation> operationByName = mapOperations(
					endpoints.get(EndpointId.of('test')).getOperations());
			assertThat(operationByName).containsOnlyKeys('getAll', 'getSomething', 'update', 'deleteSomething');
			JmxOperation getAll = operationByName.get('getAll');
			assertThat(getInvoker(getAll)).isInstanceOf(CachingOperationInvoker.class);
			assertThat(((CachingOperationInvoker) getInvoker(getAll)).getTimeToLive()).isEqualTo(500);
		});
	}
	@Test
	void getEndpointsShouldCacheReadOperations() {
		load(AdditionalOperationJmxEndpointConfiguration.class, (id) -> 500L, (discoverer) -> {
			Map<EndpointId, ExposableJmxEndpoint> endpoints = discover(discoverer);
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<String, JmxOperation> operationByName = mapOperations(
					endpoints.get(EndpointId.of('test')).getOperations());
			assertThat(operationByName).containsOnlyKeys('getAll', 'getSomething', 'update', 'deleteSomething',
					'getAnother');
			JmxOperation getAll = operationByName.get('getAll');
			assertThat(getInvoker(getAll)).isInstanceOf(CachingOperationInvoker.class);
			assertThat(((CachingOperationInvoker) getInvoker(getAll)).getTimeToLive()).isEqualTo(500);
			JmxOperation getAnother = operationByName.get('getAnother');
			assertThat(getInvoker(getAnother)).isInstanceOf(CachingOperationInvoker.class);
			assertThat(((CachingOperationInvoker) getInvoker(getAnother)).getTimeToLive()).isEqualTo(500);
		});
	}
	@Test
	void getEndpointsWhenTwoExtensionsHaveTheSameEndpointTypeShouldThrowException() {
		load(ClashingJmxEndpointConfiguration.class, (discoverer) -> assertThatIllegalStateException()
			.isThrownBy(discoverer::getEndpoints)
			.withMessageContaining(
					'Found multiple extensions for the endpoint bean testEndpoint (testExtensionOne, testExtensionTwo)'));
	}
	@Test
	void getEndpointsWhenTwoStandardEndpointsHaveTheSameIdShouldThrowException() {
		load(ClashingStandardEndpointConfiguration.class,
				(discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
					.withMessageContaining('Found two endpoints with the id "test": '));
	}
	@Test
	void getEndpointsWhenWhenEndpointHasTwoOperationsWithTheSameNameShouldThrowException() {
		load(ClashingOperationsEndpoint.class, (discoverer) -> assertThatIllegalStateException()
			.isThrownBy(discoverer::getEndpoints)
			.withMessageContaining(
					'Unable to map duplicate endpoint operations: [MBean call "getAll"] to jmxEndpointDiscovererTests.ClashingOperationsEndpoint'));
	}
	@Test
	void getEndpointsWhenWhenExtensionHasTwoOperationsWithTheSameNameShouldThrowException() {
		load(AdditionalClashingOperationsConfiguration.class, (discoverer) -> assertThatIllegalStateException()
			.isThrownBy(discoverer::getEndpoints)
			.withMessageContaining(
					'Unable to map duplicate endpoint operations: [MBean call "getAll"] to testEndpoint (clashingOperationsJmxEndpointExtension)'));
	}
	@Test
	void getEndpointsWhenExtensionIsNotCompatibleWithTheEndpointTypeShouldThrowException() {
		load(InvalidJmxExtensionConfiguration.class, (discoverer) -> assertThatIllegalStateException()
			.isThrownBy(discoverer::getEndpoints)
			.withMessageContaining(
					'Endpoint bean "nonJmxEndpoint" cannot support the extension bean "nonJmxJmxEndpointExtension"'));
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new JmxEndpointDiscovererRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(JmxEndpointFilter.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(runtimeHints);
	}
	private Object getInvoker(JmxOperation operation) {
		return ReflectionTestUtils.getField(operation, 'invoker');
	}
	private void assertJmxTestEndpoint(ExposableJmxEndpoint endpoint) {
		Map<String, JmxOperation> operationsByName = mapOperations(endpoint.getOperations());
		assertThat(operationsByName).containsOnlyKeys('getAll', 'getSomething', 'update', 'deleteSomething');
		JmxOperation getAll = operationsByName.get('getAll');
		assertThat(getAll.getDescription()).isEqualTo('Get all the things');
		assertThat(getAll.getOutputType()).isEqualTo(Object.class);
		assertThat(getAll.getParameters()).isEmpty();
		JmxOperation getSomething = operationsByName.get('getSomething');
		assertThat(getSomething.getDescription()).isEqualTo('Get something based on a timeUnit');
		assertThat(getSomething.getOutputType()).isEqualTo(String.class);
		assertThat(getSomething.getParameters()).hasSize(1);
		hasDocumentedParameter(getSomething, 0, 'unitMs', Long.class, 'Number of milliseconds');
		JmxOperation update = operationsByName.get('update');
		assertThat(update.getDescription()).isEqualTo('Update something based on bar');
		assertThat(update.getOutputType()).isEqualTo(Void.TYPE);
		assertThat(update.getParameters()).hasSize(2);
		hasDocumentedParameter(update, 0, 'foo', String.class, 'Foo identifier');
		hasDocumentedParameter(update, 1, 'bar', String.class, 'Bar value');
		JmxOperation deleteSomething = operationsByName.get('deleteSomething');
		assertThat(deleteSomething.getDescription()).isEqualTo('Delete something based on a timeUnit');
		assertThat(deleteSomething.getOutputType()).isEqualTo(Void.TYPE);
		assertThat(deleteSomething.getParameters()).hasSize(1);
		hasDocumentedParameter(deleteSomething, 0, 'unitMs', Long.class, 'Number of milliseconds');
	}
	private void hasDocumentedParameter(JmxOperation operation, int index, String name, Class<?> type,
			String description) {
		assertThat(index).isLessThan(operation.getParameters().size());
		JmxOperationParameter parameter = operation.getParameters().get(index);
		assertThat(parameter.getName()).isEqualTo(name);
		assertThat(parameter.getType()).isEqualTo(type);
		assertThat(parameter.getDescription()).isEqualTo(description);
	}
	private Map<EndpointId, ExposableJmxEndpoint> discover(JmxEndpointDiscoverer discoverer) {
		Map<EndpointId, ExposableJmxEndpoint> byId = new HashMap<>();
		discoverer.getEndpoints().forEach((endpoint) -> byId.put(endpoint.getEndpointId(), endpoint));
		return byId;
	}
	private Map<String, JmxOperation> mapOperations(Collection<JmxOperation> operations) {
		Map<String, JmxOperation> byName = new HashMap<>();
		operations.forEach((operation) -> byName.put(operation.getName(), operation));
		return byName;
	}
	private void load(Class<?> configuration, Consumer<JmxEndpointDiscoverer> consumer) {
		load(configuration, (id) -> null, consumer);
	}
	private void load(Class<?> configuration, Function<EndpointId, Long> timeToLive,
			Consumer<JmxEndpointDiscoverer> consumer) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(configuration)) {
			ConversionServiceParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper(
					DefaultConversionService.getSharedInstance());
			JmxEndpointDiscoverer discoverer = new JmxEndpointDiscoverer(context, parameterMapper,
					Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)), Collections.emptyList(),
					Collections.emptyList());
			consumer.accept(discoverer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleEndpointsConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		TestJmxEndpoint testJmxEndpoint() {
			return new TestJmxEndpoint();
		}
		@Bean
		NonJmxEndpoint nonJmxEndpoint() {
			return new NonJmxEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OverriddenOperationJmxEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		TestJmxEndpointExtension testJmxEndpointExtension() {
			return new TestJmxEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AdditionalOperationJmxEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		AdditionalOperationJmxEndpointExtension additionalOperationJmxEndpointExtension() {
			return new AdditionalOperationJmxEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AdditionalClashingOperationsConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		ClashingOperationsJmxEndpointExtension clashingOperationsJmxEndpointExtension() {
			return new ClashingOperationsJmxEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingJmxEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		TestJmxEndpointExtension testExtensionOne() {
			return new TestJmxEndpointExtension();
		}
		@Bean
		TestJmxEndpointExtension testExtensionTwo() {
			return new TestJmxEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingStandardEndpointConfiguration {
		@Bean
		TestEndpoint testEndpointTwo() {
			return new TestEndpoint();
		}
		@Bean
		TestEndpoint testEndpointOne() {
			return new TestEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class InvalidJmxExtensionConfiguration {
		@Bean
		NonJmxEndpoint nonJmxEndpoint() {
			return new NonJmxEndpoint();
		}
		@Bean
		NonJmxJmxEndpointExtension nonJmxJmxEndpointExtension() {
			return new NonJmxJmxEndpointExtension();
		}
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		String getSomething(TimeUnit timeUnit) {
			return null;
		}
		@WriteOperation
		void update(String foo, String bar) {
		}
		@DeleteOperation
		void deleteSomething(TimeUnit timeUnit) {
		}
	}
	@JmxEndpoint(id = 'jmx')
	static class TestJmxEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@EndpointJmxExtension(endpoint = TestEndpoint.class)
	static class TestJmxEndpointExtension {
		@ManagedOperation(description = 'Get all the things')
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		@ManagedOperation(description = 'Get something based on a timeUnit')
		@ManagedOperationParameters({
				@ManagedOperationParameter(name = 'unitMs', description = 'Number of milliseconds') })
		String getSomething(Long timeUnit) {
			return null;
		}
		@WriteOperation
		@ManagedOperation(description = 'Update something based on bar')
		@ManagedOperationParameters({ @ManagedOperationParameter(name = 'foo', description = 'Foo identifier'),
				@ManagedOperationParameter(name = 'bar', description = 'Bar value') })
		void update(String foo, String bar) {
		}
		@DeleteOperation
		@ManagedOperation(description = 'Delete something based on a timeUnit')
		@ManagedOperationParameters({
				@ManagedOperationParameter(name = 'unitMs', description = 'Number of milliseconds') })
		void deleteSomething(Long timeUnit) {
		}
	}
	@EndpointJmxExtension(endpoint = TestEndpoint.class)
	static class AdditionalOperationJmxEndpointExtension {
		@ManagedOperation(description = 'Get another thing')
		@ReadOperation
		Object getAnother() {
			return null;
		}
	}
	@Endpoint(id = 'test')
	static class ClashingOperationsEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		Object getAll(String param) {
			return null;
		}
	}
	@EndpointJmxExtension(endpoint = TestEndpoint.class)
	static class ClashingOperationsJmxEndpointExtension {
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		Object getAll(String param) {
			return null;
		}
	}
	@WebEndpoint(id = 'nonjmx')
	static class NonJmxEndpoint {
		@ReadOperation
		Object getData() {
			return null;
		}
	}
	@EndpointJmxExtension(endpoint = NonJmxEndpoint.class)
	static class NonJmxJmxEndpointExtension {
		@ReadOperation
		Object getSomething() {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
class MBeanInfoFactoryTests {
	private final MBeanInfoFactory factory = new MBeanInfoFactory(new TestJmxOperationResponseMapper());
	@Test
	void getMBeanInfoShouldReturnMBeanInfo() {
		MBeanInfo info = this.factory.getMBeanInfo(new TestExposableJmxEndpoint(new TestJmxOperation()));
		assertThat(info).isNotNull();
		assertThat(info.getClassName()).isEqualTo(EndpointMBean.class.getName());
		assertThat(info.getDescription()).isEqualTo('MBean operations for endpoint test');
		assertThat(info.getAttributes()).isEmpty();
		assertThat(info.getNotifications()).isEmpty();
		assertThat(info.getConstructors()).isEmpty();
		assertThat(info.getOperations()).hasSize(1);
		MBeanOperationInfo operationInfo = info.getOperations()[0];
		assertThat(operationInfo.getName()).isEqualTo('testOperation');
		assertThat(operationInfo.getReturnType()).isEqualTo(String.class.getName());
		assertThat(operationInfo.getImpact()).isZero();
		assertThat(operationInfo.getSignature()).isEmpty();
	}
	@Test
	void getMBeanInfoWhenReadOperationShouldHaveInfoImpact() {
		MBeanInfo info = this.factory
			.getMBeanInfo(new TestExposableJmxEndpoint(new TestJmxOperation(OperationType.READ)));
		assertThat(info.getOperations()[0].getImpact()).isZero();
	}
	@Test
	void getMBeanInfoWhenWriteOperationShouldHaveActionImpact() {
		MBeanInfo info = this.factory
			.getMBeanInfo(new TestExposableJmxEndpoint(new TestJmxOperation(OperationType.WRITE)));
		assertThat(info.getOperations()[0].getImpact()).isOne();
	}
	@Test
	void getMBeanInfoWhenDeleteOperationShouldHaveActionImpact() {
		MBeanInfo info = this.factory
			.getMBeanInfo(new TestExposableJmxEndpoint(new TestJmxOperation(OperationType.DELETE)));
		assertThat(info.getOperations()[0].getImpact()).isOne();
	}
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void getMBeanInfoShouldUseJmxOperationResponseMapper() {
		JmxOperationResponseMapper mapper = mock(JmxOperationResponseMapper.class);
		given(mapper.mapResponseType(String.class)).willReturn((Class) Integer.class);
		MBeanInfoFactory factory = new MBeanInfoFactory(mapper);
		MBeanInfo info = factory.getMBeanInfo(new TestExposableJmxEndpoint(new TestJmxOperation()));
		MBeanOperationInfo operationInfo = info.getOperations()[0];
		assertThat(operationInfo.getReturnType()).isEqualTo(Integer.class.getName());
	}
	@Test
	void getMBeanShouldMapOperationParameters() {
		List<JmxOperationParameter> parameters = new ArrayList<>();
		parameters.add(mockParameter('one', String.class, 'myone'));
		parameters.add(mockParameter('two', Object.class, null));
		TestJmxOperation operation = new TestJmxOperation(parameters);
		MBeanInfo info = this.factory.getMBeanInfo(new TestExposableJmxEndpoint(operation));
		MBeanOperationInfo operationInfo = info.getOperations()[0];
		MBeanParameterInfo[] signature = operationInfo.getSignature();
		assertThat(signature).hasSize(2);
		assertThat(signature[0].getName()).isEqualTo('one');
		assertThat(signature[0].getType()).isEqualTo(String.class.getName());
		assertThat(signature[0].getDescription()).isEqualTo('myone');
		assertThat(signature[1].getName()).isEqualTo('two');
		assertThat(signature[1].getType()).isEqualTo(Object.class.getName());
		assertThat(signature[1].getDescription()).isNull();
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private JmxOperationParameter mockParameter(String name, Class<?> type, String description) {
		JmxOperationParameter parameter = mock(JmxOperationParameter.class);
		given(parameter.getName()).willReturn(name);
		given(parameter.getType()).willReturn((Class) type);
		given(parameter.getDescription()).willReturn(description);
		return parameter;
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
@ExtendWith(MockitoExtension.class)
class JmxEndpointExporterTests {
	private final JmxOperationResponseMapper responseMapper = new TestJmxOperationResponseMapper();
	private final List<ExposableJmxEndpoint> endpoints = new ArrayList<>();
	@Mock
	private MBeanServer mBeanServer;
	@Spy
	private EndpointObjectNameFactory objectNameFactory = new TestEndpointObjectNameFactory();
	private JmxEndpointExporter exporter;
	@BeforeEach
	void setup() {
		this.exporter = new JmxEndpointExporter(this.mBeanServer, this.objectNameFactory, this.responseMapper,
				this.endpoints);
	}
	@Test
	void createWhenMBeanServerIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new JmxEndpointExporter(null, this.objectNameFactory, this.responseMapper, this.endpoints))
			.withMessageContaining('MBeanServer must not be null');
	}
	@Test
	void createWhenObjectNameFactoryIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new JmxEndpointExporter(this.mBeanServer, null, this.responseMapper, this.endpoints))
			.withMessageContaining('ObjectNameFactory must not be null');
	}
	@Test
	void createWhenResponseMapperIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new JmxEndpointExporter(this.mBeanServer, this.objectNameFactory, null, this.endpoints))
			.withMessageContaining('ResponseMapper must not be null');
	}
	@Test
	void createWhenEndpointsIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new JmxEndpointExporter(this.mBeanServer, this.objectNameFactory, this.responseMapper, null))
			.withMessageContaining('Endpoints must not be null');
	}
	@Test
	void afterPropertiesSetShouldRegisterMBeans() throws Exception {
		this.endpoints.add(new TestExposableJmxEndpoint(new TestJmxOperation()));
		this.exporter.afterPropertiesSet();
		then(this.mBeanServer).should()
			.registerMBean(assertArg((object) -> assertThat(object).isInstanceOf(EndpointMBean.class)),
					assertArg((objectName) -> assertThat(objectName.getKeyProperty('name')).isEqualTo('test')));
	}
	@Test
	void registerShouldUseObjectNameFactory() throws Exception {
		this.endpoints.add(new TestExposableJmxEndpoint(new TestJmxOperation()));
		this.exporter.afterPropertiesSet();
		then(this.objectNameFactory).should().getObjectName(any(ExposableJmxEndpoint.class));
	}
	@Test
	void registerWhenObjectNameIsMalformedShouldThrowException() throws Exception {
		given(this.objectNameFactory.getObjectName(any(ExposableJmxEndpoint.class)))
			.willThrow(MalformedObjectNameException.class);
		this.endpoints.add(new TestExposableJmxEndpoint(new TestJmxOperation()));
		assertThatIllegalStateException().isThrownBy(this.exporter::afterPropertiesSet)
			.withMessageContaining('Invalid ObjectName for endpoint "test"');
	}
	@Test
	void registerWhenRegistrationFailsShouldThrowException() throws Exception {
		given(this.mBeanServer.registerMBean(any(), any(ObjectName.class)))
			.willThrow(new MBeanRegistrationException(new RuntimeException()));
		this.endpoints.add(new TestExposableJmxEndpoint(new TestJmxOperation()));
		assertThatExceptionOfType(MBeanExportException.class).isThrownBy(this.exporter::afterPropertiesSet)
			.withMessageContaining('Failed to register MBean for endpoint "test');
	}
	@Test
	void registerWhenEndpointHasNoOperationsShouldNotCreateMBean() {
		this.endpoints.add(new TestExposableJmxEndpoint());
		this.exporter.afterPropertiesSet();
		then(this.mBeanServer).shouldHaveNoInteractions();
	}
	@Test
	void destroyShouldUnregisterMBeans() throws Exception {
		this.endpoints.add(new TestExposableJmxEndpoint(new TestJmxOperation()));
		this.exporter.afterPropertiesSet();
		this.exporter.destroy();
		then(this.mBeanServer).should()
			.unregisterMBean(
					assertArg((objectName) -> assertThat(objectName.getKeyProperty('name')).isEqualTo('test')));
	}
	@Test
	void unregisterWhenInstanceNotFoundShouldContinue() throws Exception {
		this.endpoints.add(new TestExposableJmxEndpoint(new TestJmxOperation()));
		this.exporter.afterPropertiesSet();
		willThrow(InstanceNotFoundException.class).given(this.mBeanServer).unregisterMBean(any(ObjectName.class));
		this.exporter.destroy();
	}
	@Test
	void unregisterWhenUnregisterThrowsExceptionShouldThrowException() throws Exception {
		this.endpoints.add(new TestExposableJmxEndpoint(new TestJmxOperation()));
		this.exporter.afterPropertiesSet();
		willThrow(new MBeanRegistrationException(new RuntimeException())).given(this.mBeanServer)
			.unregisterMBean(any(ObjectName.class));
		assertThatExceptionOfType(JmxException.class).isThrownBy(() -> this.exporter.destroy())
			.withMessageContaining('Failed to unregister MBean with ObjectName "boot');
	}
	/**
	 * Test {@link EndpointObjectNameFactory}.
	 */
	static class TestEndpointObjectNameFactory implements EndpointObjectNameFactory {
		@Override
		public ObjectName getObjectName(ExposableJmxEndpoint endpoint) throws MalformedObjectNameException {
			return (endpoint != null) ? new ObjectName('boot:type=Endpoint,name=' + endpoint.getEndpointId()) : null;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public class TestJmxOperation implements JmxOperation {
	private final OperationType operationType;
	private final Function<Map<String, Object>, Object> invoke;
	private final List<JmxOperationParameter> parameters;
	public TestJmxOperation() {
		this.operationType = OperationType.READ;
		this.invoke = null;
		this.parameters = Collections.emptyList();
	}
	public TestJmxOperation(OperationType operationType) {
		this.operationType = operationType;
		this.invoke = null;
		this.parameters = Collections.emptyList();
	}
	public TestJmxOperation(Function<Map<String, Object>, Object> invoke) {
		this.operationType = OperationType.READ;
		this.invoke = invoke;
		this.parameters = Collections.emptyList();
	}
	public TestJmxOperation(List<JmxOperationParameter> parameters) {
		this.operationType = OperationType.READ;
		this.invoke = null;
		this.parameters = parameters;
	}
	@Override
	public OperationType getType() {
		return this.operationType;
	}
	@Override
	public Object invoke(InvocationContext context) {
		return (this.invoke != null) ? this.invoke.apply(context.getArguments()) : 'result';
	}
	@Override
	public String getName() {
		return 'testOperation';
	}
	@Override
	public Class<?> getOutputType() {
		return String.class;
	}
	@Override
	public String getDescription() {
		return 'Test JMX operation';
	}
	@Override
	public List<JmxOperationParameter> getParameters() {
		return this.parameters;
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public class TestExposableJmxEndpoint implements ExposableJmxEndpoint {
	private final Collection<JmxOperation> operations;
	public TestExposableJmxEndpoint(JmxOperation... operations) {
		this(Arrays.asList(operations));
	}
	public TestExposableJmxEndpoint(Collection<JmxOperation> operations) {
		this.operations = operations;
	}
	@Override
	public EndpointId getEndpointId() {
		return EndpointId.of('test');
	}
	@Override
	@SuppressWarnings('removal')
	public boolean isEnableByDefault() {
		return true;
	}
	@Override
	public Collection<JmxOperation> getOperations() {
		return this.operations;
	}
	@Override
	public Access getDefaultAccess() {
		return Access.UNRESTRICTED;
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
class EndpointMBeanTests {
	private static final Object[] NO_PARAMS = {};
	private static final String[] NO_SIGNATURE = {};
	private final TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(new TestJmxOperation());
	private final TestJmxOperationResponseMapper responseMapper = new TestJmxOperationResponseMapper();
	@Test
	void createWhenResponseMapperIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new EndpointMBean(null, null, mock(ExposableJmxEndpoint.class)))
			.withMessageContaining('ResponseMapper must not be null');
	}
	@Test
	void createWhenEndpointIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new EndpointMBean(mock(JmxOperationResponseMapper.class), null, null))
			.withMessageContaining('Endpoint must not be null');
	}
	@Test
	void getMBeanInfoShouldReturnMBeanInfo() {
		EndpointMBean bean = createEndpointMBean();
		MBeanInfo info = bean.getMBeanInfo();
		assertThat(info.getDescription()).isEqualTo('MBean operations for endpoint test');
	}
	@Test
	void invokeShouldInvokeJmxOperation() throws MBeanException, ReflectionException {
		EndpointMBean bean = createEndpointMBean();
		Object result = bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE);
		assertThat(result).isEqualTo('result');
	}
	@Test
	void invokeWhenOperationFailedShouldTranslateException() {
		TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(new TestJmxOperation((arguments) -> {
			throw new FatalBeanException('test failure');
		}));
		EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint);
		assertThatExceptionOfType(MBeanException.class)
			.isThrownBy(() -> bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE))
			.withCauseInstanceOf(IllegalStateException.class)
			.withMessageContaining('test failure');
	}
	@Test
	void invokeWhenOperationFailedWithJdkExceptionShouldReuseException() {
		TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(new TestJmxOperation((arguments) -> {
			throw new UnsupportedOperationException('test failure');
		}));
		EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint);
		assertThatExceptionOfType(MBeanException.class)
			.isThrownBy(() -> bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE))
			.withCauseInstanceOf(UnsupportedOperationException.class)
			.withMessageContaining('test failure');
	}
	@Test
	void invokeWhenActionNameIsNotAnOperationShouldThrowException() {
		EndpointMBean bean = createEndpointMBean();
		assertThatExceptionOfType(ReflectionException.class)
			.isThrownBy(() -> bean.invoke('missingOperation', NO_PARAMS, NO_SIGNATURE))
			.withCauseInstanceOf(IllegalArgumentException.class)
			.withMessageContaining('no operation named missingOperation');
	}
	@Test
	void invokeShouldInvokeJmxOperationWithBeanClassLoader() throws ReflectionException, MBeanException {
		ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
		TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(
				new TestJmxOperation((arguments) -> ClassUtils.getDefaultClassLoader()));
		URLClassLoader beanClassLoader = new URLClassLoader(new URL[0], getClass().getClassLoader());
		EndpointMBean bean = new EndpointMBean(this.responseMapper, beanClassLoader, endpoint);
		Object result = bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE);
		assertThat(result).isEqualTo(beanClassLoader);
		assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(originalClassLoader);
	}
	@Test
	void invokeWhenOperationIsInvalidShouldThrowException() {
		TestJmxOperation operation = new TestJmxOperation() {
			@Override
			public Object invoke(InvocationContext context) {
				throw new InvalidEndpointRequestException('test failure', 'test');
			}
		};
		TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(operation);
		EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint);
		assertThatExceptionOfType(ReflectionException.class)
			.isThrownBy(() -> bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE))
			.withRootCauseInstanceOf(IllegalArgumentException.class)
			.withMessageContaining('test failure');
	}
	@Test
	void invokeWhenMonoResultShouldBlockOnMono() throws MBeanException, ReflectionException {
		TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(
				new TestJmxOperation((arguments) -> Mono.just('monoResult')));
		EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint);
		Object result = bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE);
		assertThat(result).isEqualTo('monoResult');
	}
	@Test
	void invokeWhenFluxResultShouldCollectToMonoListAndBlockOnMono() throws MBeanException, ReflectionException {
		TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(
				new TestJmxOperation((arguments) -> Flux.just('flux', 'result')));
		EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint);
		Object result = bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE);
		assertThat(result).asInstanceOf(InstanceOfAssertFactories.LIST).containsExactly('flux', 'result');
	}
	@Test
	void invokeShouldCallResponseMapper() throws MBeanException, ReflectionException {
		TestJmxOperationResponseMapper responseMapper = spy(this.responseMapper);
		EndpointMBean bean = new EndpointMBean(responseMapper, null, this.endpoint);
		bean.invoke('testOperation', NO_PARAMS, NO_SIGNATURE);
		then(responseMapper).should().mapResponseType(String.class);
		then(responseMapper).should().mapResponse('result');
	}
	@Test
	void getAttributeShouldThrowException() {
		EndpointMBean bean = createEndpointMBean();
		assertThatExceptionOfType(AttributeNotFoundException.class).isThrownBy(() -> bean.getAttribute('test'))
			.withMessageContaining('EndpointMBeans do not support attributes');
	}
	@Test
	void setAttributeShouldThrowException() {
		EndpointMBean bean = createEndpointMBean();
		assertThatExceptionOfType(AttributeNotFoundException.class)
			.isThrownBy(() -> bean.setAttribute(new Attribute('test', 'test')))
			.withMessageContaining('EndpointMBeans do not support attributes');
	}
	@Test
	void getAttributesShouldReturnEmptyAttributeList() {
		EndpointMBean bean = createEndpointMBean();
		AttributeList attributes = bean.getAttributes(new String[] { 'test' });
		assertThat(attributes).isEmpty();
	}
	@Test
	void setAttributesShouldReturnEmptyAttributeList() {
		EndpointMBean bean = createEndpointMBean();
		AttributeList sourceAttributes = new AttributeList();
		sourceAttributes.add(new Attribute('test', 'test'));
		AttributeList attributes = bean.setAttributes(sourceAttributes);
		assertThat(attributes).isEmpty();
	}
	private EndpointMBean createEndpointMBean() {
		return new EndpointMBean(this.responseMapper, null, this.endpoint);
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
class JacksonJmxOperationResponseMapperTests {
	private final JacksonJmxOperationResponseMapper mapper = new JacksonJmxOperationResponseMapper(null);
	private final BasicJsonTester json = new BasicJsonTester(getClass());
	@Test
	void createWhenObjectMapperIsNullShouldUseDefaultObjectMapper() {
		JacksonJmxOperationResponseMapper mapper = new JacksonJmxOperationResponseMapper(null);
		Object mapped = mapper.mapResponse(Collections.singleton('test'));
		assertThat(this.json.from(mapped.toString())).isEqualToJson('[test]');
	}
	@Test
	void createWhenObjectMapperIsSpecifiedShouldUseObjectMapper() {
		ObjectMapper objectMapper = spy(ObjectMapper.class);
		JacksonJmxOperationResponseMapper mapper = new JacksonJmxOperationResponseMapper(objectMapper);
		Set<String> response = Collections.singleton('test');
		mapper.mapResponse(response);
		then(objectMapper).should().convertValue(eq(response), any(JavaType.class));
	}
	@Test
	void mapResponseTypeWhenCharSequenceShouldReturnString() {
		assertThat(this.mapper.mapResponseType(String.class)).isEqualTo(String.class);
		assertThat(this.mapper.mapResponseType(StringBuilder.class)).isEqualTo(String.class);
	}
	@Test
	void mapResponseTypeWhenArrayShouldReturnList() {
		assertThat(this.mapper.mapResponseType(String[].class)).isEqualTo(List.class);
		assertThat(this.mapper.mapResponseType(Object[].class)).isEqualTo(List.class);
	}
	@Test
	void mapResponseTypeWhenCollectionShouldReturnList() {
		assertThat(this.mapper.mapResponseType(Collection.class)).isEqualTo(List.class);
		assertThat(this.mapper.mapResponseType(Set.class)).isEqualTo(List.class);
		assertThat(this.mapper.mapResponseType(List.class)).isEqualTo(List.class);
	}
	@Test
	void mapResponseTypeWhenOtherShouldReturnMap() {
		assertThat(this.mapper.mapResponseType(ExampleBean.class)).isEqualTo(Map.class);
	}
	@Test
	void mapResponseWhenNullShouldReturnNull() {
		assertThat(this.mapper.mapResponse(null)).isNull();
	}
	@Test
	void mapResponseWhenCharSequenceShouldReturnString() {
		assertThat(this.mapper.mapResponse(new StringBuilder('test'))).isEqualTo('test');
	}
	@Test
	void mapResponseWhenArrayShouldReturnJsonArray() {
		Object mapped = this.mapper.mapResponse(new int[] { 1, 2, 3 });
		assertThat(this.json.from(mapped.toString())).isEqualToJson('[1,2,3]');
	}
	@Test
	void mapResponseWhenCollectionShouldReturnJsonArray() {
		Object mapped = this.mapper.mapResponse(Arrays.asList('a', 'b', 'c'));
		assertThat(this.json.from(mapped.toString())).isEqualToJson('[a,b,c]');
	}
	@Test
	void mapResponseWhenOtherShouldReturnMap() {
		ExampleBean bean = new ExampleBean();
		bean.setName('boot');
		Object mapped = this.mapper.mapResponse(bean);
		assertThat(this.json.from(mapped.toString())).isEqualToJson('{"name":"boot"}');
	}
	public static class ExampleBean {
		private String name;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
class DiscoveredOperationsFactoryTests {
	private TestDiscoveredOperationsFactory factory;
	private ParameterValueMapper parameterValueMapper;
	private List<OperationInvokerAdvisor> invokerAdvisors;
	@BeforeEach
	void setup() {
		this.parameterValueMapper = (parameter, value) -> value.toString();
		this.invokerAdvisors = new ArrayList<>();
		this.factory = new TestDiscoveredOperationsFactory(this.parameterValueMapper, this.invokerAdvisors);
	}
	@Test
	void createOperationsWhenHasReadMethodShouldCreateOperation() {
		Collection<TestOperation> operations = this.factory.createOperations(EndpointId.of('test'), new ExampleRead());
		assertThat(operations).hasSize(1);
		TestOperation operation = getFirst(operations);
		assertThat(operation.getType()).isEqualTo(OperationType.READ);
	}
	@Test
	void createOperationsWhenHasWriteMethodShouldCreateOperation() {
		Collection<TestOperation> operations = this.factory.createOperations(EndpointId.of('test'), new ExampleWrite());
		assertThat(operations).hasSize(1);
		TestOperation operation = getFirst(operations);
		assertThat(operation.getType()).isEqualTo(OperationType.WRITE);
	}
	@Test
	void createOperationsWhenHasDeleteMethodShouldCreateOperation() {
		Collection<TestOperation> operations = this.factory.createOperations(EndpointId.of('test'),
				new ExampleDelete());
		assertThat(operations).hasSize(1);
		TestOperation operation = getFirst(operations);
		assertThat(operation.getType()).isEqualTo(OperationType.DELETE);
	}
	@Test
	void createOperationsWhenMultipleShouldReturnMultiple() {
		Collection<TestOperation> operations = this.factory.createOperations(EndpointId.of('test'),
				new ExampleMultiple());
		assertThat(operations).hasSize(2);
		assertThat(operations.stream().map(TestOperation::getType)).containsOnly(OperationType.READ,
				OperationType.WRITE);
	}
	@Test
	void createOperationsShouldProvideOperationMethod() {
		TestOperation operation = getFirst(
				this.factory.createOperations(EndpointId.of('test'), new ExampleWithParams()));
		OperationMethod operationMethod = operation.getOperationMethod();
		assertThat(operationMethod.getMethod().getName()).isEqualTo('read');
		assertThat(operationMethod.getParameters().hasParameters()).isTrue();
	}
	@Test
	void createOperationsShouldProviderInvoker() {
		TestOperation operation = getFirst(
				this.factory.createOperations(EndpointId.of('test'), new ExampleWithParams()));
		Map<String, Object> params = Collections.singletonMap('name', 123);
		Object result = operation.invoke(new InvocationContext(mock(SecurityContext.class), params));
		assertThat(result).isEqualTo('123');
	}
	@Test
	void createOperationShouldApplyAdvisors() {
		TestOperationInvokerAdvisor advisor = new TestOperationInvokerAdvisor();
		this.invokerAdvisors.add(advisor);
		TestOperation operation = getFirst(this.factory.createOperations(EndpointId.of('test'), new ExampleRead()));
		operation.invoke(new InvocationContext(mock(SecurityContext.class), Collections.emptyMap()));
		assertThat(advisor.getEndpointId()).isEqualTo(EndpointId.of('test'));
		assertThat(advisor.getOperationType()).isEqualTo(OperationType.READ);
		assertThat(advisor.getParameters()).isEmpty();
	}
	@Test
	void createOperationShouldApplyProducesFrom() {
		TestOperation operation = getFirst(
				this.factory.createOperations(EndpointId.of('test'), new ExampleWithProducesFrom()));
		DiscoveredOperationMethod method = (DiscoveredOperationMethod) operation.getOperationMethod();
		assertThat(method.getProducesMediaTypes()).containsExactly('one/*', 'two/*', 'three/*');
	}
	private <T> T getFirst(Iterable<T> iterable) {
		return iterable.iterator().next();
	}
	static class ExampleRead {
		@ReadOperation
		String read() {
			return 'read';
		}
	}
	static class ExampleWrite {
		@WriteOperation
		String write() {
			return 'write';
		}
	}
	static class ExampleDelete {
		@DeleteOperation
		String delete() {
			return 'delete';
		}
	}
	static class ExampleMultiple {
		@ReadOperation
		String read() {
			return 'read';
		}
		@WriteOperation
		String write() {
			return 'write';
		}
	}
	static class ExampleWithParams {
		@ReadOperation
		String read(String name) {
			return name;
		}
	}
	static class ExampleWithProducesFrom {
		@ReadOperation(producesFrom = ExampleProducible.class)
		String read() {
			return 'read';
		}
	}
	static class TestDiscoveredOperationsFactory extends DiscoveredOperationsFactory<TestOperation> {
		TestDiscoveredOperationsFactory(ParameterValueMapper parameterValueMapper,
				Collection<OperationInvokerAdvisor> invokerAdvisors) {
			super(parameterValueMapper, invokerAdvisors);
		}
		@Override
		protected TestOperation createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
				OperationInvoker invoker) {
			return new TestOperation(endpointId, operationMethod, invoker);
		}
	}
	static class TestOperation extends AbstractDiscoveredOperation {
		TestOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
			super(operationMethod, invoker);
		}
	}
	static class TestOperationInvokerAdvisor implements OperationInvokerAdvisor {
		private EndpointId endpointId;
		private OperationType operationType;
		private OperationParameters parameters;
		@Override
		public OperationInvoker apply(EndpointId endpointId, OperationType operationType,
				OperationParameters parameters, OperationInvoker invoker) {
			this.endpointId = endpointId;
			this.operationType = operationType;
			this.parameters = parameters;
			return invoker;
		}
		EndpointId getEndpointId() {
			return this.endpointId;
		}
		OperationType getOperationType() {
			return this.operationType;
		}
		OperationParameters getParameters() {
			return this.parameters;
		}
	}
	enum ExampleProducible implements Producible<ExampleProducible> {
		ONE, TWO, THREE;
		@Override
		public MimeType getProducedMimeType() {
			return new MimeType(toString().toLowerCase(Locale.ROOT));
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
class EndpointDiscovererTests {
	@Test
	void createWhenApplicationContextIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestEndpointDiscoverer(null, mock(ParameterValueMapper.class),
					Collections.emptyList(), Collections.emptyList()))
			.withMessageContaining('ApplicationContext must not be null');
	}
	@Test
	void createWhenParameterValueMapperIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestEndpointDiscoverer(mock(ApplicationContext.class), null, Collections.emptyList(),
					Collections.emptyList()))
			.withMessageContaining('ParameterValueMapper must not be null');
	}
	@Test
	void createWhenInvokerAdvisorsIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestEndpointDiscoverer(mock(ApplicationContext.class),
					mock(ParameterValueMapper.class), null, Collections.emptyList()))
			.withMessageContaining('InvokerAdvisors must not be null');
	}
	@Test
	void createWhenFiltersIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestEndpointDiscoverer(mock(ApplicationContext.class),
					mock(ParameterValueMapper.class), Collections.emptyList(), null))
			.withMessageContaining('Filters must not be null');
	}
	@Test
	void getEndpointsWhenNoEndpointBeansShouldReturnEmptyCollection() {
		load(EmptyConfiguration.class, (context) -> {
			TestEndpointDiscoverer discoverer = new TestEndpointDiscoverer(context);
			Collection<TestExposableEndpoint> endpoints = discoverer.getEndpoints();
			assertThat(endpoints).isEmpty();
		});
	}
	@Test
	void getEndpointsWhenHasEndpointShouldReturnEndpoint() {
		load(TestEndpointConfiguration.class, this::hasTestEndpoint);
	}
	@Test
	void getEndpointsWhenHasEndpointInParentContextShouldReturnEndpoint() {
		AnnotationConfigApplicationContext parent = new AnnotationConfigApplicationContext(
				TestEndpointConfiguration.class);
		loadWithParent(parent, EmptyConfiguration.class, this::hasTestEndpoint);
	}
	@Test
	void getEndpointsWhenHasSubclassedEndpointShouldReturnEndpoint() {
		load(TestEndpointSubclassConfiguration.class, (context) -> {
			TestEndpointDiscoverer discoverer = new TestEndpointDiscoverer(context);
			Map<EndpointId, TestExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<Method, TestOperation> operations = mapOperations(endpoints.get(EndpointId.of('test')));
			assertThat(operations).hasSize(5);
			assertThat(operations).containsKeys(testEndpointMethods());
			assertThat(operations).containsKeys(ReflectionUtils.findMethod(TestEndpointSubclass.class,
					'updateWithMoreArguments', String.class, String.class, String.class));
		});
	}
	@Test
	void getEndpointsWhenTwoEndpointsHaveTheSameIdShouldThrowException() {
		load(ClashingEndpointConfiguration.class,
				(context) -> assertThatIllegalStateException()
					.isThrownBy(new TestEndpointDiscoverer(context)::getEndpoints)
					.withMessageContaining('Found two endpoints with the id "test": '));
	}
	@Test
	void getEndpointsWhenEndpointsArePrefixedWithScopedTargetShouldRegisterOnlyOneEndpoint() {
		load(ScopedTargetEndpointConfiguration.class, (context) -> {
			TestEndpoint expectedEndpoint = context.getBean('testEndpoint', TestEndpoint.class);
			Collection<TestExposableEndpoint> endpoints = new TestEndpointDiscoverer(context).getEndpoints();
			assertThat(endpoints).flatExtracting(TestExposableEndpoint::getEndpointBean).containsOnly(expectedEndpoint);
		});
	}
	@Test
	void getEndpointsWhenTtlSetToZeroShouldNotCacheInvokeCalls() {
		load(TestEndpointConfiguration.class, (context) -> {
			TestEndpointDiscoverer discoverer = new TestEndpointDiscoverer(context, (endpointId) -> 0L);
			Map<EndpointId, TestExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<Method, TestOperation> operations = mapOperations(endpoints.get(EndpointId.of('test')));
			operations.values()
				.forEach((operation) -> assertThat(operation.getInvoker())
					.isNotInstanceOf(CachingOperationInvoker.class));
		});
	}
	@Test
	void getEndpointsWhenTtlSetByIdAndIdDoesNotMatchShouldNotCacheInvokeCalls() {
		load(TestEndpointConfiguration.class, (context) -> {
			TestEndpointDiscoverer discoverer = new TestEndpointDiscoverer(context,
					(endpointId) -> (endpointId.equals(EndpointId.of('foo')) ? 500L : 0L));
			Map<EndpointId, TestExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<Method, TestOperation> operations = mapOperations(endpoints.get(EndpointId.of('test')));
			operations.values()
				.forEach((operation) -> assertThat(operation.getInvoker())
					.isNotInstanceOf(CachingOperationInvoker.class));
		});
	}
	@Test
	void getEndpointsWhenTtlSetByIdAndIdMatchesShouldCacheInvokeCalls() {
		load(TestEndpointConfiguration.class, (context) -> {
			TestEndpointDiscoverer discoverer = new TestEndpointDiscoverer(context,
					(endpointId) -> (endpointId.equals(EndpointId.of('test')) ? 500L : 0L));
			Map<EndpointId, TestExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			Map<Method, TestOperation> operations = mapOperations(endpoints.get(EndpointId.of('test')));
			TestOperation getAll = operations.get(findTestEndpointMethod('getAll'));
			TestOperation getOne = operations.get(findTestEndpointMethod('getOne', String.class));
			TestOperation update = operations
				.get(ReflectionUtils.findMethod(TestEndpoint.class, 'update', String.class, String.class));
			assertThat(((CachingOperationInvoker) getAll.getInvoker()).getTimeToLive()).isEqualTo(500);
			assertThat(getOne.getInvoker()).isNotInstanceOf(CachingOperationInvoker.class);
			assertThat(update.getInvoker()).isNotInstanceOf(CachingOperationInvoker.class);
		});
	}
	@Test
	void getEndpointsWhenHasSpecializedFiltersInNonSpecializedDiscovererShouldFilterEndpoints() {
		load(SpecializedEndpointsConfiguration.class, (context) -> {
			TestEndpointDiscoverer discoverer = new TestEndpointDiscoverer(context);
			Map<EndpointId, TestExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
		});
	}
	@Test
	void getEndpointsWhenHasSpecializedFiltersInSpecializedDiscovererShouldNotFilterEndpoints() {
		load(SpecializedEndpointsConfiguration.class, (context) -> {
			SpecializedEndpointDiscoverer discoverer = new SpecializedEndpointDiscoverer(context);
			Map<EndpointId, SpecializedExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'), EndpointId.of('specialized'),
					EndpointId.of('specialized-superclass'));
		});
	}
	@Test
	void getEndpointsShouldApplyExtensions() {
		load(SpecializedEndpointsConfiguration.class, (context) -> {
			SpecializedEndpointDiscoverer discoverer = new SpecializedEndpointDiscoverer(context);
			Map<EndpointId, SpecializedExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			Map<Method, SpecializedOperation> operations = mapOperations(endpoints.get(EndpointId.of('specialized')));
			assertThat(operations).containsKeys(ReflectionUtils.findMethod(SpecializedExtension.class, 'getSpecial'));
		});
	}
	@Test
	void getEndpointShouldFindParentExtension() {
		load(SubSpecializedEndpointsConfiguration.class, (context) -> {
			SpecializedEndpointDiscoverer discoverer = new SpecializedEndpointDiscoverer(context);
			Map<EndpointId, SpecializedExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			Map<Method, SpecializedOperation> operations = mapOperations(endpoints.get(EndpointId.of('specialized')));
			assertThat(operations).containsKeys(ReflectionUtils.findMethod(SpecializedTestEndpoint.class, 'getAll'));
			assertThat(operations).containsKeys(
					ReflectionUtils.findMethod(SubSpecializedTestEndpoint.class, 'getSpecialOne', String.class));
			assertThat(operations).containsKeys(ReflectionUtils.findMethod(SpecializedExtension.class, 'getSpecial'));
			assertThat(operations).hasSize(3);
		});
	}
	@Test
	void getEndpointsWhenHasProxiedEndpointShouldReturnEndpoint() {
		load(ProxiedSpecializedEndpointsConfiguration.class, (context) -> {
			SpecializedEndpointDiscoverer discoverer = new SpecializedEndpointDiscoverer(context);
			Map<EndpointId, SpecializedExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'), EndpointId.of('specialized'));
		});
	}
	@Test
	void getEndpointsShouldApplyEndpointFilters() {
		load(SpecializedEndpointsConfiguration.class, (context) -> {
			EndpointFilter<SpecializedExposableEndpoint> filter = (endpoint) -> {
				EndpointId id = endpoint.getEndpointId();
				return !id.equals(EndpointId.of('specialized')) && !id.equals(EndpointId.of('specialized-superclass'));
			};
			SpecializedEndpointDiscoverer discoverer = new SpecializedEndpointDiscoverer(context,
					Collections.singleton(filter), Collections.emptyList());
			Map<EndpointId, SpecializedExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
		});
	}
	@Test
	void getEndpointsShouldApplyOperationFilters() {
		load(SpecializedEndpointsConfiguration.class, (context) -> {
			OperationFilter<SpecializedOperation> operationFilter = (operation, endpointId,
					defaultAccess) -> operation.getType() == OperationType.READ;
			SpecializedEndpointDiscoverer discoverer = new SpecializedEndpointDiscoverer(context,
					Collections.emptyList(), List.of(operationFilter));
			Map<EndpointId, SpecializedExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints.values())
				.allSatisfy((endpoint) -> assertThat(endpoint.getOperations()).extracting(SpecializedOperation::getType)
					.containsOnly(OperationType.READ));
		});
	}
	private void hasTestEndpoint(AnnotationConfigApplicationContext context) {
		TestEndpointDiscoverer discoverer = new TestEndpointDiscoverer(context);
		Map<EndpointId, TestExposableEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
		assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
		Map<Method, TestOperation> operations = mapOperations(endpoints.get(EndpointId.of('test')));
		assertThat(operations).containsOnlyKeys(testEndpointMethods());
	}
	private Method[] testEndpointMethods() {
		List<Method> methods = new ArrayList<>();
		methods.add(findTestEndpointMethod('getAll'));
		methods.add(findTestEndpointMethod('getOne', String.class));
		methods.add(findTestEndpointMethod('update', String.class, String.class));
		methods.add(findTestEndpointMethod('deleteOne', String.class));
		return methods.toArray(new Method[0]);
	}
	private Method findTestEndpointMethod(String name, Class<?>... paramTypes) {
		return ReflectionUtils.findMethod(TestEndpoint.class, name, paramTypes);
	}
	private <E extends ExposableEndpoint<?>> Map<EndpointId, E> mapEndpoints(Collection<E> endpoints) {
		Map<EndpointId, E> byId = new LinkedHashMap<>();
		endpoints.forEach((endpoint) -> {
			E existing = byId.put(endpoint.getEndpointId(), endpoint);
			if (existing != null) {
				throw new AssertionError(
						String.format('Found endpoints with duplicate id "%s"', endpoint.getEndpointId()));
			}
		});
		return byId;
	}
	private <O extends Operation> Map<Method, O> mapOperations(ExposableEndpoint<O> endpoint) {
		Map<Method, O> byMethod = new HashMap<>();
		endpoint.getOperations().forEach((operation) -> {
			AbstractDiscoveredOperation discoveredOperation = (AbstractDiscoveredOperation) operation;
			Method method = discoveredOperation.getOperationMethod().getMethod();
			O existing = byMethod.put(method, operation);
			if (existing != null) {
				throw new AssertionError(String.format('Found endpoint with duplicate operation method "%s"', method));
			}
		});
		return byMethod;
	}
	private void load(Class<?> configuration, Consumer<AnnotationConfigApplicationContext> consumer) {
		load(null, configuration, consumer);
	}
	private void loadWithParent(ApplicationContext parent, Class<?> configuration,
			Consumer<AnnotationConfigApplicationContext> consumer) {
		load(parent, configuration, consumer);
	}
	private void load(ApplicationContext parent, Class<?> configuration,
			Consumer<AnnotationConfigApplicationContext> consumer) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		try (context) {
			if (parent != null) {
				context.setParent(parent);
			}
			context.register(configuration);
			context.refresh();
			consumer.accept(context);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class ProxiedSpecializedTestEndpointConfiguration {
		@Bean
		SpecializedExtension specializedExtension() {
			Enhancer enhancer = new Enhancer();
			enhancer.setSuperclass(SpecializedExtension.class);
			enhancer.setCallback((FixedValue) () -> null);
			return (SpecializedExtension) enhancer.create();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestEndpointSubclassConfiguration {
		@Bean
		TestEndpointSubclass testEndpointSubclass() {
			return new TestEndpointSubclass();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingEndpointConfiguration {
		@Bean
		TestEndpoint testEndpointTwo() {
			return new TestEndpoint();
		}
		@Bean
		TestEndpoint testEndpointOne() {
			return new TestEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ScopedTargetEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean(name = 'scopedTarget.testEndpoint')
		TestEndpoint scopedTargetTestEndpoint() {
			return new TestEndpoint();
		}
	}
	@Import({ TestEndpoint.class, SpecializedTestEndpoint.class, SpecializedSuperclassTestEndpoint.class,
			SpecializedExtension.class })
	static class SpecializedEndpointsConfiguration {
	}
	@Import({ TestEndpoint.class, SubSpecializedTestEndpoint.class, SpecializedExtension.class })
	static class SubSpecializedEndpointsConfiguration {
	}
	@Import({ TestEndpoint.class, SpecializedTestEndpoint.class, ProxiedSpecializedTestEndpointConfiguration.class })
	static class ProxiedSpecializedEndpointsConfiguration {
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		Object getOne(@Selector String id) {
			return null;
		}
		@WriteOperation
		void update(String foo, String bar) {
		}
		@DeleteOperation
		void deleteOne(@Selector String id) {
		}
		void someOtherMethod() {
		}
	}
	static class TestEndpointSubclass extends TestEndpoint {
		@WriteOperation
		void updateWithMoreArguments(String foo, String bar, String baz) {
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Endpoint
	@FilteredEndpoint(SpecializedEndpointFilter.class)
	@interface SpecializedEndpoint {
		@AliasFor(annotation = Endpoint.class)
		String id();
	}
	@EndpointExtension(endpoint = SpecializedTestEndpoint.class, filter = SpecializedEndpointFilter.class)
	static class SpecializedExtension {
		@ReadOperation
		Object getSpecial() {
			return null;
		}
	}
	static class SpecializedEndpointFilter extends DiscovererEndpointFilter {
		SpecializedEndpointFilter() {
			super(SpecializedEndpointDiscoverer.class);
		}
	}
	@SpecializedEndpoint(id = 'specialized')
	static class SpecializedTestEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@SpecializedEndpoint(id = 'specialized-superclass')
	static class AbstractFilteredEndpoint {
	}
	static class SpecializedSuperclassTestEndpoint extends AbstractFilteredEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	static class SubSpecializedTestEndpoint extends SpecializedTestEndpoint {
		@ReadOperation
		Object getSpecialOne(@Selector String id) {
			return null;
		}
	}
	static class TestEndpointDiscoverer extends EndpointDiscoverer<TestExposableEndpoint, TestOperation> {
		TestEndpointDiscoverer(ApplicationContext applicationContext) {
			this(applicationContext, (id) -> null);
		}
		TestEndpointDiscoverer(ApplicationContext applicationContext, Function<EndpointId, Long> timeToLive) {
			this(applicationContext, timeToLive, Collections.emptyList());
		}
		TestEndpointDiscoverer(ApplicationContext applicationContext, Function<EndpointId, Long> timeToLive,
				Collection<EndpointFilter<TestExposableEndpoint>> filters) {
			this(applicationContext, new ConversionServiceParameterValueMapper(),
					Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)), filters);
		}
		TestEndpointDiscoverer(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
				Collection<OperationInvokerAdvisor> invokerAdvisors,
				Collection<EndpointFilter<TestExposableEndpoint>> filters) {
			super(applicationContext, parameterValueMapper, invokerAdvisors, filters, Collections.emptyList());
		}
		@Override
		protected TestExposableEndpoint createEndpoint(Object endpointBean, EndpointId id, Access defaultAccess,
				Collection<TestOperation> operations) {
			return new TestExposableEndpoint(this, endpointBean, id, defaultAccess, operations);
		}
		@Override
		@SuppressWarnings('removal')
		protected TestExposableEndpoint createEndpoint(Object endpointBean, EndpointId id, boolean enabledByDefault,
				Collection<TestOperation> operations) {
			return new TestExposableEndpoint(this, endpointBean, id, enabledByDefault, operations);
		}
		@Override
		protected TestOperation createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
				OperationInvoker invoker) {
			return new TestOperation(operationMethod, invoker);
		}
		@Override
		protected OperationKey createOperationKey(TestOperation operation) {
			return new OperationKey(operation.getOperationMethod(),
					() -> 'TestOperation ' + operation.getOperationMethod());
		}
	}
	static class SpecializedEndpointDiscoverer
			extends EndpointDiscoverer<SpecializedExposableEndpoint, SpecializedOperation> {
		SpecializedEndpointDiscoverer(ApplicationContext applicationContext) {
			this(applicationContext, Collections.emptyList(), Collections.emptyList());
		}
		SpecializedEndpointDiscoverer(ApplicationContext applicationContext,
				Collection<EndpointFilter<SpecializedExposableEndpoint>> filters,
				Collection<OperationFilter<SpecializedOperation>> operationFilters) {
			super(applicationContext, new ConversionServiceParameterValueMapper(), Collections.emptyList(), filters,
					operationFilters);
		}
		@Override
		protected SpecializedExposableEndpoint createEndpoint(Object endpointBean, EndpointId id, Access defaultAccess,
				Collection<SpecializedOperation> operations) {
			return new SpecializedExposableEndpoint(this, endpointBean, id, defaultAccess, operations);
		}
		@Override
		@SuppressWarnings('removal')
		protected SpecializedExposableEndpoint createEndpoint(Object endpointBean, EndpointId id,
				boolean enabledByDefault, Collection<SpecializedOperation> operations) {
			return new SpecializedExposableEndpoint(this, endpointBean, id, enabledByDefault, operations);
		}
		@Override
		protected SpecializedOperation createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
				OperationInvoker invoker) {
			return new SpecializedOperation(operationMethod, invoker);
		}
		@Override
		protected OperationKey createOperationKey(SpecializedOperation operation) {
			return new OperationKey(operation.getOperationMethod(),
					() -> 'TestOperation ' + operation.getOperationMethod());
		}
	}
	static class TestExposableEndpoint extends AbstractDiscoveredEndpoint<TestOperation> {
		TestExposableEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id,
				Access defaultAccess, Collection<? extends TestOperation> operations) {
			super(discoverer, endpointBean, id, defaultAccess, operations);
		}
		@SuppressWarnings('removal')
		TestExposableEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id,
				boolean enabledByDefault, Collection<? extends TestOperation> operations) {
			super(discoverer, endpointBean, id, enabledByDefault, operations);
		}
	}
	static class SpecializedExposableEndpoint extends AbstractDiscoveredEndpoint<SpecializedOperation> {
		@SuppressWarnings('removal')
		SpecializedExposableEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id,
				Access defaultAccess, Collection<? extends SpecializedOperation> operations) {
			super(discoverer, endpointBean, id, defaultAccess, operations);
		}
		@SuppressWarnings('removal')
		SpecializedExposableEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id,
				boolean enabledByDefault, Collection<? extends SpecializedOperation> operations) {
			super(discoverer, endpointBean, id, enabledByDefault, operations);
		}
	}
	static class TestOperation extends AbstractDiscoveredOperation {
		private final OperationInvoker invoker;
		TestOperation(DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
			super(operationMethod, invoker);
			this.invoker = invoker;
		}
		OperationInvoker getInvoker() {
			return this.invoker;
		}
	}
	static class SpecializedOperation extends TestOperation {
		SpecializedOperation(DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
			super(operationMethod, invoker);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
class DiscoveredOperationMethodTests {
	@Test
	void createWhenAnnotationAttributesIsNullShouldThrowException() {
		Method method = ReflectionUtils.findMethod(getClass(), 'example');
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DiscoveredOperationMethod(method, OperationType.READ, null))
			.withMessageContaining('AnnotationAttributes must not be null');
	}
	@Test
	void getProducesMediaTypesShouldReturnMediaTypes() {
		Method method = ReflectionUtils.findMethod(getClass(), 'example');
		AnnotationAttributes annotationAttributes = new AnnotationAttributes();
		String[] produces = new String[] { 'application/json' };
		annotationAttributes.put('produces', produces);
		annotationAttributes.put('producesFrom', Producible.class);
		DiscoveredOperationMethod discovered = new DiscoveredOperationMethod(method, OperationType.READ,
				annotationAttributes);
		assertThat(discovered.getProducesMediaTypes()).containsExactly('application/json');
	}
	@Test
	void getProducesMediaTypesWhenProducesFromShouldReturnMediaTypes() {
		Method method = ReflectionUtils.findMethod(getClass(), 'example');
		AnnotationAttributes annotationAttributes = new AnnotationAttributes();
		annotationAttributes.put('produces', new String[0]);
		annotationAttributes.put('producesFrom', ExampleProducible.class);
		DiscoveredOperationMethod discovered = new DiscoveredOperationMethod(method, OperationType.READ,
				annotationAttributes);
		assertThat(discovered.getProducesMediaTypes()).containsExactly('one/*', 'two/*', 'three/*');
	}
	void example() {
	}
	enum ExampleProducible implements Producible<ExampleProducible> {
		ONE, TWO, THREE;
		@Override
		public MimeType getProducedMimeType() {
			return new MimeType(toString().toLowerCase(Locale.ROOT));
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
class OperationReflectiveProcessorTests {
	private final OperationReflectiveProcessor processor = new OperationReflectiveProcessor();
	private final RuntimeHints runtimeHints = new RuntimeHints();
	@Test
	void shouldRegisterMethodAsInvokable() {
		Method method = ReflectionUtils.findMethod(Methods.class, 'string');
		runProcessor(method);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(method)).accepts(this.runtimeHints);
	}
	@Test
	void shouldRegisterReturnType() {
		Method method = ReflectionUtils.findMethod(Methods.class, 'dto');
		runProcessor(method);
		assertHintsForDto();
	}
	@Test
	void shouldRegisterMapValueFromReturnType() {
		Method method = ReflectionUtils.findMethod(Methods.class, 'dtos');
		runProcessor(method);
		assertHintsForDto();
	}
	@Test
	void shouldRegisterWebEndpointResponseReturnType() {
		Method method = ReflectionUtils.findMethod(Methods.class, 'webEndpointResponse');
		runProcessor(method);
		assertHintsForDto();
		assertThat(RuntimeHintsPredicates.reflection().onType(WebEndpointResponse.class)).rejects(this.runtimeHints);
	}
	@Test
	void shouldNotRegisterResourceReturnType() {
		Method method = ReflectionUtils.findMethod(Methods.class, 'resource');
		runProcessor(method);
		assertThat(RuntimeHintsPredicates.reflection().onType(Resource.class)).rejects(this.runtimeHints);
	}
	private void assertHintsForDto() {
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(Dto.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(this.runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(NestedDto.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
			.accepts(this.runtimeHints);
	}
	private void runProcessor(Method method) {
		this.processor.registerReflectionHints(this.runtimeHints.reflection(), method);
	}
	@SuppressWarnings('unused')
	private static final class Methods {
		private String string() {
			return null;
		}
		private Map<String, List<Dto>> dtos() {
			return null;
		}
		private Dto dto() {
			return null;
		}
		private WebEndpointResponse<Dto> webEndpointResponse() {
			return null;
		}
		private Resource resource() {
			return null;
		}
	}
	@SuppressWarnings('unused')
	public static class Dto {
		private final NestedDto nestedDto = new NestedDto();
		public NestedDto getNestedDto() {
			return this.nestedDto;
		}
	}
	public static class NestedDto {
		private final String string = 'some-string';
		public String getString() {
			return this.string;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
class DiscovererEndpointFilterTests {
	@Test
	void createWhenDiscovererIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TestDiscovererEndpointFilter(null))
			.withMessageContaining('Discoverer must not be null');
	}
	@Test
	void matchWhenDiscoveredByDiscovererShouldReturnTrue() {
		DiscovererEndpointFilter filter = new TestDiscovererEndpointFilter(TestDiscovererA.class);
		DiscoveredEndpoint<?> endpoint = mockDiscoveredEndpoint(TestDiscovererA.class);
		assertThat(filter.match(endpoint)).isTrue();
	}
	@Test
	void matchWhenNotDiscoveredByDiscovererShouldReturnFalse() {
		DiscovererEndpointFilter filter = new TestDiscovererEndpointFilter(TestDiscovererA.class);
		DiscoveredEndpoint<?> endpoint = mockDiscoveredEndpoint(TestDiscovererB.class);
		assertThat(filter.match(endpoint)).isFalse();
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private DiscoveredEndpoint<?> mockDiscoveredEndpoint(Class<?> discoverer) {
		DiscoveredEndpoint endpoint = mock(DiscoveredEndpoint.class);
		given(endpoint.wasDiscoveredBy(discoverer)).willReturn(true);
		return endpoint;
	}
	static class TestDiscovererEndpointFilter extends DiscovererEndpointFilter {
		TestDiscovererEndpointFilter(Class<? extends EndpointDiscoverer<?, ?>> discoverer) {
			super(discoverer);
		}
	}
	abstract static class TestDiscovererA extends EndpointDiscoverer<ExposableEndpoint<Operation>, Operation> {
		TestDiscovererA(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
				Collection<OperationInvokerAdvisor> invokerAdvisors,
				Collection<EndpointFilter<ExposableEndpoint<Operation>>> filters) {
			super(applicationContext, parameterValueMapper, invokerAdvisors, filters, Collections.emptyList());
		}
	}
	abstract static class TestDiscovererB extends EndpointDiscoverer<ExposableEndpoint<Operation>, Operation> {
		TestDiscovererB(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
				Collection<OperationInvokerAdvisor> invokerAdvisors,
				Collection<EndpointFilter<ExposableEndpoint<Operation>>> filters) {
			super(applicationContext, parameterValueMapper, invokerAdvisors, filters, Collections.emptyList());
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
class WebEndpointResponseTests {
	@Test
	void createWithNoParamsShouldReturn200() {
		WebEndpointResponse<Object> response = new WebEndpointResponse<>();
		assertThat(response.getStatus()).isEqualTo(200);
		assertThat(response.getBody()).isNull();
	}
	@Test
	void createWithStatusShouldReturnStatus() {
		WebEndpointResponse<Object> response = new WebEndpointResponse<>(404);
		assertThat(response.getStatus()).isEqualTo(404);
		assertThat(response.getBody()).isNull();
	}
	@Test
	void createWithBodyShouldReturnBody() {
		WebEndpointResponse<Object> response = new WebEndpointResponse<>('body');
		assertThat(response.getStatus()).isEqualTo(200);
		assertThat(response.getBody()).isEqualTo('body');
	}
	@Test
	void createWithBodyAndStatusShouldReturnStatusAndBody() {
		WebEndpointResponse<Object> response = new WebEndpointResponse<>('body', 500);
		assertThat(response.getStatus()).isEqualTo(500);
		assertThat(response.getBody()).isEqualTo('body');
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
class LinkTests {
	@Test
	void createWhenHrefIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Link(null))
			.withMessageContaining('HREF must not be null');
	}
	@Test
	void getHrefShouldReturnHref() {
		String href = 'https://example.com';
		Link link = new Link(href);
		assertThat(link.getHref()).isEqualTo(href);
	}
	@Test
	void isTemplatedWhenContainsPlaceholderShouldReturnTrue() {
		String href = 'https://example.com/{path}';
		Link link = new Link(href);
		assertThat(link.isTemplated()).isTrue();
	}
	@Test
	void isTemplatedWhenContainsNoPlaceholderShouldReturnFalse() {
		String href = 'https://example.com/path';
		Link link = new Link(href);
		assertThat(link.isTemplated()).isFalse();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@SuppressWarnings('removal')
class EndpointLinksResolverTests {
	@Test
	void linkResolutionWithTrailingSlashStripsSlashOnSelfLink() {
		Map<String, Link> links = new EndpointLinksResolver(Collections.emptyList())
			.resolveLinks('https://api.example.com/actuator/');
		assertThat(links).hasSize(1);
		assertThat(links).hasEntrySatisfying('self', linkWithHref('https://api.example.com/actuator'));
	}
	@Test
	void linkResolutionWithoutTrailingSlash() {
		Map<String, Link> links = new EndpointLinksResolver(Collections.emptyList())
			.resolveLinks('https://api.example.com/actuator');
		assertThat(links).hasSize(1);
		assertThat(links).hasEntrySatisfying('self', linkWithHref('https://api.example.com/actuator'));
	}
	@Test
	void resolvedLinksContainsALinkForEachWebEndpointOperation() {
		List<WebOperation> operations = new ArrayList<>();
		operations.add(operationWithPath('/alpha', 'alpha'));
		operations.add(operationWithPath('/alpha/{name}', 'alpha-name'));
		ExposableWebEndpoint endpoint = mock(ExposableWebEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(EndpointId.of('alpha'));
		given(endpoint.isEnableByDefault()).willReturn(true);
		given(endpoint.getOperations()).willReturn(operations);
		String requestUrl = 'https://api.example.com/actuator';
		Map<String, Link> links = new EndpointLinksResolver(Collections.singletonList(endpoint))
			.resolveLinks(requestUrl);
		assertThat(links).hasSize(3);
		assertThat(links).hasEntrySatisfying('self', linkWithHref('https://api.example.com/actuator'));
		assertThat(links).hasEntrySatisfying('alpha', linkWithHref('https://api.example.com/actuator/alpha'));
		assertThat(links).hasEntrySatisfying('alpha-name',
				linkWithHref('https://api.example.com/actuator/alpha/{name}'));
	}
	@Test
	@SuppressWarnings('removal')
	void resolvedLinksContainsALinkForServletEndpoint() {
		ExposableServletEndpoint servletEndpoint = mock(ExposableServletEndpoint.class);
		given(servletEndpoint.getEndpointId()).willReturn(EndpointId.of('alpha'));
		given(servletEndpoint.isEnableByDefault()).willReturn(true);
		given(servletEndpoint.getRootPath()).willReturn('alpha');
		String requestUrl = 'https://api.example.com/actuator';
		Map<String, Link> links = new EndpointLinksResolver(Collections.singletonList(servletEndpoint))
			.resolveLinks(requestUrl);
		assertThat(links).hasSize(2);
		assertThat(links).hasEntrySatisfying('self', linkWithHref('https://api.example.com/actuator'));
		assertThat(links).hasEntrySatisfying('alpha', linkWithHref('https://api.example.com/actuator/alpha'));
	}
	@Test
	void resolvedLinksContainsALinkForControllerEndpoint() {
		ExposableControllerEndpoint controllerEndpoint = mock(ExposableControllerEndpoint.class);
		given(controllerEndpoint.getEndpointId()).willReturn(EndpointId.of('alpha'));
		given(controllerEndpoint.isEnableByDefault()).willReturn(true);
		given(controllerEndpoint.getRootPath()).willReturn('alpha');
		String requestUrl = 'https://api.example.com/actuator';
		Map<String, Link> links = new EndpointLinksResolver(Collections.singletonList(controllerEndpoint))
			.resolveLinks(requestUrl);
		assertThat(links).hasSize(2);
		assertThat(links).hasEntrySatisfying('self', linkWithHref('https://api.example.com/actuator'));
		assertThat(links).hasEntrySatisfying('alpha', linkWithHref('https://api.example.com/actuator/alpha'));
	}
	private WebOperation operationWithPath(String path, String id) {
		WebOperationRequestPredicate predicate = new WebOperationRequestPredicate(path, WebEndpointHttpMethod.GET,
				Collections.emptyList(), Collections.emptyList());
		WebOperation operation = mock(WebOperation.class);
		given(operation.getId()).willReturn(id);
		given(operation.getType()).willReturn(OperationType.READ);
		given(operation.getRequestPredicate()).willReturn(predicate);
		return operation;
	}
	private Condition<Link> linkWithHref(String href) {
		return new Condition<>((link) -> href.equals(link.getHref()), 'Link with href "%s"', href);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class ServletEndpointDiscovererTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void getEndpointsWhenNoEndpointBeansShouldReturnEmptyCollection() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run(assertDiscoverer((discoverer) -> assertThat(discoverer.getEndpoints()).isEmpty()));
	}
	@Test
	void getEndpointsShouldIncludeServletEndpoints() {
		this.contextRunner.withUserConfiguration(TestServletEndpoint.class).run(assertDiscoverer((discoverer) -> {
			Collection<ExposableServletEndpoint> endpoints = discoverer.getEndpoints();
			assertThat(endpoints).hasSize(1);
			ExposableServletEndpoint endpoint = endpoints.iterator().next();
			assertThat(endpoint.getEndpointId()).isEqualTo(EndpointId.of('testservlet'));
			assertThat(endpoint.getEndpointServlet()).isNotNull();
			assertThat(endpoint).isInstanceOf(DiscoveredEndpoint.class);
		}));
	}
	@Test
	void getEndpointsShouldDiscoverProxyServletEndpoints() {
		this.contextRunner.withUserConfiguration(TestProxyServletEndpoint.class)
			.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.run(assertDiscoverer((discoverer) -> {
				Collection<ExposableServletEndpoint> endpoints = discoverer.getEndpoints();
				assertThat(endpoints).hasSize(1);
				ExposableServletEndpoint endpoint = endpoints.iterator().next();
				assertThat(endpoint.getEndpointId()).isEqualTo(EndpointId.of('testservlet'));
				assertThat(endpoint.getEndpointServlet()).isNotNull();
				assertThat(endpoint).isInstanceOf(DiscoveredEndpoint.class);
			}));
	}
	@Test
	void getEndpointsShouldNotDiscoverRegularEndpoints() {
		this.contextRunner.withUserConfiguration(WithRegularEndpointConfiguration.class)
			.run(assertDiscoverer((discoverer) -> {
				Collection<ExposableServletEndpoint> endpoints = discoverer.getEndpoints();
				List<EndpointId> ids = endpoints.stream().map(ExposableServletEndpoint::getEndpointId).toList();
				assertThat(ids).containsOnly(EndpointId.of('testservlet'));
			}));
	}
	@Test
	void getEndpointWhenEndpointHasOperationsShouldThrowException() {
		this.contextRunner.withUserConfiguration(TestServletEndpointWithOperation.class)
			.run(assertDiscoverer((discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
				.withMessageContaining('ServletEndpoints must not declare operations')));
	}
	@Test
	void getEndpointWhenEndpointNotASupplierShouldThrowException() {
		this.contextRunner.withUserConfiguration(TestServletEndpointNotASupplier.class)
			.run(assertDiscoverer((discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
				.withMessageContaining('must be a supplier')));
	}
	@Test
	void getEndpointWhenEndpointSuppliesWrongTypeShouldThrowException() {
		this.contextRunner.withUserConfiguration(TestServletEndpointSupplierOfWrongType.class)
			.run(assertDiscoverer((discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
				.withMessageContaining('must supply an EndpointServlet')));
	}
	@Test
	void getEndpointWhenEndpointSuppliesNullShouldThrowException() {
		this.contextRunner.withUserConfiguration(TestServletEndpointSupplierOfNull.class)
			.run(assertDiscoverer((discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
				.withMessageContaining('must not supply null')));
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new ServletEndpointDiscoverer.ServletEndpointDiscovererRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(ServletEndpointFilter.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(runtimeHints);
	}
	private ContextConsumer<AssertableApplicationContext> assertDiscoverer(
			Consumer<ServletEndpointDiscoverer> consumer) {
		return (context) -> {
			ServletEndpointDiscoverer discoverer = new ServletEndpointDiscoverer(context, null,
					Collections.emptyList());
			consumer.accept(discoverer);
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ TestEndpoint.class, TestServletEndpoint.class })
	static class WithRegularEndpointConfiguration {
	}
	@ServletEndpoint(id = 'testservlet')
	static class TestServletEndpoint implements Supplier<EndpointServlet> {
		@Override
		public EndpointServlet get() {
			return new EndpointServlet(TestServlet.class);
		}
	}
	@ServletEndpoint(id = 'testservlet')
	@Validated
	static class TestProxyServletEndpoint implements Supplier<EndpointServlet> {
		@Override
		public EndpointServlet get() {
			return new EndpointServlet(TestServlet.class);
		}
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
	}
	@ServletEndpoint(id = 'testservlet')
	static class TestServletEndpointWithOperation implements Supplier<EndpointServlet> {
		@Override
		public EndpointServlet get() {
			return new EndpointServlet(TestServlet.class);
		}
		@ReadOperation
		String read() {
			return 'error';
		}
	}
	static class TestServlet extends GenericServlet {
		@Override
		public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		}
	}
	@ServletEndpoint(id = 'testservlet')
	static class TestServletEndpointNotASupplier {
	}
	@ServletEndpoint(id = 'testservlet')
	static class TestServletEndpointSupplierOfWrongType implements Supplier<String> {
		@Override
		public String get() {
			return 'error';
		}
	}
	@ServletEndpoint(id = 'testservlet')
	static class TestServletEndpointSupplierOfNull implements Supplier<EndpointServlet> {
		@Override
		public EndpointServlet get() {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
class RequestPredicateFactoryTests {
	private final RequestPredicateFactory factory = new RequestPredicateFactory(
			new EndpointMediaTypes(Collections.emptyList(), Collections.emptyList()));
	private final String rootPath = '/root';
	@Test
	void getRequestPredicateWhenHasMoreThanOneMatchAllThrowsException() {
		DiscoveredOperationMethod operationMethod = getDiscoveredOperationMethod(MoreThanOneMatchAll.class);
		assertThatIllegalStateException()
			.isThrownBy(() -> this.factory.getRequestPredicate(this.rootPath, operationMethod))
			.withMessage('@Selector annotation with Match.ALL_REMAINING must be unique');
	}
	@Test
	void getRequestPredicateWhenMatchAllIsNotLastParameterThrowsException() {
		DiscoveredOperationMethod operationMethod = getDiscoveredOperationMethod(MatchAllIsNotLastParameter.class);
		assertThatIllegalStateException()
			.isThrownBy(() -> this.factory.getRequestPredicate(this.rootPath, operationMethod))
			.withMessage('@Selector annotation with Match.ALL_REMAINING must be the last parameter');
	}
	@Test
	void getRequestPredicateReturnsPredicateWithPath() {
		DiscoveredOperationMethod operationMethod = getDiscoveredOperationMethod(ValidSelectors.class);
		WebOperationRequestPredicate requestPredicate = this.factory.getRequestPredicate(this.rootPath,
				operationMethod);
		assertThat(requestPredicate.getPath()).isEqualTo('/root/{one}/{*two}');
	}
	@Test
	void getRequestPredicateWithSlashRootReturnsPredicateWithPathWithoutDoubleSlash() {
		DiscoveredOperationMethod operationMethod = getDiscoveredOperationMethod(ValidSelectors.class);
		WebOperationRequestPredicate requestPredicate = this.factory.getRequestPredicate('/', operationMethod);
		assertThat(requestPredicate.getPath()).isEqualTo('/{one}/{*two}');
	}
	private DiscoveredOperationMethod getDiscoveredOperationMethod(Class<?> source) {
		Method method = source.getDeclaredMethods()[0];
		AnnotationAttributes attributes = new AnnotationAttributes();
		attributes.put('produces', 'application/json');
		return new DiscoveredOperationMethod(method, OperationType.READ, attributes);
	}
	static class MoreThanOneMatchAll {
		void test(@Selector(match = Match.ALL_REMAINING) String[] one,
				@Selector(match = Match.ALL_REMAINING) String[] two) {
		}
	}
	static class MatchAllIsNotLastParameter {
		void test(@Selector(match = Match.ALL_REMAINING) String[] one, @Selector String[] two) {
		}
	}
	static class ValidSelectors {
		void test(@Selector String[] one, @Selector(match = Match.ALL_REMAINING) String[] two) {
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
class WebEndpointDiscovererTests {
	@Test
	void getEndpointsWhenNoEndpointBeansShouldReturnEmptyCollection() {
		load(EmptyConfiguration.class, (discoverer) -> assertThat(discoverer.getEndpoints()).isEmpty());
	}
	@Test
	void getEndpointsWhenWebExtensionIsMissingEndpointShouldThrowException() {
		load(TestWebEndpointExtensionConfiguration.class,
				(discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
					.withMessageContaining('Invalid extension "endpointExtension": no endpoint found with id "test"'));
	}
	@Test
	void getEndpointsWhenHasFilteredEndpointShouldOnlyDiscoverWebEndpoints() {
		load(MultipleEndpointsConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
		});
	}
	@Test
	void getEndpointsWhenHasWebExtensionShouldOverrideStandardEndpoint() {
		load(OverriddenOperationWebEndpointExtensionConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('test'));
			assertThat(requestPredicates(endpoint)).has(requestPredicates(
					path('test').httpMethod(WebEndpointHttpMethod.GET).consumes().produces('application/json')));
		});
	}
	@Test
	void getEndpointsWhenExtensionAddsOperationShouldHaveBothOperations() {
		load(AdditionalOperationWebEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('test'));
			assertThat(requestPredicates(endpoint)).has(requestPredicates(
					path('test').httpMethod(WebEndpointHttpMethod.GET).consumes().produces('application/json'),
					path('test/{id}').httpMethod(WebEndpointHttpMethod.GET).consumes().produces('application/json')));
		});
	}
	@Test
	void getEndpointsWhenPredicateForWriteOperationThatReturnsVoidShouldHaveNoProducedMediaTypes() {
		load(VoidWriteOperationEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('voidwrite'));
			ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('voidwrite'));
			assertThat(requestPredicates(endpoint)).has(requestPredicates(
					path('voidwrite').httpMethod(WebEndpointHttpMethod.POST).produces().consumes('application/json')));
		});
	}
	@Test
	void getEndpointsWhenTwoExtensionsHaveTheSameEndpointTypeShouldThrowException() {
		load(ClashingWebEndpointConfiguration.class,
				(discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
					.withMessageContaining('Found multiple extensions for the endpoint bean '
							+ 'testEndpoint (testExtensionOne, testExtensionTwo)'));
	}
	@Test
	void getEndpointsWhenTwoStandardEndpointsHaveTheSameIdShouldThrowException() {
		load(ClashingStandardEndpointConfiguration.class,
				(discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
					.withMessageContaining('Found two endpoints with the id "test": '));
	}
	@Test
	void getEndpointsWhenWhenEndpointHasTwoOperationsWithTheSameNameShouldThrowException() {
		load(ClashingOperationsEndpointConfiguration.class,
				(discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
					.withMessageContaining('Unable to map duplicate endpoint operations: '
							+ '[web request predicate GET to path "test" '
							+ 'produces: application/json] to clashingOperationsEndpoint'));
	}
	@Test
	void getEndpointsWhenExtensionIsNotCompatibleWithTheEndpointTypeShouldThrowException() {
		load(InvalidWebExtensionConfiguration.class,
				(discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
					.withMessageContaining('Endpoint bean "nonWebEndpoint" cannot support the '
							+ 'extension bean "nonWebWebEndpointExtension"'));
	}
	@Test
	void getEndpointsWhenWhenExtensionHasTwoOperationsWithTheSameNameShouldThrowException() {
		load(ClashingSelectorsWebEndpointExtensionConfiguration.class,
				(discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
					.withMessageContaining('Unable to map duplicate endpoint operations')
					.withMessageContaining('to testEndpoint (clashingSelectorsExtension)'));
	}
	@Test
	void getEndpointsWhenHasCacheWithTtlShouldCacheReadOperationWithTtlValue() {
		load((id) -> 500L, EndpointId::toString, TestEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('test'));
			assertThat(endpoint.getOperations()).hasSize(1);
			WebOperation operation = endpoint.getOperations().iterator().next();
			Object invoker = ReflectionTestUtils.getField(operation, 'invoker');
			assertThat(invoker).isInstanceOf(CachingOperationInvoker.class);
			assertThat(((CachingOperationInvoker) invoker).getTimeToLive()).isEqualTo(500);
		});
	}
	@Test
	void getEndpointsWhenOperationReturnsResourceShouldProduceApplicationOctetStream() {
		load(ResourceEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('resource'));
			ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('resource'));
			assertThat(requestPredicates(endpoint))
				.has(requestPredicates(path('resource').httpMethod(WebEndpointHttpMethod.GET)
					.consumes()
					.produces('application/octet-stream')));
		});
	}
	@Test
	void getEndpointsWhenHasCustomMediaTypeShouldProduceCustomMediaType() {
		load(CustomMediaTypesEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('custommediatypes'));
			ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('custommediatypes'));
			assertThat(requestPredicates(endpoint)).has(requestPredicates(
					path('custommediatypes').httpMethod(WebEndpointHttpMethod.GET).consumes().produces('text/plain'),
					path('custommediatypes').httpMethod(WebEndpointHttpMethod.POST).consumes().produces('a/b', 'c/d'),
					path('custommediatypes').httpMethod(WebEndpointHttpMethod.DELETE)
						.consumes()
						.produces('text/plain')));
		});
	}
	@Test
	void getEndpointsWhenHasCustomPathShouldReturnCustomPath() {
		load((id) -> null, (id) -> 'custom/' + id, AdditionalOperationWebEndpointConfiguration.class, (discoverer) -> {
			Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
			assertThat(endpoints).containsOnlyKeys(EndpointId.of('test'));
			ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('test'));
			Condition<List<? extends WebOperationRequestPredicate>> expected = requestPredicates(
					path('custom/test').httpMethod(WebEndpointHttpMethod.GET).consumes().produces('application/json'),
					path('custom/test/{id}').httpMethod(WebEndpointHttpMethod.GET)
						.consumes()
						.produces('application/json'));
			assertThat(requestPredicates(endpoint)).has(expected);
		});
	}
	@Test
	void getEndpointsWhenHasAdditionalPaths() {
		AdditionalPathsMapper additionalPathsMapper = (id, webServerNamespace) -> {
			if (!WebServerNamespace.SERVER.equals(webServerNamespace)) {
				return Collections.emptyList();
			}
			return List.of('/test');
		};
		load((id) -> null, EndpointId::toString, additionalPathsMapper,
				AdditionalOperationWebEndpointConfiguration.class, (discoverer) -> {
					Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());
					ExposableWebEndpoint endpoint = endpoints.get(EndpointId.of('test'));
					assertThat(endpoint.getAdditionalPaths(WebServerNamespace.SERVER)).containsExactly('/test');
					assertThat(endpoint.getAdditionalPaths(WebServerNamespace.MANAGEMENT)).isEmpty();
				});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new WebEndpointDiscovererRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(WebEndpointFilter.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(runtimeHints);
	}
	private void load(Class<?> configuration, Consumer<WebEndpointDiscoverer> consumer) {
		load((id) -> null, EndpointId::toString, configuration, consumer);
	}
	private void load(Function<EndpointId, Long> timeToLive, PathMapper endpointPathMapper, Class<?> configuration,
			Consumer<WebEndpointDiscoverer> consumer) {
		load(timeToLive, endpointPathMapper, null, configuration, consumer);
	}
	private void load(Function<EndpointId, Long> timeToLive, PathMapper endpointPathMapper,
			AdditionalPathsMapper additionalPathsMapper, Class<?> configuration,
			Consumer<WebEndpointDiscoverer> consumer) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(configuration)) {
			ConversionServiceParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper(
					DefaultConversionService.getSharedInstance());
			EndpointMediaTypes mediaTypes = new EndpointMediaTypes(Collections.singletonList('application/json'),
					Collections.singletonList('application/json'));
			WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(context, parameterMapper, mediaTypes,
					Collections.singletonList(endpointPathMapper),
					(additionalPathsMapper != null) ? Collections.singletonList(additionalPathsMapper) : null,
					Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)), Collections.emptyList(),
					Collections.emptyList());
			consumer.accept(discoverer);
		}
	}
	private Map<EndpointId, ExposableWebEndpoint> mapEndpoints(Collection<ExposableWebEndpoint> endpoints) {
		Map<EndpointId, ExposableWebEndpoint> endpointById = new HashMap<>();
		endpoints.forEach((endpoint) -> endpointById.put(endpoint.getEndpointId(), endpoint));
		return endpointById;
	}
	private List<WebOperationRequestPredicate> requestPredicates(ExposableWebEndpoint endpoint) {
		return endpoint.getOperations().stream().map(WebOperation::getRequestPredicate).toList();
	}
	private Condition<List<? extends WebOperationRequestPredicate>> requestPredicates(
			RequestPredicateMatcher... matchers) {
		return new Condition<>((predicates) -> {
			if (predicates.size() != matchers.length) {
				return false;
			}
			Map<WebOperationRequestPredicate, Long> matchCounts = new HashMap<>();
			for (WebOperationRequestPredicate predicate : predicates) {
				matchCounts.put(predicate, Stream.of(matchers).filter((matcher) -> matcher.matches(predicate)).count());
			}
			return matchCounts.values().stream().noneMatch((count) -> count != 1);
		}, Arrays.toString(matchers));
	}
	private RequestPredicateMatcher path(String path) {
		return new RequestPredicateMatcher(path);
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleEndpointsConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		NonWebEndpoint nonWebEndpoint() {
			return new NonWebEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestWebEndpointExtensionConfiguration {
		@Bean
		TestWebEndpointExtension endpointExtension() {
			return new TestWebEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingOperationsEndpointConfiguration {
		@Bean
		ClashingOperationsEndpoint clashingOperationsEndpoint() {
			return new ClashingOperationsEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingOperationsWebEndpointExtensionConfiguration {
		@Bean
		ClashingOperationsWebEndpointExtension clashingOperationsExtension() {
			return new ClashingOperationsWebEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestEndpointConfiguration.class)
	static class OverriddenOperationWebEndpointExtensionConfiguration {
		@Bean
		OverriddenOperationWebEndpointExtension overriddenOperationExtension() {
			return new OverriddenOperationWebEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestEndpointConfiguration.class)
	static class AdditionalOperationWebEndpointConfiguration {
		@Bean
		AdditionalOperationWebEndpointExtension additionalOperationExtension() {
			return new AdditionalOperationWebEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingWebEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		TestWebEndpointExtension testExtensionOne() {
			return new TestWebEndpointExtension();
		}
		@Bean
		TestWebEndpointExtension testExtensionTwo() {
			return new TestWebEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingStandardEndpointConfiguration {
		@Bean
		TestEndpoint testEndpointTwo() {
			return new TestEndpoint();
		}
		@Bean
		TestEndpoint testEndpointOne() {
			return new TestEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClashingSelectorsWebEndpointExtensionConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		ClashingSelectorsWebEndpointExtension clashingSelectorsExtension() {
			return new ClashingSelectorsWebEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class InvalidWebExtensionConfiguration {
		@Bean
		NonWebEndpoint nonWebEndpoint() {
			return new NonWebEndpoint();
		}
		@Bean
		NonWebWebEndpointExtension nonWebWebEndpointExtension() {
			return new NonWebWebEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class VoidWriteOperationEndpointConfiguration {
		@Bean
		VoidWriteOperationEndpoint voidWriteOperationEndpoint() {
			return new VoidWriteOperationEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class ResourceEndpointConfiguration {
		@Bean
		ResourceEndpoint resourceEndpoint() {
			return new ResourceEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomMediaTypesEndpointConfiguration {
		@Bean
		CustomMediaTypesEndpoint customMediaTypesEndpoint() {
			return new CustomMediaTypesEndpoint();
		}
	}
	@EndpointWebExtension(endpoint = TestEndpoint.class)
	static class TestWebEndpointExtension {
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		Object getOne(@Selector String id) {
			return null;
		}
		@WriteOperation
		void update(String foo, String bar) {
		}
		void someOtherMethod() {
		}
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@EndpointWebExtension(endpoint = TestEndpoint.class)
	static class OverriddenOperationWebEndpointExtension {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@EndpointWebExtension(endpoint = TestEndpoint.class)
	static class AdditionalOperationWebEndpointExtension {
		@ReadOperation
		Object getOne(@Selector String id) {
			return null;
		}
	}
	@Endpoint(id = 'test')
	static class ClashingOperationsEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		Object getAgain() {
			return null;
		}
	}
	@EndpointWebExtension(endpoint = TestEndpoint.class)
	static class ClashingOperationsWebEndpointExtension {
		@ReadOperation
		Object getAll() {
			return null;
		}
		@ReadOperation
		Object getAgain() {
			return null;
		}
	}
	@EndpointWebExtension(endpoint = TestEndpoint.class)
	static class ClashingSelectorsWebEndpointExtension {
		@ReadOperation
		Object readOne(@Selector String oneA, @Selector String oneB) {
			return null;
		}
		@ReadOperation
		Object readTwo(@Selector String twoA, @Selector String twoB) {
			return null;
		}
	}
	@JmxEndpoint(id = 'nonweb')
	static class NonWebEndpoint {
		@ReadOperation
		Object getData() {
			return null;
		}
	}
	@EndpointWebExtension(endpoint = NonWebEndpoint.class)
	static class NonWebWebEndpointExtension {
		@ReadOperation
		Object getSomething(@Selector String name) {
			return null;
		}
	}
	@Endpoint(id = 'voidwrite')
	static class VoidWriteOperationEndpoint {
		@WriteOperation
		void write(String foo, String bar) {
		}
	}
	@Endpoint(id = 'resource')
	static class ResourceEndpoint {
		@ReadOperation
		Resource read() {
			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });
		}
	}
	@Endpoint(id = 'custommediatypes')
	static class CustomMediaTypesEndpoint {
		@ReadOperation(produces = 'text/plain')
		String read() {
			return 'read';
		}
		@WriteOperation(produces = { 'a/b', 'c/d' })
		String write() {
			return 'write';
		}
		@DeleteOperation(produces = 'text/plain')
		String delete() {
			return 'delete';
		}
	}
	private static final class RequestPredicateMatcher {
		private final String path;
		private List<String> produces;
		private List<String> consumes;
		private WebEndpointHttpMethod httpMethod;
		private RequestPredicateMatcher(String path) {
			this.path = path;
		}
		RequestPredicateMatcher produces(String... mediaTypes) {
			this.produces = Arrays.asList(mediaTypes);
			return this;
		}
		RequestPredicateMatcher consumes(String... mediaTypes) {
			this.consumes = Arrays.asList(mediaTypes);
			return this;
		}
		private RequestPredicateMatcher httpMethod(WebEndpointHttpMethod httpMethod) {
			this.httpMethod = httpMethod;
			return this;
		}
		private boolean matches(WebOperationRequestPredicate predicate) {
			return (this.path == null || this.path.equals(predicate.getPath()))
					&& (this.httpMethod == null || this.httpMethod == predicate.getHttpMethod())
					&& (this.produces == null || this.produces.equals(new ArrayList<>(predicate.getProduces())))
					&& (this.consumes == null || this.consumes.equals(new ArrayList<>(predicate.getConsumes())));
		}
		@Override
		public String toString() {
			return 'Request predicate with path = "' + this.path + '", httpMethod = "' + this.httpMethod
					+ '", produces = "' + this.produces + '"';
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
public abstract class AbstractWebEndpointIntegrationTests<T extends ConfigurableApplicationContext & AnnotationConfigRegistry> {
	private static final Duration TIMEOUT = Duration.ofMinutes(5);
	private static final String ACTUATOR_MEDIA_TYPE_PATTERN = 'application/vnd.test\\+json(;charset=UTF-8)?';
	private static final String JSON_MEDIA_TYPE_PATTERN = 'application/json(;charset=UTF-8)?';
	private final Supplier<T> applicationContextSupplier;
	private final Consumer<T> authenticatedContextCustomizer;
	protected AbstractWebEndpointIntegrationTests(Supplier<T> applicationContextSupplier,
			Consumer<T> authenticatedContextCustomizer) {
		this.applicationContextSupplier = applicationContextSupplier;
		this.authenticatedContextCustomizer = authenticatedContextCustomizer;
	}
	@Test
	void readOperation() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/test')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('All')
					.isEqualTo(true));
	}
	@Test
	void readOperationWithEndpointsMappedToTheRoot() {
		load(TestEndpointConfiguration.class, '',
				(client) -> client.get()
					.uri('/test')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('All')
					.isEqualTo(true));
	}
	@Test
	void readOperationWithEndpointPathMappedToTheRoot() {
		load(EndpointPathMappedToRootConfiguration.class, '', (client) -> {
			client.get().uri('/').exchange().expectStatus().isOk().expectBody().jsonPath('All').isEqualTo(true);
			client.get()
				.uri('/some-part')
				.exchange()
				.expectStatus()
				.isOk()
				.expectBody()
				.jsonPath('part')
				.isEqualTo('some-part');
		});
	}
	@Test
	void readOperationWithSelector() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/test/one')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('part')
					.isEqualTo('one'));
	}
	@Test
	void readOperationWithSelectorContainingADot() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/test/foo.bar')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('part')
					.isEqualTo('foo.bar'));
	}
	@Test
	void linksToOtherEndpointsAreProvided() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('_links.length()')
					.isEqualTo(3)
					.jsonPath('_links.self.href')
					.isNotEmpty()
					.jsonPath('_links.self.templated')
					.isEqualTo(false)
					.jsonPath('_links.test.href')
					.isNotEmpty()
					.jsonPath('_links.test.templated')
					.isEqualTo(false)
					.jsonPath('_links.test-part.href')
					.isNotEmpty()
					.jsonPath('_links.test-part.templated')
					.isEqualTo(true));
	}
	@Test
	void linksMappingIsDisabledWhenEndpointPathIsEmpty() {
		load(TestEndpointConfiguration.class, '',
				(client) -> client.get().uri('').exchange().expectStatus().isNotFound());
	}
	@Test
	protected void operationWithTrailingSlashShouldNotMatch() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get().uri('/test/').exchange().expectStatus().isNotFound());
	}
	@Test
	void matchAllRemainingPathsSelectorShouldMatchFullPath() {
		load(MatchAllRemainingEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/matchallremaining/one/two/three')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('selection')
					.isEqualTo('one|two|three'));
	}
	@Test
	void matchAllRemainingPathsSelectorShouldDecodePath() {
		load(MatchAllRemainingEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/matchallremaining/one/two three/')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('selection')
					.isEqualTo('one|two three'));
	}
	@Test
	void readOperationWithSingleQueryParameters() {
		load(QueryEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/query?one=1&two=2')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('query')
					.isEqualTo('1 2'));
	}
	@Test
	void readOperationWithQueryParametersMissing() {
		load(QueryEndpointConfiguration.class,
				(client) -> client.get().uri('/query').exchange().expectStatus().isBadRequest());
	}
	@Test
	void reactiveReadOperationWithSingleQueryParameters() {
		load(ReactiveQueryEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/query?param=test')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('query')
					.isEqualTo('test'));
	}
	@Test
	void reactiveReadOperationWithQueryParametersMissing() {
		load(ReactiveQueryEndpointConfiguration.class,
				(client) -> client.get().uri('/query').exchange().expectStatus().isBadRequest());
	}
	@Test
	void readOperationWithSingleQueryParametersAndMultipleValues() {
		load(QueryEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/query?one=1&one=1&two=2')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('query')
					.isEqualTo('1,1 2'));
	}
	@Test
	void readOperationWithListQueryParameterAndSingleValue() {
		load(QueryWithListEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/query?one=1&two=2')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('query')
					.isEqualTo('1 [2]'));
	}
	@Test
	void readOperationWithListQueryParameterAndMultipleValues() {
		load(QueryWithListEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/query?one=1&two=2&two=2')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('query')
					.isEqualTo('1 [2, 2]'));
	}
	@Test
	void readOperationWithMappingFailureProducesBadRequestResponse() {
		load(QueryEndpointConfiguration.class, (client) -> {
			WebTestClient.BodyContentSpec body = client.get()
				.uri('/query?two=two')
				.accept(MediaType.APPLICATION_JSON)
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody();
			validateErrorBody(body, HttpStatus.BAD_REQUEST, '/endpoints/query', 'Missing parameters: one');
		});
	}
	@Test
	void writeOperation() {
		load(TestEndpointConfiguration.class, (client) -> {
			Map<String, Object> body = new HashMap<>();
			body.put('foo', 'one');
			body.put('bar', 'two');
			client.post().uri('/test').bodyValue(body).exchange().expectStatus().isNoContent().expectBody().isEmpty();
		});
	}
	@Test
	void writeOperationWithVoidResponse() {
		load(VoidWriteResponseEndpointConfiguration.class, (context, client) -> {
			client.post().uri('/voidwrite').exchange().expectStatus().isNoContent().expectBody().isEmpty();
			then(context.getBean(EndpointDelegate.class)).should().write();
		});
	}
	@Test
	void deleteOperation() {
		load(TestEndpointConfiguration.class,
				(client) -> client.delete()
					.uri('/test/one')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('part')
					.isEqualTo('one'));
	}
	@Test
	void deleteOperationWithVoidResponse() {
		load(VoidDeleteResponseEndpointConfiguration.class, (context, client) -> {
			client.delete().uri('/voiddelete').exchange().expectStatus().isNoContent().expectBody().isEmpty();
			then(context.getBean(EndpointDelegate.class)).should().delete();
		});
	}
	@Test
	void nullIsPassedToTheOperationWhenArgumentIsNotFoundInPostRequestBody() {
		load(TestEndpointConfiguration.class, (context, client) -> {
			Map<String, Object> body = new HashMap<>();
			body.put('foo', 'one');
			client.post().uri('/test').bodyValue(body).exchange().expectStatus().isNoContent().expectBody().isEmpty();
			then(context.getBean(EndpointDelegate.class)).should().write('one', null);
		});
	}
	@Test
	void nullsArePassedToTheOperationWhenPostRequestHasNoBody() {
		load(TestEndpointConfiguration.class, (context, client) -> {
			client.post()
				.uri('/test')
				.contentType(MediaType.APPLICATION_JSON)
				.exchange()
				.expectStatus()
				.isNoContent()
				.expectBody()
				.isEmpty();
			then(context.getBean(EndpointDelegate.class)).should().write(null, null);
		});
	}
	@Test
	void nullResponseFromReadOperationResultsInNotFoundResponseStatus() {
		load(NullReadResponseEndpointConfiguration.class,
				(context, client) -> client.get().uri('/nullread').exchange().expectStatus().isNotFound());
	}
	@Test
	void nullResponseFromDeleteOperationResultsInNoContentResponseStatus() {
		load(NullDeleteResponseEndpointConfiguration.class,
				(context, client) -> client.delete().uri('/nulldelete').exchange().expectStatus().isNoContent());
	}
	@Test
	void nullResponseFromWriteOperationResultsInNoContentResponseStatus() {
		load(NullWriteResponseEndpointConfiguration.class,
				(context, client) -> client.post().uri('/nullwrite').exchange().expectStatus().isNoContent());
	}
	@Test
	void readOperationWithResourceResponse() {
		load(ResourceEndpointConfiguration.class, (context, client) -> {
			byte[] responseBody = client.get()
				.uri('/resource')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.contentType(MediaType.APPLICATION_OCTET_STREAM)
				.returnResult(byte[].class)
				.getResponseBodyContent();
			assertThat(responseBody).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
		});
	}
	@Test
	void readOperationWithResourceWebOperationResponse() {
		load(ResourceWebEndpointResponseEndpointConfiguration.class, (context, client) -> {
			byte[] responseBody = client.get()
				.uri('/resource')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.contentType(MediaType.APPLICATION_OCTET_STREAM)
				.returnResult(byte[].class)
				.getResponseBodyContent();
			assertThat(responseBody).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
		});
	}
	@Test
	void readOperationWithMonoResponse() {
		load(MonoResponseEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/mono')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('a')
					.isEqualTo('alpha'));
	}
	@Test
	void readOperationWithFluxResponse() {
		load(FluxResponseEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/flux')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('[0].a')
					.isEqualTo('alpha')
					.jsonPath('[1].b')
					.isEqualTo('bravo')
					.jsonPath('[2].c')
					.isEqualTo('charlie'));
	}
	@Test
	void readOperationWithCustomMediaType() {
		load(CustomMediaTypesEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/custommediatypes')
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueMatches('Content-Type', 'text/plain(;charset=.*)?'));
	}
	@Test
	void readOperationWithMissingRequiredParametersReturnsBadRequestResponse() {
		load(RequiredParameterEndpointConfiguration.class, (client) -> {
			WebTestClient.BodyContentSpec body = client.get()
				.uri('/requiredparameters')
				.accept(MediaType.APPLICATION_JSON)
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody();
			validateErrorBody(body, HttpStatus.BAD_REQUEST, '/endpoints/requiredparameters', 'Missing parameters: foo');
		});
	}
	@Test
	void readOperationWithMissingNullableParametersIsOk() {
		load(RequiredParameterEndpointConfiguration.class,
				(client) -> client.get().uri('/requiredparameters?foo=hello').exchange().expectStatus().isOk());
	}
	@Test
	void endpointsProducePrimaryMediaTypeByDefault() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/test')
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueMatches('Content-Type', ACTUATOR_MEDIA_TYPE_PATTERN));
	}
	@Test
	void endpointsProduceSecondaryMediaTypeWhenRequested() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/test')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueMatches('Content-Type', JSON_MEDIA_TYPE_PATTERN));
	}
	@Test
	void linksProducesPrimaryMediaTypeByDefault() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('')
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueMatches('Content-Type', ACTUATOR_MEDIA_TYPE_PATTERN));
	}
	@Test
	void linksProducesSecondaryMediaTypeWhenRequested() {
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueMatches('Content-Type', JSON_MEDIA_TYPE_PATTERN));
	}
	@Test
	void principalIsNullWhenRequestHasNoPrincipal() {
		load(PrincipalEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/principal')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody(String.class)
					.isEqualTo('None'));
	}
	@Test
	void principalIsAvailableWhenRequestHasAPrincipal() {
		load((context) -> {
			this.authenticatedContextCustomizer.accept(context);
			context.register(PrincipalEndpointConfiguration.class);
		}, (client) -> client.get()
			.uri('/principal')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('Alice'));
	}
	@Test
	void operationWithAQueryNamedPrincipalCanBeAccessedWhenAuthenticated() {
		load((context) -> {
			this.authenticatedContextCustomizer.accept(context);
			context.register(PrincipalQueryEndpointConfiguration.class);
		}, (client) -> client.get()
			.uri('/principalquery?principal=Zoe')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('Zoe'));
	}
	@Test
	void securityContextIsAvailableAndHasNullPrincipalWhenRequestHasNoPrincipal() {
		load(SecurityContextEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/securitycontext')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody(String.class)
					.isEqualTo('None'));
	}
	@Test
	void securityContextIsAvailableAndHasPrincipalWhenRequestHasPrincipal() {
		load((context) -> {
			this.authenticatedContextCustomizer.accept(context);
			context.register(SecurityContextEndpointConfiguration.class);
		}, (client) -> client.get()
			.uri('/securitycontext')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('Alice'));
	}
	@Test
	void userInRoleReturnsFalseWhenRequestHasNoPrincipal() {
		load(UserInRoleEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/userinrole?role=ADMIN')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody(String.class)
					.isEqualTo('ADMIN: false'));
	}
	@Test
	void userInRoleReturnsFalseWhenUserIsNotInRole() {
		load((context) -> {
			this.authenticatedContextCustomizer.accept(context);
			context.register(UserInRoleEndpointConfiguration.class);
		}, (client) -> client.get()
			.uri('/userinrole?role=ADMIN')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('ADMIN: false'));
	}
	@Test
	void userInRoleReturnsTrueWhenUserIsInRole() {
		load((context) -> {
			this.authenticatedContextCustomizer.accept(context);
			context.register(UserInRoleEndpointConfiguration.class);
		}, (client) -> client.get()
			.uri('/userinrole?role=ACTUATOR')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('ACTUATOR: true'));
	}
	@Test
	void endpointCanProduceAResponseWithACustomStatus() {
		load((context) -> context.register(CustomResponseStatusEndpointConfiguration.class),
				(client) -> client.get().uri('/customstatus').exchange().expectStatus().isEqualTo(234));
	}
	protected abstract int getPort(T context);
	protected void validateErrorBody(WebTestClient.BodyContentSpec body, HttpStatus status, String path,
			String message) {
		body.jsonPath('status')
			.isEqualTo(status.value())
			.jsonPath('error')
			.isEqualTo(status.getReasonPhrase())
			.jsonPath('path')
			.isEqualTo(path)
			.jsonPath('message')
			.isEqualTo(message);
	}
	private void load(Class<?> configuration, BiConsumer<ApplicationContext, WebTestClient> consumer) {
		load((context) -> context.register(configuration), '/endpoints', consumer);
	}
	protected void load(Class<?> configuration, Consumer<WebTestClient> clientConsumer) {
		load((context) -> context.register(configuration), '/endpoints',
				(context, client) -> clientConsumer.accept(client));
	}
	protected void load(Consumer<T> contextCustomizer, Consumer<WebTestClient> clientConsumer) {
		load(contextCustomizer, '/endpoints', (context, client) -> clientConsumer.accept(client));
	}
	protected void load(Class<?> configuration, String endpointPath, Consumer<WebTestClient> clientConsumer) {
		load((context) -> context.register(configuration), endpointPath,
				(context, client) -> clientConsumer.accept(client));
	}
	private void load(Consumer<T> contextCustomizer, String endpointPath,
			BiConsumer<ApplicationContext, WebTestClient> consumer) {
		T applicationContext = this.applicationContextSupplier.get();
		contextCustomizer.accept(applicationContext);
		Map<String, Object> properties = new HashMap<>();
		properties.put('endpointPath', endpointPath);
		properties.put('server.error.include-message', 'always');
		applicationContext.getEnvironment().getPropertySources().addLast(new MapPropertySource('test', properties));
		applicationContext.refresh();
		try {
			InetSocketAddress address = new InetSocketAddress(getPort(applicationContext));
			String url = 'http://' + address.getHostString() + ':' + address.getPort() + endpointPath;
			consumer.accept(applicationContext,
					WebTestClient.bindToServer().baseUrl(url).responseTimeout(TIMEOUT).build());
		}
		finally {
			applicationContext.close();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	protected static class TestEndpointConfiguration {
		@Bean
		public TestEndpoint testEndpoint(EndpointDelegate endpointDelegate) {
			return new TestEndpoint(endpointDelegate);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestEndpointConfiguration.class)
	protected static class EndpointPathMappedToRootConfiguration {
		@Bean
		PathMapper pathMapper() {
			return (endpointId) -> '/';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class MatchAllRemainingEndpointConfiguration {
		@Bean
		MatchAllRemainingEndpoint matchAllRemainingEndpoint() {
			return new MatchAllRemainingEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class QueryEndpointConfiguration {
		@Bean
		QueryEndpoint queryEndpoint() {
			return new QueryEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class QueryWithListEndpointConfiguration {
		@Bean
		QueryWithListEndpoint queryEndpoint() {
			return new QueryWithListEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class ReactiveQueryEndpointConfiguration {
		@Bean
		ReactiveQueryEndpoint reactiveQueryEndpoint() {
			return new ReactiveQueryEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class VoidWriteResponseEndpointConfiguration {
		@Bean
		VoidWriteResponseEndpoint voidWriteResponseEndpoint(EndpointDelegate delegate) {
			return new VoidWriteResponseEndpoint(delegate);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class VoidDeleteResponseEndpointConfiguration {
		@Bean
		VoidDeleteResponseEndpoint voidDeleteResponseEndpoint(EndpointDelegate delegate) {
			return new VoidDeleteResponseEndpoint(delegate);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class NullWriteResponseEndpointConfiguration {
		@Bean
		NullWriteResponseEndpoint nullWriteResponseEndpoint(EndpointDelegate delegate) {
			return new NullWriteResponseEndpoint(delegate);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class NullReadResponseEndpointConfiguration {
		@Bean
		NullReadResponseEndpoint nullResponseEndpoint() {
			return new NullReadResponseEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class NullDeleteResponseEndpointConfiguration {
		@Bean
		NullDeleteResponseEndpoint nullDeleteResponseEndpoint() {
			return new NullDeleteResponseEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	protected static class ResourceEndpointConfiguration {
		@Bean
		public ResourceEndpoint resourceEndpoint() {
			return new ResourceEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class ResourceWebEndpointResponseEndpointConfiguration {
		@Bean
		ResourceWebEndpointResponseEndpoint resourceEndpoint() {
			return new ResourceWebEndpointResponseEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class MonoResponseEndpointConfiguration {
		@Bean
		MonoResponseEndpoint testEndpoint(EndpointDelegate endpointDelegate) {
			return new MonoResponseEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class FluxResponseEndpointConfiguration {
		@Bean
		FluxResponseEndpoint testEndpoint(EndpointDelegate endpointDelegate) {
			return new FluxResponseEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomMediaTypesEndpointConfiguration {
		@Bean
		CustomMediaTypesEndpoint customMediaTypesEndpoint() {
			return new CustomMediaTypesEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class RequiredParameterEndpointConfiguration {
		@Bean
		RequiredParametersEndpoint requiredParametersEndpoint() {
			return new RequiredParametersEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class PrincipalEndpointConfiguration {
		@Bean
		PrincipalEndpoint principalEndpoint() {
			return new PrincipalEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class PrincipalQueryEndpointConfiguration {
		@Bean
		PrincipalQueryEndpoint principalQueryEndpoint() {
			return new PrincipalQueryEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class SecurityContextEndpointConfiguration {
		@Bean
		SecurityContextEndpoint securityContextEndpoint() {
			return new SecurityContextEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class UserInRoleEndpointConfiguration {
		@Bean
		UserInRoleEndpoint userInRoleEndpoint() {
			return new UserInRoleEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomResponseStatusEndpointConfiguration {
		@Bean
		CustomResponseStatusEndpoint customResponseStatusEndpoint() {
			return new CustomResponseStatusEndpoint();
		}
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		private final EndpointDelegate endpointDelegate;
		TestEndpoint(EndpointDelegate endpointDelegate) {
			this.endpointDelegate = endpointDelegate;
		}
		@ReadOperation
		Map<String, Object> readAll() {
			return Collections.singletonMap('All', true);
		}
		@ReadOperation
		Map<String, Object> readPart(@Selector String part) {
			return Collections.singletonMap('part', part);
		}
		@WriteOperation
		void write(@Nullable String foo, @Nullable String bar) {
			this.endpointDelegate.write(foo, bar);
		}
		@DeleteOperation
		Map<String, Object> deletePart(@Selector String part) {
			return Collections.singletonMap('part', part);
		}
	}
	@Endpoint(id = 'matchallremaining')
	static class MatchAllRemainingEndpoint {
		@ReadOperation
		Map<String, String> select(@Selector(match = Match.ALL_REMAINING) String... selection) {
			return Collections.singletonMap('selection', StringUtils.arrayToDelimitedString(selection, '|'));
		}
	}
	@Endpoint(id = 'query')
	static class QueryEndpoint {
		@ReadOperation
		Map<String, String> query(String one, Integer two) {
			return Collections.singletonMap('query', one + ' ' + two);
		}
		@ReadOperation
		Map<String, String> queryWithParameterList(@Selector String list, String one, List<String> two) {
			return Collections.singletonMap('query', list + ' ' + one + ' ' + two);
		}
	}
	@Endpoint(id = 'query')
	static class QueryWithListEndpoint {
		@ReadOperation
		Map<String, String> queryWithParameterList(String one, List<String> two) {
			return Collections.singletonMap('query', one + ' ' + two);
		}
	}
	@Endpoint(id = 'query')
	static class ReactiveQueryEndpoint {
		@ReadOperation
		Mono<Map<String, String>> query(String param) {
			return Mono.just(Collections.singletonMap('query', param));
		}
	}
	@Endpoint(id = 'voidwrite')
	static class VoidWriteResponseEndpoint {
		private final EndpointDelegate delegate;
		VoidWriteResponseEndpoint(EndpointDelegate delegate) {
			this.delegate = delegate;
		}
		@WriteOperation
		void write() {
			this.delegate.write();
		}
	}
	@Endpoint(id = 'voiddelete')
	static class VoidDeleteResponseEndpoint {
		private final EndpointDelegate delegate;
		VoidDeleteResponseEndpoint(EndpointDelegate delegate) {
			this.delegate = delegate;
		}
		@DeleteOperation
		void delete() {
			this.delegate.delete();
		}
	}
	@Endpoint(id = 'nullwrite')
	static class NullWriteResponseEndpoint {
		private final EndpointDelegate delegate;
		NullWriteResponseEndpoint(EndpointDelegate delegate) {
			this.delegate = delegate;
		}
		@WriteOperation
		Object write() {
			this.delegate.write();
			return null;
		}
	}
	@Endpoint(id = 'nullread')
	static class NullReadResponseEndpoint {
		@ReadOperation
		String readReturningNull() {
			return null;
		}
	}
	@Endpoint(id = 'nulldelete')
	static class NullDeleteResponseEndpoint {
		@DeleteOperation
		String deleteReturningNull() {
			return null;
		}
	}
	@Endpoint(id = 'resource')
	static class ResourceEndpoint {
		@ReadOperation
		Resource read() {
			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });
		}
	}
	@Endpoint(id = 'resource')
	static class ResourceWebEndpointResponseEndpoint {
		@ReadOperation
		WebEndpointResponse<Resource> read() {
			return new WebEndpointResponse<>(new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 200);
		}
	}
	@Endpoint(id = 'mono')
	static class MonoResponseEndpoint {
		@ReadOperation
		Mono<Map<String, String>> operation() {
			return Mono.just(Collections.singletonMap('a', 'alpha'));
		}
	}
	@Endpoint(id = 'flux')
	static class FluxResponseEndpoint {
		@ReadOperation
		Flux<Map<String, String>> operation() {
			return Flux.just(Collections.singletonMap('a', 'alpha'), Collections.singletonMap('b', 'bravo'),
					Collections.singletonMap('c', 'charlie'));
		}
	}
	@Endpoint(id = 'custommediatypes')
	static class CustomMediaTypesEndpoint {
		@ReadOperation(produces = 'text/plain')
		String read() {
			return 'read';
		}
	}
	@Endpoint(id = 'requiredparameters')
	static class RequiredParametersEndpoint {
		@ReadOperation
		String read(String foo, @Nullable String bar) {
			return foo;
		}
	}
	@Endpoint(id = 'principal')
	static class PrincipalEndpoint {
		@ReadOperation
		String read(@Nullable Principal principal) {
			return (principal != null) ? principal.getName() : 'None';
		}
	}
	@Endpoint(id = 'principalquery')
	static class PrincipalQueryEndpoint {
		@ReadOperation
		String read(String principal) {
			return principal;
		}
	}
	@Endpoint(id = 'securitycontext')
	static class SecurityContextEndpoint {
		@ReadOperation
		String read(SecurityContext securityContext) {
			Principal principal = securityContext.getPrincipal();
			return (principal != null) ? principal.getName() : 'None';
		}
	}
	@Endpoint(id = 'userinrole')
	static class UserInRoleEndpoint {
		@ReadOperation
		String read(SecurityContext securityContext, String role) {
			return role + ': ' + securityContext.isUserInRole(role);
		}
	}
	@Endpoint(id = 'customstatus')
	static class CustomResponseStatusEndpoint {
		@ReadOperation
		WebEndpointResponse<String> read() {
			return new WebEndpointResponse<>('Custom status', 234);
		}
	}
	interface EndpointDelegate {
		void write();
		void write(String foo, String bar);
		void delete();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@Configuration(proxyBeanMethods = false)
class BaseConfiguration {
	@Bean
	AbstractWebEndpointIntegrationTests.EndpointDelegate endpointDelegate() {
		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
		if (classLoader instanceof TomcatEmbeddedWebappClassLoader) {
			Thread.currentThread().setContextClassLoader(classLoader.getParent());
		}
		try {
			return mock(AbstractWebEndpointIntegrationTests.EndpointDelegate.class);
		}
		finally {
			Thread.currentThread().setContextClassLoader(classLoader);
		}
	}
	@Bean
	EndpointMediaTypes endpointMediaTypes() {
		List<String> mediaTypes = Arrays.asList('application/vnd.test+json', 'application/json');
		return new EndpointMediaTypes(mediaTypes, mediaTypes);
	}
	@Bean
	WebEndpointDiscoverer webEndpointDiscoverer(EndpointMediaTypes endpointMediaTypes,
			ApplicationContext applicationContext, ObjectProvider<PathMapper> pathMappers) {
		ParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper(
				DefaultConversionService.getSharedInstance());
		return new WebEndpointDiscoverer(applicationContext, parameterMapper, endpointMediaTypes,
				pathMappers.orderedStream().toList(), Collections.emptyList(), Collections.emptyList(),
				Collections.emptyList(), Collections.emptyList());
	}
	@Bean
	static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
		return new PropertySourcesPlaceholderConfigurer();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class ControllerEndpointDiscovererTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void getEndpointsWhenNoEndpointBeansShouldReturnEmptyCollection() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run(assertDiscoverer((discoverer) -> assertThat(discoverer.getEndpoints()).isEmpty()));
	}
	@Test
	void getEndpointsShouldIncludeControllerEndpoints() {
		this.contextRunner.withUserConfiguration(TestControllerEndpoint.class).run(assertDiscoverer((discoverer) -> {
			Collection<ExposableControllerEndpoint> endpoints = discoverer.getEndpoints();
			assertThat(endpoints).hasSize(1);
			ExposableControllerEndpoint endpoint = endpoints.iterator().next();
			assertThat(endpoint.getEndpointId()).isEqualTo(EndpointId.of('testcontroller'));
			assertThat(endpoint.getController()).isInstanceOf(TestControllerEndpoint.class);
			assertThat(endpoint).isInstanceOf(DiscoveredEndpoint.class);
		}));
	}
	@Test
	void getEndpointsShouldDiscoverProxyControllerEndpoints() {
		this.contextRunner.withUserConfiguration(TestProxyControllerEndpoint.class)
			.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.run(assertDiscoverer((discoverer) -> {
				Collection<ExposableControllerEndpoint> endpoints = discoverer.getEndpoints();
				assertThat(endpoints).hasSize(1);
				ExposableControllerEndpoint endpoint = endpoints.iterator().next();
				assertThat(endpoint.getEndpointId()).isEqualTo(EndpointId.of('testcontroller'));
				assertThat(endpoint.getController()).isInstanceOf(TestProxyControllerEndpoint.class);
				assertThat(endpoint).isInstanceOf(DiscoveredEndpoint.class);
			}));
	}
	@Test
	void getEndpointsShouldIncludeRestControllerEndpoints() {
		this.contextRunner.withUserConfiguration(TestRestControllerEndpoint.class)
			.run(assertDiscoverer((discoverer) -> {
				Collection<ExposableControllerEndpoint> endpoints = discoverer.getEndpoints();
				assertThat(endpoints).hasSize(1);
				ExposableControllerEndpoint endpoint = endpoints.iterator().next();
				assertThat(endpoint.getEndpointId()).isEqualTo(EndpointId.of('testrestcontroller'));
				assertThat(endpoint.getController()).isInstanceOf(TestRestControllerEndpoint.class);
			}));
	}
	@Test
	void getEndpointsShouldDiscoverProxyRestControllerEndpoints() {
		this.contextRunner.withUserConfiguration(TestProxyRestControllerEndpoint.class)
			.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.run(assertDiscoverer((discoverer) -> {
				Collection<ExposableControllerEndpoint> endpoints = discoverer.getEndpoints();
				assertThat(endpoints).hasSize(1);
				ExposableControllerEndpoint endpoint = endpoints.iterator().next();
				assertThat(endpoint.getEndpointId()).isEqualTo(EndpointId.of('testrestcontroller'));
				assertThat(endpoint.getController()).isInstanceOf(TestProxyRestControllerEndpoint.class);
				assertThat(endpoint).isInstanceOf(DiscoveredEndpoint.class);
			}));
	}
	@Test
	void getEndpointsShouldNotDiscoverRegularEndpoints() {
		this.contextRunner.withUserConfiguration(WithRegularEndpointConfiguration.class)
			.run(assertDiscoverer((discoverer) -> {
				Collection<ExposableControllerEndpoint> endpoints = discoverer.getEndpoints();
				List<EndpointId> ids = endpoints.stream().map(ExposableControllerEndpoint::getEndpointId).toList();
				assertThat(ids).containsOnly(EndpointId.of('testcontroller'), EndpointId.of('testrestcontroller'));
			}));
	}
	@Test
	void getEndpointWhenEndpointHasOperationsShouldThrowException() {
		this.contextRunner.withUserConfiguration(TestControllerWithOperation.class)
			.run(assertDiscoverer((discoverer) -> assertThatIllegalStateException().isThrownBy(discoverer::getEndpoints)
				.withMessageContaining('ControllerEndpoints must not declare operations')));
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new ControllerEndpointDiscoverer.ControllerEndpointDiscovererRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(ControllerEndpointFilter.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(runtimeHints);
	}
	private ContextConsumer<AssertableApplicationContext> assertDiscoverer(
			Consumer<ControllerEndpointDiscoverer> consumer) {
		return (context) -> {
			ControllerEndpointDiscoverer discoverer = new ControllerEndpointDiscoverer(context, null,
					Collections.emptyList());
			consumer.accept(discoverer);
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ TestEndpoint.class, TestControllerEndpoint.class, TestRestControllerEndpoint.class })
	static class WithRegularEndpointConfiguration {
	}
	@ControllerEndpoint(id = 'testcontroller')
	static class TestControllerEndpoint {
	}
	@ControllerEndpoint(id = 'testcontroller')
	@Validated
	static class TestProxyControllerEndpoint {
	}
	@RestControllerEndpoint(id = 'testrestcontroller')
	static class TestRestControllerEndpoint {
	}
	@RestControllerEndpoint(id = 'testrestcontroller')
	@Validated
	static class TestProxyRestControllerEndpoint {
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
	}
	@ControllerEndpoint(id = 'testcontroller')
	static class TestControllerWithOperation {
		@ReadOperation
		String read() {
			return 'error';
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.test;
/**
class WebEndpointTestInvocationContextProvider implements TestTemplateInvocationContextProvider {
	@Override
	public boolean supportsTestTemplate(ExtensionContext context) {
		return true;
	}
	@Override
	public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(
			ExtensionContext extensionContext) {
		WebEndpointTest webEndpointTest = AnnotationUtils
			.findAnnotation(extensionContext.getRequiredTestMethod(), WebEndpointTest.class)
			.orElseThrow(() -> new IllegalStateException('Unable to find WebEndpointTest annotation on %s'
				.formatted(extensionContext.getRequiredTestMethod())));
		return Stream.of(webEndpointTest.infrastructure()).distinct().map(Infrastructure::createInvocationContext);
	}
	static ConfigurableApplicationContext createJerseyContext(List<Class<?>> classes) {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();
		classes.add(JerseyEndpointConfiguration.class);
		context.register(ClassUtils.toClassArray(classes));
		context.refresh();
		return context;
	}
	static ConfigurableApplicationContext createWebMvcContext(List<Class<?>> classes) {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();
		classes.add(WebMvcEndpointConfiguration.class);
		context.register(ClassUtils.toClassArray(classes));
		context.refresh();
		return context;
	}
	static ConfigurableApplicationContext createWebFluxContext(List<Class<?>> classes) {
		AnnotationConfigReactiveWebServerApplicationContext context = new AnnotationConfigReactiveWebServerApplicationContext();
		classes.add(WebFluxEndpointConfiguration.class);
		context.register(ClassUtils.toClassArray(classes));
		context.refresh();
		return context;
	}
	static class WebEndpointsInvocationContext
			implements TestTemplateInvocationContext, BeforeEachCallback, AfterEachCallback, ParameterResolver {
		private static final Duration TIMEOUT = Duration.ofMinutes(5);
		private final String name;
		private final Function<List<Class<?>>, ConfigurableApplicationContext> contextFactory;
		private ConfigurableApplicationContext context;
		<T extends ConfigurableApplicationContext & AnnotationConfigRegistry> WebEndpointsInvocationContext(String name,
				Function<List<Class<?>>, ConfigurableApplicationContext> contextFactory) {
			this.name = name;
			this.contextFactory = contextFactory;
		}
		@Override
		public void beforeEach(ExtensionContext extensionContext) throws Exception {
			List<Class<?>> configurationClasses = Stream
				.of(extensionContext.getRequiredTestClass().getDeclaredClasses())
				.filter(this::isConfiguration)
				.collect(Collectors.toCollection(ArrayList::new));
			this.context = this.contextFactory.apply(configurationClasses);
		}
		private boolean isConfiguration(Class<?> candidate) {
			return MergedAnnotations.from(candidate, SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class);
		}
		@Override
		public void afterEach(ExtensionContext context) throws Exception {
			if (this.context != null) {
				this.context.close();
			}
		}
		@Override
		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			Class<?> type = parameterContext.getParameter().getType();
			return type.equals(WebTestClient.class) || type.isAssignableFrom(ConfigurableApplicationContext.class);
		}
		@Override
		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			Class<?> type = parameterContext.getParameter().getType();
			if (type.equals(WebTestClient.class)) {
				return createWebTestClient();
			}
			else {
				return this.context;
			}
		}
		@Override
		public List<Extension> getAdditionalExtensions() {
			return Collections.singletonList(this);
		}
		@Override
		public String getDisplayName(int invocationIndex) {
			return this.name;
		}
		private WebTestClient createWebTestClient() {
			DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(
					'http://localhost:' + determinePort());
			uriBuilderFactory.setEncodingMode(EncodingMode.NONE);
			return WebTestClient.bindToServer()
				.uriBuilderFactory(uriBuilderFactory)
				.responseTimeout(TIMEOUT)
				.codecs((codecs) -> codecs.defaultCodecs().maxInMemorySize(-1))
				.filter((request, next) -> {
					if (HttpMethod.GET == request.method()) {
						return next.exchange(request).retry(10);
					}
					return next.exchange(request);
				})
				.build();
		}
		private int determinePort() {
			if (this.context instanceof AnnotationConfigServletWebServerApplicationContext webServerContext) {
				return webServerContext.getWebServer().getPort();
			}
			return this.context.getBean(PortHolder.class).getPort();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, JerseyAutoConfiguration.class })
	static class JerseyEndpointConfiguration {
		private final ApplicationContext applicationContext;
		JerseyEndpointConfiguration(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		ResourceConfig resourceConfig() {
			return new ResourceConfig();
		}
		@Bean
		ResourceConfigCustomizer webEndpointRegistrar() {
			return this::customize;
		}
		private void customize(ResourceConfig config) {
			EndpointMediaTypes endpointMediaTypes = EndpointMediaTypes.DEFAULT;
			WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(this.applicationContext,
					new ConversionServiceParameterValueMapper(), endpointMediaTypes, null, Collections.emptyList(),
					Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
			Collection<Resource> resources = new JerseyEndpointResourceFactory().createEndpointResources(
					new EndpointMapping('/actuator'), discoverer.getEndpoints(), endpointMediaTypes,
					new EndpointLinksResolver(discoverer.getEndpoints()), true);
			config.registerResources(new HashSet<>(resources));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, WebFluxAutoConfiguration.class })
	static class WebFluxEndpointConfiguration implements ApplicationListener<WebServerInitializedEvent> {
		private final ApplicationContext applicationContext;
		private final PortHolder portHolder = new PortHolder();
		WebFluxEndpointConfiguration(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Bean
		NettyReactiveWebServerFactory netty() {
			return new NettyReactiveWebServerFactory(0);
		}
		@Bean
		PortHolder portHolder() {
			return this.portHolder;
		}
		@Override
		public void onApplicationEvent(WebServerInitializedEvent event) {
			this.portHolder.setPort(event.getWebServer().getPort());
		}
		@Bean
		HttpHandler httpHandler(ApplicationContext applicationContext) {
			return WebHttpHandlerBuilder.applicationContext(applicationContext).build();
		}
		@Bean
		WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping() {
			EndpointMediaTypes endpointMediaTypes = EndpointMediaTypes.DEFAULT;
			WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(this.applicationContext,
					new ConversionServiceParameterValueMapper(), endpointMediaTypes, Collections.emptyList(),
					Collections.emptyList(), Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
			return new WebFluxEndpointHandlerMapping(new EndpointMapping('/actuator'), discoverer.getEndpoints(),
					endpointMediaTypes, new CorsConfiguration(), new EndpointLinksResolver(discoverer.getEndpoints()),
					true);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class })
	static class WebMvcEndpointConfiguration {
		private final ApplicationContext applicationContext;
		WebMvcEndpointConfiguration(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping() {
			EndpointMediaTypes endpointMediaTypes = EndpointMediaTypes.DEFAULT;
			WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(this.applicationContext,
					new ConversionServiceParameterValueMapper(), endpointMediaTypes, Collections.emptyList(),
					Collections.emptyList(), Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
			return new WebMvcEndpointHandlerMapping(new EndpointMapping('/actuator'), discoverer.getEndpoints(),
					endpointMediaTypes, new CorsConfiguration(), new EndpointLinksResolver(discoverer.getEndpoints()),
					true);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.test;
public class PortHolder {
	private int port;
	int getPort() {
		return this.port;
	}
	void setPort(int port) {
		this.port = port;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.test;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@TestTemplate
@ExtendWith(WebEndpointTestInvocationContextProvider.class)
public @interface WebEndpointTest {
	/**
	 * The infrastructure against which the test should run.
	 * @return the infrastructure to run the tests against
	 */
	Infrastructure[] infrastructure() default { Infrastructure.JERSEY, Infrastructure.MVC, Infrastructure.WEBFLUX };
	enum Infrastructure {
		/**
		 * Actuator running on the Jersey-based infrastructure.
		 */
		JERSEY('Jersey', WebEndpointTestInvocationContextProvider::createJerseyContext),
		/**
		 * Actuator running on the WebMVC-based infrastructure.
		 */
		MVC('WebMvc', WebEndpointTestInvocationContextProvider::createWebMvcContext),
		/**
		 * Actuator running on the WebFlux-based infrastructure.
		 */
		WEBFLUX('WebFlux', WebEndpointTestInvocationContextProvider::createWebFluxContext);
		private final String name;
		private final Function<List<Class<?>>, ConfigurableApplicationContext> contextFactory;
		Infrastructure(String name, Function<List<Class<?>>, ConfigurableApplicationContext> contextFactory) {
			this.name = name;
			this.contextFactory = contextFactory;
		}
		WebEndpointsInvocationContext createInvocationContext() {
			return new WebEndpointsInvocationContext(this.name, this.contextFactory);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
class WebOperationRequestPredicateTests {
	@Test
	void predicatesWithIdenticalPathsAreEqual() {
		assertThat(predicateWithPath('/path')).isEqualTo(predicateWithPath('/path'));
	}
	@Test
	void predicatesWithDifferentPathsAreNotEqual() {
		assertThat(predicateWithPath('/one')).isNotEqualTo(predicateWithPath('/two'));
	}
	@Test
	void predicatesWithIdenticalPathsWithVariablesAreEqual() {
		assertThat(predicateWithPath('/path/{foo}')).isEqualTo(predicateWithPath('/path/{foo}'));
	}
	@Test
	void predicatesWhereOneHasAPathAndTheOtherHasAVariableAreNotEqual() {
		assertThat(predicateWithPath('/path/{foo}')).isNotEqualTo(predicateWithPath('/path/foo'));
	}
	@Test
	void predicatesWithSinglePathVariablesInTheSamePlaceAreEqual() {
		assertThat(predicateWithPath('/path/{foo1}')).isEqualTo(predicateWithPath('/path/{foo2}'));
	}
	@Test
	void predicatesWithSingleWildcardPathVariablesInTheSamePlaceAreEqual() {
		assertThat(predicateWithPath('/path/{*foo1}')).isEqualTo(predicateWithPath('/path/{*foo2}'));
	}
	@Test
	void predicatesWithSingleWildcardPathVariableAndRegularVariableInTheSamePlaceAreNotEqual() {
		assertThat(predicateWithPath('/path/{*foo1}')).isNotEqualTo(predicateWithPath('/path/{foo2}'));
	}
	@Test
	void predicatesWithMultiplePathVariablesInTheSamePlaceAreEqual() {
		assertThat(predicateWithPath('/path/{foo1}/more/{bar1}'))
			.isEqualTo(predicateWithPath('/path/{foo2}/more/{bar2}'));
	}
	@Test
	void predicateWithWildcardPathVariableReturnsMatchAllRemainingPathSegmentsVariable() {
		assertThat(predicateWithPath('/path/{*foo1}').getMatchAllRemainingPathSegmentsVariable()).isEqualTo('foo1');
	}
	@Test
	void predicateWithRegularPathVariableDoesNotReturnMatchAllRemainingPathSegmentsVariable() {
		assertThat(predicateWithPath('/path/{foo1}').getMatchAllRemainingPathSegmentsVariable()).isNull();
	}
	@Test
	void predicateWithNoPathVariableDoesNotReturnMatchAllRemainingPathSegmentsVariable() {
		assertThat(predicateWithPath('/path/foo1').getMatchAllRemainingPathSegmentsVariable()).isNull();
	}
	private WebOperationRequestPredicate predicateWithPath(String path) {
		return new WebOperationRequestPredicate(path, WebEndpointHttpMethod.GET, Collections.emptyList(),
				Collections.emptyList());
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.jersey;
/**
class JerseyWebEndpointIntegrationTests
		extends AbstractWebEndpointIntegrationTests<AnnotationConfigServletWebServerApplicationContext> {
	JerseyWebEndpointIntegrationTests() {
		super(JerseyWebEndpointIntegrationTests::createApplicationContext,
				JerseyWebEndpointIntegrationTests::applyAuthenticatedConfiguration);
	}
	private static AnnotationConfigServletWebServerApplicationContext createApplicationContext() {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();
		context.register(JerseyConfiguration.class);
		return context;
	}
	private static void applyAuthenticatedConfiguration(AnnotationConfigServletWebServerApplicationContext context) {
		context.register(AuthenticatedConfiguration.class);
	}
	@Override
	protected int getPort(AnnotationConfigServletWebServerApplicationContext context) {
		return context.getWebServer().getPort();
	}
	@Override
	protected void validateErrorBody(WebTestClient.BodyContentSpec body, HttpStatus status, String path,
			String message) {
		// Jersey doesn"t support the general error page handling
	}
	@Override
	@Test
	@Disabled('Jersey does not distinguish between /example and /example/')
	protected void operationWithTrailingSlashShouldNotMatch() {
	}
	@Configuration(proxyBeanMethods = false)
	static class JerseyConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		ServletRegistrationBean<ServletContainer> servletContainer(ResourceConfig resourceConfig) {
			return new ServletRegistrationBean<>(new ServletContainer(resourceConfig), '/*');
		}
		@Bean
		ResourceConfig resourceConfig(Environment environment, WebEndpointDiscoverer endpointDiscoverer,
				EndpointMediaTypes endpointMediaTypes) {
			ResourceConfig resourceConfig = new ResourceConfig();
			String endpointPath = environment.getProperty('endpointPath');
			Collection<Resource> resources = new JerseyEndpointResourceFactory().createEndpointResources(
					new EndpointMapping(endpointPath), endpointDiscoverer.getEndpoints(), endpointMediaTypes,
					new EndpointLinksResolver(endpointDiscoverer.getEndpoints()), StringUtils.hasText(endpointPath));
			resourceConfig.registerResources(new HashSet<>(resources));
			resourceConfig.register(JacksonFeature.class);
			resourceConfig.register(new ObjectMapperContextResolver(new ObjectMapper()), ContextResolver.class);
			return resourceConfig;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AuthenticatedConfiguration {
		@Bean
		Filter securityFilter() {
			return new OncePerRequestFilter() {
				@Override
				protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
						FilterChain filterChain) throws ServletException, IOException {
					SecurityContext context = SecurityContextHolder.createEmptyContext();
					context.setAuthentication(new UsernamePasswordAuthenticationToken('Alice', 'secret',
							Arrays.asList(new SimpleGrantedAuthority('ROLE_ACTUATOR'))));
					SecurityContextHolder.setContext(context);
					try {
						filterChain.doFilter(new SecurityContextHolderAwareRequestWrapper(request, 'ROLE_'), response);
					}
					finally {
						SecurityContextHolder.clearContext();
					}
				}
			};
		}
	}
	private static final class ObjectMapperContextResolver implements ContextResolver<ObjectMapper> {
		private final ObjectMapper objectMapper;
		private ObjectMapperContextResolver(ObjectMapper objectMapper) {
			this.objectMapper = objectMapper;
		}
		@Override
		public ObjectMapper getContext(Class<?> type) {
			return this.objectMapper;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class EndpointServletTests {
	@Test
	void createWhenServletClassIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new EndpointServlet((Class<Servlet>) null))
			.withMessageContaining('Servlet must not be null');
	}
	@Test
	void createWhenServletIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new EndpointServlet((Servlet) null))
			.withMessageContaining('Servlet must not be null');
	}
	@Test
	void createWithServletClassShouldCreateServletInstance() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThat(endpointServlet.getServlet()).isInstanceOf(TestServlet.class);
	}
	@Test
	void getServletShouldGetServlet() {
		TestServlet servlet = new TestServlet();
		EndpointServlet endpointServlet = new EndpointServlet(servlet);
		assertThat(endpointServlet.getServlet()).isEqualTo(servlet);
	}
	@Test
	void withInitParameterNullName() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThatIllegalArgumentException().isThrownBy(() -> endpointServlet.withInitParameter(null, 'value'));
	}
	@Test
	void withInitParameterEmptyName() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThatIllegalArgumentException().isThrownBy(() -> endpointServlet.withInitParameter(' ', 'value'));
	}
	@Test
	void withInitParameterShouldReturnNewInstance() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThat(endpointServlet.withInitParameter('spring', 'boot')).isNotSameAs(endpointServlet);
	}
	@Test
	void withInitParameterWhenHasExistingShouldMergeParameters() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class).withInitParameter('a', 'b')
			.withInitParameter('c', 'd');
		assertThat(endpointServlet.withInitParameter('a', 'b1').withInitParameter('e', 'f').getInitParameters())
			.containsExactly(entry('a', 'b1'), entry('c', 'd'), entry('e', 'f'));
	}
	@Test
	void withInitParametersNullName() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThatIllegalArgumentException()
			.isThrownBy(() -> endpointServlet.withInitParameters(Collections.singletonMap(null, 'value')));
	}
	@Test
	void withInitParametersEmptyName() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThatIllegalArgumentException()
			.isThrownBy(() -> endpointServlet.withInitParameters(Collections.singletonMap(' ', 'value')));
	}
	@Test
	void withInitParametersShouldCreateNewInstance() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThat(endpointServlet.withInitParameters(Collections.singletonMap('spring', 'boot')))
			.isNotSameAs(endpointServlet);
	}
	@Test
	void withInitParametersWhenHasExistingShouldMergeParameters() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class).withInitParameter('a', 'b')
			.withInitParameter('c', 'd');
		Map<String, String> extra = new LinkedHashMap<>();
		extra.put('a', 'b1');
		extra.put('e', 'f');
		assertThat(endpointServlet.withInitParameters(extra).getInitParameters()).containsExactly(entry('a', 'b1'),
				entry('c', 'd'), entry('e', 'f'));
	}
	@Test
	void withLoadOnStartupNotSetShouldReturnDefaultValue() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class);
		assertThat(endpointServlet.getLoadOnStartup()).isEqualTo(-1);
	}
	@Test
	void withLoadOnStartupSetShouldReturnValue() {
		EndpointServlet endpointServlet = new EndpointServlet(TestServlet.class).withLoadOnStartup(3);
		assertThat(endpointServlet.getLoadOnStartup()).isEqualTo(3);
	}
	static class TestServlet extends GenericServlet {
		@Override
		public void service(ServletRequest req, ServletResponse res) {
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
class PathMappedEndpointsTests {
	@Test
	void createWhenSupplierIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PathMappedEndpoints(null, (WebEndpointsSupplier) null))
			.withMessageContaining('Supplier must not be null');
	}
	@Test
	void createWhenSuppliersIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PathMappedEndpoints(null, (Collection<EndpointsSupplier<?>>) null))
			.withMessageContaining('Suppliers must not be null');
	}
	@Test
	void iteratorShouldReturnPathMappedEndpoints() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped).hasSize(2);
		assertThat(mapped).extracting('endpointId').containsExactly(EndpointId.of('e2'), EndpointId.of('e3'));
	}
	@Test
	void streamShouldReturnPathMappedEndpoints() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.stream()).hasSize(2);
		assertThat(mapped.stream()).extracting('endpointId').containsExactly(EndpointId.of('e2'), EndpointId.of('e3'));
	}
	@Test
	void getRootPathWhenContainsIdShouldReturnRootPath() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.getRootPath(EndpointId.of('e2'))).isEqualTo('p2');
	}
	@Test
	void getRootPathWhenMissingIdShouldReturnNull() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.getRootPath(EndpointId.of('xx'))).isNull();
	}
	@Test
	void getPathWhenContainsIdShouldReturnRootPath() {
		assertThat(createTestMapped(null).getPath(EndpointId.of('e2'))).isEqualTo('/p2');
		assertThat(createTestMapped('/x').getPath(EndpointId.of('e2'))).isEqualTo('/x/p2');
	}
	@Test
	void getPathWhenMissingIdShouldReturnNull() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.getPath(EndpointId.of('xx'))).isNull();
	}
	@Test
	void getPathWhenBasePathIsRootAndEndpointIsPathMappedToRootShouldReturnSingleSlash() {
		PathMappedEndpoints mapped = new PathMappedEndpoints('/',
				() -> List.of(mockEndpoint(EndpointId.of('root'), '/')));
		assertThat(mapped.getPath(EndpointId.of('root'))).isEqualTo('/');
	}
	@Test
	void getPathWhenBasePathIsRootAndEndpointIsPathMapped() {
		PathMappedEndpoints mapped = new PathMappedEndpoints('/',
				() -> List.of(mockEndpoint(EndpointId.of('a'), 'alpha')));
		assertThat(mapped.getPath(EndpointId.of('a'))).isEqualTo('/alpha');
	}
	@Test
	void getAllRootPathsShouldReturnAllPaths() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.getAllRootPaths()).containsExactly('p2', 'p3');
	}
	@Test
	void getAllPathsShouldReturnAllPaths() {
		assertThat(createTestMapped(null).getAllPaths()).containsExactly('/p2', '/p3');
		assertThat(createTestMapped('/x').getAllPaths()).containsExactly('/x/p2', '/x/p3');
	}
	@Test
	void getEndpointWhenContainsIdShouldReturnPathMappedEndpoint() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.getEndpoint(EndpointId.of('e2')).getRootPath()).isEqualTo('p2');
	}
	@Test
	void getEndpointWhenMissingIdShouldReturnNull() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.getEndpoint(EndpointId.of('xx'))).isNull();
	}
	@Test
	void getAdditionalPathsShouldReturnCanonicalAdditionalPaths() {
		PathMappedEndpoints mapped = createTestMapped(null);
		assertThat(mapped.getAdditionalPaths(WebServerNamespace.SERVER, EndpointId.of('e2'))).containsExactly('/a2',
				'/A2');
		assertThat(mapped.getAdditionalPaths(WebServerNamespace.MANAGEMENT, EndpointId.of('e2'))).isEmpty();
		assertThat(mapped.getAdditionalPaths(WebServerNamespace.SERVER, EndpointId.of('e3'))).isEmpty();
	}
	private PathMappedEndpoints createTestMapped(String basePath) {
		List<ExposableEndpoint<?>> endpoints = new ArrayList<>();
		endpoints.add(mockEndpoint(EndpointId.of('e1')));
		endpoints.add(mockEndpoint(EndpointId.of('e2'), 'p2', WebServerNamespace.SERVER, List.of('/a2', 'A2')));
		endpoints.add(mockEndpoint(EndpointId.of('e3'), 'p3'));
		endpoints.add(mockEndpoint(EndpointId.of('e4')));
		return new PathMappedEndpoints(basePath, () -> endpoints);
	}
	private TestPathMappedEndpoint mockEndpoint(EndpointId id, String rootPath) {
		return mockEndpoint(id, rootPath, null, null);
	}
	private TestPathMappedEndpoint mockEndpoint(EndpointId id, String rootPath, WebServerNamespace webServerNamespace,
			List<String> additionalPaths) {
		TestPathMappedEndpoint endpoint = mock(TestPathMappedEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(id);
		given(endpoint.getRootPath()).willReturn(rootPath);
		if (webServerNamespace != null && additionalPaths != null) {
			given(endpoint.getAdditionalPaths(webServerNamespace)).willReturn(additionalPaths);
		}
		return endpoint;
	}
	private TestEndpoint mockEndpoint(EndpointId id) {
		TestEndpoint endpoint = mock(TestEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(id);
		return endpoint;
	}
	public interface TestEndpoint extends ExposableEndpoint<Operation> {
	}
	public interface TestPathMappedEndpoint extends ExposableEndpoint<Operation>, PathMappedEndpoint {
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
class WebMvcEndpointHandlerMappingTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new WebMvcEndpointHandlerMappingRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onMethod(WebMvcLinksHandler.class, 'links'))
			.accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(Link.class)).accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
class AbstractWebMvcEndpointHandlerMappingTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new AbstractWebMvcEndpointHandlerMappingRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(TypeReference
				.of('org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping.OperationHandler')))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
@Deprecated(since = '3.3.5', forRemoval = true)
@SuppressWarnings('removal')
class ControllerEndpointHandlerMappingTests {
	private final StaticApplicationContext context = new StaticApplicationContext();
	@Test
	void mappingWithNoPrefix() throws Exception {
		ExposableControllerEndpoint first = firstEndpoint();
		ExposableControllerEndpoint second = secondEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('', first, second);
		assertThat(mapping.getHandler(request('GET', '/first')).getHandler())
			.isEqualTo(handlerOf(first.getController(), 'get'));
		assertThat(mapping.getHandler(request('POST', '/second')).getHandler())
			.isEqualTo(handlerOf(second.getController(), 'save'));
		assertThat(mapping.getHandler(request('GET', '/third'))).isNull();
	}
	@Test
	void mappingWithPrefix() throws Exception {
		ExposableControllerEndpoint first = firstEndpoint();
		ExposableControllerEndpoint second = secondEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('actuator', first, second);
		assertThat(mapping.getHandler(request('GET', '/actuator/first')).getHandler())
			.isEqualTo(handlerOf(first.getController(), 'get'));
		assertThat(mapping.getHandler(request('POST', '/actuator/second')).getHandler())
			.isEqualTo(handlerOf(second.getController(), 'save'));
		assertThat(mapping.getHandler(request('GET', '/first'))).isNull();
		assertThat(mapping.getHandler(request('GET', '/second'))).isNull();
	}
	@Test
	void mappingNarrowedToMethod() {
		ExposableControllerEndpoint first = firstEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('actuator', first);
		assertThatExceptionOfType(HttpRequestMethodNotSupportedException.class)
			.isThrownBy(() -> mapping.getHandler(request('POST', '/actuator/first')));
	}
	@Test
	void mappingWithNoPath() throws Exception {
		ExposableControllerEndpoint pathless = pathlessEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('actuator', pathless);
		assertThat(mapping.getHandler(request('GET', '/actuator/pathless')).getHandler())
			.isEqualTo(handlerOf(pathless.getController(), 'get'));
		assertThat(mapping.getHandler(request('GET', '/pathless'))).isNull();
		assertThat(mapping.getHandler(request('GET', '/'))).isNull();
	}
	private ControllerEndpointHandlerMapping createMapping(String prefix, ExposableControllerEndpoint... endpoints) {
		ControllerEndpointHandlerMapping mapping = new ControllerEndpointHandlerMapping(new EndpointMapping(prefix),
				Arrays.asList(endpoints), null, (endpointId, defaultAccess) -> Access.UNRESTRICTED);
		mapping.setApplicationContext(this.context);
		mapping.afterPropertiesSet();
		return mapping;
	}
	private HandlerMethod handlerOf(Object source, String methodName) {
		return new HandlerMethod(source, ReflectionUtils.findMethod(source.getClass(), methodName));
	}
	private MockHttpServletRequest request(String method, String requestURI) {
		return new MockHttpServletRequest(method, requestURI);
	}
	private ExposableControllerEndpoint firstEndpoint() {
		return mockEndpoint(EndpointId.of('first'), new FirstTestMvcEndpoint());
	}
	private ExposableControllerEndpoint secondEndpoint() {
		return mockEndpoint(EndpointId.of('second'), new SecondTestMvcEndpoint());
	}
	private ExposableControllerEndpoint pathlessEndpoint() {
		return mockEndpoint(EndpointId.of('pathless'), new PathlessControllerEndpoint());
	}
	private ExposableControllerEndpoint mockEndpoint(EndpointId id, Object controller) {
		ExposableControllerEndpoint endpoint = mock(ExposableControllerEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(id);
		given(endpoint.getController()).willReturn(controller);
		given(endpoint.getRootPath()).willReturn(id.toString());
		return endpoint;
	}
	@ControllerEndpoint(id = 'first')
	static class FirstTestMvcEndpoint {
		@GetMapping('/')
		String get() {
			return 'test';
		}
	}
	@ControllerEndpoint(id = 'second')
	static class SecondTestMvcEndpoint {
		@PostMapping('/')
		void save() {
		}
	}
	@ControllerEndpoint(id = 'pathless')
	static class PathlessControllerEndpoint {
		@GetMapping
		String get() {
			return 'test';
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
@Deprecated(since = '3.3.5', forRemoval = true)
@SuppressWarnings('removal')
class ControllerEndpointHandlerMappingIntegrationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
			AnnotationConfigServletWebServerApplicationContext::new)
		.withUserConfiguration(EndpointConfiguration.class, ExampleMvcEndpoint.class);
	@Test
	void getMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.get()
			.uri('/actuator/example/one')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
			.expectBody(String.class)
			.isEqualTo('One')));
	}
	@Test
	void getWithUnacceptableContentType() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.get()
			.uri('/actuator/example/one')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isEqualTo(HttpStatus.NOT_ACCEPTABLE)));
	}
	@Test
	void postMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.post()
			.uri('/actuator/example/two')
			.bodyValue(Collections.singletonMap('id', 'test'))
			.exchange()
			.expectStatus()
			.isCreated()
			.expectHeader()
			.valueEquals(HttpHeaders.LOCATION, '/example/test')));
	}
	@Test
	void postMappingWithReadOnlyAccessRespondsWith404() {
		this.contextRunner.withPropertyValues('endpoint-access=READ_ONLY')
			.run(withWebTestClient((webTestClient) -> webTestClient.post()
				.uri('/actuator/example/two')
				.bodyValue(Collections.singletonMap('id', 'test'))
				.exchange()
				.expectStatus()
				.isNotFound()));
	}
	@Test
	void getToRequestMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.get()
			.uri('/actuator/example/three')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
			.expectBody(String.class)
			.isEqualTo('Three')));
	}
	@Test
	void getToRequestMappingWithReadOnlyAccess() {
		this.contextRunner.withPropertyValues('endpoint-access=READ_ONLY')
			.run(withWebTestClient((webTestClient) -> webTestClient.get()
				.uri('/actuator/example/three')
				.accept(MediaType.TEXT_PLAIN)
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
				.expectBody(String.class)
				.isEqualTo('Three')));
	}
	@Test
	void postToRequestMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.post()
			.uri('/actuator/example/three')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
			.expectBody(String.class)
			.isEqualTo('Three')));
	}
	@Test
	void postToRequestMappingWithReadOnlyAccessRespondsWith405() {
		this.contextRunner.withPropertyValues('endpoint-access=READ_ONLY')
			.run(withWebTestClient((webTestClient) -> webTestClient.post()
				.uri('/actuator/example/three')
				.accept(MediaType.TEXT_PLAIN)
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.METHOD_NOT_ALLOWED)));
	}
	private ContextConsumer<AssertableWebApplicationContext> withWebTestClient(Consumer<WebTestClient> webClient) {
		return (context) -> {
			int port = ((AnnotationConfigServletWebServerApplicationContext) context.getSourceApplicationContext())
				.getWebServer()
				.getPort();
			WebTestClient webTestClient = createWebTestClient(port);
			webClient.accept(webTestClient);
		};
	}
	private WebTestClient createWebTestClient(int port) {
		DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory('http://localhost:' + port);
		uriBuilderFactory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.NONE);
		return WebTestClient.bindToServer()
			.uriBuilderFactory(uriBuilderFactory)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class })
	static class EndpointConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		ControllerEndpointDiscoverer webEndpointDiscoverer(ApplicationContext applicationContext) {
			return new ControllerEndpointDiscoverer(applicationContext, null, Collections.emptyList());
		}
		@Bean
		ControllerEndpointHandlerMapping webEndpointHandlerMapping(ControllerEndpointsSupplier endpointsSupplier,
				EndpointAccessResolver endpointAccessResolver) {
			return new ControllerEndpointHandlerMapping(new EndpointMapping('actuator'),
					endpointsSupplier.getEndpoints(), null, endpointAccessResolver);
		}
		@Bean
		EndpointAccessResolver endpointAccessResolver(Environment environment) {
			return (id, defaultAccess) -> environment.getProperty('endpoint-access', Access.class, Access.UNRESTRICTED);
		}
	}
	@RestControllerEndpoint(id = 'example')
	static class ExampleMvcEndpoint {
		@GetMapping(path = 'one', produces = MediaType.TEXT_PLAIN_VALUE)
		String one() {
			return 'One';
		}
		@PostMapping('/two')
		ResponseEntity<String> two(@RequestBody Map<String, Object> content) {
			return ResponseEntity.created(URI.create('/example/' + content.get('id'))).build();
		}
		@RequestMapping(path = '/three', produces = MediaType.TEXT_PLAIN_VALUE)
		String three() {
			return 'Three';
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
class MvcWebEndpointIntegrationTests
		extends AbstractWebEndpointIntegrationTests<AnnotationConfigServletWebServerApplicationContext> {
	MvcWebEndpointIntegrationTests() {
		super(MvcWebEndpointIntegrationTests::createApplicationContext,
				MvcWebEndpointIntegrationTests::applyAuthenticatedConfiguration);
	}
	private static AnnotationConfigServletWebServerApplicationContext createApplicationContext() {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();
		context.register(WebMvcConfiguration.class);
		return context;
	}
	private static void applyAuthenticatedConfiguration(AnnotationConfigServletWebServerApplicationContext context) {
		context.register(AuthenticatedConfiguration.class);
	}
	@Test
	void responseToOptionsRequestIncludesCorsHeaders() {
		load(TestEndpointConfiguration.class,
				(client) -> client.options()
					.uri('/test')
					.accept(MediaType.APPLICATION_JSON)
					.header('Access-Control-Request-Method', 'POST')
					.header('Origin', 'https://example.com')
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueEquals('Access-Control-Allow-Origin', 'https://example.com')
					.expectHeader()
					.valueEquals('Access-Control-Allow-Methods', 'GET,POST'));
	}
	@Test
	void readOperationsThatReturnAResourceSupportRangeRequests() {
		load(ResourceEndpointConfiguration.class, (client) -> {
			byte[] responseBody = client.get()
				.uri('/resource')
				.header('Range', 'bytes=0-3')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.PARTIAL_CONTENT)
				.expectHeader()
				.contentType(MediaType.APPLICATION_OCTET_STREAM)
				.returnResult(byte[].class)
				.getResponseBodyContent();
			assertThat(responseBody).containsExactly(0, 1, 2, 3);
		});
	}
	@Test
	void requestWithSuffixShouldNotMatch() {
		load(TestEndpointConfiguration.class,
				(client) -> client.options()
					.uri('/test.do')
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isNotFound());
	}
	@Override
	protected int getPort(AnnotationConfigServletWebServerApplicationContext context) {
		return context.getWebServer().getPort();
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			ServletWebServerFactoryAutoConfiguration.class, WebMvcAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class })
	static class WebMvcConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		WebMvcEndpointHandlerMapping webEndpointHandlerMapping(Environment environment,
				WebEndpointDiscoverer endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) {
			CorsConfiguration corsConfiguration = new CorsConfiguration();
			corsConfiguration.setAllowedOrigins(Arrays.asList('https://example.com'));
			corsConfiguration.setAllowedMethods(Arrays.asList('GET', 'POST'));
			String endpointPath = environment.getProperty('endpointPath');
			return new WebMvcEndpointHandlerMapping(new EndpointMapping(endpointPath),
					endpointDiscoverer.getEndpoints(), endpointMediaTypes, corsConfiguration,
					new EndpointLinksResolver(endpointDiscoverer.getEndpoints()), StringUtils.hasText(endpointPath));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			ServletWebServerFactoryAutoConfiguration.class, WebMvcAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class })
	static class PathMatcherWebMvcConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		WebMvcEndpointHandlerMapping webEndpointHandlerMapping(Environment environment,
				WebEndpointDiscoverer endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) {
			CorsConfiguration corsConfiguration = new CorsConfiguration();
			corsConfiguration.setAllowedOrigins(Arrays.asList('https://example.com'));
			corsConfiguration.setAllowedMethods(Arrays.asList('GET', 'POST'));
			String endpointPath = environment.getProperty('endpointPath');
			WebMvcEndpointHandlerMapping handlerMapping = new WebMvcEndpointHandlerMapping(
					new EndpointMapping(endpointPath), endpointDiscoverer.getEndpoints(), endpointMediaTypes,
					corsConfiguration, new EndpointLinksResolver(endpointDiscoverer.getEndpoints()),
					StringUtils.hasText(endpointPath));
			return handlerMapping;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AuthenticatedConfiguration {
		@Bean
		Filter securityFilter() {
			return new OncePerRequestFilter() {
				@Override
				protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
						FilterChain filterChain) throws ServletException, IOException {
					SecurityContext context = SecurityContextHolder.createEmptyContext();
					context.setAuthentication(new UsernamePasswordAuthenticationToken('Alice', 'secret',
							Arrays.asList(new SimpleGrantedAuthority('ROLE_ACTUATOR'))));
					SecurityContextHolder.setContext(context);
					try {
						filterChain.doFilter(new SecurityContextHolderAwareRequestWrapper(request, 'ROLE_'), response);
					}
					finally {
						SecurityContextHolder.clearContext();
					}
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@ExtendWith(MockitoExtension.class)
@SuppressWarnings({ 'deprecation', 'removal' })
class ServletEndpointRegistrarTests {
	@Mock
	private ServletContext servletContext;
	@Mock
	private ServletRegistration.Dynamic servletDynamic;
	@Mock
	private FilterRegistration.Dynamic filterDynamic;
	@Test
	void createWhenServletEndpointsIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ServletEndpointRegistrar(null, null))
			.withMessageContaining('ServletEndpoints must not be null');
	}
	@Test
	void onStartupShouldRegisterServlets() throws ServletException {
		assertBasePath(null, '/test/*');
	}
	@Test
	void onStartupWhenHasBasePathShouldIncludeBasePath() throws ServletException {
		assertBasePath('/actuator', '/actuator/test/*');
	}
	@Test
	void onStartupWhenHasEmptyBasePathShouldPrefixWithSlash() throws ServletException {
		assertBasePath('', '/test/*');
	}
	@Test
	void onStartupWhenHasRootBasePathShouldNotAddDuplicateSlash() throws ServletException {
		assertBasePath('/', '/test/*');
	}
	private void assertBasePath(String basePath, String expectedMapping) throws ServletException {
		given(this.servletContext.addServlet(any(String.class), any(Servlet.class))).willReturn(this.servletDynamic);
		ExposableServletEndpoint endpoint = mockEndpoint(new EndpointServlet(TestServlet.class));
		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar(basePath, Collections.singleton(endpoint),
				(endpointId, defaultAccess) -> Access.UNRESTRICTED);
		registrar.onStartup(this.servletContext);
		then(this.servletContext).should()
			.addServlet(eq('test-actuator-endpoint'),
					(Servlet) assertArg((servlet) -> assertThat(servlet).isInstanceOf(TestServlet.class)));
		then(this.servletDynamic).should().addMapping(expectedMapping);
		then(this.servletContext).shouldHaveNoMoreInteractions();
	}
	@Test
	void onStartupWhenHasInitParametersShouldRegisterInitParameters() throws Exception {
		given(this.servletContext.addServlet(any(String.class), any(Servlet.class))).willReturn(this.servletDynamic);
		ExposableServletEndpoint endpoint = mockEndpoint(
				new EndpointServlet(TestServlet.class).withInitParameter('a', 'b'));
		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar('/actuator', Collections.singleton(endpoint),
				(endpointId, defaultAccess) -> Access.UNRESTRICTED);
		registrar.onStartup(this.servletContext);
		then(this.servletDynamic).should().setInitParameters(Collections.singletonMap('a', 'b'));
	}
	@Test
	void onStartupWhenHasLoadOnStartupShouldRegisterLoadOnStartup() throws Exception {
		given(this.servletContext.addServlet(any(String.class), any(Servlet.class))).willReturn(this.servletDynamic);
		ExposableServletEndpoint endpoint = mockEndpoint(new EndpointServlet(TestServlet.class).withLoadOnStartup(7));
		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar('/actuator', Collections.singleton(endpoint),
				(endpointId, defaultAccess) -> Access.UNRESTRICTED);
		registrar.onStartup(this.servletContext);
		then(this.servletDynamic).should().setLoadOnStartup(7);
	}
	@Test
	void onStartupWhenHasNotLoadOnStartupShouldRegisterDefaultValue() throws Exception {
		given(this.servletContext.addServlet(any(String.class), any(Servlet.class))).willReturn(this.servletDynamic);
		ExposableServletEndpoint endpoint = mockEndpoint(new EndpointServlet(TestServlet.class));
		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar('/actuator', Collections.singleton(endpoint),
				(endpointId, defaultAccess) -> Access.UNRESTRICTED);
		registrar.onStartup(this.servletContext);
		then(this.servletDynamic).should().setLoadOnStartup(-1);
	}
	@Test
	void onStartupWhenAccessIsDisabledShouldNotRegister() throws Exception {
		ExposableServletEndpoint endpoint = mock(ExposableServletEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(EndpointId.of('test'));
		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar('/actuator', Collections.singleton(endpoint));
		registrar.onStartup(this.servletContext);
		then(this.servletContext).shouldHaveNoInteractions();
	}
	@Test
	void onStartupWhenAccessIsReadOnlyShouldRegisterServletWithFilter() throws Exception {
		ExposableServletEndpoint endpoint = mockEndpoint(new EndpointServlet(TestServlet.class));
		given(endpoint.getEndpointId()).willReturn(EndpointId.of('test'));
		given(this.servletContext.addServlet(any(String.class), any(Servlet.class))).willReturn(this.servletDynamic);
		given(this.servletContext.addFilter(any(String.class), any(Filter.class))).willReturn(this.filterDynamic);
		ServletEndpointRegistrar registrar = new ServletEndpointRegistrar('/actuator', Collections.singleton(endpoint),
				(endpointId, defaultAccess) -> Access.READ_ONLY);
		registrar.onStartup(this.servletContext);
		then(this.servletContext).should()
			.addServlet(eq('test-actuator-endpoint'),
					(Servlet) assertArg((servlet) -> assertThat(servlet).isInstanceOf(TestServlet.class)));
		then(this.servletDynamic).should().addMapping('/actuator/test/*');
		then(this.servletContext).should()
			.addFilter(eq('test-actuator-endpoint-access-filter'), (Filter) assertArg((filter) -> assertThat(filter)
				.isInstanceOf(
						org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar.ReadOnlyAccessFilter.class)));
		then(this.filterDynamic).should()
			.addMappingForServletNames(EnumSet.allOf(DispatcherType.class), false, 'test-actuator-endpoint');
	}
	private ExposableServletEndpoint mockEndpoint(EndpointServlet endpointServlet) {
		ExposableServletEndpoint endpoint = mock(ExposableServletEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(EndpointId.of('test'));
		given(endpoint.getEndpointServlet()).willReturn(endpointServlet);
		given(endpoint.getRootPath()).willReturn('test');
		return endpoint;
	}
	static class TestServlet extends GenericServlet {
		@Override
		public void service(ServletRequest req, ServletResponse res) {
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
class EndpointMediaTypesTests {
	private static final String V2_JSON = ApiVersion.V2.getProducedMimeType().toString();
	private static final String V3_JSON = ApiVersion.V3.getProducedMimeType().toString();
	@Test
	void defaultReturnsExpectedProducedAndConsumedTypes() {
		assertThat(EndpointMediaTypes.DEFAULT.getProduced()).containsExactly(V3_JSON, V2_JSON, 'application/json');
		assertThat(EndpointMediaTypes.DEFAULT.getConsumed()).containsExactly(V3_JSON, V2_JSON, 'application/json');
	}
	@Test
	void createWhenProducedIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new EndpointMediaTypes(null, Collections.emptyList()))
			.withMessageContaining('Produced must not be null');
	}
	@Test
	void createWhenConsumedIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new EndpointMediaTypes(Collections.emptyList(), null))
			.withMessageContaining('Consumed must not be null');
	}
	@Test
	void createFromProducedAndConsumedUsesSameListForBoth() {
		EndpointMediaTypes types = new EndpointMediaTypes('spring/framework', 'spring/boot');
		assertThat(types.getProduced()).containsExactly('spring/framework', 'spring/boot');
		assertThat(types.getConsumed()).containsExactly('spring/framework', 'spring/boot');
	}
	@Test
	void getProducedShouldReturnProduced() {
		List<String> produced = Arrays.asList('a', 'b', 'c');
		EndpointMediaTypes types = new EndpointMediaTypes(produced, Collections.emptyList());
		assertThat(types.getProduced()).isEqualTo(produced);
	}
	@Test
	void getConsumedShouldReturnConsumed() {
		List<String> consumed = Arrays.asList('a', 'b', 'c');
		EndpointMediaTypes types = new EndpointMediaTypes(Collections.emptyList(), consumed);
		assertThat(types.getConsumed()).isEqualTo(consumed);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
class EndpointMappingTests {
	@Test
	void normalizationTurnsASlashIntoAnEmptyString() {
		assertThat(new EndpointMapping('/').getPath()).isEmpty();
	}
	@Test
	void normalizationLeavesAnEmptyStringAsIs() {
		assertThat(new EndpointMapping('').getPath()).isEmpty();
	}
	@Test
	void normalizationRemovesATrailingSlash() {
		assertThat(new EndpointMapping('/test/').getPath()).isEqualTo('/test');
	}
	@Test
	void normalizationAddsALeadingSlash() {
		assertThat(new EndpointMapping('test').getPath()).isEqualTo('/test');
	}
	@Test
	void normalizationAddsALeadingSlashAndRemovesATrailingSlash() {
		assertThat(new EndpointMapping('test/').getPath()).isEqualTo('/test');
	}
	@Test
	void normalizationLeavesAPathWithALeadingSlashAndNoTrailingSlashAsIs() {
		assertThat(new EndpointMapping('/test').getPath()).isEqualTo('/test');
	}
	@Test
	void subPathForAnEmptyStringReturnsBasePath() {
		assertThat(new EndpointMapping('/test').createSubPath('')).isEqualTo('/test');
	}
	@Test
	void subPathWithALeadingSlashIsSeparatedFromBasePathBySingleSlash() {
		assertThat(new EndpointMapping('/test').createSubPath('/one')).isEqualTo('/test/one');
	}
	@Test
	void subPathWithoutALeadingSlashIsSeparatedFromBasePathBySingleSlash() {
		assertThat(new EndpointMapping('/test').createSubPath('one')).isEqualTo('/test/one');
	}
	@Test
	void trailingSlashIsRemovedFromASubPath() {
		assertThat(new EndpointMapping('/test').createSubPath('one/')).isEqualTo('/test/one');
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
class WebServerNamespaceTests {
	@Test
	void fromWhenValueHasText() {
		assertThat(WebServerNamespace.from('management')).isEqualTo(WebServerNamespace.MANAGEMENT);
	}
	@Test
	void fromWhenValueIsNull() {
		assertThat(WebServerNamespace.from(null)).isEqualTo(WebServerNamespace.SERVER);
	}
	@Test
	void fromWhenValueIsEmpty() {
		assertThat(WebServerNamespace.from('')).isEqualTo(WebServerNamespace.SERVER);
	}
	@Test
	void namespaceWithSameValueAreEqual() {
		assertThat(WebServerNamespace.from('value')).isEqualTo(WebServerNamespace.from('value'));
	}
	@Test
	void namespaceWithDifferentValuesAreNotEqual() {
		assertThat(WebServerNamespace.from('value')).isNotEqualTo(WebServerNamespace.from('other'));
	}
	@Test
	void toStringReturnsString() {
		assertThat(WebServerNamespace.from('value')).hasToString('value');
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
class AbstractWebFluxEndpointHandlerMappingTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new AbstractWebFluxEndpointHandlerMappingRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(TypeReference
				.of('org.springframework.boot.actuate.endpoint.web.reactive.AbstractWebFluxEndpointHandlerMapping.WriteOperationHandler')))
			.accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(TypeReference
				.of('org.springframework.boot.actuate.endpoint.web.reactive.AbstractWebFluxEndpointHandlerMapping.ReadOperationHandler')))
			.accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
class WebFluxEndpointIntegrationTests
		extends AbstractWebEndpointIntegrationTests<AnnotationConfigReactiveWebServerApplicationContext> {
	WebFluxEndpointIntegrationTests() {
		super(WebFluxEndpointIntegrationTests::createApplicationContext,
				WebFluxEndpointIntegrationTests::applyAuthenticatedConfiguration);
	}
	private static AnnotationConfigReactiveWebServerApplicationContext createApplicationContext() {
		AnnotationConfigReactiveWebServerApplicationContext context = new AnnotationConfigReactiveWebServerApplicationContext();
		context.register(ReactiveConfiguration.class);
		return context;
	}
	private static void applyAuthenticatedConfiguration(AnnotationConfigReactiveWebServerApplicationContext context) {
		context.register(AuthenticatedConfiguration.class);
	}
	@Test
	void responseToOptionsRequestIncludesCorsHeaders() {
		load(TestEndpointConfiguration.class,
				(client) -> client.options()
					.uri('/test')
					.accept(MediaType.APPLICATION_JSON)
					.header('Access-Control-Request-Method', 'POST')
					.header('Origin', 'https://example.com')
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueEquals('Access-Control-Allow-Origin', 'https://example.com')
					.expectHeader()
					.valueEquals('Access-Control-Allow-Methods', 'GET,POST'));
	}
	@Test
	void readOperationsThatReturnAResourceSupportRangeRequests() {
		load(ResourceEndpointConfiguration.class, (client) -> {
			byte[] responseBody = client.get()
				.uri('/resource')
				.header('Range', 'bytes=0-3')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.PARTIAL_CONTENT)
				.expectHeader()
				.contentType(MediaType.APPLICATION_OCTET_STREAM)
				.returnResult(byte[].class)
				.getResponseBodyContent();
			assertThat(responseBody).containsExactly(0, 1, 2, 3);
		});
	}
	@Override
	protected int getPort(AnnotationConfigReactiveWebServerApplicationContext context) {
		return context.getBean(ReactiveConfiguration.class).port;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebFlux
	@ImportAutoConfiguration(ErrorWebFluxAutoConfiguration.class)
	static class ReactiveConfiguration {
		private int port;
		@Bean
		NettyReactiveWebServerFactory netty() {
			return new NettyReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler(ApplicationContext applicationContext) {
			return WebHttpHandlerBuilder.applicationContext(applicationContext).build();
		}
		@Bean
		WebFluxEndpointHandlerMapping webEndpointHandlerMapping(Environment environment,
				WebEndpointDiscoverer endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) {
			CorsConfiguration corsConfiguration = new CorsConfiguration();
			corsConfiguration.setAllowedOrigins(Arrays.asList('https://example.com'));
			corsConfiguration.setAllowedMethods(Arrays.asList('GET', 'POST'));
			String endpointPath = environment.getProperty('endpointPath');
			return new WebFluxEndpointHandlerMapping(new EndpointMapping(endpointPath),
					endpointDiscoverer.getEndpoints(), endpointMediaTypes, corsConfiguration,
					new EndpointLinksResolver(endpointDiscoverer.getEndpoints()), StringUtils.hasText(endpointPath));
		}
		@Bean
		ApplicationListener<ReactiveWebServerInitializedEvent> serverInitializedListener() {
			return (event) -> this.port = event.getWebServer().getPort();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AuthenticatedConfiguration {
		@Bean
		WebFilter webFilter() {
			return (exchange, chain) -> chain.filter(exchange)
				.contextWrite(ReactiveSecurityContextHolder.withAuthentication(new UsernamePasswordAuthenticationToken(
						'Alice', 'secret', Arrays.asList(new SimpleGrantedAuthority('ROLE_ACTUATOR')))));
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
@Deprecated(since = '3.3.5', forRemoval = true)
@SuppressWarnings('removal')
class ControllerEndpointHandlerMappingTests {
	private final StaticApplicationContext context = new StaticApplicationContext();
	@Test
	void mappingWithNoPrefix() {
		ExposableControllerEndpoint first = firstEndpoint();
		ExposableControllerEndpoint second = secondEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('', first, second);
		assertThat(getHandler(mapping, HttpMethod.GET, '/first')).isEqualTo(handlerOf(first.getController(), 'get'));
		assertThat(getHandler(mapping, HttpMethod.POST, '/second'))
			.isEqualTo(handlerOf(second.getController(), 'save'));
		assertThat(getHandler(mapping, HttpMethod.GET, '/third')).isNull();
	}
	@Test
	void mappingWithPrefix() {
		ExposableControllerEndpoint first = firstEndpoint();
		ExposableControllerEndpoint second = secondEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('actuator', first, second);
		assertThat(getHandler(mapping, HttpMethod.GET, '/actuator/first'))
			.isEqualTo(handlerOf(first.getController(), 'get'));
		assertThat(getHandler(mapping, HttpMethod.POST, '/actuator/second'))
			.isEqualTo(handlerOf(second.getController(), 'save'));
		assertThat(getHandler(mapping, HttpMethod.GET, '/first')).isNull();
		assertThat(getHandler(mapping, HttpMethod.GET, '/second')).isNull();
	}
	@Test
	void mappingWithNoPath() {
		ExposableControllerEndpoint pathless = pathlessEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('actuator', pathless);
		assertThat(getHandler(mapping, HttpMethod.GET, '/actuator/pathless'))
			.isEqualTo(handlerOf(pathless.getController(), 'get'));
		assertThat(getHandler(mapping, HttpMethod.GET, '/pathless')).isNull();
		assertThat(getHandler(mapping, HttpMethod.GET, '/')).isNull();
	}
	@Test
	void mappingNarrowedToMethod() {
		ExposableControllerEndpoint first = firstEndpoint();
		ControllerEndpointHandlerMapping mapping = createMapping('actuator', first);
		assertThatExceptionOfType(MethodNotAllowedException.class)
			.isThrownBy(() -> getHandler(mapping, HttpMethod.POST, '/actuator/first'));
	}
	private Object getHandler(ControllerEndpointHandlerMapping mapping, HttpMethod method, String requestURI) {
		return mapping.getHandler(exchange(method, requestURI)).block(Duration.ofSeconds(30));
	}
	private ControllerEndpointHandlerMapping createMapping(String prefix, ExposableControllerEndpoint... endpoints) {
		ControllerEndpointHandlerMapping mapping = new ControllerEndpointHandlerMapping(new EndpointMapping(prefix),
				Arrays.asList(endpoints), null, (endpointId, defaultAccess) -> Access.UNRESTRICTED);
		mapping.setApplicationContext(this.context);
		mapping.afterPropertiesSet();
		return mapping;
	}
	private HandlerMethod handlerOf(Object source, String methodName) {
		return new HandlerMethod(source, ReflectionUtils.findMethod(source.getClass(), methodName));
	}
	private MockServerWebExchange exchange(HttpMethod method, String requestURI) {
		return MockServerWebExchange.from(MockServerHttpRequest.method(method, requestURI).build());
	}
	private ExposableControllerEndpoint firstEndpoint() {
		return mockEndpoint(EndpointId.of('first'), new FirstTestMvcEndpoint());
	}
	private ExposableControllerEndpoint secondEndpoint() {
		return mockEndpoint(EndpointId.of('second'), new SecondTestMvcEndpoint());
	}
	private ExposableControllerEndpoint pathlessEndpoint() {
		return mockEndpoint(EndpointId.of('pathless'), new PathlessControllerEndpoint());
	}
	private ExposableControllerEndpoint mockEndpoint(EndpointId id, Object controller) {
		ExposableControllerEndpoint endpoint = mock(ExposableControllerEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(id);
		given(endpoint.getController()).willReturn(controller);
		given(endpoint.getRootPath()).willReturn(id.toString());
		return endpoint;
	}
	@ControllerEndpoint(id = 'first')
	static class FirstTestMvcEndpoint {
		@GetMapping('/')
		String get() {
			return 'test';
		}
	}
	@ControllerEndpoint(id = 'second')
	static class SecondTestMvcEndpoint {
		@PostMapping('/')
		void save() {
		}
	}
	@ControllerEndpoint(id = 'pathless')
	static class PathlessControllerEndpoint {
		@GetMapping
		String get() {
			return 'test';
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
class WebFluxEndpointHandlerMappingTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new WebFluxEndpointHandlerMappingRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onMethod(WebFluxLinksHandler.class, 'links'))
			.accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(Link.class)).accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.3.5', forRemoval = true)
class ControllerEndpointHandlerMappingIntegrationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner(
			AnnotationConfigReactiveWebServerApplicationContext::new)
		.withUserConfiguration(EndpointConfiguration.class, ExampleWebFluxEndpoint.class);
	@Test
	void getMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.get()
			.uri('/actuator/example/one')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
			.expectBody(String.class)
			.isEqualTo('One')));
	}
	@Test
	void getWithUnacceptableContentType() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.get()
			.uri('/actuator/example/one')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isEqualTo(HttpStatus.NOT_ACCEPTABLE)));
	}
	@Test
	void postMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.post()
			.uri('/actuator/example/two')
			.bodyValue(Collections.singletonMap('id', 'test'))
			.exchange()
			.expectStatus()
			.isCreated()
			.expectHeader()
			.valueEquals(HttpHeaders.LOCATION, '/example/test')));
	}
	@Test
	void postMappingWithReadOnlyAccessRespondsWith404() {
		this.contextRunner.withPropertyValues('endpoint-access=READ_ONLY')
			.run(withWebTestClient((webTestClient) -> webTestClient.post()
				.uri('/actuator/example/two')
				.bodyValue(Collections.singletonMap('id', 'test'))
				.exchange()
				.expectStatus()
				.isNotFound()));
	}
	@Test
	void getToRequestMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.get()
			.uri('/actuator/example/three')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
			.expectBody(String.class)
			.isEqualTo('Three')));
	}
	@Test
	void getToRequestMappingWithReadOnlyAccess() {
		this.contextRunner.withPropertyValues('endpoint-access=READ_ONLY')
			.run(withWebTestClient((webTestClient) -> webTestClient.get()
				.uri('/actuator/example/three')
				.accept(MediaType.TEXT_PLAIN)
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
				.expectBody(String.class)
				.isEqualTo('Three')));
	}
	@Test
	void postToRequestMapping() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.post()
			.uri('/actuator/example/three')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentTypeCompatibleWith(MediaType.TEXT_PLAIN)
			.expectBody(String.class)
			.isEqualTo('Three')));
	}
	@Test
	void postToRequestMappingWithReadOnlyAccessRespondsWith405() {
		this.contextRunner.withPropertyValues('endpoint-access=READ_ONLY')
			.run(withWebTestClient((webTestClient) -> webTestClient.post()
				.uri('/actuator/example/three')
				.accept(MediaType.TEXT_PLAIN)
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.METHOD_NOT_ALLOWED)));
	}
	private ContextConsumer<AssertableReactiveWebApplicationContext> withWebTestClient(
			Consumer<WebTestClient> webClient) {
		return (context) -> {
			int port = ((AnnotationConfigReactiveWebServerApplicationContext) context.getSourceApplicationContext())
				.getWebServer()
				.getPort();
			WebTestClient webTestClient = createWebTestClient(port);
			webClient.accept(webTestClient);
		};
	}
	private WebTestClient createWebTestClient(int port) {
		DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory('http://localhost:' + port);
		uriBuilderFactory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.NONE);
		return WebTestClient.bindToServer()
			.uriBuilderFactory(uriBuilderFactory)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			WebFluxAutoConfiguration.class })
	static class EndpointConfiguration {
		@Bean
		NettyReactiveWebServerFactory netty() {
			return new NettyReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler(ApplicationContext applicationContext) {
			return WebHttpHandlerBuilder.applicationContext(applicationContext).build();
		}
		@Bean
		ControllerEndpointDiscoverer webEndpointDiscoverer(ApplicationContext applicationContext) {
			return new ControllerEndpointDiscoverer(applicationContext, null, Collections.emptyList());
		}
		@Bean
		ControllerEndpointHandlerMapping webEndpointHandlerMapping(ControllerEndpointsSupplier endpointsSupplier,
				EndpointAccessResolver endpointAccessResolver) {
			return new ControllerEndpointHandlerMapping(new EndpointMapping('actuator'),
					endpointsSupplier.getEndpoints(), null, endpointAccessResolver);
		}
		@Bean
		EndpointAccessResolver endpointAccessResolver(Environment environment) {
			return (id, defaultAccess) -> environment.getProperty('endpoint-access', Access.class, Access.UNRESTRICTED);
		}
	}
	@RestControllerEndpoint(id = 'example')
	static class ExampleWebFluxEndpoint {
		@GetMapping(path = 'one', produces = MediaType.TEXT_PLAIN_VALUE)
		String one() {
			return 'One';
		}
		@PostMapping('/two')
		ResponseEntity<String> two(@RequestBody Map<String, Object> content) {
			return ResponseEntity.created(URI.create('/example/' + content.get('id'))).build();
		}
		@RequestMapping(path = '/three', produces = MediaType.TEXT_PLAIN_VALUE)
		String three() {
			return 'Three';
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class ShowTests {
	@Test
	void isShownWhenNever() {
		assertThat(Show.NEVER.isShown(null, Collections.emptySet())).isFalse();
		assertThat(Show.NEVER.isShown(true)).isFalse();
		assertThat(Show.NEVER.isShown(false)).isFalse();
	}
	@Test
	void isShownWhenAlways() {
		assertThat(Show.ALWAYS.isShown(null, Collections.emptySet())).isTrue();
		assertThat(Show.ALWAYS.isShown(true)).isTrue();
		assertThat(Show.ALWAYS.isShown(true)).isTrue();
	}
	@Test
	void isShownWithUnauthorizedResult() {
		assertThat(Show.WHEN_AUTHORIZED.isShown(true)).isTrue();
		assertThat(Show.WHEN_AUTHORIZED.isShown(false)).isFalse();
	}
	@Test
	void isShownWhenUserNotInRole() {
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
		given(securityContext.isUserInRole('admin')).willReturn(false);
		assertThat(Show.WHEN_AUTHORIZED.isShown(securityContext, Collections.singleton('admin'))).isFalse();
	}
	@Test
	void isShownWhenUserInRole() {
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
		given(securityContext.isUserInRole('admin')).willReturn(true);
		assertThat(Show.WHEN_AUTHORIZED.isShown(securityContext, Collections.singleton('admin'))).isTrue();
	}
	@Test
	void isShownWhenPrincipalNull() {
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.isUserInRole('admin')).willReturn(true);
		assertThat(Show.WHEN_AUTHORIZED.isShown(securityContext, Collections.singleton('admin'))).isFalse();
	}
	@Test
	void isShownWhenRolesEmpty() {
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
		assertThat(Show.WHEN_AUTHORIZED.isShown(securityContext, Collections.emptySet())).isTrue();
	}
	@Test
	void isShownWhenSpringSecurityAuthenticationAndUnauthorized() {
		SecurityContext securityContext = mock(SecurityContext.class);
		Authentication authentication = mock(Authentication.class);
		given(securityContext.getPrincipal()).willReturn(authentication);
		given(authentication.getAuthorities())
			.willAnswer((invocation) -> Collections.singleton(new SimpleGrantedAuthority('other')));
		assertThat(Show.WHEN_AUTHORIZED.isShown(securityContext, Collections.singleton('admin'))).isFalse();
	}
	@Test
	void isShownWhenSpringSecurityAuthenticationAndAuthorized() {
		SecurityContext securityContext = mock(SecurityContext.class);
		Authentication authentication = mock(Authentication.class);
		given(securityContext.getPrincipal()).willReturn(authentication);
		given(authentication.getAuthorities())
			.willAnswer((invocation) -> Collections.singleton(new SimpleGrantedAuthority('admin')));
		assertThat(Show.WHEN_AUTHORIZED.isShown(securityContext, Collections.singleton('admin'))).isTrue();
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class SanitizableDataTests {
	private final PropertySource<?> propertySource = new MapPropertySource('test', Map.of('key', 'value'));
	@Test
	void getPropertySourceReturnsPropertySource() {
		SanitizableData data = new SanitizableData(this.propertySource, 'key', 'value');
		assertThat(data.getPropertySource()).isSameAs(this.propertySource);
	}
	@Test
	void getKeyReturnsKey() {
		SanitizableData data = new SanitizableData(this.propertySource, 'key', 'value');
		assertThat(data.getKey()).isEqualTo('key');
	}
	@Test
	void getValueReturnsValue() {
		SanitizableData data = new SanitizableData(this.propertySource, 'key', 'value');
		assertThat(data.getValue()).isEqualTo('value');
	}
	@Test
	void withSanitizedValueReturnsNewInstanceWithSanitizedValue() {
		SanitizableData data = new SanitizableData(this.propertySource, 'key', 'value');
		SanitizableData sanitized = data.withSanitizedValue();
		assertThat(data.getValue()).isEqualTo('value');
		assertThat(sanitized.getValue()).isEqualTo('******');
	}
	@Test
	void withValueReturnsNewInstanceWithNewValue() {
		SanitizableData data = new SanitizableData(this.propertySource, 'key', 'value');
		SanitizableData sanitized = data.withValue('eulav');
		assertThat(data.getValue()).isEqualTo('value');
		assertThat(sanitized.getValue()).isEqualTo('eulav');
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class InvocationContextTests {
	private final SecurityContext securityContext = mock(SecurityContext.class);
	private final Map<String, Object> arguments = Collections.singletonMap('test', 'value');
	@Test
	void whenCreatedWithoutApiVersionThenResolveApiVersionReturnsLatestVersion() {
		InvocationContext context = new InvocationContext(this.securityContext, this.arguments);
		assertThat(context.resolveArgument(ApiVersion.class)).isEqualTo(ApiVersion.LATEST);
	}
	@Test
	void createWhenSecurityContextIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new InvocationContext(null, this.arguments))
			.withMessage('SecurityContext must not be null');
	}
	@Test
	void createWhenArgumentsIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new InvocationContext(this.securityContext, null))
			.withMessage('Arguments must not be null');
	}
	@Test
	void resolveSecurityContextReturnsSecurityContext() {
		InvocationContext context = new InvocationContext(this.securityContext, this.arguments);
		assertThat(context.resolveArgument(SecurityContext.class)).isEqualTo(this.securityContext);
	}
	@Test
	void getArgumentsReturnsArguments() {
		InvocationContext context = new InvocationContext(this.securityContext, this.arguments);
		assertThat(context.getArguments()).isEqualTo(this.arguments);
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class ProducibleOperationArgumentResolverTests {
	private static final String V2_JSON = ApiVersion.V2.getProducedMimeType().toString();
	private static final String V3_JSON = ApiVersion.V3.getProducedMimeType().toString();
	@Test
	void whenAcceptHeaderIsEmptyThenHighestOrdinalIsReturned() {
		assertThat(resolve(acceptHeader())).isEqualTo(ApiVersion.V3);
	}
	@Test
	void whenAcceptHeaderIsEmptyAndWithDefaultThenDefaultIsReturned() {
		assertThat(resolve(acceptHeader(), WithDefault.class)).isEqualTo(WithDefault.TWO);
	}
	@Test
	void whenEverythingIsAcceptableThenHighestOrdinalIsReturned() {
		assertThat(resolve(acceptHeader('*/*'))).isEqualTo(ApiVersion.V3);
	}
	@Test
	void whenEverythingIsAcceptableWithDefaultThenDefaultIsReturned() {
		assertThat(resolve(acceptHeader('*/*'), WithDefault.class)).isEqualTo(WithDefault.TWO);
	}
	@Test
	void whenNothingIsAcceptableThenNullIsReturned() {
		assertThat(resolve(acceptHeader('image/png'))).isNull();
	}
	@Test
	void whenSingleValueIsAcceptableThenMatchingEnumValueIsReturned() {
		assertThat(new ProducibleOperationArgumentResolver(acceptHeader(V2_JSON)).resolve(ApiVersion.class))
			.isEqualTo(ApiVersion.V2);
		assertThat(new ProducibleOperationArgumentResolver(acceptHeader(V3_JSON)).resolve(ApiVersion.class))
			.isEqualTo(ApiVersion.V3);
	}
	@Test
	void whenMultipleValuesAreAcceptableThenHighestOrdinalIsReturned() {
		assertThat(resolve(acceptHeader(V2_JSON, V3_JSON))).isEqualTo(ApiVersion.V3);
	}
	@Test
	void whenMultipleValuesAreAcceptableAsSingleHeaderThenHighestOrdinalIsReturned() {
		assertThat(resolve(acceptHeader(V2_JSON + ',' + V3_JSON))).isEqualTo(ApiVersion.V3);
	}
	@Test
	void withMultipleValuesOneOfWhichIsAllReturnsDefault() {
		assertThat(resolve(acceptHeader('one/one', '*/*'), WithDefault.class)).isEqualTo(WithDefault.TWO);
	}
	@Test
	void whenMultipleDefaultsThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> resolve(acceptHeader('one/one'), WithMultipleDefaults.class))
			.withMessageContaining('Multiple default values');
	}
	private Supplier<List<String>> acceptHeader(String... types) {
		List<String> value = Arrays.asList(types);
		return () -> (value.isEmpty() ? null : value);
	}
	private ApiVersion resolve(Supplier<List<String>> accepts) {
		return resolve(accepts, ApiVersion.class);
	}
	private <T> T resolve(Supplier<List<String>> accepts, Class<T> type) {
		return new ProducibleOperationArgumentResolver(accepts).resolve(type);
	}
	enum WithDefault implements Producible<WithDefault> {
		ONE('one/one'),
		TWO('two/two') {
			@Override
			public boolean isDefault() {
				return true;
			}
		},
		THREE('three/three');
		private final MimeType mimeType;
		WithDefault(String mimeType) {
			this.mimeType = MimeType.valueOf(mimeType);
		}
		@Override
		public MimeType getProducedMimeType() {
			return this.mimeType;
		}
	}
	enum WithMultipleDefaults implements Producible<WithMultipleDefaults> {
		ONE, TWO, THREE;
		@Override
		public boolean isDefault() {
			return true;
		}
		@Override
		public MimeType getProducedMimeType() {
			return MimeType.valueOf('image/jpeg');
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class AccessTests {
	@Test
	void capWhenAboveMaximum() {
		assertThat(Access.UNRESTRICTED.cap(Access.READ_ONLY)).isEqualTo(Access.READ_ONLY);
	}
	@Test
	void capWhenAtMaximum() {
		assertThat(Access.READ_ONLY.cap(Access.READ_ONLY)).isEqualTo(Access.READ_ONLY);
	}
	@Test
	void capWhenBelowMaximum() {
		assertThat(Access.NONE.cap(Access.READ_ONLY)).isEqualTo(Access.NONE);
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoker.cache;
/**
class CachingOperationInvokerTests {
	private static final long CACHE_TTL = Duration.ofHours(1).toMillis();
	@Test
	void createInstanceWithTtlSetToZero() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new CachingOperationInvoker(mock(OperationInvoker.class), 0))
			.withMessageContaining('TimeToLive');
	}
	@Test
	void cacheInTtlRangeWithNoParameter() {
		assertCacheIsUsed(Collections.emptyMap());
	}
	@Test
	void cacheInTtlWithPrincipal() {
		assertCacheIsUsed(Collections.emptyMap(), mock(Principal.class));
	}
	@Test
	void cacheInTtlWithNullParameters() {
		Map<String, Object> parameters = new HashMap<>();
		parameters.put('first', null);
		parameters.put('second', null);
		assertCacheIsUsed(parameters);
	}
	@Test
	void cacheInTtlWithMonoResponse() {
		MonoOperationInvoker.invocations = new AtomicInteger();
		MonoOperationInvoker target = new MonoOperationInvoker();
		InvocationContext context = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap());
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		Object response = ((Mono<?>) invoker.invoke(context)).block();
		Object cachedResponse = ((Mono<?>) invoker.invoke(context)).block();
		assertThat(MonoOperationInvoker.invocations).hasValue(1);
		assertThat(response).isSameAs(cachedResponse);
	}
	@Test
	void cacheInTtlWithFluxResponse() {
		FluxOperationInvoker.invocations = new AtomicInteger();
		FluxOperationInvoker target = new FluxOperationInvoker();
		InvocationContext context = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap());
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		Object response = ((Flux<?>) invoker.invoke(context)).blockLast();
		Object cachedResponse = ((Flux<?>) invoker.invoke(context)).blockLast();
		assertThat(FluxOperationInvoker.invocations).hasValue(1);
		assertThat(response).isSameAs(cachedResponse);
	}
	@Test // gh-28313
	void cacheWhenEachPrincipalIsUniqueDoesNotConsumeTooMuchMemory() throws Exception {
		MonoOperationInvoker target = new MonoOperationInvoker();
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 50L);
		int count = 1000;
		for (int i = 0; i < count; i++) {
			invokeWithUniquePrincipal(invoker);
		}
		long expired = System.currentTimeMillis() + 50;
		while (System.currentTimeMillis() < expired) {
			Thread.sleep(10);
		}
		invokeWithUniquePrincipal(invoker);
		assertThat(invoker).extracting('cachedResponses', as(InstanceOfAssertFactories.MAP)).hasSizeLessThan(count);
	}
	private void invokeWithUniquePrincipal(CachingOperationInvoker invoker) {
		SecurityContext securityContext = mock(SecurityContext.class);
		Principal principal = mock(Principal.class);
		given(securityContext.getPrincipal()).willReturn(principal);
		InvocationContext context = new InvocationContext(securityContext, Collections.emptyMap());
		((Mono<?>) invoker.invoke(context)).block();
	}
	private void assertCacheIsUsed(Map<String, Object> parameters) {
		assertCacheIsUsed(parameters, null);
	}
	private void assertCacheIsUsed(Map<String, Object> parameters, Principal principal) {
		OperationInvoker target = mock(OperationInvoker.class);
		Object expected = new Object();
		SecurityContext securityContext = mock(SecurityContext.class);
		if (principal != null) {
			given(securityContext.getPrincipal()).willReturn(principal);
		}
		InvocationContext context = new InvocationContext(securityContext, parameters);
		given(target.invoke(context)).willReturn(expected);
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		Object response = invoker.invoke(context);
		assertThat(response).isSameAs(expected);
		then(target).should().invoke(context);
		Object cachedResponse = invoker.invoke(context);
		assertThat(cachedResponse).isSameAs(response);
		then(target).shouldHaveNoMoreInteractions();
	}
	@Test
	void targetAlwaysInvokedWithParameters() {
		OperationInvoker target = mock(OperationInvoker.class);
		Map<String, Object> parameters = new HashMap<>();
		parameters.put('test', 'value');
		parameters.put('something', null);
		InvocationContext context = new InvocationContext(mock(SecurityContext.class), parameters);
		given(target.invoke(context)).willReturn(new Object());
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		invoker.invoke(context);
		invoker.invoke(context);
		invoker.invoke(context);
		then(target).should(times(3)).invoke(context);
	}
	@Test
	void targetAlwaysInvokedWithDifferentPrincipals() {
		OperationInvoker target = mock(OperationInvoker.class);
		Map<String, Object> parameters = new HashMap<>();
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.getPrincipal()).willReturn(mock(Principal.class), mock(Principal.class),
				mock(Principal.class));
		InvocationContext context = new InvocationContext(securityContext, parameters);
		Object result1 = new Object();
		Object result2 = new Object();
		Object result3 = new Object();
		given(target.invoke(context)).willReturn(result1, result2, result3);
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		assertThat(invoker.invoke(context)).isEqualTo(result1);
		assertThat(invoker.invoke(context)).isEqualTo(result2);
		assertThat(invoker.invoke(context)).isEqualTo(result3);
		then(target).should(times(3)).invoke(context);
	}
	@Test
	void targetInvokedWhenCalledWithAndWithoutPrincipal() {
		OperationInvoker target = mock(OperationInvoker.class);
		Map<String, Object> parameters = new HashMap<>();
		SecurityContext anonymous = mock(SecurityContext.class);
		SecurityContext authenticated = mock(SecurityContext.class);
		given(authenticated.getPrincipal()).willReturn(mock(Principal.class));
		InvocationContext anonymousContext = new InvocationContext(anonymous, parameters);
		Object anonymousResult = new Object();
		given(target.invoke(anonymousContext)).willReturn(anonymousResult);
		InvocationContext authenticatedContext = new InvocationContext(authenticated, parameters);
		Object authenticatedResult = new Object();
		given(target.invoke(authenticatedContext)).willReturn(authenticatedResult);
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		assertThat(invoker.invoke(anonymousContext)).isEqualTo(anonymousResult);
		assertThat(invoker.invoke(authenticatedContext)).isEqualTo(authenticatedResult);
		assertThat(invoker.invoke(anonymousContext)).isEqualTo(anonymousResult);
		assertThat(invoker.invoke(authenticatedContext)).isEqualTo(authenticatedResult);
		then(target).should().invoke(anonymousContext);
		then(target).should().invoke(authenticatedContext);
	}
	@Test
	void targetInvokedWhenCacheExpires() throws InterruptedException {
		OperationInvoker target = mock(OperationInvoker.class);
		Map<String, Object> parameters = new HashMap<>();
		InvocationContext context = new InvocationContext(mock(SecurityContext.class), parameters);
		given(target.invoke(context)).willReturn(new Object());
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 50L);
		invoker.invoke(context);
		long expired = System.currentTimeMillis() + 50;
		while (System.currentTimeMillis() < expired) {
			Thread.sleep(10);
		}
		invoker.invoke(context);
		then(target).should(times(2)).invoke(context);
	}
	@Test
	void targetInvokedWithDifferentApiVersion() {
		OperationInvoker target = mock(OperationInvoker.class);
		Object expectedV2 = new Object();
		Object expectedV3 = new Object();
		InvocationContext contextV2 = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap(),
				new ApiVersionArgumentResolver(ApiVersion.V2));
		InvocationContext contextV3 = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap(),
				new ApiVersionArgumentResolver(ApiVersion.V3));
		given(target.invoke(contextV2)).willReturn(expectedV2);
		given(target.invoke(contextV3)).willReturn(expectedV3);
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		Object responseV2 = invoker.invoke(contextV2);
		assertThat(responseV2).isSameAs(expectedV2);
		then(target).should().invoke(contextV2);
		Object responseV3 = invoker.invoke(contextV3);
		assertThat(responseV3).isNotSameAs(responseV2);
		then(target).should().invoke(contextV3);
	}
	@Test
	void targetInvokedWithDifferentWebServerNamespace() {
		OperationInvoker target = mock(OperationInvoker.class);
		Object expectedServer = new Object();
		Object expectedManagement = new Object();
		InvocationContext contextServer = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap(),
				new WebServerNamespaceArgumentResolver(WebServerNamespace.SERVER));
		InvocationContext contextManagement = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap(),
				new WebServerNamespaceArgumentResolver(WebServerNamespace.MANAGEMENT));
		given(target.invoke(contextServer)).willReturn(expectedServer);
		given(target.invoke(contextManagement)).willReturn(expectedManagement);
		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL);
		Object responseServer = invoker.invoke(contextServer);
		assertThat(responseServer).isSameAs(expectedServer);
		then(target).should(times(1)).invoke(contextServer);
		Object responseManagement = invoker.invoke(contextManagement);
		assertThat(responseManagement).isNotSameAs(responseServer);
		then(target).should(times(1)).invoke(contextManagement);
	}
	private static final class MonoOperationInvoker implements OperationInvoker {
		static AtomicInteger invocations = new AtomicInteger();
		@Override
		public Mono<String> invoke(InvocationContext context) {
			return Mono.fromCallable(() -> {
				invocations.incrementAndGet();
				return 'test';
			});
		}
	}
	private static final class FluxOperationInvoker implements OperationInvoker {
		static AtomicInteger invocations = new AtomicInteger();
		@Override
		public Flux<String> invoke(InvocationContext context) {
			return Flux.just('spring', 'boot').hide().doFirst(invocations::incrementAndGet);
		}
	}
	private static final class ApiVersionArgumentResolver implements OperationArgumentResolver {
		private final ApiVersion apiVersion;
		private ApiVersionArgumentResolver(ApiVersion apiVersion) {
			this.apiVersion = apiVersion;
		}
		@SuppressWarnings('unchecked')
		@Override
		public <T> T resolve(Class<T> type) {
			return (T) this.apiVersion;
		}
		@Override
		public boolean canResolve(Class<?> type) {
			return ApiVersion.class.equals(type);
		}
	}
	private static final class WebServerNamespaceArgumentResolver implements OperationArgumentResolver {
		private final WebServerNamespace webServerNamespace;
		private WebServerNamespaceArgumentResolver(WebServerNamespace webServerNamespace) {
			this.webServerNamespace = webServerNamespace;
		}
		@SuppressWarnings('unchecked')
		@Override
		public <T> T resolve(Class<T> type) {
			return (T) this.webServerNamespace;
		}
		@Override
		public boolean canResolve(Class<?> type) {
			return WebServerNamespace.class.equals(type);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoker.cache;
/**
@ExtendWith(MockitoExtension.class)
class CachingOperationInvokerAdvisorTests {
	@Mock
	private OperationInvoker invoker;
	@Mock
	private Function<EndpointId, Long> timeToLive;
	private CachingOperationInvokerAdvisor advisor;
	@BeforeEach
	void setup() {
		this.advisor = new CachingOperationInvokerAdvisor(this.timeToLive);
	}
	@Test
	void applyWhenOperationIsNotReadShouldNotAddAdvise() {
		OperationParameters parameters = getParameters('get');
		OperationInvoker advised = this.advisor.apply(EndpointId.of('foo'), OperationType.WRITE, parameters,
				this.invoker);
		assertThat(advised).isSameAs(this.invoker);
	}
	@Test
	void applyWhenHasAtLeaseOneMandatoryParameterShouldNotAddAdvise() {
		OperationParameters parameters = getParameters('getWithParameters', String.class, String.class);
		OperationInvoker advised = this.advisor.apply(EndpointId.of('foo'), OperationType.READ, parameters,
				this.invoker);
		assertThat(advised).isSameAs(this.invoker);
	}
	@Test
	void applyWhenTimeToLiveReturnsNullShouldNotAddAdvise() {
		OperationParameters parameters = getParameters('get');
		given(this.timeToLive.apply(any())).willReturn(null);
		OperationInvoker advised = this.advisor.apply(EndpointId.of('foo'), OperationType.READ, parameters,
				this.invoker);
		assertThat(advised).isSameAs(this.invoker);
		then(this.timeToLive).should().apply(EndpointId.of('foo'));
	}
	@Test
	void applyWhenTimeToLiveIsZeroShouldNotAddAdvise() {
		OperationParameters parameters = getParameters('get');
		given(this.timeToLive.apply(any())).willReturn(0L);
		OperationInvoker advised = this.advisor.apply(EndpointId.of('foo'), OperationType.READ, parameters,
				this.invoker);
		assertThat(advised).isSameAs(this.invoker);
		then(this.timeToLive).should().apply(EndpointId.of('foo'));
	}
	@Test
	void applyShouldAddCacheAdvise() {
		OperationParameters parameters = getParameters('get');
		given(this.timeToLive.apply(any())).willReturn(100L);
		assertAdviseIsApplied(parameters);
	}
	@Test
	void applyWithAllOptionalParametersShouldAddAdvise() {
		OperationParameters parameters = getParameters('getWithAllOptionalParameters', String.class, String.class);
		given(this.timeToLive.apply(any())).willReturn(100L);
		assertAdviseIsApplied(parameters);
	}
	@Test
	void applyWithSecurityContextShouldAddAdvise() {
		OperationParameters parameters = getParameters('getWithSecurityContext', SecurityContext.class, String.class);
		given(this.timeToLive.apply(any())).willReturn(100L);
		assertAdviseIsApplied(parameters);
	}
	@Test
	void applyWithApiVersionShouldAddAdvise() {
		OperationParameters parameters = getParameters('getWithApiVersion', ApiVersion.class, String.class);
		given(this.timeToLive.apply(any())).willReturn(100L);
		assertAdviseIsApplied(parameters);
	}
	@Test
	void applyWithWebServerNamespaceShouldAddAdvise() {
		OperationParameters parameters = getParameters('getWithServerNamespace', WebServerNamespace.class,
				String.class);
		given(this.timeToLive.apply(any())).willReturn(100L);
		assertAdviseIsApplied(parameters);
	}
	@Test
	void applyWithMandatoryCachedAndNonCachedShouldAddAdvise() {
		OperationParameters parameters = getParameters('getWithServerNamespaceAndOtherMandatory',
				WebServerNamespace.class, String.class);
		OperationInvoker advised = this.advisor.apply(EndpointId.of('foo'), OperationType.READ, parameters,
				this.invoker);
		assertThat(advised).isSameAs(this.invoker);
	}
	private void assertAdviseIsApplied(OperationParameters parameters) {
		OperationInvoker advised = this.advisor.apply(EndpointId.of('foo'), OperationType.READ, parameters,
				this.invoker);
		assertThat(advised).isInstanceOf(CachingOperationInvoker.class);
		assertThat(advised).hasFieldOrPropertyWithValue('invoker', this.invoker);
		assertThat(advised).hasFieldOrPropertyWithValue('timeToLive', 100L);
	}
	private OperationParameters getParameters(String methodName, Class<?>... parameterTypes) {
		return getOperationMethod(methodName, parameterTypes).getParameters();
	}
	private OperationMethod getOperationMethod(String methodName, Class<?>... parameterTypes) {
		Method method = ReflectionUtils.findMethod(TestOperations.class, methodName, parameterTypes);
		return new OperationMethod(method, OperationType.READ);
	}
	static class TestOperations {
		String get() {
			return '';
		}
		String getWithParameters(@Nullable String foo, String bar) {
			return '';
		}
		String getWithAllOptionalParameters(@Nullable String foo, @Nullable String bar) {
			return '';
		}
		String getWithSecurityContext(SecurityContext securityContext, @Nullable String bar) {
			return '';
		}
		String getWithApiVersion(ApiVersion apiVersion, @Nullable String bar) {
			return '';
		}
		String getWithServerNamespace(WebServerNamespace serverNamespace, @Nullable String bar) {
			return '';
		}
		String getWithServerNamespaceAndOtherMandatory(WebServerNamespace serverNamespace, String bar) {
			return '';
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class SanitizerTests {
	@Test
	void whenNoSanitizationFunctionAndShowUnsanitizedIsFalse() {
		Sanitizer sanitizer = new Sanitizer();
		assertThat(sanitizer.sanitize(new SanitizableData(null, 'password', 'secret'), false)).isEqualTo('******');
		assertThat(sanitizer.sanitize(new SanitizableData(null, 'other', 'something'), false)).isEqualTo('******');
	}
	@Test
	void whenNoSanitizationFunctionAndShowUnsanitizedIsTrue() {
		Sanitizer sanitizer = new Sanitizer();
		assertThat(sanitizer.sanitize(new SanitizableData(null, 'password', 'secret'), true)).isEqualTo('secret');
		assertThat(sanitizer.sanitize(new SanitizableData(null, 'other', 'something'), true)).isEqualTo('something');
	}
	@Test
	void whenCustomSanitizationFunctionAndShowUnsanitizedIsFalse() {
		Sanitizer sanitizer = new Sanitizer(Collections.singletonList((data) -> {
			if (data.getKey().equals('custom')) {
				return data.withValue('$$$$$$');
			}
			return data;
		}));
		SanitizableData secret = new SanitizableData(null, 'secret', 'xyz');
		assertThat(sanitizer.sanitize(secret, false)).isEqualTo('******');
		SanitizableData custom = new SanitizableData(null, 'custom', 'abcde');
		assertThat(sanitizer.sanitize(custom, false)).isEqualTo('******');
		SanitizableData hello = new SanitizableData(null, 'hello', 'abc');
		assertThat(sanitizer.sanitize(hello, false)).isEqualTo('******');
	}
	@Test
	void whenCustomSanitizationFunctionAndShowUnsanitizedIsTrue() {
		Sanitizer sanitizer = new Sanitizer(Collections.singletonList((data) -> {
			if (data.getKey().equals('custom')) {
				return data.withValue('$$$$$$');
			}
			return data;
		}));
		SanitizableData secret = new SanitizableData(null, 'secret', 'xyz');
		assertThat(sanitizer.sanitize(secret, true)).isEqualTo('xyz');
		SanitizableData custom = new SanitizableData(null, 'custom', 'abcde');
		assertThat(sanitizer.sanitize(custom, true)).isEqualTo('$$$$$$');
		SanitizableData hello = new SanitizableData(null, 'hello', 'abc');
		assertThat(sanitizer.sanitize(hello, true)).isEqualTo('abc');
	}
	@Test
	void overridingDefaultSanitizingFunction() {
		Sanitizer sanitizer = new Sanitizer(Collections.singletonList((data) -> {
			if (data.getKey().equals('password')) {
				return data.withValue('------');
			}
			return data;
		}));
		SanitizableData password = new SanitizableData(null, 'password', '123456');
		assertThat(sanitizer.sanitize(password, true)).isEqualTo('------');
	}
	@Test
	void whenValueSanitizedLaterSanitizingFunctionsShouldBeSkipped() {
		final String sameKey = 'custom';
		List<SanitizingFunction> sanitizingFunctions = new ArrayList<>();
		sanitizingFunctions.add((data) -> {
			if (data.getKey().equals(sameKey)) {
				return data.withValue('------');
			}
			return data;
		});
		sanitizingFunctions.add((data) -> {
			if (data.getKey().equals(sameKey)) {
				return data.withValue('******');
			}
			return data;
		});
		Sanitizer sanitizer = new Sanitizer(sanitizingFunctions);
		SanitizableData custom = new SanitizableData(null, sameKey, '123456');
		assertThat(sanitizer.sanitize(custom, true)).isEqualTo('------');
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.convert;
/**
class ConversionServiceParameterValueMapperTests {
	@Test
	void mapParameterShouldDelegateToConversionService() {
		DefaultFormattingConversionService conversionService = spy(new DefaultFormattingConversionService());
		ConversionServiceParameterValueMapper mapper = new ConversionServiceParameterValueMapper(conversionService);
		Object mapped = mapper.mapParameterValue(new TestOperationParameter(Integer.class), '123');
		assertThat(mapped).isEqualTo(123);
		then(conversionService).should().convert('123', Integer.class);
	}
	@Test
	void mapParameterWhenConversionServiceFailsShouldThrowParameterMappingException() {
		ConversionService conversionService = mock(ConversionService.class);
		RuntimeException error = new RuntimeException();
		given(conversionService.convert(any(Object.class), eq(Integer.class))).willThrow(error);
		ConversionServiceParameterValueMapper mapper = new ConversionServiceParameterValueMapper(conversionService);
		assertThatExceptionOfType(ParameterMappingException.class)
			.isThrownBy(() -> mapper.mapParameterValue(new TestOperationParameter(Integer.class), '123'))
			.satisfies((ex) -> {
				assertThat(ex.getValue()).isEqualTo('123');
				assertThat(ex.getParameter().getType()).isEqualTo(Integer.class);
				assertThat(ex.getCause()).isEqualTo(error);
			});
	}
	@Test
	void createShouldRegisterIsoOffsetDateTimeConverter() {
		ConversionServiceParameterValueMapper mapper = new ConversionServiceParameterValueMapper();
		Object mapped = mapper.mapParameterValue(new TestOperationParameter(OffsetDateTime.class),
				'2011-12-03T10:15:30+01:00');
		assertThat(mapped).isNotNull();
	}
	@Test
	void createWithConversionServiceShouldNotRegisterIsoOffsetDateTimeConverter() {
		ConversionService conversionService = new DefaultConversionService();
		ConversionServiceParameterValueMapper mapper = new ConversionServiceParameterValueMapper(conversionService);
		assertThatExceptionOfType(ParameterMappingException.class).isThrownBy(() -> mapper
			.mapParameterValue(new TestOperationParameter(OffsetDateTime.class), '2011-12-03T10:15:30+01:00'));
	}
	static class TestOperationParameter implements OperationParameter {
		private final Class<?> type;
		TestOperationParameter(Class<?> type) {
			this.type = type;
		}
		@Override
		public String getName() {
			return 'test';
		}
		@Override
		public Class<?> getType() {
			return this.type;
		}
		@Override
		public boolean isMandatory() {
			return false;
		}
		@Override
		public <T extends Annotation> T getAnnotation(Class<T> annotation) {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.convert;
/**
class IsoOffsetDateTimeConverterTests {
	@Test
	void convertShouldConvertIsoDate() {
		IsoOffsetDateTimeConverter converter = new IsoOffsetDateTimeConverter();
		OffsetDateTime time = converter.convert('2011-12-03T10:15:30+01:00');
		assertThat(time).isNotNull();
	}
	@Test
	void registerConverterShouldRegister() {
		DefaultConversionService service = new DefaultConversionService();
		IsoOffsetDateTimeConverter.registerConverter(service);
		OffsetDateTime time = service.convert('2011-12-03T10:15:30+01:00', OffsetDateTime.class);
		assertThat(time).isNotNull();
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
class ReflectiveOperationInvokerTests {
	private Example target;
	private OperationMethod operationMethod;
	private ParameterValueMapper parameterValueMapper;
	@BeforeEach
	void setup() {
		this.target = new Example();
		this.operationMethod = new OperationMethod(ReflectionUtils.findMethod(Example.class, 'reverse',
				ApiVersion.class, SecurityContext.class, String.class), OperationType.READ);
		this.parameterValueMapper = (parameter, value) -> (value != null) ? value.toString() : null;
	}
	@Test
	void createWhenTargetIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ReflectiveOperationInvoker(null, this.operationMethod, this.parameterValueMapper))
			.withMessageContaining('Target must not be null');
	}
	@Test
	void createWhenOperationMethodIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ReflectiveOperationInvoker(this.target, null, this.parameterValueMapper))
			.withMessageContaining('OperationMethod must not be null');
	}
	@Test
	void createWhenParameterValueMapperIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ReflectiveOperationInvoker(this.target, this.operationMethod, null))
			.withMessageContaining('ParameterValueMapper must not be null');
	}
	@Test
	void invokeShouldInvokeMethod() {
		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, this.operationMethod,
				this.parameterValueMapper);
		Object result = invoker
			.invoke(new InvocationContext(mock(SecurityContext.class), Collections.singletonMap('name', 'boot')));
		assertThat(result).isEqualTo('toob');
	}
	@Test
	void invokeWhenMissingNonNullableArgumentShouldThrowException() {
		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, this.operationMethod,
				this.parameterValueMapper);
		assertThatExceptionOfType(MissingParametersException.class).isThrownBy(() -> invoker
			.invoke(new InvocationContext(mock(SecurityContext.class), Collections.singletonMap('name', null))));
	}
	@Test
	void invokeWhenMissingNullableArgumentShouldInvoke() {
		OperationMethod operationMethod = new OperationMethod(ReflectionUtils.findMethod(Example.class,
				'reverseNullable', ApiVersion.class, SecurityContext.class, String.class), OperationType.READ);
		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, operationMethod,
				this.parameterValueMapper);
		Object result = invoker
			.invoke(new InvocationContext(mock(SecurityContext.class), Collections.singletonMap('name', null)));
		assertThat(result).isEqualTo('llun');
	}
	@Test
	void invokeShouldResolveParameters() {
		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, this.operationMethod,
				this.parameterValueMapper);
		Object result = invoker
			.invoke(new InvocationContext(mock(SecurityContext.class), Collections.singletonMap('name', 1234)));
		assertThat(result).isEqualTo('4321');
	}
	static class Example {
		String reverse(ApiVersion apiVersion, SecurityContext securityContext, String name) {
			assertThat(apiVersion).isEqualTo(ApiVersion.LATEST);
			assertThat(securityContext).isNotNull();
			return new StringBuilder(name).reverse().toString();
		}
		String reverseNullable(ApiVersion apiVersion, SecurityContext securityContext, @Nullable String name) {
			assertThat(apiVersion).isEqualTo(ApiVersion.LATEST);
			assertThat(securityContext).isNotNull();
			return new StringBuilder(String.valueOf(name)).reverse().toString();
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
class OperationMethodTests {
	private final Method exampleMethod = ReflectionUtils.findMethod(getClass(), 'example', String.class);
	@Test
	void createWhenMethodIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new OperationMethod(null, OperationType.READ))
			.withMessageContaining('Method must not be null');
	}
	@Test
	void createWhenOperationTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new OperationMethod(this.exampleMethod, null))
			.withMessageContaining('OperationType must not be null');
	}
	@Test
	void getMethodShouldReturnMethod() {
		OperationMethod operationMethod = new OperationMethod(this.exampleMethod, OperationType.READ);
		assertThat(operationMethod.getMethod()).isEqualTo(this.exampleMethod);
	}
	@Test
	void getOperationTypeShouldReturnOperationType() {
		OperationMethod operationMethod = new OperationMethod(this.exampleMethod, OperationType.READ);
		assertThat(operationMethod.getOperationType()).isEqualTo(OperationType.READ);
	}
	@Test
	void getParametersShouldReturnParameters() {
		OperationMethod operationMethod = new OperationMethod(this.exampleMethod, OperationType.READ);
		OperationParameters parameters = operationMethod.getParameters();
		assertThat(parameters.getParameterCount()).isOne();
		assertThat(parameters.iterator().next().getName()).isEqualTo('name');
	}
	String example(String name) {
		return name;
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
class OperationMethodParametersTests {
	private final Method exampleMethod = ReflectionUtils.findMethod(getClass(), 'example', String.class);
	private final Method exampleNoParamsMethod = ReflectionUtils.findMethod(getClass(), 'exampleNoParams');
	@Test
	void createWhenMethodIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new OperationMethodParameters(null, mock(ParameterNameDiscoverer.class)))
			.withMessageContaining('Method must not be null');
	}
	@Test
	void createWhenParameterNameDiscovererIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new OperationMethodParameters(this.exampleMethod, null))
			.withMessageContaining('ParameterNameDiscoverer must not be null');
	}
	@Test
	void createWhenParameterNameDiscovererReturnsNullShouldThrowException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new OperationMethodParameters(this.exampleMethod, mock(ParameterNameDiscoverer.class)))
			.withMessageContaining('Failed to extract parameter names');
	}
	@Test
	void hasParametersWhenHasParametersShouldReturnTrue() {
		OperationMethodParameters parameters = new OperationMethodParameters(this.exampleMethod,
				new DefaultParameterNameDiscoverer());
		assertThat(parameters.hasParameters()).isTrue();
	}
	@Test
	void hasParametersWhenHasNoParametersShouldReturnFalse() {
		OperationMethodParameters parameters = new OperationMethodParameters(this.exampleNoParamsMethod,
				new DefaultParameterNameDiscoverer());
		assertThat(parameters.hasParameters()).isFalse();
	}
	@Test
	void getParameterCountShouldReturnParameterCount() {
		OperationMethodParameters parameters = new OperationMethodParameters(this.exampleMethod,
				new DefaultParameterNameDiscoverer());
		assertThat(parameters.getParameterCount()).isOne();
	}
	@Test
	void iteratorShouldIterateOperationParameters() {
		OperationMethodParameters parameters = new OperationMethodParameters(this.exampleMethod,
				new DefaultParameterNameDiscoverer());
		Iterator<OperationParameter> iterator = parameters.iterator();
		assertParameters(
				StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED), false));
	}
	@Test
	void streamShouldStreamOperationParameters() {
		OperationMethodParameters parameters = new OperationMethodParameters(this.exampleMethod,
				new DefaultParameterNameDiscoverer());
		assertParameters(parameters.stream());
	}
	private void assertParameters(Stream<OperationParameter> stream) {
		List<OperationParameter> parameters = stream.toList();
		assertThat(parameters).hasSize(1);
		OperationParameter parameter = parameters.get(0);
		assertThat(parameter.getName()).isEqualTo('name');
		assertThat(parameter.getType()).isEqualTo(String.class);
	}
	String example(String name) {
		return name;
	}
	String exampleNoParams() {
		return 'example';
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
class OperationMethodParameterTests {
	private final Method example = ReflectionUtils.findMethod(getClass(), 'example', String.class, String.class);
	private final Method exampleJsr305 = ReflectionUtils.findMethod(getClass(), 'exampleJsr305', String.class,
			String.class);
	private final Method exampleMetaJsr305 = ReflectionUtils.findMethod(getClass(), 'exampleMetaJsr305', String.class,
			String.class);
	private final Method exampleJsr305NonNull = ReflectionUtils.findMethod(getClass(), 'exampleJsr305NonNull',
			String.class, String.class);
	private Method exampleAnnotation = ReflectionUtils.findMethod(getClass(), 'exampleAnnotation', String.class);
	@Test
	void getNameShouldReturnName() {
		OperationMethodParameter parameter = new OperationMethodParameter('name', this.example.getParameters()[0]);
		assertThat(parameter.getName()).isEqualTo('name');
	}
	@Test
	void getTypeShouldReturnType() {
		OperationMethodParameter parameter = new OperationMethodParameter('name', this.example.getParameters()[0]);
		assertThat(parameter.getType()).isEqualTo(String.class);
	}
	@Test
	void isMandatoryWhenNoAnnotationShouldReturnTrue() {
		OperationMethodParameter parameter = new OperationMethodParameter('name', this.example.getParameters()[0]);
		assertThat(parameter.isMandatory()).isTrue();
	}
	@Test
	void isMandatoryWhenNullableAnnotationShouldReturnFalse() {
		OperationMethodParameter parameter = new OperationMethodParameter('name', this.example.getParameters()[1]);
		assertThat(parameter.isMandatory()).isFalse();
	}
	@Test
	void isMandatoryWhenJsrNullableAnnotationShouldReturnFalse() {
		OperationMethodParameter parameter = new OperationMethodParameter('name',
				this.exampleJsr305.getParameters()[1]);
		assertThat(parameter.isMandatory()).isFalse();
	}
	@Test
	void isMandatoryWhenJsrMetaNullableAnnotationShouldReturnFalse() {
		OperationMethodParameter parameter = new OperationMethodParameter('name',
				this.exampleMetaJsr305.getParameters()[1]);
		assertThat(parameter.isMandatory()).isFalse();
	}
	@Test
	void isMandatoryWhenJsrNonnullAnnotationShouldReturnTrue() {
		OperationMethodParameter parameter = new OperationMethodParameter('name',
				this.exampleJsr305NonNull.getParameters()[1]);
		assertThat(parameter.isMandatory()).isTrue();
	}
	@Test
	void getAnnotationShouldReturnAnnotation() {
		OperationMethodParameter parameter = new OperationMethodParameter('name',
				this.exampleAnnotation.getParameters()[0]);
		Selector annotation = parameter.getAnnotation(Selector.class);
		assertThat(annotation).isNotNull();
		assertThat(annotation.match()).isEqualTo(Match.ALL_REMAINING);
	}
	void example(String one, @Nullable String two) {
	}
	void exampleJsr305(String one, @javax.annotation.Nullable String two) {
	}
	void exampleMetaJsr305(String one, @MetaNullable String two) {
	}
	void exampleJsr305NonNull(String one, @javax.annotation.Nonnull String two) {
	}
	void exampleAnnotation(@Selector(match = Match.ALL_REMAINING) String allRemaining) {
	}
	@TypeQualifier
	@Retention(RetentionPolicy.RUNTIME)
	@Nonnull(when = When.MAYBE)
	@interface MetaNullable {
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class OperationFilterTests {
	private final EndpointAccessResolver accessResolver = mock(EndpointAccessResolver.class);
	private final Operation operation = mock(Operation.class);
	private final OperationFilter<Operation> filter = OperationFilter.byAccess(this.accessResolver);
	@Test
	void whenAccessIsUnrestrictedThenMatchReturnsTrue() {
		EndpointId endpointId = EndpointId.of('test');
		Access defaultAccess = Access.READ_ONLY;
		given(this.accessResolver.accessFor(endpointId, defaultAccess)).willReturn(Access.UNRESTRICTED);
		assertThat(this.filter.match(this.operation, endpointId, defaultAccess)).isTrue();
	}
	@Test
	void whenAccessIsNoneThenMatchReturnsFalse() {
		EndpointId endpointId = EndpointId.of('test');
		Access defaultAccess = Access.READ_ONLY;
		given(this.accessResolver.accessFor(endpointId, defaultAccess)).willReturn(Access.NONE);
		assertThat(this.filter.match(this.operation, endpointId, defaultAccess)).isFalse();
	}
	@Test
	void whenAccessIsReadOnlyAndOperationTypeIsReadThenMatchReturnsTrue() {
		EndpointId endpointId = EndpointId.of('test');
		Access defaultAccess = Access.READ_ONLY;
		given(this.accessResolver.accessFor(endpointId, defaultAccess)).willReturn(Access.READ_ONLY);
		given(this.operation.getType()).willReturn(OperationType.READ);
		assertThat(this.filter.match(this.operation, endpointId, defaultAccess)).isTrue();
	}
	@Test
	void whenAccessIsReadOnlyAndOperationTypeIsWriteThenMatchReturnsFalse() {
		EndpointId endpointId = EndpointId.of('test');
		Access defaultAccess = Access.READ_ONLY;
		given(this.accessResolver.accessFor(endpointId, defaultAccess)).willReturn(Access.READ_ONLY);
		given(this.operation.getType()).willReturn(OperationType.WRITE);
		assertThat(this.filter.match(this.operation, endpointId, defaultAccess)).isFalse();
	}
	@Test
	void whenAccessIsReadOnlyAndOperationTypeIsDeleteThenMatchReturnsFalse() {
		EndpointId endpointId = EndpointId.of('test');
		Access defaultAccess = Access.READ_ONLY;
		given(this.accessResolver.accessFor(endpointId, defaultAccess)).willReturn(Access.READ_ONLY);
		given(this.operation.getType()).willReturn(OperationType.DELETE);
		assertThat(this.filter.match(this.operation, endpointId, defaultAccess)).isFalse();
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
@ExtendWith(OutputCaptureExtension.class)
class EndpointIdTests {
	@Test
	void ofWhenNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EndpointId.of(null))
			.withMessage('Value must not be empty');
	}
	@Test
	void ofWhenEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EndpointId.of('')).withMessage('Value must not be empty');
	}
	@Test
	void ofWhenContainsSlashThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EndpointId.of('foo/bar'))
			.withMessage('Value must only contain valid chars');
	}
	@Test
	void ofWhenContainsBackslashThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EndpointId.of('foo\\bar'))
			.withMessage('Value must only contain valid chars');
	}
	@Test
	void ofWhenHasBadCharThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EndpointId.of('foo!bar'))
			.withMessage('Value must only contain valid chars');
	}
	@Test
	void ofWhenStartsWithNumberThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EndpointId.of('1foo'))
			.withMessage('Value must not start with a number');
	}
	@Test
	void ofWhenStartsWithUppercaseLetterThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EndpointId.of('Foo'))
			.withMessage('Value must not start with an uppercase letter');
	}
	@Test
	void ofWhenContainsDotIsValid() {
		// Ideally we wouldn"t support this but there are existing endpoints using the
		// pattern. See gh-14773
		EndpointId endpointId = EndpointId.of('foo.bar');
		assertThat(endpointId).hasToString('foo.bar');
	}
	@Test
	void ofWhenContainsDashIsValid() {
		// Ideally we wouldn"t support this but there are existing endpoints using the
		// pattern. See gh-14773
		EndpointId endpointId = EndpointId.of('foo-bar');
		assertThat(endpointId).hasToString('foo-bar');
	}
	@Test
	void ofWhenContainsDeprecatedCharsLogsWarning(CapturedOutput output) {
		EndpointId.resetLoggedWarnings();
		EndpointId.of('foo-bar');
		assertThat(output)
			.contains('Endpoint ID "foo-bar" contains invalid characters, please migrate to a valid format');
	}
	@Test
	void ofWhenMigratingLegacyNameRemovesDots(CapturedOutput output) {
		EndpointId endpointId = migrateLegacyName('one.two.three');
		assertThat(endpointId).hasToString('onetwothree');
		assertThat(output).doesNotContain('contains invalid characters');
	}
	@Test
	void ofWhenMigratingLegacyNameRemovesHyphens(CapturedOutput output) {
		EndpointId endpointId = migrateLegacyName('one-two-three');
		assertThat(endpointId).hasToString('onetwothree');
		assertThat(output).doesNotContain('contains invalid characters');
	}
	@Test
	void ofWhenMigratingLegacyNameRemovesMixOfDashAndDot(CapturedOutput output) {
		EndpointId endpointId = migrateLegacyName('one.two-three');
		assertThat(endpointId).hasToString('onetwothree');
		assertThat(output).doesNotContain('contains invalid characters');
	}
	private EndpointId migrateLegacyName(String name) {
		EndpointId.resetLoggedWarnings();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('management.endpoints.migrate-legacy-ids', 'true');
		return EndpointId.of(environment, name);
	}
	@Test
	void equalsAndHashCode() {
		EndpointId one = EndpointId.of('foobar1');
		EndpointId two = EndpointId.of('fooBar1');
		EndpointId three = EndpointId.of('foo-bar1');
		EndpointId four = EndpointId.of('foo.bar1');
		EndpointId five = EndpointId.of('barfoo1');
		EndpointId six = EndpointId.of('foobar2');
		assertThat(one).hasSameHashCodeAs(two);
		assertThat(one).isEqualTo(one)
			.isEqualTo(two)
			.isEqualTo(three)
			.isEqualTo(four)
			.isNotEqualTo(five)
			.isNotEqualTo(six);
	}
	@Test
	void toLowerCaseStringReturnsLowercase() {
		assertThat(EndpointId.of('fooBar').toLowerCaseString()).isEqualTo('foobar');
	}
	@Test
	void toStringReturnsString() {
		assertThat(EndpointId.of('fooBar')).hasToString('fooBar');
	}
	@Test
	void fromPropertyValueStripsDashes() {
		EndpointId fromPropertyValue = EndpointId.fromPropertyValue('foo-bar');
		assertThat(fromPropertyValue).isEqualTo(EndpointId.of('fooBar'));
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
class OperationResponseBodyTests {
	@Test
	void ofMapReturnsOperationResponseBody() {
		LinkedHashMap<String, String> map = new LinkedHashMap<>();
		map.put('one', '1');
		map.put('two', '2');
		Map<String, String> mapDescriptor = OperationResponseBody.of(map);
		assertThat(mapDescriptor).containsExactly(entry('one', '1'), entry('two', '2'));
		assertThat(mapDescriptor).isInstanceOf(OperationResponseBody.class);
	}
}
/*
package org.springframework.boot.actuate.elasticsearch;
/**
class ElasticsearchReactiveHealthIndicatorTests {
	private static final Duration TIMEOUT = Duration.ofSeconds(5);
	private MockWebServer server;
	private ElasticsearchReactiveHealthIndicator healthIndicator;
	@BeforeEach
	void setup() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		ReactiveElasticsearchClient client = new ReactiveElasticsearchClient(new RestClientTransport(
				RestClient.builder(HttpHost.create(this.server.getHostName() + ':' + this.server.getPort())).build(),
				new JacksonJsonpMapper()));
		this.healthIndicator = new ElasticsearchReactiveHealthIndicator(client);
	}
	@AfterEach
	void shutdown() throws Exception {
		this.server.shutdown();
	}
	@Test
	void elasticsearchIsUp() {
		setupMockResponse(200, 'green');
		Health health = this.healthIndicator.health().block(TIMEOUT);
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertHealthDetailsWithStatus(health.getDetails(), 'green');
	}
	@Test
	void elasticsearchWithYellowStatusIsUp() {
		setupMockResponse(200, 'yellow');
		Health health = this.healthIndicator.health().block(TIMEOUT);
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertHealthDetailsWithStatus(health.getDetails(), 'yellow');
	}
	@Test
	void elasticsearchIsDown() throws Exception {
		this.server.shutdown();
		Health health = this.healthIndicator.health().block(TIMEOUT);
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails().get('error')).asString().contains('Connection refused');
	}
	@Test
	void elasticsearchIsDownByResponseCode() {
		this.server.enqueue(new MockResponse().setResponseCode(HttpStatus.INTERNAL_SERVER_ERROR.value()));
		Health health = this.healthIndicator.health().block(TIMEOUT);
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails().get('error')).asString().startsWith(ResponseException.class.getName());
	}
	@Test
	void elasticsearchIsOutOfServiceByStatus() {
		setupMockResponse(200, 'red');
		Health health = this.healthIndicator.health().block(TIMEOUT);
		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
		assertHealthDetailsWithStatus(health.getDetails(), 'red');
	}
	private void assertHealthDetailsWithStatus(Map<String, Object> details, String status) {
		assertThat(details).contains(entry('cluster_name', 'elasticsearch'), entry('status', status),
				entry('timed_out', false), entry('number_of_nodes', 1), entry('number_of_data_nodes', 1),
				entry('active_primary_shards', 0), entry('active_shards', 0), entry('relocating_shards', 0),
				entry('initializing_shards', 0), entry('unassigned_shards', 0), entry('delayed_unassigned_shards', 0),
				entry('number_of_pending_tasks', 0), entry('number_of_in_flight_fetch', 0),
				entry('task_max_waiting_in_queue_millis', 0L), entry('active_shards_percent_as_number', 100.0));
	}
	private void setupMockResponse(int responseCode, String status) {
		MockResponse mockResponse = new MockResponse().setBody(createJsonResult(status))
			.setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
			.setHeader('X-Elastic-Product', 'Elasticsearch');
		this.server.enqueue(mockResponse);
	}
	private String createJsonResult(String status) {
		return String.format(
				'{\'cluster_name\':\'elasticsearch\',' + '\'status\':\'%s\',\'timed_out\':false,\'number_of_nodes\':1,'
						+ '\'number_of_data_nodes\':1,\'active_primary_shards\':0,'
						+ '\'active_shards\':0,\'relocating_shards\':0,\'initializing_shards\':0,'
						+ '\'unassigned_shards\':0,\'delayed_unassigned_shards\':0,'
						+ '\'number_of_pending_tasks\':0,\'number_of_in_flight_fetch\':0,'
						+ '\'task_max_waiting_in_queue_millis\':0,\'active_shards_percent_as_number\':100.0}',
				status);
	}
}
/*
package org.springframework.boot.actuate.elasticsearch;
/**
class ElasticsearchRestClientHealthIndicatorTests {
	private final RestClient restClient = mock(RestClient.class);
	private final ElasticsearchRestClientHealthIndicator elasticsearchRestClientHealthIndicator = new ElasticsearchRestClientHealthIndicator(
			this.restClient);
	@Test
	void elasticsearchIsUp() throws IOException {
		BasicHttpEntity httpEntity = new BasicHttpEntity();
		httpEntity.setContent(new ByteArrayInputStream(createJsonResult(200, 'green').getBytes()));
		Response response = mock(Response.class);
		StatusLine statusLine = mock(StatusLine.class);
		given(statusLine.getStatusCode()).willReturn(200);
		given(response.getStatusLine()).willReturn(statusLine);
		given(response.getEntity()).willReturn(httpEntity);
		given(this.restClient.performRequest(any(Request.class))).willReturn(response);
		Health health = this.elasticsearchRestClientHealthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertHealthDetailsWithStatus(health.getDetails(), 'green');
	}
	@Test
	void elasticsearchWithYellowStatusIsUp() throws IOException {
		BasicHttpEntity httpEntity = new BasicHttpEntity();
		httpEntity.setContent(new ByteArrayInputStream(createJsonResult(200, 'yellow').getBytes()));
		Response response = mock(Response.class);
		StatusLine statusLine = mock(StatusLine.class);
		given(statusLine.getStatusCode()).willReturn(200);
		given(response.getStatusLine()).willReturn(statusLine);
		given(response.getEntity()).willReturn(httpEntity);
		given(this.restClient.performRequest(any(Request.class))).willReturn(response);
		Health health = this.elasticsearchRestClientHealthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertHealthDetailsWithStatus(health.getDetails(), 'yellow');
	}
	@Test
	void elasticsearchIsDown() throws IOException {
		given(this.restClient.performRequest(any(Request.class))).willThrow(new IOException('Couldn"t connect'));
		Health health = this.elasticsearchRestClientHealthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).contains(entry('error', 'java.io.IOException: Couldn"t connect'));
	}
	@Test
	void elasticsearchIsDownByResponseCode() throws IOException {
		Response response = mock(Response.class);
		StatusLine statusLine = mock(StatusLine.class);
		given(statusLine.getStatusCode()).willReturn(500);
		given(statusLine.getReasonPhrase()).willReturn('Internal server error');
		given(response.getStatusLine()).willReturn(statusLine);
		given(this.restClient.performRequest(any(Request.class))).willReturn(response);
		Health health = this.elasticsearchRestClientHealthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).contains(entry('statusCode', 500),
				entry('reasonPhrase', 'Internal server error'));
	}
	@Test
	void elasticsearchIsOutOfServiceByStatus() throws IOException {
		BasicHttpEntity httpEntity = new BasicHttpEntity();
		httpEntity.setContent(new ByteArrayInputStream(createJsonResult(200, 'red').getBytes()));
		Response response = mock(Response.class);
		StatusLine statusLine = mock(StatusLine.class);
		given(statusLine.getStatusCode()).willReturn(200);
		given(response.getStatusLine()).willReturn(statusLine);
		given(response.getEntity()).willReturn(httpEntity);
		given(this.restClient.performRequest(any(Request.class))).willReturn(response);
		Health health = this.elasticsearchRestClientHealthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
		assertHealthDetailsWithStatus(health.getDetails(), 'red');
	}
	private void assertHealthDetailsWithStatus(Map<String, Object> details, String status) {
		assertThat(details).contains(entry('cluster_name', 'elasticsearch'), entry('status', status),
				entry('timed_out', false), entry('number_of_nodes', 1), entry('number_of_data_nodes', 1),
				entry('active_primary_shards', 0), entry('active_shards', 0), entry('relocating_shards', 0),
				entry('initializing_shards', 0), entry('unassigned_shards', 0), entry('delayed_unassigned_shards', 0),
				entry('number_of_pending_tasks', 0), entry('number_of_in_flight_fetch', 0),
				entry('task_max_waiting_in_queue_millis', 0), entry('active_shards_percent_as_number', 100.0));
	}
	private String createJsonResult(int responseCode, String status) {
		if (responseCode == 200) {
			return String.format(
					'{\'cluster_name\':\'elasticsearch\','
							+ '\'status\':\'%s\',\'timed_out\':false,\'number_of_nodes\':1,'
							+ '\'number_of_data_nodes\':1,\'active_primary_shards\':0,'
							+ '\'active_shards\':0,\'relocating_shards\':0,\'initializing_shards\':0,'
							+ '\'unassigned_shards\':0,\'delayed_unassigned_shards\':0,'
							+ '\'number_of_pending_tasks\':0,\'number_of_in_flight_fetch\':0,'
							+ '\'task_max_waiting_in_queue_millis\':0,\'active_shards_percent_as_number\':100.0}',
					status);
		}
		return '{\n  \'error\': \'Server Error\',\n  \'status\': ' + responseCode + '\n}';
	}
}
/*
package org.springframework.boot.actuate.redis;
/**
class RedisHealthIndicatorTests {
	@Test
	void redisIsUp() {
		Properties info = new Properties();
		info.put('redis_version', '2.8.9');
		RedisConnection redisConnection = mock(RedisConnection.class);
		RedisServerCommands serverCommands = mock(RedisServerCommands.class);
		given(redisConnection.serverCommands()).willReturn(serverCommands);
		given(serverCommands.info()).willReturn(info);
		RedisHealthIndicator healthIndicator = createHealthIndicator(redisConnection);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('version', '2.8.9');
	}
	@Test
	void redisIsDown() {
		RedisConnection redisConnection = mock(RedisConnection.class);
		RedisServerCommands serverCommands = mock(RedisServerCommands.class);
		given(redisConnection.serverCommands()).willReturn(serverCommands);
		given(serverCommands.info()).willThrow(new RedisConnectionFailureException('Connection failed'));
		RedisHealthIndicator healthIndicator = createHealthIndicator(redisConnection);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat((String) health.getDetails().get('error')).contains('Connection failed');
	}
	@Test
	void healthWhenClusterStateIsAbsentShouldBeUp() {
		RedisConnectionFactory redisConnectionFactory = createClusterConnectionFactory(null);
		RedisHealthIndicator healthIndicator = new RedisHealthIndicator(redisConnectionFactory);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('cluster_size', 4L);
		assertThat(health.getDetails()).containsEntry('slots_up', 4L);
		assertThat(health.getDetails()).containsEntry('slots_fail', 0L);
		then(redisConnectionFactory).should(atLeastOnce()).getConnection();
	}
	@Test
	void healthWhenClusterStateIsOkShouldBeUp() {
		RedisConnectionFactory redisConnectionFactory = createClusterConnectionFactory('ok');
		RedisHealthIndicator healthIndicator = new RedisHealthIndicator(redisConnectionFactory);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('cluster_size', 4L);
		assertThat(health.getDetails()).containsEntry('slots_up', 4L);
		assertThat(health.getDetails()).containsEntry('slots_fail', 0L);
		then(redisConnectionFactory).should(atLeastOnce()).getConnection();
	}
	@Test
	void healthWhenClusterStateIsFailShouldBeDown() {
		RedisConnectionFactory redisConnectionFactory = createClusterConnectionFactory('fail');
		RedisHealthIndicator healthIndicator = new RedisHealthIndicator(redisConnectionFactory);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsEntry('cluster_size', 4L);
		assertThat(health.getDetails()).containsEntry('slots_up', 3L);
		assertThat(health.getDetails()).containsEntry('slots_fail', 1L);
		then(redisConnectionFactory).should(atLeastOnce()).getConnection();
	}
	private RedisHealthIndicator createHealthIndicator(RedisConnection redisConnection) {
		RedisConnectionFactory redisConnectionFactory = mock(RedisConnectionFactory.class);
		given(redisConnectionFactory.getConnection()).willReturn(redisConnection);
		return new RedisHealthIndicator(redisConnectionFactory);
	}
	private RedisConnectionFactory createClusterConnectionFactory(String state) {
		Properties clusterProperties = new Properties();
		if (state != null) {
			clusterProperties.setProperty('cluster_state', state);
		}
		clusterProperties.setProperty('cluster_size', '4');
		boolean failure = 'fail'.equals(state);
		clusterProperties.setProperty('cluster_slots_ok', failure ? '3' : '4');
		clusterProperties.setProperty('cluster_slots_fail', failure ? '1' : '0');
		List<RedisClusterNode> redisMasterNodes = Arrays.asList(new RedisClusterNode('127.0.0.1', 7001),
				new RedisClusterNode('127.0.0.2', 7001));
		RedisClusterConnection redisConnection = mock(RedisClusterConnection.class);
		given(redisConnection.clusterGetNodes()).willReturn(redisMasterNodes);
		given(redisConnection.clusterGetClusterInfo()).willReturn(new ClusterInfo(clusterProperties));
		RedisConnectionFactory redisConnectionFactory = mock(RedisConnectionFactory.class);
		given(redisConnectionFactory.getConnection()).willReturn(redisConnection);
		return redisConnectionFactory;
	}
}
/*
package org.springframework.boot.actuate.redis;
/**
class RedisReactiveHealthIndicatorTests {
	@Test
	void redisIsUp() {
		Properties info = new Properties();
		info.put('redis_version', '2.8.9');
		ReactiveRedisConnection redisConnection = mock(ReactiveRedisConnection.class);
		given(redisConnection.closeLater()).willReturn(Mono.empty());
		ReactiveServerCommands commands = mock(ReactiveServerCommands.class);
		given(commands.info('server')).willReturn(Mono.just(info));
		RedisReactiveHealthIndicator healthIndicator = createHealthIndicator(redisConnection, commands);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.UP);
			assertThat(h.getDetails()).containsOnlyKeys('version');
			assertThat(h.getDetails()).containsEntry('version', '2.8.9');
		}).expectComplete().verify(Duration.ofSeconds(30));
		then(redisConnection).should().closeLater();
	}
	@Test
	void healthWhenClusterStateIsAbsentShouldBeUp() {
		ReactiveRedisConnectionFactory redisConnectionFactory = createClusterConnectionFactory(null);
		RedisReactiveHealthIndicator healthIndicator = new RedisReactiveHealthIndicator(redisConnectionFactory);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.UP);
			assertThat(h.getDetails()).containsEntry('cluster_size', 4L);
			assertThat(h.getDetails()).containsEntry('slots_up', 4L);
			assertThat(h.getDetails()).containsEntry('slots_fail', 0L);
		}).expectComplete().verify(Duration.ofSeconds(30));
		then(redisConnectionFactory.getReactiveConnection()).should().closeLater();
	}
	@Test
	void healthWhenClusterStateIsOkShouldBeUp() {
		ReactiveRedisConnectionFactory redisConnectionFactory = createClusterConnectionFactory('ok');
		RedisReactiveHealthIndicator healthIndicator = new RedisReactiveHealthIndicator(redisConnectionFactory);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.UP);
			assertThat(h.getDetails()).containsEntry('cluster_size', 4L);
			assertThat(h.getDetails()).containsEntry('slots_up', 4L);
			assertThat(h.getDetails()).containsEntry('slots_fail', 0L);
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void healthWhenClusterStateIsFailShouldBeDown() {
		ReactiveRedisConnectionFactory redisConnectionFactory = createClusterConnectionFactory('fail');
		RedisReactiveHealthIndicator healthIndicator = new RedisReactiveHealthIndicator(redisConnectionFactory);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.DOWN);
			assertThat(h.getDetails()).containsEntry('slots_up', 3L);
			assertThat(h.getDetails()).containsEntry('slots_fail', 1L);
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void redisCommandIsDown() {
		ReactiveServerCommands commands = mock(ReactiveServerCommands.class);
		given(commands.info('server')).willReturn(Mono.error(new RedisConnectionFailureException('Connection failed')));
		ReactiveRedisConnection redisConnection = mock(ReactiveRedisConnection.class);
		given(redisConnection.closeLater()).willReturn(Mono.empty());
		RedisReactiveHealthIndicator healthIndicator = createHealthIndicator(redisConnection, commands);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.DOWN))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		then(redisConnection).should().closeLater();
	}
	@Test
	void redisConnectionIsDown() {
		ReactiveRedisConnectionFactory redisConnectionFactory = mock(ReactiveRedisConnectionFactory.class);
		given(redisConnectionFactory.getReactiveConnection())
			.willThrow(new RedisConnectionException('Unable to connect to localhost:6379'));
		RedisReactiveHealthIndicator healthIndicator = new RedisReactiveHealthIndicator(redisConnectionFactory);
		Mono<Health> health = healthIndicator.health();
		StepVerifier.create(health)
			.consumeNextWith((h) -> assertThat(h.getStatus()).isEqualTo(Status.DOWN))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	private RedisReactiveHealthIndicator createHealthIndicator(ReactiveRedisConnection redisConnection,
			ReactiveServerCommands serverCommands) {
		ReactiveRedisConnectionFactory redisConnectionFactory = mock(ReactiveRedisConnectionFactory.class);
		given(redisConnectionFactory.getReactiveConnection()).willReturn(redisConnection);
		given(redisConnection.serverCommands()).willReturn(serverCommands);
		return new RedisReactiveHealthIndicator(redisConnectionFactory);
	}
	private ReactiveRedisConnectionFactory createClusterConnectionFactory(String state) {
		Properties clusterProperties = new Properties();
		if (state != null) {
			clusterProperties.setProperty('cluster_state', state);
		}
		clusterProperties.setProperty('cluster_size', '4');
		boolean failure = 'fail'.equals(state);
		clusterProperties.setProperty('cluster_slots_ok', failure ? '3' : '4');
		clusterProperties.setProperty('cluster_slots_fail', failure ? '1' : '0');
		ReactiveRedisClusterConnection redisConnection = mock(ReactiveRedisClusterConnection.class);
		given(redisConnection.closeLater()).willReturn(Mono.empty());
		given(redisConnection.clusterGetClusterInfo()).willReturn(Mono.just(new ClusterInfo(clusterProperties)));
		ReactiveRedisConnectionFactory redisConnectionFactory = mock(ReactiveRedisConnectionFactory.class);
		given(redisConnectionFactory.getReactiveConnection()).willReturn(redisConnection);
		return redisConnectionFactory;
	}
}
/*
package org.springframework.boot.actuate.startup;
/**
class StartupEndpointTests {
	@Test
	void startupEventsAreFound() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(256);
		testStartupEndpoint(applicationStartup, (startupEndpoint) -> {
			StartupDescriptor startup = startupEndpoint.startup();
			assertThat(startup.getSpringBootVersion()).isEqualTo(SpringBootVersion.getVersion());
			assertThat(startup.getTimeline().getStartTime())
				.isEqualTo(applicationStartup.getBufferedTimeline().getStartTime());
		});
	}
	@Test
	void bufferWithGetIsNotDrained() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(256);
		testStartupEndpoint(applicationStartup, (startupEndpoint) -> {
			StartupDescriptor startup = startupEndpoint.startupSnapshot();
			assertThat(startup.getTimeline().getEvents()).isNotEmpty();
			assertThat(applicationStartup.getBufferedTimeline().getEvents()).isNotEmpty();
		});
	}
	@Test
	void bufferWithPostIsDrained() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(256);
		testStartupEndpoint(applicationStartup, (startupEndpoint) -> {
			StartupDescriptor startup = startupEndpoint.startup();
			assertThat(startup.getTimeline().getEvents()).isNotEmpty();
			assertThat(applicationStartup.getBufferedTimeline().getEvents()).isEmpty();
		});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new StartupEndpointRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		Set<TypeReference> bindingTypes = Set.of(
				TypeReference.of('org.springframework.boot.context.metrics.buffering.BufferedStartupStep$DefaultTag'),
				TypeReference.of('org.springframework.core.metrics.jfr.FlightRecorderStartupStep$FlightRecorderTag'));
		for (TypeReference bindingType : bindingTypes) {
			assertThat(RuntimeHintsPredicates.reflection()
				.onType(bindingType)
				.withMemberCategories(MemberCategory.INVOKE_PUBLIC_METHODS)).accepts(runtimeHints);
		}
	}
	private void testStartupEndpoint(ApplicationStartup applicationStartup, Consumer<StartupEndpoint> startupEndpoint) {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withInitializer((context) -> context.setApplicationStartup(applicationStartup))
			.withUserConfiguration(EndpointConfiguration.class);
		contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(StartupEndpoint.class);
			startupEndpoint.accept(context.getBean(StartupEndpoint.class));
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointConfiguration {
		@Bean
		StartupEndpoint endpoint(BufferingApplicationStartup applicationStartup) {
			return new StartupEndpoint(applicationStartup);
		}
	}
}
/*
package org.springframework.boot.actuate.r2dbc;
/**
class ConnectionFactoryHealthIndicatorTests {
	@Test
	void healthIndicatorWhenDatabaseUpWithConnectionValidation() {
		CloseableConnectionFactory connectionFactory = createTestDatabase();
		try {
			ConnectionFactoryHealthIndicator healthIndicator = new ConnectionFactoryHealthIndicator(connectionFactory);
			healthIndicator.health().as(StepVerifier::create).assertNext((actual) -> {
				assertThat(actual.getStatus()).isEqualTo(Status.UP);
				assertThat(actual.getDetails()).containsOnly(entry('database', 'H2'),
						entry('validationQuery', 'validate(REMOTE)'));
			}).expectComplete().verify(Duration.ofSeconds(30));
		}
		finally {
			StepVerifier.create(connectionFactory.close()).expectComplete().verify(Duration.ofSeconds(30));
		}
	}
	@Test
	void healthIndicatorWhenDatabaseDownWithConnectionValidation() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		given(connectionFactory.getMetadata()).willReturn(() -> 'mock');
		RuntimeException exception = new RuntimeException('test');
		given(connectionFactory.create()).willReturn(Mono.error(exception));
		ConnectionFactoryHealthIndicator healthIndicator = new ConnectionFactoryHealthIndicator(connectionFactory);
		healthIndicator.health().as(StepVerifier::create).assertNext((actual) -> {
			assertThat(actual.getStatus()).isEqualTo(Status.DOWN);
			assertThat(actual.getDetails()).containsOnly(entry('database', 'mock'),
					entry('validationQuery', 'validate(REMOTE)'), entry('error', 'java.lang.RuntimeException: test'));
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void healthIndicatorWhenConnectionValidationFails() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		given(connectionFactory.getMetadata()).willReturn(() -> 'mock');
		Connection connection = mock(Connection.class);
		given(connection.validate(ValidationDepth.REMOTE)).willReturn(Mono.just(false));
		given(connection.close()).willReturn(Mono.empty());
		given(connectionFactory.create()).willAnswer((invocation) -> Mono.just(connection));
		ConnectionFactoryHealthIndicator healthIndicator = new ConnectionFactoryHealthIndicator(connectionFactory);
		healthIndicator.health().as(StepVerifier::create).assertNext((actual) -> {
			assertThat(actual.getStatus()).isEqualTo(Status.DOWN);
			assertThat(actual.getDetails()).containsOnly(entry('database', 'mock'),
					entry('validationQuery', 'validate(REMOTE)'));
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void healthIndicatorWhenDatabaseUpWithSuccessValidationQuery() {
		CloseableConnectionFactory connectionFactory = createTestDatabase();
		try {
			String customValidationQuery = 'SELECT COUNT(*) from HEALTH_TEST';
			String createTableStatement = 'CREATE TABLE HEALTH_TEST (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY)';
			Mono.from(connectionFactory.create())
				.flatMapMany((it) -> Flux.from(it.createStatement(createTableStatement).execute())
					.flatMap(Result::getRowsUpdated)
					.thenMany(it.close()))
				.as(StepVerifier::create)
				.expectComplete()
				.verify(Duration.ofSeconds(30));
			ReactiveHealthIndicator healthIndicator = new ConnectionFactoryHealthIndicator(connectionFactory,
					customValidationQuery);
			healthIndicator.health().as(StepVerifier::create).assertNext((actual) -> {
				assertThat(actual.getStatus()).isEqualTo(Status.UP);
				assertThat(actual.getDetails()).containsOnly(entry('database', 'H2'), entry('result', 0L),
						entry('validationQuery', customValidationQuery));
			}).expectComplete().verify(Duration.ofSeconds(30));
		}
		finally {
			StepVerifier.create(connectionFactory.close()).expectComplete().verify(Duration.ofSeconds(30));
		}
	}
	@Test
	void healthIndicatorWhenDatabaseUpWithFailureValidationQuery() {
		CloseableConnectionFactory connectionFactory = createTestDatabase();
		try {
			String invalidValidationQuery = 'SELECT COUNT(*) from DOES_NOT_EXIST';
			ReactiveHealthIndicator healthIndicator = new ConnectionFactoryHealthIndicator(connectionFactory,
					invalidValidationQuery);
			healthIndicator.health().as(StepVerifier::create).assertNext((actual) -> {
				assertThat(actual.getStatus()).isEqualTo(Status.DOWN);
				assertThat(actual.getDetails()).contains(entry('database', 'H2'),
						entry('validationQuery', invalidValidationQuery));
				assertThat(actual.getDetails()).containsOnlyKeys('database', 'error', 'validationQuery');
			}).expectComplete().verify(Duration.ofSeconds(30));
		}
		finally {
			StepVerifier.create(connectionFactory.close()).expectComplete().verify(Duration.ofSeconds(30));
		}
	}
	private CloseableConnectionFactory createTestDatabase() {
		return H2ConnectionFactory.inMemory('db-' + UUID.randomUUID(), 'sa', '',
				Collections.singletonMap(H2ConnectionOption.DB_CLOSE_DELAY, '-1'));
	}
}
/*
package org.springframework.boot.actuate.liquibase;
/**
class LiquibaseEndpointTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class, LiquibaseAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void liquibaseReportIsReturned() {
		this.contextRunner.withUserConfiguration(Config.class).run((context) -> {
			Map<String, LiquibaseBeanDescriptor> liquibaseBeans = context.getBean(LiquibaseEndpoint.class)
				.liquibaseBeans()
				.getContexts()
				.get(context.getId())
				.getLiquibaseBeans();
			assertThat(liquibaseBeans.get('liquibase').getChangeSets()).hasSize(1);
		});
	}
	@Test
	void liquibaseReportIsReturnedForContextHierarchy() {
		this.contextRunner.withUserConfiguration().run((parent) -> {
			this.contextRunner.withUserConfiguration(Config.class).withParent(parent).run((context) -> {
				Map<String, LiquibaseBeanDescriptor> liquibaseBeans = context.getBean(LiquibaseEndpoint.class)
					.liquibaseBeans()
					.getContexts()
					.get(parent.getId())
					.getLiquibaseBeans();
				assertThat(liquibaseBeans.get('liquibase').getChangeSets()).hasSize(1);
			});
		});
	}
	@Test
	void invokeWithCustomSchema() {
		this.contextRunner.withUserConfiguration(Config.class, DataSourceWithSchemaConfiguration.class)
			.withPropertyValues('spring.liquibase.default-schema=CUSTOMSCHEMA')
			.run((context) -> {
				Map<String, LiquibaseBeanDescriptor> liquibaseBeans = context.getBean(LiquibaseEndpoint.class)
					.liquibaseBeans()
					.getContexts()
					.get(context.getId())
					.getLiquibaseBeans();
				assertThat(liquibaseBeans.get('liquibase').getChangeSets()).hasSize(1);
			});
	}
	@Test
	void invokeWithCustomTables() {
		this.contextRunner.withUserConfiguration(Config.class)
			.withPropertyValues('spring.liquibase.database-change-log-lock-table=liquibase_database_changelog_lock',
					'spring.liquibase.database-change-log-table=liquibase_database_changelog')
			.run((context) -> {
				Map<String, LiquibaseBeanDescriptor> liquibaseBeans = context.getBean(LiquibaseEndpoint.class)
					.liquibaseBeans()
					.getContexts()
					.get(context.getId())
					.getLiquibaseBeans();
				assertThat(liquibaseBeans.get('liquibase').getChangeSets()).hasSize(1);
			});
	}
	@Test
	void connectionAutoCommitPropertyIsReset() {
		this.contextRunner.withUserConfiguration(Config.class).run((context) -> {
			DataSource dataSource = context.getBean(DataSource.class);
			assertThat(getAutoCommit(dataSource)).isTrue();
			context.getBean(LiquibaseEndpoint.class).liquibaseBeans();
			assertThat(getAutoCommit(dataSource)).isTrue();
		});
	}
	@Test
	void whenMultipleLiquibaseBeansArePresentChangeSetsAreCorrectlyReportedForEachBean() {
		this.contextRunner.withUserConfiguration(Config.class, MultipleDataSourceLiquibaseConfiguration.class)
			.run((context) -> {
				Map<String, LiquibaseBeanDescriptor> liquibaseBeans = context.getBean(LiquibaseEndpoint.class)
					.liquibaseBeans()
					.getContexts()
					.get(context.getId())
					.getLiquibaseBeans();
				assertThat(liquibaseBeans.get('liquibase').getChangeSets()).hasSize(1);
				assertThat(liquibaseBeans.get('liquibase').getChangeSets().get(0).getChangeLog())
					.isEqualTo('db/changelog/db.changelog-master.yaml');
				assertThat(liquibaseBeans.get('liquibaseBackup').getChangeSets()).hasSize(1);
				assertThat(liquibaseBeans.get('liquibaseBackup').getChangeSets().get(0).getChangeLog())
					.isEqualTo('db/changelog/db.changelog-master-backup.yaml');
			});
	}
	private boolean getAutoCommit(DataSource dataSource) throws SQLException {
		try (Connection connection = dataSource.getConnection()) {
			return connection.getAutoCommit();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		LiquibaseEndpoint endpoint(ApplicationContext context) {
			return new LiquibaseEndpoint(context);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataSourceWithSchemaConfiguration {
		@Bean
		DataSource dataSource() {
			DataSource dataSource = new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseConnection.get(getClass().getClassLoader()).getType())
				.setName(UUID.randomUUID().toString())
				.build();
			DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
			settings.setSchemaLocations(Arrays.asList('classpath:/db/create-custom-schema.sql'));
			DataSourceScriptDatabaseInitializer initializer = new DataSourceScriptDatabaseInitializer(dataSource,
					settings);
			initializer.initializeDatabase();
			return dataSource;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleDataSourceLiquibaseConfiguration {
		@Bean
		DataSource dataSource() {
			return createEmbeddedDatabase();
		}
		@Bean
		DataSource dataSourceBackup() {
			return createEmbeddedDatabase();
		}
		@Bean
		SpringLiquibase liquibase(DataSource dataSource) {
			return createSpringLiquibase('db.changelog-master.yaml', dataSource);
		}
		@Bean
		SpringLiquibase liquibaseBackup(DataSource dataSourceBackup) {
			return createSpringLiquibase('db.changelog-master-backup.yaml', dataSourceBackup);
		}
		private DataSource createEmbeddedDatabase() {
			return new EmbeddedDatabaseBuilder().generateUniqueName(true)
				.setType(EmbeddedDatabaseConnection.HSQLDB.getType())
				.build();
		}
		private SpringLiquibase createSpringLiquibase(String changeLog, DataSource dataSource) {
			SpringLiquibase liquibase = new SpringLiquibase();
			liquibase.setChangeLog('classpath:/db/changelog/' + changeLog);
			liquibase.setShouldRun(true);
			liquibase.setDataSource(dataSource);
			return liquibase;
		}
	}
}
/*
package org.springframework.boot.actuate.flyway;
/**
class FlywayEndpointTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
		.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
		.withBean('endpoint', FlywayEndpoint.class);
	@Test
	void flywayReportIsProduced() {
		this.contextRunner.run((context) -> {
			Map<String, FlywayDescriptor> flywayBeans = context.getBean(FlywayEndpoint.class)
				.flywayBeans()
				.getContexts()
				.get(context.getId())
				.getFlywayBeans();
			assertThat(flywayBeans).hasSize(1);
			assertThat(flywayBeans.values().iterator().next().getMigrations()).hasSize(3);
		});
	}
	@Test
	void whenFlywayHasBeenBaselinedFlywayReportIsProduced() {
		this.contextRunner.withPropertyValues('spring.flyway.baseline-version=2')
			.withBean(FlywayMigrationStrategy.class, () -> (flyway) -> {
				flyway.baseline();
				flyway.migrate();
			})
			.run((context) -> {
				Map<String, FlywayDescriptor> flywayBeans = context.getBean(FlywayEndpoint.class)
					.flywayBeans()
					.getContexts()
					.get(context.getId())
					.getFlywayBeans();
				assertThat(flywayBeans).hasSize(1);
				assertThat(flywayBeans.values().iterator().next().getMigrations()).hasSize(4);
			});
	}
}
/*
package org.springframework.boot.actuate.sbom;
/**
class SbomEndpointCycloneDxWebIntegrationTests {
	@WebEndpointTest
	void shouldReturnSbomContent(WebTestClient client) {
		client.get()
			.uri('/actuator/sbom/application')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType('application/vnd.cyclonedx+json'))
			.expectBody()
			.jsonPath('$.bomFormat')
			.isEqualTo('CycloneDX');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		SbomProperties sbomProperties() {
			SbomProperties properties = new SbomProperties();
			properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
			return properties;
		}
		@Bean
		SbomEndpoint sbomEndpoint(SbomProperties properties, ResourceLoader resourceLoader) {
			return new SbomEndpoint(properties, resourceLoader);
		}
		@Bean
		SbomEndpointWebExtension sbomEndpointWebExtension(SbomEndpoint sbomEndpoint, SbomProperties properties) {
			return new SbomEndpointWebExtension(sbomEndpoint, properties);
		}
	}
}
/*
package org.springframework.boot.actuate.sbom;
/**
class SbomEndpointWebExtensionTests {
	private SbomProperties properties;
	@BeforeEach
	void setUp() {
		this.properties = new SbomProperties();
	}
	@Test
	void shouldReturnHttpOk() {
		this.properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
		WebEndpointResponse<Resource> response = createWebExtension().sbom('application');
		assertThat(response.getStatus()).isEqualTo(200);
	}
	@Test
	void shouldReturnNotFoundIfResourceDoesntExist() {
		WebEndpointResponse<Resource> response = createWebExtension().sbom('application');
		assertThat(response.getStatus()).isEqualTo(404);
	}
	@Test
	void shouldAutoDetectContentTypeForCycloneDx() {
		this.properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
		WebEndpointResponse<Resource> response = createWebExtension().sbom('application');
		assertThat(response.getContentType()).isEqualTo(MimeType.valueOf('application/vnd.cyclonedx+json'));
	}
	@Test
	void shouldAutoDetectContentTypeForSpdx() {
		this.properties.getApplication().setLocation('classpath:sbom/spdx.json');
		WebEndpointResponse<Resource> response = createWebExtension().sbom('application');
		assertThat(response.getContentType()).isEqualTo(MimeType.valueOf('application/spdx+json'));
	}
	@Test
	void shouldAutoDetectContentTypeForSyft() {
		this.properties.getApplication().setLocation('classpath:sbom/syft.json');
		WebEndpointResponse<Resource> response = createWebExtension().sbom('application');
		assertThat(response.getContentType()).isEqualTo(MimeType.valueOf('application/vnd.syft+json'));
	}
	@Test
	void shouldSupportUnknownFiles() {
		this.properties.getApplication().setLocation('classpath:git.properties');
		WebEndpointResponse<Resource> response = createWebExtension().sbom('application');
		assertThat(response.getContentType()).isNull();
	}
	@Test
	void shouldUseContentTypeIfSet() {
		this.properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
		this.properties.getApplication().setMediaType(MimeType.valueOf('text/plain'));
		WebEndpointResponse<Resource> response = createWebExtension().sbom('application');
		assertThat(response.getContentType()).isEqualTo(MimeType.valueOf('text/plain'));
	}
	@Test
	void shouldUseContentTypeForAdditionalSbomsIfSet() {
		this.properties.getAdditional()
			.put('alpha', sbom('classpath:sbom/cyclonedx.json', MediaType.valueOf('text/plain')));
		WebEndpointResponse<Resource> response = createWebExtension().sbom('alpha');
		assertThat(response.getContentType()).isEqualTo(MimeType.valueOf('text/plain'));
	}
	@ParameterizedTest
	@EnumSource(value = SbomType.class, names = 'UNKNOWN', mode = Mode.EXCLUDE)
	void shouldAutodetectFormats(SbomType type) throws IOException {
		String content = getSbomContent(type);
		assertThat(type.matches(content)).isTrue();
		Arrays.stream(SbomType.values())
			.filter((candidate) -> candidate != type)
			.forEach((notType) -> assertThat(notType.matches(content)).isFalse());
	}
	private String getSbomContent(SbomType type) throws IOException {
		return switch (type) {
			case CYCLONE_DX -> readResource('/sbom/cyclonedx.json');
			case SPDX -> readResource('/sbom/spdx.json');
			case SYFT -> readResource('/sbom/syft.json');
			case UNKNOWN -> throw new IllegalArgumentException('UNKNOWN is not supported');
		};
	}
	private String readResource(String resource) throws IOException {
		try (InputStream stream = getClass().getResourceAsStream(resource)) {
			assertThat(stream).as('Resource "%s"', resource).isNotNull();
			return new String(stream.readAllBytes(), StandardCharsets.UTF_8);
		}
	}
	private Sbom sbom(String location, MimeType mediaType) {
		Sbom sbom = new Sbom();
		sbom.setLocation(location);
		sbom.setMediaType(mediaType);
		return sbom;
	}
	private SbomEndpointWebExtension createWebExtension() {
		SbomEndpoint endpoint = new SbomEndpoint(this.properties, new GenericApplicationContext());
		return new SbomEndpointWebExtension(endpoint, this.properties);
	}
}
/*
package org.springframework.boot.actuate.sbom;
/**
class SbomEndpointWebIntegrationTests {
	@WebEndpointTest
	void shouldReturnSboms(WebTestClient client) {
		client.get()
			.uri('/actuator/sbom')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType('application/vnd.spring-boot.actuator.v3+json'))
			.expectBody()
			.jsonPath('$.ids')
			.value((value) -> assertThat(value).isEqualTo(new JSONArray().appendElement('application')));
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		SbomProperties sbomProperties() {
			SbomProperties properties = new SbomProperties();
			properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
			return properties;
		}
		@Bean
		SbomEndpoint sbomEndpoint(SbomProperties properties, ResourceLoader resourceLoader) {
			return new SbomEndpoint(properties, resourceLoader);
		}
		@Bean
		SbomEndpointWebExtension sbomEndpointWebExtension(SbomEndpoint sbomEndpoint, SbomProperties properties) {
			return new SbomEndpointWebExtension(sbomEndpoint, properties);
		}
	}
}
/*
package org.springframework.boot.actuate.sbom;
/**
class SbomEndpointSpdxWebIntegrationTests {
	@WebEndpointTest
	void shouldReturnSbomContent(WebTestClient client) {
		client.get()
			.uri('/actuator/sbom/application')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType('application/spdx+json'))
			.expectBody()
			.jsonPath('$.spdxVersion')
			.isEqualTo('SPDX-2.3');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		SbomProperties sbomProperties() {
			SbomProperties properties = new SbomProperties();
			properties.getApplication().setLocation('classpath:sbom/spdx.json');
			return properties;
		}
		@Bean
		SbomEndpoint sbomEndpoint(SbomProperties properties, ResourceLoader resourceLoader) {
			return new SbomEndpoint(properties, resourceLoader);
		}
		@Bean
		SbomEndpointWebExtension sbomEndpointWebExtension(SbomEndpoint sbomEndpoint, SbomProperties properties) {
			return new SbomEndpointWebExtension(sbomEndpoint, properties);
		}
	}
}
/*
package org.springframework.boot.actuate.sbom;
/**
class SbomEndpointTests {
	private SbomProperties properties;
	@BeforeEach
	void setUp() {
		this.properties = new SbomProperties();
	}
	@Test
	void shouldListSboms() {
		this.properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
		this.properties.getAdditional().put('alpha', sbom('classpath:sbom/cyclonedx.json'));
		this.properties.getAdditional().put('beta', sbom('classpath:sbom/cyclonedx.json'));
		Sboms sboms = createEndpoint().sboms();
		assertThat(sboms.ids()).containsExactly('alpha', 'application', 'beta');
	}
	@Test
	void shouldFailIfDuplicateSbomIdIsRegistered() {
		// This adds an SBOM with id "application"
		this.properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
		this.properties.getAdditional().put('application', sbom('classpath:sbom/cyclonedx.json'));
		assertThatIllegalStateException().isThrownBy(this::createEndpoint)
			.withMessage('Duplicate SBOM registration with id "application"');
	}
	@Test
	void shouldUseLocationFromProperties() throws IOException {
		this.properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
		String content = createEndpoint().sbom('application').getContentAsString(StandardCharsets.UTF_8);
		assertThat(content).contains('\'bomFormat\' : \'CycloneDX\'');
	}
	@Test
	void shouldFailIfNonExistingLocationIsGiven() {
		this.properties.getApplication().setLocation('classpath:does-not-exist.json');
		assertThatIllegalStateException().isThrownBy(() -> createEndpoint().sbom('application'))
			.withMessageContaining('Resource "classpath:does-not-exist.json" doesn"t exist');
	}
	@Test
	void shouldNotFailIfNonExistingOptionalLocationIsGiven() {
		this.properties.getApplication().setLocation('optional:classpath:does-not-exist.json');
		assertThat(createEndpoint().sbom('application')).isNull();
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new SbomEndpointRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('META-INF/sbom/bom.json')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('META-INF/sbom/application.cdx.json')).accepts(hints);
	}
	private Sbom sbom(String location) {
		Sbom result = new Sbom();
		result.setLocation(location);
		return result;
	}
	private SbomEndpoint createEndpoint() {
		return new SbomEndpoint(this.properties, new GenericApplicationContext());
	}
}
/*
package org.springframework.boot.actuate.sbom;
/**
class SbomEndpointSyftWebIntegrationTests {
	@WebEndpointTest
	void shouldReturnSbomContent(WebTestClient client) {
		client.get()
			.uri('/actuator/sbom/application')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.parseMediaType('application/vnd.syft+json'))
			.expectBody()
			.jsonPath('$.descriptor.name')
			.isEqualTo('syft');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		SbomProperties sbomProperties() {
			SbomProperties properties = new SbomProperties();
			properties.getApplication().setLocation('classpath:sbom/syft.json');
			return properties;
		}
		@Bean
		SbomEndpoint sbomEndpoint(SbomProperties properties, ResourceLoader resourceLoader) {
			return new SbomEndpoint(properties, resourceLoader);
		}
		@Bean
		SbomEndpointWebExtension sbomEndpointWebExtension(SbomEndpoint sbomEndpoint, SbomProperties properties) {
			return new SbomEndpointWebExtension(sbomEndpoint, properties);
		}
	}
}
/*
package org.springframework.boot.actuate.management;
/**
class ThreadDumpEndpointWebIntegrationTests {
	@WebEndpointTest
	void getRequestWithJsonAcceptHeaderShouldProduceJsonThreadDumpResponse(WebTestClient client) {
		client.get()
			.uri('/actuator/threaddump')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.APPLICATION_JSON);
	}
	@WebEndpointTest
	void getRequestWithTextPlainAcceptHeaderShouldProduceTextPlainResponse(WebTestClient client) {
		String response = client.get()
			.uri('/actuator/threaddump')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType('text/plain;charset=UTF-8')
			.expectBody(String.class)
			.returnResult()
			.getResponseBody();
		assertThat(response).contains('Full thread dump');
	}
	@Configuration(proxyBeanMethods = false)
	public static class TestConfiguration {
		@Bean
		public ThreadDumpEndpoint endpoint() {
			return new ThreadDumpEndpoint();
		}
	}
}
/*
package org.springframework.boot.actuate.management;
/**
class ThreadDumpEndpointTests {
	@Test
	void dumpThreads() {
		assertThat(new ThreadDumpEndpoint().threadDump().getThreads()).isNotEmpty();
	}
	@Test
	void dumpThreadsAsText() throws InterruptedException {
		Object contendedMonitor = new Object();
		Object monitor = new Object();
		CountDownLatch latch = new CountDownLatch(1);
		Thread awaitCountDownLatchThread = new Thread(() -> {
			try {
				latch.await();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}, 'Awaiting CountDownLatch');
		awaitCountDownLatchThread.start();
		Thread contendedMonitorThread = new Thread(() -> {
			synchronized (contendedMonitor) {
				// Intentionally empty
			}
		}, 'Waiting for monitor');
		Thread waitOnMonitorThread = new Thread(() -> {
			synchronized (monitor) {
				try {
					monitor.wait();
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
			}
		}, 'Waiting on monitor');
		waitOnMonitorThread.start();
		ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
		Lock writeLock = readWriteLock.writeLock();
		new Thread(() -> {
			writeLock.lock();
			try {
				latch.await();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
			finally {
				writeLock.unlock();
			}
		}, 'Holding write lock').start();
		while (writeLock.tryLock()) {
			writeLock.unlock();
		}
		awaitState(waitOnMonitorThread, State.WAITING);
		awaitState(awaitCountDownLatchThread, State.WAITING);
		String threadDump;
		synchronized (contendedMonitor) {
			contendedMonitorThread.start();
			awaitState(contendedMonitorThread, State.BLOCKED);
			threadDump = new ThreadDumpEndpoint().textThreadDump();
		}
		latch.countDown();
		synchronized (monitor) {
			monitor.notifyAll();
		}
		assertThat(threadDump)
			.containsPattern(String.format('\t- parking to wait for <[0-9a-z]+> \\(a %s\\$Sync\\)',
					CountDownLatch.class.getName().replace('.', '\\.')))
			.contains(String.format('\t- locked <%s> (a java.lang.Object)', hexIdentityHashCode(contendedMonitor)))
			.contains(String.format('\t- waiting to lock <%s> (a java.lang.Object) owned by \'%s\' t@%d',
					hexIdentityHashCode(contendedMonitor), Thread.currentThread().getName(),
					Thread.currentThread().getId()))
			.satisfiesAnyOf(
					(dump) -> assertThat(dump).contains(
							String.format('\t- waiting on <%s> (a java.lang.Object)', hexIdentityHashCode(monitor))),
					(dump) -> assertThat(dump).contains(String
						.format('\t- parking to wait for <%s> (a java.lang.Object)', hexIdentityHashCode(monitor))))
			.containsPattern(
					String.format('Locked ownable synchronizers:%n\t- Locked <[0-9a-z]+> \\(a %s\\$NonfairSync\\)',
							ReentrantReadWriteLock.class.getName().replace('.', '\\.')));
	}
	private String hexIdentityHashCode(Object object) {
		return Integer.toHexString(System.identityHashCode(object));
	}
	private void awaitState(Thread thread, State state) throws InterruptedException {
		while (thread.getState() != state) {
			Thread.sleep(50);
		}
	}
}
/*
package org.springframework.boot.actuate.management;
/**
class HeapDumpWebEndpointTests {
	@Test
	void parallelRequestProducesTooManyRequestsResponse() throws InterruptedException {
		CountDownLatch dumpingLatch = new CountDownLatch(1);
		CountDownLatch blockingLatch = new CountDownLatch(1);
		HeapDumpWebEndpoint slowEndpoint = new HeapDumpWebEndpoint(2500) {
			@Override
			protected HeapDumper createHeapDumper() {
				return (live) -> {
					dumpingLatch.countDown();
					blockingLatch.await();
					return Files.createTempFile('heap-', '.dump').toFile();
				};
			}
		};
		Thread thread = new Thread(() -> slowEndpoint.heapDump(true));
		thread.start();
		dumpingLatch.await();
		assertThat(slowEndpoint.heapDump(true).getStatus()).isEqualTo(429);
		blockingLatch.countDown();
		thread.join();
	}
}
/*
package org.springframework.boot.actuate.management;
/**
class HeapDumpWebEndpointWebIntegrationTests {
	private TestHeapDumpWebEndpoint endpoint;
	@BeforeEach
	void configureEndpoint(ApplicationContext context) {
		this.endpoint = context.getBean(TestHeapDumpWebEndpoint.class);
		this.endpoint.setAvailable(true);
	}
	@WebEndpointTest
	void invokeWhenNotAvailableShouldReturnServiceUnavailableStatus(WebTestClient client) {
		this.endpoint.setAvailable(false);
		client.get().uri('/actuator/heapdump').exchange().expectStatus().isEqualTo(HttpStatus.SERVICE_UNAVAILABLE);
	}
	@WebEndpointTest
	void getRequestShouldReturnHeapDumpInResponseBody(WebTestClient client) {
		client.get()
			.uri('/actuator/heapdump')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.APPLICATION_OCTET_STREAM)
			.expectBody(String.class)
			.isEqualTo('HEAPDUMP');
		assertHeapDumpFileIsDeleted();
	}
	private void assertHeapDumpFileIsDeleted() {
		Awaitility.waitAtMost(Duration.ofSeconds(5)).until(this.endpoint.file::exists, is(false));
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		HeapDumpWebEndpoint endpoint() {
			return new TestHeapDumpWebEndpoint();
		}
	}
	static class TestHeapDumpWebEndpoint extends HeapDumpWebEndpoint {
		private boolean available;
		private final String heapDump = 'HEAPDUMP';
		private File file;
		TestHeapDumpWebEndpoint() {
			super(TimeUnit.SECONDS.toMillis(1));
			reset();
		}
		void reset() {
			this.available = true;
		}
		@Override
		protected HeapDumper createHeapDumper() {
			return (live) -> {
				this.file = Files.createTempFile('heap-', '.dump').toFile();
				if (!TestHeapDumpWebEndpoint.this.available) {
					throw new HeapDumperUnavailableException('Not available', null);
				}
				FileCopyUtils.copy(TestHeapDumpWebEndpoint.this.heapDump.getBytes(), this.file);
				return this.file;
			};
		}
		void setAvailable(boolean available) {
			this.available = available;
		}
	}
}
/*
package org.springframework.boot.actuate.ldap;
/**
class LdapHealthIndicatorTests {
	@Test
	@SuppressWarnings('unchecked')
	void ldapIsUp() {
		LdapTemplate ldapTemplate = mock(LdapTemplate.class);
		given(ldapTemplate.executeReadOnly((ContextExecutor<String>) any())).willReturn('3');
		LdapHealthIndicator healthIndicator = new LdapHealthIndicator(ldapTemplate);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('version', '3');
		then(ldapTemplate).should().executeReadOnly((ContextExecutor<String>) any());
	}
	@Test
	@SuppressWarnings('unchecked')
	void ldapIsDown() {
		LdapTemplate ldapTemplate = mock(LdapTemplate.class);
		given(ldapTemplate.executeReadOnly((ContextExecutor<String>) any()))
			.willThrow(new CommunicationException(new javax.naming.CommunicationException('Connection failed')));
		LdapHealthIndicator healthIndicator = new LdapHealthIndicator(ldapTemplate);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat((String) health.getDetails().get('error')).contains('Connection failed');
		then(ldapTemplate).should().executeReadOnly((ContextExecutor<String>) any());
	}
}
/*
package org.springframework.boot.actuate.mongo;
/**
class MongoHealthIndicatorTests {
	@Test
	void mongoIsUp() {
		Document commandResult = mock(Document.class);
		given(commandResult.getInteger('maxWireVersion')).willReturn(10);
		MongoTemplate mongoTemplate = mock(MongoTemplate.class);
		given(mongoTemplate.executeCommand('{ hello: 1 }')).willReturn(commandResult);
		MongoHealthIndicator healthIndicator = new MongoHealthIndicator(mongoTemplate);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('maxWireVersion', 10);
		then(commandResult).should().getInteger('maxWireVersion');
		then(mongoTemplate).should().executeCommand('{ hello: 1 }');
	}
	@Test
	void mongoIsDown() {
		MongoTemplate mongoTemplate = mock(MongoTemplate.class);
		given(mongoTemplate.executeCommand('{ hello: 1 }')).willThrow(new MongoException('Connection failed'));
		MongoHealthIndicator healthIndicator = new MongoHealthIndicator(mongoTemplate);
		Health health = healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat((String) health.getDetails().get('error')).contains('Connection failed');
		then(mongoTemplate).should().executeCommand('{ hello: 1 }');
	}
}
/*
package org.springframework.boot.actuate.mongo;
/**
class MongoReactiveHealthIndicatorTests {
	@Test
	void testMongoIsUp() {
		Document buildInfo = mock(Document.class);
		given(buildInfo.getInteger('maxWireVersion')).willReturn(10);
		ReactiveMongoTemplate reactiveMongoTemplate = mock(ReactiveMongoTemplate.class);
		given(reactiveMongoTemplate.executeCommand('{ hello: 1 }')).willReturn(Mono.just(buildInfo));
		MongoReactiveHealthIndicator mongoReactiveHealthIndicator = new MongoReactiveHealthIndicator(
				reactiveMongoTemplate);
		Mono<Health> health = mongoReactiveHealthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.UP);
			assertThat(h.getDetails()).containsOnlyKeys('maxWireVersion');
			assertThat(h.getDetails()).containsEntry('maxWireVersion', 10);
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void testMongoIsDown() {
		ReactiveMongoTemplate reactiveMongoTemplate = mock(ReactiveMongoTemplate.class);
		given(reactiveMongoTemplate.executeCommand('{ hello: 1 }')).willThrow(new MongoException('Connection failed'));
		MongoReactiveHealthIndicator mongoReactiveHealthIndicator = new MongoReactiveHealthIndicator(
				reactiveMongoTemplate);
		Mono<Health> health = mongoReactiveHealthIndicator.health();
		StepVerifier.create(health).consumeNextWith((h) -> {
			assertThat(h.getStatus()).isEqualTo(Status.DOWN);
			assertThat(h.getDetails()).containsOnlyKeys('error');
			assertThat(h.getDetails()).containsEntry('error', MongoException.class.getName() + ': Connection failed');
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
}
/*
package org.springframework.boot.actuate.env;
/**
class EnvironmentEndpointTests {
	@AfterEach
	void close() {
		System.clearProperty('VCAP_SERVICES');
	}
	@Test
	void basicResponse() {
		ConfigurableEnvironment environment = emptyEnvironment();
		environment.getPropertySources().addLast(singleKeyPropertySource('one', 'my.key', 'first'));
		environment.getPropertySources().addLast(singleKeyPropertySource('two', 'my.key', 'second'));
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		assertThat(descriptor.getActiveProfiles()).isEmpty();
		Map<String, PropertySourceDescriptor> sources = propertySources(descriptor);
		assertThat(sources.keySet()).containsExactly('one', 'two');
		assertThat(sources.get('one').getProperties()).containsOnlyKeys('my.key');
		assertThat(sources.get('two').getProperties()).containsOnlyKeys('my.key');
	}
	@Test
	void responseWhenShowNever() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		TestPropertyValues.of('other.service=abcde').applyTo(environment);
		TestPropertyValues.of('system.service=123456').applyToSystemProperties(() -> {
			EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.NEVER)
				.environment(null);
			assertThat(propertySources(descriptor).get('test').getProperties().get('other.service').getValue())
				.isEqualTo('******');
			Map<String, PropertyValueDescriptor> systemProperties = propertySources(descriptor).get('systemProperties')
				.getProperties();
			assertThat(systemProperties.get('system.service').getValue()).isEqualTo('******');
			return null;
		});
	}
	@Test
	void responseWhenShowWhenAuthorized() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		TestPropertyValues.of('other.service=abcde').applyTo(environment);
		TestPropertyValues.of('system.service=123456').applyToSystemProperties(() -> {
			EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(),
					Show.WHEN_AUTHORIZED)
				.environment(null);
			assertThat(propertySources(descriptor).get('test').getProperties().get('other.service').getValue())
				.isEqualTo('abcde');
			Map<String, PropertyValueDescriptor> systemProperties = propertySources(descriptor).get('systemProperties')
				.getProperties();
			assertThat(systemProperties.get('system.service').getValue()).isEqualTo('123456');
			return null;
		});
	}
	@Test
	void compositeSourceIsHandledCorrectly() {
		ConfigurableEnvironment environment = emptyEnvironment();
		CompositePropertySource source = new CompositePropertySource('composite');
		source.addPropertySource(new MapPropertySource('one', Collections.singletonMap('foo', 'bar')));
		source.addPropertySource(new MapPropertySource('two', Collections.singletonMap('foo', 'spam')));
		environment.getPropertySources().addFirst(source);
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		Map<String, PropertySourceDescriptor> sources = propertySources(descriptor);
		assertThat(sources.keySet()).containsExactly('composite:one', 'composite:two');
		assertThat(sources.get('composite:one').getProperties().get('foo').getValue()).isEqualTo('bar');
		assertThat(sources.get('composite:two').getProperties().get('foo').getValue()).isEqualTo('spam');
	}
	@Test
	void keysMatchingCustomSanitizingFunctionHaveTheirValuesSanitized() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		TestPropertyValues.of('other.service=abcde').applyTo(environment);
		TestPropertyValues.of('system.service=123456').applyToSystemProperties(() -> {
			EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment,
					Collections.singletonList((data) -> {
						String name = data.getPropertySource().getName();
						if (name.equals(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)) {
							return data.withValue('******');
						}
						return data;
					}), Show.ALWAYS)
				.environment(null);
			assertThat(propertySources(descriptor).get('test').getProperties().get('other.service').getValue())
				.isEqualTo('abcde');
			Map<String, PropertyValueDescriptor> systemProperties = propertySources(descriptor).get('systemProperties')
				.getProperties();
			assertThat(systemProperties.get('system.service').getValue()).isEqualTo('******');
			return null;
		});
	}
	@Test
	void propertyWithPlaceholderResolved() {
		ConfigurableEnvironment environment = emptyEnvironment();
		TestPropertyValues.of('my.foo: ${bar.blah}', 'bar.blah: hello').applyTo(environment);
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		assertThat(propertySources(descriptor).get('test').getProperties().get('my.foo').getValue()).isEqualTo('hello');
	}
	@Test
	void propertyWithPlaceholderNotResolved() {
		ConfigurableEnvironment environment = emptyEnvironment();
		TestPropertyValues.of('my.foo: ${bar.blah}').applyTo(environment);
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		assertThat(propertySources(descriptor).get('test').getProperties().get('my.foo').getValue())
			.isEqualTo('${bar.blah}');
	}
	@Test
	void propertyWithComplexTypeShouldNotFail() {
		ConfigurableEnvironment environment = emptyEnvironment();
		environment.getPropertySources()
			.addFirst(singleKeyPropertySource('test', 'foo', Collections.singletonMap('bar', 'baz')));
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		String value = (String) propertySources(descriptor).get('test').getProperties().get('foo').getValue();
		assertThat(value).isEqualTo('Complex property type java.util.Collections$SingletonMap');
	}
	@Test
	void propertyWithPrimitiveOrWrapperTypeIsHandledCorrectly() {
		ConfigurableEnvironment environment = emptyEnvironment();
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('char', "a");
		map.put('integer', 100);
		map.put('boolean', true);
		map.put('biginteger', BigInteger.valueOf(200));
		environment.getPropertySources().addFirst(new MapPropertySource('test', map));
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		Map<String, PropertyValueDescriptor> properties = propertySources(descriptor).get('test').getProperties();
		assertThat(properties.get('char').getValue()).isEqualTo("a");
		assertThat(properties.get('integer').getValue()).isEqualTo(100);
		assertThat(properties.get('boolean').getValue()).isEqualTo(true);
		assertThat(properties.get('biginteger').getValue()).isEqualTo(BigInteger.valueOf(200));
	}
	@Test
	void propertyWithCharSequenceTypeIsConvertedToString() {
		ConfigurableEnvironment environment = emptyEnvironment();
		environment.getPropertySources().addFirst(singleKeyPropertySource('test', 'foo', new CharSequenceProperty()));
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		String value = (String) propertySources(descriptor).get('test').getProperties().get('foo').getValue();
		assertThat(value).isEqualTo('test value');
	}
	@Test
	void propertyEntry() {
		testPropertyEntry(Show.ALWAYS, 'bar', 'another');
	}
	@Test
	void propertyEntryWhenShowNever() {
		testPropertyEntry(Show.NEVER, '******', '******');
	}
	@Test
	void propertyEntryWhenShowWhenAuthorized() {
		testPropertyEntry(Show.ALWAYS, 'bar', 'another');
	}
	private void testPropertyEntry(Show always, String bar, String another) {
		TestPropertyValues.of('my.foo=another').applyToSystemProperties(() -> {
			StandardEnvironment environment = new StandardEnvironment();
			TestPropertyValues.of('my.foo=bar', 'my.foo2=bar2')
				.applyTo(environment, TestPropertyValues.Type.MAP, 'test');
			EnvironmentEntryDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(),
					always)
				.environmentEntry('my.foo');
			assertThat(descriptor).isNotNull();
			assertThat(descriptor.getProperty()).isNotNull();
			assertThat(descriptor.getProperty().getSource()).isEqualTo('test');
			assertThat(descriptor.getProperty().getValue()).isEqualTo(bar);
			Map<String, PropertySourceEntryDescriptor> sources = propertySources(descriptor);
			assertThat(sources.keySet()).containsExactly('test', 'systemProperties', 'systemEnvironment');
			assertPropertySourceEntryDescriptor(sources.get('test'), bar, null);
			assertPropertySourceEntryDescriptor(sources.get('systemProperties'), another, null);
			assertPropertySourceEntryDescriptor(sources.get('systemEnvironment'), null, null);
			return null;
		});
	}
	@Test
	void originAndOriginParents() {
		StandardEnvironment environment = new StandardEnvironment();
		OriginParentMockPropertySource propertySource = new OriginParentMockPropertySource();
		propertySource.setProperty('name', 'test');
		environment.getPropertySources().addFirst(propertySource);
		EnvironmentEntryDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(),
				Show.ALWAYS)
			.environmentEntry('name');
		PropertySourceEntryDescriptor entryDescriptor = propertySources(descriptor).get('mockProperties');
		assertThat(entryDescriptor.getProperty().getOrigin()).isEqualTo('name');
		assertThat(entryDescriptor.getProperty().getOriginParents()).containsExactly('spring', 'boot');
	}
	@Test
	void propertyEntryNotFound() {
		ConfigurableEnvironment environment = emptyEnvironment();
		environment.getPropertySources().addFirst(singleKeyPropertySource('test', 'foo', 'bar'));
		EnvironmentEntryDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(),
				Show.ALWAYS)
			.environmentEntry('does.not.exist');
		assertThat(descriptor).isNotNull();
		assertThat(descriptor.getProperty()).isNull();
		Map<String, PropertySourceEntryDescriptor> sources = propertySources(descriptor);
		assertThat(sources.keySet()).containsExactly('test');
		assertPropertySourceEntryDescriptor(sources.get('test'), null, null);
	}
	@Test
	void multipleSourcesWithSameProperty() {
		ConfigurableEnvironment environment = emptyEnvironment();
		environment.getPropertySources().addFirst(singleKeyPropertySource('one', 'a', 'alpha'));
		environment.getPropertySources().addFirst(singleKeyPropertySource('two', 'a', 'apple'));
		EnvironmentDescriptor descriptor = new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS)
			.environment(null);
		Map<String, PropertySourceDescriptor> sources = propertySources(descriptor);
		assertThat(sources.keySet()).containsExactly('two', 'one');
		assertThat(sources.get('one').getProperties().get('a').getValue()).isEqualTo('alpha');
		assertThat(sources.get('two').getProperties().get('a').getValue()).isEqualTo('apple');
	}
	private static ConfigurableEnvironment emptyEnvironment() {
		StandardEnvironment environment = new StandardEnvironment();
		environment.getPropertySources().remove(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME);
		environment.getPropertySources().remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME);
		return environment;
	}
	private MapPropertySource singleKeyPropertySource(String name, String key, Object value) {
		return new MapPropertySource(name, Collections.singletonMap(key, value));
	}
	private Map<String, PropertySourceDescriptor> propertySources(EnvironmentDescriptor descriptor) {
		Map<String, PropertySourceDescriptor> sources = new LinkedHashMap<>();
		descriptor.getPropertySources().forEach((d) -> sources.put(d.getName(), d));
		return sources;
	}
	private Map<String, PropertySourceEntryDescriptor> propertySources(EnvironmentEntryDescriptor descriptor) {
		Map<String, PropertySourceEntryDescriptor> sources = new LinkedHashMap<>();
		descriptor.getPropertySources().forEach((d) -> sources.put(d.getName(), d));
		return sources;
	}
	private void assertPropertySourceEntryDescriptor(PropertySourceEntryDescriptor actual, Object value,
			String origin) {
		assertThat(actual).isNotNull();
		if (value != null) {
			assertThat(actual.getProperty().getValue()).isEqualTo(value);
			assertThat(actual.getProperty().getOrigin()).isEqualTo(origin);
		}
		else {
			assertThat(actual.getProperty()).isNull();
		}
	}
	static class OriginParentMockPropertySource extends MockPropertySource implements OriginLookup<String> {
		@Override
		public Origin getOrigin(String key) {
			return new MockOrigin(key, new MockOrigin('spring', new MockOrigin('boot', null)));
		}
	}
	static class MockOrigin implements Origin {
		private final String value;
		private final MockOrigin parent;
		MockOrigin(String value, MockOrigin parent) {
			this.value = value;
			this.parent = parent;
		}
		@Override
		public Origin getParent() {
			return this.parent;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class Config {
		@Bean
		EnvironmentEndpoint environmentEndpoint(Environment environment) {
			return new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS);
		}
	}
	public static class CharSequenceProperty implements CharSequence, InputStreamSource {
		private final String value = 'test value';
		@Override
		public int length() {
			return this.value.length();
		}
		@Override
		public char charAt(int index) {
			return this.value.charAt(index);
		}
		@Override
		public CharSequence subSequence(int start, int end) {
			return this.value.subSequence(start, end);
		}
		@Override
		public String toString() {
			return this.value;
		}
		@Override
		public InputStream getInputStream() throws IOException {
			return new ByteArrayInputStream(this.value.getBytes());
		}
	}
}
/*
package org.springframework.boot.actuate.env;
/**
class EnvironmentEndpointWebExtensionTests {
	private EnvironmentEndpointWebExtension webExtension;
	private EnvironmentEndpoint delegate;
	@BeforeEach
	void setup() {
		this.delegate = mock(EnvironmentEndpoint.class);
	}
	@Test
	void whenShowValuesIsNever() {
		this.webExtension = new EnvironmentEndpointWebExtension(this.delegate, Show.NEVER, Collections.emptySet());
		this.webExtension.environment(null, null);
		then(this.delegate).should().getEnvironmentDescriptor(null, false);
		verifyPrefixed(null, false);
	}
	@Test
	void whenShowValuesIsAlways() {
		this.webExtension = new EnvironmentEndpointWebExtension(this.delegate, Show.ALWAYS, Collections.emptySet());
		this.webExtension.environment(null, null);
		then(this.delegate).should().getEnvironmentDescriptor(null, true);
		verifyPrefixed(null, true);
	}
	@Test
	void whenShowValuesIsWhenAuthorizedAndSecurityContextIsAuthorized() {
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
		this.webExtension = new EnvironmentEndpointWebExtension(this.delegate, Show.WHEN_AUTHORIZED,
				Collections.emptySet());
		this.webExtension.environment(securityContext, null);
		then(this.delegate).should().getEnvironmentDescriptor(null, true);
		verifyPrefixed(securityContext, true);
	}
	@Test
	void whenShowValuesIsWhenAuthorizedAndSecurityContextIsNotAuthorized() {
		SecurityContext securityContext = mock(SecurityContext.class);
		this.webExtension = new EnvironmentEndpointWebExtension(this.delegate, Show.WHEN_AUTHORIZED,
				Collections.emptySet());
		this.webExtension.environment(securityContext, null);
		then(this.delegate).should().getEnvironmentDescriptor(null, false);
		verifyPrefixed(securityContext, false);
	}
	private void verifyPrefixed(SecurityContext securityContext, boolean showUnsanitized) {
		given(this.delegate.getEnvironmentEntryDescriptor('test', showUnsanitized))
			.willReturn(new EnvironmentEntryDescriptor(null, Collections.emptyList(), Collections.emptyList(),
					Collections.emptyList()));
		this.webExtension.environmentEntry(securityContext, 'test');
		then(this.delegate).should().getEnvironmentEntryDescriptor('test', showUnsanitized);
	}
}
/*
package org.springframework.boot.actuate.env;
class EnvironmentEndpointWebIntegrationTests {
	private ConfigurableApplicationContext context;
	private WebTestClient client;
	@BeforeEach
	void prepareEnvironment(ConfigurableApplicationContext context, WebTestClient client) {
		TestPropertyValues.of('foo:bar', 'fool:baz').applyTo(context);
		this.client = client;
		this.context = context;
	}
	@WebEndpointTest
	void home() {
		this.client.get()
			.uri('/actuator/env')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('propertySources[?(@.name=="systemProperties")]')
			.exists();
	}
	@WebEndpointTest
	void sub() {
		this.client.get()
			.uri('/actuator/env/foo')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('property.source')
			.isEqualTo('test')
			.jsonPath('property.value')
			.isEqualTo('bar');
	}
	@WebEndpointTest
	void regex() {
		Map<String, Object> map = new HashMap<>();
		map.put('food', null);
		this.context.getEnvironment().getPropertySources().addFirst(new MapPropertySource('null-value', map));
		this.client.get()
			.uri('/actuator/env?pattern=foo.*')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath(forProperty('test', 'foo'))
			.isEqualTo('bar')
			.jsonPath(forProperty('test', 'fool'))
			.isEqualTo('baz');
	}
	@WebEndpointTest
	void nestedPathWhenPlaceholderCannotBeResolvedShouldReturnUnresolvedProperty() {
		Map<String, Object> map = new HashMap<>();
		map.put('my.foo', '${my.bar}');
		this.context.getEnvironment()
			.getPropertySources()
			.addFirst(new MapPropertySource('unresolved-placeholder', map));
		this.client.get()
			.uri('/actuator/env/my.foo')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('property.value')
			.isEqualTo('${my.bar}')
			.jsonPath(forPropertyEntry('unresolved-placeholder'))
			.isEqualTo('${my.bar}');
	}
	@WebEndpointTest
	void nestedPathForUnknownKeyShouldReturn404() {
		this.client.get().uri('/actuator/env/this.does.not.exist').exchange().expectStatus().isNotFound();
	}
	@WebEndpointTest
	void nestedPathMatchedByRegexWhenPlaceholderCannotBeResolvedShouldReturnUnresolvedProperty() {
		Map<String, Object> map = new HashMap<>();
		map.put('my.foo', '${my.bar}');
		this.context.getEnvironment()
			.getPropertySources()
			.addFirst(new MapPropertySource('unresolved-placeholder', map));
		this.client.get()
			.uri('/actuator/env?pattern=my.*')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('propertySources[?(@.name=="unresolved-placeholder")].properties.["my.foo"].value')
			.isEqualTo('${my.bar}');
	}
	private String forProperty(String source, String name) {
		return 'propertySources[?(@.name=="' + source + '")].properties.["' + name + '"].value';
	}
	private String forPropertyEntry(String source) {
		return 'propertySources[?(@.name=="' + source + '")].property.value';
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		EnvironmentEndpoint endpoint(Environment environment) {
			return new EnvironmentEndpoint(environment, Collections.emptyList(), Show.ALWAYS);
		}
		@Bean
		EnvironmentEndpointWebExtension environmentEndpointWebExtension(EnvironmentEndpoint endpoint) {
			return new EnvironmentEndpointWebExtension(endpoint, Show.ALWAYS, Collections.emptySet());
		}
	}
}
/*
package org.springframework.boot.actuate.beans;
/**
class BeansEndpointTests {
	@Test
	void beansAreFound() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfiguration.class);
		contextRunner.run((context) -> {
			BeansDescriptor result = context.getBean(BeansEndpoint.class).beans();
			ContextBeansDescriptor descriptor = result.getContexts().get(context.getId());
			assertThat(descriptor.getParentId()).isNull();
			Map<String, BeanDescriptor> beans = descriptor.getBeans();
			assertThat(beans).hasSizeLessThanOrEqualTo(context.getBeanDefinitionCount());
			assertThat(beans).containsKey('endpoint');
		});
	}
	@Test
	void infrastructureBeansAreOmitted() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfiguration.class);
		contextRunner.run((context) -> {
			ConfigurableListableBeanFactory factory = (ConfigurableListableBeanFactory) context
				.getAutowireCapableBeanFactory();
			List<String> infrastructureBeans = Stream.of(context.getBeanDefinitionNames())
				.filter((name) -> BeanDefinition.ROLE_INFRASTRUCTURE == factory.getBeanDefinition(name).getRole())
				.toList();
			BeansDescriptor result = context.getBean(BeansEndpoint.class).beans();
			ContextBeansDescriptor contextDescriptor = result.getContexts().get(context.getId());
			Map<String, BeanDescriptor> beans = contextDescriptor.getBeans();
			for (String infrastructureBean : infrastructureBeans) {
				assertThat(beans).doesNotContainKey(infrastructureBean);
			}
		});
	}
	@Test
	void lazyBeansAreOmitted() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfiguration.class, LazyBeanConfiguration.class);
		contextRunner.run((context) -> {
			BeansDescriptor result = context.getBean(BeansEndpoint.class).beans();
			ContextBeansDescriptor contextDescriptor = result.getContexts().get(context.getId());
			assertThat(context).hasBean('lazyBean');
			assertThat(contextDescriptor.getBeans()).doesNotContainKey('lazyBean');
		});
	}
	@Test
	void beansInParentContextAreFound() {
		ApplicationContextRunner parentRunner = new ApplicationContextRunner()
			.withUserConfiguration(BeanConfiguration.class);
		parentRunner.run((parent) -> {
			new ApplicationContextRunner().withUserConfiguration(EndpointConfiguration.class)
				.withParent(parent)
				.run((child) -> {
					BeansDescriptor result = child.getBean(BeansEndpoint.class).beans();
					assertThat(result.getContexts().get(parent.getId()).getBeans()).containsKey('bean');
					assertThat(result.getContexts().get(child.getId()).getBeans()).containsKey('endpoint');
				});
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointConfiguration {
		@Bean
		BeansEndpoint endpoint(ConfigurableApplicationContext context) {
			return new BeansEndpoint(context);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BeanConfiguration {
		@Bean
		String bean() {
			return 'bean';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class LazyBeanConfiguration {
		@Lazy
		@Bean
		String lazyBean() {
			return 'lazyBean';
		}
	}
}
/*
package org.springframework.boot.actuate.ssl;
/**
public class SslHealthIndicator extends AbstractHealthIndicator {
	private final SslInfo sslInfo;
	public SslHealthIndicator(SslInfo sslInfo) {
		this.sslInfo = sslInfo;
	}
	@Override
	protected void doHealthCheck(Builder builder) throws Exception {
		List<CertificateChainInfo> validCertificateChains = new ArrayList<>();
		List<CertificateChainInfo> invalidCertificateChains = new ArrayList<>();
		for (BundleInfo bundle : this.sslInfo.getBundles()) {
			for (CertificateChainInfo certificateChain : bundle.getCertificateChains()) {
				if (containsOnlyValidCertificates(certificateChain)) {
					validCertificateChains.add(certificateChain);
				}
				else if (containsInvalidCertificate(certificateChain)) {
					invalidCertificateChains.add(certificateChain);
				}
			}
		}
		builder.status((invalidCertificateChains.isEmpty()) ? Status.UP : Status.OUT_OF_SERVICE);
		builder.withDetail('validChains', validCertificateChains);
		builder.withDetail('invalidChains', invalidCertificateChains);
	}
	private boolean containsOnlyValidCertificates(CertificateChainInfo certificateChain) {
		return validatableCertificates(certificateChain).allMatch(this::isValidCertificate);
	}
	private boolean containsInvalidCertificate(CertificateChainInfo certificateChain) {
		return validatableCertificates(certificateChain).anyMatch(this::isNotValidCertificate);
	}
	private Stream<CertificateInfo> validatableCertificates(CertificateChainInfo certificateChain) {
		return certificateChain.getCertificates().stream().filter((certificate) -> certificate.getValidity() != null);
	}
	private boolean isValidCertificate(CertificateInfo certificate) {
		return certificate.getValidity().getStatus().isValid();
	}
	private boolean isNotValidCertificate(CertificateInfo certificate) {
		return !isValidCertificate(certificate);
	}
}
/*
/**
package org.springframework.boot.actuate.ssl;
/*
package org.springframework.boot.actuate.scheduling;
/**
@Endpoint(id = 'scheduledtasks')
@ImportRuntimeHints(ScheduledTasksEndpointRuntimeHints.class)
public class ScheduledTasksEndpoint {
	private final Collection<ScheduledTaskHolder> scheduledTaskHolders;
	public ScheduledTasksEndpoint(Collection<ScheduledTaskHolder> scheduledTaskHolders) {
		this.scheduledTaskHolders = scheduledTaskHolders;
	}
	@ReadOperation
	public ScheduledTasksDescriptor scheduledTasks() {
		MultiValueMap<TaskType, TaskDescriptor> descriptionsByType = new LinkedMultiValueMap<>();
		for (ScheduledTaskHolder holder : this.scheduledTaskHolders) {
			for (ScheduledTask scheduledTask : holder.getScheduledTasks()) {
				TaskType taskType = TaskType.forTask(scheduledTask);
				if (taskType != null) {
					TaskDescriptor descriptor = taskType.createDescriptor(scheduledTask);
					descriptionsByType.add(descriptor.getType(), descriptor);
				}
			}
		}
		return new ScheduledTasksDescriptor(descriptionsByType);
	}
	/**
	 * Description of an application"s scheduled {@link Task Tasks}.
	 */
	public static final class ScheduledTasksDescriptor implements OperationResponseBody {
		private final List<TaskDescriptor> cron;
		private final List<TaskDescriptor> fixedDelay;
		private final List<TaskDescriptor> fixedRate;
		private final List<TaskDescriptor> custom;
		private ScheduledTasksDescriptor(Map<TaskType, List<TaskDescriptor>> descriptionsByType) {
			this.cron = descriptionsByType.getOrDefault(TaskType.CRON, Collections.emptyList());
			this.fixedDelay = descriptionsByType.getOrDefault(TaskType.FIXED_DELAY, Collections.emptyList());
			this.fixedRate = descriptionsByType.getOrDefault(TaskType.FIXED_RATE, Collections.emptyList());
			this.custom = descriptionsByType.getOrDefault(TaskType.CUSTOM_TRIGGER, Collections.emptyList());
		}
		public List<TaskDescriptor> getCron() {
			return this.cron;
		}
		public List<TaskDescriptor> getFixedDelay() {
			return this.fixedDelay;
		}
		public List<TaskDescriptor> getFixedRate() {
			return this.fixedRate;
		}
		public List<TaskDescriptor> getCustom() {
			return this.custom;
		}
	}
	/**
	 * Base class for descriptions of a {@link Task}.
	 */
	public abstract static class TaskDescriptor {
		private final TaskType type;
		private final ScheduledTask scheduledTask;
		private final RunnableDescriptor runnable;
		protected TaskDescriptor(ScheduledTask scheduledTask, TaskType type) {
			this.scheduledTask = scheduledTask;
			this.type = type;
			this.runnable = new RunnableDescriptor(scheduledTask.getTask().getRunnable());
		}
		private TaskType getType() {
			return this.type;
		}
		public final RunnableDescriptor getRunnable() {
			return this.runnable;
		}
		public final NextExecution getNextExecution() {
			Instant nextExecution = this.scheduledTask.nextExecution();
			if (nextExecution != null) {
				return new NextExecution(nextExecution);
			}
			return null;
		}
		public final LastExecution getLastExecution() {
			TaskExecutionOutcome lastExecutionOutcome = this.scheduledTask.getTask().getLastExecutionOutcome();
			if (lastExecutionOutcome.status() != Status.NONE) {
				return new LastExecution(lastExecutionOutcome);
			}
			return null;
		}
	}
	public static final class NextExecution {
		private final Instant time;
		public NextExecution(Instant time) {
			this.time = time;
		}
		public Instant getTime() {
			return this.time;
		}
	}
	public static final class LastExecution {
		private final TaskExecutionOutcome lastExecutionOutcome;
		private LastExecution(TaskExecutionOutcome lastExecutionOutcome) {
			this.lastExecutionOutcome = lastExecutionOutcome;
		}
		public Status getStatus() {
			return this.lastExecutionOutcome.status();
		}
		public Instant getTime() {
			return this.lastExecutionOutcome.executionTime();
		}
		public ExceptionInfo getException() {
			Throwable throwable = this.lastExecutionOutcome.throwable();
			if (throwable != null) {
				return new ExceptionInfo(throwable);
			}
			return null;
		}
	}
	public static final class ExceptionInfo {
		private final Throwable throwable;
		private ExceptionInfo(Throwable throwable) {
			this.throwable = throwable;
		}
		public String getType() {
			return this.throwable.getClass().getName();
		}
		public String getMessage() {
			return this.throwable.getMessage();
		}
	}
	private enum TaskType {
		CRON(CronTask.class,
				(scheduledTask) -> new CronTaskDescriptor(scheduledTask, (CronTask) scheduledTask.getTask())),
		FIXED_DELAY(FixedDelayTask.class,
				(scheduledTask) -> new FixedDelayTaskDescriptor(scheduledTask,
						(FixedDelayTask) scheduledTask.getTask())),
		FIXED_RATE(FixedRateTask.class,
				(scheduledTask) -> new FixedRateTaskDescriptor(scheduledTask, (FixedRateTask) scheduledTask.getTask())),
		CUSTOM_TRIGGER(TriggerTask.class, TaskType::describeTriggerTask);
		final Class<?> taskClass;
		final Function<ScheduledTask, TaskDescriptor> describer;
		TaskType(Class<?> taskClass, Function<ScheduledTask, TaskDescriptor> describer) {
			this.taskClass = taskClass;
			this.describer = describer;
		}
		static TaskType forTask(ScheduledTask scheduledTask) {
			for (TaskType taskType : TaskType.values()) {
				if (taskType.taskClass.isInstance(scheduledTask.getTask())) {
					return taskType;
				}
			}
			return null;
		}
		TaskDescriptor createDescriptor(ScheduledTask scheduledTask) {
			return this.describer.apply(scheduledTask);
		}
		private static TaskDescriptor describeTriggerTask(ScheduledTask scheduledTask) {
			TriggerTask triggerTask = (TriggerTask) scheduledTask.getTask();
			Trigger trigger = triggerTask.getTrigger();
			if (trigger instanceof CronTrigger cronTrigger) {
				return new CronTaskDescriptor(scheduledTask, triggerTask, cronTrigger);
			}
			if (trigger instanceof PeriodicTrigger periodicTrigger) {
				if (periodicTrigger.isFixedRate()) {
					return new FixedRateTaskDescriptor(scheduledTask, triggerTask, periodicTrigger);
				}
				return new FixedDelayTaskDescriptor(scheduledTask, triggerTask, periodicTrigger);
			}
			return new CustomTriggerTaskDescriptor(scheduledTask);
		}
	}
	/**
	 * Description of an {@link IntervalTask}.
	 */
	public static class IntervalTaskDescriptor extends TaskDescriptor {
		private final long initialDelay;
		private final long interval;
		protected IntervalTaskDescriptor(ScheduledTask scheduledTask, TaskType type, IntervalTask intervalTask) {
			super(scheduledTask, type);
			this.initialDelay = intervalTask.getInitialDelayDuration().toMillis();
			this.interval = intervalTask.getIntervalDuration().toMillis();
		}
		protected IntervalTaskDescriptor(ScheduledTask scheduledTask, TaskType type, TriggerTask task,
				PeriodicTrigger trigger) {
			super(scheduledTask, type);
			Duration initialDelayDuration = trigger.getInitialDelayDuration();
			this.initialDelay = (initialDelayDuration != null) ? initialDelayDuration.toMillis() : 0;
			this.interval = trigger.getPeriodDuration().toMillis();
		}
		public long getInitialDelay() {
			return this.initialDelay;
		}
		public long getInterval() {
			return this.interval;
		}
	}
	/**
	 * Description of a {@link FixedDelayTask} or a {@link TriggerTask} with a fixed-delay
	 * {@link PeriodicTrigger}.
	 */
	public static final class FixedDelayTaskDescriptor extends IntervalTaskDescriptor {
		private FixedDelayTaskDescriptor(ScheduledTask scheduledTask, FixedDelayTask task) {
			super(scheduledTask, TaskType.FIXED_DELAY, task);
		}
		private FixedDelayTaskDescriptor(ScheduledTask scheduledTask, TriggerTask task, PeriodicTrigger trigger) {
			super(scheduledTask, TaskType.FIXED_DELAY, task, trigger);
		}
	}
	/**
	 * Description of a {@link FixedRateTask} or a {@link TriggerTask} with a fixed-rate
	 * {@link PeriodicTrigger}.
	 */
	public static final class FixedRateTaskDescriptor extends IntervalTaskDescriptor {
		private FixedRateTaskDescriptor(ScheduledTask scheduledTask, FixedRateTask task) {
			super(scheduledTask, TaskType.FIXED_RATE, task);
		}
		private FixedRateTaskDescriptor(ScheduledTask scheduledTask, TriggerTask task, PeriodicTrigger trigger) {
			super(scheduledTask, TaskType.FIXED_RATE, task, trigger);
		}
	}
	/**
	 * Description of a {@link CronTask} or a {@link TriggerTask} with a
	 * {@link CronTrigger}.
	 */
	public static final class CronTaskDescriptor extends TaskDescriptor {
		private final String expression;
		private CronTaskDescriptor(ScheduledTask scheduledTask, CronTask cronTask) {
			super(scheduledTask, TaskType.CRON);
			this.expression = cronTask.getExpression();
		}
		private CronTaskDescriptor(ScheduledTask scheduledTask, TriggerTask triggerTask, CronTrigger trigger) {
			super(scheduledTask, TaskType.CRON);
			this.expression = trigger.getExpression();
		}
		public String getExpression() {
			return this.expression;
		}
	}
	/**
	 * Description of a {@link TriggerTask} with a custom {@link Trigger}.
	 */
	public static final class CustomTriggerTaskDescriptor extends TaskDescriptor {
		private final String trigger;
		private CustomTriggerTaskDescriptor(ScheduledTask scheduledTask) {
			super(scheduledTask, TaskType.CUSTOM_TRIGGER);
			TriggerTask triggerTask = (TriggerTask) scheduledTask.getTask();
			this.trigger = triggerTask.getTrigger().toString();
		}
		public String getTrigger() {
			return this.trigger;
		}
	}
	/**
	 * Description of a {@link Task Task"s} {@link Runnable}.
	 */
	public static final class RunnableDescriptor {
		private final String target;
		private RunnableDescriptor(Runnable runnable) {
			this.target = runnable.toString();
		}
		public String getTarget() {
			return this.target;
		}
	}
	static class ScheduledTasksEndpointRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), FixedRateTaskDescriptor.class,
					FixedDelayTaskDescriptor.class, CronTaskDescriptor.class, CustomTriggerTaskDescriptor.class);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.scheduling;
/*
package org.springframework.boot.actuate.jdbc;
/**
public class DataSourceHealthIndicator extends AbstractHealthIndicator implements InitializingBean {
	private DataSource dataSource;
	private String query;
	private JdbcTemplate jdbcTemplate;
	/**
	 * Create a new {@link DataSourceHealthIndicator} instance.
	 */
	public DataSourceHealthIndicator() {
		this(null, null);
	}
	/**
	 * Create a new {@link DataSourceHealthIndicator} using the specified
	 * {@link DataSource}.
	 * @param dataSource the data source
	 */
	public DataSourceHealthIndicator(DataSource dataSource) {
		this(dataSource, null);
	}
	/**
	 * Create a new {@link DataSourceHealthIndicator} using the specified
	 * {@link DataSource} and validation query.
	 * @param dataSource the data source
	 * @param query the validation query to use (can be {@code null})
	 */
	public DataSourceHealthIndicator(DataSource dataSource, String query) {
		super('DataSource health check failed');
		this.dataSource = dataSource;
		this.query = query;
		this.jdbcTemplate = (dataSource != null) ? new JdbcTemplate(dataSource) : null;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		Assert.state(this.dataSource != null, 'DataSource for DataSourceHealthIndicator must be specified');
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		if (this.dataSource == null) {
			builder.up().withDetail('database', 'unknown');
		}
		else {
			doDataSourceHealthCheck(builder);
		}
	}
	private void doDataSourceHealthCheck(Health.Builder builder) {
		builder.up().withDetail('database', getProduct());
		String validationQuery = this.query;
		if (StringUtils.hasText(validationQuery)) {
			builder.withDetail('validationQuery', validationQuery);
			// Avoid calling getObject as it breaks MySQL on Java 7 and later
			List<Object> results = this.jdbcTemplate.query(validationQuery, new SingleColumnRowMapper());
			Object result = DataAccessUtils.requiredSingleResult(results);
			builder.withDetail('result', result);
		}
		else {
			builder.withDetail('validationQuery', 'isValid()');
			boolean valid = isConnectionValid();
			builder.status((valid) ? Status.UP : Status.DOWN);
		}
	}
	private String getProduct() {
		return this.jdbcTemplate.execute((ConnectionCallback<String>) this::getProduct);
	}
	private String getProduct(Connection connection) throws SQLException {
		return connection.getMetaData().getDatabaseProductName();
	}
	private Boolean isConnectionValid() {
		return this.jdbcTemplate.execute((ConnectionCallback<Boolean>) this::isConnectionValid);
	}
	private Boolean isConnectionValid(Connection connection) throws SQLException {
		return connection.isValid(0);
	}
	/**
	 * Set the {@link DataSource} to use.
	 * @param dataSource the data source
	 */
	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
		this.jdbcTemplate = new JdbcTemplate(dataSource);
	}
	/**
	 * Set a specific validation query to use to validate a connection. If none is set, a
	 * validation based on {@link Connection#isValid(int)} is used.
	 * @param query the validation query to use
	 */
	public void setQuery(String query) {
		this.query = query;
	}
	/**
	 * Return the validation query or {@code null}.
	 * @return the query
	 */
	public String getQuery() {
		return this.query;
	}
	/**
	 * {@link RowMapper} that expects and returns results from a single column.
	 */
	private static final class SingleColumnRowMapper implements RowMapper<Object> {
		@Override
		public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
			ResultSetMetaData metaData = rs.getMetaData();
			int columns = metaData.getColumnCount();
			if (columns != 1) {
				throw new IncorrectResultSetColumnCountException(1, columns);
			}
			return JdbcUtils.getResultSetValue(rs, 1);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.jdbc;
/*
/**
package org.springframework.boot.actuate.jms;
/*
package org.springframework.boot.actuate.jms;
/**
public class JmsHealthIndicator extends AbstractHealthIndicator {
	private final Log logger = LogFactory.getLog(JmsHealthIndicator.class);
	private final ConnectionFactory connectionFactory;
	public JmsHealthIndicator(ConnectionFactory connectionFactory) {
		super('JMS health check failed');
		this.connectionFactory = connectionFactory;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		try (Connection connection = this.connectionFactory.createConnection()) {
			new MonitoredConnection(connection).start();
			builder.up().withDetail('provider', connection.getMetaData().getJMSProviderName());
		}
	}
	private final class MonitoredConnection {
		private final CountDownLatch latch = new CountDownLatch(1);
		private final Connection connection;
		MonitoredConnection(Connection connection) {
			this.connection = connection;
		}
		void start() throws JMSException {
			new Thread(() -> {
				try {
					if (!this.latch.await(5, TimeUnit.SECONDS)) {
						JmsHealthIndicator.this.logger
							.warn('Connection failed to start within 5 seconds and will be closed.');
						closeConnection();
					}
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
			}, 'jms-health-indicator').start();
			this.connection.start();
			this.latch.countDown();
		}
		private void closeConnection() {
			try {
				this.connection.close();
			}
			catch (Exception ex) {
				// Continue
			}
		}
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
@EndpointWebExtension(endpoint = ConfigurationPropertiesReportEndpoint.class)
public class ConfigurationPropertiesReportEndpointWebExtension {
	private final ConfigurationPropertiesReportEndpoint delegate;
	private final Show showValues;
	private final Set<String> roles;
	public ConfigurationPropertiesReportEndpointWebExtension(ConfigurationPropertiesReportEndpoint delegate,
			Show showValues, Set<String> roles) {
		this.delegate = delegate;
		this.showValues = showValues;
		this.roles = roles;
	}
	@ReadOperation
	public ConfigurationPropertiesDescriptor configurationProperties(SecurityContext securityContext) {
		boolean showUnsanitized = this.showValues.isShown(securityContext, this.roles);
		return this.delegate.getConfigurationProperties(showUnsanitized);
	}
	@ReadOperation
	public WebEndpointResponse<ConfigurationPropertiesDescriptor> configurationPropertiesWithPrefix(
			SecurityContext securityContext, @Selector String prefix) {
		boolean showUnsanitized = this.showValues.isShown(securityContext, this.roles);
		ConfigurationPropertiesDescriptor configurationProperties = this.delegate.getConfigurationProperties(prefix,
				showUnsanitized);
		boolean foundMatchingBeans = configurationProperties.getContexts()
			.values()
			.stream()
			.anyMatch((context) -> !context.getBeans().isEmpty());
		return (foundMatchingBeans) ? new WebEndpointResponse<>(configurationProperties, WebEndpointResponse.STATUS_OK)
				: new WebEndpointResponse<>(WebEndpointResponse.STATUS_NOT_FOUND);
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
@Endpoint(id = 'configprops')
public class ConfigurationPropertiesReportEndpoint implements ApplicationContextAware {
	private static final String CONFIGURATION_PROPERTIES_FILTER_ID = 'configurationPropertiesFilter';
	private final Sanitizer sanitizer;
	private final Show showValues;
	private ApplicationContext context;
	private ObjectMapper objectMapper;
	public ConfigurationPropertiesReportEndpoint(Iterable<SanitizingFunction> sanitizingFunctions, Show showValues) {
		this.sanitizer = new Sanitizer(sanitizingFunctions);
		this.showValues = showValues;
	}
	@Override
	public void setApplicationContext(ApplicationContext context) throws BeansException {
		this.context = context;
	}
	@ReadOperation
	public ConfigurationPropertiesDescriptor configurationProperties() {
		boolean showUnsanitized = this.showValues.isShown(true);
		return getConfigurationProperties(showUnsanitized);
	}
	ConfigurationPropertiesDescriptor getConfigurationProperties(boolean showUnsanitized) {
		return getConfigurationProperties(this.context, (bean) -> true, showUnsanitized);
	}
	@ReadOperation
	public ConfigurationPropertiesDescriptor configurationPropertiesWithPrefix(@Selector String prefix) {
		boolean showUnsanitized = this.showValues.isShown(true);
		return getConfigurationProperties(prefix, showUnsanitized);
	}
	ConfigurationPropertiesDescriptor getConfigurationProperties(String prefix, boolean showUnsanitized) {
		return getConfigurationProperties(this.context, (bean) -> bean.getAnnotation().prefix().startsWith(prefix),
				showUnsanitized);
	}
	private ConfigurationPropertiesDescriptor getConfigurationProperties(ApplicationContext context,
			Predicate<ConfigurationPropertiesBean> beanFilterPredicate, boolean showUnsanitized) {
		ObjectMapper mapper = getObjectMapper();
		Map<String, ContextConfigurationPropertiesDescriptor> contexts = new HashMap<>();
		ApplicationContext target = context;
		while (target != null) {
			contexts.put(target.getId(), describeBeans(mapper, target, beanFilterPredicate, showUnsanitized));
			target = target.getParent();
		}
		return new ConfigurationPropertiesDescriptor(contexts);
	}
	private ObjectMapper getObjectMapper() {
		if (this.objectMapper == null) {
			JsonMapper.Builder builder = JsonMapper.builder();
			configureJsonMapper(builder);
			this.objectMapper = builder.build();
		}
		return this.objectMapper;
	}
	/**
	 * Configure Jackson"s {@link JsonMapper} to be used to serialize the
	 * {@link ConfigurationProperties @ConfigurationProperties} objects into a {@link Map}
	 * structure.
	 * @param builder the json mapper builder
	 * @since 2.6.0
	 */
	protected void configureJsonMapper(JsonMapper.Builder builder) {
		builder.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
		builder.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
		builder.configure(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS, false);
		builder.configure(MapperFeature.USE_STD_BEAN_NAMING, true);
		builder.serializationInclusion(Include.NON_NULL);
		applyConfigurationPropertiesFilter(builder);
		applySerializationModifier(builder);
		builder.addModule(new JavaTimeModule());
		builder.addModule(new ConfigurationPropertiesModule());
	}
	private void applyConfigurationPropertiesFilter(JsonMapper.Builder builder) {
		builder.annotationIntrospector(new ConfigurationPropertiesAnnotationIntrospector());
		builder
			.filterProvider(new SimpleFilterProvider().setDefaultFilter(new ConfigurationPropertiesPropertyFilter()));
	}
	/**
	 * Ensure only bindable and non-cyclic bean properties are reported.
	 * @param builder the JsonMapper builder
	 */
	private void applySerializationModifier(JsonMapper.Builder builder) {
		SerializerFactory factory = BeanSerializerFactory.instance
			.withSerializerModifier(new GenericSerializerModifier());
		builder.serializerFactory(factory);
	}
	private ContextConfigurationPropertiesDescriptor describeBeans(ObjectMapper mapper, ApplicationContext context,
			Predicate<ConfigurationPropertiesBean> beanFilterPredicate, boolean showUnsanitized) {
		Map<String, ConfigurationPropertiesBean> beans = ConfigurationPropertiesBean.getAll(context);
		Map<String, ConfigurationPropertiesBeanDescriptor> descriptors = beans.values()
			.stream()
			.filter(beanFilterPredicate)
			.collect(Collectors.toMap(ConfigurationPropertiesBean::getName,
					(bean) -> describeBean(mapper, bean, showUnsanitized)));
		return new ContextConfigurationPropertiesDescriptor(descriptors,
				(context.getParent() != null) ? context.getParent().getId() : null);
	}
	private ConfigurationPropertiesBeanDescriptor describeBean(ObjectMapper mapper, ConfigurationPropertiesBean bean,
			boolean showUnsanitized) {
		String prefix = bean.getAnnotation().prefix();
		Map<String, Object> serialized = safeSerialize(mapper, bean.getInstance(), prefix);
		Map<String, Object> properties = sanitize(prefix, serialized, showUnsanitized);
		Map<String, Object> inputs = getInputs(prefix, serialized, showUnsanitized);
		return new ConfigurationPropertiesBeanDescriptor(prefix, properties, inputs);
	}
	/**
	 * Cautiously serialize the bean to a map (returning a map with an error message
	 * instead of throwing an exception if there is a problem).
	 * @param mapper the object mapper
	 * @param bean the source bean
	 * @param prefix the prefix
	 * @return the serialized instance
	 */
	@SuppressWarnings({ 'unchecked' })
	private Map<String, Object> safeSerialize(ObjectMapper mapper, Object bean, String prefix) {
		try {
			return new HashMap<>(mapper.convertValue(bean, Map.class));
		}
		catch (Exception ex) {
			return new HashMap<>(Collections.singletonMap('error', 'Cannot serialize "' + prefix + '"'));
		}
	}
	/**
	 * Sanitize all unwanted configuration properties to avoid leaking of sensitive
	 * information.
	 * @param prefix the property prefix
	 * @param map the source map
	 * @param showUnsanitized whether to show the unsanitized values
	 * @return the sanitized map
	 */
	@SuppressWarnings('unchecked')
	private Map<String, Object> sanitize(String prefix, Map<String, Object> map, boolean showUnsanitized) {
		map.forEach((key, value) -> {
			String qualifiedKey = getQualifiedKey(prefix, key);
			if (value instanceof Map) {
				map.put(key, sanitize(qualifiedKey, (Map<String, Object>) value, showUnsanitized));
			}
			else if (value instanceof List) {
				map.put(key, sanitize(qualifiedKey, (List<Object>) value, showUnsanitized));
			}
			else {
				map.put(key, sanitizeWithPropertySourceIfPresent(qualifiedKey, value, showUnsanitized));
			}
		});
		return map;
	}
	private Object sanitizeWithPropertySourceIfPresent(String qualifiedKey, Object value, boolean showUnsanitized) {
		ConfigurationPropertyName currentName = getCurrentName(qualifiedKey);
		ConfigurationProperty candidate = getCandidate(currentName);
		PropertySource<?> propertySource = getPropertySource(candidate);
		if (propertySource != null) {
			SanitizableData data = new SanitizableData(propertySource, qualifiedKey, value);
			return this.sanitizer.sanitize(data, showUnsanitized);
		}
		SanitizableData data = new SanitizableData(null, qualifiedKey, value);
		return this.sanitizer.sanitize(data, showUnsanitized);
	}
	private PropertySource<?> getPropertySource(ConfigurationProperty configurationProperty) {
		if (configurationProperty == null) {
			return null;
		}
		ConfigurationPropertySource source = configurationProperty.getSource();
		Object underlyingSource = (source != null) ? source.getUnderlyingSource() : null;
		return (underlyingSource instanceof PropertySource<?>) ? (PropertySource<?>) underlyingSource : null;
	}
	private ConfigurationPropertyName getCurrentName(String qualifiedKey) {
		return ConfigurationPropertyName.adapt(qualifiedKey, ".");
	}
	private ConfigurationProperty getCandidate(ConfigurationPropertyName currentName) {
		BoundConfigurationProperties bound = BoundConfigurationProperties.get(this.context);
		if (bound == null) {
			return null;
		}
		ConfigurationProperty candidate = bound.get(currentName);
		if (candidate == null && currentName.isLastElementIndexed()) {
			candidate = bound.get(currentName.chop(currentName.getNumberOfElements() - 1));
		}
		return candidate;
	}
	@SuppressWarnings('unchecked')
	private List<Object> sanitize(String prefix, List<Object> list, boolean showUnsanitized) {
		List<Object> sanitized = new ArrayList<>();
		int index = 0;
		for (Object item : list) {
			String name = prefix + '[' + index++ + ']';
			if (item instanceof Map) {
				sanitized.add(sanitize(name, (Map<String, Object>) item, showUnsanitized));
			}
			else if (item instanceof List) {
				sanitized.add(sanitize(name, (List<Object>) item, showUnsanitized));
			}
			else {
				sanitized.add(sanitizeWithPropertySourceIfPresent(name, item, showUnsanitized));
			}
		}
		return sanitized;
	}
	@SuppressWarnings('unchecked')
	private Map<String, Object> getInputs(String prefix, Map<String, Object> map, boolean showUnsanitized) {
		Map<String, Object> augmented = new LinkedHashMap<>(map);
		map.forEach((key, value) -> {
			String qualifiedKey = getQualifiedKey(prefix, key);
			if (value instanceof Map) {
				augmented.put(key, getInputs(qualifiedKey, (Map<String, Object>) value, showUnsanitized));
			}
			else if (value instanceof List) {
				augmented.put(key, getInputs(qualifiedKey, (List<Object>) value, showUnsanitized));
			}
			else {
				augmented.put(key, applyInput(qualifiedKey, showUnsanitized));
			}
		});
		return augmented;
	}
	@SuppressWarnings('unchecked')
	private List<Object> getInputs(String prefix, List<Object> list, boolean showUnsanitized) {
		List<Object> augmented = new ArrayList<>();
		int index = 0;
		for (Object item : list) {
			String name = prefix + '[' + index++ + ']';
			if (item instanceof Map) {
				augmented.add(getInputs(name, (Map<String, Object>) item, showUnsanitized));
			}
			else if (item instanceof List) {
				augmented.add(getInputs(name, (List<Object>) item, showUnsanitized));
			}
			else {
				augmented.add(applyInput(name, showUnsanitized));
			}
		}
		return augmented;
	}
	private Map<String, Object> applyInput(String qualifiedKey, boolean showUnsanitized) {
		ConfigurationPropertyName currentName = getCurrentName(qualifiedKey);
		ConfigurationProperty candidate = getCandidate(currentName);
		PropertySource<?> propertySource = getPropertySource(candidate);
		if (propertySource != null) {
			Object value = stringifyIfNecessary(candidate.getValue());
			SanitizableData data = new SanitizableData(propertySource, currentName.toString(), value);
			return getInput(candidate, this.sanitizer.sanitize(data, showUnsanitized));
		}
		return Collections.emptyMap();
	}
	private Map<String, Object> getInput(ConfigurationProperty candidate, Object sanitizedValue) {
		Map<String, Object> input = new LinkedHashMap<>();
		Origin origin = Origin.from(candidate);
		List<Origin> originParents = Origin.parentsFrom(candidate);
		input.put('value', sanitizedValue);
		input.put('origin', (origin != null) ? origin.toString() : 'none');
		if (!originParents.isEmpty()) {
			input.put('originParents', originParents.stream().map(Object::toString).toArray(String[]::new));
		}
		return input;
	}
	private Object stringifyIfNecessary(Object value) {
		if (value == null || ClassUtils.isPrimitiveOrWrapper(value.getClass()) || value instanceof String) {
			return value;
		}
		if (CharSequence.class.isAssignableFrom(value.getClass())) {
			return value.toString();
		}
		return 'Complex property value ' + value.getClass().getName();
	}
	private String getQualifiedKey(String prefix, String key) {
		return (prefix.isEmpty() ? prefix : prefix + '.') + key;
	}
	/**
	 * Extension to {@link JacksonAnnotationIntrospector} to suppress CGLIB generated bean
	 * properties.
	 */
	private static final class ConfigurationPropertiesAnnotationIntrospector extends JacksonAnnotationIntrospector {
		@Override
		public Object findFilterId(Annotated a) {
			Object id = super.findFilterId(a);
			if (id == null) {
				id = CONFIGURATION_PROPERTIES_FILTER_ID;
			}
			return id;
		}
	}
	/**
	 * {@link SimpleBeanPropertyFilter} for serialization of
	 * {@link ConfigurationProperties @ConfigurationProperties} beans. The filter hides:
	 *
	 * <ul>
	 * <li>Properties that have a name starting with "$$".
	 * <li>Properties that are self-referential.
	 * <li>Properties that throw an exception when retrieving their value.
	 * </ul>
	 */
	private static final class ConfigurationPropertiesPropertyFilter extends SimpleBeanPropertyFilter {
		private static final Log logger = LogFactory.getLog(ConfigurationPropertiesPropertyFilter.class);
		@Override
		protected boolean include(BeanPropertyWriter writer) {
			return include(writer.getFullName().getSimpleName());
		}
		@Override
		protected boolean include(PropertyWriter writer) {
			return include(writer.getFullName().getSimpleName());
		}
		private boolean include(String name) {
			return !name.startsWith('$$');
		}
		@Override
		public void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider provider,
				PropertyWriter writer) throws Exception {
			if (writer instanceof BeanPropertyWriter beanPropertyWriter) {
				try {
					if (pojo == beanPropertyWriter.get(pojo)) {
						if (logger.isDebugEnabled()) {
							logger.debug('Skipping "' + writer.getFullName() + '" on "' + pojo.getClass().getName()
									+ '" as it is self-referential');
						}
						return;
					}
				}
				catch (Exception ex) {
					if (logger.isDebugEnabled()) {
						logger.debug('Skipping "' + writer.getFullName() + '" on "' + pojo.getClass().getName()
								+ '" as an exception was thrown when retrieving its value', ex);
					}
					return;
				}
			}
			super.serializeAsField(pojo, jgen, provider, writer);
		}
	}
	/**
	 * {@link SimpleModule} for configuring the serializer.
	 */
	private static final class ConfigurationPropertiesModule extends SimpleModule {
		private ConfigurationPropertiesModule() {
			addSerializer(DataSize.class, ToStringSerializer.instance);
		}
	}
	/**
	 * {@link BeanSerializerModifier} to return only relevant configuration properties.
	 */
	protected static class GenericSerializerModifier extends BeanSerializerModifier {
		private static final ParameterNameDiscoverer PARAMETER_NAME_DISCOVERER = new DefaultParameterNameDiscoverer();
		@Override
		public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc,
				List<BeanPropertyWriter> beanProperties) {
			List<BeanPropertyWriter> result = new ArrayList<>();
			Class<?> beanClass = beanDesc.getType().getRawClass();
			Bindable<?> bindable = Bindable.of(ClassUtils.getUserClass(beanClass));
			Constructor<?> bindConstructor = BindConstructorProvider.DEFAULT.getBindConstructor(bindable, false);
			for (BeanPropertyWriter writer : beanProperties) {
				if (isCandidate(beanDesc, writer, bindConstructor)) {
					result.add(writer);
				}
			}
			return result;
		}
		private boolean isCandidate(BeanDescription beanDesc, BeanPropertyWriter writer, Constructor<?> constructor) {
			if (constructor != null) {
				Parameter[] parameters = constructor.getParameters();
				String[] names = PARAMETER_NAME_DISCOVERER.getParameterNames(constructor);
				if (names == null) {
					names = new String[parameters.length];
				}
				for (int i = 0; i < parameters.length; i++) {
					String name = MergedAnnotations.from(parameters[i])
						.get(Name.class)
						.getValue(MergedAnnotation.VALUE, String.class)
						.orElse((names[i] != null) ? names[i] : parameters[i].getName());
					if (name.equals(writer.getName())) {
						return true;
					}
				}
			}
			return isReadable(beanDesc, writer);
		}
		private boolean isReadable(BeanDescription beanDesc, BeanPropertyWriter writer) {
			Class<?> parentType = beanDesc.getType().getRawClass();
			Class<?> type = writer.getType().getRawClass();
			AnnotatedMethod setter = findSetter(beanDesc, writer);
			// If there"s a setter, we assume it"s OK to report on the value,
			// similarly, if there"s no setter but the package names match, we assume
			// that it is a nested class used solely for binding to config props, so it
			// should be kosher. Lists and Maps are also auto-detected by default since
			// that"s what the metadata generator does. This filter is not used if there
			// is JSON metadata for the property, so it"s mainly for user-defined beans.
			return (setter != null) || ClassUtils.getPackageName(parentType).equals(ClassUtils.getPackageName(type))
					|| Map.class.isAssignableFrom(type) || Collection.class.isAssignableFrom(type);
		}
		private AnnotatedMethod findSetter(BeanDescription beanDesc, BeanPropertyWriter writer) {
			String name = 'set' + determineAccessorSuffix(writer.getName());
			Class<?> type = writer.getType().getRawClass();
			AnnotatedMethod setter = beanDesc.findMethod(name, new Class<?>[] { type });
			// The enabled property of endpoints returns a boolean primitive but is set
			// using a Boolean class
			if (setter == null && type.equals(Boolean.TYPE)) {
				setter = beanDesc.findMethod(name, new Class<?>[] { Boolean.class });
			}
			return setter;
		}
		/**
		 * Determine the accessor suffix of the specified {@code propertyName}, see
		 * section 8.8 'Capitalization of inferred names' of the JavaBean specs for more
		 * details.
		 * @param propertyName the property name to turn into an accessor suffix
		 * @return the accessor suffix for {@code propertyName}
		 */
		private String determineAccessorSuffix(String propertyName) {
			if (propertyName.length() > 1 && Character.isUpperCase(propertyName.charAt(1))) {
				return propertyName;
			}
			return StringUtils.capitalize(propertyName);
		}
	}
	/**
	 * Description of an application"s
	 * {@link ConfigurationProperties @ConfigurationProperties} beans.
	 */
	public static final class ConfigurationPropertiesDescriptor implements OperationResponseBody {
		private final Map<String, ContextConfigurationPropertiesDescriptor> contexts;
		ConfigurationPropertiesDescriptor(Map<String, ContextConfigurationPropertiesDescriptor> contexts) {
			this.contexts = contexts;
		}
		public Map<String, ContextConfigurationPropertiesDescriptor> getContexts() {
			return this.contexts;
		}
	}
	/**
	 * Description of an application context"s
	 * {@link ConfigurationProperties @ConfigurationProperties} beans.
	 */
	public static final class ContextConfigurationPropertiesDescriptor {
		private final Map<String, ConfigurationPropertiesBeanDescriptor> beans;
		private final String parentId;
		private ContextConfigurationPropertiesDescriptor(Map<String, ConfigurationPropertiesBeanDescriptor> beans,
				String parentId) {
			this.beans = beans;
			this.parentId = parentId;
		}
		public Map<String, ConfigurationPropertiesBeanDescriptor> getBeans() {
			return this.beans;
		}
		public String getParentId() {
			return this.parentId;
		}
	}
	/**
	 * Description of a {@link ConfigurationProperties @ConfigurationProperties} bean.
	 */
	public static final class ConfigurationPropertiesBeanDescriptor {
		private final String prefix;
		private final Map<String, Object> properties;
		private final Map<String, Object> inputs;
		private ConfigurationPropertiesBeanDescriptor(String prefix, Map<String, Object> properties,
				Map<String, Object> inputs) {
			this.prefix = prefix;
			this.properties = properties;
			this.inputs = inputs;
		}
		public String getPrefix() {
			return this.prefix;
		}
		public Map<String, Object> getProperties() {
			return this.properties;
		}
		public Map<String, Object> getInputs() {
			return this.inputs;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.context.properties;
/*
package org.springframework.boot.actuate.context;
/**
@Endpoint(id = 'shutdown', defaultAccess = Access.NONE)
public class ShutdownEndpoint implements ApplicationContextAware {
	private ConfigurableApplicationContext context;
	@WriteOperation
	public ShutdownDescriptor shutdown() {
		if (this.context == null) {
			return ShutdownDescriptor.NO_CONTEXT;
		}
		try {
			return ShutdownDescriptor.DEFAULT;
		}
		finally {
			Thread thread = new Thread(this::performShutdown);
			thread.setContextClassLoader(getClass().getClassLoader());
			thread.start();
		}
	}
	private void performShutdown() {
		try {
			Thread.sleep(500L);
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
		this.context.close();
	}
	@Override
	public void setApplicationContext(ApplicationContext context) throws BeansException {
		if (context instanceof ConfigurableApplicationContext configurableContext) {
			this.context = configurableContext;
		}
	}
	/**
	 * Description of the shutdown.
	 */
	public static class ShutdownDescriptor implements OperationResponseBody {
		private static final ShutdownDescriptor DEFAULT = new ShutdownDescriptor('Shutting down, bye...');
		private static final ShutdownDescriptor NO_CONTEXT = new ShutdownDescriptor('No context to shutdown.');
		private final String message;
		ShutdownDescriptor(String message) {
			this.message = message;
		}
		public String getMessage() {
			return this.message;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.context;
/*
package org.springframework.boot.actuate.quartz;
/**
@EndpointWebExtension(endpoint = QuartzEndpoint.class)
@ImportRuntimeHints(QuartzEndpointWebExtensionRuntimeHints.class)
public class QuartzEndpointWebExtension {
	private final QuartzEndpoint delegate;
	private final Show showValues;
	private final Set<String> roles;
	public QuartzEndpointWebExtension(QuartzEndpoint delegate, Show showValues, Set<String> roles) {
		this.delegate = delegate;
		this.showValues = showValues;
		this.roles = roles;
	}
	@ReadOperation
	public WebEndpointResponse<QuartzGroupsDescriptor> quartzJobOrTriggerGroups(@Selector String jobsOrTriggers)
			throws SchedulerException {
		return handle(jobsOrTriggers, this.delegate::quartzJobGroups, this.delegate::quartzTriggerGroups);
	}
	@ReadOperation
	public WebEndpointResponse<Object> quartzJobOrTriggerGroup(@Selector String jobsOrTriggers, @Selector String group)
			throws SchedulerException {
		return handle(jobsOrTriggers, () -> this.delegate.quartzJobGroupSummary(group),
				() -> this.delegate.quartzTriggerGroupSummary(group));
	}
	@ReadOperation
	public WebEndpointResponse<Object> quartzJobOrTrigger(SecurityContext securityContext,
			@Selector String jobsOrTriggers, @Selector String group, @Selector String name) throws SchedulerException {
		boolean showUnsanitized = this.showValues.isShown(securityContext, this.roles);
		return handle(jobsOrTriggers, () -> this.delegate.quartzJob(group, name, showUnsanitized),
				() -> this.delegate.quartzTrigger(group, name, showUnsanitized));
	}
	private <T> WebEndpointResponse<T> handle(String jobsOrTriggers, ResponseSupplier<T> jobAction,
			ResponseSupplier<T> triggerAction) throws SchedulerException {
		if ('jobs'.equals(jobsOrTriggers)) {
			return handleNull(jobAction.get());
		}
		if ('triggers'.equals(jobsOrTriggers)) {
			return handleNull(triggerAction.get());
		}
		return new WebEndpointResponse<>(WebEndpointResponse.STATUS_BAD_REQUEST);
	}
	private <T> WebEndpointResponse<T> handleNull(T value) {
		if (value != null) {
			return new WebEndpointResponse<>(value);
		}
		return new WebEndpointResponse<>(WebEndpointResponse.STATUS_NOT_FOUND);
	}
	@FunctionalInterface
	private interface ResponseSupplier<T> {
		T get() throws SchedulerException;
	}
	static class QuartzEndpointWebExtensionRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), QuartzGroupsDescriptor.class,
					QuartzJobDetailsDescriptor.class, QuartzJobGroupSummaryDescriptor.class,
					QuartzTriggerGroupSummaryDescriptor.class);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.quartz;
/*
package org.springframework.boot.actuate.quartz;
/**
@Endpoint(id = 'quartz')
public class QuartzEndpoint {
	private static final Comparator<Trigger> TRIGGER_COMPARATOR = Comparator
		.comparing(Trigger::getNextFireTime, Comparator.nullsLast(Comparator.naturalOrder()))
		.thenComparing(Comparator.comparingInt(Trigger::getPriority).reversed());
	private final Scheduler scheduler;
	private final Sanitizer sanitizer;
	public QuartzEndpoint(Scheduler scheduler, Iterable<SanitizingFunction> sanitizingFunctions) {
		Assert.notNull(scheduler, 'Scheduler must not be null');
		this.scheduler = scheduler;
		this.sanitizer = new Sanitizer(sanitizingFunctions);
	}
	/**
	 * Return the available job and trigger group names.
	 * @return a report of the available group names
	 * @throws SchedulerException if retrieving the information from the scheduler failed
	 */
	@ReadOperation
	public QuartzDescriptor quartzReport() throws SchedulerException {
		return new QuartzDescriptor(new GroupNamesDescriptor(this.scheduler.getJobGroupNames()),
				new GroupNamesDescriptor(this.scheduler.getTriggerGroupNames()));
	}
	/**
	 * Return the available job names, identified by group name.
	 * @return the available job names
	 * @throws SchedulerException if retrieving the information from the scheduler failed
	 */
	public QuartzGroupsDescriptor quartzJobGroups() throws SchedulerException {
		Map<String, Object> result = new LinkedHashMap<>();
		for (String groupName : this.scheduler.getJobGroupNames()) {
			List<String> jobs = this.scheduler.getJobKeys(GroupMatcher.jobGroupEquals(groupName))
				.stream()
				.map(Key::getName)
				.toList();
			result.put(groupName, Collections.singletonMap('jobs', jobs));
		}
		return new QuartzGroupsDescriptor(result);
	}
	/**
	 * Return the available trigger names, identified by group name.
	 * @return the available trigger names
	 * @throws SchedulerException if retrieving the information from the scheduler failed
	 */
	public QuartzGroupsDescriptor quartzTriggerGroups() throws SchedulerException {
		Map<String, Object> result = new LinkedHashMap<>();
		Set<String> pausedTriggerGroups = this.scheduler.getPausedTriggerGroups();
		for (String groupName : this.scheduler.getTriggerGroupNames()) {
			Map<String, Object> groupDetails = new LinkedHashMap<>();
			groupDetails.put('paused', pausedTriggerGroups.contains(groupName));
			groupDetails.put('triggers',
					this.scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(groupName))
						.stream()
						.map(Key::getName)
						.toList());
			result.put(groupName, groupDetails);
		}
		return new QuartzGroupsDescriptor(result);
	}
	/**
	 * Return a summary of the jobs group with the specified name or {@code null} if no
	 * such group exists.
	 * @param group the name of a jobs group
	 * @return a summary of the jobs in the given {@code group}
	 * @throws SchedulerException if retrieving the information from the scheduler failed
	 */
	public QuartzJobGroupSummaryDescriptor quartzJobGroupSummary(String group) throws SchedulerException {
		List<JobDetail> jobs = findJobsByGroup(group);
		if (jobs.isEmpty() && !this.scheduler.getJobGroupNames().contains(group)) {
			return null;
		}
		Map<String, QuartzJobSummaryDescriptor> result = new LinkedHashMap<>();
		for (JobDetail job : jobs) {
			result.put(job.getKey().getName(), QuartzJobSummaryDescriptor.of(job));
		}
		return new QuartzJobGroupSummaryDescriptor(group, result);
	}
	private List<JobDetail> findJobsByGroup(String group) throws SchedulerException {
		List<JobDetail> jobs = new ArrayList<>();
		Set<JobKey> jobKeys = this.scheduler.getJobKeys(GroupMatcher.jobGroupEquals(group));
		for (JobKey jobKey : jobKeys) {
			jobs.add(this.scheduler.getJobDetail(jobKey));
		}
		return jobs;
	}
	/**
	 * Return a summary of the triggers group with the specified name or {@code null} if
	 * no such group exists.
	 * @param group the name of a triggers group
	 * @return a summary of the triggers in the given {@code group}
	 * @throws SchedulerException if retrieving the information from the scheduler failed
	 */
	public QuartzTriggerGroupSummaryDescriptor quartzTriggerGroupSummary(String group) throws SchedulerException {
		List<Trigger> triggers = findTriggersByGroup(group);
		if (triggers.isEmpty() && !this.scheduler.getTriggerGroupNames().contains(group)) {
			return null;
		}
		Map<TriggerType, Map<String, Object>> result = new LinkedHashMap<>();
		triggers.forEach((trigger) -> {
			TriggerDescriptor triggerDescriptor = TriggerDescriptor.of(trigger);
			Map<String, Object> triggerTypes = result.computeIfAbsent(triggerDescriptor.getType(),
					(key) -> new LinkedHashMap<>());
			triggerTypes.put(trigger.getKey().getName(), triggerDescriptor.buildSummary(true));
		});
		boolean paused = this.scheduler.getPausedTriggerGroups().contains(group);
		return new QuartzTriggerGroupSummaryDescriptor(group, paused, result);
	}
	private List<Trigger> findTriggersByGroup(String group) throws SchedulerException {
		List<Trigger> triggers = new ArrayList<>();
		Set<TriggerKey> triggerKeys = this.scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(group));
		for (TriggerKey triggerKey : triggerKeys) {
			triggers.add(this.scheduler.getTrigger(triggerKey));
		}
		return triggers;
	}
	/**
	 * Return the {@link QuartzJobDetailsDescriptor details of the job} identified with
	 * the given group name and job name.
	 * @param groupName the name of the group
	 * @param jobName the name of the job
	 * @param showUnsanitized whether to sanitize values in data map
	 * @return the details of the job or {@code null} if such job does not exist
	 * @throws SchedulerException if retrieving the information from the scheduler failed
	 */
	public QuartzJobDetailsDescriptor quartzJob(String groupName, String jobName, boolean showUnsanitized)
			throws SchedulerException {
		JobKey jobKey = JobKey.jobKey(jobName, groupName);
		JobDetail jobDetail = this.scheduler.getJobDetail(jobKey);
		if (jobDetail != null) {
			List<? extends Trigger> triggers = this.scheduler.getTriggersOfJob(jobKey);
			return new QuartzJobDetailsDescriptor(jobDetail.getKey().getGroup(), jobDetail.getKey().getName(),
					jobDetail.getDescription(), jobDetail.getJobClass().getName(), jobDetail.isDurable(),
					jobDetail.requestsRecovery(), sanitizeJobDataMap(jobDetail.getJobDataMap(), showUnsanitized),
					extractTriggersSummary(triggers));
		}
		return null;
	}
	private static List<Map<String, Object>> extractTriggersSummary(List<? extends Trigger> triggers) {
		List<Trigger> triggersToSort = new ArrayList<>(triggers);
		triggersToSort.sort(TRIGGER_COMPARATOR);
		List<Map<String, Object>> result = new ArrayList<>();
		triggersToSort.forEach((trigger) -> {
			Map<String, Object> triggerSummary = new LinkedHashMap<>();
			triggerSummary.put('group', trigger.getKey().getGroup());
			triggerSummary.put('name', trigger.getKey().getName());
			triggerSummary.putAll(TriggerDescriptor.of(trigger).buildSummary(false));
			result.add(triggerSummary);
		});
		return result;
	}
	/**
	 * Return the details of the trigger identified by the given group name and trigger
	 * name.
	 * @param groupName the name of the group
	 * @param triggerName the name of the trigger
	 * @param showUnsanitized whether to sanitize values in data map
	 * @return the details of the trigger or {@code null} if such trigger does not exist
	 * @throws SchedulerException if retrieving the information from the scheduler failed
	 */
	Map<String, Object> quartzTrigger(String groupName, String triggerName, boolean showUnsanitized)
			throws SchedulerException {
		TriggerKey triggerKey = TriggerKey.triggerKey(triggerName, groupName);
		Trigger trigger = this.scheduler.getTrigger(triggerKey);
		if (trigger == null) {
			return null;
		}
		TriggerState triggerState = this.scheduler.getTriggerState(triggerKey);
		TriggerDescriptor triggerDescriptor = TriggerDescriptor.of(trigger);
		Map<String, Object> jobDataMap = sanitizeJobDataMap(trigger.getJobDataMap(), showUnsanitized);
		return OperationResponseBody.of(triggerDescriptor.buildDetails(triggerState, jobDataMap));
	}
	private static Duration getIntervalDuration(long amount, IntervalUnit unit) {
		return temporalUnit(unit).getDuration().multipliedBy(amount);
	}
	private static LocalTime getLocalTime(TimeOfDay timeOfDay) {
		return (timeOfDay != null) ? LocalTime.of(timeOfDay.getHour(), timeOfDay.getMinute(), timeOfDay.getSecond())
				: null;
	}
	private Map<String, Object> sanitizeJobDataMap(JobDataMap dataMap, boolean showUnsanitized) {
		if (dataMap != null) {
			Map<String, Object> map = new LinkedHashMap<>(dataMap.getWrappedMap());
			map.replaceAll((key, value) -> getSanitizedValue(showUnsanitized, key, value));
			return map;
		}
		return null;
	}
	private Object getSanitizedValue(boolean showUnsanitized, String key, Object value) {
		SanitizableData data = new SanitizableData(null, key, value);
		return this.sanitizer.sanitize(data, showUnsanitized);
	}
	private static TemporalUnit temporalUnit(IntervalUnit unit) {
		return switch (unit) {
			case DAY -> ChronoUnit.DAYS;
			case HOUR -> ChronoUnit.HOURS;
			case MINUTE -> ChronoUnit.MINUTES;
			case MONTH -> ChronoUnit.MONTHS;
			case SECOND -> ChronoUnit.SECONDS;
			case MILLISECOND -> ChronoUnit.MILLIS;
			case WEEK -> ChronoUnit.WEEKS;
			case YEAR -> ChronoUnit.YEARS;
		};
	}
	/**
	 * Description of available job and trigger group names.
	 */
	public static final class QuartzDescriptor implements OperationResponseBody {
		private final GroupNamesDescriptor jobs;
		private final GroupNamesDescriptor triggers;
		QuartzDescriptor(GroupNamesDescriptor jobs, GroupNamesDescriptor triggers) {
			this.jobs = jobs;
			this.triggers = triggers;
		}
		public GroupNamesDescriptor getJobs() {
			return this.jobs;
		}
		public GroupNamesDescriptor getTriggers() {
			return this.triggers;
		}
	}
	/**
	 * Description of group names.
	 */
	public static class GroupNamesDescriptor {
		private final Set<String> groups;
		public GroupNamesDescriptor(List<String> groups) {
			this.groups = new LinkedHashSet<>(groups);
		}
		public Set<String> getGroups() {
			return this.groups;
		}
	}
	/**
	 * Description of each group identified by name.
	 */
	public static class QuartzGroupsDescriptor implements OperationResponseBody {
		private final Map<String, Object> groups;
		public QuartzGroupsDescriptor(Map<String, Object> groups) {
			this.groups = groups;
		}
		public Map<String, Object> getGroups() {
			return this.groups;
		}
	}
	/**
	 * Description of the {@link JobDetail jobs} in a given group.
	 */
	public static final class QuartzJobGroupSummaryDescriptor implements OperationResponseBody {
		private final String group;
		private final Map<String, QuartzJobSummaryDescriptor> jobs;
		private QuartzJobGroupSummaryDescriptor(String group, Map<String, QuartzJobSummaryDescriptor> jobs) {
			this.group = group;
			this.jobs = jobs;
		}
		public String getGroup() {
			return this.group;
		}
		public Map<String, QuartzJobSummaryDescriptor> getJobs() {
			return this.jobs;
		}
	}
	/**
	 * Description of a {@link Job Quartz Job}.
	 */
	public static final class QuartzJobSummaryDescriptor {
		private final String className;
		private QuartzJobSummaryDescriptor(JobDetail job) {
			this.className = job.getJobClass().getName();
		}
		private static QuartzJobSummaryDescriptor of(JobDetail job) {
			return new QuartzJobSummaryDescriptor(job);
		}
		public String getClassName() {
			return this.className;
		}
	}
	/**
	 * Description of a {@link Job Quartz Job}.
	 */
	public static final class QuartzJobDetailsDescriptor implements OperationResponseBody {
		private final String group;
		private final String name;
		private final String description;
		private final String className;
		private final boolean durable;
		private final boolean requestRecovery;
		private final Map<String, Object> data;
		private final List<Map<String, Object>> triggers;
		QuartzJobDetailsDescriptor(String group, String name, String description, String className, boolean durable,
				boolean requestRecovery, Map<String, Object> data, List<Map<String, Object>> triggers) {
			this.group = group;
			this.name = name;
			this.description = description;
			this.className = className;
			this.durable = durable;
			this.requestRecovery = requestRecovery;
			this.data = data;
			this.triggers = triggers;
		}
		public String getGroup() {
			return this.group;
		}
		public String getName() {
			return this.name;
		}
		public String getDescription() {
			return this.description;
		}
		public String getClassName() {
			return this.className;
		}
		public boolean isDurable() {
			return this.durable;
		}
		public boolean isRequestRecovery() {
			return this.requestRecovery;
		}
		public Map<String, Object> getData() {
			return this.data;
		}
		public List<Map<String, Object>> getTriggers() {
			return this.triggers;
		}
	}
	/**
	 * Description of the {@link Trigger triggers} in a given group.
	 */
	public static final class QuartzTriggerGroupSummaryDescriptor implements OperationResponseBody {
		private final String group;
		private final boolean paused;
		private final Triggers triggers;
		private QuartzTriggerGroupSummaryDescriptor(String group, boolean paused,
				Map<TriggerType, Map<String, Object>> descriptionsByType) {
			this.group = group;
			this.paused = paused;
			this.triggers = new Triggers(descriptionsByType);
		}
		public String getGroup() {
			return this.group;
		}
		public boolean isPaused() {
			return this.paused;
		}
		public Triggers getTriggers() {
			return this.triggers;
		}
		public static final class Triggers {
			private final Map<String, Object> cron;
			private final Map<String, Object> simple;
			private final Map<String, Object> dailyTimeInterval;
			private final Map<String, Object> calendarInterval;
			private final Map<String, Object> custom;
			private Triggers(Map<TriggerType, Map<String, Object>> descriptionsByType) {
				this.cron = descriptionsByType.getOrDefault(TriggerType.CRON, Collections.emptyMap());
				this.dailyTimeInterval = descriptionsByType.getOrDefault(TriggerType.DAILY_INTERVAL,
						Collections.emptyMap());
				this.calendarInterval = descriptionsByType.getOrDefault(TriggerType.CALENDAR_INTERVAL,
						Collections.emptyMap());
				this.simple = descriptionsByType.getOrDefault(TriggerType.SIMPLE, Collections.emptyMap());
				this.custom = descriptionsByType.getOrDefault(TriggerType.CUSTOM_TRIGGER, Collections.emptyMap());
			}
			public Map<String, Object> getCron() {
				return this.cron;
			}
			public Map<String, Object> getSimple() {
				return this.simple;
			}
			public Map<String, Object> getDailyTimeInterval() {
				return this.dailyTimeInterval;
			}
			public Map<String, Object> getCalendarInterval() {
				return this.calendarInterval;
			}
			public Map<String, Object> getCustom() {
				return this.custom;
			}
		}
	}
	private enum TriggerType {
		CRON('cron'),
		CUSTOM_TRIGGER('custom'),
		CALENDAR_INTERVAL('calendarInterval'),
		DAILY_INTERVAL('dailyTimeInterval'),
		SIMPLE('simple');
		private final String id;
		TriggerType(String id) {
			this.id = id;
		}
		public String getId() {
			return this.id;
		}
	}
	/**
	 * Base class for descriptions of a {@link Trigger}.
	 */
	public abstract static class TriggerDescriptor {
		private static final Map<Class<? extends Trigger>, Function<Trigger, TriggerDescriptor>> DESCRIBERS = new LinkedHashMap<>();
		static {
			DESCRIBERS.put(CronTrigger.class, (trigger) -> new CronTriggerDescriptor((CronTrigger) trigger));
			DESCRIBERS.put(SimpleTrigger.class, (trigger) -> new SimpleTriggerDescriptor((SimpleTrigger) trigger));
			DESCRIBERS.put(DailyTimeIntervalTrigger.class,
					(trigger) -> new DailyTimeIntervalTriggerDescriptor((DailyTimeIntervalTrigger) trigger));
			DESCRIBERS.put(CalendarIntervalTrigger.class,
					(trigger) -> new CalendarIntervalTriggerDescriptor((CalendarIntervalTrigger) trigger));
		}
		private final Trigger trigger;
		private final TriggerType type;
		private static TriggerDescriptor of(Trigger trigger) {
			return DESCRIBERS.entrySet()
				.stream()
				.filter((entry) -> entry.getKey().isInstance(trigger))
				.map((entry) -> entry.getValue().apply(trigger))
				.findFirst()
				.orElse(new CustomTriggerDescriptor(trigger));
		}
		protected TriggerDescriptor(Trigger trigger, TriggerType type) {
			this.trigger = trigger;
			this.type = type;
		}
		/**
		 * Build the summary of the trigger.
		 * @param addTriggerSpecificSummary whether to add trigger-implementation specific
		 * summary.
		 * @return basic properties of the trigger
		 */
		public Map<String, Object> buildSummary(boolean addTriggerSpecificSummary) {
			Map<String, Object> summary = new LinkedHashMap<>();
			putIfNoNull(summary, 'previousFireTime', this.trigger.getPreviousFireTime());
			putIfNoNull(summary, 'nextFireTime', this.trigger.getNextFireTime());
			summary.put('priority', this.trigger.getPriority());
			if (addTriggerSpecificSummary) {
				appendSummary(summary);
			}
			return summary;
		}
		/**
		 * Append trigger-implementation specific summary items to the specified
		 * {@code content}.
		 * @param content the summary of the trigger
		 */
		protected abstract void appendSummary(Map<String, Object> content);
		/**
		 * Build the full details of the trigger.
		 * @param triggerState the current state of the trigger
		 * @param sanitizedDataMap a sanitized data map or {@code null}
		 * @return all properties of the trigger
		 */
		public Map<String, Object> buildDetails(TriggerState triggerState, Map<String, Object> sanitizedDataMap) {
			Map<String, Object> details = new LinkedHashMap<>();
			details.put('group', this.trigger.getKey().getGroup());
			details.put('name', this.trigger.getKey().getName());
			putIfNoNull(details, 'description', this.trigger.getDescription());
			details.put('state', triggerState);
			details.put('type', getType().getId());
			putIfNoNull(details, 'calendarName', this.trigger.getCalendarName());
			putIfNoNull(details, 'startTime', this.trigger.getStartTime());
			putIfNoNull(details, 'endTime', this.trigger.getEndTime());
			putIfNoNull(details, 'previousFireTime', this.trigger.getPreviousFireTime());
			putIfNoNull(details, 'nextFireTime', this.trigger.getNextFireTime());
			putIfNoNull(details, 'priority', this.trigger.getPriority());
			putIfNoNull(details, 'finalFireTime', this.trigger.getFinalFireTime());
			putIfNoNull(details, 'data', sanitizedDataMap);
			Map<String, Object> typeDetails = new LinkedHashMap<>();
			appendDetails(typeDetails);
			details.put(getType().getId(), typeDetails);
			return details;
		}
		/**
		 * Append trigger-implementation specific details to the specified
		 * {@code content}.
		 * @param content the details of the trigger
		 */
		protected abstract void appendDetails(Map<String, Object> content);
		protected void putIfNoNull(Map<String, Object> content, String key, Object value) {
			if (value != null) {
				content.put(key, value);
			}
		}
		protected Trigger getTrigger() {
			return this.trigger;
		}
		protected TriggerType getType() {
			return this.type;
		}
	}
	/**
	 * Description of a {@link CronTrigger}.
	 */
	public static final class CronTriggerDescriptor extends TriggerDescriptor {
		private final CronTrigger trigger;
		public CronTriggerDescriptor(CronTrigger trigger) {
			super(trigger, TriggerType.CRON);
			this.trigger = trigger;
		}
		@Override
		protected void appendSummary(Map<String, Object> content) {
			content.put('expression', this.trigger.getCronExpression());
			putIfNoNull(content, 'timeZone', this.trigger.getTimeZone());
		}
		@Override
		protected void appendDetails(Map<String, Object> content) {
			appendSummary(content);
		}
	}
	/**
	 * Description of a {@link SimpleTrigger}.
	 */
	public static final class SimpleTriggerDescriptor extends TriggerDescriptor {
		private final SimpleTrigger trigger;
		public SimpleTriggerDescriptor(SimpleTrigger trigger) {
			super(trigger, TriggerType.SIMPLE);
			this.trigger = trigger;
		}
		@Override
		protected void appendSummary(Map<String, Object> content) {
			content.put('interval', this.trigger.getRepeatInterval());
		}
		@Override
		protected void appendDetails(Map<String, Object> content) {
			appendSummary(content);
			content.put('repeatCount', this.trigger.getRepeatCount());
			content.put('timesTriggered', this.trigger.getTimesTriggered());
		}
	}
	/**
	 * Description of a {@link DailyTimeIntervalTrigger}.
	 */
	public static final class DailyTimeIntervalTriggerDescriptor extends TriggerDescriptor {
		private final DailyTimeIntervalTrigger trigger;
		public DailyTimeIntervalTriggerDescriptor(DailyTimeIntervalTrigger trigger) {
			super(trigger, TriggerType.DAILY_INTERVAL);
			this.trigger = trigger;
		}
		@Override
		protected void appendSummary(Map<String, Object> content) {
			content.put('interval',
					getIntervalDuration(this.trigger.getRepeatInterval(), this.trigger.getRepeatIntervalUnit())
						.toMillis());
			putIfNoNull(content, 'daysOfWeek', this.trigger.getDaysOfWeek());
			putIfNoNull(content, 'startTimeOfDay', getLocalTime(this.trigger.getStartTimeOfDay()));
			putIfNoNull(content, 'endTimeOfDay', getLocalTime(this.trigger.getEndTimeOfDay()));
		}
		@Override
		protected void appendDetails(Map<String, Object> content) {
			appendSummary(content);
			content.put('repeatCount', this.trigger.getRepeatCount());
			content.put('timesTriggered', this.trigger.getTimesTriggered());
		}
	}
	/**
	 * Description of a {@link CalendarIntervalTrigger}.
	 */
	public static final class CalendarIntervalTriggerDescriptor extends TriggerDescriptor {
		private final CalendarIntervalTrigger trigger;
		public CalendarIntervalTriggerDescriptor(CalendarIntervalTrigger trigger) {
			super(trigger, TriggerType.CALENDAR_INTERVAL);
			this.trigger = trigger;
		}
		@Override
		protected void appendSummary(Map<String, Object> content) {
			content.put('interval',
					getIntervalDuration(this.trigger.getRepeatInterval(), this.trigger.getRepeatIntervalUnit())
						.toMillis());
			putIfNoNull(content, 'timeZone', this.trigger.getTimeZone());
		}
		@Override
		protected void appendDetails(Map<String, Object> content) {
			appendSummary(content);
			content.put('timesTriggered', this.trigger.getTimesTriggered());
			content.put('preserveHourOfDayAcrossDaylightSavings',
					this.trigger.isPreserveHourOfDayAcrossDaylightSavings());
			content.put('skipDayIfHourDoesNotExist', this.trigger.isSkipDayIfHourDoesNotExist());
		}
	}
	/**
	 * Description of a custom {@link Trigger}.
	 */
	public static final class CustomTriggerDescriptor extends TriggerDescriptor {
		public CustomTriggerDescriptor(Trigger trigger) {
			super(trigger, TriggerType.CUSTOM_TRIGGER);
		}
		@Override
		protected void appendSummary(Map<String, Object> content) {
			content.put('trigger', getTrigger().toString());
		}
		@Override
		protected void appendDetails(Map<String, Object> content) {
			appendSummary(content);
		}
	}
}
/*
package org.springframework.boot.actuate.cache;
/**
@EndpointWebExtension(endpoint = CachesEndpoint.class)
public class CachesEndpointWebExtension {
	private final CachesEndpoint delegate;
	public CachesEndpointWebExtension(CachesEndpoint delegate) {
		this.delegate = delegate;
	}
	@ReadOperation
	public WebEndpointResponse<CacheEntryDescriptor> cache(@Selector String cache, @Nullable String cacheManager) {
		try {
			CacheEntryDescriptor entry = this.delegate.cache(cache, cacheManager);
			int status = (entry != null) ? WebEndpointResponse.STATUS_OK : WebEndpointResponse.STATUS_NOT_FOUND;
			return new WebEndpointResponse<>(entry, status);
		}
		catch (NonUniqueCacheException ex) {
			return new WebEndpointResponse<>(WebEndpointResponse.STATUS_BAD_REQUEST);
		}
	}
	@DeleteOperation
	public WebEndpointResponse<Void> clearCache(@Selector String cache, @Nullable String cacheManager) {
		try {
			boolean cleared = this.delegate.clearCache(cache, cacheManager);
			int status = (cleared ? WebEndpointResponse.STATUS_NO_CONTENT : WebEndpointResponse.STATUS_NOT_FOUND);
			return new WebEndpointResponse<>(status);
		}
		catch (NonUniqueCacheException ex) {
			return new WebEndpointResponse<>(WebEndpointResponse.STATUS_BAD_REQUEST);
		}
	}
}
/*
package org.springframework.boot.actuate.cache;
/**
public class NonUniqueCacheException extends RuntimeException {
	private final String cacheName;
	private final Collection<String> cacheManagerNames;
	public NonUniqueCacheException(String cacheName, Collection<String> cacheManagerNames) {
		super(String.format('Multiple caches named %s found, specify the "cacheManager" to use: %s', cacheName,
				cacheManagerNames));
		this.cacheName = cacheName;
		this.cacheManagerNames = Collections.unmodifiableCollection(cacheManagerNames);
	}
	public String getCacheName() {
		return this.cacheName;
	}
	public Collection<String> getCacheManagerNames() {
		return this.cacheManagerNames;
	}
}
/*
package org.springframework.boot.actuate.cache;
/**
@Endpoint(id = 'caches')
public class CachesEndpoint {
	private final Map<String, CacheManager> cacheManagers;
	/**
	 * Create a new endpoint with the {@link CacheManager} instances to use.
	 * @param cacheManagers the cache managers to use, indexed by name
	 */
	public CachesEndpoint(Map<String, CacheManager> cacheManagers) {
		this.cacheManagers = new LinkedHashMap<>(cacheManagers);
	}
	/**
	 * Return a {@link CachesDescriptor} of all available {@link Cache caches}.
	 * @return a caches reports
	 */
	@ReadOperation
	public CachesDescriptor caches() {
		Map<String, Map<String, CacheDescriptor>> descriptors = new LinkedHashMap<>();
		getCacheEntries(matchAll(), matchAll()).forEach((entry) -> {
			String cacheName = entry.getName();
			String cacheManager = entry.getCacheManager();
			Map<String, CacheDescriptor> cacheManagerDescriptors = descriptors.computeIfAbsent(cacheManager,
					(key) -> new LinkedHashMap<>());
			cacheManagerDescriptors.put(cacheName, new CacheDescriptor(entry.getTarget()));
		});
		Map<String, CacheManagerDescriptor> cacheManagerDescriptors = new LinkedHashMap<>();
		descriptors.forEach((name, entries) -> cacheManagerDescriptors.put(name, new CacheManagerDescriptor(entries)));
		return new CachesDescriptor(cacheManagerDescriptors);
	}
	/**
	 * Return a {@link CacheDescriptor} for the specified cache.
	 * @param cache the name of the cache
	 * @param cacheManager the name of the cacheManager (can be {@code null}
	 * @return the descriptor of the cache or {@code null} if no such cache exists
	 * @throws NonUniqueCacheException if more than one cache with that name exists and no
	 * {@code cacheManager} was provided to identify a unique candidate
	 */
	@ReadOperation
	public CacheEntryDescriptor cache(@Selector String cache, @Nullable String cacheManager) {
		return extractUniqueCacheEntry(cache, getCacheEntries((name) -> name.equals(cache), isNameMatch(cacheManager)));
	}
	/**
	 * Clear all the available {@link Cache caches}.
	 */
	@DeleteOperation
	public void clearCaches() {
		getCacheEntries(matchAll(), matchAll()).forEach(this::clearCache);
	}
	/**
	 * Clear the specific {@link Cache}.
	 * @param cache the name of the cache
	 * @param cacheManager the name of the cacheManager (can be {@code null} to match all)
	 * @return {@code true} if the cache was cleared or {@code false} if no such cache
	 * exists
	 * @throws NonUniqueCacheException if more than one cache with that name exists and no
	 * {@code cacheManager} was provided to identify a unique candidate
	 */
	@DeleteOperation
	public boolean clearCache(@Selector String cache, @Nullable String cacheManager) {
		CacheEntryDescriptor entry = extractUniqueCacheEntry(cache,
				getCacheEntries((name) -> name.equals(cache), isNameMatch(cacheManager)));
		return (entry != null && clearCache(entry));
	}
	private List<CacheEntryDescriptor> getCacheEntries(Predicate<String> cacheNamePredicate,
			Predicate<String> cacheManagerNamePredicate) {
		return this.cacheManagers.keySet()
			.stream()
			.filter(cacheManagerNamePredicate)
			.flatMap((cacheManagerName) -> getCacheEntries(cacheManagerName, cacheNamePredicate).stream())
			.toList();
	}
	private List<CacheEntryDescriptor> getCacheEntries(String cacheManagerName, Predicate<String> cacheNamePredicate) {
		CacheManager cacheManager = this.cacheManagers.get(cacheManagerName);
		return cacheManager.getCacheNames()
			.stream()
			.filter(cacheNamePredicate)
			.map(cacheManager::getCache)
			.filter(Objects::nonNull)
			.map((cache) -> new CacheEntryDescriptor(cache, cacheManagerName))
			.toList();
	}
	private CacheEntryDescriptor extractUniqueCacheEntry(String cache, List<CacheEntryDescriptor> entries) {
		if (entries.size() > 1) {
			throw new NonUniqueCacheException(cache,
					entries.stream().map(CacheEntryDescriptor::getCacheManager).distinct().toList());
		}
		return (!entries.isEmpty() ? entries.get(0) : null);
	}
	private boolean clearCache(CacheEntryDescriptor entry) {
		String cacheName = entry.getName();
		String cacheManager = entry.getCacheManager();
		Cache cache = this.cacheManagers.get(cacheManager).getCache(cacheName);
		if (cache != null) {
			cache.clear();
			return true;
		}
		return false;
	}
	private Predicate<String> isNameMatch(String name) {
		return (name != null) ? ((requested) -> requested.equals(name)) : matchAll();
	}
	private Predicate<String> matchAll() {
		return (name) -> true;
	}
	/**
	 * Description of the caches.
	 */
	public static final class CachesDescriptor implements OperationResponseBody {
		private final Map<String, CacheManagerDescriptor> cacheManagers;
		public CachesDescriptor(Map<String, CacheManagerDescriptor> cacheManagers) {
			this.cacheManagers = cacheManagers;
		}
		public Map<String, CacheManagerDescriptor> getCacheManagers() {
			return this.cacheManagers;
		}
	}
	/**
	 * Description of a {@link CacheManager}.
	 */
	public static final class CacheManagerDescriptor {
		private final Map<String, CacheDescriptor> caches;
		public CacheManagerDescriptor(Map<String, CacheDescriptor> caches) {
			this.caches = caches;
		}
		public Map<String, CacheDescriptor> getCaches() {
			return this.caches;
		}
	}
	/**
	 * Description of a {@link Cache}.
	 */
	public static class CacheDescriptor implements OperationResponseBody {
		private final String target;
		public CacheDescriptor(String target) {
			this.target = target;
		}
		/**
		 * Return the fully qualified name of the native cache.
		 * @return the fully qualified name of the native cache
		 */
		public String getTarget() {
			return this.target;
		}
	}
	/**
	 * Description of a {@link Cache} entry.
	 */
	public static final class CacheEntryDescriptor extends CacheDescriptor {
		private final String name;
		private final String cacheManager;
		public CacheEntryDescriptor(Cache cache, String cacheManager) {
			super(cache.getNativeCache().getClass().getName());
			this.name = cache.getName();
			this.cacheManager = cacheManager;
		}
		public String getName() {
			return this.name;
		}
		public String getCacheManager() {
			return this.cacheManager;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.cache;
/*
package org.springframework.boot.actuate.web.exchanges;
/**
public final class HttpExchange {
	private final Instant timestamp;
	private final Request request;
	private final Response response;
	private final Principal principal;
	private final Session session;
	private final Duration timeTaken;
	/**
	 * Primarily for use by {@link HttpExchangeRepository} implementations when recreating
	 * an exchange from a persistent store.
	 * @param timestamp the instant that the exchange started
	 * @param request the request
	 * @param response the response
	 * @param principal the principal
	 * @param session the session
	 * @param timeTaken the total time taken
	 */
	public HttpExchange(Instant timestamp, Request request, Response response, Principal principal, Session session,
			Duration timeTaken) {
		this.timestamp = timestamp;
		this.request = request;
		this.response = response;
		this.principal = principal;
		this.session = session;
		this.timeTaken = timeTaken;
	}
	/**
	 * Returns the instant that the exchange started.
	 * @return the start timestamp
	 */
	public Instant getTimestamp() {
		return this.timestamp;
	}
	/**
	 * Returns the request that started the exchange.
	 * @return the request.
	 */
	public Request getRequest() {
		return this.request;
	}
	/**
	 * Returns the response that completed the exchange.
	 * @return the response.
	 */
	public Response getResponse() {
		return this.response;
	}
	/**
	 * Returns the principal.
	 * @return the request
	 */
	public Principal getPrincipal() {
		return this.principal;
	}
	/**
	 * Returns the session details.
	 * @return the session
	 */
	public Session getSession() {
		return this.session;
	}
	/**
	 * Returns the total time taken for the exchange.
	 * @return the total time taken
	 */
	public Duration getTimeTaken() {
		return this.timeTaken;
	}
	/**
	 * Start a new {@link Started} from the given source request.
	 * @param request the recordable HTTP request
	 * @return an in-progress request
	 */
	public static Started start(RecordableHttpRequest request) {
		return start(Clock.systemUTC(), request);
	}
	/**
	 * Start a new {@link Started} from the given source request.
	 * @param clock the clock to use
	 * @param request the recordable HTTP request
	 * @return an in-progress request
	 */
	public static Started start(Clock clock, RecordableHttpRequest request) {
		return new Started(clock, request);
	}
	/**
	 * A started request that when {@link #finish finished} will return a new
	 * {@link HttpExchange} instance.
	 */
	public static final class Started {
		private final Instant timestamp;
		private final RecordableHttpRequest request;
		private Started(Clock clock, RecordableHttpRequest request) {
			this.timestamp = Instant.now(clock);
			this.request = request;
		}
		/**
		 * Finish the request and return a new {@link HttpExchange} instance.
		 * @param response the recordable HTTP response
		 * @param principalSupplier a supplier to provide the principal
		 * @param sessionIdSupplier a supplier to provide the session ID
		 * @param includes the options to include
		 * @return a new {@link HttpExchange} instance
		 */
		public HttpExchange finish(RecordableHttpResponse response, Supplier<java.security.Principal> principalSupplier,
				Supplier<String> sessionIdSupplier, Include... includes) {
			return finish(Clock.systemUTC(), response, principalSupplier, sessionIdSupplier, includes);
		}
		/**
		 * Finish the request and return a new {@link HttpExchange} instance.
		 * @param clock the clock to use
		 * @param response the recordable HTTP response
		 * @param principalSupplier a supplier to provide the principal
		 * @param sessionIdSupplier a supplier to provide the session ID
		 * @param includes the options to include
		 * @return a new {@link HttpExchange} instance
		 */
		public HttpExchange finish(Clock clock, RecordableHttpResponse response,
				Supplier<java.security.Principal> principalSupplier, Supplier<String> sessionIdSupplier,
				Include... includes) {
			return finish(clock, response, principalSupplier, sessionIdSupplier,
					new HashSet<>(Arrays.asList(includes)));
		}
		/**
		 * Finish the request and return a new {@link HttpExchange} instance.
		 * @param response the recordable HTTP response
		 * @param principalSupplier a supplier to provide the principal
		 * @param sessionIdSupplier a supplier to provide the session ID
		 * @param includes the options to include
		 * @return a new {@link HttpExchange} instance
		 */
		public HttpExchange finish(RecordableHttpResponse response, Supplier<java.security.Principal> principalSupplier,
				Supplier<String> sessionIdSupplier, Set<Include> includes) {
			return finish(Clock.systemUTC(), response, principalSupplier, sessionIdSupplier, includes);
		}
		/**
		 * Finish the request and return a new {@link HttpExchange} instance.
		 * @param clock the clock to use
		 * @param response the recordable HTTP response
		 * @param principalSupplier a supplier to provide the principal
		 * @param sessionIdSupplier a supplier to provide the session ID
		 * @param includes the options to include
		 * @return a new {@link HttpExchange} instance
		 */
		public HttpExchange finish(Clock clock, RecordableHttpResponse response,
				Supplier<java.security.Principal> principalSupplier, Supplier<String> sessionIdSupplier,
				Set<Include> includes) {
			Request exchangeRequest = new Request(this.request, includes);
			Response exchangeResponse = new Response(response, includes);
			Principal principal = getIfIncluded(includes, Include.PRINCIPAL, () -> Principal.from(principalSupplier));
			Session session = getIfIncluded(includes, Include.SESSION_ID, () -> Session.from(sessionIdSupplier));
			Duration duration = getIfIncluded(includes, Include.TIME_TAKEN,
					() -> Duration.between(this.timestamp, Instant.now(clock)));
			return new HttpExchange(this.timestamp, exchangeRequest, exchangeResponse, principal, session, duration);
		}
		private <T> T getIfIncluded(Set<Include> includes, Include include, Supplier<T> supplier) {
			return (includes.contains(include)) ? supplier.get() : null;
		}
	}
	/**
	 * The request that started the exchange.
	 */
	public static final class Request {
		private final URI uri;
		private final String remoteAddress;
		private final String method;
		private final Map<String, List<String>> headers;
		private Request(RecordableHttpRequest request, Set<Include> includes) {
			this.uri = request.getUri();
			this.remoteAddress = (includes.contains(Include.REMOTE_ADDRESS)) ? request.getRemoteAddress() : null;
			this.method = request.getMethod();
			this.headers = Collections.unmodifiableMap(filterHeaders(request.getHeaders(), includes));
		}
		/**
		 * Creates a fully-configured {@code Request} instance. Primarily for use by
		 * {@link HttpExchangeRepository} implementations when recreating a request from a
		 * persistent store.
		 * @param uri the URI of the request
		 * @param remoteAddress remote address from which the request was sent, if known
		 * @param method the HTTP method of the request
		 * @param headers the request headers
		 */
		public Request(URI uri, String remoteAddress, String method, Map<String, List<String>> headers) {
			this.uri = uri;
			this.remoteAddress = remoteAddress;
			this.method = method;
			this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));
		}
		private Map<String, List<String>> filterHeaders(Map<String, List<String>> headers, Set<Include> includes) {
			HeadersFilter filter = new HeadersFilter(includes, Include.REQUEST_HEADERS);
			filter.excludeUnless(HttpHeaders.COOKIE, Include.COOKIE_HEADERS);
			filter.excludeUnless(HttpHeaders.AUTHORIZATION, Include.AUTHORIZATION_HEADER);
			return filter.apply(headers);
		}
		/**
		 * Return the HTTP method requested.
		 * @return the HTTP method
		 */
		public String getMethod() {
			return this.method;
		}
		/**
		 * Return the URI requested.
		 * @return the URI
		 */
		public URI getUri() {
			return this.uri;
		}
		/**
		 * Return the request headers.
		 * @return the request headers
		 */
		public Map<String, List<String>> getHeaders() {
			return this.headers;
		}
		/**
		 * Return the remote address that made the request.
		 * @return the remote address
		 */
		public String getRemoteAddress() {
			return this.remoteAddress;
		}
	}
	/**
	 * The response that finished the exchange.
	 */
	public static final class Response {
		private final int status;
		private final Map<String, List<String>> headers;
		private Response(RecordableHttpResponse request, Set<Include> includes) {
			this.status = request.getStatus();
			this.headers = Collections.unmodifiableMap(filterHeaders(request.getHeaders(), includes));
		}
		/**
		 * Creates a fully-configured {@code Response} instance. Primarily for use by
		 * {@link HttpExchangeRepository} implementations when recreating a response from
		 * a persistent store.
		 * @param status the status of the response
		 * @param headers the response headers
		 */
		public Response(int status, Map<String, List<String>> headers) {
			this.status = status;
			this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));
		}
		private Map<String, List<String>> filterHeaders(Map<String, List<String>> headers, Set<Include> includes) {
			HeadersFilter filter = new HeadersFilter(includes, Include.RESPONSE_HEADERS);
			filter.excludeUnless(HttpHeaders.SET_COOKIE, Include.COOKIE_HEADERS);
			return filter.apply(headers);
		}
		/**
		 * Return the status code of the response.
		 * @return the response status code
		 */
		public int getStatus() {
			return this.status;
		}
		/**
		 * Return the response headers.
		 * @return the headers
		 */
		public Map<String, List<String>> getHeaders() {
			return this.headers;
		}
	}
	/**
	 * The session associated with the exchange.
	 */
	public static final class Session {
		private final String id;
		/**
		 * Creates a {@code Session}. Primarily for use by {@link HttpExchangeRepository}
		 * implementations when recreating a session from a persistent store.
		 * @param id the session id
		 */
		public Session(String id) {
			this.id = id;
		}
		/**
		 * Return the ID of the session.
		 * @return the session ID
		 */
		public String getId() {
			return this.id;
		}
		static Session from(Supplier<String> sessionIdSupplier) {
			String id = sessionIdSupplier.get();
			return (id != null) ? new Session(id) : null;
		}
	}
	/**
	 * Principal associated with an HTTP request-response exchange.
	 */
	public static final class Principal {
		private final String name;
		/**
		 * Creates a {@code Principal}. Primarily for use by {@link Principal}
		 * implementations when recreating a response from a persistent store.
		 * @param name the name of the principal
		 */
		public Principal(String name) {
			this.name = name;
		}
		/**
		 * Return the name of the principal.
		 * @return the principal name
		 */
		public String getName() {
			return this.name;
		}
		static Principal from(Supplier<java.security.Principal> principalSupplier) {
			java.security.Principal principal = principalSupplier.get();
			return (principal != null) ? new Principal(principal.getName()) : null;
		}
	}
	/**
	 * Utility class used to filter headers.
	 */
	private static class HeadersFilter {
		private final Set<Include> includes;
		private final Include requiredInclude;
		private final Set<String> filteredHeaderNames;
		HeadersFilter(Set<Include> includes, Include requiredInclude) {
			this.includes = includes;
			this.requiredInclude = requiredInclude;
			this.filteredHeaderNames = new HashSet<>();
		}
		void excludeUnless(String header, Include exception) {
			if (!this.includes.contains(exception)) {
				this.filteredHeaderNames.add(header.toLowerCase(Locale.ROOT));
			}
		}
		Map<String, List<String>> apply(Map<String, List<String>> headers) {
			if (!this.includes.contains(this.requiredInclude)) {
				return Collections.emptyMap();
			}
			Map<String, List<String>> filtered = new LinkedHashMap<>();
			headers.forEach((name, value) -> {
				if (!this.filteredHeaderNames.contains(name.toLowerCase(Locale.ROOT))) {
					filtered.put(name, value);
				}
			});
			return filtered;
		}
	}
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
@Endpoint(id = 'httpexchanges')
public class HttpExchangesEndpoint {
	private final HttpExchangeRepository repository;
	/**
	 * Create a new {@link HttpExchangesEndpoint} instance.
	 * @param repository the exchange repository
	 */
	public HttpExchangesEndpoint(HttpExchangeRepository repository) {
		Assert.notNull(repository, 'Repository must not be null');
		this.repository = repository;
	}
	@ReadOperation
	public HttpExchangesDescriptor httpExchanges() {
		return new HttpExchangesDescriptor(this.repository.findAll());
	}
	/**
	 * Description of an application"s {@link HttpExchange} entries.
	 */
	public static final class HttpExchangesDescriptor implements OperationResponseBody {
		private final List<HttpExchange> exchanges;
		private HttpExchangesDescriptor(List<HttpExchange> exchanges) {
			this.exchanges = exchanges;
		}
		public List<HttpExchange> getExchanges() {
			return this.exchanges;
		}
	}
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
public enum Include {
	/**
	 * Include request headers.
	 */
	REQUEST_HEADERS,
	/**
	 * Include the remote address from the request.
	 */
	REMOTE_ADDRESS,
	/**
	 * Include 'Cookie' header (if any) in request headers and 'Set-Cookie' (if any) in
	 * response headers.
	 */
	COOKIE_HEADERS,
	/**
	 * Include authorization header (if any).
	 */
	AUTHORIZATION_HEADER,
	/**
	 * Include response headers.
	 */
	RESPONSE_HEADERS,
	/**
	 * Include the principal.
	 */
	PRINCIPAL,
	/**
	 * Include the session ID.
	 */
	SESSION_ID,
	/**
	 * Include the time taken to service the request.
	 */
	TIME_TAKEN;
	private static final Set<Include> DEFAULT_INCLUDES;
	static {
		Set<Include> defaultIncludes = new LinkedHashSet<>();
		defaultIncludes.add(Include.TIME_TAKEN);
		defaultIncludes.add(Include.REQUEST_HEADERS);
		defaultIncludes.add(Include.RESPONSE_HEADERS);
		DEFAULT_INCLUDES = Collections.unmodifiableSet(defaultIncludes);
	}
	/**
	 * Return the default {@link Include}.
	 * @return the default include.
	 */
	public static Set<Include> defaultIncludes() {
		return DEFAULT_INCLUDES;
	}
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
public interface RecordableHttpRequest {
	/**
	 * Returns the URI of the request.
	 * @return the URI
	 */
	URI getUri();
	/**
	 * Returns the remote address from which the request was sent, if available.
	 * @return the remote address or {@code null}
	 */
	String getRemoteAddress();
	/**
	 * Returns the method (GET, POST, etc.) of the request.
	 * @return the method
	 */
	String getMethod();
	/**
	 * Returns a modifiable copy of the headers of the request.
	 * @return the headers
	 */
	Map<String, List<String>> getHeaders();
}
/*
package org.springframework.boot.actuate.web.exchanges.servlet;
/**
public class HttpExchangesFilter extends OncePerRequestFilter implements Ordered {
	// Not LOWEST_PRECEDENCE, but near the end, so it has a good chance of catching all
	// enriched headers, but users can add stuff after this if they want to
	private int order = Ordered.LOWEST_PRECEDENCE - 10;
	private final HttpExchangeRepository repository;
	private final Set<Include> includes;
	/**
	 * Create a new {@link HttpExchangesWebFilter} instance.
	 * @param repository the repository used to record events
	 * @param includes the include options
	 */
	public HttpExchangesFilter(HttpExchangeRepository repository, Set<Include> includes) {
		this.repository = repository;
		this.includes = includes;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {
		if (!isRequestValid(request)) {
			filterChain.doFilter(request, response);
			return;
		}
		RecordableServletHttpRequest sourceRequest = new RecordableServletHttpRequest(request);
		HttpExchange.Started startedHttpExchange = HttpExchange.start(sourceRequest);
		int status = HttpStatus.INTERNAL_SERVER_ERROR.value();
		try {
			filterChain.doFilter(request, response);
			status = response.getStatus();
		}
		finally {
			RecordableServletHttpResponse sourceResponse = new RecordableServletHttpResponse(response, status);
			HttpExchange finishedExchange = startedHttpExchange.finish(sourceResponse, request::getUserPrincipal,
					() -> getSessionId(request), this.includes);
			this.repository.add(finishedExchange);
		}
	}
	private boolean isRequestValid(HttpServletRequest request) {
		try {
			new URI(request.getRequestURL().toString());
			return true;
		}
		catch (URISyntaxException ex) {
			return false;
		}
	}
	private String getSessionId(HttpServletRequest request) {
		HttpSession session = request.getSession(false);
		return (session != null) ? session.getId() : null;
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.servlet;
/**
final class RecordableServletHttpResponse implements RecordableHttpResponse {
	private final HttpServletResponse delegate;
	private final int status;
	RecordableServletHttpResponse(HttpServletResponse response, int status) {
		this.delegate = response;
		this.status = status;
	}
	@Override
	public int getStatus() {
		return this.status;
	}
	@Override
	public Map<String, List<String>> getHeaders() {
		Map<String, List<String>> headers = new LinkedHashMap<>();
		for (String name : this.delegate.getHeaderNames()) {
			headers.put(name, new ArrayList<>(this.delegate.getHeaders(name)));
		}
		return headers;
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.servlet;
/**
final class RecordableServletHttpRequest implements RecordableHttpRequest {
	private final HttpServletRequest request;
	RecordableServletHttpRequest(HttpServletRequest request) {
		this.request = request;
	}
	@Override
	public String getMethod() {
		return this.request.getMethod();
	}
	@Override
	public URI getUri() {
		String queryString = this.request.getQueryString();
		if (!StringUtils.hasText(queryString)) {
			return URI.create(this.request.getRequestURL().toString());
		}
		try {
			StringBuffer urlBuffer = appendQueryString(queryString);
			return new URI(urlBuffer.toString());
		}
		catch (URISyntaxException ex) {
			String encoded = UriUtils.encodeQuery(queryString, StandardCharsets.UTF_8);
			StringBuffer urlBuffer = appendQueryString(encoded);
			return URI.create(urlBuffer.toString());
		}
	}
	private StringBuffer appendQueryString(String queryString) {
		return this.request.getRequestURL().append('?').append(queryString);
	}
	@Override
	public Map<String, List<String>> getHeaders() {
		return extractHeaders();
	}
	@Override
	public String getRemoteAddress() {
		return this.request.getRemoteAddr();
	}
	private Map<String, List<String>> extractHeaders() {
		Map<String, List<String>> headers = new LinkedHashMap<>();
		Enumeration<String> names = this.request.getHeaderNames();
		while (names.hasMoreElements()) {
			String name = names.nextElement();
			headers.put(name, Collections.list(this.request.getHeaders(name)));
		}
		return headers;
	}
}
/*
/**
package org.springframework.boot.actuate.web.exchanges.servlet;
/*
package org.springframework.boot.actuate.web.exchanges;
/**
public class InMemoryHttpExchangeRepository implements HttpExchangeRepository {
	private int capacity = 100;
	private boolean reverse = true;
	private final List<HttpExchange> httpExchanges = new LinkedList<>();
	/**
	 * Flag to say that the repository lists exchanges in reverse order.
	 * @param reverse flag value (default true)
	 */
	public void setReverse(boolean reverse) {
		synchronized (this.httpExchanges) {
			this.reverse = reverse;
		}
	}
	/**
	 * Set the capacity of the in-memory repository.
	 * @param capacity the capacity
	 */
	public void setCapacity(int capacity) {
		synchronized (this.httpExchanges) {
			this.capacity = capacity;
		}
	}
	@Override
	public List<HttpExchange> findAll() {
		synchronized (this.httpExchanges) {
			return List.copyOf(this.httpExchanges);
		}
	}
	@Override
	public void add(HttpExchange exchange) {
		synchronized (this.httpExchanges) {
			while (this.httpExchanges.size() >= this.capacity) {
				this.httpExchanges.remove(this.reverse ? this.capacity - 1 : 0);
			}
			if (this.reverse) {
				this.httpExchanges.add(0, exchange);
			}
			else {
				this.httpExchanges.add(exchange);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
public interface RecordableHttpResponse {
	/**
	 * The status of the response.
	 * @return the status
	 */
	int getStatus();
	/**
	 * Returns a modifiable copy of the headers of the response.
	 * @return the headers
	 */
	Map<String, List<String>> getHeaders();
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
public interface HttpExchangeRepository {
	/**
	 * Find all {@link HttpExchange} instances contained in the repository.
	 * @return all contained HTTP exchanges
	 */
	List<HttpExchange> findAll();
	/**
	 * Adds an {@link HttpExchange} instance to the repository.
	 * @param httpExchange the HTTP exchange to add
	 */
	void add(HttpExchange httpExchange);
}
/*
/**
package org.springframework.boot.actuate.web.exchanges;
/*
package org.springframework.boot.actuate.web.exchanges.reactive;
/**
public class HttpExchangesWebFilter implements WebFilter, Ordered {
	private static final Object NONE = new Object();
	// Not LOWEST_PRECEDENCE, but near the end, so it has a good chance of catching all
	// enriched headers, but users can add stuff after this if they want to
	private int order = Ordered.LOWEST_PRECEDENCE - 10;
	private final HttpExchangeRepository repository;
	private final Set<Include> includes;
	/**
	 * Create a new {@link HttpExchangesWebFilter} instance.
	 * @param repository the repository used to record events
	 * @param includes the include options
	 */
	public HttpExchangesWebFilter(HttpExchangeRepository repository, Set<Include> includes) {
		this.repository = repository;
		this.includes = includes;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
		Mono<?> principal = exchange.getPrincipal().cast(Object.class).defaultIfEmpty(NONE);
		Mono<Object> session = exchange.getSession().cast(Object.class).defaultIfEmpty(NONE);
		return Mono.zip(PrincipalAndSession::new, principal, session)
			.flatMap((principalAndSession) -> filter(exchange, chain, principalAndSession));
	}
	private Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain,
			PrincipalAndSession principalAndSession) {
		return Mono.fromRunnable(() -> addExchangeOnCommit(exchange, principalAndSession)).and(chain.filter(exchange));
	}
	private void addExchangeOnCommit(ServerWebExchange exchange, PrincipalAndSession principalAndSession) {
		RecordableServerHttpRequest sourceRequest = new RecordableServerHttpRequest(exchange.getRequest());
		HttpExchange.Started startedHttpExchange = HttpExchange.start(sourceRequest);
		exchange.getResponse().beforeCommit(() -> {
			RecordableServerHttpResponse sourceResponse = new RecordableServerHttpResponse(exchange.getResponse());
			HttpExchange finishedExchange = startedHttpExchange.finish(sourceResponse,
					principalAndSession::getPrincipal, principalAndSession::getSessionId, this.includes);
			this.repository.add(finishedExchange);
			return Mono.empty();
		});
	}
	/**
	 * A {@link Principal} and {@link WebSession}.
	 */
	private static class PrincipalAndSession {
		private final Principal principal;
		private final WebSession session;
		PrincipalAndSession(Object[] zipped) {
			this.principal = (zipped[0] != NONE) ? (Principal) zipped[0] : null;
			this.session = (zipped[1] != NONE) ? (WebSession) zipped[1] : null;
		}
		Principal getPrincipal() {
			return this.principal;
		}
		String getSessionId() {
			return (this.session != null && this.session.isStarted()) ? this.session.getId() : null;
		}
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.reactive;
/**
class RecordableServerHttpRequest implements RecordableHttpRequest {
	private final String method;
	private final Map<String, List<String>> headers;
	private final URI uri;
	private final String remoteAddress;
	RecordableServerHttpRequest(ServerHttpRequest request) {
		this.method = request.getMethod().name();
		this.headers = request.getHeaders();
		this.uri = request.getURI();
		this.remoteAddress = getRemoteAddress(request);
	}
	private static String getRemoteAddress(ServerHttpRequest request) {
		InetSocketAddress remoteAddress = request.getRemoteAddress();
		InetAddress address = (remoteAddress != null) ? remoteAddress.getAddress() : null;
		return (address != null) ? address.toString() : null;
	}
	@Override
	public String getMethod() {
		return this.method;
	}
	@Override
	public URI getUri() {
		return this.uri;
	}
	@Override
	public Map<String, List<String>> getHeaders() {
		return new LinkedHashMap<>(this.headers);
	}
	@Override
	public String getRemoteAddress() {
		return this.remoteAddress;
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.reactive;
/**
class RecordableServerHttpResponse implements RecordableHttpResponse {
	private final int status;
	private final Map<String, List<String>> headers;
	RecordableServerHttpResponse(ServerHttpResponse response) {
		this.status = (response.getStatusCode() != null) ? response.getStatusCode().value() : HttpStatus.OK.value();
		this.headers = new LinkedHashMap<>(response.getHeaders());
	}
	@Override
	public int getStatus() {
		return this.status;
	}
	@Override
	public Map<String, List<String>> getHeaders() {
		return this.headers;
	}
}
/*
/**
package org.springframework.boot.actuate.web.exchanges.reactive;
/*
package org.springframework.boot.actuate.web.mappings;
/**
public class HandlerMethodDescription {
	private final String className;
	private final String name;
	private final String descriptor;
	public HandlerMethodDescription(HandlerMethod handlerMethod) {
		this.name = handlerMethod.getMethod().getName();
		this.className = handlerMethod.getMethod().getDeclaringClass().getCanonicalName();
		this.descriptor = Type.getMethodDescriptor(handlerMethod.getMethod());
	}
	public String getName() {
		return this.name;
	}
	public String getDescriptor() {
		return this.descriptor;
	}
	public String getClassName() {
		return this.className;
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
@ImportRuntimeHints(ServletsMappingDescriptionProviderRuntimeHints.class)
public class ServletsMappingDescriptionProvider implements MappingDescriptionProvider {
	@Override
	public List<ServletRegistrationMappingDescription> describeMappings(ApplicationContext context) {
		if (context instanceof WebApplicationContext webApplicationContext) {
			return webApplicationContext.getServletContext()
				.getServletRegistrations()
				.values()
				.stream()
				.map(ServletRegistrationMappingDescription::new)
				.toList();
		}
		return Collections.emptyList();
	}
	@Override
	public String getMappingName() {
		return 'servlets';
	}
	static class ServletsMappingDescriptionProviderRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(),
					ServletRegistrationMappingDescription.class);
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
@ImportRuntimeHints(DispatcherServletsMappingDescriptionProviderRuntimeHints.class)
public class DispatcherServletsMappingDescriptionProvider implements MappingDescriptionProvider {
	private static final List<HandlerMappingDescriptionProvider<?>> descriptionProviders;
	static {
		List<HandlerMappingDescriptionProvider<?>> providers = new ArrayList<>();
		providers.add(new RequestMappingInfoHandlerMappingDescriptionProvider());
		providers.add(new UrlHandlerMappingDescriptionProvider());
		providers.add(new IterableDelegatesHandlerMappingDescriptionProvider(new ArrayList<>(providers)));
		descriptionProviders = Collections.unmodifiableList(providers);
	}
	@Override
	public String getMappingName() {
		return 'dispatcherServlets';
	}
	@Override
	public Map<String, List<DispatcherServletMappingDescription>> describeMappings(ApplicationContext context) {
		if (context instanceof WebApplicationContext webApplicationContext) {
			return describeMappings(webApplicationContext);
		}
		return Collections.emptyMap();
	}
	private Map<String, List<DispatcherServletMappingDescription>> describeMappings(WebApplicationContext context) {
		Map<String, List<DispatcherServletMappingDescription>> mappings = new HashMap<>();
		determineDispatcherServlets(context).forEach((name, dispatcherServlet) -> mappings.put(name,
				describeMappings(new DispatcherServletHandlerMappings(name, dispatcherServlet, context))));
		return mappings;
	}
	private Map<String, DispatcherServlet> determineDispatcherServlets(WebApplicationContext context) {
		Map<String, DispatcherServlet> dispatcherServlets = new LinkedHashMap<>();
		context.getBeansOfType(ServletRegistrationBean.class).values().forEach((registration) -> {
			Servlet servlet = registration.getServlet();
			if (servlet instanceof DispatcherServlet && !dispatcherServlets.containsValue(servlet)) {
				dispatcherServlets.put(registration.getServletName(), (DispatcherServlet) servlet);
			}
		});
		context.getBeansOfType(DispatcherServlet.class).forEach((name, dispatcherServlet) -> {
			if (!dispatcherServlets.containsValue(dispatcherServlet)) {
				dispatcherServlets.put(name, dispatcherServlet);
			}
		});
		return dispatcherServlets;
	}
	private List<DispatcherServletMappingDescription> describeMappings(DispatcherServletHandlerMappings mappings) {
		return mappings.getHandlerMappings().stream().flatMap(this::describe).toList();
	}
	private <T> Stream<DispatcherServletMappingDescription> describe(T handlerMapping) {
		return describe(handlerMapping, descriptionProviders).stream();
	}
	@SuppressWarnings('unchecked')
	private static <T> List<DispatcherServletMappingDescription> describe(T handlerMapping,
			List<HandlerMappingDescriptionProvider<?>> descriptionProviders) {
		for (HandlerMappingDescriptionProvider<?> descriptionProvider : descriptionProviders) {
			if (descriptionProvider.getMappingClass().isInstance(handlerMapping)) {
				return ((HandlerMappingDescriptionProvider<T>) descriptionProvider).describe(handlerMapping);
			}
		}
		return Collections.emptyList();
	}
	private interface HandlerMappingDescriptionProvider<T> {
		Class<T> getMappingClass();
		List<DispatcherServletMappingDescription> describe(T handlerMapping);
	}
	private static final class RequestMappingInfoHandlerMappingDescriptionProvider
			implements HandlerMappingDescriptionProvider<RequestMappingInfoHandlerMapping> {
		@Override
		public Class<RequestMappingInfoHandlerMapping> getMappingClass() {
			return RequestMappingInfoHandlerMapping.class;
		}
		@Override
		public List<DispatcherServletMappingDescription> describe(RequestMappingInfoHandlerMapping handlerMapping) {
			Map<RequestMappingInfo, HandlerMethod> handlerMethods = handlerMapping.getHandlerMethods();
			return handlerMethods.entrySet().stream().map(this::describe).toList();
		}
		private DispatcherServletMappingDescription describe(Entry<RequestMappingInfo, HandlerMethod> mapping) {
			DispatcherServletMappingDetails mappingDetails = new DispatcherServletMappingDetails();
			mappingDetails.setHandlerMethod(new HandlerMethodDescription(mapping.getValue()));
			mappingDetails.setRequestMappingConditions(new RequestMappingConditionsDescription(mapping.getKey()));
			return new DispatcherServletMappingDescription(mapping.getKey().toString(), mapping.getValue().toString(),
					mappingDetails);
		}
	}
	private static final class UrlHandlerMappingDescriptionProvider
			implements HandlerMappingDescriptionProvider<AbstractUrlHandlerMapping> {
		@Override
		public Class<AbstractUrlHandlerMapping> getMappingClass() {
			return AbstractUrlHandlerMapping.class;
		}
		@Override
		public List<DispatcherServletMappingDescription> describe(AbstractUrlHandlerMapping handlerMapping) {
			return handlerMapping.getHandlerMap().entrySet().stream().map(this::describe).toList();
		}
		private DispatcherServletMappingDescription describe(Entry<String, Object> mapping) {
			return new DispatcherServletMappingDescription(mapping.getKey(), mapping.getValue().toString(), null);
		}
	}
	@SuppressWarnings('rawtypes')
	private static final class IterableDelegatesHandlerMappingDescriptionProvider
			implements HandlerMappingDescriptionProvider<Iterable> {
		private final List<HandlerMappingDescriptionProvider<?>> descriptionProviders;
		private IterableDelegatesHandlerMappingDescriptionProvider(
				List<HandlerMappingDescriptionProvider<?>> descriptionProviders) {
			this.descriptionProviders = descriptionProviders;
		}
		@Override
		public Class<Iterable> getMappingClass() {
			return Iterable.class;
		}
		@Override
		public List<DispatcherServletMappingDescription> describe(Iterable handlerMapping) {
			List<DispatcherServletMappingDescription> descriptions = new ArrayList<>();
			for (Object delegate : handlerMapping) {
				descriptions
					.addAll(DispatcherServletsMappingDescriptionProvider.describe(delegate, this.descriptionProviders));
			}
			return descriptions;
		}
	}
	static class DispatcherServletsMappingDescriptionProviderRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(),
					DispatcherServletMappingDescription.class);
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
@ImportRuntimeHints(FiltersMappingDescriptionProviderRuntimeHints.class)
public class FiltersMappingDescriptionProvider implements MappingDescriptionProvider {
	@Override
	public List<FilterRegistrationMappingDescription> describeMappings(ApplicationContext context) {
		if (context instanceof WebApplicationContext webApplicationContext) {
			return webApplicationContext.getServletContext()
				.getFilterRegistrations()
				.values()
				.stream()
				.map(FilterRegistrationMappingDescription::new)
				.toList();
		}
		return Collections.emptyList();
	}
	@Override
	public String getMappingName() {
		return 'servletFilters';
	}
	static class FiltersMappingDescriptionProviderRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(),
					FilterRegistrationMappingDescription.class);
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
public class FilterRegistrationMappingDescription extends RegistrationMappingDescription<FilterRegistration> {
	/**
	 * Creates a new {@code FilterRegistrationMappingDescription} derived from the given
	 * {@code filterRegistration}.
	 * @param filterRegistration the filter registration
	 */
	public FilterRegistrationMappingDescription(FilterRegistration filterRegistration) {
		super(filterRegistration);
	}
	/**
	 * Returns the servlet name mappings for the registered filter.
	 * @return the mappings
	 */
	public Collection<String> getServletNameMappings() {
		return getRegistration().getServletNameMappings();
	}
	/**
	 * Returns the URL pattern mappings for the registered filter.
	 * @return the mappings
	 */
	public Collection<String> getUrlPatternMappings() {
		return getRegistration().getUrlPatternMappings();
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
final class DispatcherServletHandlerMappings {
	private final String name;
	private final DispatcherServlet dispatcherServlet;
	private final WebApplicationContext applicationContext;
	DispatcherServletHandlerMappings(String name, DispatcherServlet dispatcherServlet,
			WebApplicationContext applicationContext) {
		this.name = name;
		this.dispatcherServlet = dispatcherServlet;
		this.applicationContext = applicationContext;
	}
	List<HandlerMapping> getHandlerMappings() {
		List<HandlerMapping> handlerMappings = this.dispatcherServlet.getHandlerMappings();
		if (handlerMappings == null) {
			initializeDispatcherServletIfPossible();
			handlerMappings = this.dispatcherServlet.getHandlerMappings();
		}
		return (handlerMappings != null) ? handlerMappings : Collections.emptyList();
	}
	private void initializeDispatcherServletIfPossible() {
		if (!(this.applicationContext instanceof ServletWebServerApplicationContext webServerApplicationContext)) {
			return;
		}
		WebServer webServer = webServerApplicationContext.getWebServer();
		if (webServer instanceof UndertowServletWebServer undertowServletWebServer) {
			new UndertowServletInitializer(undertowServletWebServer).initializeServlet(this.name);
		}
		else if (webServer instanceof TomcatWebServer tomcatWebServer) {
			new TomcatServletInitializer(tomcatWebServer).initializeServlet(this.name);
		}
	}
	String getName() {
		return this.name;
	}
	private static final class TomcatServletInitializer {
		private final TomcatWebServer webServer;
		private TomcatServletInitializer(TomcatWebServer webServer) {
			this.webServer = webServer;
		}
		void initializeServlet(String name) {
			findContext().ifPresent((context) -> initializeServlet(context, name));
		}
		private Optional<Context> findContext() {
			return Stream.of(this.webServer.getTomcat().getHost().findChildren())
				.filter(Context.class::isInstance)
				.map(Context.class::cast)
				.findFirst();
		}
		private void initializeServlet(Context context, String name) {
			Container child = context.findChild(name);
			if (child instanceof StandardWrapper wrapper) {
				try {
					wrapper.deallocate(wrapper.allocate());
				}
				catch (ServletException ex) {
					// Continue
				}
			}
		}
	}
	private static final class UndertowServletInitializer {
		private final UndertowServletWebServer webServer;
		private UndertowServletInitializer(UndertowServletWebServer webServer) {
			this.webServer = webServer;
		}
		void initializeServlet(String name) {
			try {
				this.webServer.getDeploymentManager().getDeployment().getServlets().getManagedServlet(name).forceInit();
			}
			catch (ServletException ex) {
				// Continue
			}
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
public class DispatcherServletMappingDescription {
	private final String handler;
	private final String predicate;
	private final DispatcherServletMappingDetails details;
	DispatcherServletMappingDescription(String predicate, String handler, DispatcherServletMappingDetails details) {
		this.handler = handler;
		this.predicate = predicate;
		this.details = details;
	}
	public String getHandler() {
		return this.handler;
	}
	public String getPredicate() {
		return this.predicate;
	}
	public DispatcherServletMappingDetails getDetails() {
		return this.details;
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
public class DispatcherServletMappingDetails {
	private HandlerMethodDescription handlerMethod;
	private RequestMappingConditionsDescription requestMappingConditions;
	public HandlerMethodDescription getHandlerMethod() {
		return this.handlerMethod;
	}
	void setHandlerMethod(HandlerMethodDescription handlerMethod) {
		this.handlerMethod = handlerMethod;
	}
	public RequestMappingConditionsDescription getRequestMappingConditions() {
		return this.requestMappingConditions;
	}
	void setRequestMappingConditions(RequestMappingConditionsDescription requestMappingConditions) {
		this.requestMappingConditions = requestMappingConditions;
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
public class RequestMappingConditionsDescription {
	private final List<MediaTypeExpressionDescription> consumes;
	private final List<NameValueExpressionDescription> headers;
	private final Set<RequestMethod> methods;
	private final List<NameValueExpressionDescription> params;
	private final Set<String> patterns;
	private final List<MediaTypeExpressionDescription> produces;
	RequestMappingConditionsDescription(RequestMappingInfo requestMapping) {
		this.consumes = requestMapping.getConsumesCondition()
			.getExpressions()
			.stream()
			.map(MediaTypeExpressionDescription::new)
			.toList();
		this.headers = requestMapping.getHeadersCondition()
			.getExpressions()
			.stream()
			.map(NameValueExpressionDescription::new)
			.toList();
		this.methods = requestMapping.getMethodsCondition().getMethods();
		this.params = requestMapping.getParamsCondition()
			.getExpressions()
			.stream()
			.map(NameValueExpressionDescription::new)
			.toList();
		this.patterns = extractPathPatterns(requestMapping);
		this.produces = requestMapping.getProducesCondition()
			.getExpressions()
			.stream()
			.map(MediaTypeExpressionDescription::new)
			.toList();
	}
	private Set<String> extractPathPatterns(RequestMappingInfo requestMapping) {
		PatternsRequestCondition patternsCondition = requestMapping.getPatternsCondition();
		return (patternsCondition != null) ? patternsCondition.getPatterns()
				: requestMapping.getPathPatternsCondition().getPatternValues();
	}
	public List<MediaTypeExpressionDescription> getConsumes() {
		return this.consumes;
	}
	public List<NameValueExpressionDescription> getHeaders() {
		return this.headers;
	}
	public Set<RequestMethod> getMethods() {
		return this.methods;
	}
	public List<NameValueExpressionDescription> getParams() {
		return this.params;
	}
	public Set<String> getPatterns() {
		return this.patterns;
	}
	public List<MediaTypeExpressionDescription> getProduces() {
		return this.produces;
	}
	/**
	 * A description of a {@link MediaTypeExpression} in a request mapping condition.
	 */
	public static class MediaTypeExpressionDescription {
		private final String mediaType;
		private final boolean negated;
		MediaTypeExpressionDescription(MediaTypeExpression expression) {
			this.mediaType = expression.getMediaType().toString();
			this.negated = expression.isNegated();
		}
		public String getMediaType() {
			return this.mediaType;
		}
		public boolean isNegated() {
			return this.negated;
		}
	}
	/**
	 * A description of a {@link NameValueExpression} in a request mapping condition.
	 */
	public static class NameValueExpressionDescription {
		private final String name;
		private final Object value;
		private final boolean negated;
		NameValueExpressionDescription(NameValueExpression<?> expression) {
			this.name = expression.getName();
			this.value = expression.getValue();
			this.negated = expression.isNegated();
		}
		public String getName() {
			return this.name;
		}
		public Object getValue() {
			return this.value;
		}
		public boolean isNegated() {
			return this.negated;
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
public class ServletRegistrationMappingDescription extends RegistrationMappingDescription<ServletRegistration> {
	/**
	 * Creates a new {@code ServletRegistrationMappingDescription} derived from the given
	 * {@code servletRegistration}.
	 * @param servletRegistration the servlet registration
	 */
	public ServletRegistrationMappingDescription(ServletRegistration servletRegistration) {
		super(servletRegistration);
	}
	/**
	 * Returns the mappings for the registered servlet.
	 * @return the mappings
	 */
	public Collection<String> getMappings() {
		return getRegistration().getMappings();
	}
}
/*
/**
package org.springframework.boot.actuate.web.mappings.servlet;
/*
package org.springframework.boot.actuate.web.mappings.servlet;
/**
public class RegistrationMappingDescription<T extends Registration> {
	private final T registration;
	/**
	 * Creates a new {@link RegistrationMappingDescription} derived from the given
	 * {@code registration} and with the given {@code predicate}.
	 * @param registration the registration
	 */
	public RegistrationMappingDescription(T registration) {
		this.registration = registration;
	}
	/**
	 * Returns the name of the registered Filter or Servlet.
	 * @return the name
	 */
	public String getName() {
		return this.registration.getName();
	}
	/**
	 * Returns the class name of the registered Filter or Servlet.
	 * @return the class name
	 */
	public String getClassName() {
		return this.registration.getClassName();
	}
	/**
	 * Returns the registration that is being described.
	 * @return the registration
	 */
	protected final T getRegistration() {
		return this.registration;
	}
}
/*
package org.springframework.boot.actuate.web.mappings;
/**
@Endpoint(id = 'mappings')
public class MappingsEndpoint {
	private final Collection<MappingDescriptionProvider> descriptionProviders;
	private final ApplicationContext context;
	public MappingsEndpoint(Collection<MappingDescriptionProvider> descriptionProviders, ApplicationContext context) {
		this.descriptionProviders = descriptionProviders;
		this.context = context;
	}
	@ReadOperation
	public ApplicationMappingsDescriptor mappings() {
		ApplicationContext target = this.context;
		Map<String, ContextMappingsDescriptor> contextMappings = new HashMap<>();
		while (target != null) {
			contextMappings.put(target.getId(), mappingsForContext(target));
			target = target.getParent();
		}
		return new ApplicationMappingsDescriptor(contextMappings);
	}
	private ContextMappingsDescriptor mappingsForContext(ApplicationContext applicationContext) {
		Map<String, Object> mappings = new HashMap<>();
		this.descriptionProviders.forEach(
				(provider) -> mappings.put(provider.getMappingName(), provider.describeMappings(applicationContext)));
		return new ContextMappingsDescriptor(mappings,
				(applicationContext.getParent() != null) ? applicationContext.getId() : null);
	}
	/**
	 * Description of an application"s request mappings.
	 */
	public static final class ApplicationMappingsDescriptor implements OperationResponseBody {
		private final Map<String, ContextMappingsDescriptor> contextMappings;
		private ApplicationMappingsDescriptor(Map<String, ContextMappingsDescriptor> contextMappings) {
			this.contextMappings = contextMappings;
		}
		public Map<String, ContextMappingsDescriptor> getContexts() {
			return this.contextMappings;
		}
	}
	/**
	 * Description of an application context"s request mappings.
	 */
	public static final class ContextMappingsDescriptor {
		private final Map<String, Object> mappings;
		private final String parentId;
		private ContextMappingsDescriptor(Map<String, Object> mappings, String parentId) {
			this.mappings = mappings;
			this.parentId = parentId;
		}
		public String getParentId() {
			return this.parentId;
		}
		public Map<String, Object> getMappings() {
			return this.mappings;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.web.mappings;
/*
package org.springframework.boot.actuate.web.mappings;
/**
public interface MappingDescriptionProvider {
	/**
	 * Returns the name of the mappings described by this provider.
	 * @return the name of the mappings
	 */
	String getMappingName();
	/**
	 * Produce the descriptions of the mappings identified by this provider in the given
	 * {@code context}.
	 * @param context the application context to introspect
	 * @return the mapping descriptions
	 */
	Object describeMappings(ApplicationContext context);
}
/*
package org.springframework.boot.actuate.web.mappings.reactive;
/**
public class DispatcherHandlerMappingDescription {
	private final String predicate;
	private final String handler;
	private final DispatcherHandlerMappingDetails details;
	DispatcherHandlerMappingDescription(String predicate, String handler, DispatcherHandlerMappingDetails details) {
		this.predicate = predicate;
		this.handler = handler;
		this.details = details;
	}
	public String getHandler() {
		return this.handler;
	}
	public String getPredicate() {
		return this.predicate;
	}
	public DispatcherHandlerMappingDetails getDetails() {
		return this.details;
	}
}
/*
package org.springframework.boot.actuate.web.mappings.reactive;
/**
public class HandlerFunctionDescription {
	private final String className;
	HandlerFunctionDescription(HandlerFunction<?> handlerFunction) {
		this.className = getHandlerFunctionClassName(handlerFunction);
	}
	private static String getHandlerFunctionClassName(HandlerFunction<?> handlerFunction) {
		Class<?> functionClass = handlerFunction.getClass();
		String canonicalName = functionClass.getCanonicalName();
		return (canonicalName != null) ? canonicalName : functionClass.getName();
	}
	public String getClassName() {
		return this.className;
	}
}
/*
package org.springframework.boot.actuate.web.mappings.reactive;
/**
@ImportRuntimeHints(DispatcherHandlersMappingDescriptionProviderRuntimeHints.class)
public class DispatcherHandlersMappingDescriptionProvider implements MappingDescriptionProvider {
	private static final List<HandlerMappingDescriptionProvider<? extends HandlerMapping>> descriptionProviders = Arrays
		.asList(new RequestMappingInfoHandlerMappingDescriptionProvider(), new UrlHandlerMappingDescriptionProvider(),
				new RouterFunctionMappingDescriptionProvider());
	@Override
	public String getMappingName() {
		return 'dispatcherHandlers';
	}
	@Override
	public Map<String, List<DispatcherHandlerMappingDescription>> describeMappings(ApplicationContext context) {
		Map<String, List<DispatcherHandlerMappingDescription>> mappings = new HashMap<>();
		context.getBeansOfType(DispatcherHandler.class)
			.forEach((name, handler) -> mappings.put(name, describeMappings(handler)));
		return mappings;
	}
	private List<DispatcherHandlerMappingDescription> describeMappings(DispatcherHandler dispatcherHandler) {
		return dispatcherHandler.getHandlerMappings().stream().flatMap(this::describe).toList();
	}
	@SuppressWarnings('unchecked')
	private <T extends HandlerMapping> Stream<DispatcherHandlerMappingDescription> describe(T handlerMapping) {
		for (HandlerMappingDescriptionProvider<?> descriptionProvider : descriptionProviders) {
			if (descriptionProvider.getMappingClass().isInstance(handlerMapping)) {
				return ((HandlerMappingDescriptionProvider<T>) descriptionProvider).describe(handlerMapping).stream();
			}
		}
		return Stream.empty();
	}
	private interface HandlerMappingDescriptionProvider<T extends HandlerMapping> {
		Class<T> getMappingClass();
		List<DispatcherHandlerMappingDescription> describe(T handlerMapping);
	}
	private static final class RequestMappingInfoHandlerMappingDescriptionProvider
			implements HandlerMappingDescriptionProvider<RequestMappingInfoHandlerMapping> {
		@Override
		public Class<RequestMappingInfoHandlerMapping> getMappingClass() {
			return RequestMappingInfoHandlerMapping.class;
		}
		@Override
		public List<DispatcherHandlerMappingDescription> describe(RequestMappingInfoHandlerMapping handlerMapping) {
			Map<RequestMappingInfo, HandlerMethod> handlerMethods = handlerMapping.getHandlerMethods();
			return handlerMethods.entrySet().stream().map(this::describe).toList();
		}
		private DispatcherHandlerMappingDescription describe(Entry<RequestMappingInfo, HandlerMethod> mapping) {
			DispatcherHandlerMappingDetails handlerMapping = new DispatcherHandlerMappingDetails();
			handlerMapping.setHandlerMethod(new HandlerMethodDescription(mapping.getValue()));
			handlerMapping.setRequestMappingConditions(new RequestMappingConditionsDescription(mapping.getKey()));
			return new DispatcherHandlerMappingDescription(mapping.getKey().toString(), mapping.getValue().toString(),
					handlerMapping);
		}
	}
	private static final class UrlHandlerMappingDescriptionProvider
			implements HandlerMappingDescriptionProvider<AbstractUrlHandlerMapping> {
		@Override
		public Class<AbstractUrlHandlerMapping> getMappingClass() {
			return AbstractUrlHandlerMapping.class;
		}
		@Override
		public List<DispatcherHandlerMappingDescription> describe(AbstractUrlHandlerMapping handlerMapping) {
			return handlerMapping.getHandlerMap().entrySet().stream().map(this::describe).toList();
		}
		private DispatcherHandlerMappingDescription describe(Entry<PathPattern, Object> mapping) {
			return new DispatcherHandlerMappingDescription(mapping.getKey().getPatternString(),
					mapping.getValue().toString(), null);
		}
	}
	private static final class RouterFunctionMappingDescriptionProvider
			implements HandlerMappingDescriptionProvider<RouterFunctionMapping> {
		@Override
		public Class<RouterFunctionMapping> getMappingClass() {
			return RouterFunctionMapping.class;
		}
		@Override
		public List<DispatcherHandlerMappingDescription> describe(RouterFunctionMapping handlerMapping) {
			MappingDescriptionVisitor visitor = new MappingDescriptionVisitor();
			RouterFunction<?> routerFunction = handlerMapping.getRouterFunction();
			if (routerFunction != null) {
				routerFunction.accept(visitor);
			}
			return visitor.descriptions;
		}
	}
	private static final class MappingDescriptionVisitor implements Visitor {
		private final List<DispatcherHandlerMappingDescription> descriptions = new ArrayList<>();
		@Override
		public void startNested(RequestPredicate predicate) {
		}
		@Override
		public void endNested(RequestPredicate predicate) {
		}
		@Override
		public void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction) {
			DispatcherHandlerMappingDetails details = new DispatcherHandlerMappingDetails();
			details.setHandlerFunction(new HandlerFunctionDescription(handlerFunction));
			this.descriptions.add(
					new DispatcherHandlerMappingDescription(predicate.toString(), handlerFunction.toString(), details));
		}
		@Override
		public void resources(Function<ServerRequest, Mono<Resource>> lookupFunction) {
		}
		@Override
		public void attributes(Map<String, Object> attributes) {
		}
		@Override
		public void unknown(RouterFunction<?> routerFunction) {
		}
	}
	static class DispatcherHandlersMappingDescriptionProviderRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(),
					DispatcherHandlerMappingDescription.class);
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.reactive;
/**
public class RequestMappingConditionsDescription {
	private final List<MediaTypeExpressionDescription> consumes;
	private final List<NameValueExpressionDescription> headers;
	private final Set<RequestMethod> methods;
	private final List<NameValueExpressionDescription> params;
	private final Set<String> patterns;
	private final List<MediaTypeExpressionDescription> produces;
	RequestMappingConditionsDescription(RequestMappingInfo requestMapping) {
		this.consumes = requestMapping.getConsumesCondition()
			.getExpressions()
			.stream()
			.map(MediaTypeExpressionDescription::new)
			.toList();
		this.headers = requestMapping.getHeadersCondition()
			.getExpressions()
			.stream()
			.map(NameValueExpressionDescription::new)
			.toList();
		this.methods = requestMapping.getMethodsCondition().getMethods();
		this.params = requestMapping.getParamsCondition()
			.getExpressions()
			.stream()
			.map(NameValueExpressionDescription::new)
			.toList();
		this.patterns = requestMapping.getPatternsCondition()
			.getPatterns()
			.stream()
			.map(PathPattern::getPatternString)
			.collect(Collectors.collectingAndThen(Collectors.toSet(), Collections::unmodifiableSet));
		this.produces = requestMapping.getProducesCondition()
			.getExpressions()
			.stream()
			.map(MediaTypeExpressionDescription::new)
			.toList();
	}
	public List<MediaTypeExpressionDescription> getConsumes() {
		return this.consumes;
	}
	public List<NameValueExpressionDescription> getHeaders() {
		return this.headers;
	}
	public Set<RequestMethod> getMethods() {
		return this.methods;
	}
	public List<NameValueExpressionDescription> getParams() {
		return this.params;
	}
	public Set<String> getPatterns() {
		return this.patterns;
	}
	public List<MediaTypeExpressionDescription> getProduces() {
		return this.produces;
	}
	/**
	 * A description of a {@link MediaTypeExpression} in a request mapping condition.
	 */
	public static class MediaTypeExpressionDescription {
		private final String mediaType;
		private final boolean negated;
		MediaTypeExpressionDescription(MediaTypeExpression expression) {
			this.mediaType = expression.getMediaType().toString();
			this.negated = expression.isNegated();
		}
		public String getMediaType() {
			return this.mediaType;
		}
		public boolean isNegated() {
			return this.negated;
		}
	}
	/**
	 * A description of a {@link NameValueExpression} in a request mapping condition.
	 */
	public static class NameValueExpressionDescription {
		private final String name;
		private final Object value;
		private final boolean negated;
		NameValueExpressionDescription(NameValueExpression<?> expression) {
			this.name = expression.getName();
			this.value = expression.getValue();
			this.negated = expression.isNegated();
		}
		public String getName() {
			return this.name;
		}
		public Object getValue() {
			return this.value;
		}
		public boolean isNegated() {
			return this.negated;
		}
	}
}
/*
package org.springframework.boot.actuate.web.mappings.reactive;
/**
public class DispatcherHandlerMappingDetails {
	private HandlerMethodDescription handlerMethod;
	private HandlerFunctionDescription handlerFunction;
	private RequestMappingConditionsDescription requestMappingConditions;
	public HandlerMethodDescription getHandlerMethod() {
		return this.handlerMethod;
	}
	void setHandlerMethod(HandlerMethodDescription handlerMethod) {
		this.handlerMethod = handlerMethod;
	}
	public HandlerFunctionDescription getHandlerFunction() {
		return this.handlerFunction;
	}
	void setHandlerFunction(HandlerFunctionDescription handlerFunction) {
		this.handlerFunction = handlerFunction;
	}
	public RequestMappingConditionsDescription getRequestMappingConditions() {
		return this.requestMappingConditions;
	}
	void setRequestMappingConditions(RequestMappingConditionsDescription requestMappingConditions) {
		this.requestMappingConditions = requestMappingConditions;
	}
}
/*
/**
package org.springframework.boot.actuate.web.mappings.reactive;
/*
package org.springframework.boot.actuate.integration;
/**
@Endpoint(id = 'integrationgraph')
public class IntegrationGraphEndpoint {
	private final IntegrationGraphServer graphServer;
	/**
	 * Create a new {@code IntegrationGraphEndpoint} instance that exposes a graph
	 * containing all the Spring Integration components in the given
	 * {@link IntegrationGraphServer}.
	 * @param graphServer the integration graph server
	 */
	public IntegrationGraphEndpoint(IntegrationGraphServer graphServer) {
		this.graphServer = graphServer;
	}
	@ReadOperation
	public GraphDescriptor graph() {
		return new GraphDescriptor(this.graphServer.getGraph());
	}
	@WriteOperation
	public void rebuild() {
		this.graphServer.rebuild();
	}
	/**
	 * Description of a {@link Graph}.
	 */
	public static class GraphDescriptor implements OperationResponseBody {
		private final Map<String, Object> contentDescriptor;
		private final Collection<IntegrationNode> nodes;
		private final Collection<LinkNode> links;
		GraphDescriptor(Graph graph) {
			this.contentDescriptor = graph.getContentDescriptor();
			this.nodes = graph.getNodes();
			this.links = graph.getLinks();
		}
		public Map<String, Object> getContentDescriptor() {
			return this.contentDescriptor;
		}
		public Collection<IntegrationNode> getNodes() {
			return this.nodes;
		}
		public Collection<LinkNode> getLinks() {
			return this.links;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.integration;
/*
package org.springframework.boot.actuate.health;
/**
class CompositeHealthContributorMapAdapter<V> extends NamedContributorsMapAdapter<V, HealthContributor>
		implements CompositeHealthContributor {
	CompositeHealthContributorMapAdapter(Map<String, V> map, Function<V, ? extends HealthContributor> valueAdapter) {
		super(map, valueAdapter);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class DefaultContributorRegistry<C> implements ContributorRegistry<C> {
	private final Function<String, String> nameFactory;
	private final Object monitor = new Object();
	private volatile Map<String, C> contributors;
	DefaultContributorRegistry() {
		this(Collections.emptyMap());
	}
	DefaultContributorRegistry(Map<String, C> contributors) {
		this(contributors, HealthContributorNameFactory.INSTANCE);
	}
	DefaultContributorRegistry(Map<String, C> contributors, Function<String, String> nameFactory) {
		Assert.notNull(contributors, 'Contributors must not be null');
		Assert.notNull(nameFactory, 'NameFactory must not be null');
		this.nameFactory = nameFactory;
		Map<String, C> namedContributors = new LinkedHashMap<>();
		contributors.forEach((name, contributor) -> namedContributors.put(nameFactory.apply(name), contributor));
		this.contributors = Collections.unmodifiableMap(namedContributors);
	}
	@Override
	public void registerContributor(String name, C contributor) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(contributor, 'Contributor must not be null');
		String adaptedName = this.nameFactory.apply(name);
		synchronized (this.monitor) {
			Assert.state(!this.contributors.containsKey(adaptedName),
					() -> 'A contributor named \'' + adaptedName + '\' has already been registered');
			Map<String, C> contributors = new LinkedHashMap<>(this.contributors);
			contributors.put(adaptedName, contributor);
			this.contributors = Collections.unmodifiableMap(contributors);
		}
	}
	@Override
	public C unregisterContributor(String name) {
		Assert.notNull(name, 'Name must not be null');
		String adaptedName = this.nameFactory.apply(name);
		synchronized (this.monitor) {
			C unregistered = this.contributors.get(adaptedName);
			if (unregistered != null) {
				Map<String, C> contributors = new LinkedHashMap<>(this.contributors);
				contributors.remove(adaptedName);
				this.contributors = Collections.unmodifiableMap(contributors);
			}
			return unregistered;
		}
	}
	@Override
	public C getContributor(String name) {
		return this.contributors.get(name);
	}
	@Override
	public Iterator<NamedContributor<C>> iterator() {
		Iterator<Map.Entry<String, C>> iterator = this.contributors.entrySet().iterator();
		return new Iterator<>() {
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
			@Override
			public NamedContributor<C> next() {
				Entry<String, C> entry = iterator.next();
				return NamedContributor.of(entry.getKey(), entry.getValue());
			}
		};
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public class DefaultReactiveHealthContributorRegistry extends DefaultContributorRegistry<ReactiveHealthContributor>
		implements ReactiveHealthContributorRegistry {
	public DefaultReactiveHealthContributorRegistry() {
	}
	public DefaultReactiveHealthContributorRegistry(Map<String, ReactiveHealthContributor> contributors) {
		super(contributors);
	}
	public DefaultReactiveHealthContributorRegistry(Map<String, ReactiveHealthContributor> contributors,
			Function<String, String> nameFactory) {
		super(contributors, nameFactory);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface ContributorRegistry<C> extends NamedContributors<C> {
	/**
	 * Register a contributor with the given {@code name}.
	 * @param name the name of the contributor
	 * @param contributor the contributor to register
	 * @throws IllegalStateException if the contributor cannot be registered with the
	 * given {@code name}.
	 */
	void registerContributor(String name, C contributor);
	/**
	 * Unregister a previously registered contributor.
	 * @param name the name of the contributor to unregister
	 * @return the unregistered indicator, or {@code null} if no indicator was found in
	 * the registry for the given {@code name}.
	 */
	C unregisterContributor(String name);
}
/*
package org.springframework.boot.actuate.health;
/**
@FunctionalInterface
public interface ReactiveHealthIndicator extends ReactiveHealthContributor {
	/**
	 * Provide the indicator of health.
	 * @param includeDetails if details should be included or removed
	 * @return a {@link Mono} that provides the {@link Health}
	 * @since 2.2.0
	 */
	default Mono<Health> getHealth(boolean includeDetails) {
		Mono<Health> health = health();
		return includeDetails ? health : health.map(Health::withoutDetails);
	}
	/**
	 * Provide the indicator of health.
	 * @return a {@link Mono} that provides the {@link Health}
	 */
	Mono<Health> health();
}
/*
package org.springframework.boot.actuate.health;
/**
public interface NamedContributor<C> {
	/**
	 * Returns the name of the contributor.
	 * @return the contributor name
	 */
	String getName();
	/**
	 * Returns the contributor instance.
	 * @return the contributor instance
	 */
	C getContributor();
	static <C> NamedContributor<C> of(String name, C contributor) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(contributor, 'Contributor must not be null');
		return new NamedContributor<>() {
			@Override
			public String getName() {
				return name;
			}
			@Override
			public C getContributor() {
				return contributor;
			}
		};
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public class SimpleHttpCodeStatusMapper implements HttpCodeStatusMapper {
	private static final Map<String, Integer> DEFAULT_MAPPINGS;
	static {
		Map<String, Integer> defaultMappings = new HashMap<>();
		defaultMappings.put(Status.DOWN.getCode(), WebEndpointResponse.STATUS_SERVICE_UNAVAILABLE);
		defaultMappings.put(Status.OUT_OF_SERVICE.getCode(), WebEndpointResponse.STATUS_SERVICE_UNAVAILABLE);
		DEFAULT_MAPPINGS = getUniformMappings(defaultMappings);
	}
	private final Map<String, Integer> mappings;
	/**
	 * Create a new {@link SimpleHttpCodeStatusMapper} instance using default mappings.
	 */
	public SimpleHttpCodeStatusMapper() {
		this(null);
	}
	/**
	 * Create a new {@link SimpleHttpCodeStatusMapper} with the specified mappings.
	 * @param mappings the mappings to use or {@code null} to use the default mappings
	 */
	public SimpleHttpCodeStatusMapper(Map<String, Integer> mappings) {
		this.mappings = CollectionUtils.isEmpty(mappings) ? DEFAULT_MAPPINGS : getUniformMappings(mappings);
	}
	@Override
	public int getStatusCode(Status status) {
		String code = getUniformCode(status.getCode());
		return this.mappings.getOrDefault(code, WebEndpointResponse.STATUS_OK);
	}
	private static Map<String, Integer> getUniformMappings(Map<String, Integer> mappings) {
		Map<String, Integer> result = new LinkedHashMap<>();
		for (Map.Entry<String, Integer> entry : mappings.entrySet()) {
			String code = getUniformCode(entry.getKey());
			if (code != null) {
				result.putIfAbsent(code, entry.getValue());
			}
		}
		return Collections.unmodifiableMap(result);
	}
	private static String getUniformCode(String code) {
		if (code == null) {
			return null;
		}
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < code.length(); i++) {
			char ch = code.charAt(i);
			if (Character.isAlphabetic(ch) || Character.isDigit(ch)) {
				builder.append(Character.toLowerCase(ch));
			}
		}
		return builder.toString();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@EndpointWebExtension(endpoint = HealthEndpoint.class)
@ImportRuntimeHints(HealthEndpointWebExtensionRuntimeHints.class)
public class HealthEndpointWebExtension extends HealthEndpointSupport<HealthContributor, HealthComponent> {
	private static final String[] NO_PATH = {};
	/**
	 * Create a new {@link HealthEndpointWebExtension} instance.
	 * @param registry the health contributor registry
	 * @param groups the health endpoint groups
	 * @param slowIndicatorLoggingThreshold duration after which slow health indicator
	 * logging should occur
	 * @since 2.6.9
	 */
	public HealthEndpointWebExtension(HealthContributorRegistry registry, HealthEndpointGroups groups,
			Duration slowIndicatorLoggingThreshold) {
		super(registry, groups, slowIndicatorLoggingThreshold);
	}
	@ReadOperation
	public WebEndpointResponse<HealthComponent> health(ApiVersion apiVersion, WebServerNamespace serverNamespace,
			SecurityContext securityContext) {
		return health(apiVersion, serverNamespace, securityContext, false, NO_PATH);
	}
	@ReadOperation
	public WebEndpointResponse<HealthComponent> health(ApiVersion apiVersion, WebServerNamespace serverNamespace,
			SecurityContext securityContext, @Selector(match = Match.ALL_REMAINING) String... path) {
		return health(apiVersion, serverNamespace, securityContext, false, path);
	}
	public WebEndpointResponse<HealthComponent> health(ApiVersion apiVersion, WebServerNamespace serverNamespace,
			SecurityContext securityContext, boolean showAll, String... path) {
		HealthResult<HealthComponent> result = getHealth(apiVersion, serverNamespace, securityContext, showAll, path);
		if (result == null) {
			return (Arrays.equals(path, NO_PATH))
					? new WebEndpointResponse<>(DEFAULT_HEALTH, WebEndpointResponse.STATUS_OK)
					: new WebEndpointResponse<>(WebEndpointResponse.STATUS_NOT_FOUND);
		}
		HealthComponent health = result.getHealth();
		HealthEndpointGroup group = result.getGroup();
		int statusCode = group.getHttpCodeStatusMapper().getStatusCode(health.getStatus());
		return new WebEndpointResponse<>(health, statusCode);
	}
	@Override
	protected HealthComponent getHealth(HealthContributor contributor, boolean includeDetails) {
		return ((HealthIndicator) contributor).getHealth(includeDetails);
	}
	@Override
	protected HealthComponent aggregateContributions(ApiVersion apiVersion, Map<String, HealthComponent> contributions,
			StatusAggregator statusAggregator, boolean showComponents, Set<String> groupNames) {
		return getCompositeHealth(apiVersion, contributions, statusAggregator, showComponents, groupNames);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public class SimpleStatusAggregator implements StatusAggregator {
	private static final List<String> DEFAULT_ORDER;
	static final StatusAggregator INSTANCE;
	static {
		List<String> defaultOrder = new ArrayList<>();
		defaultOrder.add(Status.DOWN.getCode());
		defaultOrder.add(Status.OUT_OF_SERVICE.getCode());
		defaultOrder.add(Status.UP.getCode());
		defaultOrder.add(Status.UNKNOWN.getCode());
		DEFAULT_ORDER = Collections.unmodifiableList(getUniformCodes(defaultOrder.stream()));
		INSTANCE = new SimpleStatusAggregator();
	}
	private final List<String> order;
	private final Comparator<Status> comparator = new StatusComparator();
	public SimpleStatusAggregator() {
		this.order = DEFAULT_ORDER;
	}
	public SimpleStatusAggregator(Status... order) {
		this.order = ObjectUtils.isEmpty(order) ? DEFAULT_ORDER
				: getUniformCodes(Arrays.stream(order).map(Status::getCode));
	}
	public SimpleStatusAggregator(String... order) {
		this.order = ObjectUtils.isEmpty(order) ? DEFAULT_ORDER : getUniformCodes(Arrays.stream(order));
	}
	public SimpleStatusAggregator(List<String> order) {
		this.order = CollectionUtils.isEmpty(order) ? DEFAULT_ORDER : getUniformCodes(order.stream());
	}
	@Override
	public Status getAggregateStatus(Set<Status> statuses) {
		return statuses.stream().filter(this::contains).min(this.comparator).orElse(Status.UNKNOWN);
	}
	private boolean contains(Status status) {
		return this.order.contains(getUniformCode(status.getCode()));
	}
	private static List<String> getUniformCodes(Stream<String> codes) {
		return codes.map(SimpleStatusAggregator::getUniformCode).toList();
	}
	private static String getUniformCode(String code) {
		if (code == null) {
			return null;
		}
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < code.length(); i++) {
			char ch = code.charAt(i);
			if (Character.isAlphabetic(ch) || Character.isDigit(ch)) {
				builder.append(Character.toLowerCase(ch));
			}
		}
		return builder.toString();
	}
	/**
	 * {@link Comparator} used to order {@link Status}.
	 */
	private final class StatusComparator implements Comparator<Status> {
		@Override
		public int compare(Status s1, Status s2) {
			List<String> order = SimpleStatusAggregator.this.order;
			int i1 = order.indexOf(getUniformCode(s1.getCode()));
			int i2 = order.indexOf(getUniformCode(s2.getCode()));
			return (i1 < i2) ? -1 : (i1 != i2) ? 1 : s1.getCode().compareTo(s2.getCode());
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface ReactiveHealthContributor {
	static ReactiveHealthContributor adapt(HealthContributor healthContributor) {
		Assert.notNull(healthContributor, 'HealthContributor must not be null');
		if (healthContributor instanceof HealthIndicator healthIndicator) {
			return new HealthIndicatorReactiveAdapter(healthIndicator);
		}
		if (healthContributor instanceof CompositeHealthContributor compositeHealthContributor) {
			return new CompositeHealthContributorReactiveAdapter(compositeHealthContributor);
		}
		throw new IllegalStateException('Unknown HealthContributor type');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@EndpointWebExtension(endpoint = HealthEndpoint.class)
@ImportRuntimeHints(HealthEndpointWebExtensionRuntimeHints.class)
public class ReactiveHealthEndpointWebExtension
		extends HealthEndpointSupport<ReactiveHealthContributor, Mono<? extends HealthComponent>> {
	private static final String[] NO_PATH = {};
	/**
	 * Create a new {@link ReactiveHealthEndpointWebExtension} instance.
	 * @param registry the health contributor registry
	 * @param groups the health endpoint groups
	 * @param slowIndicatorLoggingThreshold duration after which slow health indicator
	 * logging should occur
	 * @since 2.6.9
	 */
	public ReactiveHealthEndpointWebExtension(ReactiveHealthContributorRegistry registry, HealthEndpointGroups groups,
			Duration slowIndicatorLoggingThreshold) {
		super(registry, groups, slowIndicatorLoggingThreshold);
	}
	@ReadOperation
	public Mono<WebEndpointResponse<? extends HealthComponent>> health(ApiVersion apiVersion,
			WebServerNamespace serverNamespace, SecurityContext securityContext) {
		return health(apiVersion, serverNamespace, securityContext, false, NO_PATH);
	}
	@ReadOperation
	public Mono<WebEndpointResponse<? extends HealthComponent>> health(ApiVersion apiVersion,
			WebServerNamespace serverNamespace, SecurityContext securityContext,
			@Selector(match = Match.ALL_REMAINING) String... path) {
		return health(apiVersion, serverNamespace, securityContext, false, path);
	}
	public Mono<WebEndpointResponse<? extends HealthComponent>> health(ApiVersion apiVersion,
			WebServerNamespace serverNamespace, SecurityContext securityContext, boolean showAll, String... path) {
		HealthResult<Mono<? extends HealthComponent>> result = getHealth(apiVersion, serverNamespace, securityContext,
				showAll, path);
		if (result == null) {
			return (Arrays.equals(path, NO_PATH))
					? Mono.just(new WebEndpointResponse<>(DEFAULT_HEALTH, WebEndpointResponse.STATUS_OK))
					: Mono.just(new WebEndpointResponse<>(WebEndpointResponse.STATUS_NOT_FOUND));
		}
		HealthEndpointGroup group = result.getGroup();
		return result.getHealth().map((health) -> {
			int statusCode = group.getHttpCodeStatusMapper().getStatusCode(health.getStatus());
			return new WebEndpointResponse<>(health, statusCode);
		});
	}
	@Override
	protected Mono<? extends HealthComponent> getHealth(ReactiveHealthContributor contributor, boolean includeDetails) {
		return ((ReactiveHealthIndicator) contributor).getHealth(includeDetails);
	}
	@Override
	protected Mono<? extends HealthComponent> aggregateContributions(ApiVersion apiVersion,
			Map<String, Mono<? extends HealthComponent>> contributions, StatusAggregator statusAggregator,
			boolean showComponents, Set<String> groupNames) {
		return Flux.fromIterable(contributions.entrySet())
			.flatMap(NamedHealthComponent::create)
			.collectMap(NamedHealthComponent::getName, NamedHealthComponent::getHealth)
			.map((components) -> this.getCompositeHealth(apiVersion, components, statusAggregator, showComponents,
					groupNames));
	}
	/**
	 * A named {@link HealthComponent}.
	 */
	private static final class NamedHealthComponent {
		private final String name;
		private final HealthComponent health;
		private NamedHealthComponent(Object... pair) {
			this.name = (String) pair[0];
			this.health = (HealthComponent) pair[1];
		}
		String getName() {
			return this.name;
		}
		HealthComponent getHealth() {
			return this.health;
		}
		static Mono<NamedHealthComponent> create(Map.Entry<String, Mono<? extends HealthComponent>> entry) {
			Mono<String> name = Mono.just(entry.getKey());
			Mono<? extends HealthComponent> health = entry.getValue();
			return Mono.zip(NamedHealthComponent::new, name, health);
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public abstract class AbstractReactiveHealthIndicator implements ReactiveHealthIndicator {
	private static final String NO_MESSAGE = null;
	private static final String DEFAULT_MESSAGE = 'Health check failed';
	private final Log logger = LogFactory.getLog(getClass());
	private final Function<Throwable, String> healthCheckFailedMessage;
	/**
	 * Create a new {@link AbstractReactiveHealthIndicator} instance with a default
	 * {@code healthCheckFailedMessage}.
	 * @since 2.1.7
	 */
	protected AbstractReactiveHealthIndicator() {
		this(NO_MESSAGE);
	}
	/**
	 * Create a new {@link AbstractReactiveHealthIndicator} instance with a specific
	 * message to log when the health check fails.
	 * @param healthCheckFailedMessage the message to log on health check failure
	 * @since 2.1.7
	 */
	protected AbstractReactiveHealthIndicator(String healthCheckFailedMessage) {
		this.healthCheckFailedMessage = (ex) -> healthCheckFailedMessage;
	}
	/**
	 * Create a new {@link AbstractReactiveHealthIndicator} instance with a specific
	 * message to log when the health check fails.
	 * @param healthCheckFailedMessage the message to log on health check failure
	 * @since 2.1.7
	 */
	protected AbstractReactiveHealthIndicator(Function<Throwable, String> healthCheckFailedMessage) {
		Assert.notNull(healthCheckFailedMessage, 'HealthCheckFailedMessage must not be null');
		this.healthCheckFailedMessage = healthCheckFailedMessage;
	}
	@Override
	public final Mono<Health> health() {
		try {
			Health.Builder builder = new Health.Builder();
			Mono<Health> result = doHealthCheck(builder).onErrorResume(this::handleFailure);
			return result.doOnNext((health) -> logExceptionIfPresent(builder.getException()));
		}
		catch (Exception ex) {
			return handleFailure(ex);
		}
	}
	private void logExceptionIfPresent(Throwable ex) {
		if (ex != null && this.logger.isWarnEnabled()) {
			String message = (ex instanceof Exception) ? this.healthCheckFailedMessage.apply(ex) : null;
			this.logger.warn(StringUtils.hasText(message) ? message : DEFAULT_MESSAGE, ex);
		}
	}
	private Mono<Health> handleFailure(Throwable ex) {
		logExceptionIfPresent(ex);
		return Mono.just(new Health.Builder().down(ex).build());
	}
	/**
	 * Actual health check logic. If an error occurs in the pipeline, it will be handled
	 * automatically.
	 * @param builder the {@link Health.Builder} to report health status and details
	 * @return a {@link Mono} that provides the {@link Health}
	 */
	protected abstract Mono<Health> doHealthCheck(Health.Builder builder);
}
/*
package org.springframework.boot.actuate.health;
/**
@FunctionalInterface
public interface HealthEndpointGroupsPostProcessor {
	/**
	 * Post-process the given {@link HealthEndpointGroups} instance.
	 * @param groups the existing groups instance
	 * @return a post-processed groups instance, or the original instance if not
	 * post-processing was required
	 */
	HealthEndpointGroups postProcessHealthEndpointGroups(HealthEndpointGroups groups);
}
/*
package org.springframework.boot.actuate.health;
/**
class CompositeReactiveHealthContributorMapAdapter<V> extends NamedContributorsMapAdapter<V, ReactiveHealthContributor>
		implements CompositeReactiveHealthContributor {
	CompositeReactiveHealthContributorMapAdapter(Map<String, V> map,
			Function<V, ? extends ReactiveHealthContributor> valueAdapter) {
		super(map, valueAdapter);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface HealthContributorRegistry extends ContributorRegistry<HealthContributor> {
}
/*
package org.springframework.boot.actuate.health;
/**
@FunctionalInterface
public interface HealthIndicator extends HealthContributor {
	/**
	 * Return an indication of health.
	 * @param includeDetails if details should be included or removed
	 * @return the health
	 * @since 2.2.0
	 */
	default Health getHealth(boolean includeDetails) {
		Health health = health();
		return includeDetails ? health : health.withoutDetails();
	}
	/**
	 * Return an indication of health.
	 * @return the health
	 */
	Health health();
}
/*
package org.springframework.boot.actuate.health;
/**
public abstract class AbstractHealthIndicator implements HealthIndicator {
	private static final String NO_MESSAGE = null;
	private static final String DEFAULT_MESSAGE = 'Health check failed';
	private final Log logger = LogFactory.getLog(getClass());
	private final Function<Exception, String> healthCheckFailedMessage;
	/**
	 * Create a new {@link AbstractHealthIndicator} instance with a default
	 * {@code healthCheckFailedMessage}.
	 */
	protected AbstractHealthIndicator() {
		this(NO_MESSAGE);
	}
	/**
	 * Create a new {@link AbstractHealthIndicator} instance with a specific message to
	 * log when the health check fails.
	 * @param healthCheckFailedMessage the message to log on health check failure
	 * @since 2.0.0
	 */
	protected AbstractHealthIndicator(String healthCheckFailedMessage) {
		this.healthCheckFailedMessage = (ex) -> healthCheckFailedMessage;
	}
	/**
	 * Create a new {@link AbstractHealthIndicator} instance with a specific message to
	 * log when the health check fails.
	 * @param healthCheckFailedMessage the message to log on health check failure
	 * @since 2.0.0
	 */
	protected AbstractHealthIndicator(Function<Exception, String> healthCheckFailedMessage) {
		Assert.notNull(healthCheckFailedMessage, 'HealthCheckFailedMessage must not be null');
		this.healthCheckFailedMessage = healthCheckFailedMessage;
	}
	@Override
	public final Health health() {
		Health.Builder builder = new Health.Builder();
		try {
			doHealthCheck(builder);
		}
		catch (Exception ex) {
			builder.down(ex);
		}
		logExceptionIfPresent(builder.getException());
		return builder.build();
	}
	private void logExceptionIfPresent(Throwable throwable) {
		if (throwable != null && this.logger.isWarnEnabled()) {
			String message = (throwable instanceof Exception ex) ? this.healthCheckFailedMessage.apply(ex) : null;
			this.logger.warn(StringUtils.hasText(message) ? message : DEFAULT_MESSAGE, throwable);
		}
	}
	/**
	 * Actual health check logic.
	 * @param builder the {@link Builder} to report health status and details
	 * @throws Exception any {@link Exception} that should create a {@link Status#DOWN}
	 * system status.
	 */
	protected abstract void doHealthCheck(Health.Builder builder) throws Exception;
}
/*
package org.springframework.boot.actuate.health;
/**
public class DefaultHealthContributorRegistry extends DefaultContributorRegistry<HealthContributor>
		implements HealthContributorRegistry {
	public DefaultHealthContributorRegistry() {
	}
	public DefaultHealthContributorRegistry(Map<String, HealthContributor> contributors) {
		super(contributors);
	}
	public DefaultHealthContributorRegistry(Map<String, HealthContributor> contributors,
			Function<String, String> nameFactory) {
		super(contributors, nameFactory);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@FunctionalInterface
public interface HttpCodeStatusMapper {
	/**
	 * An {@link HttpCodeStatusMapper} instance using default mappings.
	 * @since 2.3.0
	 */
	HttpCodeStatusMapper DEFAULT = new SimpleHttpCodeStatusMapper();
	/**
	 * Return the HTTP status code that corresponds to the given {@link Status health
	 * status}.
	 * @param status the health status to map
	 * @return the corresponding HTTP status code
	 */
	int getStatusCode(Status status);
}
/*
package org.springframework.boot.actuate.health;
/**
public interface HealthEndpointGroup {
	/**
	 * Returns {@code true} if the given contributor is a member of this group.
	 * @param name the contributor name
	 * @return {@code true} if the contributor is a member of this group
	 */
	boolean isMember(String name);
	/**
	 * Returns if {@link CompositeHealth#getComponents() health components} should be
	 * shown in the response.
	 * @param securityContext the endpoint security context
	 * @return {@code true} to shown details or {@code false} to hide them
	 */
	boolean showComponents(SecurityContext securityContext);
	/**
	 * Returns if {@link Health#getDetails() health details} should be shown in the
	 * response.
	 * @param securityContext the endpoint security context
	 * @return {@code true} to shown details or {@code false} to hide them
	 */
	boolean showDetails(SecurityContext securityContext);
	/**
	 * Returns the status aggregator that should be used for this group.
	 * @return the status aggregator for this group
	 */
	StatusAggregator getStatusAggregator();
	/**
	 * Returns the {@link HttpCodeStatusMapper} that should be used for this group.
	 * @return the HTTP code status mapper
	 */
	HttpCodeStatusMapper getHttpCodeStatusMapper();
	/**
	 * Return an additional path that can be used to map the health group to an
	 * alternative location.
	 * @return the additional health path or {@code null}
	 * @since 2.6.0
	 */
	AdditionalHealthEndpointPath getAdditionalPath();
}
/*
package org.springframework.boot.actuate.health;
/**
abstract class HealthEndpointSupport<C, T> {
	private static final Log logger = LogFactory.getLog(HealthEndpointSupport.class);
	static final Health DEFAULT_HEALTH = Health.up().build();
	private final ContributorRegistry<C> registry;
	private final HealthEndpointGroups groups;
	private final Duration slowIndicatorLoggingThreshold;
	/**
	 * Create a new {@link HealthEndpointSupport} instance.
	 * @param registry the health contributor registry
	 * @param groups the health endpoint groups
	 * @param slowIndicatorLoggingThreshold duration after which slow health indicator
	 * logging should occur
	 */
	HealthEndpointSupport(ContributorRegistry<C> registry, HealthEndpointGroups groups,
			Duration slowIndicatorLoggingThreshold) {
		Assert.notNull(registry, 'Registry must not be null');
		Assert.notNull(groups, 'Groups must not be null');
		this.registry = registry;
		this.groups = groups;
		this.slowIndicatorLoggingThreshold = slowIndicatorLoggingThreshold;
	}
	HealthResult<T> getHealth(ApiVersion apiVersion, WebServerNamespace serverNamespace,
			SecurityContext securityContext, boolean showAll, String... path) {
		if (path.length > 0) {
			HealthEndpointGroup group = getHealthGroup(serverNamespace, path);
			if (group != null) {
				return getHealth(apiVersion, group, securityContext, showAll, path, 1);
			}
		}
		return getHealth(apiVersion, this.groups.getPrimary(), securityContext, showAll, path, 0);
	}
	private HealthEndpointGroup getHealthGroup(WebServerNamespace serverNamespace, String... path) {
		if (this.groups.get(path[0]) != null) {
			return this.groups.get(path[0]);
		}
		if (serverNamespace != null) {
			AdditionalHealthEndpointPath additionalPath = AdditionalHealthEndpointPath.of(serverNamespace, path[0]);
			return this.groups.get(additionalPath);
		}
		return null;
	}
	private HealthResult<T> getHealth(ApiVersion apiVersion, HealthEndpointGroup group, SecurityContext securityContext,
			boolean showAll, String[] path, int pathOffset) {
		boolean showComponents = showAll || group.showComponents(securityContext);
		boolean showDetails = showAll || group.showDetails(securityContext);
		boolean isSystemHealth = group == this.groups.getPrimary() && pathOffset == 0;
		boolean isRoot = path.length - pathOffset == 0;
		if (!showComponents && !isRoot) {
			return null;
		}
		Object contributor = getContributor(path, pathOffset);
		if (contributor == null) {
			return null;
		}
		String name = getName(path, pathOffset);
		Set<String> groupNames = isSystemHealth ? this.groups.getNames() : null;
		T health = getContribution(apiVersion, group, name, contributor, showComponents, showDetails, groupNames);
		return (health != null) ? new HealthResult<>(health, group) : null;
	}
	@SuppressWarnings('unchecked')
	private Object getContributor(String[] path, int pathOffset) {
		Object contributor = this.registry;
		while (pathOffset < path.length) {
			if (!(contributor instanceof NamedContributors)) {
				return null;
			}
			contributor = ((NamedContributors<C>) contributor).getContributor(path[pathOffset]);
			pathOffset++;
		}
		return contributor;
	}
	private String getName(String[] path, int pathOffset) {
		StringBuilder name = new StringBuilder();
		while (pathOffset < path.length) {
			name.append((!name.isEmpty()) ? '/' : '');
			name.append(path[pathOffset]);
			pathOffset++;
		}
		return name.toString();
	}
	@SuppressWarnings('unchecked')
	private T getContribution(ApiVersion apiVersion, HealthEndpointGroup group, String name, Object contributor,
			boolean showComponents, boolean showDetails, Set<String> groupNames) {
		if (contributor instanceof NamedContributors) {
			return getAggregateContribution(apiVersion, group, name, (NamedContributors<C>) contributor, showComponents,
					showDetails, groupNames);
		}
		if (contributor != null && (name.isEmpty() || group.isMember(name))) {
			return getLoggedHealth((C) contributor, name, showDetails);
		}
		return null;
	}
	private T getAggregateContribution(ApiVersion apiVersion, HealthEndpointGroup group, String name,
			NamedContributors<C> namedContributors, boolean showComponents, boolean showDetails,
			Set<String> groupNames) {
		String prefix = (StringUtils.hasText(name)) ? name + '/' : '';
		Map<String, T> contributions = new LinkedHashMap<>();
		for (NamedContributor<C> child : namedContributors) {
			T contribution = getContribution(apiVersion, group, prefix + child.getName(), child.getContributor(),
					showComponents, showDetails, null);
			if (contribution != null) {
				contributions.put(child.getName(), contribution);
			}
		}
		if (contributions.isEmpty()) {
			return null;
		}
		return aggregateContributions(apiVersion, contributions, group.getStatusAggregator(), showComponents,
				groupNames);
	}
	private T getLoggedHealth(C contributor, String name, boolean showDetails) {
		Instant start = Instant.now();
		try {
			return getHealth(contributor, showDetails);
		}
		finally {
			if (logger.isWarnEnabled() && this.slowIndicatorLoggingThreshold != null) {
				Duration duration = Duration.between(start, Instant.now());
				if (duration.compareTo(this.slowIndicatorLoggingThreshold) > 0) {
					String contributorClassName = contributor.getClass().getName();
					Object contributorIdentifier = (!StringUtils.hasLength(name)) ? contributorClassName
							: contributorClassName + ' (' + name + ')';
					logger.warn(LogMessage.format('Health contributor %s took %s to respond', contributorIdentifier,
							DurationStyle.SIMPLE.print(duration)));
				}
			}
		}
	}
	protected abstract T getHealth(C contributor, boolean includeDetails);
	protected abstract T aggregateContributions(ApiVersion apiVersion, Map<String, T> contributions,
			StatusAggregator statusAggregator, boolean showComponents, Set<String> groupNames);
	protected final CompositeHealth getCompositeHealth(ApiVersion apiVersion, Map<String, HealthComponent> components,
			StatusAggregator statusAggregator, boolean showComponents, Set<String> groupNames) {
		Status status = statusAggregator
			.getAggregateStatus(components.values().stream().map(this::getStatus).collect(Collectors.toSet()));
		Map<String, HealthComponent> instances = showComponents ? components : null;
		if (groupNames != null) {
			return new SystemHealth(apiVersion, status, instances, groupNames);
		}
		return new CompositeHealth(apiVersion, status, instances);
	}
	private Status getStatus(HealthComponent component) {
		return (component != null) ? component.getStatus() : Status.UNKNOWN;
	}
	/**
	 * A health result containing health and the group that created it.
	 *
	 * @param <T> the contributed health component
	 */
	static class HealthResult<T> {
		private final T health;
		private final HealthEndpointGroup group;
		HealthResult(T health, HealthEndpointGroup group) {
			this.health = health;
			this.group = group;
		}
		T getHealth() {
			return this.health;
		}
		HealthEndpointGroup getGroup() {
			return this.group;
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public class CompositeHealth extends HealthComponent {
	private final Status status;
	private final Map<String, HealthComponent> components;
	private final Map<String, HealthComponent> details;
	CompositeHealth(ApiVersion apiVersion, Status status, Map<String, HealthComponent> components) {
		Assert.notNull(status, 'Status must not be null');
		this.status = status;
		this.components = (apiVersion != ApiVersion.V3) ? null : sort(components);
		this.details = (apiVersion != ApiVersion.V2) ? null : sort(components);
	}
	private Map<String, HealthComponent> sort(Map<String, HealthComponent> components) {
		return (components != null) ? new TreeMap<>(components) : components;
	}
	@Override
	public Status getStatus() {
		return this.status;
	}
	@JsonInclude(Include.NON_EMPTY)
	public Map<String, HealthComponent> getComponents() {
		return this.components;
	}
	@JsonInclude(Include.NON_EMPTY)
	@JsonProperty
	public Map<String, HealthComponent> getDetails() {
		return this.details;
	}
}
/*
package org.springframework.boot.actuate.health;
/**
class CompositeHealthContributorReactiveAdapter implements CompositeReactiveHealthContributor {
	private final CompositeHealthContributor delegate;
	CompositeHealthContributorReactiveAdapter(CompositeHealthContributor delegate) {
		Assert.notNull(delegate, 'Delegate must not be null');
		this.delegate = delegate;
	}
	@Override
	public Iterator<NamedContributor<ReactiveHealthContributor>> iterator() {
		Iterator<NamedContributor<HealthContributor>> iterator = this.delegate.iterator();
		return new Iterator<>() {
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
			@Override
			public NamedContributor<ReactiveHealthContributor> next() {
				NamedContributor<HealthContributor> namedContributor = iterator.next();
				return NamedContributor.of(namedContributor.getName(),
						ReactiveHealthContributor.adapt(namedContributor.getContributor()));
			}
		};
	}
	@Override
	public ReactiveHealthContributor getContributor(String name) {
		HealthContributor contributor = this.delegate.getContributor(name);
		return (contributor != null) ? ReactiveHealthContributor.adapt(contributor) : null;
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface CompositeHealthContributor extends HealthContributor, NamedContributors<HealthContributor> {
	/**
	 * Factory method that will create a {@link CompositeHealthContributor} from the
	 * specified map.
	 * @param map the source map
	 * @return a composite health contributor instance
	 */
	static CompositeHealthContributor fromMap(Map<String, ? extends HealthContributor> map) {
		return fromMap(map, Function.identity());
	}
	/**
	 * Factory method that will create a {@link CompositeHealthContributor} from the
	 * specified map.
	 * @param <V> the value type
	 * @param map the source map
	 * @param valueAdapter function used to adapt the map value
	 * @return a composite health contributor instance
	 */
	static <V> CompositeHealthContributor fromMap(Map<String, V> map,
			Function<V, ? extends HealthContributor> valueAdapter) {
		return new CompositeHealthContributorMapAdapter<>(map, valueAdapter);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface NamedContributors<C> extends Iterable<NamedContributor<C>> {
	/**
	 * Return the contributor with the given name.
	 * @param name the name of the contributor
	 * @return a contributor instance or {@code null}
	 */
	C getContributor(String name);
	/**
	 * Return a stream of the {@link NamedContributor named contributors}.
	 * @return the stream of named contributors
	 */
	default Stream<NamedContributor<C>> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public abstract class HealthComponent implements OperationResponseBody {
	HealthComponent() {
	}
	/**
	 * Return the status of the component.
	 * @return the component status
	 */
	@JsonUnwrapped
	public abstract Status getStatus();
}
/*
package org.springframework.boot.actuate.health;
/**
@Endpoint(id = 'health')
public class HealthEndpoint extends HealthEndpointSupport<HealthContributor, HealthComponent> {
	/**
	 * Health endpoint id.
	 */
	public static final EndpointId ID = EndpointId.of('health');
	private static final String[] EMPTY_PATH = {};
	/**
	 * Create a new {@link HealthEndpoint} instance.
	 * @param registry the health contributor registry
	 * @param groups the health endpoint groups
	 * @param slowIndicatorLoggingThreshold duration after which slow health indicator
	 * logging should occur
	 * @since 2.6.9
	 */
	public HealthEndpoint(HealthContributorRegistry registry, HealthEndpointGroups groups,
			Duration slowIndicatorLoggingThreshold) {
		super(registry, groups, slowIndicatorLoggingThreshold);
	}
	@ReadOperation
	public HealthComponent health() {
		HealthComponent health = health(ApiVersion.V3, EMPTY_PATH);
		return (health != null) ? health : DEFAULT_HEALTH;
	}
	@ReadOperation
	public HealthComponent healthForPath(@Selector(match = Match.ALL_REMAINING) String... path) {
		return health(ApiVersion.V3, path);
	}
	private HealthComponent health(ApiVersion apiVersion, String... path) {
		HealthResult<HealthComponent> result = getHealth(apiVersion, null, SecurityContext.NONE, true, path);
		return (result != null) ? result.getHealth() : null;
	}
	@Override
	protected HealthComponent getHealth(HealthContributor contributor, boolean includeDetails) {
		return ((HealthIndicator) contributor).getHealth(includeDetails);
	}
	@Override
	protected HealthComponent aggregateContributions(ApiVersion apiVersion, Map<String, HealthComponent> contributions,
			StatusAggregator statusAggregator, boolean showComponents, Set<String> groupNames) {
		return getCompositeHealth(apiVersion, contributions, statusAggregator, showComponents, groupNames);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public final class SystemHealth extends CompositeHealth {
	private final Set<String> groups;
	SystemHealth(ApiVersion apiVersion, Status status, Map<String, HealthComponent> instances, Set<String> groups) {
		super(apiVersion, status, instances);
		this.groups = (groups != null) ? new TreeSet<>(groups) : null;
	}
	@JsonInclude(Include.NON_EMPTY)
	public Set<String> getGroups() {
		return this.groups;
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface HealthContributor {
}
/*
package org.springframework.boot.actuate.health;
/**
class HealthEndpointWebExtensionRuntimeHints implements RuntimeHintsRegistrar {
	private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		this.bindingRegistrar.registerReflectionHints(hints.reflection(), Health.class, SystemHealth.class,
				CompositeHealth.class);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@FunctionalInterface
public interface StatusAggregator {
	/**
	 * Return {@link StatusAggregator} instance using default ordering rules.
	 * @return a {@code StatusAggregator} with default ordering rules.
	 * @since 2.3.0
	 */
	static StatusAggregator getDefault() {
		return SimpleStatusAggregator.INSTANCE;
	}
	/**
	 * Return the aggregate status for the given set of statuses.
	 * @param statuses the statuses to aggregate
	 * @return the aggregate status
	 */
	default Status getAggregateStatus(Status... statuses) {
		return getAggregateStatus(new LinkedHashSet<>(Arrays.asList(statuses)));
	}
	/**
	 * Return the aggregate status for the given set of statuses.
	 * @param statuses the statuses to aggregate
	 * @return the aggregate status
	 */
	Status getAggregateStatus(Set<Status> statuses);
}
/*
package org.springframework.boot.actuate.health;
/**
abstract class NamedContributorsMapAdapter<V, C> implements NamedContributors<C> {
	private final Map<String, C> map;
	NamedContributorsMapAdapter(Map<String, V> map, Function<V, ? extends C> valueAdapter) {
		Assert.notNull(map, 'Map must not be null');
		Assert.notNull(valueAdapter, 'ValueAdapter must not be null');
		map.keySet().forEach(this::validateKey);
		this.map = Collections.unmodifiableMap(map.entrySet()
			.stream()
			.collect(LinkedHashMap::new,
					(result, entry) -> result.put(entry.getKey(), adapt(entry.getValue(), valueAdapter)), Map::putAll));
	}
	private void validateKey(String value) {
		Assert.notNull(value, 'Map must not contain null keys');
		Assert.isTrue(!value.contains('/'), 'Map keys must not contain a "/"');
	}
	private C adapt(V value, Function<V, ? extends C> valueAdapter) {
		C contributor = (value != null) ? valueAdapter.apply(value) : null;
		Assert.notNull(contributor, 'Map must not contain null values');
		return contributor;
	}
	@Override
	public Iterator<NamedContributor<C>> iterator() {
		Iterator<Entry<String, C>> iterator = this.map.entrySet().iterator();
		return new Iterator<>() {
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
			@Override
			public NamedContributor<C> next() {
				Entry<String, C> entry = iterator.next();
				return NamedContributor.of(entry.getKey(), entry.getValue());
			}
		};
	}
	@Override
	public C getContributor(String name) {
		return this.map.get(name);
	}
}
/*
/**
package org.springframework.boot.actuate.health;
/*
package org.springframework.boot.actuate.health;
/**
class HealthIndicatorReactiveAdapter implements ReactiveHealthIndicator {
	private final HealthIndicator delegate;
	HealthIndicatorReactiveAdapter(HealthIndicator delegate) {
		Assert.notNull(delegate, 'Delegate must not be null');
		this.delegate = delegate;
	}
	@Override
	public Mono<Health> health() {
		return Mono.fromCallable(this.delegate::health).subscribeOn(Schedulers.boundedElastic());
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@JsonInclude(Include.NON_EMPTY)
public final class Status {
	/**
	 * {@link Status} indicating that the component or subsystem is in an unknown state.
	 */
	public static final Status UNKNOWN = new Status('UNKNOWN');
	/**
	 * {@link Status} indicating that the component or subsystem is functioning as
	 * expected.
	 */
	public static final Status UP = new Status('UP');
	/**
	 * {@link Status} indicating that the component or subsystem has suffered an
	 * unexpected failure.
	 */
	public static final Status DOWN = new Status('DOWN');
	/**
	 * {@link Status} indicating that the component or subsystem has been taken out of
	 * service and should not be used.
	 */
	public static final Status OUT_OF_SERVICE = new Status('OUT_OF_SERVICE');
	private final String code;
	private final String description;
	/**
	 * Create a new {@link Status} instance with the given code and an empty description.
	 * @param code the status code
	 */
	public Status(String code) {
		this(code, '');
	}
	/**
	 * Create a new {@link Status} instance with the given code and description.
	 * @param code the status code
	 * @param description a description of the status
	 */
	public Status(String code, String description) {
		Assert.notNull(code, 'Code must not be null');
		Assert.notNull(description, 'Description must not be null');
		this.code = code;
		this.description = description;
	}
	/**
	 * Return the code for this status.
	 * @return the code
	 */
	@JsonProperty('status')
	public String getCode() {
		return this.code;
	}
	/**
	 * Return the description of this status.
	 * @return the description
	 */
	@JsonInclude(Include.NON_EMPTY)
	public String getDescription() {
		return this.description;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj instanceof Status other) {
			return ObjectUtils.nullSafeEquals(this.code, other.code);
		}
		return false;
	}
	@Override
	public int hashCode() {
		return this.code.hashCode();
	}
	@Override
	public String toString() {
		return this.code;
	}
}
/*
package org.springframework.boot.actuate.health;
/**
@JsonInclude(Include.NON_EMPTY)
public final class Health extends HealthComponent {
	private final Status status;
	private final Map<String, Object> details;
	/**
	 * Create a new {@link Health} instance with the specified status and details.
	 * @param builder the Builder to use
	 */
	private Health(Builder builder) {
		Assert.notNull(builder, 'Builder must not be null');
		this.status = builder.status;
		this.details = Collections.unmodifiableMap(builder.details);
	}
	Health(Status status, Map<String, Object> details) {
		this.status = status;
		this.details = details;
	}
	/**
	 * Return the status of the health.
	 * @return the status (never {@code null})
	 */
	@Override
	public Status getStatus() {
		return this.status;
	}
	/**
	 * Return the details of the health.
	 * @return the details (or an empty map)
	 */
	@JsonInclude(Include.NON_EMPTY)
	public Map<String, Object> getDetails() {
		return this.details;
	}
	/**
	 * Return a new instance of this {@link Health} with all {@link #getDetails() details}
	 * removed.
	 * @return a new instance without details
	 * @since 2.2.0
	 */
	Health withoutDetails() {
		if (this.details.isEmpty()) {
			return this;
		}
		return status(getStatus()).build();
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj instanceof Health other) {
			return this.status.equals(other.status) && this.details.equals(other.details);
		}
		return false;
	}
	@Override
	public int hashCode() {
		int hashCode = this.status.hashCode();
		return 13 * hashCode + this.details.hashCode();
	}
	@Override
	public String toString() {
		return getStatus() + ' ' + getDetails();
	}
	/**
	 * Create a new {@link Builder} instance with an {@link Status#UNKNOWN} status.
	 * @return a new {@link Builder} instance
	 */
	public static Builder unknown() {
		return status(Status.UNKNOWN);
	}
	/**
	 * Create a new {@link Builder} instance with an {@link Status#UP} status.
	 * @return a new {@link Builder} instance
	 */
	public static Builder up() {
		return status(Status.UP);
	}
	/**
	 * Create a new {@link Builder} instance with an {@link Status#DOWN} status and the
	 * specified exception details.
	 * @param ex the exception
	 * @return a new {@link Builder} instance
	 */
	public static Builder down(Throwable ex) {
		return down().withException(ex);
	}
	/**
	 * Create a new {@link Builder} instance with a {@link Status#DOWN} status.
	 * @return a new {@link Builder} instance
	 */
	public static Builder down() {
		return status(Status.DOWN);
	}
	/**
	 * Create a new {@link Builder} instance with an {@link Status#OUT_OF_SERVICE} status.
	 * @return a new {@link Builder} instance
	 */
	public static Builder outOfService() {
		return status(Status.OUT_OF_SERVICE);
	}
	/**
	 * Create a new {@link Builder} instance with a specific status code.
	 * @param statusCode the status code
	 * @return a new {@link Builder} instance
	 */
	public static Builder status(String statusCode) {
		return status(new Status(statusCode));
	}
	/**
	 * Create a new {@link Builder} instance with a specific {@link Status}.
	 * @param status the status
	 * @return a new {@link Builder} instance
	 */
	public static Builder status(Status status) {
		return new Builder(status);
	}
	/**
	 * Builder for creating immutable {@link Health} instances.
	 */
	public static class Builder {
		private Status status;
		private final Map<String, Object> details;
		private Throwable exception;
		/**
		 * Create new Builder instance.
		 */
		public Builder() {
			this.status = Status.UNKNOWN;
			this.details = new LinkedHashMap<>();
		}
		/**
		 * Create new Builder instance, setting status to given {@code status}.
		 * @param status the {@link Status} to use
		 */
		public Builder(Status status) {
			Assert.notNull(status, 'Status must not be null');
			this.status = status;
			this.details = new LinkedHashMap<>();
		}
		/**
		 * Create new Builder instance, setting status to given {@code status} and details
		 * to given {@code details}.
		 * @param status the {@link Status} to use
		 * @param details the details {@link Map} to use
		 */
		public Builder(Status status, Map<String, ?> details) {
			Assert.notNull(status, 'Status must not be null');
			Assert.notNull(details, 'Details must not be null');
			this.status = status;
			this.details = new LinkedHashMap<>(details);
		}
		/**
		 * Record detail for given {@link Exception}.
		 * @param ex the exception
		 * @return this {@link Builder} instance
		 */
		public Builder withException(Throwable ex) {
			Assert.notNull(ex, 'Exception must not be null');
			this.exception = ex;
			return withDetail('error', ex.getClass().getName() + ': ' + ex.getMessage());
		}
		/**
		 * Record detail using given {@code key} and {@code value}.
		 * @param key the detail key
		 * @param value the detail value
		 * @return this {@link Builder} instance
		 */
		public Builder withDetail(String key, Object value) {
			Assert.notNull(key, 'Key must not be null');
			Assert.notNull(value, 'Value must not be null');
			this.details.put(key, value);
			return this;
		}
		/**
		 * Record details from the given {@code details} map. Keys from the given map
		 * replace any existing keys if there are duplicates.
		 * @param details map of details
		 * @return this {@link Builder} instance
		 * @since 2.1.0
		 */
		public Builder withDetails(Map<String, ?> details) {
			Assert.notNull(details, 'Details must not be null');
			this.details.putAll(details);
			return this;
		}
		/**
		 * Set status to {@link Status#UNKNOWN} status.
		 * @return this {@link Builder} instance
		 */
		public Builder unknown() {
			return status(Status.UNKNOWN);
		}
		/**
		 * Set status to {@link Status#UP} status.
		 * @return this {@link Builder} instance
		 */
		public Builder up() {
			return status(Status.UP);
		}
		/**
		 * Set status to {@link Status#DOWN} and add details for given {@link Throwable}.
		 * @param ex the exception
		 * @return this {@link Builder} instance
		 */
		public Builder down(Throwable ex) {
			return down().withException(ex);
		}
		/**
		 * Set status to {@link Status#DOWN}.
		 * @return this {@link Builder} instance
		 */
		public Builder down() {
			return status(Status.DOWN);
		}
		/**
		 * Set status to {@link Status#OUT_OF_SERVICE}.
		 * @return this {@link Builder} instance
		 */
		public Builder outOfService() {
			return status(Status.OUT_OF_SERVICE);
		}
		/**
		 * Set status to given {@code statusCode}.
		 * @param statusCode the status code
		 * @return this {@link Builder} instance
		 */
		public Builder status(String statusCode) {
			return status(new Status(statusCode));
		}
		/**
		 * Set status to given {@link Status} instance.
		 * @param status the status
		 * @return this {@link Builder} instance
		 */
		public Builder status(Status status) {
			this.status = status;
			return this;
		}
		/**
		 * Create a new {@link Health} instance with the previously specified code and
		 * details.
		 * @return a new {@link Health} instance
		 */
		public Health build() {
			return new Health(this);
		}
		/**
		 * Return the {@link Exception}.
		 * @return the exception or {@code null} if the builder has no exception
		 */
		Throwable getException() {
			return this.exception;
		}
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface CompositeReactiveHealthContributor
		extends ReactiveHealthContributor, NamedContributors<ReactiveHealthContributor> {
	/**
	 * Factory method that will create a {@link CompositeReactiveHealthContributor} from
	 * the specified map.
	 * @param map the source map
	 * @return a composite health contributor instance
	 */
	static CompositeReactiveHealthContributor fromMap(Map<String, ? extends ReactiveHealthContributor> map) {
		return fromMap(map, Function.identity());
	}
	/**
	 * Factory method that will create a {@link CompositeReactiveHealthContributor} from
	 * the specified map.
	 * @param <V> the value type
	 * @param map the source map
	 * @param valueAdapter function used to adapt the map value
	 * @return a composite health contributor instance
	 */
	static <V> CompositeReactiveHealthContributor fromMap(Map<String, V> map,
			Function<V, ? extends ReactiveHealthContributor> valueAdapter) {
		return new CompositeReactiveHealthContributorMapAdapter<>(map, valueAdapter);
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public final class AdditionalHealthEndpointPath {
	private final WebServerNamespace namespace;
	private final String value;
	private final String canonicalValue;
	private AdditionalHealthEndpointPath(WebServerNamespace namespace, String value) {
		this.namespace = namespace;
		this.value = value;
		this.canonicalValue = (!value.startsWith('/')) ? '/' + value : value;
	}
	/**
	 * Returns the {@link WebServerNamespace} associated with this path.
	 * @return the server namespace
	 */
	public WebServerNamespace getNamespace() {
		return this.namespace;
	}
	/**
	 * Returns the value corresponding to this path.
	 * @return the path
	 */
	public String getValue() {
		return this.value;
	}
	/**
	 * Returns {@code true} if this path has the given {@link WebServerNamespace}.
	 * @param webServerNamespace the server namespace
	 * @return the new instance
	 */
	public boolean hasNamespace(WebServerNamespace webServerNamespace) {
		return this.namespace.equals(webServerNamespace);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		AdditionalHealthEndpointPath other = (AdditionalHealthEndpointPath) obj;
		boolean result = true;
		result = result && this.namespace.equals(other.namespace);
		result = result && this.canonicalValue.equals(other.canonicalValue);
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.namespace.hashCode();
		result = prime * result + this.canonicalValue.hashCode();
		return result;
	}
	@Override
	public String toString() {
		return this.namespace.getValue() + ':' + this.value;
	}
	/**
	 * Creates an {@link AdditionalHealthEndpointPath} from the given input. The input
	 * must contain a prefix and value separated by a `:`. The value must be limited to
	 * one path segment. For example, `server:/healthz`.
	 * @param value the value to parse
	 * @return the new instance
	 */
	public static AdditionalHealthEndpointPath from(String value) {
		Assert.hasText(value, 'Value must not be null');
		String[] values = value.split(':');
		Assert.isTrue(values.length == 2, 'Value must contain a valid namespace and value separated by ":".');
		Assert.isTrue(StringUtils.hasText(values[0]), 'Value must contain a valid namespace.');
		WebServerNamespace namespace = WebServerNamespace.from(values[0]);
		validateValue(values[1]);
		return new AdditionalHealthEndpointPath(namespace, values[1]);
	}
	/**
	 * Creates an {@link AdditionalHealthEndpointPath} from the given
	 * {@link WebServerNamespace} and value.
	 * @param webServerNamespace the server namespace
	 * @param value the value
	 * @return the new instance
	 */
	public static AdditionalHealthEndpointPath of(WebServerNamespace webServerNamespace, String value) {
		Assert.notNull(webServerNamespace, 'The server namespace must not be null.');
		Assert.notNull(value, 'The value must not be null.');
		validateValue(value);
		return new AdditionalHealthEndpointPath(webServerNamespace, value);
	}
	private static void validateValue(String value) {
		Assert.isTrue(StringUtils.countOccurrencesOf(value, '/') <= 1 && value.indexOf('/') <= 0,
				'Value must contain only one segment.');
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public class PingHealthIndicator extends AbstractHealthIndicator {
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		builder.up();
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface HealthEndpointGroups {
	/**
	 * Return the primary group used by the endpoint.
	 * @return the primary group (never {@code null})
	 */
	HealthEndpointGroup getPrimary();
	/**
	 * Return the names of any additional groups.
	 * @return the additional group names
	 */
	Set<String> getNames();
	/**
	 * Return the group with the specified name or {@code null} if the name is not known.
	 * @param name the name of the group
	 * @return the {@link HealthEndpointGroup} or {@code null}
	 */
	HealthEndpointGroup get(String name);
	/**
	 * Return the group with the specified additional path or {@code null} if no group
	 * with that path is found.
	 * @param path the additional path
	 * @return the matching {@link HealthEndpointGroup} or {@code null}
	 * @since 2.6.0
	 */
	default HealthEndpointGroup get(AdditionalHealthEndpointPath path) {
		Assert.notNull(path, 'Path must not be null');
		for (String name : getNames()) {
			HealthEndpointGroup group = get(name);
			if (path.equals(group.getAdditionalPath())) {
				return group;
			}
		}
		return null;
	}
	/**
	 * Return all the groups with an additional path on the specified
	 * {@link WebServerNamespace}.
	 * @param namespace the {@link WebServerNamespace}
	 * @return the matching groups
	 * @since 2.6.0
	 */
	default Set<HealthEndpointGroup> getAllWithAdditionalPath(WebServerNamespace namespace) {
		Assert.notNull(namespace, 'Namespace must not be null');
		Set<HealthEndpointGroup> filteredGroups = new LinkedHashSet<>();
		getNames().stream()
			.map(this::get)
			.filter((group) -> group.getAdditionalPath() != null && group.getAdditionalPath().hasNamespace(namespace))
			.forEach(filteredGroups::add);
		return filteredGroups;
	}
	/**
	 * Factory method to create a {@link HealthEndpointGroups} instance.
	 * @param primary the primary group
	 * @param additional the additional groups
	 * @return a new {@link HealthEndpointGroups} instance
	 */
	static HealthEndpointGroups of(HealthEndpointGroup primary, Map<String, HealthEndpointGroup> additional) {
		Assert.notNull(primary, 'Primary must not be null');
		Assert.notNull(additional, 'Additional must not be null');
		return new HealthEndpointGroups() {
			@Override
			public HealthEndpointGroup getPrimary() {
				return primary;
			}
			@Override
			public Set<String> getNames() {
				return additional.keySet();
			}
			@Override
			public HealthEndpointGroup get(String name) {
				return additional.get(name);
			}
		};
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public class HealthContributorNameFactory implements Function<String, String> {
	private static final String[] SUFFIXES = { 'healthindicator', 'healthcontributor' };
	/**
	 * A shared singleton {@link HealthContributorNameFactory} instance.
	 */
	public static final HealthContributorNameFactory INSTANCE = new HealthContributorNameFactory();
	@Override
	public String apply(String name) {
		for (String suffix : SUFFIXES) {
			if (name != null && name.toLowerCase(Locale.ENGLISH).endsWith(suffix)) {
				return name.substring(0, name.length() - suffix.length());
			}
		}
		return name;
	}
}
/*
package org.springframework.boot.actuate.health;
/**
public interface ReactiveHealthContributorRegistry extends ContributorRegistry<ReactiveHealthContributor> {
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
@WebEndpoint(id = 'prometheus')
public class PrometheusSimpleclientScrapeEndpoint {
	private static final int METRICS_SCRAPE_CHARS_EXTRA = 1024;
	private final CollectorRegistry collectorRegistry;
	private volatile int nextMetricsScrapeSize = 16;
	public PrometheusSimpleclientScrapeEndpoint(CollectorRegistry collectorRegistry) {
		this.collectorRegistry = collectorRegistry;
	}
	@SuppressWarnings('removal')
	@ReadOperation(producesFrom = TextOutputFormat.class)
	public WebEndpointResponse<String> scrape(TextOutputFormat format, @Nullable Set<String> includedNames) {
		try {
			Writer writer = new StringWriter(this.nextMetricsScrapeSize);
			Enumeration<MetricFamilySamples> samples = (includedNames != null)
					? this.collectorRegistry.filteredMetricFamilySamples(includedNames)
					: this.collectorRegistry.metricFamilySamples();
			format.write(writer, samples);
			String scrapePage = writer.toString();
			this.nextMetricsScrapeSize = scrapePage.length() + METRICS_SCRAPE_CHARS_EXTRA;
			return new WebEndpointResponse<>(scrapePage, format);
		}
		catch (IOException ex) {
			// This actually never happens since StringWriter doesn"t throw an IOException
			throw new IllegalStateException('Writing metrics failed', ex);
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
@WebEndpoint(id = 'prometheus')
public class PrometheusScrapeEndpoint {
	private static final int METRICS_SCRAPE_CHARS_EXTRA = 1024;
	private final PrometheusRegistry prometheusRegistry;
	private final ExpositionFormats expositionFormats;
	private volatile int nextMetricsScrapeSize = 16;
	/**
	 * Creates a new {@link PrometheusScrapeEndpoint}.
	 * @param prometheusRegistry the Prometheus registry to use
	 * @deprecated since 3.3.1 for removal in 3.5.0 in favor of
	 * {@link #PrometheusScrapeEndpoint(PrometheusRegistry, Properties)}
	 */
	@Deprecated(since = '3.3.1', forRemoval = true)
	public PrometheusScrapeEndpoint(PrometheusRegistry prometheusRegistry) {
		this(prometheusRegistry, null);
	}
	/**
	 * Creates a new {@link PrometheusScrapeEndpoint}.
	 * @param prometheusRegistry the Prometheus registry to use
	 * @param exporterProperties the properties used to configure Prometheus"
	 * {@link ExpositionFormats}
	 * @since 3.3.1
	 */
	public PrometheusScrapeEndpoint(PrometheusRegistry prometheusRegistry, Properties exporterProperties) {
		this.prometheusRegistry = prometheusRegistry;
		PrometheusProperties prometheusProperties = (exporterProperties != null)
				? PrometheusPropertiesLoader.load(exporterProperties) : PrometheusPropertiesLoader.load();
		this.expositionFormats = ExpositionFormats.init(prometheusProperties.getExporterProperties());
	}
	@ReadOperation(producesFrom = PrometheusOutputFormat.class)
	public WebEndpointResponse<byte[]> scrape(PrometheusOutputFormat format, @Nullable Set<String> includedNames) {
		try {
			ByteArrayOutputStream outputStream = new ByteArrayOutputStream(this.nextMetricsScrapeSize);
			MetricSnapshots metricSnapshots = (includedNames != null)
					? this.prometheusRegistry.scrape(includedNames::contains) : this.prometheusRegistry.scrape();
			format.write(this.expositionFormats, outputStream, metricSnapshots);
			byte[] content = outputStream.toByteArray();
			this.nextMetricsScrapeSize = content.length + METRICS_SCRAPE_CHARS_EXTRA;
			return new WebEndpointResponse<>(content, format);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Writing metrics failed', ex);
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
public enum PrometheusOutputFormat implements Producible<PrometheusOutputFormat> {
	/**
	 * Prometheus text version 0.0.4.
	 */
	CONTENT_TYPE_004(PrometheusTextFormatWriter.CONTENT_TYPE) {
		@Override
		void write(ExpositionFormats expositionFormats, OutputStream outputStream, MetricSnapshots snapshots)
				throws IOException {
			expositionFormats.getPrometheusTextFormatWriter().write(outputStream, snapshots);
		}
		@Override
		public boolean isDefault() {
			return true;
		}
	},
	/**
	 * OpenMetrics text version 1.0.0.
	 */
	CONTENT_TYPE_OPENMETRICS_100(OpenMetricsTextFormatWriter.CONTENT_TYPE) {
		@Override
		void write(ExpositionFormats expositionFormats, OutputStream outputStream, MetricSnapshots snapshots)
				throws IOException {
			expositionFormats.getOpenMetricsTextFormatWriter().write(outputStream, snapshots);
		}
	},
	/**
	 * Prometheus metrics protobuf.
	 */
	CONTENT_TYPE_PROTOBUF(PrometheusProtobufWriter.CONTENT_TYPE) {
		@Override
		void write(ExpositionFormats expositionFormats, OutputStream outputStream, MetricSnapshots snapshots)
				throws IOException {
			expositionFormats.getPrometheusProtobufWriter().write(outputStream, snapshots);
		}
	};
	private final MimeType mimeType;
	PrometheusOutputFormat(String mimeType) {
		this.mimeType = MimeTypeUtils.parseMimeType(mimeType);
	}
	@Override
	public MimeType getProducedMimeType() {
		return this.mimeType;
	}
	abstract void write(ExpositionFormats expositionFormats, OutputStream outputStream, MetricSnapshots snapshots)
			throws IOException;
}
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
public class PrometheusPushGatewayManager {
	private static final Log logger = LogFactory.getLog(PrometheusPushGatewayManager.class);
	private final PushGateway pushGateway;
	private final CollectorRegistry registry;
	private final String job;
	private final Map<String, String> groupingKey;
	private final ShutdownOperation shutdownOperation;
	private final TaskScheduler scheduler;
	private final ScheduledFuture<?> scheduled;
	/**
	 * Create a new {@link PrometheusPushGatewayManager} instance using a single threaded
	 * {@link TaskScheduler}.
	 * @param pushGateway the source push gateway
	 * @param registry the collector registry to push
	 * @param pushRate the rate at which push operations occur
	 * @param job the job ID for the operation
	 * @param groupingKeys an optional set of grouping keys for the operation
	 * @param shutdownOperation the shutdown operation that should be performed when
	 * context is closed.
	 */
	public PrometheusPushGatewayManager(PushGateway pushGateway, CollectorRegistry registry, Duration pushRate,
			String job, Map<String, String> groupingKeys, ShutdownOperation shutdownOperation) {
		this(pushGateway, registry, new PushGatewayTaskScheduler(), pushRate, job, groupingKeys, shutdownOperation);
	}
	/**
	 * Create a new {@link PrometheusPushGatewayManager} instance.
	 * @param pushGateway the source push gateway
	 * @param registry the collector registry to push
	 * @param scheduler the scheduler used for operations
	 * @param pushRate the rate at which push operations occur
	 * @param job the job ID for the operation
	 * @param groupingKey an optional set of grouping keys for the operation
	 * @param shutdownOperation the shutdown operation that should be performed when
	 * context is closed.
	 */
	public PrometheusPushGatewayManager(PushGateway pushGateway, CollectorRegistry registry, TaskScheduler scheduler,
			Duration pushRate, String job, Map<String, String> groupingKey, ShutdownOperation shutdownOperation) {
		Assert.notNull(pushGateway, 'PushGateway must not be null');
		Assert.notNull(registry, 'Registry must not be null');
		Assert.notNull(scheduler, 'Scheduler must not be null');
		Assert.notNull(pushRate, 'PushRate must not be null');
		Assert.hasLength(job, 'Job must not be empty');
		this.pushGateway = pushGateway;
		this.registry = registry;
		this.job = job;
		this.groupingKey = groupingKey;
		this.shutdownOperation = (shutdownOperation != null) ? shutdownOperation : ShutdownOperation.NONE;
		this.scheduler = scheduler;
		this.scheduled = this.scheduler.scheduleAtFixedRate(this::post, pushRate);
	}
	private void post() {
		try {
			this.pushGateway.pushAdd(this.registry, this.job, this.groupingKey);
		}
		catch (Throwable ex) {
			logger.warn('Unexpected exception thrown by POST of metrics to Prometheus Pushgateway', ex);
		}
	}
	private void put() {
		try {
			this.pushGateway.push(this.registry, this.job, this.groupingKey);
		}
		catch (Throwable ex) {
			logger.warn('Unexpected exception thrown by PUT of metrics to Prometheus Pushgateway', ex);
		}
	}
	private void delete() {
		try {
			this.pushGateway.delete(this.job, this.groupingKey);
		}
		catch (Throwable ex) {
			logger.warn('Unexpected exception thrown by DELETE of metrics from Prometheus Pushgateway', ex);
		}
	}
	/**
	 * Shutdown the manager, running any {@link ShutdownOperation}.
	 */
	public void shutdown() {
		shutdown(this.shutdownOperation);
	}
	private void shutdown(ShutdownOperation shutdownOperation) {
		if (this.scheduler instanceof PushGatewayTaskScheduler pushGatewayTaskScheduler) {
			pushGatewayTaskScheduler.shutdown();
		}
		this.scheduled.cancel(false);
		switch (shutdownOperation) {
			case POST -> post();
			case PUT -> put();
			case DELETE -> delete();
		}
	}
	/**
	 * The operation that should be performed on shutdown.
	 */
	public enum ShutdownOperation {
		/**
		 * Don"t perform any shutdown operation.
		 */
		NONE,
		/**
		 * Perform a POST before shutdown.
		 */
		POST,
		/**
		 * Perform a PUT before shutdown.
		 */
		PUT,
		/**
		 * Perform a DELETE before shutdown.
		 */
		DELETE
	}
	/**
	 * {@link TaskScheduler} used when the user doesn"t specify one.
	 */
	static class PushGatewayTaskScheduler extends ThreadPoolTaskScheduler {
		PushGatewayTaskScheduler() {
			setPoolSize(1);
			setDaemon(true);
			setThreadGroupName('prometheus-push-gateway');
		}
		@Override
		public ScheduledExecutorService getScheduledExecutor() throws IllegalStateException {
			return Executors.newSingleThreadScheduledExecutor(this::newThread);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.export.prometheus;
/*
package org.springframework.boot.actuate.metrics.export.prometheus;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
public enum TextOutputFormat implements Producible<TextOutputFormat> {
	/**
	 * Prometheus text version 0.0.4.
	 */
	CONTENT_TYPE_004(TextFormat.CONTENT_TYPE_004) {
		@Override
		void write(Writer writer, Enumeration<MetricFamilySamples> samples) throws IOException {
			TextFormat.write004(writer, samples);
		}
		@Override
		public boolean isDefault() {
			return true;
		}
	},
	/**
	 * OpenMetrics text version 1.0.0.
	 */
	CONTENT_TYPE_OPENMETRICS_100(TextFormat.CONTENT_TYPE_OPENMETRICS_100) {
		@Override
		void write(Writer writer, Enumeration<MetricFamilySamples> samples) throws IOException {
			TextFormat.writeOpenMetrics100(writer, samples);
		}
	};
	private final MimeType mimeType;
	TextOutputFormat(String mimeType) {
		this.mimeType = MimeTypeUtils.parseMimeType(mimeType);
	}
	@Override
	public MimeType getProducedMimeType() {
		return this.mimeType;
	}
	abstract void write(Writer writer, Enumeration<MetricFamilySamples> samples) throws IOException;
}
/*
package org.springframework.boot.actuate.metrics.jdbc;
/**
public class DataSourcePoolMetrics implements MeterBinder {
	private final DataSource dataSource;
	private final CachingDataSourcePoolMetadataProvider metadataProvider;
	private final Iterable<Tag> tags;
	public DataSourcePoolMetrics(DataSource dataSource, Collection<DataSourcePoolMetadataProvider> metadataProviders,
			String dataSourceName, Iterable<Tag> tags) {
		this(dataSource, new CompositeDataSourcePoolMetadataProvider(metadataProviders), dataSourceName, tags);
	}
	public DataSourcePoolMetrics(DataSource dataSource, DataSourcePoolMetadataProvider metadataProvider, String name,
			Iterable<Tag> tags) {
		Assert.notNull(dataSource, 'DataSource must not be null');
		Assert.notNull(metadataProvider, 'MetadataProvider must not be null');
		this.dataSource = dataSource;
		this.metadataProvider = new CachingDataSourcePoolMetadataProvider(metadataProvider);
		this.tags = Tags.concat(tags, 'name', name);
	}
	@Override
	public void bindTo(MeterRegistry registry) {
		if (this.metadataProvider.getDataSourcePoolMetadata(this.dataSource) != null) {
			bindPoolMetadata(registry, 'active',
					'Current number of active connections that have been allocated from the data source.',
					DataSourcePoolMetadata::getActive);
			bindPoolMetadata(registry, 'idle', 'Number of established but idle connections.',
					DataSourcePoolMetadata::getIdle);
			bindPoolMetadata(registry, 'max',
					'Maximum number of active connections that can be allocated at the same time.',
					DataSourcePoolMetadata::getMax);
			bindPoolMetadata(registry, 'min', 'Minimum number of idle connections in the pool.',
					DataSourcePoolMetadata::getMin);
		}
	}
	private <N extends Number> void bindPoolMetadata(MeterRegistry registry, String metricName, String description,
			Function<DataSourcePoolMetadata, N> function) {
		bindDataSource(registry, metricName, description, this.metadataProvider.getValueFunction(function));
	}
	private <N extends Number> void bindDataSource(MeterRegistry registry, String metricName, String description,
			Function<DataSource, N> function) {
		if (function.apply(this.dataSource) != null) {
			Gauge.builder('jdbc.connections.' + metricName, this.dataSource, (m) -> function.apply(m).doubleValue())
				.tags(this.tags)
				.description(description)
				.register(registry);
		}
	}
	private static class CachingDataSourcePoolMetadataProvider implements DataSourcePoolMetadataProvider {
		private static final Map<DataSource, DataSourcePoolMetadata> cache = new ConcurrentReferenceHashMap<>();
		private final DataSourcePoolMetadataProvider metadataProvider;
		CachingDataSourcePoolMetadataProvider(DataSourcePoolMetadataProvider metadataProvider) {
			this.metadataProvider = metadataProvider;
		}
		<N extends Number> Function<DataSource, N> getValueFunction(Function<DataSourcePoolMetadata, N> function) {
			return (dataSource) -> function.apply(getDataSourcePoolMetadata(dataSource));
		}
		@Override
		public DataSourcePoolMetadata getDataSourcePoolMetadata(DataSource dataSource) {
			return cache.computeIfAbsent(dataSource,
					(key) -> this.metadataProvider.getDataSourcePoolMetadata(dataSource));
		}
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.jdbc;
/*
package org.springframework.boot.actuate.metrics.cache;
/**
public class JCacheCacheMeterBinderProvider implements CacheMeterBinderProvider<JCacheCache> {
	@Override
	public MeterBinder getMeterBinder(JCacheCache cache, Iterable<Tag> tags) {
		return new JCacheMetrics<>(cache.getNativeCache(), tags);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
@FunctionalInterface
public interface CacheMeterBinderProvider<C extends Cache> {
	/**
	 * Return the {@link MeterBinder} managing the specified {@link Cache} or {@code null}
	 * if the specified {@link Cache} is not supported.
	 * @param cache the cache to instrument
	 * @param tags tags to apply to all recorded metrics
	 * @return a {@link MeterBinder} handling the specified {@link Cache} or {@code null}
	 */
	MeterBinder getMeterBinder(C cache, Iterable<Tag> tags);
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
public class RedisCacheMeterBinderProvider implements CacheMeterBinderProvider<RedisCache> {
	@Override
	public MeterBinder getMeterBinder(RedisCache cache, Iterable<Tag> tags) {
		return new RedisCacheMetrics(cache, tags);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
public class Cache2kCacheMeterBinderProvider implements CacheMeterBinderProvider<SpringCache2kCache> {
	@Override
	public MeterBinder getMeterBinder(SpringCache2kCache cache, Iterable<Tag> tags) {
		return new Cache2kCacheMetrics(cache.getNativeCache(), tags);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
public class CaffeineCacheMeterBinderProvider implements CacheMeterBinderProvider<CaffeineCache> {
	@Override
	public MeterBinder getMeterBinder(CaffeineCache cache, Iterable<Tag> tags) {
		return new CaffeineCacheMetrics<>(cache.getNativeCache(), cache.getName(), tags);
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.cache;
/*
package org.springframework.boot.actuate.metrics.cache;
/**
@ImportRuntimeHints(HazelcastCacheMeterBinderProviderRuntimeHints.class)
public class HazelcastCacheMeterBinderProvider implements CacheMeterBinderProvider<HazelcastCache> {
	@Override
	public MeterBinder getMeterBinder(HazelcastCache cache, Iterable<Tag> tags) {
		try {
			return new HazelcastCacheMetrics(cache.getNativeCache(), tags);
		}
		catch (NoSuchMethodError ex) {
			// Hazelcast 4
			return createHazelcast4CacheMetrics(cache, tags);
		}
	}
	private MeterBinder createHazelcast4CacheMetrics(HazelcastCache cache, Iterable<Tag> tags) {
		try {
			Method nativeCacheAccessor = ReflectionUtils.findMethod(HazelcastCache.class, 'getNativeCache');
			Object nativeCache = ReflectionUtils.invokeMethod(nativeCacheAccessor, cache);
			return HazelcastCacheMetrics.class.getConstructor(Object.class, Iterable.class)
				.newInstance(nativeCache, tags);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Failed to create MeterBinder for Hazelcast', ex);
		}
	}
	static class HazelcastCacheMeterBinderProviderRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			try {
				Method getNativeCacheMethod = ReflectionUtils.findMethod(HazelcastCache.class, 'getNativeCache');
				Assert.state(getNativeCacheMethod != null, 'Unable to find "getNativeCache" method');
				Constructor<?> constructor = HazelcastCacheMetrics.class.getConstructor(Object.class, Iterable.class);
				hints.reflection()
					.registerMethod(getNativeCacheMethod, ExecutableMode.INVOKE)
					.registerConstructor(constructor, ExecutableMode.INVOKE);
			}
			catch (NoSuchMethodException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
public class RedisCacheMetrics extends CacheMeterBinder<RedisCache> {
	private final RedisCache cache;
	public RedisCacheMetrics(RedisCache cache, Iterable<Tag> tags) {
		super(cache, cache.getName(), tags);
		this.cache = cache;
	}
	@Override
	protected Long size() {
		return null;
	}
	@Override
	protected long hitCount() {
		return this.cache.getStatistics().getHits();
	}
	@Override
	protected Long missCount() {
		return this.cache.getStatistics().getMisses();
	}
	@Override
	protected Long evictionCount() {
		return null;
	}
	@Override
	protected long putCount() {
		return this.cache.getStatistics().getPuts();
	}
	@Override
	protected void bindImplementationSpecificMetrics(MeterRegistry registry) {
		FunctionCounter.builder('cache.removals', this.cache, (cache) -> cache.getStatistics().getDeletes())
			.tags(getTagsWithCacheName())
			.description('Cache removals')
			.register(registry);
		FunctionCounter.builder('cache.gets', this.cache, (cache) -> cache.getStatistics().getPending())
			.tags(getTagsWithCacheName())
			.tag('result', 'pending')
			.description('The number of pending requests')
			.register(registry);
		TimeGauge
			.builder('cache.lock.duration', this.cache, TimeUnit.NANOSECONDS,
					(cache) -> cache.getStatistics().getLockWaitDuration(TimeUnit.NANOSECONDS))
			.tags(getTagsWithCacheName())
			.description('The time the cache has spent waiting on a lock')
			.register(registry);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
public class CacheMetricsRegistrar {
	private final MeterRegistry registry;
	private final Collection<CacheMeterBinderProvider<?>> binderProviders;
	/**
	 * Creates a new registrar.
	 * @param registry the {@link MeterRegistry} to use
	 * @param binderProviders the {@link CacheMeterBinderProvider} instances that should
	 * be used to detect compatible caches
	 */
	public CacheMetricsRegistrar(MeterRegistry registry, Collection<CacheMeterBinderProvider<?>> binderProviders) {
		this.registry = registry;
		this.binderProviders = binderProviders;
	}
	/**
	 * Attempt to bind the specified {@link Cache} to the registry. Return {@code true} if
	 * the cache is supported and was bound to the registry, {@code false} otherwise.
	 * @param cache the cache to handle
	 * @param tags the tags to associate with the metrics of that cache
	 * @return {@code true} if the {@code cache} is supported and was registered
	 */
	public boolean bindCacheToRegistry(Cache cache, Tag... tags) {
		MeterBinder meterBinder = getMeterBinder(unwrapIfNecessary(cache), Tags.of(tags));
		if (meterBinder != null) {
			meterBinder.bindTo(this.registry);
			return true;
		}
		return false;
	}
	@SuppressWarnings({ 'unchecked' })
	private MeterBinder getMeterBinder(Cache cache, Tags tags) {
		Tags cacheTags = tags.and(getAdditionalTags(cache));
		return LambdaSafe.callbacks(CacheMeterBinderProvider.class, this.binderProviders, cache)
			.withLogger(CacheMetricsRegistrar.class)
			.invokeAnd((binderProvider) -> binderProvider.getMeterBinder(cache, cacheTags))
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(null);
	}
	/**
	 * Return additional {@link Tag tags} to be associated with the given {@link Cache}.
	 * @param cache the cache
	 * @return a list of additional tags to associate to that {@code cache}.
	 */
	protected Iterable<Tag> getAdditionalTags(Cache cache) {
		return Tags.of('name', cache.getName());
	}
	private Cache unwrapIfNecessary(Cache cache) {
		if (ClassUtils.isPresent('org.springframework.cache.transaction.TransactionAwareCacheDecorator',
				getClass().getClassLoader())) {
			return TransactionAwareCacheDecoratorHandler.unwrapIfNecessary(cache);
		}
		return cache;
	}
	private static final class TransactionAwareCacheDecoratorHandler {
		private static Cache unwrapIfNecessary(Cache cache) {
			try {
				if (cache instanceof TransactionAwareCacheDecorator decorator) {
					return decorator.getTargetCache();
				}
			}
			catch (NoClassDefFoundError ex) {
				// Ignore
			}
			return cache;
		}
	}
}
/*
package org.springframework.boot.actuate.metrics;
/**
@FunctionalInterface
public interface AutoTimer {
	/**
	 * An {@link AutoTimer} implementation that is enabled but applies no additional
	 * customizations.
	 */
	AutoTimer ENABLED = (builder) -> {
	};
	/**
	 * An {@link AutoTimer} implementation that is disabled and will not record metrics.
	 */
	AutoTimer DISABLED = new AutoTimer() {
		@Override
		public boolean isEnabled() {
			return false;
		}
		@Override
		public void apply(Builder builder) {
			throw new IllegalStateException('AutoTimer is disabled');
		}
	};
	/**
	 * Return if the auto-timer is enabled and metrics should be recorded.
	 * @return if the auto-timer is enabled
	 */
	default boolean isEnabled() {
		return true;
	}
	/**
	 * Factory method to create a new {@link Builder Timer.Builder} with auto-timer
	 * settings {@link #apply(Timer.Builder) applied}.
	 * @param name the name of the timer
	 * @return a new builder instance with auto-settings applied
	 */
	default Timer.Builder builder(String name) {
		return builder(() -> Timer.builder(name));
	}
	/**
	 * Factory method to create a new {@link Builder Timer.Builder} with auto-timer
	 * settings {@link #apply(Timer.Builder) applied}.
	 * @param supplier the builder supplier
	 * @return a new builder instance with auto-settings applied
	 */
	default Timer.Builder builder(Supplier<Timer.Builder> supplier) {
		Timer.Builder builder = supplier.get();
		apply(builder);
		return builder;
	}
	/**
	 * Called to apply any auto-timer settings to the given {@link Builder Timer.Builder}.
	 * @param builder the builder to apply settings to
	 */
	void apply(Timer.Builder builder);
	static void apply(AutoTimer autoTimer, String metricName, Set<Timed> annotations, Consumer<Timer.Builder> action) {
		if (!CollectionUtils.isEmpty(annotations)) {
			for (Timed annotation : annotations) {
				action.accept(Timer.builder(annotation, metricName));
			}
		}
		else {
			if (autoTimer != null && autoTimer.isEnabled()) {
				action.accept(autoTimer.builder(metricName));
			}
		}
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.annotation;
/*
package org.springframework.boot.actuate.metrics.annotation;
/**
public final class TimedAnnotations {
	private static final Map<AnnotatedElement, Set<Timed>> cache = new ConcurrentReferenceHashMap<>();
	private TimedAnnotations() {
	}
	/**
	 * Return {@link Timed} annotations that should be used for the given {@code method}
	 * and {@code type}.
	 * @param method the source method
	 * @param type the source type
	 * @return the {@link Timed} annotations to use or an empty set
	 */
	public static Set<Timed> get(Method method, Class<?> type) {
		Set<Timed> methodAnnotations = findTimedAnnotations(method);
		if (!methodAnnotations.isEmpty()) {
			return methodAnnotations;
		}
		return findTimedAnnotations(type);
	}
	private static Set<Timed> findTimedAnnotations(AnnotatedElement element) {
		if (element == null) {
			return Collections.emptySet();
		}
		Set<Timed> result = cache.get(element);
		if (result != null) {
			return result;
		}
		MergedAnnotations annotations = MergedAnnotations.from(element);
		result = (!annotations.isPresent(Timed.class)) ? Collections.emptySet()
				: annotations.stream(Timed.class).collect(MergedAnnotationCollectors.toAnnotationSet());
		cache.put(element, result);
		return result;
	}
}
/*
package org.springframework.boot.actuate.metrics.web.jetty;
/**
public abstract class AbstractJettyMetricsBinder implements ApplicationListener<ApplicationStartedEvent> {
	@Override
	public void onApplicationEvent(ApplicationStartedEvent event) {
		Server server = findServer(event.getApplicationContext());
		if (server != null) {
			bindMetrics(server);
		}
	}
	private Server findServer(ApplicationContext applicationContext) {
		if (applicationContext instanceof WebServerApplicationContext webServerApplicationContext) {
			WebServer webServer = webServerApplicationContext.getWebServer();
			if (webServer instanceof JettyWebServer jettyWebServer) {
				return jettyWebServer.getServer();
			}
		}
		return null;
	}
	protected abstract void bindMetrics(Server server);
}
/*
package org.springframework.boot.actuate.metrics.web.jetty;
/**
public class JettySslHandshakeMetricsBinder extends AbstractJettyMetricsBinder {
	private final MeterRegistry meterRegistry;
	private final Iterable<Tag> tags;
	public JettySslHandshakeMetricsBinder(MeterRegistry meterRegistry) {
		this(meterRegistry, Collections.emptyList());
	}
	public JettySslHandshakeMetricsBinder(MeterRegistry meterRegistry, Iterable<Tag> tags) {
		this.meterRegistry = meterRegistry;
		this.tags = tags;
	}
	@Override
	protected void bindMetrics(Server server) {
		JettySslHandshakeMetrics.addToAllConnectors(server, this.meterRegistry, this.tags);
	}
}
/*
package org.springframework.boot.actuate.metrics.web.jetty;
/**
public class JettyConnectionMetricsBinder extends AbstractJettyMetricsBinder {
	private final MeterRegistry meterRegistry;
	private final Iterable<Tag> tags;
	public JettyConnectionMetricsBinder(MeterRegistry meterRegistry) {
		this(meterRegistry, Collections.emptyList());
	}
	public JettyConnectionMetricsBinder(MeterRegistry meterRegistry, Iterable<Tag> tags) {
		this.meterRegistry = meterRegistry;
		this.tags = tags;
	}
	@Override
	protected void bindMetrics(Server server) {
		JettyConnectionMetrics.addToAllConnectors(server, this.meterRegistry, this.tags);
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.web.jetty;
/*
package org.springframework.boot.actuate.metrics.web.jetty;
/**
public class JettyServerThreadPoolMetricsBinder extends AbstractJettyMetricsBinder {
	private final MeterRegistry meterRegistry;
	private final Iterable<Tag> tags;
	public JettyServerThreadPoolMetricsBinder(MeterRegistry meterRegistry) {
		this(meterRegistry, Collections.emptyList());
	}
	public JettyServerThreadPoolMetricsBinder(MeterRegistry meterRegistry, Iterable<Tag> tags) {
		this.meterRegistry = meterRegistry;
		this.tags = tags;
	}
	@Override
	@SuppressWarnings('resource')
	protected void bindMetrics(Server server) {
		ThreadPool threadPool = server.getThreadPool();
		if (threadPool != null) {
			new JettyServerThreadPoolMetrics(threadPool, this.tags).bindTo(this.meterRegistry);
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.web.client;
/**
public class ObservationRestClientCustomizer implements RestClientCustomizer {
	private final ObservationRegistry observationRegistry;
	private final ClientRequestObservationConvention observationConvention;
	/**
	 * Create a new {@link ObservationRestClientCustomizer}.
	 * @param observationRegistry the observation registry
	 * @param observationConvention the observation convention
	 */
	public ObservationRestClientCustomizer(ObservationRegistry observationRegistry,
			ClientRequestObservationConvention observationConvention) {
		Assert.notNull(observationConvention, 'ObservationConvention must not be null');
		Assert.notNull(observationRegistry, 'ObservationRegistry must not be null');
		this.observationRegistry = observationRegistry;
		this.observationConvention = observationConvention;
	}
	@Override
	public void customize(Builder restClientBuilder) {
		restClientBuilder.observationRegistry(this.observationRegistry);
		restClientBuilder.observationConvention(this.observationConvention);
	}
}
/*
package org.springframework.boot.actuate.metrics.web.client;
/**
public class ObservationRestTemplateCustomizer implements RestTemplateCustomizer {
	private final ObservationRegistry observationRegistry;
	private final ClientRequestObservationConvention observationConvention;
	/**
	 * Create a new {@code ObservationRestTemplateCustomizer}.
	 * @param observationConvention the observation convention
	 * @param observationRegistry the observation registry
	 */
	public ObservationRestTemplateCustomizer(ObservationRegistry observationRegistry,
			ClientRequestObservationConvention observationConvention) {
		this.observationConvention = observationConvention;
		this.observationRegistry = observationRegistry;
	}
	@Override
	public void customize(RestTemplate restTemplate) {
		restTemplate.setObservationConvention(this.observationConvention);
		restTemplate.setObservationRegistry(this.observationRegistry);
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.web.client;
/*
package org.springframework.boot.actuate.metrics.web.tomcat;
/**
public class TomcatMetricsBinder implements ApplicationListener<ApplicationStartedEvent>, DisposableBean {
	private final MeterRegistry meterRegistry;
	private final Iterable<Tag> tags;
	private volatile TomcatMetrics tomcatMetrics;
	public TomcatMetricsBinder(MeterRegistry meterRegistry) {
		this(meterRegistry, Collections.emptyList());
	}
	public TomcatMetricsBinder(MeterRegistry meterRegistry, Iterable<Tag> tags) {
		this.meterRegistry = meterRegistry;
		this.tags = tags;
	}
	@Override
	public void onApplicationEvent(ApplicationStartedEvent event) {
		ApplicationContext applicationContext = event.getApplicationContext();
		Manager manager = findManager(applicationContext);
		this.tomcatMetrics = new TomcatMetrics(manager, this.tags);
		this.tomcatMetrics.bindTo(this.meterRegistry);
	}
	private Manager findManager(ApplicationContext applicationContext) {
		if (applicationContext instanceof WebServerApplicationContext webServerApplicationContext) {
			WebServer webServer = webServerApplicationContext.getWebServer();
			if (webServer instanceof TomcatWebServer tomcatWebServer) {
				Context context = findContext(tomcatWebServer);
				if (context != null) {
					return context.getManager();
				}
			}
		}
		return null;
	}
	private Context findContext(TomcatWebServer tomcatWebServer) {
		for (Container container : tomcatWebServer.getTomcat().getHost().findChildren()) {
			if (container instanceof Context context) {
				return context;
			}
		}
		return null;
	}
	@Override
	public void destroy() {
		if (this.tomcatMetrics != null) {
			this.tomcatMetrics.close();
		}
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.web.tomcat;
/*
package org.springframework.boot.actuate.metrics.web.reactive.client;
/**
public class ObservationWebClientCustomizer implements WebClientCustomizer {
	private final ObservationRegistry observationRegistry;
	private final ClientRequestObservationConvention observationConvention;
	/**
	 * Create a new {@code ObservationWebClientCustomizer} that will configure the
	 * {@code Observation} setup on the client.
	 * @param observationRegistry the registry to publish observations to
	 * @param observationConvention the convention to use to populate observations
	 */
	public ObservationWebClientCustomizer(ObservationRegistry observationRegistry,
			ClientRequestObservationConvention observationConvention) {
		this.observationRegistry = observationRegistry;
		this.observationConvention = observationConvention;
	}
	@Override
	public void customize(WebClient.Builder webClientBuilder) {
		webClientBuilder.observationRegistry(this.observationRegistry)
			.observationConvention(this.observationConvention);
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.web.reactive.client;
/*
package org.springframework.boot.actuate.metrics;
/**
@Endpoint(id = 'metrics')
public class MetricsEndpoint {
	private final MeterRegistry registry;
	public MetricsEndpoint(MeterRegistry registry) {
		this.registry = registry;
	}
	@ReadOperation
	public MetricNamesDescriptor listNames() {
		Set<String> names = new TreeSet<>();
		collectNames(names, this.registry);
		return new MetricNamesDescriptor(names);
	}
	private void collectNames(Set<String> names, MeterRegistry registry) {
		if (registry instanceof CompositeMeterRegistry compositeMeterRegistry) {
			compositeMeterRegistry.getRegistries().forEach((member) -> collectNames(names, member));
		}
		else {
			registry.getMeters().stream().map(this::getName).forEach(names::add);
		}
	}
	private String getName(Meter meter) {
		return meter.getId().getName();
	}
	@ReadOperation
	public MetricDescriptor metric(@Selector String requiredMetricName, @Nullable List<String> tag) {
		List<Tag> tags = parseTags(tag);
		Collection<Meter> meters = findFirstMatchingMeters(this.registry, requiredMetricName, tags);
		if (meters.isEmpty()) {
			return null;
		}
		Map<Statistic, Double> samples = getSamples(meters);
		Map<String, Set<String>> availableTags = getAvailableTags(meters);
		tags.forEach((t) -> availableTags.remove(t.getKey()));
		Meter.Id meterId = meters.iterator().next().getId();
		return new MetricDescriptor(requiredMetricName, meterId.getDescription(), meterId.getBaseUnit(),
				asList(samples, Sample::new), asList(availableTags, AvailableTag::new));
	}
	private List<Tag> parseTags(List<String> tags) {
		return (tags != null) ? tags.stream().map(this::parseTag).toList() : Collections.emptyList();
	}
	private Tag parseTag(String tag) {
		String[] parts = tag.split(':', 2);
		if (parts.length != 2) {
			throw new InvalidEndpointRequestException(
					'Each tag parameter must be in the form "key:value" but was: ' + tag,
					'Each tag parameter must be in the form "key:value"');
		}
		return Tag.of(parts[0], parts[1]);
	}
	private Collection<Meter> findFirstMatchingMeters(MeterRegistry registry, String name, Iterable<Tag> tags) {
		if (registry instanceof CompositeMeterRegistry compositeMeterRegistry) {
			return findFirstMatchingMeters(compositeMeterRegistry, name, tags);
		}
		return registry.find(name).tags(tags).meters();
	}
	private Collection<Meter> findFirstMatchingMeters(CompositeMeterRegistry composite, String name,
			Iterable<Tag> tags) {
		return composite.getRegistries()
			.stream()
			.map((registry) -> findFirstMatchingMeters(registry, name, tags))
			.filter((matching) -> !matching.isEmpty())
			.findFirst()
			.orElse(Collections.emptyList());
	}
	private Map<Statistic, Double> getSamples(Collection<Meter> meters) {
		Map<Statistic, Double> samples = new LinkedHashMap<>();
		meters.forEach((meter) -> mergeMeasurements(samples, meter));
		return samples;
	}
	private void mergeMeasurements(Map<Statistic, Double> samples, Meter meter) {
		meter.measure()
			.forEach((measurement) -> samples.merge(measurement.getStatistic(), measurement.getValue(),
					mergeFunction(measurement.getStatistic())));
	}
	private BiFunction<Double, Double, Double> mergeFunction(Statistic statistic) {
		return Statistic.MAX.equals(statistic) ? Double::max : Double::sum;
	}
	private Map<String, Set<String>> getAvailableTags(Collection<Meter> meters) {
		Map<String, Set<String>> availableTags = new HashMap<>();
		meters.forEach((meter) -> mergeAvailableTags(availableTags, meter));
		return availableTags;
	}
	private void mergeAvailableTags(Map<String, Set<String>> availableTags, Meter meter) {
		meter.getId().getTags().forEach((tag) -> {
			Set<String> value = Collections.singleton(tag.getValue());
			availableTags.merge(tag.getKey(), value, this::merge);
		});
	}
	private <T> Set<T> merge(Set<T> set1, Set<T> set2) {
		Set<T> result = new HashSet<>(set1.size() + set2.size());
		result.addAll(set1);
		result.addAll(set2);
		return result;
	}
	private <K, V, T> List<T> asList(Map<K, V> map, BiFunction<K, V, T> mapper) {
		return map.entrySet().stream().map((entry) -> mapper.apply(entry.getKey(), entry.getValue())).toList();
	}
	/**
	 * Description of metric names.
	 */
	public static final class MetricNamesDescriptor implements OperationResponseBody {
		private final Set<String> names;
		MetricNamesDescriptor(Set<String> names) {
			this.names = names;
		}
		public Set<String> getNames() {
			return this.names;
		}
	}
	/**
	 * Description of a metric.
	 */
	public static final class MetricDescriptor implements OperationResponseBody {
		private final String name;
		private final String description;
		private final String baseUnit;
		private final List<Sample> measurements;
		private final List<AvailableTag> availableTags;
		MetricDescriptor(String name, String description, String baseUnit, List<Sample> measurements,
				List<AvailableTag> availableTags) {
			this.name = name;
			this.description = description;
			this.baseUnit = baseUnit;
			this.measurements = measurements;
			this.availableTags = availableTags;
		}
		public String getName() {
			return this.name;
		}
		public String getDescription() {
			return this.description;
		}
		public String getBaseUnit() {
			return this.baseUnit;
		}
		public List<Sample> getMeasurements() {
			return this.measurements;
		}
		public List<AvailableTag> getAvailableTags() {
			return this.availableTags;
		}
	}
	/**
	 * A set of tags for further dimensional drill-down and their potential values.
	 */
	public static final class AvailableTag {
		private final String tag;
		private final Set<String> values;
		AvailableTag(String tag, Set<String> values) {
			this.tag = tag;
			this.values = values;
		}
		public String getTag() {
			return this.tag;
		}
		public Set<String> getValues() {
			return this.values;
		}
	}
	/**
	 * A measurement sample combining a {@link Statistic statistic} and a value.
	 */
	public static final class Sample {
		private final Statistic statistic;
		private final Double value;
		Sample(Statistic statistic, Double value) {
			this.statistic = statistic;
			this.value = value;
		}
		public Statistic getStatistic() {
			return this.statistic;
		}
		public Double getValue() {
			return this.value;
		}
		@Override
		public String toString() {
			return 'MeasurementSample{statistic=' + this.statistic + ', value=' + this.value + "}";
		}
	}
}
/*
package org.springframework.boot.actuate.metrics.data;
/**
public class MetricsRepositoryMethodInvocationListener implements RepositoryMethodInvocationListener {
	private final SingletonSupplier<MeterRegistry> registrySupplier;
	private final RepositoryTagsProvider tagsProvider;
	private final String metricName;
	private final AutoTimer autoTimer;
	/**
	 * Create a new {@code MetricsRepositoryMethodInvocationListener}.
	 * @param registrySupplier a supplier for the registry to which metrics are recorded
	 * @param tagsProvider provider for metrics tags
	 * @param metricName name of the metric to record
	 * @param autoTimer the auto-timers to apply or {@code null} to disable auto-timing
	 * @since 2.5.4
	 */
	public MetricsRepositoryMethodInvocationListener(Supplier<MeterRegistry> registrySupplier,
			RepositoryTagsProvider tagsProvider, String metricName, AutoTimer autoTimer) {
		this.registrySupplier = (registrySupplier instanceof SingletonSupplier)
				? (SingletonSupplier<MeterRegistry>) registrySupplier : SingletonSupplier.of(registrySupplier);
		this.tagsProvider = tagsProvider;
		this.metricName = metricName;
		this.autoTimer = (autoTimer != null) ? autoTimer : AutoTimer.DISABLED;
	}
	@Override
	public void afterInvocation(RepositoryMethodInvocation invocation) {
		Set<Timed> annotations = TimedAnnotations.get(invocation.getMethod(), invocation.getRepositoryInterface());
		Iterable<Tag> tags = this.tagsProvider.repositoryTags(invocation);
		long duration = invocation.getDuration(TimeUnit.NANOSECONDS);
		AutoTimer.apply(this.autoTimer, this.metricName, annotations,
				(builder) -> builder.description('Duration of repository invocations')
					.tags(tags)
					.register(this.registrySupplier.get())
					.record(duration, TimeUnit.NANOSECONDS));
	}
}
/*
package org.springframework.boot.actuate.metrics.data;
/**
public class DefaultRepositoryTagsProvider implements RepositoryTagsProvider {
	private static final Tag EXCEPTION_NONE = Tag.of('exception', 'None');
	@Override
	public Iterable<Tag> repositoryTags(RepositoryMethodInvocation invocation) {
		Tags tags = Tags.empty();
		tags = and(tags, invocation.getRepositoryInterface(), 'repository', this::getSimpleClassName);
		tags = and(tags, invocation.getMethod(), 'method', Method::getName);
		tags = and(tags, invocation.getResult().getState(), 'state', State::name);
		tags = and(tags, invocation.getResult().getError(), 'exception', this::getExceptionName, EXCEPTION_NONE);
		return tags;
	}
	private <T> Tags and(Tags tags, T instance, String key, Function<T, String> value) {
		return and(tags, instance, key, value, null);
	}
	private <T> Tags and(Tags tags, T instance, String key, Function<T, String> value, Tag fallback) {
		if (instance != null) {
			return tags.and(key, value.apply(instance));
		}
		return (fallback != null) ? tags.and(fallback) : tags;
	}
	private String getExceptionName(Throwable error) {
		return getSimpleClassName(error.getClass());
	}
	private String getSimpleClassName(Class<?> type) {
		String simpleName = type.getSimpleName();
		return (!StringUtils.hasText(simpleName)) ? type.getName() : simpleName;
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.data;
/*
package org.springframework.boot.actuate.metrics.data;
/**
@FunctionalInterface
public interface RepositoryTagsProvider {
	/**
	 * Provides tags to be associated with metrics for the given {@code invocation}.
	 * @param invocation the repository invocation
	 * @return tags to associate with metrics for the invocation
	 */
	Iterable<Tag> repositoryTags(RepositoryMethodInvocation invocation);
}
/*
package org.springframework.boot.actuate.metrics.system;
/**
public class DiskSpaceMetricsBinder implements MeterBinder {
	private final List<File> paths;
	private final Iterable<Tag> tags;
	public DiskSpaceMetricsBinder(List<File> paths, Iterable<Tag> tags) {
		Assert.notEmpty(paths, 'Paths must not be empty');
		this.paths = paths;
		this.tags = tags;
	}
	@Override
	public void bindTo(MeterRegistry registry) {
		this.paths.forEach((path) -> new DiskSpaceMetrics(path, this.tags).bindTo(registry));
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.system;
/*
package org.springframework.boot.actuate.metrics.amqp;
/**
public class RabbitMetrics implements MeterBinder {
	private final Iterable<Tag> tags;
	private final ConnectionFactory connectionFactory;
	/**
	 * Create a new meter binder recording the specified {@link ConnectionFactory}.
	 * @param connectionFactory the {@link ConnectionFactory} to instrument
	 * @param tags tags to apply to all recorded metrics
	 */
	public RabbitMetrics(ConnectionFactory connectionFactory, Iterable<Tag> tags) {
		Assert.notNull(connectionFactory, 'ConnectionFactory must not be null');
		this.connectionFactory = connectionFactory;
		this.tags = (tags != null) ? tags : Collections.emptyList();
	}
	@Override
	public void bindTo(MeterRegistry registry) {
		this.connectionFactory.setMetricsCollector(new MicrometerMetricsCollector(registry, 'rabbitmq', this.tags));
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.amqp;
/*
/**
package org.springframework.boot.actuate.metrics.startup;
/*
package org.springframework.boot.actuate.metrics.startup;
/**
public class StartupTimeMetricsListener implements SmartApplicationListener {
	/**
	 * The default name to use for the application started time metric.
	 */
	public static final String APPLICATION_STARTED_TIME_METRIC_NAME = 'application.started.time';
	/**
	 * The default name to use for the application ready time metric.
	 */
	public static final String APPLICATION_READY_TIME_METRIC_NAME = 'application.ready.time';
	private final MeterRegistry meterRegistry;
	private final String startedTimeMetricName;
	private final String readyTimeMetricName;
	private final Tags tags;
	/**
	 * Create a new instance using default metric names.
	 * @param meterRegistry the registry to use
	 * @see #APPLICATION_STARTED_TIME_METRIC_NAME
	 * @see #APPLICATION_READY_TIME_METRIC_NAME
	 */
	public StartupTimeMetricsListener(MeterRegistry meterRegistry) {
		this(meterRegistry, APPLICATION_STARTED_TIME_METRIC_NAME, APPLICATION_READY_TIME_METRIC_NAME,
				Collections.emptyList());
	}
	/**
	 * Create a new instance using the specified options.
	 * @param meterRegistry the registry to use
	 * @param startedTimeMetricName the name to use for the application started time
	 * metric
	 * @param readyTimeMetricName the name to use for the application ready time metric
	 * @param tags the tags to associate to application startup metrics
	 */
	public StartupTimeMetricsListener(MeterRegistry meterRegistry, String startedTimeMetricName,
			String readyTimeMetricName, Iterable<Tag> tags) {
		this.meterRegistry = meterRegistry;
		this.startedTimeMetricName = startedTimeMetricName;
		this.readyTimeMetricName = readyTimeMetricName;
		this.tags = Tags.of(tags);
	}
	@Override
	public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
		return ApplicationStartedEvent.class.isAssignableFrom(eventType)
				|| ApplicationReadyEvent.class.isAssignableFrom(eventType);
	}
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof ApplicationStartedEvent startedEvent) {
			onApplicationStarted(startedEvent);
		}
		if (event instanceof ApplicationReadyEvent readyEvent) {
			onApplicationReady(readyEvent);
		}
	}
	private void onApplicationStarted(ApplicationStartedEvent event) {
		registerGauge(this.startedTimeMetricName, 'Time taken to start the application', event.getTimeTaken(),
				event.getSpringApplication());
	}
	private void onApplicationReady(ApplicationReadyEvent event) {
		registerGauge(this.readyTimeMetricName, 'Time taken for the application to be ready to service requests',
				event.getTimeTaken(), event.getSpringApplication());
	}
	private void registerGauge(String name, String description, Duration timeTaken,
			SpringApplication springApplication) {
		if (timeTaken != null) {
			Iterable<Tag> tags = createTagsFrom(springApplication);
			TimeGauge.builder(name, timeTaken::toMillis, TimeUnit.MILLISECONDS)
				.tags(tags)
				.description(description)
				.register(this.meterRegistry);
		}
	}
	private Iterable<Tag> createTagsFrom(SpringApplication springApplication) {
		Class<?> mainClass = springApplication.getMainApplicationClass();
		return (mainClass != null) ? this.tags.and('main.application.class', mainClass.getName()) : this.tags;
	}
}
/*
package org.springframework.boot.actuate.metrics.r2dbc;
/**
public class ConnectionPoolMetrics implements MeterBinder {
	private static final String CONNECTIONS = 'connections';
	private final ConnectionPool pool;
	private final Iterable<Tag> tags;
	public ConnectionPoolMetrics(ConnectionPool pool, String name, Iterable<Tag> tags) {
		this.pool = pool;
		this.tags = Tags.concat(tags, 'name', name);
	}
	@Override
	public void bindTo(MeterRegistry registry) {
		this.pool.getMetrics().ifPresent((poolMetrics) -> {
			bindConnectionPoolMetric(registry,
					Gauge.builder(metricKey('acquired'), poolMetrics, PoolMetrics::acquiredSize)
						.description('Size of successfully acquired connections which are in active use.'));
			bindConnectionPoolMetric(registry,
					Gauge.builder(metricKey('allocated'), poolMetrics, PoolMetrics::allocatedSize)
						.description('Size of allocated connections in the pool which are in active use or idle.'));
			bindConnectionPoolMetric(registry, Gauge.builder(metricKey('idle'), poolMetrics, PoolMetrics::idleSize)
				.description('Size of idle connections in the pool.'));
			bindConnectionPoolMetric(registry,
					Gauge.builder(metricKey('pending'), poolMetrics, PoolMetrics::pendingAcquireSize)
						.description('Size of pending to acquire connections from the underlying connection factory.'));
			bindConnectionPoolMetric(registry,
					Gauge.builder(metricKey('max.allocated'), poolMetrics, PoolMetrics::getMaxAllocatedSize)
						.description('Maximum size of allocated connections that this pool allows.'));
			bindConnectionPoolMetric(registry,
					Gauge.builder(metricKey('max.pending'), poolMetrics, PoolMetrics::getMaxPendingAcquireSize)
						.description('Maximum size of pending state to acquire connections that this pool allows.'));
		});
	}
	private void bindConnectionPoolMetric(MeterRegistry registry, Builder<?> builder) {
		builder.tags(this.tags).baseUnit(CONNECTIONS).register(registry);
	}
	private static String metricKey(String name) {
		return 'r2dbc.pool.' + name;
	}
}
/*
/**
package org.springframework.boot.actuate.metrics.r2dbc;
/*
/**
package org.springframework.boot.actuate.metrics;
/*
/**
package org.springframework.boot.actuate.metrics.http;
/*
package org.springframework.boot.actuate.metrics.http;
/**
public enum Outcome {
	/**
	 * Outcome of the request was informational.
	 */
	INFORMATIONAL,
	/**
	 * Outcome of the request was success.
	 */
	SUCCESS,
	/**
	 * Outcome of the request was redirection.
	 */
	REDIRECTION,
	/**
	 * Outcome of the request was client error.
	 */
	CLIENT_ERROR,
	/**
	 * Outcome of the request was server error.
	 */
	SERVER_ERROR,
	/**
	 * Outcome of the request was unknown.
	 */
	UNKNOWN;
	private final Tag tag;
	Outcome() {
		this.tag = Tag.of('outcome', name());
	}
	/**
	 * Returns the {@code Outcome} as a {@link Tag} named {@code outcome}.
	 * @return the {@code outcome} {@code Tag}
	 */
	public Tag asTag() {
		return this.tag;
	}
	/**
	 * Return the {@code Outcome} for the given HTTP {@code status} code.
	 * @param status the HTTP status code
	 * @return the matching Outcome
	 */
	public static Outcome forStatus(int status) {
		if (status >= 100 && status < 200) {
			return INFORMATIONAL;
		}
		else if (status >= 200 && status < 300) {
			return SUCCESS;
		}
		else if (status >= 300 && status < 400) {
			return REDIRECTION;
		}
		else if (status >= 400 && status < 500) {
			return CLIENT_ERROR;
		}
		else if (status >= 500 && status < 600) {
			return SERVER_ERROR;
		}
		return UNKNOWN;
	}
}
/*
package org.springframework.boot.actuate.cassandra;
/**
public class CassandraDriverHealthIndicator extends AbstractHealthIndicator {
	private final CqlSession session;
	/**
	 * Create a new {@link CassandraDriverHealthIndicator} instance.
	 * @param session the {@link CqlSession}.
	 */
	public CassandraDriverHealthIndicator(CqlSession session) {
		super('Cassandra health check failed');
		Assert.notNull(session, 'session must not be null');
		this.session = session;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		Collection<Node> nodes = this.session.getMetadata().getNodes().values();
		Optional<Node> nodeUp = nodes.stream().filter((node) -> node.getState() == NodeState.UP).findAny();
		builder.status(nodeUp.isPresent() ? Status.UP : Status.DOWN);
		nodeUp.map(Node::getCassandraVersion).ifPresent((version) -> builder.withDetail('version', version));
	}
}
/*
/**
package org.springframework.boot.actuate.cassandra;
/*
package org.springframework.boot.actuate.cassandra;
/**
public class CassandraDriverReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
	private final CqlSession session;
	/**
	 * Create a new {@link CassandraDriverReactiveHealthIndicator} instance.
	 * @param session the {@link CqlSession}.
	 */
	public CassandraDriverReactiveHealthIndicator(CqlSession session) {
		super('Cassandra health check failed');
		Assert.notNull(session, 'session must not be null');
		this.session = session;
	}
	@Override
	protected Mono<Health> doHealthCheck(Health.Builder builder) {
		return Mono.fromSupplier(() -> {
			Collection<Node> nodes = this.session.getMetadata().getNodes().values();
			Optional<Node> nodeUp = nodes.stream().filter((node) -> node.getState() == NodeState.UP).findAny();
			builder.status(nodeUp.isPresent() ? Status.UP : Status.DOWN);
			nodeUp.map(Node::getCassandraVersion).ifPresent((version) -> builder.withDetail('version', version));
			return builder.build();
		});
	}
}
/*
package org.springframework.boot.actuate.audit;
/**
public interface AuditEventRepository {
	/**
	 * Log an event.
	 * @param event the audit event to log
	 */
	void add(AuditEvent event);
	/**
	 * Find audit events of specified type relating to the specified principal that
	 * occurred {@link Instant#isAfter(Instant) after} the time provided.
	 * @param principal the principal name to search for (or {@code null} if unrestricted)
	 * @param after time after which an event must have occurred (or {@code null} if
	 * unrestricted)
	 * @param type the event type to search for (or {@code null} if unrestricted)
	 * @return audit events of specified type relating to the principal
	 * @since 1.4.0
	 */
	List<AuditEvent> find(String principal, Instant after, String type);
}
/*
package org.springframework.boot.actuate.audit;
/**
@JsonInclude(Include.NON_EMPTY)
public class AuditEvent implements Serializable {
	private final Instant timestamp;
	private final String principal;
	private final String type;
	private final Map<String, Object> data;
	/**
	 * Create a new audit event for the current time.
	 * @param principal the user principal responsible
	 * @param type the event type
	 * @param data the event data
	 */
	public AuditEvent(String principal, String type, Map<String, Object> data) {
		this(Instant.now(), principal, type, data);
	}
	/**
	 * Create a new audit event for the current time from data provided as name-value
	 * pairs.
	 * @param principal the user principal responsible
	 * @param type the event type
	 * @param data the event data in the form "key=value" or simply "key"
	 */
	public AuditEvent(String principal, String type, String... data) {
		this(Instant.now(), principal, type, convert(data));
	}
	/**
	 * Create a new audit event.
	 * @param timestamp the date/time of the event
	 * @param principal the user principal responsible
	 * @param type the event type
	 * @param data the event data
	 */
	public AuditEvent(Instant timestamp, String principal, String type, Map<String, Object> data) {
		Assert.notNull(timestamp, 'Timestamp must not be null');
		Assert.notNull(type, 'Type must not be null');
		this.timestamp = timestamp;
		this.principal = (principal != null) ? principal : '';
		this.type = type;
		this.data = Collections.unmodifiableMap(data);
	}
	private static Map<String, Object> convert(String[] data) {
		Map<String, Object> result = new HashMap<>();
		for (String entry : data) {
			int index = entry.indexOf("=");
			if (index != -1) {
				result.put(entry.substring(0, index), entry.substring(index + 1));
			}
			else {
				result.put(entry, null);
			}
		}
		return result;
	}
	/**
	 * Returns the date/time that the event was logged.
	 * @return the timestamp
	 */
	public Instant getTimestamp() {
		return this.timestamp;
	}
	/**
	 * Returns the user principal responsible for the event or an empty String if the
	 * principal is not available.
	 * @return the principal
	 */
	public String getPrincipal() {
		return this.principal;
	}
	/**
	 * Returns the type of event.
	 * @return the event type
	 */
	public String getType() {
		return this.type;
	}
	/**
	 * Returns the event data.
	 * @return the event data
	 */
	public Map<String, Object> getData() {
		return this.data;
	}
	@Override
	public String toString() {
		return 'AuditEvent [timestamp=' + this.timestamp + ', principal=' + this.principal + ', type=' + this.type
				+ ', data=' + this.data + ']';
	}
}
/*
package org.springframework.boot.actuate.audit;
/**
public class InMemoryAuditEventRepository implements AuditEventRepository {
	private static final int DEFAULT_CAPACITY = 1000;
	private final Object monitor = new Object();
	/**
	 * Circular buffer of the event with tail pointing to the last element.
	 */
	private AuditEvent[] events;
	private volatile int tail = -1;
	public InMemoryAuditEventRepository() {
		this(DEFAULT_CAPACITY);
	}
	public InMemoryAuditEventRepository(int capacity) {
		this.events = new AuditEvent[capacity];
	}
	/**
	 * Set the capacity of this event repository.
	 * @param capacity the capacity
	 */
	public void setCapacity(int capacity) {
		synchronized (this.monitor) {
			this.events = new AuditEvent[capacity];
		}
	}
	@Override
	public void add(AuditEvent event) {
		Assert.notNull(event, 'AuditEvent must not be null');
		synchronized (this.monitor) {
			this.tail = (this.tail + 1) % this.events.length;
			this.events[this.tail] = event;
		}
	}
	@Override
	public List<AuditEvent> find(String principal, Instant after, String type) {
		LinkedList<AuditEvent> events = new LinkedList<>();
		synchronized (this.monitor) {
			for (int i = 0; i < this.events.length; i++) {
				AuditEvent event = resolveTailEvent(i);
				if (event != null && isMatch(principal, after, type, event)) {
					events.addFirst(event);
				}
			}
		}
		return events;
	}
	private boolean isMatch(String principal, Instant after, String type, AuditEvent event) {
		boolean match = true;
		match = match && (principal == null || event.getPrincipal().equals(principal));
		match = match && (after == null || event.getTimestamp().isAfter(after));
		match = match && (type == null || event.getType().equals(type));
		return match;
	}
	private AuditEvent resolveTailEvent(int offset) {
		int index = ((this.tail + this.events.length - offset) % this.events.length);
		return this.events[index];
	}
}
/*
package org.springframework.boot.actuate.audit;
/**
@Endpoint(id = 'auditevents')
public class AuditEventsEndpoint {
	private final AuditEventRepository auditEventRepository;
	public AuditEventsEndpoint(AuditEventRepository auditEventRepository) {
		Assert.notNull(auditEventRepository, 'AuditEventRepository must not be null');
		this.auditEventRepository = auditEventRepository;
	}
	@ReadOperation
	public AuditEventsDescriptor events(@Nullable String principal, @Nullable OffsetDateTime after,
			@Nullable String type) {
		List<AuditEvent> events = this.auditEventRepository.find(principal, getInstant(after), type);
		return new AuditEventsDescriptor(events);
	}
	private Instant getInstant(OffsetDateTime offsetDateTime) {
		return (offsetDateTime != null) ? offsetDateTime.toInstant() : null;
	}
	/**
	 * Description of an application"s {@link AuditEvent audit events}.
	 */
	public static final class AuditEventsDescriptor implements OperationResponseBody {
		private final List<AuditEvent> events;
		private AuditEventsDescriptor(List<AuditEvent> events) {
			this.events = events;
		}
		public List<AuditEvent> getEvents() {
			return this.events;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.audit;
/*
package org.springframework.boot.actuate.audit.listener;
/**
public class AuditApplicationEvent extends ApplicationEvent {
	private final AuditEvent auditEvent;
	/**
	 * Create a new {@link AuditApplicationEvent} that wraps a newly created
	 * {@link AuditEvent}.
	 * @param principal the principal
	 * @param type the event type
	 * @param data the event data
	 * @see AuditEvent#AuditEvent(String, String, Map)
	 */
	public AuditApplicationEvent(String principal, String type, Map<String, Object> data) {
		this(new AuditEvent(principal, type, data));
	}
	/**
	 * Create a new {@link AuditApplicationEvent} that wraps a newly created
	 * {@link AuditEvent}.
	 * @param principal the principal
	 * @param type the event type
	 * @param data the event data
	 * @see AuditEvent#AuditEvent(String, String, String...)
	 */
	public AuditApplicationEvent(String principal, String type, String... data) {
		this(new AuditEvent(principal, type, data));
	}
	/**
	 * Create a new {@link AuditApplicationEvent} that wraps a newly created
	 * {@link AuditEvent}.
	 * @param timestamp the timestamp
	 * @param principal the principal
	 * @param type the event type
	 * @param data the event data
	 * @see AuditEvent#AuditEvent(Instant, String, String, Map)
	 */
	public AuditApplicationEvent(Instant timestamp, String principal, String type, Map<String, Object> data) {
		this(new AuditEvent(timestamp, principal, type, data));
	}
	/**
	 * Create a new {@link AuditApplicationEvent} that wraps the specified
	 * {@link AuditEvent}.
	 * @param auditEvent the source of this event
	 */
	public AuditApplicationEvent(AuditEvent auditEvent) {
		super(auditEvent);
		Assert.notNull(auditEvent, 'AuditEvent must not be null');
		this.auditEvent = auditEvent;
	}
	/**
	 * Get the audit event.
	 * @return the audit event
	 */
	public AuditEvent getAuditEvent() {
		return this.auditEvent;
	}
}
/*
package org.springframework.boot.actuate.audit.listener;
/**
public class AuditListener extends AbstractAuditListener {
	private static final Log logger = LogFactory.getLog(AuditListener.class);
	private final AuditEventRepository auditEventRepository;
	public AuditListener(AuditEventRepository auditEventRepository) {
		this.auditEventRepository = auditEventRepository;
	}
	@Override
	protected void onAuditEvent(AuditEvent event) {
		if (logger.isDebugEnabled()) {
			logger.debug(event);
		}
		this.auditEventRepository.add(event);
	}
}
/*
/**
package org.springframework.boot.actuate.audit.listener;
/*
package org.springframework.boot.actuate.audit.listener;
/**
public abstract class AbstractAuditListener implements ApplicationListener<AuditApplicationEvent> {
	@Override
	public void onApplicationEvent(AuditApplicationEvent event) {
		onAuditEvent(event.getAuditEvent());
	}
	protected abstract void onAuditEvent(AuditEvent event);
}
/*
package org.springframework.boot.actuate.availability;
/**
public class AvailabilityStateHealthIndicator extends AbstractHealthIndicator {
	private final ApplicationAvailability applicationAvailability;
	private final Class<? extends AvailabilityState> stateType;
	private final Map<AvailabilityState, Status> statusMappings = new HashMap<>();
	/**
	 * Create a new {@link AvailabilityStateHealthIndicator} instance.
	 * @param <S> the availability state type
	 * @param applicationAvailability the application availability
	 * @param stateType the availability state type
	 * @param statusMappings consumer used to set up the status mappings
	 */
	public <S extends AvailabilityState> AvailabilityStateHealthIndicator(
			ApplicationAvailability applicationAvailability, Class<S> stateType,
			Consumer<StatusMappings<S>> statusMappings) {
		Assert.notNull(applicationAvailability, 'ApplicationAvailability must not be null');
		Assert.notNull(stateType, 'StateType must not be null');
		Assert.notNull(statusMappings, 'StatusMappings must not be null');
		this.applicationAvailability = applicationAvailability;
		this.stateType = stateType;
		statusMappings.accept(this.statusMappings::put);
		assertAllEnumsMapped(stateType);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private <S extends AvailabilityState> void assertAllEnumsMapped(Class<S> stateType) {
		if (!this.statusMappings.containsKey(null) && Enum.class.isAssignableFrom(stateType)) {
			EnumSet elements = EnumSet.allOf((Class) stateType);
			for (Object element : elements) {
				Assert.isTrue(this.statusMappings.containsKey(element),
						() -> 'StatusMappings does not include ' + element);
			}
		}
	}
	@Override
	protected void doHealthCheck(Builder builder) throws Exception {
		AvailabilityState state = getState(this.applicationAvailability);
		Status status = this.statusMappings.get(state);
		if (status == null) {
			status = this.statusMappings.get(null);
		}
		Assert.state(status != null, () -> 'No mapping provided for ' + state);
		builder.status(status);
	}
	/**
	 * Return the current availability state. Subclasses can override this method if a
	 * different retrieval mechanism is needed.
	 * @param applicationAvailability the application availability
	 * @return the current availability state
	 */
	protected AvailabilityState getState(ApplicationAvailability applicationAvailability) {
		return applicationAvailability.getState(this.stateType);
	}
	/**
	 * Callback used to add status mappings.
	 *
	 * @param <S> the availability state type
	 */
	public interface StatusMappings<S extends AvailabilityState> {
		/**
		 * Add the status that should be used if no explicit mapping is defined.
		 * @param status the default status
		 */
		default void addDefaultStatus(Status status) {
			add(null, status);
		}
		/**
		 * Add a new status mapping .
		 * @param availabilityState the availability state
		 * @param status the mapped status
		 */
		void add(S availabilityState, Status status);
	}
}
/*
package org.springframework.boot.actuate.availability;
/**
public class LivenessStateHealthIndicator extends AvailabilityStateHealthIndicator {
	public LivenessStateHealthIndicator(ApplicationAvailability availability) {
		super(availability, LivenessState.class, (statusMappings) -> {
			statusMappings.add(LivenessState.CORRECT, Status.UP);
			statusMappings.add(LivenessState.BROKEN, Status.DOWN);
		});
	}
	@Override
	protected AvailabilityState getState(ApplicationAvailability applicationAvailability) {
		return applicationAvailability.getLivenessState();
	}
}
/*
/**
package org.springframework.boot.actuate.availability;
/*
package org.springframework.boot.actuate.availability;
/**
public class ReadinessStateHealthIndicator extends AvailabilityStateHealthIndicator {
	public ReadinessStateHealthIndicator(ApplicationAvailability availability) {
		super(availability, ReadinessState.class, (statusMappings) -> {
			statusMappings.add(ReadinessState.ACCEPTING_TRAFFIC, Status.UP);
			statusMappings.add(ReadinessState.REFUSING_TRAFFIC, Status.OUT_OF_SERVICE);
		});
	}
	@Override
	protected AvailabilityState getState(ApplicationAvailability applicationAvailability) {
		return applicationAvailability.getReadinessState();
	}
}
/*
package org.springframework.boot.actuate.mail;
/**
public class MailHealthIndicator extends AbstractHealthIndicator {
	private final JavaMailSenderImpl mailSender;
	public MailHealthIndicator(JavaMailSenderImpl mailSender) {
		super('Mail health check failed');
		this.mailSender = mailSender;
	}
	@Override
	protected void doHealthCheck(Builder builder) throws Exception {
		String host = this.mailSender.getHost();
		int port = this.mailSender.getPort();
		StringBuilder location = new StringBuilder((host != null) ? host : '');
		if (port != JavaMailSenderImpl.DEFAULT_PORT) {
			location.append(':').append(port);
		}
		if (StringUtils.hasLength(location)) {
			builder.withDetail('location', location.toString());
		}
		this.mailSender.testConnection();
		builder.up();
	}
}
/*
/**
package org.springframework.boot.actuate.mail;
/*
package org.springframework.boot.actuate.security;
/**
public abstract class AbstractAuthorizationAuditListener
		implements ApplicationListener<AuthorizationEvent>, ApplicationEventPublisherAware {
	private ApplicationEventPublisher publisher;
	@Override
	public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
		this.publisher = publisher;
	}
	protected ApplicationEventPublisher getPublisher() {
		return this.publisher;
	}
	protected void publish(AuditEvent event) {
		if (getPublisher() != null) {
			getPublisher().publishEvent(new AuditApplicationEvent(event));
		}
	}
}
/*
package org.springframework.boot.actuate.security;
/**
public abstract class AbstractAuthenticationAuditListener
		implements ApplicationListener<AbstractAuthenticationEvent>, ApplicationEventPublisherAware {
	private ApplicationEventPublisher publisher;
	@Override
	public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
		this.publisher = publisher;
	}
	protected ApplicationEventPublisher getPublisher() {
		return this.publisher;
	}
	protected void publish(AuditEvent event) {
		if (getPublisher() != null) {
			getPublisher().publishEvent(new AuditApplicationEvent(event));
		}
	}
}
/*
package org.springframework.boot.actuate.security;
/**
public class AuthenticationAuditListener extends AbstractAuthenticationAuditListener {
	/**
	 * Authentication success event type.
	 */
	public static final String AUTHENTICATION_SUCCESS = 'AUTHENTICATION_SUCCESS';
	/**
	 * Authentication failure event type.
	 */
	public static final String AUTHENTICATION_FAILURE = 'AUTHENTICATION_FAILURE';
	/**
	 * Authentication switch event type.
	 */
	public static final String AUTHENTICATION_SWITCH = 'AUTHENTICATION_SWITCH';
	/**
	 * Logout success event type.
	 *
	 * @since 3.4.0
	 */
	public static final String LOGOUT_SUCCESS = 'LOGOUT_SUCCESS';
	private static final String WEB_LISTENER_CHECK_CLASS = 'org.springframework.security.web.authentication.switchuser.AuthenticationSwitchUserEvent';
	private final WebAuditListener webListener = maybeCreateWebListener();
	private static WebAuditListener maybeCreateWebListener() {
		if (ClassUtils.isPresent(WEB_LISTENER_CHECK_CLASS, null)) {
			return new WebAuditListener();
		}
		return null;
	}
	@Override
	public void onApplicationEvent(AbstractAuthenticationEvent event) {
		if (event instanceof AbstractAuthenticationFailureEvent failureEvent) {
			onAuthenticationFailureEvent(failureEvent);
		}
		else if (this.webListener != null && this.webListener.accepts(event)) {
			this.webListener.process(this, event);
		}
		else if (event instanceof AuthenticationSuccessEvent successEvent) {
			onAuthenticationSuccessEvent(successEvent);
		}
		else if (event instanceof LogoutSuccessEvent logoutSuccessEvent) {
			onLogoutSuccessEvent(logoutSuccessEvent);
		}
	}
	private void onAuthenticationFailureEvent(AbstractAuthenticationFailureEvent event) {
		Map<String, Object> data = new LinkedHashMap<>();
		data.put('type', event.getException().getClass().getName());
		data.put('message', event.getException().getMessage());
		if (event.getAuthentication().getDetails() != null) {
			data.put('details', event.getAuthentication().getDetails());
		}
		publish(new AuditEvent(event.getAuthentication().getName(), AUTHENTICATION_FAILURE, data));
	}
	private void onAuthenticationSuccessEvent(AuthenticationSuccessEvent event) {
		Map<String, Object> data = new LinkedHashMap<>();
		if (event.getAuthentication().getDetails() != null) {
			data.put('details', event.getAuthentication().getDetails());
		}
		publish(new AuditEvent(event.getAuthentication().getName(), AUTHENTICATION_SUCCESS, data));
	}
	private void onLogoutSuccessEvent(LogoutSuccessEvent event) {
		Map<String, Object> data = new LinkedHashMap<>();
		if (event.getAuthentication().getDetails() != null) {
			data.put('details', event.getAuthentication().getDetails());
		}
		publish(new AuditEvent(event.getAuthentication().getName(), LOGOUT_SUCCESS, data));
	}
	private static final class WebAuditListener {
		void process(AuthenticationAuditListener listener, AbstractAuthenticationEvent input) {
			if (listener != null) {
				AuthenticationSwitchUserEvent event = (AuthenticationSwitchUserEvent) input;
				Map<String, Object> data = new HashMap<>();
				if (event.getAuthentication().getDetails() != null) {
					data.put('details', event.getAuthentication().getDetails());
				}
				if (event.getTargetUser() != null) {
					data.put('target', event.getTargetUser().getUsername());
				}
				listener.publish(new AuditEvent(event.getAuthentication().getName(), AUTHENTICATION_SWITCH, data));
			}
		}
		boolean accepts(AbstractAuthenticationEvent event) {
			return event instanceof AuthenticationSwitchUserEvent;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.security;
/*
package org.springframework.boot.actuate.security;
/**
public class AuthorizationAuditListener extends AbstractAuthorizationAuditListener {
	/**
	 * Authorization failure event type.
	 */
	public static final String AUTHORIZATION_FAILURE = 'AUTHORIZATION_FAILURE';
	@Override
	public void onApplicationEvent(AuthorizationEvent event) {
		if (event instanceof AuthorizationDeniedEvent<?> authorizationDeniedEvent) {
			onAuthorizationDeniedEvent(authorizationDeniedEvent);
		}
	}
	private void onAuthorizationDeniedEvent(AuthorizationDeniedEvent<?> event) {
		String name = getName(event.getAuthentication());
		Map<String, Object> data = new LinkedHashMap<>();
		Object details = getDetails(event.getAuthentication());
		if (details != null) {
			data.put('details', details);
		}
		publish(new AuditEvent(name, AUTHORIZATION_FAILURE, data));
	}
	private String getName(Supplier<Authentication> authentication) {
		try {
			return authentication.get().getName();
		}
		catch (Exception ex) {
			return '<unknown>';
		}
	}
	private Object getDetails(Supplier<Authentication> authentication) {
		try {
			return authentication.get().getDetails();
		}
		catch (Exception ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.couchbase;
/**
public class CouchbaseReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
	private final Cluster cluster;
	/**
	 * Create a new {@link CouchbaseReactiveHealthIndicator} instance.
	 * @param cluster the Couchbase cluster
	 */
	public CouchbaseReactiveHealthIndicator(Cluster cluster) {
		super('Couchbase health check failed');
		this.cluster = cluster;
	}
	@Override
	protected Mono<Health> doHealthCheck(Health.Builder builder) {
		return this.cluster.reactive().diagnostics().map((diagnostics) -> {
			new CouchbaseHealth(diagnostics).applyTo(builder);
			return builder.build();
		});
	}
}
/*
package org.springframework.boot.actuate.couchbase;
/**
class CouchbaseHealth {
	private final DiagnosticsResult diagnostics;
	CouchbaseHealth(DiagnosticsResult diagnostics) {
		this.diagnostics = diagnostics;
	}
	void applyTo(Builder builder) {
		builder = isCouchbaseUp(this.diagnostics) ? builder.up() : builder.down();
		builder.withDetail('sdk', this.diagnostics.sdk());
		builder.withDetail('endpoints',
				this.diagnostics.endpoints()
					.values()
					.stream()
					.flatMap(Collection::stream)
					.map(this::describe)
					.toList());
	}
	private boolean isCouchbaseUp(DiagnosticsResult diagnostics) {
		return diagnostics.state() == ClusterState.ONLINE;
	}
	private Map<String, Object> describe(EndpointDiagnostics endpointHealth) {
		Map<String, Object> map = new HashMap<>();
		map.put('id', endpointHealth.id());
		map.put('lastActivity', endpointHealth.lastActivity());
		map.put('local', endpointHealth.local());
		map.put('remote', endpointHealth.remote());
		map.put('state', endpointHealth.state());
		map.put('type', endpointHealth.type());
		return map;
	}
}
/*
/**
package org.springframework.boot.actuate.couchbase;
/*
package org.springframework.boot.actuate.couchbase;
/**
public class CouchbaseHealthIndicator extends AbstractHealthIndicator {
	private final Cluster cluster;
	/**
	 * Create an indicator with the specified {@link Cluster}.
	 * @param cluster the Couchbase Cluster
	 * @since 2.0.6
	 */
	public CouchbaseHealthIndicator(Cluster cluster) {
		super('Couchbase health check failed');
		Assert.notNull(cluster, 'Cluster must not be null');
		this.cluster = cluster;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		DiagnosticsResult diagnostics = this.cluster.diagnostics();
		new CouchbaseHealth(diagnostics).applyTo(builder);
	}
}
/*
package org.springframework.boot.actuate.session;
/**
@Endpoint(id = 'sessions')
public class SessionsEndpoint {
	private final SessionRepository<? extends Session> sessionRepository;
	private final FindByIndexNameSessionRepository<? extends Session> indexedSessionRepository;
	/**
	 * Create a new {@link SessionsEndpoint} instance.
	 * @param sessionRepository the session repository
	 * @deprecated since 3.3.0 for removal in 3.5.0 in favor of
	 * {@link #SessionsEndpoint(SessionRepository, FindByIndexNameSessionRepository)}
	 */
	@Deprecated(since = '3.3.0', forRemoval = true)
	public SessionsEndpoint(FindByIndexNameSessionRepository<? extends Session> sessionRepository) {
		this(sessionRepository, sessionRepository);
	}
	/**
	 * Create a new {@link SessionsEndpoint} instance.
	 * @param sessionRepository the session repository
	 * @param indexedSessionRepository the indexed session repository
	 * @since 3.3.0
	 */
	public SessionsEndpoint(SessionRepository<? extends Session> sessionRepository,
			FindByIndexNameSessionRepository<? extends Session> indexedSessionRepository) {
		Assert.notNull(sessionRepository, 'SessionRepository must not be null');
		this.sessionRepository = sessionRepository;
		this.indexedSessionRepository = indexedSessionRepository;
	}
	@ReadOperation
	public SessionsDescriptor sessionsForUsername(String username) {
		if (this.indexedSessionRepository == null) {
			return null;
		}
		Map<String, ? extends Session> sessions = this.indexedSessionRepository.findByPrincipalName(username);
		return new SessionsDescriptor(sessions);
	}
	@ReadOperation
	public SessionDescriptor getSession(@Selector String sessionId) {
		Session session = this.sessionRepository.findById(sessionId);
		if (session == null) {
			return null;
		}
		return new SessionDescriptor(session);
	}
	@DeleteOperation
	public void deleteSession(@Selector String sessionId) {
		this.sessionRepository.deleteById(sessionId);
	}
}
/*
package org.springframework.boot.actuate.session;
/**
public final class SessionsDescriptor implements OperationResponseBody {
	private final List<SessionDescriptor> sessions;
	public SessionsDescriptor(Map<String, ? extends Session> sessions) {
		this.sessions = sessions.values().stream().map(SessionDescriptor::new).toList();
	}
	public List<SessionDescriptor> getSessions() {
		return this.sessions;
	}
	/**
	 * A description of user"s {@link Session session} exposed by {@code sessions}
	 * endpoint. Primarily intended for serialization to JSON.
	 */
	public static final class SessionDescriptor {
		private final String id;
		private final Set<String> attributeNames;
		private final Instant creationTime;
		private final Instant lastAccessedTime;
		private final long maxInactiveInterval;
		private final boolean expired;
		SessionDescriptor(Session session) {
			this.id = session.getId();
			this.attributeNames = session.getAttributeNames();
			this.creationTime = session.getCreationTime();
			this.lastAccessedTime = session.getLastAccessedTime();
			this.maxInactiveInterval = session.getMaxInactiveInterval().getSeconds();
			this.expired = session.isExpired();
		}
		public String getId() {
			return this.id;
		}
		public Set<String> getAttributeNames() {
			return this.attributeNames;
		}
		public Instant getCreationTime() {
			return this.creationTime;
		}
		public Instant getLastAccessedTime() {
			return this.lastAccessedTime;
		}
		public long getMaxInactiveInterval() {
			return this.maxInactiveInterval;
		}
		public boolean isExpired() {
			return this.expired;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.session;
/*
package org.springframework.boot.actuate.session;
/**
@Endpoint(id = 'sessions')
public class ReactiveSessionsEndpoint {
	private final ReactiveSessionRepository<? extends Session> sessionRepository;
	private final ReactiveFindByIndexNameSessionRepository<? extends Session> indexedSessionRepository;
	/**
	 * Create a new {@link ReactiveSessionsEndpoint} instance.
	 * @param sessionRepository the session repository
	 * @param indexedSessionRepository the indexed session repository
	 */
	public ReactiveSessionsEndpoint(ReactiveSessionRepository<? extends Session> sessionRepository,
			ReactiveFindByIndexNameSessionRepository<? extends Session> indexedSessionRepository) {
		Assert.notNull(sessionRepository, 'ReactiveSessionRepository must not be null');
		this.sessionRepository = sessionRepository;
		this.indexedSessionRepository = indexedSessionRepository;
	}
	@ReadOperation
	public Mono<SessionsDescriptor> sessionsForUsername(String username) {
		if (this.indexedSessionRepository == null) {
			return Mono.empty();
		}
		return this.indexedSessionRepository.findByPrincipalName(username).map(SessionsDescriptor::new);
	}
	@ReadOperation
	public Mono<SessionDescriptor> getSession(@Selector String sessionId) {
		return this.sessionRepository.findById(sessionId).map(SessionDescriptor::new);
	}
	@DeleteOperation
	public Mono<Void> deleteSession(@Selector String sessionId) {
		return this.sessionRepository.deleteById(sessionId);
	}
}
/*
/**
package org.springframework.boot.actuate.data.elasticsearch;
/*
package org.springframework.boot.actuate.data.elasticsearch;
/**
public class ElasticsearchReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
	private final ReactiveElasticsearchClient client;
	public ElasticsearchReactiveHealthIndicator(ReactiveElasticsearchClient client) {
		super('Elasticsearch health check failed');
		this.client = client;
	}
	@Override
	protected Mono<Health> doHealthCheck(Health.Builder builder) {
		return this.client.cluster().health((b) -> b).map((response) -> processResponse(builder, response));
	}
	private Health processResponse(Health.Builder builder, HealthResponse response) {
		if (!response.timedOut()) {
			HealthStatus status = response.status();
			builder.status((HealthStatus.Red == status) ? Status.OUT_OF_SERVICE : Status.UP);
			builder.withDetail('cluster_name', response.clusterName());
			builder.withDetail('status', response.status().jsonValue());
			builder.withDetail('timed_out', response.timedOut());
			builder.withDetail('number_of_nodes', response.numberOfNodes());
			builder.withDetail('number_of_data_nodes', response.numberOfDataNodes());
			builder.withDetail('active_primary_shards', response.activePrimaryShards());
			builder.withDetail('active_shards', response.activeShards());
			builder.withDetail('relocating_shards', response.relocatingShards());
			builder.withDetail('initializing_shards', response.initializingShards());
			builder.withDetail('unassigned_shards', response.unassignedShards());
			builder.withDetail('delayed_unassigned_shards', response.delayedUnassignedShards());
			builder.withDetail('number_of_pending_tasks', response.numberOfPendingTasks());
			builder.withDetail('number_of_in_flight_fetch', response.numberOfInFlightFetch());
			builder.withDetail('task_max_waiting_in_queue_millis', response.taskMaxWaitingInQueueMillis());
			builder.withDetail('active_shards_percent_as_number',
					Double.parseDouble(response.activeShardsPercentAsNumber()));
			return builder.build();
		}
		return builder.down().build();
	}
}
/*
package org.springframework.boot.actuate.data.redis;
/**
final class RedisHealth {
	private RedisHealth() {
	}
	static Builder up(Health.Builder builder, Properties info) {
		builder.withDetail('version', info.getProperty('redis_version'));
		return builder.up();
	}
	static Builder fromClusterInfo(Health.Builder builder, ClusterInfo clusterInfo) {
		builder.withDetail('cluster_size', clusterInfo.getClusterSize());
		builder.withDetail('slots_up', clusterInfo.getSlotsOk());
		builder.withDetail('slots_fail', clusterInfo.getSlotsFail());
		if ('fail'.equalsIgnoreCase(clusterInfo.getState())) {
			return builder.down();
		}
		else {
			return builder.up();
		}
	}
}
/*
package org.springframework.boot.actuate.data.redis;
/**
public class RedisReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
	private final ReactiveRedisConnectionFactory connectionFactory;
	public RedisReactiveHealthIndicator(ReactiveRedisConnectionFactory connectionFactory) {
		super('Redis health check failed');
		this.connectionFactory = connectionFactory;
	}
	@Override
	protected Mono<Health> doHealthCheck(Health.Builder builder) {
		return getConnection().flatMap((connection) -> doHealthCheck(builder, connection));
	}
	private Mono<ReactiveRedisConnection> getConnection() {
		return Mono.fromSupplier(this.connectionFactory::getReactiveConnection)
			.subscribeOn(Schedulers.boundedElastic());
	}
	private Mono<Health> doHealthCheck(Health.Builder builder, ReactiveRedisConnection connection) {
		return getHealth(builder, connection).onErrorResume((ex) -> Mono.just(builder.down(ex).build()))
			.flatMap((health) -> connection.closeLater().thenReturn(health));
	}
	private Mono<Health> getHealth(Health.Builder builder, ReactiveRedisConnection connection) {
		if (connection instanceof ReactiveRedisClusterConnection clusterConnection) {
			return clusterConnection.clusterGetClusterInfo().map((info) -> fromClusterInfo(builder, info));
		}
		return connection.serverCommands().info('server').map((info) -> up(builder, info));
	}
	private Health up(Health.Builder builder, Properties info) {
		return RedisHealth.up(builder, info).build();
	}
	private Health fromClusterInfo(Health.Builder builder, ClusterInfo clusterInfo) {
		return RedisHealth.fromClusterInfo(builder, clusterInfo).build();
	}
}
/*
package org.springframework.boot.actuate.data.redis;
/**
public class RedisHealthIndicator extends AbstractHealthIndicator {
	private final RedisConnectionFactory redisConnectionFactory;
	public RedisHealthIndicator(RedisConnectionFactory connectionFactory) {
		super('Redis health check failed');
		Assert.notNull(connectionFactory, 'ConnectionFactory must not be null');
		this.redisConnectionFactory = connectionFactory;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		RedisConnection connection = RedisConnectionUtils.getConnection(this.redisConnectionFactory);
		try {
			doHealthCheck(builder, connection);
		}
		finally {
			RedisConnectionUtils.releaseConnection(connection, this.redisConnectionFactory);
		}
	}
	private void doHealthCheck(Health.Builder builder, RedisConnection connection) {
		if (connection instanceof RedisClusterConnection clusterConnection) {
			RedisHealth.fromClusterInfo(builder, clusterConnection.clusterGetClusterInfo());
		}
		else {
			RedisHealth.up(builder, connection.serverCommands().info());
		}
	}
}
/*
/**
package org.springframework.boot.actuate.data.redis;
/*
/**
package org.springframework.boot.actuate.data;
/*
package org.springframework.boot.actuate.data.mongo;
/**
public class MongoHealthIndicator extends AbstractHealthIndicator {
	private final MongoTemplate mongoTemplate;
	public MongoHealthIndicator(MongoTemplate mongoTemplate) {
		super('MongoDB health check failed');
		Assert.notNull(mongoTemplate, 'MongoTemplate must not be null');
		this.mongoTemplate = mongoTemplate;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		Document result = this.mongoTemplate.executeCommand('{ hello: 1 }');
		builder.up().withDetail('maxWireVersion', result.getInteger('maxWireVersion'));
	}
}
/*
package org.springframework.boot.actuate.data.mongo;
/**
public class MongoReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
	private final ReactiveMongoTemplate reactiveMongoTemplate;
	public MongoReactiveHealthIndicator(ReactiveMongoTemplate reactiveMongoTemplate) {
		super('Mongo health check failed');
		Assert.notNull(reactiveMongoTemplate, 'ReactiveMongoTemplate must not be null');
		this.reactiveMongoTemplate = reactiveMongoTemplate;
	}
	@Override
	protected Mono<Health> doHealthCheck(Health.Builder builder) {
		Mono<Document> buildInfo = this.reactiveMongoTemplate.executeCommand('{ hello: 1 }');
		return buildInfo.map((document) -> up(builder, document));
	}
	private Health up(Health.Builder builder, Document document) {
		return builder.up().withDetail('maxWireVersion', document.getInteger('maxWireVersion')).build();
	}
}
/*
/**
package org.springframework.boot.actuate.data.mongo;
/*
/**
package org.springframework.boot.actuate.logging;
/*
package org.springframework.boot.actuate.logging;
/**
@WebEndpoint(id = 'logfile')
public class LogFileWebEndpoint {
	private static final Log logger = LogFactory.getLog(LogFileWebEndpoint.class);
	private final LogFile logFile;
	private final File externalFile;
	public LogFileWebEndpoint(LogFile logFile, File externalFile) {
		this.logFile = logFile;
		this.externalFile = externalFile;
	}
	@ReadOperation(produces = 'text/plain; charset=UTF-8')
	public Resource logFile() {
		Resource logFileResource = getLogFileResource();
		if (logFileResource == null || !logFileResource.isReadable()) {
			return null;
		}
		return logFileResource;
	}
	private Resource getLogFileResource() {
		if (this.externalFile != null) {
			return new FileSystemResource(this.externalFile);
		}
		if (this.logFile == null) {
			logger.debug('Missing "logging.file.name" or "logging.file.path" properties');
			return null;
		}
		return new FileSystemResource(this.logFile.toString());
	}
}
/*
package org.springframework.boot.actuate.logging;
/**
@Endpoint(id = 'loggers')
@RegisterReflectionForBinding({ GroupLoggerLevelsDescriptor.class, SingleLoggerLevelsDescriptor.class })
public class LoggersEndpoint {
	private final LoggingSystem loggingSystem;
	private final LoggerGroups loggerGroups;
	/**
	 * Create a new {@link LoggersEndpoint} instance.
	 * @param loggingSystem the logging system to expose
	 * @param loggerGroups the logger group to expose
	 */
	public LoggersEndpoint(LoggingSystem loggingSystem, LoggerGroups loggerGroups) {
		Assert.notNull(loggingSystem, 'LoggingSystem must not be null');
		Assert.notNull(loggerGroups, 'LoggerGroups must not be null');
		this.loggingSystem = loggingSystem;
		this.loggerGroups = loggerGroups;
	}
	@ReadOperation
	public LoggersDescriptor loggers() {
		Collection<LoggerConfiguration> configurations = this.loggingSystem.getLoggerConfigurations();
		if (configurations == null) {
			return LoggersDescriptor.NONE;
		}
		return new LoggersDescriptor(getLevels(), getLoggers(configurations), getGroups());
	}
	private Map<String, GroupLoggerLevelsDescriptor> getGroups() {
		Map<String, GroupLoggerLevelsDescriptor> groups = new LinkedHashMap<>();
		this.loggerGroups.forEach((group) -> groups.put(group.getName(),
				new GroupLoggerLevelsDescriptor(group.getConfiguredLevel(), group.getMembers())));
		return groups;
	}
	@ReadOperation
	public LoggerLevelsDescriptor loggerLevels(@Selector String name) {
		Assert.notNull(name, 'Name must not be null');
		LoggerGroup group = this.loggerGroups.get(name);
		if (group != null) {
			return new GroupLoggerLevelsDescriptor(group.getConfiguredLevel(), group.getMembers());
		}
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration(name);
		return (configuration != null) ? new SingleLoggerLevelsDescriptor(configuration) : null;
	}
	@WriteOperation
	public void configureLogLevel(@Selector String name, @Nullable LogLevel configuredLevel) {
		Assert.notNull(name, 'Name must not be empty');
		LoggerGroup group = this.loggerGroups.get(name);
		if (group != null && group.hasMembers()) {
			group.configureLogLevel(configuredLevel, this.loggingSystem::setLogLevel);
			return;
		}
		this.loggingSystem.setLogLevel(name, configuredLevel);
	}
	private NavigableSet<LogLevel> getLevels() {
		Set<LogLevel> levels = this.loggingSystem.getSupportedLogLevels();
		return new TreeSet<>(levels).descendingSet();
	}
	private Map<String, LoggerLevelsDescriptor> getLoggers(Collection<LoggerConfiguration> configurations) {
		Map<String, LoggerLevelsDescriptor> loggers = new LinkedHashMap<>(configurations.size());
		for (LoggerConfiguration configuration : configurations) {
			loggers.put(configuration.getName(), new SingleLoggerLevelsDescriptor(configuration));
		}
		return loggers;
	}
	/**
	 * Description of loggers.
	 */
	public static class LoggersDescriptor implements OperationResponseBody {
		/**
		 * Empty description.
		 */
		public static final LoggersDescriptor NONE = new LoggersDescriptor(null, null, null);
		private final NavigableSet<LogLevel> levels;
		private final Map<String, LoggerLevelsDescriptor> loggers;
		private final Map<String, GroupLoggerLevelsDescriptor> groups;
		public LoggersDescriptor(NavigableSet<LogLevel> levels, Map<String, LoggerLevelsDescriptor> loggers,
				Map<String, GroupLoggerLevelsDescriptor> groups) {
			this.levels = levels;
			this.loggers = loggers;
			this.groups = groups;
		}
		public NavigableSet<LogLevel> getLevels() {
			return this.levels;
		}
		public Map<String, LoggerLevelsDescriptor> getLoggers() {
			return this.loggers;
		}
		public Map<String, GroupLoggerLevelsDescriptor> getGroups() {
			return this.groups;
		}
	}
	/**
	 * Description of levels configured for a given logger.
	 */
	public static class LoggerLevelsDescriptor implements OperationResponseBody {
		private final String configuredLevel;
		public LoggerLevelsDescriptor(LogLevel configuredLevel) {
			this.configuredLevel = (configuredLevel != null) ? configuredLevel.name() : null;
		}
		LoggerLevelsDescriptor(LevelConfiguration directConfiguration) {
			this.configuredLevel = (directConfiguration != null) ? directConfiguration.getName() : null;
		}
		protected final String getName(LogLevel level) {
			return (level != null) ? level.name() : null;
		}
		public String getConfiguredLevel() {
			return this.configuredLevel;
		}
	}
	/**
	 * Description of levels configured for a given group logger.
	 */
	public static class GroupLoggerLevelsDescriptor extends LoggerLevelsDescriptor {
		private final List<String> members;
		public GroupLoggerLevelsDescriptor(LogLevel configuredLevel, List<String> members) {
			super(configuredLevel);
			this.members = members;
		}
		public List<String> getMembers() {
			return this.members;
		}
	}
	/**
	 * Description of levels configured for a given single logger.
	 */
	public static class SingleLoggerLevelsDescriptor extends LoggerLevelsDescriptor {
		private final String effectiveLevel;
		public SingleLoggerLevelsDescriptor(LoggerConfiguration configuration) {
			super(configuration.getLevelConfiguration(ConfigurationScope.DIRECT));
			this.effectiveLevel = configuration.getLevelConfiguration().getName();
		}
		public String getEffectiveLevel() {
			return this.effectiveLevel;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.hazelcast;
/*
package org.springframework.boot.actuate.hazelcast;
/**
public class HazelcastHealthIndicator extends AbstractHealthIndicator {
	private final HazelcastInstance hazelcast;
	public HazelcastHealthIndicator(HazelcastInstance hazelcast) {
		super('Hazelcast health check failed');
		Assert.notNull(hazelcast, 'HazelcastInstance must not be null');
		this.hazelcast = hazelcast;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) {
		this.hazelcast.executeTransaction((context) -> {
			String uuid = this.hazelcast.getLocalEndpoint().getUuid().toString();
			builder.up().withDetail('name', this.hazelcast.getName()).withDetail('uuid', uuid);
			return null;
		});
	}
}
/*
package org.springframework.boot.actuate.info;
/**
public class SimpleInfoContributor implements InfoContributor {
	private final String prefix;
	private final Object detail;
	public SimpleInfoContributor(String prefix, Object detail) {
		Assert.notNull(prefix, 'Prefix must not be null');
		this.prefix = prefix;
		this.detail = detail;
	}
	@Override
	public void contribute(Info.Builder builder) {
		if (this.detail != null) {
			builder.withDetail(this.prefix, this.detail);
		}
	}
}
/*
package org.springframework.boot.actuate.info;
/**
public class EnvironmentInfoContributor implements InfoContributor {
	private static final Bindable<Map<String, Object>> STRING_OBJECT_MAP = Bindable.mapOf(String.class, Object.class);
	private final ConfigurableEnvironment environment;
	public EnvironmentInfoContributor(ConfigurableEnvironment environment) {
		this.environment = environment;
	}
	@Override
	public void contribute(Info.Builder builder) {
		Binder binder = Binder.get(this.environment);
		binder.bind('info', STRING_OBJECT_MAP).ifBound(builder::withDetails);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@ImportRuntimeHints(ProcessInfoContributorRuntimeHints.class)
public class ProcessInfoContributor implements InfoContributor {
	private final ProcessInfo processInfo;
	public ProcessInfoContributor() {
		this.processInfo = new ProcessInfo();
	}
	@Override
	public void contribute(Builder builder) {
		builder.withDetail('process', this.processInfo);
	}
	static class ProcessInfoContributorRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), ProcessInfo.class);
		}
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@FunctionalInterface
public interface InfoContributor {
	/**
	 * Contributes additional details using the specified {@link Info.Builder Builder}.
	 * @param builder the builder to use
	 */
	void contribute(Info.Builder builder);
}
/*
package org.springframework.boot.actuate.info;
/**
@ImportRuntimeHints(BuildInfoContributorRuntimeHints.class)
public class BuildInfoContributor extends InfoPropertiesInfoContributor<BuildProperties> {
	public BuildInfoContributor(BuildProperties properties) {
		super(properties, Mode.FULL);
	}
	@Override
	public void contribute(Info.Builder builder) {
		builder.withDetail('build', generateContent());
	}
	@Override
	protected PropertySource<?> toSimplePropertySource() {
		Properties props = new Properties();
		copyIfSet(props, 'group');
		copyIfSet(props, 'artifact');
		copyIfSet(props, 'name');
		copyIfSet(props, 'version');
		copyIfSet(props, 'time');
		return new PropertiesPropertySource('build', props);
	}
	@Override
	protected void postProcessContent(Map<String, Object> content) {
		replaceValue(content, 'time', getProperties().getTime());
	}
	static class BuildInfoContributorRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), BuildProperties.class);
		}
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@Endpoint(id = 'info')
public class InfoEndpoint {
	private final List<InfoContributor> infoContributors;
	/**
	 * Create a new {@link InfoEndpoint} instance.
	 * @param infoContributors the info contributors to use
	 */
	public InfoEndpoint(List<InfoContributor> infoContributors) {
		Assert.notNull(infoContributors, 'Info contributors must not be null');
		this.infoContributors = infoContributors;
	}
	@ReadOperation
	public Map<String, Object> info() {
		Info.Builder builder = new Info.Builder();
		for (InfoContributor contributor : this.infoContributors) {
			contributor.contribute(builder);
		}
		return OperationResponseBody.of(builder.build().getDetails());
	}
}
/*
package org.springframework.boot.actuate.info;
/**
public class MapInfoContributor implements InfoContributor {
	private final Map<String, Object> info;
	public MapInfoContributor(Map<String, Object> info) {
		this.info = new LinkedHashMap<>(info);
	}
	@Override
	public void contribute(Info.Builder builder) {
		builder.withDetails(this.info);
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@JsonInclude(Include.NON_EMPTY)
public final class Info {
	private final Map<String, Object> details;
	private Info(Builder builder) {
		Map<String, Object> content = new LinkedHashMap<>(builder.content);
		this.details = Collections.unmodifiableMap(content);
	}
	/**
	 * Return the content.
	 * @return the details of the info or an empty map.
	 */
	@JsonAnyGetter
	public Map<String, Object> getDetails() {
		return this.details;
	}
	public Object get(String id) {
		return this.details.get(id);
	}
	@SuppressWarnings('unchecked')
	public <T> T get(String id, Class<T> type) {
		Object value = get(id);
		if (value != null && type != null && !type.isInstance(value)) {
			throw new IllegalStateException('Info entry is not of required type [' + type.getName() + ']: ' + value);
		}
		return (T) value;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj instanceof Info other) {
			return this.details.equals(other.details);
		}
		return false;
	}
	@Override
	public int hashCode() {
		return this.details.hashCode();
	}
	@Override
	public String toString() {
		return getDetails().toString();
	}
	/**
	 * Builder for creating immutable {@link Info} instances.
	 */
	public static class Builder {
		private final Map<String, Object> content;
		public Builder() {
			this.content = new LinkedHashMap<>();
		}
		/**
		 * Record detail using given {@code key} and {@code value}.
		 * @param key the detail key
		 * @param value the detail value
		 * @return this {@link Builder} instance
		 */
		public Builder withDetail(String key, Object value) {
			this.content.put(key, value);
			return this;
		}
		/**
		 * Record several details.
		 * @param details the details
		 * @return this {@link Builder} instance
		 * @see #withDetail(String, Object)
		 */
		public Builder withDetails(Map<String, Object> details) {
			this.content.putAll(details);
			return this;
		}
		/**
		 * Create a new {@link Info} instance based on the state of this builder.
		 * @return a new {@link Info} instance
		 */
		public Info build() {
			return new Info(this);
		}
	}
}
/*
package org.springframework.boot.actuate.info;
/**
public abstract class InfoPropertiesInfoContributor<T extends InfoProperties> implements InfoContributor {
	private static final Bindable<Map<String, Object>> STRING_OBJECT_MAP = Bindable.mapOf(String.class, Object.class);
	private final T properties;
	private final Mode mode;
	protected InfoPropertiesInfoContributor(T properties, Mode mode) {
		this.properties = properties;
		this.mode = mode;
	}
	/**
	 * Return the properties that this instance manages.
	 * @return the info properties
	 */
	protected final T getProperties() {
		return this.properties;
	}
	/**
	 * Return the mode that should be used to expose the content.
	 * @return the mode
	 */
	protected final Mode getMode() {
		return this.mode;
	}
	/**
	 * Return a {@link PropertySource} for the {@link Mode#SIMPLE SIMPLE} mode.
	 * @return the property source for the simple model
	 * @see #toPropertySource()
	 */
	protected abstract PropertySource<?> toSimplePropertySource();
	/**
	 * Extract the content to contribute to the info endpoint.
	 * @return the content to expose
	 * @see #extractContent(PropertySource)
	 * @see #postProcessContent(Map)
	 */
	protected Map<String, Object> generateContent() {
		Map<String, Object> content = extractContent(toPropertySource());
		postProcessContent(content);
		return content;
	}
	/**
	 * Extract the raw content based on the specified {@link PropertySource}.
	 * @param propertySource the property source to use
	 * @return the raw content
	 */
	protected Map<String, Object> extractContent(PropertySource<?> propertySource) {
		return new Binder(ConfigurationPropertySources.from(propertySource)).bind('', STRING_OBJECT_MAP)
			.orElseGet(LinkedHashMap::new);
	}
	/**
	 * Post-process the content to expose. Elements can be added, changed or removed.
	 * @param content the content to expose
	 */
	protected void postProcessContent(Map<String, Object> content) {
	}
	/**
	 * Return the {@link PropertySource} to use based on the chosen {@link Mode}.
	 * @return the property source
	 */
	protected PropertySource<?> toPropertySource() {
		if (this.mode.equals(Mode.FULL)) {
			return this.properties.toPropertySource();
		}
		return toSimplePropertySource();
	}
	/**
	 * Copy the specified key to the target {@link Properties} if it is set.
	 * @param target the target properties to update
	 * @param key the key
	 */
	protected void copyIfSet(Properties target, String key) {
		String value = this.properties.get(key);
		if (StringUtils.hasText(value)) {
			target.put(key, value);
		}
	}
	/**
	 * Replace the {@code value} for the specified key if the value is not {@code null}.
	 * @param content the content to expose
	 * @param key the property to replace
	 * @param value the new value
	 */
	protected void replaceValue(Map<String, Object> content, String key, Object value) {
		if (content.containsKey(key) && value != null) {
			content.put(key, value);
		}
	}
	/**
	 * Return the nested map with the specified key or empty map if the specified map
	 * contains no mapping for the key.
	 * @param map the content
	 * @param key the key of a nested map
	 * @return the nested map
	 */
	@SuppressWarnings('unchecked')
	protected Map<String, Object> getNestedMap(Map<String, Object> map, String key) {
		Object value = map.get(key);
		if (value == null) {
			return Collections.emptyMap();
		}
		return (Map<String, Object>) value;
	}
	/**
	 * Defines how properties should be exposed.
	 */
	public enum Mode {
		/**
		 * Expose all available data, including custom properties.
		 */
		FULL,
		/**
		 * Expose a pre-defined set of core settings only.
		 */
		SIMPLE
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@ImportRuntimeHints(SslInfoContributorRuntimeHints.class)
public class SslInfoContributor implements InfoContributor {
	private final SslInfo sslInfo;
	public SslInfoContributor(SslInfo sslInfo) {
		this.sslInfo = sslInfo;
	}
	@Override
	public void contribute(Builder builder) {
		builder.withDetail('ssl', this.sslInfo);
	}
	static class SslInfoContributorRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), SslInfo.class);
		}
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@ImportRuntimeHints(JavaInfoContributorRuntimeHints.class)
public class JavaInfoContributor implements InfoContributor {
	private final JavaInfo javaInfo;
	public JavaInfoContributor() {
		this.javaInfo = new JavaInfo();
	}
	@Override
	public void contribute(Builder builder) {
		builder.withDetail('java', this.javaInfo);
	}
	static class JavaInfoContributorRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), JavaInfo.class);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.info;
/*
package org.springframework.boot.actuate.info;
/**
@ImportRuntimeHints(OsInfoContributorRuntimeHints.class)
public class OsInfoContributor implements InfoContributor {
	private final OsInfo osInfo;
	public OsInfoContributor() {
		this.osInfo = new OsInfo();
	}
	@Override
	public void contribute(Info.Builder builder) {
		builder.withDetail('os', this.osInfo);
	}
	static class OsInfoContributorRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), OsInfo.class);
		}
	}
}
/*
package org.springframework.boot.actuate.info;
/**
@ImportRuntimeHints(GitInfoContributorRuntimeHints.class)
public class GitInfoContributor extends InfoPropertiesInfoContributor<GitProperties> {
	public GitInfoContributor(GitProperties properties) {
		this(properties, Mode.SIMPLE);
	}
	public GitInfoContributor(GitProperties properties, Mode mode) {
		super(properties, mode);
	}
	@Override
	public void contribute(Info.Builder builder) {
		builder.withDetail('git', generateContent());
	}
	@Override
	protected PropertySource<?> toSimplePropertySource() {
		Properties props = new Properties();
		copyIfSet(props, 'branch');
		String commitId = getProperties().getShortCommitId();
		if (commitId != null) {
			props.put('commit.id', commitId);
		}
		copyIfSet(props, 'commit.time');
		return new PropertiesPropertySource('git', props);
	}
	/**
	 * Post-process the content to expose. By default, well known keys representing dates
	 * are converted to {@link Instant} instances.
	 * @param content the content to expose
	 */
	@Override
	protected void postProcessContent(Map<String, Object> content) {
		replaceValue(getNestedMap(content, 'commit'), 'time', getProperties().getCommitTime());
		replaceValue(getNestedMap(content, 'build'), 'time', getProperties().getInstant('build.time'));
	}
	static class GitInfoContributorRuntimeHints implements RuntimeHintsRegistrar {
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), GitProperties.class);
		}
	}
}
/*
package org.springframework.boot.actuate.system;
/**
public class DiskSpaceHealthIndicator extends AbstractHealthIndicator {
	private static final Log logger = LogFactory.getLog(DiskSpaceHealthIndicator.class);
	private final File path;
	private final DataSize threshold;
	/**
	 * Create a new {@code DiskSpaceHealthIndicator} instance.
	 * @param path the Path used to compute the available disk space
	 * @param threshold the minimum disk space that should be available
	 */
	public DiskSpaceHealthIndicator(File path, DataSize threshold) {
		super('DiskSpace health check failed');
		this.path = path;
		this.threshold = threshold;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		long diskFreeInBytes = this.path.getUsableSpace();
		if (diskFreeInBytes >= this.threshold.toBytes()) {
			builder.up();
		}
		else {
			logger.warn(LogMessage.format(
					'Free disk space at path "%s" below threshold. Available: %d bytes (threshold: %s)',
					this.path.getAbsolutePath(), diskFreeInBytes, this.threshold));
			builder.down();
		}
		builder.withDetail('total', this.path.getTotalSpace())
			.withDetail('free', diskFreeInBytes)
			.withDetail('threshold', this.threshold.toBytes())
			.withDetail('path', this.path.getAbsolutePath())
			.withDetail('exists', this.path.exists());
	}
}
/*
/**
package org.springframework.boot.actuate.system;
/*
package org.springframework.boot.actuate.neo4j;
/**
class Neo4jHealthDetailsHandler {
	/**
	 * Add health details for the specified {@link ResultSummary} and {@code edition}.
	 * @param builder the {@link Builder} to use
	 * @param healthDetails the health details of the server
	 */
	void addHealthDetails(Builder builder, Neo4jHealthDetails healthDetails) {
		ResultSummary summary = healthDetails.getSummary();
		ServerInfo serverInfo = summary.server();
		builder.up()
			.withDetail('server', healthDetails.getVersion() + '@' + serverInfo.address())
			.withDetail('edition', healthDetails.getEdition());
		DatabaseInfo databaseInfo = summary.database();
		if (StringUtils.hasText(databaseInfo.name())) {
			builder.withDetail('database', databaseInfo.name());
		}
	}
}
/*
package org.springframework.boot.actuate.neo4j;
/**
public final class Neo4jReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
	private static final Log logger = LogFactory.getLog(Neo4jReactiveHealthIndicator.class);
	private final Driver driver;
	private final Neo4jHealthDetailsHandler healthDetailsHandler;
	public Neo4jReactiveHealthIndicator(Driver driver) {
		this.driver = driver;
		this.healthDetailsHandler = new Neo4jHealthDetailsHandler();
	}
	@Override
	protected Mono<Health> doHealthCheck(Health.Builder builder) {
		return runHealthCheckQuery()
			.doOnError(SessionExpiredException.class, (ex) -> logger.warn(Neo4jHealthIndicator.MESSAGE_SESSION_EXPIRED))
			.retryWhen(Retry.max(1).filter(SessionExpiredException.class::isInstance))
			.map((healthDetails) -> {
				this.healthDetailsHandler.addHealthDetails(builder, healthDetails);
				return builder.build();
			});
	}
	Mono<Neo4jHealthDetails> runHealthCheckQuery() {
		return Mono.using(this::session, this::healthDetails, ReactiveSession::close);
	}
	private ReactiveSession session() {
		return this.driver.session(ReactiveSession.class, Neo4jHealthIndicator.DEFAULT_SESSION_CONFIG);
	}
	private Mono<Neo4jHealthDetails> healthDetails(ReactiveSession session) {
		return Mono.from(session.run(Neo4jHealthIndicator.CYPHER)).flatMap(this::healthDetails);
	}
	private Mono<? extends Neo4jHealthDetails> healthDetails(ReactiveResult result) {
		Flux<Record> records = Flux.from(result.records());
		Mono<ResultSummary> summary = Mono.from(result.consume());
		Neo4jHealthDetailsBuilder builder = new Neo4jHealthDetailsBuilder();
		return records.single().doOnNext(builder::record).then(summary).map(builder::build);
	}
	/**
	 * Builder used to create a {@link Neo4jHealthDetails} from a {@link Record} and a
	 * {@link ResultSummary}.
	 */
	private static final class Neo4jHealthDetailsBuilder {
		private Record record;
		void record(Record record) {
			this.record = record;
		}
		private Neo4jHealthDetails build(ResultSummary summary) {
			return new Neo4jHealthDetails(this.record, summary);
		}
	}
}
/*
package org.springframework.boot.actuate.neo4j;
/**
public class Neo4jHealthIndicator extends AbstractHealthIndicator {
	private static final Log logger = LogFactory.getLog(Neo4jHealthIndicator.class);
	/**
	 * The Cypher statement used to verify Neo4j is up.
	 */
	static final String CYPHER = 'CALL dbms.components() YIELD versions, name, edition WHERE name = "Neo4j Kernel" RETURN edition, versions[0] as version';
	/**
	 * Message logged before retrying a health check.
	 */
	static final String MESSAGE_SESSION_EXPIRED = 'Neo4j session has expired, retrying one single time to retrieve server health.';
	/**
	 * The default session config to use while connecting.
	 */
	static final SessionConfig DEFAULT_SESSION_CONFIG = SessionConfig.builder()
		.withDefaultAccessMode(AccessMode.WRITE)
		.build();
	private final Driver driver;
	private final Neo4jHealthDetailsHandler healthDetailsHandler;
	public Neo4jHealthIndicator(Driver driver) {
		super('Neo4j health check failed');
		this.driver = driver;
		this.healthDetailsHandler = new Neo4jHealthDetailsHandler();
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) {
		try {
			try {
				runHealthCheckQuery(builder);
			}
			catch (SessionExpiredException ex) {
				// Retry one time when the session has been expired
				logger.warn(MESSAGE_SESSION_EXPIRED);
				runHealthCheckQuery(builder);
			}
		}
		catch (Exception ex) {
			builder.down().withException(ex);
		}
	}
	private void runHealthCheckQuery(Health.Builder builder) {
		// We use WRITE here to make sure UP is returned for a server that supports
		// all possible workloads
		try (Session session = this.driver.session(DEFAULT_SESSION_CONFIG)) {
			Result result = session.run(CYPHER);
			Record record = result.single();
			ResultSummary resultSummary = result.consume();
			this.healthDetailsHandler.addHealthDetails(builder, new Neo4jHealthDetails(record, resultSummary));
		}
	}
}
/*
package org.springframework.boot.actuate.neo4j;
/**
class Neo4jHealthDetails {
	private final String version;
	private final String edition;
	private final ResultSummary summary;
	Neo4jHealthDetails(Record record, ResultSummary summary) {
		this.version = record.get('version').asString();
		this.edition = record.get('edition').asString();
		this.summary = summary;
	}
	String getVersion() {
		return this.version;
	}
	String getEdition() {
		return this.edition;
	}
	ResultSummary getSummary() {
		return this.summary;
	}
}
/*
/**
package org.springframework.boot.actuate.neo4j;
/*
package org.springframework.boot.actuate.amqp;
/**
public class RabbitHealthIndicator extends AbstractHealthIndicator {
	private final RabbitTemplate rabbitTemplate;
	public RabbitHealthIndicator(RabbitTemplate rabbitTemplate) {
		super('Rabbit health check failed');
		Assert.notNull(rabbitTemplate, 'RabbitTemplate must not be null');
		this.rabbitTemplate = rabbitTemplate;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		builder.up().withDetail('version', getVersion());
	}
	private String getVersion() {
		return this.rabbitTemplate
			.execute((channel) -> channel.getConnection().getServerProperties().get('version').toString());
	}
}
/*
/**
package org.springframework.boot.actuate.amqp;
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@EndpointExtension(filter = JmxEndpointFilter.class)
public @interface EndpointJmxExtension {
	/**
	 * The {@link Endpoint endpoint} class to which this JMX extension relates.
	 * @return the endpoint class
	 */
	@AliasFor(annotation = EndpointExtension.class)
	Class<?> endpoint();
}
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
@ImportRuntimeHints(JmxEndpointDiscovererRuntimeHints.class)
public class JmxEndpointDiscoverer extends EndpointDiscoverer<ExposableJmxEndpoint, JmxOperation>
		implements JmxEndpointsSupplier {
	/**
	 * Create a new {@link JmxEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param invokerAdvisors invoker advisors to apply
	 * @param endpointFilters endpoint filters to apply
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #JmxEndpointDiscoverer(ApplicationContext, ParameterValueMapper, Collection, Collection, Collection)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public JmxEndpointDiscoverer(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<ExposableJmxEndpoint>> endpointFilters) {
		this(applicationContext, parameterValueMapper, invokerAdvisors, endpointFilters, Collections.emptyList());
	}
	/**
	 * Create a new {@link JmxEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param invokerAdvisors invoker advisors to apply
	 * @param endpointFilters endpoint filters to apply
	 * @param operationFilters operation filters to apply
	 * @since 3.4.0
	 */
	public JmxEndpointDiscoverer(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<ExposableJmxEndpoint>> endpointFilters,
			Collection<OperationFilter<JmxOperation>> operationFilters) {
		super(applicationContext, parameterValueMapper, invokerAdvisors, endpointFilters, operationFilters);
	}
	@Override
	protected ExposableJmxEndpoint createEndpoint(Object endpointBean, EndpointId id, Access defaultAccess,
			Collection<JmxOperation> operations) {
		return new DiscoveredJmxEndpoint(this, endpointBean, id, defaultAccess, operations);
	}
	@Override
	protected JmxOperation createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
			OperationInvoker invoker) {
		return new DiscoveredJmxOperation(endpointId, operationMethod, invoker);
	}
	@Override
	protected OperationKey createOperationKey(JmxOperation operation) {
		return new OperationKey(operation.getName(), () -> 'MBean call "' + operation.getName() + '"');
	}
	static class JmxEndpointDiscovererRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection().registerType(JmxEndpointFilter.class, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
class JmxEndpointFilter extends DiscovererEndpointFilter {
	JmxEndpointFilter() {
		super(JmxEndpointDiscoverer.class);
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
class DiscoveredJmxOperation extends AbstractDiscoveredOperation implements JmxOperation {
	private static final JmxAttributeSource jmxAttributeSource = new AnnotationJmxAttributeSource();
	private final String name;
	private final Class<?> outputType;
	private final String description;
	private final List<JmxOperationParameter> parameters;
	DiscoveredJmxOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
		super(operationMethod, invoker);
		Method method = operationMethod.getMethod();
		this.name = method.getName();
		this.outputType = JmxType.get(method.getReturnType());
		this.description = getDescription(method, () -> 'Invoke ' + this.name + ' for endpoint ' + endpointId);
		this.parameters = getParameters(operationMethod);
	}
	private String getDescription(Method method, Supplier<String> fallback) {
		ManagedOperation managed = jmxAttributeSource.getManagedOperation(method);
		if (managed != null && StringUtils.hasText(managed.getDescription())) {
			return managed.getDescription();
		}
		return fallback.get();
	}
	private List<JmxOperationParameter> getParameters(OperationMethod operationMethod) {
		if (!operationMethod.getParameters().hasParameters()) {
			return Collections.emptyList();
		}
		Method method = operationMethod.getMethod();
		ManagedOperationParameter[] managed = jmxAttributeSource.getManagedOperationParameters(method);
		if (managed.length == 0) {
			Stream<JmxOperationParameter> parameters = operationMethod.getParameters()
				.stream()
				.map(DiscoveredJmxOperationParameter::new);
			return parameters.toList();
		}
		return mergeParameters(operationMethod.getParameters(), managed);
	}
	private List<JmxOperationParameter> mergeParameters(OperationParameters operationParameters,
			ManagedOperationParameter[] managedParameters) {
		List<JmxOperationParameter> merged = new ArrayList<>(managedParameters.length);
		for (int i = 0; i < managedParameters.length; i++) {
			merged.add(new DiscoveredJmxOperationParameter(managedParameters[i], operationParameters.get(i)));
		}
		return Collections.unmodifiableList(merged);
	}
	@Override
	public String getName() {
		return this.name;
	}
	@Override
	public Class<?> getOutputType() {
		return this.outputType;
	}
	@Override
	public String getDescription() {
		return this.description;
	}
	@Override
	public List<JmxOperationParameter> getParameters() {
		return this.parameters;
	}
	@Override
	protected void appendFields(ToStringCreator creator) {
		creator.append('name', this.name)
			.append('outputType', this.outputType)
			.append('description', this.description)
			.append('parameters', this.parameters);
	}
	/**
	 * A discovered {@link JmxOperationParameter}.
	 */
	private static class DiscoveredJmxOperationParameter implements JmxOperationParameter {
		private final String name;
		private final Class<?> type;
		private final String description;
		DiscoveredJmxOperationParameter(OperationParameter operationParameter) {
			this.name = operationParameter.getName();
			this.type = JmxType.get(operationParameter.getType());
			this.description = null;
		}
		DiscoveredJmxOperationParameter(ManagedOperationParameter managedParameter,
				OperationParameter operationParameter) {
			this.name = managedParameter.getName();
			this.type = JmxType.get(operationParameter.getType());
			this.description = managedParameter.getDescription();
		}
		@Override
		public String getName() {
			return this.name;
		}
		@Override
		public Class<?> getType() {
			return this.type;
		}
		@Override
		public String getDescription() {
			return this.description;
		}
		@Override
		public String toString() {
			StringBuilder result = new StringBuilder(this.name);
			if (this.description != null) {
				result.append(' (').append(this.description).append(')');
			}
			result.append(':').append(this.type);
			return result.toString();
		}
	}
	/**
	 * Utility to convert to JMX supported types.
	 */
	private static final class JmxType {
		static Class<?> get(Class<?> source) {
			if (source.isEnum()) {
				return String.class;
			}
			if (Date.class.isAssignableFrom(source) || Instant.class.isAssignableFrom(source)) {
				return String.class;
			}
			if (source.getName().startsWith('java.')) {
				return source;
			}
			if (source.equals(Void.TYPE)) {
				return source;
			}
			return Object.class;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Endpoint
@FilteredEndpoint(JmxEndpointFilter.class)
public @interface JmxEndpoint {
	/**
	 * The id of the endpoint.
	 * @return the id
	 */
	@AliasFor(annotation = Endpoint.class)
	String id() default '';
	/**
	 * If the endpoint should be enabled or disabled by default.
	 * @return {@code true} if the endpoint is enabled by default
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	@AliasFor(annotation = Endpoint.class)
	boolean enableByDefault() default true;
	/**
	 * Level of access to the endpoint that is permitted by default.
	 * @return the default level of access
	 * @since 3.4.0
	 */
	@AliasFor(annotation = Endpoint.class)
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/**
class DiscoveredJmxEndpoint extends AbstractDiscoveredEndpoint<JmxOperation> implements ExposableJmxEndpoint {
	@SuppressWarnings('removal')
	DiscoveredJmxEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id, Access defaultAccess,
			Collection<JmxOperation> operations) {
		super(discoverer, endpointBean, id, defaultAccess, operations);
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.jmx.annotation;
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
class MBeanInfoFactory {
	private static final ModelMBeanAttributeInfo[] NO_ATTRIBUTES = new ModelMBeanAttributeInfo[0];
	private static final ModelMBeanConstructorInfo[] NO_CONSTRUCTORS = new ModelMBeanConstructorInfo[0];
	private static final ModelMBeanNotificationInfo[] NO_NOTIFICATIONS = new ModelMBeanNotificationInfo[0];
	private final JmxOperationResponseMapper responseMapper;
	MBeanInfoFactory(JmxOperationResponseMapper responseMapper) {
		this.responseMapper = responseMapper;
	}
	MBeanInfo getMBeanInfo(ExposableJmxEndpoint endpoint) {
		String className = EndpointMBean.class.getName();
		String description = getDescription(endpoint);
		ModelMBeanOperationInfo[] operations = getMBeanOperations(endpoint);
		return new ModelMBeanInfoSupport(className, description, NO_ATTRIBUTES, NO_CONSTRUCTORS, operations,
				NO_NOTIFICATIONS);
	}
	private String getDescription(ExposableJmxEndpoint endpoint) {
		return 'MBean operations for endpoint ' + endpoint.getEndpointId();
	}
	private ModelMBeanOperationInfo[] getMBeanOperations(ExposableJmxEndpoint endpoint) {
		return endpoint.getOperations().stream().map(this::getMBeanOperation).toArray(ModelMBeanOperationInfo[]::new);
	}
	private ModelMBeanOperationInfo getMBeanOperation(JmxOperation operation) {
		String name = operation.getName();
		String description = operation.getDescription();
		MBeanParameterInfo[] signature = getSignature(operation.getParameters());
		String type = getType(operation.getOutputType());
		int impact = getImpact(operation.getType());
		return new ModelMBeanOperationInfo(name, description, signature, type, impact);
	}
	private MBeanParameterInfo[] getSignature(List<JmxOperationParameter> parameters) {
		return parameters.stream().map(this::getMBeanParameter).toArray(MBeanParameterInfo[]::new);
	}
	private MBeanParameterInfo getMBeanParameter(JmxOperationParameter parameter) {
		return new MBeanParameterInfo(parameter.getName(), parameter.getType().getName(), parameter.getDescription());
	}
	private int getImpact(OperationType operationType) {
		if (operationType == OperationType.READ) {
			return MBeanOperationInfo.INFO;
		}
		if (operationType == OperationType.WRITE || operationType == OperationType.DELETE) {
			return MBeanOperationInfo.ACTION;
		}
		return MBeanOperationInfo.UNKNOWN;
	}
	private String getType(Class<?> outputType) {
		return this.responseMapper.mapResponseType(outputType).getName();
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
@FunctionalInterface
public interface EndpointObjectNameFactory {
	/**
	 * Generate an {@link ObjectName} for the specified {@link ExposableJmxEndpoint
	 * endpoint}.
	 * @param endpoint the endpoint MBean to handle
	 * @return the {@link ObjectName} to use for the endpoint
	 * @throws MalformedObjectNameException if the object name is invalid
	 */
	ObjectName getObjectName(ExposableJmxEndpoint endpoint) throws MalformedObjectNameException;
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public interface JmxOperationParameter {
	/**
	 * Return the name of the operation parameter.
	 * @return the name of the parameter
	 */
	String getName();
	/**
	 * Return the type of the operation parameter.
	 * @return the type
	 */
	Class<?> getType();
	/**
	 * Return the description of the parameter or {@code null} if none is available.
	 * @return the description or {@code null}
	 */
	String getDescription();
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public interface ExposableJmxEndpoint extends ExposableEndpoint<JmxOperation> {
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public class JmxEndpointExporter implements InitializingBean, DisposableBean, BeanClassLoaderAware {
	private static final Log logger = LogFactory.getLog(JmxEndpointExporter.class);
	private ClassLoader classLoader;
	private final MBeanServer mBeanServer;
	private final EndpointObjectNameFactory objectNameFactory;
	private final JmxOperationResponseMapper responseMapper;
	private final Collection<ExposableJmxEndpoint> endpoints;
	private Collection<ObjectName> registered;
	public JmxEndpointExporter(MBeanServer mBeanServer, EndpointObjectNameFactory objectNameFactory,
			JmxOperationResponseMapper responseMapper, Collection<? extends ExposableJmxEndpoint> endpoints) {
		Assert.notNull(mBeanServer, 'MBeanServer must not be null');
		Assert.notNull(objectNameFactory, 'ObjectNameFactory must not be null');
		Assert.notNull(responseMapper, 'ResponseMapper must not be null');
		Assert.notNull(endpoints, 'Endpoints must not be null');
		this.mBeanServer = mBeanServer;
		this.objectNameFactory = objectNameFactory;
		this.responseMapper = responseMapper;
		this.endpoints = Collections.unmodifiableCollection(endpoints);
	}
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	@Override
	public void afterPropertiesSet() {
		this.registered = register();
	}
	@Override
	public void destroy() throws Exception {
		unregister(this.registered);
	}
	private Collection<ObjectName> register() {
		return this.endpoints.stream().filter(this::hasOperations).map(this::register).toList();
	}
	private boolean hasOperations(ExposableJmxEndpoint endpoint) {
		return !CollectionUtils.isEmpty(endpoint.getOperations());
	}
	private ObjectName register(ExposableJmxEndpoint endpoint) {
		Assert.notNull(endpoint, 'Endpoint must not be null');
		try {
			ObjectName name = this.objectNameFactory.getObjectName(endpoint);
			EndpointMBean mbean = new EndpointMBean(this.responseMapper, this.classLoader, endpoint);
			this.mBeanServer.registerMBean(mbean, name);
			return name;
		}
		catch (MalformedObjectNameException ex) {
			throw new IllegalStateException('Invalid ObjectName for ' + getEndpointDescription(endpoint), ex);
		}
		catch (Exception ex) {
			throw new MBeanExportException('Failed to register MBean for ' + getEndpointDescription(endpoint), ex);
		}
	}
	private void unregister(Collection<ObjectName> objectNames) {
		objectNames.forEach(this::unregister);
	}
	private void unregister(ObjectName objectName) {
		try {
			if (logger.isDebugEnabled()) {
				logger.debug('Unregister endpoint with ObjectName "' + objectName + '" from the JMX domain');
			}
			this.mBeanServer.unregisterMBean(objectName);
		}
		catch (InstanceNotFoundException ex) {
			// Ignore and continue
		}
		catch (MBeanRegistrationException ex) {
			throw new JmxException('Failed to unregister MBean with ObjectName "' + objectName + '"', ex);
		}
	}
	private String getEndpointDescription(ExposableJmxEndpoint endpoint) {
		return 'endpoint "' + endpoint.getEndpointId() + '"';
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public interface JmxOperation extends Operation {
	/**
	 * Returns the name of the operation.
	 * @return the operation name
	 */
	String getName();
	/**
	 * Returns the type of the output of the operation.
	 * @return the output type
	 */
	Class<?> getOutputType();
	/**
	 * Returns the description of the operation.
	 * @return the operation description
	 */
	String getDescription();
	/**
	 * Returns the parameters the operation expects in the order that they should be
	 * provided.
	 * @return the operation parameter names
	 */
	List<JmxOperationParameter> getParameters();
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
@FunctionalInterface
public interface JmxEndpointsSupplier extends EndpointsSupplier<ExposableJmxEndpoint> {
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public class JacksonJmxOperationResponseMapper implements JmxOperationResponseMapper {
	private final ObjectMapper objectMapper;
	private final JavaType listType;
	private final JavaType mapType;
	public JacksonJmxOperationResponseMapper(ObjectMapper objectMapper) {
		this.objectMapper = (objectMapper != null) ? objectMapper : new ObjectMapper();
		this.listType = this.objectMapper.getTypeFactory().constructParametricType(List.class, Object.class);
		this.mapType = this.objectMapper.getTypeFactory()
			.constructParametricType(Map.class, String.class, Object.class);
	}
	@Override
	public Class<?> mapResponseType(Class<?> responseType) {
		if (CharSequence.class.isAssignableFrom(responseType)) {
			return String.class;
		}
		if (responseType.isArray() || Collection.class.isAssignableFrom(responseType)) {
			return List.class;
		}
		return Map.class;
	}
	@Override
	public Object mapResponse(Object response) {
		if (response == null) {
			return null;
		}
		if (response instanceof CharSequence) {
			return response.toString();
		}
		if (response.getClass().isArray() || response instanceof Collection) {
			return this.objectMapper.convertValue(response, this.listType);
		}
		return this.objectMapper.convertValue(response, this.mapType);
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public class EndpointMBean implements DynamicMBean {
	private static final boolean REACTOR_PRESENT = ClassUtils.isPresent('reactor.core.publisher.Mono',
			EndpointMBean.class.getClassLoader());
	private final JmxOperationResponseMapper responseMapper;
	private final ClassLoader classLoader;
	private final ExposableJmxEndpoint endpoint;
	private final MBeanInfo info;
	private final Map<String, JmxOperation> operations;
	EndpointMBean(JmxOperationResponseMapper responseMapper, ClassLoader classLoader, ExposableJmxEndpoint endpoint) {
		Assert.notNull(responseMapper, 'ResponseMapper must not be null');
		Assert.notNull(endpoint, 'Endpoint must not be null');
		this.responseMapper = responseMapper;
		this.classLoader = classLoader;
		this.endpoint = endpoint;
		this.info = new MBeanInfoFactory(responseMapper).getMBeanInfo(endpoint);
		this.operations = getOperations(endpoint);
	}
	private Map<String, JmxOperation> getOperations(ExposableJmxEndpoint endpoint) {
		Map<String, JmxOperation> operations = new HashMap<>();
		endpoint.getOperations().forEach((operation) -> operations.put(operation.getName(), operation));
		return Collections.unmodifiableMap(operations);
	}
	@Override
	public MBeanInfo getMBeanInfo() {
		return this.info;
	}
	@Override
	public Object invoke(String actionName, Object[] params, String[] signature)
			throws MBeanException, ReflectionException {
		JmxOperation operation = this.operations.get(actionName);
		if (operation == null) {
			String message = 'Endpoint with id "' + this.endpoint.getEndpointId() + '" has no operation named '
					+ actionName;
			throw new ReflectionException(new IllegalArgumentException(message), message);
		}
		ClassLoader previousClassLoader = overrideThreadContextClassLoader(this.classLoader);
		try {
			return invoke(operation, params);
		}
		finally {
			overrideThreadContextClassLoader(previousClassLoader);
		}
	}
	private ClassLoader overrideThreadContextClassLoader(ClassLoader classLoader) {
		if (classLoader != null) {
			try {
				return ClassUtils.overrideThreadContextClassLoader(classLoader);
			}
			catch (SecurityException ex) {
				// can"t set class loader, ignore it and proceed
			}
		}
		return null;
	}
	private Object invoke(JmxOperation operation, Object[] params) throws MBeanException, ReflectionException {
		try {
			String[] parameterNames = operation.getParameters()
				.stream()
				.map(JmxOperationParameter::getName)
				.toArray(String[]::new);
			Map<String, Object> arguments = getArguments(parameterNames, params);
			InvocationContext context = new InvocationContext(SecurityContext.NONE, arguments);
			Object result = operation.invoke(context);
			if (REACTOR_PRESENT) {
				result = ReactiveHandler.handle(result);
			}
			return this.responseMapper.mapResponse(result);
		}
		catch (InvalidEndpointRequestException ex) {
			throw new ReflectionException(new IllegalArgumentException(ex.getMessage()), ex.getMessage());
		}
		catch (Exception ex) {
			throw new MBeanException(translateIfNecessary(ex), ex.getMessage());
		}
	}
	private Exception translateIfNecessary(Exception exception) {
		if (exception.getClass().getName().startsWith('java.')) {
			return exception;
		}
		return new IllegalStateException(exception.getMessage());
	}
	private Map<String, Object> getArguments(String[] parameterNames, Object[] params) {
		Map<String, Object> arguments = new HashMap<>();
		for (int i = 0; i < params.length; i++) {
			arguments.put(parameterNames[i], params[i]);
		}
		return arguments;
	}
	@Override
	public Object getAttribute(String attribute)
			throws AttributeNotFoundException, MBeanException, ReflectionException {
		throw new AttributeNotFoundException('EndpointMBeans do not support attributes');
	}
	@Override
	public void setAttribute(Attribute attribute)
			throws AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException {
		throw new AttributeNotFoundException('EndpointMBeans do not support attributes');
	}
	@Override
	public AttributeList getAttributes(String[] attributes) {
		return new AttributeList();
	}
	@Override
	public AttributeList setAttributes(AttributeList attributes) {
		return new AttributeList();
	}
	private static final class ReactiveHandler {
		static Object handle(Object result) {
			if (result instanceof Flux) {
				result = ((Flux<?>) result).collectList();
			}
			if (result instanceof Mono) {
				return ((Mono<?>) result).block();
			}
			return result;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.jmx;
/**
public interface JmxOperationResponseMapper {
	/**
	 * Map the response type to its JMX compliant counterpart.
	 * @param responseType the operation"s response type
	 * @return the JMX compliant type
	 */
	Class<?> mapResponseType(Class<?> responseType);
	/**
	 * Map the operation"s response so that it can be consumed by a JMX compliant client.
	 * @param response the operation"s response
	 * @return the {@code response}, in a JMX compliant format
	 */
	Object mapResponse(Object response);
}
/*
/**
package org.springframework.boot.actuate.endpoint.jmx;
/*
package org.springframework.boot.actuate.endpoint;
/**
public class InvocationContext {
	private final Map<String, Object> arguments;
	private final List<OperationArgumentResolver> argumentResolvers;
	/**
	 * Creates a new context for an operation being invoked by the given
	 * {@code securityContext} with the given available {@code arguments}.
	 * @param securityContext the current security context. Never {@code null}
	 * @param arguments the arguments available to the operation. Never {@code null}
	 * @param argumentResolvers resolvers for additional arguments should be available to
	 * the operation.
	 */
	public InvocationContext(SecurityContext securityContext, Map<String, Object> arguments,
			OperationArgumentResolver... argumentResolvers) {
		Assert.notNull(securityContext, 'SecurityContext must not be null');
		Assert.notNull(arguments, 'Arguments must not be null');
		this.arguments = arguments;
		this.argumentResolvers = new ArrayList<>();
		if (argumentResolvers != null) {
			this.argumentResolvers.addAll(Arrays.asList(argumentResolvers));
		}
		this.argumentResolvers.add(OperationArgumentResolver.of(SecurityContext.class, () -> securityContext));
		this.argumentResolvers.add(OperationArgumentResolver.of(Principal.class, securityContext::getPrincipal));
		this.argumentResolvers.add(OperationArgumentResolver.of(ApiVersion.class, () -> ApiVersion.LATEST));
	}
	/**
	 * Return the invocation arguments.
	 * @return the arguments
	 */
	public Map<String, Object> getArguments() {
		return this.arguments;
	}
	/**
	 * Resolves an argument with the given {@code argumentType}.
	 * @param <T> type of the argument
	 * @param argumentType type of the argument
	 * @return resolved argument of the required type or {@code null}
	 * @since 2.5.0
	 * @see #canResolve(Class)
	 */
	public <T> T resolveArgument(Class<T> argumentType) {
		for (OperationArgumentResolver argumentResolver : this.argumentResolvers) {
			if (argumentResolver.canResolve(argumentType)) {
				T result = argumentResolver.resolve(argumentType);
				if (result != null) {
					return result;
				}
			}
		}
		return null;
	}
	/**
	 * Returns whether the context is capable of resolving an argument of the given
	 * {@code type}. Note that, even when {@code true} is returned,
	 * {@link #resolveArgument argument resolution} will return {@code null} if no
	 * argument of the required type is available.
	 * @param type argument type
	 * @return {@code true} if resolution of arguments of the given type is possible,
	 * otherwise {@code false}.
	 * @since 2.5.0
	 * @see #resolveArgument(Class)
	 */
	public boolean canResolve(Class<?> type) {
		for (OperationArgumentResolver argumentResolver : this.argumentResolvers) {
			if (argumentResolver.canResolve(type)) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
public interface DiscoveredEndpoint<O extends Operation> extends ExposableEndpoint<O> {
	/**
	 * Return {@code true} if the endpoint was discovered by the specified discoverer.
	 * @param discoverer the discoverer type
	 * @return {@code true} if discovered using the specified discoverer
	 */
	boolean wasDiscoveredBy(Class<? extends EndpointDiscoverer<?, ?>> discoverer);
	/**
	 * Return the source bean that was used to construct the {@link DiscoveredEndpoint}.
	 * @return the source endpoint bean
	 */
	Object getEndpointBean();
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Reflective(OperationReflectiveProcessor.class)
public @interface WriteOperation {
	/**
	 * The media type of the result of the operation.
	 * @return the media type
	 */
	String[] produces() default {};
	/**
	 * The media types of the result of the operation.
	 * @return the media types
	 */
	@SuppressWarnings('rawtypes')
	Class<? extends Producible> producesFrom() default Producible.class;
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FilteredEndpoint {
	/**
	 * The filter class to use.
	 * @return the filter class
	 */
	Class<? extends EndpointFilter<?>> value();
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
public abstract class AbstractDiscoveredEndpoint<O extends Operation> extends AbstractExposableEndpoint<O>
		implements DiscoveredEndpoint<O> {
	private final EndpointDiscoverer<?, ?> discoverer;
	private final Object endpointBean;
	/**
	 * Create a new {@link AbstractDiscoveredEndpoint} instance.
	 * @param discoverer the discoverer that discovered the endpoint
	 * @param endpointBean the primary source bean
	 * @param id the ID of the endpoint
	 * @param enabledByDefault if the endpoint is enabled by default
	 * @param operations the endpoint operations
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #AbstractDiscoveredEndpoint(EndpointDiscoverer, Object, EndpointId, Access, Collection)}
	 */
	@SuppressWarnings('removal')
	@Deprecated(since = '3.4.0', forRemoval = true)
	public AbstractDiscoveredEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id,
			boolean enabledByDefault, Collection<? extends O> operations) {
		this(discoverer, endpointBean, id, (enabledByDefault) ? Access.UNRESTRICTED : Access.READ_ONLY, operations);
	}
	/**
	 * Create a new {@link AbstractDiscoveredEndpoint} instance.
	 * @param discoverer the discoverer that discovered the endpoint
	 * @param endpointBean the primary source bean
	 * @param id the ID of the endpoint
	 * @param defaultAccess access to the endpoint that is permitted by default
	 * @param operations the endpoint operations
	 * @since 3.4.0
	 */
	public AbstractDiscoveredEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id,
			Access defaultAccess, Collection<? extends O> operations) {
		super(id, defaultAccess, operations);
		Assert.notNull(discoverer, 'Discoverer must not be null');
		Assert.notNull(endpointBean, 'EndpointBean must not be null');
		this.discoverer = discoverer;
		this.endpointBean = endpointBean;
	}
	@Override
	public Object getEndpointBean() {
		return this.endpointBean;
	}
	@Override
	public boolean wasDiscoveredBy(Class<? extends EndpointDiscoverer<?, ?>> discoverer) {
		return discoverer.isInstance(this.discoverer);
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this).append('discoverer', this.discoverer.getClass().getName())
			.append('endpointBean', this.endpointBean.getClass().getName());
		appendFields(creator);
		return creator.toString();
	}
	protected void appendFields(ToStringCreator creator) {
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface EndpointConverter {
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
public class DiscoveredOperationMethod extends OperationMethod {
	private final List<String> producesMediaTypes;
	public DiscoveredOperationMethod(Method method, OperationType operationType,
			AnnotationAttributes annotationAttributes) {
		super(method, operationType);
		Assert.notNull(annotationAttributes, 'AnnotationAttributes must not be null');
		List<String> producesMediaTypes = new ArrayList<>();
		producesMediaTypes.addAll(Arrays.asList(annotationAttributes.getStringArray('produces')));
		producesMediaTypes.addAll(getProducesFromProducible(annotationAttributes));
		this.producesMediaTypes = Collections.unmodifiableList(producesMediaTypes);
	}
	private <E extends Enum<E> & Producible<E>> List<String> getProducesFromProducible(
			AnnotationAttributes annotationAttributes) {
		Class<?> type = getProducesFrom(annotationAttributes);
		if (type == Producible.class) {
			return Collections.emptyList();
		}
		List<String> produces = new ArrayList<>();
		for (Object value : type.getEnumConstants()) {
			produces.add(((Producible<?>) value).getProducedMimeType().toString());
		}
		return produces;
	}
	private Class<?> getProducesFrom(AnnotationAttributes annotationAttributes) {
		try {
			return annotationAttributes.getClass('producesFrom');
		}
		catch (IllegalArgumentException ex) {
			return Producible.class;
		}
	}
	public List<String> getProducesMediaTypes() {
		return this.producesMediaTypes;
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Reflective
public @interface Endpoint {
	/**
	 * The id of the endpoint (must follow {@link EndpointId} rules).
	 * @return the id
	 * @see EndpointId
	 */
	String id() default '';
	/**
	 * If the endpoint should be enabled or disabled by default.
	 * @return {@code true} if the endpoint is enabled by default
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of {@link #defaultAccess()}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	boolean enableByDefault() default true;
	/**
	 * Level of access to the endpoint that is permitted by default.
	 * @return the default level of access
	 * @since 3.4.0
	 */
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Reflective(OperationReflectiveProcessor.class)
public @interface ReadOperation {
	/**
	 * The media type of the result of the operation.
	 * @return the media type
	 */
	String[] produces() default {};
	/**
	 * The media types of the result of the operation.
	 * @return the media types
	 */
	@SuppressWarnings('rawtypes')
	Class<? extends Producible> producesFrom() default Producible.class;
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
public abstract class DiscovererEndpointFilter implements EndpointFilter<DiscoveredEndpoint<?>> {
	private final Class<? extends EndpointDiscoverer<?, ?>> discoverer;
	/**
	 * Create a new {@link DiscovererEndpointFilter} instance.
	 * @param discoverer the required discoverer
	 */
	protected DiscovererEndpointFilter(Class<? extends EndpointDiscoverer<?, ?>> discoverer) {
		Assert.notNull(discoverer, 'Discoverer must not be null');
		this.discoverer = discoverer;
	}
	@Override
	public boolean match(DiscoveredEndpoint<?> endpoint) {
		return endpoint.wasDiscoveredBy(this.discoverer);
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Reflective
public @interface EndpointExtension {
	/**
	 * The filter class used to determine when the extension applies.
	 * @return the filter class
	 */
	Class<? extends EndpointFilter<?>> filter();
	/**
	 * The class of the endpoint to extend.
	 * @return the class endpoint to extend
	 */
	Class<?> endpoint() default Void.class;
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
public abstract class AbstractDiscoveredOperation implements Operation {
	private final OperationMethod operationMethod;
	private final OperationInvoker invoker;
	/**
	 * Create a new {@link AbstractDiscoveredOperation} instance.
	 * @param operationMethod the method backing the operation
	 * @param invoker the operation invoker to use
	 */
	public AbstractDiscoveredOperation(DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
		this.operationMethod = operationMethod;
		this.invoker = invoker;
	}
	public OperationMethod getOperationMethod() {
		return this.operationMethod;
	}
	@Override
	public OperationType getType() {
		return this.operationMethod.getOperationType();
	}
	@Override
	public Object invoke(InvocationContext context) {
		return this.invoker.invoke(context);
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this).append('operationMethod', this.operationMethod)
			.append('invoker', this.invoker);
		appendFields(creator);
		return creator.toString();
	}
	protected void appendFields(ToStringCreator creator) {
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
abstract class DiscoveredOperationsFactory<O extends Operation> {
	private static final Map<OperationType, Class<? extends Annotation>> OPERATION_TYPES;
	static {
		Map<OperationType, Class<? extends Annotation>> operationTypes = new EnumMap<>(OperationType.class);
		operationTypes.put(OperationType.READ, ReadOperation.class);
		operationTypes.put(OperationType.WRITE, WriteOperation.class);
		operationTypes.put(OperationType.DELETE, DeleteOperation.class);
		OPERATION_TYPES = Collections.unmodifiableMap(operationTypes);
	}
	private final ParameterValueMapper parameterValueMapper;
	private final Collection<OperationInvokerAdvisor> invokerAdvisors;
	DiscoveredOperationsFactory(ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors) {
		this.parameterValueMapper = parameterValueMapper;
		this.invokerAdvisors = invokerAdvisors;
	}
	Collection<O> createOperations(EndpointId id, Object target) {
		return MethodIntrospector
			.selectMethods(target.getClass(), (MetadataLookup<O>) (method) -> createOperation(id, target, method))
			.values();
	}
	private O createOperation(EndpointId endpointId, Object target, Method method) {
		return OPERATION_TYPES.entrySet()
			.stream()
			.map((entry) -> createOperation(endpointId, target, method, entry.getKey(), entry.getValue()))
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(null);
	}
	private O createOperation(EndpointId endpointId, Object target, Method method, OperationType operationType,
			Class<? extends Annotation> annotationType) {
		MergedAnnotation<?> annotation = MergedAnnotations.from(method).get(annotationType);
		if (!annotation.isPresent()) {
			return null;
		}
		DiscoveredOperationMethod operationMethod = new DiscoveredOperationMethod(method, operationType,
				annotation.asAnnotationAttributes());
		OperationInvoker invoker = new ReflectiveOperationInvoker(target, operationMethod, this.parameterValueMapper);
		invoker = applyAdvisors(endpointId, operationMethod, invoker);
		return createOperation(endpointId, operationMethod, invoker);
	}
	private OperationInvoker applyAdvisors(EndpointId endpointId, OperationMethod operationMethod,
			OperationInvoker invoker) {
		if (this.invokerAdvisors != null) {
			for (OperationInvokerAdvisor advisor : this.invokerAdvisors) {
				invoker = advisor.apply(endpointId, operationMethod.getOperationType(), operationMethod.getParameters(),
						invoker);
			}
		}
		return invoker;
	}
	protected abstract O createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
			OperationInvoker invoker);
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Selector {
	/**
	 * The match type that should be used for the selection.
	 * @return the match type
	 * @since 2.2.0
	 */
	Match match() default Match.SINGLE;
	/**
	 * Match types that can be used with the {@code @Selector}.
	 */
	enum Match {
		/**
		 * Capture a single item. For example, in the case of a web application a single
		 * path segment. The parameter value be converted from a {@code String} source.
		 */
		SINGLE,
		/**
		 * Capture all remaining times. For example, in the case of a web application all
		 * remaining path segments. The parameter value be converted from a
		 * {@code String[]} source.
		 */
		ALL_REMAINING
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Reflective(OperationReflectiveProcessor.class)
public @interface DeleteOperation {
	/**
	 * The media type of the result of the operation.
	 * @return the media type
	 */
	String[] produces() default {};
	/**
	 * The media types of the result of the operation.
	 * @return the media types
	 */
	@SuppressWarnings('rawtypes')
	Class<? extends Producible> producesFrom() default Producible.class;
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
public abstract class EndpointDiscoverer<E extends ExposableEndpoint<O>, O extends Operation>
		implements EndpointsSupplier<E> {
	private final ApplicationContext applicationContext;
	private final Collection<EndpointFilter<E>> endpointFilters;
	private final Collection<OperationFilter<O>> operationFilters;
	private final DiscoveredOperationsFactory<O> operationsFactory;
	private final Map<EndpointBean, E> filterEndpoints = new ConcurrentHashMap<>();
	private volatile Collection<E> endpoints;
	/**
	 * Create a new {@link EndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param invokerAdvisors invoker advisors to apply
	 * @param endpointFilters endpoint filters to apply
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #EndpointDiscoverer(ApplicationContext, ParameterValueMapper, Collection, Collection, Collection)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public EndpointDiscoverer(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors, Collection<EndpointFilter<E>> endpointFilters) {
		this(applicationContext, parameterValueMapper, invokerAdvisors, endpointFilters, Collections.emptyList());
	}
	/**
	 * Create a new {@link EndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param invokerAdvisors invoker advisors to apply
	 * @param endpointFilters endpoint filters to apply
	 * @param operationFilters operation filters to apply
	 * @since 3.4.0
	 */
	public EndpointDiscoverer(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors, Collection<EndpointFilter<E>> endpointFilters,
			Collection<OperationFilter<O>> operationFilters) {
		Assert.notNull(applicationContext, 'ApplicationContext must not be null');
		Assert.notNull(parameterValueMapper, 'ParameterValueMapper must not be null');
		Assert.notNull(invokerAdvisors, 'InvokerAdvisors must not be null');
		Assert.notNull(endpointFilters, 'EndpointFilters must not be null');
		Assert.notNull(operationFilters, 'OperationFilters must not be null');
		this.applicationContext = applicationContext;
		this.endpointFilters = Collections.unmodifiableCollection(endpointFilters);
		this.operationFilters = Collections.unmodifiableCollection(operationFilters);
		this.operationsFactory = getOperationsFactory(parameterValueMapper, invokerAdvisors);
	}
	private DiscoveredOperationsFactory<O> getOperationsFactory(ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors) {
		return new DiscoveredOperationsFactory<>(parameterValueMapper, invokerAdvisors) {
			@Override
			Collection<O> createOperations(EndpointId id, Object target) {
				return super.createOperations(id, target);
			}
			@Override
			protected O createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
					OperationInvoker invoker) {
				return EndpointDiscoverer.this.createOperation(endpointId, operationMethod, invoker);
			}
		};
	}
	@Override
	public final Collection<E> getEndpoints() {
		if (this.endpoints == null) {
			this.endpoints = discoverEndpoints();
		}
		return this.endpoints;
	}
	private Collection<E> discoverEndpoints() {
		Collection<EndpointBean> endpointBeans = createEndpointBeans();
		addExtensionBeans(endpointBeans);
		return convertToEndpoints(endpointBeans);
	}
	private Collection<EndpointBean> createEndpointBeans() {
		Map<EndpointId, EndpointBean> byId = new LinkedHashMap<>();
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(this.applicationContext,
				Endpoint.class);
		for (String beanName : beanNames) {
			if (!ScopedProxyUtils.isScopedTarget(beanName)) {
				EndpointBean endpointBean = createEndpointBean(beanName);
				EndpointBean previous = byId.putIfAbsent(endpointBean.getId(), endpointBean);
				Assert.state(previous == null, () -> 'Found two endpoints with the id "' + endpointBean.getId() + '": "'
						+ endpointBean.getBeanName() + '" and "' + previous.getBeanName() + '"');
			}
		}
		return byId.values();
	}
	private EndpointBean createEndpointBean(String beanName) {
		Class<?> beanType = ClassUtils.getUserClass(this.applicationContext.getType(beanName, false));
		Supplier<Object> beanSupplier = () -> this.applicationContext.getBean(beanName);
		return new EndpointBean(this.applicationContext.getEnvironment(), beanName, beanType, beanSupplier);
	}
	private void addExtensionBeans(Collection<EndpointBean> endpointBeans) {
		Map<EndpointId, EndpointBean> byId = endpointBeans.stream()
			.collect(Collectors.toMap(EndpointBean::getId, Function.identity()));
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(this.applicationContext,
				EndpointExtension.class);
		for (String beanName : beanNames) {
			ExtensionBean extensionBean = createExtensionBean(beanName);
			EndpointBean endpointBean = byId.get(extensionBean.getEndpointId());
			Assert.state(endpointBean != null, () -> ('Invalid extension "' + extensionBean.getBeanName()
					+ '": no endpoint found with id "' + extensionBean.getEndpointId() + '"'));
			addExtensionBean(endpointBean, extensionBean);
		}
	}
	private ExtensionBean createExtensionBean(String beanName) {
		Class<?> beanType = ClassUtils.getUserClass(this.applicationContext.getType(beanName));
		Supplier<Object> beanSupplier = () -> this.applicationContext.getBean(beanName);
		return new ExtensionBean(this.applicationContext.getEnvironment(), beanName, beanType, beanSupplier);
	}
	private void addExtensionBean(EndpointBean endpointBean, ExtensionBean extensionBean) {
		if (isExtensionExposed(endpointBean, extensionBean)) {
			Assert.state(isEndpointExposed(endpointBean) || isEndpointFiltered(endpointBean),
					() -> 'Endpoint bean "' + endpointBean.getBeanName() + '" cannot support the extension bean "'
							+ extensionBean.getBeanName() + '"');
			endpointBean.addExtension(extensionBean);
		}
	}
	private Collection<E> convertToEndpoints(Collection<EndpointBean> endpointBeans) {
		Set<E> endpoints = new LinkedHashSet<>();
		for (EndpointBean endpointBean : endpointBeans) {
			if (isEndpointExposed(endpointBean)) {
				E endpoint = convertToEndpoint(endpointBean);
				if (isInvocable(endpoint)) {
					endpoints.add(endpoint);
				}
			}
		}
		return Collections.unmodifiableSet(endpoints);
	}
	/**
	 * Returns whether the endpoint is invocable and should be included in the discovered
	 * endpoints. The default implementation returns {@code true} if the endpoint has any
	 * operations, otherwise {@code false}.
	 * @param endpoint the endpoint to assess
	 * @return {@code true} if the endpoint is invocable, otherwise {@code false}.
	 * @since 3.4.0
	 */
	protected boolean isInvocable(E endpoint) {
		return !endpoint.getOperations().isEmpty();
	}
	private E convertToEndpoint(EndpointBean endpointBean) {
		MultiValueMap<OperationKey, O> indexed = new LinkedMultiValueMap<>();
		EndpointId id = endpointBean.getId();
		addOperations(indexed, id, endpointBean.getDefaultAccess(), endpointBean.getBean(), false);
		if (endpointBean.getExtensions().size() > 1) {
			String extensionBeans = endpointBean.getExtensions()
				.stream()
				.map(ExtensionBean::getBeanName)
				.collect(Collectors.joining(', '));
			throw new IllegalStateException('Found multiple extensions for the endpoint bean '
					+ endpointBean.getBeanName() + ' (' + extensionBeans + ')');
		}
		for (ExtensionBean extensionBean : endpointBean.getExtensions()) {
			addOperations(indexed, id, endpointBean.getDefaultAccess(), extensionBean.getBean(), true);
		}
		assertNoDuplicateOperations(endpointBean, indexed);
		List<O> operations = indexed.values().stream().map(this::getLast).filter(Objects::nonNull).toList();
		return createEndpoint(endpointBean.getBean(), id, endpointBean.getDefaultAccess(), operations);
	}
	private void addOperations(MultiValueMap<OperationKey, O> indexed, EndpointId id, Access defaultAccess,
			Object target, boolean replaceLast) {
		Set<OperationKey> replacedLast = new HashSet<>();
		Collection<O> operations = this.operationsFactory.createOperations(id, target);
		for (O operation : operations) {
			if (!isOperationFiltered(operation, id, defaultAccess)) {
				OperationKey key = createOperationKey(operation);
				O last = getLast(indexed.get(key));
				if (replaceLast && replacedLast.add(key) && last != null) {
					indexed.get(key).remove(last);
				}
				indexed.add(key, operation);
			}
		}
	}
	private <T> T getLast(List<T> list) {
		return CollectionUtils.isEmpty(list) ? null : list.get(list.size() - 1);
	}
	private void assertNoDuplicateOperations(EndpointBean endpointBean, MultiValueMap<OperationKey, O> indexed) {
		List<OperationKey> duplicates = indexed.entrySet()
			.stream()
			.filter((entry) -> entry.getValue().size() > 1)
			.map(Map.Entry::getKey)
			.toList();
		if (!duplicates.isEmpty()) {
			Set<ExtensionBean> extensions = endpointBean.getExtensions();
			String extensionBeanNames = extensions.stream()
				.map(ExtensionBean::getBeanName)
				.collect(Collectors.joining(', '));
			throw new IllegalStateException('Unable to map duplicate endpoint operations: ' + duplicates + ' to '
					+ endpointBean.getBeanName() + (extensions.isEmpty() ? '' : ' (' + extensionBeanNames + ')'));
		}
	}
	private boolean isExtensionExposed(EndpointBean endpointBean, ExtensionBean extensionBean) {
		return isFilterMatch(extensionBean.getFilter(), endpointBean)
				&& isExtensionTypeExposed(extensionBean.getBeanType());
	}
	/**
	 * Determine if an extension bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param extensionBeanType the extension bean type
	 * @return {@code true} if the extension is exposed
	 */
	protected boolean isExtensionTypeExposed(Class<?> extensionBeanType) {
		return true;
	}
	private boolean isEndpointExposed(EndpointBean endpointBean) {
		return isFilterMatch(endpointBean.getFilter(), endpointBean) && !isEndpointFiltered(endpointBean)
				&& isEndpointTypeExposed(endpointBean.getBeanType());
	}
	/**
	 * Determine if an endpoint bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param beanType the endpoint bean type
	 * @return {@code true} if the endpoint is exposed
	 */
	protected boolean isEndpointTypeExposed(Class<?> beanType) {
		return true;
	}
	private boolean isEndpointFiltered(EndpointBean endpointBean) {
		for (EndpointFilter<E> filter : this.endpointFilters) {
			if (!isFilterMatch(filter, endpointBean)) {
				return true;
			}
		}
		return false;
	}
	@SuppressWarnings('unchecked')
	private boolean isFilterMatch(Class<?> filter, EndpointBean endpointBean) {
		if (!isEndpointTypeExposed(endpointBean.getBeanType())) {
			return false;
		}
		if (filter == null) {
			return true;
		}
		E endpoint = getFilterEndpoint(endpointBean);
		Class<?> generic = ResolvableType.forClass(EndpointFilter.class, filter).resolveGeneric(0);
		if (generic == null || generic.isInstance(endpoint)) {
			EndpointFilter<E> instance = (EndpointFilter<E>) BeanUtils.instantiateClass(filter);
			return isFilterMatch(instance, endpoint);
		}
		return false;
	}
	private boolean isFilterMatch(EndpointFilter<E> filter, EndpointBean endpointBean) {
		return isFilterMatch(filter, getFilterEndpoint(endpointBean));
	}
	@SuppressWarnings('unchecked')
	private boolean isFilterMatch(EndpointFilter<E> filter, E endpoint) {
		return LambdaSafe.callback(EndpointFilter.class, filter, endpoint)
			.withLogger(EndpointDiscoverer.class)
			.invokeAnd((f) -> f.match(endpoint))
			.get();
	}
	private boolean isOperationFiltered(Operation operation, EndpointId endpointId, Access defaultAccess) {
		for (OperationFilter<O> filter : this.operationFilters) {
			if (!isFilterMatch(filter, operation, endpointId, defaultAccess)) {
				return true;
			}
		}
		return false;
	}
	@SuppressWarnings('unchecked')
	private boolean isFilterMatch(OperationFilter<O> filter, Operation operation, EndpointId endpointId,
			Access defaultAccess) {
		return LambdaSafe.callback(OperationFilter.class, filter, operation)
			.withLogger(EndpointDiscoverer.class)
			.invokeAnd((f) -> f.match(operation, endpointId, defaultAccess))
			.get();
	}
	private E getFilterEndpoint(EndpointBean endpointBean) {
		return this.filterEndpoints.computeIfAbsent(endpointBean, (key) -> createEndpoint(endpointBean.getBean(),
				endpointBean.getId(), endpointBean.getDefaultAccess(), Collections.emptySet()));
	}
	@SuppressWarnings('unchecked')
	protected Class<? extends E> getEndpointType() {
		return (Class<? extends E>) ResolvableType.forClass(EndpointDiscoverer.class, getClass()).resolveGeneric(0);
	}
	/**
	 * Factory method called to create the {@link ExposableEndpoint endpoint}.
	 * @param endpointBean the source endpoint bean
	 * @param id the ID of the endpoint
	 * @param enabledByDefault if the endpoint is enabled by default
	 * @param operations the endpoint operations
	 * @return a created endpoint (a {@link DiscoveredEndpoint} is recommended)
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #createEndpoint(Object, EndpointId, Access, Collection)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	protected E createEndpoint(Object endpointBean, EndpointId id, boolean enabledByDefault, Collection<O> operations) {
		return createEndpoint(endpointBean, id, (enabledByDefault) ? Access.UNRESTRICTED : Access.NONE, operations);
	}
	/**
	 * Factory method called to create the {@link ExposableEndpoint endpoint}.
	 * @param endpointBean the source endpoint bean
	 * @param id the ID of the endpoint
	 * @param defaultAccess access to the endpoint that is permitted by default
	 * @param operations the endpoint operations
	 * @return a created endpoint (a {@link DiscoveredEndpoint} is recommended)
	 */
	protected abstract E createEndpoint(Object endpointBean, EndpointId id, Access defaultAccess,
			Collection<O> operations);
	/**
	 * Factory method to create an {@link Operation endpoint operation}.
	 * @param endpointId the endpoint id
	 * @param operationMethod the operation method
	 * @param invoker the invoker to use
	 * @return a created operation
	 */
	protected abstract O createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
			OperationInvoker invoker);
	/**
	 * Create an {@link OperationKey} for the given operation.
	 * @param operation the source operation
	 * @return the operation key
	 */
	protected abstract OperationKey createOperationKey(O operation);
	/**
	 * A key generated for an {@link Operation} based on specific criteria from the actual
	 * operation implementation.
	 */
	protected static final class OperationKey {
		private final Object key;
		private final Supplier<String> description;
		/**
		 * Create a new {@link OperationKey} instance.
		 * @param key the underlying key for the operation
		 * @param description a human-readable description of the key
		 */
		public OperationKey(Object key, Supplier<String> description) {
			Assert.notNull(key, 'Key must not be null');
			Assert.notNull(description, 'Description must not be null');
			this.key = key;
			this.description = description;
		}
		@Override
		public boolean equals(Object obj) {
			if (obj == this) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.key.equals(((OperationKey) obj).key);
		}
		@Override
		public int hashCode() {
			return this.key.hashCode();
		}
		@Override
		public String toString() {
			return this.description.get();
		}
	}
	/**
	 * Information about an {@link Endpoint @Endpoint} bean.
	 */
	private static class EndpointBean {
		private final String beanName;
		private final Class<?> beanType;
		private final Supplier<Object> beanSupplier;
		private final EndpointId id;
		private final Access defaultAccess;
		private final Class<?> filter;
		private final Set<ExtensionBean> extensions = new LinkedHashSet<>();
		EndpointBean(Environment environment, String beanName, Class<?> beanType, Supplier<Object> beanSupplier) {
			MergedAnnotation<Endpoint> annotation = MergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY)
				.get(Endpoint.class);
			String id = annotation.getString('id');
			Assert.state(StringUtils.hasText(id),
					() -> 'No @Endpoint id attribute specified for ' + beanType.getName());
			this.beanName = beanName;
			this.beanType = beanType;
			this.beanSupplier = beanSupplier;
			this.id = EndpointId.of(environment, id);
			boolean enabledByDefault = annotation.getBoolean('enableByDefault');
			this.defaultAccess = enabledByDefault ? annotation.getEnum('defaultAccess', Access.class) : Access.NONE;
			this.filter = getFilter(beanType);
		}
		void addExtension(ExtensionBean extensionBean) {
			this.extensions.add(extensionBean);
		}
		Set<ExtensionBean> getExtensions() {
			return this.extensions;
		}
		private Class<?> getFilter(Class<?> type) {
			return MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY)
				.get(FilteredEndpoint.class)
				.getValue(MergedAnnotation.VALUE, Class.class)
				.orElse(null);
		}
		String getBeanName() {
			return this.beanName;
		}
		Class<?> getBeanType() {
			return this.beanType;
		}
		Object getBean() {
			return this.beanSupplier.get();
		}
		EndpointId getId() {
			return this.id;
		}
		Access getDefaultAccess() {
			return this.defaultAccess;
		}
		Class<?> getFilter() {
			return this.filter;
		}
	}
	/**
	 * Information about an {@link EndpointExtension @EndpointExtension} bean.
	 */
	private static class ExtensionBean {
		private final String beanName;
		private final Class<?> beanType;
		private final Supplier<Object> beanSupplier;
		private final EndpointId endpointId;
		private final Class<?> filter;
		ExtensionBean(Environment environment, String beanName, Class<?> beanType, Supplier<Object> beanSupplier) {
			this.beanName = beanName;
			this.beanType = beanType;
			this.beanSupplier = beanSupplier;
			MergedAnnotation<EndpointExtension> extensionAnnotation = MergedAnnotations
				.from(beanType, SearchStrategy.TYPE_HIERARCHY)
				.get(EndpointExtension.class);
			Class<?> endpointType = extensionAnnotation.getClass('endpoint');
			MergedAnnotation<Endpoint> endpointAnnotation = MergedAnnotations
				.from(endpointType, SearchStrategy.TYPE_HIERARCHY)
				.get(Endpoint.class);
			Assert.state(endpointAnnotation.isPresent(),
					() -> 'Extension ' + endpointType.getName() + ' does not specify an endpoint');
			this.endpointId = EndpointId.of(environment, endpointAnnotation.getString('id'));
			this.filter = extensionAnnotation.getClass('filter');
		}
		String getBeanName() {
			return this.beanName;
		}
		Class<?> getBeanType() {
			return this.beanType;
		}
		Object getBean() {
			return this.beanSupplier.get();
		}
		EndpointId getEndpointId() {
			return this.endpointId;
		}
		Class<?> getFilter() {
			return this.filter;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.annotation;
/**
class OperationReflectiveProcessor extends SimpleReflectiveProcessor {
	private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
	@Override
	protected void registerMethodHint(ReflectionHints hints, Method method) {
		super.registerMethodHint(hints, method);
		Type returnType = extractReturnType(method);
		if (returnType != null) {
			registerReflectionHints(hints, returnType);
		}
	}
	private Type extractReturnType(Method method) {
		ResolvableType returnType = ResolvableType.forMethodReturnType(method);
		if (!WebEndpointResponse.class.isAssignableFrom(method.getReturnType())) {
			return returnType.getType();
		}
		return returnType.as(WebEndpointResponse.class).getGeneric(0).getType();
	}
	private void registerReflectionHints(ReflectionHints hints, Type type) {
		if (!type.equals(Resource.class)) {
			this.bindingRegistrar.registerReflectionHints(hints, type);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.annotation;
/*
package org.springframework.boot.actuate.endpoint;
/**
class OperationResponseBodyMap<K, V> extends LinkedHashMap<K, V> implements OperationResponseBody {
	OperationResponseBodyMap(Map<? extends K, ? extends V> map) {
		super(map);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public final class WebOperationRequestPredicate {
	private static final Pattern PATH_VAR_PATTERN = Pattern.compile('(\\{\\*?).+?}');
	private static final Pattern ALL_REMAINING_PATH_SEGMENTS_VAR_PATTERN = Pattern.compile('^.*\\{\\*(.+?)}$');
	private final String path;
	private final String matchAllRemainingPathSegmentsVariable;
	private final String canonicalPath;
	private final WebEndpointHttpMethod httpMethod;
	private final Collection<String> consumes;
	private final Collection<String> produces;
	/**
	 * Creates a new {@code OperationRequestPredicate}.
	 * @param path the path for the operation
	 * @param httpMethod the HTTP method that the operation supports
	 * @param produces the media types that the operation produces
	 * @param consumes the media types that the operation consumes
	 */
	public WebOperationRequestPredicate(String path, WebEndpointHttpMethod httpMethod, Collection<String> consumes,
			Collection<String> produces) {
		this.path = path;
		this.canonicalPath = extractCanonicalPath(path);
		this.matchAllRemainingPathSegmentsVariable = extractMatchAllRemainingPathSegmentsVariable(path);
		this.httpMethod = httpMethod;
		this.consumes = consumes;
		this.produces = produces;
	}
	private String extractCanonicalPath(String path) {
		Matcher matcher = PATH_VAR_PATTERN.matcher(path);
		return matcher.replaceAll('$1*}');
	}
	private String extractMatchAllRemainingPathSegmentsVariable(String path) {
		Matcher matcher = ALL_REMAINING_PATH_SEGMENTS_VAR_PATTERN.matcher(path);
		return matcher.matches() ? matcher.group(1) : null;
	}
	/**
	 * Returns the path for the operation.
	 * @return the path
	 */
	public String getPath() {
		return this.path;
	}
	/**
	 * Returns the name of the variable used to catch all remaining path segments
	 * {@code null}.
	 * @return the variable name
	 * @since 2.2.0
	 */
	public String getMatchAllRemainingPathSegmentsVariable() {
		return this.matchAllRemainingPathSegmentsVariable;
	}
	/**
	 * Returns the HTTP method for the operation.
	 * @return the HTTP method
	 */
	public WebEndpointHttpMethod getHttpMethod() {
		return this.httpMethod;
	}
	/**
	 * Returns the media types that the operation consumes.
	 * @return the consumed media types
	 */
	public Collection<String> getConsumes() {
		return Collections.unmodifiableCollection(this.consumes);
	}
	/**
	 * Returns the media types that the operation produces.
	 * @return the produced media types
	 */
	public Collection<String> getProduces() {
		return Collections.unmodifiableCollection(this.produces);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		WebOperationRequestPredicate other = (WebOperationRequestPredicate) obj;
		boolean result = true;
		result = result && this.consumes.equals(other.consumes);
		result = result && this.httpMethod == other.httpMethod;
		result = result && this.canonicalPath.equals(other.canonicalPath);
		result = result && this.produces.equals(other.produces);
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.consumes.hashCode();
		result = prime * result + this.httpMethod.hashCode();
		result = prime * result + this.canonicalPath.hashCode();
		result = prime * result + this.produces.hashCode();
		return result;
	}
	@Override
	public String toString() {
		StringBuilder result = new StringBuilder(this.httpMethod + ' to path "' + this.path + '"');
		if (!CollectionUtils.isEmpty(this.consumes)) {
			result.append(' consumes: ').append(StringUtils.collectionToCommaDelimitedString(this.consumes));
		}
		if (!CollectionUtils.isEmpty(this.produces)) {
			result.append(' produces: ').append(StringUtils.collectionToCommaDelimitedString(this.produces));
		}
		return result.toString();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public class EndpointMapping {
	private final String path;
	/**
	 * Creates a new {@code EndpointMapping} using the given {@code path}.
	 * @param path the path
	 */
	public EndpointMapping(String path) {
		this.path = normalizePath(path);
	}
	/**
	 * Returns the path to which endpoints should be mapped.
	 * @return the path
	 */
	public String getPath() {
		return this.path;
	}
	public String createSubPath(String path) {
		return this.path + normalizePath(path);
	}
	private static String normalizePath(String path) {
		if (!StringUtils.hasText(path)) {
			return path;
		}
		String normalizedPath = path;
		if (!normalizedPath.startsWith('/')) {
			normalizedPath = '/' + normalizedPath;
		}
		if (normalizedPath.endsWith('/')) {
			normalizedPath = normalizedPath.substring(0, normalizedPath.length() - 1);
		}
		return normalizedPath;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
@SuppressWarnings('removal')
public interface ExposableServletEndpoint extends ExposableEndpoint<Operation>, PathMappedEndpoint {
	/**
	 * Return details of the servlet that should be registered.
	 * @return the endpoint servlet
	 */
	EndpointServlet getEndpointServlet();
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
@SuppressWarnings('removal')
public class ServletEndpointRegistrar implements ServletContextInitializer {
	private static final Set<String> READ_ONLY_ACCESS_REQUEST_METHODS = Set.of('GET', 'HEAD');
	private static final Log logger = LogFactory.getLog(ServletEndpointRegistrar.class);
	private final String basePath;
	private final Collection<ExposableServletEndpoint> servletEndpoints;
	private final EndpointAccessResolver endpointAccessResolver;
	public ServletEndpointRegistrar(String basePath, Collection<ExposableServletEndpoint> servletEndpoints) {
		this(basePath, servletEndpoints, (endpointId, defaultAccess) -> Access.NONE);
	}
	public ServletEndpointRegistrar(String basePath, Collection<ExposableServletEndpoint> servletEndpoints,
			EndpointAccessResolver endpointAccessResolver) {
		Assert.notNull(servletEndpoints, 'ServletEndpoints must not be null');
		this.basePath = cleanBasePath(basePath);
		this.servletEndpoints = servletEndpoints;
		this.endpointAccessResolver = endpointAccessResolver;
	}
	private static String cleanBasePath(String basePath) {
		if (StringUtils.hasText(basePath) && basePath.endsWith('/')) {
			return basePath.substring(0, basePath.length() - 1);
		}
		return (basePath != null) ? basePath : '';
	}
	@Override
	public void onStartup(ServletContext servletContext) throws ServletException {
		this.servletEndpoints.forEach((servletEndpoint) -> register(servletContext, servletEndpoint));
	}
	private void register(ServletContext servletContext, ExposableServletEndpoint endpoint) {
		Access access = this.endpointAccessResolver.accessFor(endpoint.getEndpointId(), endpoint.getDefaultAccess());
		if (access == Access.NONE) {
			return;
		}
		String name = endpoint.getEndpointId().toLowerCaseString() + '-actuator-endpoint';
		String path = this.basePath + '/' + endpoint.getRootPath();
		String urlMapping = path.endsWith('/') ? path + '*' : path + '/*';
		EndpointServlet endpointServlet = endpoint.getEndpointServlet();
		Dynamic registration = servletContext.addServlet(name, endpointServlet.getServlet());
		registration.addMapping(urlMapping);
		registration.setInitParameters(endpointServlet.getInitParameters());
		registration.setLoadOnStartup(endpointServlet.getLoadOnStartup());
		if (access == Access.READ_ONLY) {
			servletContext.addFilter(name + '-access-filter', new ReadOnlyAccessFilter())
				.addMappingForServletNames(EnumSet.allOf(DispatcherType.class), false, name);
		}
		logger.info('Registered "' + path + '" to ' + name);
	}
	static class ReadOnlyAccessFilter implements Filter {
		private static final int METHOD_NOT_ALLOWED = 405;
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
				throws IOException, ServletException {
			if (request instanceof HttpServletRequest httpRequest
					&& response instanceof HttpServletResponse httpResponse) {
				doFilter(httpRequest, httpResponse, chain);
			}
			else {
				throw new ServletException();
			}
		}
		private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
				throws IOException, ServletException {
			if (isReadOnlyAccessMethod(request)) {
				chain.doFilter(request, response);
			}
			else {
				response.sendError(METHOD_NOT_ALLOWED);
			}
		}
		private boolean isReadOnlyAccessMethod(HttpServletRequest request) {
			return READ_ONLY_ACCESS_REQUEST_METHODS.contains(request.getMethod().toUpperCase(Locale.ROOT));
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@SuppressWarnings('removal')
class ServletEndpointFilter extends DiscovererEndpointFilter {
	ServletEndpointFilter() {
		super(ServletEndpointDiscoverer.class);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Endpoint
@FilteredEndpoint(ControllerEndpointFilter.class)
@Deprecated(since = '3.3.0', forRemoval = true)
public @interface ControllerEndpoint {
	/**
	 * The id of the endpoint.
	 * @return the id
	 */
	@AliasFor(annotation = Endpoint.class)
	String id();
	/**
	 * If the endpoint should be enabled or disabled by default.
	 * @return {@code true} if the endpoint is enabled by default
	 */
	@AliasFor(annotation = Endpoint.class)
	boolean enableByDefault() default true;
	/**
	 * Level of access to the endpoint that is permitted by default.
	 * @return the default level of access
	 * @since 3.4.0
	 */
	@AliasFor(annotation = Endpoint.class)
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
class WebEndpointFilter extends DiscovererEndpointFilter {
	WebEndpointFilter() {
		super(WebEndpointDiscoverer.class);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
class DiscoveredWebEndpoint extends AbstractDiscoveredEndpoint<WebOperation> implements ExposableWebEndpoint {
	private final String rootPath;
	private Collection<AdditionalPathsMapper> additionalPathsMappers;
	DiscoveredWebEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id, String rootPath,
			Access defaultAccess, Collection<WebOperation> operations,
			Collection<AdditionalPathsMapper> additionalPathsMappers) {
		super(discoverer, endpointBean, id, defaultAccess, operations);
		this.rootPath = rootPath;
		this.additionalPathsMappers = additionalPathsMappers;
	}
	@Override
	public String getRootPath() {
		return this.rootPath;
	}
	@Override
	public List<String> getAdditionalPaths(WebServerNamespace webServerNamespace) {
		return this.additionalPathsMappers.stream()
			.flatMap((mapper) -> getAdditionalPaths(webServerNamespace, mapper))
			.toList();
	}
	private Stream<String> getAdditionalPaths(WebServerNamespace webServerNamespace, AdditionalPathsMapper mapper) {
		return mapper.getAdditionalPaths(getEndpointId(), webServerNamespace).stream();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Endpoint
@FilteredEndpoint(WebEndpointFilter.class)
public @interface WebEndpoint {
	/**
	 * The id of the endpoint.
	 * @return the id
	 */
	@AliasFor(annotation = Endpoint.class)
	String id();
	/**
	 * If the endpoint should be enabled or disabled by default.
	 * @return {@code true} if the endpoint is enabled by default
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	@AliasFor(annotation = Endpoint.class)
	boolean enableByDefault() default true;
	/**
	 * Level of access to the endpoint that is permitted by default.
	 * @return the default level of access
	 * @since 3.4.0
	 */
	@AliasFor(annotation = Endpoint.class)
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@SuppressWarnings('removal')
class DiscoveredControllerEndpoint extends AbstractDiscoveredEndpoint<Operation>
		implements ExposableControllerEndpoint {
	private final String rootPath;
	DiscoveredControllerEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id,
			String rootPath, Access defaultAccess) {
		super(discoverer, endpointBean, id, defaultAccess, Collections.emptyList());
		this.rootPath = rootPath;
	}
	@Override
	public Object getController() {
		return getEndpointBean();
	}
	@Override
	public String getRootPath() {
		return this.rootPath;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
class DiscoveredWebOperation extends AbstractDiscoveredOperation implements WebOperation {
	private static final boolean REACTIVE_STREAMS_PRESENT = ClassUtils.isPresent('org.reactivestreams.Publisher',
			DiscoveredWebOperation.class.getClassLoader());
	private final String id;
	private final boolean blocking;
	private final WebOperationRequestPredicate requestPredicate;
	DiscoveredWebOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod, OperationInvoker invoker,
			WebOperationRequestPredicate requestPredicate) {
		super(operationMethod, invoker);
		this.id = getId(endpointId, operationMethod);
		this.blocking = getBlocking(operationMethod);
		this.requestPredicate = requestPredicate;
	}
	private String getId(EndpointId endpointId, OperationMethod method) {
		return endpointId + method.getParameters()
			.stream()
			.filter(this::hasSelector)
			.map(this::dashName)
			.collect(Collectors.joining());
	}
	private boolean hasSelector(OperationParameter parameter) {
		return parameter.getAnnotation(Selector.class) != null;
	}
	private String dashName(OperationParameter parameter) {
		return '-' + parameter.getName();
	}
	private boolean getBlocking(OperationMethod method) {
		return !REACTIVE_STREAMS_PRESENT || !Publisher.class.isAssignableFrom(method.getMethod().getReturnType());
	}
	@Override
	public String getId() {
		return this.id;
	}
	@Override
	public boolean isBlocking() {
		return this.blocking;
	}
	@Override
	public WebOperationRequestPredicate getRequestPredicate() {
		return this.requestPredicate;
	}
	@Override
	protected void appendFields(ToStringCreator creator) {
		creator.append('id', this.id)
			.append('blocking', this.blocking)
			.append('requestPredicate', this.requestPredicate);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Endpoint
@FilteredEndpoint(ServletEndpointFilter.class)
@Deprecated(since = '3.3.0', forRemoval = true)
public @interface ServletEndpoint {
	/**
	 * The id of the endpoint.
	 * @return the id
	 */
	@AliasFor(annotation = Endpoint.class)
	String id();
	/**
	 * If the endpoint should be enabled or disabled by default.
	 * @return {@code true} if the endpoint is enabled by default
	 */
	@AliasFor(annotation = Endpoint.class)
	boolean enableByDefault() default true;
	/**
	 * Level of access to the endpoint that is permitted by default.
	 * @return the default level of access
	 * @since 3.4.0
	 */
	@AliasFor(annotation = Endpoint.class)
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@EndpointExtension(filter = WebEndpointFilter.class)
public @interface EndpointWebExtension {
	/**
	 * The {@link Endpoint endpoint} class to which this Web extension relates.
	 * @return the endpoint class
	 */
	@AliasFor(annotation = EndpointExtension.class)
	Class<?> endpoint();
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@FunctionalInterface
@Deprecated(since = '3.3.3', forRemoval = true)
@SuppressWarnings('removal')
public interface ControllerEndpointsSupplier extends EndpointsSupplier<ExposableControllerEndpoint> {
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@FunctionalInterface
@Deprecated(since = '3.3.0', forRemoval = true)
@SuppressWarnings('removal')
public interface ServletEndpointsSupplier extends EndpointsSupplier<ExposableServletEndpoint> {
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@ImportRuntimeHints(WebEndpointDiscovererRuntimeHints.class)
public class WebEndpointDiscoverer extends EndpointDiscoverer<ExposableWebEndpoint, WebOperation>
		implements WebEndpointsSupplier {
	private final List<PathMapper> endpointPathMappers;
	private final List<AdditionalPathsMapper> additionalPathsMappers;
	private final RequestPredicateFactory requestPredicateFactory;
	/**
	 * Create a new {@link WebEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param endpointMediaTypes the endpoint media types
	 * @param endpointPathMappers the endpoint path mappers
	 * @param invokerAdvisors invoker advisors to apply
	 * @param filters filters to apply
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #WebEndpointDiscoverer(ApplicationContext, ParameterValueMapper, EndpointMediaTypes, List, List, Collection, Collection, Collection)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public WebEndpointDiscoverer(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
			EndpointMediaTypes endpointMediaTypes, List<PathMapper> endpointPathMappers,
			Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<ExposableWebEndpoint>> filters) {
		this(applicationContext, parameterValueMapper, endpointMediaTypes, endpointPathMappers, Collections.emptyList(),
				invokerAdvisors, filters, Collections.emptyList());
	}
	/**
	 * Create a new {@link WebEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param endpointMediaTypes the endpoint media types
	 * @param endpointPathMappers the endpoint path mappers
	 * @param additionalPathsMappers the
	 * @param invokerAdvisors invoker advisors to apply
	 * @param endpointFilters endpoint filters to apply
	 * @param operationFilters operation filters to apply
	 * @since 3.4.0
	 */
	public WebEndpointDiscoverer(ApplicationContext applicationContext, ParameterValueMapper parameterValueMapper,
			EndpointMediaTypes endpointMediaTypes, List<PathMapper> endpointPathMappers,
			List<AdditionalPathsMapper> additionalPathsMappers, Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<ExposableWebEndpoint>> endpointFilters,
			Collection<OperationFilter<WebOperation>> operationFilters) {
		super(applicationContext, parameterValueMapper, invokerAdvisors, endpointFilters, operationFilters);
		this.endpointPathMappers = (endpointPathMappers != null) ? endpointPathMappers : Collections.emptyList();
		this.additionalPathsMappers = (additionalPathsMappers != null) ? additionalPathsMappers
				: Collections.emptyList();
		this.requestPredicateFactory = new RequestPredicateFactory(endpointMediaTypes);
	}
	@Override
	protected ExposableWebEndpoint createEndpoint(Object endpointBean, EndpointId id, Access defaultAccess,
			Collection<WebOperation> operations) {
		String rootPath = PathMapper.getRootPath(this.endpointPathMappers, id);
		return new DiscoveredWebEndpoint(this, endpointBean, id, rootPath, defaultAccess, operations,
				this.additionalPathsMappers);
	}
	@Override
	protected WebOperation createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
			OperationInvoker invoker) {
		String rootPath = PathMapper.getRootPath(this.endpointPathMappers, endpointId);
		WebOperationRequestPredicate requestPredicate = this.requestPredicateFactory.getRequestPredicate(rootPath,
				operationMethod);
		return new DiscoveredWebOperation(endpointId, operationMethod, invoker, requestPredicate);
	}
	@Override
	protected OperationKey createOperationKey(WebOperation operation) {
		return new OperationKey(operation.getRequestPredicate(),
				() -> 'web request predicate ' + operation.getRequestPredicate());
	}
	static class WebEndpointDiscovererRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection().registerType(WebEndpointFilter.class, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@ImportRuntimeHints(ServletEndpointDiscoverer.ServletEndpointDiscovererRuntimeHints.class)
@Deprecated(since = '3.3.0', forRemoval = true)
@SuppressWarnings('removal')
public class ServletEndpointDiscoverer extends EndpointDiscoverer<ExposableServletEndpoint, Operation>
		implements ServletEndpointsSupplier {
	private final List<PathMapper> endpointPathMappers;
	/**
	 * Create a new {@link ServletEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param endpointPathMappers the endpoint path mappers
	 * @param filters filters to apply
	 */
	public ServletEndpointDiscoverer(ApplicationContext applicationContext, List<PathMapper> endpointPathMappers,
			Collection<EndpointFilter<ExposableServletEndpoint>> filters) {
		super(applicationContext, ParameterValueMapper.NONE, Collections.emptyList(), filters, Collections.emptyList());
		this.endpointPathMappers = endpointPathMappers;
	}
	@Override
	protected boolean isEndpointTypeExposed(Class<?> beanType) {
		return MergedAnnotations.from(beanType, SearchStrategy.SUPERCLASS).isPresent(ServletEndpoint.class);
	}
	@Override
	protected ExposableServletEndpoint createEndpoint(Object endpointBean, EndpointId id, Access defaultAccess,
			Collection<Operation> operations) {
		String rootPath = PathMapper.getRootPath(this.endpointPathMappers, id);
		return new DiscoveredServletEndpoint(this, endpointBean, id, rootPath, defaultAccess);
	}
	@Override
	protected Operation createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
			OperationInvoker invoker) {
		throw new IllegalStateException('ServletEndpoints must not declare operations');
	}
	@Override
	protected OperationKey createOperationKey(Operation operation) {
		throw new IllegalStateException('ServletEndpoints must not declare operations');
	}
	@Override
	protected boolean isInvocable(ExposableServletEndpoint endpoint) {
		return true;
	}
	static class ServletEndpointDiscovererRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection().registerType(ServletEndpointFilter.class, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@Deprecated(since = '3.3.3', forRemoval = true)
public interface ExposableControllerEndpoint extends ExposableEndpoint<Operation>, PathMappedEndpoint {
	/**
	 * Return the source controller that contains {@link RequestMapping @RequestMapping}
	 * methods.
	 * @return the source controller
	 */
	Object getController();
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@SuppressWarnings('removal')
class ControllerEndpointFilter extends DiscovererEndpointFilter {
	ControllerEndpointFilter() {
		super(ControllerEndpointDiscoverer.class);
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@SuppressWarnings('removal')
class DiscoveredServletEndpoint extends AbstractDiscoveredEndpoint<Operation> implements ExposableServletEndpoint {
	private final String rootPath;
	private final EndpointServlet endpointServlet;
	DiscoveredServletEndpoint(EndpointDiscoverer<?, ?> discoverer, Object endpointBean, EndpointId id, String rootPath,
			Access defaultAccess) {
		super(discoverer, endpointBean, id, defaultAccess, Collections.emptyList());
		String beanType = endpointBean.getClass().getName();
		Assert.state(endpointBean instanceof Supplier,
				() -> 'ServletEndpoint bean ' + beanType + ' must be a supplier');
		Object supplied = ((Supplier<?>) endpointBean).get();
		Assert.state(supplied != null, () -> 'ServletEndpoint bean ' + beanType + ' must not supply null');
		Assert.state(supplied instanceof EndpointServlet,
				() -> 'ServletEndpoint bean ' + beanType + ' must supply an EndpointServlet');
		this.endpointServlet = (EndpointServlet) supplied;
		this.rootPath = rootPath;
	}
	@Override
	public String getRootPath() {
		return this.rootPath;
	}
	@Override
	public EndpointServlet getEndpointServlet() {
		return this.endpointServlet;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@ImportRuntimeHints(ControllerEndpointDiscoverer.ControllerEndpointDiscovererRuntimeHints.class)
@Deprecated(since = '3.3.0', forRemoval = true)
@SuppressWarnings('removal')
public class ControllerEndpointDiscoverer extends EndpointDiscoverer<ExposableControllerEndpoint, Operation>
		implements ControllerEndpointsSupplier {
	private final List<PathMapper> endpointPathMappers;
	/**
	 * Create a new {@link ControllerEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param endpointPathMappers the endpoint path mappers
	 * @param filters filters to apply
	 */
	public ControllerEndpointDiscoverer(ApplicationContext applicationContext, List<PathMapper> endpointPathMappers,
			Collection<EndpointFilter<ExposableControllerEndpoint>> filters) {
		super(applicationContext, ParameterValueMapper.NONE, Collections.emptyList(), filters, Collections.emptyList());
		this.endpointPathMappers = endpointPathMappers;
	}
	@Override
	protected boolean isEndpointTypeExposed(Class<?> beanType) {
		MergedAnnotations annotations = MergedAnnotations.from(beanType, SearchStrategy.SUPERCLASS);
		return annotations.isPresent(ControllerEndpoint.class) || annotations.isPresent(RestControllerEndpoint.class);
	}
	@Override
	protected ExposableControllerEndpoint createEndpoint(Object endpointBean, EndpointId id, Access defaultAccess,
			Collection<Operation> operations) {
		String rootPath = PathMapper.getRootPath(this.endpointPathMappers, id);
		return new DiscoveredControllerEndpoint(this, endpointBean, id, rootPath, defaultAccess);
	}
	@Override
	protected Operation createOperation(EndpointId endpointId, DiscoveredOperationMethod operationMethod,
			OperationInvoker invoker) {
		throw new IllegalStateException('ControllerEndpoints must not declare operations');
	}
	@Override
	protected OperationKey createOperationKey(Operation operation) {
		throw new IllegalStateException('ControllerEndpoints must not declare operations');
	}
	@Override
	protected boolean isInvocable(ExposableControllerEndpoint endpoint) {
		return true;
	}
	static class ControllerEndpointDiscovererRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection()
				.registerType(ControllerEndpointFilter.class, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.web.annotation;
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
class RequestPredicateFactory {
	private final EndpointMediaTypes endpointMediaTypes;
	RequestPredicateFactory(EndpointMediaTypes endpointMediaTypes) {
		Assert.notNull(endpointMediaTypes, 'EndpointMediaTypes must not be null');
		this.endpointMediaTypes = endpointMediaTypes;
	}
	WebOperationRequestPredicate getRequestPredicate(String rootPath, DiscoveredOperationMethod operationMethod) {
		Method method = operationMethod.getMethod();
		OperationParameter[] selectorParameters = operationMethod.getParameters()
			.stream()
			.filter(this::hasSelector)
			.toArray(OperationParameter[]::new);
		OperationParameter allRemainingPathSegmentsParameter = getAllRemainingPathSegmentsParameter(selectorParameters);
		String path = getPath(rootPath, selectorParameters, allRemainingPathSegmentsParameter != null);
		WebEndpointHttpMethod httpMethod = determineHttpMethod(operationMethod.getOperationType());
		Collection<String> consumes = getConsumes(httpMethod, method);
		Collection<String> produces = getProduces(operationMethod, method);
		return new WebOperationRequestPredicate(path, httpMethod, consumes, produces);
	}
	private OperationParameter getAllRemainingPathSegmentsParameter(OperationParameter[] selectorParameters) {
		OperationParameter trailingPathsParameter = null;
		for (OperationParameter selectorParameter : selectorParameters) {
			Selector selector = selectorParameter.getAnnotation(Selector.class);
			if (selector.match() == Match.ALL_REMAINING) {
				Assert.state(trailingPathsParameter == null,
						'@Selector annotation with Match.ALL_REMAINING must be unique');
				trailingPathsParameter = selectorParameter;
			}
		}
		if (trailingPathsParameter != null) {
			Assert.state(trailingPathsParameter == selectorParameters[selectorParameters.length - 1],
					'@Selector annotation with Match.ALL_REMAINING must be the last parameter');
		}
		return trailingPathsParameter;
	}
	private String getPath(String rootPath, OperationParameter[] selectorParameters,
			boolean matchRemainingPathSegments) {
		StringBuilder path = new StringBuilder(rootPath);
		for (int i = 0; i < selectorParameters.length; i++) {
			path.append((i != 0 || !rootPath.endsWith('/')) ? '/{' : '{');
			if (i == selectorParameters.length - 1 && matchRemainingPathSegments) {
				path.append('*');
			}
			path.append(selectorParameters[i].getName());
			path.append('}');
		}
		return path.toString();
	}
	private boolean hasSelector(OperationParameter parameter) {
		return parameter.getAnnotation(Selector.class) != null;
	}
	private Collection<String> getConsumes(WebEndpointHttpMethod httpMethod, Method method) {
		if (WebEndpointHttpMethod.POST == httpMethod && consumesRequestBody(method)) {
			return this.endpointMediaTypes.getConsumed();
		}
		return Collections.emptyList();
	}
	private Collection<String> getProduces(DiscoveredOperationMethod operationMethod, Method method) {
		if (!operationMethod.getProducesMediaTypes().isEmpty()) {
			return operationMethod.getProducesMediaTypes();
		}
		if (Void.class.equals(method.getReturnType()) || void.class.equals(method.getReturnType())) {
			return Collections.emptyList();
		}
		if (producesResource(method)) {
			return Collections.singletonList('application/octet-stream');
		}
		return this.endpointMediaTypes.getProduced();
	}
	private boolean producesResource(Method method) {
		if (Resource.class.equals(method.getReturnType())) {
			return true;
		}
		if (WebEndpointResponse.class.isAssignableFrom(method.getReturnType())) {
			ResolvableType returnType = ResolvableType.forMethodReturnType(method);
			return ResolvableType.forClass(Resource.class).isAssignableFrom(returnType.getGeneric(0));
		}
		return false;
	}
	private boolean consumesRequestBody(Method method) {
		return Stream.of(method.getParameters())
			.anyMatch((parameter) -> parameter.getAnnotation(Selector.class) == null);
	}
	private WebEndpointHttpMethod determineHttpMethod(OperationType operationType) {
		if (operationType == OperationType.WRITE) {
			return WebEndpointHttpMethod.POST;
		}
		if (operationType == OperationType.DELETE) {
			return WebEndpointHttpMethod.DELETE;
		}
		return WebEndpointHttpMethod.GET;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.annotation;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Endpoint
@FilteredEndpoint(ControllerEndpointFilter.class)
@ResponseBody
@Deprecated(since = '3.3.0', forRemoval = true)
public @interface RestControllerEndpoint {
	/**
	 * The id of the endpoint.
	 * @return the id
	 */
	@AliasFor(annotation = Endpoint.class)
	String id();
	/**
	 * If the endpoint should be enabled or disabled by default.
	 * @return {@code true} if the endpoint is enabled by default
	 */
	@AliasFor(annotation = Endpoint.class)
	boolean enableByDefault() default true;
	/**
	 * Level of access to the endpoint that is permitted by default.
	 * @return the default level of access
	 * @since 3.4.0
	 */
	@AliasFor(annotation = Endpoint.class)
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public final class WebEndpointResponse<T> {
	/**
	 * {@code 200 OK}.
	 */
	public static final int STATUS_OK = 200;
	/**
	 * {@code 204 No Content}.
	 */
	public static final int STATUS_NO_CONTENT = 204;
	/**
	 * {@code 400 Bad Request}.
	 */
	public static final int STATUS_BAD_REQUEST = 400;
	/**
	 * {@code 404 Not Found}.
	 */
	public static final int STATUS_NOT_FOUND = 404;
	/**
	 * {@code 429 Too Many Requests}.
	 */
	public static final int STATUS_TOO_MANY_REQUESTS = 429;
	/**
	 * {@code 500 Internal Server Error}.
	 */
	public static final int STATUS_INTERNAL_SERVER_ERROR = 500;
	/**
	 * {@code 503 Service Unavailable}.
	 */
	public static final int STATUS_SERVICE_UNAVAILABLE = 503;
	private final T body;
	private final int status;
	private final MimeType contentType;
	/**
	 * Creates a new {@code WebEndpointResponse} with no body and a 200 (OK) status.
	 */
	public WebEndpointResponse() {
		this(null);
	}
	/**
	 * Creates a new {@code WebEndpointResponse} with no body and the given
	 * {@code status}.
	 * @param status the HTTP status
	 */
	public WebEndpointResponse(int status) {
		this(null, status);
	}
	/**
	 * Creates a new {@code WebEndpointResponse} with the given body and a 200 (OK)
	 * status.
	 * @param body the body
	 */
	public WebEndpointResponse(T body) {
		this(body, STATUS_OK);
	}
	/**
	 * Creates a new {@code WebEndpointResponse} with the given body and content type and
	 * a 200 (OK) status.
	 * @param body the body
	 * @param producible the producible providing the content type
	 * @since 2.5.0
	 */
	public WebEndpointResponse(T body, Producible<?> producible) {
		this(body, STATUS_OK, producible.getProducedMimeType());
	}
	/**
	 * Creates a new {@code WebEndpointResponse} with the given body and content type and
	 * a 200 (OK) status.
	 * @param body the body
	 * @param contentType the content type of the response
	 * @since 2.5.0
	 */
	public WebEndpointResponse(T body, MimeType contentType) {
		this(body, STATUS_OK, contentType);
	}
	/**
	 * Creates a new {@code WebEndpointResponse} with the given body and status.
	 * @param body the body
	 * @param status the HTTP status
	 */
	public WebEndpointResponse(T body, int status) {
		this(body, status, null);
	}
	/**
	 * Creates a new {@code WebEndpointResponse} with the given body and status.
	 * @param body the body
	 * @param status the HTTP status
	 * @param contentType the content type of the response
	 * @since 2.5.0
	 */
	public WebEndpointResponse(T body, int status, MimeType contentType) {
		this.body = body;
		this.status = status;
		this.contentType = contentType;
	}
	/**
	 * Returns the content type of the response.
	 * @return the content type;
	 */
	public MimeType getContentType() {
		return this.contentType;
	}
	/**
	 * Returns the body for the response.
	 * @return the body
	 */
	public T getBody() {
		return this.body;
	}
	/**
	 * Returns the status for the response.
	 * @return the status
	 */
	public int getStatus() {
		return this.status;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@FunctionalInterface
public interface WebEndpointsSupplier extends EndpointsSupplier<ExposableWebEndpoint> {
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@FunctionalInterface
public interface PathMapper {
	/**
	 * Resolve the root path for the specified {@code endpointId}.
	 * @param endpointId the id of an endpoint
	 * @return the path of the endpoint or {@code null} if this mapper doesn"t support the
	 * given endpoint ID
	 */
	String getRootPath(EndpointId endpointId);
	/**
	 * Resolve the root path for the specified {@code endpointId} from the given path
	 * mappers. If no mapper matches then the ID itself is returned.
	 * @param pathMappers the path mappers (may be {@code null})
	 * @param endpointId the id of an endpoint
	 * @return the path of the endpoint
	 */
	static String getRootPath(List<PathMapper> pathMappers, EndpointId endpointId) {
		Assert.notNull(endpointId, 'EndpointId must not be null');
		if (pathMappers != null) {
			for (PathMapper mapper : pathMappers) {
				String path = mapper.getRootPath(endpointId);
				if (StringUtils.hasText(path)) {
					return path;
				}
			}
		}
		return endpointId.toString();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public class EndpointMediaTypes {
	/**
	 * Default {@link EndpointMediaTypes} for this version of Spring Boot.
	 */
	public static final EndpointMediaTypes DEFAULT = new EndpointMediaTypes(
			ApiVersion.V3.getProducedMimeType().toString(), ApiVersion.V2.getProducedMimeType().toString(),
			'application/json');
	private final List<String> produced;
	private final List<String> consumed;
	/**
	 * Creates a new {@link EndpointMediaTypes} with the given {@code produced} and
	 * {@code consumed} media types.
	 * @param producedAndConsumed the default media types that are produced and consumed
	 * by an endpoint. Must not be {@code null}.
	 * @since 2.2.0
	 */
	public EndpointMediaTypes(String... producedAndConsumed) {
		this((producedAndConsumed != null) ? Arrays.asList(producedAndConsumed) : null);
	}
	/**
	 * Creates a new {@link EndpointMediaTypes} with the given {@code produced} and
	 * {@code consumed} media types.
	 * @param producedAndConsumed the default media types that are produced and consumed
	 * by an endpoint. Must not be {@code null}.
	 * @since 2.2.0
	 */
	public EndpointMediaTypes(List<String> producedAndConsumed) {
		this(producedAndConsumed, producedAndConsumed);
	}
	/**
	 * Creates a new {@link EndpointMediaTypes} with the given {@code produced} and
	 * {@code consumed} media types.
	 * @param produced the default media types that are produced by an endpoint. Must not
	 * be {@code null}.
	 * @param consumed the default media types that are consumed by an endpoint. Must not
	 */
	public EndpointMediaTypes(List<String> produced, List<String> consumed) {
		Assert.notNull(produced, 'Produced must not be null');
		Assert.notNull(consumed, 'Consumed must not be null');
		this.produced = Collections.unmodifiableList(produced);
		this.consumed = Collections.unmodifiableList(consumed);
	}
	/**
	 * Returns the media types produced by an endpoint.
	 * @return the produced media types
	 */
	public List<String> getProduced() {
		return this.produced;
	}
	/**
	 * Returns the media types consumed by an endpoint.
	 * @return the consumed media types
	 */
	public List<String> getConsumed() {
		return this.consumed;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public class EndpointLinksResolver {
	private static final Log logger = LogFactory.getLog(EndpointLinksResolver.class);
	private final Collection<? extends ExposableEndpoint<?>> endpoints;
	/**
	 * Creates a new {@code EndpointLinksResolver} that will resolve links to the given
	 * {@code endpoints}.
	 * @param endpoints the endpoints
	 */
	public EndpointLinksResolver(Collection<? extends ExposableEndpoint<?>> endpoints) {
		this.endpoints = endpoints;
	}
	/**
	 * Creates a new {@code EndpointLinksResolver} that will resolve links to the given
	 * {@code endpoints} that are exposed beneath the given {@code basePath}.
	 * @param endpoints the endpoints
	 * @param basePath the basePath
	 */
	public EndpointLinksResolver(Collection<? extends ExposableEndpoint<?>> endpoints, String basePath) {
		this.endpoints = endpoints;
		if (logger.isInfoEnabled()) {
			String suffix = (endpoints.size() == 1) ? '' : 's';
			logger
				.info('Exposing ' + endpoints.size() + ' endpoint' + suffix + ' beneath base path "' + basePath + '"');
		}
	}
	/**
	 * Resolves links to the known endpoints based on a request with the given
	 * {@code requestUrl}.
	 * @param requestUrl the url of the request for the endpoint links
	 * @return the links
	 */
	public Map<String, Link> resolveLinks(String requestUrl) {
		String normalizedUrl = normalizeRequestUrl(requestUrl);
		Map<String, Link> links = new LinkedHashMap<>();
		links.put('self', new Link(normalizedUrl));
		for (ExposableEndpoint<?> endpoint : this.endpoints) {
			if (endpoint instanceof ExposableWebEndpoint exposableWebEndpoint) {
				collectLinks(links, exposableWebEndpoint, normalizedUrl);
			}
			else if (endpoint instanceof PathMappedEndpoint pathMappedEndpoint) {
				String rootPath = pathMappedEndpoint.getRootPath();
				Link link = createLink(normalizedUrl, rootPath);
				links.put(endpoint.getEndpointId().toLowerCaseString(), link);
			}
		}
		return links;
	}
	private String normalizeRequestUrl(String requestUrl) {
		if (requestUrl.endsWith('/')) {
			return requestUrl.substring(0, requestUrl.length() - 1);
		}
		return requestUrl;
	}
	private void collectLinks(Map<String, Link> links, ExposableWebEndpoint endpoint, String normalizedUrl) {
		for (WebOperation operation : endpoint.getOperations()) {
			links.put(operation.getId(), createLink(normalizedUrl, operation));
		}
	}
	private Link createLink(String requestUrl, WebOperation operation) {
		return createLink(requestUrl, operation.getRequestPredicate().getPath());
	}
	private Link createLink(String requestUrl, String path) {
		return new Link(requestUrl + (path.startsWith('/') ? path : '/' + path));
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public interface WebOperation extends Operation {
	/**
	 * Returns the ID of the operation that uniquely identifies it within its endpoint.
	 * @return the ID
	 */
	String getId();
	/**
	 * Returns if the underlying operation is blocking.
	 * @return {@code true} if the operation is blocking
	 */
	boolean isBlocking();
	/**
	 * Returns the predicate for requests that can be handled by this operation.
	 * @return the predicate
	 */
	WebOperationRequestPredicate getRequestPredicate();
}
/*
package org.springframework.boot.actuate.endpoint.web.jersey;
/**
interface JerseyRemainingPathSegmentProvider {
	String get(ContainerRequestContext requestContext, String matchAllRemainingPathSegmentsVariable);
}
/*
package org.springframework.boot.actuate.endpoint.web.jersey;
/**
public class JerseyEndpointResourceFactory {
	/**
	 * Creates {@link Resource Resources} for the operations of the given
	 * {@code webEndpoints}.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param endpointMediaTypes media types consumed and produced by the endpoints
	 * @param linksResolver resolver for determining links to available endpoints
	 * @param shouldRegisterLinks should register links
	 * @return the resources for the operations
	 */
	public Collection<Resource> createEndpointResources(EndpointMapping endpointMapping,
			Collection<ExposableWebEndpoint> endpoints, EndpointMediaTypes endpointMediaTypes,
			EndpointLinksResolver linksResolver, boolean shouldRegisterLinks) {
		List<Resource> resources = new ArrayList<>();
		endpoints.stream()
			.flatMap((endpoint) -> endpoint.getOperations().stream())
			.map((operation) -> createResource(endpointMapping, operation))
			.forEach(resources::add);
		if (shouldRegisterLinks) {
			Resource resource = createEndpointLinksResource(endpointMapping.getPath(), endpointMediaTypes,
					linksResolver);
			resources.add(resource);
		}
		return resources;
	}
	protected Resource createResource(EndpointMapping endpointMapping, WebOperation operation) {
		WebOperationRequestPredicate requestPredicate = operation.getRequestPredicate();
		String path = requestPredicate.getPath();
		String matchAllRemainingPathSegmentsVariable = requestPredicate.getMatchAllRemainingPathSegmentsVariable();
		if (matchAllRemainingPathSegmentsVariable != null) {
			path = path.replace('{*' + matchAllRemainingPathSegmentsVariable + '}',
					'{' + matchAllRemainingPathSegmentsVariable + ': .*}');
		}
		return getResource(endpointMapping, operation, requestPredicate, path, null, null);
	}
	protected Resource getResource(EndpointMapping endpointMapping, WebOperation operation,
			WebOperationRequestPredicate requestPredicate, String path, WebServerNamespace serverNamespace,
			JerseyRemainingPathSegmentProvider remainingPathSegmentProvider) {
		Builder resourceBuilder = Resource.builder()
			.path(endpointMapping.getPath())
			.path(endpointMapping.createSubPath(path));
		resourceBuilder.addMethod(requestPredicate.getHttpMethod().name())
			.consumes(StringUtils.toStringArray(requestPredicate.getConsumes()))
			.produces(StringUtils.toStringArray(requestPredicate.getProduces()))
			.handledBy(new OperationInflector(operation, !requestPredicate.getConsumes().isEmpty(), serverNamespace,
					remainingPathSegmentProvider));
		return resourceBuilder.build();
	}
	private Resource createEndpointLinksResource(String endpointPath, EndpointMediaTypes endpointMediaTypes,
			EndpointLinksResolver linksResolver) {
		Builder resourceBuilder = Resource.builder().path(endpointPath);
		resourceBuilder.addMethod('GET')
			.produces(StringUtils.toStringArray(endpointMediaTypes.getProduced()))
			.handledBy(new EndpointLinksInflector(linksResolver));
		return resourceBuilder.build();
	}
	/**
	 * {@link Inflector} to invoke the {@link WebOperation}.
	 */
	private static final class OperationInflector implements Inflector<ContainerRequestContext, Object> {
		private static final String PATH_SEPARATOR = AntPathMatcher.DEFAULT_PATH_SEPARATOR;
		private static final List<Function<Object, Object>> BODY_CONVERTERS;
		static {
			List<Function<Object, Object>> converters = new ArrayList<>();
			converters.add(new ResourceBodyConverter());
			if (ClassUtils.isPresent('reactor.core.publisher.Mono', OperationInflector.class.getClassLoader())) {
				converters.add(new FluxBodyConverter());
				converters.add(new MonoBodyConverter());
			}
			BODY_CONVERTERS = Collections.unmodifiableList(converters);
		}
		private final WebOperation operation;
		private final boolean readBody;
		private final WebServerNamespace serverNamespace;
		private final JerseyRemainingPathSegmentProvider remainingPathSegmentProvider;
		private OperationInflector(WebOperation operation, boolean readBody, WebServerNamespace serverNamespace,
				JerseyRemainingPathSegmentProvider remainingPathSegments) {
			this.operation = operation;
			this.readBody = readBody;
			this.serverNamespace = serverNamespace;
			this.remainingPathSegmentProvider = remainingPathSegments;
		}
		@Override
		public Response apply(ContainerRequestContext data) {
			Map<String, Object> arguments = new HashMap<>();
			if (this.readBody) {
				arguments.putAll(extractBodyArguments(data));
			}
			arguments.putAll(extractPathParameters(data));
			arguments.putAll(extractQueryParameters(data));
			try {
				JerseySecurityContext securityContext = new JerseySecurityContext(data.getSecurityContext());
				OperationArgumentResolver serverNamespaceArgumentResolver = OperationArgumentResolver
					.of(WebServerNamespace.class, () -> this.serverNamespace);
				InvocationContext invocationContext = new InvocationContext(securityContext, arguments,
						serverNamespaceArgumentResolver,
						new ProducibleOperationArgumentResolver(() -> data.getHeaders().get('Accept')));
				Object response = this.operation.invoke(invocationContext);
				return convertToJaxRsResponse(response, data.getRequest().getMethod());
			}
			catch (InvalidEndpointRequestException ex) {
				return Response.status(Status.BAD_REQUEST).build();
			}
		}
		@SuppressWarnings('unchecked')
		private Map<String, Object> extractBodyArguments(ContainerRequestContext data) {
			Map<String, Object> entity = ((ContainerRequest) data).readEntity(Map.class);
			return (entity != null) ? entity : Collections.emptyMap();
		}
		private Map<String, Object> extractPathParameters(ContainerRequestContext requestContext) {
			Map<String, Object> pathParameters = extract(requestContext.getUriInfo().getPathParameters());
			String matchAllRemainingPathSegmentsVariable = this.operation.getRequestPredicate()
				.getMatchAllRemainingPathSegmentsVariable();
			if (matchAllRemainingPathSegmentsVariable != null) {
				String remainingPathSegments = getRemainingPathSegments(requestContext, pathParameters,
						matchAllRemainingPathSegmentsVariable);
				pathParameters.put(matchAllRemainingPathSegmentsVariable, tokenizePathSegments(remainingPathSegments));
			}
			return pathParameters;
		}
		private String getRemainingPathSegments(ContainerRequestContext requestContext,
				Map<String, Object> pathParameters, String matchAllRemainingPathSegmentsVariable) {
			if (this.remainingPathSegmentProvider != null) {
				return this.remainingPathSegmentProvider.get(requestContext, matchAllRemainingPathSegmentsVariable);
			}
			return (String) pathParameters.get(matchAllRemainingPathSegmentsVariable);
		}
		private String[] tokenizePathSegments(String path) {
			String[] segments = StringUtils.tokenizeToStringArray(path, PATH_SEPARATOR, false, true);
			for (int i = 0; i < segments.length; i++) {
				if (segments[i].contains('%')) {
					segments[i] = StringUtils.uriDecode(segments[i], StandardCharsets.UTF_8);
				}
			}
			return segments;
		}
		private Map<String, Object> extractQueryParameters(ContainerRequestContext requestContext) {
			return extract(requestContext.getUriInfo().getQueryParameters());
		}
		private Map<String, Object> extract(MultivaluedMap<String, String> multivaluedMap) {
			Map<String, Object> result = new HashMap<>();
			multivaluedMap.forEach((name, values) -> {
				if (!CollectionUtils.isEmpty(values)) {
					result.put(name, (values.size() != 1) ? values : values.get(0));
				}
			});
			return result;
		}
		private Response convertToJaxRsResponse(Object response, String httpMethod) {
			if (response == null) {
				boolean isGet = HttpMethod.GET.equals(httpMethod);
				Status status = isGet ? Status.NOT_FOUND : Status.NO_CONTENT;
				return Response.status(status).build();
			}
			if (!(response instanceof WebEndpointResponse<?> webEndpointResponse)) {
				return Response.status(Status.OK).entity(convertIfNecessary(response)).build();
			}
			return Response.status(webEndpointResponse.getStatus())
				.header('Content-Type', webEndpointResponse.getContentType())
				.entity(convertIfNecessary(webEndpointResponse.getBody()))
				.build();
		}
		private Object convertIfNecessary(Object body) {
			for (Function<Object, Object> converter : BODY_CONVERTERS) {
				body = converter.apply(body);
			}
			return body;
		}
	}
	/**
	 * Body converter from {@link org.springframework.core.io.Resource} to
	 * {@link InputStream}.
	 */
	private static final class ResourceBodyConverter implements Function<Object, Object> {
		@Override
		public Object apply(Object body) {
			if (body instanceof org.springframework.core.io.Resource) {
				try {
					return ((org.springframework.core.io.Resource) body).getInputStream();
				}
				catch (IOException ex) {
					throw new IllegalStateException();
				}
			}
			return body;
		}
	}
	/**
	 * Body converter from {@link Mono} to {@link Mono#block()}.
	 */
	private static final class MonoBodyConverter implements Function<Object, Object> {
		@Override
		public Object apply(Object body) {
			if (body instanceof Mono) {
				return ((Mono<?>) body).block();
			}
			return body;
		}
	}
	/**
	 * Body converter from {@link Flux} to {@link Flux#collectList Mono&lt;List&gt;}.
	 */
	private static final class FluxBodyConverter implements Function<Object, Object> {
		@Override
		public Object apply(Object body) {
			if (body instanceof Flux) {
				return ((Flux<?>) body).collectList();
			}
			return body;
		}
	}
	/**
	 * {@link Inflector} to for endpoint links.
	 */
	private static final class EndpointLinksInflector implements Inflector<ContainerRequestContext, Response> {
		private final EndpointLinksResolver linksResolver;
		private EndpointLinksInflector(EndpointLinksResolver linksResolver) {
			this.linksResolver = linksResolver;
		}
		@Override
		public Response apply(ContainerRequestContext request) {
			Map<String, Link> links = this.linksResolver
				.resolveLinks(request.getUriInfo().getAbsolutePath().toString());
			Map<String, Map<String, Link>> entity = OperationResponseBody.of(Collections.singletonMap('_links', links));
			return Response.ok(entity).build();
		}
	}
	private static final class JerseySecurityContext implements SecurityContext {
		private final jakarta.ws.rs.core.SecurityContext securityContext;
		private JerseySecurityContext(jakarta.ws.rs.core.SecurityContext securityContext) {
			this.securityContext = securityContext;
		}
		@Override
		public Principal getPrincipal() {
			return this.securityContext.getUserPrincipal();
		}
		@Override
		public boolean isUserInRole(String role) {
			return this.securityContext.isUserInRole(role);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.web.jersey;
/*
package org.springframework.boot.actuate.endpoint.web.jersey;
/**
public final class JerseyHealthEndpointAdditionalPathResourceFactory {
	private final JerseyEndpointResourceFactory delegate = new JerseyEndpointResourceFactory();
	private final Set<HealthEndpointGroup> groups;
	private final WebServerNamespace serverNamespace;
	public JerseyHealthEndpointAdditionalPathResourceFactory(WebServerNamespace serverNamespace,
			HealthEndpointGroups groups) {
		this.serverNamespace = serverNamespace;
		this.groups = groups.getAllWithAdditionalPath(serverNamespace);
	}
	public Collection<Resource> createEndpointResources(EndpointMapping endpointMapping,
			Collection<ExposableWebEndpoint> endpoints) {
		return endpoints.stream()
			.flatMap((endpoint) -> endpoint.getOperations().stream())
			.flatMap((operation) -> createResources(endpointMapping, operation))
			.toList();
	}
	private Stream<Resource> createResources(EndpointMapping endpointMapping, WebOperation operation) {
		WebOperationRequestPredicate requestPredicate = operation.getRequestPredicate();
		String matchAllRemainingPathSegmentsVariable = requestPredicate.getMatchAllRemainingPathSegmentsVariable();
		if (matchAllRemainingPathSegmentsVariable != null) {
			List<Resource> resources = new ArrayList<>();
			for (HealthEndpointGroup group : this.groups) {
				AdditionalHealthEndpointPath additionalPath = group.getAdditionalPath();
				if (additionalPath != null) {
					resources.add(this.delegate.getResource(endpointMapping, operation, requestPredicate,
							additionalPath.getValue(), this.serverNamespace,
							(data, pathSegmentsVariable) -> data.getUriInfo().getPath()));
				}
			}
			return resources.stream();
		}
		return Stream.empty();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public class PathMappedEndpoints implements Iterable<PathMappedEndpoint> {
	private final String basePath;
	private final Map<EndpointId, PathMappedEndpoint> endpoints;
	/**
	 * Create a new {@link PathMappedEndpoints} instance for the given supplier.
	 * @param basePath the base path of the endpoints
	 * @param supplier the endpoint supplier
	 */
	public PathMappedEndpoints(String basePath, EndpointsSupplier<?> supplier) {
		Assert.notNull(supplier, 'Supplier must not be null');
		this.basePath = (basePath != null) ? basePath : '';
		this.endpoints = getEndpoints(Collections.singleton(supplier));
	}
	/**
	 * Create a new {@link PathMappedEndpoints} instance for the given suppliers.
	 * @param basePath the base path of the endpoints
	 * @param suppliers the endpoint suppliers
	 */
	public PathMappedEndpoints(String basePath, Collection<EndpointsSupplier<?>> suppliers) {
		Assert.notNull(suppliers, 'Suppliers must not be null');
		this.basePath = (basePath != null) ? basePath : '';
		this.endpoints = getEndpoints(suppliers);
	}
	private Map<EndpointId, PathMappedEndpoint> getEndpoints(Collection<EndpointsSupplier<?>> suppliers) {
		Map<EndpointId, PathMappedEndpoint> endpoints = new LinkedHashMap<>();
		suppliers.forEach((supplier) -> supplier.getEndpoints().forEach((endpoint) -> {
			if (endpoint instanceof PathMappedEndpoint pathMappedEndpoint) {
				endpoints.put(endpoint.getEndpointId(), pathMappedEndpoint);
			}
		}));
		return Collections.unmodifiableMap(endpoints);
	}
	/**
	 * Return the base path for the endpoints.
	 * @return the base path
	 */
	public String getBasePath() {
		return this.basePath;
	}
	/**
	 * Return the root path for the endpoint with the given ID or {@code null} if the
	 * endpoint cannot be found.
	 * @param endpointId the endpoint ID
	 * @return the root path or {@code null}
	 */
	public String getRootPath(EndpointId endpointId) {
		PathMappedEndpoint endpoint = getEndpoint(endpointId);
		return (endpoint != null) ? endpoint.getRootPath() : null;
	}
	/**
	 * Return the full path for the endpoint with the given ID or {@code null} if the
	 * endpoint cannot be found.
	 * @param endpointId the endpoint ID
	 * @return the full path or {@code null}
	 */
	public String getPath(EndpointId endpointId) {
		return getPath(getEndpoint(endpointId));
	}
	/**
	 * Return the root paths for each mapped endpoint (excluding additional paths).
	 * @return all root paths
	 */
	public Collection<String> getAllRootPaths() {
		return stream().map(PathMappedEndpoint::getRootPath).toList();
	}
	/**
	 * Return the full paths for each mapped endpoint (excluding additional paths).
	 * @return all root paths
	 */
	public Collection<String> getAllPaths() {
		return stream().map(this::getPath).toList();
	}
	/**
	 * Return the additional paths for each mapped endpoint.
	 * @param webServerNamespace the web server namespace
	 * @param endpointId the endpoint ID
	 * @return all additional paths
	 * @since 3.4.0
	 */
	public Collection<String> getAdditionalPaths(WebServerNamespace webServerNamespace, EndpointId endpointId) {
		return getAdditionalPaths(webServerNamespace, getEndpoint(endpointId)).toList();
	}
	private Stream<String> getAdditionalPaths(WebServerNamespace webServerNamespace, PathMappedEndpoint endpoint) {
		List<String> additionalPaths = (endpoint != null) ? endpoint.getAdditionalPaths(webServerNamespace) : null;
		if (CollectionUtils.isEmpty(additionalPaths)) {
			return Stream.empty();
		}
		return additionalPaths.stream().map(this::getAdditionalPath);
	}
	private String getAdditionalPath(String path) {
		return path.startsWith('/') ? path : '/' + path;
	}
	/**
	 * Return the {@link PathMappedEndpoint} with the given ID or {@code null} if the
	 * endpoint cannot be found.
	 * @param endpointId the endpoint ID
	 * @return the path mapped endpoint or {@code null}
	 */
	public PathMappedEndpoint getEndpoint(EndpointId endpointId) {
		return this.endpoints.get(endpointId);
	}
	/**
	 * Stream all {@link PathMappedEndpoint path mapped endpoints}.
	 * @return a stream of endpoints
	 */
	public Stream<PathMappedEndpoint> stream() {
		return this.endpoints.values().stream();
	}
	@Override
	public Iterator<PathMappedEndpoint> iterator() {
		return this.endpoints.values().iterator();
	}
	private String getPath(PathMappedEndpoint endpoint) {
		if (endpoint == null) {
			return null;
		}
		StringBuilder path = new StringBuilder(this.basePath);
		if (!this.basePath.equals('/')) {
			path.append('/');
		}
		if (!endpoint.getRootPath().equals('/')) {
			path.append(endpoint.getRootPath());
		}
		return path.toString();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@FunctionalInterface
public interface PathMappedEndpoint {
	/**
	 * Return the root path of the endpoint (relative to the context and base path) that
	 * exposes it. For example, a root path of {@code example} would be exposed under the
	 * URL '/{actuator-context}/example'.
	 * @return the root path for the endpoint
	 * @see PathMappedEndpoints#getBasePath
	 */
	String getRootPath();
	/**
	 * Return any additional paths (relative to the context) for the given
	 * {@link WebServerNamespace}.
	 * @param webServerNamespace the web server namespace
	 * @return a list of additional paths
	 * @since 3.4.0
	 */
	default List<String> getAdditionalPaths(WebServerNamespace webServerNamespace) {
		return Collections.emptyList();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
@ImportRuntimeHints(WebMvcEndpointHandlerMappingRuntimeHints.class)
public class WebMvcEndpointHandlerMapping extends AbstractWebMvcEndpointHandlerMapping {
	private final EndpointLinksResolver linksResolver;
	/**
	 * Creates a new {@code WebMvcEndpointHandlerMapping} instance that provides mappings
	 * for the given endpoints.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param endpointMediaTypes media types consumed and produced by the endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
	 * @param linksResolver resolver for determining links to available endpoints
	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
	 */
	public WebMvcEndpointHandlerMapping(EndpointMapping endpointMapping, Collection<ExposableWebEndpoint> endpoints,
			EndpointMediaTypes endpointMediaTypes, CorsConfiguration corsConfiguration,
			EndpointLinksResolver linksResolver, boolean shouldRegisterLinksMapping) {
		super(endpointMapping, endpoints, endpointMediaTypes, corsConfiguration, shouldRegisterLinksMapping);
		this.linksResolver = linksResolver;
		setOrder(-100);
	}
	@Override
	protected LinksHandler getLinksHandler() {
		return new WebMvcLinksHandler();
	}
	/**
	 * Handler for root endpoint providing links.
	 */
	class WebMvcLinksHandler implements LinksHandler {
		@Override
		@ResponseBody
		@Reflective
		public Map<String, Map<String, Link>> links(HttpServletRequest request, HttpServletResponse response) {
			Map<String, Link> links = WebMvcEndpointHandlerMapping.this.linksResolver
				.resolveLinks(request.getRequestURL().toString());
			return OperationResponseBody.of(Collections.singletonMap('_links', links));
		}
		@Override
		public String toString() {
			return 'Actuator root web endpoint';
		}
	}
	static class WebMvcEndpointHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {
		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.reflectiveRegistrar.registerRuntimeHints(hints, WebMvcLinksHandler.class);
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), Link.class);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
final class SkipPathExtensionContentNegotiation implements HandlerInterceptor {
	@SuppressWarnings('deprecation')
	private static final String SKIP_ATTRIBUTE = org.springframework.web.accept.PathExtensionContentNegotiationStrategy.class
		.getName() + '.SKIP';
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		request.setAttribute(SKIP_ATTRIBUTE, Boolean.TRUE);
		return true;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
@Deprecated(since = '3.3.5', forRemoval = true)
@SuppressWarnings('removal')
public class ControllerEndpointHandlerMapping extends RequestMappingHandlerMapping {
	private static final Set<RequestMethod> READ_ONLY_ACCESS_REQUEST_METHODS = EnumSet.of(RequestMethod.GET,
			RequestMethod.HEAD);
	private final EndpointMapping endpointMapping;
	private final CorsConfiguration corsConfiguration;
	private final Map<Object, ExposableControllerEndpoint> handlers;
	private final EndpointAccessResolver accessResolver;
	/**
	 * Create a new {@link ControllerEndpointHandlerMapping} instance providing mappings
	 * for the specified endpoints.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
	 */
	public ControllerEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableControllerEndpoint> endpoints, CorsConfiguration corsConfiguration) {
		this(endpointMapping, endpoints, corsConfiguration, (endpointId, defaultAccess) -> Access.NONE);
	}
	/**
	 * Create a new {@link ControllerEndpointHandlerMapping} instance providing mappings
	 * for the specified endpoints.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
	 * @param endpointAccessResolver resolver for endpoint access
	 */
	public ControllerEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableControllerEndpoint> endpoints, CorsConfiguration corsConfiguration,
			EndpointAccessResolver endpointAccessResolver) {
		Assert.notNull(endpointMapping, 'EndpointMapping must not be null');
		Assert.notNull(endpoints, 'Endpoints must not be null');
		this.endpointMapping = endpointMapping;
		this.handlers = getHandlers(endpoints);
		this.corsConfiguration = corsConfiguration;
		this.accessResolver = endpointAccessResolver;
		setOrder(-100);
	}
	private Map<Object, ExposableControllerEndpoint> getHandlers(Collection<ExposableControllerEndpoint> endpoints) {
		Map<Object, ExposableControllerEndpoint> handlers = new LinkedHashMap<>();
		endpoints.forEach((endpoint) -> handlers.put(endpoint.getController(), endpoint));
		return Collections.unmodifiableMap(handlers);
	}
	@Override
	protected void initHandlerMethods() {
		this.handlers.keySet().forEach(this::detectHandlerMethods);
	}
	@Override
	protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {
		ExposableControllerEndpoint endpoint = this.handlers.get(handler);
		Access access = this.accessResolver.accessFor(endpoint.getEndpointId(), endpoint.getDefaultAccess());
		if (access == Access.NONE) {
			return;
		}
		if (access == Access.READ_ONLY) {
			mapping = withReadOnlyAccess(access, mapping);
			if (CollectionUtils.isEmpty(mapping.getMethodsCondition().getMethods())) {
				return;
			}
		}
		mapping = withEndpointMappedPatterns(endpoint, mapping);
		super.registerHandlerMethod(handler, method, mapping);
	}
	private RequestMappingInfo withReadOnlyAccess(Access access, RequestMappingInfo mapping) {
		Set<RequestMethod> methods = mapping.getMethodsCondition().getMethods();
		Set<RequestMethod> modifiedMethods = new HashSet<>(methods);
		if (modifiedMethods.isEmpty()) {
			modifiedMethods.addAll(READ_ONLY_ACCESS_REQUEST_METHODS);
		}
		else {
			modifiedMethods.retainAll(READ_ONLY_ACCESS_REQUEST_METHODS);
		}
		return mapping.mutate().methods(modifiedMethods.toArray(new RequestMethod[0])).build();
	}
	private RequestMappingInfo withEndpointMappedPatterns(ExposableControllerEndpoint endpoint,
			RequestMappingInfo mapping) {
		Set<PathPattern> patterns = mapping.getPathPatternsCondition().getPatterns();
		if (patterns.isEmpty()) {
			patterns = Collections.singleton(getPatternParser().parse(''));
		}
		String[] endpointMappedPatterns = patterns.stream()
			.map((pattern) -> getEndpointMappedPattern(endpoint, pattern))
			.toArray(String[]::new);
		return mapping.mutate().paths(endpointMappedPatterns).build();
	}
	private String getEndpointMappedPattern(ExposableControllerEndpoint endpoint, PathPattern pattern) {
		return this.endpointMapping.createSubPath(endpoint.getRootPath() + pattern);
	}
	@Override
	protected boolean hasCorsConfigurationSource(Object handler) {
		return this.corsConfiguration != null;
	}
	@Override
	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mapping) {
		return this.corsConfiguration;
	}
	@Override
	protected void extendInterceptors(List<Object> interceptors) {
		interceptors.add(new SkipPathExtensionContentNegotiation());
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
public class AdditionalHealthEndpointPathsWebMvcHandlerMapping extends AbstractWebMvcEndpointHandlerMapping {
	private final ExposableWebEndpoint healthEndpoint;
	private final Set<HealthEndpointGroup> groups;
	public AdditionalHealthEndpointPathsWebMvcHandlerMapping(ExposableWebEndpoint healthEndpoint,
			Set<HealthEndpointGroup> groups) {
		super(new EndpointMapping(''), asList(healthEndpoint), null, false);
		this.healthEndpoint = healthEndpoint;
		this.groups = groups;
	}
	private static Collection<ExposableWebEndpoint> asList(ExposableWebEndpoint healthEndpoint) {
		return (healthEndpoint != null) ? Collections.singletonList(healthEndpoint) : Collections.emptyList();
	}
	@Override
	protected void initHandlerMethods() {
		if (this.healthEndpoint == null) {
			return;
		}
		for (WebOperation operation : this.healthEndpoint.getOperations()) {
			WebOperationRequestPredicate predicate = operation.getRequestPredicate();
			String matchAllRemainingPathSegmentsVariable = predicate.getMatchAllRemainingPathSegmentsVariable();
			if (matchAllRemainingPathSegmentsVariable != null) {
				for (HealthEndpointGroup group : this.groups) {
					AdditionalHealthEndpointPath additionalPath = group.getAdditionalPath();
					if (additionalPath != null) {
						registerMapping(this.healthEndpoint, predicate, operation, additionalPath.getValue());
					}
				}
			}
		}
	}
	@Override
	protected LinksHandler getLinksHandler() {
		return null;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.servlet;
/**
@ImportRuntimeHints(AbstractWebMvcEndpointHandlerMappingRuntimeHints.class)
public abstract class AbstractWebMvcEndpointHandlerMapping extends RequestMappingInfoHandlerMapping
		implements InitializingBean {
	private final EndpointMapping endpointMapping;
	private final Collection<ExposableWebEndpoint> endpoints;
	private final EndpointMediaTypes endpointMediaTypes;
	private final CorsConfiguration corsConfiguration;
	private final boolean shouldRegisterLinksMapping;
	private final Method handleMethod = ReflectionUtils.findMethod(OperationHandler.class, 'handle',
			HttpServletRequest.class, Map.class);
	private RequestMappingInfo.BuilderConfiguration builderConfig = new RequestMappingInfo.BuilderConfiguration();
	/**
	 * Creates a new {@code WebEndpointHandlerMapping} that provides mappings for the
	 * operations of the given {@code webEndpoints}.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param endpointMediaTypes media types consumed and produced by the endpoints
	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
	 */
	public AbstractWebMvcEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableWebEndpoint> endpoints, EndpointMediaTypes endpointMediaTypes,
			boolean shouldRegisterLinksMapping) {
		this(endpointMapping, endpoints, endpointMediaTypes, null, shouldRegisterLinksMapping);
	}
	/**
	 * Creates a new {@code AbstractWebMvcEndpointHandlerMapping} that provides mappings
	 * for the operations of the given endpoints.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param endpointMediaTypes media types consumed and produced by the endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
	 */
	public AbstractWebMvcEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableWebEndpoint> endpoints, EndpointMediaTypes endpointMediaTypes,
			CorsConfiguration corsConfiguration, boolean shouldRegisterLinksMapping) {
		this.endpointMapping = endpointMapping;
		this.endpoints = endpoints;
		this.endpointMediaTypes = endpointMediaTypes;
		this.corsConfiguration = corsConfiguration;
		this.shouldRegisterLinksMapping = shouldRegisterLinksMapping;
		setOrder(-100);
	}
	@Override
	public void afterPropertiesSet() {
		this.builderConfig = new RequestMappingInfo.BuilderConfiguration();
		this.builderConfig.setPatternParser(getPatternParser());
		super.afterPropertiesSet();
	}
	@Override
	protected void initHandlerMethods() {
		for (ExposableWebEndpoint endpoint : this.endpoints) {
			for (WebOperation operation : endpoint.getOperations()) {
				registerMappingForOperation(endpoint, operation);
			}
		}
		if (this.shouldRegisterLinksMapping) {
			registerLinksMapping();
		}
	}
	@Override
	protected HandlerMethod createHandlerMethod(Object handler, Method method) {
		HandlerMethod handlerMethod = super.createHandlerMethod(handler, method);
		return new WebMvcEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod());
	}
	private void registerMappingForOperation(ExposableWebEndpoint endpoint, WebOperation operation) {
		WebOperationRequestPredicate predicate = operation.getRequestPredicate();
		String path = predicate.getPath();
		String matchAllRemainingPathSegmentsVariable = predicate.getMatchAllRemainingPathSegmentsVariable();
		if (matchAllRemainingPathSegmentsVariable != null) {
			path = path.replace('{*' + matchAllRemainingPathSegmentsVariable + '}', '**');
		}
		registerMapping(endpoint, predicate, operation, path);
	}
	protected void registerMapping(ExposableWebEndpoint endpoint, WebOperationRequestPredicate predicate,
			WebOperation operation, String path) {
		ServletWebOperation servletWebOperation = wrapServletWebOperation(endpoint, operation,
				new ServletWebOperationAdapter(operation));
		registerMapping(createRequestMappingInfo(predicate, path), new OperationHandler(servletWebOperation),
				this.handleMethod);
	}
	/**
	 * Hook point that allows subclasses to wrap the {@link ServletWebOperation} before
	 * it"s called. Allows additional features, such as security, to be added.
	 * @param endpoint the source endpoint
	 * @param operation the source operation
	 * @param servletWebOperation the servlet web operation to wrap
	 * @return a wrapped servlet web operation
	 */
	protected ServletWebOperation wrapServletWebOperation(ExposableWebEndpoint endpoint, WebOperation operation,
			ServletWebOperation servletWebOperation) {
		return servletWebOperation;
	}
	private RequestMappingInfo createRequestMappingInfo(WebOperationRequestPredicate predicate, String path) {
		String subPath = this.endpointMapping.createSubPath(path);
		List<String> paths = new ArrayList<>();
		paths.add(subPath);
		if (!StringUtils.hasLength(subPath)) {
			paths.add('/');
		}
		return RequestMappingInfo.paths(paths.toArray(new String[0]))
			.options(this.builderConfig)
			.methods(RequestMethod.valueOf(predicate.getHttpMethod().name()))
			.consumes(predicate.getConsumes().toArray(new String[0]))
			.produces(predicate.getProduces().toArray(new String[0]))
			.build();
	}
	private void registerLinksMapping() {
		String path = this.endpointMapping.getPath();
		String linksPath = (StringUtils.hasLength(path)) ? this.endpointMapping.createSubPath('/') : '/';
		RequestMappingInfo mapping = RequestMappingInfo.paths(linksPath)
			.methods(RequestMethod.GET)
			.produces(this.endpointMediaTypes.getProduced().toArray(new String[0]))
			.options(this.builderConfig)
			.build();
		LinksHandler linksHandler = getLinksHandler();
		registerMapping(mapping, linksHandler, ReflectionUtils.findMethod(linksHandler.getClass(), 'links',
				HttpServletRequest.class, HttpServletResponse.class));
	}
	@Override
	protected boolean hasCorsConfigurationSource(Object handler) {
		return this.corsConfiguration != null;
	}
	@Override
	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mapping) {
		return this.corsConfiguration;
	}
	@Override
	protected boolean isHandler(Class<?> beanType) {
		return false;
	}
	@Override
	protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {
		return null;
	}
	@Override
	protected void extendInterceptors(List<Object> interceptors) {
		interceptors.add(new SkipPathExtensionContentNegotiation());
	}
	/**
	 * Return the Handler providing actuator links at the root endpoint.
	 * @return the links handler
	 */
	protected abstract LinksHandler getLinksHandler();
	/**
	 * Return the web endpoints being mapped.
	 * @return the endpoints
	 */
	public Collection<ExposableWebEndpoint> getEndpoints() {
		return this.endpoints;
	}
	/**
	 * Handler providing actuator links at the root endpoint.
	 */
	@FunctionalInterface
	protected interface LinksHandler {
		Object links(HttpServletRequest request, HttpServletResponse response);
	}
	/**
	 * A servlet web operation that can be handled by Spring MVC.
	 */
	@FunctionalInterface
	protected interface ServletWebOperation {
		Object handle(HttpServletRequest request, Map<String, String> body);
	}
	/**
	 * Adapter class to convert an {@link OperationInvoker} into a
	 * {@link ServletWebOperation}.
	 */
	private static class ServletWebOperationAdapter implements ServletWebOperation {
		private static final String PATH_SEPARATOR = AntPathMatcher.DEFAULT_PATH_SEPARATOR;
		private static final List<Function<Object, Object>> BODY_CONVERTERS;
		static {
			List<Function<Object, Object>> converters = new ArrayList<>();
			if (ClassUtils.isPresent('reactor.core.publisher.Flux',
					ServletWebOperationAdapter.class.getClassLoader())) {
				converters.add(new FluxBodyConverter());
			}
			BODY_CONVERTERS = Collections.unmodifiableList(converters);
		}
		private final WebOperation operation;
		ServletWebOperationAdapter(WebOperation operation) {
			this.operation = operation;
		}
		@Override
		public Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) {
			HttpHeaders headers = new ServletServerHttpRequest(request).getHeaders();
			Map<String, Object> arguments = getArguments(request, body);
			try {
				ServletSecurityContext securityContext = new ServletSecurityContext(request);
				ProducibleOperationArgumentResolver producibleOperationArgumentResolver = new ProducibleOperationArgumentResolver(
						() -> headers.get('Accept'));
				OperationArgumentResolver serverNamespaceArgumentResolver = OperationArgumentResolver
					.of(WebServerNamespace.class, () -> {
						WebApplicationContext applicationContext = WebApplicationContextUtils
							.getRequiredWebApplicationContext(request.getServletContext());
						return WebServerNamespace
							.from(WebServerApplicationContext.getServerNamespace(applicationContext));
					});
				InvocationContext invocationContext = new InvocationContext(securityContext, arguments,
						serverNamespaceArgumentResolver, producibleOperationArgumentResolver);
				return handleResult(this.operation.invoke(invocationContext), HttpMethod.valueOf(request.getMethod()));
			}
			catch (InvalidEndpointRequestException ex) {
				throw new InvalidEndpointBadRequestException(ex);
			}
		}
		@Override
		public String toString() {
			return 'Actuator web endpoint "' + this.operation.getId() + '"';
		}
		private Map<String, Object> getArguments(HttpServletRequest request, Map<String, String> body) {
			Map<String, Object> arguments = new LinkedHashMap<>(getTemplateVariables(request));
			String matchAllRemainingPathSegmentsVariable = this.operation.getRequestPredicate()
				.getMatchAllRemainingPathSegmentsVariable();
			if (matchAllRemainingPathSegmentsVariable != null) {
				arguments.put(matchAllRemainingPathSegmentsVariable, getRemainingPathSegments(request));
			}
			if (body != null && HttpMethod.POST.name().equals(request.getMethod())) {
				arguments.putAll(body);
			}
			request.getParameterMap()
				.forEach((name, values) -> arguments.put(name,
						(values.length != 1) ? Arrays.asList(values) : values[0]));
			return arguments;
		}
		private Object getRemainingPathSegments(HttpServletRequest request) {
			String[] pathTokens = tokenize(request, HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, true);
			String[] patternTokens = tokenize(request, HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE, false);
			int numberOfRemainingPathSegments = pathTokens.length - patternTokens.length + 1;
			Assert.state(numberOfRemainingPathSegments >= 0, 'Unable to extract remaining path segments');
			String[] remainingPathSegments = new String[numberOfRemainingPathSegments];
			System.arraycopy(pathTokens, patternTokens.length - 1, remainingPathSegments, 0,
					numberOfRemainingPathSegments);
			return remainingPathSegments;
		}
		private String[] tokenize(HttpServletRequest request, String attributeName, boolean decode) {
			String value = (String) request.getAttribute(attributeName);
			String[] segments = StringUtils.tokenizeToStringArray(value, PATH_SEPARATOR, false, true);
			if (decode) {
				for (int i = 0; i < segments.length; i++) {
					if (segments[i].contains('%')) {
						segments[i] = StringUtils.uriDecode(segments[i], StandardCharsets.UTF_8);
					}
				}
			}
			return segments;
		}
		@SuppressWarnings('unchecked')
		private Map<String, String> getTemplateVariables(HttpServletRequest request) {
			return (Map<String, String>) request.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);
		}
		private Object handleResult(Object result, HttpMethod httpMethod) {
			if (result == null) {
				return new ResponseEntity<>(
						(httpMethod != HttpMethod.GET) ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND);
			}
			if (!(result instanceof WebEndpointResponse<?> response)) {
				return convertIfNecessary(result);
			}
			MediaType contentType = (response.getContentType() != null) ? new MediaType(response.getContentType())
					: null;
			return ResponseEntity.status(response.getStatus())
				.contentType(contentType)
				.body(convertIfNecessary(response.getBody()));
		}
		private Object convertIfNecessary(Object body) {
			for (Function<Object, Object> converter : BODY_CONVERTERS) {
				body = converter.apply(body);
			}
			return body;
		}
		private static final class FluxBodyConverter implements Function<Object, Object> {
			@Override
			public Object apply(Object body) {
				if (!(body instanceof Flux)) {
					return body;
				}
				return ((Flux<?>) body).collectList();
			}
		}
	}
	/**
	 * Handler for a {@link ServletWebOperation}.
	 */
	private static final class OperationHandler {
		private final ServletWebOperation operation;
		OperationHandler(ServletWebOperation operation) {
			this.operation = operation;
		}
		@ResponseBody
		@Reflective
		Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) {
			return this.operation.handle(request, body);
		}
		@Override
		public String toString() {
			return this.operation.toString();
		}
	}
	/**
	 * {@link HandlerMethod} subclass for endpoint information logging.
	 */
	private static class WebMvcEndpointHandlerMethod extends HandlerMethod {
		WebMvcEndpointHandlerMethod(Object bean, Method method) {
			super(bean, method);
		}
		@Override
		public String toString() {
			return getBean().toString();
		}
		@Override
		public HandlerMethod createWithResolvedBean() {
			return this;
		}
	}
	/**
	 * Nested exception used to wrap an {@link InvalidEndpointRequestException} and
	 * provide a {@link HttpStatus#BAD_REQUEST} status.
	 */
	private static class InvalidEndpointBadRequestException extends ResponseStatusException {
		InvalidEndpointBadRequestException(InvalidEndpointRequestException cause) {
			super(HttpStatus.BAD_REQUEST, cause.getReason(), cause);
		}
	}
	private static final class ServletSecurityContext implements SecurityContext {
		private final HttpServletRequest request;
		private ServletSecurityContext(HttpServletRequest request) {
			this.request = request;
		}
		@Override
		public Principal getPrincipal() {
			return this.request.getUserPrincipal();
		}
		@Override
		public boolean isUserInRole(String role) {
			return this.request.isUserInRole(role);
		}
	}
	static class AbstractWebMvcEndpointHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {
		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.reflectiveRegistrar.registerRuntimeHints(hints, OperationHandler.class);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.web.servlet;
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
public final class EndpointServlet {
	private final Servlet servlet;
	private final Map<String, String> initParameters;
	private final int loadOnStartup;
	public EndpointServlet(Class<? extends Servlet> servlet) {
		this(instantiateClass(servlet));
	}
	private static Servlet instantiateClass(Class<? extends Servlet> servlet) {
		Assert.notNull(servlet, 'Servlet must not be null');
		return BeanUtils.instantiateClass(servlet);
	}
	public EndpointServlet(Servlet servlet) {
		this(servlet, Collections.emptyMap(), -1);
	}
	private EndpointServlet(Servlet servlet, Map<String, String> initParameters, int loadOnStartup) {
		Assert.notNull(servlet, 'Servlet must not be null');
		this.servlet = servlet;
		this.initParameters = Collections.unmodifiableMap(initParameters);
		this.loadOnStartup = loadOnStartup;
	}
	public EndpointServlet withInitParameter(String name, String value) {
		Assert.hasText(name, 'Name must not be empty');
		return withInitParameters(Collections.singletonMap(name, value));
	}
	public EndpointServlet withInitParameters(Map<String, String> initParameters) {
		Assert.notNull(initParameters, 'InitParameters must not be null');
		boolean hasEmptyName = initParameters.keySet().stream().anyMatch((name) -> !StringUtils.hasText(name));
		Assert.isTrue(!hasEmptyName, 'InitParameters must not contain empty names');
		Map<String, String> mergedInitParameters = new LinkedHashMap<>(this.initParameters);
		mergedInitParameters.putAll(initParameters);
		return new EndpointServlet(this.servlet, mergedInitParameters, this.loadOnStartup);
	}
	/**
	 * Sets the {@code loadOnStartup} priority that will be set on Servlet registration.
	 * The default value for {@code loadOnStartup} is {@code -1}.
	 * @param loadOnStartup the initialization priority of the Servlet
	 * @return a new instance of {@link EndpointServlet} with the provided
	 * {@code loadOnStartup} value set
	 * @since 2.2.0
	 * @see Dynamic#setLoadOnStartup(int)
	 */
	public EndpointServlet withLoadOnStartup(int loadOnStartup) {
		return new EndpointServlet(this.servlet, this.initParameters, loadOnStartup);
	}
	Servlet getServlet() {
		return this.servlet;
	}
	Map<String, String> getInitParameters() {
		return this.initParameters;
	}
	int getLoadOnStartup() {
		return this.loadOnStartup;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
@FunctionalInterface
public interface AdditionalPathsMapper {
	/**
	 * Resolve the additional paths for the specified {@code endpointId} and web server
	 * namespace.
	 * @param endpointId the id of an endpoint
	 * @param webServerNamespace the web server namespace
	 * @return the additional paths of the endpoint or {@code null} if this mapper doesn"t
	 * support the given endpoint ID.
	 */
	List<String> getAdditionalPaths(EndpointId endpointId, WebServerNamespace webServerNamespace);
}
/*
/**
package org.springframework.boot.actuate.endpoint.web;
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public class Link {
	private final String href;
	private final boolean templated;
	/**
	 * Creates a new {@link Link} with the given {@code href}.
	 * @param href the href
	 */
	public Link(String href) {
		Assert.notNull(href, 'HREF must not be null');
		this.href = href;
		this.templated = href.contains('{');
	}
	/**
	 * Returns the href of the link.
	 * @return the href
	 */
	public String getHref() {
		return this.href;
	}
	/**
	 * Returns whether the {@link #getHref() href} is templated.
	 * @return {@code true} if the href is templated, otherwise {@code false}
	 */
	public boolean isTemplated() {
		return this.templated;
	}
	@Override
	public String toString() {
		return new ToStringCreator(this).append('href', this.href).toString();
	}
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public final class WebServerNamespace {
	/**
	 * {@link WebServerNamespace} that represents the main server.
	 */
	public static final WebServerNamespace SERVER = new WebServerNamespace('server');
	/**
	 * {@link WebServerNamespace} that represents the management server.
	 */
	public static final WebServerNamespace MANAGEMENT = new WebServerNamespace('management');
	private final String value;
	private WebServerNamespace(String value) {
		this.value = value;
	}
	/**
	 * Return the value of the namespace.
	 * @return the value
	 */
	public String getValue() {
		return this.value;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		WebServerNamespace other = (WebServerNamespace) obj;
		return this.value.equals(other.value);
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Factory method to create a new {@link WebServerNamespace} from a value. If the
	 * value is empty or {@code null} then {@link #SERVER} is returned.
	 * @param value the namespace value or {@code null}
	 * @return the web server namespace
	 */
	public static WebServerNamespace from(String value) {
		if (StringUtils.hasText(value)) {
			return new WebServerNamespace(value);
		}
		return SERVER;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
@Deprecated(since = '3.3.5', forRemoval = true)
@SuppressWarnings('removal')
public class ControllerEndpointHandlerMapping extends RequestMappingHandlerMapping {
	private static final Set<RequestMethod> READ_ONLY_ACCESS_REQUEST_METHODS = EnumSet.of(RequestMethod.GET,
			RequestMethod.HEAD);
	private final EndpointMapping endpointMapping;
	private final CorsConfiguration corsConfiguration;
	private final Map<Object, ExposableControllerEndpoint> handlers;
	private final EndpointAccessResolver accessResolver;
	/**
	 * Create a new {@link ControllerEndpointHandlerMapping} instance providing mappings
	 * for the specified endpoints.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
	 */
	public ControllerEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableControllerEndpoint> endpoints, CorsConfiguration corsConfiguration) {
		this(endpointMapping, endpoints, corsConfiguration, (endpointId, defaultAccess) -> Access.NONE);
	}
	/**
	 * Create a new {@link ControllerEndpointHandlerMapping} instance providing mappings
	 * for the specified endpoints.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
	 * @param endpointAccessResolver resolver for endpoint access
	 */
	public ControllerEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableControllerEndpoint> endpoints, CorsConfiguration corsConfiguration,
			EndpointAccessResolver endpointAccessResolver) {
		Assert.notNull(endpointMapping, 'EndpointMapping must not be null');
		Assert.notNull(endpoints, 'Endpoints must not be null');
		this.endpointMapping = endpointMapping;
		this.handlers = getHandlers(endpoints);
		this.corsConfiguration = corsConfiguration;
		this.accessResolver = endpointAccessResolver;
		setOrder(-100);
	}
	private Map<Object, ExposableControllerEndpoint> getHandlers(Collection<ExposableControllerEndpoint> endpoints) {
		Map<Object, ExposableControllerEndpoint> handlers = new LinkedHashMap<>();
		endpoints.forEach((endpoint) -> handlers.put(endpoint.getController(), endpoint));
		return Collections.unmodifiableMap(handlers);
	}
	@Override
	protected void initHandlerMethods() {
		this.handlers.keySet().forEach(this::detectHandlerMethods);
	}
	@Override
	protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {
		ExposableControllerEndpoint endpoint = this.handlers.get(handler);
		Access access = this.accessResolver.accessFor(endpoint.getEndpointId(), endpoint.getDefaultAccess());
		if (access == Access.NONE) {
			return;
		}
		if (access == Access.READ_ONLY) {
			mapping = withReadOnlyAccess(access, mapping);
			if (CollectionUtils.isEmpty(mapping.getMethodsCondition().getMethods())) {
				return;
			}
		}
		mapping = withEndpointMappedPatterns(endpoint, mapping);
		super.registerHandlerMethod(handler, method, mapping);
	}
	private RequestMappingInfo withReadOnlyAccess(Access access, RequestMappingInfo mapping) {
		Set<RequestMethod> methods = new HashSet<>(mapping.getMethodsCondition().getMethods());
		if (methods.isEmpty()) {
			methods.addAll(READ_ONLY_ACCESS_REQUEST_METHODS);
		}
		else {
			methods.retainAll(READ_ONLY_ACCESS_REQUEST_METHODS);
		}
		return mapping.mutate().methods(methods.toArray(new RequestMethod[0])).build();
	}
	private RequestMappingInfo withEndpointMappedPatterns(ExposableControllerEndpoint endpoint,
			RequestMappingInfo mapping) {
		Set<PathPattern> patterns = mapping.getPatternsCondition().getPatterns();
		if (patterns.isEmpty()) {
			patterns = Collections.singleton(getPathPatternParser().parse(''));
		}
		String[] endpointMappedPatterns = patterns.stream()
			.map((pattern) -> getEndpointMappedPattern(endpoint, pattern))
			.toArray(String[]::new);
		return mapping.mutate().paths(endpointMappedPatterns).build();
	}
	private String getEndpointMappedPattern(ExposableControllerEndpoint endpoint, PathPattern pattern) {
		return this.endpointMapping.createSubPath(endpoint.getRootPath() + pattern);
	}
	@Override
	protected boolean hasCorsConfigurationSource(Object handler) {
		return this.corsConfiguration != null;
	}
	@Override
	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mapping) {
		return this.corsConfiguration;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
@ImportRuntimeHints(WebFluxEndpointHandlerMappingRuntimeHints.class)
public class WebFluxEndpointHandlerMapping extends AbstractWebFluxEndpointHandlerMapping implements InitializingBean {
	private final EndpointLinksResolver linksResolver;
	/**
	 * Creates a new {@code WebFluxEndpointHandlerMapping} instance that provides mappings
	 * for the given endpoints.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param endpointMediaTypes media types consumed and produced by the endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
	 * @param linksResolver resolver for determining links to available endpoints
	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
	 */
	public WebFluxEndpointHandlerMapping(EndpointMapping endpointMapping, Collection<ExposableWebEndpoint> endpoints,
			EndpointMediaTypes endpointMediaTypes, CorsConfiguration corsConfiguration,
			EndpointLinksResolver linksResolver, boolean shouldRegisterLinksMapping) {
		super(endpointMapping, endpoints, endpointMediaTypes, corsConfiguration, shouldRegisterLinksMapping);
		this.linksResolver = linksResolver;
		setOrder(-100);
	}
	@Override
	protected LinksHandler getLinksHandler() {
		return new WebFluxLinksHandler();
	}
	/**
	 * Handler for root endpoint providing links.
	 */
	class WebFluxLinksHandler implements LinksHandler {
		@Override
		@ResponseBody
		@Reflective
		public Map<String, Map<String, Link>> links(ServerWebExchange exchange) {
			String requestUri = UriComponentsBuilder.fromUri(exchange.getRequest().getURI())
				.replaceQuery(null)
				.toUriString();
			Map<String, Link> links = WebFluxEndpointHandlerMapping.this.linksResolver.resolveLinks(requestUri);
			return OperationResponseBody.of(Collections.singletonMap('_links', links));
		}
		@Override
		public String toString() {
			return 'Actuator root web endpoint';
		}
	}
	static class WebFluxEndpointHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {
		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.reflectiveRegistrar.registerRuntimeHints(hints, WebFluxLinksHandler.class);
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), Link.class);
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
public class AdditionalHealthEndpointPathsWebFluxHandlerMapping extends AbstractWebFluxEndpointHandlerMapping {
	private final EndpointMapping endpointMapping;
	private final ExposableWebEndpoint healthEndpoint;
	private final Set<HealthEndpointGroup> groups;
	public AdditionalHealthEndpointPathsWebFluxHandlerMapping(EndpointMapping endpointMapping,
			ExposableWebEndpoint healthEndpoint, Set<HealthEndpointGroup> groups) {
		super(endpointMapping, asList(healthEndpoint), null, null, false);
		this.endpointMapping = endpointMapping;
		this.groups = groups;
		this.healthEndpoint = healthEndpoint;
	}
	private static Collection<ExposableWebEndpoint> asList(ExposableWebEndpoint healthEndpoint) {
		return (healthEndpoint != null) ? Collections.singletonList(healthEndpoint) : Collections.emptyList();
	}
	@Override
	protected void initHandlerMethods() {
		if (this.healthEndpoint == null) {
			return;
		}
		for (WebOperation operation : this.healthEndpoint.getOperations()) {
			WebOperationRequestPredicate predicate = operation.getRequestPredicate();
			String matchAllRemainingPathSegmentsVariable = predicate.getMatchAllRemainingPathSegmentsVariable();
			if (matchAllRemainingPathSegmentsVariable != null) {
				for (HealthEndpointGroup group : this.groups) {
					AdditionalHealthEndpointPath additionalPath = group.getAdditionalPath();
					if (additionalPath != null) {
						RequestMappingInfo requestMappingInfo = getRequestMappingInfo(operation,
								additionalPath.getValue());
						registerReadMapping(requestMappingInfo, this.healthEndpoint, operation);
					}
				}
			}
		}
	}
	private RequestMappingInfo getRequestMappingInfo(WebOperation operation, String additionalPath) {
		WebOperationRequestPredicate predicate = operation.getRequestPredicate();
		String path = this.endpointMapping.createSubPath(additionalPath);
		RequestMethod method = RequestMethod.valueOf(predicate.getHttpMethod().name());
		String[] consumes = StringUtils.toStringArray(predicate.getConsumes());
		String[] produces = StringUtils.toStringArray(predicate.getProduces());
		return RequestMappingInfo.paths(path).methods(method).consumes(consumes).produces(produces).build();
	}
	@Override
	protected LinksHandler getLinksHandler() {
		return null;
	}
}
/*
package org.springframework.boot.actuate.endpoint.web.reactive;
/**
@ImportRuntimeHints(AbstractWebFluxEndpointHandlerMappingRuntimeHints.class)
public abstract class AbstractWebFluxEndpointHandlerMapping extends RequestMappingInfoHandlerMapping {
	private final EndpointMapping endpointMapping;
	private final Collection<ExposableWebEndpoint> endpoints;
	private final EndpointMediaTypes endpointMediaTypes;
	private final CorsConfiguration corsConfiguration;
	private final Method handleWriteMethod = ReflectionUtils.findMethod(WriteOperationHandler.class, 'handle',
			ServerWebExchange.class, Map.class);
	private final Method handleReadMethod = ReflectionUtils.findMethod(ReadOperationHandler.class, 'handle',
			ServerWebExchange.class);
	private final boolean shouldRegisterLinksMapping;
	/**
	 * Creates a new {@code AbstractWebFluxEndpointHandlerMapping} that provides mappings
	 * for the operations of the given {@code webEndpoints}.
	 * @param endpointMapping the base mapping for all endpoints
	 * @param endpoints the web endpoints
	 * @param endpointMediaTypes media types consumed and produced by the endpoints
	 * @param corsConfiguration the CORS configuration for the endpoints
	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
	 */
	public AbstractWebFluxEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableWebEndpoint> endpoints, EndpointMediaTypes endpointMediaTypes,
			CorsConfiguration corsConfiguration, boolean shouldRegisterLinksMapping) {
		this.endpointMapping = endpointMapping;
		this.endpoints = endpoints;
		this.endpointMediaTypes = endpointMediaTypes;
		this.corsConfiguration = corsConfiguration;
		this.shouldRegisterLinksMapping = shouldRegisterLinksMapping;
		setOrder(-100);
	}
	@Override
	protected void initHandlerMethods() {
		for (ExposableWebEndpoint endpoint : this.endpoints) {
			for (WebOperation operation : endpoint.getOperations()) {
				registerMappingForOperation(endpoint, operation);
			}
		}
		if (this.shouldRegisterLinksMapping) {
			registerLinksMapping();
		}
	}
	@Override
	protected HandlerMethod createHandlerMethod(Object handler, Method method) {
		HandlerMethod handlerMethod = super.createHandlerMethod(handler, method);
		return new WebFluxEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod());
	}
	private void registerMappingForOperation(ExposableWebEndpoint endpoint, WebOperation operation) {
		RequestMappingInfo requestMappingInfo = createRequestMappingInfo(operation);
		if (operation.getType() == OperationType.WRITE) {
			ReactiveWebOperation reactiveWebOperation = wrapReactiveWebOperation(endpoint, operation,
					new ReactiveWebOperationAdapter(operation));
			registerMapping(requestMappingInfo, new WriteOperationHandler((reactiveWebOperation)),
					this.handleWriteMethod);
		}
		else {
			registerReadMapping(requestMappingInfo, endpoint, operation);
		}
	}
	protected void registerReadMapping(RequestMappingInfo requestMappingInfo, ExposableWebEndpoint endpoint,
			WebOperation operation) {
		ReactiveWebOperation reactiveWebOperation = wrapReactiveWebOperation(endpoint, operation,
				new ReactiveWebOperationAdapter(operation));
		registerMapping(requestMappingInfo, new ReadOperationHandler((reactiveWebOperation)), this.handleReadMethod);
	}
	/**
	 * Hook point that allows subclasses to wrap the {@link ReactiveWebOperation} before
	 * it"s called. Allows additional features, such as security, to be added.
	 * @param endpoint the source endpoint
	 * @param operation the source operation
	 * @param reactiveWebOperation the reactive web operation to wrap
	 * @return a wrapped reactive web operation
	 */
	protected ReactiveWebOperation wrapReactiveWebOperation(ExposableWebEndpoint endpoint, WebOperation operation,
			ReactiveWebOperation reactiveWebOperation) {
		return reactiveWebOperation;
	}
	private RequestMappingInfo createRequestMappingInfo(WebOperation operation) {
		WebOperationRequestPredicate predicate = operation.getRequestPredicate();
		String path = this.endpointMapping.createSubPath(predicate.getPath());
		List<String> paths = new ArrayList<>();
		paths.add(path);
		if (!StringUtils.hasText(path)) {
			paths.add('/');
		}
		RequestMethod method = RequestMethod.valueOf(predicate.getHttpMethod().name());
		String[] consumes = StringUtils.toStringArray(predicate.getConsumes());
		String[] produces = StringUtils.toStringArray(predicate.getProduces());
		return RequestMappingInfo.paths(paths.toArray(new String[0]))
			.methods(method)
			.consumes(consumes)
			.produces(produces)
			.build();
	}
	private void registerLinksMapping() {
		String path = this.endpointMapping.getPath();
		String linksPath = StringUtils.hasLength(path) ? path : '/';
		String[] produces = StringUtils.toStringArray(this.endpointMediaTypes.getProduced());
		RequestMappingInfo mapping = RequestMappingInfo.paths(linksPath)
			.methods(RequestMethod.GET)
			.produces(produces)
			.build();
		LinksHandler linksHandler = getLinksHandler();
		registerMapping(mapping, linksHandler,
				ReflectionUtils.findMethod(linksHandler.getClass(), 'links', ServerWebExchange.class));
	}
	@Override
	protected boolean hasCorsConfigurationSource(Object handler) {
		return this.corsConfiguration != null;
	}
	@Override
	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mapping) {
		return this.corsConfiguration;
	}
	@Override
	protected boolean isHandler(Class<?> beanType) {
		return false;
	}
	@Override
	protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {
		return null;
	}
	/**
	 * Return the Handler providing actuator links at the root endpoint.
	 * @return the links handler
	 */
	protected abstract LinksHandler getLinksHandler();
	/**
	 * Return the web endpoints being mapped.
	 * @return the endpoints
	 */
	public Collection<ExposableWebEndpoint> getEndpoints() {
		return this.endpoints;
	}
	/**
	 * An {@link OperationInvoker} that performs the invocation of a blocking operation on
	 * a separate thread using Reactor"s {@link Schedulers#boundedElastic() bounded
	 * elastic scheduler}.
	 */
	protected static final class ElasticSchedulerInvoker implements OperationInvoker {
		private final OperationInvoker invoker;
		public ElasticSchedulerInvoker(OperationInvoker invoker) {
			this.invoker = invoker;
		}
		@Override
		public Object invoke(InvocationContext context) {
			return Mono.fromCallable(() -> this.invoker.invoke(context)).subscribeOn(Schedulers.boundedElastic());
		}
	}
	protected static final class ExceptionCapturingInvoker implements OperationInvoker {
		private final OperationInvoker invoker;
		public ExceptionCapturingInvoker(OperationInvoker invoker) {
			this.invoker = invoker;
		}
		@Override
		public Object invoke(InvocationContext context) {
			try {
				return this.invoker.invoke(context);
			}
			catch (Exception ex) {
				return Mono.error(ex);
			}
		}
	}
	/**
	 * Reactive handler providing actuator links at the root endpoint.
	 */
	@FunctionalInterface
	protected interface LinksHandler {
		Object links(ServerWebExchange exchange);
	}
	/**
	 * A reactive web operation that can be handled by WebFlux.
	 */
	@FunctionalInterface
	protected interface ReactiveWebOperation {
		Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body);
	}
	/**
	 * Adapter class to convert an {@link OperationInvoker} into a
	 * {@link ReactiveWebOperation}.
	 */
	private static final class ReactiveWebOperationAdapter implements ReactiveWebOperation {
		private static final String PATH_SEPARATOR = AntPathMatcher.DEFAULT_PATH_SEPARATOR;
		private final WebOperation operation;
		private final OperationInvoker invoker;
		private final Supplier<Mono<? extends SecurityContext>> securityContextSupplier;
		private ReactiveWebOperationAdapter(WebOperation operation) {
			this.operation = operation;
			this.invoker = getInvoker(operation);
			this.securityContextSupplier = getSecurityContextSupplier();
		}
		private OperationInvoker getInvoker(WebOperation operation) {
			OperationInvoker invoker = operation::invoke;
			if (operation.isBlocking()) {
				return new ElasticSchedulerInvoker(invoker);
			}
			return new ExceptionCapturingInvoker(invoker);
		}
		private Supplier<Mono<? extends SecurityContext>> getSecurityContextSupplier() {
			if (ClassUtils.isPresent('org.springframework.security.core.context.ReactiveSecurityContextHolder',
					getClass().getClassLoader())) {
				return this::springSecurityContext;
			}
			return this::emptySecurityContext;
		}
		Mono<? extends SecurityContext> springSecurityContext() {
			return ReactiveSecurityContextHolder.getContext()
				.map((securityContext) -> new ReactiveSecurityContext(securityContext.getAuthentication()))
				.switchIfEmpty(Mono.just(new ReactiveSecurityContext(null)));
		}
		Mono<SecurityContext> emptySecurityContext() {
			return Mono.just(SecurityContext.NONE);
		}
		@Override
		public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body) {
			Map<String, Object> arguments = getArguments(exchange, body);
			OperationArgumentResolver serverNamespaceArgumentResolver = OperationArgumentResolver
				.of(WebServerNamespace.class, () -> WebServerNamespace
					.from(WebServerApplicationContext.getServerNamespace(exchange.getApplicationContext())));
			return this.securityContextSupplier.get()
				.map((securityContext) -> new InvocationContext(securityContext, arguments,
						serverNamespaceArgumentResolver,
						new ProducibleOperationArgumentResolver(
								() -> exchange.getRequest().getHeaders().get('Accept'))))
				.flatMap((invocationContext) -> handleResult((Publisher<?>) this.invoker.invoke(invocationContext),
						exchange.getRequest().getMethod()));
		}
		private Map<String, Object> getArguments(ServerWebExchange exchange, Map<String, String> body) {
			Map<String, Object> arguments = new LinkedHashMap<>(getTemplateVariables(exchange));
			String matchAllRemainingPathSegmentsVariable = this.operation.getRequestPredicate()
				.getMatchAllRemainingPathSegmentsVariable();
			if (matchAllRemainingPathSegmentsVariable != null) {
				arguments.put(matchAllRemainingPathSegmentsVariable, getRemainingPathSegments(exchange));
			}
			if (body != null) {
				arguments.putAll(body);
			}
			exchange.getRequest()
				.getQueryParams()
				.forEach((name, values) -> arguments.put(name, (values.size() != 1) ? values : values.get(0)));
			return arguments;
		}
		private Object getRemainingPathSegments(ServerWebExchange exchange) {
			PathPattern pathPattern = exchange.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);
			if (pathPattern.hasPatternSyntax()) {
				String remainingSegments = pathPattern
					.extractPathWithinPattern(exchange.getRequest().getPath().pathWithinApplication())
					.value();
				return tokenizePathSegments(remainingSegments);
			}
			return tokenizePathSegments(pathPattern.toString());
		}
		private String[] tokenizePathSegments(String value) {
			String[] segments = StringUtils.tokenizeToStringArray(value, PATH_SEPARATOR, false, true);
			for (int i = 0; i < segments.length; i++) {
				if (segments[i].contains('%')) {
					segments[i] = StringUtils.uriDecode(segments[i], StandardCharsets.UTF_8);
				}
			}
			return segments;
		}
		private Map<String, String> getTemplateVariables(ServerWebExchange exchange) {
			return exchange.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);
		}
		private Mono<ResponseEntity<Object>> handleResult(Publisher<?> result, HttpMethod httpMethod) {
			if (result instanceof Flux) {
				result = ((Flux<?>) result).collectList();
			}
			return Mono.from(result)
				.map(this::toResponseEntity)
				.onErrorMap(InvalidEndpointRequestException.class,
						(ex) -> new ResponseStatusException(HttpStatus.BAD_REQUEST, ex.getReason()))
				.defaultIfEmpty(new ResponseEntity<>(
						(httpMethod != HttpMethod.GET) ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND));
		}
		private ResponseEntity<Object> toResponseEntity(Object response) {
			if (!(response instanceof WebEndpointResponse<?> webEndpointResponse)) {
				return new ResponseEntity<>(response, HttpStatus.OK);
			}
			MediaType contentType = (webEndpointResponse.getContentType() != null)
					? new MediaType(webEndpointResponse.getContentType()) : null;
			return ResponseEntity.status(webEndpointResponse.getStatus())
				.contentType(contentType)
				.body(webEndpointResponse.getBody());
		}
		@Override
		public String toString() {
			return 'Actuator web endpoint "' + this.operation.getId() + '"';
		}
	}
	/**
	 * Handler for a {@link ReactiveWebOperation}.
	 */
	private static final class WriteOperationHandler {
		private final ReactiveWebOperation operation;
		WriteOperationHandler(ReactiveWebOperation operation) {
			this.operation = operation;
		}
		@ResponseBody
		@Reflective
		Publisher<ResponseEntity<Object>> handle(ServerWebExchange exchange,
				@RequestBody(required = false) Map<String, String> body) {
			return this.operation.handle(exchange, body);
		}
		@Override
		public String toString() {
			return this.operation.toString();
		}
	}
	/**
	 * Handler for a {@link ReactiveWebOperation}.
	 */
	private static final class ReadOperationHandler {
		private final ReactiveWebOperation operation;
		ReadOperationHandler(ReactiveWebOperation operation) {
			this.operation = operation;
		}
		@ResponseBody
		@Reflective
		Publisher<ResponseEntity<Object>> handle(ServerWebExchange exchange) {
			return this.operation.handle(exchange, null);
		}
		@Override
		public String toString() {
			return this.operation.toString();
		}
	}
	private static class WebFluxEndpointHandlerMethod extends HandlerMethod {
		WebFluxEndpointHandlerMethod(Object bean, Method method) {
			super(bean, method);
		}
		@Override
		public String toString() {
			return getBean().toString();
		}
		@Override
		public HandlerMethod createWithResolvedBean() {
			HandlerMethod handlerMethod = super.createWithResolvedBean();
			return new WebFluxEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod());
		}
	}
	private static final class ReactiveSecurityContext implements SecurityContext {
		private static final String ROLE_PREFIX = 'ROLE_';
		private final Authentication authentication;
		ReactiveSecurityContext(Authentication authentication) {
			this.authentication = authentication;
		}
		private Authentication getAuthentication() {
			return this.authentication;
		}
		@Override
		public Principal getPrincipal() {
			return this.authentication;
		}
		@Override
		public boolean isUserInRole(String role) {
			String authority = (!role.startsWith(ROLE_PREFIX)) ? ROLE_PREFIX + role : role;
			AuthorizationResult result = AuthorityAuthorizationManager.hasAuthority(authority)
				.authorize(this::getAuthentication, null);
			return result != null && result.isGranted();
		}
	}
	static class AbstractWebFluxEndpointHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {
		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.reflectiveRegistrar.registerRuntimeHints(hints, WriteOperationHandler.class,
					ReadOperationHandler.class);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.web.reactive;
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public enum WebEndpointHttpMethod {
	/**
	 * An HTTP GET request.
	 */
	GET,
	/**
	 * An HTTP POST request.
	 */
	POST,
	/**
	 * An HTTP DELETE request.
	 */
	DELETE
}
/*
package org.springframework.boot.actuate.endpoint.web;
/**
public interface ExposableWebEndpoint extends ExposableEndpoint<WebOperation>, PathMappedEndpoint {
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public interface OperationArgumentResolver {
	/**
	 * Return whether an argument of the given {@code type} can be resolved.
	 * @param type argument type
	 * @return {@code true} if an argument of the required type can be resolved, otherwise
	 * {@code false}
	 */
	boolean canResolve(Class<?> type);
	/**
	 * Resolves an argument of the given {@code type}.
	 * @param <T> required type of the argument
	 * @param type argument type
	 * @return an argument of the required type, or {@code null}
	 */
	<T> T resolve(Class<T> type);
	/**
	 * Factory method that creates an {@link OperationArgumentResolver} for a specific
	 * type using a {@link Supplier}.
	 * @param <T> the resolvable type
	 * @param type the resolvable type
	 * @param supplier the value supplier
	 * @return an {@link OperationArgumentResolver} instance
	 */
	static <T> OperationArgumentResolver of(Class<T> type, Supplier<? extends T> supplier) {
		Assert.notNull(type, 'Type must not be null');
		Assert.notNull(supplier, 'Supplier must not be null');
		return new OperationArgumentResolver() {
			@Override
			public boolean canResolve(Class<?> actualType) {
				return actualType.equals(type);
			}
			@Override
			@SuppressWarnings('unchecked')
			public <R> R resolve(Class<R> argumentType) {
				return (R) supplier.get();
			}
		};
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public interface SecurityContext {
	/**
	 * Empty security context.
	 */
	SecurityContext NONE = new SecurityContext() {
		@Override
		public Principal getPrincipal() {
			return null;
		}
		@Override
		public boolean isUserInRole(String role) {
			return false;
		}
	};
	/**
	 * Return the currently authenticated {@link Principal} or {@code null}.
	 * @return the principal or {@code null}
	 */
	Principal getPrincipal();
	/**
	 * Returns {@code true} if the currently authenticated user is in the given
	 * {@code role}, or false otherwise.
	 * @param role name of the role
	 * @return {@code true} if the user is in the given role
	 */
	boolean isUserInRole(String role);
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public enum ApiVersion implements Producible<ApiVersion> {
	/**
	 * Version 2 (supported by Spring Boot 2.0+).
	 */
	V2('application/vnd.spring-boot.actuator.v2+json'),
	/**
	 * Version 3 (supported by Spring Boot 2.2+).
	 */
	V3('application/vnd.spring-boot.actuator.v3+json');
	/**
	 * The latest API version.
	 */
	public static final ApiVersion LATEST = ApiVersion.V3;
	private final MimeType mimeType;
	ApiVersion(String mimeType) {
		this.mimeType = MimeTypeUtils.parseMimeType(mimeType);
	}
	@Override
	public MimeType getProducedMimeType() {
		return this.mimeType;
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public interface Producible<E extends Enum<E> & Producible<E>> {
	/**
	 * Mime type that can be produced.
	 * @return the producible mime type
	 */
	MimeType getProducedMimeType();
	/**
	 * Return if this enum value should be used as the default value when an accept header
	 * of &#42;&#47;&#42; is provided, or if the {@code Accept} header is missing. Only
	 * one value can be marked as default. If no value is marked, then the value with the
	 * highest {@link Enum#ordinal() ordinal} is used as the default.
	 * @return if this value should be used as the default value
	 * @since 2.5.6
	 */
	default boolean isDefault() {
		return false;
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
@FunctionalInterface
public interface OperationFilter<O extends Operation> {
	/**
	 * Return {@code true} if the filter matches.
	 * @param endpointId the ID of the endpoint to which the operation belongs
	 * @param operation the operation to check
	 * @param defaultAccess the default permitted level of access to the endpoint
	 * @return {@code true} if the filter matches
	 */
	boolean match(O operation, EndpointId endpointId, Access defaultAccess);
	/**
	 * Return an {@link OperationFilter} that filters based on the allowed {@link Access
	 * access} as determined by an {@link EndpointAccessResolver access resolver}.
	 * @param <O> the operation type
	 * @param accessResolver the access resolver
	 * @return a new {@link OperationFilter}
	 */
	static <O extends Operation> OperationFilter<O> byAccess(EndpointAccessResolver accessResolver) {
		return (operation, endpointId, defaultAccess) -> {
			Access access = accessResolver.accessFor(endpointId, defaultAccess);
			return switch (access) {
				case NONE -> false;
				case READ_ONLY -> operation.getType() == OperationType.READ;
				case UNRESTRICTED -> true;
			};
		};
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public enum OperationType {
	/**
	 * A read operation.
	 */
	READ,
	/**
	 * A write operation.
	 */
	WRITE,
	/**
	 * A delete operation.
	 */
	DELETE
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public final class SanitizableData {
	/**
	 * Represents a sanitized value.
	 */
	public static final String SANITIZED_VALUE = '******';
	private final PropertySource<?> propertySource;
	private final String key;
	private final Object value;
	/**
	 * Create a new {@link SanitizableData} instance.
	 * @param propertySource the property source that provided the data or {@code null}.
	 * @param key the data key
	 * @param value the data value
	 */
	public SanitizableData(PropertySource<?> propertySource, String key, Object value) {
		this.propertySource = propertySource;
		this.key = key;
		this.value = value;
	}
	/**
	 * Return the property source that provided the data or {@code null} If the data was
	 * not from a {@link PropertySource}.
	 * @return the property source that provided the data
	 */
	public PropertySource<?> getPropertySource() {
		return this.propertySource;
	}
	/**
	 * Return the key of the data.
	 * @return the data key
	 */
	public String getKey() {
		return this.key;
	}
	/**
	 * Return the value of the data.
	 * @return the data value
	 */
	public Object getValue() {
		return this.value;
	}
	/**
	 * Return a new {@link SanitizableData} instance with sanitized value.
	 * @return a new sanitizable data instance.
	 * @since 3.1.0
	 */
	public SanitizableData withSanitizedValue() {
		return withValue(SANITIZED_VALUE);
	}
	/**
	 * Return a new {@link SanitizableData} instance with a different value.
	 * @param value the new value (often {@link #SANITIZED_VALUE}
	 * @return a new sanitizable data instance
	 */
	public SanitizableData withValue(Object value) {
		return new SanitizableData(this.propertySource, this.key, value);
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
@FunctionalInterface
public interface EndpointsSupplier<E extends ExposableEndpoint<?>> {
	/**
	 * Return the provided endpoints.
	 * @return the endpoints
	 */
	Collection<E> getEndpoints();
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public enum Access {
	/**
	 * No access to the endpoint is permitted.
	 */
	NONE,
	/**
	 * Read-only access to the endpoint is permitted.
	 */
	READ_ONLY,
	/**
	 * Unrestricted access to the endpoint is permitted.
	 */
	UNRESTRICTED;
	/**
	 * Cap access to a maximum permitted.
	 * @param maxPermitted the maximum permitted access
	 * @return this access if less than the maximum or the maximum permitted
	 */
	public Access cap(Access maxPermitted) {
		Assert.notNull(maxPermitted, '"maxPermittedAccess" must not be null');
		return (ordinal() <= maxPermitted.ordinal()) ? this : maxPermitted;
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoker.cache;
/**
public class CachingOperationInvoker implements OperationInvoker {
	private static final boolean IS_REACTOR_PRESENT = ClassUtils.isPresent('reactor.core.publisher.Mono', null);
	private static final int CACHE_CLEANUP_THRESHOLD = 40;
	private final OperationInvoker invoker;
	private final long timeToLive;
	private final Map<CacheKey, CachedResponse> cachedResponses;
	/**
	 * Create a new instance with the target {@link OperationInvoker} to use to compute
	 * the response and the time to live for the cache.
	 * @param invoker the {@link OperationInvoker} this instance wraps
	 * @param timeToLive the maximum time in milliseconds that a response can be cached
	 */
	CachingOperationInvoker(OperationInvoker invoker, long timeToLive) {
		Assert.isTrue(timeToLive > 0, 'TimeToLive must be strictly positive');
		this.invoker = invoker;
		this.timeToLive = timeToLive;
		this.cachedResponses = new ConcurrentReferenceHashMap<>();
	}
	/**
	 * Return the maximum time in milliseconds that a response can be cached.
	 * @return the time to live of a response
	 */
	public long getTimeToLive() {
		return this.timeToLive;
	}
	@Override
	public Object invoke(InvocationContext context) {
		if (hasInput(context)) {
			return this.invoker.invoke(context);
		}
		long accessTime = System.currentTimeMillis();
		if (this.cachedResponses.size() > CACHE_CLEANUP_THRESHOLD) {
			cleanExpiredCachedResponses(accessTime);
		}
		CacheKey cacheKey = getCacheKey(context);
		CachedResponse cached = this.cachedResponses.get(cacheKey);
		if (cached == null || cached.isStale(accessTime, this.timeToLive)) {
			Object response = this.invoker.invoke(context);
			cached = createCachedResponse(response, accessTime);
			this.cachedResponses.put(cacheKey, cached);
		}
		return cached.getResponse();
	}
	private CacheKey getCacheKey(InvocationContext context) {
		ApiVersion contextApiVersion = context.resolveArgument(ApiVersion.class);
		Principal principal = context.resolveArgument(Principal.class);
		WebServerNamespace serverNamespace = context.resolveArgument(WebServerNamespace.class);
		return new CacheKey(contextApiVersion, principal, serverNamespace);
	}
	private void cleanExpiredCachedResponses(long accessTime) {
		try {
			this.cachedResponses.entrySet().removeIf((entry) -> entry.getValue().isStale(accessTime, this.timeToLive));
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	private boolean hasInput(InvocationContext context) {
		Map<String, Object> arguments = context.getArguments();
		if (!ObjectUtils.isEmpty(arguments)) {
			return arguments.values().stream().anyMatch(Objects::nonNull);
		}
		return false;
	}
	private CachedResponse createCachedResponse(Object response, long accessTime) {
		if (IS_REACTOR_PRESENT) {
			return new ReactiveCachedResponse(response, accessTime, this.timeToLive);
		}
		return new CachedResponse(response, accessTime);
	}
	static boolean isApplicable(OperationParameters parameters) {
		for (OperationParameter parameter : parameters) {
			if (parameter.isMandatory() && !CacheKey.containsType(parameter.getType())) {
				return false;
			}
		}
		return true;
	}
	/**
	 * A cached response that encapsulates the response itself and the time at which it
	 * was created.
	 */
	static class CachedResponse {
		private final Object response;
		private final long creationTime;
		CachedResponse(Object response, long creationTime) {
			this.response = response;
			this.creationTime = creationTime;
		}
		boolean isStale(long accessTime, long timeToLive) {
			return (accessTime - this.creationTime) >= timeToLive;
		}
		Object getResponse() {
			return this.response;
		}
	}
	/**
	 * {@link CachedResponse} variant used when Reactor is present.
	 */
	static class ReactiveCachedResponse extends CachedResponse {
		ReactiveCachedResponse(Object response, long creationTime, long timeToLive) {
			super(applyCaching(response, timeToLive), creationTime);
		}
		private static Object applyCaching(Object response, long timeToLive) {
			if (response instanceof Mono) {
				return ((Mono<?>) response).cache(Duration.ofMillis(timeToLive));
			}
			if (response instanceof Flux) {
				return ((Flux<?>) response).cache(Duration.ofMillis(timeToLive));
			}
			return response;
		}
	}
	private static final class CacheKey {
		private static final Class<?>[] CACHEABLE_TYPES = new Class<?>[] { ApiVersion.class, SecurityContext.class,
				WebServerNamespace.class };
		private final ApiVersion apiVersion;
		private final Principal principal;
		private final WebServerNamespace serverNamespace;
		private CacheKey(ApiVersion apiVersion, Principal principal, WebServerNamespace serverNamespace) {
			this.principal = principal;
			this.apiVersion = apiVersion;
			this.serverNamespace = serverNamespace;
		}
		static boolean containsType(Class<?> type) {
			return Arrays.stream(CacheKey.CACHEABLE_TYPES).anyMatch((c) -> c.isAssignableFrom(type));
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			CacheKey other = (CacheKey) obj;
			return this.apiVersion.equals(other.apiVersion)
					&& ObjectUtils.nullSafeEquals(this.principal, other.principal)
					&& ObjectUtils.nullSafeEquals(this.serverNamespace, other.serverNamespace);
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + this.apiVersion.hashCode();
			result = prime * result + ObjectUtils.nullSafeHashCode(this.principal);
			result = prime * result + ObjectUtils.nullSafeHashCode(this.serverNamespace);
			return result;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoker.cache;
/**
public class CachingOperationInvokerAdvisor implements OperationInvokerAdvisor {
	private final Function<EndpointId, Long> endpointIdTimeToLive;
	public CachingOperationInvokerAdvisor(Function<EndpointId, Long> endpointIdTimeToLive) {
		this.endpointIdTimeToLive = endpointIdTimeToLive;
	}
	@Override
	public OperationInvoker apply(EndpointId endpointId, OperationType operationType, OperationParameters parameters,
			OperationInvoker invoker) {
		if (operationType == OperationType.READ && CachingOperationInvoker.isApplicable(parameters)) {
			Long timeToLive = this.endpointIdTimeToLive.apply(endpointId);
			if (timeToLive != null && timeToLive > 0) {
				return new CachingOperationInvoker(invoker, timeToLive);
			}
		}
		return invoker;
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.invoker.cache;
/*
package org.springframework.boot.actuate.endpoint;
/**
public interface EndpointAccessResolver {
	/**
	 * Resolves the permitted level of access for the endpoint with the given
	 * {@code endpointId} and {@code defaultAccess}.
	 * @param endpointId the ID of the endpoint
	 * @param defaultAccess the default access level of the endpoint
	 * @return the permitted level of access, never {@code null}
	 */
	Access accessFor(EndpointId endpointId, Access defaultAccess);
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public final class EndpointId {
	private static final Log logger = LogFactory.getLog(EndpointId.class);
	private static final Set<String> loggedWarnings = new HashSet<>();
	private static final Pattern VALID_PATTERN = Pattern.compile('[a-zA-Z0-9.-]+');
	private static final Pattern WARNING_PATTERN = Pattern.compile('[.-]+');
	private static final String MIGRATE_LEGACY_NAMES_PROPERTY = 'management.endpoints.migrate-legacy-ids';
	private final String value;
	private final String lowerCaseValue;
	private final String lowerCaseAlphaNumeric;
	private EndpointId(String value) {
		Assert.hasText(value, 'Value must not be empty');
		Assert.isTrue(VALID_PATTERN.matcher(value).matches(), 'Value must only contain valid chars');
		Assert.isTrue(!Character.isDigit(value.charAt(0)), 'Value must not start with a number');
		Assert.isTrue(!Character.isUpperCase(value.charAt(0)), 'Value must not start with an uppercase letter');
		if (WARNING_PATTERN.matcher(value).find()) {
			logWarning(value);
		}
		this.value = value;
		this.lowerCaseValue = value.toLowerCase(Locale.ENGLISH);
		this.lowerCaseAlphaNumeric = getAlphaNumerics(this.lowerCaseValue);
	}
	private String getAlphaNumerics(String value) {
		StringBuilder result = new StringBuilder(value.length());
		for (int i = 0; i < value.length(); i++) {
			char ch = value.charAt(i);
			if (ch >= "a" && ch <= "z" || ch >= "0" && ch <= "9") {
				result.append(ch);
			}
		}
		return result.toString();
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.lowerCaseAlphaNumeric.equals(((EndpointId) obj).lowerCaseAlphaNumeric);
	}
	@Override
	public int hashCode() {
		return this.lowerCaseAlphaNumeric.hashCode();
	}
	/**
	 * Return a lower-case version of the endpoint ID.
	 * @return the lower-case endpoint ID
	 */
	public String toLowerCaseString() {
		return this.lowerCaseValue;
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Factory method to create a new {@link EndpointId} of the specified value.
	 * @param value the endpoint ID value
	 * @return an {@link EndpointId} instance
	 */
	public static EndpointId of(String value) {
		return new EndpointId(value);
	}
	/**
	 * Factory method to create a new {@link EndpointId} of the specified value. This
	 * variant will respect the {@code management.endpoints.migrate-legacy-names} property
	 * if it has been set in the {@link Environment}.
	 * @param environment the Spring environment
	 * @param value the endpoint ID value
	 * @return an {@link EndpointId} instance
	 * @since 2.2.0
	 */
	public static EndpointId of(Environment environment, String value) {
		Assert.notNull(environment, 'Environment must not be null');
		return new EndpointId(migrateLegacyId(environment, value));
	}
	private static String migrateLegacyId(Environment environment, String value) {
		if (environment.getProperty(MIGRATE_LEGACY_NAMES_PROPERTY, Boolean.class, false)) {
			return value.replaceAll('[-.]+', '');
		}
		return value;
	}
	/**
	 * Factory method to create a new {@link EndpointId} from a property value. More
	 * lenient than {@link #of(String)} to allow for common 'relaxed' property variants.
	 * @param value the property value to convert
	 * @return an {@link EndpointId} instance
	 */
	public static EndpointId fromPropertyValue(String value) {
		return new EndpointId(value.replace('-', ''));
	}
	static void resetLoggedWarnings() {
		loggedWarnings.clear();
	}
	private static void logWarning(String value) {
		if (logger.isWarnEnabled() && loggedWarnings.add(value)) {
			logger.warn('Endpoint ID "' + value + '" contains invalid characters, please migrate to a valid format.');
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
@FunctionalInterface
public interface SanitizingFunction {
	/**
	 * Apply the sanitizing function to the given data.
	 * @param data the data to sanitize
	 * @return the sanitized data or the original instance is no sanitization is applied
	 */
	SanitizableData apply(SanitizableData data);
}
/*
package org.springframework.boot.actuate.endpoint;
/**
@FunctionalInterface
public interface EndpointFilter<E extends ExposableEndpoint<?>> {
	/**
	 * Return {@code true} if the filter matches.
	 * @param endpoint the endpoint to check
	 * @return {@code true} if the filter matches
	 */
	boolean match(E endpoint);
}
/*
package org.springframework.boot.actuate.endpoint.invoke.convert;
/**
public class IsoOffsetDateTimeConverter implements Converter<String, OffsetDateTime> {
	@Override
	public OffsetDateTime convert(String source) {
		if (StringUtils.hasLength(source)) {
			return OffsetDateTime.parse(source, DateTimeFormatter.ISO_OFFSET_DATE_TIME);
		}
		return null;
	}
	public static void registerConverter(ConverterRegistry registry) {
		registry.addConverter(new IsoOffsetDateTimeConverter());
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.convert;
/**
public class ConversionServiceParameterValueMapper implements ParameterValueMapper {
	private final ConversionService conversionService;
	/**
	 * Create a new {@link ConversionServiceParameterValueMapper} instance.
	 */
	public ConversionServiceParameterValueMapper() {
		this(ApplicationConversionService.getSharedInstance());
	}
	/**
	 * Create a new {@link ConversionServiceParameterValueMapper} instance backed by a
	 * specific conversion service.
	 * @param conversionService the conversion service
	 */
	public ConversionServiceParameterValueMapper(ConversionService conversionService) {
		Assert.notNull(conversionService, 'ConversionService must not be null');
		this.conversionService = conversionService;
	}
	@Override
	public Object mapParameterValue(OperationParameter parameter, Object value) throws ParameterMappingException {
		try {
			return this.conversionService.convert(value, parameter.getType());
		}
		catch (Exception ex) {
			throw new ParameterMappingException(parameter, value, ex);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.invoke.convert;
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
class OperationMethodParameter implements OperationParameter {
	private static final boolean jsr305Present = ClassUtils.isPresent('javax.annotation.Nonnull', null);
	private final String name;
	private final Parameter parameter;
	/**
	 * Create a new {@link OperationMethodParameter} instance.
	 * @param name the parameter name
	 * @param parameter the parameter
	 */
	OperationMethodParameter(String name, Parameter parameter) {
		this.name = name;
		this.parameter = parameter;
	}
	@Override
	public String getName() {
		return this.name;
	}
	@Override
	public Class<?> getType() {
		return this.parameter.getType();
	}
	@Override
	public boolean isMandatory() {
		if (!ObjectUtils.isEmpty(this.parameter.getAnnotationsByType(Nullable.class))) {
			return false;
		}
		if (jsr305Present) {
			return new Jsr305().isMandatory(this.parameter);
		}
		return true;
	}
	@Override
	public <T extends Annotation> T getAnnotation(Class<T> annotation) {
		return this.parameter.getAnnotation(annotation);
	}
	@Override
	public String toString() {
		return this.name + ' of type ' + this.parameter.getType().getName();
	}
	private static final class Jsr305 {
		boolean isMandatory(Parameter parameter) {
			MergedAnnotation<Nonnull> annotation = MergedAnnotations.from(parameter).get(Nonnull.class);
			return !annotation.isPresent() || annotation.getEnum('when', When.class) == When.ALWAYS;
		}
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
class OperationMethodParameters implements OperationParameters {
	private final List<OperationParameter> operationParameters;
	/**
	 * Create a new {@link OperationMethodParameters} instance.
	 * @param method the source method
	 * @param parameterNameDiscoverer the parameter name discoverer
	 */
	OperationMethodParameters(Method method, ParameterNameDiscoverer parameterNameDiscoverer) {
		Assert.notNull(method, 'Method must not be null');
		Assert.notNull(parameterNameDiscoverer, 'ParameterNameDiscoverer must not be null');
		String[] parameterNames = parameterNameDiscoverer.getParameterNames(method);
		Parameter[] parameters = method.getParameters();
		Assert.state(parameterNames != null, () -> 'Failed to extract parameter names for ' + method);
		this.operationParameters = getOperationParameters(parameters, parameterNames);
	}
	private List<OperationParameter> getOperationParameters(Parameter[] parameters, String[] names) {
		List<OperationParameter> operationParameters = new ArrayList<>(parameters.length);
		for (int i = 0; i < names.length; i++) {
			operationParameters.add(new OperationMethodParameter(names[i], parameters[i]));
		}
		return Collections.unmodifiableList(operationParameters);
	}
	@Override
	public int getParameterCount() {
		return this.operationParameters.size();
	}
	@Override
	public OperationParameter get(int index) {
		return this.operationParameters.get(index);
	}
	@Override
	public Iterator<OperationParameter> iterator() {
		return this.operationParameters.iterator();
	}
	@Override
	public Stream<OperationParameter> stream() {
		return this.operationParameters.stream();
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
public class OperationMethod {
	private static final ParameterNameDiscoverer DEFAULT_PARAMETER_NAME_DISCOVERER = new DefaultParameterNameDiscoverer();
	private final Method method;
	private final OperationType operationType;
	private final OperationParameters operationParameters;
	/**
	 * Create a new {@link OperationMethod} instance.
	 * @param method the source method
	 * @param operationType the operation type
	 */
	public OperationMethod(Method method, OperationType operationType) {
		Assert.notNull(method, 'Method must not be null');
		Assert.notNull(operationType, 'OperationType must not be null');
		this.method = method;
		this.operationType = operationType;
		this.operationParameters = new OperationMethodParameters(method, DEFAULT_PARAMETER_NAME_DISCOVERER);
	}
	/**
	 * Return the source Java method.
	 * @return the method
	 */
	public Method getMethod() {
		return this.method;
	}
	/**
	 * Return the operation type.
	 * @return the operation type
	 */
	public OperationType getOperationType() {
		return this.operationType;
	}
	/**
	 * Return the operation parameters.
	 * @return the operation parameters
	 */
	public OperationParameters getParameters() {
		return this.operationParameters;
	}
	@Override
	public String toString() {
		return 'Operation ' + this.operationType.name().toLowerCase(Locale.ENGLISH) + ' method ' + this.method;
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/**
public class ReflectiveOperationInvoker implements OperationInvoker {
	private final Object target;
	private final OperationMethod operationMethod;
	private final ParameterValueMapper parameterValueMapper;
	/**
	 * Creates a new {@code ReflectiveOperationInvoker} that will invoke the given
	 * {@code method} on the given {@code target}. The given {@code parameterMapper} will
	 * be used to map parameters to the required types and the given
	 * {@code parameterNameMapper} will be used map parameters by name.
	 * @param target the target of the reflective call
	 * @param operationMethod the method info
	 * @param parameterValueMapper the parameter mapper
	 */
	public ReflectiveOperationInvoker(Object target, OperationMethod operationMethod,
			ParameterValueMapper parameterValueMapper) {
		Assert.notNull(target, 'Target must not be null');
		Assert.notNull(operationMethod, 'OperationMethod must not be null');
		Assert.notNull(parameterValueMapper, 'ParameterValueMapper must not be null');
		ReflectionUtils.makeAccessible(operationMethod.getMethod());
		this.target = target;
		this.operationMethod = operationMethod;
		this.parameterValueMapper = parameterValueMapper;
	}
	@Override
	public Object invoke(InvocationContext context) {
		validateRequiredParameters(context);
		Method method = this.operationMethod.getMethod();
		Object[] resolvedArguments = resolveArguments(context);
		ReflectionUtils.makeAccessible(method);
		return ReflectionUtils.invokeMethod(method, this.target, resolvedArguments);
	}
	private void validateRequiredParameters(InvocationContext context) {
		Set<OperationParameter> missing = this.operationMethod.getParameters()
			.stream()
			.filter((parameter) -> isMissing(context, parameter))
			.collect(Collectors.toSet());
		if (!missing.isEmpty()) {
			throw new MissingParametersException(missing);
		}
	}
	private boolean isMissing(InvocationContext context, OperationParameter parameter) {
		if (!parameter.isMandatory()) {
			return false;
		}
		if (context.canResolve(parameter.getType())) {
			return false;
		}
		return context.getArguments().get(parameter.getName()) == null;
	}
	private Object[] resolveArguments(InvocationContext context) {
		return this.operationMethod.getParameters()
			.stream()
			.map((parameter) -> resolveArgument(parameter, context))
			.toArray();
	}
	private Object resolveArgument(OperationParameter parameter, InvocationContext context) {
		Object resolvedByType = context.resolveArgument(parameter.getType());
		if (resolvedByType != null) {
			return resolvedByType;
		}
		Object value = context.getArguments().get(parameter.getName());
		return this.parameterValueMapper.mapParameterValue(parameter, value);
	}
	@Override
	public String toString() {
		return new ToStringCreator(this).append('target', this.target)
			.append('method', this.operationMethod)
			.toString();
	}
}
/*
/**
package org.springframework.boot.actuate.endpoint.invoke.reflect;
/*
package org.springframework.boot.actuate.endpoint.invoke;
/**
@FunctionalInterface
public interface OperationInvoker {
	/**
	 * Invoke the underlying operation using the given {@code context}.
	 * @param context the context to use to invoke the operation
	 * @return the result of the operation, may be {@code null}
	 * @throws MissingParametersException if parameters are missing
	 */
	Object invoke(InvocationContext context) throws MissingParametersException;
}
/*
package org.springframework.boot.actuate.endpoint.invoke;
/**
@FunctionalInterface
public interface ParameterValueMapper {
	/**
	 * A {@link ParameterValueMapper} that does nothing.
	 */
	ParameterValueMapper NONE = (parameter, value) -> value;
	/**
	 * Map the specified {@code input} parameter to the given {@code parameterType}.
	 * @param parameter the parameter to map
	 * @param value a parameter value
	 * @return a value suitable for that parameter
	 * @throws ParameterMappingException when a mapping failure occurs
	 */
	Object mapParameterValue(OperationParameter parameter, Object value) throws ParameterMappingException;
}
/*
package org.springframework.boot.actuate.endpoint.invoke;
/**
public interface OperationParameter {
	/**
	 * Returns the parameter name.
	 * @return the name
	 */
	String getName();
	/**
	 * Returns the parameter type.
	 * @return the type
	 */
	Class<?> getType();
	/**
	 * Return if the parameter is mandatory (does not accept null values).
	 * @return if the parameter is mandatory
	 */
	boolean isMandatory();
	/**
	 * Returns this element"s annotation for the specified type if such an annotation is
	 * present, else null.
	 * @param annotation class of the annotation
	 * @return annotation value
	 * @param <T> type of the annotation
	 * @since 2.7.8
	 */
	<T extends Annotation> T getAnnotation(Class<T> annotation);
}
/*
package org.springframework.boot.actuate.endpoint.invoke;
/**
@FunctionalInterface
public interface OperationInvokerAdvisor {
	/**
	 * Apply additional functionality to the given invoker.
	 * @param endpointId the endpoint ID
	 * @param operationType the operation type
	 * @param parameters the operation parameters
	 * @param invoker the invoker to advise
	 * @return a potentially new operation invoker with support for additional features
	 */
	OperationInvoker apply(EndpointId endpointId, OperationType operationType, OperationParameters parameters,
			OperationInvoker invoker);
}
/*
package org.springframework.boot.actuate.endpoint.invoke;
/**
public final class ParameterMappingException extends InvalidEndpointRequestException {
	private final OperationParameter parameter;
	private final Object value;
	/**
	 * Creates a new {@code ParameterMappingException} for a failure that occurred when
	 * trying to map the given {@code input} to the given {@code type}.
	 * @param parameter the parameter being mapping
	 * @param value the value being mapped
	 * @param cause the cause of the mapping failure
	 */
	public ParameterMappingException(OperationParameter parameter, Object value, Throwable cause) {
		super('Failed to map ' + value + ' of type ' + value.getClass() + ' to ' + parameter,
				'Parameter mapping failure', cause);
		this.parameter = parameter;
		this.value = value;
	}
	/**
	 * Return the parameter being mapped.
	 * @return the parameter
	 */
	public OperationParameter getParameter() {
		return this.parameter;
	}
	/**
	 * Return the value being mapped.
	 * @return the value
	 */
	public Object getValue() {
		return this.value;
	}
}
/*
package org.springframework.boot.actuate.endpoint.invoke;
/**
public interface OperationParameters extends Iterable<OperationParameter> {
	/**
	 * Return {@code true} if there is at least one parameter.
	 * @return if there are parameters
	 */
	default boolean hasParameters() {
		return getParameterCount() > 0;
	}
	/**
	 * Return the total number of parameters.
	 * @return the total number of parameters
	 */
	int getParameterCount();
	/**
	 * Return if any of the contained parameters are
	 * {@link OperationParameter#isMandatory() mandatory}.
	 * @return if any parameters are mandatory
	 */
	default boolean hasMandatoryParameter() {
		return stream().anyMatch(OperationParameter::isMandatory);
	}
	/**
	 * Return the parameter at the specified index.
	 * @param index the parameter index
	 * @return the parameter
	 */
	OperationParameter get(int index);
	/**
	 * Return a stream of the contained parameters.
	 * @return a stream of the parameters
	 */
	Stream<OperationParameter> stream();
}
/*
/**
package org.springframework.boot.actuate.endpoint.invoke;
/*
package org.springframework.boot.actuate.endpoint.invoke;
/**
public final class MissingParametersException extends InvalidEndpointRequestException {
	private final Set<OperationParameter> missingParameters;
	public MissingParametersException(Set<OperationParameter> missingParameters) {
		super('Failed to invoke operation because the following required parameters were missing: '
				+ StringUtils.collectionToCommaDelimitedString(missingParameters),
				'Missing parameters: '
						+ missingParameters.stream().map(OperationParameter::getName).collect(Collectors.joining(',')));
		this.missingParameters = missingParameters;
	}
	/**
	 * Returns the parameters that were missing.
	 * @return the parameters
	 */
	public Set<OperationParameter> getMissingParameters() {
		return this.missingParameters;
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public abstract class AbstractExposableEndpoint<O extends Operation> implements ExposableEndpoint<O> {
	private final EndpointId id;
	private final Access defaultAccess;
	private final List<O> operations;
	/**
	 * Create a new {@link AbstractExposableEndpoint} instance.
	 * @param id the endpoint id
	 * @param enabledByDefault if the endpoint is enabled by default
	 * @param operations the endpoint operations
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #AbstractExposableEndpoint(EndpointId, Access, Collection)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public AbstractExposableEndpoint(EndpointId id, boolean enabledByDefault, Collection<? extends O> operations) {
		this(id, (enabledByDefault) ? Access.UNRESTRICTED : Access.READ_ONLY, operations);
	}
	/**
	 * Create a new {@link AbstractExposableEndpoint} instance.
	 * @param id the endpoint id
	 * @param defaultAccess access to the endpoint that is permitted by default
	 * @param operations the endpoint operations
	 * @since 3.4.0
	 */
	public AbstractExposableEndpoint(EndpointId id, Access defaultAccess, Collection<? extends O> operations) {
		Assert.notNull(id, 'ID must not be null');
		Assert.notNull(operations, 'Operations must not be null');
		this.id = id;
		this.defaultAccess = defaultAccess;
		this.operations = List.copyOf(operations);
	}
	@Override
	public EndpointId getEndpointId() {
		return this.id;
	}
	@Override
	@SuppressWarnings('removal')
	@Deprecated(since = '3.4.0', forRemoval = true)
	public boolean isEnableByDefault() {
		return this.defaultAccess != Access.NONE;
	}
	@Override
	public Access getDefaultAccess() {
		return this.defaultAccess;
	}
	@Override
	public Collection<O> getOperations() {
		return this.operations;
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public enum Show {
	/**
	 * Never show the item in the response.
	 */
	NEVER,
	/**
	 * Show the item in the response when accessed by an authorized user.
	 */
	WHEN_AUTHORIZED,
	/**
	 * Always show the item in the response.
	 */
	ALWAYS;
	/**
	 * Return if data should be shown when no {@link SecurityContext} is available.
	 * @param unauthorizedResult the result to used for an unauthorized user
	 * @return if data should be shown
	 */
	public boolean isShown(boolean unauthorizedResult) {
		return switch (this) {
			case NEVER -> false;
			case ALWAYS -> true;
			case WHEN_AUTHORIZED -> unauthorizedResult;
		};
	}
	/**
	 * Return if data should be shown.
	 * @param securityContext the security context
	 * @param roles the required roles
	 * @return if data should be shown
	 */
	public boolean isShown(SecurityContext securityContext, Collection<String> roles) {
		return switch (this) {
			case NEVER -> false;
			case ALWAYS -> true;
			case WHEN_AUTHORIZED -> isAuthorized(securityContext, roles);
		};
	}
	private boolean isAuthorized(SecurityContext securityContext, Collection<String> roles) {
		Principal principal = securityContext.getPrincipal();
		if (principal == null) {
			return false;
		}
		if (CollectionUtils.isEmpty(roles)) {
			return true;
		}
		boolean checkAuthorities = isSpringSecurityAuthentication(principal);
		for (String role : roles) {
			if (securityContext.isUserInRole(role)) {
				return true;
			}
			if (checkAuthorities) {
				Authentication authentication = (Authentication) principal;
				for (GrantedAuthority authority : authentication.getAuthorities()) {
					String name = authority.getAuthority();
					if (role.equals(name)) {
						return true;
					}
				}
			}
		}
		return false;
	}
	private boolean isSpringSecurityAuthentication(Principal principal) {
		return ClassUtils.isPresent('org.springframework.security.core.Authentication', null)
				&& (principal instanceof Authentication);
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public class ProducibleOperationArgumentResolver implements OperationArgumentResolver {
	private final Supplier<List<String>> accepts;
	/**
	 * Create a new {@link ProducibleOperationArgumentResolver} instance.
	 * @param accepts supplier that returns accepted mime types
	 */
	public ProducibleOperationArgumentResolver(Supplier<List<String>> accepts) {
		this.accepts = accepts;
	}
	@Override
	public boolean canResolve(Class<?> type) {
		return Producible.class.isAssignableFrom(type) && Enum.class.isAssignableFrom(type);
	}
	@SuppressWarnings('unchecked')
	@Override
	public <T> T resolve(Class<T> type) {
		return (T) resolveProducible((Class<Enum<? extends Producible<?>>>) type);
	}
	private Enum<? extends Producible<?>> resolveProducible(Class<Enum<? extends Producible<?>>> type) {
		List<String> accepts = this.accepts.get();
		List<Enum<? extends Producible<?>>> values = getValues(type);
		if (CollectionUtils.isEmpty(accepts)) {
			return getDefaultValue(values);
		}
		Enum<? extends Producible<?>> result = null;
		for (String accept : accepts) {
			for (String mimeType : MimeTypeUtils.tokenize(accept)) {
				result = mostRecent(result, forMimeType(values, MimeTypeUtils.parseMimeType(mimeType)));
			}
		}
		return result;
	}
	private Enum<? extends Producible<?>> mostRecent(Enum<? extends Producible<?>> existing,
			Enum<? extends Producible<?>> candidate) {
		int existingOrdinal = (existing != null) ? existing.ordinal() : -1;
		int candidateOrdinal = (candidate != null) ? candidate.ordinal() : -1;
		return (candidateOrdinal > existingOrdinal) ? candidate : existing;
	}
	private Enum<? extends Producible<?>> forMimeType(List<Enum<? extends Producible<?>>> values, MimeType mimeType) {
		if (mimeType.isWildcardType() && mimeType.isWildcardSubtype()) {
			return getDefaultValue(values);
		}
		for (Enum<? extends Producible<?>> candidate : values) {
			if (mimeType.isCompatibleWith(((Producible<?>) candidate).getProducedMimeType())) {
				return candidate;
			}
		}
		return null;
	}
	private List<Enum<? extends Producible<?>>> getValues(Class<Enum<? extends Producible<?>>> type) {
		List<Enum<? extends Producible<?>>> values = Arrays.asList(type.getEnumConstants());
		Collections.reverse(values);
		Assert.state(values.stream().filter(this::isDefault).count() <= 1,
				'Multiple default values declared in ' + type.getName());
		return values;
	}
	private Enum<? extends Producible<?>> getDefaultValue(List<Enum<? extends Producible<?>>> values) {
		return values.stream().filter(this::isDefault).findFirst().orElseGet(() -> values.get(0));
	}
	private boolean isDefault(Enum<? extends Producible<?>> value) {
		return ((Producible<?>) value).isDefault();
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public interface OperationResponseBody {
	/**
	 * Return a {@link OperationResponseBody} {@link Map} instance containing entries from
	 * the given {@code map}.
	 * @param <K> the key type
	 * @param <V> the value type
	 * @param map the source map or {@code null}
	 * @return a {@link OperationResponseBody} version of the map or {@code null}
	 */
	static <K, V> Map<K, V> of(Map<K, V> map) {
		return (map != null) ? new OperationResponseBodyMap<>(map) : null;
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public interface ExposableEndpoint<O extends Operation> {
	/**
	 * Return the endpoint ID.
	 * @return the endpoint ID
	 */
	EndpointId getEndpointId();
	/**
	 * Returns if the endpoint is enabled by default.
	 * @return if the endpoint is enabled by default
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #getDefaultAccess()}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	boolean isEnableByDefault();
	/**
	 * Returns the access to the endpoint that is permitted by default.
	 * @return access that is permitted by default
	 * @since 3.4.0
	 */
	Access getDefaultAccess();
	/**
	 * Returns the operations of the endpoint.
	 * @return the operations
	 */
	Collection<O> getOperations();
}
/*
/**
package org.springframework.boot.actuate.endpoint;
/*
package org.springframework.boot.actuate.endpoint;
/**
public class InvalidEndpointRequestException extends RuntimeException {
	private final String reason;
	public InvalidEndpointRequestException(String message, String reason) {
		super(message);
		this.reason = reason;
	}
	public InvalidEndpointRequestException(String message, String reason, Throwable cause) {
		super(message, cause);
		this.reason = reason;
	}
	/**
	 * Return the reason explaining why the request is invalid, potentially {@code null}.
	 * @return the reason for the failure
	 */
	public String getReason() {
		return this.reason;
	}
}
/*
package org.springframework.boot.actuate.endpoint;
/**
public class Sanitizer {
	private final List<SanitizingFunction> sanitizingFunctions = new ArrayList<>();
	/**
	 * Create a new {@link Sanitizer} instance.
	 */
	public Sanitizer() {
		this(Collections.emptyList());
	}
	/**
	 * Create a new {@link Sanitizer} instance with sanitizing functions.
	 * @param sanitizingFunctions the sanitizing functions to apply
	 * @since 2.6.0
	 */
	public Sanitizer(Iterable<SanitizingFunction> sanitizingFunctions) {
		sanitizingFunctions.forEach(this.sanitizingFunctions::add);
	}
	/**
	 * Sanitize the value from the given {@link SanitizableData} using the available
	 * {@link SanitizingFunction}s.
	 * @param data the sanitizable data
	 * @param showUnsanitized whether to show the unsanitized values or not
	 * @return the potentially updated data
	 * @since 3.0.0
	 */
	public Object sanitize(SanitizableData data, boolean showUnsanitized) {
		Object value = data.getValue();
		if (value == null) {
			return null;
		}
		if (!showUnsanitized) {
			return SanitizableData.SANITIZED_VALUE;
		}
		for (SanitizingFunction sanitizingFunction : this.sanitizingFunctions) {
			data = sanitizingFunction.apply(data);
			Object sanitizedValue = data.getValue();
			if (!value.equals(sanitizedValue)) {
				return sanitizedValue;
			}
		}
		return value;
	}
}
/*
package org.springframework.boot.actuate.endpoint.jackson;
/**
public interface EndpointObjectMapper {
	/**
	 * Return the {@link ObjectMapper} that should be used to serialize
	 * {@link OperationResponseBody} endpoint results.
	 * @return the object mapper
	 */
	ObjectMapper get();
}
/*
/**
package org.springframework.boot.actuate.endpoint.jackson;
/*
package org.springframework.boot.actuate.endpoint;
/**
public interface Operation {
	/**
	 * Returns the {@link OperationType type} of the operation.
	 * @return the type
	 */
	OperationType getType();
	/**
	 * Invoke the underlying operation using the given {@code context}. Results intended
	 * to be returned in the body of the response should additionally implement
	 * {@link OperationResponseBody}.
	 * @param context the context in to use when invoking the operation
	 * @return the result of the operation, may be {@code null}
	 */
	Object invoke(InvocationContext context);
}
/*
package org.springframework.boot.actuate.elasticsearch;
/**
public class ElasticsearchRestClientHealthIndicator extends AbstractHealthIndicator {
	private static final String RED_STATUS = 'red';
	private final RestClient client;
	private final JsonParser jsonParser;
	public ElasticsearchRestClientHealthIndicator(RestClient client) {
		super('Elasticsearch health check failed');
		this.client = client;
		this.jsonParser = JsonParserFactory.getJsonParser();
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		Response response = this.client.performRequest(new Request('GET', '/_cluster/health/'));
		StatusLine statusLine = response.getStatusLine();
		if (statusLine.getStatusCode() != HttpStatus.SC_OK) {
			builder.down();
			builder.withDetail('statusCode', statusLine.getStatusCode());
			builder.withDetail('reasonPhrase', statusLine.getReasonPhrase());
			return;
		}
		try (InputStream inputStream = response.getEntity().getContent()) {
			doHealthCheck(builder, StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8));
		}
	}
	private void doHealthCheck(Health.Builder builder, String json) {
		Map<String, Object> response = this.jsonParser.parseMap(json);
		String status = (String) response.get('status');
		if (RED_STATUS.equals(status)) {
			builder.outOfService();
		}
		else {
			builder.up();
		}
		builder.withDetails(response);
	}
}
/*
/**
package org.springframework.boot.actuate.elasticsearch;
/*
package org.springframework.boot.actuate.startup;
/**
@Endpoint(id = 'startup')
@ImportRuntimeHints(StartupEndpointRuntimeHints.class)
public class StartupEndpoint {
	private final BufferingApplicationStartup applicationStartup;
	/**
	 * Creates a new {@code StartupEndpoint} that will describe the timeline of buffered
	 * application startup events.
	 * @param applicationStartup the application startup
	 */
	public StartupEndpoint(BufferingApplicationStartup applicationStartup) {
		this.applicationStartup = applicationStartup;
	}
	@ReadOperation
	public StartupDescriptor startupSnapshot() {
		StartupTimeline startupTimeline = this.applicationStartup.getBufferedTimeline();
		return new StartupDescriptor(startupTimeline);
	}
	@WriteOperation
	public StartupDescriptor startup() {
		StartupTimeline startupTimeline = this.applicationStartup.drainBufferedTimeline();
		return new StartupDescriptor(startupTimeline);
	}
	/**
	 * Description of an application startup.
	 */
	public static final class StartupDescriptor implements OperationResponseBody {
		private final String springBootVersion;
		private final StartupTimeline timeline;
		private StartupDescriptor(StartupTimeline timeline) {
			this.timeline = timeline;
			this.springBootVersion = SpringBootVersion.getVersion();
		}
		public String getSpringBootVersion() {
			return this.springBootVersion;
		}
		public StartupTimeline getTimeline() {
			return this.timeline;
		}
	}
	static class StartupEndpointRuntimeHints implements RuntimeHintsRegistrar {
		private static final TypeReference DEFAULT_TAG = TypeReference
			.of('org.springframework.boot.context.metrics.buffering.BufferedStartupStep$DefaultTag');
		private static final TypeReference BUFFERED_STARTUP_STEP = TypeReference
			.of('org.springframework.boot.context.metrics.buffering.BufferedStartupStep');
		private static final TypeReference FLIGHT_RECORDER_TAG = TypeReference
			.of('org.springframework.core.metrics.jfr.FlightRecorderStartupStep$FlightRecorderTag');
		private static final TypeReference FLIGHT_RECORDER_STARTUP_STEP = TypeReference
			.of('org.springframework.core.metrics.jfr.FlightRecorderStartupStep');
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection()
				.registerType(DEFAULT_TAG, (typeHint) -> typeHint.onReachableType(BUFFERED_STARTUP_STEP)
					.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS));
			hints.reflection()
				.registerType(FLIGHT_RECORDER_TAG, (typeHint) -> typeHint.onReachableType(FLIGHT_RECORDER_STARTUP_STEP)
					.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS));
		}
	}
}
/*
/**
package org.springframework.boot.actuate.startup;
/*
package org.springframework.boot.actuate.r2dbc;
/**
public class ConnectionFactoryHealthIndicator extends AbstractReactiveHealthIndicator {
	private final ConnectionFactory connectionFactory;
	private final String validationQuery;
	/**
	 * Create a new {@link ConnectionFactoryHealthIndicator} using the specified
	 * {@link ConnectionFactory} and no validation query.
	 * @param connectionFactory the connection factory
	 * @see Connection#validate(ValidationDepth)
	 */
	public ConnectionFactoryHealthIndicator(ConnectionFactory connectionFactory) {
		this(connectionFactory, null);
	}
	/**
	 * Create a new {@link ConnectionFactoryHealthIndicator} using the specified
	 * {@link ConnectionFactory} and validation query.
	 * @param connectionFactory the connection factory
	 * @param validationQuery the validation query, can be {@code null} to use connection
	 * validation
	 */
	public ConnectionFactoryHealthIndicator(ConnectionFactory connectionFactory, String validationQuery) {
		Assert.notNull(connectionFactory, 'ConnectionFactory must not be null');
		this.connectionFactory = connectionFactory;
		this.validationQuery = validationQuery;
	}
	@Override
	protected final Mono<Health> doHealthCheck(Builder builder) {
		return validate(builder).defaultIfEmpty(builder.build())
			.onErrorResume(Exception.class, (ex) -> Mono.just(builder.down(ex).build()));
	}
	private Mono<Health> validate(Builder builder) {
		builder.withDetail('database', this.connectionFactory.getMetadata().getName());
		return (StringUtils.hasText(this.validationQuery)) ? validateWithQuery(builder)
				: validateWithConnectionValidation(builder);
	}
	private Mono<Health> validateWithQuery(Builder builder) {
		builder.withDetail('validationQuery', this.validationQuery);
		Mono<Object> connectionValidation = Mono.usingWhen(this.connectionFactory.create(),
				(conn) -> Flux.from(conn.createStatement(this.validationQuery).execute())
					.flatMap((it) -> it.map(this::extractResult))
					.next(),
				Connection::close, (o, throwable) -> o.close(), Connection::close);
		return connectionValidation.map((result) -> builder.up().withDetail('result', result).build());
	}
	private Mono<Health> validateWithConnectionValidation(Builder builder) {
		builder.withDetail('validationQuery', 'validate(REMOTE)');
		Mono<Boolean> connectionValidation = Mono.usingWhen(this.connectionFactory.create(),
				(connection) -> Mono.from(connection.validate(ValidationDepth.REMOTE)), Connection::close,
				(connection, ex) -> connection.close(), Connection::close);
		return connectionValidation.map((valid) -> builder.status((valid) ? Status.UP : Status.DOWN).build());
	}
	private Object extractResult(Row row, RowMetadata metadata) {
		return row.get(metadata.getColumnMetadatas().iterator().next().getName());
	}
}
/*
/**
package org.springframework.boot.actuate.r2dbc;
/*
package org.springframework.boot.actuate.liquibase;
/**
@Endpoint(id = 'liquibase')
public class LiquibaseEndpoint {
	private final ApplicationContext context;
	public LiquibaseEndpoint(ApplicationContext context) {
		Assert.notNull(context, 'Context must be specified');
		this.context = context;
	}
	@ReadOperation
	public LiquibaseBeansDescriptor liquibaseBeans() {
		ApplicationContext target = this.context;
		Map<String, ContextLiquibaseBeansDescriptor> contextBeans = new HashMap<>();
		while (target != null) {
			Map<String, LiquibaseBeanDescriptor> liquibaseBeans = new HashMap<>();
			DatabaseFactory factory = DatabaseFactory.getInstance();
			target.getBeansOfType(SpringLiquibase.class)
				.forEach((name, liquibase) -> liquibaseBeans.put(name, createReport(liquibase, factory)));
			ApplicationContext parent = target.getParent();
			contextBeans.put(target.getId(),
					new ContextLiquibaseBeansDescriptor(liquibaseBeans, (parent != null) ? parent.getId() : null));
			target = parent;
		}
		return new LiquibaseBeansDescriptor(contextBeans);
	}
	private LiquibaseBeanDescriptor createReport(SpringLiquibase liquibase, DatabaseFactory factory) {
		try {
			DataSource dataSource = liquibase.getDataSource();
			JdbcConnection connection = new JdbcConnection(dataSource.getConnection());
			Database database = null;
			try {
				database = factory.findCorrectDatabaseImplementation(connection);
				String defaultSchema = liquibase.getDefaultSchema();
				if (StringUtils.hasText(defaultSchema)) {
					database.setDefaultSchemaName(defaultSchema);
				}
				database.setDatabaseChangeLogTableName(liquibase.getDatabaseChangeLogTable());
				database.setDatabaseChangeLogLockTableName(liquibase.getDatabaseChangeLogLockTable());
				StandardChangeLogHistoryService service = new StandardChangeLogHistoryService();
				service.setDatabase(database);
				return new LiquibaseBeanDescriptor(
						service.getRanChangeSets().stream().map(ChangeSetDescriptor::new).toList());
			}
			finally {
				if (database != null) {
					database.close();
				}
				else {
					connection.close();
				}
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to get Liquibase change sets', ex);
		}
	}
	/**
	 * Description of an application"s {@link SpringLiquibase} beans.
	 */
	public static final class LiquibaseBeansDescriptor implements OperationResponseBody {
		private final Map<String, ContextLiquibaseBeansDescriptor> contexts;
		private LiquibaseBeansDescriptor(Map<String, ContextLiquibaseBeansDescriptor> contexts) {
			this.contexts = contexts;
		}
		public Map<String, ContextLiquibaseBeansDescriptor> getContexts() {
			return this.contexts;
		}
	}
	/**
	 * Description of an application context"s {@link SpringLiquibase} beans.
	 */
	public static final class ContextLiquibaseBeansDescriptor {
		private final Map<String, LiquibaseBeanDescriptor> liquibaseBeans;
		private final String parentId;
		private ContextLiquibaseBeansDescriptor(Map<String, LiquibaseBeanDescriptor> liquibaseBeans, String parentId) {
			this.liquibaseBeans = liquibaseBeans;
			this.parentId = parentId;
		}
		public Map<String, LiquibaseBeanDescriptor> getLiquibaseBeans() {
			return this.liquibaseBeans;
		}
		public String getParentId() {
			return this.parentId;
		}
	}
	/**
	 * Description of a {@link SpringLiquibase} bean.
	 */
	public static final class LiquibaseBeanDescriptor {
		private final List<ChangeSetDescriptor> changeSets;
		public LiquibaseBeanDescriptor(List<ChangeSetDescriptor> changeSets) {
			this.changeSets = changeSets;
		}
		public List<ChangeSetDescriptor> getChangeSets() {
			return this.changeSets;
		}
	}
	/**
	 * Description of a Liquibase change set.
	 */
	public static class ChangeSetDescriptor {
		private final String author;
		private final String changeLog;
		private final String comments;
		private final Set<String> contexts;
		private final Instant dateExecuted;
		private final String deploymentId;
		private final String description;
		private final ExecType execType;
		private final String id;
		private final Set<String> labels;
		private final String checksum;
		private final Integer orderExecuted;
		private final String tag;
		public ChangeSetDescriptor(RanChangeSet ranChangeSet) {
			this.author = ranChangeSet.getAuthor();
			this.changeLog = ranChangeSet.getChangeLog();
			this.comments = ranChangeSet.getComments();
			this.contexts = ranChangeSet.getContextExpression().getContexts();
			this.dateExecuted = Instant.ofEpochMilli(ranChangeSet.getDateExecuted().getTime());
			this.deploymentId = ranChangeSet.getDeploymentId();
			this.description = ranChangeSet.getDescription();
			this.execType = ranChangeSet.getExecType();
			this.id = ranChangeSet.getId();
			this.labels = ranChangeSet.getLabels().getLabels();
			this.checksum = ((ranChangeSet.getLastCheckSum() != null) ? ranChangeSet.getLastCheckSum().toString()
					: null);
			this.orderExecuted = ranChangeSet.getOrderExecuted();
			this.tag = ranChangeSet.getTag();
		}
		public String getAuthor() {
			return this.author;
		}
		public String getChangeLog() {
			return this.changeLog;
		}
		public String getComments() {
			return this.comments;
		}
		public Set<String> getContexts() {
			return this.contexts;
		}
		public Instant getDateExecuted() {
			return this.dateExecuted;
		}
		public String getDeploymentId() {
			return this.deploymentId;
		}
		public String getDescription() {
			return this.description;
		}
		public ExecType getExecType() {
			return this.execType;
		}
		public String getId() {
			return this.id;
		}
		public Set<String> getLabels() {
			return this.labels;
		}
		public String getChecksum() {
			return this.checksum;
		}
		public Integer getOrderExecuted() {
			return this.orderExecuted;
		}
		public String getTag() {
			return this.tag;
		}
	}
	/**
	 * Description of a context expression in a {@link ChangeSetDescriptor}.
	 */
	public static class ContextExpressionDescriptor {
		private final Set<String> contexts;
		public ContextExpressionDescriptor(Set<String> contexts) {
			this.contexts = contexts;
		}
		public Set<String> getContexts() {
			return this.contexts;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.liquibase;
/*
package org.springframework.boot.actuate.flyway;
/**
@Endpoint(id = 'flyway')
public class FlywayEndpoint {
	private final ApplicationContext context;
	public FlywayEndpoint(ApplicationContext context) {
		this.context = context;
	}
	@ReadOperation
	public FlywayBeansDescriptor flywayBeans() {
		ApplicationContext target = this.context;
		Map<String, ContextFlywayBeansDescriptor> contextFlywayBeans = new HashMap<>();
		while (target != null) {
			Map<String, FlywayDescriptor> flywayBeans = new HashMap<>();
			target.getBeansOfType(Flyway.class)
				.forEach((name, flyway) -> flywayBeans.put(name, new FlywayDescriptor(flyway.info().all())));
			ApplicationContext parent = target.getParent();
			contextFlywayBeans.put(target.getId(),
					new ContextFlywayBeansDescriptor(flywayBeans, (parent != null) ? parent.getId() : null));
			target = parent;
		}
		return new FlywayBeansDescriptor(contextFlywayBeans);
	}
	/**
	 * Description of an application"s {@link Flyway} beans.
	 */
	public static final class FlywayBeansDescriptor implements OperationResponseBody {
		private final Map<String, ContextFlywayBeansDescriptor> contexts;
		private FlywayBeansDescriptor(Map<String, ContextFlywayBeansDescriptor> contexts) {
			this.contexts = contexts;
		}
		public Map<String, ContextFlywayBeansDescriptor> getContexts() {
			return this.contexts;
		}
	}
	/**
	 * Description of an application context"s {@link Flyway} beans.
	 */
	public static final class ContextFlywayBeansDescriptor {
		private final Map<String, FlywayDescriptor> flywayBeans;
		private final String parentId;
		private ContextFlywayBeansDescriptor(Map<String, FlywayDescriptor> flywayBeans, String parentId) {
			this.flywayBeans = flywayBeans;
			this.parentId = parentId;
		}
		public Map<String, FlywayDescriptor> getFlywayBeans() {
			return this.flywayBeans;
		}
		public String getParentId() {
			return this.parentId;
		}
	}
	/**
	 * Description of a {@link Flyway} bean.
	 */
	public static class FlywayDescriptor {
		private final List<FlywayMigrationDescriptor> migrations;
		private FlywayDescriptor(MigrationInfo[] migrations) {
			this.migrations = Stream.of(migrations).map(FlywayMigrationDescriptor::new).toList();
		}
		public FlywayDescriptor(List<FlywayMigrationDescriptor> migrations) {
			this.migrations = migrations;
		}
		public List<FlywayMigrationDescriptor> getMigrations() {
			return this.migrations;
		}
	}
	/**
	 * Description of a migration performed by Flyway.
	 */
	public static final class FlywayMigrationDescriptor {
		private final String type;
		private final Integer checksum;
		private final String version;
		private final String description;
		private final String script;
		private final MigrationState state;
		private final String installedBy;
		private final Instant installedOn;
		private final Integer installedRank;
		private final Integer executionTime;
		private FlywayMigrationDescriptor(MigrationInfo info) {
			this.type = info.getType().name();
			this.checksum = info.getChecksum();
			this.version = nullSafeToString(info.getVersion());
			this.description = info.getDescription();
			this.script = info.getScript();
			this.state = info.getState();
			this.installedBy = info.getInstalledBy();
			this.installedRank = info.getInstalledRank();
			this.executionTime = info.getExecutionTime();
			this.installedOn = nullSafeToInstant(info.getInstalledOn());
		}
		private String nullSafeToString(Object obj) {
			return (obj != null) ? obj.toString() : null;
		}
		private Instant nullSafeToInstant(Date date) {
			return (date != null) ? Instant.ofEpochMilli(date.getTime()) : null;
		}
		public String getType() {
			return this.type;
		}
		public Integer getChecksum() {
			return this.checksum;
		}
		public String getVersion() {
			return this.version;
		}
		public String getDescription() {
			return this.description;
		}
		public String getScript() {
			return this.script;
		}
		public MigrationState getState() {
			return this.state;
		}
		public String getInstalledBy() {
			return this.installedBy;
		}
		public Instant getInstalledOn() {
			return this.installedOn;
		}
		public Integer getInstalledRank() {
			return this.installedRank;
		}
		public Integer getExecutionTime() {
			return this.executionTime;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.flyway;
/*
package org.springframework.boot.actuate.sbom;
/**
@Endpoint(id = 'sbom')
@ImportRuntimeHints(SbomEndpointRuntimeHints.class)
public class SbomEndpoint {
	static final String APPLICATION_SBOM_ID = 'application';
	private static final List<AutodetectedSbom> AUTODETECTED_SBOMS = List.of(
			new AutodetectedSbom(APPLICATION_SBOM_ID, 'classpath:META-INF/sbom/bom.json', true),
			new AutodetectedSbom(APPLICATION_SBOM_ID, 'classpath:META-INF/sbom/application.cdx.json', true),
			new AutodetectedSbom('native-image', 'classpath:META-INF/native-image/sbom.json', false));
	private final SbomProperties properties;
	private final ResourceLoader resourceLoader;
	private final Map<String, Resource> sboms;
	public SbomEndpoint(SbomProperties properties, ResourceLoader resourceLoader) {
		this.properties = properties;
		this.resourceLoader = resourceLoader;
		this.sboms = loadSboms();
	}
	private Map<String, Resource> loadSboms() {
		Map<String, Resource> sboms = new HashMap<>();
		addConfiguredApplicationSbom(sboms);
		addAdditionalSboms(sboms);
		addAutodetectedSboms(sboms);
		return Collections.unmodifiableMap(sboms);
	}
	private void addConfiguredApplicationSbom(Map<String, Resource> sboms) {
		String location = this.properties.getApplication().getLocation();
		if (!StringUtils.hasLength(location)) {
			return;
		}
		Resource resource = loadResource(location);
		if (resource != null) {
			sboms.put(APPLICATION_SBOM_ID, resource);
		}
	}
	private void addAdditionalSboms(Map<String, Resource> result) {
		this.properties.getAdditional().forEach((id, sbom) -> {
			Resource resource = loadResource(sbom.getLocation());
			if (resource != null) {
				if (result.putIfAbsent(id, resource) != null) {
					throw new IllegalStateException('Duplicate SBOM registration with id "%s"'.formatted(id));
				}
			}
		});
	}
	private void addAutodetectedSboms(Map<String, Resource> sboms) {
		for (AutodetectedSbom sbom : AUTODETECTED_SBOMS) {
			if (sboms.containsKey(sbom.id())) {
				continue;
			}
			Resource resource = this.resourceLoader.getResource(sbom.resource());
			if (resource.exists()) {
				sboms.put(sbom.id(), resource);
			}
		}
	}
	private Resource loadResource(String location) {
		if (location == null) {
			return null;
		}
		Location parsedLocation = Location.of(location);
		Resource resource = this.resourceLoader.getResource(parsedLocation.location());
		if (resource.exists()) {
			return resource;
		}
		if (parsedLocation.optional()) {
			return null;
		}
		throw new IllegalStateException('Resource "%s" doesn"t exist and it"s not marked optional'.formatted(location));
	}
	@ReadOperation
	Sboms sboms() {
		return new Sboms(new TreeSet<>(this.sboms.keySet()));
	}
	@ReadOperation
	Resource sbom(@Selector String id) {
		return this.sboms.get(id);
	}
	record Sboms(Collection<String> ids) implements OperationResponseBody {
	}
	private record Location(String location, boolean optional) {
		private static final String OPTIONAL_PREFIX = 'optional:';
		static Location of(String location) {
			boolean optional = isOptional(location);
			return new Location(optional ? stripOptionalPrefix(location) : location, optional);
		}
		private static boolean isOptional(String location) {
			return location.startsWith(OPTIONAL_PREFIX);
		}
		private static String stripOptionalPrefix(String location) {
			return location.substring(OPTIONAL_PREFIX.length());
		}
	}
	private record AutodetectedSbom(String id, String resource, boolean needsHints) {
		void registerHintsIfNeeded(RuntimeHints hints) {
			if (this.needsHints) {
				hints.resources().registerPattern(stripClasspathPrefix(this.resource));
			}
		}
		private String stripClasspathPrefix(String location) {
			return location.substring('classpath:'.length());
		}
	}
	static class SbomEndpointRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			for (AutodetectedSbom sbom : AUTODETECTED_SBOMS) {
				sbom.registerHintsIfNeeded(hints);
			}
		}
	}
}
/*
/**
package org.springframework.boot.actuate.sbom;
/*
package org.springframework.boot.actuate.sbom;
/**
@EndpointWebExtension(endpoint = SbomEndpoint.class)
public class SbomEndpointWebExtension {
	private final SbomEndpoint sbomEndpoint;
	private final SbomProperties properties;
	private final Map<String, SbomType> detectedMediaTypeCache = new ConcurrentHashMap<>();
	public SbomEndpointWebExtension(SbomEndpoint sbomEndpoint, SbomProperties properties) {
		this.sbomEndpoint = sbomEndpoint;
		this.properties = properties;
	}
	@ReadOperation
	WebEndpointResponse<Resource> sbom(@Selector String id) {
		Resource resource = this.sbomEndpoint.sbom(id);
		if (resource == null) {
			return new WebEndpointResponse<>(WebEndpointResponse.STATUS_NOT_FOUND);
		}
		MimeType type = getMediaType(id, resource);
		return (type != null) ? new WebEndpointResponse<>(resource, type) : new WebEndpointResponse<>(resource);
	}
	private MimeType getMediaType(String id, Resource resource) {
		if (SbomEndpoint.APPLICATION_SBOM_ID.equals(id) && this.properties.getApplication().getMediaType() != null) {
			return this.properties.getApplication().getMediaType();
		}
		Sbom sbomProperties = this.properties.getAdditional().get(id);
		if (sbomProperties != null && sbomProperties.getMediaType() != null) {
			return sbomProperties.getMediaType();
		}
		return this.detectedMediaTypeCache.computeIfAbsent(id, (ignored) -> {
			try {
				return detectSbomType(resource);
			}
			catch (IOException ex) {
				throw new UncheckedIOException('Failed to detect type of resource "%s"'.formatted(resource), ex);
			}
		}).getMediaType();
	}
	private SbomType detectSbomType(Resource resource) throws IOException {
		String content = resource.getContentAsString(StandardCharsets.UTF_8);
		for (SbomType candidate : SbomType.values()) {
			if (candidate.matches(content)) {
				return candidate;
			}
		}
		return SbomType.UNKNOWN;
	}
	enum SbomType {
		CYCLONE_DX(MimeType.valueOf('application/vnd.cyclonedx+json')) {
			@Override
			boolean matches(String content) {
				return content.replaceAll('\\s', '').contains('\'bomFormat\':\'CycloneDX\'');
			}
		},
		SPDX(MimeType.valueOf('application/spdx+json')) {
			@Override
			boolean matches(String content) {
				return content.contains('\'spdxVersion\'');
			}
		},
		SYFT(MimeType.valueOf('application/vnd.syft+json')) {
			@Override
			boolean matches(String content) {
				return content.contains('\'FoundBy\'') || content.contains('\'foundBy\'');
			}
		},
		UNKNOWN(null) {
			@Override
			boolean matches(String content) {
				return false;
			}
		};
		private final MimeType mediaType;
		SbomType(MimeType mediaType) {
			this.mediaType = mediaType;
		}
		MimeType getMediaType() {
			return this.mediaType;
		}
		abstract boolean matches(String content);
	}
}
/*
package org.springframework.boot.actuate.sbom;
/**
@ConfigurationProperties(prefix = 'management.endpoint.sbom')
public class SbomProperties {
	/**
	 * Application SBOM configuration.
	 */
	private final Sbom application = new Sbom();
	/**
	 * Additional SBOMs.
	 */
	private Map<String, Sbom> additional = new HashMap<>();
	public Sbom getApplication() {
		return this.application;
	}
	public Map<String, Sbom> getAdditional() {
		return this.additional;
	}
	public void setAdditional(Map<String, Sbom> additional) {
		this.additional = additional;
	}
	public static class Sbom {
		/**
		 * Location to the SBOM. If null, the location will be auto-detected.
		 */
		private String location;
		/**
		 * Media type of the SBOM. If null, the media type will be auto-detected.
		 */
		private MimeType mediaType;
		public String getLocation() {
			return this.location;
		}
		public void setLocation(String location) {
			this.location = location;
		}
		public MimeType getMediaType() {
			return this.mediaType;
		}
		public void setMediaType(MimeType mediaType) {
			this.mediaType = mediaType;
		}
	}
}
/*
package org.springframework.boot.actuate.management;
/**
@WebEndpoint(id = 'heapdump')
public class HeapDumpWebEndpoint {
	private final long timeout;
	private final Lock lock = new ReentrantLock();
	private HeapDumper heapDumper;
	public HeapDumpWebEndpoint() {
		this(TimeUnit.SECONDS.toMillis(10));
	}
	protected HeapDumpWebEndpoint(long timeout) {
		this.timeout = timeout;
	}
	@ReadOperation
	public WebEndpointResponse<Resource> heapDump(@Nullable Boolean live) {
		try {
			if (this.lock.tryLock(this.timeout, TimeUnit.MILLISECONDS)) {
				try {
					return new WebEndpointResponse<>(dumpHeap(live));
				}
				finally {
					this.lock.unlock();
				}
			}
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
		catch (IOException ex) {
			return new WebEndpointResponse<>(WebEndpointResponse.STATUS_INTERNAL_SERVER_ERROR);
		}
		catch (HeapDumperUnavailableException ex) {
			return new WebEndpointResponse<>(WebEndpointResponse.STATUS_SERVICE_UNAVAILABLE);
		}
		return new WebEndpointResponse<>(WebEndpointResponse.STATUS_TOO_MANY_REQUESTS);
	}
	private Resource dumpHeap(Boolean live) throws IOException, InterruptedException {
		if (this.heapDumper == null) {
			this.heapDumper = createHeapDumper();
		}
		File file = this.heapDumper.dumpHeap(live);
		return new TemporaryFileSystemResource(file);
	}
	/**
	 * Factory method used to create the {@link HeapDumper}.
	 * @return the heap dumper to use
	 * @throws HeapDumperUnavailableException if the heap dumper cannot be created
	 */
	protected HeapDumper createHeapDumper() throws HeapDumperUnavailableException {
		try {
			return new HotSpotDiagnosticMXBeanHeapDumper();
		}
		catch (HeapDumperUnavailableException ex) {
			return new OpenJ9DiagnosticsMXBeanHeapDumper();
		}
	}
	/**
	 * Strategy interface used to dump the heap to a file.
	 */
	@FunctionalInterface
	protected interface HeapDumper {
		/**
		 * Dump the current heap to a file.
		 * @param live if only <em>live</em> objects (i.e. objects that are reachable from
		 * others) should be dumped. May be {@code null} to use a JVM-specific default.
		 * @return the file containing the heap dump
		 * @throws IOException on IO error
		 * @throws InterruptedException on thread interruption
		 * @throws IllegalArgumentException if live is non-null and is not supported by
		 * the JVM
		 * @since 3.0.0
		 */
		File dumpHeap(Boolean live) throws IOException, InterruptedException;
	}
	/**
	 * {@link HeapDumper} that uses {@code com.sun.management.HotSpotDiagnosticMXBean},
	 * available on Oracle and OpenJDK, to dump the heap to a file.
	 */
	protected static class HotSpotDiagnosticMXBeanHeapDumper implements HeapDumper {
		private final Object diagnosticMXBean;
		private final Method dumpHeapMethod;
		@SuppressWarnings('unchecked')
		protected HotSpotDiagnosticMXBeanHeapDumper() {
			try {
				Class<?> diagnosticMXBeanClass = ClassUtils
					.resolveClassName('com.sun.management.HotSpotDiagnosticMXBean', null);
				this.diagnosticMXBean = ManagementFactory
					.getPlatformMXBean((Class<PlatformManagedObject>) diagnosticMXBeanClass);
				this.dumpHeapMethod = ReflectionUtils.findMethod(diagnosticMXBeanClass, 'dumpHeap', String.class,
						Boolean.TYPE);
			}
			catch (Throwable ex) {
				throw new HeapDumperUnavailableException('Unable to locate HotSpotDiagnosticMXBean', ex);
			}
		}
		@Override
		public File dumpHeap(Boolean live) throws IOException {
			File file = createTempFile();
			ReflectionUtils.invokeMethod(this.dumpHeapMethod, this.diagnosticMXBean, file.getAbsolutePath(),
					(live != null) ? live : true);
			return file;
		}
		private File createTempFile() throws IOException {
			String date = DateTimeFormatter.ofPattern('yyyy-MM-dd-HH-mm').format(LocalDateTime.now());
			File file = File.createTempFile('heap-' + date, '.hprof');
			file.delete();
			return file;
		}
	}
	/**
	 * {@link HeapDumper} that uses
	 * {@code openj9.lang.management.OpenJ9DiagnosticsMXBean}, available on OpenJ9, to
	 * dump the heap to a file.
	 */
	private static final class OpenJ9DiagnosticsMXBeanHeapDumper implements HeapDumper {
		private final Object diagnosticMXBean;
		private final Method dumpHeapMethod;
		@SuppressWarnings('unchecked')
		private OpenJ9DiagnosticsMXBeanHeapDumper() {
			try {
				Class<?> mxBeanClass = ClassUtils.resolveClassName('openj9.lang.management.OpenJ9DiagnosticsMXBean',
						null);
				this.diagnosticMXBean = ManagementFactory.getPlatformMXBean((Class<PlatformManagedObject>) mxBeanClass);
				this.dumpHeapMethod = ReflectionUtils.findMethod(mxBeanClass, 'triggerDumpToFile', String.class,
						String.class);
			}
			catch (Throwable ex) {
				throw new HeapDumperUnavailableException('Unable to locate OpenJ9DiagnosticsMXBean', ex);
			}
		}
		@Override
		public File dumpHeap(Boolean live) throws IOException, InterruptedException {
			Assert.isNull(live, 'OpenJ9DiagnosticsMXBean does not support live parameter when dumping the heap');
			return new File(
					(String) ReflectionUtils.invokeMethod(this.dumpHeapMethod, this.diagnosticMXBean, 'heap', null));
		}
	}
	/**
	 * Exception to be thrown if the {@link HeapDumper} cannot be created.
	 */
	protected static class HeapDumperUnavailableException extends RuntimeException {
		public HeapDumperUnavailableException(String message, Throwable cause) {
			super(message, cause);
		}
	}
	private static final class TemporaryFileSystemResource extends FileSystemResource {
		private final Log logger = LogFactory.getLog(getClass());
		private TemporaryFileSystemResource(File file) {
			super(file);
		}
		@Override
		public ReadableByteChannel readableChannel() throws IOException {
			ReadableByteChannel readableChannel = super.readableChannel();
			return new ReadableByteChannel() {
				@Override
				public boolean isOpen() {
					return readableChannel.isOpen();
				}
				@Override
				public void close() throws IOException {
					closeThenDeleteFile(readableChannel);
				}
				@Override
				public int read(ByteBuffer dst) throws IOException {
					return readableChannel.read(dst);
				}
			};
		}
		@Override
		public InputStream getInputStream() throws IOException {
			return new FilterInputStream(super.getInputStream()) {
				@Override
				public void close() throws IOException {
					closeThenDeleteFile(this.in);
				}
			};
		}
		private void closeThenDeleteFile(Closeable closeable) throws IOException {
			try {
				closeable.close();
			}
			finally {
				deleteFile();
			}
		}
		private void deleteFile() {
			try {
				Files.delete(getFile().toPath());
			}
			catch (IOException ex) {
				TemporaryFileSystemResource.this.logger
					.warn('Failed to delete temporary heap dump file "' + getFile() + '"', ex);
			}
		}
		@Override
		public boolean isFile() {
			// Prevent zero-copy so we can delete the file on close
			return false;
		}
	}
}
/*
package org.springframework.boot.actuate.management;
/**
@Endpoint(id = 'threaddump')
public class ThreadDumpEndpoint {
	private final PlainTextThreadDumpFormatter plainTextFormatter = new PlainTextThreadDumpFormatter();
	@ReadOperation
	public ThreadDumpDescriptor threadDump() {
		return getFormattedThreadDump(ThreadDumpDescriptor::new);
	}
	@ReadOperation(produces = 'text/plain;charset=UTF-8')
	public String textThreadDump() {
		return getFormattedThreadDump(this.plainTextFormatter::format);
	}
	private <T> T getFormattedThreadDump(Function<ThreadInfo[], T> formatter) {
		return formatter.apply(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true));
	}
	/**
	 * Description of a thread dump.
	 */
	public static final class ThreadDumpDescriptor implements OperationResponseBody {
		private final List<ThreadInfo> threads;
		private ThreadDumpDescriptor(ThreadInfo[] threads) {
			this.threads = Arrays.asList(threads);
		}
		public List<ThreadInfo> getThreads() {
			return this.threads;
		}
	}
}
/*
package org.springframework.boot.actuate.management;
/**
class PlainTextThreadDumpFormatter {
	String format(ThreadInfo[] threads) {
		StringWriter dump = new StringWriter();
		PrintWriter writer = new PrintWriter(dump);
		writePreamble(writer);
		for (ThreadInfo info : threads) {
			writeThread(writer, info);
		}
		return dump.toString();
	}
	private void writePreamble(PrintWriter writer) {
		DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern('yyyy-MM-dd HH:mm:ss');
		writer.println(dateFormat.format(LocalDateTime.now()));
		RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
		writer.printf('Full thread dump %s (%s %s):%n', runtime.getVmName(), runtime.getVmVersion(),
				System.getProperty('java.vm.info'));
		writer.println();
	}
	private void writeThread(PrintWriter writer, ThreadInfo info) {
		writer.printf('\'%s\' - Thread t@%d%n', info.getThreadName(), info.getThreadId());
		writer.printf('   %s: %s%n', Thread.State.class.getCanonicalName(), info.getThreadState());
		writeStackTrace(writer, info, info.getLockedMonitors());
		writer.println();
		writeLockedOwnableSynchronizers(writer, info);
		writer.println();
	}
	private void writeStackTrace(PrintWriter writer, ThreadInfo info, MonitorInfo[] lockedMonitors) {
		int depth = 0;
		for (StackTraceElement element : info.getStackTrace()) {
			writeStackTraceElement(writer, element, info, lockedMonitorsForDepth(lockedMonitors, depth), depth == 0);
			depth++;
		}
	}
	private List<MonitorInfo> lockedMonitorsForDepth(MonitorInfo[] lockedMonitors, int depth) {
		return Stream.of(lockedMonitors).filter((candidate) -> candidate.getLockedStackDepth() == depth).toList();
	}
	private void writeStackTraceElement(PrintWriter writer, StackTraceElement element, ThreadInfo info,
			List<MonitorInfo> lockedMonitors, boolean firstElement) {
		writer.printf('\tat %s%n', element.toString());
		LockInfo lockInfo = info.getLockInfo();
		if (firstElement && lockInfo != null) {
			if (element.getClassName().equals(Object.class.getName()) && element.getMethodName().equals('wait')) {
				writer.printf('\t- waiting on %s%n', format(lockInfo));
			}
			else {
				String lockOwner = info.getLockOwnerName();
				if (lockOwner != null) {
					writer.printf('\t- waiting to lock %s owned by \'%s\' t@%d%n', format(lockInfo), lockOwner,
							info.getLockOwnerId());
				}
				else {
					writer.printf('\t- parking to wait for %s%n', format(lockInfo));
				}
			}
		}
		writeMonitors(writer, lockedMonitors);
	}
	private String format(LockInfo lockInfo) {
		return String.format('<%x> (a %s)', lockInfo.getIdentityHashCode(), lockInfo.getClassName());
	}
	private void writeMonitors(PrintWriter writer, List<MonitorInfo> lockedMonitorsAtCurrentDepth) {
		for (MonitorInfo lockedMonitor : lockedMonitorsAtCurrentDepth) {
			writer.printf('\t- locked %s%n', format(lockedMonitor));
		}
	}
	private void writeLockedOwnableSynchronizers(PrintWriter writer, ThreadInfo info) {
		writer.println('   Locked ownable synchronizers:');
		LockInfo[] lockedSynchronizers = info.getLockedSynchronizers();
		if (lockedSynchronizers == null || lockedSynchronizers.length == 0) {
			writer.println('\t- None');
		}
		else {
			for (LockInfo lockedSynchronizer : lockedSynchronizers) {
				writer.printf('\t- Locked %s%n', format(lockedSynchronizer));
			}
		}
	}
}
/*
/**
package org.springframework.boot.actuate.management;
/*
/**
package org.springframework.boot.actuate.ldap;
/*
package org.springframework.boot.actuate.ldap;
/**
public class LdapHealthIndicator extends AbstractHealthIndicator {
	private static final ContextExecutor<String> versionContextExecutor = new VersionContextExecutor();
	private final LdapOperations ldapOperations;
	public LdapHealthIndicator(LdapOperations ldapOperations) {
		super('LDAP health check failed');
		Assert.notNull(ldapOperations, 'LdapOperations must not be null');
		this.ldapOperations = ldapOperations;
	}
	@Override
	protected void doHealthCheck(Health.Builder builder) throws Exception {
		String version = this.ldapOperations.executeReadOnly(versionContextExecutor);
		builder.up().withDetail('version', version);
	}
	private static final class VersionContextExecutor implements ContextExecutor<String> {
		@Override
		public String executeWithContext(DirContext ctx) throws NamingException {
			Object version = ctx.getEnvironment().get('java.naming.ldap.version');
			if (version != null) {
				return (String) version;
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.env;
/**
@Endpoint(id = 'env')
public class EnvironmentEndpoint {
	private final Sanitizer sanitizer;
	private final Environment environment;
	private final Show showValues;
	public EnvironmentEndpoint(Environment environment, Iterable<SanitizingFunction> sanitizingFunctions,
			Show showValues) {
		this.environment = environment;
		this.sanitizer = new Sanitizer(sanitizingFunctions);
		this.showValues = showValues;
	}
	@ReadOperation
	public EnvironmentDescriptor environment(@Nullable String pattern) {
		boolean showUnsanitized = this.showValues.isShown(true);
		return getEnvironmentDescriptor(pattern, showUnsanitized);
	}
	EnvironmentDescriptor getEnvironmentDescriptor(String pattern, boolean showUnsanitized) {
		if (StringUtils.hasText(pattern)) {
			return getEnvironmentDescriptor(Pattern.compile(pattern).asPredicate(), showUnsanitized);
		}
		return getEnvironmentDescriptor((name) -> true, showUnsanitized);
	}
	private EnvironmentDescriptor getEnvironmentDescriptor(Predicate<String> propertyNamePredicate,
			boolean showUnsanitized) {
		List<PropertySourceDescriptor> propertySources = new ArrayList<>();
		getPropertySourcesAsMap().forEach((sourceName, source) -> {
			if (source instanceof EnumerablePropertySource) {
				propertySources.add(describeSource(sourceName, (EnumerablePropertySource<?>) source,
						propertyNamePredicate, showUnsanitized));
			}
		});
		return new EnvironmentDescriptor(Arrays.asList(this.environment.getActiveProfiles()),
				Arrays.asList(this.environment.getDefaultProfiles()), propertySources);
	}
	@ReadOperation
	public EnvironmentEntryDescriptor environmentEntry(@Selector String toMatch) {
		boolean showUnsanitized = this.showValues.isShown(true);
		return getEnvironmentEntryDescriptor(toMatch, showUnsanitized);
	}
	EnvironmentEntryDescriptor getEnvironmentEntryDescriptor(String propertyName, boolean showUnsanitized) {
		Map<String, PropertyValueDescriptor> descriptors = getPropertySourceDescriptors(propertyName, showUnsanitized);
		PropertySummaryDescriptor summary = getPropertySummaryDescriptor(descriptors);
		return new EnvironmentEntryDescriptor(summary, Arrays.asList(this.environment.getActiveProfiles()),
				Arrays.asList(this.environment.getDefaultProfiles()), toPropertySourceDescriptors(descriptors));
	}
	private List<PropertySourceEntryDescriptor> toPropertySourceDescriptors(
			Map<String, PropertyValueDescriptor> descriptors) {
		List<PropertySourceEntryDescriptor> result = new ArrayList<>();
		descriptors.forEach((name, property) -> result.add(new PropertySourceEntryDescriptor(name, property)));
		return result;
	}
	private PropertySummaryDescriptor getPropertySummaryDescriptor(Map<String, PropertyValueDescriptor> descriptors) {
		for (Map.Entry<String, PropertyValueDescriptor> entry : descriptors.entrySet()) {
			if (entry.getValue() != null) {
				return new PropertySummaryDescriptor(entry.getKey(), entry.getValue().getValue());
			}
		}
		return null;
	}
	private Map<String, PropertyValueDescriptor> getPropertySourceDescriptors(String propertyName,
			boolean showUnsanitized) {
		Map<String, PropertyValueDescriptor> propertySources = new LinkedHashMap<>();
		getPropertySourcesAsMap().forEach((sourceName, source) -> propertySources.put(sourceName,
				source.containsProperty(propertyName) ? describeValueOf(propertyName, source, showUnsanitized) : null));
		return propertySources;
	}
	private PropertySourceDescriptor describeSource(String sourceName, EnumerablePropertySource<?> source,
			Predicate<String> namePredicate, boolean showUnsanitized) {
		Map<String, PropertyValueDescriptor> properties = new LinkedHashMap<>();
		Stream.of(source.getPropertyNames())
			.filter(namePredicate)
			.forEach((name) -> properties.put(name, describeValueOf(name, source, showUnsanitized)));
		return new PropertySourceDescriptor(sourceName, properties);
	}
	@SuppressWarnings('unchecked')
	private PropertyValueDescriptor describeValueOf(String name, PropertySource<?> source, boolean showUnsanitized) {
		PlaceholdersResolver resolver = new PropertySourcesPlaceholdersResolver(getPropertySources());
		Object resolved = resolver.resolvePlaceholders(source.getProperty(name));
		Origin origin = ((source instanceof OriginLookup) ? ((OriginLookup<Object>) source).getOrigin(name) : null);
		Object sanitizedValue = sanitize(source, name, resolved, showUnsanitized);
		return new PropertyValueDescriptor(stringifyIfNecessary(sanitizedValue), origin);
	}
	private Map<String, PropertySource<?>> getPropertySourcesAsMap() {
		Map<String, PropertySource<?>> map = new LinkedHashMap<>();
		for (PropertySource<?> source : getPropertySources()) {
			if (!ConfigurationPropertySources.isAttachedConfigurationPropertySource(source)) {
				extract('', map, source);
			}
		}
		return map;
	}
	private MutablePropertySources getPropertySources() {
		if (this.environment instanceof ConfigurableEnvironment configurableEnvironment) {
			return configurableEnvironment.getPropertySources();
		}
		return new StandardEnvironment().getPropertySources();
	}
	private void extract(String root, Map<String, PropertySource<?>> map, PropertySource<?> source) {
		if (source instanceof CompositePropertySource compositePropertySource) {
			for (PropertySource<?> nest : compositePropertySource.getPropertySources()) {
				extract(source.getName() + ':', map, nest);
			}
		}
		else {
			map.put(root + source.getName(), source);
		}
	}
	private Object sanitize(PropertySource<?> source, String name, Object value, boolean showUnsanitized) {
		return this.sanitizer.sanitize(new SanitizableData(source, name, value), showUnsanitized);
	}
	protected Object stringifyIfNecessary(Object value) {
		if (value == null || ClassUtils.isPrimitiveOrWrapper(value.getClass())
				|| Number.class.isAssignableFrom(value.getClass())) {
			return value;
		}
		if (CharSequence.class.isAssignableFrom(value.getClass())) {
			return value.toString();
		}
		return 'Complex property type ' + value.getClass().getName();
	}
	/**
	 * Description of an {@link Environment}.
	 */
	public static final class EnvironmentDescriptor implements OperationResponseBody {
		private final List<String> activeProfiles;
		private final List<String> defaultProfiles;
		private final List<PropertySourceDescriptor> propertySources;
		private EnvironmentDescriptor(List<String> activeProfiles, List<String> defaultProfiles,
				List<PropertySourceDescriptor> propertySources) {
			this.activeProfiles = activeProfiles;
			this.defaultProfiles = defaultProfiles;
			this.propertySources = propertySources;
		}
		public List<String> getActiveProfiles() {
			return this.activeProfiles;
		}
		public List<String> getDefaultProfiles() {
			return this.defaultProfiles;
		}
		public List<PropertySourceDescriptor> getPropertySources() {
			return this.propertySources;
		}
	}
	/**
	 * Description of an entry of the {@link Environment}.
	 */
	@JsonInclude(JsonInclude.Include.NON_NULL)
	public static final class EnvironmentEntryDescriptor {
		private final PropertySummaryDescriptor property;
		private final List<String> activeProfiles;
		private final List<String> defaultProfiles;
		private final List<PropertySourceEntryDescriptor> propertySources;
		EnvironmentEntryDescriptor(PropertySummaryDescriptor property, List<String> activeProfiles,
				List<String> defaultProfiles, List<PropertySourceEntryDescriptor> propertySources) {
			this.property = property;
			this.activeProfiles = activeProfiles;
			this.defaultProfiles = defaultProfiles;
			this.propertySources = propertySources;
		}
		public PropertySummaryDescriptor getProperty() {
			return this.property;
		}
		public List<String> getActiveProfiles() {
			return this.activeProfiles;
		}
		public List<String> getDefaultProfiles() {
			return this.defaultProfiles;
		}
		public List<PropertySourceEntryDescriptor> getPropertySources() {
			return this.propertySources;
		}
	}
	/**
	 * Description of a particular entry of the {@link Environment}.
	 */
	@JsonInclude(JsonInclude.Include.NON_NULL)
	public static final class PropertySummaryDescriptor {
		private final String source;
		private final Object value;
		public PropertySummaryDescriptor(String source, Object value) {
			this.source = source;
			this.value = value;
		}
		public String getSource() {
			return this.source;
		}
		public Object getValue() {
			return this.value;
		}
	}
	/**
	 * Description of a {@link PropertySource}.
	 */
	public static final class PropertySourceDescriptor {
		private final String name;
		private final Map<String, PropertyValueDescriptor> properties;
		private PropertySourceDescriptor(String name, Map<String, PropertyValueDescriptor> properties) {
			this.name = name;
			this.properties = properties;
		}
		public String getName() {
			return this.name;
		}
		public Map<String, PropertyValueDescriptor> getProperties() {
			return this.properties;
		}
	}
	/**
	 * Description of a particular entry of {@link PropertySource}.
	 */
	@JsonInclude(JsonInclude.Include.NON_NULL)
	public static final class PropertySourceEntryDescriptor {
		private final String name;
		private final PropertyValueDescriptor property;
		private PropertySourceEntryDescriptor(String name, PropertyValueDescriptor property) {
			this.name = name;
			this.property = property;
		}
		public String getName() {
			return this.name;
		}
		public PropertyValueDescriptor getProperty() {
			return this.property;
		}
	}
	/**
	 * Description of a property"s value, including its origin if available.
	 */
	@JsonInclude(JsonInclude.Include.NON_NULL)
	public static final class PropertyValueDescriptor {
		private final Object value;
		private final String origin;
		private final String[] originParents;
		private PropertyValueDescriptor(Object value, Origin origin) {
			this.value = value;
			this.origin = (origin != null) ? origin.toString() : null;
			List<Origin> originParents = Origin.parentsFrom(origin);
			this.originParents = originParents.isEmpty() ? null
					: originParents.stream().map(Object::toString).toArray(String[]::new);
		}
		public Object getValue() {
			return this.value;
		}
		public String getOrigin() {
			return this.origin;
		}
		public String[] getOriginParents() {
			return this.originParents;
		}
	}
}
/*
package org.springframework.boot.actuate.env;
/**
@EndpointWebExtension(endpoint = EnvironmentEndpoint.class)
public class EnvironmentEndpointWebExtension {
	private final EnvironmentEndpoint delegate;
	private final Show showValues;
	private final Set<String> roles;
	public EnvironmentEndpointWebExtension(EnvironmentEndpoint delegate, Show showValues, Set<String> roles) {
		this.delegate = delegate;
		this.showValues = showValues;
		this.roles = roles;
	}
	@ReadOperation
	public EnvironmentDescriptor environment(SecurityContext securityContext, @Nullable String pattern) {
		boolean showUnsanitized = this.showValues.isShown(securityContext, this.roles);
		return this.delegate.getEnvironmentDescriptor(pattern, showUnsanitized);
	}
	@ReadOperation
	public WebEndpointResponse<EnvironmentEntryDescriptor> environmentEntry(SecurityContext securityContext,
			@Selector String toMatch) {
		boolean showUnsanitized = this.showValues.isShown(securityContext, this.roles);
		EnvironmentEntryDescriptor descriptor = this.delegate.getEnvironmentEntryDescriptor(toMatch, showUnsanitized);
		return (descriptor.getProperty() != null) ? new WebEndpointResponse<>(descriptor, WebEndpointResponse.STATUS_OK)
				: new WebEndpointResponse<>(WebEndpointResponse.STATUS_NOT_FOUND);
	}
}
/*
/**
package org.springframework.boot.actuate.env;
/*
package org.springframework.boot.actuate.beans;
/**
@Endpoint(id = 'beans')
public class BeansEndpoint {
	private final ConfigurableApplicationContext context;
	/**
	 * Creates a new {@code BeansEndpoint} that will describe the beans in the given
	 * {@code context} and all of its ancestors.
	 * @param context the application context
	 * @see ConfigurableApplicationContext#getParent()
	 */
	public BeansEndpoint(ConfigurableApplicationContext context) {
		this.context = context;
	}
	@ReadOperation
	public BeansDescriptor beans() {
		Map<String, ContextBeansDescriptor> contexts = new HashMap<>();
		ConfigurableApplicationContext context = this.context;
		while (context != null) {
			contexts.put(context.getId(), ContextBeansDescriptor.describing(context));
			context = getConfigurableParent(context);
		}
		return new BeansDescriptor(contexts);
	}
	private static ConfigurableApplicationContext getConfigurableParent(ConfigurableApplicationContext context) {
		ApplicationContext parent = context.getParent();
		if (parent instanceof ConfigurableApplicationContext configurableParent) {
			return configurableParent;
		}
		return null;
	}
	/**
	 * Description of an application"s beans.
	 */
	public static final class BeansDescriptor implements OperationResponseBody {
		private final Map<String, ContextBeansDescriptor> contexts;
		private BeansDescriptor(Map<String, ContextBeansDescriptor> contexts) {
			this.contexts = contexts;
		}
		public Map<String, ContextBeansDescriptor> getContexts() {
			return this.contexts;
		}
	}
	/**
	 * Description of an application context beans.
	 */
	public static final class ContextBeansDescriptor {
		private final Map<String, BeanDescriptor> beans;
		private final String parentId;
		private ContextBeansDescriptor(Map<String, BeanDescriptor> beans, String parentId) {
			this.beans = beans;
			this.parentId = parentId;
		}
		public String getParentId() {
			return this.parentId;
		}
		public Map<String, BeanDescriptor> getBeans() {
			return this.beans;
		}
		private static ContextBeansDescriptor describing(ConfigurableApplicationContext context) {
			if (context == null) {
				return null;
			}
			ConfigurableApplicationContext parent = getConfigurableParent(context);
			return new ContextBeansDescriptor(describeBeans(context.getBeanFactory()),
					(parent != null) ? parent.getId() : null);
		}
		private static Map<String, BeanDescriptor> describeBeans(ConfigurableListableBeanFactory beanFactory) {
			Map<String, BeanDescriptor> beans = new HashMap<>();
			for (String beanName : beanFactory.getBeanDefinitionNames()) {
				BeanDefinition definition = beanFactory.getBeanDefinition(beanName);
				if (isBeanEligible(beanName, definition, beanFactory)) {
					beans.put(beanName, describeBean(beanName, definition, beanFactory));
				}
			}
			return beans;
		}
		private static BeanDescriptor describeBean(String name, BeanDefinition definition,
				ConfigurableListableBeanFactory factory) {
			return new BeanDescriptor(factory.getAliases(name), definition.getScope(), factory.getType(name),
					definition.getResourceDescription(), factory.getDependenciesForBean(name));
		}
		private static boolean isBeanEligible(String beanName, BeanDefinition bd, ConfigurableBeanFactory bf) {
			return (bd.getRole() != BeanDefinition.ROLE_INFRASTRUCTURE
					&& (!bd.isLazyInit() || bf.containsSingleton(beanName)));
		}
	}
	/**
	 * Description of a bean.
	 */
	public static final class BeanDescriptor {
		private final String[] aliases;
		private final String scope;
		private final Class<?> type;
		private final String resource;
		private final String[] dependencies;
		private BeanDescriptor(String[] aliases, String scope, Class<?> type, String resource, String[] dependencies) {
			this.aliases = aliases;
			this.scope = (StringUtils.hasText(scope) ? scope : BeanDefinition.SCOPE_SINGLETON);
			this.type = type;
			this.resource = resource;
			this.dependencies = dependencies;
		}
		public String[] getAliases() {
			return this.aliases;
		}
		public String getScope() {
			return this.scope;
		}
		public Class<?> getType() {
			return this.type;
		}
		public String getResource() {
			return this.resource;
		}
		public String[] getDependencies() {
			return this.dependencies;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.beans;
/*
package org.springframework.boot.docs.howto.actuator.maphealthindicatorstometrics;
/**
@SpringBootTest
class MetricsHealthMicrometerExportTests {
	@Autowired
	private MeterRegistry registry;
	@Test
	void registryExportsHealth() {
		Gauge gauge = this.registry.get('health').gauge();
		assertThat(gauge.value()).isEqualTo(2);
	}
	@Configuration(proxyBeanMethods = false)
	@Import(MyHealthMetricsExportConfiguration.class)
	@ImportAutoConfiguration(classes = { HealthContributorAutoConfiguration.class, MetricsAutoConfiguration.class,
			HealthEndpointAutoConfiguration.class })
	static class Config {
		@Bean
		MetricsHealthMicrometerExport example() {
			return new MetricsHealthMicrometerExport();
		}
		@Bean
		SimpleMeterRegistry simpleMeterRegistry() {
			return new SimpleMeterRegistry();
		}
		@Bean
		HealthIndicator outOfService() {
			return () -> new Health.Builder().outOfService().build();
		}
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configuretwodatasources;
/**
@SpringBootTest(properties = { 'app.datasource.url=jdbc:h2:mem:bar;DB_CLOSE_DELAY=-1', 'app.datasource.max-total=42' })
@Import(MyAdditionalDataSourceConfiguration.class)
class MyDataSourcesConfigurationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private DataSource dataSource;
	@Autowired
	@Qualifier('second')
	private DataSource secondDataSource;
	@Test
	void validateConfiguration() throws SQLException {
		assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(2);
		assertThat(this.context.getBean('dataSource')).isSameAs(this.dataSource);
		assertThat(this.dataSource.getConnection().getMetaData().getURL()).startsWith('jdbc:h2:mem:');
		assertThat(this.context.getBean('secondDataSource')).isSameAs(this.secondDataSource);
		assertThat(this.secondDataSource).extracting((dataSource) -> ((BasicDataSource) dataSource).getUrl())
			.isEqualTo('jdbc:h2:mem:bar;DB_CLOSE_DELAY=-1');
		assertThat(this.secondDataSource).extracting((dataSource) -> ((BasicDataSource) dataSource).getMaxTotal())
			.isEqualTo(42);
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configuretwodatasources;
/**
@SpringBootTest
@Import(MyCompleteAdditionalDataSourceConfiguration.class)
class MyCompleteDataSourcesConfigurationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private DataSource dataSource;
	@Autowired
	@Qualifier('second')
	private DataSource secondDataSource;
	@Test
	void validateConfiguration() throws SQLException {
		assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(2);
		assertThat(this.context.getBean('dataSource')).isSameAs(this.dataSource);
		assertThat(this.dataSource.getConnection().getMetaData().getURL()).startsWith('jdbc:h2:mem:');
		assertThat(this.context.getBean('secondDataSource')).isSameAs(this.secondDataSource);
		assertThat(this.secondDataSource.getConnection().getMetaData().getURL()).startsWith('jdbc:h2:mem:');
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess;
/**
@SpringBootConfiguration
@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
class SampleApp {
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource.configurable;
/**
@ExtendWith(SpringExtension.class)
@SpringBootTest(properties = { 'app.datasource.url=jdbc:h2:mem:configurable;DB_CLOSE_DELAY=-1',
		'app.datasource.configuration.maximum-pool-size=42' })
@Import(MyDataSourceConfiguration.class)
class MyDataSourceConfigurationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void validateConfiguration() throws SQLException {
		assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(1);
		HikariDataSource dataSource = this.context.getBean(HikariDataSource.class);
		assertThat(dataSource.getConnection().getMetaData().getURL()).isEqualTo('jdbc:h2:mem:configurable');
		assertThat(dataSource.getMaximumPoolSize()).isEqualTo(42);
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource;
/**
@ExtendWith(SpringExtension.class)
@SpringBootTest(properties = 'app.datasource.jdbcUrl=jdbc:h2:mem:basic;DB_CLOSE_DELAY=-1')
@Import(MyDataSourceConfiguration.class)
class MyDataSourceConfigurationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void validateConfiguration() throws SQLException {
		assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(1);
		DataSource dataSource = this.context.getBean(DataSource.class);
		assertThat(dataSource.getConnection().getMetaData().getURL()).isEqualTo('jdbc:h2:mem:basic');
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource.simple;
/**
@ExtendWith(SpringExtension.class)
@SpringBootTest(properties = { 'app.datasource.jdbc-url=jdbc:h2:mem:simple;DB_CLOSE_DELAY=-1',
		'app.datasource.maximum-pool-size=42' })
@Import(MyDataSourceConfiguration.class)
class MyDataSourceConfigurationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void validateConfiguration() throws SQLException {
		assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(1);
		HikariDataSource dataSource = this.context.getBean(HikariDataSource.class);
		assertThat(dataSource.getConnection().getMetaData().getURL()).isEqualTo('jdbc:h2:mem:simple');
		assertThat(dataSource.getMaximumPoolSize()).isEqualTo(42);
	}
}
/*
package org.springframework.boot.docs.howto.springbootapplication;
/**
class MyEnvironmentPostProcessorTests {
	private final StandardEnvironment environment = new StandardEnvironment();
	@Test
	void applyEnvironmentPostProcessor() {
		assertThat(this.environment.containsProperty('test.foo.bar')).isFalse();
		new MyEnvironmentPostProcessor().postProcessEnvironment(this.environment, new SpringApplication());
		assertThat(this.environment.containsProperty('test.foo.bar')).isTrue();
		assertThat(this.environment.getProperty('test.foo.bar')).isEqualTo('value');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.jmx;
/**
class MyJmxTestsTests extends MyJmxTests {
}
/*
package org.springframework.boot.docs.testing.utilities.outputcapture;
/**
class MyOutputCaptureTestsTests extends MyOutputCaptureTests {
}
/*
package org.springframework.boot.docs.testing.utilities.testresttemplate;
/**
class MySpringBootTestsTests extends MySpringBootTests {
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.conversion.durations.javabeanbinding;
/**
class MyPropertiesTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(Config.class);
	@Test
	void bindWithDefaultUnit() {
		this.contextRunner.withPropertyValues('my.session-timeout=40', 'my.read-timeout=5000')
			.run(assertBinding((properties) -> {
				assertThat(properties.getSessionTimeout()).hasSeconds(40);
				assertThat(properties.getReadTimeout()).hasMillis(5000);
			}));
	}
	@Test
	void bindWithExplicitUnit() {
		this.contextRunner.withPropertyValues('my.session-timeout=1h', 'my.read-timeout=5s')
			.run(assertBinding((properties) -> {
				assertThat(properties.getSessionTimeout()).hasMinutes(60);
				assertThat(properties.getReadTimeout()).hasMillis(5000);
			}));
	}
	@Test
	void bindWithIso8601Format() {
		this.contextRunner.withPropertyValues('my.session-timeout=PT15S', 'my.read-timeout=PT0.5S')
			.run(assertBinding((properties) -> {
				assertThat(properties.getSessionTimeout()).hasSeconds(15);
				assertThat(properties.getReadTimeout()).hasMillis(500);
			}));
	}
	private ContextConsumer<AssertableApplicationContext> assertBinding(Consumer<MyProperties> properties) {
		return (context) -> {
			assertThat(context).hasSingleBean(MyProperties.class);
			properties.accept(context.getBean(MyProperties.class));
		};
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(MyProperties.class)
	static class Config {
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.conversion.durations.constructorbinding;
/**
class MyPropertiesTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(Config.class);
	@Test
	void bindWithDefaultUnit() {
		this.contextRunner.withPropertyValues('my.session-timeout=40', 'my.read-timeout=5000')
			.run(assertBinding((properties) -> {
				assertThat(properties.getSessionTimeout()).hasSeconds(40);
				assertThat(properties.getReadTimeout()).hasMillis(5000);
			}));
	}
	@Test
	void bindWithExplicitUnit() {
		this.contextRunner.withPropertyValues('my.session-timeout=1h', 'my.read-timeout=5s')
			.run(assertBinding((properties) -> {
				assertThat(properties.getSessionTimeout()).hasMinutes(60);
				assertThat(properties.getReadTimeout()).hasMillis(5000);
			}));
	}
	@Test
	void bindWithIso8601Format() {
		this.contextRunner.withPropertyValues('my.session-timeout=PT15S', 'my.read-timeout=PT0.5S')
			.run(assertBinding((properties) -> {
				assertThat(properties.getSessionTimeout()).hasSeconds(15);
				assertThat(properties.getReadTimeout()).hasMillis(500);
			}));
	}
	private ContextConsumer<AssertableApplicationContext> assertBinding(Consumer<MyProperties> properties) {
		return (context) -> {
			assertThat(context).hasSingleBean(MyProperties.class);
			properties.accept(context.getBean(MyProperties.class));
		};
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(MyProperties.class)
	static class Config {
	}
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.testing;
/**
class MyServiceAutoConfigurationTestsTests extends MyServiceAutoConfigurationTests {
}
/*
package org.springframework.boot.docs.features.springapplication.fluentbuilderapi;
/**
@ExtendWith(OutputCaptureExtension.class)
class MyApplicationTests {
	@Test
	void contextHierarchyWithDisabledBanner(CapturedOutput output) {
		System.setProperty('spring.main.web-application-type', 'none');
		try {
			new MyApplication().hierarchyWithDisabledBanner(new String[0]);
			assertThat(output).doesNotContain(':: Spring Boot ::');
		}
		finally {
			System.clearProperty('spring.main.web-application-type');
		}
	}
}
/*
package org.springframework.boot.docs.howto.webserver.addservletfilterlistener.springbean.disable;
@Configuration(proxyBeanMethods = false)
public class MyFilterConfiguration {
	@Bean
	public FilterRegistrationBean<MyFilter> registration(MyFilter filter) {
		FilterRegistrationBean<MyFilter> registration = new FilterRegistrationBean<>(filter);
		registration.setEnabled(false);
		return registration;
	}
}
/*
package org.springframework.boot.docs.howto.webserver.addservletfilterlistener.springbean.disable;
public abstract class MyFilter implements Filter {
}
/*
package org.springframework.boot.docs.howto.webserver.createwebsocketendpointsusingserverendpoint;
@Configuration(proxyBeanMethods = false)
public class MyWebSocketConfiguration {
	@Bean
	public ServerEndpointExporter serverEndpointExporter() {
		return new ServerEndpointExporter();
	}
}
/*
package org.springframework.boot.docs.howto.webserver.configure;
@Component
public class MyTomcatWebServerCustomizer implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {
	@Override
	public void customize(TomcatServletWebServerFactory factory) {
		// customize the factory here
	}
}
/*
package org.springframework.boot.docs.howto.webserver.discoverport;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyWebIntegrationTests {
	@LocalServerPort
	int port;
	// ...
}
/*
package org.springframework.boot.docs.howto.webserver.enablemultiplelistenersinundertow;
@Configuration(proxyBeanMethods = false)
public class MyUndertowConfiguration {
	@Bean
	public WebServerFactoryCustomizer<UndertowServletWebServerFactory> undertowListenerCustomizer() {
		return (factory) -> factory.addBuilderCustomizers(this::addHttpListener);
	}
	private Builder addHttpListener(Builder builder) {
		return builder.addHttpListener(8080, '0.0.0.0');
	}
}
/*
package org.springframework.boot.docs.howto.webserver.enablemultipleconnectorsintomcat;
@Configuration(proxyBeanMethods = false)
public class MyTomcatConfiguration {
	@Bean
	public WebServerFactoryCustomizer<TomcatServletWebServerFactory> connectorCustomizer() {
		return (tomcat) -> tomcat.addAdditionalTomcatConnectors(createConnector());
	}
	private Connector createConnector() {
		Connector connector = new Connector('org.apache.coyote.http11.Http11NioProtocol');
		connector.setPort(8081);
		return connector;
	}
}
/*
package org.springframework.boot.docs.howto.messaging.disabletransactedjmssession;
@Configuration(proxyBeanMethods = false)
public class MyJmsConfiguration {
	@Bean
	public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(ConnectionFactory connectionFactory,
			DefaultJmsListenerContainerFactoryConfigurer configurer) {
		DefaultJmsListenerContainerFactory listenerFactory = new DefaultJmsListenerContainerFactory();
		configurer.configure(listenerFactory, ConnectionFactoryUnwrapper.unwrap(connectionFactory));
		listenerFactory.setTransactionManager(null);
		listenerFactory.setSessionTransacted(false);
		return listenerFactory;
	}
}
/*
package org.springframework.boot.docs.howto.testing.slicetests;
@Configuration(proxyBeanMethods = false)
public class MyDatasourceConfiguration {
	@Bean
	@ConfigurationProperties('app.datasource.second')
	public BasicDataSource secondDataSource() {
		return DataSourceBuilder.create().type(BasicDataSource.class).build();
	}
}
/*
package org.springframework.boot.docs.howto.testing.slicetests;
@Configuration(proxyBeanMethods = false)
public class MyConfiguration {
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
		return http.build();
	}
	@Bean
	@ConfigurationProperties('app.datasource.second')
	public BasicDataSource secondDataSource() {
		return DataSourceBuilder.create().type(BasicDataSource.class).build();
	}
}
/*
package org.springframework.boot.docs.howto.testing.slicetests;
@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
		return http.build();
	}
}
/*
package org.springframework.boot.docs.howto.testing.withspringsecurity;
@WebMvcTest(UserController.class)
class MySecurityTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	@WithMockUser(roles = 'ADMIN')
	void requestProtectedUrlWithUser() {
		assertThat(this.mvc.get().uri('/')).doesNotHaveFailed();
	}
}
/*
package org.springframework.boot.docs.howto.testing.withspringsecurity;
class UserController {
}
/*
package org.springframework.boot.docs.howto.deployment.cloud.cloudfoundry.bindingtoservices;
@Component
public class MyBean implements EnvironmentAware {
	@SuppressWarnings('unused')
	private String instanceId;
	@Override
	public void setEnvironment(Environment environment) {
		this.instanceId = environment.getProperty('vcap.application.instance_id');
	}
	// ...
}
/*
package org.springframework.boot.docs.howto.traditionaldeployment.convertexistingapplication.both;
@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
		return customizerBuilder(builder);
	}
	public static void main(String[] args) {
		customizerBuilder(new SpringApplicationBuilder()).run(args);
	}
	private static SpringApplicationBuilder customizerBuilder(SpringApplicationBuilder builder) {
		return builder.sources(MyApplication.class).bannerMode(Banner.Mode.OFF);
	}
}
/*
package org.springframework.boot.docs.howto.traditionaldeployment.convertexistingapplication;
@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		// Customize the application or call application.sources(...) to add sources
		// Since our example is itself a @Configuration class (through
		// @SpringBootApplication)
		// we actually do not need to override this method.
		return application;
	}
	// tag::main[]
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
	// end::main[]
}
/*
package org.springframework.boot.docs.howto.traditionaldeployment.weblogic;
@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer implements WebApplicationInitializer {
}
/*
package org.springframework.boot.docs.howto.traditionaldeployment.war;
@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(MyApplication.class);
	}
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.howto.security.enablehttps;
@Configuration
public class MySecurityConfig {
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		// Customize the application security ...
		http.requiresChannel((channel) -> channel.anyRequest().requiresSecure());
		return http.build();
	}
}
/*
package org.springframework.boot.docs.howto.jersey.alongsideanotherwebframework;
@Component
public class JerseyConfig extends ResourceConfig {
	public JerseyConfig() {
		register(Endpoint.class);
		property(ServletProperties.FILTER_FORWARD_ON_404, true);
	}
}
/*
package org.springframework.boot.docs.howto.jersey.alongsideanotherwebframework;
class Endpoint {
}
/*
package org.springframework.boot.docs.howto.jersey.springsecurity;
@Component
public class JerseySetStatusOverSendErrorConfig extends ResourceConfig {
	public JerseySetStatusOverSendErrorConfig() {
		register(Endpoint.class);
		setProperties(Collections.singletonMap('jersey.config.server.response.setStatusOverSendError', true));
	}
}
/*
package org.springframework.boot.docs.howto.jersey.springsecurity;
class Endpoint {
}
/*
package org.springframework.boot.docs.howto.actuator.maphealthindicatorstometrics;
@Configuration(proxyBeanMethods = false)
public class MyHealthMetricsExportConfiguration {
	public MyHealthMetricsExportConfiguration(MeterRegistry registry, HealthEndpoint healthEndpoint) {
		// This example presumes common tags (such as the app) are applied elsewhere
		Gauge.builder('health', healthEndpoint, this::getStatusCode).strongReference(true).register(registry);
	}
	private int getStatusCode(HealthEndpoint health) {
		Status status = health.health().getStatus();
		if (Status.UP.equals(status)) {
			return 3;
		}
		if (Status.OUT_OF_SERVICE.equals(status)) {
			return 2;
		}
		if (Status.DOWN.equals(status)) {
			return 1;
		}
		return 0;
	}
}
/*
package org.springframework.boot.docs.howto.actuator.maphealthindicatorstometrics;
public class MetricsHealthMicrometerExport {
}
/*
package org.springframework.boot.docs.howto.propertiesandconfiguration.externalizeconfiguration.application;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication application = new SpringApplication(MyApplication.class);
		application.setBannerMode(Banner.Mode.OFF);
		application.run(args);
	}
}
/*
package org.springframework.boot.docs.howto.propertiesandconfiguration.externalizeconfiguration.builder;
public class MyApplication {
	public static void main(String[] args) {
		// @formatter:off
		new SpringApplicationBuilder()
			.bannerMode(Banner.Mode.OFF)
			.sources(MyApplication.class)
			.run(args);
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configuretwodatasources;
@Configuration(proxyBeanMethods = false)
public class MyAdditionalDataSourceConfiguration {
	@Qualifier('second')
	@Bean(defaultCandidate = false)
	@ConfigurationProperties('app.datasource')
	public BasicDataSource secondDataSource() {
		return DataSourceBuilder.create().type(BasicDataSource.class).build();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configuretwodatasources;
@Configuration(proxyBeanMethods = false)
public class MyCompleteAdditionalDataSourceConfiguration {
	@Qualifier('second')
	@Bean(defaultCandidate = false)
	@ConfigurationProperties('app.datasource')
	public DataSourceProperties secondDataSourceProperties() {
		return new DataSourceProperties();
	}
	@Qualifier('second')
	@Bean(defaultCandidate = false)
	@ConfigurationProperties('app.datasource.configuration')
	public BasicDataSource secondDataSource(
			@Qualifier('secondDataSourceProperties') DataSourceProperties secondDataSourceProperties) {
		return secondDataSourceProperties.initializeDataSourceBuilder().type(BasicDataSource.class).build();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configureacomponentthatisusedbyjpa;
/**
@Component
public class ElasticsearchEntityManagerFactoryDependsOnPostProcessor
		extends EntityManagerFactoryDependsOnPostProcessor {
	public ElasticsearchEntityManagerFactoryDependsOnPostProcessor() {
		super('elasticsearchClient');
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurehibernatesecondlevelcaching;
@Configuration(proxyBeanMethods = false)
public class MyHibernateSecondLevelCacheConfiguration {
	@Bean
	public HibernatePropertiesCustomizer hibernateSecondLevelCacheCustomizer(JCacheCacheManager cacheManager) {
		return (properties) -> properties.put(ConfigSettings.CACHE_MANAGER, cacheManager.getCacheManager());
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.separateentitydefinitionsfromspringconfiguration;
class City {
}
/*
package org.springframework.boot.docs.howto.dataaccess.separateentitydefinitionsfromspringconfiguration;
@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@EntityScan(basePackageClasses = City.class)
public class MyApplication {
	// ...
}
/*
package org.springframework.boot.docs.howto.dataaccess.usemultipleentitymanagers;
@Configuration(proxyBeanMethods = false)
@EnableJpaRepositories(basePackageClasses = Order.class, entityManagerFactoryRef = 'entityManagerFactory')
public class OrderConfiguration {
}
/*
package org.springframework.boot.docs.howto.dataaccess.usemultipleentitymanagers;
public class Customer {
}
/*
package org.springframework.boot.docs.howto.dataaccess.usemultipleentitymanagers;
@Configuration(proxyBeanMethods = false)
@EnableJpaRepositories(basePackageClasses = Customer.class, entityManagerFactoryRef = 'secondEntityManagerFactory')
public class CustomerConfiguration {
}
/*
package org.springframework.boot.docs.howto.dataaccess.usemultipleentitymanagers;
@Configuration(proxyBeanMethods = false)
public class MyAdditionalEntityManagerFactoryConfiguration {
	@Qualifier('second')
	@Bean(defaultCandidate = false)
	@ConfigurationProperties('app.jpa')
	public JpaProperties secondJpaProperties() {
		return new JpaProperties();
	}
	@Qualifier('second')
	@Bean(defaultCandidate = false)
	public LocalContainerEntityManagerFactoryBean secondEntityManagerFactory(@Qualifier('second') DataSource dataSource,
			@Qualifier('second') JpaProperties jpaProperties) {
		EntityManagerFactoryBuilder builder = createEntityManagerFactoryBuilder(jpaProperties);
		return builder.dataSource(dataSource).packages(Order.class).persistenceUnit('second').build();
	}
	private EntityManagerFactoryBuilder createEntityManagerFactoryBuilder(JpaProperties jpaProperties) {
		JpaVendorAdapter jpaVendorAdapter = createJpaVendorAdapter(jpaProperties);
		return new EntityManagerFactoryBuilder(jpaVendorAdapter, jpaProperties.getProperties(), null);
	}
	private JpaVendorAdapter createJpaVendorAdapter(JpaProperties jpaProperties) {
		// ... map JPA properties as needed
		return new HibernateJpaVendorAdapter();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.usemultipleentitymanagers;
public class Order {
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurehibernatenamingstrategy.spring;
@Configuration(proxyBeanMethods = false)
public class MyHibernateConfiguration {
	@Bean
	public CamelCaseToUnderscoresNamingStrategy caseSensitivePhysicalNamingStrategy() {
		return new CamelCaseToUnderscoresNamingStrategy() {
			@Override
			protected boolean isCaseInsensitive(JdbcEnvironment jdbcEnvironment) {
				return false;
			}
		};
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurehibernatenamingstrategy.standard;
@Configuration(proxyBeanMethods = false)
class MyHibernateConfiguration {
	@Bean
	PhysicalNamingStrategyStandardImpl caseSensitivePhysicalNamingStrategy() {
		return new PhysicalNamingStrategyStandardImpl();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource.configurable;
@Configuration(proxyBeanMethods = false)
public class MyDataSourceConfiguration {
	@Bean
	@Primary
	@ConfigurationProperties('app.datasource')
	public DataSourceProperties dataSourceProperties() {
		return new DataSourceProperties();
	}
	@Bean
	@ConfigurationProperties('app.datasource.configuration')
	public HikariDataSource dataSource(DataSourceProperties properties) {
		return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource.custom;
public class SomeDataSource {
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource.custom;
@Configuration(proxyBeanMethods = false)
public class MyDataSourceConfiguration {
	@Bean
	@ConfigurationProperties(prefix = 'app.datasource')
	public SomeDataSource dataSource() {
		return new SomeDataSource();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource.builder;
@Configuration(proxyBeanMethods = false)
public class MyDataSourceConfiguration {
	@Bean
	@ConfigurationProperties('app.datasource')
	public DataSource dataSource() {
		return DataSourceBuilder.create().build();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.configurecustomdatasource.simple;
@Configuration(proxyBeanMethods = false)
public class MyDataSourceConfiguration {
	@Bean
	@ConfigurationProperties('app.datasource')
	public HikariDataSource dataSource() {
		return DataSourceBuilder.create().type(HikariDataSource.class).build();
	}
}
/*
package org.springframework.boot.docs.howto.dataaccess.filterscannedentitydefinitions;
@Configuration(proxyBeanMethods = false)
public class MyEntityScanConfiguration {
	@Bean
	public ManagedClassNameFilter entityScanFilter() {
		return (className) -> className.startsWith('com.example.app.customer.');
	}
}
/*
package org.springframework.boot.docs.howto.nativeimage.developingyourfirstapplication.sampleapplication;
@RestController
@SpringBootApplication
public class MyApplication {
	@RequestMapping('/')
	String home() {
		return 'Hello World!';
	}
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.howto.application.customizetheenvironmentorapplicationcontext;
public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor {
	private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		Resource path = new ClassPathResource('com/example/myapp/config.yml');
		PropertySource<?> propertySource = loadYaml(path);
		environment.getPropertySources().addLast(propertySource);
	}
	private PropertySource<?> loadYaml(Resource path) {
		Assert.isTrue(path.exists(), () -> 'Resource ' + path + ' does not exist');
		try {
			return this.loader.load('custom-resource', path).get(0);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to load yaml configuration from ' + path, ex);
		}
	}
}
/*
package org.springframework.boot.docs.howto.httpclients.webclientreactornettycustomization;
@Configuration(proxyBeanMethods = false)
public class MyReactorNettyClientConfiguration {
	@Bean
	ClientHttpConnector clientHttpConnector(ReactorResourceFactory resourceFactory) {
		// @formatter:off
		HttpClient httpClient = HttpClient.create(resourceFactory.getConnectionProvider())
				.runOn(resourceFactory.getLoopResources())
				.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 60000)
				.doOnConnected((connection) -> connection.addHandlerLast(new ReadTimeoutHandler(60)));
		return new ReactorClientHttpConnector(httpClient);
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.howto.springmvc.writexmlrestservice;
@XmlRootElement
public class MyThing {
	private String name;
	// @fold:on // getters/setters ...
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.howto.springmvc.writejsonrestservice;
@RestController
public class MyController {
	@RequestMapping('/thing')
	public MyThing thing() {
		return new MyThing();
	}
}
/*
package org.springframework.boot.docs.howto.springmvc.writejsonrestservice;
public class MyThing {
}
/*
package org.springframework.boot.docs.io.jta.mixingxaandnonxaconnections.xa;
public class MyBean {
	public MyBean(@Qualifier('xaJmsConnectionFactory') ConnectionFactory connectionFactory) {
		// ...
	}
}
/*
package org.springframework.boot.docs.io.jta.mixingxaandnonxaconnections.primary;
public class MyBean {
	public MyBean(ConnectionFactory connectionFactory) {
		// ...
	}
}
/*
package org.springframework.boot.docs.io.jta.mixingxaandnonxaconnections.nonxa;
public class MyBean {
	public MyBean(@Qualifier('nonXaJmsConnectionFactory') ConnectionFactory connectionFactory) {
		// ...
	}
}
/*
package org.springframework.boot.docs.io.webservices.template;
@Configuration(proxyBeanMethods = false)
public class MyWebServiceTemplateConfiguration {
	@Bean
	public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(2))
			.withReadTimeout(Duration.ofSeconds(2));
		WebServiceMessageSender sender = WebServiceMessageSenderFactory.http(settings).getWebServiceMessageSender();
		return builder.messageSenders(sender).build();
	}
}
/*
package org.springframework.boot.docs.io.webservices.template;
class SomeResponse {
}
/*
package org.springframework.boot.docs.io.webservices.template;
@Service
public class MyService {
	private final WebServiceTemplate webServiceTemplate;
	public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
		this.webServiceTemplate = webServiceTemplateBuilder.build();
	}
	public SomeResponse someWsCall(SomeRequest detailsReq) {
		return (SomeResponse) this.webServiceTemplate.marshalSendAndReceive(detailsReq,
				new SoapActionCallback('https://ws.example.com/action'));
	}
}
/*
package org.springframework.boot.docs.io.webservices.template;
class SomeRequest {
}
/*
package org.springframework.boot.docs.io.quartz;
public class MySampleJob extends QuartzJobBean {
	// @fold:on // fields ...
	private MyService myService;
	private String name;
	// @fold:off
	// Inject 'MyService' bean
	public void setMyService(MyService myService) {
		this.myService = myService;
	}
	// Inject the 'name' job data property
	public void setName(String name) {
		this.name = name;
	}
	@Override
	protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
		this.myService.someMethod(context.getFireTime(), this.name);
	}
}
/*
package org.springframework.boot.docs.io.quartz;
class MyService {
	void someMethod(Date date, String name) {
	}
}
/*
package org.springframework.boot.docs.io.validation;
@Service
@Validated
public class MyBean {
	public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code, Author author) {
		return /**/ null;
	}
}
/*
package org.springframework.boot.docs.io.validation;
class Archive {
}
/*
package org.springframework.boot.docs.io.validation;
class Author {
}
/*
package org.springframework.boot.docs.io.restclient.webclient.ssl;
public class Details {
}
/*
package org.springframework.boot.docs.io.restclient.webclient.ssl;
@Service
public class MyService {
	private final WebClient webClient;
	public MyService(WebClient.Builder webClientBuilder, WebClientSsl ssl) {
		this.webClient = webClientBuilder.baseUrl('https://example.org').apply(ssl.fromBundle('mybundle')).build();
	}
	public Mono<Details> someRestCall(String name) {
		return this.webClient.get().uri('/{name}/details', name).retrieve().bodyToMono(Details.class);
	}
}
/*
package org.springframework.boot.docs.io.restclient.webclient;
public class Details {
}
/*
package org.springframework.boot.docs.io.restclient.webclient;
@Service
public class MyService {
	private final WebClient webClient;
	public MyService(WebClient.Builder webClientBuilder) {
		this.webClient = webClientBuilder.baseUrl('https://example.org').build();
	}
	public Mono<Details> someRestCall(String name) {
		return this.webClient.get().uri('/{name}/details', name).retrieve().bodyToMono(Details.class);
	}
}
/*
package org.springframework.boot.docs.io.restclient.restclient.ssl;
public class Details {
}
/*
package org.springframework.boot.docs.io.restclient.restclient.ssl;
@Service
public class MyService {
	private final RestClient restClient;
	public MyService(RestClient.Builder restClientBuilder, RestClientSsl ssl) {
		this.restClient = restClientBuilder.baseUrl('https://example.org').apply(ssl.fromBundle('mybundle')).build();
	}
	public Details someRestCall(String name) {
		return this.restClient.get().uri('/{name}/details', name).retrieve().body(Details.class);
	}
}
/*
package org.springframework.boot.docs.io.restclient.restclient.ssl.settings;
public class Details {
}
/*
package org.springframework.boot.docs.io.restclient.restclient.ssl.settings;
@Service
public class MyService {
	private final RestClient restClient;
	public MyService(RestClient.Builder restClientBuilder, SslBundles sslBundles) {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings
			.ofSslBundle(sslBundles.getBundle('mybundle'))
			.withReadTimeout(Duration.ofMinutes(2));
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactoryBuilder.detect().build(settings);
		this.restClient = restClientBuilder.baseUrl('https://example.org').requestFactory(requestFactory).build();
	}
	public Details someRestCall(String name) {
		return this.restClient.get().uri('/{name}/details', name).retrieve().body(Details.class);
	}
}
/*
package org.springframework.boot.docs.io.restclient.restclient;
public class Details {
}
/*
package org.springframework.boot.docs.io.restclient.restclient;
@Service
public class MyService {
	private final RestClient restClient;
	public MyService(RestClient.Builder restClientBuilder) {
		this.restClient = restClientBuilder.baseUrl('https://example.org').build();
	}
	public Details someRestCall(String name) {
		return this.restClient.get().uri('/{name}/details', name).retrieve().body(Details.class);
	}
}
/*
package org.springframework.boot.docs.io.restclient.resttemplate.ssl;
@Service
public class MyService {
	private final RestTemplate restTemplate;
	public MyService(RestTemplateBuilder restTemplateBuilder, SslBundles sslBundles) {
		this.restTemplate = restTemplateBuilder.sslBundle(sslBundles.getBundle('mybundle')).build();
	}
	public Details someRestCall(String name) {
		return this.restTemplate.getForObject('/{name}/details', Details.class, name);
	}
}
/*
package org.springframework.boot.docs.io.restclient.resttemplate.customization;
public class MyRestTemplateCustomizer implements RestTemplateCustomizer {
	@Override
	public void customize(RestTemplate restTemplate) {
		HttpRoutePlanner routePlanner = new CustomRoutePlanner(new HttpHost('proxy.example.com'));
		HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build();
		restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
	}
	static class CustomRoutePlanner extends DefaultProxyRoutePlanner {
		CustomRoutePlanner(HttpHost proxy) {
			super(proxy);
		}
		@Override
		protected HttpHost determineProxy(HttpHost target, HttpContext context) throws HttpException {
			if (target.getHostName().equals('192.168.0.5')) {
				return null;
			}
			return super.determineProxy(target, context);
		}
	}
}
/*
package org.springframework.boot.docs.io.restclient.resttemplate.customization;
@Configuration(proxyBeanMethods = false)
public class MyRestTemplateBuilderConfiguration {
	@Bean
	public RestTemplateBuilder restTemplateBuilder(RestTemplateBuilderConfigurer configurer) {
		return configurer.configure(new RestTemplateBuilder())
			.connectTimeout(Duration.ofSeconds(5))
			.readTimeout(Duration.ofSeconds(2));
	}
}
/*
package org.springframework.boot.docs.io.restclient.resttemplate;
public class Details {
}
/*
package org.springframework.boot.docs.io.restclient.resttemplate;
@Service
public class MyService {
	private final RestTemplate restTemplate;
	public MyService(RestTemplateBuilder restTemplateBuilder) {
		this.restTemplate = restTemplateBuilder.build();
	}
	public Details someRestCall(String name) {
		return this.restTemplate.getForObject('/{name}/details', Details.class, name);
	}
}
/*
package org.springframework.boot.docs.io.caching;
@Component
public class MyMathService {
	@Cacheable('piDecimals')
	public int computePiDecimal(int precision) {
		/**/ return 0;
	}
}
/*
package org.springframework.boot.docs.io.caching.provider.couchbase;
@Configuration(proxyBeanMethods = false)
public class MyCouchbaseCacheManagerConfiguration {
	@Bean
	public CouchbaseCacheManagerBuilderCustomizer myCouchbaseCacheManagerBuilderCustomizer() {
		// @formatter:off
		return (builder) -> builder
				.withCacheConfiguration('cache1', CouchbaseCacheConfiguration
						.defaultCacheConfig().entryExpiry(Duration.ofSeconds(10)))
				.withCacheConfiguration('cache2', CouchbaseCacheConfiguration
						.defaultCacheConfig().entryExpiry(Duration.ofMinutes(1)));
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.io.caching.provider.cache2k;
@Configuration(proxyBeanMethods = false)
public class MyCache2kDefaultsConfiguration {
	@Bean
	public Cache2kBuilderCustomizer myCache2kDefaultsCustomizer() {
		// @formatter:off
		return (builder) -> builder.entryCapacity(200)
				.expireAfterWrite(5, TimeUnit.MINUTES);
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.io.caching.provider;
@Configuration(proxyBeanMethods = false)
public class MyCacheManagerConfiguration {
	@Bean
	public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() {
		return (cacheManager) -> cacheManager.setAllowNullValues(false);
	}
}
/*
package org.springframework.boot.docs.io.caching.provider.redis;
@Configuration(proxyBeanMethods = false)
public class MyRedisCacheManagerConfiguration {
	@Bean
	public RedisCacheManagerBuilderCustomizer myRedisCacheManagerBuilderCustomizer() {
		// @formatter:off
		return (builder) -> builder
				.withCacheConfiguration('cache1', RedisCacheConfiguration
						.defaultCacheConfig().entryTtl(Duration.ofSeconds(10)))
				.withCacheConfiguration('cache2', RedisCacheConfiguration
						.defaultCacheConfig().entryTtl(Duration.ofMinutes(1)));
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.using.springbeansanddependencyinjection.multipleconstructors;
public interface AccountService {
}
/*
package org.springframework.boot.docs.using.springbeansanddependencyinjection.multipleconstructors;
public interface RiskAssessor {
}
/*
package org.springframework.boot.docs.using.springbeansanddependencyinjection.multipleconstructors;
@Service
public class MyAccountService implements AccountService {
	@SuppressWarnings('unused')
	private final RiskAssessor riskAssessor;
	@SuppressWarnings('unused')
	private final PrintStream out;
	@Autowired
	public MyAccountService(RiskAssessor riskAssessor) {
		this.riskAssessor = riskAssessor;
		this.out = System.out;
	}
	public MyAccountService(RiskAssessor riskAssessor, PrintStream out) {
		this.riskAssessor = riskAssessor;
		this.out = out;
	}
	// ...
}
/*
package org.springframework.boot.docs.using.springbeansanddependencyinjection.singleconstructor;
public interface AccountService {
}
/*
package org.springframework.boot.docs.using.springbeansanddependencyinjection.singleconstructor;
public interface RiskAssessor {
}
/*
package org.springframework.boot.docs.using.springbeansanddependencyinjection.singleconstructor;
@Service
public class MyAccountService implements AccountService {
	@SuppressWarnings('unused')
	private final RiskAssessor riskAssessor;
	public MyAccountService(RiskAssessor riskAssessor) {
		this.riskAssessor = riskAssessor;
	}
	// ...
}
/*
package org.springframework.boot.docs.using.usingthespringbootapplicationannotation.individualannotations;
public class SomeConfiguration {
}
/*
package org.springframework.boot.docs.using.usingthespringbootapplicationannotation.individualannotations;
@SpringBootConfiguration(proxyBeanMethods = false)
@EnableAutoConfiguration
@Import({ SomeConfiguration.class, AnotherConfiguration.class })
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.using.usingthespringbootapplicationannotation.individualannotations;
public class AnotherConfiguration {
}
/*
package org.springframework.boot.docs.using.usingthespringbootapplicationannotation.springapplication;
// Same as @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.using.structuringyourcode.locatingthemainclass;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.using.devtools.restart.disable;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		System.setProperty('spring.devtools.restart.enabled', 'false');
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.using.autoconfiguration.disablingspecific;
@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })
public class MyApplication {
}
/*
package org.springframework.boot.docs.messaging.jms.receiving;
@Component
public class MyBean {
	@JmsListener(destination = 'someQueue')
	public void processMessage(String content) {
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.jms.receiving.custom;
@Component
public class MyBean {
	@JmsListener(destination = 'someQueue', containerFactory = 'myFactory')
	public void processMessage(String content) {
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.jms.receiving.custom;
@Configuration(proxyBeanMethods = false)
public class MyJmsConfiguration {
	@Bean
	public DefaultJmsListenerContainerFactory myFactory(DefaultJmsListenerContainerFactoryConfigurer configurer,
			ConnectionFactory connectionFactory) {
		DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
		configurer.configure(factory, ConnectionFactoryUnwrapper.unwrap(connectionFactory));
		factory.setMessageConverter(new MyMessageConverter());
		return factory;
	}
}
/*
package org.springframework.boot.docs.messaging.jms.receiving.custom;
class MyMessageConverter implements MessageConverter {
	@Override
	public Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {
		return null;
	}
	@Override
	public Object fromMessage(Message message) throws JMSException, MessageConversionException {
		return null;
	}
}
/*
package org.springframework.boot.docs.messaging.jms.sending;
@Component
public class MyBean {
	private final JmsTemplate jmsTemplate;
	public MyBean(JmsTemplate jmsTemplate) {
		this.jmsTemplate = jmsTemplate;
	}
	// @fold:on // ...
	public void someMethod() {
		this.jmsTemplate.convertAndSend('hello');
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.messaging.pulsar.readingreactive;
@Component
public class MyBean {
	private final ReactivePulsarReaderFactory<String> pulsarReaderFactory;
	public MyBean(ReactivePulsarReaderFactory<String> pulsarReaderFactory) {
		this.pulsarReaderFactory = pulsarReaderFactory;
	}
	@SuppressWarnings('unused')
	public void someMethod() {
		ReactiveMessageReaderBuilderCustomizer<String> readerBuilderCustomizer = (readerBuilder) -> readerBuilder
			.topic('someTopic')
			.startAtSpec(StartAtSpec.ofInstant(Instant.now().minusSeconds(5)));
		Mono<Message<String>> message = this.pulsarReaderFactory
			.createReader(Schema.STRING, List.of(readerBuilderCustomizer))
			.readOne();
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.pulsar.reading;
@Component
public class MyBean {
	@PulsarReader(topics = 'someTopic', startMessageId = 'earliest')
	public void processMessage(String content) {
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.pulsar.sendingreactive;
@Component
public class MyBean {
	private final ReactivePulsarTemplate<String> pulsarTemplate;
	public MyBean(ReactivePulsarTemplate<String> pulsarTemplate) {
		this.pulsarTemplate = pulsarTemplate;
	}
	public void someMethod() {
		this.pulsarTemplate.send('someTopic', 'Hello').subscribe();
	}
}
/*
package org.springframework.boot.docs.messaging.pulsar.receiving;
@Component
public class MyBean {
	@PulsarListener(topics = 'someTopic')
	public void processMessage(String content) {
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.pulsar.sending;
@Component
public class MyBean {
	private final PulsarTemplate<String> pulsarTemplate;
	public MyBean(PulsarTemplate<String> pulsarTemplate) {
		this.pulsarTemplate = pulsarTemplate;
	}
	public void someMethod() {
		this.pulsarTemplate.send('someTopic', 'Hello');
	}
}
/*
package org.springframework.boot.docs.messaging.pulsar.receivingreactive;
@Component
public class MyBean {
	@ReactivePulsarListener(topics = 'someTopic')
	public Mono<Void> processMessage(String content) {
		// ...
		return Mono.empty();
	}
}
/*
package org.springframework.boot.docs.messaging.amqp.receiving;
@Component
public class MyBean {
	@RabbitListener(queues = 'someQueue')
	public void processMessage(String content) {
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.amqp.receiving.custom;
@Component
public class MyBean {
	@RabbitListener(queues = 'someQueue', containerFactory = 'myFactory')
	public void processMessage(String content) {
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.amqp.receiving.custom;
@Configuration(proxyBeanMethods = false)
public class MyRabbitConfiguration {
	@Bean
	public SimpleRabbitListenerContainerFactory myFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer) {
		SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
		ConnectionFactory connectionFactory = getCustomConnectionFactory();
		configurer.configure(factory, connectionFactory);
		factory.setMessageConverter(new MyMessageConverter());
		return factory;
	}
	private ConnectionFactory getCustomConnectionFactory() {
		return /**/ null;
	}
}
/*
package org.springframework.boot.docs.messaging.amqp.receiving.custom;
class MyMessageConverter implements MessageConverter {
	@Override
	public Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException {
		return null;
	}
	@Override
	public Object fromMessage(Message message) throws MessageConversionException {
		return null;
	}
}
/*
package org.springframework.boot.docs.messaging.amqp.sending;
@Component
public class MyBean {
	private final AmqpAdmin amqpAdmin;
	private final AmqpTemplate amqpTemplate;
	public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
		this.amqpAdmin = amqpAdmin;
		this.amqpTemplate = amqpTemplate;
	}
	// @fold:on // ...
	public void someMethod() {
		this.amqpAdmin.getQueueInfo('someQueue');
	}
	public void someOtherMethod() {
		this.amqpTemplate.convertAndSend('hello');
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.messaging.kafka.embedded.property;
@SpringBootTest
class MyTest {
	// tag::code[]
	static {
		System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, 'spring.kafka.bootstrap-servers');
	}
	// end::code[]
}
/*
package org.springframework.boot.docs.messaging.kafka.embedded.annotation;
@SpringBootTest
@EmbeddedKafka(topics = 'someTopic', bootstrapServersProperty = 'spring.kafka.bootstrap-servers')
class MyTest {
	// ...
}
/*
package org.springframework.boot.docs.messaging.kafka.receiving;
@Component
public class MyBean {
	@KafkaListener(topics = 'someTopic')
	public void processMessage(String content) {
		// ...
	}
}
/*
package org.springframework.boot.docs.messaging.kafka.sending;
@Component
public class MyBean {
	private final KafkaTemplate<String, String> kafkaTemplate;
	public MyBean(KafkaTemplate<String, String> kafkaTemplate) {
		this.kafkaTemplate = kafkaTemplate;
	}
	// @fold:on // ...
	public void someMethod() {
		this.kafkaTemplate.send('someTopic', 'Hello');
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.messaging.kafka.streams;
@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
public class MyKafkaStreamsConfiguration {
	@Bean
	public KStream<Integer, String> kStream(StreamsBuilder streamsBuilder) {
		KStream<Integer, String> stream = streamsBuilder.stream('ks1In');
		stream.map(this::uppercaseValue).to('ks1Out', Produced.with(Serdes.Integer(), new JsonSerde<>()));
		return stream;
	}
	private KeyValue<Integer, String> uppercaseValue(Integer key, String value) {
		return new KeyValue<>(key, value.toUpperCase(Locale.getDefault()));
	}
}
/*
package org.springframework.boot.docs.messaging.rsocket.requester;
@Service
public class MyService {
	private final RSocketRequester rsocketRequester;
	public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
		this.rsocketRequester = rsocketRequesterBuilder.tcp('example.org', 9898);
	}
	public Mono<User> someRSocketCall(String name) {
		return this.rsocketRequester.route('user').data(name).retrieveMono(User.class);
	}
}
/*
package org.springframework.boot.docs.messaging.rsocket.requester;
class User {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.jmx;
@SpringBootTest(properties = 'spring.jmx.enabled=true')
@DirtiesContext
class MyJmxTests {
	@Autowired
	private MBeanServer mBeanServer;
	@Test
	void exampleTest() {
		assertThat(this.mBeanServer.getDomains()).contains('java.lang');
		// ...
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.jmx;
@SpringBootConfiguration
@ImportAutoConfiguration(JmxAutoConfiguration.class)
public class SampleApp {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataneo4j.propagation;
interface SomeRepository {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataneo4j.propagation;
@DataNeo4jTest
class MyDataNeo4jTests {
	@Autowired
	@SuppressWarnings('unused')
	private SomeRepository repository;
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataneo4j.nopropagation;
@DataNeo4jTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class MyDataNeo4jTests {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.withrunningserver;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyRandomPortTestRestTemplateTests {
	@Test
	void exampleTest(@Autowired TestRestTemplate restTemplate) {
		String body = restTemplate.getForObject('/', String.class);
		assertThat(body).isEqualTo('Hello World');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.withrunningserver;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyRandomPortWebTestClientTests {
	@Test
	void exampleTest(@Autowired WebTestClient webClient) {
		// @formatter:off
		webClient
			.get().uri('/')
			.exchange()
			.expectStatus().isOk()
			.expectBody(String.class).isEqualTo('Hello World');
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatamongodb;
@DataMongoTest
class MyDataMongoDbTests {
	@Autowired
	@SuppressWarnings('unused')
	private MongoTemplate mongoTemplate;
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.detectingwebapptype;
@SpringBootTest(properties = 'spring.main.web-application-type=reactive')
class MyWebFluxTests {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataredis;
@DataRedisTest
class MyDataRedisTests {
	@Autowired
	@SuppressWarnings('unused')
	private SomeRepository repository;
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataredis;
interface SomeRepository {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springwebfluxtests;
class UserVehicleController {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springwebfluxtests;
class VehicleDetails {
	VehicleDetails(String make, String model) {
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springwebfluxtests;
@WebFluxTest(UserVehicleController.class)
class MyControllerTests {
	@Autowired
	private WebTestClient webClient;
	@MockitoBean
	private UserVehicleService userVehicleService;
	@Test
	void testExample() {
		// @formatter:off
		given(this.userVehicleService.getVehicleDetails('sboot'))
			.willReturn(new VehicleDetails('Honda', 'Civic'));
		this.webClient.get().uri('/sboot/vehicle').accept(MediaType.TEXT_PLAIN).exchange()
			.expectStatus().isOk()
			.expectBody(String.class).isEqualTo('Honda Civic');
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springwebfluxtests;
class UserVehicleService {
	VehicleDetails getVehicleDetails(String name) {
		return null;
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springmvctests;
class UserVehicleController {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springmvctests;
@WebMvcTest(UserVehicleController.class)
class MyHtmlUnitTests {
	@Autowired
	private WebClient webClient;
	@MockitoBean
	private UserVehicleService userVehicleService;
	@Test
	void testExample() throws Exception {
		given(this.userVehicleService.getVehicleDetails('sboot')).willReturn(new VehicleDetails('Honda', 'Civic'));
		HtmlPage page = this.webClient.getPage('/sboot/vehicle.html');
		assertThat(page.getBody().getTextContent()).isEqualTo('Honda Civic');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springmvctests;
class VehicleDetails {
	VehicleDetails(String make, String model) {
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springmvctests;
@WebMvcTest(UserVehicleController.class)
class MyControllerTests {
	@Autowired
	private MockMvcTester mvc;
	@MockitoBean
	private UserVehicleService userVehicleService;
	@Test
	void testExample() {
		// @formatter:off
		given(this.userVehicleService.getVehicleDetails('sboot'))
			.willReturn(new VehicleDetails('Honda', 'Civic'));
		assertThat(this.mvc.get().uri('/sboot/vehicle').accept(MediaType.TEXT_PLAIN))
			.hasStatusOk()
			.hasBodyTextEqualTo('Honda Civic');
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springmvctests;
class UserVehicleService {
	VehicleDetails getVehicleDetails(String name) {
		return null;
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.withmockenvironment;
@SpringBootTest
@AutoConfigureWebTestClient
class MyMockWebTestClientTests {
	@Test
	void exampleTest(@Autowired WebTestClient webClient) {
		// @formatter:off
		webClient
			.get().uri('/')
			.exchange()
			.expectStatus().isOk()
			.expectBody(String.class).isEqualTo('Hello World');
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.withmockenvironment;
@SpringBootTest
@AutoConfigureMockMvc
class MyMockMvcTests {
	@Test
	void testWithMockMvc(@Autowired MockMvc mvc) throws Exception {
		mvc.perform(get('/')).andExpect(status().isOk()).andExpect(content().string('Hello World'));
	}
	// If AssertJ is on the classpath, you can use MockMvcTester
	@Test
	void testWithMockMvcTester(@Autowired MockMvcTester mvc) {
		assertThat(mvc.get().uri('/')).hasStatusOk().hasBodyTextEqualTo('Hello World');
	}
	// If Spring WebFlux is on the classpath, you can drive MVC tests with a WebTestClient
	@Test
	void testWithWebTestClient(@Autowired WebTestClient webClient) {
		// @formatter:off
		webClient
				.get().uri('/')
				.exchange()
				.expectStatus().isOk()
				.expectBody(String.class).isEqualTo('Hello World');
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataldap.server;
@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
class MyDataLdapTests {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataldap.inmemory;
@DataLdapTest
class MyDataLdapTests {
	@Autowired
	@SuppressWarnings('unused')
	private LdapTemplate ldapTemplate;
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataelasticsearch;
public interface SomeRepository {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdataelasticsearch;
@DataElasticsearchTest
class MyDataElasticsearchTests {
	@Autowired
	@SuppressWarnings('unused')
	private SomeRepository repository;
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.usingmain.custom;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication application = new SpringApplication(MyApplication.class);
		application.setBannerMode(Banner.Mode.OFF);
		application.setAdditionalProfiles('myprofile');
		application.run(args);
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.usingmain.typical;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.usingmain.always;
@SpringBootTest(useMainMethod = UseMainMethod.ALWAYS)
class MyApplicationTests {
	@Test
	void exampleTest() {
		// ...
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.userconfigurationandslicing;
@Configuration(proxyBeanMethods = false)
@EnableMongoAuditing
public class MyMongoConfiguration {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.userconfigurationandslicing;
@Component
public class MyWebMvcConfigurer implements WebMvcConfigurer {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.userconfigurationandslicing;
@Configuration(proxyBeanMethods = false)
public class MyWebConfiguration {
	@Bean
	public WebMvcConfigurer testConfigurer() {
		return new WebMvcConfigurer() {
			// ...
		};
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.userconfigurationandslicing.scan;
@SpringBootApplication
@ComponentScan({ 'com.example.app', 'com.example.another' })
public class MyApplication {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.userconfigurationandslicing;
@SpringBootApplication
@EnableMongoAuditing
public class MyApplication {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredjooq;
@JooqTest
class MyJooqTests {
	@Autowired
	@SuppressWarnings('unused')
	private DSLContext dslContext;
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatacouchbase;
interface SomeRepository {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatacouchbase;
@DataCouchbaseTest
class MyDataCouchbaseTests {
	@Autowired
	@SuppressWarnings('unused')
	private SomeRepository repository;
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withmockmvc.assertj;
@WebMvcTest(UserController.class)
@AutoConfigureRestDocs
class MyUserDocumentationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void listUsers() {
		assertThat(this.mvc.get().uri('/users').accept(MediaType.TEXT_PLAIN)).hasStatusOk()
			.apply(document('list-users'));
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withmockmvc.assertj;
class UserController {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withmockmvc;
@TestConfiguration(proxyBeanMethods = false)
public class MyResultHandlerConfiguration {
	@Bean
	public RestDocumentationResultHandler restDocumentation() {
		return MockMvcRestDocumentation.document('{method-name}');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withmockmvc.hamcrest;
@WebMvcTest(UserController.class)
@AutoConfigureRestDocs
class MyUserDocumentationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void listUsers() {
		assertThat(this.mvc.get().uri('/users').accept(MediaType.TEXT_PLAIN)).hasStatusOk()
			.apply(document('list-users'));
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withmockmvc.hamcrest;
class UserController {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withmockmvc;
@TestConfiguration(proxyBeanMethods = false)
public class MyRestDocsConfiguration implements RestDocsMockMvcConfigurationCustomizer {
	@Override
	public void customize(MockMvcRestDocumentationConfigurer configurer) {
		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withwebtestclient;
@WebFluxTest
@AutoConfigureRestDocs
class MyUsersDocumentationTests {
	@Autowired
	private WebTestClient webTestClient;
	@Test
	void listUsers() {
		// @formatter:off
		this.webTestClient
			.get().uri('/')
		.exchange()
		.expectStatus()
			.isOk()
		.expectBody()
			.consumeWith(document('list-users'));
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withwebtestclient;
@TestConfiguration(proxyBeanMethods = false)
public class MyWebTestClientBuilderCustomizerConfiguration {
	@Bean
	public WebTestClientBuilderCustomizer restDocumentation() {
		return (builder) -> builder.entityExchangeResultConsumer(document('{method-name}'));
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withwebtestclient;
@TestConfiguration(proxyBeanMethods = false)
public class MyRestDocsConfiguration implements RestDocsWebTestClientConfigurationCustomizer {
	@Override
	public void customize(WebTestClientRestDocumentationConfigurer configurer) {
		configurer.snippets().withEncoding('UTF-8');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withrestassured;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureRestDocs
class MyUserDocumentationTests {
	@Test
	void listUsers(@Autowired RequestSpecification documentationSpec, @LocalServerPort int port) {
		// @formatter:off
		given(documentationSpec)
			.filter(document('list-users'))
		.when()
			.port(port)
			.get('/')
		.then().assertThat()
			.statusCode(is(200));
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringrestdocs.withrestassured;
@TestConfiguration(proxyBeanMethods = false)
public class MyRestDocsConfiguration implements RestDocsRestAssuredConfigurationCustomizer {
	@Override
	public void customize(RestAssuredRestDocumentationConfigurer configurer) {
		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.jsontests;
@JsonTest
class MyJsonAssertJTests {
	@Autowired
	private JacksonTester<SomeObject> json;
	// tag::code[]
	@Test
	void someTest() throws Exception {
		SomeObject value = new SomeObject(0.152f);
		assertThat(this.json.write(value)).extractingJsonPathNumberValue('@.test.numberValue')
			.satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));
	}
	// end::code[]
}
/*
package org.springframework.boot.docs.testing.springbootapplications.jsontests;
@JsonTest
class MyJsonTests {
	@Autowired
	private JacksonTester<VehicleDetails> json;
	@Test
	void serialize() throws Exception {
		VehicleDetails details = new VehicleDetails('Honda', 'Civic');
		// Assert against a `.json` file in the same package as the test
		assertThat(this.json.write(details)).isEqualToJson('expected.json');
		// Or use JSON path based assertions
		assertThat(this.json.write(details)).hasJsonPathStringValue('@.make');
		assertThat(this.json.write(details)).extractingJsonPathStringValue('@.make').isEqualTo('Honda');
	}
	@Test
	void deserialize() throws Exception {
		String content = '{\'make\':\'Ford\',\'model\':\'Focus\'}';
		assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails('Ford', 'Focus'));
		assertThat(this.json.parseObject(content).getMake()).isEqualTo('Ford');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.jsontests;
class VehicleDetails {
	private final String make;
	private final String model;
	VehicleDetails(String make, String model) {
		this.make = make;
		this.model = model;
	}
	String getMake() {
		return this.make;
	}
	String getModel() {
		return this.model;
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.jsontests;
class SomeObject {
	SomeObject(float value) {
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatacassandra;
interface SomeRepository {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatacassandra;
@DataCassandraTest
class MyDataCassandraTests {
	@Autowired
	@SuppressWarnings('unused')
	private SomeRepository repository;
}
/*
package org.springframework.boot.docs.testing.springbootapplications.excludingconfiguration;
@SpringBootTest
@Import(MyTestsConfiguration.class)
class MyTests {
	@Test
	void exampleTest() {
		// ...
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.excludingconfiguration;
class MyTestsConfiguration {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatajpa;
@DataJpaTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class MyNonTransactionalTests {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatajpa.withdb;
@DataJpaTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
class MyRepositoryTests {
	// ...
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatajpa.withoutdb;
@DataJpaTest
class MyRepositoryTests {
	@Autowired
	private TestEntityManager entityManager;
	@Autowired
	private UserRepository repository;
	@Test
	void testExample() {
		this.entityManager.persist(new User('sboot', '1234'));
		User user = this.repository.findByUsername('sboot');
		assertThat(user.getUsername()).isEqualTo('sboot');
		assertThat(user.getEmployeeNumber()).isEqualTo('1234');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatajpa.withoutdb;
class User {
	User(String username, String employeeNumber) {
	}
	String getEmployeeNumber() {
		return null;
	}
	String getUsername() {
		return null;
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredspringdatajpa.withoutdb;
interface UserRepository {
	User findByUsername(String username);
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredjdbc;
@JdbcTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class MyTransactionalTests {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.usingapplicationarguments;
@SpringBootTest(args = '--app.test=one')
class MyApplicationArgumentTests {
	@Test
	void applicationArgumentsPopulated(@Autowired ApplicationArguments args) {
		assertThat(args.getOptionNames()).containsOnly('app.test');
		assertThat(args.getOptionValues('app.test')).containsOnly('one');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredrestclient;
@RestClientTest(RemoteVehicleDetailsService.class)
class MyRestClientServiceTests {
	@Autowired
	private RemoteVehicleDetailsService service;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() {
		this.server.expect(requestTo('https://example.com/greet/details'))
			.andRespond(withSuccess('hello', MediaType.TEXT_PLAIN));
		String greeting = this.service.callRestService();
		assertThat(greeting).isEqualTo('hello');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredrestclient;
class RemoteVehicleDetailsService {
	String callRestService() {
		return 'hello';
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredrestclient;
@RestClientTest(org.springframework.boot.docs.testing.springbootapplications.autoconfiguredrestclient.RemoteVehicleDetailsService.class)
class MyRestTemplateServiceTests {
	@Autowired
	private RemoteVehicleDetailsService service;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() {
		this.server.expect(requestTo('/greet/details')).andRespond(withSuccess('hello', MediaType.TEXT_PLAIN));
		String greeting = this.service.callRestService();
		assertThat(greeting).isEqualTo('hello');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredwebservices.server;
@WebServiceServerTest(ExampleEndpoint.class)
class MyWebServiceServerTests {
	@Autowired
	private MockWebServiceClient client;
	@Test
	void mockServerCall() {
		// @formatter:off
		this.client
			.sendRequest(RequestCreators.withPayload(new StringSource('<ExampleRequest/>')))
			.andExpect(ResponseMatchers.payload(new StringSource('<ExampleResponse>42</ExampleResponse>')));
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredwebservices.server;
@Endpoint
public class ExampleEndpoint {
	@PayloadRoot(localPart = 'ExampleRequest')
	@ResponsePayload
	public Source handleRequest() {
		return new StringSource('<ExampleResponse>42</ExampleResponse>');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredwebservices.client;
@Service
public class SomeWebService {
	private final WebServiceTemplate webServiceTemplate;
	public SomeWebService(WebServiceTemplateBuilder builder) {
		this.webServiceTemplate = builder.build();
	}
	public Response test() {
		return (Response) this.webServiceTemplate.marshalSendAndReceive('https://example.com', new Request());
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredwebservices.client;
@XmlRootElement(name = 'request')
class Request {
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredwebservices.client;
@WebServiceClientTest(SomeWebService.class)
class MyWebServiceClientTests {
	@Autowired
	private MockWebServiceServer server;
	@Autowired
	private SomeWebService someWebService;
	@Test
	void mockServerCall() {
		// @formatter:off
		this.server
			.expect(payload(new StringSource('<request/>')))
			.andRespond(withPayload(new StringSource('<response><status>200</status></response>')));
		assertThat(this.someWebService.test())
			.extracting(Response::getStatus)
			.isEqualTo(200);
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.autoconfiguredwebservices.client;
@XmlRootElement(name = 'response')
@XmlAccessorType(XmlAccessType.FIELD)
class Response {
	private int status;
	int getStatus() {
		return this.status;
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springgraphqltests;
@GraphQlTest(GreetingController.class)
class GreetingControllerTests {
	@Autowired
	private GraphQlTester graphQlTester;
	@Test
	void shouldGreetWithSpecificName() {
		this.graphQlTester.document('{ greeting(name: \'Alice\') } ')
			.execute()
			.path('greeting')
			.entity(String.class)
			.isEqualTo('Hello, Alice!');
	}
	@Test
	void shouldGreetWithDefaultName() {
		this.graphQlTester.document('{ greeting } ')
			.execute()
			.path('greeting')
			.entity(String.class)
			.isEqualTo('Hello, Spring!');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.springgraphqltests;
@AutoConfigureHttpGraphQlTester
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
class GraphQlIntegrationTests {
	@Test
	void shouldGreetWithSpecificName(@Autowired HttpGraphQlTester graphQlTester) {
		HttpGraphQlTester authenticatedTester = graphQlTester.mutate()
			.webTestClient((client) -> client.defaultHeaders((headers) -> headers.setBasicAuth('admin', 'ilovespring')))
			.build();
		authenticatedTester.document('{ greeting(name: \'Alice\') } ')
			.execute()
			.path('greeting')
			.entity(String.class)
			.isEqualTo('Hello, Alice!');
	}
}
/*
package org.springframework.boot.docs.testing.springbootapplications.additionalautoconfigurationandslicing;
@JdbcTest
@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
class MyJdbcTests {
}
/*
package org.springframework.boot.docs.testing.testcontainers.serviceconnections;
@Testcontainers
@SpringBootTest
class MyIntegrationTests {
	@Container
	@ServiceConnection
	static Neo4jContainer<?> neo4j = new Neo4jContainer<>('neo4j:5');
	@Test
	void myTest() {
		// ...
	}
}
/*
package org.springframework.boot.docs.testing.testcontainers.serviceconnections;
@TestConfiguration(proxyBeanMethods = false)
public class MyRedisConfiguration {
	@Bean
	@ServiceConnection(name = 'redis')
	public GenericContainer<?> redisContainer() {
		return new GenericContainer<>('redis:7');
	}
}
/*
package org.springframework.boot.docs.testing.testcontainers.vanilla;
@Testcontainers
@SpringBootTest
class MyIntegrationTests {
	@Container
	static Neo4jContainer<?> neo4j = new Neo4jContainer<>('neo4j:5');
	@Test
	void myTest() {
		// ...
	}
}
/*
package org.springframework.boot.docs.testing.testcontainers.dynamicproperties;
@Testcontainers
@SpringBootTest
class MyIntegrationTests {
	@Container
	static Neo4jContainer<?> neo4j = new Neo4jContainer<>('neo4j:5');
	@Test
	void myTest() {
		// ...
	}
	@DynamicPropertySource
	static void neo4jProperties(DynamicPropertyRegistry registry) {
		registry.add('spring.neo4j.uri', neo4j::getBoltUrl);
	}
}
/*
package org.springframework.boot.docs.testing.utilities.testpropertyvalues;
class MyEnvironmentTests {
	@Test
	void testPropertySources() {
		MockEnvironment environment = new MockEnvironment();
		TestPropertyValues.of('org=Spring', 'name=Boot').applyTo(environment);
		assertThat(environment.getProperty('name')).isEqualTo('Boot');
	}
}
/*
package org.springframework.boot.docs.testing.utilities.outputcapture;
@ExtendWith(OutputCaptureExtension.class)
class MyOutputCaptureTests {
	@Test
	void testName(CapturedOutput output) {
		System.out.println('Hello World!');
		assertThat(output).contains('World');
	}
}
/*
package org.springframework.boot.docs.testing.utilities.testresttemplate;
@SpringBootConfiguration(proxyBeanMethods = false)
@ImportAutoConfiguration({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
		JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class })
public class MySpringBootTestsConfiguration {
	@RestController
	private static final class ExampleController {
		@RequestMapping('/example')
		ResponseEntity<String> example() {
			return ResponseEntity.ok().location(URI.create('https://other.example.com/example')).body('test');
		}
	}
}
/*
package org.springframework.boot.docs.testing.utilities.testresttemplate;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MySpringBootTests {
	@Autowired
	private TestRestTemplate template;
	@Test
	void testRequest() {
		HttpHeaders headers = this.template.getForEntity('/example', String.class).getHeaders();
		assertThat(headers.getLocation()).hasHost('other.example.com');
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class RestTemplateBuilderConfiguration {
		@Bean
		RestTemplateBuilder restTemplateBuilder() {
			return new RestTemplateBuilder().connectTimeout(Duration.ofSeconds(1)).readTimeout(Duration.ofSeconds(1));
		}
	}
}
/*
package org.springframework.boot.docs.testing.utilities.testresttemplate;
class MyTests {
	private final TestRestTemplate template = new TestRestTemplate();
	@Test
	void testRequest() {
		ResponseEntity<String> headers = this.template.getForEntity('https://myhost.example.com/example', String.class);
		assertThat(headers.getHeaders().getLocation()).hasHost('other.example.com');
	}
}
/*
package org.springframework.boot.docs.testing.utilities.configdataapplicationcontextinitializer;
@ContextConfiguration(classes = Config.class, initializers = ConfigDataApplicationContextInitializer.class)
class MyConfigFileTests {
	// ...
}
/*
package org.springframework.boot.docs.testing.utilities.configdataapplicationcontextinitializer;
class Config {
}
/*
package org.springframework.boot.docs.web.security.springwebflux;
@Configuration(proxyBeanMethods = false)
public class MyWebFluxSecurityConfiguration {
	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http.authorizeExchange((exchange) -> {
			exchange.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();
			exchange.pathMatchers('/foo', '/bar').authenticated();
		});
		http.formLogin(withDefaults());
		return http.build();
	}
}
/*
package org.springframework.boot.docs.web.security.oauth2.client;
@Configuration(proxyBeanMethods = false)
@EnableWebSecurity
public class MyOAuthClientConfiguration {
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		// @formatter:off
		http
			.authorizeHttpRequests((requests) -> requests
				.anyRequest().authenticated()
			)
			.oauth2Login((login) -> login
				.redirectionEndpoint((endpoint) -> endpoint
					.baseUri('/login/oauth2/callback/*')
				)
			);
		// @formatter:on
		return http.build();
	}
}
/*
package org.springframework.boot.docs.web.security.saml2.relyingparty;
@Configuration(proxyBeanMethods = false)
public class MySamlRelyingPartyConfiguration {
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
		http.saml2Login(withDefaults());
		http.saml2Logout((saml2) -> saml2.logoutRequest((request) -> request.logoutUrl('/SLOService.saml2'))
			.logoutResponse((response) -> response.logoutUrl('/SLOService.saml2')));
		return http.build();
	}
}
/*
package org.springframework.boot.docs.web.servlet.jersey;
@Component
@Path('/hello')
public class MyEndpoint {
	@GET
	public String message() {
		return 'Hello';
	}
}
/*
package org.springframework.boot.docs.web.servlet.jersey;
@Component
public class MyJerseyConfig extends ResourceConfig {
	public MyJerseyConfig() {
		register(MyEndpoint.class);
	}
}
/*
package org.springframework.boot.docs.web.servlet.embeddedcontainer.applicationcontext;
public class MyDemoBean implements ApplicationListener<ApplicationStartedEvent> {
	@SuppressWarnings('unused')
	private ServletContext servletContext;
	@Override
	public void onApplicationEvent(ApplicationStartedEvent event) {
		ApplicationContext applicationContext = event.getApplicationContext();
		this.servletContext = ((WebApplicationContext) applicationContext).getServletContext();
	}
}
/*
package org.springframework.boot.docs.web.servlet.embeddedcontainer.customizing.samesite;
@Configuration(proxyBeanMethods = false)
public class MySameSiteConfiguration {
	@Bean
	public CookieSameSiteSupplier applicationCookieSameSiteSupplier() {
		return CookieSameSiteSupplier.ofLax().whenHasNameMatching('myapp.*');
	}
}
/*
package org.springframework.boot.docs.web.servlet.embeddedcontainer.customizing.programmatic;
@Component
public class MyTomcatWebServerFactoryCustomizer implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {
	@Override
	public void customize(TomcatServletWebServerFactory server) {
		server.addConnectorCustomizers((connector) -> connector.setAsyncTimeout(Duration.ofSeconds(20).toMillis()));
	}
}
/*
package org.springframework.boot.docs.web.servlet.embeddedcontainer.customizing.programmatic;
@Component
public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {
	@Override
	public void customize(ConfigurableServletWebServerFactory server) {
		server.setPort(9000);
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc;
interface CustomerRepository extends CrudRepository<Customer, Long> {
	List<Customer> findByUser(User user);
}
/*
package org.springframework.boot.docs.web.servlet.springmvc;
class Customer {
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.messageconverters;
class AnotherHttpMessageConverter extends AdditionalHttpMessageConverter {
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.messageconverters;
@Configuration(proxyBeanMethods = false)
public class MyHttpMessageConvertersConfiguration {
	@Bean
	public HttpMessageConverters customConverters() {
		HttpMessageConverter<?> additional = new AdditionalHttpMessageConverter();
		HttpMessageConverter<?> another = new AnotherHttpMessageConverter();
		return new HttpMessageConverters(additional, another);
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.messageconverters;
class AdditionalHttpMessageConverter extends AbstractHttpMessageConverter<Object> {
	@Override
	protected boolean supports(Class<?> type) {
		return false;
	}
	@Override
	protected Object readInternal(Class<?> type, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException {
		return null;
	}
	@Override
	protected void writeInternal(Object instance, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException {
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc;
@Component
public class MyUserHandler {
	public ServerResponse getUser(ServerRequest request) {
		/**/ return ServerResponse.ok().build();
	}
	public ServerResponse getUserCustomers(ServerRequest request) {
		/**/ return ServerResponse.ok().build();
	}
	public ServerResponse deleteUser(ServerRequest request) {
		/**/ return ServerResponse.ok().build();
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.cors;
@Configuration(proxyBeanMethods = false)
public class MyCorsConfiguration {
	@Bean
	public WebMvcConfigurer corsConfigurer() {
		return new WebMvcConfigurer() {
			@Override
			public void addCorsMappings(CorsRegistry registry) {
				registry.addMapping('/api/**');
			}
		};
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc;
class User {
	List<Customer> getCustomers() {
		return null;
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling;
class CustomException extends RuntimeException {
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling;
class MyException extends RuntimeException {
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling.errorpageswithoutspringmvc;
@Configuration(proxyBeanMethods = false)
public class MyFilterConfiguration {
	@Bean
	public FilterRegistrationBean<MyFilter> myFilter() {
		FilterRegistrationBean<MyFilter> registration = new FilterRegistrationBean<>(new MyFilter());
		// ...
		registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
		return registration;
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling.errorpageswithoutspringmvc;
class MyFilter extends GenericFilterBean {
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling.errorpageswithoutspringmvc;
@Configuration(proxyBeanMethods = false)
public class MyErrorPagesConfiguration {
	@Bean
	public ErrorPageRegistrar errorPageRegistrar() {
		return this::registerErrorPages;
	}
	private void registerErrorPages(ErrorPageRegistry registry) {
		registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, '/400'));
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling;
@ControllerAdvice(basePackageClasses = SomeController.class)
public class MyControllerAdvice extends ResponseEntityExceptionHandler {
	@ResponseBody
	@ExceptionHandler(MyException.class)
	public ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
		HttpStatus status = getStatus(request);
		return new ResponseEntity<>(new MyErrorBody(status.value(), ex.getMessage()), status);
	}
	private HttpStatus getStatus(HttpServletRequest request) {
		Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
		HttpStatus status = HttpStatus.resolve(code);
		return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR;
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling;
class MyErrorBody {
	MyErrorBody(int value, String message) {
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling.errorpages;
public class MyErrorViewResolver implements ErrorViewResolver {
	@Override
	public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) {
		// Use the request or status to optionally return a ModelAndView
		if (status == HttpStatus.INSUFFICIENT_STORAGE) {
			// We could add custom model values here
			new ModelAndView('myview');
		}
		return null;
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc.errorhandling;
class SomeController {
}
/*
package org.springframework.boot.docs.web.servlet.springmvc;
@RestController
@RequestMapping('/users')
public class MyRestController {
	private final UserRepository userRepository;
	private final CustomerRepository customerRepository;
	public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
		this.userRepository = userRepository;
		this.customerRepository = customerRepository;
	}
	@GetMapping('/{userId}')
	public User getUser(@PathVariable Long userId) {
		return this.userRepository.findById(userId).get();
	}
	@GetMapping('/{userId}/customers')
	public List<Customer> getUserCustomers(@PathVariable Long userId) {
		return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();
	}
	@DeleteMapping('/{userId}')
	public void deleteUser(@PathVariable Long userId) {
		this.userRepository.deleteById(userId);
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc;
@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {
	private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);
	@Bean
	public RouterFunction<ServerResponse> routerFunction(MyUserHandler userHandler) {
		// @formatter:off
		return route()
				.GET('/{user}', ACCEPT_JSON, userHandler::getUser)
				.GET('/{user}/customers', ACCEPT_JSON, userHandler::getUserCustomers)
				.DELETE('/{user}', ACCEPT_JSON, userHandler::deleteUser)
				.build();
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.web.servlet.springmvc;
interface UserRepository extends CrudRepository<User, Long> {
}
/*
package org.springframework.boot.docs.web.reactive.reactiveserver.customizing.programmatic;
@Component
public class MyNettyWebServerFactoryCustomizer implements WebServerFactoryCustomizer<NettyReactiveWebServerFactory> {
	@Override
	public void customize(NettyReactiveWebServerFactory factory) {
		factory.addServerCustomizers((server) -> server.idleTimeout(Duration.ofSeconds(20)));
	}
}
/*
package org.springframework.boot.docs.web.reactive.reactiveserver.customizing.programmatic;
@Component
public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer<ConfigurableReactiveWebServerFactory> {
	@Override
	public void customize(ConfigurableReactiveWebServerFactory server) {
		server.setPort(9000);
	}
}
/*
package org.springframework.boot.docs.web.reactive.webflux;
interface CustomerRepository extends ReactiveCrudRepository<Customer, Long> {
	Flux<Customer> findByUser(User user);
}
/*
package org.springframework.boot.docs.web.reactive.webflux;
class Customer {
}
/*
package org.springframework.boot.docs.web.reactive.webflux;
@Component
public class MyUserHandler {
	public Mono<ServerResponse> getUser(ServerRequest request) {
		/**/ return ServerResponse.ok().build();
	}
	public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
		/**/ return ServerResponse.ok().build();
	}
	public Mono<ServerResponse> deleteUser(ServerRequest request) {
		/**/ return ServerResponse.ok().build();
	}
}
/*
package org.springframework.boot.docs.web.reactive.webflux;
class User {
	List<Customer> getCustomers() {
		return null;
	}
}
/*
package org.springframework.boot.docs.web.reactive.webflux.errorhandling;
@Component
public class MyErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {
	public MyErrorWebExceptionHandler(ErrorAttributes errorAttributes, WebProperties webProperties,
			ApplicationContext applicationContext, ServerCodecConfigurer serverCodecConfigurer) {
		super(errorAttributes, webProperties.getResources(), applicationContext);
		setMessageReaders(serverCodecConfigurer.getReaders());
		setMessageWriters(serverCodecConfigurer.getWriters());
	}
	@Override
	protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {
		return RouterFunctions.route(this::acceptsXml, this::handleErrorAsXml);
	}
	private boolean acceptsXml(ServerRequest request) {
		return request.headers().accept().contains(MediaType.APPLICATION_XML);
	}
	public Mono<ServerResponse> handleErrorAsXml(ServerRequest request) {
		BodyBuilder builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR);
		// ... additional builder calls
		return builder.build();
	}
}
/*
package org.springframework.boot.docs.web.reactive.webflux;
@RestController
@RequestMapping('/users')
public class MyRestController {
	private final UserRepository userRepository;
	private final CustomerRepository customerRepository;
	public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
		this.userRepository = userRepository;
		this.customerRepository = customerRepository;
	}
	@GetMapping('/{userId}')
	public Mono<User> getUser(@PathVariable Long userId) {
		return this.userRepository.findById(userId);
	}
	@GetMapping('/{userId}/customers')
	public Flux<Customer> getUserCustomers(@PathVariable Long userId) {
		return this.userRepository.findById(userId).flatMapMany(this.customerRepository::findByUser);
	}
	@DeleteMapping('/{userId}')
	public Mono<Void> deleteUser(@PathVariable Long userId) {
		return this.userRepository.deleteById(userId);
	}
}
/*
package org.springframework.boot.docs.web.reactive.webflux;
@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {
	private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);
	@Bean
	public RouterFunction<ServerResponse> monoRouterFunction(MyUserHandler userHandler) {
		// @formatter:off
		return route()
				.GET('/{user}', ACCEPT_JSON, userHandler::getUser)
				.GET('/{user}/customers', ACCEPT_JSON, userHandler::getUserCustomers)
				.DELETE('/{user}', ACCEPT_JSON, userHandler::deleteUser)
				.build();
		// @formatter:on
	}
}
/*
package org.springframework.boot.docs.web.reactive.webflux.httpcodecs;
@Configuration(proxyBeanMethods = false)
public class MyCodecsConfiguration {
	@Bean
	public CodecCustomizer myCodecCustomizer() {
		return (configurer) -> {
			configurer.registerDefaults(false);
			configurer.customCodecs().register(new ServerSentEventHttpMessageReader());
			// ...
		};
	}
}
/*
package org.springframework.boot.docs.web.reactive.webflux;
interface UserRepository extends ReactiveCrudRepository<User, Long> {
}
/*
package org.springframework.boot.docs.web.graphql.transports.rsocket;
// tag::builder[]
@Component
public class RSocketGraphQlClientExample {
	private final RSocketGraphQlClient graphQlClient;
	public RSocketGraphQlClientExample(RSocketGraphQlClient.Builder<?> builder) {
		this.graphQlClient = builder.tcp('example.spring.io', 8181).route('graphql').build();
	}
	// end::builder[]
	public void rsocketOverTcp() {
		// tag::request[]
		Mono<Book> book = this.graphQlClient.document('{ bookById(id: \'book-1\'){ id name pageCount author } }')
			.retrieve('bookById')
			.toEntity(Book.class);
		// end::request[]
		book.block(Duration.ofSeconds(5));
	}
	static class Book {
	}
}
/*
package org.springframework.boot.docs.web.graphql.runtimewiring;
@Controller
public class GreetingController {
	@QueryMapping
	public String greeting(@Argument String name) {
		return 'Hello, ' + name + '!';
	}
}
/*
package org.springframework.boot.docs.buildtoolplugins.otherbuildsystems.examplerepackageimplementation;
public class MyBuildTool {
	public void build() throws IOException {
		File sourceJarFile = /**/ null;
		Repackager repackager = new Repackager(sourceJarFile);
		repackager.setBackupSource(false);
		repackager.repackage(this::getLibraries);
	}
	private void getLibraries(LibraryCallback callback) throws IOException {
		// Build system specific implementation, callback for each dependency
		for (File nestedJar : getCompileScopeJars()) {
			callback.library(new Library(nestedJar, LibraryScope.COMPILE));
		}
		// ...
	}
	private List<File> getCompileScopeJars() {
		return /**/ null;
	}
}
/*
package org.springframework.boot.docs.gettingstarted.firstapplication.code;
@RestController
@SpringBootApplication
public class MyApplication {
	@RequestMapping('/')
	String home() {
		return 'Hello World!';
	}
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.actuator.loggers.opentelemetry;
@Component
class OpenTelemetryAppenderInitializer implements InitializingBean {
	private final OpenTelemetry openTelemetry;
	OpenTelemetryAppenderInitializer(OpenTelemetry openTelemetry) {
		this.openTelemetry = openTelemetry;
	}
	@Override
	public void afterPropertiesSet() {
		OpenTelemetryAppender.install(this.openTelemetry);
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.export.jmx;
@Configuration(proxyBeanMethods = false)
public class MyJmxConfiguration {
	@Bean
	public JmxMeterRegistry jmxMeterRegistry(JmxConfig config, Clock clock) {
		return new JmxMeterRegistry(config, clock, this::toHierarchicalName);
	}
	private String toHierarchicalName(Meter.Id id, NamingConvention convention) {
		return /**/ HierarchicalNameMapper.DEFAULT.toHierarchicalName(id, convention);
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.export.graphite;
@Configuration(proxyBeanMethods = false)
public class MyGraphiteConfiguration {
	@Bean
	public GraphiteMeterRegistry graphiteMeterRegistry(GraphiteConfig config, Clock clock) {
		return new GraphiteMeterRegistry(config, clock, this::toHierarchicalName);
	}
	private String toHierarchicalName(Meter.Id id, NamingConvention convention) {
		return /**/ HierarchicalNameMapper.DEFAULT.toHierarchicalName(id, convention);
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.registeringcustom;
class Dictionary {
	static Dictionary load() {
		return new Dictionary();
	}
	List<String> getWords() {
		return Collections.emptyList();
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.registeringcustom;
@Component
public class MyBean {
	private final Dictionary dictionary;
	public MyBean(MeterRegistry registry) {
		this.dictionary = Dictionary.load();
		registry.gauge('dictionary.size', Tags.empty(), this.dictionary.getWords().size());
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.registeringcustom;
class Queue {
	int size() {
		return 5;
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.registeringcustom;
public class MyMeterBinderConfiguration {
	@Bean
	public MeterBinder queueSize(Queue queue) {
		return (registry) -> Gauge.builder('queueSize', queue::size).register(registry);
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.gettingstarted.specifictype;
@Configuration(proxyBeanMethods = false)
public class MyMeterRegistryConfiguration {
	@Bean
	public MeterRegistryCustomizer<GraphiteMeterRegistry> graphiteMetricsNamingConvention() {
		return (registry) -> registry.config().namingConvention(this::name);
	}
	private String name(String name, Meter.Type type, String baseUnit) {
		return /**/ NamingConvention.snakeCase.name(name, type, baseUnit);
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.gettingstarted.commontags;
@Configuration(proxyBeanMethods = false)
public class MyMeterRegistryConfiguration {
	@Bean
	public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
		return (registry) -> registry.config().commonTags('region', 'us-east-1');
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.supported.mongodb.command;
class CustomCommandTagsProvider implements MongoCommandTagsProvider {
	@Override
	public Iterable<Tag> commandTags(CommandEvent commandEvent) {
		return java.util.Collections.emptyList();
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.supported.mongodb.command;
@Configuration(proxyBeanMethods = false)
public class MyCommandTagsProviderConfiguration {
	@Bean
	public MongoCommandTagsProvider customCommandTagsProvider() {
		return new CustomCommandTagsProvider();
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.supported.mongodb.connectionpool;
public class CustomConnectionPoolTagsProvider implements MongoConnectionPoolTagsProvider {
	@Override
	public Iterable<Tag> connectionPoolTags(ConnectionPoolCreatedEvent event) {
		return java.util.Collections.emptyList();
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.supported.mongodb.connectionpool;
@Configuration(proxyBeanMethods = false)
public class MyConnectionPoolTagsProviderConfiguration {
	@Bean
	public MongoConnectionPoolTagsProvider customConnectionPoolTagsProvider() {
		return new CustomConnectionPoolTagsProvider();
	}
}
/*
package org.springframework.boot.docs.actuator.metrics.customizing;
@Configuration(proxyBeanMethods = false)
public class MyMetricsFilterConfiguration {
	@Bean
	public MeterFilter renameRegionTagMeterFilter() {
		return MeterFilter.renameTag('com.example', 'mytag.region', 'mytag.area');
	}
}
/*
package org.springframework.boot.docs.actuator.micrometertracing.creatingspans;
@Component
class CustomObservation {
	private final ObservationRegistry observationRegistry;
	CustomObservation(ObservationRegistry observationRegistry) {
		this.observationRegistry = observationRegistry;
	}
	void someOperation() {
		Observation observation = Observation.createNotStarted('some-operation', this.observationRegistry);
		observation.lowCardinalityKeyValue('some-tag', 'some-value');
		observation.observe(() -> {
			// Business logic ...
		});
	}
}
/*
package org.springframework.boot.docs.actuator.micrometertracing.baggage;
@Component
class CreatingBaggage {
	private final Tracer tracer;
	CreatingBaggage(Tracer tracer) {
		this.tracer = tracer;
	}
	void doSomething() {
		try (BaggageInScope scope = this.tracer.createBaggageInScope('baggage1', 'value1')) {
			// Business logic
		}
	}
}
/*
package org.springframework.boot.docs.actuator.micrometertracing.gettingstarted;
@RestController
@SpringBootApplication
public class MyApplication {
	private static final Log logger = LogFactory.getLog(MyApplication.class);
	@RequestMapping('/')
	String home() {
		logger.info('home() has been called');
		return 'Hello World!';
	}
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.actuator.observability;
@Component
public class MyCustomObservation {
	private final ObservationRegistry observationRegistry;
	public MyCustomObservation(ObservationRegistry observationRegistry) {
		this.observationRegistry = observationRegistry;
	}
	public void doSomething() {
		Observation.createNotStarted('doSomething', this.observationRegistry)
			.lowCardinalityKeyValue('locale', 'en-US')
			.highCardinalityKeyValue('userId', '42')
			.observe(() -> {
				// Execute business logic here
			});
	}
}
/*
package org.springframework.boot.docs.actuator.observability.preventingobservations;
@Component
class MyObservationPredicate implements ObservationPredicate {
	@Override
	public boolean test(String name, Context context) {
		return !name.contains('denied');
	}
}
/*
package org.springframework.boot.docs.actuator.endpoints.health.reactivehealthindicators;
@Component
public class MyReactiveHealthIndicator implements ReactiveHealthIndicator {
	@Override
	public Mono<Health> health() {
		// @formatter:off
		return doHealthCheck().onErrorResume((exception) ->
			Mono.just(new Health.Builder().down(exception).build()));
		// @formatter:on
	}
	private Mono<Health> doHealthCheck() {
		// perform some specific health check
		return /**/ null;
	}
}
/*
package org.springframework.boot.docs.actuator.endpoints.health.writingcustomhealthindicators;
@Component
public class MyHealthIndicator implements HealthIndicator {
	@Override
	public Health health() {
		int errorCode = check();
		if (errorCode != 0) {
			return Health.down().withDetail('Error Code', errorCode).build();
		}
		return Health.up().build();
	}
	private int check() {
		// perform some specific health check
		return /**/ 0;
	}
}
/*
package org.springframework.boot.docs.actuator.endpoints.security.exposeall;
@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http.securityMatcher(EndpointRequest.toAnyEndpoint());
		http.authorizeHttpRequests((requests) -> requests.anyRequest().permitAll());
		return http.build();
	}
}
/*
package org.springframework.boot.docs.actuator.endpoints.security.typical;
@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http.securityMatcher(EndpointRequest.toAnyEndpoint());
		http.authorizeHttpRequests((requests) -> requests.anyRequest().hasRole('ENDPOINT_ADMIN'));
		http.httpBasic(withDefaults());
		return http.build();
	}
}
/*
package org.springframework.boot.docs.actuator.endpoints.info.writingcustominfocontributors;
@Component
public class MyInfoContributor implements InfoContributor {
	@Override
	public void contribute(Info.Builder builder) {
		builder.withDetail('example', Collections.singletonMap('key', 'value'));
	}
}
/*
package org.springframework.boot.docs.actuator.endpoints.implementingcustom;
class CustomData {
	private final String name;
	private final int counter;
	CustomData(String name, int counter) {
		this.name = name;
		this.counter = counter;
	}
	String getName() {
		return this.name;
	}
	int getCounter() {
		return this.counter;
	}
}
/*
package org.springframework.boot.docs.actuator.endpoints.implementingcustom;
@Endpoint(id = 'custom')
public class MyEndpoint {
	// tag::read[]
	@ReadOperation
	public CustomData getData() {
		return new CustomData('test', 5);
	}
	// end::read[]
	// tag::write[]
	@WriteOperation
	public void updateData(String name, int counter) {
		// injects 'test' and 42
	}
	// end::write[]
}
/*
package org.springframework.boot.docs.actuator.cloudfoundry.customcontextpath;
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(WebFluxProperties.class)
public class MyReactiveCloudFoundryConfiguration {
	@Bean
	public HttpHandler httpHandler(ApplicationContext applicationContext, WebFluxProperties properties) {
		HttpHandler httpHandler = WebHttpHandlerBuilder.applicationContext(applicationContext).build();
		return new CloudFoundryHttpHandler(properties.getBasePath(), httpHandler);
	}
	private static final class CloudFoundryHttpHandler implements HttpHandler {
		private final HttpHandler delegate;
		private final ContextPathCompositeHandler contextPathDelegate;
		private CloudFoundryHttpHandler(String basePath, HttpHandler delegate) {
			this.delegate = delegate;
			this.contextPathDelegate = new ContextPathCompositeHandler(Map.of(basePath, delegate));
		}
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			// Remove underlying context path first (e.g. Servlet container)
			String path = request.getPath().pathWithinApplication().value();
			if (path.startsWith('/cloudfoundryapplication')) {
				return this.delegate.handle(request, response);
			}
			else {
				return this.contextPathDelegate.handle(request, response);
			}
		}
	}
}
/*
package org.springframework.boot.docs.actuator.cloudfoundry.customcontextpath;
@Configuration(proxyBeanMethods = false)
public class MyCloudFoundryConfiguration {
	@Bean
	public TomcatServletWebServerFactory servletWebServerFactory() {
		return new TomcatServletWebServerFactory() {
			@Override
			protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
				super.prepareContext(host, initializers);
				StandardContext child = new StandardContext();
				child.addLifecycleListener(new Tomcat.FixContextListener());
				child.setPath('/cloudfoundryapplication');
				ServletContainerInitializer initializer = getServletContextInitializer(getContextPath());
				child.addServletContainerInitializer(initializer, Collections.emptySet());
				child.setCrossContext(true);
				host.addChild(child);
			}
		};
	}
	private ServletContainerInitializer getServletContextInitializer(String contextPath) {
		return (classes, context) -> {
			Servlet servlet = new GenericServlet() {
				@Override
				public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
					ServletContext context = req.getServletContext().getContext(contextPath);
					context.getRequestDispatcher('/cloudfoundryapplication').forward(req, res);
				}
			};
			context.addServlet('cloudfoundry', servlet).addMapping('/*');
		};
	}
}
/*
package org.springframework.boot.docs.data.sql.h2webconsole.springsecurity;
@Profile('dev')
@Configuration(proxyBeanMethods = false)
public class DevProfileSecurityConfiguration {
	@Bean
	@Order(Ordered.HIGHEST_PRECEDENCE)
	SecurityFilterChain h2ConsoleSecurityFilterChain(HttpSecurity http) throws Exception {
		http.securityMatcher(PathRequest.toH2Console());
		http.authorizeHttpRequests(yourCustomAuthorization());
		http.csrf(CsrfConfigurer::disable);
		http.headers((headers) -> headers.frameOptions(FrameOptionsConfig::sameOrigin));
		return http.build();
	}
	// tag::customizer[]
	<T> Customizer<T> yourCustomAuthorization() {
		return (t) -> {
		};
	}
	// end::customizer[]
}
/*
package org.springframework.boot.docs.data.sql.jdbctemplate;
@Component
public class MyBean {
	private final JdbcTemplate jdbcTemplate;
	public MyBean(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}
	public void doSomething() {
		/* @chomp:line this.jdbcTemplate ... */ this.jdbcTemplate.execute('delete from customer');
	}
}
/*
package org.springframework.boot.docs.data.sql.jooq.dslcontext;
@Component
public class MyBean {
	private final DSLContext create;
	public MyBean(DSLContext dslContext) {
		this.create = dslContext;
	}
	// tag::method[]
	public List<GregorianCalendar> authorsBornAfter1980() {
		return this.create.selectFrom(AUTHOR)
			.where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
			.fetch(AUTHOR.DATE_OF_BIRTH);
	} // end::method[]
}
/*
package org.springframework.boot.docs.data.sql.jooq.dslcontext;
abstract class Tables {
	static final TAuthor AUTHOR = null;
	abstract class TAuthor extends TableImpl<TAuthorRecord> {
		TAuthor(Name name) {
			super(name);
		}
		public final TableField<TAuthorRecord, GregorianCalendar> DATE_OF_BIRTH = null;
	}
	abstract class TAuthorRecord extends TableRecordImpl<TAuthorRecord> {
		TAuthorRecord(Table<TAuthorRecord> table) {
			super(table);
		}
	}
}
/*
package org.springframework.boot.docs.data.sql.r2dbc;
@Configuration(proxyBeanMethods = false)
public class MyPostgresR2dbcConfiguration {
	@Bean
	public ConnectionFactoryOptionsBuilderCustomizer postgresCustomizer() {
		Map<String, String> options = new HashMap<>();
		options.put('lock_timeout', '30s');
		options.put('statement_timeout', '60s');
		return (builder) -> builder.option(PostgresqlConnectionFactoryProvider.OPTIONS, options);
	}
}
/*
package org.springframework.boot.docs.data.sql.r2dbc.repositories;
public class City {
}
/*
package org.springframework.boot.docs.data.sql.r2dbc.repositories;
public interface CityRepository extends Repository<City, Long> {
	Mono<City> findByNameAndStateAllIgnoringCase(String name, String state);
}
/*
package org.springframework.boot.docs.data.sql.r2dbc.usingdatabaseclient;
@Component
public class MyBean {
	private final DatabaseClient databaseClient;
	public MyBean(DatabaseClient databaseClient) {
		this.databaseClient = databaseClient;
	}
	// @fold:on // ...
	public Flux<Map<String, Object>> someMethod() {
		return this.databaseClient.sql('select * from user').fetch().all();
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.sql.r2dbc;
@Configuration(proxyBeanMethods = false)
public class MyR2dbcConfiguration {
	@Bean
	public ConnectionFactoryOptionsBuilderCustomizer connectionFactoryPortCustomizer() {
		return (builder) -> builder.option(ConnectionFactoryOptions.PORT, 5432);
	}
}
/*
package org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses;
@Entity
public class City implements Serializable {
	@Id
	@GeneratedValue
	private Long id;
	@Column(nullable = false)
	private String name;
	@Column(nullable = false)
	private String state;
	// ... additional members, often include @OneToMany mappings
	protected City() {
		// no-args constructor required by JPA spec
		// this one is protected since it should not be used directly
	}
	public City(String name, String state) {
		this.name = name;
		this.state = state;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	// ... etc
}
/*
package org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses;
@Entity
public class Country implements Serializable {
	@Id
	@GeneratedValue
	private Long id;
	@Audited
	@Column(nullable = false)
	private String name;
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.docs.data.sql.jpaandspringdata.enversrepositories;
public interface CountryRepository extends RevisionRepository<Country, Long, Integer>, Repository<Country, Long> {
	Page<Country> findAll(Pageable pageable);
}
/*
package org.springframework.boot.docs.data.sql.jpaandspringdata.repositories;
public interface CityRepository extends Repository<City, Long> {
	Page<City> findAll(Pageable pageable);
	City findByNameAndStateAllIgnoringCase(String name, String state);
}
/*
package org.springframework.boot.docs.data.sql.jdbcclient;
@Component
public class MyBean {
	private final JdbcClient jdbcClient;
	public MyBean(JdbcClient jdbcClient) {
		this.jdbcClient = jdbcClient;
	}
	public void doSomething() {
		/* @chomp:line this.jdbcClient ... */ this.jdbcClient.sql('delete from customer').update();
	}
}
/*
package org.springframework.boot.docs.data.nosql.cassandra.connecting;
@Component
public class MyBean {
	private final CassandraTemplate template;
	public MyBean(CassandraTemplate template) {
		this.template = template;
	}
	// @fold:on // ...
	public long someMethod() {
		return this.template.count(User.class);
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.cassandra.connecting;
class User {
}
/*
package org.springframework.boot.docs.data.nosql.couchbase.repositories;
@Component
public class MyBean {
	private final CouchbaseTemplate template;
	public MyBean(CouchbaseTemplate template) {
		this.template = template;
	}
	// @fold:on // ...
	public String someMethod() {
		return this.template.getBucketName();
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.couchbase.repositories;
class CouchbaseProperties {
}
/*
package org.springframework.boot.docs.data.nosql.couchbase.repositories;
@Configuration(proxyBeanMethods = false)
public class MyCouchbaseConfiguration {
	@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
	public CouchbaseCustomConversions myCustomConversions() {
		return new CouchbaseCustomConversions(Arrays.asList(new MyConverter()));
	}
}
/*
package org.springframework.boot.docs.data.nosql.couchbase.repositories;
class MyConverter implements Converter<CouchbaseProperties, Boolean> {
	@Override
	public Boolean convert(CouchbaseProperties value) {
		return true;
	}
}
/*
package org.springframework.boot.docs.data.nosql.neo4j.repositories;
public class City {
}
/*
package org.springframework.boot.docs.data.nosql.neo4j.repositories;
public interface CityRepository extends Neo4jRepository<City, Long> {
	Optional<City> findOneByNameAndState(String name, String state);
}
/*
package org.springframework.boot.docs.data.nosql.neo4j.repositories;
@Configuration(proxyBeanMethods = false)
public class MyNeo4jConfiguration {
	@Bean
	public ReactiveNeo4jTransactionManager reactiveTransactionManager(Driver driver,
			ReactiveDatabaseSelectionProvider databaseNameProvider) {
		return new ReactiveNeo4jTransactionManager(driver, databaseNameProvider);
	}
}
/*
package org.springframework.boot.docs.data.nosql.neo4j.connecting;
@Component
public class MyBean {
	private final Driver driver;
	public MyBean(Driver driver) {
		this.driver = driver;
	}
	// @fold:on // ...
	public String someMethod(String message) {
		try (Session session = this.driver.session()) {
			return session.executeWrite(
					(transaction) -> transaction
						.run('CREATE (a:Greeting) SET a.message = $message RETURN a.message + ", from node " + id(a)',
								Values.parameters('message', message))
						.single()
						.get(0)
						.asString());
		}
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.mongodb.template;
@Component
public class MyBean {
	private final MongoTemplate mongoTemplate;
	public MyBean(MongoTemplate mongoTemplate) {
		this.mongoTemplate = mongoTemplate;
	}
	// @fold:on // ...
	public MongoCollection<Document> someMethod() {
		return this.mongoTemplate.getCollection('users');
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.mongodb.repositories;
public class City {
}
/*
package org.springframework.boot.docs.data.nosql.mongodb.repositories;
public interface CityRepository extends Repository<City, Long> {
	Page<City> findAll(Pageable pageable);
	City findByNameAndStateAllIgnoringCase(String name, String state);
}
/*
package org.springframework.boot.docs.data.nosql.mongodb.connecting;
@Component
public class MyBean {
	private final MongoDatabaseFactory mongo;
	public MyBean(MongoDatabaseFactory mongo) {
		this.mongo = mongo;
	}
	// @fold:on // ...
	public MongoCollection<Document> someMethod() {
		MongoDatabase db = this.mongo.getMongoDatabase();
		return db.getCollection('users');
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.elasticsearch.connectingusingspringdata;
@Component
public class MyBean {
	private final ElasticsearchTemplate template;
	public MyBean(ElasticsearchTemplate template) {
		this.template = template;
	}
	// @fold:on // ...
	public boolean someMethod(String id) {
		return this.template.exists(id, User.class);
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.elasticsearch.connectingusingspringdata;
class User {
}
/*
package org.springframework.boot.docs.data.nosql.redis.connecting;
@Component
public class MyBean {
	private final StringRedisTemplate template;
	public MyBean(StringRedisTemplate template) {
		this.template = template;
	}
	// @fold:on // ...
	public Boolean someMethod() {
		return this.template.hasKey('spring');
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.ldap.repositories;
@Component
public class MyBean {
	private final LdapTemplate template;
	public MyBean(LdapTemplate template) {
		this.template = template;
	}
	// @fold:on // ...
	public List<User> someMethod() {
		return this.template.findAll(User.class);
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.data.nosql.ldap.repositories;
class User {
}
/*
package org.springframework.boot.docs.features.ssl.bundles;
@Component
public class MyComponent {
	@SuppressWarnings('unused')
	public MyComponent(SslBundles sslBundles) {
		SslBundle sslBundle = sslBundles.getBundle('mybundle');
		SSLContext sslContext = sslBundle.createSslContext();
		// do something with the created sslContext
	}
}
/*
package org.springframework.boot.docs.features.externalconfig;
@Component
public class MyBean {
	@Value('${name}')
	private String name;
	// ...
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.mergingcomplextypes.map;
class MyPojo {
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.mergingcomplextypes.map;
@ConfigurationProperties('my')
public class MyProperties {
	private final Map<String, MyPojo> map = new LinkedHashMap<>();
	public Map<String, MyPojo> getMap() {
		return this.map;
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.mergingcomplextypes.list;
class MyPojo {
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.mergingcomplextypes.list;
@ConfigurationProperties('my')
public class MyProperties {
	private final List<MyPojo> list = new ArrayList<>();
	public List<MyPojo> getList() {
		return this.list;
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.thirdpartyconfiguration;
@Configuration(proxyBeanMethods = false)
public class ThirdPartyConfiguration {
	@Bean
	@ConfigurationProperties(prefix = 'another')
	public AnotherComponent anotherComponent() {
		return new AnotherComponent();
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.thirdpartyconfiguration;
class AnotherComponent {
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.enablingannotatedtypes;
@ConfigurationProperties('some.properties')
public class SomeProperties {
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.enablingannotatedtypes;
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(SomeProperties.class)
public class MyConfiguration {
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.enablingannotatedtypes;
@SpringBootApplication
@ConfigurationPropertiesScan({ 'com.example.app', 'com.example.another' })
public class MyApplication {
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.validation;
@ConfigurationProperties('my.service')
@Validated
public class MyProperties {
	@NotNull
	private InetAddress remoteAddress;
	// @fold:on // getters/setters...
	public InetAddress getRemoteAddress() {
		return this.remoteAddress;
	}
	public void setRemoteAddress(InetAddress remoteAddress) {
		this.remoteAddress = remoteAddress;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.validation.nested;
@ConfigurationProperties('my.service')
@Validated
public class MyProperties {
	@NotNull
	private InetAddress remoteAddress;
	@Valid
	private final Security security = new Security();
	// @fold:on // getters/setters...
	public InetAddress getRemoteAddress() {
		return this.remoteAddress;
	}
	public void setRemoteAddress(InetAddress remoteAddress) {
		this.remoteAddress = remoteAddress;
	}
	public Security getSecurity() {
		return this.security;
	}
	// @fold:off
	public static class Security {
		@NotEmpty
		private String username;
		// @fold:on // getters/setters...
		public String getUsername() {
			return this.username;
		}
		public void setUsername(String username) {
			this.username = username;
		}
		// @fold:off
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.javabeanbinding;
@ConfigurationProperties('my.service')
public class MyProperties {
	private boolean enabled;
	private InetAddress remoteAddress;
	private final Security security = new Security();
	// @fold:on // getters / setters...
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public InetAddress getRemoteAddress() {
		return this.remoteAddress;
	}
	public void setRemoteAddress(InetAddress remoteAddress) {
		this.remoteAddress = remoteAddress;
	}
	public Security getSecurity() {
		return this.security;
	}
	// @fold:off
	public static class Security {
		private String username;
		private String password;
		private List<String> roles = new ArrayList<>(Collections.singleton('USER'));
		// @fold:on // getters / setters...
		public String getUsername() {
			return this.username;
		}
		public void setUsername(String username) {
			this.username = username;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
		public List<String> getRoles() {
			return this.roles;
		}
		public void setRoles(List<String> roles) {
			this.roles = roles;
		}
		// @fold:off
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.usingannotatedtypes;
class Server {
	Server(Object remoteAddress) {
	}
	void start() {
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.usingannotatedtypes;
class MyProperties {
	Object getRemoteAddress() {
		return null;
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.usingannotatedtypes;
@Service
public class MyService {
	private final MyProperties properties;
	public MyService(MyProperties properties) {
		this.properties = properties;
	}
	public void openConnection() {
		Server server = new Server(this.properties.getRemoteAddress());
		server.start();
		// ...
	}
	// ...
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.constructorbinding;
@ConfigurationProperties('my.service')
public class MyProperties {
	// @fold:on // fields...
	private final boolean enabled;
	private final InetAddress remoteAddress;
	private final Security security;
	// @fold:off
	public MyProperties(boolean enabled, InetAddress remoteAddress, Security security) {
		this.enabled = enabled;
		this.remoteAddress = remoteAddress;
		this.security = security;
	}
	// @fold:on // getters...
	public boolean isEnabled() {
		return this.enabled;
	}
	public InetAddress getRemoteAddress() {
		return this.remoteAddress;
	}
	public Security getSecurity() {
		return this.security;
	}
	// @fold:off
	public static class Security {
		// @fold:on // fields...
		private final String username;
		private final String password;
		private final List<String> roles;
		// @fold:off
		public Security(String username, String password, @DefaultValue('USER') List<String> roles) {
			this.username = username;
			this.password = password;
			this.roles = roles;
		}
		// @fold:on // getters...
		public String getUsername() {
			return this.username;
		}
		public String getPassword() {
			return this.password;
		}
		public List<String> getRoles() {
			return this.roles;
		}
		// @fold:off
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.constructorbinding.nonnull;
@ConfigurationProperties('my.service')
public class MyProperties {
	private final boolean enabled;
	private final InetAddress remoteAddress;
	private final Security security;
	// tag::code[]
	public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) {
		this.enabled = enabled;
		this.remoteAddress = remoteAddress;
		this.security = security;
	}
	// end::code[]
	public boolean isEnabled() {
		return this.enabled;
	}
	public InetAddress getRemoteAddress() {
		return this.remoteAddress;
	}
	public Security getSecurity() {
		return this.security;
	}
	public static class Security {
		private final String username;
		private final String password;
		private final List<String> roles;
		public Security(String username, String password, @DefaultValue('USER') List<String> roles) {
			this.username = username;
			this.password = password;
			this.roles = roles;
		}
		public String getUsername() {
			return this.username;
		}
		public String getPassword() {
			return this.password;
		}
		public List<String> getRoles() {
			return this.roles;
		}
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.relaxedbinding;
@ConfigurationProperties(prefix = 'my.main-project.person')
public class MyPersonProperties {
	private String firstName;
	public String getFirstName() {
		return this.firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.relaxedbinding.mapsfromenvironmentvariables;
@ConfigurationProperties(prefix = 'my.props')
public class MyMapsProperties {
	private final Map<String, String> values = new HashMap<>();
	public Map<String, String> getValues() {
		return this.values;
	}
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.conversion.datasizes.javabeanbinding;
@ConfigurationProperties('my')
public class MyProperties {
	@DataSizeUnit(DataUnit.MEGABYTES)
	private DataSize bufferSize = DataSize.ofMegabytes(2);
	private DataSize sizeThreshold = DataSize.ofBytes(512);
	// @fold:on // getters/setters...
	public DataSize getBufferSize() {
		return this.bufferSize;
	}
	public void setBufferSize(DataSize bufferSize) {
		this.bufferSize = bufferSize;
	}
	public DataSize getSizeThreshold() {
		return this.sizeThreshold;
	}
	public void setSizeThreshold(DataSize sizeThreshold) {
		this.sizeThreshold = sizeThreshold;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.conversion.datasizes.constructorbinding;
@ConfigurationProperties('my')
public class MyProperties {
	// @fold:on // fields...
	private final DataSize bufferSize;
	private final DataSize sizeThreshold;
	// @fold:off
	public MyProperties(@DataSizeUnit(DataUnit.MEGABYTES) @DefaultValue('2MB') DataSize bufferSize,
			@DefaultValue('512B') DataSize sizeThreshold) {
		this.bufferSize = bufferSize;
		this.sizeThreshold = sizeThreshold;
	}
	// @fold:on // getters...
	public DataSize getBufferSize() {
		return this.bufferSize;
	}
	public DataSize getSizeThreshold() {
		return this.sizeThreshold;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.conversion.durations.javabeanbinding;
@ConfigurationProperties('my')
public class MyProperties {
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration sessionTimeout = Duration.ofSeconds(30);
	private Duration readTimeout = Duration.ofMillis(1000);
	// @fold:on // getters / setters...
	public Duration getSessionTimeout() {
		return this.sessionTimeout;
	}
	public void setSessionTimeout(Duration sessionTimeout) {
		this.sessionTimeout = sessionTimeout;
	}
	public Duration getReadTimeout() {
		return this.readTimeout;
	}
	public void setReadTimeout(Duration readTimeout) {
		this.readTimeout = readTimeout;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.features.externalconfig.typesafeconfigurationproperties.conversion.durations.constructorbinding;
@ConfigurationProperties('my')
public class MyProperties {
	// @fold:on // fields...
	private final Duration sessionTimeout;
	private final Duration readTimeout;
	// @fold:off
	public MyProperties(@DurationUnit(ChronoUnit.SECONDS) @DefaultValue('30s') Duration sessionTimeout,
			@DefaultValue('1000ms') Duration readTimeout) {
		this.sessionTimeout = sessionTimeout;
		this.readTimeout = readTimeout;
	}
	// @fold:on // getters...
	public Duration getSessionTimeout() {
		return this.sessionTimeout;
	}
	public Duration getReadTimeout() {
		return this.readTimeout;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.customstarter.configurationkeys;
@ConfigurationProperties('acme')
public class AcmeProperties {
	/**
	 * Whether to check the location of acme resources.
	 */
	private boolean checkLocation = true;
	/**
	 * Timeout for establishing a connection to the acme server.
	 */
	private Duration loginTimeout = Duration.ofSeconds(3);
	// @fold:on // getters/setters ...
	public boolean isCheckLocation() {
		return this.checkLocation;
	}
	public void setCheckLocation(boolean checkLocation) {
		this.checkLocation = checkLocation;
	}
	public Duration getLoginTimeout() {
		return this.loginTimeout;
	}
	public void setLoginTimeout(Duration loginTimeout) {
		this.loginTimeout = loginTimeout;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.testing;
class MyServiceAutoConfigurationTests {
	// tag::runner[]
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));
	// end::runner[]
	// tag::test-env[]
	@Test
	void serviceNameCanBeConfigured() {
		this.contextRunner.withPropertyValues('user.name=test123').run((context) -> {
			assertThat(context).hasSingleBean(MyService.class);
			assertThat(context.getBean(MyService.class).getName()).isEqualTo('test123');
		});
	}
	// end::test-env[]
	// tag::test-classloader[]
	@Test
	void serviceIsIgnoredIfLibraryIsNotPresent() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(MyService.class))
			.run((context) -> assertThat(context).doesNotHaveBean('myService'));
	}
	// end::test-classloader[]
	// tag::test-user-config[]
	@Test
	void defaultServiceBacksOff() {
		this.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(MyService.class);
			assertThat(context).getBean('myCustomService').isSameAs(context.getBean(MyService.class));
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class UserConfiguration {
		@Bean
		MyService myCustomService() {
			return new MyService('mine');
		}
	}
	// end::test-user-config[]
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.testing;
@AutoConfiguration
@ConditionalOnClass(MyService.class)
@EnableConfigurationProperties(UserProperties.class)
public class MyServiceAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public MyService userService(UserProperties properties) {
		return new MyService(properties.getName());
	}
	@ConfigurationProperties('user')
	public static class UserProperties {
		private String name = 'test';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.testing;
public class MyService {
	private final String name;
	public MyService(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.testing;
class MyConditionEvaluationReportingTests {
	@Test
	void autoConfigTest() {
		new ApplicationContextRunner()
			.withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO))
			.run((context) -> {
				// Test something...
			});
	}
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.conditionannotations.classconditions;
@AutoConfiguration
// Some conditions ...
public class MyAutoConfiguration {
	// Auto-configured beans ...
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(SomeService.class)
	public static class SomeServiceConfiguration {
		@Bean
		@ConditionalOnMissingBean
		public SomeService someService() {
			return new SomeService();
		}
	}
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.conditionannotations.classconditions;
class SomeService {
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.conditionannotations.beanconditions;
@AutoConfiguration
public class MyAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public SomeService someService() {
		return new SomeService();
	}
}
/*
package org.springframework.boot.docs.features.developingautoconfiguration.conditionannotations.beanconditions;
public class SomeService {
}
/*
package org.springframework.boot.docs.features.springapplication.applicationavailability.managing;
@Component
public class MyReadinessStateExporter {
	@EventListener
	public void onStateChange(AvailabilityChangeEvent<ReadinessState> event) {
		switch (event.getState()) {
			case ACCEPTING_TRAFFIC -> {
				// create file /tmp/healthy
			}
			case REFUSING_TRAFFIC -> {
				// remove file /tmp/healthy
			}
		}
	}
}
/*
package org.springframework.boot.docs.features.springapplication.applicationavailability.managing;
class CacheCompletelyBrokenException extends RuntimeException {
}
/*
package org.springframework.boot.docs.features.springapplication.applicationavailability.managing;
@Component
public class MyLocalCacheVerifier {
	private final ApplicationEventPublisher eventPublisher;
	public MyLocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
		this.eventPublisher = eventPublisher;
	}
	public void checkLocalCache() {
		try {
			// ...
		}
		catch (CacheCompletelyBrokenException ex) {
			AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);
		}
	}
}
/*
package org.springframework.boot.docs.features.springapplication.commandlinerunner;
@Component
public class MyCommandLineRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		// Do something...
	}
}
/*
package org.springframework.boot.docs.features.springapplication.applicationexit;
@SpringBootApplication
public class MyApplication {
	@Bean
	public ExitCodeGenerator exitCodeGenerator() {
		return () -> 42;
	}
	public static void main(String[] args) {
		System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args)));
	}
}
/*
package org.springframework.boot.docs.features.springapplication.startuptracking;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication application = new SpringApplication(MyApplication.class);
		application.setApplicationStartup(new BufferingApplicationStartup(2048));
		application.run(args);
	}
}
/*
package org.springframework.boot.docs.features.springapplication.applicationarguments;
@Component
public class MyBean {
	public MyBean(ApplicationArguments args) {
		boolean debug = args.containsOption('debug');
		List<String> files = args.getNonOptionArgs();
		if (debug) {
			System.out.println(files);
		}
		// if run with '--debug logfile.txt' prints ['logfile.txt']
	}
}
/*
package org.springframework.boot.docs.features.springapplication.customizingspringapplication;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication application = new SpringApplication(MyApplication.class);
		application.setBannerMode(Banner.Mode.OFF);
		application.run(args);
	}
}
/*
package org.springframework.boot.docs.features.springapplication.fluentbuilderapi;
public class MyApplication {
	public void hierarchyWithDisabledBanner(String[] args) {
		// tag::code[]
		new SpringApplicationBuilder().sources(Parent.class)
			.child(Application.class)
			.bannerMode(Banner.Mode.OFF)
			.run(args);
		// end::code[]
	}
	static class Parent {
	}
	static class Application {
	}
}
/*
package org.springframework.boot.docs.features.springapplication;
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.features.logging.structured.otherformats;
class MyCustomFormat implements StructuredLogFormatter<ILoggingEvent> {
	@Override
	public String format(ILoggingEvent event) {
		return 'time=' + event.getInstant() + ' level=' + event.getLevel() + ' message=' + event.getMessage() + '\n';
	}
}
/*
package org.springframework.boot.docs.features.json.jackson.customserializersanddeserializers.object;
class MyObject {
	MyObject(String name, int age) {
	}
	String getName() {
		return null;
	}
	Integer getAge() {
		return null;
	}
}
/*
package org.springframework.boot.docs.features.json.jackson.customserializersanddeserializers.object;
@JsonComponent
public class MyJsonComponent {
	public static class Serializer extends JsonObjectSerializer<MyObject> {
		@Override
		protected void serializeObject(MyObject value, JsonGenerator jgen, SerializerProvider provider)
				throws IOException {
			jgen.writeStringField('name', value.getName());
			jgen.writeNumberField('age', value.getAge());
		}
	}
	public static class Deserializer extends JsonObjectDeserializer<MyObject> {
		@Override
		protected MyObject deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,
				JsonNode tree) throws IOException {
			String name = nullSafeValue(tree.get('name'), String.class);
			int age = nullSafeValue(tree.get('age'), Integer.class);
			return new MyObject(name, age);
		}
	}
}
/*
package org.springframework.boot.docs.features.json.jackson.customserializersanddeserializers;
class MyObject {
	MyObject(String name, int age) {
	}
	String getName() {
		return null;
	}
	Integer getAge() {
		return null;
	}
}
/*
package org.springframework.boot.docs.features.json.jackson.customserializersanddeserializers;
@JsonComponent
public class MyJsonComponent {
	public static class Serializer extends JsonSerializer<MyObject> {
		@Override
		public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException {
			jgen.writeStartObject();
			jgen.writeStringField('name', value.getName());
			jgen.writeNumberField('age', value.getAge());
			jgen.writeEndObject();
		}
	}
	public static class Deserializer extends JsonDeserializer<MyObject> {
		@Override
		public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException {
			ObjectCodec codec = jsonParser.getCodec();
			JsonNode tree = codec.readTree(jsonParser);
			String name = tree.get('name').textValue();
			int age = tree.get('age').intValue();
			return new MyObject(name, age);
		}
	}
}
/*
package org.springframework.boot.docs.features.profiles;
@Configuration(proxyBeanMethods = false)
@Profile('production')
public class ProductionConfiguration {
	// ...
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.test;
@TestConfiguration(proxyBeanMethods = false)
public class MyContainersConfiguration {
	@Bean
	@ServiceConnection
	public Neo4jContainer<?> neo4jContainer() {
		return new Neo4jContainer<>('neo4j:5');
	}
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.test;
public class MyApplication {
	public static void main(String[] args) {
	}
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.test;
public class TestMyApplication {
	public static void main(String[] args) {
		SpringApplication.from(MyApplication::main).with(MyContainersConfiguration.class).run(args);
	}
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.launch;
public class MyApplication {
	public static void main(String[] args) {
	}
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.launch;
public class TestMyApplication {
	public static void main(String[] args) {
		SpringApplication.from(MyApplication::main).run(args);
	}
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.devtools;
@TestConfiguration(proxyBeanMethods = false)
public class MyContainersConfiguration {
	@Bean
	@RestartScope
	@ServiceConnection
	public MongoDBContainer mongoDbContainer() {
		return new MongoDBContainer('mongo:5.0');
	}
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.importingcontainerdeclarations;
public interface MyContainers {
	@Container
	@ServiceConnection
	MongoDBContainer mongoContainer = new MongoDBContainer('mongo:5.0');
	@Container
	@ServiceConnection
	Neo4jContainer<?> neo4jContainer = new Neo4jContainer<>('neo4j:5');
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.importingcontainerdeclarations;
@TestConfiguration(proxyBeanMethods = false)
@ImportTestcontainers(MyContainers.class)
public class MyContainersConfiguration {
}
/*
package org.springframework.boot.docs.features.devservices.testcontainers.atdevelopmenttime.dynamicproperties;
@TestConfiguration(proxyBeanMethods = false)
public class MyContainersConfiguration {
	@Bean
	public MongoDBContainer mongoDbContainer() {
		return new MongoDBContainer('mongo:5.0');
	}
	@Bean
	public DynamicPropertyRegistrar mongoDbProperties(MongoDBContainer container) {
		return (properties) -> {
			properties.add('spring.data.mongodb.host', container::getHost);
			properties.add('spring.data.mongodb.port', container::getFirstMappedPort);
		};
	}
}
/*
package org.springframework.boot.docs.features.logexample;
/**
@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}
}
/*
package org.springframework.boot.docs.packaging.nativeimage.introducinggraalvmnativeimages.understandingaotprocessing.sourcecodegeneration;
public class MyBean {
}
/*
package org.springframework.boot.docs.packaging.nativeimage.introducinggraalvmnativeimages.understandingaotprocessing.sourcecodegeneration;
/**
@SuppressWarnings('javadoc')
public class MyConfiguration__BeanDefinitions {
	/**
	 * Get the bean definition for "myConfiguration".
	 */
	public static BeanDefinition getMyConfigurationBeanDefinition() {
		Class<?> beanType = MyConfiguration.class;
		RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
		beanDefinition.setInstanceSupplier(MyConfiguration::new);
		return beanDefinition;
	}
	/**
	 * Get the bean instance supplier for "myBean".
	 */
	private static BeanInstanceSupplier<MyBean> getMyBeanInstanceSupplier() {
		return BeanInstanceSupplier.<MyBean>forFactoryMethod(MyConfiguration.class, 'myBean')
			.withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(MyConfiguration.class).myBean());
	}
	/**
	 * Get the bean definition for "myBean".
	 */
	public static BeanDefinition getMyBeanBeanDefinition() {
		Class<?> beanType = MyBean.class;
		RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
		beanDefinition.setInstanceSupplier(getMyBeanInstanceSupplier());
		return beanDefinition;
	}
}
/*
package org.springframework.boot.docs.packaging.nativeimage.introducinggraalvmnativeimages.understandingaotprocessing.sourcecodegeneration;
@Configuration(proxyBeanMethods = false)
public class MyConfiguration {
	@Bean
	public MyBean myBean() {
		return new MyBean();
	}
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.customhints.testing;
class MyRuntimeHintsTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new MyRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('my-resource.txt')).accepts(hints);
	}
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.customhints;
class MyClass {
	void sayHello(String name) {
		System.out.println('Hello ' + name);
	}
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.customhints;
interface MyInterface {
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.customhints;
public class MyRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		// Register method for reflection
		Method method = ReflectionUtils.findMethod(MyClass.class, 'sayHello', String.class);
		hints.reflection().registerMethod(method, ExecutableMode.INVOKE);
		// Register resources
		hints.resources().registerPattern('my-resource.txt');
		// Register serialization
		hints.serialization().registerType(MySerializableClass.class);
		// Register proxy
		hints.proxies().registerJdkProxy(MyInterface.class);
	}
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.customhints;
class MySerializableClass implements Serializable {
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.nestedconfigurationproperties;
@ConfigurationProperties(prefix = 'my.properties')
public class MyPropertiesCtor {
	private final String name;
	@NestedConfigurationProperty
	private final Nested nested;
	public MyPropertiesCtor(String name, Nested nested) {
		this.name = name;
		this.nested = nested;
	}
	// @fold:on // getters / setters...
	public String getName() {
		return this.name;
	}
	public Nested getNested() {
		return this.nested;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.nestedconfigurationproperties;
@ConfigurationProperties(prefix = 'my.properties')
public class MyProperties {
	private String name;
	@NestedConfigurationProperty
	private final Nested nested = new Nested();
	// @fold:on // getters / setters...
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Nested getNested() {
		return this.nested;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.nestedconfigurationproperties;
public class Nested {
	private int number;
	// @fold:on // getters / setters...
	public int getNumber() {
		return this.number;
	}
	public void setNumber(int number) {
		this.number = number;
	}
	// @fold:off
}
/*
package org.springframework.boot.docs.packaging.nativeimage.advanced.nestedconfigurationproperties;
@ConfigurationProperties(prefix = 'my.properties')
public record MyPropertiesRecord(String name, @NestedConfigurationProperty Nested nested) {
}
/*
package org.springframework.boot.docs.appendix.configurationmetadata.annotationprocessor.automaticmetadatageneration;
@ConfigurationProperties(prefix = 'my.server')
public class MyServerProperties {
	/**
	 * Name of the server.
	 */
	private String name;
	/**
	 * IP address to listen to.
	 */
	private String ip = '127.0.0.1';
	/**
	 * Port to listener to.
	 */
	private int port = 9797;
	// @fold:on // getters/setters ...
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getIp() {
		return this.ip;
	}
	public void setIp(String ip) {
		this.ip = ip;
	}
	public int getPort() {
		return this.port;
	}
	public void setPort(int port) {
		this.port = port;
	}
	// fold:off
}
/*
package org.springframework.boot.docs.appendix.configurationmetadata.annotationprocessor.automaticmetadatageneration.nestedproperties;
@ConfigurationProperties(prefix = 'my.server')
public class MyServerProperties {
	private String name;
	private Host host;
	// @fold:on // getters/setters ...
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Host getHost() {
		return this.host;
	}
	public void setHost(Host host) {
		this.host = host;
	}
	// @fold:off
	public static class Host {
		private String ip;
		private int port;
		// @fold:on // getters/setters ...
		public String getIp() {
			return this.ip;
		}
		public void setIp(String ip) {
			this.ip = ip;
		}
		public int getPort() {
			return this.port;
		}
		public void setPort(int port) {
			this.port = port;
		}
		// @fold:off // getters/setters ...
	}
}
/*
package org.springframework.boot.docs.appendix.configurationmetadata.annotationprocessor.automaticmetadatageneration;
@ConfigurationProperties(prefix = 'my.messaging')
public class MyMessagingProperties {
	private List<String> addresses = new ArrayList<>(Arrays.asList('a', 'b'));
	private ContainerType containerType = ContainerType.SIMPLE;
	// @fold:on // getters/setters ...
	public List<String> getAddresses() {
		return this.addresses;
	}
	public void setAddresses(List<String> addresses) {
		this.addresses = addresses;
	}
	public ContainerType getContainerType() {
		return this.containerType;
	}
	public void setContainerType(ContainerType containerType) {
		this.containerType = containerType;
	}
	// @fold:off
	public enum ContainerType {
		SIMPLE, DIRECT
	}
}
/*
package org.springframework.boot.docs.appendix.configurationmetadata.format.property;
@ConfigurationProperties('my.app')
public class MyProperties {
	private String name;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@Deprecated
	@DeprecatedConfigurationProperty(replacement = 'my.app.name')
	public String getTarget() {
		return this.name;
	}
	@Deprecated
	public void setTarget(String target) {
		this.name = target;
	}
}
/*
package org.springframework.boot.docs.appendix.configurationmetadata.manualhints.valuehint;
@ConfigurationProperties('my')
public class MyProperties {
	private Map<String, Integer> contexts;
	// @fold:on // getters/setters ...
	public Map<String, Integer> getContexts() {
		return this.contexts;
	}
	public void setContexts(Map<String, Integer> contexts) {
		this.contexts = contexts;
	}
	// @fold:off
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'value=123' })
class SpringBootTestWebEnvironmentRandomPortTests extends AbstractSpringBootTestWebServerWebEnvironmentTests {
	@Test
	void testRestTemplateShouldUseBuilder() {
		assertThat(getRestTemplate().getRestTemplate().getMessageConverters())
			.hasAtLeastOneElementOfType(MyConverter.class);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	@RestController
	static class Config extends AbstractConfig {
		@Bean
		RestTemplateBuilder restTemplateBuilder() {
			return new RestTemplateBuilder().additionalMessageConverters(new MyConverter());
		}
	}
	static class MyConverter extends StringHttpMessageConverter {
	}
}
/*
package org.springframework.boot.test.context;
/**
class AnnotatedClassFinderTests {
	private final AnnotatedClassFinder finder = new AnnotatedClassFinder(SpringBootConfiguration.class);
	@Test
	void findFromClassWhenSourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.finder.findFromClass((Class<?>) null))
			.withMessageContaining('Source must not be null');
	}
	@Test
	void findFromPackageWhenSourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.finder.findFromPackage((String) null))
			.withMessageContaining('Source must not be null');
	}
	@Test
	void findFromPackageWhenNoConfigurationFoundShouldReturnNull() {
		Class<?> config = this.finder.findFromPackage('org.springframework.boot');
		assertThat(config).isNull();
	}
	@Test
	void findFromClassWhenConfigurationIsFoundShouldReturnConfiguration() {
		Class<?> config = this.finder.findFromClass(Example.class);
		assertThat(config).isEqualTo(ExampleConfig.class);
	}
	@Test
	void findFromPackageWhenConfigurationIsFoundShouldReturnConfiguration() {
		Class<?> config = this.finder.findFromPackage('org.springframework.boot.test.context.example.scan');
		assertThat(config).isEqualTo(ExampleConfig.class);
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
@ExtendWith(MockitoExtension.class)
class ApplicationContextAssertProviderTests {
	@Mock
	private ConfigurableApplicationContext mockContext;
	private RuntimeException startupFailure;
	private Supplier<ApplicationContext> mockContextSupplier;
	private Supplier<ApplicationContext> startupFailureSupplier;
	@BeforeEach
	void setup() {
		this.startupFailure = new RuntimeException();
		this.mockContextSupplier = () -> this.mockContext;
		this.startupFailureSupplier = () -> {
			throw this.startupFailure;
		};
	}
	@Test
	void getWhenTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(
				() -> ApplicationContextAssertProvider.get(null, ApplicationContext.class, this.mockContextSupplier))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void getWhenTypeIsClassShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(
				() -> ApplicationContextAssertProvider.get(null, ApplicationContext.class, this.mockContextSupplier))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void getWhenContextTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ApplicationContextAssertProvider.get(TestAssertProviderApplicationContextClass.class,
					ApplicationContext.class, this.mockContextSupplier))
			.withMessageContaining('Type must be an interface');
	}
	@Test
	void getWhenContextTypeIsClassShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ApplicationContextAssertProvider.get(TestAssertProviderApplicationContext.class, null,
					this.mockContextSupplier))
			.withMessageContaining('ContextType must not be null');
	}
	@Test
	void getWhenSupplierIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ApplicationContextAssertProvider.get(TestAssertProviderApplicationContext.class,
					StaticApplicationContext.class, this.mockContextSupplier))
			.withMessageContaining('ContextType must be an interface');
	}
	@Test
	void getWhenContextStartsShouldReturnProxyThatCallsRealMethods() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.mockContextSupplier);
		assertThat((Object) context).isNotNull();
		context.getBean('foo');
		then(this.mockContext).should().getBean('foo');
	}
	@Test
	void getWhenContextFailsShouldReturnProxyThatThrowsExceptions() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.startupFailureSupplier);
		assertThat((Object) context).isNotNull();
		assertThatIllegalStateException().isThrownBy(() -> context.getBean('foo'))
			.withCause(this.startupFailure)
			.withMessageContaining('failed to start');
	}
	@Test
	void getSourceContextWhenContextStartsShouldReturnSourceContext() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.mockContextSupplier);
		assertThat(context.getSourceApplicationContext()).isSameAs(this.mockContext);
	}
	@Test
	void getSourceContextWhenContextFailsShouldThrowException() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.startupFailureSupplier);
		assertThatIllegalStateException().isThrownBy(context::getSourceApplicationContext)
			.withCause(this.startupFailure)
			.withMessageContaining('failed to start');
	}
	@Test
	void getSourceContextOfTypeWhenContextStartsShouldReturnSourceContext() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.mockContextSupplier);
		assertThat(context.getSourceApplicationContext(ApplicationContext.class)).isSameAs(this.mockContext);
	}
	@Test
	void getSourceContextOfTypeWhenContextFailsToStartShouldThrowException() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.startupFailureSupplier);
		assertThatIllegalStateException()
			.isThrownBy(() -> context.getSourceApplicationContext(ApplicationContext.class))
			.withCause(this.startupFailure)
			.withMessageContaining('failed to start');
	}
	@Test
	void getStartupFailureWhenContextStartsShouldReturnNull() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.mockContextSupplier);
		assertThat(context.getStartupFailure()).isNull();
	}
	@Test
	void getStartupFailureWhenContextFailsToStartShouldReturnException() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.startupFailureSupplier);
		assertThat(context.getStartupFailure()).isEqualTo(this.startupFailure);
	}
	@Test
	void assertThatWhenContextStartsShouldReturnAssertions() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.mockContextSupplier);
		ApplicationContextAssert<ApplicationContext> contextAssert = assertThat(context);
		assertThat(contextAssert.getApplicationContext()).isSameAs(context);
		assertThat(contextAssert.getStartupFailure()).isNull();
	}
	@Test
	void assertThatWhenContextFailsShouldReturnAssertions() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.startupFailureSupplier);
		ApplicationContextAssert<ApplicationContext> contextAssert = assertThat(context);
		assertThat(contextAssert.getApplicationContext()).isSameAs(context);
		assertThat(contextAssert.getStartupFailure()).isSameAs(this.startupFailure);
	}
	@Test
	void toStringWhenContextStartsShouldReturnSimpleString() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.mockContextSupplier);
		assertThat(context.toString()).startsWith('Started application [ConfigurableApplicationContext.MockitoMock')
			.endsWith('id = [null], applicationName = [null], beanDefinitionCount = 0]');
	}
	@Test
	void toStringWhenContextFailsToStartShouldReturnSimpleString() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.startupFailureSupplier);
		assertThat(context).hasToString('Unstarted application context '
				+ 'org.springframework.context.ApplicationContext[startupFailure=java.lang.RuntimeException]');
	}
	@Test
	void closeShouldCloseContext() {
		ApplicationContextAssertProvider<ApplicationContext> context = get(this.mockContextSupplier);
		context.close();
		then(this.mockContext).should().close();
	}
	private ApplicationContextAssertProvider<ApplicationContext> get(Supplier<ApplicationContext> contextSupplier) {
		return ApplicationContextAssertProvider.get(TestAssertProviderApplicationContext.class,
				ApplicationContext.class, contextSupplier);
	}
	interface TestAssertProviderApplicationContext extends ApplicationContextAssertProvider<ApplicationContext> {
	}
	abstract static class TestAssertProviderApplicationContextClass implements TestAssertProviderApplicationContext {
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
class ApplicationContextAssertTests {
	private StaticApplicationContext parent;
	private StaticApplicationContext context;
	private final RuntimeException failure = new RuntimeException();
	@BeforeEach
	void setup() {
		this.parent = new StaticApplicationContext();
		this.context = new StaticApplicationContext();
		this.context.setParent(this.parent);
	}
	@AfterEach
	void cleanup() {
		this.context.close();
		this.parent.close();
	}
	@Test
	void createWhenApplicationContextIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ApplicationContextAssert<>(null, null))
			.withMessageContaining('ApplicationContext must not be null');
	}
	@Test
	void createWhenHasApplicationContextShouldSetActual() {
		assertThat(getAssert(this.context).getSourceApplicationContext()).isSameAs(this.context);
	}
	@Test
	void createWhenHasExceptionShouldSetFailure() {
		assertThat(getAssert(this.failure)).getFailure().isSameAs(this.failure);
	}
	@Test
	void hasBeanWhenHasBeanShouldPass() {
		this.context.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).hasBean('foo');
	}
	@Test
	void hasBeanWhenHasNoBeanShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).hasBean('foo'))
			.withMessageContaining('no such bean');
	}
	@Test
	void hasBeanWhenNotStartedShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).hasBean('foo'))
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void hasSingleBeanWhenHasSingleBeanShouldPass() {
		this.context.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).hasSingleBean(Foo.class);
	}
	@Test
	void hasSingleBeanWhenHasNoBeansShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).hasSingleBean(Foo.class))
			.withMessageContaining('to have a single bean of type');
	}
	@Test
	void hasSingleBeanWhenHasMultipleShouldFail() {
		this.context.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).hasSingleBean(Foo.class))
			.withMessageContaining('but found:');
	}
	@Test
	void hasSingleBeanWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).hasSingleBean(Foo.class))
			.withMessageContaining('to have a single bean of type')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void hasSingleBeanWhenInParentShouldFail() {
		this.parent.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).hasSingleBean(Foo.class))
			.withMessageContaining('but found:');
	}
	@Test
	void hasSingleBeanWithLimitedScopeWhenInParentShouldPass() {
		this.parent.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThat(getAssert(this.context)).hasSingleBean(Foo.class, Scope.NO_ANCESTORS);
	}
	@Test
	void doesNotHaveBeanOfTypeWhenHasNoBeanOfTypeShouldPass() {
		assertThat(getAssert(this.context)).doesNotHaveBean(Foo.class);
	}
	@Test
	void doesNotHaveBeanOfTypeWhenHasBeanOfTypeShouldFail() {
		this.context.registerSingleton('foo', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).doesNotHaveBean(Foo.class))
			.withMessageContaining('but found');
	}
	@Test
	void doesNotHaveBeanOfTypeWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).doesNotHaveBean(Foo.class))
			.withMessageContaining('not to have any beans of type')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void doesNotHaveBeanOfTypeWhenInParentShouldFail() {
		this.parent.registerSingleton('foo', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).doesNotHaveBean(Foo.class))
			.withMessageContaining('but found');
	}
	@Test
	void doesNotHaveBeanOfTypeWithLimitedScopeWhenInParentShouldPass() {
		this.parent.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).doesNotHaveBean(Foo.class, Scope.NO_ANCESTORS);
	}
	@Test
	void doesNotHaveBeanOfNameWhenHasNoBeanOfTypeShouldPass() {
		assertThat(getAssert(this.context)).doesNotHaveBean('foo');
	}
	@Test
	void doesNotHaveBeanOfNameWhenHasBeanOfTypeShouldFail() {
		this.context.registerSingleton('foo', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).doesNotHaveBean('foo'))
			.withMessageContaining('but found');
	}
	@Test
	void doesNotHaveBeanOfNameWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).doesNotHaveBean('foo'))
			.withMessageContaining('not to have any beans of name')
			.withMessageContaining('failed to start');
	}
	@Test
	void getBeanNamesWhenHasNamesShouldReturnNamesAssert() {
		this.context.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThat(getAssert(this.context)).getBeanNames(Foo.class).containsOnly('foo', 'bar');
	}
	@Test
	void getBeanNamesWhenHasNoNamesShouldReturnEmptyAssert() {
		assertThat(getAssert(this.context)).getBeanNames(Foo.class).isEmpty();
	}
	@Test
	void getBeanNamesWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).doesNotHaveBean('foo'))
			.withMessageContaining('not to have any beans of name')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void getBeanOfTypeWhenHasBeanShouldReturnBeanAssert() {
		this.context.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).getBean(Foo.class).isNotNull();
	}
	@Test
	void getBeanOfTypeWhenHasNoBeanShouldReturnNullAssert() {
		assertThat(getAssert(this.context)).getBean(Foo.class).isNull();
	}
	@Test
	void getBeanOfTypeWhenHasMultipleBeansShouldFail() {
		this.context.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).getBean(Foo.class))
			.withMessageContaining('but found');
	}
	@Test
	void getBeanOfTypeWhenHasPrimaryBeanShouldReturnPrimary() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PrimaryFooConfig.class);
		assertThat(getAssert(context)).getBean(Foo.class).isInstanceOf(Bar.class);
		context.close();
	}
	@Test
	void getBeanOfTypeWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).getBean(Foo.class))
			.withMessageContaining('to contain bean of type')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void getBeanOfTypeWhenInParentShouldReturnBeanAssert() {
		this.parent.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).getBean(Foo.class).isNotNull();
	}
	@Test
	void getBeanOfTypeWhenInParentWithLimitedScopeShouldReturnNullAssert() {
		this.parent.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).getBean(Foo.class, Scope.NO_ANCESTORS).isNull();
	}
	@Test
	void getBeanOfTypeWhenHasMultipleBeansIncludingParentShouldFail() {
		this.parent.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).getBean(Foo.class))
			.withMessageContaining('but found');
	}
	@Test
	void getBeanOfTypeWithLimitedScopeWhenHasMultipleBeansIncludingParentShouldReturnBeanAssert() {
		this.parent.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThat(getAssert(this.context)).getBean(Foo.class, Scope.NO_ANCESTORS).isNotNull();
	}
	@Test
	void getBeanOfNameWhenHasBeanShouldReturnBeanAssert() {
		this.context.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).getBean('foo').isNotNull();
	}
	@Test
	void getBeanOfNameWhenHasNoBeanOfNameShouldReturnNullAssert() {
		assertThat(getAssert(this.context)).getBean('foo').isNull();
	}
	@Test
	void getBeanOfNameWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).getBean('foo'))
			.withMessageContaining('to contain a bean of name')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void getBeanOfNameAndTypeWhenHasBeanShouldReturnBeanAssert() {
		this.context.registerSingleton('foo', Foo.class);
		assertThat(getAssert(this.context)).getBean('foo', Foo.class).isNotNull();
	}
	@Test
	void getBeanOfNameAndTypeWhenHasNoBeanOfNameShouldReturnNullAssert() {
		assertThat(getAssert(this.context)).getBean('foo', Foo.class).isNull();
	}
	@Test
	void getBeanOfNameAndTypeWhenHasNoBeanOfNameButDifferentTypeShouldFail() {
		this.context.registerSingleton('foo', Foo.class);
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).getBean('foo', String.class))
			.withMessageContaining('of type');
	}
	@Test
	void getBeanOfNameAndTypeWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).getBean('foo', Foo.class))
			.withMessageContaining('to contain a bean of name')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void getBeansWhenHasBeansShouldReturnMapAssert() {
		this.context.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThat(getAssert(this.context)).getBeans(Foo.class).hasSize(2).containsKeys('foo', 'bar');
	}
	@Test
	void getBeansWhenHasNoBeansShouldReturnEmptyMapAssert() {
		assertThat(getAssert(this.context)).getBeans(Foo.class).isEmpty();
	}
	@Test
	void getBeansWhenFailedToStartShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).getBeans(Foo.class))
			.withMessageContaining('to get beans of type')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void getBeansShouldIncludeBeansFromParentScope() {
		this.parent.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThat(getAssert(this.context)).getBeans(Foo.class).hasSize(2).containsKeys('foo', 'bar');
	}
	@Test
	void getBeansWithLimitedScopeShouldNotIncludeBeansFromParentScope() {
		this.parent.registerSingleton('foo', Foo.class);
		this.context.registerSingleton('bar', Foo.class);
		assertThat(getAssert(this.context)).getBeans(Foo.class, Scope.NO_ANCESTORS).hasSize(1).containsKeys('bar');
	}
	@Test
	void getFailureWhenFailedShouldReturnFailure() {
		assertThat(getAssert(this.failure)).getFailure().isSameAs(this.failure);
	}
	@Test
	void getFailureWhenDidNotFailShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).getFailure())
			.withMessageContaining('context started');
	}
	@Test
	void hasFailedWhenFailedShouldPass() {
		assertThat(getAssert(this.failure)).hasFailed();
	}
	@Test
	void hasFailedWhenNotFailedShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.context)).hasFailed())
			.withMessageContaining('to have failed');
	}
	@Test
	void hasNotFailedWhenFailedShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(getAssert(this.failure)).hasNotFailed())
			.withMessageContaining('to have not failed')
			.withMessageContaining(String.format('but context failed to start:%n java.lang.RuntimeException'));
	}
	@Test
	void hasNotFailedWhenNotFailedShouldPass() {
		assertThat(getAssert(this.context)).hasNotFailed();
	}
	private AssertableApplicationContext getAssert(ConfigurableApplicationContext applicationContext) {
		return AssertableApplicationContext.get(() -> applicationContext);
	}
	private AssertableApplicationContext getAssert(RuntimeException failure) {
		return AssertableApplicationContext.get(() -> {
			throw failure;
		});
	}
	static class Foo {
	}
	static class Bar extends Foo {
	}
	@Configuration(proxyBeanMethods = false)
	static class PrimaryFooConfig {
		@Bean
		Foo foo() {
			return new Foo();
		}
		@Bean
		@Primary
		Bar bar() {
			return new Bar();
		}
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
interface AdditionalContextInterface {
}
/*
package org.springframework.boot.test.context.assertj;
/**
class AssertableReactiveWebApplicationContextTests {
	@Test
	void getShouldReturnProxy() {
		AssertableReactiveWebApplicationContext context = AssertableReactiveWebApplicationContext
			.get(() -> mock(ConfigurableReactiveWebApplicationContext.class));
		assertThat(context).isInstanceOf(ConfigurableReactiveWebApplicationContext.class);
	}
	@Test
	void getWhenHasAdditionalInterfaceShouldReturnProxy() {
		AssertableReactiveWebApplicationContext context = AssertableReactiveWebApplicationContext.get(
				() -> mock(ConfigurableReactiveWebApplicationContext.class,
						withSettings().extraInterfaces(AdditionalContextInterface.class)),
				AdditionalContextInterface.class);
		assertThat(context).isInstanceOf(ConfigurableReactiveWebApplicationContext.class)
			.isInstanceOf(AdditionalContextInterface.class);
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
class AssertableWebApplicationContextTests {
	@Test
	void getShouldReturnProxy() {
		AssertableWebApplicationContext context = AssertableWebApplicationContext
			.get(() -> mock(ConfigurableWebApplicationContext.class));
		assertThat(context).isInstanceOf(ConfigurableWebApplicationContext.class);
	}
	@Test
	void getWhenHasAdditionalInterfaceShouldReturnProxy() {
		ConfigurableWebApplicationContext context = AssertableWebApplicationContext.get(
				() -> mock(ConfigurableWebApplicationContext.class,
						withSettings().extraInterfaces(AdditionalContextInterface.class)),
				AdditionalContextInterface.class);
		assertThat(context).isInstanceOf(ConfigurableWebApplicationContext.class)
			.isInstanceOf(AdditionalContextInterface.class);
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
class AssertableApplicationContextTests {
	@Test
	void getShouldReturnProxy() {
		AssertableApplicationContext context = AssertableApplicationContext
			.get(() -> mock(ConfigurableApplicationContext.class));
		assertThat(context).isInstanceOf(ConfigurableApplicationContext.class);
	}
	@Test
	void getWhenHasAdditionalInterfaceShouldReturnProxy() {
		AssertableApplicationContext context = AssertableApplicationContext.get(
				() -> mock(ConfigurableApplicationContext.class,
						withSettings().extraInterfaces(AdditionalContextInterface.class)),
				AdditionalContextInterface.class);
		assertThat(context).isInstanceOf(ConfigurableApplicationContext.class)
			.isInstanceOf(AdditionalContextInterface.class);
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest
@ContextConfiguration(locations = 'classpath:test.groovy')
class SpringBootTestGroovyConfigurationTests {
	@Autowired
	private String foo;
	@Test
	void groovyConfigLoaded() {
		assertThat(this.foo).isNotNull();
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest(properties = 'test=123', useMainMethod = UseMainMethod.ALWAYS)
class SpringBootTestUseMainMethodWithPropertiesTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void propertyIsSet() {
		assertThat(this.applicationContext.getEnvironment().getProperty('test')).isEqualTo('123');
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	public static class ConfigWithMain {
		public static void main(String[] args) {
			new SpringApplication(ConfigWithMain.class).run();
		}
	}
}
/*
package org.springframework.boot.test.context.filter;
class JupiterTestExample {
	@Test
	void repeatedTest() {
	}
}
/*
package org.springframework.boot.test.context.filter;
class JupiterRepeatedTestExample {
	@RepeatedTest(5)
	void repeatedTest() {
	}
}
/*
package org.springframework.boot.test.context.filter;
@ExtendWith(SpringExtension.class)
public abstract class AbstractJupiterTestWithConfigAndExtendWith {
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context.filter;
/**
class ExcludeFilterApplicationContextInitializerTests {
	@Test
	void testConfigurationIsExcluded() {
		SpringApplication application = new SpringApplication(TestApplication.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		AssertableApplicationContext applicationContext = AssertableApplicationContext.get(application::run);
		assertThat(applicationContext).hasSingleBean(TestApplication.class);
		assertThat(applicationContext).doesNotHaveBean(ExcludedTestConfiguration.class);
	}
	@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class) })
	static class TestApplication {
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class ExcludedTestConfiguration {
	}
}
/*
package org.springframework.boot.test.context.filter;
class JupiterTestFactoryExample {
	@TestFactory
	Collection<DynamicNode> testFactory() {
		return Arrays.asList(DynamicTest.dynamicTest('Some dynamic test', () -> {
			// Test
		}));
	}
}
/*
package org.springframework.boot.test.context.filter;
/**
@ExtendWith(SpringExtension.class)
public abstract class AbstractTestWithConfigAndRunWith {
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context.filter;
@Test
public abstract class AbstractTestNgTestWithConfig {
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context.filter;
@Testable
public abstract class AbstractJupiterTestWithConfigAndTestable {
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context.filter;
/**
class TestTypeExcludeFilterTests {
	private final TestTypeExcludeFilter filter = new TestTypeExcludeFilter();
	private final MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
	@Test
	void matchesJUnit4TestClass() throws Exception {
		assertThat(this.filter.match(getMetadataReader(TestTypeExcludeFilterTests.class), this.metadataReaderFactory))
			.isTrue();
	}
	@Test
	void matchesJUnitJupiterTestClass() throws Exception {
		assertThat(this.filter.match(getMetadataReader(JupiterTestExample.class), this.metadataReaderFactory)).isTrue();
	}
	@Test
	void matchesJUnitJupiterRepeatedTestClass() throws Exception {
		assertThat(this.filter.match(getMetadataReader(JupiterRepeatedTestExample.class), this.metadataReaderFactory))
			.isTrue();
	}
	@Test
	void matchesJUnitJupiterTestFactoryClass() throws Exception {
		assertThat(this.filter.match(getMetadataReader(JupiterTestFactoryExample.class), this.metadataReaderFactory))
			.isTrue();
	}
	@Test
	void matchesNestedConfiguration() throws Exception {
		assertThat(this.filter.match(getMetadataReader(NestedConfig.class), this.metadataReaderFactory)).isTrue();
	}
	@Test
	void matchesNestedConfigurationClassWithoutTestMethodsIfItHasRunWith() throws Exception {
		assertThat(this.filter.match(getMetadataReader(AbstractTestWithConfigAndRunWith.Config.class),
				this.metadataReaderFactory))
			.isTrue();
	}
	@Test
	void matchesNestedConfigurationClassWithoutTestMethodsIfItHasExtendWith() throws Exception {
		assertThat(this.filter.match(getMetadataReader(AbstractJupiterTestWithConfigAndExtendWith.Config.class),
				this.metadataReaderFactory))
			.isTrue();
	}
	@Test
	void matchesNestedConfigurationClassWithoutTestMethodsIfItHasTestable() throws Exception {
		assertThat(this.filter.match(getMetadataReader(AbstractJupiterTestWithConfigAndTestable.Config.class),
				this.metadataReaderFactory))
			.isTrue();
	}
	@Test
	void matchesTestConfiguration() throws Exception {
		assertThat(this.filter.match(getMetadataReader(SampleTestConfig.class), this.metadataReaderFactory)).isTrue();
	}
	@Test
	void doesNotMatchRegularConfiguration() throws Exception {
		assertThat(this.filter.match(getMetadataReader(SampleConfig.class), this.metadataReaderFactory)).isFalse();
	}
	@Test
	void matchesNestedConfigurationClassWithoutTestNgAnnotation() throws Exception {
		assertThat(this.filter.match(getMetadataReader(AbstractTestNgTestWithConfig.Config.class),
				this.metadataReaderFactory))
			.isTrue();
	}
	private MetadataReader getMetadataReader(Class<?> source) throws IOException {
		return this.metadataReaderFactory.getMetadataReader(source.getName());
	}
	@Configuration(proxyBeanMethods = false)
	static class NestedConfig {
	}
}
/*
package org.springframework.boot.test.context.filter;
@Configuration(proxyBeanMethods = false)
@TestComponent
public class SampleTestConfig {
}
/*
package org.springframework.boot.test.context.filter;
@Configuration(proxyBeanMethods = false)
public class SampleConfig {
}
/*
package org.springframework.boot.test.context;
/**
@ExtendWith(SpringExtension.class)
@DirtiesContext
@TestPropertySource(properties = 'spring.config.use-legacy-processing=true')
@ContextConfiguration(classes = ConfigDataApplicationContextInitializerWithLegacySwitchTests.Config.class,
		initializers = ConfigDataApplicationContextInitializer.class)
class ConfigDataApplicationContextInitializerWithLegacySwitchTests {
	@Autowired
	private Environment environment;
	@Test
	void initializerPopulatesEnvironment() {
		assertThat(this.environment.getProperty('foo')).isEqualTo('bucket');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context;
/**
class SpringBootContextLoaderTests {
	@BeforeEach
	void setUp() {
		ContextLoaderApplicationContextFailureProcessor.reset();
	}
	@Test
	void environmentPropertiesSimple() {
		Map<String, Object> config = getMergedContextConfigurationProperties(SimpleConfig.class);
		assertKey(config, 'key', 'myValue');
		assertKey(config, 'anotherKey', 'anotherValue');
	}
	@Test
	void environmentPropertiesSimpleNonAlias() {
		Map<String, Object> config = getMergedContextConfigurationProperties(SimpleConfigNonAlias.class);
		assertKey(config, 'key', 'myValue');
		assertKey(config, 'anotherKey', 'anotherValue');
	}
	@Test
	void environmentPropertiesOverrideDefaults() {
		Map<String, Object> config = getMergedContextConfigurationProperties(OverrideConfig.class);
		assertKey(config, 'server.port', '2345');
	}
	@Test
	void environmentPropertiesAppend() {
		Map<String, Object> config = getMergedContextConfigurationProperties(AppendConfig.class);
		assertKey(config, 'key', 'myValue');
		assertKey(config, 'otherKey', 'otherValue');
	}
	@Test
	void environmentPropertiesSeparatorInValue() {
		Map<String, Object> config = getMergedContextConfigurationProperties(SameSeparatorInValue.class);
		assertKey(config, 'key', 'my=Value');
		assertKey(config, 'anotherKey', 'another:Value');
	}
	@Test
	void environmentPropertiesAnotherSeparatorInValue() {
		Map<String, Object> config = getMergedContextConfigurationProperties(AnotherSeparatorInValue.class);
		assertKey(config, 'key', 'my:Value');
		assertKey(config, 'anotherKey', 'another=Value');
	}
	@Test // gh-4384
	@Disabled
	void environmentPropertiesNewLineInValue() {
		Map<String, Object> config = getMergedContextConfigurationProperties(NewLineInValue.class);
		assertKey(config, 'key', 'myValue');
		assertKey(config, 'variables', 'foo=FOO\n bar=BAR');
	}
	@Test
	void noActiveProfiles() {
		assertThat(getActiveProfiles(SimpleConfig.class)).isEmpty();
	}
	@Test
	void multipleActiveProfiles() {
		assertThat(getActiveProfiles(MultipleActiveProfiles.class)).containsExactly('profile1', 'profile2');
	}
	@Test
	void activeProfileWithComma() {
		assertThat(getActiveProfiles(ActiveProfileWithComma.class)).containsExactly('profile1,2');
	}
	@Test // gh-28776
	void testPropertyValuesShouldTakePrecedenceWhenInlinedPropertiesPresent() {
		TestContext context = new ExposedTestContextManager(SimpleConfig.class).getExposedTestContext();
		StandardEnvironment environment = (StandardEnvironment) context.getApplicationContext().getEnvironment();
		TestPropertyValues.of('key=thisValue').applyTo(environment);
		assertThat(environment.getProperty('key')).isEqualTo('thisValue');
		assertThat(environment.getPropertySources().get('active-test-profiles')).isNull();
	}
	@Test
	void testPropertyValuesShouldTakePrecedenceWhenInlinedPropertiesPresentAndProfilesActive() {
		TestContext context = new ExposedTestContextManager(ActiveProfileWithInlinedProperties.class)
			.getExposedTestContext();
		StandardEnvironment environment = (StandardEnvironment) context.getApplicationContext().getEnvironment();
		TestPropertyValues.of('key=thisValue').applyTo(environment);
		assertThat(environment.getProperty('key')).isEqualTo('thisValue');
		assertThat(environment.getPropertySources().get('active-test-profiles')).isNotNull();
	}
	@Test
	void propertySourceOrdering() {
		TestContext context = new ExposedTestContextManager(PropertySourceOrdering.class).getExposedTestContext();
		ConfigurableEnvironment environment = (ConfigurableEnvironment) context.getApplicationContext()
			.getEnvironment();
		List<String> names = environment.getPropertySources()
			.stream()
			.map(PropertySource::getName)
			.collect(Collectors.toCollection(ArrayList::new));
		String configResource = names.remove(names.size() - 2);
		assertThat(names).containsExactly('configurationProperties', 'Inlined Test Properties', 'commandLineArgs',
				'servletConfigInitParams', 'servletContextInitParams', 'systemProperties', 'systemEnvironment',
				'random', 'applicationInfo');
		assertThat(configResource).startsWith('Config resource');
	}
	@Test
	void whenEnvironmentChangesWebApplicationTypeToNoneThenContextTypeChangesAccordingly() {
		TestContext context = new ExposedTestContextManager(ChangingWebApplicationTypeToNone.class)
			.getExposedTestContext();
		assertThat(context.getApplicationContext()).isNotInstanceOf(WebApplicationContext.class);
	}
	@Test
	void whenEnvironmentChangesWebApplicationTypeToReactiveThenContextTypeChangesAccordingly() {
		TestContext context = new ExposedTestContextManager(ChangingWebApplicationTypeToReactive.class)
			.getExposedTestContext();
		assertThat(context.getApplicationContext()).isInstanceOf(GenericReactiveWebApplicationContext.class);
	}
	@Test
	void whenUseMainMethodAlwaysAndMainMethodThrowsException() {
		TestContext testContext = new ExposedTestContextManager(UseMainMethodAlwaysAndMainMethodThrowsException.class)
			.getExposedTestContext();
		assertThatIllegalStateException().isThrownBy(testContext::getApplicationContext)
			.havingCause()
			.withMessageContaining('ThrownFromMain');
	}
	@Test
	void whenUseMainMethodWhenAvailableAndNoMainMethod() {
		TestContext testContext = new ExposedTestContextManager(UseMainMethodWhenAvailableAndNoMainMethod.class)
			.getExposedTestContext();
		ApplicationContext applicationContext = testContext.getApplicationContext();
		assertThat(applicationContext.getEnvironment().getActiveProfiles()).isEmpty();
	}
	@Test
	void whenUseMainMethodWhenAvailableAndMainMethod() {
		TestContext testContext = new ExposedTestContextManager(UseMainMethodWhenAvailableAndMainMethod.class)
			.getExposedTestContext();
		ApplicationContext applicationContext = testContext.getApplicationContext();
		assertThat(applicationContext.getEnvironment().getActiveProfiles()).contains('frommain');
	}
	@Test
	void whenUseMainMethodNever() {
		TestContext testContext = new ExposedTestContextManager(UseMainMethodNever.class).getExposedTestContext();
		ApplicationContext applicationContext = testContext.getApplicationContext();
		assertThat(applicationContext.getEnvironment().getActiveProfiles()).isEmpty();
	}
	@Test
	void whenUseMainMethodWithBeanThrowingException() {
		TestContext testContext = new ExposedTestContextManager(UseMainMethodWithBeanThrowingException.class)
			.getExposedTestContext();
		assertThatIllegalStateException().isThrownBy(testContext::getApplicationContext)
			.havingCause()
			.satisfies((exception) -> {
				assertThat(exception).isInstanceOf(BeanCreationException.class);
				assertThat(exception).isSameAs(ContextLoaderApplicationContextFailureProcessor.contextLoadException);
			});
		assertThat(ContextLoaderApplicationContextFailureProcessor.failedContext).isNotNull();
	}
	@Test
	void whenNoMainMethodWithBeanThrowingException() {
		TestContext testContext = new ExposedTestContextManager(NoMainMethodWithBeanThrowingException.class)
			.getExposedTestContext();
		assertThatIllegalStateException().isThrownBy(testContext::getApplicationContext)
			.havingCause()
			.satisfies((exception) -> {
				assertThat(exception).isInstanceOf(BeanCreationException.class);
				assertThat(exception).isSameAs(ContextLoaderApplicationContextFailureProcessor.contextLoadException);
			});
		assertThat(ContextLoaderApplicationContextFailureProcessor.failedContext).isNotNull();
	}
	@Test
	void whenUseMainMethodWithContextHierarchyThrowsException() {
		TestContext testContext = new ExposedTestContextManager(UseMainMethodWithContextHierarchy.class)
			.getExposedTestContext();
		assertThatIllegalStateException().isThrownBy(testContext::getApplicationContext)
			.havingCause()
			.withMessage('UseMainMethod.ALWAYS cannot be used with @ContextHierarchy tests');
	}
	@Test
	void whenSubclassProvidesCustomApplicationContextFactory() {
		TestContext testContext = new ExposedTestContextManager(CustomApplicationContextTest.class)
			.getExposedTestContext();
		assertThat(testContext.getApplicationContext()).isInstanceOf(CustomAnnotationConfigApplicationContext.class);
	}
	private String[] getActiveProfiles(Class<?> testClass) {
		TestContext testContext = new ExposedTestContextManager(testClass).getExposedTestContext();
		ApplicationContext applicationContext = testContext.getApplicationContext();
		return applicationContext.getEnvironment().getActiveProfiles();
	}
	private Map<String, Object> getMergedContextConfigurationProperties(Class<?> testClass) {
		TestContext context = new ExposedTestContextManager(testClass).getExposedTestContext();
		MergedContextConfiguration config = (MergedContextConfiguration) ReflectionTestUtils.getField(context,
				'mergedConfig');
		return TestPropertySourceUtils.convertInlinedPropertiesToMap(config.getPropertySourceProperties());
	}
	private void assertKey(Map<String, Object> actual, String key, Object value) {
		assertThat(actual).as('Key "' + key + '" not found').containsKey(key);
		assertThat(actual).containsEntry(key, value);
	}
	@SpringBootTest(properties = { 'key=myValue', 'anotherKey:anotherValue' }, classes = Config.class)
	static class SimpleConfig {
	}
	@SpringBootTest(properties = { 'key=myValue', 'anotherKey:anotherValue' }, classes = Config.class)
	static class SimpleConfigNonAlias {
	}
	@SpringBootTest(properties = 'server.port=2345', classes = Config.class)
	static class OverrideConfig {
	}
	@SpringBootTest(properties = { 'key=myValue', 'otherKey=otherValue' }, classes = Config.class)
	static class AppendConfig {
	}
	@SpringBootTest(properties = { 'key=my=Value', 'anotherKey:another:Value' }, classes = Config.class)
	static class SameSeparatorInValue {
	}
	@SpringBootTest(properties = { 'key=my:Value', 'anotherKey:another=Value' }, classes = Config.class)
	static class AnotherSeparatorInValue {
	}
	@SpringBootTest(properties = { 'key=myValue', 'variables=foo=FOO\n bar=BAR' }, classes = Config.class)
	static class NewLineInValue {
	}
	@SpringBootTest(classes = Config.class)
	@ActiveProfiles({ 'profile1', 'profile2' })
	static class MultipleActiveProfiles {
	}
	@SpringBootTest(classes = Config.class)
	@ActiveProfiles({ 'profile1,2' })
	static class ActiveProfileWithComma {
	}
	@SpringBootTest(properties = { 'key=myValue' }, classes = Config.class)
	@ActiveProfiles({ 'profile1,2' })
	static class ActiveProfileWithInlinedProperties {
	}
	@SpringBootTest(classes = Config.class, args = 'args', properties = 'one=1')
	@TestPropertySource(properties = 'two=2')
	static class PropertySourceOrdering {
	}
	@SpringBootTest(classes = Config.class, args = '--spring.main.web-application-type=none')
	static class ChangingWebApplicationTypeToNone {
	}
	@SpringBootTest(classes = Config.class, args = '--spring.main.web-application-type=reactive')
	static class ChangingWebApplicationTypeToReactive {
	}
	@SpringBootTest(classes = ConfigWithMainThrowingException.class, useMainMethod = UseMainMethod.ALWAYS)
	static class UseMainMethodAlwaysAndMainMethodThrowsException {
	}
	@SpringBootTest(classes = ConfigWithNoMain.class, useMainMethod = UseMainMethod.WHEN_AVAILABLE)
	static class UseMainMethodWhenAvailableAndNoMainMethod {
	}
	@SpringBootTest(classes = ConfigWithMain.class, useMainMethod = UseMainMethod.WHEN_AVAILABLE)
	static class UseMainMethodWhenAvailableAndMainMethod {
	}
	@SpringBootTest(classes = ConfigWithMain.class, useMainMethod = UseMainMethod.NEVER)
	static class UseMainMethodNever {
	}
	@SpringBootTest(classes = ConfigWithMainWithBeanThrowingException.class, useMainMethod = UseMainMethod.ALWAYS)
	static class UseMainMethodWithBeanThrowingException {
	}
	@SpringBootTest(classes = ConfigWithNoMainWithBeanThrowingException.class, useMainMethod = UseMainMethod.NEVER)
	static class NoMainMethodWithBeanThrowingException {
	}
	@SpringBootTest(useMainMethod = UseMainMethod.ALWAYS)
	@ContextHierarchy({ @ContextConfiguration(classes = ConfigWithMain.class),
			@ContextConfiguration(classes = AnotherConfigWithMain.class) })
	static class UseMainMethodWithContextHierarchy {
	}
	@SpringBootTest
	@ContextConfiguration(classes = Config.class, loader = CustomApplicationContextSpringBootContextLoader.class)
	static class CustomApplicationContextTest {
	}
	static class CustomApplicationContextSpringBootContextLoader extends SpringBootContextLoader {
		@Override
		protected ApplicationContextFactory getApplicationContextFactory(MergedContextConfiguration mergedConfig) {
			return (webApplicationType) -> new CustomAnnotationConfigApplicationContext();
		}
	}
	static class CustomAnnotationConfigApplicationContext extends AnnotationConfigApplicationContext {
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	public static class ConfigWithMain {
		public static void main(String[] args) {
			new SpringApplication(ConfigWithMain.class).run('--spring.profiles.active=frommain');
		}
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	public static class AnotherConfigWithMain {
		public static void main(String[] args) {
			new SpringApplication(AnotherConfigWithMain.class).run('--spring.profiles.active=anotherfrommain');
		}
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	static class ConfigWithNoMain {
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	public static class ConfigWithMainWithBeanThrowingException {
		public static void main(String[] args) {
			new SpringApplication(ConfigWithMainWithBeanThrowingException.class).run();
		}
		@Bean
		String failContextLoad() {
			throw new RuntimeException('ThrownFromBeanMethod');
		}
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	static class ConfigWithNoMainWithBeanThrowingException {
		@Bean
		String failContextLoad() {
			throw new RuntimeException('ThrownFromBeanMethod');
		}
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	public static class ConfigWithMainThrowingException {
		public static void main(String[] args) {
			throw new RuntimeException('ThrownFromMain');
		}
	}
	/**
	 * {@link TestContextManager} which exposes the {@link TestContext}.
	 */
	static class ExposedTestContextManager extends TestContextManager {
		ExposedTestContextManager(Class<?> testClass) {
			super(testClass);
		}
		final TestContext getExposedTestContext() {
			return super.getTestContext();
		}
	}
	private static final class ContextLoaderApplicationContextFailureProcessor
			implements ApplicationContextFailureProcessor {
		static ApplicationContext failedContext;
		static Throwable contextLoadException;
		@Override
		public void processLoadFailure(ApplicationContext context, Throwable exception) {
			failedContext = context;
			contextLoadException = exception;
		}
		private static void reset() {
			failedContext = null;
			contextLoadException = null;
		}
	}
}
/*
package org.springframework.boot.test.context.example;
/**
@SpringBootConfiguration
public class ExampleConfig {
}
/*
package org.springframework.boot.test.context.example.scan;
/**
public class Example {
}
/*
package org.springframework.boot.test.context.example.scan.sub;
/**
@SpringBootConfiguration
public class SubExampleConfig {
}
/*
package org.springframework.boot.test.context;
/**
class TestConfigurationTests {
	@Test
	void proxyBeanMethodsIsEnabledByDefault() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(DefaultTestConfiguration.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', true);
	}
	@Test
	void proxyBeanMethodsCanBeDisabled() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(NoBeanMethodProxyingTestConfiguration.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', false);
	}
	@TestConfiguration
	static class DefaultTestConfiguration {
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class NoBeanMethodProxyingTestConfiguration {
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest(args = { '--option.foo=foo-value', 'other.bar=other-bar-value' })
class SpringBootTestArgsTests {
	@Autowired
	private ApplicationArguments args;
	@Test
	void applicationArgumentsPopulated() {
		assertThat(this.args.getOptionNames()).containsOnly('option.foo');
		assertThat(this.args.getOptionValues('option.foo')).containsOnly('foo-value');
		assertThat(this.args.getNonOptionArgs()).containsOnly('other.bar=other-bar-value');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context;
/**
abstract class AbstractSpringBootTestEmbeddedReactiveWebEnvironmentTests {
	@LocalServerPort
	private int port = 0;
	@Value('${value}')
	private int value = 0;
	@Autowired
	private ReactiveWebApplicationContext context;
	@Autowired
	private WebTestClient webClient;
	@Autowired
	private TestRestTemplate restTemplate;
	ReactiveWebApplicationContext getContext() {
		return this.context;
	}
	@Test
	void runAndTestHttpEndpoint() {
		assertThat(this.port).isNotEqualTo(8080).isNotZero();
		WebTestClient.bindToServer()
			.baseUrl('http://localhost:' + this.port)
			.responseTimeout(Duration.ofMinutes(5))
			.build()
			.get()
			.uri('/')
			.exchange()
			.expectBody(String.class)
			.isEqualTo('Hello World');
	}
	@Test
	void injectWebTestClient() {
		this.webClient.get().uri('/').exchange().expectBody(String.class).isEqualTo('Hello World');
	}
	@Test
	void injectTestRestTemplate() {
		String body = this.restTemplate.getForObject('/', String.class);
		assertThat(body).isEqualTo('Hello World');
	}
	@Test
	void annotationAttributesOverridePropertiesFile() {
		assertThat(this.value).isEqualTo(123);
	}
	@Configuration(proxyBeanMethods = false)
	static class AbstractConfig {
		@Value('${server.port:8080}')
		private int port = 8080;
		@Bean
		HttpHandler httpHandler(ApplicationContext applicationContext) {
			return WebHttpHandlerBuilder.applicationContext(applicationContext).build();
		}
		@Bean
		ReactiveWebServerFactory webServerFactory() {
			TomcatReactiveWebServerFactory factory = new TomcatReactiveWebServerFactory();
			factory.setPort(this.port);
			return factory;
		}
		@Bean
		static PropertySourcesPlaceholderConfigurer propertyPlaceholder() {
			return new PropertySourcesPlaceholderConfigurer();
		}
		@RequestMapping('/')
		Mono<String> home() {
			return Mono.just('Hello World');
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest('value=123')
@DirtiesContext
class SpringBootTestWebEnvironmentMockTests {
	@Value('${value}')
	private int value = 0;
	@Autowired
	private WebApplicationContext context;
	@Autowired
	private ServletContext servletContext;
	@Test
	void annotationAttributesOverridePropertiesFile() {
		assertThat(this.value).isEqualTo(123);
	}
	@Test
	void validateWebApplicationContextIsSet() {
		WebApplicationContext fromServletContext = WebApplicationContextUtils
			.getWebApplicationContext(this.servletContext);
		assertThat(fromServletContext).isSameAs(this.context);
	}
	@Test
	void setsRequestContextHolder() {
		RequestAttributes attributes = RequestContextHolder.getRequestAttributes();
		assertThat(attributes).isNotNull();
	}
	@Test
	void resourcePath() {
		assertThat(this.servletContext).hasFieldOrPropertyWithValue('resourceBasePath', 'src/main/webapp');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class Config {
		@Bean
		static PropertySourcesPlaceholderConfigurer propertyPlaceholder() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@ExtendWith(SpringExtension.class)
@Import(ImportedBean.class)
class ImportsContextCustomizerFactoryIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private ImportedBean bean;
	@Test
	void beanWasImported() {
		assertThat(this.bean).isNotNull();
	}
	@Test
	void testItselfIsNotABean() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(getClass()));
	}
	@Component
	static class ImportedBean {
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'server.port=12345' })
class SpringBootTestWebEnvironmentRandomPortCustomPortTests {
	@Autowired
	private Environment environment;
	@Test
	void validatePortIsNotOverwritten() {
		String port = this.environment.getProperty('server.port');
		assertThat(port).isEqualTo('0');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class Config extends AbstractConfig {
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'spring.main.webApplicationType=reactive', 'value=123' })
public class SpringBootTestReactiveWebEnvironmentRandomPortTests
		extends AbstractSpringBootTestEmbeddedReactiveWebEnvironmentTests {
	@Configuration(proxyBeanMethods = false)
	@EnableWebFlux
	@RestController
	static class Config extends AbstractConfig {
	}
}
/*
package org.springframework.boot.test.context;
/**
@ExtendWith(SpringExtension.class)
@DirtiesContext
@ContextConfiguration(classes = ConfigDataApplicationContextInitializerTests.Config.class,
		initializers = ConfigDataApplicationContextInitializer.class)
class ConfigDataApplicationContextInitializerTests {
	@Autowired
	private Environment environment;
	@Test
	void initializerPopulatesEnvironment() {
		assertThat(this.environment.getProperty('foo')).isEqualTo('bucket');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context;
/**
class FilteredClassLoaderTests {
	static ClassPathResource TEST_RESOURCE = new ClassPathResource(
			'org/springframework/boot/test/context/FilteredClassLoaderTestsResource.txt');
	@Test
	void loadClassWhenFilteredOnPackageShouldThrowClassNotFound() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader(
				FilteredClassLoaderTests.class.getPackage().getName())) {
			assertThatExceptionOfType(ClassNotFoundException.class)
				.isThrownBy(() -> Class.forName(getClass().getName(), false, classLoader));
		}
	}
	@Test
	void loadClassWhenFilteredOnClassShouldThrowClassNotFound() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader(FilteredClassLoaderTests.class)) {
			assertThatExceptionOfType(ClassNotFoundException.class)
				.isThrownBy(() -> Class.forName(getClass().getName(), false, classLoader));
		}
	}
	@Test
	void loadClassWhenNotFilteredShouldLoadClass() throws Exception {
		FilteredClassLoader classLoader = new FilteredClassLoader((className) -> false);
		Class<?> loaded = Class.forName(getClass().getName(), false, classLoader);
		assertThat(loaded.getName()).isEqualTo(getClass().getName());
		classLoader.close();
	}
	@Test
	void loadResourceWhenFilteredOnResourceShouldReturnNotFound() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader(TEST_RESOURCE)) {
			final URL loaded = classLoader.getResource(TEST_RESOURCE.getPath());
			assertThat(loaded).isNull();
		}
	}
	@Test
	void loadResourceWhenNotFilteredShouldLoadResource() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader((resourceName) -> false)) {
			final URL loaded = classLoader.getResource(TEST_RESOURCE.getPath());
			assertThat(loaded).isNotNull();
		}
	}
	@Test
	void loadResourcesWhenFilteredOnResourceShouldReturnNotFound() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader(TEST_RESOURCE)) {
			final Enumeration<URL> loaded = classLoader.getResources(TEST_RESOURCE.getPath());
			assertThat(loaded.hasMoreElements()).isFalse();
		}
	}
	@Test
	void loadResourcesWhenNotFilteredShouldLoadResource() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader((resourceName) -> false)) {
			final Enumeration<URL> loaded = classLoader.getResources(TEST_RESOURCE.getPath());
			assertThat(loaded.hasMoreElements()).isTrue();
		}
	}
	@Test
	void loadResourceAsStreamWhenFilteredOnResourceShouldReturnNotFound() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader(TEST_RESOURCE)) {
			final InputStream loaded = classLoader.getResourceAsStream(TEST_RESOURCE.getPath());
			assertThat(loaded).isNull();
		}
	}
	@Test
	void loadResourceAsStreamWhenNotFilteredShouldLoadResource() throws Exception {
		try (FilteredClassLoader classLoader = new FilteredClassLoader((resourceName) -> false)) {
			final InputStream loaded = classLoader.getResourceAsStream(TEST_RESOURCE.getPath());
			assertThat(loaded).isNotNull();
		}
	}
	@Test
	void publicDefineClassWhenFilteredThrowsException() throws Exception {
		Class<FilteredClassLoaderTests> hiddenClass = FilteredClassLoaderTests.class;
		try (FilteredClassLoader classLoader = new FilteredClassLoader(hiddenClass)) {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> classLoader.publicDefineClass(hiddenClass.getName(), new byte[] {}, null));
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest
class SpringBootTestJmxTests {
	@Value('${spring.jmx.enabled}')
	private boolean jmx;
	@Test
	void disabledByDefault() {
		assertThat(this.jmx).isFalse();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest
@DirtiesContext
@WebAppConfiguration('src/mymain/mywebapp')
class SpringBootTestWebEnvironmentMockWithWebAppConfigurationTests {
	@Autowired
	private ServletContext servletContext;
	@Test
	void resourcePath() {
		assertThat(this.servletContext).hasFieldOrPropertyWithValue('resourceBasePath', 'src/mymain/mywebapp');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class Config {
		@Bean
		static PropertySourcesPlaceholderConfigurer propertyPlaceholder() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT, properties = { 'server.port=0', 'value=123' })
class SpringBootTestWebEnvironmentDefinedPortTests extends AbstractSpringBootTestWebServerWebEnvironmentTests {
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	@RestController
	static class Config extends AbstractConfig {
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(classes = SpringBootTestWithClassesIntegrationTests.Config.class)
class SpringBootTestWithClassesIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void injectsOnlyConfig() {
		assertThat(this.context.getBean(Config.class)).isNotNull();
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(AdditionalConfig.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	static class AdditionalConfig {
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
class ReactiveWebApplicationContextRunnerTests extends
		AbstractApplicationContextRunnerTests<ReactiveWebApplicationContextRunner, ConfigurableReactiveWebApplicationContext, AssertableReactiveWebApplicationContext> {
	@Override
	protected ReactiveWebApplicationContextRunner get() {
		return new ReactiveWebApplicationContextRunner();
	}
	@Override
	protected ReactiveWebApplicationContextRunner getWithAdditionalContextInterface() {
		return new ReactiveWebApplicationContextRunner(TestAnnotationConfigReactiveWebApplicationContext::new,
				AdditionalContextInterface.class);
	}
	static class TestAnnotationConfigReactiveWebApplicationContext extends AnnotationConfigReactiveWebApplicationContext
			implements AdditionalContextInterface {
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
interface AdditionalContextInterface {
}
/*
package org.springframework.boot.test.context.runner;
/**
class ApplicationContextRunnerTests extends
		AbstractApplicationContextRunnerTests<ApplicationContextRunner, ConfigurableApplicationContext, AssertableApplicationContext> {
	@Override
	protected ApplicationContextRunner get() {
		return new ApplicationContextRunner();
	}
	@Override
	protected ApplicationContextRunner getWithAdditionalContextInterface() {
		return new ApplicationContextRunner(TestAnnotationConfigApplicationContext::new,
				AdditionalContextInterface.class);
	}
	static class TestAnnotationConfigApplicationContext extends AnnotationConfigApplicationContext
			implements AdditionalContextInterface {
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
class WebApplicationContextRunnerTests extends
		AbstractApplicationContextRunnerTests<WebApplicationContextRunner, ConfigurableWebApplicationContext, AssertableWebApplicationContext> {
	@Test
	void contextShouldHaveMockServletContext() {
		get().run((context) -> assertThat(context.getServletContext()).isInstanceOf(MockServletContext.class));
	}
	@Override
	protected WebApplicationContextRunner get() {
		return new WebApplicationContextRunner();
	}
	@Override
	protected WebApplicationContextRunner getWithAdditionalContextInterface() {
		return new WebApplicationContextRunner(TestAnnotationConfigServletWebApplicationContext::new,
				AdditionalContextInterface.class);
	}
	static class TestAnnotationConfigServletWebApplicationContext extends AnnotationConfigServletWebApplicationContext
			implements AdditionalContextInterface {
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
class ContextConsumerTests {
	@Test
	void andThenInvokeInOrder() throws Throwable {
		IntPredicate predicate = mock(IntPredicate.class);
		given(predicate.test(42)).willReturn(true);
		given(predicate.test(24)).willReturn(false);
		ContextConsumer<ApplicationContext> firstConsumer = (context) -> assertThat(predicate.test(42)).isTrue();
		ContextConsumer<ApplicationContext> secondConsumer = (context) -> assertThat(predicate.test(24)).isFalse();
		firstConsumer.andThen(secondConsumer).accept(mock(ApplicationContext.class));
		InOrder ordered = inOrder(predicate);
		ordered.verify(predicate).test(42);
		ordered.verify(predicate).test(24);
		ordered.verifyNoMoreInteractions();
	}
	@Test
	void andThenNoInvokedIfThisFails() {
		IntPredicate predicate = mock(IntPredicate.class);
		given(predicate.test(42)).willReturn(true);
		given(predicate.test(24)).willReturn(false);
		ContextConsumer<ApplicationContext> firstConsumer = (context) -> assertThat(predicate.test(42)).isFalse();
		ContextConsumer<ApplicationContext> secondConsumer = (context) -> assertThat(predicate.test(24)).isFalse();
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> firstConsumer.andThen(secondConsumer).accept(mock(ApplicationContext.class)));
		then(predicate).should().test(42);
		then(predicate).shouldHaveNoMoreInteractions();
	}
	@Test
	void andThenWithNull() {
		ContextConsumer<?> consumer = (context) -> {
		};
		assertThatIllegalArgumentException().isThrownBy(() -> consumer.andThen(null))
			.withMessage('After must not be null');
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
abstract class AbstractApplicationContextRunnerTests<T extends AbstractApplicationContextRunner<T, C, A>, C extends ConfigurableApplicationContext, A extends ApplicationContextAssertProvider<C>> {
	@Test
	void runWithInitializerShouldInitialize() {
		AtomicBoolean called = new AtomicBoolean();
		get().withInitializer((context) -> called.set(true)).run((context) -> {
		});
		assertThat(called).isTrue();
	}
	@Test
	void runWithSystemPropertiesShouldSetAndRemoveProperties() {
		String key = 'test.' + UUID.randomUUID();
		assertThat(System.getProperties()).doesNotContainKey(key);
		get().withSystemProperties(key + '=value')
			.run((context) -> assertThat(System.getProperties()).containsEntry(key, 'value'));
		assertThat(System.getProperties()).doesNotContainKey(key);
	}
	@Test
	void runWithSystemPropertiesWhenContextFailsShouldRemoveProperties() {
		String key = 'test.' + UUID.randomUUID();
		assertThat(System.getProperties()).doesNotContainKey(key);
		get().withSystemProperties(key + '=value')
			.withUserConfiguration(FailingConfig.class)
			.run((context) -> assertThat(context).hasFailed());
		assertThat(System.getProperties()).doesNotContainKey(key);
	}
	@Test
	void runWithSystemPropertiesShouldRestoreOriginalProperties() {
		String key = 'test.' + UUID.randomUUID();
		System.setProperty(key, 'value');
		try {
			assertThat(System.getProperties().getProperty(key)).isEqualTo('value');
			get().withSystemProperties(key + '=newValue')
				.run((context) -> assertThat(System.getProperties()).containsEntry(key, 'newValue'));
			assertThat(System.getProperties().getProperty(key)).isEqualTo('value');
		}
		finally {
			System.clearProperty(key);
		}
	}
	@Test
	void runWithSystemPropertiesWhenValueIsNullShouldRemoveProperty() {
		String key = 'test.' + UUID.randomUUID();
		System.setProperty(key, 'value');
		try {
			assertThat(System.getProperties().getProperty(key)).isEqualTo('value');
			get().withSystemProperties(key + '=')
				.run((context) -> assertThat(System.getProperties()).doesNotContainKey(key));
			assertThat(System.getProperties().getProperty(key)).isEqualTo('value');
		}
		finally {
			System.clearProperty(key);
		}
	}
	@Test
	void runWithMultiplePropertyValuesShouldAllAllValues() {
		get().withPropertyValues('test.foo=1').withPropertyValues('test.bar=2').run((context) -> {
			Environment environment = context.getEnvironment();
			assertThat(environment.getProperty('test.foo')).isEqualTo('1');
			assertThat(environment.getProperty('test.bar')).isEqualTo('2');
		});
	}
	@Test
	void runWithPropertyValuesWhenHasExistingShouldReplaceValue() {
		get().withPropertyValues('test.foo=1').withPropertyValues('test.foo=2').run((context) -> {
			Environment environment = context.getEnvironment();
			assertThat(environment.getProperty('test.foo')).isEqualTo('2');
		});
	}
	@Test
	void runWithConfigurationsShouldRegisterConfigurations() {
		get().withUserConfiguration(FooConfig.class).run((context) -> assertThat(context).hasBean('foo'));
	}
	@Test
	void runWithUserNamedBeanShouldRegisterBean() {
		get().withBean('foo', String.class, () -> 'foo').run((context) -> assertThat(context).hasBean('foo'));
	}
	@Test
	void runWithUserBeanShouldRegisterBeanWithDefaultName() {
		get().withBean(String.class, () -> 'foo').run((context) -> assertThat(context).hasBean('string'));
	}
	@Test
	void runWithMultipleConfigurationsShouldRegisterAllConfigurations() {
		get().withUserConfiguration(FooConfig.class)
			.withConfiguration(UserConfigurations.of(BarConfig.class))
			.run((context) -> assertThat(context).hasBean('foo').hasBean('bar'));
	}
	@Test
	void runWithFailedContextShouldReturnFailedAssertableContext() {
		get().withUserConfiguration(FailingConfig.class).run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void runWithClassLoaderShouldSetClassLoaderOnContext() {
		get().withClassLoader(new FilteredClassLoader(Gson.class.getPackage().getName()))
			.run((context) -> assertThatExceptionOfType(ClassNotFoundException.class)
				.isThrownBy(() -> ClassUtils.forName(Gson.class.getName(), context.getClassLoader())));
	}
	@Test
	void runWithClassLoaderShouldSetClassLoaderOnConditionContext() {
		get().withClassLoader(new FilteredClassLoader(Gson.class.getPackage().getName()))
			.withUserConfiguration(ConditionalConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(ConditionalConfig.class));
	}
	@Test
	void consecutiveRunWithFilteredClassLoaderShouldHaveBeanWithLazyProperties() {
		get().withClassLoader(new FilteredClassLoader(Gson.class))
			.withUserConfiguration(LazyConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(ExampleBeanWithLazyProperties.class));
		get().withClassLoader(new FilteredClassLoader(Gson.class))
			.withUserConfiguration(LazyConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(ExampleBeanWithLazyProperties.class));
	}
	@Test
	void thrownRuleWorksWithCheckedException() {
		get().run((context) -> assertThatIOException().isThrownBy(() -> throwCheckedException('Expected message'))
			.withMessageContaining('Expected message'));
	}
	@Test
	void runDisablesBeanOverridingByDefault() {
		get().withUserConfiguration(FooConfig.class).withBean('foo', Integer.class, () -> 42).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context.getStartupFailure()).isInstanceOf(BeanDefinitionStoreException.class)
				.hasMessageContaining('Invalid bean definition with name "foo"')
				.hasMessageContaining('@Bean definition illegally overridden by existing bean definition');
		});
	}
	@Test
	void runDisablesCircularReferencesByDefault() {
		get().withUserConfiguration(ExampleConsumerConfiguration.class, ExampleProducerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasRootCauseInstanceOf(BeanCurrentlyInCreationException.class);
			});
	}
	@Test
	void circularReferencesCanBeAllowed() {
		get().withAllowCircularReferences(true)
			.withUserConfiguration(ExampleConsumerConfiguration.class, ExampleProducerConfiguration.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void runWithUserBeanShouldBeRegisteredInOrder() {
		get().withAllowBeanDefinitionOverriding(true)
			.withBean(String.class, () -> 'one')
			.withBean(String.class, () -> 'two')
			.withBean(String.class, () -> 'three')
			.run((context) -> {
				assertThat(context).hasBean('string');
				assertThat(context.getBean('string')).isEqualTo('three');
			});
	}
	@Test
	void runWithConfigurationsAndUserBeanShouldRegisterUserBeanLast() {
		get().withAllowBeanDefinitionOverriding(true)
			.withUserConfiguration(FooConfig.class)
			.withBean('foo', String.class, () -> 'overridden')
			.run((context) -> {
				assertThat(context).hasBean('foo');
				assertThat(context.getBean('foo')).isEqualTo('overridden');
			});
	}
	@Test
	void changesMadeByInitializersShouldBeVisibleToRegisteredClasses() {
		get().withInitializer((context) -> context.getEnvironment().setActiveProfiles('test'))
			.withUserConfiguration(ProfileConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(ProfileConfig.class));
	}
	@Test
	void prepareDoesNotRefreshContext() {
		get().withUserConfiguration(FooConfig.class).prepare((context) -> {
			assertThatIllegalStateException().isThrownBy(() -> context.getBean(String.class))
				.withMessageContaining('not been refreshed');
			context.getSourceApplicationContext().refresh();
			assertThat(context.getBean(String.class)).isEqualTo('foo');
		});
	}
	@Test
	void getWirhAdditionalContextInterfaceHasCorrectInstanceOf() {
		getWithAdditionalContextInterface()
			.run((context) -> assertThat(context).isInstanceOf(AdditionalContextInterface.class));
	}
	protected abstract T get();
	protected abstract T getWithAdditionalContextInterface();
	private static void throwCheckedException(String message) throws IOException {
		throw new IOException(message);
	}
	@Configuration(proxyBeanMethods = false)
	static class FailingConfig {
		@Bean
		String foo() {
			throw new IllegalStateException('Failed');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FooConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BarConfig {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(FilteredClassLoaderCondition.class)
	static class ConditionalConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ExampleProperties.class)
	static class LazyConfig {
		@Bean
		ExampleBeanWithLazyProperties exampleBeanWithLazyProperties() {
			return new ExampleBeanWithLazyProperties();
		}
	}
	static class ExampleBeanWithLazyProperties {
		@Autowired
		@Lazy
		ExampleProperties exampleProperties;
	}
	@ConfigurationProperties
	public static class ExampleProperties {
	}
	static class FilteredClassLoaderCondition implements Condition {
		@Override
		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
			return context.getClassLoader() instanceof FilteredClassLoader;
		}
	}
	static class Example {
	}
	@FunctionalInterface
	interface ExampleConfigurer {
		void configure(Example example);
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleProducerConfiguration {
		@Bean
		Example example(ObjectProvider<ExampleConfigurer> configurers) {
			Example example = new Example();
			configurers.orderedStream().forEach((configurer) -> configurer.configure(example));
			return example;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleConsumerConfiguration {
		@Autowired
		Example example;
		@Bean
		ExampleConfigurer configurer() {
			return (example) -> {
			};
		}
	}
	@Profile('test')
	@Configuration(proxyBeanMethods = false)
	static class ProfileConfig {
	}
}
/*
package org.springframework.boot.test.context;
/**
@CompileWithForkedClassLoader
class SpringBootContextLoaderAotTests {
	@Test
	void loadContextForAotProcessingAndAotRuntime() {
		InMemoryGeneratedFiles generatedFiles = new InMemoryGeneratedFiles();
		TestContextAotGenerator generator = new TestContextAotGenerator(generatedFiles);
		Class<?> testClass = ExampleTest.class;
		generator.processAheadOfTime(Stream.of(testClass));
		TestCompiler.forSystem()
			.with(CompilerFiles.from(generatedFiles))
			.compile(ThrowingConsumer.of((compiled) -> assertCompiledTest(testClass)));
	}
	private void assertCompiledTest(Class<?> testClass) throws Exception {
		try {
			System.setProperty(AotDetector.AOT_ENABLED, 'true');
			resetAotClasses();
			AotTestContextInitializers aotContextInitializers = new AotTestContextInitializers();
			TestContextBootstrapper testContextBootstrapper = BootstrapUtils.resolveTestContextBootstrapper(testClass);
			MergedContextConfiguration mergedConfig = testContextBootstrapper.buildMergedContextConfiguration();
			ApplicationContextInitializer<ConfigurableApplicationContext> contextInitializer = aotContextInitializers
				.getContextInitializer(testClass);
			ConfigurableApplicationContext context = (ConfigurableApplicationContext) ((AotContextLoader) mergedConfig
				.getContextLoader()).loadContextForAotRuntime(mergedConfig, contextInitializer);
			assertThat(context).isExactlyInstanceOf(GenericApplicationContext.class);
			String[] beanNames = context.getBeanNamesForType(ExampleBean.class);
			BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(beanNames[0]);
			assertThat(beanDefinition).isNotExactlyInstanceOf(GenericBeanDefinition.class);
		}
		finally {
			System.clearProperty(AotDetector.AOT_ENABLED);
			resetAotClasses();
		}
	}
	private void resetAotClasses() {
		reset('org.springframework.test.context.aot.AotTestAttributesFactory');
		reset('org.springframework.test.context.aot.AotTestContextInitializersFactory');
	}
	private void reset(String className) {
		Class<?> targetClass = ClassUtils.resolveClassName(className, null);
		ReflectionTestUtils.invokeMethod(targetClass, 'reset');
	}
	@SpringBootTest(classes = ExampleConfig.class, webEnvironment = WebEnvironment.NONE)
	static class ExampleTest {
	}
	@SpringBootConfiguration
	@Import(ExampleBean.class)
	static class ExampleConfig {
	}
	static class ExampleBean {
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.NONE,
		properties = { 'boot-test-inlined=foo', 'b=boot-test-inlined', 'c=boot-test-inlined' })
@TestPropertySource(
		properties = { 'property-source-inlined=bar', 'a=property-source-inlined', 'c=property-source-inlined' },
		locations = 'classpath:/test-property-source-annotation.properties')
class SpringBootTestWithTestPropertySourceTests {
	@Autowired
	private Config config;
	@Test
	void propertyFromSpringBootTestProperties() {
		assertThat(this.config.bootTestInlined).isEqualTo('foo');
	}
	@Test
	void propertyFromTestPropertySourceProperties() {
		assertThat(this.config.propertySourceInlined).isEqualTo('bar');
	}
	@Test
	void propertyFromTestPropertySourceLocations() {
		assertThat(this.config.propertySourceLocation).isEqualTo('baz');
	}
	@Test
	void propertyFromPropertySourcePropertiesOverridesPropertyFromPropertySourceLocations() {
		assertThat(this.config.propertySourceInlinedOverridesPropertySourceLocation)
			.isEqualTo('property-source-inlined');
	}
	@Test
	void propertyFromBootTestPropertiesOverridesPropertyFromPropertySourceLocations() {
		assertThat(this.config.bootTestInlinedOverridesPropertySourceLocation).isEqualTo('boot-test-inlined');
	}
	@Test
	void propertyFromPropertySourcePropertiesOverridesPropertyFromBootTestProperties() {
		assertThat(this.config.propertySourceInlinedOverridesBootTestInlined).isEqualTo('property-source-inlined');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Value('${boot-test-inlined}')
		private String bootTestInlined;
		@Value('${property-source-inlined}')
		private String propertySourceInlined;
		@Value('${property-source-location}')
		private String propertySourceLocation;
		@Value('${a}')
		private String propertySourceInlinedOverridesPropertySourceLocation;
		@Value('${b}')
		private String bootTestInlinedOverridesPropertySourceLocation;
		@Value('${c}')
		private String propertySourceInlinedOverridesBootTestInlined;
		@Bean
		static PropertySourcesPlaceholderConfigurer propertyPlaceholder() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest
@ContextConfiguration(classes = SpringBootTestWithContextConfigurationIntegrationTests.Config.class)
class SpringBootTestWithContextConfigurationIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void injectsOnlyConfig() {
		assertThat(this.context.getBean(Config.class)).isNotNull();
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(AdditionalConfig.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	static class AdditionalConfig {
	}
}
/*
package org.springframework.boot.test.context;
/**
class ImportsContextCustomizerTests {
	@Test
	void importSelectorsCouldUseAnyAnnotations() {
		assertThat(new ImportsContextCustomizer(FirstImportSelectorAnnotatedClass.class))
			.isNotEqualTo(new ImportsContextCustomizer(SecondImportSelectorAnnotatedClass.class));
	}
	@Test
	void determinableImportSelector() {
		assertThat(new ImportsContextCustomizer(FirstDeterminableImportSelectorAnnotatedClass.class))
			.isEqualTo(new ImportsContextCustomizer(SecondDeterminableImportSelectorAnnotatedClass.class));
	}
	@Test
	void customizersForTestClassesWithDifferentKotlinMetadataAreEqual() {
		assertThat(new ImportsContextCustomizer(FirstKotlinAnnotatedTestClass.class))
			.isEqualTo(new ImportsContextCustomizer(SecondKotlinAnnotatedTestClass.class));
	}
	@Test
	void customizersForTestClassesWithDifferentSpockFrameworkAnnotationsAreEqual() {
		assertThat(new ImportsContextCustomizer(FirstSpockFrameworkAnnotatedTestClass.class))
			.isEqualTo(new ImportsContextCustomizer(SecondSpockFrameworkAnnotatedTestClass.class));
	}
	@Test
	void customizersForTestClassesWithDifferentSpockLangAnnotationsAreEqual() {
		assertThat(new ImportsContextCustomizer(FirstSpockLangAnnotatedTestClass.class))
			.isEqualTo(new ImportsContextCustomizer(SecondSpockLangAnnotatedTestClass.class));
	}
	@Test
	void customizersForTestClassesWithDifferentJUnitAnnotationsAreEqual() {
		assertThat(new ImportsContextCustomizer(FirstJUnitAnnotatedTestClass.class))
			.isEqualTo(new ImportsContextCustomizer(SecondJUnitAnnotatedTestClass.class));
	}
	@Test
	void customizersForClassesWithDifferentImportsAreNotEqual() {
		assertThat(new ImportsContextCustomizer(FirstAnnotatedTestClass.class))
			.isNotEqualTo(new ImportsContextCustomizer(SecondAnnotatedTestClass.class));
	}
	@Test
	void customizersForClassesWithDifferentMetaImportsAreNotEqual() {
		assertThat(new ImportsContextCustomizer(FirstMetaAnnotatedTestClass.class))
			.isNotEqualTo(new ImportsContextCustomizer(SecondMetaAnnotatedTestClass.class));
	}
	@Test
	void customizersForClassesWithDifferentAliasedImportsAreNotEqual() {
		assertThat(new ImportsContextCustomizer(FirstAliasAnnotatedTestClass.class))
			.isNotEqualTo(new ImportsContextCustomizer(SecondAliasAnnotatedTestClass.class));
	}
	@Test
	void importsCanBeScatteredOnMultipleAnnotations() {
		assertThat(new ImportsContextCustomizer(SingleImportAnnotationTestClass.class))
			.isEqualTo(new ImportsContextCustomizer(MultipleImportAnnotationTestClass.class));
	}
	@Import(TestImportSelector.class)
	@Indicator1
	static class FirstImportSelectorAnnotatedClass {
	}
	@Import(TestImportSelector.class)
	@Indicator2
	static class SecondImportSelectorAnnotatedClass {
	}
	@Import(TestDeterminableImportSelector.class)
	@Indicator1
	static class FirstDeterminableImportSelectorAnnotatedClass {
	}
	@Import(TestDeterminableImportSelector.class)
	@Indicator2
	static class SecondDeterminableImportSelectorAnnotatedClass {
	}
	@Metadata(d2 = 'foo')
	@Import(TestImportSelector.class)
	static class FirstKotlinAnnotatedTestClass {
	}
	@Metadata(d2 = 'bar')
	@Import(TestImportSelector.class)
	static class SecondKotlinAnnotatedTestClass {
	}
	@SpecMetadata(filename = 'foo', line = 10)
	@Import(TestImportSelector.class)
	static class FirstSpockFrameworkAnnotatedTestClass {
	}
	@SpecMetadata(filename = 'bar', line = 10)
	@Import(TestImportSelector.class)
	static class SecondSpockFrameworkAnnotatedTestClass {
	}
	@Stepwise
	@Import(TestImportSelector.class)
	static class FirstSpockLangAnnotatedTestClass {
	}
	@Issue('1234')
	@Import(TestImportSelector.class)
	static class SecondSpockLangAnnotatedTestClass {
	}
	@Nested
	@Import(TestImportSelector.class)
	static class FirstJUnitAnnotatedTestClass {
	}
	@Tag('test')
	@Import(TestImportSelector.class)
	static class SecondJUnitAnnotatedTestClass {
	}
	@Import({ FirstImportedClass.class, SecondImportedClass.class })
	static class SingleImportAnnotationTestClass {
	}
	@FirstMetaImport
	@Import(SecondImportedClass.class)
	static class MultipleImportAnnotationTestClass {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface Indicator1 {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface Indicator2 {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@Import(AliasFor.class)
	public @interface AliasedImport {
		@AliasFor(annotation = Import.class)
		Class<?>[] value();
	}
	@Retention(RetentionPolicy.RUNTIME)
	@Import(FirstImportedClass.class)
	public @interface FirstMetaImport {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@Import(SecondImportedClass.class)
	public @interface SecondMetaImport {
	}
	static class FirstImportedClass {
	}
	static class SecondImportedClass {
	}
	@AliasedImport(FirstImportedClass.class)
	static class FirstAliasAnnotatedTestClass {
	}
	@AliasedImport(SecondImportedClass.class)
	static class SecondAliasAnnotatedTestClass {
	}
	@FirstMetaImport
	static class FirstMetaAnnotatedTestClass {
	}
	@SecondMetaImport
	static class SecondMetaAnnotatedTestClass {
	}
	@Import(FirstImportedClass.class)
	static class FirstAnnotatedTestClass {
	}
	@Import(SecondImportedClass.class)
	static class SecondAnnotatedTestClass {
	}
	static class TestImportSelector implements ImportSelector {
		@Override
		public String[] selectImports(AnnotationMetadata arg0) {
			return new String[] {};
		}
	}
	static class TestDeterminableImportSelector implements ImportSelector, DeterminableImports {
		@Override
		public String[] selectImports(AnnotationMetadata arg0) {
			return new String[] { TestConfig.class.getName() };
		}
		@Override
		public Set<Object> determineImports(AnnotationMetadata metadata) {
			return Collections.singleton(TestConfig.class.getName());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest('spring.config.name=enableother')
@ActiveProfiles('override')
class SpringBootTestActiveProfileTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void profiles() {
		assertThat(this.context.getEnvironment().getActiveProfiles()).containsExactly('override');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest
class SpringBootTestXmlConventionConfigurationTests {
	@Autowired
	private String foo;
	@Test
	void xmlConfigLoaded() {
		assertThat(this.foo).isEqualTo('World');
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'spring.main.web-application-type=reactive', 'value=123' })
class SpringBootTestReactiveWebEnvironmentUserDefinedTestRestTemplateTests
		extends AbstractSpringBootTestEmbeddedReactiveWebEnvironmentTests {
	@Test
	void restTemplateIsUserDefined() {
		assertThat(getContext().getBean('testRestTemplate')).isInstanceOf(RestTemplate.class);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebFlux
	@RestController
	static class Config extends AbstractConfig {
		@Bean
		RestTemplate testRestTemplate() {
			return new RestTemplate();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'value=123' })
class SpringBootTestUserDefinedTestRestTemplateTests extends AbstractSpringBootTestWebServerWebEnvironmentTests {
	@Test
	void restTemplateIsUserDefined() {
		assertThat(getContext().getBean('testRestTemplate')).isInstanceOf(RestTemplate.class);
	}
	// gh-7711
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	@RestController
	static class Config extends AbstractConfig {
		@Bean
		RestTemplate testRestTemplate() {
			return new RestTemplate();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest(properties = 'server.port=12345')
class SpringBootTestCustomPortTests {
	@Autowired
	private Environment environment;
	@Test
	void validatePortIsNotOverwritten() {
		String port = this.environment.getProperty('server.port');
		assertThat(port).isEqualTo('12345');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context.bootstrap;
/**
@ExtendWith(SpringExtension.class)
@BootstrapWith(SpringBootTestContextBootstrapper.class)
@ContextConfiguration
class SpringBootTestContextBootstrapperWithContextConfigurationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private SpringBootTestContextBootstrapperExampleConfig config;
	@Test
	void findConfigAutomatically() {
		assertThat(this.config).isNotNull();
	}
	@Test
	void contextWasCreatedViaSpringApplication() {
		assertThat(this.context.getId()).startsWith('application');
	}
}
/*
package org.springframework.boot.test.context.bootstrap;
/**
@SpringBootConfiguration
public class SpringBootTestContextBootstrapperExampleConfig {
}
/*
package org.springframework.boot.test.context.bootstrap;
/**
@ExtendWith(SpringExtension.class)
@BootstrapWith(SpringBootTestContextBootstrapper.class)
class SpringBootTestContextBootstrapperIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private SpringBootTestContextBootstrapperExampleConfig config;
	@Test
	void findConfigAutomatically() {
		assertThat(this.config).isNotNull();
	}
	@Test
	void contextWasCreatedViaSpringApplication() {
		assertThat(this.context.getId()).startsWith('application');
	}
	@Test
	void testConfigurationWasApplied() {
		assertThat(this.context.getBean(ExampleBean.class)).isNotNull();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		ExampleBean exampleBean() {
			return new ExampleBean();
		}
	}
	static class ExampleBean {
	}
}
/*
package org.springframework.boot.test.context.bootstrap;
/**
class SpringBootTestContextBootstrapperTests {
	@Test
	void springBootTestWithANonMockWebEnvironmentAndWebAppConfigurationFailsFast() {
		assertThatIllegalStateException()
			.isThrownBy(() -> buildTestContext(SpringBootTestNonMockWebEnvironmentAndWebAppConfiguration.class))
			.withMessageContaining('@WebAppConfiguration should only be used with '
					+ '@SpringBootTest when @SpringBootTest is configured with a mock web '
					+ 'environment. Please remove @WebAppConfiguration or reconfigure @SpringBootTest.');
	}
	@Test
	void springBootTestWithAMockWebEnvironmentCanBeUsedWithWebAppConfiguration() {
		buildTestContext(SpringBootTestMockWebEnvironmentAndWebAppConfiguration.class);
	}
	@Test
	void mergedContextConfigurationWhenArgsDifferentShouldNotBeConsideredEqual() {
		TestContext context = buildTestContext(SpringBootTestArgsConfiguration.class);
		MergedContextConfiguration contextConfiguration = getMergedContextConfiguration(context);
		TestContext otherContext2 = buildTestContext(SpringBootTestOtherArgsConfiguration.class);
		MergedContextConfiguration otherContextConfiguration = getMergedContextConfiguration(otherContext2);
		assertThat(contextConfiguration).isNotEqualTo(otherContextConfiguration);
	}
	@Test
	void mergedContextConfigurationWhenArgsSameShouldBeConsideredEqual() {
		TestContext context = buildTestContext(SpringBootTestArgsConfiguration.class);
		MergedContextConfiguration contextConfiguration = getMergedContextConfiguration(context);
		TestContext otherContext2 = buildTestContext(SpringBootTestSameArgsConfiguration.class);
		MergedContextConfiguration otherContextConfiguration = getMergedContextConfiguration(otherContext2);
		assertThat(contextConfiguration).isEqualTo(otherContextConfiguration);
	}
	@Test
	void mergedContextConfigurationWhenWebEnvironmentsDifferentShouldNotBeConsideredEqual() {
		TestContext context = buildTestContext(SpringBootTestMockWebEnvironmentConfiguration.class);
		MergedContextConfiguration contextConfiguration = getMergedContextConfiguration(context);
		TestContext otherContext = buildTestContext(SpringBootTestDefinedPortWebEnvironmentConfiguration.class);
		MergedContextConfiguration otherContextConfiguration = getMergedContextConfiguration(otherContext);
		assertThat(contextConfiguration).isNotEqualTo(otherContextConfiguration);
	}
	@Test
	void mergedContextConfigurationWhenWebEnvironmentsSameShouldBeConsideredEqual() {
		TestContext context = buildTestContext(SpringBootTestMockWebEnvironmentConfiguration.class);
		MergedContextConfiguration contextConfiguration = getMergedContextConfiguration(context);
		TestContext otherContext = buildTestContext(SpringBootTestAnotherMockWebEnvironmentConfiguration.class);
		MergedContextConfiguration otherContextConfiguration = getMergedContextConfiguration(otherContext);
		assertThat(contextConfiguration).isEqualTo(otherContextConfiguration);
	}
	@Test
	void mergedContextConfigurationClassesShouldNotContainDuplicates() {
		TestContext context = buildTestContext(SpringBootTestClassesConfiguration.class);
		MergedContextConfiguration contextConfiguration = getMergedContextConfiguration(context);
		Class<?>[] classes = contextConfiguration.getClasses();
		assertThat(classes).containsExactly(SpringBootTestContextBootstrapperExampleConfig.class);
	}
	@SuppressWarnings('rawtypes')
	private TestContext buildTestContext(Class<?> testClass) {
		SpringBootTestContextBootstrapper bootstrapper = new SpringBootTestContextBootstrapper();
		BootstrapContext bootstrapContext = mock(BootstrapContext.class);
		bootstrapper.setBootstrapContext(bootstrapContext);
		given((Class) bootstrapContext.getTestClass()).willReturn(testClass);
		CacheAwareContextLoaderDelegate contextLoaderDelegate = mock(CacheAwareContextLoaderDelegate.class);
		given(bootstrapContext.getCacheAwareContextLoaderDelegate()).willReturn(contextLoaderDelegate);
		return bootstrapper.buildTestContext();
	}
	private MergedContextConfiguration getMergedContextConfiguration(TestContext context) {
		return (MergedContextConfiguration) ReflectionTestUtils.getField(context, 'mergedConfig');
	}
	@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
	@WebAppConfiguration
	static class SpringBootTestNonMockWebEnvironmentAndWebAppConfiguration {
	}
	@SpringBootTest
	@WebAppConfiguration
	static class SpringBootTestMockWebEnvironmentAndWebAppConfiguration {
	}
	@SpringBootTest(args = '--app.test=same')
	static class SpringBootTestArgsConfiguration {
	}
	@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
	static class SpringBootTestMockWebEnvironmentConfiguration {
	}
	@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
	static class SpringBootTestAnotherMockWebEnvironmentConfiguration {
	}
	@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT)
	static class SpringBootTestDefinedPortWebEnvironmentConfiguration {
	}
	@SpringBootTest(args = '--app.test=same')
	static class SpringBootTestSameArgsConfiguration {
	}
	@SpringBootTest(args = '--app.test=different')
	static class SpringBootTestOtherArgsConfiguration {
	}
	@SpringBootTest(classes = SpringBootTestContextBootstrapperExampleConfig.class)
	static class SpringBootTestClassesConfiguration {
	}
}
/*
package org.springframework.boot.test.context.bootstrap;
/**
@ExtendWith(SpringExtension.class)
@BootstrapWith(SpringBootTestContextBootstrapper.class)
@ContextConfiguration(initializers = CustomInitializer.class)
class SpringBootTestContextBootstrapperWithInitializersTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void foundConfiguration() {
		Object bean = this.context.getBean(SpringBootTestContextBootstrapperExampleConfig.class);
		assertThat(bean).isNotNull();
	}
	// gh-8483
	static class CustomInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest
@ActiveProfiles({ 'test1', 'test2' })
@ContextConfiguration(loader = SpringBootTestWithCustomEnvironmentTests.Loader.class)
class SpringBootTestWithCustomEnvironmentTests {
	@Autowired
	private Environment environment;
	@Test
	void getActiveProfiles() {
		assertThat(this.environment).isInstanceOf(MockEnvironment.class);
		assertThat(this.environment.getActiveProfiles()).containsOnly('test1', 'test2');
	}
	@Configuration
	static class Config {
	}
	static class Loader extends SpringBootContextLoader {
		@Override
		protected ConfigurableEnvironment getEnvironment() {
			return new MockEnvironment();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest
@ActiveProfiles({ 'test1', 'test2' })
@ContextConfiguration(loader = SpringBootTestWithActiveProfilesAndSystemEnvironmentPropertyTests.Loader.class)
class SpringBootTestWithActiveProfilesAndSystemEnvironmentPropertyTests {
	@Autowired
	private Environment environment;
	@Test
	void getActiveProfiles() {
		assertThat(this.environment.getActiveProfiles()).containsOnly('test1', 'test2');
	}
	@Configuration
	static class Config {
	}
	static class Loader extends SpringBootContextLoader {
		@Override
		@SuppressWarnings('unchecked')
		protected ConfigurableEnvironment getEnvironment() {
			ConfigurableEnvironment environment = new StandardEnvironment();
			MutablePropertySources sources = environment.getPropertySources();
			PropertySource<?> source = sources.get(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME);
			Map<String, Object> map = new LinkedHashMap<>((Map<String, Object>) source.getSource());
			map.put('SPRING_PROFILES_ACTIVE', 'local');
			sources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
					new MapPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, map));
			return environment;
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest
@ContextHierarchy({ @ContextConfiguration(classes = ParentConfiguration.class),
		@ContextConfiguration(classes = ChildConfiguration.class) })
@ExtendWith(OutputCaptureExtension.class)
class SpringBootTestContextHierarchyTests {
	@Test
	void contextLoads(CapturedOutput capturedOutput) {
		assertThat(capturedOutput).containsOnlyOnce(':: Spring Boot ::');
	}
	@Configuration(proxyBeanMethods = false)
	static class ParentConfiguration {
		@Bean
		MyBean myBean() {
			return new MyBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ChildConfiguration {
		ChildConfiguration(MyBean myBean) {
		}
	}
	static class MyBean {
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest
@DirtiesContext
class SpringBootTestGroovyConventionConfigurationTests {
	@Autowired
	private String foo;
	@Test
	void groovyConfigLoaded() {
		assertThat(this.foo).isEqualTo('World');
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest
@ContextConfiguration(classes = Config.class, locations = 'classpath:test.groovy')
class SpringBootTestMixedConfigurationTests {
	@Autowired
	private String foo;
	@Autowired
	private Config config;
	@Test
	void mixedConfigClasses() {
		assertThat(this.foo).isNotNull();
		assertThat(this.config).isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context;
/**
class ImportsContextCustomizerFactoryTests {
	private final ImportsContextCustomizerFactory factory = new ImportsContextCustomizerFactory();
	@Test
	void getContextCustomizerWhenHasNoImportAnnotationShouldReturnNull() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(TestWithNoImport.class, null);
		assertThat(customizer).isNull();
	}
	@Test
	void getContextCustomizerWhenHasImportAnnotationShouldReturnCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(TestWithImport.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void getContextCustomizerWhenHasMetaImportAnnotationShouldReturnCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(TestWithMetaImport.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void contextCustomizerEqualsAndHashCode() {
		ContextCustomizer customizer1 = this.factory.createContextCustomizer(TestWithImport.class, null);
		ContextCustomizer customizer2 = this.factory.createContextCustomizer(TestWithImport.class, null);
		ContextCustomizer customizer3 = this.factory.createContextCustomizer(TestWithImportAndMetaImport.class, null);
		ContextCustomizer customizer4 = this.factory.createContextCustomizer(TestWithSameImportAndMetaImport.class,
				null);
		assertThat(customizer1).hasSameHashCodeAs(customizer1);
		assertThat(customizer1).hasSameHashCodeAs(customizer2);
		assertThat(customizer1).isEqualTo(customizer1).isEqualTo(customizer2).isNotEqualTo(customizer3);
		assertThat(customizer3).isEqualTo(customizer4);
	}
	@Test
	void contextCustomizerEqualsAndHashCodeConsidersComponentScan() {
		ContextCustomizer customizer1 = this.factory
			.createContextCustomizer(TestWithImportAndComponentScanOfSomePackage.class, null);
		ContextCustomizer customizer2 = this.factory
			.createContextCustomizer(TestWithImportAndComponentScanOfSomePackage.class, null);
		ContextCustomizer customizer3 = this.factory
			.createContextCustomizer(TestWithImportAndComponentScanOfAnotherPackage.class, null);
		assertThat(customizer1.hashCode()).isEqualTo(customizer2.hashCode());
		assertThat(customizer1).isEqualTo(customizer2);
		assertThat(customizer3.hashCode()).isNotEqualTo(customizer2.hashCode()).isNotEqualTo(customizer1.hashCode());
		assertThat(customizer3).isNotEqualTo(customizer2).isNotEqualTo(customizer1);
	}
	@Test
	void getContextCustomizerWhenClassHasBeanMethodsShouldThrowException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.factory.createContextCustomizer(TestWithImportAndBeanMethod.class, null))
			.withMessageContaining('Test classes cannot include @Bean methods');
	}
	@Test
	void contextCustomizerImportsBeans() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(TestWithImport.class, null);
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		customizer.customizeContext(context, mock(MergedContextConfiguration.class));
		context.refresh();
		assertThat(context.getBean(ImportedBean.class)).isNotNull();
	}
	@Test
	void selfAnnotatingAnnotationDoesNotCauseStackOverflow() {
		assertThat(this.factory.createContextCustomizer(TestWithImportAndSelfAnnotatingAnnotation.class, null))
			.isNotNull();
	}
	static class TestWithNoImport {
	}
	@Import(ImportedBean.class)
	static class TestWithImport {
	}
	@Import(ImportedBean.class)
	@ComponentScan('some.package')
	static class TestWithImportAndComponentScanOfSomePackage {
	}
	@Import(ImportedBean.class)
	@ComponentScan('another.package')
	static class TestWithImportAndComponentScanOfAnotherPackage {
	}
	@MetaImport
	static class TestWithMetaImport {
	}
	@MetaImport
	@Import(AnotherImportedBean.class)
	static class TestWithImportAndMetaImport {
	}
	@MetaImport
	@Import(AnotherImportedBean.class)
	static class TestWithSameImportAndMetaImport {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ImportedBean.class)
	static class TestWithImportAndBeanMethod {
		@Bean
		String bean() {
			return 'bean';
		}
	}
	@SelfAnnotating
	@Import(ImportedBean.class)
	static class TestWithImportAndSelfAnnotatingAnnotation {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@Import(ImportedBean.class)
	@interface MetaImport {
	}
	@Component
	static class ImportedBean {
	}
	@Component
	static class AnotherImportedBean {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@SelfAnnotating
	@interface SelfAnnotating {
	}
}
/*
package org.springframework.boot.test.context;
/**
@ExtendWith(SpringExtension.class)
@DirtiesContext
@ContextConfiguration(loader = SpringBootContextLoader.class)
@WebAppConfiguration
class SpringBootContextLoaderMockMvcTests {
	@Autowired
	private WebApplicationContext context;
	@Autowired
	private ServletContext servletContext;
	private MockMvcTester mvc;
	@BeforeEach
	void setUp() {
		this.mvc = MockMvcTester.from(this.context);
	}
	@Test
	void testMockHttpEndpoint() {
		assertThat(this.mvc.get().uri('/')).hasStatusOk().hasBodyTextEqualTo('Hello World');
	}
	@Test
	void validateWebApplicationContextIsSet() {
		assertThat(this.context).isSameAs(WebApplicationContextUtils.getWebApplicationContext(this.servletContext));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	@RestController
	static class Config {
		@RequestMapping('/')
		String home() {
			return 'Hello World';
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
abstract class AbstractSpringBootTestWebServerWebEnvironmentTests {
	@LocalServerPort
	private int port = 0;
	@Value('${value}')
	private int value = 0;
	@Autowired
	private WebApplicationContext context;
	@Autowired
	private ServletContext servletContext;
	@Autowired
	private TestRestTemplate restTemplate;
	WebApplicationContext getContext() {
		return this.context;
	}
	TestRestTemplate getRestTemplate() {
		return this.restTemplate;
	}
	@Test
	void runAndTestHttpEndpoint() {
		assertThat(this.port).isNotEqualTo(8080).isNotZero();
		String body = new RestTemplate().getForObject('http://localhost:' + this.port + '/', String.class);
		assertThat(body).isEqualTo('Hello World');
	}
	@Test
	void injectTestRestTemplate() {
		String body = this.restTemplate.getForObject('/', String.class);
		assertThat(body).isEqualTo('Hello World');
	}
	@Test
	void annotationAttributesOverridePropertiesFile() {
		assertThat(this.value).isEqualTo(123);
	}
	@Test
	void validateWebApplicationContextIsSet() {
		assertThat(this.context).isSameAs(WebApplicationContextUtils.getWebApplicationContext(this.servletContext));
	}
	@Configuration(proxyBeanMethods = false)
	static class AbstractConfig {
		@Value('${server.port:8080}')
		private int port = 8080;
		@Bean
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
		@Bean
		ServletWebServerFactory webServerFactory() {
			TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
			factory.setPort(this.port);
			return factory;
		}
		@Bean
		static PropertySourcesPlaceholderConfigurer propertyPlaceholder() {
			return new PropertySourcesPlaceholderConfigurer();
		}
		@RequestMapping('/')
		String home() {
			return 'Hello World';
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest
@ActiveProfiles({ 'test1', 'test2' })
@ContextConfiguration(loader = SpringBootTestWithActiveProfilesAndEnvironmentPropertyTests.Loader.class)
class SpringBootTestWithActiveProfilesAndEnvironmentPropertyTests {
	@Autowired
	private Environment environment;
	@Test
	void getActiveProfiles() {
		assertThat(this.environment.getActiveProfiles()).containsOnly('test1', 'test2');
	}
	@Configuration
	static class Config {
	}
	static class Loader extends SpringBootContextLoader {
		@Override
		protected ConfigurableEnvironment getEnvironment() {
			ConfigurableEnvironment environment = new StandardEnvironment();
			MutablePropertySources sources = environment.getPropertySources();
			Map<String, Object> map = new LinkedHashMap<>();
			map.put('spring.profiles.active', 'local');
			sources.addLast(new MapPropertySource('profiletest', map));
			return environment;
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT, properties = { 'server.port=0', 'value=123' })
@ContextHierarchy({ @ContextConfiguration(classes = ParentConfiguration.class),
		@ContextConfiguration(classes = ChildConfiguration.class) })
class SpringBootTestWebEnvironmentContextHierarchyTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void testShouldOnlyStartSingleServer() {
		ApplicationContext parent = this.context.getParent();
		assertThat(this.context).isInstanceOf(WebApplicationContext.class);
		assertThat(parent).isNotInstanceOf(WebApplicationContext.class);
	}
	@Configuration(proxyBeanMethods = false)
	static class ParentConfiguration extends AbstractConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	@RestController
	static class ChildConfiguration extends AbstractConfig {
	}
}
/*
package org.springframework.boot.test.context;
/**
@SpringBootTest(properties = 'spring.config.name=custom-config-name')
class SpringBootTestCustomConfigNameTests {
	@Value('${test.foo}')
	private String foo;
	@Test
	void propertyIsLoadedFromConfigFileWithCustomName() {
		assertThat(this.foo).isEqualTo('bar');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
}
/*
package org.springframework.boot.test.context.nestedtests;
/**
@SpringBootTest(classes = AppConfiguration.class)
@Import(ActionPerformer.class)
class InheritedNestedTestConfigurationTests {
	@MockitoBean
	Action action;
	@Autowired
	ActionPerformer performer;
	@Test
	void mockWasInvokedOnce() {
		this.performer.run();
		then(this.action).should().perform();
	}
	@Test
	void mockWasInvokedTwice() {
		this.performer.run();
		this.performer.run();
		then(this.action).should(times(2)).perform();
	}
	@Nested
	class InnerTests {
		@Test
		void mockWasInvokedOnce() {
			InheritedNestedTestConfigurationTests.this.performer.run();
			then(InheritedNestedTestConfigurationTests.this.action).should().perform();
		}
		@Test
		void mockWasInvokedTwice() {
			InheritedNestedTestConfigurationTests.this.performer.run();
			InheritedNestedTestConfigurationTests.this.performer.run();
			then(InheritedNestedTestConfigurationTests.this.action).should(times(2)).perform();
		}
	}
	@Component
	static class ActionPerformer {
		private final Action action;
		ActionPerformer(Action action) {
			this.action = action;
		}
		void run() {
			this.action.perform();
		}
	}
	public interface Action {
		void perform();
	}
	@SpringBootConfiguration
	static class AppConfiguration {
	}
}
/*
package org.springframework.boot.test.context;
/**
@ExtendWith(SpringExtension.class)
@DirtiesContext
class SpringBootTestDefaultConfigurationTests {
	@Autowired
	private Config config;
	@Test
	void nestedConfigClasses() {
		assertThat(this.config).isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.context;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT,
		properties = { 'spring.main.web-application-type=reactive', 'server.port=0', 'value=123' })
public class SpringBootTestReactiveWebEnvironmentDefinedPortTests
		extends AbstractSpringBootTestEmbeddedReactiveWebEnvironmentTests {
	@Configuration(proxyBeanMethods = false)
	@EnableWebFlux
	@RestController
	static class Config extends AbstractConfig {
	}
}
/*
package org.springframework.boot.test.web.htmlunit.webdriver;
/**
@ExtendWith(MockitoExtension.class)
class LocalHostWebConnectionHtmlUnitDriverTests {
	private final WebClient webClient;
	LocalHostWebConnectionHtmlUnitDriverTests(@Mock WebClient webClient) {
		this.webClient = webClient;
		given(this.webClient.getOptions()).willReturn(new WebClientOptions());
		given(this.webClient.getWebConsole()).willReturn(new WebConsole());
		WebWindow currentWindow = mock(WebWindow.class);
		given(currentWindow.isClosed()).willReturn(false);
		given(this.webClient.getCurrentWindow()).willReturn(currentWindow);
	}
	@Test
	void createWhenEnvironmentIsNullWillThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LocalHostWebConnectionHtmlUnitDriver(null))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void createWithJavascriptFlagWhenEnvironmentIsNullWillThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LocalHostWebConnectionHtmlUnitDriver(null, true))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void createWithBrowserVersionWhenEnvironmentIsNullWillThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new LocalHostWebConnectionHtmlUnitDriver(null, BrowserVersion.CHROME))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void createWithCapabilitiesWhenEnvironmentIsNullWillThrowException() {
		Capabilities capabilities = mock(Capabilities.class);
		given(capabilities.getBrowserName()).willReturn('htmlunit');
		given(capabilities.getBrowserVersion()).willReturn('chrome');
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new LocalHostWebConnectionHtmlUnitDriver(null, capabilities))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void getWhenUrlIsRelativeAndNoPortWillUseLocalhost8080() throws Exception {
		MockEnvironment environment = new MockEnvironment();
		LocalHostWebConnectionHtmlUnitDriver driver = new TestLocalHostWebConnectionHtmlUnitDriver(environment);
		driver.get('/test');
		then(this.webClient).should()
			.getPage(any(TopLevelWindow.class), requestToUrl(new URL('http://localhost:8080/test')));
	}
	@Test
	void getWhenUrlIsRelativeAndHasPortWillUseLocalhostPort() throws Exception {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('local.server.port', '8181');
		LocalHostWebConnectionHtmlUnitDriver driver = new TestLocalHostWebConnectionHtmlUnitDriver(environment);
		driver.get('/test');
		then(this.webClient).should()
			.getPage(any(TopLevelWindow.class), requestToUrl(new URL('http://localhost:8181/test')));
	}
	private WebRequest requestToUrl(URL url) {
		return argThat(new WebRequestUrlArgumentMatcher(url));
	}
	public class TestLocalHostWebConnectionHtmlUnitDriver extends LocalHostWebConnectionHtmlUnitDriver {
		TestLocalHostWebConnectionHtmlUnitDriver(Environment environment) {
			super(environment);
		}
		@Override
		public WebClient getWebClient() {
			return LocalHostWebConnectionHtmlUnitDriverTests.this.webClient;
		}
	}
	private static final class WebRequestUrlArgumentMatcher implements ArgumentMatcher<WebRequest> {
		private final URL expectedUrl;
		private WebRequestUrlArgumentMatcher(URL expectedUrl) {
			this.expectedUrl = expectedUrl;
		}
		@Override
		public boolean matches(WebRequest argument) {
			return argument.getUrl().equals(this.expectedUrl);
		}
	}
}
/*
package org.springframework.boot.test.web.htmlunit;
/**
@SuppressWarnings('resource')
@ExtendWith(MockitoExtension.class)
class LocalHostWebClientTests {
	@Test
	void createWhenEnvironmentIsNullWillThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LocalHostWebClient(null))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void getPageWhenUrlIsRelativeAndNoPortWillUseLocalhost8080() throws Exception {
		MockEnvironment environment = new MockEnvironment();
		WebClient client = new LocalHostWebClient(environment);
		WebConnection connection = mockConnection();
		client.setWebConnection(connection);
		client.getPage('/test');
		URL expectedUrl = new URL('http://localhost:8080/test');
		then(connection).should()
			.getResponse(assertArg((request) -> assertThat(request.getUrl()).isEqualTo(expectedUrl)));
	}
	@Test
	void getPageWhenUrlIsRelativeAndHasPortWillUseLocalhostPort() throws Exception {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('local.server.port', '8181');
		WebClient client = new LocalHostWebClient(environment);
		WebConnection connection = mockConnection();
		client.setWebConnection(connection);
		client.getPage('/test');
		URL expectedUrl = new URL('http://localhost:8181/test');
		then(connection).should()
			.getResponse(assertArg((request) -> assertThat(request.getUrl()).isEqualTo(expectedUrl)));
	}
	private WebConnection mockConnection() throws IOException {
		WebConnection connection = mock(WebConnection.class);
		WebResponse response = new StringWebResponse('test', new URL('http://localhost'));
		given(connection.getResponse(any())).willReturn(response);
		return connection;
	}
}
/*
package org.springframework.boot.test.web.server;
/**
@ExtendWith(SpringExtension.class)
@TestPropertySource(properties = 'local.server.port=8181')
class LocalServerPortTests {
	@Value('${local.server.port}')
	private String fromValue;
	@LocalServerPort
	private String fromAnnotation;
	@Test
	void testLocalServerPortAnnotation() {
		assertThat(this.fromAnnotation).isNotNull().isEqualTo(this.fromValue);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.web.server;
/**
@ExtendWith(SpringExtension.class)
@TestPropertySource(properties = 'local.management.port=8181')
class LocalManagementPortTests {
	@Value('${local.management.port}')
	private String fromValue;
	@LocalManagementPort
	private String fromAnnotation;
	@Test
	void testLocalManagementPortAnnotation() {
		assertThat(this.fromAnnotation).isNotNull().isEqualTo(this.fromValue);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.web.reactor.netty;
/**
@SpringJUnitConfig
class DisableReactorResourceFactoryGlobalResourcesContextCustomizerFactoryTests {
	@Autowired
	private ReactorResourceFactory reactorResourceFactory;
	@Test
	void disablesUseGlobalResources() {
		assertThat(this.reactorResourceFactory.isUseGlobalResources()).isFalse();
	}
	@Configuration
	static class Config {
		@Bean
		ReactorResourceFactory reactorResourceFactory() {
			return new ReactorResourceFactory();
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class TestRestTemplateContextCustomizerTests {
	@Test
	void whenContextIsNotABeanDefinitionRegistryTestRestTemplateIsRegistered() {
		new ApplicationContextRunner(TestApplicationContext::new)
			.withInitializer(this::applyTestRestTemplateContextCustomizer)
			.run((context) -> assertThat(context).hasSingleBean(TestRestTemplate.class));
	}
	@Test
	void whenUsingAotGeneratedArtifactsTestRestTemplateIsNotRegistered() {
		new ApplicationContextRunner().withSystemProperties('spring.aot.enabled:true')
			.withInitializer(this::applyTestRestTemplateContextCustomizer)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(TestRestTemplateRegistrar.class);
				assertThat(context).doesNotHaveBean(TestRestTemplate.class);
			});
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void applyTestRestTemplateContextCustomizer(ConfigurableApplicationContext context) {
		MergedContextConfiguration configuration = mock(MergedContextConfiguration.class);
		given(configuration.getTestClass()).willReturn((Class) TestClass.class);
		new TestRestTemplateContextCustomizer().customizeContext(context, configuration);
	}
	@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
	static class TestClass {
	}
	static class TestApplicationContext extends AbstractApplicationContext {
		private final ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		@Override
		protected void refreshBeanFactory() {
		}
		@Override
		protected void closeBeanFactory() {
		}
		@Override
		public ConfigurableListableBeanFactory getBeanFactory() {
			return this.beanFactory;
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
class TestRestTemplateContextCustomizerIntegrationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void test() {
		assertThat(this.restTemplate.getForObject('/', String.class)).contains('hello');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ TestServlet.class, NoTestRestTemplateBeanChecker.class })
	static class TestConfig {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	static class TestServlet extends GenericServlet {
		@Override
		public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
			try (PrintWriter writer = response.getWriter()) {
				writer.println('hello');
			}
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
@SpringBootTest(classes = TestRestTemplateContextCustomizerWithFactoryBeanTests.TestClassWithFactoryBean.class,
		webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
class TestRestTemplateContextCustomizerWithFactoryBeanTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void test() {
		assertThat(this.restTemplate).isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	@ComponentScan('org.springframework.boot.test.web.client.scan')
	static class TestClassWithFactoryBean {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class NoTestRestTemplateBeanChecker implements ImportSelector, BeanFactoryAware {
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		assertThat(BeanFactoryUtils.beanNamesForTypeIncludingAncestors((ListableBeanFactory) beanFactory,
				TestRestTemplate.class))
			.isEmpty();
	}
	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		return new String[0];
	}
}
/*
package org.springframework.boot.test.web.client;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
class TestRestTemplateContextCustomizerWithOverrideIntegrationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void test() {
		assertThat(this.restTemplate).isInstanceOf(CustomTestRestTemplate.class);
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ TestServlet.class, NoTestRestTemplateBeanChecker.class })
	static class TestConfig {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		TestRestTemplate template() {
			return new CustomTestRestTemplate();
		}
	}
	static class TestServlet extends GenericServlet {
		@Override
		public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
			try (PrintWriter writer = response.getWriter()) {
				writer.println('hello');
			}
		}
	}
	static class CustomTestRestTemplate extends TestRestTemplate {
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class MockServerRestClientCustomizerTests {
	private MockServerRestClientCustomizer customizer;
	@BeforeEach
	void setup() {
		this.customizer = new MockServerRestClientCustomizer();
	}
	@Test
	void createShouldUseSimpleRequestExpectationManager() {
		MockServerRestClientCustomizer customizer = new MockServerRestClientCustomizer();
		customizer.customize(RestClient.builder());
		assertThat(customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(SimpleRequestExpectationManager.class);
	}
	@Test
	void createWhenExpectationManagerClassIsNullShouldThrowException() {
		Class<? extends RequestExpectationManager> expectationManager = null;
		assertThatIllegalArgumentException().isThrownBy(() -> new MockServerRestClientCustomizer(expectationManager))
			.withMessageContaining('ExpectationManager must not be null');
	}
	@Test
	void createWhenExpectationManagerSupplierIsNullShouldThrowException() {
		Supplier<? extends RequestExpectationManager> expectationManagerSupplier = null;
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new MockServerRestClientCustomizer(expectationManagerSupplier))
			.withMessageContaining('ExpectationManagerSupplier must not be null');
	}
	@Test
	void createShouldUseExpectationManagerClass() {
		MockServerRestClientCustomizer customizer = new MockServerRestClientCustomizer(
				UnorderedRequestExpectationManager.class);
		customizer.customize(RestClient.builder());
		assertThat(customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(UnorderedRequestExpectationManager.class);
	}
	@Test
	void createShouldUseSupplier() {
		MockServerRestClientCustomizer customizer = new MockServerRestClientCustomizer(
				UnorderedRequestExpectationManager::new);
		customizer.customize(RestClient.builder());
		assertThat(customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(UnorderedRequestExpectationManager.class);
	}
	@Test
	void customizeShouldBindServer() {
		Builder builder = RestClient.builder();
		this.customizer.customize(builder);
		this.customizer.getServer().expect(requestTo('/test')).andRespond(withSuccess());
		builder.build().get().uri('/test').retrieve().toEntity(String.class);
		this.customizer.getServer().verify();
	}
	@Test
	void getServerWhenNoServersAreBoundShouldThrowException() {
		assertThatIllegalStateException().isThrownBy(this.customizer::getServer)
			.withMessageContaining('Unable to return a single MockRestServiceServer since '
					+ 'MockServerRestClientCustomizer has not been bound to a RestClient');
	}
	@Test
	void getServerWhenMultipleServersAreBoundShouldThrowException() {
		this.customizer.customize(RestClient.builder());
		this.customizer.customize(RestClient.builder());
		assertThatIllegalStateException().isThrownBy(this.customizer::getServer)
			.withMessageContaining('Unable to return a single MockRestServiceServer since '
					+ 'MockServerRestClientCustomizer has been bound to more than one RestClient');
	}
	@Test
	void getServerWhenSingleServerIsBoundShouldReturnServer() {
		Builder builder = RestClient.builder();
		this.customizer.customize(builder);
		assertThat(this.customizer.getServer()).isEqualTo(this.customizer.getServer(builder));
	}
	@Test
	void getServerWhenRestClientBuilderIsFoundShouldReturnServer() {
		Builder builder1 = RestClient.builder();
		Builder builder2 = RestClient.builder();
		this.customizer.customize(builder1);
		this.customizer.customize(builder2);
		assertThat(this.customizer.getServer(builder1)).isNotNull();
		assertThat(this.customizer.getServer(builder2)).isNotNull().isNotSameAs(this.customizer.getServer(builder1));
	}
	@Test
	void getServerWhenRestClientBuilderIsNotFoundShouldReturnNull() {
		Builder builder1 = RestClient.builder();
		Builder builder2 = RestClient.builder();
		this.customizer.customize(builder1);
		assertThat(this.customizer.getServer(builder1)).isNotNull();
		assertThat(this.customizer.getServer(builder2)).isNull();
	}
	@Test
	void getServersShouldReturnServers() {
		Builder builder1 = RestClient.builder();
		Builder builder2 = RestClient.builder();
		this.customizer.customize(builder1);
		this.customizer.customize(builder2);
		assertThat(this.customizer.getServers()).containsOnlyKeys(builder1, builder2);
	}
	@Test
	void getExpectationManagersShouldReturnExpectationManagers() {
		Builder builder1 = RestClient.builder();
		Builder builder2 = RestClient.builder();
		this.customizer.customize(builder1);
		this.customizer.customize(builder2);
		RequestExpectationManager manager1 = this.customizer.getExpectationManagers().get(builder1);
		RequestExpectationManager manager2 = this.customizer.getExpectationManagers().get(builder2);
		assertThat(this.customizer.getServer(builder1)).extracting('expectationManager').isEqualTo(manager1);
		assertThat(this.customizer.getServer(builder2)).extracting('expectationManager').isEqualTo(manager2);
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class MockServerRestTemplateCustomizerTests {
	private MockServerRestTemplateCustomizer customizer;
	@BeforeEach
	void setup() {
		this.customizer = new MockServerRestTemplateCustomizer();
	}
	@Test
	void createShouldUseSimpleRequestExpectationManager() {
		MockServerRestTemplateCustomizer customizer = new MockServerRestTemplateCustomizer();
		customizer.customize(new RestTemplate());
		assertThat(customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(SimpleRequestExpectationManager.class);
	}
	@Test
	void createWhenExpectationManagerClassIsNullShouldThrowException() {
		Class<? extends RequestExpectationManager> expectationManager = null;
		assertThatIllegalArgumentException().isThrownBy(() -> new MockServerRestTemplateCustomizer(expectationManager))
			.withMessageContaining('ExpectationManager must not be null');
	}
	@Test
	void createWhenExpectationManagerSupplierIsNullShouldThrowException() {
		Supplier<? extends RequestExpectationManager> expectationManagerSupplier = null;
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new MockServerRestTemplateCustomizer(expectationManagerSupplier))
			.withMessageContaining('ExpectationManagerSupplier must not be null');
	}
	@Test
	void createShouldUseExpectationManagerClass() {
		MockServerRestTemplateCustomizer customizer = new MockServerRestTemplateCustomizer(
				UnorderedRequestExpectationManager.class);
		customizer.customize(new RestTemplate());
		assertThat(customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(UnorderedRequestExpectationManager.class);
	}
	@Test
	void createShouldUseSupplier() {
		MockServerRestTemplateCustomizer customizer = new MockServerRestTemplateCustomizer(
				UnorderedRequestExpectationManager::new);
		customizer.customize(new RestTemplate());
		assertThat(customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(UnorderedRequestExpectationManager.class);
	}
	@Test
	void detectRootUriShouldDefaultToTrue() {
		MockServerRestTemplateCustomizer customizer = new MockServerRestTemplateCustomizer(
				UnorderedRequestExpectationManager.class);
		customizer.customize(new RestTemplateBuilder().rootUri('https://example.com').build());
		assertThat(customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(RootUriRequestExpectationManager.class);
	}
	@Test
	void setDetectRootUriShouldDisableRootUriDetection() {
		this.customizer.setDetectRootUri(false);
		this.customizer.customize(new RestTemplateBuilder().rootUri('https://example.com').build());
		assertThat(this.customizer.getServer()).extracting('expectationManager')
			.isInstanceOf(SimpleRequestExpectationManager.class);
	}
	@Test
	void bufferContentShouldDefaultToFalse() {
		MockServerRestTemplateCustomizer customizer = new MockServerRestTemplateCustomizer();
		RestTemplate restTemplate = new RestTemplate();
		customizer.customize(restTemplate);
		assertThat(restTemplate.getRequestFactory()).isInstanceOf(ClientHttpRequestFactory.class);
	}
	@Test
	void setBufferContentShouldEnableContentBuffering() {
		MockServerRestTemplateCustomizer customizer = new MockServerRestTemplateCustomizer();
		RestTemplate restTemplate = new RestTemplate();
		customizer.setBufferContent(true);
		customizer.customize(restTemplate);
		assertThat(restTemplate.getRequestFactory()).isInstanceOf(BufferingClientHttpRequestFactory.class);
	}
	@Test
	void customizeShouldBindServer() {
		RestTemplate template = new RestTemplateBuilder(this.customizer).build();
		this.customizer.getServer().expect(requestTo('/test')).andRespond(withSuccess());
		template.getForEntity('/test', String.class);
		this.customizer.getServer().verify();
	}
	@Test
	void getServerWhenNoServersAreBoundShouldThrowException() {
		assertThatIllegalStateException().isThrownBy(this.customizer::getServer)
			.withMessageContaining('Unable to return a single MockRestServiceServer since '
					+ 'MockServerRestTemplateCustomizer has not been bound to a RestTemplate');
	}
	@Test
	void getServerWhenMultipleServersAreBoundShouldThrowException() {
		this.customizer.customize(new RestTemplate());
		this.customizer.customize(new RestTemplate());
		assertThatIllegalStateException().isThrownBy(this.customizer::getServer)
			.withMessageContaining('Unable to return a single MockRestServiceServer since '
					+ 'MockServerRestTemplateCustomizer has been bound to more than one RestTemplate');
	}
	@Test
	void getServerWhenSingleServerIsBoundShouldReturnServer() {
		RestTemplate template = new RestTemplate();
		this.customizer.customize(template);
		assertThat(this.customizer.getServer()).isEqualTo(this.customizer.getServer(template));
	}
	@Test
	void getServerWhenRestTemplateIsFoundShouldReturnServer() {
		RestTemplate template1 = new RestTemplate();
		RestTemplate template2 = new RestTemplate();
		this.customizer.customize(template1);
		this.customizer.customize(template2);
		assertThat(this.customizer.getServer(template1)).isNotNull();
		assertThat(this.customizer.getServer(template2)).isNotNull().isNotSameAs(this.customizer.getServer(template1));
	}
	@Test
	void getServerWhenRestTemplateIsNotFoundShouldReturnNull() {
		RestTemplate template1 = new RestTemplate();
		RestTemplate template2 = new RestTemplate();
		this.customizer.customize(template1);
		assertThat(this.customizer.getServer(template1)).isNotNull();
		assertThat(this.customizer.getServer(template2)).isNull();
	}
	@Test
	void getServersShouldReturnServers() {
		RestTemplate template1 = new RestTemplate();
		RestTemplate template2 = new RestTemplate();
		this.customizer.customize(template1);
		this.customizer.customize(template2);
		assertThat(this.customizer.getServers()).containsOnlyKeys(template1, template2);
	}
	@Test
	void getExpectationManagersShouldReturnExpectationManagers() {
		RestTemplate template1 = new RestTemplate();
		RestTemplate template2 = new RestTemplate();
		this.customizer.customize(template1);
		this.customizer.customize(template2);
		RequestExpectationManager manager1 = this.customizer.getExpectationManagers().get(template1);
		RequestExpectationManager manager2 = this.customizer.getExpectationManagers().get(template2);
		assertThat(this.customizer.getServer(template1)).extracting('expectationManager').isEqualTo(manager1);
		assertThat(this.customizer.getServer(template2)).extracting('expectationManager').isEqualTo(manager2);
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class LocalHostUriTemplateHandlerTests {
	@Test
	void createWhenEnvironmentIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LocalHostUriTemplateHandler(null))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void createWhenSchemeIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new LocalHostUriTemplateHandler(new MockEnvironment(), null))
			.withMessageContaining('Scheme must not be null');
	}
	@Test
	void createWhenHandlerIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new LocalHostUriTemplateHandler(new MockEnvironment(), 'http', null))
			.withMessageContaining('Handler must not be null');
	}
	@Test
	void getRootUriShouldUseLocalServerPort() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('local.server.port', '1234');
		LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(environment);
		assertThat(handler.getRootUri()).isEqualTo('http://localhost:1234');
	}
	@Test
	void getRootUriWhenLocalServerPortMissingShouldUsePort8080() {
		MockEnvironment environment = new MockEnvironment();
		LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(environment);
		assertThat(handler.getRootUri()).isEqualTo('http://localhost:8080');
	}
	@Test
	void getRootUriUsesCustomScheme() {
		MockEnvironment environment = new MockEnvironment();
		LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(environment, 'https');
		assertThat(handler.getRootUri()).isEqualTo('https://localhost:8080');
	}
	@Test
	void getRootUriShouldUseContextPath() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('server.servlet.context-path', '/foo');
		LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(environment);
		assertThat(handler.getRootUri()).isEqualTo('http://localhost:8080/foo');
	}
	@Test
	void expandShouldUseCustomHandler() {
		MockEnvironment environment = new MockEnvironment();
		UriTemplateHandler uriTemplateHandler = mock(UriTemplateHandler.class);
		Map<String, ?> uriVariables = new HashMap<>();
		URI uri = URI.create('https://www.example.com');
		given(uriTemplateHandler.expand('https://localhost:8080/', uriVariables)).willReturn(uri);
		LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(environment, 'https', uriTemplateHandler);
		assertThat(handler.expand('/', uriVariables)).isEqualTo(uri);
		then(uriTemplateHandler).should().expand('https://localhost:8080/', uriVariables);
	}
}
/*
package org.springframework.boot.test.web.client;
/**
@ExtendWith(MockitoExtension.class)
class RootUriRequestExpectationManagerTests {
	private final String uri = 'https://example.com';
	@Mock
	private RequestExpectationManager delegate;
	private RootUriRequestExpectationManager manager;
	@BeforeEach
	void setup() {
		this.manager = new RootUriRequestExpectationManager(this.uri, this.delegate);
	}
	@Test
	void createWhenRootUriIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new RootUriRequestExpectationManager(null, this.delegate))
			.withMessageContaining('RootUri must not be null');
	}
	@Test
	void createWhenExpectationManagerIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new RootUriRequestExpectationManager(this.uri, null))
			.withMessageContaining('ExpectationManager must not be null');
	}
	@Test
	void expectRequestShouldDelegateToExpectationManager() {
		ExpectedCount count = ExpectedCount.once();
		RequestMatcher requestMatcher = mock(RequestMatcher.class);
		this.manager.expectRequest(count, requestMatcher);
		then(this.delegate).should().expectRequest(count, requestMatcher);
	}
	@Test
	void validateRequestWhenUriDoesNotStartWithRootUriShouldDelegateToExpectationManager() throws Exception {
		ClientHttpRequest request = mock(ClientHttpRequest.class);
		given(request.getURI()).willReturn(new URI('https://spring.io/test'));
		this.manager.validateRequest(request);
		then(this.delegate).should().validateRequest(request);
	}
	@Test
	void validateRequestWhenUriStartsWithRootUriShouldReplaceUri() throws Exception {
		ClientHttpRequest request = mock(ClientHttpRequest.class);
		given(request.getURI()).willReturn(new URI(this.uri + '/hello'));
		this.manager.validateRequest(request);
		URI expectedURI = new URI('/hello');
		then(this.delegate).should()
			.validateRequest(assertArg((actual) -> assertThat(actual).isInstanceOfSatisfying(HttpRequestWrapper.class,
					(requestWrapper) -> {
						assertThat(requestWrapper.getRequest()).isSameAs(request);
						assertThat(requestWrapper.getURI()).isEqualTo(expectedURI);
					})));
	}
	@Test
	void validateRequestWhenRequestUriAssertionIsThrownShouldReplaceUriInMessage() throws Exception {
		ClientHttpRequest request = mock(ClientHttpRequest.class);
		given(request.getURI()).willReturn(new URI(this.uri + '/hello'));
		given(this.delegate.validateRequest(any(ClientHttpRequest.class)))
			.willThrow(new AssertionError('Request URI expected:</hello> was:<https://example.com/bad>'));
		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> this.manager.validateRequest(request))
			.withMessageContaining('Request URI expected:<https://example.com/hello>');
	}
	@Test
	void resetRequestShouldDelegateToExpectationManager() {
		this.manager.reset();
		then(this.delegate).should().reset();
	}
	@Test
	void bindToShouldReturnMockRestServiceServer() {
		RestTemplate restTemplate = new RestTemplateBuilder().build();
		MockRestServiceServer bound = RootUriRequestExpectationManager.bindTo(restTemplate);
		assertThat(bound).isNotNull();
	}
	@Test
	void bindToWithExpectationManagerShouldReturnMockRestServiceServer() {
		RestTemplate restTemplate = new RestTemplateBuilder().build();
		MockRestServiceServer bound = RootUriRequestExpectationManager.bindTo(restTemplate, this.delegate);
		assertThat(bound).isNotNull();
	}
	@Test
	void forRestTemplateWhenUsingRootUriTemplateHandlerShouldReturnRootUriRequestExpectationManager() {
		RestTemplate restTemplate = new RestTemplateBuilder().rootUri(this.uri).build();
		RequestExpectationManager actual = RootUriRequestExpectationManager.forRestTemplate(restTemplate,
				this.delegate);
		assertThat(actual).isInstanceOf(RootUriRequestExpectationManager.class);
		assertThat(actual).extracting('rootUri').isEqualTo(this.uri);
	}
	@Test
	void forRestTemplateWhenNotUsingRootUriTemplateHandlerShouldReturnOriginalRequestExpectationManager() {
		RestTemplate restTemplate = new RestTemplateBuilder().build();
		RequestExpectationManager actual = RootUriRequestExpectationManager.forRestTemplate(restTemplate,
				this.delegate);
		assertThat(actual).isSameAs(this.delegate);
	}
	@Test
	void boundRestTemplateShouldPrefixRootUri() {
		RestTemplate restTemplate = new RestTemplateBuilder().rootUri('https://example.com').build();
		MockRestServiceServer server = RootUriRequestExpectationManager.bindTo(restTemplate);
		server.expect(requestTo('/hello')).andRespond(withSuccess());
		restTemplate.getForEntity('/hello', String.class);
	}
	@Test
	void boundRestTemplateWhenUrlIncludesDomainShouldNotPrefixRootUri() {
		RestTemplate restTemplate = new RestTemplateBuilder().rootUri('https://example.com').build();
		MockRestServiceServer server = RootUriRequestExpectationManager.bindTo(restTemplate);
		server.expect(requestTo('/hello')).andRespond(withSuccess());
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> restTemplate.getForEntity('https://spring.io/hello', String.class))
			.withMessageContaining('expected:<https://example.com/hello> but was:<https://spring.io/hello>');
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class TestRestTemplateTests {
	@Test
	void fromRestTemplateBuilder() {
		RestTemplateBuilder builder = mock(RestTemplateBuilder.class);
		RestTemplate delegate = new RestTemplate();
		given(builder.build()).willReturn(delegate);
		assertThat(new TestRestTemplate(builder).getRestTemplate()).isEqualTo(delegate);
	}
	@Test
	void simple() {
		// The Apache client is on the classpath so we get the fully-fledged factory
		assertThat(new TestRestTemplate().getRestTemplate().getRequestFactory())
			.isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	void doNotReplaceCustomRequestFactory() {
		RestTemplateBuilder builder = new RestTemplateBuilder().requestFactory(TestClientHttpRequestFactory.class);
		TestRestTemplate testRestTemplate = new TestRestTemplate(builder);
		assertThat(testRestTemplate.getRestTemplate().getRequestFactory())
			.isInstanceOf(TestClientHttpRequestFactory.class);
	}
	@Test
	void useTheSameRequestFactoryClassWithBasicAuth() {
		TestClientHttpRequestFactory customFactory = new TestClientHttpRequestFactory();
		RestTemplateBuilder builder = new RestTemplateBuilder().requestFactory(() -> customFactory);
		TestRestTemplate testRestTemplate = new TestRestTemplate(builder).withBasicAuth('test', 'test');
		RestTemplate restTemplate = testRestTemplate.getRestTemplate();
		assertThat(restTemplate.getRequestFactory()).isEqualTo(customFactory).hasSameClassAs(customFactory);
	}
	@Test
	void getRootUriRootUriSetViaRestTemplateBuilder() {
		String rootUri = 'https://example.com';
		RestTemplateBuilder delegate = new RestTemplateBuilder().rootUri(rootUri);
		assertThat(new TestRestTemplate(delegate).getRootUri()).isEqualTo(rootUri);
	}
	@Test
	void getRootUriRootUriSetViaLocalHostUriTemplateHandler() {
		String rootUri = 'https://example.com';
		TestRestTemplate template = new TestRestTemplate();
		LocalHostUriTemplateHandler templateHandler = mock(LocalHostUriTemplateHandler.class);
		given(templateHandler.getRootUri()).willReturn(rootUri);
		template.setUriTemplateHandler(templateHandler);
		assertThat(template.getRootUri()).isEqualTo(rootUri);
	}
	@Test
	void getRootUriRootUriNotSet() {
		assertThat(new TestRestTemplate().getRootUri()).isEmpty();
	}
	@Test
	void authenticated() {
		TestRestTemplate restTemplate = new TestRestTemplate('user', 'password');
		assertBasicAuthorizationCredentials(restTemplate, 'user', 'password');
	}
	@Test
	void options() {
		TestRestTemplate template = new TestRestTemplate(HttpClientOption.ENABLE_REDIRECTS);
		CustomHttpComponentsClientHttpRequestFactory factory = (CustomHttpComponentsClientHttpRequestFactory) template
			.getRestTemplate()
			.getRequestFactory();
		RequestConfig config = factory.createRequestConfig();
		assertThat(config.isRedirectsEnabled()).isTrue();
	}
	@Test
	void restOperationsAreAvailable() {
		RestTemplate delegate = mock(RestTemplate.class);
		given(delegate.getRequestFactory()).willReturn(new SimpleClientHttpRequestFactory());
		given(delegate.getUriTemplateHandler()).willReturn(new DefaultUriBuilderFactory());
		RestTemplateBuilder builder = mock(RestTemplateBuilder.class);
		given(builder.build()).willReturn(delegate);
		TestRestTemplate restTemplate = new TestRestTemplate(builder);
		ReflectionUtils.doWithMethods(RestOperations.class, new MethodCallback() {
			@Override
			public void doWith(Method method) {
				Method equivalent = ReflectionUtils.findMethod(TestRestTemplate.class, method.getName(),
						method.getParameterTypes());
				assertThat(equivalent).as('Method %s not found', method).isNotNull();
				assertThat(Modifier.isPublic(equivalent.getModifiers()))
					.as('Method %s should have been public', equivalent)
					.isTrue();
				try {
					equivalent.invoke(restTemplate, mockArguments(method.getParameterTypes()));
				}
				catch (Exception ex) {
					throw new IllegalStateException(ex);
				}
			}
			private Object[] mockArguments(Class<?>[] parameterTypes) throws Exception {
				Object[] arguments = new Object[parameterTypes.length];
				for (int i = 0; i < parameterTypes.length; i++) {
					arguments[i] = mockArgument(parameterTypes[i]);
				}
				return arguments;
			}
			@SuppressWarnings('rawtypes')
			private Object mockArgument(Class<?> type) throws Exception {
				if (String.class.equals(type)) {
					return 'String';
				}
				if (Object[].class.equals(type)) {
					return new Object[0];
				}
				if (URI.class.equals(type)) {
					return new URI('http://localhost');
				}
				if (HttpMethod.class.equals(type)) {
					return HttpMethod.GET;
				}
				if (Class.class.equals(type)) {
					return Object.class;
				}
				if (RequestEntity.class.equals(type)) {
					return new RequestEntity(HttpMethod.GET, new URI('http://localhost'));
				}
				return mock(type);
			}
		}, (method) -> Modifier.isPublic(method.getModifiers()));
	}
	@Test
	void withBasicAuthAddsBasicAuthWhenNotAlreadyPresent() {
		TestRestTemplate original = new TestRestTemplate();
		TestRestTemplate basicAuth = original.withBasicAuth('user', 'password');
		assertThat(getConverterClasses(original)).containsExactlyElementsOf(getConverterClasses(basicAuth).toList());
		assertThat(basicAuth.getRestTemplate().getInterceptors()).isEmpty();
		assertBasicAuthorizationCredentials(original, null, null);
		assertBasicAuthorizationCredentials(basicAuth, 'user', 'password');
	}
	@Test
	void withBasicAuthReplacesBasicAuthWhenAlreadyPresent() {
		TestRestTemplate original = new TestRestTemplate('foo', 'bar').withBasicAuth('replace', 'replace');
		TestRestTemplate basicAuth = original.withBasicAuth('user', 'password');
		assertThat(getConverterClasses(basicAuth)).containsExactlyElementsOf(getConverterClasses(original).toList());
		assertBasicAuthorizationCredentials(original, 'replace', 'replace');
		assertBasicAuthorizationCredentials(basicAuth, 'user', 'password');
	}
	private Stream<Class<?>> getConverterClasses(TestRestTemplate testRestTemplate) {
		return testRestTemplate.getRestTemplate().getMessageConverters().stream().map(Object::getClass);
	}
	@Test
	void withBasicAuthShouldUseNoOpErrorHandler() {
		TestRestTemplate originalTemplate = new TestRestTemplate('foo', 'bar');
		ResponseErrorHandler errorHandler = mock(ResponseErrorHandler.class);
		originalTemplate.getRestTemplate().setErrorHandler(errorHandler);
		TestRestTemplate basicAuthTemplate = originalTemplate.withBasicAuth('user', 'password');
		assertThat(basicAuthTemplate.getRestTemplate().getErrorHandler()).isInstanceOf(NoOpResponseErrorHandler.class);
	}
	@Test
	void exchangeWithRelativeTemplatedUrlRequestEntity() throws Exception {
		RequestEntity<Void> entity = RequestEntity.get('/a/b/c.{ext}', 'txt').build();
		TestRestTemplate template = new TestRestTemplate();
		ClientHttpRequestFactory requestFactory = mock(ClientHttpRequestFactory.class);
		MockClientHttpRequest request = new MockClientHttpRequest();
		request.setResponse(new MockClientHttpResponse(new byte[0], HttpStatus.OK));
		URI absoluteUri = URI.create('http://localhost:8080/a/b/c.txt');
		given(requestFactory.createRequest(eq(absoluteUri), eq(HttpMethod.GET))).willReturn(request);
		template.getRestTemplate().setRequestFactory(requestFactory);
		LocalHostUriTemplateHandler uriTemplateHandler = new LocalHostUriTemplateHandler(new MockEnvironment());
		template.setUriTemplateHandler(uriTemplateHandler);
		template.exchange(entity, String.class);
		then(requestFactory).should().createRequest(eq(absoluteUri), eq(HttpMethod.GET));
	}
	@Test
	void exchangeWithAbsoluteTemplatedUrlRequestEntity() throws Exception {
		RequestEntity<Void> entity = RequestEntity.get('https://api.example.com/a/b/c.{ext}', 'txt').build();
		TestRestTemplate template = new TestRestTemplate();
		ClientHttpRequestFactory requestFactory = mock(ClientHttpRequestFactory.class);
		MockClientHttpRequest request = new MockClientHttpRequest();
		request.setResponse(new MockClientHttpResponse(new byte[0], HttpStatus.OK));
		URI absoluteUri = URI.create('https://api.example.com/a/b/c.txt');
		given(requestFactory.createRequest(eq(absoluteUri), eq(HttpMethod.GET))).willReturn(request);
		template.getRestTemplate().setRequestFactory(requestFactory);
		template.exchange(entity, String.class);
		then(requestFactory).should().createRequest(eq(absoluteUri), eq(HttpMethod.GET));
	}
	@Test
	void deleteHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(TestRestTemplate::delete);
	}
	@Test
	void exchangeWithRequestEntityAndClassHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling((testRestTemplate, relativeUri) -> testRestTemplate
			.exchange(new RequestEntity<String>(HttpMethod.GET, relativeUri), String.class));
	}
	@Test
	void exchangeWithRequestEntityAndParameterizedTypeReferenceHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling((testRestTemplate, relativeUri) -> testRestTemplate
			.exchange(new RequestEntity<String>(HttpMethod.GET, relativeUri), new ParameterizedTypeReference<String>() {
			}));
	}
	@Test
	void exchangeHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling((testRestTemplate, relativeUri) -> testRestTemplate.exchange(relativeUri,
				HttpMethod.GET, new HttpEntity<>(new byte[0]), String.class));
	}
	@Test
	void exchangeWithParameterizedTypeReferenceHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling((testRestTemplate, relativeUri) -> testRestTemplate.exchange(relativeUri,
				HttpMethod.GET, new HttpEntity<>(new byte[0]), new ParameterizedTypeReference<String>() {
				}));
	}
	@Test
	void executeHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(
				(testRestTemplate, relativeUri) -> testRestTemplate.execute(relativeUri, HttpMethod.GET, null, null));
	}
	@Test
	void getForEntityHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(
				(testRestTemplate, relativeUri) -> testRestTemplate.getForEntity(relativeUri, String.class));
	}
	@Test
	void getForObjectHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(
				(testRestTemplate, relativeUri) -> testRestTemplate.getForObject(relativeUri, String.class));
	}
	@Test
	void headForHeadersHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(TestRestTemplate::headForHeaders);
	}
	@Test
	void optionsForAllowHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(TestRestTemplate::optionsForAllow);
	}
	@Test
	void patchForObjectHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(
				(testRestTemplate, relativeUri) -> testRestTemplate.patchForObject(relativeUri, 'hello', String.class));
	}
	@Test
	void postForEntityHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(
				(testRestTemplate, relativeUri) -> testRestTemplate.postForEntity(relativeUri, 'hello', String.class));
	}
	@Test
	void postForLocationHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(
				(testRestTemplate, relativeUri) -> testRestTemplate.postForLocation(relativeUri, 'hello'));
	}
	@Test
	void postForObjectHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling(
				(testRestTemplate, relativeUri) -> testRestTemplate.postForObject(relativeUri, 'hello', String.class));
	}
	@Test
	void putHandlesRelativeUris() throws IOException {
		verifyRelativeUriHandling((testRestTemplate, relativeUri) -> testRestTemplate.put(relativeUri, 'hello'));
	}
	private void verifyRelativeUriHandling(TestRestTemplateCallback callback) throws IOException {
		ClientHttpRequestFactory requestFactory = mock(ClientHttpRequestFactory.class);
		MockClientHttpRequest request = new MockClientHttpRequest();
		request.setResponse(new MockClientHttpResponse(new byte[0], HttpStatus.OK));
		URI absoluteUri = URI.create('http://localhost:8080/a/b/c.txt?param=%7Bsomething%7D');
		given(requestFactory.createRequest(eq(absoluteUri), any(HttpMethod.class))).willReturn(request);
		TestRestTemplate template = new TestRestTemplate();
		template.getRestTemplate().setRequestFactory(requestFactory);
		LocalHostUriTemplateHandler uriTemplateHandler = new LocalHostUriTemplateHandler(new MockEnvironment());
		template.setUriTemplateHandler(uriTemplateHandler);
		callback.doWithTestRestTemplate(template, URI.create('/a/b/c.txt?param=%7Bsomething%7D'));
		then(requestFactory).should().createRequest(eq(absoluteUri), any(HttpMethod.class));
	}
	private void assertBasicAuthorizationCredentials(TestRestTemplate testRestTemplate, String username,
			String password) {
		ClientHttpRequest request = ReflectionTestUtils.invokeMethod(testRestTemplate.getRestTemplate(),
				'createRequest', URI.create('http://localhost'), HttpMethod.POST);
		if (username == null) {
			assertThat(request.getHeaders()).doesNotContainKey(HttpHeaders.AUTHORIZATION);
		}
		else {
			assertThat(request.getHeaders()).containsKeys(HttpHeaders.AUTHORIZATION);
			assertThat(request.getHeaders().get(HttpHeaders.AUTHORIZATION)).containsExactly('Basic '
					+ Base64.getEncoder().encodeToString(String.format('%s:%s', username, password).getBytes()));
		}
	}
	interface TestRestTemplateCallback {
		void doWithTestRestTemplate(TestRestTemplate testRestTemplate, URI relativeUri);
	}
	static class TestClientHttpRequestFactory extends SimpleClientHttpRequestFactory {
	}
}
/*
package org.springframework.boot.test.web.client.scan;
/**
@Component
@SuppressWarnings('rawtypes')
public class SimpleFactoryBean implements FactoryBean {
	private static boolean isInitializedEarly = false;
	public SimpleFactoryBean() {
		isInitializedEarly = true;
		throw new RuntimeException();
	}
	@Autowired
	public SimpleFactoryBean(ApplicationContext context) {
		if (isInitializedEarly) {
			throw new RuntimeException();
		}
	}
	@Override
	public Object getObject() {
		return new Object();
	}
	@Override
	public Class<?> getObjectType() {
		return Object.class;
	}
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(properties = 'server.servlet.context-path=/test')
class WebTestClientContextCustomizerWithCustomContextPathTests {
	@Autowired
	private WebTestClient webTestClient;
	@Test
	void test() {
		this.webTestClient.get().uri('/hello').exchange().expectBody(String.class).isEqualTo('hello world');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestController.class)
	static class TestConfig {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
			factory.setContextPath('/test');
			return factory;
		}
		@Bean
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
	}
	@RestController
	static class TestController {
		@GetMapping('/hello')
		String hello() {
			return 'hello world';
		}
	}
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
class NoWebTestClientBeanChecker implements ImportSelector, BeanFactoryAware {
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		assertThat(BeanFactoryUtils.beanNamesForTypeIncludingAncestors((ListableBeanFactory) beanFactory,
				WebTestClient.class))
			.isEmpty();
	}
	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		return new String[0];
	}
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.main.web-application-type=reactive')
@DirtiesContext
class WebTestClientContextCustomizerIntegrationTests {
	@Autowired
	private WebTestClient webTestClient;
	@Autowired
	private WebTestClientBuilderCustomizer clientBuilderCustomizer;
	@Test
	void test() {
		then(this.clientBuilderCustomizer).should().customize(any(Builder.class));
		this.webTestClient.get().uri('/').exchange().expectBody(String.class).isEqualTo('hello');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ TestHandler.class, NoWebTestClientBeanChecker.class })
	static class TestConfig {
		@Bean
		TomcatReactiveWebServerFactory webServerFactory() {
			return new TomcatReactiveWebServerFactory(0);
		}
		@Bean
		WebTestClientBuilderCustomizer clientBuilderCustomizer() {
			return mock(WebTestClientBuilderCustomizer.class);
		}
	}
	static class TestHandler implements HttpHandler {
		private static final DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			response.setStatusCode(HttpStatus.OK);
			return response.writeWith(Mono.just(factory.wrap('hello'.getBytes())));
		}
	}
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
@ClassPathExclusions('spring-webflux*.jar')
class WebTestClientContextCustomizerWithoutWebfluxIntegrationTests {
	@Test
	void customizerIsNotCreatedWithoutWebClient() {
		WebTestClientContextCustomizerFactory contextCustomizerFactory = new WebTestClientContextCustomizerFactory();
		ContextCustomizer contextCustomizer = contextCustomizerFactory.createContextCustomizer(TestClass.class,
				Collections.emptyList());
		assertThat(contextCustomizer).isNull();
	}
	@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
	private static final class TestClass {
	}
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.main.web-application-type=reactive')
@DirtiesContext
class WebTestClientContextCustomizerWithOverrideIntegrationTests {
	@Autowired
	private WebTestClient webTestClient;
	@Test
	void test() {
		assertThat(this.webTestClient).isInstanceOf(CustomWebTestClient.class);
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ TestHandler.class, NoWebTestClientBeanChecker.class })
	static class TestConfig {
		@Bean
		TomcatReactiveWebServerFactory webServerFactory() {
			return new TomcatReactiveWebServerFactory(0);
		}
		@Bean
		WebTestClient webTestClient() {
			return mock(CustomWebTestClient.class);
		}
	}
	static class TestHandler implements HttpHandler {
		private static final DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			response.setStatusCode(HttpStatus.OK);
			return response.writeWith(Mono.just(factory.wrap('hello'.getBytes())));
		}
	}
	interface CustomWebTestClient extends WebTestClient {
	}
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = 'spring.main.web-application-type=reactive')
@TestPropertySource(properties = 'spring.webflux.base-path=/test')
class WebTestClientContextCustomizerWithCustomBasePathTests {
	@Autowired
	private WebTestClient webTestClient;
	@Test
	void test() {
		this.webTestClient.get().uri('/hello').exchange().expectBody(String.class).isEqualTo('hello world');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		TomcatReactiveWebServerFactory webServerFactory() {
			return new TomcatReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler() {
			TestHandler httpHandler = new TestHandler();
			Map<String, HttpHandler> handlersMap = Collections.singletonMap('/test', httpHandler);
			return new ContextPathCompositeHandler(handlersMap);
		}
	}
	static class TestHandler implements HttpHandler {
		private static final DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			response.setStatusCode(HttpStatus.OK);
			return response.writeWith(Mono.just(factory.wrap('hello world'.getBytes())));
		}
	}
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
class WebTestClientContextCustomizerTests {
	@Test
	void whenContextIsNotABeanDefinitionRegistryWebTestClientIsRegistered() {
		new ApplicationContextRunner(TestApplicationContext::new)
			.withInitializer(this::applyWebTestClientContextCustomizer)
			.run((context) -> assertThat(context).hasSingleBean(WebTestClient.class));
	}
	@Test
	void whenUsingAotGeneratedArtifactsWebTestClientIsNotRegistered() {
		new ApplicationContextRunner().withSystemProperties('spring.aot.enabled:true')
			.withInitializer(this::applyWebTestClientContextCustomizer)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(WebTestClientRegistrar.class);
				assertThat(context).doesNotHaveBean(WebTestClient.class);
			});
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void applyWebTestClientContextCustomizer(ConfigurableApplicationContext context) {
		MergedContextConfiguration configuration = mock(MergedContextConfiguration.class);
		given(configuration.getTestClass()).willReturn((Class) TestClass.class);
		new WebTestClientContextCustomizer().customizeContext(context, configuration);
	}
	@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
	static class TestClass {
	}
	static class TestApplicationContext extends AbstractApplicationContext {
		private final ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		@Override
		protected void refreshBeanFactory() {
		}
		@Override
		protected void closeBeanFactory() {
		}
		@Override
		public ConfigurableListableBeanFactory getBeanFactory() {
			return this.beanFactory;
		}
	}
}
/*
package org.springframework.boot.test.web;
/**
class SpringBootTestRandomPortEnvironmentPostProcessorTests {
	private final SpringBootTestRandomPortEnvironmentPostProcessor postProcessor = new SpringBootTestRandomPortEnvironmentPostProcessor();
	private MockEnvironment environment;
	private MutablePropertySources propertySources;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.propertySources = this.environment.getPropertySources();
	}
	@Test
	void postProcessWhenServerAndManagementPortIsZeroInTestPropertySource() {
		addTestPropertySource('0', '0');
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('0');
	}
	@Test
	void postProcessWhenServerPortAndManagementPortIsZeroInDifferentPropertySources() {
		addTestPropertySource('0', null);
		Map<String, Object> source = new HashMap<>();
		source.put('management.server.port', '0');
		this.propertySources.addLast(new MapPropertySource('other', source));
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('0');
	}
	@Test
	void postProcessWhenTestServerAndTestManagementPortAreNonZero() {
		addTestPropertySource('8080', '8081');
		this.environment.setProperty('server.port', '8080');
		this.environment.setProperty('management.server.port', '8081');
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('8080');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('8081');
	}
	@Test
	void postProcessWhenTestServerPortIsZeroAndTestManagementPortIsNotNull() {
		addTestPropertySource('0', '8080');
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('8080');
	}
	@Test
	void postProcessWhenTestServerPortIsZeroAndManagementPortIsNull() {
		addTestPropertySource('0', null);
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isNull();
	}
	@Test
	void postProcessWhenTestServerPortIsZeroAndManagementPortIsNotNullAndSameInProduction() {
		addTestPropertySource('0', null);
		Map<String, Object> other = new HashMap<>();
		other.put('server.port', '8081');
		other.put('management.server.port', '8081');
		MapPropertySource otherSource = new MapPropertySource('other', other);
		this.propertySources.addLast(otherSource);
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEmpty();
	}
	@Test
	void postProcessWhenTestServerPortIsZeroAndManagementPortIsNotNullAndDefaultSameInProduction() {
		// mgmt port is 8080 which means it"s on the same port as main server since that
		// is null in app properties
		addTestPropertySource('0', null);
		this.propertySources
			.addLast(new MapPropertySource('other', Collections.singletonMap('management.server.port', '8080')));
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEmpty();
	}
	@Test
	void postProcessWhenTestServerPortIsZeroAndManagementPortIsNotNullAndDifferentInProduction() {
		addTestPropertySource('0', null);
		this.propertySources
			.addLast(new MapPropertySource('other', Collections.singletonMap('management.server.port', '8081')));
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('0');
	}
	@Test
	void postProcessWhenTestServerPortIsZeroAndManagementPortMinusOne() {
		addTestPropertySource('0', null);
		this.propertySources
			.addLast(new MapPropertySource('other', Collections.singletonMap('management.server.port', '-1')));
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('-1');
	}
	@Test
	void postProcessWhenTestServerPortIsZeroAndManagementPortIsAnInteger() {
		addTestPropertySource('0', null);
		this.propertySources
			.addLast(new MapPropertySource('other', Collections.singletonMap('management.server.port', 8081)));
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('0');
	}
	@Test
	void postProcessWhenManagementServerPortPlaceholderPresentShouldResolvePlaceholder() {
		addTestPropertySource('0', null);
		MapPropertySource testPropertySource = (MapPropertySource) this.propertySources
			.get(TestPropertySourceUtils.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);
		testPropertySource.getSource().put('port', '9090');
		this.propertySources
			.addLast(new MapPropertySource('other', Collections.singletonMap('management.server.port', '${port}')));
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('0');
	}
	@Test
	void postProcessWhenManagementServerPortPlaceholderAbsentShouldFail() {
		addTestPropertySource('0', null);
		this.propertySources
			.addLast(new MapPropertySource('other', Collections.singletonMap('management.server.port', '${port}')));
		assertThatExceptionOfType(PlaceholderResolutionException.class)
			.isThrownBy(() -> this.postProcessor.postProcessEnvironment(this.environment, null))
			.withMessage('Could not resolve placeholder "port" in value \'${port}\'');
	}
	@Test
	void postProcessWhenServerPortPlaceholderPresentShouldResolvePlaceholder() {
		addTestPropertySource('0', null);
		MapPropertySource testPropertySource = (MapPropertySource) this.propertySources
			.get(TestPropertySourceUtils.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);
		testPropertySource.getSource().put('port', '8080');
		Map<String, Object> source = new HashMap<>();
		source.put('server.port', '${port}');
		source.put('management.server.port', '9090');
		this.propertySources.addLast(new MapPropertySource('other', source));
		this.postProcessor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('server.port')).isEqualTo('0');
		assertThat(this.environment.getProperty('management.server.port')).isEqualTo('0');
	}
	@Test
	void postProcessWhenServerPortPlaceholderAbsentShouldFail() {
		addTestPropertySource('0', null);
		Map<String, Object> source = new HashMap<>();
		source.put('server.port', '${port}');
		source.put('management.server.port', '9090');
		this.propertySources.addLast(new MapPropertySource('other', source));
		assertThatExceptionOfType(PlaceholderResolutionException.class)
			.isThrownBy(() -> this.postProcessor.postProcessEnvironment(this.environment, null))
			.withMessage('Could not resolve placeholder "port" in value \'${port}\'');
	}
	private void addTestPropertySource(String serverPort, String managementPort) {
		Map<String, Object> source = new HashMap<>();
		source.put('server.port', serverPort);
		source.put('management.server.port', managementPort);
		MapPropertySource inlineTestSource = new MapPropertySource(
				TestPropertySourceUtils.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, source);
		this.propertySources.addFirst(inlineTestSource);
	}
}
/*
package org.springframework.boot.test.system;
/**
public class OutputCaptureRuleTests {
	@Rule
	public OutputCaptureRule output = new OutputCaptureRule();
	@Test
	public void toStringShouldReturnAllCapturedOutput() {
		System.out.println('Hello World');
		assertThat(this.output.toString()).contains('Hello World');
	}
	@Test
	public void getAllShouldReturnAllCapturedOutput() {
		System.out.println('Hello World');
		System.err.println('Hello Error');
		assertThat(this.output.getAll()).contains('Hello World', 'Hello Error');
	}
	@Test
	public void getOutShouldOnlyReturnOutputCapturedFromSystemOut() {
		System.out.println('Hello World');
		System.err.println('Hello Error');
		assertThat(this.output.getOut()).contains('Hello World');
		assertThat(this.output.getOut()).doesNotContain('Hello Error');
	}
	@Test
	public void getErrShouldOnlyReturnOutputCapturedFromSystemErr() {
		System.out.println('Hello World');
		System.err.println('Hello Error');
		assertThat(this.output.getErr()).contains('Hello Error');
		assertThat(this.output.getErr()).doesNotContain('Hello World');
	}
	@Test
	public void captureShouldBeAssertable() {
		System.out.println('Hello World');
		assertThat(this.output).contains('Hello World');
	}
}
/*
package org.springframework.boot.test.system;
/**
class OutputCaptureTests {
	private PrintStream originalOut;
	private PrintStream originalErr;
	private TestPrintStream systemOut;
	private TestPrintStream systemErr;
	private final TestOutputCapture output = new TestOutputCapture();
	@BeforeEach
	void replaceSystemStreams() {
		this.originalOut = System.out;
		this.originalErr = System.err;
		this.systemOut = new TestPrintStream();
		this.systemErr = new TestPrintStream();
		System.setOut(this.systemOut);
		System.setErr(this.systemErr);
	}
	@AfterEach
	void restoreSystemStreams() {
		System.setOut(this.originalOut);
		System.setErr(this.originalErr);
	}
	@Test
	void pushWhenEmptyStartsCapture() {
		System.out.print('A');
		this.output.push();
		System.out.print('B');
		assertThat(this.output).isEqualTo('B');
	}
	@Test
	void pushWhenHasExistingStartsNewCapture() {
		System.out.print('A');
		this.output.push();
		System.out.print('B');
		this.output.push();
		System.out.print('C');
		assertThat(this.output).isEqualTo('BC');
	}
	@Test
	void popWhenEmptyThrowsException() {
		assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(this.output::pop);
	}
	@Test
	void popWhenHasExistingEndsCapture() {
		this.output.push();
		System.out.print('A');
		this.output.pop();
		System.out.print('B');
		assertThat(this.systemOut).hasToString('AB');
	}
	@Test
	void captureAlsoWritesToSystemOut() {
		this.output.push();
		System.out.print('A');
		assertThat(this.systemOut).hasToString('A');
	}
	@Test
	void captureAlsoWritesToSystemErr() {
		this.output.push();
		System.err.print('A');
		assertThat(this.systemErr).hasToString('A');
	}
	@Test
	void lengthReturnsCapturedLength() {
		this.output.push();
		System.out.print('ABC');
		assertThat(this.output).hasSize(3);
	}
	@Test
	void charAtReturnsCapturedCharAt() {
		this.output.push();
		System.out.print('ABC');
		assertThat(this.output.charAt(1)).isEqualTo("B");
	}
	@Test
	void subSequenceReturnsCapturedSubSequence() {
		this.output.push();
		System.out.print('ABC');
		assertThat(this.output.subSequence(1, 3)).isEqualTo('BC');
	}
	@Test
	void getAllReturnsAllCapturedOutput() {
		pushAndPrint();
		assertThat(this.output.getAll()).isEqualTo('ABC');
	}
	@Test
	void toStringReturnsAllCapturedOutput() {
		pushAndPrint();
		assertThat(this.output).hasToString('ABC');
	}
	@Test
	void getErrReturnsOnlyCapturedErrOutput() {
		pushAndPrint();
		assertThat(this.output.getErr()).isEqualTo('B');
	}
	@Test
	void getOutReturnsOnlyCapturedOutOutput() {
		pushAndPrint();
		assertThat(this.output.getOut()).isEqualTo('AC');
	}
	@Test
	void getAllUsesCache() {
		pushAndPrint();
		for (int i = 0; i < 10; i++) {
			assertThat(this.output.getAll()).isEqualTo('ABC');
		}
		assertThat(this.output.buildCount).isOne();
		System.out.print('X');
		assertThat(this.output.getAll()).isEqualTo('ABCX');
		assertThat(this.output.buildCount).isEqualTo(2);
	}
	@Test
	void getOutUsesCache() {
		pushAndPrint();
		for (int i = 0; i < 10; i++) {
			assertThat(this.output.getOut()).isEqualTo('AC');
		}
		assertThat(this.output.buildCount).isOne();
		System.out.print('X');
		assertThat(this.output.getOut()).isEqualTo('ACX');
		assertThat(this.output.buildCount).isEqualTo(2);
	}
	@Test
	void getErrUsesCache() {
		pushAndPrint();
		for (int i = 0; i < 10; i++) {
			assertThat(this.output.getErr()).isEqualTo('B');
		}
		assertThat(this.output.buildCount).isOne();
		System.err.print('X');
		assertThat(this.output.getErr()).isEqualTo('BX');
		assertThat(this.output.buildCount).isEqualTo(2);
	}
	private void pushAndPrint() {
		this.output.push();
		System.out.print('A');
		System.err.print('B');
		System.out.print('C');
	}
	static class TestPrintStream extends PrintStream {
		TestPrintStream() {
			super(new ByteArrayOutputStream());
		}
		@Override
		public String toString() {
			return this.out.toString();
		}
	}
	static class TestOutputCapture extends OutputCapture {
		int buildCount;
		@Override
		String build(Predicate<Type> filter) {
			this.buildCount++;
			return super.build(filter);
		}
	}
}
/*
package org.springframework.boot.test.system;
/**
@ExtendWith(OutputCaptureExtension.class)
@ExtendWith(OutputExtensionExtendWithTests.BeforeAllExtension.class)
@ExtendWith(OutputExtensionExtendWithTests.BeforeEachExtension.class)
class OutputExtensionExtendWithTests {
	@Test
	void captureShouldReturnOutputCapturedBeforeAllTestMethod(CapturedOutput output) {
		assertThat(output).contains('Before all').doesNotContain('Hello');
	}
	@Test
	void captureShouldReturnOutputCapturedBeforeEachTestMethod(CapturedOutput output) {
		assertThat(output).contains('Before each').doesNotContain('Hello');
	}
	@Test
	void captureShouldReturnAllCapturedOutput(CapturedOutput output) {
		System.out.println('Hello World');
		System.err.println('Error!!!');
		assertThat(output).contains('Before all').contains('Before each').contains('Hello World').contains('Error!!!');
	}
	static class BeforeAllExtension implements BeforeAllCallback {
		@Override
		public void beforeAll(ExtensionContext context) {
			System.out.println('Before all');
		}
	}
	static class BeforeEachExtension implements BeforeEachCallback {
		@Override
		public void beforeEach(ExtensionContext context) {
			System.out.println('Before each');
		}
	}
}
/*
package org.springframework.boot.test.util;
/**
class TestPropertyValuesTests {
	private final ConfigurableEnvironment environment = new StandardEnvironment();
	@Test
	void ofStringArrayCreatesValues() {
		TestPropertyValues.of('spring:boot', 'version:latest').applyTo(this.environment);
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
		assertThat(this.environment.getProperty('version')).isEqualTo('latest');
	}
	@Test
	void ofIterableCreatesValues() {
		TestPropertyValues.of(Arrays.asList('spring:boot', 'version:latest')).applyTo(this.environment);
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
		assertThat(this.environment.getProperty('version')).isEqualTo('latest');
	}
	@Test
	void ofStreamCreatesValues() {
		TestPropertyValues.of(Stream.of('spring:boot', 'version:latest')).applyTo(this.environment);
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
		assertThat(this.environment.getProperty('version')).isEqualTo('latest');
	}
	@Test
	void ofMapCreatesValues() {
		Map<String, String> map = new LinkedHashMap<>();
		map.put('spring', 'boot');
		map.put('version', 'latest');
		TestPropertyValues.of(map).applyTo(this.environment);
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
		assertThat(this.environment.getProperty('version')).isEqualTo('latest');
	}
	@Test
	void ofMappedStreamCreatesValues() {
		TestPropertyValues.of(Stream.of('spring|boot', 'version|latest'), (string) -> {
			String[] split = string.split('\\|');
			return Pair.of(split[0], split[1]);
		}).applyTo(this.environment);
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
		assertThat(this.environment.getProperty('version')).isEqualTo('latest');
	}
	@Test
	void applyToEnvironmentShouldAttachConfigurationPropertySource() {
		TestPropertyValues.of('foo.bar=baz').applyTo(this.environment);
		PropertySource<?> source = this.environment.getPropertySources().get('configurationProperties');
		assertThat(source).isNotNull();
	}
	@Test
	void applyToDefaultPropertySource() {
		TestPropertyValues.of('foo.bar=baz', 'hello.world=hi').applyTo(this.environment);
		assertThat(this.environment.getProperty('foo.bar')).isEqualTo('baz');
		assertThat(this.environment.getProperty('hello.world')).isEqualTo('hi');
	}
	@Test
	void applyToSystemPropertySource() {
		TestPropertyValues.of('FOO_BAR=BAZ').applyTo(this.environment, Type.SYSTEM_ENVIRONMENT);
		assertThat(this.environment.getProperty('foo.bar')).isEqualTo('BAZ');
		assertThat(this.environment.getPropertySources()
			.contains('test-' + StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME)).isTrue();
	}
	@Test
	void applyToWithSpecificName() {
		TestPropertyValues.of('foo.bar=baz').applyTo(this.environment, Type.MAP, 'other');
		assertThat(this.environment.getPropertySources().get('other')).isNotNull();
		assertThat(this.environment.getProperty('foo.bar')).isEqualTo('baz');
	}
	@Test
	void applyToExistingNameAndDifferentTypeShouldOverrideExistingOne() {
		TestPropertyValues.of('foo.bar=baz', 'hello.world=hi').applyTo(this.environment, Type.MAP, 'other');
		TestPropertyValues.of('FOO_BAR=BAZ').applyTo(this.environment, Type.SYSTEM_ENVIRONMENT, 'other');
		assertThat(this.environment.getPropertySources().get('other'))
			.isInstanceOf(SystemEnvironmentPropertySource.class);
		assertThat(this.environment.getProperty('foo.bar')).isEqualTo('BAZ');
		assertThat(this.environment.getProperty('hello.world')).isNull();
	}
	@Test
	void applyToExistingNameAndSameTypeShouldMerge() {
		TestPropertyValues.of('foo.bar=baz', 'hello.world=hi').applyTo(this.environment, Type.MAP);
		TestPropertyValues.of('foo.bar=new').applyTo(this.environment, Type.MAP);
		assertThat(this.environment.getProperty('foo.bar')).isEqualTo('new');
		assertThat(this.environment.getProperty('hello.world')).isEqualTo('hi');
	}
	@Test
	void andShouldChainAndAddSingleKeyValue() {
		TestPropertyValues.of('foo.bar=baz')
			.and('hello.world=hi')
			.and('bling.blah=bing')
			.applyTo(this.environment, Type.MAP);
		assertThat(this.environment.getProperty('foo.bar')).isEqualTo('baz');
		assertThat(this.environment.getProperty('hello.world')).isEqualTo('hi');
		assertThat(this.environment.getProperty('bling.blah')).isEqualTo('bing');
	}
	@Test
	void applyToSystemPropertiesWithCallableShouldSetSystemProperties() {
		TestPropertyValues.of('foo=bar').applyToSystemProperties(() -> {
			assertThat(System.getProperty('foo')).isEqualTo('bar');
			return null;
		});
	}
	@Test
	void applyToSystemPropertiesWithRunnableShouldSetSystemProperties() {
		TestPropertyValues.of('foo=bar')
			.applyToSystemProperties(() -> assertThat(System.getProperty('foo')).isEqualTo('bar'));
	}
	@Test
	void applyToSystemPropertiesShouldRestoreSystemProperties() {
		System.setProperty('foo', 'bar1');
		System.clearProperty('baz');
		try {
			TestPropertyValues.of('foo=bar2', 'baz=bing').applyToSystemProperties(() -> {
				assertThat(System.getProperty('foo')).isEqualTo('bar2');
				assertThat(System.getProperty('baz')).isEqualTo('bing');
				return null;
			});
			assertThat(System.getProperty('foo')).isEqualTo('bar1');
			assertThat(System.getProperties()).doesNotContainKey('baz');
		}
		finally {
			System.clearProperty('foo');
		}
	}
	@Test
	void applyToSystemPropertiesWhenValueIsNullShouldRemoveProperty() {
		System.setProperty('foo', 'bar1');
		try {
			TestPropertyValues.of('foo').applyToSystemProperties(() -> {
				assertThat(System.getProperties()).doesNotContainKey('foo');
				return null;
			});
			assertThat(System.getProperty('foo')).isEqualTo('bar1');
		}
		finally {
			System.clearProperty('foo');
		}
	}
	@Test
	void pairOfCreatesPair() {
		Map<String, Object> map = new LinkedHashMap<>();
		Pair.of('spring', 'boot').addTo(map);
		assertThat(map).containsOnly(entry('spring', 'boot'));
	}
	@Test
	void pairOfWhenNameAndValueAreEmptyReturnsNull() {
		assertThat(Pair.of('', '')).isNull();
	}
	@Test
	void pairFromMapEntryCreatesPair() {
		Map<String, Object> map = new LinkedHashMap<>();
		Pair.fromMapEntry(entry('spring', 'boot')).addTo(map);
		assertThat(map).containsOnly(entry('spring', 'boot'));
	}
}
/*
package org.springframework.boot.test.util;
/**
class ApplicationContextTestUtilsTests {
	@Test
	void closeNull() {
		ApplicationContextTestUtils.closeAll(null);
	}
	@Test
	void closeNonClosableContext() {
		ApplicationContext mock = mock(ApplicationContext.class);
		ApplicationContextTestUtils.closeAll(mock);
	}
	@Test
	void closeContextAndParent() {
		ConfigurableApplicationContext mock = mock(ConfigurableApplicationContext.class);
		ConfigurableApplicationContext parent = mock(ConfigurableApplicationContext.class);
		given(mock.getParent()).willReturn(parent);
		given(parent.getParent()).willReturn(null);
		ApplicationContextTestUtils.closeAll(mock);
		then(mock).should().getParent();
		then(mock).should().close();
		then(parent).should().getParent();
		then(parent).should().close();
	}
}
/*
package org.springframework.boot.test.json;
/**
class GsonTesterTests extends AbstractJsonMarshalTesterTests {
	@Test
	void initFieldsWhenTestIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> GsonTester.initFields(null, new GsonBuilder().create()))
			.withMessageContaining('TestInstance must not be null');
	}
	@Test
	void initFieldsWhenMarshallerIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> GsonTester.initFields(new InitFieldsTestClass(), (Gson) null))
			.withMessageContaining('Marshaller must not be null');
	}
	@Test
	void initFieldsShouldSetNullFields() {
		InitFieldsTestClass test = new InitFieldsTestClass();
		assertThat(test.test).isNull();
		assertThat(test.base).isNull();
		GsonTester.initFields(test, new GsonBuilder().create());
		assertThat(test.test).isNotNull();
		assertThat(test.base).isNotNull();
		assertThat(test.test.getType().resolve()).isEqualTo(List.class);
		assertThat(test.test.getType().resolveGeneric()).isEqualTo(ExampleObject.class);
	}
	@Override
	protected AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type) {
		return new GsonTester<>(resourceLoadClass, type, new GsonBuilder().create());
	}
	abstract static class InitFieldsBaseClass {
		public GsonTester<ExampleObject> base;
		public GsonTester<ExampleObject> baseSet = new GsonTester<>(InitFieldsBaseClass.class,
				ResolvableType.forClass(ExampleObject.class), new GsonBuilder().create());
	}
	static class InitFieldsTestClass extends InitFieldsBaseClass {
		public GsonTester<List<ExampleObject>> test;
		public GsonTester<ExampleObject> testSet = new GsonTester<>(InitFieldsBaseClass.class,
				ResolvableType.forClass(ExampleObject.class), new GsonBuilder().create());
	}
}
/*
package org.springframework.boot.test.json;
/**
class JsonbTesterTests extends AbstractJsonMarshalTesterTests {
	@Test
	void initFieldsWhenTestIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> JsonbTester.initFields(null, JsonbBuilder.create()))
			.withMessageContaining('TestInstance must not be null');
	}
	@Test
	void initFieldsWhenMarshallerIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> JsonbTester.initFields(new InitFieldsTestClass(), (Jsonb) null))
			.withMessageContaining('Marshaller must not be null');
	}
	@Test
	void initFieldsShouldSetNullFields() {
		InitFieldsTestClass test = new InitFieldsTestClass();
		assertThat(test.test).isNull();
		assertThat(test.base).isNull();
		JsonbTester.initFields(test, JsonbBuilder.create());
		assertThat(test.test).isNotNull();
		assertThat(test.base).isNotNull();
		assertThat(test.test.getType().resolve()).isEqualTo(List.class);
		assertThat(test.test.getType().resolveGeneric()).isEqualTo(ExampleObject.class);
	}
	@Override
	protected AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type) {
		return new JsonbTester<>(resourceLoadClass, type, JsonbBuilder.create());
	}
	abstract static class InitFieldsBaseClass {
		public JsonbTester<ExampleObject> base;
		public JsonbTester<ExampleObject> baseSet = new JsonbTester<>(InitFieldsBaseClass.class,
				ResolvableType.forClass(ExampleObject.class), JsonbBuilder.create());
	}
	static class InitFieldsTestClass extends InitFieldsBaseClass {
		public JsonbTester<List<ExampleObject>> test;
		public JsonbTester<ExampleObject> testSet = new JsonbTester<>(InitFieldsBaseClass.class,
				ResolvableType.forClass(ExampleObject.class), JsonbBuilder.create());
	}
}
/*
package org.springframework.boot.test.json;
/**
@ExtendWith(OutputCaptureExtension.class)
@ClassPathOverrides('org.json:json:20140107')
class DuplicateJsonObjectContextCustomizerFactoryTests {
	private CapturedOutput output;
	@BeforeEach
	void setup(CapturedOutput output) {
		this.output = output;
	}
	@Test
	void warningForMultipleVersions() {
		new DuplicateJsonObjectContextCustomizerFactory().createContextCustomizer(null, null)
			.customizeContext(null, null);
		assertThat(this.output).contains('Found multiple occurrences of org.json.JSONObject on the class path:');
	}
}
/*
package org.springframework.boot.test.json;
/**
public class ExampleObject {
	private String name;
	private int age;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return this.age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		ExampleObject other = (ExampleObject) obj;
		return ObjectUtils.nullSafeEquals(this.name, other.name) && ObjectUtils.nullSafeEquals(this.age, other.age);
	}
	@Override
	public int hashCode() {
		return 0;
	}
	@Override
	public String toString() {
		return this.name + ' ' + this.age;
	}
}
/*
package org.springframework.boot.test.json;
/**
class JsonContentTests {
	private static final String JSON = '{\'name\':\'spring\', \'age\':100}';
	private static final ResolvableType TYPE = ResolvableType.forClass(ExampleObject.class);
	@Test
	void createWhenResourceLoadClassIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new JsonContent<ExampleObject>(null, TYPE, JSON, Configuration.defaultConfiguration()))
			.withMessageContaining('ResourceLoadClass must not be null');
	}
	@Test
	void createWhenJsonIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new JsonContent<ExampleObject>(getClass(), TYPE, null, Configuration.defaultConfiguration()))
			.withMessageContaining('JSON must not be null');
	}
	@Test
	void createWhenConfigurationIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new JsonContent<ExampleObject>(getClass(), TYPE, JSON, null))
			.withMessageContaining('Configuration must not be null');
	}
	@Test
	void createWhenTypeIsNullShouldCreateContent() {
		JsonContent<ExampleObject> content = new JsonContent<>(getClass(), null, JSON,
				Configuration.defaultConfiguration());
		assertThat(content).isNotNull();
	}
	@Test
	@SuppressWarnings('deprecation')
	void assertThatShouldReturnJsonContentAssert() {
		JsonContent<ExampleObject> content = new JsonContent<>(getClass(), TYPE, JSON,
				Configuration.defaultConfiguration());
		assertThat(content.assertThat()).isInstanceOf(JsonContentAssert.class);
	}
	@Test
	void getJsonShouldReturnJson() {
		JsonContent<ExampleObject> content = new JsonContent<>(getClass(), TYPE, JSON,
				Configuration.defaultConfiguration());
		assertThat(content.getJson()).isEqualTo(JSON);
	}
	@Test
	void toStringWhenHasTypeShouldReturnString() {
		JsonContent<ExampleObject> content = new JsonContent<>(getClass(), TYPE, JSON,
				Configuration.defaultConfiguration());
		assertThat(content.toString()).isEqualTo('JsonContent ' + JSON + ' created from ' + TYPE);
	}
	@Test
	void toStringWhenHasNoTypeShouldReturnString() {
		JsonContent<ExampleObject> content = new JsonContent<>(getClass(), null, JSON,
				Configuration.defaultConfiguration());
		assertThat(content.toString()).isEqualTo('JsonContent ' + JSON);
	}
}
/*
package org.springframework.boot.test.json;
/**
class JacksonTesterTests extends AbstractJsonMarshalTesterTests {
	@Test
	void initFieldsWhenTestIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> JacksonTester.initFields(null, new ObjectMapper()))
			.withMessageContaining('TestInstance must not be null');
	}
	@Test
	void initFieldsWhenMarshallerIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> JacksonTester.initFields(new InitFieldsTestClass(), (ObjectMapper) null))
			.withMessageContaining('Marshaller must not be null');
	}
	@Test
	void initFieldsShouldSetNullFields() {
		InitFieldsTestClass test = new InitFieldsTestClass();
		assertThat(test.test).isNull();
		assertThat(test.base).isNull();
		JacksonTester.initFields(test, new ObjectMapper());
		assertThat(test.test).isNotNull();
		assertThat(test.base).isNotNull();
		assertThat(test.test.getType().resolve()).isEqualTo(List.class);
		assertThat(test.test.getType().resolveGeneric()).isEqualTo(ExampleObject.class);
	}
	@Override
	protected AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type) {
		return new JacksonTester<>(resourceLoadClass, type, new ObjectMapper());
	}
	abstract static class InitFieldsBaseClass {
		public JacksonTester<ExampleObject> base;
		public JacksonTester<ExampleObject> baseSet = new JacksonTester<>(InitFieldsBaseClass.class,
				ResolvableType.forClass(ExampleObject.class), new ObjectMapper());
	}
	static class InitFieldsTestClass extends InitFieldsBaseClass {
		public JacksonTester<List<ExampleObject>> test;
		public JacksonTester<ExampleObject> testSet = new JacksonTester<>(InitFieldsBaseClass.class,
				ResolvableType.forClass(ExampleObject.class), new ObjectMapper());
	}
}
/*
package org.springframework.boot.test.json;
/**
class JacksonTesterIntegrationTests {
	private JacksonTester<ExampleObject> simpleJson;
	private JacksonTester<ExampleObjectWithView> jsonWithView;
	private JacksonTester<List<ExampleObject>> listJson;
	private JacksonTester<Map<String, Integer>> mapJson;
	private JacksonTester<String> stringJson;
	private static final String JSON = '{\'name\':\'Spring\',\'age\':123}';
	@Test
	void typicalTest() throws Exception {
		JacksonTester.initFields(this, new ObjectMapper());
		String example = JSON;
		assertThat(this.simpleJson.parse(example).getObject().getName()).isEqualTo('Spring');
	}
	@Test
	void typicalListTest() throws Exception {
		JacksonTester.initFields(this, new ObjectMapper());
		String example = '[' + JSON + ']';
		assertThat(this.listJson.parse(example)).asInstanceOf(InstanceOfAssertFactories.LIST).hasSize(1);
		assertThat(this.listJson.parse(example).getObject().get(0).getName()).isEqualTo('Spring');
	}
	@Test
	void typicalMapTest() throws Exception {
		JacksonTester.initFields(this, new ObjectMapper());
		Map<String, Integer> map = new LinkedHashMap<>();
		map.put('a', 1);
		map.put('b', 2);
		assertThat(this.mapJson.write(map)).extractingJsonPathNumberValue('@.a').isEqualTo(1);
	}
	@Test
	void stringLiteral() throws Exception {
		JacksonTester.initFields(this, new ObjectMapper());
		String stringWithSpecialCharacters = 'myString';
		assertThat(this.stringJson.write(stringWithSpecialCharacters)).extractingJsonPathStringValue('@')
			.isEqualTo(stringWithSpecialCharacters);
	}
	@Test
	void parseSpecialCharactersTest() throws Exception {
		JacksonTester.initFields(this, new ObjectMapper());
		// Confirms that the handling of special characters is symmetrical between
		// the serialization (through the JacksonTester) and the parsing (through
		// json-path). By default json-path uses SimpleJson as its parser, which has a
		// slightly different behavior to Jackson and breaks the symmetry. JacksonTester
		// configures json-path to use Jackson for evaluating the path expressions and
		// restores the symmetry. See gh-15727
		String stringWithSpecialCharacters = '\u0006\u007F';
		assertThat(this.stringJson.write(stringWithSpecialCharacters)).extractingJsonPathStringValue('@')
			.isEqualTo(stringWithSpecialCharacters);
	}
	@Test
	void writeWithView() throws Exception {
		JacksonTester.initFields(this, JsonMapper.builder().disable(MapperFeature.DEFAULT_VIEW_INCLUSION).build());
		ExampleObjectWithView object = new ExampleObjectWithView();
		object.setName('Spring');
		object.setAge(123);
		JsonContent<ExampleObjectWithView> content = this.jsonWithView.forView(ExampleObjectWithView.TestView.class)
			.write(object);
		assertThat(content).extractingJsonPathStringValue('@.name').isEqualTo('Spring');
		assertThat(content).doesNotHaveJsonPathValue('age');
	}
	@Test
	void readWithResourceAndView() throws Exception {
		JacksonTester.initFields(this, JsonMapper.builder().disable(MapperFeature.DEFAULT_VIEW_INCLUSION).build());
		ByteArrayResource resource = new ByteArrayResource(JSON.getBytes());
		ObjectContent<ExampleObjectWithView> content = this.jsonWithView.forView(ExampleObjectWithView.TestView.class)
			.read(resource);
		assertThat(content.getObject().getName()).isEqualTo('Spring');
		assertThat(content.getObject().getAge()).isZero();
	}
	@Test
	void readWithReaderAndView() throws Exception {
		JacksonTester.initFields(this, JsonMapper.builder().disable(MapperFeature.DEFAULT_VIEW_INCLUSION).build());
		Reader reader = new StringReader(JSON);
		ObjectContent<ExampleObjectWithView> content = this.jsonWithView.forView(ExampleObjectWithView.TestView.class)
			.read(reader);
		assertThat(content.getObject().getName()).isEqualTo('Spring');
		assertThat(content.getObject().getAge()).isZero();
	}
}
/*
package org.springframework.boot.test.json;
/**
public class ExampleObjectWithView {
	@JsonView(TestView.class)
	private String name;
	private int age;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return this.age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		ExampleObjectWithView other = (ExampleObjectWithView) obj;
		return ObjectUtils.nullSafeEquals(this.name, other.name) && ObjectUtils.nullSafeEquals(this.age, other.age);
	}
	@Override
	public int hashCode() {
		return 0;
	}
	@Override
	public String toString() {
		return this.name + ' ' + this.age;
	}
	static class TestView {
	}
}
/*
package org.springframework.boot.test.json;
/**
class ObjectContentTests {
	private static final ExampleObject OBJECT = new ExampleObject();
	private static final ResolvableType TYPE = ResolvableType.forClass(ExampleObject.class);
	@Test
	void createWhenObjectIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ObjectContent<ExampleObject>(TYPE, null))
			.withMessageContaining('Object must not be null');
	}
	@Test
	void createWhenTypeIsNullShouldCreateContent() {
		ObjectContent<ExampleObject> content = new ObjectContent<>(null, OBJECT);
		assertThat(content).isNotNull();
	}
	@Test
	void assertThatShouldReturnObjectContentAssert() {
		ObjectContent<ExampleObject> content = new ObjectContent<>(TYPE, OBJECT);
		assertThat(content.assertThat()).isInstanceOf(ObjectContentAssert.class);
	}
	@Test
	void getObjectShouldReturnObject() {
		ObjectContent<ExampleObject> content = new ObjectContent<>(TYPE, OBJECT);
		assertThat(content.getObject()).isEqualTo(OBJECT);
	}
	@Test
	void toStringWhenHasTypeShouldReturnString() {
		ObjectContent<ExampleObject> content = new ObjectContent<>(TYPE, OBJECT);
		assertThat(content.toString()).isEqualTo('ObjectContent ' + OBJECT + ' created from ' + TYPE);
	}
	@Test
	void toStringWhenHasNoTypeShouldReturnString() {
		ObjectContent<ExampleObject> content = new ObjectContent<>(null, OBJECT);
		assertThat(content.toString()).isEqualTo('ObjectContent ' + OBJECT);
	}
}
/*
package org.springframework.boot.test.json;
/**
class ObjectContentAssertTests {
	private static final ExampleObject SOURCE = new ExampleObject();
	private static final ExampleObject DIFFERENT;
	static {
		DIFFERENT = new ExampleObject();
		DIFFERENT.setAge(123);
	}
	@Test
	void isEqualToWhenObjectsAreEqualShouldPass() {
		assertThat(forObject(SOURCE)).isEqualTo(SOURCE);
	}
	@Test
	void isEqualToWhenObjectsAreDifferentShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forObject(SOURCE)).isEqualTo(DIFFERENT));
	}
	@Test
	void asArrayForArrayShouldReturnObjectArrayAssert() {
		ExampleObject[] source = new ExampleObject[] { SOURCE };
		assertThat(forObject(source)).asArray().containsExactly(SOURCE);
	}
	@Test
	void asArrayForNonArrayShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(forObject(SOURCE)).asArray());
	}
	@Test
	void asMapForMapShouldReturnMapAssert() {
		Map<String, ExampleObject> source = Collections.singletonMap('a', SOURCE);
		assertThat(forObject(source)).asMap().containsEntry('a', SOURCE);
	}
	@Test
	void asMapForNonMapShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(forObject(SOURCE)).asMap());
	}
	private AssertProvider<ObjectContentAssert<Object>> forObject(Object source) {
		return () -> new ObjectContentAssert<>(source);
	}
}
/*
package org.springframework.boot.test.json;
/**
class BasicJsonTesterTests {
	private static final String JSON = '{\'spring\':[\'boot\',\'framework\']}';
	private final BasicJsonTester json = new BasicJsonTester(getClass());
	@Test
	void createWhenResourceLoadClassIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new BasicJsonTester(null))
			.withMessageContaining('ResourceLoadClass must not be null');
	}
	@Test
	void fromJsonStringShouldReturnJsonContent() {
		assertThat(this.json.from(JSON)).isEqualToJson('source.json');
	}
	@Test
	void fromResourceStringShouldReturnJsonContent() {
		assertThat(this.json.from('source.json')).isEqualToJson(JSON);
	}
	@Test
	void fromResourceStringWithClassShouldReturnJsonContent() {
		assertThat(this.json.from('source.json', getClass())).isEqualToJson(JSON);
	}
	@Test
	void fromByteArrayShouldReturnJsonContent() {
		assertThat(this.json.from(JSON.getBytes())).isEqualToJson('source.json');
	}
	@Test
	void fromFileShouldReturnJsonContent(@TempDir Path temp) throws Exception {
		File file = new File(temp.toFile(), 'file.json');
		FileCopyUtils.copy(JSON.getBytes(), file);
		assertThat(this.json.from(file)).isEqualToJson('source.json');
	}
	@Test
	void fromInputStreamShouldReturnJsonContent() {
		InputStream inputStream = new ByteArrayInputStream(JSON.getBytes());
		assertThat(this.json.from(inputStream)).isEqualToJson('source.json');
	}
	@Test
	void fromResourceShouldReturnJsonContent() {
		Resource resource = new ByteArrayResource(JSON.getBytes());
		assertThat(this.json.from(resource)).isEqualToJson('source.json');
	}
}
/*
package org.springframework.boot.test.json;
/**
class JsonContentAssertTests {
	private static final String SOURCE = loadJson('source.json');
	private static final String LENIENT_SAME = loadJson('lenient-same.json');
	private static final String DIFFERENT = loadJson('different.json');
	private static final String TYPES = loadJson('types.json');
	private static final String SIMPSONS = loadJson('simpsons.json');
	private static final String NULLS = loadJson('nulls.json');
	private static final JSONComparator COMPARATOR = new DefaultComparator(JSONCompareMode.LENIENT);
	@TempDir
	public Path tempDir;
	private File temp;
	@BeforeEach
	void setup() {
		this.temp = new File(this.tempDir.toFile(), 'file.json');
	}
	@Test
	void isEqualToWhenStringIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualTo(LENIENT_SAME);
	}
	@Test
	void isEqualToWhenNullActualShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(forJson(null)).isEqualTo(SOURCE));
	}
	@Test
	void isEqualToWhenStringIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualTo(DIFFERENT));
	}
	@Test
	void isEqualToWhenResourcePathIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualTo('lenient-same.json');
	}
	@Test
	void isEqualToWhenResourcePathIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualTo('different.json'));
	}
	@Test
	void isEqualToWhenBytesAreMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualTo(LENIENT_SAME.getBytes());
	}
	@Test
	void isEqualToWhenBytesAreNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualTo(DIFFERENT.getBytes()));
	}
	@Test
	void isEqualToWhenFileIsMatchingShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isEqualTo(createFile(LENIENT_SAME));
	}
	@Test
	void isEqualToWhenFileIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualTo(createFile(DIFFERENT)));
	}
	@Test
	void isEqualToWhenInputStreamIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualTo(createInputStream(LENIENT_SAME));
	}
	@Test
	void isEqualToWhenInputStreamIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualTo(createInputStream(DIFFERENT)));
	}
	@Test
	void isEqualToWhenResourceIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualTo(createResource(LENIENT_SAME));
	}
	@Test
	void isEqualToWhenResourceIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualTo(createResource(DIFFERENT)));
	}
	@Test
	void isEqualToJsonWhenStringIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(LENIENT_SAME);
	}
	@Test
	void isEqualToJsonWhenNullActualShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(null)).isEqualToJson(SOURCE));
	}
	@Test
	void isEqualToJsonWhenStringIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(DIFFERENT));
	}
	@Test
	void isEqualToJsonWhenResourcePathIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson('lenient-same.json');
	}
	@Test
	void isEqualToJsonWhenResourcePathIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson('different.json'));
	}
	@Test
	void isEqualToJsonWhenResourcePathAndClassIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson('lenient-same.json', getClass());
	}
	@Test
	void isEqualToJsonWhenResourcePathAndClassIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson('different.json', getClass()));
	}
	@Test
	void isEqualToJsonWhenBytesAreMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(LENIENT_SAME.getBytes());
	}
	@Test
	void isEqualToJsonWhenBytesAreNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(DIFFERENT.getBytes()));
	}
	@Test
	void isEqualToJsonWhenFileIsMatchingShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isEqualToJson(createFile(LENIENT_SAME));
	}
	@Test
	void isEqualToJsonWhenFileIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(createFile(DIFFERENT)));
	}
	@Test
	void isEqualToJsonWhenInputStreamIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(createInputStream(LENIENT_SAME));
	}
	@Test
	void isEqualToJsonWhenInputStreamIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(createInputStream(DIFFERENT)));
	}
	@Test
	void isEqualToJsonWhenResourceIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(createResource(LENIENT_SAME));
	}
	@Test
	void isEqualToJsonWhenResourceIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(createResource(DIFFERENT)));
	}
	@Test
	void isStrictlyEqualToJsonWhenStringIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isStrictlyEqualToJson(SOURCE);
	}
	@Test
	void isStrictlyEqualToJsonWhenStringIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isStrictlyEqualToJson(LENIENT_SAME));
	}
	@Test
	void isStrictlyEqualToJsonWhenResourcePathIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isStrictlyEqualToJson('source.json');
	}
	@Test
	void isStrictlyEqualToJsonWhenResourcePathIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isStrictlyEqualToJson('lenient-same.json'));
	}
	@Test
	void isStrictlyEqualToJsonWhenResourcePathAndClassIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isStrictlyEqualToJson('source.json', getClass());
	}
	@Test
	void isStrictlyEqualToJsonWhenResourcePathAndClassIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isStrictlyEqualToJson('lenient-same.json', getClass()));
	}
	@Test
	void isStrictlyEqualToJsonWhenBytesAreMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isStrictlyEqualToJson(SOURCE.getBytes());
	}
	@Test
	void isStrictlyEqualToJsonWhenBytesAreNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isStrictlyEqualToJson(LENIENT_SAME.getBytes()));
	}
	@Test
	void isStrictlyEqualToJsonWhenFileIsMatchingShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isStrictlyEqualToJson(createFile(SOURCE));
	}
	@Test
	void isStrictlyEqualToJsonWhenFileIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isStrictlyEqualToJson(createFile(LENIENT_SAME)));
	}
	@Test
	void isStrictlyEqualToJsonWhenInputStreamIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isStrictlyEqualToJson(createInputStream(SOURCE));
	}
	@Test
	void isStrictlyEqualToJsonWhenInputStreamIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isStrictlyEqualToJson(createInputStream(LENIENT_SAME)));
	}
	@Test
	void isStrictlyEqualToJsonWhenResourceIsMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isStrictlyEqualToJson(createResource(SOURCE));
	}
	@Test
	void isStrictlyEqualToJsonWhenResourceIsNotMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isStrictlyEqualToJson(createResource(LENIENT_SAME)));
	}
	@Test
	void isEqualToJsonWhenStringIsMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(LENIENT_SAME, JSONCompareMode.LENIENT);
	}
	@Test
	void isEqualToJsonWhenStringIsNotMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(DIFFERENT, JSONCompareMode.LENIENT));
	}
	@Test
	void isEqualToJsonWhenResourcePathIsMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson('lenient-same.json', JSONCompareMode.LENIENT);
	}
	@Test
	void isEqualToJsonWhenResourcePathIsNotMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson('different.json', JSONCompareMode.LENIENT));
	}
	@Test
	void isEqualToJsonWhenResourcePathAndClassIsMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson('lenient-same.json', getClass(), JSONCompareMode.LENIENT);
	}
	@Test
	void isEqualToJsonWhenResourcePathAndClassIsNotMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isEqualToJson('different.json', getClass(), JSONCompareMode.LENIENT));
	}
	@Test
	void isEqualToJsonWhenBytesAreMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(LENIENT_SAME.getBytes(), JSONCompareMode.LENIENT);
	}
	@Test
	void isEqualToJsonWhenBytesAreNotMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(DIFFERENT.getBytes(), JSONCompareMode.LENIENT));
	}
	@Test
	void isEqualToJsonWhenFileIsMatchingAndLenientShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isEqualToJson(createFile(LENIENT_SAME), JSONCompareMode.LENIENT);
	}
	@Test
	void isEqualToJsonWhenFileIsNotMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isEqualToJson(createFile(DIFFERENT), JSONCompareMode.LENIENT));
	}
	@Test
	void isEqualToJsonWhenInputStreamIsMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(createInputStream(LENIENT_SAME), JSONCompareMode.LENIENT);
	}
	@Test
	void isEqualToJsonWhenInputStreamIsNotMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isEqualToJson(createInputStream(DIFFERENT), JSONCompareMode.LENIENT));
	}
	@Test
	void isEqualToJsonWhenResourceIsMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(createResource(LENIENT_SAME), JSONCompareMode.LENIENT);
	}
	@Test
	void isEqualToJsonWhenResourceIsNotMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isEqualToJson(createResource(DIFFERENT), JSONCompareMode.LENIENT));
	}
	@Test
	void isEqualToJsonWhenStringIsMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(LENIENT_SAME, COMPARATOR);
	}
	@Test
	void isEqualToJsonWhenStringIsNotMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(DIFFERENT, COMPARATOR));
	}
	@Test
	void isEqualToJsonWhenResourcePathIsMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson('lenient-same.json', COMPARATOR);
	}
	@Test
	void isEqualToJsonWhenResourcePathIsNotMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson('different.json', COMPARATOR));
	}
	@Test
	void isEqualToJsonWhenResourcePathAndClassAreMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson('lenient-same.json', getClass(), COMPARATOR);
	}
	@Test
	void isEqualToJsonWhenResourcePathAndClassAreNotMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson('different.json', getClass(), COMPARATOR));
	}
	@Test
	void isEqualToJsonWhenBytesAreMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(LENIENT_SAME.getBytes(), COMPARATOR);
	}
	@Test
	void isEqualToJsonWhenBytesAreNotMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(DIFFERENT.getBytes(), COMPARATOR));
	}
	@Test
	void isEqualToJsonWhenFileIsMatchingAndComparatorShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isEqualToJson(createFile(LENIENT_SAME), COMPARATOR);
	}
	@Test
	void isEqualToJsonWhenFileIsNotMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(createFile(DIFFERENT), COMPARATOR));
	}
	@Test
	void isEqualToJsonWhenInputStreamIsMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(createInputStream(LENIENT_SAME), COMPARATOR);
	}
	@Test
	void isEqualToJsonWhenInputStreamIsNotMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(createInputStream(DIFFERENT), COMPARATOR));
	}
	@Test
	void isEqualToJsonWhenResourceIsMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isEqualToJson(createResource(LENIENT_SAME), COMPARATOR);
	}
	@Test
	void isEqualToJsonWhenResourceIsNotMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isEqualToJson(createResource(DIFFERENT), COMPARATOR));
	}
	@Test
	void isNotEqualToWhenStringIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualTo(LENIENT_SAME));
	}
	@Test
	void isNotEqualToWhenNullActualShouldPass() {
		assertThat(forJson(null)).isNotEqualTo(SOURCE);
	}
	@Test
	void isNotEqualToWhenStringIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualTo(DIFFERENT);
	}
	@Test
	void isNotEqualToWhenResourcePathIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualTo('lenient-same.json'));
	}
	@Test
	void isNotEqualToWhenResourcePathIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualTo('different.json');
	}
	@Test
	void isNotEqualToWhenBytesAreMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualTo(LENIENT_SAME.getBytes()));
	}
	@Test
	void isNotEqualToWhenBytesAreNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualTo(DIFFERENT.getBytes());
	}
	@Test
	void isNotEqualToWhenFileIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualTo(createFile(LENIENT_SAME)));
	}
	@Test
	void isNotEqualToWhenFileIsNotMatchingShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isNotEqualTo(createFile(DIFFERENT));
	}
	@Test
	void isNotEqualToWhenInputStreamIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualTo(createInputStream(LENIENT_SAME)));
	}
	@Test
	void isNotEqualToWhenInputStreamIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualTo(createInputStream(DIFFERENT));
	}
	@Test
	void isNotEqualToWhenResourceIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualTo(createResource(LENIENT_SAME)));
	}
	@Test
	void isNotEqualToWhenResourceIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualTo(createResource(DIFFERENT));
	}
	@Test
	void isNotEqualToJsonWhenStringIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(LENIENT_SAME));
	}
	@Test
	void isNotEqualToJsonWhenNullActualShouldPass() {
		assertThat(forJson(null)).isNotEqualToJson(SOURCE);
	}
	@Test
	void isNotEqualToJsonWhenStringIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(DIFFERENT);
	}
	@Test
	void isNotEqualToJsonWhenResourcePathIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson('lenient-same.json'));
	}
	@Test
	void isNotEqualToJsonWhenResourcePathIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson('different.json');
	}
	@Test
	void isNotEqualToJsonWhenResourcePathAndClassAreMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson('lenient-same.json', getClass()));
	}
	@Test
	void isNotEqualToJsonWhenResourcePathAndClassAreNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson('different.json', getClass());
	}
	@Test
	void isNotEqualToJsonWhenBytesAreMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(LENIENT_SAME.getBytes()));
	}
	@Test
	void isNotEqualToJsonWhenBytesAreNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(DIFFERENT.getBytes());
	}
	@Test
	void isNotEqualToJsonWhenFileIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(createFile(LENIENT_SAME)));
	}
	@Test
	void isNotEqualToJsonWhenFileIsNotMatchingShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createFile(DIFFERENT));
	}
	@Test
	void isNotEqualToJsonWhenInputStreamIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(createInputStream(LENIENT_SAME)));
	}
	@Test
	void isNotEqualToJsonWhenInputStreamIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createInputStream(DIFFERENT));
	}
	@Test
	void isNotEqualToJsonWhenResourceIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(createResource(LENIENT_SAME)));
	}
	@Test
	void isNotEqualToJsonWhenResourceIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createResource(DIFFERENT));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenStringIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(SOURCE));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenStringIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(LENIENT_SAME);
	}
	@Test
	void isNotStrictlyEqualToJsonWhenResourcePathIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson('source.json'));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenResourcePathIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson('lenient-same.json');
	}
	@Test
	void isNotStrictlyEqualToJsonWhenResourcePathAndClassAreMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson('source.json', getClass()));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenResourcePathAndClassAreNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson('lenient-same.json', getClass());
	}
	@Test
	void isNotStrictlyEqualToJsonWhenBytesAreMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(SOURCE.getBytes()));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenBytesAreNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(LENIENT_SAME.getBytes());
	}
	@Test
	void isNotStrictlyEqualToJsonWhenFileIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(createFile(SOURCE)));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenFileIsNotMatchingShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(createFile(LENIENT_SAME));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenInputStreamIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(createInputStream(SOURCE)));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenInputStreamIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(createInputStream(LENIENT_SAME));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenResourceIsMatchingShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(createResource(SOURCE)));
	}
	@Test
	void isNotStrictlyEqualToJsonWhenResourceIsNotMatchingShouldPass() {
		assertThat(forJson(SOURCE)).isNotStrictlyEqualToJson(createResource(LENIENT_SAME));
	}
	@Test
	void isNotEqualToJsonWhenStringIsMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(LENIENT_SAME, JSONCompareMode.LENIENT));
	}
	@Test
	void isNotEqualToJsonWhenStringIsNotMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(DIFFERENT, JSONCompareMode.LENIENT);
	}
	@Test
	void isNotEqualToJsonWhenResourcePathIsMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isNotEqualToJson('lenient-same.json', JSONCompareMode.LENIENT));
	}
	@Test
	void isNotEqualToJsonWhenResourcePathIsNotMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson('different.json', JSONCompareMode.LENIENT);
	}
	@Test
	void isNotEqualToJsonWhenResourcePathAndClassAreMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(forJson(SOURCE))
			.isNotEqualToJson('lenient-same.json', getClass(), JSONCompareMode.LENIENT));
	}
	@Test
	void isNotEqualToJsonWhenResourcePathAndClassAreNotMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson('different.json', getClass(), JSONCompareMode.LENIENT);
	}
	@Test
	void isNotEqualToJsonWhenBytesAreMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isNotEqualToJson(LENIENT_SAME.getBytes(), JSONCompareMode.LENIENT));
	}
	@Test
	void isNotEqualToJsonWhenBytesAreNotMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(DIFFERENT.getBytes(), JSONCompareMode.LENIENT);
	}
	@Test
	void isNotEqualToJsonWhenFileIsMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isNotEqualToJson(createFile(LENIENT_SAME), JSONCompareMode.LENIENT));
	}
	@Test
	void isNotEqualToJsonWhenFileIsNotMatchingAndLenientShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createFile(DIFFERENT), JSONCompareMode.LENIENT);
	}
	@Test
	void isNotEqualToJsonWhenInputStreamIsMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(forJson(SOURCE))
			.isNotEqualToJson(createInputStream(LENIENT_SAME), JSONCompareMode.LENIENT));
	}
	@Test
	void isNotEqualToJsonWhenInputStreamIsNotMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createInputStream(DIFFERENT), JSONCompareMode.LENIENT);
	}
	@Test
	void isNotEqualToJsonWhenResourceIsMatchingAndLenientShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(forJson(SOURCE))
			.isNotEqualToJson(createResource(LENIENT_SAME), JSONCompareMode.LENIENT));
	}
	@Test
	void isNotEqualToJsonWhenResourceIsNotMatchingAndLenientShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createResource(DIFFERENT), JSONCompareMode.LENIENT);
	}
	@Test
	void isNotEqualToJsonWhenStringIsMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(LENIENT_SAME, COMPARATOR));
	}
	@Test
	void isNotEqualToJsonWhenStringIsNotMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(DIFFERENT, COMPARATOR);
	}
	@Test
	void isNotEqualToJsonWhenResourcePathIsMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson('lenient-same.json', COMPARATOR));
	}
	@Test
	void isNotEqualToJsonWhenResourcePathIsNotMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson('different.json', COMPARATOR);
	}
	@Test
	void isNotEqualToJsonWhenResourcePathAndClassAreMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isNotEqualToJson('lenient-same.json', getClass(), COMPARATOR));
	}
	@Test
	void isNotEqualToJsonWhenResourcePathAndClassAreNotMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson('different.json', getClass(), COMPARATOR);
	}
	@Test
	void isNotEqualToJsonWhenBytesAreMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(LENIENT_SAME.getBytes(), COMPARATOR));
	}
	@Test
	void isNotEqualToJsonWhenBytesAreNotMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(DIFFERENT.getBytes(), COMPARATOR);
	}
	@Test
	void isNotEqualToJsonWhenFileIsMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(createFile(LENIENT_SAME), COMPARATOR));
	}
	@Test
	void isNotEqualToJsonWhenFileIsNotMatchingAndComparatorShouldPass() throws Exception {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createFile(DIFFERENT), COMPARATOR);
	}
	@Test
	void isNotEqualToJsonWhenInputStreamIsMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class).isThrownBy(
				() -> assertThat(forJson(SOURCE)).isNotEqualToJson(createInputStream(LENIENT_SAME), COMPARATOR));
	}
	@Test
	void isNotEqualToJsonWhenInputStreamIsNotMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createInputStream(DIFFERENT), COMPARATOR);
	}
	@Test
	void isNotEqualToJsonWhenResourceIsMatchingAndComparatorShouldFail() {
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SOURCE)).isNotEqualToJson(createResource(LENIENT_SAME), COMPARATOR));
	}
	@Test
	void isNotEqualToJsonWhenResourceIsNotMatchingAndComparatorShouldPass() {
		assertThat(forJson(SOURCE)).isNotEqualToJson(createResource(DIFFERENT), COMPARATOR);
	}
	@Test
	void hasJsonPathForPresentAndNotNull() {
		assertThat(forJson(NULLS)).hasJsonPath('valuename');
	}
	@Test
	void hasJsonPathForPresentAndNull() {
		assertThat(forJson(NULLS)).hasJsonPath('nullname');
	}
	@Test
	void hasJsonPathForNotPresent() {
		String expression = 'missing';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(NULLS)).hasJsonPath(expression))
			.withMessageContaining('No JSON path \'' + expression + '\' found');
	}
	@Test
	void hasJsonPathValue() {
		assertThat(forJson(TYPES)).hasJsonPathValue('$.str');
	}
	@Test
	void hasJsonPathValueForAnEmptyArray() {
		assertThat(forJson(TYPES)).hasJsonPathValue('$.emptyArray');
	}
	@Test
	void hasJsonPathValueForAnEmptyMap() {
		assertThat(forJson(TYPES)).hasJsonPathValue('$.emptyMap');
	}
	@Test
	void hasJsonPathValueForANullValue() {
		String expression = 'nullname';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(NULLS)).hasJsonPathValue(expression))
			.withMessageContaining('No value at JSON path \'' + expression + '\'');
	}
	@Test
	void hasJsonPathValueForMissingValue() {
		String expression = 'missing';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(NULLS)).hasJsonPathValue(expression))
			.withMessageContaining('No value at JSON path \'' + expression + '\'');
	}
	@Test
	void hasJsonPathValueForIndefinitePathWithResults() {
		assertThat(forJson(SIMPSONS)).hasJsonPathValue('$.familyMembers[?(@.name == "Bart")]');
	}
	@Test
	void hasJsonPathValueForIndefinitePathWithEmptyResults() {
		String expression = '$.familyMembers[?(@.name == "Dilbert")]';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SIMPSONS)).hasJsonPathValue(expression))
			.withMessageContaining('No value at JSON path \'' + expression + '\'');
	}
	@Test
	void doesNotHaveJsonPathForMissing() {
		assertThat(forJson(NULLS)).doesNotHaveJsonPath('missing');
	}
	@Test
	void doesNotHaveJsonPathForNull() {
		String expression = 'nullname';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(NULLS)).doesNotHaveJsonPath(expression))
			.withMessageContaining('Expecting no JSON path \'' + expression + '\'');
	}
	@Test
	void doesNotHaveJsonPathForPresent() {
		String expression = 'valuename';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(NULLS)).doesNotHaveJsonPath(expression))
			.withMessageContaining('Expecting no JSON path \'' + expression + '\'');
	}
	@Test
	void doesNotHaveJsonPathValue() {
		assertThat(forJson(TYPES)).doesNotHaveJsonPathValue('$.bogus');
	}
	@Test
	void doesNotHaveJsonPathValueForAnEmptyArray() {
		String expression = '$.emptyArray';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).doesNotHaveJsonPathValue(expression))
			.withMessageContaining('Expected no value at JSON path \'' + expression + '\' but found: []');
	}
	@Test
	void doesNotHaveJsonPathValueForAnEmptyMap() {
		String expression = '$.emptyMap';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).doesNotHaveJsonPathValue(expression))
			.withMessageContaining('Expected no value at JSON path \'' + expression + '\' but found: {}');
	}
	@Test
	void doesNotHaveJsonPathValueForIndefinitePathWithResults() {
		String expression = '$.familyMembers[?(@.name == "Bart")]';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SIMPSONS)).doesNotHaveJsonPathValue(expression))
			.withMessageContaining(
					'Expected no value at JSON path \'' + expression + '\' but found: [{\'name\':\'Bart\'}]');
	}
	@Test
	void doesNotHaveJsonPathValueForIndefinitePathWithEmptyResults() {
		assertThat(forJson(SIMPSONS)).doesNotHaveJsonPathValue('$.familyMembers[?(@.name == "Dilbert")]');
	}
	@Test
	void doesNotHaveJsonPathValueForNull() {
		assertThat(forJson(NULLS)).doesNotHaveJsonPathValue('nullname');
	}
	@Test
	void hasEmptyJsonPathValueForAnEmptyString() {
		assertThat(forJson(TYPES)).hasEmptyJsonPathValue('$.emptyString');
	}
	@Test
	void hasEmptyJsonPathValueForAnEmptyArray() {
		assertThat(forJson(TYPES)).hasEmptyJsonPathValue('$.emptyArray');
	}
	@Test
	void hasEmptyJsonPathValueForAnEmptyMap() {
		assertThat(forJson(TYPES)).hasEmptyJsonPathValue('$.emptyMap');
	}
	@Test
	void hasEmptyJsonPathValueForIndefinitePathWithEmptyResults() {
		assertThat(forJson(SIMPSONS)).hasEmptyJsonPathValue('$.familyMembers[?(@.name == "Dilbert")]');
	}
	@Test
	void hasEmptyJsonPathValueForIndefinitePathWithResults() {
		String expression = '$.familyMembers[?(@.name == "Bart")]';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SIMPSONS)).hasEmptyJsonPathValue(expression))
			.withMessageContaining(
					'Expected an empty value at JSON path \'' + expression + '\' but found: [{\'name\':\'Bart\'}]');
	}
	@Test
	void hasEmptyJsonPathValueForWhitespace() {
		String expression = '$.whitespace';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).hasEmptyJsonPathValue(expression))
			.withMessageContaining('Expected an empty value at JSON path \'' + expression + '\' but found: "    "');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForString() {
		assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue('$.str');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForNumber() {
		assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue('$.num');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForBoolean() {
		assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue('$.bool');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForArray() {
		assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue('$.arr');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForMap() {
		assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue('$.colorMap');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForIndefinitePathWithResults() {
		assertThat(forJson(SIMPSONS)).doesNotHaveEmptyJsonPathValue('$.familyMembers[?(@.name == "Bart")]');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForIndefinitePathWithEmptyResults() {
		String expression = '$.familyMembers[?(@.name == "Dilbert")]';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(SIMPSONS)).doesNotHaveEmptyJsonPathValue(expression))
			.withMessageContaining('Expected a non-empty value at JSON path \'' + expression + '\' but found: []');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForAnEmptyString() {
		String expression = '$.emptyString';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue(expression))
			.withMessageContaining('Expected a non-empty value at JSON path \'' + expression + '\' but found: ""');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForForAnEmptyArray() {
		String expression = '$.emptyArray';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue(expression))
			.withMessageContaining('Expected a non-empty value at JSON path \'' + expression + '\' but found: []');
	}
	@Test
	void doesNotHaveEmptyJsonPathValueForAnEmptyMap() {
		String expression = '$.emptyMap';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).doesNotHaveEmptyJsonPathValue(expression))
			.withMessageContaining('Expected a non-empty value at JSON path \'' + expression + '\' but found: {}');
	}
	@Test
	void hasJsonPathStringValue() {
		assertThat(forJson(TYPES)).hasJsonPathStringValue('$.str');
	}
	@Test
	void hasJsonPathStringValueForAnEmptyString() {
		assertThat(forJson(TYPES)).hasJsonPathStringValue('$.emptyString');
	}
	@Test
	void hasJsonPathStringValueForNonString() {
		String expression = '$.bool';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).hasJsonPathStringValue(expression))
			.withMessageContaining('Expected a string at JSON path \'' + expression + '\' but found: true');
	}
	@Test
	void hasJsonPathNumberValue() {
		assertThat(forJson(TYPES)).hasJsonPathNumberValue('$.num');
	}
	@Test
	void hasJsonPathNumberValueForNonNumber() {
		String expression = '$.bool';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).hasJsonPathNumberValue(expression))
			.withMessageContaining('Expected a number at JSON path \'' + expression + '\' but found: true');
	}
	@Test
	void hasJsonPathBooleanValue() {
		assertThat(forJson(TYPES)).hasJsonPathBooleanValue('$.bool');
	}
	@Test
	void hasJsonPathBooleanValueForNonBoolean() {
		String expression = '$.num';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).hasJsonPathBooleanValue(expression))
			.withMessageContaining('Expected a boolean at JSON path \'' + expression + '\' but found: 5');
	}
	@Test
	void hasJsonPathArrayValue() {
		assertThat(forJson(TYPES)).hasJsonPathArrayValue('$.arr');
	}
	@Test
	void hasJsonPathArrayValueForAnEmptyArray() {
		assertThat(forJson(TYPES)).hasJsonPathArrayValue('$.emptyArray');
	}
	@Test
	void hasJsonPathArrayValueForNonArray() {
		String expression = '$.str';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).hasJsonPathArrayValue(expression))
			.withMessageContaining('Expected an array at JSON path \'' + expression + '\' but found: "foo"');
	}
	@Test
	void hasJsonPathMapValue() {
		assertThat(forJson(TYPES)).hasJsonPathMapValue('$.colorMap');
	}
	@Test
	void hasJsonPathMapValueForAnEmptyMap() {
		assertThat(forJson(TYPES)).hasJsonPathMapValue('$.emptyMap');
	}
	@Test
	void hasJsonPathMapValueForNonMap() {
		String expression = '$.str';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).hasJsonPathMapValue(expression))
			.withMessageContaining('Expected a map at JSON path \'' + expression + '\' but found: "foo"');
	}
	@Test
	void extractingJsonPathValue() {
		assertThat(forJson(TYPES)).extractingJsonPathValue('@.str').isEqualTo('foo');
	}
	@Test
	void extractingJsonPathValueForMissing() {
		assertThat(forJson(TYPES)).extractingJsonPathValue('@.bogus').isNull();
	}
	@Test
	void extractingJsonPathStringValue() {
		assertThat(forJson(TYPES)).extractingJsonPathStringValue('@.str').isEqualTo('foo');
	}
	@Test
	void extractingJsonPathStringValueForMissing() {
		assertThat(forJson(TYPES)).extractingJsonPathStringValue('@.bogus').isNull();
	}
	@Test
	void extractingJsonPathStringValueForEmptyString() {
		assertThat(forJson(TYPES)).extractingJsonPathStringValue('@.emptyString').isEmpty();
	}
	@Test
	void extractingJsonPathStringValueForWrongType() {
		String expression = '$.num';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).extractingJsonPathStringValue(expression))
			.withMessageContaining('Expected a string at JSON path \'' + expression + '\' but found: 5');
	}
	@Test
	void extractingJsonPathNumberValue() {
		assertThat(forJson(TYPES)).extractingJsonPathNumberValue('@.num').isEqualTo(5);
	}
	@Test
	void extractingJsonPathNumberValueForMissing() {
		assertThat(forJson(TYPES)).extractingJsonPathNumberValue('@.bogus').isNull();
	}
	@Test
	void extractingJsonPathNumberValueForWrongType() {
		String expression = '$.str';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).extractingJsonPathNumberValue(expression))
			.withMessageContaining('Expected a number at JSON path \'' + expression + '\' but found: "foo"');
	}
	@Test
	void extractingJsonPathBooleanValue() {
		assertThat(forJson(TYPES)).extractingJsonPathBooleanValue('@.bool').isTrue();
	}
	@Test
	void extractingJsonPathBooleanValueForMissing() {
		assertThat(forJson(TYPES)).extractingJsonPathBooleanValue('@.bogus').isNull();
	}
	@Test
	void extractingJsonPathBooleanValueForWrongType() {
		String expression = '$.str';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).extractingJsonPathBooleanValue(expression))
			.withMessageContaining('Expected a boolean at JSON path \'' + expression + '\' but found: "foo"');
	}
	@Test
	void extractingJsonPathArrayValue() {
		assertThat(forJson(TYPES)).extractingJsonPathArrayValue('@.arr').containsExactly(42);
	}
	@Test
	void extractingJsonPathArrayValueForMissing() {
		assertThat(forJson(TYPES)).extractingJsonPathArrayValue('@.bogus').isNull();
	}
	@Test
	void extractingJsonPathArrayValueForEmpty() {
		assertThat(forJson(TYPES)).extractingJsonPathArrayValue('@.emptyArray').isEmpty();
	}
	@Test
	void extractingJsonPathArrayValueForWrongType() {
		String expression = '$.str';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).extractingJsonPathArrayValue(expression))
			.withMessageContaining('Expected an array at JSON path \'' + expression + '\' but found: "foo"');
	}
	@Test
	void extractingJsonPathMapValue() {
		assertThat(forJson(TYPES)).extractingJsonPathMapValue('@.colorMap').contains(entry('red', 'rojo'));
	}
	@Test
	void extractingJsonPathMapValueForMissing() {
		assertThat(forJson(TYPES)).extractingJsonPathMapValue('@.bogus').isNull();
	}
	@Test
	void extractingJsonPathMapValueForEmpty() {
		assertThat(forJson(TYPES)).extractingJsonPathMapValue('@.emptyMap').isEmpty();
	}
	@Test
	void extractingJsonPathMapValueForWrongType() {
		String expression = '$.str';
		assertThatExceptionOfType(AssertionError.class)
			.isThrownBy(() -> assertThat(forJson(TYPES)).extractingJsonPathMapValue(expression))
			.withMessageContaining('Expected a map at JSON path \'' + expression + '\' but found: "foo"');
	}
	@Test
	void isNullWhenActualIsNullShouldPass() {
		assertThat(forJson(null)).isNull();
	}
	private File createFile(String content) throws IOException {
		File file = this.temp;
		FileCopyUtils.copy(content.getBytes(), file);
		return file;
	}
	private InputStream createInputStream(String content) {
		return new ByteArrayInputStream(content.getBytes());
	}
	private Resource createResource(String content) {
		return new ByteArrayResource(content.getBytes());
	}
	private static String loadJson(String path) {
		try {
			ClassPathResource resource = new ClassPathResource(path, JsonContentAssertTests.class);
			return new String(FileCopyUtils.copyToByteArray(resource.getInputStream()));
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	private AssertProvider<JsonContentAssert> forJson(String json) {
		return () -> new JsonContentAssert(JsonContentAssertTests.class, json);
	}
}
/*
package org.springframework.boot.test.json;
/**
class GsonTesterIntegrationTests {
	private GsonTester<ExampleObject> simpleJson;
	private GsonTester<List<ExampleObject>> listJson;
	private GsonTester<Map<String, Integer>> mapJson;
	private GsonTester<String> stringJson;
	private Gson gson;
	private static final String JSON = '{\'name\':\'Spring\',\'age\':123}';
	@BeforeEach
	void setup() {
		this.gson = new Gson();
		GsonTester.initFields(this, this.gson);
	}
	@Test
	void typicalTest() throws Exception {
		String example = JSON;
		assertThat(this.simpleJson.parse(example).getObject().getName()).isEqualTo('Spring');
	}
	@Test
	void typicalListTest() throws Exception {
		String example = '[' + JSON + ']';
		assertThat(this.listJson.parse(example)).asInstanceOf(InstanceOfAssertFactories.LIST).hasSize(1);
		assertThat(this.listJson.parse(example).getObject().get(0).getName()).isEqualTo('Spring');
	}
	@Test
	void typicalMapTest() throws Exception {
		Map<String, Integer> map = new LinkedHashMap<>();
		map.put('a', 1);
		map.put('b', 2);
		assertThat(this.mapJson.write(map)).extractingJsonPathNumberValue('@.a').isEqualTo(1);
	}
	@Test
	void stringLiteral() throws Exception {
		String stringWithSpecialCharacters = 'myString';
		assertThat(this.stringJson.write(stringWithSpecialCharacters)).extractingJsonPathStringValue('@')
			.isEqualTo(stringWithSpecialCharacters);
	}
}
/*
package org.springframework.boot.test.json;
/**
abstract class AbstractJsonMarshalTesterTests {
	private static final String JSON = '{\'name\':\'Spring\',\'age\':123}';
	private static final String MAP_JSON = '{\'a\':' + JSON + '}';
	private static final String ARRAY_JSON = '[' + JSON + ']';
	private static final ExampleObject OBJECT = createExampleObject('Spring', 123);
	private static final ResolvableType TYPE = ResolvableType.forClass(ExampleObject.class);
	@Test
	void writeShouldReturnJsonContent() throws Exception {
		JsonContent<Object> content = createTester(TYPE).write(OBJECT);
		assertThat(content).isEqualToJson(JSON);
	}
	@Test
	void writeListShouldReturnJsonContent() throws Exception {
		ResolvableType type = ResolvableTypes.get('listOfExampleObject');
		List<ExampleObject> value = Collections.singletonList(OBJECT);
		JsonContent<Object> content = createTester(type).write(value);
		assertThat(content).isEqualToJson(ARRAY_JSON);
	}
	@Test
	void writeArrayShouldReturnJsonContent() throws Exception {
		ResolvableType type = ResolvableTypes.get('arrayOfExampleObject');
		ExampleObject[] value = new ExampleObject[] { OBJECT };
		JsonContent<Object> content = createTester(type).write(value);
		assertThat(content).isEqualToJson(ARRAY_JSON);
	}
	@Test
	void writeMapShouldReturnJsonContent() throws Exception {
		ResolvableType type = ResolvableTypes.get('mapOfExampleObject');
		Map<String, Object> value = new LinkedHashMap<>();
		value.put('a', OBJECT);
		JsonContent<Object> content = createTester(type).write(value);
		assertThat(content).isEqualToJson(MAP_JSON);
	}
	@Test
	void createWhenResourceLoadClassIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> createTester(null, ResolvableType.forClass(ExampleObject.class)))
			.withMessageContaining('ResourceLoadClass must not be null');
	}
	@Test
	void createWhenTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> createTester(getClass(), null))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void parseBytesShouldReturnObject() throws Exception {
		AbstractJsonMarshalTester<Object> tester = createTester(TYPE);
		assertThat(tester.parse(JSON.getBytes())).isEqualTo(OBJECT);
	}
	@Test
	void parseStringShouldReturnObject() throws Exception {
		AbstractJsonMarshalTester<Object> tester = createTester(TYPE);
		assertThat(tester.parse(JSON)).isEqualTo(OBJECT);
	}
	@Test
	void readResourcePathShouldReturnObject() throws Exception {
		AbstractJsonMarshalTester<Object> tester = createTester(TYPE);
		assertThat(tester.read('example.json')).isEqualTo(OBJECT);
	}
	@Test
	void readFileShouldReturnObject(@TempDir Path temp) throws Exception {
		File file = new File(temp.toFile(), 'example.json');
		FileCopyUtils.copy(JSON.getBytes(), file);
		AbstractJsonMarshalTester<Object> tester = createTester(TYPE);
		assertThat(tester.read(file)).isEqualTo(OBJECT);
	}
	@Test
	void readInputStreamShouldReturnObject() throws Exception {
		InputStream stream = new ByteArrayInputStream(JSON.getBytes());
		AbstractJsonMarshalTester<Object> tester = createTester(TYPE);
		assertThat(tester.read(stream)).isEqualTo(OBJECT);
	}
	@Test
	void readResourceShouldReturnObject() throws Exception {
		Resource resource = new ByteArrayResource(JSON.getBytes());
		AbstractJsonMarshalTester<Object> tester = createTester(TYPE);
		assertThat(tester.read(resource)).isEqualTo(OBJECT);
	}
	@Test
	void readReaderShouldReturnObject() throws Exception {
		Reader reader = new StringReader(JSON);
		AbstractJsonMarshalTester<Object> tester = createTester(TYPE);
		assertThat(tester.read(reader)).isEqualTo(OBJECT);
	}
	@Test
	void parseListShouldReturnContent() throws Exception {
		ResolvableType type = ResolvableTypes.get('listOfExampleObject');
		AbstractJsonMarshalTester<Object> tester = createTester(type);
		assertThat(tester.parse(ARRAY_JSON)).asInstanceOf(InstanceOfAssertFactories.LIST).containsOnly(OBJECT);
	}
	@Test
	void parseArrayShouldReturnContent() throws Exception {
		ResolvableType type = ResolvableTypes.get('arrayOfExampleObject');
		AbstractJsonMarshalTester<Object> tester = createTester(type);
		assertThat(tester.parse(ARRAY_JSON)).asArray().containsOnly(OBJECT);
	}
	@Test
	void parseMapShouldReturnContent() throws Exception {
		ResolvableType type = ResolvableTypes.get('mapOfExampleObject');
		AbstractJsonMarshalTester<Object> tester = createTester(type);
		assertThat(tester.parse(MAP_JSON)).asMap().containsEntry('a', OBJECT);
	}
	protected static ExampleObject createExampleObject(String name, int age) {
		ExampleObject exampleObject = new ExampleObject();
		exampleObject.setName(name);
		exampleObject.setAge(age);
		return exampleObject;
	}
	protected final AbstractJsonMarshalTester<Object> createTester(ResolvableType type) {
		return createTester(AbstractJsonMarshalTesterTests.class, type);
	}
	protected abstract AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type);
	/**
	 * Access to field backed by {@link ResolvableType}.
	 */
	static class ResolvableTypes {
		public List<ExampleObject> listOfExampleObject;
		public ExampleObject[] arrayOfExampleObject;
		public Map<String, ExampleObject> mapOfExampleObject;
		static ResolvableType get(String name) {
			Field field = ReflectionUtils.findField(ResolvableTypes.class, name);
			return ResolvableType.forField(field);
		}
	}
}
/*
package org.springframework.boot.test.mock.web;
/**
@DirtiesContext
@ExtendWith(SpringExtension.class)
@ContextConfiguration(loader = SpringBootContextLoader.class)
@WebAppConfiguration('src/test/webapp')
class SpringBootMockServletContextTests implements ServletContextAware {
	private ServletContext servletContext;
	@Override
	public void setServletContext(ServletContext servletContext) {
		this.servletContext = servletContext;
	}
	@Test
	void getResourceLocation() throws Exception {
		testResource('/inwebapp', 'src/test/webapp');
		testResource('/inmetainfresources', '/META-INF/resources');
		testResource('/inresources', '/resources');
		testResource('/instatic', '/static');
		testResource('/inpublic', '/public');
	}
	private void testResource(String path, String expectedLocation) throws MalformedURLException {
		URL resource = this.servletContext.getResource(path);
		assertThat(resource).isNotNull();
		assertThat(resource.getPath()).contains(expectedLocation);
	}
	// gh-2654
	@Test
	void getRootUrlExistsAndIsEmpty() throws Exception {
		SpringBootMockServletContext context = new SpringBootMockServletContext('src/test/doesntexist') {
			@Override
			protected String getResourceLocation(String path) {
				// Don"t include the Spring Boot defaults for this test
				return getResourceBasePathLocation(path);
			}
		};
		URL resource = context.getResource('/');
		assertThat(resource).isNotNull();
		File file = new File(URLDecoder.decode(resource.getPath(), StandardCharsets.UTF_8));
		assertThat(file).exists().isDirectory();
		String[] contents = file.list((dir, name) -> !('.'.equals(name) || '..'.equals(name)));
		assertThat(contents).isNotNull();
		assertThat(contents).isEmpty();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@ContextHierarchy({ @ContextConfiguration(classes = SpyBeanOnContextHierarchyIntegrationTests.ParentConfig.class),
		@ContextConfiguration(classes = SpyBeanOnContextHierarchyIntegrationTests.ChildConfig.class) })
class SpyBeanOnContextHierarchyIntegrationTests {
	@Autowired
	private ChildConfig childConfig;
	@Test
	void testSpying() {
		ApplicationContext context = this.childConfig.getContext();
		ApplicationContext parentContext = context.getParent();
		assertThat(parentContext
			.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleService.class)).hasSize(1);
		assertThat(parentContext
			.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class))
			.isEmpty();
		assertThat(context.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleService.class))
			.isEmpty();
		assertThat(context
			.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class))
			.hasSize(1);
		assertThat(context.getBean(org.springframework.boot.test.mock.mockito.example.ExampleService.class))
			.isNotNull();
		assertThat(context.getBean(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class))
			.isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	@SpyBean(org.springframework.boot.test.mock.mockito.example.SimpleExampleService.class)
	static class ParentConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@SpyBean(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class)
	static class ChildConfig implements ApplicationContextAware {
		private ApplicationContext context;
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) {
			this.context = applicationContext;
		}
		ApplicationContext getContext() {
			return this.context;
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanWithAopProxyAndNotProxyTargetAwareTests {
	@SpyBean(proxyTargetAware = false)
	private DateService dateService;
	@Test
	void verifyShouldUseProxyTarget() {
		this.dateService.getDate(false);
		then(this.dateService).should().getDate(false);
		assertThatExceptionOfType(UnfinishedVerificationException.class).isThrownBy(() -> reset(this.dateService));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching(proxyTargetClass = true)
	@Import(DateService.class)
	static class Config {
		@Bean
		CacheResolver cacheResolver(CacheManager cacheManager) {
			SimpleCacheResolver resolver = new SimpleCacheResolver();
			resolver.setCacheManager(cacheManager);
			return resolver;
		}
		@Bean
		ConcurrentMapCacheManager cacheManager() {
			ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();
			cacheManager.setCacheNames(Arrays.asList('test'));
			return cacheManager;
		}
	}
	@Service
	public static class DateService {
		@Cacheable(cacheNames = 'test')
		public Long getDate(boolean arg) {
			return System.nanoTime();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class SpringBootMockResolverTests {
	@Test
	void testStaticTarget() {
		MyServiceImpl myService = new MyServiceImpl();
		MyService proxy = ProxyFactory.getProxy(MyService.class, new SingletonTargetSource(myService));
		Object target = new SpringBootMockResolver().resolve(proxy);
		assertThat(target).isInstanceOf(MyServiceImpl.class);
	}
	@Test
	void testNonStaticTarget() {
		MyServiceImpl myService = new MyServiceImpl();
		MyService proxy = ProxyFactory.getProxy(MyService.class, new HotSwappableTargetSource(myService));
		Object target = new SpringBootMockResolver().resolve(proxy);
		assertThat(target).isInstanceOf(SpringProxy.class);
	}
	private interface MyService {
		int a();
	}
	private static final class MyServiceImpl implements MyService {
		@Override
		public int a() {
			return 1;
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockitoContextCustomizerTests {
	private static final Set<MockDefinition> NO_DEFINITIONS = Collections.emptySet();
	@Test
	void hashCodeAndEquals() {
		MockDefinition d1 = createTestMockDefinition(ExampleService.class);
		MockDefinition d2 = createTestMockDefinition(ExampleServiceCaller.class);
		MockitoContextCustomizer c1 = new MockitoContextCustomizer(NO_DEFINITIONS);
		MockitoContextCustomizer c2 = new MockitoContextCustomizer(new LinkedHashSet<>(Arrays.asList(d1, d2)));
		MockitoContextCustomizer c3 = new MockitoContextCustomizer(new LinkedHashSet<>(Arrays.asList(d2, d1)));
		assertThat(c2).hasSameHashCodeAs(c3);
		assertThat(c1).isEqualTo(c1).isNotEqualTo(c2);
		assertThat(c2).isEqualTo(c2).isEqualTo(c3).isNotEqualTo(c1);
	}
	private MockDefinition createTestMockDefinition(Class<?> typeToMock) {
		return new MockDefinition(null, ResolvableType.forClass(typeToMock), null, null, false, null, null);
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnTestFieldForNewBeanIntegrationTests {
	@SpyBean
	private SimpleExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.caller.getService()).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanWithNameOnTestFieldForMultipleExistingBeansTests {
	@SpyBean(name = 'two')
	private SimpleExampleStringGenericService spy;
	@Test
	void testSpying() {
		MockingDetails mockingDetails = Mockito.mockingDetails(this.spy);
		assertThat(mockingDetails.isSpy()).isTrue();
		assertThat(mockingDetails.getMockCreationSettings().getMockName()).hasToString('two');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		SimpleExampleStringGenericService one() {
			return new SimpleExampleStringGenericService('one');
		}
		@Bean
		SimpleExampleStringGenericService two() {
			return new SimpleExampleStringGenericService('two');
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@SpringBootTest(classes = AbstractMockBeanOnGenericTests.TestConfiguration.class)
abstract class AbstractMockBeanOnGenericTests<T extends AbstractMockBeanOnGenericTests.Thing<U>, U extends AbstractMockBeanOnGenericTests.Something> {
	@Autowired
	@SuppressWarnings('unused')
	private T thing;
	@MockBean
	private U something;
	@Test
	void mockBeanShouldResolveConcreteType() {
		assertThat(this.something).isInstanceOf(SomethingImpl.class);
	}
	abstract static class Thing<T extends AbstractMockBeanOnGenericTests.Something> {
		@Autowired
		private T something;
		T getSomething() {
			return this.something;
		}
		void setSomething(T something) {
			this.something = something;
		}
	}
	static class SomethingImpl extends Something {
	}
	static class ThingImpl extends Thing<SomethingImpl> {
	}
	static class Something {
	}
	@Configuration
	static class TestConfiguration {
		@Bean
		ThingImpl thing() {
			return new ThingImpl();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@Configuration(proxyBeanMethods = false)
@Import({ ExampleServiceCaller.class, SimpleExampleService.class })
public class SpyBeanOnTestFieldForExistingBeanConfig {
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnConfigurationClassForExistingBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.caller.getService()).should().greeting();
	}
	@SuppressWarnings('removal')
	@Configuration(proxyBeanMethods = false)
	@SpyBean(SimpleExampleService.class)
	@Import({ ExampleServiceCaller.class, SimpleExampleService.class })
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@ExtendWith(SpringExtension.class)
@Deprecated(since = '3.4.0', forRemoval = true)
class MockBeanOnConfigurationFieldForExistingBeanIntegrationTests {
	@Autowired
	private Config config;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.config.exampleService.greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ExampleServiceCaller.class, FailingExampleService.class })
	static class Config {
		@MockBean
		private ExampleService exampleService;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockDefinitionTests {
	private static final ResolvableType EXAMPLE_SERVICE_TYPE = ResolvableType.forClass(ExampleService.class);
	@Test
	void classToMockMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new MockDefinition(null, null, null, null, false, null, null))
			.withMessageContaining('TypeToMock must not be null');
	}
	@Test
	void createWithDefaults() {
		MockDefinition definition = new MockDefinition(null, EXAMPLE_SERVICE_TYPE, null, null, false, null, null);
		assertThat(definition.getName()).isNull();
		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE);
		assertThat(definition.getExtraInterfaces()).isEmpty();
		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_DEFAULTS);
		assertThat(definition.isSerializable()).isFalse();
		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER);
		assertThat(definition.getQualifier()).isNull();
	}
	@Test
	void createExplicit() {
		QualifierDefinition qualifier = mock(QualifierDefinition.class);
		MockDefinition definition = new MockDefinition('name', EXAMPLE_SERVICE_TYPE,
				new Class<?>[] { ExampleExtraInterface.class }, Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE,
				qualifier);
		assertThat(definition.getName()).isEqualTo('name');
		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE);
		assertThat(definition.getExtraInterfaces()).containsExactly(ExampleExtraInterface.class);
		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS);
		assertThat(definition.isSerializable()).isTrue();
		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE);
		assertThat(definition.isProxyTargetAware()).isFalse();
		assertThat(definition.getQualifier()).isEqualTo(qualifier);
	}
	@Test
	void createMock() {
		MockDefinition definition = new MockDefinition('name', EXAMPLE_SERVICE_TYPE,
				new Class<?>[] { ExampleExtraInterface.class }, Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE,
				null);
		ExampleService mock = definition.createMock();
		MockCreationSettings<?> settings = Mockito.mockingDetails(mock).getMockCreationSettings();
		assertThat(mock).isInstanceOf(ExampleService.class);
		assertThat(mock).isInstanceOf(ExampleExtraInterface.class);
		assertThat(settings.getMockName()).hasToString('name');
		assertThat(settings.getDefaultAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS);
		assertThat(settings.isSerializable()).isTrue();
		assertThat(MockReset.get(mock)).isEqualTo(MockReset.BEFORE);
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@Configuration(proxyBeanMethods = false)
@Import({ ExampleServiceCaller.class, FailingExampleService.class })
public class MockBeanOnTestFieldForExistingBeanConfig {
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class RealExampleService implements ExampleService {
	private final String greeting;
	public RealExampleService(String greeting) {
		this.greeting = greeting;
	}
	@Override
	public String greeting() {
		return this.greeting;
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class ExampleGenericStringServiceCaller {
	private final ExampleGenericService<String> stringService;
	public ExampleGenericStringServiceCaller(ExampleGenericService<String> stringService) {
		this.stringService = stringService;
	}
	public ExampleGenericService<String> getStringService() {
		return this.stringService;
	}
	public String sayGreeting() {
		return 'I say ' + this.stringService.greeting();
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@CustomQualifier
public class CustomQualifierExampleService implements ExampleService {
	@Override
	public String greeting() {
		return 'CustomQualifier';
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomQualifier {
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class SimpleExampleService extends RealExampleService {
	public SimpleExampleService() {
		super('simple');
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class SimpleExampleStringGenericService implements ExampleGenericService<String> {
	private final String greeting;
	public SimpleExampleStringGenericService() {
		this('simple');
	}
	public SimpleExampleStringGenericService(String greeting) {
		this.greeting = greeting;
	}
	@Override
	public String greeting() {
		return this.greeting;
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class ExampleServiceCaller {
	private final ExampleService service;
	public ExampleServiceCaller(ExampleService service) {
		this.service = service;
	}
	public ExampleService getService() {
		return this.service;
	}
	public String sayGreeting() {
		return 'I say ' + this.service.greeting();
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@Service
public class FailingExampleService implements ExampleService {
	@Override
	public String greeting() {
		throw new IllegalStateException('Failed');
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class ExampleGenericServiceCaller {
	private final ExampleGenericService<Integer> integerService;
	private final ExampleGenericService<String> stringService;
	public ExampleGenericServiceCaller(ExampleGenericService<Integer> integerService,
			ExampleGenericService<String> stringService) {
		this.integerService = integerService;
		this.stringService = stringService;
	}
	public ExampleGenericService<Integer> getIntegerService() {
		return this.integerService;
	}
	public ExampleGenericService<String> getStringService() {
		return this.stringService;
	}
	public String sayGreeting() {
		return 'I say ' + this.integerService.greeting() + ' ' + this.stringService.greeting();
	}
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public interface ExampleGenericService<T> {
	T greeting();
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public interface ExampleService {
	String greeting();
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public interface ExampleExtraInterface {
	String doExtra();
}
/*
package org.springframework.boot.test.mock.mockito.example;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class SimpleExampleIntegerGenericService implements ExampleGenericService<Integer> {
	@Override
	public Integer greeting() {
		return 123;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@ContextHierarchy({ @ContextConfiguration(classes = MockBeanOnContextHierarchyIntegrationTests.ParentConfig.class),
		@ContextConfiguration(classes = MockBeanOnContextHierarchyIntegrationTests.ChildConfig.class) })
class MockBeanOnContextHierarchyIntegrationTests {
	@Autowired
	private ChildConfig childConfig;
	@Test
	void testMocking() {
		ApplicationContext context = this.childConfig.getContext();
		ApplicationContext parentContext = context.getParent();
		assertThat(parentContext
			.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleService.class)).hasSize(1);
		assertThat(parentContext
			.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class))
			.isEmpty();
		assertThat(context.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleService.class))
			.isEmpty();
		assertThat(context
			.getBeanNamesForType(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class))
			.hasSize(1);
		assertThat(context.getBean(org.springframework.boot.test.mock.mockito.example.ExampleService.class))
			.isNotNull();
		assertThat(context.getBean(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class))
			.isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	@MockBean(org.springframework.boot.test.mock.mockito.example.ExampleService.class)
	static class ParentConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@MockBean(org.springframework.boot.test.mock.mockito.example.ExampleServiceCaller.class)
	static class ChildConfig implements ApplicationContextAware {
		private ApplicationContext context;
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) {
			this.context = applicationContext;
		}
		ApplicationContext getContext() {
			return this.context;
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanWithAsyncInterfaceMethodIntegrationTests {
	@MockBean
	private Transformer transformer;
	@Autowired
	private MyService service;
	@Test
	void mockedMethodsAreNotAsync() {
		given(this.transformer.transform('foo')).willReturn('bar');
		assertThat(this.service.transform('foo')).isEqualTo('bar');
	}
	interface Transformer {
		@Async
		String transform(String input);
	}
	static class MyService {
		private final Transformer transformer;
		MyService(Transformer transformer) {
			this.transformer = transformer;
		}
		String transform(String input) {
			return this.transformer.transform(input);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAsync
	static class MyConfiguration {
		@Bean
		MyService myService(Transformer transformer) {
			return new MyService(transformer);
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class MockBeanWithSpringMethodRuleRepeatJUnit4IntegrationTests {
	@Rule
	public final SpringMethodRule springMethodRule = new SpringMethodRule();
	@MockBean
	private FirstService first;
	private static int invocations;
	@AfterClass
	public static void afterClass() {
		assertThat(invocations).isEqualTo(2);
	}
	@Test
	@Repeat(2)
	public void repeatedTest() {
		invocations++;
	}
	interface FirstService {
		String greeting();
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnTestFieldForExistingGenericBeanProducedByFactoryBeanIntegrationTests {
	// gh-40234
	@SpyBean(name = 'exampleService')
	private ExampleGenericService<String> exampleService;
	@Test
	void testSpying() {
		assertThat(Mockito.mockingDetails(this.exampleService).isSpy()).isTrue();
		assertThat(Mockito.mockingDetails(this.exampleService).getMockCreationSettings().getSpiedInstance())
			.isInstanceOf(SimpleExampleStringGenericService.class);
	}
	@Configuration(proxyBeanMethods = false)
	@Import(FactoryBeanRegistrar.class)
	static class SpyBeanOnTestFieldForExistingBeanConfig {
	}
	static class FactoryBeanRegistrar implements ImportBeanDefinitionRegistrar {
		@Override
		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {
			RootBeanDefinition definition = new RootBeanDefinition(ExampleGenericServiceFactoryBean.class);
			definition.setTargetType(ResolvableType.forClassWithGenerics(ExampleGenericServiceFactoryBean.class, null,
					ExampleGenericService.class));
			registry.registerBeanDefinition('exampleService', definition);
		}
	}
	static class ExampleGenericServiceFactoryBean<T, U extends ExampleGenericService<T>> implements FactoryBean<U> {
		@SuppressWarnings('unchecked')
		@Override
		public U getObject() throws Exception {
			return (U) new SimpleExampleStringGenericService();
		}
		@Override
		@SuppressWarnings('rawtypes')
		public Class<ExampleGenericService> getObjectType() {
			return ExampleGenericService.class;
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@ContextConfiguration(
		classes = SpyBeanOnTestFieldForExistingCircularBeansIntegrationTests.SpyBeanOnTestFieldForExistingCircularBeansConfig.class)
class SpyBeanOnTestFieldForExistingCircularBeansIntegrationTests {
	@SpyBean
	private One one;
	@Autowired
	private Two two;
	@Test
	void beanWithCircularDependenciesCanBeSpied() {
		this.two.callOne();
		then(this.one).should().someMethod();
	}
	@Import({ One.class, Two.class })
	static class SpyBeanOnTestFieldForExistingCircularBeansConfig {
	}
	static class One {
		@Autowired
		@SuppressWarnings('unused')
		private Two two;
		void someMethod() {
		}
	}
	static class Two {
		@Autowired
		private One one;
		void callOne() {
			this.one.someMethod();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanOnTestFieldForExistingBeanWithQualifierIntegrationTests {
	@MockBean
	@CustomQualifier
	private ExampleService service;
	@Autowired
	private ExampleServiceCaller caller;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testMocking() {
		this.caller.sayGreeting();
		then(this.service).should().greeting();
	}
	@Test
	void onlyQualifiedBeanIsReplaced() {
		assertThat(this.applicationContext.getBean('service')).isSameAs(this.service);
		ExampleService anotherService = this.applicationContext.getBean('anotherService', ExampleService.class);
		assertThat(anotherService.greeting()).isEqualTo('Another');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		CustomQualifierExampleService service() {
			return new CustomQualifierExampleService();
		}
		@Bean
		ExampleService anotherService() {
			return new RealExampleService('Another');
		}
		@Bean
		ExampleServiceCaller controller(@CustomQualifier ExampleService service) {
			return new ExampleServiceCaller(service);
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
class ResetMocksTestExecutionListenerTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void test001() {
		given(getMock('none').greeting()).willReturn('none');
		given(getMock('before').greeting()).willReturn('before');
		given(getMock('after').greeting()).willReturn('after');
		given(getMock('fromFactoryBean').greeting()).willReturn('fromFactoryBean');
		assertThat(this.context.getBean(NonSingletonFactoryBean.class).getObjectInvocations).isEqualTo(0);
	}
	@Test
	void test002() {
		assertThat(getMock('none').greeting()).isEqualTo('none');
		assertThat(getMock('before').greeting()).isNull();
		assertThat(getMock('after').greeting()).isNull();
		assertThat(getMock('fromFactoryBean').greeting()).isNull();
		assertThat(this.context.getBean(NonSingletonFactoryBean.class).getObjectInvocations).isEqualTo(0);
	}
	ExampleService getMock(String name) {
		return this.context.getBean(name, ExampleService.class);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		ExampleService before(MockitoBeans mockedBeans) {
			ExampleService mock = mock(ExampleService.class, MockReset.before());
			mockedBeans.add(mock);
			return mock;
		}
		@Bean
		ExampleService after(MockitoBeans mockedBeans) {
			ExampleService mock = mock(ExampleService.class, MockReset.after());
			mockedBeans.add(mock);
			return mock;
		}
		@Bean
		ExampleService none(MockitoBeans mockedBeans) {
			ExampleService mock = mock(ExampleService.class);
			mockedBeans.add(mock);
			return mock;
		}
		@Bean
		@Lazy
		ExampleService fail() {
			// gh-5870
			throw new RuntimeException();
		}
		@Bean
		BrokenFactoryBean brokenFactoryBean() {
			// gh-7270
			return new BrokenFactoryBean();
		}
		@Bean
		WorkingFactoryBean fromFactoryBean() {
			return new WorkingFactoryBean();
		}
		@Bean
		NonSingletonFactoryBean nonSingletonFactoryBean() {
			return new NonSingletonFactoryBean();
		}
	}
	static class BrokenFactoryBean implements FactoryBean<String> {
		@Override
		public String getObject() {
			throw new IllegalStateException();
		}
		@Override
		public Class<?> getObjectType() {
			return String.class;
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
	}
	static class WorkingFactoryBean implements FactoryBean<ExampleService> {
		private final ExampleService service = mock(ExampleService.class, MockReset.before());
		@Override
		public ExampleService getObject() {
			return this.service;
		}
		@Override
		public Class<?> getObjectType() {
			return ExampleService.class;
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
	}
	static class NonSingletonFactoryBean implements FactoryBean<ExampleService> {
		private int getObjectInvocations = 0;
		@Override
		public ExampleService getObject() {
			this.getObjectInvocations++;
			return mock(ExampleService.class, MockReset.before());
		}
		@Override
		public Class<?> getObjectType() {
			return ExampleService.class;
		}
		@Override
		public boolean isSingleton() {
			return false;
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanWithAopProxyTests {
	@MockBean
	private DateService dateService;
	@Test
	void verifyShouldUseProxyTarget() {
		given(this.dateService.getDate(false)).willReturn(1L);
		Long d1 = this.dateService.getDate(false);
		assertThat(d1).isOne();
		given(this.dateService.getDate(false)).willReturn(2L);
		Long d2 = this.dateService.getDate(false);
		assertThat(d2).isEqualTo(2L);
		then(this.dateService).should(times(2)).getDate(false);
		then(this.dateService).should(times(2)).getDate(eq(false));
		then(this.dateService).should(times(2)).getDate(anyBoolean());
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching(proxyTargetClass = true)
	@Import(DateService.class)
	static class Config {
		@Bean
		CacheResolver cacheResolver(CacheManager cacheManager) {
			SimpleCacheResolver resolver = new SimpleCacheResolver();
			resolver.setCacheManager(cacheManager);
			return resolver;
		}
		@Bean
		ConcurrentMapCacheManager cacheManager() {
			ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();
			cacheManager.setCacheNames(Arrays.asList('test'));
			return cacheManager;
		}
	}
	@Service
	static class DateService {
		@Cacheable(cacheNames = 'test')
		Long getDate(boolean argument) {
			return System.nanoTime();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class AbstractMockBeanOnGenericExtensionTests extends
		AbstractMockBeanOnGenericTests<AbstractMockBeanOnGenericTests.ThingImpl, AbstractMockBeanOnGenericTests.SomethingImpl> {
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanWithGenericsOnTestFieldForNewBeanIntegrationTests {
	@MockBean
	private ExampleGenericService<Integer> exampleIntegerService;
	@MockBean
	private ExampleGenericService<String> exampleStringService;
	@Autowired
	private ExampleGenericServiceCaller caller;
	@Test
	void testMocking() {
		given(this.exampleIntegerService.greeting()).willReturn(200);
		given(this.exampleStringService.greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say 200 Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleGenericServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanOnScopedProxyTests {
	@MockBean
	private ExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.caller.getService().greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ExampleServiceCaller.class })
	static class Config {
		@Bean
		@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)
		ExampleService exampleService() {
			return new FailingExampleService();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanWithJdkProxyTests {
	@Autowired
	private ExampleService service;
	@SpyBean
	private ExampleRepository repository;
	@Test
	void jdkProxyCanBeSpied() {
		Example example = this.service.find('id');
		assertThat(example.id).isEqualTo('id');
		then(this.repository).should().find('id');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleService.class)
	static class Config {
		@Bean
		ExampleRepository dateService() {
			return (ExampleRepository) Proxy.newProxyInstance(getClass().getClassLoader(),
					new Class<?>[] { ExampleRepository.class }, (proxy, method, args) -> new Example((String) args[0]));
		}
	}
	static class ExampleService {
		private final ExampleRepository repository;
		ExampleService(ExampleRepository repository) {
			this.repository = repository;
		}
		Example find(String id) {
			return this.repository.find(id);
		}
	}
	interface ExampleRepository {
		Example find(String id);
	}
	static class Example {
		private final String id;
		Example(String id) {
			this.id = id;
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class DefinitionsParserTests {
	private final DefinitionsParser parser = new DefinitionsParser();
	@Test
	void parseSingleMockBean() {
		this.parser.parse(SingleMockBean.class);
		assertThat(getDefinitions()).hasSize(1);
		assertThat(getMockDefinition(0).getTypeToMock().resolve()).isEqualTo(ExampleService.class);
	}
	@Test
	void parseRepeatMockBean() {
		this.parser.parse(RepeatMockBean.class);
		assertThat(getDefinitions()).hasSize(2);
		assertThat(getMockDefinition(0).getTypeToMock().resolve()).isEqualTo(ExampleService.class);
		assertThat(getMockDefinition(1).getTypeToMock().resolve()).isEqualTo(ExampleServiceCaller.class);
	}
	@Test
	void parseMockBeanAttributes() {
		this.parser.parse(MockBeanAttributes.class);
		assertThat(getDefinitions()).hasSize(1);
		MockDefinition definition = getMockDefinition(0);
		assertThat(definition.getName()).isEqualTo('Name');
		assertThat(definition.getTypeToMock().resolve()).isEqualTo(ExampleService.class);
		assertThat(definition.getExtraInterfaces()).containsExactly(ExampleExtraInterface.class);
		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS);
		assertThat(definition.isSerializable()).isTrue();
		assertThat(definition.getReset()).isEqualTo(MockReset.NONE);
		assertThat(definition.getQualifier()).isNull();
	}
	@Test
	void parseMockBeanOnClassAndField() {
		this.parser.parse(MockBeanOnClassAndField.class);
		assertThat(getDefinitions()).hasSize(2);
		MockDefinition classDefinition = getMockDefinition(0);
		assertThat(classDefinition.getTypeToMock().resolve()).isEqualTo(ExampleService.class);
		assertThat(classDefinition.getQualifier()).isNull();
		MockDefinition fieldDefinition = getMockDefinition(1);
		assertThat(fieldDefinition.getTypeToMock().resolve()).isEqualTo(ExampleServiceCaller.class);
		QualifierDefinition qualifier = QualifierDefinition
			.forElement(ReflectionUtils.findField(MockBeanOnClassAndField.class, 'caller'));
		assertThat(fieldDefinition.getQualifier()).isNotNull().isEqualTo(qualifier);
	}
	@Test
	void parseMockBeanInferClassToMock() {
		this.parser.parse(MockBeanInferClassToMock.class);
		assertThat(getDefinitions()).hasSize(1);
		assertThat(getMockDefinition(0).getTypeToMock().resolve()).isEqualTo(ExampleService.class);
	}
	@Test
	void parseMockBeanMissingClassToMock() {
		assertThatIllegalStateException().isThrownBy(() -> this.parser.parse(MockBeanMissingClassToMock.class))
			.withMessageContaining('Unable to deduce type to mock');
	}
	@Test
	void parseMockBeanMultipleClasses() {
		this.parser.parse(MockBeanMultipleClasses.class);
		assertThat(getDefinitions()).hasSize(2);
		assertThat(getMockDefinition(0).getTypeToMock().resolve()).isEqualTo(ExampleService.class);
		assertThat(getMockDefinition(1).getTypeToMock().resolve()).isEqualTo(ExampleServiceCaller.class);
	}
	@Test
	void parseMockBeanMultipleClassesWithName() {
		assertThatIllegalStateException().isThrownBy(() -> this.parser.parse(MockBeanMultipleClassesWithName.class))
			.withMessageContaining('The name attribute can only be used when mocking a single class');
	}
	@Test
	void parseSingleSpyBean() {
		this.parser.parse(SingleSpyBean.class);
		assertThat(getDefinitions()).hasSize(1);
		assertThat(getSpyDefinition(0).getTypeToSpy().resolve()).isEqualTo(RealExampleService.class);
	}
	@Test
	void parseRepeatSpyBean() {
		this.parser.parse(RepeatSpyBean.class);
		assertThat(getDefinitions()).hasSize(2);
		assertThat(getSpyDefinition(0).getTypeToSpy().resolve()).isEqualTo(RealExampleService.class);
		assertThat(getSpyDefinition(1).getTypeToSpy().resolve()).isEqualTo(ExampleServiceCaller.class);
	}
	@Test
	void parseSpyBeanAttributes() {
		this.parser.parse(SpyBeanAttributes.class);
		assertThat(getDefinitions()).hasSize(1);
		SpyDefinition definition = getSpyDefinition(0);
		assertThat(definition.getName()).isEqualTo('Name');
		assertThat(definition.getTypeToSpy().resolve()).isEqualTo(RealExampleService.class);
		assertThat(definition.getReset()).isEqualTo(MockReset.NONE);
		assertThat(definition.getQualifier()).isNull();
	}
	@Test
	void parseSpyBeanOnClassAndField() {
		this.parser.parse(SpyBeanOnClassAndField.class);
		assertThat(getDefinitions()).hasSize(2);
		SpyDefinition classDefinition = getSpyDefinition(0);
		assertThat(classDefinition.getQualifier()).isNull();
		assertThat(classDefinition.getTypeToSpy().resolve()).isEqualTo(RealExampleService.class);
		SpyDefinition fieldDefinition = getSpyDefinition(1);
		QualifierDefinition qualifier = QualifierDefinition
			.forElement(ReflectionUtils.findField(SpyBeanOnClassAndField.class, 'caller'));
		assertThat(fieldDefinition.getQualifier()).isNotNull().isEqualTo(qualifier);
		assertThat(fieldDefinition.getTypeToSpy().resolve()).isEqualTo(ExampleServiceCaller.class);
	}
	@Test
	void parseSpyBeanInferClassToMock() {
		this.parser.parse(SpyBeanInferClassToMock.class);
		assertThat(getDefinitions()).hasSize(1);
		assertThat(getSpyDefinition(0).getTypeToSpy().resolve()).isEqualTo(RealExampleService.class);
	}
	@Test
	void parseSpyBeanMissingClassToMock() {
		assertThatIllegalStateException().isThrownBy(() -> this.parser.parse(SpyBeanMissingClassToMock.class))
			.withMessageContaining('Unable to deduce type to spy');
	}
	@Test
	void parseSpyBeanMultipleClasses() {
		this.parser.parse(SpyBeanMultipleClasses.class);
		assertThat(getDefinitions()).hasSize(2);
		assertThat(getSpyDefinition(0).getTypeToSpy().resolve()).isEqualTo(RealExampleService.class);
		assertThat(getSpyDefinition(1).getTypeToSpy().resolve()).isEqualTo(ExampleServiceCaller.class);
	}
	@Test
	void parseSpyBeanMultipleClassesWithName() {
		assertThatIllegalStateException().isThrownBy(() -> this.parser.parse(SpyBeanMultipleClassesWithName.class))
			.withMessageContaining('The name attribute can only be used when spying a single class');
	}
	private MockDefinition getMockDefinition(int index) {
		return (MockDefinition) getDefinitions().get(index);
	}
	private SpyDefinition getSpyDefinition(int index) {
		return (SpyDefinition) getDefinitions().get(index);
	}
	private List<Definition> getDefinitions() {
		return new ArrayList<>(this.parser.getDefinitions());
	}
	@SuppressWarnings('removal')
	@MockBean(ExampleService.class)
	static class SingleMockBean {
	}
	@SuppressWarnings('removal')
	@MockBeans({ @MockBean(ExampleService.class), @MockBean(ExampleServiceCaller.class) })
	static class RepeatMockBean {
	}
	@SuppressWarnings('removal')
	@MockBean(name = 'Name', classes = ExampleService.class, extraInterfaces = ExampleExtraInterface.class,
			answer = Answers.RETURNS_SMART_NULLS, serializable = true, reset = MockReset.NONE)
	static class MockBeanAttributes {
	}
	@SuppressWarnings('removal')
	@MockBean(ExampleService.class)
	static class MockBeanOnClassAndField {
		@MockBean(ExampleServiceCaller.class)
		@Qualifier('test')
		private Object caller;
	}
	@SuppressWarnings('removal')
	@MockBean({ ExampleService.class, ExampleServiceCaller.class })
	static class MockBeanMultipleClasses {
	}
	@SuppressWarnings('removal')
	@MockBean(name = 'name', classes = { ExampleService.class, ExampleServiceCaller.class })
	static class MockBeanMultipleClassesWithName {
	}
	static class MockBeanInferClassToMock {
		@MockBean
		private ExampleService exampleService;
	}
	@SuppressWarnings('removal')
	@MockBean
	static class MockBeanMissingClassToMock {
	}
	@SuppressWarnings('removal')
	@SpyBean(RealExampleService.class)
	static class SingleSpyBean {
	}
	@SuppressWarnings('removal')
	@SpyBeans({ @SpyBean(RealExampleService.class), @SpyBean(ExampleServiceCaller.class) })
	static class RepeatSpyBean {
	}
	@SuppressWarnings('removal')
	@SpyBean(name = 'Name', classes = RealExampleService.class, reset = MockReset.NONE)
	static class SpyBeanAttributes {
	}
	@SuppressWarnings('removal')
	@SpyBean(RealExampleService.class)
	static class SpyBeanOnClassAndField {
		@SpyBean(ExampleServiceCaller.class)
		@Qualifier('test')
		private Object caller;
	}
	@SuppressWarnings('removal')
	@SpyBean({ RealExampleService.class, ExampleServiceCaller.class })
	static class SpyBeanMultipleClasses {
	}
	@SuppressWarnings('removal')
	@SpyBean(name = 'name', classes = { RealExampleService.class, ExampleServiceCaller.class })
	static class SpyBeanMultipleClassesWithName {
	}
	static class SpyBeanInferClassToMock {
		@SpyBean
		private RealExampleService exampleService;
	}
	@SuppressWarnings('removal')
	@SpyBean
	static class SpyBeanMissingClassToMock {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanForBeanFactoryIntegrationTests {
	// gh-7439
	@MockBean
	private TestFactoryBean testFactoryBean;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void testName() {
		TestBean testBean = mock(TestBean.class);
		given(testBean.hello()).willReturn('amock');
		given(this.testFactoryBean.getObjectType()).willReturn((Class) TestBean.class);
		given(this.testFactoryBean.getObject()).willReturn(testBean);
		TestBean bean = this.applicationContext.getBean(TestBean.class);
		assertThat(bean.hello()).isEqualTo('amock');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		TestFactoryBean testFactoryBean() {
			return new TestFactoryBean();
		}
	}
	static class TestFactoryBean implements FactoryBean<TestBean> {
		@Override
		public TestBean getObject() {
			return () -> 'normal';
		}
		@Override
		public Class<?> getObjectType() {
			return TestBean.class;
		}
		@Override
		public boolean isSingleton() {
			return false;
		}
	}
	interface TestBean {
		String hello();
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@SpyBean(SimpleExampleService.class)
class SpyBeanOnTestClassForNewBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.caller.getService()).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanOnTestFieldForNewBeanIntegrationTests {
	@MockBean
	private ExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.exampleService.greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanWithInjectedFieldIntegrationTests {
	@MockBean
	private MyService myService;
	@Test
	void fieldInjectionIntoMyServiceMockIsNotAttempted() {
		given(this.myService.getCount()).willReturn(5);
		assertThat(this.myService.getCount()).isEqualTo(5);
	}
	static class MyService {
		@Autowired
		private MyRepository repository;
		int getCount() {
			return this.repository.findAll().size();
		}
	}
	interface MyRepository {
		List<Object> findAll();
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnConfigurationFieldForNewBeanIntegrationTests {
	@Autowired
	private Config config;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.config.exampleService).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
		@SpyBean
		private SimpleExampleService exampleService;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class SpringBootMockResolverIntegrationTests {
	@Test
	void customMockResolverIsRegisteredWithMockito() {
		assertThat(Plugins.getMockResolvers()).haveAtLeastOne(new Condition<MockResolver>(
				SpringBootMockResolver.class::isInstance, 'Spring Boot mock resolver instance'));
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockResetTests {
	@Test
	void noneAttachesReset() {
		ExampleService mock = mock(ExampleService.class);
		assertThat(MockReset.get(mock)).isEqualTo(MockReset.NONE);
	}
	@Test
	void withSettingsOfNoneAttachesReset() {
		ExampleService mock = mock(ExampleService.class, MockReset.withSettings(MockReset.NONE));
		assertThat(MockReset.get(mock)).isEqualTo(MockReset.NONE);
	}
	@Test
	void beforeAttachesReset() {
		ExampleService mock = mock(ExampleService.class, MockReset.before());
		assertThat(MockReset.get(mock)).isEqualTo(MockReset.BEFORE);
	}
	@Test
	void afterAttachesReset() {
		ExampleService mock = mock(ExampleService.class, MockReset.after());
		assertThat(MockReset.get(mock)).isEqualTo(MockReset.AFTER);
	}
	@Test
	void withSettingsAttachesReset() {
		ExampleService mock = mock(ExampleService.class, MockReset.withSettings(MockReset.BEFORE));
		assertThat(MockReset.get(mock)).isEqualTo(MockReset.BEFORE);
	}
	@Test
	void apply() {
		ExampleService mock = mock(ExampleService.class, MockReset.apply(MockReset.AFTER, withSettings()));
		assertThat(MockReset.get(mock)).isEqualTo(MockReset.AFTER);
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@ExtendWith(SpringExtension.class)
@Deprecated(since = '3.4.0', forRemoval = true)
class MockBeanOnConfigurationFieldForNewBeanIntegrationTests {
	@Autowired
	private Config config;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.config.exampleService.greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
		@MockBean
		private ExampleService exampleService;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = SpyBeanOnTestFieldForExistingBeanConfig.class)
class SpyBeanOnTestFieldForExistingBeanCacheIntegrationTests {
	@SpyBean
	private ExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.caller.getService()).should().greeting();
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockitoContextCustomizerFactoryTests {
	private final MockitoContextCustomizerFactory factory = new MockitoContextCustomizerFactory();
	@Test
	void getContextCustomizerWithoutAnnotationReturnsCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(NoMockBeanAnnotation.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void getContextCustomizerWithAnnotationReturnsCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(WithMockBeanAnnotation.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void getContextCustomizerUsesMocksAsCacheKey() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(WithMockBeanAnnotation.class, null);
		assertThat(customizer).isNotNull();
		ContextCustomizer same = this.factory.createContextCustomizer(WithSameMockBeanAnnotation.class, null);
		assertThat(customizer).isNotNull();
		ContextCustomizer different = this.factory.createContextCustomizer(WithDifferentMockBeanAnnotation.class, null);
		assertThat(different).isNotNull();
		assertThat(customizer).hasSameHashCodeAs(same);
		assertThat(customizer.hashCode()).isNotEqualTo(different.hashCode());
		assertThat(customizer).isEqualTo(customizer).isEqualTo(same).isNotEqualTo(different);
	}
	static class NoMockBeanAnnotation {
	}
	@SuppressWarnings('removal')
	@MockBean({ Service1.class, Service2.class })
	static class WithMockBeanAnnotation {
	}
	@SuppressWarnings('removal')
	@MockBean({ Service2.class, Service1.class })
	static class WithSameMockBeanAnnotation {
	}
	@SuppressWarnings('removal')
	@MockBean({ Service1.class })
	static class WithDifferentMockBeanAnnotation {
	}
	interface Service1 {
	}
	interface Service2 {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)
class MockBeanWithDirtiesContextClassModeBeforeMethodIntegrationTests {
	@MockBean
	private ExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.exampleService.greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnTestFieldForExistingGenericBeanIntegrationTests {
	// gh-7625
	@SpyBean
	private ExampleGenericService<String> exampleService;
	@Autowired
	private ExampleGenericServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say 123 simple');
		then(this.exampleService).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ExampleGenericServiceCaller.class, SimpleExampleIntegerGenericService.class })
	static class SpyBeanOnTestFieldForExistingBeanConfig {
		@Bean
		ExampleGenericService<String> simpleExampleStringGenericService() {
			// In order to trigger issue we need a method signature that returns the
			// generic type not the actual implementation class
			return new SimpleExampleStringGenericService();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockitoPostProcessorTests {
	@Test
	void cannotMockMultipleBeans() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		context.register(MultipleBeans.class);
		assertThatIllegalStateException().isThrownBy(context::refresh)
			.withMessageContaining('Unable to register mock bean ' + ExampleService.class.getName()
					+ ' expected a single matching bean to replace but found [example1, example2]');
	}
	@Test
	void cannotMockMultipleQualifiedBeans() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		context.register(MultipleQualifiedBeans.class);
		assertThatIllegalStateException().isThrownBy(context::refresh)
			.withMessageContaining('Unable to register mock bean ' + ExampleService.class.getName()
					+ ' expected a single matching bean to replace but found [example1, example3]');
	}
	@Test
	void canMockBeanProducedByFactoryBeanWithClassObjectTypeAttribute() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		RootBeanDefinition factoryBeanDefinition = new RootBeanDefinition(TestFactoryBean.class);
		factoryBeanDefinition.setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, SomeInterface.class);
		context.registerBeanDefinition('beanToBeMocked', factoryBeanDefinition);
		context.register(MockedFactoryBean.class);
		context.refresh();
		assertThat(Mockito.mockingDetails(context.getBean('beanToBeMocked')).isMock()).isTrue();
	}
	@Test
	void canMockBeanProducedByFactoryBeanWithResolvableTypeObjectTypeAttribute() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		RootBeanDefinition factoryBeanDefinition = new RootBeanDefinition(TestFactoryBean.class);
		ResolvableType objectType = ResolvableType.forClass(SomeInterface.class);
		factoryBeanDefinition.setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, objectType);
		context.registerBeanDefinition('beanToBeMocked', factoryBeanDefinition);
		context.register(MockedFactoryBean.class);
		context.refresh();
		assertThat(Mockito.mockingDetails(context.getBean('beanToBeMocked')).isMock()).isTrue();
	}
	@Test
	void canMockPrimaryBean() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		context.register(MockPrimaryBean.class);
		context.refresh();
		assertThat(Mockito.mockingDetails(context.getBean(MockPrimaryBean.class).mock).isMock()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean(ExampleService.class)).isMock()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean('examplePrimary', ExampleService.class)).isMock()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean('exampleQualified', ExampleService.class)).isMock())
			.isFalse();
	}
	@Test
	void canMockQualifiedBeanWithPrimaryBeanPresent() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		context.register(MockQualifiedBean.class);
		context.refresh();
		assertThat(Mockito.mockingDetails(context.getBean(MockQualifiedBean.class).mock).isMock()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean(ExampleService.class)).isMock()).isFalse();
		assertThat(Mockito.mockingDetails(context.getBean('examplePrimary', ExampleService.class)).isMock()).isFalse();
		assertThat(Mockito.mockingDetails(context.getBean('exampleQualified', ExampleService.class)).isMock()).isTrue();
	}
	@Test
	void canSpyPrimaryBean() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		context.register(SpyPrimaryBean.class);
		context.refresh();
		assertThat(Mockito.mockingDetails(context.getBean(SpyPrimaryBean.class).spy).isSpy()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean(ExampleService.class)).isSpy()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean('examplePrimary', ExampleService.class)).isSpy()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean('exampleQualified', ExampleService.class)).isSpy()).isFalse();
	}
	@Test
	void canSpyQualifiedBeanWithPrimaryBeanPresent() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		MockitoPostProcessor.register(context);
		context.register(SpyQualifiedBean.class);
		context.refresh();
		assertThat(Mockito.mockingDetails(context.getBean(SpyQualifiedBean.class).spy).isSpy()).isTrue();
		assertThat(Mockito.mockingDetails(context.getBean(ExampleService.class)).isSpy()).isFalse();
		assertThat(Mockito.mockingDetails(context.getBean('examplePrimary', ExampleService.class)).isSpy()).isFalse();
		assertThat(Mockito.mockingDetails(context.getBean('exampleQualified', ExampleService.class)).isSpy()).isTrue();
	}
	@Test
	void postProcessorShouldNotTriggerEarlyInitialization() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(FactoryBeanRegisteringPostProcessor.class);
		MockitoPostProcessor.register(context);
		context.register(TestBeanFactoryPostProcessor.class);
		context.register(EagerInitBean.class);
		context.refresh();
	}
	@Configuration(proxyBeanMethods = false)
	@MockBean(SomeInterface.class)
	static class MockedFactoryBean {
		@Bean
		TestFactoryBean testFactoryBean() {
			return new TestFactoryBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@MockBean(ExampleService.class)
	static class MultipleBeans {
		@Bean
		ExampleService example1() {
			return new FailingExampleService();
		}
		@Bean
		ExampleService example2() {
			return new FailingExampleService();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleQualifiedBeans {
		@MockBean
		@Qualifier('test')
		private ExampleService mock;
		@Bean
		@Qualifier('test')
		ExampleService example1() {
			return new FailingExampleService();
		}
		@Bean
		ExampleService example2() {
			return new FailingExampleService();
		}
		@Bean
		@Qualifier('test')
		ExampleService example3() {
			return new FailingExampleService();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MockPrimaryBean {
		@MockBean
		private ExampleService mock;
		@Bean
		@Qualifier('test')
		ExampleService exampleQualified() {
			return new RealExampleService('qualified');
		}
		@Bean
		@Primary
		ExampleService examplePrimary() {
			return new RealExampleService('primary');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MockQualifiedBean {
		@MockBean
		@Qualifier('test')
		private ExampleService mock;
		@Bean
		@Qualifier('test')
		ExampleService exampleQualified() {
			return new RealExampleService('qualified');
		}
		@Bean
		@Primary
		ExampleService examplePrimary() {
			return new RealExampleService('primary');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SpyPrimaryBean {
		@SpyBean
		private ExampleService spy;
		@Bean
		@Qualifier('test')
		ExampleService exampleQualified() {
			return new RealExampleService('qualified');
		}
		@Bean
		@Primary
		ExampleService examplePrimary() {
			return new RealExampleService('primary');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SpyQualifiedBean {
		@SpyBean
		@Qualifier('test')
		private ExampleService spy;
		@Bean
		@Qualifier('test')
		ExampleService exampleQualified() {
			return new RealExampleService('qualified');
		}
		@Bean
		@Primary
		ExampleService examplePrimary() {
			return new RealExampleService('primary');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EagerInitBean {
		@MockBean
		private ExampleService service;
	}
	static class TestFactoryBean implements FactoryBean<Object> {
		@Override
		public Object getObject() {
			return new TestBean();
		}
		@Override
		public Class<?> getObjectType() {
			return null;
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
	}
	static class FactoryBeanRegisteringPostProcessor implements BeanFactoryPostProcessor, Ordered {
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
			RootBeanDefinition beanDefinition = new RootBeanDefinition(TestFactoryBean.class);
			((BeanDefinitionRegistry) beanFactory).registerBeanDefinition('test', beanDefinition);
		}
		@Override
		public int getOrder() {
			return Ordered.HIGHEST_PRECEDENCE;
		}
	}
	static class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
		@Override
		@SuppressWarnings('unchecked')
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
			Map<String, BeanWrapper> cache = (Map<String, BeanWrapper>) ReflectionTestUtils.getField(beanFactory,
					'factoryBeanInstanceCache');
			Assert.isTrue(cache.isEmpty(), 'Early initialization of factory bean triggered.');
		}
	}
	interface SomeInterface {
	}
	static class TestBean implements SomeInterface {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@SpyBean(SimpleExampleService.class)
class SpyBeanOnTestClassForExistingBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.caller.getService()).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ExampleServiceCaller.class, SimpleExampleService.class })
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockBeanContextCachingTests {
	private final DefaultContextCache contextCache = new DefaultContextCache(2);
	private final DefaultCacheAwareContextLoaderDelegate delegate = new DefaultCacheAwareContextLoaderDelegate(
			this.contextCache);
	@AfterEach
	@SuppressWarnings('unchecked')
	void clearCache() {
		Map<MergedContextConfiguration, ApplicationContext> contexts = (Map<MergedContextConfiguration, ApplicationContext>) ReflectionTestUtils
			.getField(this.contextCache, 'contextMap');
		for (ApplicationContext context : contexts.values()) {
			if (context instanceof ConfigurableApplicationContext configurableContext) {
				configurableContext.close();
			}
		}
		this.contextCache.clear();
	}
	@Test
	void whenThereIsANormalBeanAndAMockBeanThenTwoContextsAreCreated() {
		bootstrapContext(TestClass.class);
		assertThat(this.contextCache.size()).isOne();
		bootstrapContext(MockedBeanTestClass.class);
		assertThat(this.contextCache.size()).isEqualTo(2);
	}
	@Test
	void whenThereIsTheSameMockedBeanInEachTestClassThenOneContextIsCreated() {
		bootstrapContext(MockedBeanTestClass.class);
		assertThat(this.contextCache.size()).isOne();
		bootstrapContext(AnotherMockedBeanTestClass.class);
		assertThat(this.contextCache.size()).isOne();
	}
	@SuppressWarnings('rawtypes')
	private void bootstrapContext(Class<?> testClass) {
		SpringBootTestContextBootstrapper bootstrapper = new SpringBootTestContextBootstrapper();
		BootstrapContext bootstrapContext = mock(BootstrapContext.class);
		given((Class) bootstrapContext.getTestClass()).willReturn(testClass);
		bootstrapper.setBootstrapContext(bootstrapContext);
		given(bootstrapContext.getCacheAwareContextLoaderDelegate()).willReturn(this.delegate);
		TestContext testContext = bootstrapper.buildTestContext();
		testContext.getApplicationContext();
	}
	@SpringBootTest(classes = TestConfiguration.class)
	static class TestClass {
	}
	@SpringBootTest(classes = TestConfiguration.class)
	static class MockedBeanTestClass {
		@MockBean
		private TestBean testBean;
	}
	@SpringBootTest(classes = TestConfiguration.class)
	static class AnotherMockedBeanTestClass {
		@MockBean
		private TestBean testBean;
	}
	@Configuration
	static class TestConfiguration {
		@Bean
		TestBean testBean() {
			return new TestBean();
		}
	}
	static class TestBean {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnConfigurationClassForNewBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.caller.getService()).should().greeting();
	}
	@SuppressWarnings('removal')
	@Configuration(proxyBeanMethods = false)
	@SpyBean(SimpleExampleService.class)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class SpyDefinitionTests {
	private static final ResolvableType REAL_SERVICE_TYPE = ResolvableType.forClass(RealExampleService.class);
	@Test
	void classToSpyMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new SpyDefinition(null, null, null, true, null))
			.withMessageContaining('TypeToSpy must not be null');
	}
	@Test
	void createWithDefaults() {
		SpyDefinition definition = new SpyDefinition(null, REAL_SERVICE_TYPE, null, true, null);
		assertThat(definition.getName()).isNull();
		assertThat(definition.getTypeToSpy()).isEqualTo(REAL_SERVICE_TYPE);
		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER);
		assertThat(definition.isProxyTargetAware()).isTrue();
		assertThat(definition.getQualifier()).isNull();
	}
	@Test
	void createExplicit() {
		QualifierDefinition qualifier = mock(QualifierDefinition.class);
		SpyDefinition definition = new SpyDefinition('name', REAL_SERVICE_TYPE, MockReset.BEFORE, false, qualifier);
		assertThat(definition.getName()).isEqualTo('name');
		assertThat(definition.getTypeToSpy()).isEqualTo(REAL_SERVICE_TYPE);
		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE);
		assertThat(definition.isProxyTargetAware()).isFalse();
		assertThat(definition.getQualifier()).isEqualTo(qualifier);
	}
	@Test
	void createSpy() {
		SpyDefinition definition = new SpyDefinition('name', REAL_SERVICE_TYPE, MockReset.BEFORE, true, null);
		RealExampleService spy = definition.createSpy(new RealExampleService('hello'));
		MockCreationSettings<?> settings = Mockito.mockingDetails(spy).getMockCreationSettings();
		assertThat(spy).isInstanceOf(ExampleService.class);
		assertThat(settings.getMockName()).hasToString('name');
		assertThat(settings.getDefaultAnswer()).isEqualTo(Answers.CALLS_REAL_METHODS);
		assertThat(MockReset.get(spy)).isEqualTo(MockReset.BEFORE);
	}
	@Test
	void createSpyWhenNullInstanceShouldThrowException() {
		SpyDefinition definition = new SpyDefinition('name', REAL_SERVICE_TYPE, MockReset.BEFORE, true, null);
		assertThatIllegalArgumentException().isThrownBy(() -> definition.createSpy(null))
			.withMessageContaining('Instance must not be null');
	}
	@Test
	void createSpyWhenWrongInstanceShouldThrowException() {
		SpyDefinition definition = new SpyDefinition('name', REAL_SERVICE_TYPE, MockReset.BEFORE, true, null);
		assertThatIllegalArgumentException().isThrownBy(() -> definition.createSpy(new ExampleServiceCaller(null)))
			.withMessageContaining('must be an instance of');
	}
	@Test
	void createSpyTwice() {
		SpyDefinition definition = new SpyDefinition('name', REAL_SERVICE_TYPE, MockReset.BEFORE, true, null);
		Object instance = new RealExampleService('hello');
		instance = definition.createSpy(instance);
		definition.createSpy(instance);
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnConfigurationFieldForExistingBeanIntegrationTests {
	@Autowired
	private Config config;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.config.exampleService).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ExampleServiceCaller.class, SimpleExampleService.class })
	static class Config {
		@SpyBean
		private ExampleService exampleService;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = MockBeanOnTestFieldForExistingBeanConfig.class)
class MockBeanOnTestFieldForExistingBeanIntegrationTests {
	@MockBean
	private ExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.exampleService.greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockBeanOnConfigurationClassForExistingBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.caller.getService().greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@SuppressWarnings('removal')
	@Configuration(proxyBeanMethods = false)
	@MockBean(ExampleService.class)
	@Import({ ExampleServiceCaller.class, FailingExampleService.class })
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@MockBean(ExampleService.class)
class MockBeanOnTestClassForExistingBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.caller.getService().greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ExampleServiceCaller.class, FailingExampleService.class })
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = MockBeanOnTestFieldForExistingBeanConfig.class)
class MockBeanOnTestFieldForExistingBeanCacheIntegrationTests {
	@MockBean
	private ExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.exampleService.greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(MockitoExtension.class)
class QualifierDefinitionTests {
	@Mock
	private ConfigurableListableBeanFactory beanFactory;
	@Test
	void forElementFieldIsNullShouldReturnNull() {
		assertThat(QualifierDefinition.forElement((Field) null)).isNull();
	}
	@Test
	void forElementWhenElementIsNotFieldShouldReturnNull() {
		assertThat(QualifierDefinition.forElement(getClass())).isNull();
	}
	@Test
	void forElementWhenElementIsFieldWithNoQualifiersShouldReturnNull() {
		QualifierDefinition definition = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigA.class, 'noQualifier'));
		assertThat(definition).isNull();
	}
	@Test
	void forElementWhenElementIsFieldWithQualifierShouldReturnDefinition() {
		QualifierDefinition definition = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigA.class, 'directQualifier'));
		assertThat(definition).isNotNull();
	}
	@Test
	void matchesShouldCallBeanFactory() {
		Field field = ReflectionUtils.findField(ConfigA.class, 'directQualifier');
		QualifierDefinition qualifierDefinition = QualifierDefinition.forElement(field);
		qualifierDefinition.matches(this.beanFactory, 'bean');
		then(this.beanFactory).should()
			.isAutowireCandidate(eq('bean'), assertArg(
					(dependencyDescriptor) -> assertThat(dependencyDescriptor.getAnnotatedElement()).isEqualTo(field)));
	}
	@Test
	void applyToShouldSetQualifierElement() {
		Field field = ReflectionUtils.findField(ConfigA.class, 'directQualifier');
		QualifierDefinition qualifierDefinition = QualifierDefinition.forElement(field);
		RootBeanDefinition definition = new RootBeanDefinition();
		qualifierDefinition.applyTo(definition);
		assertThat(definition.getQualifiedElement()).isEqualTo(field);
	}
	@Test
	void hashCodeAndEqualsShouldWorkOnDifferentClasses() {
		QualifierDefinition directQualifier1 = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigA.class, 'directQualifier'));
		QualifierDefinition directQualifier2 = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigB.class, 'directQualifier'));
		QualifierDefinition differentDirectQualifier1 = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigA.class, 'differentDirectQualifier'));
		QualifierDefinition differentDirectQualifier2 = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigB.class, 'differentDirectQualifier'));
		QualifierDefinition customQualifier1 = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigA.class, 'customQualifier'));
		QualifierDefinition customQualifier2 = QualifierDefinition
			.forElement(ReflectionUtils.findField(ConfigB.class, 'customQualifier'));
		assertThat(directQualifier1).hasSameHashCodeAs(directQualifier2);
		assertThat(differentDirectQualifier1).hasSameHashCodeAs(differentDirectQualifier2);
		assertThat(customQualifier1).hasSameHashCodeAs(customQualifier2);
		assertThat(differentDirectQualifier1).isEqualTo(differentDirectQualifier1)
			.isEqualTo(differentDirectQualifier2)
			.isNotEqualTo(directQualifier2);
		assertThat(directQualifier1).isEqualTo(directQualifier1)
			.isEqualTo(directQualifier2)
			.isNotEqualTo(differentDirectQualifier1);
		assertThat(customQualifier1).isEqualTo(customQualifier1)
			.isEqualTo(customQualifier2)
			.isNotEqualTo(differentDirectQualifier1);
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigA {
		@MockBean
		private Object noQualifier;
		@MockBean
		@Qualifier('test')
		private Object directQualifier;
		@MockBean
		@Qualifier('different')
		private Object differentDirectQualifier;
		@MockBean
		@CustomQualifier
		private Object customQualifier;
	}
	static class ConfigB {
		@MockBean
		@Qualifier('test')
		private Object directQualifier;
		@MockBean
		@Qualifier('different')
		private Object differentDirectQualifier;
		@MockBean
		@CustomQualifier
		private Object customQualifier;
	}
	@Qualifier
	@Retention(RetentionPolicy.RUNTIME)
	public @interface CustomQualifier {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = SpyBeanOnTestFieldForExistingBeanConfig.class)
class SpyBeanOnTestFieldForExistingBeanIntegrationTests {
	@SpyBean
	private ExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say simple');
		then(this.caller.getService()).should().greeting();
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnTestFieldForMultipleExistingBeansWithOnePrimaryIntegrationTests {
	@SpyBean
	private SimpleExampleStringGenericService spy;
	@Autowired
	private ExampleGenericStringServiceCaller caller;
	@Test
	void testSpying() {
		assertThat(this.caller.sayGreeting()).isEqualTo('I say two');
		assertThat(Mockito.mockingDetails(this.spy).getMockCreationSettings().getMockName()).hasToString('two');
		then(this.spy).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleGenericStringServiceCaller.class)
	static class Config {
		@Bean
		SimpleExampleStringGenericService one() {
			return new SimpleExampleStringGenericService('one');
		}
		@Bean
		@Primary
		SimpleExampleStringGenericService two() {
			return new SimpleExampleStringGenericService('two');
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanWithAopProxyTests {
	@SpyBean
	private DateService dateService;
	@Test
	void verifyShouldUseProxyTarget() throws Exception {
		Long d1 = this.dateService.getDate(false);
		Thread.sleep(200);
		Long d2 = this.dateService.getDate(false);
		assertThat(d1).isEqualTo(d2);
		then(this.dateService).should().getDate(false);
		then(this.dateService).should().getDate(eq(false));
		then(this.dateService).should().getDate(anyBoolean());
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching(proxyTargetClass = true)
	@Import(DateService.class)
	static class Config {
		@Bean
		CacheResolver cacheResolver(CacheManager cacheManager) {
			SimpleCacheResolver resolver = new SimpleCacheResolver();
			resolver.setCacheManager(cacheManager);
			return resolver;
		}
		@Bean
		ConcurrentMapCacheManager cacheManager() {
			ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();
			cacheManager.setCacheNames(Arrays.asList('test'));
			return cacheManager;
		}
	}
	@Service
	public static class DateService {
		@Cacheable(cacheNames = 'test')
		public Long getDate(boolean arg) {
			return System.nanoTime();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class MockitoTestExecutionListenerIntegrationTests {
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	class MockedStaticTests {
		private static final UUID uuid = UUID.randomUUID();
		@Mock
		private MockedStatic<UUID> mockedStatic;
		@Test
		@Order(1)
		@Disabled
		void shouldReturnConstantValueDisabled() {
			this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
			UUID result = UUID.randomUUID();
			assertThat(result).isEqualTo(uuid);
		}
		@Test
		@Order(2)
		void shouldNotFailBecauseOfMockedStaticNotBeingClosed() {
			this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
			UUID result = UUID.randomUUID();
			assertThat(result).isEqualTo(uuid);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)
	class MockedStaticTestsDirtiesContext {
		private static final UUID uuid = UUID.randomUUID();
		@Mock
		private MockedStatic<UUID> mockedStatic;
		@Test
		@Order(1)
		@Disabled
		void shouldReturnConstantValueDisabled() {
			this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
			UUID result = UUID.randomUUID();
			assertThat(result).isEqualTo(uuid);
		}
		@Test
		@Order(2)
		void shouldNotFailBecauseOfMockedStaticNotBeingClosed() {
			this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
			UUID result = UUID.randomUUID();
			assertThat(result).isEqualTo(uuid);
		}
		@Test
		@Order(3)
		void shouldNotFailBecauseOfMockedStaticNotBeingClosedWhenMocksAreReinjected() {
			this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
			UUID result = UUID.randomUUID();
			assertThat(result).isEqualTo(uuid);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@TestClassOrder(ClassOrderer.OrderAnnotation.class)
	class MockedStaticTestsIfClassContainsOnlyDisabledTests {
		@Nested
		@Order(1)
		class TestClass1 {
			private static final UUID uuid = UUID.randomUUID();
			@Mock
			private MockedStatic<UUID> mockedStatic;
			@Test
			@Order(1)
			@Disabled
			void disabledTest() {
				this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
			}
		}
		@Nested
		@Order(2)
		class TestClass2 {
			private static final UUID uuid = UUID.randomUUID();
			@Mock
			private MockedStatic<UUID> mockedStatic;
			@Test
			@Order(1)
			void shouldNotFailBecauseMockedStaticHasNotBeenClosed() {
				this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
				UUID result = UUID.randomUUID();
				assertThat(result).isEqualTo(uuid);
			}
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@TestClassOrder(ClassOrderer.OrderAnnotation.class)
	class MockedStaticTestsIfClassContainsNoTests {
		@Nested
		@Order(1)
		class TestClass1 {
			@Mock
			private MockedStatic<UUID> mockedStatic;
		}
		@Nested
		@Order(2)
		class TestClass2 {
			private static final UUID uuid = UUID.randomUUID();
			@Mock
			private MockedStatic<UUID> mockedStatic;
			@Test
			@Order(1)
			void shouldNotFailBecauseMockedStaticHasNotBeenClosed() {
				this.mockedStatic.when(UUID::randomUUID).thenReturn(uuid);
				UUID result = UUID.randomUUID();
				assertThat(result).isEqualTo(uuid);
			}
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	class ConfigureMockInBeforeEach {
		@Mock
		private List<String> mock;
		@BeforeEach
		void setUp() {
			given(this.mock.size()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldUseSetUpConfiguration() {
			assertThat(this.mock.size()).isEqualTo(1);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.size()).willReturn(2);
			assertThat(this.mock.size()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldNotBeAffectedByOtherTests() {
			assertThat(this.mock.size()).isEqualTo(1);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@TestInstance(Lifecycle.PER_CLASS)
	@Disabled('https://github.com/spring-projects/spring-framework/issues/33690')
	class ConfigureMockInBeforeAll {
		@Mock
		private List<String> mock;
		@BeforeAll
		void setUp() {
			given(this.mock.size()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldUseSetUpConfiguration() {
			assertThat(this.mock.size()).isEqualTo(1);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.size()).willReturn(2);
			assertThat(this.mock.size()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldNotBeAffectedByOtherTest() {
			assertThat(this.mock.size()).isEqualTo(2);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@Import(MyBeanConfiguration.class)
	class ConfigureMockBeanWithResetAfterInBeforeEach {
		@MockBean(reset = MockReset.AFTER)
		private MyBean mock;
		@BeforeEach
		void setUp() {
			given(this.mock.call()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldUseSetUpConfiguration() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.call()).willReturn(2);
			assertThat(this.mock.call()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldNotBeAffectedByOtherTests() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@Import(MyBeanConfiguration.class)
	class ConfigureMockBeanWithResetBeforeInBeforeEach {
		@MockBean(reset = MockReset.BEFORE)
		private MyBean mock;
		@BeforeEach
		void setUp() {
			given(this.mock.call()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldUseSetUpConfiguration() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.call()).willReturn(2);
			assertThat(this.mock.call()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldNotBeAffectedByOtherTests() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@Import(MyBeanConfiguration.class)
	class ConfigureMockBeanWithResetNoneInBeforeEach {
		@MockBean(reset = MockReset.NONE)
		private MyBean mock;
		@BeforeEach
		void setUp() {
			given(this.mock.call()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldUseSetUpConfiguration() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.call()).willReturn(2);
			assertThat(this.mock.call()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldNotBeAffectedByOtherTests() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@TestInstance(Lifecycle.PER_CLASS)
	@Import(MyBeanConfiguration.class)
	class ConfigureMockBeanWithResetAfterInBeforeAll {
		@MockBean(reset = MockReset.AFTER)
		private MyBean mock;
		@BeforeAll
		void setUp() {
			given(this.mock.call()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldUseSetUpConfiguration() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.call()).willReturn(2);
			assertThat(this.mock.call()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldResetMockAfterReconfiguration() {
			assertThat(this.mock.call()).isEqualTo(0);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@TestInstance(Lifecycle.PER_CLASS)
	@Import(MyBeanConfiguration.class)
	class ConfigureMockBeanWithResetBeforeInBeforeAll {
		@MockBean(reset = MockReset.BEFORE)
		private MyBean mock;
		@BeforeAll
		void setUp() {
			given(this.mock.call()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldResetMockBeforeThisMethod() {
			assertThat(this.mock.call()).isEqualTo(0);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.call()).willReturn(2);
			assertThat(this.mock.call()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldResetMockAfterReconfiguration() {
			assertThat(this.mock.call()).isEqualTo(0);
		}
	}
	@Nested
	@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
	@TestInstance(Lifecycle.PER_CLASS)
	@Import(MyBeanConfiguration.class)
	class ConfigureMockBeanWithResetNoneInBeforeAll {
		@MockBean(reset = MockReset.NONE)
		private MyBean mock;
		@BeforeAll
		void setUp() {
			given(this.mock.call()).willReturn(1);
		}
		@Test
		@Order(1)
		void shouldUseSetUpConfiguration() {
			assertThat(this.mock.call()).isEqualTo(1);
		}
		@Test
		@Order(2)
		void shouldBeAbleToReconfigureMock() {
			given(this.mock.call()).willReturn(2);
			assertThat(this.mock.call()).isEqualTo(2);
		}
		@Test
		@Order(3)
		void shouldNotResetMock() {
			assertThat(this.mock.call()).isEqualTo(2);
		}
	}
	interface MyBean {
		int call();
	}
	private static final class DefaultMyBean implements MyBean {
		@Override
		public int call() {
			return -1;
		}
	}
	@TestConfiguration(proxyBeanMethods = false)
	private static final class MyBeanConfiguration {
		@Bean
		MyBean myBean() {
			return new DefaultMyBean();
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@MockBean(ExampleService.class)
class MockBeanOnTestClassForNewBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.caller.getService().greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
class SpyBeanOnTestFieldForExistingBeanWithQualifierIntegrationTests {
	@SpyBean
	@CustomQualifier
	private ExampleService service;
	@Autowired
	private ExampleServiceCaller caller;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testMocking() {
		this.caller.sayGreeting();
		then(this.service).should().greeting();
	}
	@Test
	void onlyQualifiedBeanIsReplaced() {
		assertThat(this.applicationContext.getBean('service')).isSameAs(this.service);
		ExampleService anotherService = this.applicationContext.getBean('anotherService', ExampleService.class);
		assertThat(anotherService.greeting()).isEqualTo('Another');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		CustomQualifierExampleService service() {
			return new CustomQualifierExampleService();
		}
		@Bean
		ExampleService anotherService() {
			return new RealExampleService('Another');
		}
		@Bean
		ExampleServiceCaller controller(@CustomQualifier ExampleService service) {
			return new ExampleServiceCaller(service);
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(MockitoExtension.class)
class MockitoTestExecutionListenerTests {
	private final MockitoTestExecutionListener listener = new MockitoTestExecutionListener();
	@Mock
	private ApplicationContext applicationContext;
	@Mock
	private MockitoPostProcessor postProcessor;
	@Test
	void prepareTestInstanceShouldInitMockitoAnnotations() throws Exception {
		WithMockitoAnnotations instance = new WithMockitoAnnotations();
		this.listener.prepareTestInstance(mockTestContext(instance));
		assertThat(instance.mock).isNotNull();
		assertThat(instance.captor).isNotNull();
	}
	@Test
	void prepareTestInstanceShouldInjectMockBean() throws Exception {
		given(this.applicationContext.getBean(MockitoPostProcessor.class)).willReturn(this.postProcessor);
		WithMockBean instance = new WithMockBean();
		TestContext testContext = mockTestContext(instance);
		given(testContext.getApplicationContext()).willReturn(this.applicationContext);
		this.listener.prepareTestInstance(testContext);
		then(this.postProcessor).should()
			.inject(assertArg((field) -> assertThat(field.getName()).isEqualTo('mockBean')), eq(instance),
					any(MockDefinition.class));
	}
	@Test
	void beforeTestMethodShouldDoNothingWhenDirtiesContextAttributeIsNotSet() throws Exception {
		this.listener.beforeTestMethod(mock(TestContext.class));
		then(this.postProcessor).shouldHaveNoMoreInteractions();
	}
	@Test
	void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception {
		given(this.applicationContext.getBean(MockitoPostProcessor.class)).willReturn(this.postProcessor);
		WithMockBean instance = new WithMockBean();
		TestContext mockTestContext = mockTestContext(instance);
		given(mockTestContext.getApplicationContext()).willReturn(this.applicationContext);
		given(mockTestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))
			.willReturn(Boolean.TRUE);
		this.listener.beforeTestMethod(mockTestContext);
		then(this.postProcessor).should()
			.inject(assertArg((field) -> assertThat(field.getName()).isEqualTo('mockBean')), eq(instance),
					any(MockDefinition.class));
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private TestContext mockTestContext(Object instance) {
		TestContext testContext = mock(TestContext.class);
		given(testContext.getTestInstance()).willReturn(instance);
		given(testContext.getTestClass()).willReturn((Class) instance.getClass());
		return testContext;
	}
	static class WithMockitoAnnotations {
		@Mock
		InputStream mock;
		@Captor
		ArgumentCaptor<InputStream> captor;
	}
	static class WithMockBean {
		@MockBean
		InputStream mockBean;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@ExtendWith(SpringExtension.class)
@Deprecated(since = '3.4.0', forRemoval = true)
class MockBeanOnConfigurationClassForNewBeanIntegrationTests {
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testMocking() {
		given(this.caller.getService().greeting()).willReturn('Boot');
		assertThat(this.caller.sayGreeting()).isEqualTo('I say Boot');
	}
	@SuppressWarnings('removal')
	@Configuration(proxyBeanMethods = false)
	@MockBean(ExampleService.class)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@ExtendWith(SpringExtension.class)
@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)
class SpyBeanWithDirtiesContextClassModeBeforeMethodIntegrationTests {
	@SpyBean
	private SimpleExampleService exampleService;
	@Autowired
	private ExampleServiceCaller caller;
	@Test
	void testSpying() {
		this.caller.sayGreeting();
		then(this.exampleService).should().greeting();
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ExampleServiceCaller.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.rsocket.server;
/**
@ExtendWith(SpringExtension.class)
@TestPropertySource(properties = 'local.rsocket.server.port=8181')
class LocalRSocketServerPortTests {
	@Value('${local.rsocket.server.port}')
	private String fromValue;
	@LocalRSocketServerPort
	private String fromAnnotation;
	@Test
	void testLocalRSocketServerPortAnnotation() {
		assertThat(this.fromAnnotation).isNotNull().isEqualTo(this.fromValue);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.graphql.tester;
/**
class HttpGraphQlTesterContextCustomizerTests {
	@Test
	void whenContextIsNotABeanDefinitionRegistryHttpGraphQlTesterIsRegistered() {
		new ApplicationContextRunner(HttpGraphQlTesterContextCustomizerTests.TestApplicationContext::new)
			.withInitializer(this::applyHttpGraphQlTesterContextCustomizer)
			.run((context) -> assertThat(context).hasSingleBean(HttpGraphQlTester.class));
	}
	@Test
	void whenUsingAotGeneratedArtifactsHttpGraphQlTesterIsNotRegistered() {
		new ApplicationContextRunner().withSystemProperties('spring.aot.enabled:true')
			.withInitializer(this::applyHttpGraphQlTesterContextCustomizer)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(HttpGraphQlTesterRegistrar.class);
				assertThat(context).doesNotHaveBean(HttpGraphQlTester.class);
			});
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void applyHttpGraphQlTesterContextCustomizer(ConfigurableApplicationContext context) {
		MergedContextConfiguration configuration = mock(MergedContextConfiguration.class);
		given(configuration.getTestClass()).willReturn((Class) HttpGraphQlTesterContextCustomizerTests.TestClass.class);
		new HttpGraphQlTesterContextCustomizer().customizeContext(context, configuration);
	}
	@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
	static class TestClass {
	}
	static class TestApplicationContext extends AbstractApplicationContext {
		private final ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		@Override
		protected void refreshBeanFactory() {
		}
		@Override
		protected void closeBeanFactory() {
		}
		@Override
		public ConfigurableListableBeanFactory getBeanFactory() {
			return this.beanFactory;
		}
	}
}
/*
package org.springframework.boot.test.graphql.tester;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(properties = 'server.servlet.context-path=/test')
class HttpGraphQlTesterContextCustomizerWithCustomContextPathTests {
	@Autowired
	HttpGraphQlTester graphQlTester;
	@Test
	void shouldHandleGraphQlRequests() {
		this.graphQlTester.document('{}').executeAndVerify();
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestController.class)
	static class TestConfig {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
			factory.setContextPath('/test');
			return factory;
		}
		@Bean
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
	}
	@RestController
	static class TestController {
		@PostMapping(path = '/graphql', produces = MediaType.APPLICATION_JSON_VALUE)
		String graphql() {
			return '{}';
		}
	}
}
/*
package org.springframework.boot.test.graphql.tester;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = 'spring.main.web-application-type=reactive')
@DirtiesContext
class HttpGraphQlTesterContextCustomizerIntegrationTests {
	@Autowired
	HttpGraphQlTester graphQlTester;
	@Test
	void shouldHandleGraphQlRequests() {
		this.graphQlTester.document('{}').executeAndVerify();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		TomcatReactiveWebServerFactory webServerFactory() {
			return new TomcatReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler() {
			TestHandler httpHandler = new TestHandler();
			Map<String, HttpHandler> handlersMap = Collections.singletonMap('/graphql', httpHandler);
			return new ContextPathCompositeHandler(handlersMap);
		}
	}
	static class TestHandler implements HttpHandler {
		private static final DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			response.setStatusCode(HttpStatus.OK);
			response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
			return response.writeWith(Mono.just(factory.wrap('{\'data\':{}}'.getBytes())));
		}
	}
}
/*
package org.springframework.boot.test.graphql.tester;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(properties = { 'spring.main.web-application-type=reactive', 'spring.webflux.base-path=/test' })
class HttpGraphQlTesterContextCustomizerWithCustomBasePathTests {
	@Autowired
	HttpGraphQlTester graphQlTester;
	@Test
	void shouldHandleGraphQlRequests() {
		this.graphQlTester.document('{}').executeAndVerify();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		TomcatReactiveWebServerFactory webServerFactory() {
			return new TomcatReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler() {
			TestHandler httpHandler = new TestHandler();
			Map<String, HttpHandler> handlersMap = Collections.singletonMap('/test/graphql', httpHandler);
			return new ContextPathCompositeHandler(handlersMap);
		}
	}
	static class TestHandler implements HttpHandler {
		private static final DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			response.setStatusCode(HttpStatus.OK);
			response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
			return response.writeWith(Mono.just(factory.wrap('{\'data\':{}}'.getBytes())));
		}
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
public class ApplicationContextAssert<C extends ApplicationContext>
		extends AbstractAssert<ApplicationContextAssert<C>, C> {
	private final Throwable startupFailure;
	/**
	 * Create a new {@link ApplicationContextAssert} instance.
	 * @param applicationContext the source application context
	 * @param startupFailure the startup failure or {@code null}
	 */
	ApplicationContextAssert(C applicationContext, Throwable startupFailure) {
		super(applicationContext, ApplicationContextAssert.class);
		Assert.notNull(applicationContext, 'ApplicationContext must not be null');
		this.startupFailure = startupFailure;
	}
	/**
	 * Verifies that the application context contains a bean with the given name.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).hasBean('fooBean'); </pre>
	 * @param name the name of the bean
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context does not contain a bean with the
	 * given name
	 */
	public ApplicationContextAssert<C> hasBean(String name) {
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('to have bean named:%n <%s>', name));
		}
		if (findBean(name) == null) {
			throwAssertionError(new BasicErrorMessageFactory(
					'%nExpecting:%n <%s>%nto have bean named:%n <%s>%nbut found no such bean', getApplicationContext(),
					name));
		}
		return this;
	}
	/**
	 * Verifies that the application context (or ancestors) contains a single bean with
	 * the given type.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).hasSingleBean(Foo.class); </pre>
	 * @param type the bean type
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context does no beans of the given type
	 * @throws AssertionError if the application context contains multiple beans of the
	 * given type
	 */
	public ApplicationContextAssert<C> hasSingleBean(Class<?> type) {
		return hasSingleBean(type, Scope.INCLUDE_ANCESTORS);
	}
	/**
	 * Verifies that the application context contains a single bean with the given type.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).hasSingleBean(Foo.class, Scope.NO_ANCESTORS); </pre>
	 * @param type the bean type
	 * @param scope the scope of the assertion
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context does no beans of the given type
	 * @throws AssertionError if the application context contains multiple beans of the
	 * given type
	 */
	public ApplicationContextAssert<C> hasSingleBean(Class<?> type, Scope scope) {
		Assert.notNull(scope, 'Scope must not be null');
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('to have a single bean of type:%n <%s>', type));
		}
		String[] names = scope.getBeanNamesForType(getApplicationContext(), type);
		if (names.length == 0) {
			throwAssertionError(new BasicErrorMessageFactory(
					'%nExpecting:%n <%s>%nto have a single bean of type:%n <%s>%nbut found no beans of that type',
					getApplicationContext(), type));
		}
		if (names.length > 1) {
			throwAssertionError(new BasicErrorMessageFactory(
					'%nExpecting:%n <%s>%nto have a single bean of type:%n <%s>%nbut found:%n <%s>',
					getApplicationContext(), type, names));
		}
		return this;
	}
	/**
	 * Verifies that the application context (or ancestors) does not contain any beans of
	 * the given type.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).doesNotHaveBean(Foo.class); </pre>
	 * @param type the bean type
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context contains any beans of the given
	 * type
	 */
	public ApplicationContextAssert<C> doesNotHaveBean(Class<?> type) {
		return doesNotHaveBean(type, Scope.INCLUDE_ANCESTORS);
	}
	/**
	 * Verifies that the application context does not contain any beans of the given type.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).doesNotHaveBean(Foo.class, Scope.NO_ANCESTORS); </pre>
	 * @param type the bean type
	 * @param scope the scope of the assertion
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context contains any beans of the given
	 * type
	 */
	public ApplicationContextAssert<C> doesNotHaveBean(Class<?> type, Scope scope) {
		Assert.notNull(scope, 'Scope must not be null');
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('not to have any beans of type:%n <%s>', type));
		}
		String[] names = scope.getBeanNamesForType(getApplicationContext(), type);
		if (names.length > 0) {
			throwAssertionError(new BasicErrorMessageFactory(
					'%nExpecting:%n <%s>%nnot to have any beans of type:%n <%s>%nbut found:%n <%s>',
					getApplicationContext(), type, names));
		}
		return this;
	}
	/**
	 * Verifies that the application context does not contain a beans of the given name.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).doesNotHaveBean('fooBean'); </pre>
	 * @param name the name of the bean
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context contains a beans of the given
	 * name
	 */
	public ApplicationContextAssert<C> doesNotHaveBean(String name) {
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('not to have any beans of name:%n <%s>', name));
		}
		try {
			Object bean = getApplicationContext().getBean(name);
			throwAssertionError(new BasicErrorMessageFactory(
					'%nExpecting:%n <%s>%nnot to have a bean of name:%n <%s>%nbut found:%n <%s>',
					getApplicationContext(), name, bean));
		}
		catch (NoSuchBeanDefinitionException ex) {
			// Ignore
		}
		return this;
	}
	/**
	 * Obtain the beans names of the given type from the application context, the names
	 * becoming the object array under test.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getBeanNames(Foo.class).containsOnly('fooBean'); </pre>
	 * @param <T> the bean type
	 * @param type the bean type
	 * @return array assertions for the bean names
	 * @throws AssertionError if the application context did not start
	 */
	public <T> AbstractObjectArrayAssert<?, String> getBeanNames(Class<T> type) {
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('to get beans names with type:%n <%s>', type));
		}
		return Assertions.assertThat(getApplicationContext().getBeanNamesForType(type))
			.as('Bean names of type <%s> from <%s>', type, getApplicationContext());
	}
	/**
	 * Obtain a single bean of the given type from the application context (or ancestors),
	 * the bean becoming the object under test. If no beans of the specified type can be
	 * found an assert on {@code null} is returned.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getBean(Foo.class).isInstanceOf(DefaultFoo.class);
	 * assertThat(context).getBean(Bar.class).isNull();</pre>
	 * @param <T> the bean type
	 * @param type the bean type
	 * @return bean assertions for the bean, or an assert on {@code null} if the no bean
	 * is found
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context contains multiple beans of the
	 * given type
	 */
	public <T> AbstractObjectAssert<?, T> getBean(Class<T> type) {
		return getBean(type, Scope.INCLUDE_ANCESTORS);
	}
	/**
	 * Obtain a single bean of the given type from the application context, the bean
	 * becoming the object under test. If no beans of the specified type can be found an
	 * assert on {@code null} is returned.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getBean(Foo.class, Scope.NO_ANCESTORS).isInstanceOf(DefaultFoo.class);
	 * assertThat(context).getBean(Bar.class, Scope.NO_ANCESTORS).isNull();</pre>
	 * @param <T> the bean type
	 * @param type the bean type
	 * @param scope the scope of the assertion
	 * @return bean assertions for the bean, or an assert on {@code null} if the no bean
	 * is found
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context contains multiple beans of the
	 * given type
	 */
	public <T> AbstractObjectAssert<?, T> getBean(Class<T> type, Scope scope) {
		Assert.notNull(scope, 'Scope must not be null');
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('to contain bean of type:%n <%s>', type));
		}
		String[] names = scope.getBeanNamesForType(getApplicationContext(), type);
		String name = (names.length > 0) ? getPrimary(names, scope) : null;
		if (names.length > 1 && name == null) {
			throwAssertionError(
					new BasicErrorMessageFactory('%nExpecting:%n <%s>%nsingle bean of type:%n <%s>%nbut found:%n <%s>',
							getApplicationContext(), type, names));
		}
		T bean = (name != null) ? getApplicationContext().getBean(name, type) : null;
		return Assertions.assertThat(bean).as('Bean of type <%s> from <%s>', type, getApplicationContext());
	}
	private String getPrimary(String[] names, Scope scope) {
		if (names.length == 1) {
			return names[0];
		}
		String primary = null;
		for (String name : names) {
			if (isPrimary(name, scope)) {
				if (primary != null) {
					return null;
				}
				primary = name;
			}
		}
		return primary;
	}
	private boolean isPrimary(String name, Scope scope) {
		ApplicationContext context = getApplicationContext();
		while (context != null) {
			if (context instanceof ConfigurableApplicationContext configurableContext) {
				ConfigurableListableBeanFactory factory = configurableContext.getBeanFactory();
				if (factory.containsBean(name) && factory.getMergedBeanDefinition(name).isPrimary()) {
					return true;
				}
			}
			context = (scope != Scope.NO_ANCESTORS) ? context.getParent() : null;
		}
		return false;
	}
	/**
	 * Obtain a single bean of the given name from the application context, the bean
	 * becoming the object under test. If no bean of the specified name can be found an
	 * assert on {@code null} is returned.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getBean('foo').isInstanceOf(Foo.class);
	 * assertThat(context).getBean('foo').isNull();</pre>
	 * @param name the name of the bean
	 * @return bean assertions for the bean, or an assert on {@code null} if the no bean
	 * is found
	 * @throws AssertionError if the application context did not start
	 */
	public AbstractObjectAssert<?, Object> getBean(String name) {
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('to contain a bean of name:%n <%s>', name));
		}
		Object bean = findBean(name);
		return Assertions.assertThat(bean).as('Bean of name <%s> from <%s>', name, getApplicationContext());
	}
	/**
	 * Obtain a single bean of the given name and type from the application context, the
	 * bean becoming the object under test. If no bean of the specified name can be found
	 * an assert on {@code null} is returned.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getBean('foo', Foo.class).isInstanceOf(DefaultFoo.class);
	 * assertThat(context).getBean('foo', Foo.class).isNull();</pre>
	 * @param <T> the bean type
	 * @param name the name of the bean
	 * @param type the bean type
	 * @return bean assertions for the bean, or an assert on {@code null} if the no bean
	 * is found
	 * @throws AssertionError if the application context did not start
	 * @throws AssertionError if the application context contains a bean with the given
	 * name but a different type
	 */
	@SuppressWarnings('unchecked')
	public <T> AbstractObjectAssert<?, T> getBean(String name, Class<T> type) {
		if (this.startupFailure != null) {
			throwAssertionError(
					contextFailedToStartWhenExpecting('to contain a bean of name:%n <%s> (%s)', name, type));
		}
		Object bean = findBean(name);
		if (bean != null && type != null && !type.isInstance(bean)) {
			throwAssertionError(new BasicErrorMessageFactory(
					'%nExpecting:%n <%s>%nto contain a bean of name:%n <%s> (%s)%nbut found:%n <%s> of type <%s>',
					getApplicationContext(), name, type, bean, bean.getClass()));
		}
		return Assertions.assertThat((T) bean)
			.as('Bean of name <%s> and type <%s> from <%s>', name, type, getApplicationContext());
	}
	private Object findBean(String name) {
		try {
			return getApplicationContext().getBean(name);
		}
		catch (NoSuchBeanDefinitionException ex) {
			return null;
		}
	}
	/**
	 * Obtain a map bean names and instances of the given type from the application
	 * context (or ancestors), the map becoming the object under test. If no bean of the
	 * specified type can be found an assert on an empty {@code map} is returned.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getBeans(Foo.class).containsKey('foo');
	 * </pre>
	 * @param <T> the bean type
	 * @param type the bean type
	 * @return bean assertions for the beans, or an assert on an empty {@code map} if the
	 * no beans are found
	 * @throws AssertionError if the application context did not start
	 */
	public <T> MapAssert<String, T> getBeans(Class<T> type) {
		return getBeans(type, Scope.INCLUDE_ANCESTORS);
	}
	/**
	 * Obtain a map bean names and instances of the given type from the application
	 * context, the map becoming the object under test. If no bean of the specified type
	 * can be found an assert on an empty {@code map} is returned.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getBeans(Foo.class, Scope.NO_ANCESTORS).containsKey('foo');
	 * </pre>
	 * @param <T> the bean type
	 * @param type the bean type
	 * @param scope the scope of the assertion
	 * @return bean assertions for the beans, or an assert on an empty {@code map} if the
	 * no beans are found
	 * @throws AssertionError if the application context did not start
	 */
	public <T> MapAssert<String, T> getBeans(Class<T> type, Scope scope) {
		Assert.notNull(scope, 'Scope must not be null');
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('to get beans of type:%n <%s>', type));
		}
		return Assertions.assertThat(scope.getBeansOfType(getApplicationContext(), type))
			.as('Beans of type <%s> from <%s>', type, getApplicationContext());
	}
	/**
	 * Obtain the failure that stopped the application context from running, the failure
	 * becoming the object under test.
	 * <p>
	 * Example: <pre class='code'>
	 * assertThat(context).getFailure().containsMessage('missing bean');
	 * </pre>
	 * @return assertions on the cause of the failure
	 * @throws AssertionError if the application context started without a failure
	 */
	public AbstractThrowableAssert<?, ? extends Throwable> getFailure() {
		hasFailed();
		return assertThat(this.startupFailure);
	}
	/**
	 * Verifies that the application has failed to start.
	 * <p>
	 * Example: <pre class='code'> assertThat(context).hasFailed();
	 * </pre>
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context started without a failure
	 */
	public ApplicationContextAssert<C> hasFailed() {
		if (this.startupFailure == null) {
			throwAssertionError(new BasicErrorMessageFactory(
					'%nExpecting:%n <%s>%nto have failed%nbut context started successfully', getApplicationContext()));
		}
		return this;
	}
	/**
	 * Verifies that the application has not failed to start.
	 * <p>
	 * Example: <pre class='code'> assertThat(context).hasNotFailed();
	 * </pre>
	 * @return {@code this} assertion object.
	 * @throws AssertionError if the application context failed to start
	 */
	public ApplicationContextAssert<C> hasNotFailed() {
		if (this.startupFailure != null) {
			throwAssertionError(contextFailedToStartWhenExpecting('to have not failed'));
		}
		return this;
	}
	protected final C getApplicationContext() {
		return this.actual;
	}
	protected final Throwable getStartupFailure() {
		return this.startupFailure;
	}
	private ContextFailedToStart<C> contextFailedToStartWhenExpecting(String expectationFormat, Object... arguments) {
		return new ContextFailedToStart<>(getApplicationContext(), this.startupFailure, expectationFormat, arguments);
	}
	/**
	 * The scope of an assertion.
	 */
	public enum Scope {
		/**
		 * Limited to the current context.
		 */
		NO_ANCESTORS {
			@Override
			String[] getBeanNamesForType(ApplicationContext applicationContext, Class<?> type) {
				return applicationContext.getBeanNamesForType(type);
			}
			@Override
			<T> Map<String, T> getBeansOfType(ApplicationContext applicationContext, Class<T> type) {
				return applicationContext.getBeansOfType(type);
			}
		},
		/**
		 * Consider the ancestor contexts as well as the current context.
		 */
		INCLUDE_ANCESTORS {
			@Override
			String[] getBeanNamesForType(ApplicationContext applicationContext, Class<?> type) {
				return BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, type);
			}
			@Override
			<T> Map<String, T> getBeansOfType(ApplicationContext applicationContext, Class<T> type) {
				return BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, type);
			}
		};
		abstract String[] getBeanNamesForType(ApplicationContext applicationContext, Class<?> type);
		abstract <T> Map<String, T> getBeansOfType(ApplicationContext applicationContext, Class<T> type);
	}
	private static final class ContextFailedToStart<C extends ApplicationContext> extends BasicErrorMessageFactory {
		private ContextFailedToStart(C context, Throwable ex, String expectationFormat, Object... arguments) {
			super('%nExpecting:%n <%s>%n' + expectationFormat + ':%nbut context failed to start:%n%s',
					combineArguments(context.toString(), ex, arguments));
		}
		private static Object[] combineArguments(String context, Throwable ex, Object[] arguments) {
			Object[] combinedArguments = new Object[arguments.length + 2];
			combinedArguments[0] = unquotedString(context);
			System.arraycopy(arguments, 0, combinedArguments, 1, arguments.length);
			combinedArguments[combinedArguments.length - 1] = unquotedString(getIndentedStackTraceAsString(ex));
			return combinedArguments;
		}
		private static String getIndentedStackTraceAsString(Throwable ex) {
			String stackTrace = getStackTraceAsString(ex);
			return indent(stackTrace);
		}
		private static String getStackTraceAsString(Throwable ex) {
			StringWriter writer = new StringWriter();
			PrintWriter printer = new PrintWriter(writer);
			ex.printStackTrace(printer);
			return writer.toString();
		}
		private static String indent(String input) {
			BufferedReader reader = new BufferedReader(new StringReader(input));
			StringWriter writer = new StringWriter();
			PrintWriter printer = new PrintWriter(writer);
			reader.lines().forEach((line) -> {
				printer.print(' ');
				printer.println(line);
			});
			return writer.toString();
		}
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
class AssertProviderApplicationContextInvocationHandler implements InvocationHandler {
	private final Class<?> applicationContextType;
	private final ApplicationContext applicationContext;
	private final RuntimeException startupFailure;
	AssertProviderApplicationContextInvocationHandler(Class<?> applicationContextType, Supplier<?> contextSupplier) {
		this.applicationContextType = applicationContextType;
		Object contextOrStartupFailure = getContextOrStartupFailure(contextSupplier);
		if (contextOrStartupFailure instanceof RuntimeException runtimeException) {
			this.applicationContext = null;
			this.startupFailure = runtimeException;
		}
		else {
			this.applicationContext = (ApplicationContext) contextOrStartupFailure;
			this.startupFailure = null;
		}
	}
	private Object getContextOrStartupFailure(Supplier<?> contextSupplier) {
		try {
			return contextSupplier.get();
		}
		catch (RuntimeException ex) {
			return ex;
		}
	}
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		if (isToString(method)) {
			return toString();
		}
		if (isGetSourceContext(method)) {
			return getSourceContext(args);
		}
		if (isGetStartupFailure(method)) {
			return getStartupFailure();
		}
		if (isAssertThat(method)) {
			return getAssertThat(proxy);
		}
		if (isCloseMethod(method)) {
			return invokeClose();
		}
		return invokeApplicationContextMethod(method, args);
	}
	private boolean isToString(Method method) {
		return ('toString'.equals(method.getName()) && method.getParameterCount() == 0);
	}
	@Override
	public String toString() {
		if (this.startupFailure != null) {
			return 'Unstarted application context ' + this.applicationContextType.getName() + '[startupFailure='
					+ this.startupFailure.getClass().getName() + ']';
		}
		ToStringCreator builder = new ToStringCreator(this.applicationContext)
			.append('id', this.applicationContext.getId())
			.append('applicationName', this.applicationContext.getApplicationName())
			.append('beanDefinitionCount', this.applicationContext.getBeanDefinitionCount());
		return 'Started application ' + builder;
	}
	private boolean isGetSourceContext(Method method) {
		return 'getSourceApplicationContext'.equals(method.getName()) && ((method.getParameterCount() == 0)
				|| Arrays.equals(new Class<?>[] { Class.class }, method.getParameterTypes()));
	}
	private Object getSourceContext(Object[] args) {
		ApplicationContext context = getStartedApplicationContext();
		if (!ObjectUtils.isEmpty(args)) {
			Assert.isInstanceOf((Class<?>) args[0], context);
		}
		return context;
	}
	private boolean isGetStartupFailure(Method method) {
		return ('getStartupFailure'.equals(method.getName()) && method.getParameterCount() == 0);
	}
	private Object getStartupFailure() {
		return this.startupFailure;
	}
	private boolean isAssertThat(Method method) {
		return ('assertThat'.equals(method.getName()) && method.getParameterCount() == 0);
	}
	private Object getAssertThat(Object proxy) {
		return new ApplicationContextAssert<>((ApplicationContext) proxy, this.startupFailure);
	}
	private boolean isCloseMethod(Method method) {
		return ('close'.equals(method.getName()) && method.getParameterCount() == 0);
	}
	private Object invokeClose() throws IOException {
		if (this.applicationContext instanceof Closeable closeable) {
			closeable.close();
		}
		return null;
	}
	private Object invokeApplicationContextMethod(Method method, Object[] args) throws Throwable {
		try {
			return method.invoke(getStartedApplicationContext(), args);
		}
		catch (InvocationTargetException ex) {
			throw ex.getTargetException();
		}
	}
	private ApplicationContext getStartedApplicationContext() {
		if (this.startupFailure != null) {
			throw new IllegalStateException(this + ' failed to start', this.startupFailure);
		}
		return this.applicationContext;
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
public interface AssertableApplicationContext
		extends ApplicationContextAssertProvider<ConfigurableApplicationContext>, ConfigurableApplicationContext {
	/**
	 * Factory method to create a new {@link AssertableApplicationContext} instance.
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ConfigurableApplicationContext} or throw an exception if the context fails
	 * to start.
	 * @return an {@link AssertableApplicationContext} instance
	 */
	static AssertableApplicationContext get(Supplier<? extends ConfigurableApplicationContext> contextSupplier) {
		return ApplicationContextAssertProvider.get(AssertableApplicationContext.class,
				ConfigurableApplicationContext.class, contextSupplier);
	}
	/**
	 * Factory method to create a new {@link AssertableApplicationContext} instance.
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ConfigurableApplicationContext} or throw an exception if the context fails
	 * to start.
	 * @param additionalContextInterfaces and additional context interfaces to add to the
	 * proxy
	 * @return an {@link AssertableApplicationContext} instance
	 * @since 3.4.0
	 */
	static AssertableApplicationContext get(Supplier<? extends ConfigurableApplicationContext> contextSupplier,
			Class<?>... additionalContextInterfaces) {
		return ApplicationContextAssertProvider.get(AssertableApplicationContext.class,
				ConfigurableApplicationContext.class, contextSupplier, additionalContextInterfaces);
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
public interface AssertableReactiveWebApplicationContext
		extends ApplicationContextAssertProvider<ConfigurableReactiveWebApplicationContext>,
		ConfigurableReactiveWebApplicationContext {
	/**
	 * Factory method to create a new {@link AssertableReactiveWebApplicationContext}
	 * instance.
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ConfigurableReactiveWebApplicationContext} or throw an exception if the
	 * context fails to start.
	 * @return a {@link AssertableReactiveWebApplicationContext} instance
	 */
	static AssertableReactiveWebApplicationContext get(
			Supplier<? extends ConfigurableReactiveWebApplicationContext> contextSupplier) {
		return ApplicationContextAssertProvider.get(AssertableReactiveWebApplicationContext.class,
				ConfigurableReactiveWebApplicationContext.class, contextSupplier);
	}
	/**
	 * Factory method to create a new {@link AssertableReactiveWebApplicationContext}
	 * instance.
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ConfigurableReactiveWebApplicationContext} or throw an exception if the
	 * context fails to start.
	 * @param additionalContextInterfaces and additional context interfaces to add to the
	 * proxy
	 * @return a {@link AssertableReactiveWebApplicationContext} instance
	 * @since 3.4.0
	 */
	static AssertableReactiveWebApplicationContext get(
			Supplier<? extends ConfigurableReactiveWebApplicationContext> contextSupplier,
			Class<?>... additionalContextInterfaces) {
		return ApplicationContextAssertProvider.get(AssertableReactiveWebApplicationContext.class,
				ConfigurableReactiveWebApplicationContext.class, contextSupplier, additionalContextInterfaces);
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
public interface AssertableWebApplicationContext
		extends ApplicationContextAssertProvider<ConfigurableWebApplicationContext>, ConfigurableWebApplicationContext {
	/**
	 * Factory method to create a new {@link AssertableWebApplicationContext} instance.
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ConfigurableWebApplicationContext} or throw an exception if the context
	 * fails to start.
	 * @return a {@link AssertableWebApplicationContext} instance
	 */
	static AssertableWebApplicationContext get(Supplier<? extends ConfigurableWebApplicationContext> contextSupplier) {
		return ApplicationContextAssertProvider.get(AssertableWebApplicationContext.class,
				ConfigurableWebApplicationContext.class, contextSupplier);
	}
	/**
	 * Factory method to create a new {@link AssertableWebApplicationContext} instance.
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ConfigurableWebApplicationContext} or throw an exception if the context
	 * fails to start.
	 * @param additionalContextInterfaces and additional context interfaces to add to the
	 * proxy
	 * @return a {@link AssertableWebApplicationContext} instance
	 * @since 3.4.0
	 */
	static AssertableWebApplicationContext get(Supplier<? extends ConfigurableWebApplicationContext> contextSupplier,
			Class<?>... additionalContextInterfaces) {
		return ApplicationContextAssertProvider.get(AssertableWebApplicationContext.class,
				ConfigurableWebApplicationContext.class, contextSupplier, additionalContextInterfaces);
	}
}
/*
package org.springframework.boot.test.context.assertj;
/**
public interface ApplicationContextAssertProvider<C extends ApplicationContext>
		extends ApplicationContext, AssertProvider<ApplicationContextAssert<C>>, Closeable {
	/**
	 * Return an assert for AspectJ.
	 * @return an AspectJ assert
	 * @deprecated to prevent accidental use. Prefer standard AssertJ
	 * {@code assertThat(context)...} calls instead.
	 */
	@Deprecated(since = '2.0.0', forRemoval = false)
	@Override
	ApplicationContextAssert<C> assertThat();
	/**
	 * Return the original source {@link ApplicationContext}.
	 * @return the source application context
	 * @throws IllegalStateException if the source context failed to start
	 */
	C getSourceApplicationContext();
	/**
	 * Return the original source {@link ApplicationContext}, casting it to the requested
	 * type.
	 * @param <T> the context type
	 * @param requiredType the required context type
	 * @return the source application context
	 * @throws IllegalStateException if the source context failed to start
	 */
	<T extends C> T getSourceApplicationContext(Class<T> requiredType);
	/**
	 * Return the failure that caused application context to fail or {@code null} if the
	 * context started without issue.
	 * @return the startup failure or {@code null}
	 */
	Throwable getStartupFailure();
	@Override
	void close();
	/**
	 * Factory method to create a new {@link ApplicationContextAssertProvider} instance.
	 * @param <T> the assert provider type
	 * @param <C> the context type
	 * @param type the type of {@link ApplicationContextAssertProvider} required (must be
	 * an interface)
	 * @param contextType the type of {@link ApplicationContext} being managed (must be an
	 * interface)
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ApplicationContext} or throw an exception if the context fails to start.
	 * @return a {@link ApplicationContextAssertProvider} instance
	 */
	static <T extends ApplicationContextAssertProvider<C>, C extends ApplicationContext> T get(Class<T> type,
			Class<? extends C> contextType, Supplier<? extends C> contextSupplier) {
		return get(type, contextType, contextSupplier, new Class<?>[0]);
	}
	/**
	 * Factory method to create a new {@link ApplicationContextAssertProvider} instance.
	 * @param <T> the assert provider type
	 * @param <C> the context type
	 * @param type the type of {@link ApplicationContextAssertProvider} required (must be
	 * an interface)
	 * @param contextType the type of {@link ApplicationContext} being managed (must be an
	 * interface)
	 * @param contextSupplier a supplier that will either return a fully configured
	 * {@link ApplicationContext} or throw an exception if the context fails to start.
	 * @param additionalContextInterfaces and additional context interfaces to add to the
	 * proxy
	 * @return a {@link ApplicationContextAssertProvider} instance
	 * @since 3.4.0
	 */
	@SuppressWarnings('unchecked')
	static <T extends ApplicationContextAssertProvider<C>, C extends ApplicationContext> T get(Class<T> type,
			Class<? extends C> contextType, Supplier<? extends C> contextSupplier,
			Class<?>... additionalContextInterfaces) {
		Assert.notNull(type, 'Type must not be null');
		Assert.isTrue(type.isInterface(), 'Type must be an interface');
		Assert.notNull(contextType, 'ContextType must not be null');
		Assert.isTrue(contextType.isInterface(), 'ContextType must be an interface');
		Class<?>[] interfaces = merge(new Class<?>[] { type, contextType }, additionalContextInterfaces);
		return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces,
				new AssertProviderApplicationContextInvocationHandler(contextType, contextSupplier));
	}
	private static Class<?>[] merge(Class<?>[] classes, Class<?>[] additional) {
		if (ObjectUtils.isEmpty(additional)) {
			return classes;
		}
		Class<?>[] result = Arrays.copyOf(classes, classes.length + additional.length);
		System.arraycopy(additional, 0, result, classes.length, additional.length);
		return result;
	}
}
/*
/**
package org.springframework.boot.test.context.assertj;
/*
package org.springframework.boot.test.context;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
@TestComponent
public @interface TestConfiguration {
	/**
	 * Explicitly specify the name of the Spring bean definition associated with this
	 * Configuration class. See {@link Configuration#value()} for details.
	 * @return the specified bean name, if any
	 */
	@AliasFor(annotation = Configuration.class)
	String value() default '';
	/**
	 * Specify whether {@link Bean @Bean} methods should get proxied in order to enforce
	 * bean lifecycle behavior, e.g. to return shared singleton bean instances even in
	 * case of direct {@code @Bean} method calls in user code. This feature requires
	 * method interception, implemented through a runtime-generated CGLIB subclass which
	 * comes with limitations such as the configuration class and its methods not being
	 * allowed to declare {@code final}.
	 * <p>
	 * The default is {@code true}, allowing for "inter-bean references" within the
	 * configuration class as well as for external calls to this configuration"s
	 * {@code @Bean} methods, e.g. from another configuration class. If this is not needed
	 * since each of this particular configuration"s {@code @Bean} methods is
	 * self-contained and designed as a plain factory method for container use, switch
	 * this flag to {@code false} in order to avoid CGLIB subclass processing.
	 * <p>
	 * Turning off bean method interception effectively processes {@code @Bean} methods
	 * individually like when declared on non-{@code @Configuration} classes, a.k.a.
	 * '@Bean Lite Mode' (see {@link Bean @Bean"s javadoc}). It is therefore behaviorally
	 * equivalent to removing the {@code @Configuration} stereotype.
	 * @return whether to proxy {@code @Bean} methods
	 * @since 2.2.1
	 */
	@AliasFor(annotation = Configuration.class)
	boolean proxyBeanMethods() default true;
}
/*
package org.springframework.boot.test.context.filter;
/**
class ExcludeFilterContextCustomizer implements ContextCustomizer {
	@Override
	public void customizeContext(ConfigurableApplicationContext context,
			MergedContextConfiguration mergedContextConfiguration) {
		TestTypeExcludeFilter.registerWith(context.getBeanFactory());
	}
	@Override
	public boolean equals(Object obj) {
		return (obj != null) && (getClass() == obj.getClass());
	}
	@Override
	public int hashCode() {
		return getClass().hashCode();
	}
}
/*
package org.springframework.boot.test.context.filter;
/**
class ExcludeFilterContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		return new ExcludeFilterContextCustomizer();
	}
}
/*
package org.springframework.boot.test.context.filter;
/**
class ExcludeFilterApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		TestTypeExcludeFilter.registerWith(applicationContext.getBeanFactory());
	}
}
/*
/**
package org.springframework.boot.test.context.filter;
/*
package org.springframework.boot.test.context.filter;
/**
class TestTypeExcludeFilter extends TypeExcludeFilter {
	private static final String BEAN_NAME = TestTypeExcludeFilter.class.getName();
	private static final String[] CLASS_ANNOTATIONS = { 'org.junit.runner.RunWith',
			'org.junit.jupiter.api.extension.ExtendWith', 'org.junit.platform.commons.annotation.Testable',
			'org.testng.annotations.Test' };
	private static final String[] METHOD_ANNOTATIONS = { 'org.junit.Test',
			'org.junit.platform.commons.annotation.Testable', 'org.testng.annotations.Test' };
	private static final TestTypeExcludeFilter INSTANCE = new TestTypeExcludeFilter();
	@Override
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		if (isTestConfiguration(metadataReader)) {
			return true;
		}
		if (isTestClass(metadataReader)) {
			return true;
		}
		String enclosing = metadataReader.getClassMetadata().getEnclosingClassName();
		if (enclosing != null) {
			try {
				if (match(metadataReaderFactory.getMetadataReader(enclosing), metadataReaderFactory)) {
					return true;
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return false;
	}
	@Override
	public boolean equals(Object obj) {
		return (obj != null) && (getClass() == obj.getClass());
	}
	@Override
	public int hashCode() {
		return getClass().hashCode();
	}
	private boolean isTestConfiguration(MetadataReader metadataReader) {
		return (metadataReader.getAnnotationMetadata().isAnnotated(TestComponent.class.getName()));
	}
	private boolean isTestClass(MetadataReader metadataReader) {
		for (String annotation : CLASS_ANNOTATIONS) {
			if (metadataReader.getAnnotationMetadata().hasAnnotation(annotation)) {
				return true;
			}
		}
		for (String annotation : METHOD_ANNOTATIONS) {
			if (metadataReader.getAnnotationMetadata().hasAnnotatedMethods(annotation)) {
				return true;
			}
		}
		return false;
	}
	static void registerWith(ConfigurableListableBeanFactory beanFactory) {
		if (!beanFactory.containsSingleton(BEAN_NAME)) {
			beanFactory.registerSingleton(BEAN_NAME, INSTANCE);
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
public class SpringBootTestContextBootstrapper extends DefaultTestContextBootstrapper {
	private static final String[] WEB_ENVIRONMENT_CLASSES = { 'jakarta.servlet.Servlet',
			'org.springframework.web.context.ConfigurableWebApplicationContext' };
	private static final String REACTIVE_WEB_ENVIRONMENT_CLASS = 'org.springframework.'
			+ 'web.reactive.DispatcherHandler';
	private static final String MVC_WEB_ENVIRONMENT_CLASS = 'org.springframework.web.servlet.DispatcherServlet';
	private static final String JERSEY_WEB_ENVIRONMENT_CLASS = 'org.glassfish.jersey.server.ResourceConfig';
	private static final String ACTIVATE_SERVLET_LISTENER = 'org.springframework.test.'
			+ 'context.web.ServletTestExecutionListener.activateListener';
	private static final Log logger = LogFactory.getLog(SpringBootTestContextBootstrapper.class);
	private final AotTestAttributes aotTestAttributes;
	public SpringBootTestContextBootstrapper() {
		this(AotTestAttributes.getInstance());
	}
	SpringBootTestContextBootstrapper(AotTestAttributes aotTestAttributes) {
		this.aotTestAttributes = aotTestAttributes;
	}
	@Override
	public TestContext buildTestContext() {
		TestContext context = super.buildTestContext();
		verifyConfiguration(context.getTestClass());
		WebEnvironment webEnvironment = getWebEnvironment(context.getTestClass());
		if (webEnvironment == WebEnvironment.MOCK && deduceWebApplicationType() == WebApplicationType.SERVLET) {
			context.setAttribute(ACTIVATE_SERVLET_LISTENER, true);
		}
		else if (webEnvironment != null && webEnvironment.isEmbedded()) {
			context.setAttribute(ACTIVATE_SERVLET_LISTENER, false);
		}
		return context;
	}
	@Override
	protected ContextLoader resolveContextLoader(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributesList) {
		Class<?>[] classes = getClasses(testClass);
		if (!ObjectUtils.isEmpty(classes)) {
			for (ContextConfigurationAttributes configAttributes : configAttributesList) {
				addConfigAttributesClasses(configAttributes, classes);
			}
		}
		return super.resolveContextLoader(testClass, configAttributesList);
	}
	private void addConfigAttributesClasses(ContextConfigurationAttributes configAttributes, Class<?>[] classes) {
		Set<Class<?>> combined = new LinkedHashSet<>(Arrays.asList(classes));
		if (configAttributes.getClasses() != null) {
			combined.addAll(Arrays.asList(configAttributes.getClasses()));
		}
		configAttributes.setClasses(ClassUtils.toClassArray(combined));
	}
	@Override
	protected Class<? extends ContextLoader> getDefaultContextLoaderClass(Class<?> testClass) {
		return SpringBootContextLoader.class;
	}
	@Override
	protected MergedContextConfiguration processMergedContextConfiguration(MergedContextConfiguration mergedConfig) {
		Class<?>[] classes = getOrFindConfigurationClasses(mergedConfig);
		List<String> propertySourceProperties = getAndProcessPropertySourceProperties(mergedConfig);
		mergedConfig = createModifiedConfig(mergedConfig, classes, StringUtils.toStringArray(propertySourceProperties));
		WebEnvironment webEnvironment = getWebEnvironment(mergedConfig.getTestClass());
		if (webEnvironment != null && isWebEnvironmentSupported(mergedConfig)) {
			WebApplicationType webApplicationType = getWebApplicationType(mergedConfig);
			if (webApplicationType == WebApplicationType.SERVLET
					&& (webEnvironment.isEmbedded() || webEnvironment == WebEnvironment.MOCK)) {
				mergedConfig = new WebMergedContextConfiguration(mergedConfig, determineResourceBasePath(mergedConfig));
			}
			else if (webApplicationType == WebApplicationType.REACTIVE
					&& (webEnvironment.isEmbedded() || webEnvironment == WebEnvironment.MOCK)) {
				return new ReactiveWebMergedContextConfiguration(mergedConfig);
			}
		}
		return mergedConfig;
	}
	private WebApplicationType getWebApplicationType(MergedContextConfiguration configuration) {
		ConfigurationPropertySource source = new MapConfigurationPropertySource(
				TestPropertySourceUtils.convertInlinedPropertiesToMap(configuration.getPropertySourceProperties()));
		Binder binder = new Binder(source);
		return binder.bind('spring.main.web-application-type', Bindable.of(WebApplicationType.class))
			.orElseGet(this::deduceWebApplicationType);
	}
	private WebApplicationType deduceWebApplicationType() {
		if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null)
				&& !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)
				&& !ClassUtils.isPresent(JERSEY_WEB_ENVIRONMENT_CLASS, null)) {
			return WebApplicationType.REACTIVE;
		}
		for (String className : WEB_ENVIRONMENT_CLASSES) {
			if (!ClassUtils.isPresent(className, null)) {
				return WebApplicationType.NONE;
			}
		}
		return WebApplicationType.SERVLET;
	}
	/**
	 * Determines the resource base path for web applications using the value of
	 * {@link WebAppConfiguration @WebAppConfiguration}, if any, on the test class of the
	 * given {@code configuration}. Defaults to {@code src/main/webapp} in its absence.
	 * @param configuration the configuration to examine
	 * @return the resource base path
	 * @since 2.1.6
	 */
	protected String determineResourceBasePath(MergedContextConfiguration configuration) {
		return MergedAnnotations.from(configuration.getTestClass(), SearchStrategy.TYPE_HIERARCHY)
			.get(WebAppConfiguration.class)
			.getValue(MergedAnnotation.VALUE, String.class)
			.orElse('src/main/webapp');
	}
	private boolean isWebEnvironmentSupported(MergedContextConfiguration mergedConfig) {
		Class<?> testClass = mergedConfig.getTestClass();
		ContextHierarchy hierarchy = AnnotationUtils.getAnnotation(testClass, ContextHierarchy.class);
		if (hierarchy == null || hierarchy.value().length == 0) {
			return true;
		}
		ContextConfiguration[] configurations = hierarchy.value();
		return isFromConfiguration(mergedConfig, configurations[configurations.length - 1]);
	}
	private boolean isFromConfiguration(MergedContextConfiguration candidateConfig,
			ContextConfiguration configuration) {
		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(candidateConfig.getTestClass(),
				configuration);
		Set<Class<?>> configurationClasses = new HashSet<>(Arrays.asList(attributes.getClasses()));
		for (Class<?> candidate : candidateConfig.getClasses()) {
			if (configurationClasses.contains(candidate)) {
				return true;
			}
		}
		return false;
	}
	protected Class<?>[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) {
		Class<?>[] classes = mergedConfig.getClasses();
		if (containsNonTestComponent(classes) || mergedConfig.hasLocations()) {
			return classes;
		}
		Class<?> found = findConfigurationClass(mergedConfig.getTestClass());
		logger.info('Found @SpringBootConfiguration ' + found.getName() + ' for test ' + mergedConfig.getTestClass());
		return merge(found, classes);
	}
	private Class<?> findConfigurationClass(Class<?> testClass) {
		String propertyName = '%s.SpringBootConfiguration.%s'
			.formatted(SpringBootTestContextBootstrapper.class.getName(), testClass.getName());
		String foundClassName = this.aotTestAttributes.getString(propertyName);
		if (foundClassName != null) {
			return ClassUtils.resolveClassName(foundClassName, testClass.getClassLoader());
		}
		Class<?> found = new AnnotatedClassFinder(SpringBootConfiguration.class).findFromClass(testClass);
		Assert.state(found != null, 'Unable to find a @SpringBootConfiguration, you need to use '
				+ '@ContextConfiguration or @SpringBootTest(classes=...) with your test');
		this.aotTestAttributes.setAttribute(propertyName, found.getName());
		return found;
	}
	private boolean containsNonTestComponent(Class<?>[] classes) {
		for (Class<?> candidate : classes) {
			if (!MergedAnnotations.from(candidate, SearchStrategy.INHERITED_ANNOTATIONS)
				.isPresent(TestConfiguration.class)) {
				return true;
			}
		}
		return false;
	}
	private Class<?>[] merge(Class<?> head, Class<?>[] existing) {
		Class<?>[] result = new Class<?>[existing.length + 1];
		result[0] = head;
		System.arraycopy(existing, 0, result, 1, existing.length);
		return result;
	}
	private List<String> getAndProcessPropertySourceProperties(MergedContextConfiguration mergedConfig) {
		List<String> propertySourceProperties = new ArrayList<>(
				Arrays.asList(mergedConfig.getPropertySourceProperties()));
		String differentiator = getDifferentiatorPropertySourceProperty();
		if (differentiator != null) {
			propertySourceProperties.add(differentiator);
		}
		processPropertySourceProperties(mergedConfig, propertySourceProperties);
		return propertySourceProperties;
	}
	/**
	 * Return a 'differentiator' property to ensure that there is something to
	 * differentiate regular tests and bootstrapped tests. Without this property a cached
	 * context could be returned that wasn"t created by this bootstrapper. By default uses
	 * the bootstrapper class as a property.
	 * @return the differentiator or {@code null}
	 */
	protected String getDifferentiatorPropertySourceProperty() {
		return getClass().getName() + '=true';
	}
	/**
	 * Post process the property source properties, adding or removing elements as
	 * required.
	 * @param mergedConfig the merged context configuration
	 * @param propertySourceProperties the property source properties to process
	 */
	protected void processPropertySourceProperties(MergedContextConfiguration mergedConfig,
			List<String> propertySourceProperties) {
		Class<?> testClass = mergedConfig.getTestClass();
		String[] properties = getProperties(testClass);
		if (!ObjectUtils.isEmpty(properties)) {
			// Added first so that inlined properties from @TestPropertySource take
			// precedence
			propertySourceProperties.addAll(0, Arrays.asList(properties));
		}
		WebEnvironment webEnvironment = getWebEnvironment(testClass);
		if (webEnvironment == WebEnvironment.RANDOM_PORT) {
			propertySourceProperties.add('server.port=0');
		}
		else if (webEnvironment == WebEnvironment.NONE) {
			propertySourceProperties.add('spring.main.web-application-type=none');
		}
	}
	/**
	 * Return the {@link WebEnvironment} type for this test or null if undefined.
	 * @param testClass the source test class
	 * @return the {@link WebEnvironment} or {@code null}
	 */
	protected WebEnvironment getWebEnvironment(Class<?> testClass) {
		SpringBootTest annotation = getAnnotation(testClass);
		return (annotation != null) ? annotation.webEnvironment() : null;
	}
	protected Class<?>[] getClasses(Class<?> testClass) {
		SpringBootTest annotation = getAnnotation(testClass);
		return (annotation != null) ? annotation.classes() : null;
	}
	protected String[] getProperties(Class<?> testClass) {
		SpringBootTest annotation = getAnnotation(testClass);
		return (annotation != null) ? annotation.properties() : null;
	}
	protected SpringBootTest getAnnotation(Class<?> testClass) {
		return TestContextAnnotationUtils.findMergedAnnotation(testClass, SpringBootTest.class);
	}
	protected void verifyConfiguration(Class<?> testClass) {
		SpringBootTest springBootTest = getAnnotation(testClass);
		if (springBootTest != null && isListeningOnPort(springBootTest.webEnvironment())
				&& MergedAnnotations.from(testClass, SearchStrategy.INHERITED_ANNOTATIONS)
					.isPresent(WebAppConfiguration.class)) {
			throw new IllegalStateException('@WebAppConfiguration should only be used '
					+ 'with @SpringBootTest when @SpringBootTest is configured with a '
					+ 'mock web environment. Please remove @WebAppConfiguration or reconfigure @SpringBootTest.');
		}
	}
	private boolean isListeningOnPort(WebEnvironment webEnvironment) {
		return webEnvironment == WebEnvironment.DEFINED_PORT || webEnvironment == WebEnvironment.RANDOM_PORT;
	}
	/**
	 * Create a new {@link MergedContextConfiguration} with different classes.
	 * @param mergedConfig the source config
	 * @param classes the replacement classes
	 * @return a new {@link MergedContextConfiguration}
	 */
	protected final MergedContextConfiguration createModifiedConfig(MergedContextConfiguration mergedConfig,
			Class<?>[] classes) {
		return createModifiedConfig(mergedConfig, classes, mergedConfig.getPropertySourceProperties());
	}
	/**
	 * Create a new {@link MergedContextConfiguration} with different classes and
	 * properties.
	 * @param mergedConfig the source config
	 * @param classes the replacement classes
	 * @param propertySourceProperties the replacement properties
	 * @return a new {@link MergedContextConfiguration}
	 */
	protected final MergedContextConfiguration createModifiedConfig(MergedContextConfiguration mergedConfig,
			Class<?>[] classes, String[] propertySourceProperties) {
		Set<ContextCustomizer> contextCustomizers = new LinkedHashSet<>(mergedConfig.getContextCustomizers());
		contextCustomizers.add(new SpringBootTestAnnotation(mergedConfig.getTestClass()));
		return new MergedContextConfiguration(mergedConfig.getTestClass(), mergedConfig.getLocations(), classes,
				mergedConfig.getContextInitializerClasses(), mergedConfig.getActiveProfiles(),
				mergedConfig.getPropertySourceDescriptors(), propertySourceProperties, contextCustomizers,
				mergedConfig.getContextLoader(), getCacheAwareContextLoaderDelegate(), mergedConfig.getParent());
	}
}
/*
package org.springframework.boot.test.context;
/**
class SpringBootTestAnnotation implements ContextCustomizer {
	private static final String[] NO_ARGS = new String[0];
	private static final SpringBootTestAnnotation DEFAULT = new SpringBootTestAnnotation((SpringBootTest) null);
	private final String[] args;
	private final WebEnvironment webEnvironment;
	private final UseMainMethod useMainMethod;
	SpringBootTestAnnotation(Class<?> testClass) {
		this(TestContextAnnotationUtils.findMergedAnnotation(testClass, SpringBootTest.class));
	}
	private SpringBootTestAnnotation(SpringBootTest annotation) {
		this.args = (annotation != null) ? annotation.args() : NO_ARGS;
		this.webEnvironment = (annotation != null) ? annotation.webEnvironment() : WebEnvironment.NONE;
		this.useMainMethod = (annotation != null) ? annotation.useMainMethod() : UseMainMethod.NEVER;
	}
	@Override
	public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		SpringBootTestAnnotation other = (SpringBootTestAnnotation) obj;
		boolean result = Arrays.equals(this.args, other.args);
		result = result && this.useMainMethod == other.useMainMethod;
		result = result && this.webEnvironment == other.webEnvironment;
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(this.args);
		result = prime * result + Objects.hash(this.useMainMethod, this.webEnvironment);
		return result;
	}
	String[] getArgs() {
		return this.args;
	}
	WebEnvironment getWebEnvironment() {
		return this.webEnvironment;
	}
	UseMainMethod getUseMainMethod() {
		return this.useMainMethod;
	}
	/**
	 * Return the application arguments from the given {@link MergedContextConfiguration}.
	 * @param mergedConfig the merged config to check
	 * @return a {@link SpringBootTestAnnotation} instance
	 */
	static SpringBootTestAnnotation get(MergedContextConfiguration mergedConfig) {
		for (ContextCustomizer customizer : mergedConfig.getContextCustomizers()) {
			if (customizer instanceof SpringBootTestAnnotation annotation) {
				return annotation;
			}
		}
		return DEFAULT;
	}
}
/*
package org.springframework.boot.test.context;
/**
public class ConfigDataApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		ConfigurableEnvironment environment = applicationContext.getEnvironment();
		RandomValuePropertySource.addToEnvironment(environment);
		DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
		ConfigDataEnvironmentPostProcessor.applyTo(environment, applicationContext, bootstrapContext);
		bootstrapContext.close(applicationContext);
		DefaultPropertiesPropertySource.moveToEnd(environment);
	}
}
/*
package org.springframework.boot.test.context;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(SpringBootTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
public @interface SpringBootTest {
	/**
	 * Alias for {@link #properties()}.
	 * @return the properties to apply
	 */
	@AliasFor('properties')
	String[] value() default {};
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	@AliasFor('value')
	String[] properties() default {};
	/**
	 * Application arguments that should be passed to the application under test.
	 * @return the application arguments to pass to the application under test.
	 * @see ApplicationArguments
	 * @see SpringApplication#run(String...)
	 * @since 2.2.0
	 */
	String[] args() default {};
	/**
	 * The <em>component classes</em> to use for loading an
	 * {@link org.springframework.context.ApplicationContext ApplicationContext}. Can also
	 * be specified using
	 * {@link ContextConfiguration#classes() @ContextConfiguration(classes=...)}. If no
	 * explicit classes are defined the test will look for nested
	 * {@link Configuration @Configuration} classes, before falling back to a
	 * {@link SpringBootConfiguration @SpringBootConfiguration} search.
	 * @see ContextConfiguration#classes()
	 * @return the component classes used to load the application context
	 */
	Class<?>[] classes() default {};
	/**
	 * The type of web environment to create when applicable. Defaults to
	 * {@link WebEnvironment#MOCK}.
	 * @return the type of web environment
	 */
	WebEnvironment webEnvironment() default WebEnvironment.MOCK;
	/**
	 * The type of main method usage to employ when creating the {@link SpringApplication}
	 * under test.
	 * @return the type of main method usage
	 * @since 3.0.0
	 */
	UseMainMethod useMainMethod() default UseMainMethod.NEVER;
	/**
	 * An enumeration web environment modes.
	 */
	enum WebEnvironment {
		/**
		 * Creates a {@link WebApplicationContext} with a mock servlet environment if
		 * servlet APIs are on the classpath, a {@link ReactiveWebApplicationContext} if
		 * Spring WebFlux is on the classpath or a regular {@link ApplicationContext}
		 * otherwise.
		 */
		MOCK(false),
		/**
		 * Creates a web application context (reactive or servlet based) and sets a
		 * {@code server.port=0} {@link Environment} property (which usually triggers
		 * listening on a random port). Often used in conjunction with a
		 * {@link LocalServerPort @LocalServerPort} injected field on the test.
		 */
		RANDOM_PORT(true),
		/**
		 * Creates a (reactive) web application context without defining any
		 * {@code server.port=0} {@link Environment} property.
		 */
		DEFINED_PORT(true),
		/**
		 * Creates an {@link ApplicationContext} and sets
		 * {@link SpringApplication#setWebApplicationType(WebApplicationType)} to
		 * {@link WebApplicationType#NONE}.
		 */
		NONE(false);
		private final boolean embedded;
		WebEnvironment(boolean embedded) {
			this.embedded = embedded;
		}
		/**
		 * Return if the environment uses an {@link ServletWebServerApplicationContext}.
		 * @return if an {@link ServletWebServerApplicationContext} is used.
		 */
		public boolean isEmbedded() {
			return this.embedded;
		}
	}
	/**
	 * Enumeration of how the main method of the
	 * {@link SpringBootConfiguration @SpringBootConfiguration}-annotated class is used
	 * when creating and running the {@link SpringApplication} under test.
	 *
	 * @since 3.0.0
	 */
	enum UseMainMethod {
		/**
		 * Always use the {@code main} method. A failure will occur if there is no
		 * {@link SpringBootConfiguration @SpringBootConfiguration}-annotated class or
		 * that class does not have a main method.
		 */
		ALWAYS,
		/**
		 * Never use the {@code main} method, creating a test-specific
		 * {@link SpringApplication} instead.
		 */
		NEVER,
		/**
		 * Use the {@code main} method when it is available. If there is no
		 * {@link SpringBootConfiguration @SpringBootConfiguration}-annotated class or
		 * that class does not have a main method, a test-specific
		 * {@link SpringApplication} will be used.
		 */
		WHEN_AVAILABLE
	}
}
/*
package org.springframework.boot.test.context;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface TestComponent {
	/**
	 * The value may indicate a suggestion for a logical component name, to be turned into
	 * a Spring bean in case of an auto-detected component.
	 * @return the specified bean name, if any
	 */
	@AliasFor(annotation = Component.class)
	String value() default '';
}
/*
package org.springframework.boot.test.context;
/**
class ImportsContextCustomizer implements ContextCustomizer {
	private static final String TEST_CLASS_NAME_ATTRIBUTE = 'testClassName';
	private final String testClassName;
	private final ContextCustomizerKey key;
	ImportsContextCustomizer(Class<?> testClass) {
		this.testClassName = testClass.getName();
		this.key = new ContextCustomizerKey(testClass);
	}
	@Override
	public void customizeContext(ConfigurableApplicationContext context,
			MergedContextConfiguration mergedContextConfiguration) {
		BeanDefinitionRegistry registry = getBeanDefinitionRegistry(context);
		AnnotatedBeanDefinitionReader reader = new AnnotatedBeanDefinitionReader(registry);
		registerCleanupPostProcessor(registry, reader);
		registerImportsConfiguration(registry, reader);
	}
	private void registerCleanupPostProcessor(BeanDefinitionRegistry registry, AnnotatedBeanDefinitionReader reader) {
		BeanDefinition definition = registerBean(registry, reader, ImportsCleanupPostProcessor.BEAN_NAME,
				ImportsCleanupPostProcessor.class);
		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		definition.getConstructorArgumentValues().addIndexedArgumentValue(0, this.testClassName);
	}
	private void registerImportsConfiguration(BeanDefinitionRegistry registry, AnnotatedBeanDefinitionReader reader) {
		BeanDefinition definition = registerBean(registry, reader, ImportsConfiguration.BEAN_NAME,
				ImportsConfiguration.class);
		definition.setAttribute(TEST_CLASS_NAME_ATTRIBUTE, this.testClassName);
	}
	private BeanDefinitionRegistry getBeanDefinitionRegistry(ApplicationContext context) {
		if (context instanceof BeanDefinitionRegistry beanDefinitionRegistry) {
			return beanDefinitionRegistry;
		}
		if (context instanceof AbstractApplicationContext abstractContext) {
			return (BeanDefinitionRegistry) abstractContext.getBeanFactory();
		}
		throw new IllegalStateException('Could not locate BeanDefinitionRegistry');
	}
	private BeanDefinition registerBean(BeanDefinitionRegistry registry, AnnotatedBeanDefinitionReader reader,
			String beanName, Class<?> type) {
		reader.registerBean(type, beanName);
		return registry.getBeanDefinition(beanName);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		// ImportSelectors are flexible so the only safe cache key is the test class
		ImportsContextCustomizer other = (ImportsContextCustomizer) obj;
		return this.key.equals(other.key);
	}
	@Override
	public int hashCode() {
		return this.key.hashCode();
	}
	@Override
	public String toString() {
		return new ToStringCreator(this).append('key', this.key).toString();
	}
	/**
	 * {@link Configuration @Configuration} registered to trigger the
	 * {@link ImportsSelector}.
	 */
	@Configuration(proxyBeanMethods = false)
	@Import(ImportsSelector.class)
	static class ImportsConfiguration {
		static final String BEAN_NAME = ImportsConfiguration.class.getName();
	}
	/**
	 * {@link ImportSelector} that returns the original test class so that direct
	 * {@code @Import} annotations are processed.
	 */
	static class ImportsSelector implements ImportSelector, BeanFactoryAware {
		private static final String[] NO_IMPORTS = {};
		private ConfigurableListableBeanFactory beanFactory;
		@Override
		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
		}
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			BeanDefinition definition = this.beanFactory.getBeanDefinition(ImportsConfiguration.BEAN_NAME);
			Object testClassName = definition.getAttribute(TEST_CLASS_NAME_ATTRIBUTE);
			return (testClassName != null) ? new String[] { (String) testClassName } : NO_IMPORTS;
		}
	}
	/**
	 * {@link BeanDefinitionRegistryPostProcessor} to cleanup temporary configuration
	 * added to load imports.
	 */
	@Order(Ordered.LOWEST_PRECEDENCE)
	static class ImportsCleanupPostProcessor implements BeanDefinitionRegistryPostProcessor {
		static final String BEAN_NAME = ImportsCleanupPostProcessor.class.getName();
		private final String testClassName;
		ImportsCleanupPostProcessor(String testClassName) {
			this.testClassName = testClassName;
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			try {
				String[] names = registry.getBeanDefinitionNames();
				for (String name : names) {
					BeanDefinition definition = registry.getBeanDefinition(name);
					if (this.testClassName.equals(definition.getBeanClassName())) {
						registry.removeBeanDefinition(name);
					}
				}
				registry.removeBeanDefinition(ImportsConfiguration.BEAN_NAME);
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Ignore
			}
		}
	}
	/**
	 * The key used to ensure correct application context caching. Keys are generated
	 * based on <em>all</em> the annotations used with the test that aren"t core Java or
	 * Kotlin annotations. We must use something broader than just {@link Import @Import}
	 * annotations since an {@code @Import} may use an {@link ImportSelector} which could
	 * make decisions based on anything available from {@link AnnotationMetadata}.
	 */
	static class ContextCustomizerKey {
		private static final Set<AnnotationFilter> ANNOTATION_FILTERS;
		static {
			Set<AnnotationFilter> annotationFilters = new LinkedHashSet<>();
			annotationFilters.add(AnnotationFilter.PLAIN);
			annotationFilters.add('kotlin.Metadata'::equals);
			annotationFilters.add(AnnotationFilter.packages('kotlin.annotation'));
			annotationFilters.add(AnnotationFilter.packages('org.spockframework', 'spock'));
			annotationFilters.add(AnnotationFilter.packages('org.junit'));
			ANNOTATION_FILTERS = Collections.unmodifiableSet(annotationFilters);
		}
		private final Set<Object> key;
		ContextCustomizerKey(Class<?> testClass) {
			MergedAnnotations annotations = MergedAnnotations.search(MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
				.withAnnotationFilter(this::isFilteredAnnotation)
				.from(testClass);
			Set<Object> determinedImports = determineImports(annotations, testClass);
			if (determinedImports == null) {
				this.key = Collections.unmodifiableSet(synthesize(annotations));
			}
			else {
				Set<Object> key = new HashSet<>(determinedImports);
				Set<Annotation> componentScanning = annotations.stream()
					.filter((annotation) -> annotation.getType().equals(ComponentScan.class))
					.map(MergedAnnotation::synthesize)
					.collect(Collectors.toSet());
				key.addAll(componentScanning);
				this.key = Collections.unmodifiableSet(key);
			}
		}
		private boolean isFilteredAnnotation(String typeName) {
			return ANNOTATION_FILTERS.stream().anyMatch((filter) -> filter.matches(typeName));
		}
		private Set<Object> determineImports(MergedAnnotations annotations, Class<?> testClass) {
			Set<Object> determinedImports = new LinkedHashSet<>();
			AnnotationMetadata metadata = AnnotationMetadata.introspect(testClass);
			for (MergedAnnotation<Import> annotation : annotations.stream(Import.class).toList()) {
				for (Class<?> source : annotation.getClassArray(MergedAnnotation.VALUE)) {
					Set<Object> determinedSourceImports = determineImports(source, metadata);
					if (determinedSourceImports == null) {
						return null;
					}
					determinedImports.addAll(determinedSourceImports);
				}
			}
			return determinedImports;
		}
		private Set<Object> determineImports(Class<?> source, AnnotationMetadata metadata) {
			if (DeterminableImports.class.isAssignableFrom(source)) {
				// We can determine the imports
				return ((DeterminableImports) instantiate(source)).determineImports(metadata);
			}
			if (ImportSelector.class.isAssignableFrom(source)
					|| ImportBeanDefinitionRegistrar.class.isAssignableFrom(source)) {
				// Standard ImportSelector and ImportBeanDefinitionRegistrar could
				// use anything to determine the imports so we can"t be sure
				return null;
			}
			// The source itself is the import
			return Collections.singleton(source.getName());
		}
		private Set<Object> synthesize(MergedAnnotations annotations) {
			return annotations.stream().map(MergedAnnotation::synthesize).collect(Collectors.toSet());
		}
		@SuppressWarnings('unchecked')
		private <T> T instantiate(Class<T> source) {
			try {
				Constructor<?> constructor = source.getDeclaredConstructor();
				ReflectionUtils.makeAccessible(constructor);
				return (T) constructor.newInstance();
			}
			catch (Throwable ex) {
				throw new IllegalStateException('Unable to instantiate DeterminableImportSelector ' + source.getName(),
						ex);
			}
		}
		@Override
		public boolean equals(Object obj) {
			return (obj != null && getClass() == obj.getClass() && this.key.equals(((ContextCustomizerKey) obj).key));
		}
		@Override
		public int hashCode() {
			return this.key.hashCode();
		}
		@Override
		public String toString() {
			return this.key.toString();
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
public class FilteredClassLoader extends URLClassLoader implements SmartClassLoader {
	private final Collection<Predicate<String>> classesFilters;
	private final Collection<Predicate<String>> resourcesFilters;
	/**
	 * Create a {@link FilteredClassLoader} that hides the given classes.
	 * @param hiddenClasses the classes to hide
	 */
	public FilteredClassLoader(Class<?>... hiddenClasses) {
		this(Collections.singleton(ClassFilter.of(hiddenClasses)), Collections.emptyList());
	}
	/**
	 * Create a {@link FilteredClassLoader} that hides classes from the given packages.
	 * @param hiddenPackages the packages to hide
	 */
	public FilteredClassLoader(String... hiddenPackages) {
		this(Collections.singleton(PackageFilter.of(hiddenPackages)), Collections.emptyList());
	}
	/**
	 * Create a {@link FilteredClassLoader} that hides resources from the given
	 * {@link ClassPathResource classpath resources}.
	 * @param hiddenResources the resources to hide
	 * @since 2.1.0
	 */
	public FilteredClassLoader(ClassPathResource... hiddenResources) {
		this(Collections.emptyList(), Collections.singleton(ClassPathResourceFilter.of(hiddenResources)));
	}
	/**
	 * Create a {@link FilteredClassLoader} that filters based on the given predicate.
	 * @param filters a set of filters to determine when a class name or resource should
	 * be hidden. A {@link Predicate#test(Object) result} of {@code true} indicates a
	 * filtered class or resource. The input of the predicate can either be the binary
	 * name of a class or a resource name.
	 */
	@SafeVarargs
	@SuppressWarnings('varargs')
	public FilteredClassLoader(Predicate<String>... filters) {
		this(Arrays.asList(filters), Arrays.asList(filters));
	}
	private FilteredClassLoader(Collection<Predicate<String>> classesFilters,
			Collection<Predicate<String>> resourcesFilters) {
		super(new URL[0], FilteredClassLoader.class.getClassLoader());
		this.classesFilters = classesFilters;
		this.resourcesFilters = resourcesFilters;
	}
	@Override
	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		for (Predicate<String> filter : this.classesFilters) {
			if (filter.test(name)) {
				throw new ClassNotFoundException();
			}
		}
		return super.loadClass(name, resolve);
	}
	@Override
	public URL getResource(String name) {
		for (Predicate<String> filter : this.resourcesFilters) {
			if (filter.test(name)) {
				return null;
			}
		}
		return super.getResource(name);
	}
	@Override
	public Enumeration<URL> getResources(String name) throws IOException {
		for (Predicate<String> filter : this.resourcesFilters) {
			if (filter.test(name)) {
				return Collections.emptyEnumeration();
			}
		}
		return super.getResources(name);
	}
	@Override
	public InputStream getResourceAsStream(String name) {
		for (Predicate<String> filter : this.resourcesFilters) {
			if (filter.test(name)) {
				return null;
			}
		}
		return super.getResourceAsStream(name);
	}
	@Override
	public Class<?> publicDefineClass(String name, byte[] b, ProtectionDomain protectionDomain) {
		for (Predicate<String> filter : this.classesFilters) {
			if (filter.test(name)) {
				throw new IllegalArgumentException(String.format('Defining class with name %s is not supported', name));
			}
		}
		return defineClass(name, b, 0, b.length, protectionDomain);
	}
	/**
	 * Filter to restrict the classes that can be loaded.
	 */
	public static final class ClassFilter implements Predicate<String> {
		private final Class<?>[] hiddenClasses;
		private ClassFilter(Class<?>[] hiddenClasses) {
			this.hiddenClasses = hiddenClasses;
		}
		@Override
		public boolean test(String className) {
			for (Class<?> hiddenClass : this.hiddenClasses) {
				if (className.equals(hiddenClass.getName())) {
					return true;
				}
			}
			return false;
		}
		public static ClassFilter of(Class<?>... hiddenClasses) {
			return new ClassFilter(hiddenClasses);
		}
	}
	/**
	 * Filter to restrict the packages that can be loaded.
	 */
	public static final class PackageFilter implements Predicate<String> {
		private final String[] hiddenPackages;
		private PackageFilter(String[] hiddenPackages) {
			this.hiddenPackages = hiddenPackages;
		}
		@Override
		public boolean test(String className) {
			for (String hiddenPackage : this.hiddenPackages) {
				if (className.startsWith(hiddenPackage)) {
					return true;
				}
			}
			return false;
		}
		public static PackageFilter of(String... hiddenPackages) {
			return new PackageFilter(hiddenPackages);
		}
	}
	/**
	 * Filter to restrict the resources that can be loaded.
	 *
	 * @since 2.1.0
	 */
	public static final class ClassPathResourceFilter implements Predicate<String> {
		private final ClassPathResource[] hiddenResources;
		private ClassPathResourceFilter(ClassPathResource[] hiddenResources) {
			this.hiddenResources = hiddenResources;
		}
		@Override
		public boolean test(String resourceName) {
			for (ClassPathResource hiddenResource : this.hiddenResources) {
				if (hiddenResource.getFilename() != null && resourceName.equals(hiddenResource.getPath())) {
					return true;
				}
			}
			return false;
		}
		public static ClassPathResourceFilter of(ClassPathResource... hiddenResources) {
			return new ClassPathResourceFilter(hiddenResources);
		}
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
public 