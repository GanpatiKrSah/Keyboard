rField(String name) {
		return (this.jarFileConnection != null) ? this.jarFileConnection.getHeaderField(name) : null;
	}
	@Override
	public Object getContent() throws IOException {
		connect();
		return (this.entryName != null) ? super.getContent() : this.jarFile;
	}
	@Override
	public Permission getPermission() throws IOException {
		return (this.jarFileConnection != null) ? this.jarFileConnection.getPermission() : null;
	}
	@Override
	public InputStream getInputStream() throws IOException {
		if (this.notFound != null) {
			throwFileNotFound();
		}
		URL jarFileURL = getJarFileURL();
		if (this.entryName == null && !UrlJarFileFactory.isNestedUrl(jarFileURL)) {
			throw new IOException('no entry name specified');
		}
		if (!getUseCaches() && Optimizations.isEnabled(false) && this.entryName != null) {
			JarFile cached = jarFiles.getCached(jarFileURL);
			if (cached != null) {
				if (cached.getEntry(this.entryName) != null) {
					return emptyInputStream;
				}
			}
		}
		connect();
		if (this.jarEntry == null) {
			if (this.jarFile instanceof NestedJarFile nestedJarFile) {
				// In order to work with Tomcat"s TLD scanning and WarURLConnection we
				// return the raw zip data rather than failing because there is no entry.
				// See gh-38047 for details.
				return nestedJarFile.getRawZipDataInputStream();
			}
			throwFileNotFound();
		}
		return new ConnectionInputStream();
	}
	@Override
	public boolean getAllowUserInteraction() {
		return (this.jarFileConnection != null) && this.jarFileConnection.getAllowUserInteraction();
	}
	@Override
	public void setAllowUserInteraction(boolean allowUserInteraction) {
		if (this.jarFileConnection != null) {
			this.jarFileConnection.setAllowUserInteraction(allowUserInteraction);
		}
	}
	@Override
	public boolean getUseCaches() {
		return (this.jarFileConnection == null) || this.jarFileConnection.getUseCaches();
	}
	@Override
	public void setUseCaches(boolean useCaches) {
		if (this.jarFileConnection != null) {
			this.jarFileConnection.setUseCaches(useCaches);
		}
	}
	@Override
	public boolean getDefaultUseCaches() {
		return (this.jarFileConnection == null) || this.jarFileConnection.getDefaultUseCaches();
	}
	@Override
	public void setDefaultUseCaches(boolean defaultUseCaches) {
		if (this.jarFileConnection != null) {
			this.jarFileConnection.setDefaultUseCaches(defaultUseCaches);
		}
	}
	@Override
	public void setIfModifiedSince(long ifModifiedSince) {
		if (this.jarFileConnection != null) {
			this.jarFileConnection.setIfModifiedSince(ifModifiedSince);
		}
	}
	@Override
	public String getRequestProperty(String key) {
		return (this.jarFileConnection != null) ? this.jarFileConnection.getRequestProperty(key) : null;
	}
	@Override
	public void setRequestProperty(String key, String value) {
		if (this.jarFileConnection != null) {
			this.jarFileConnection.setRequestProperty(key, value);
		}
	}
	@Override
	public void addRequestProperty(String key, String value) {
		if (this.jarFileConnection != null) {
			this.jarFileConnection.addRequestProperty(key, value);
		}
	}
	@Override
	public Map<String, List<String>> getRequestProperties() {
		return (this.jarFileConnection != null) ? this.jarFileConnection.getRequestProperties()
				: Collections.emptyMap();
	}
	@Override
	public void connect() throws IOException {
		if (this.connected) {
			return;
		}
		if (this.notFound != null) {
			throwFileNotFound();
		}
		boolean useCaches = getUseCaches();
		URL jarFileURL = getJarFileURL();
		if (this.entryName != null && Optimizations.isEnabled()) {
			assertCachedJarFileHasEntry(jarFileURL, this.entryName);
		}
		this.jarFile = jarFiles.getOrCreate(useCaches, jarFileURL);
		this.jarEntry = getJarEntry(jarFileURL);
		boolean addedToCache = jarFiles.cacheIfAbsent(useCaches, jarFileURL, this.jarFile);
		if (addedToCache) {
			this.jarFileConnection = jarFiles.reconnect(this.jarFile, this.jarFileConnection);
		}
		this.connected = true;
	}
	/**
	 * The {@link URLClassLoader} connects often to check if a resource exists, we can
	 * save some object allocations by using the cached copy if we have one.
	 * @param jarFileURL the jar file to check
	 * @param entryName the entry name to check
	 * @throws FileNotFoundException on a missing entry
	 */
	private void assertCachedJarFileHasEntry(URL jarFileURL, String entryName) throws FileNotFoundException {
		JarFile cachedJarFile = jarFiles.getCached(jarFileURL);
		if (cachedJarFile != null && cachedJarFile.getJarEntry(entryName) == null) {
			throw FILE_NOT_FOUND_EXCEPTION;
		}
	}
	private JarEntry getJarEntry(URL jarFileUrl) throws IOException {
		if (this.entryName == null) {
			return null;
		}
		JarEntry jarEntry = this.jarFile.getJarEntry(this.entryName);
		if (jarEntry == null) {
			jarFiles.closeIfNotCached(jarFileUrl, this.jarFile);
			throwFileNotFound();
		}
		return jarEntry;
	}
	private void throwFileNotFound() throws FileNotFoundException {
		if (Optimizations.isEnabled()) {
			throw FILE_NOT_FOUND_EXCEPTION;
		}
		if (this.notFound != null) {
			throw this.notFound.get();
		}
		throw new FileNotFoundException('JAR entry ' + this.entryName + ' not found in ' + this.jarFile.getName());
	}
	static JarUrlConnection open(URL url) throws IOException {
		String spec = url.getFile();
		if (spec.startsWith('nested:')) {
			int separator = spec.indexOf('!/');
			boolean specHasEntry = (separator != -1) && (separator + 2 != spec.length());
			if (specHasEntry) {
				URL jarFileUrl = new URL(spec.substring(0, separator));
				if ('runtime'.equals(url.getRef())) {
					jarFileUrl = new URL(jarFileUrl, '#runtime');
				}
				String entryName = UrlDecoder.decode(spec.substring(separator + 2));
				JarFile jarFile = jarFiles.getOrCreate(true, jarFileUrl);
				jarFiles.cacheIfAbsent(true, jarFileUrl, jarFile);
				if (!hasEntry(jarFile, entryName)) {
					return notFoundConnection(jarFile.getName(), entryName);
				}
			}
		}
		return new JarUrlConnection(url);
	}
	private static boolean hasEntry(JarFile jarFile, String name) {
		return (jarFile instanceof NestedJarFile nestedJarFile) ? nestedJarFile.hasEntry(name)
				: jarFile.getEntry(name) != null;
	}
	private static JarUrlConnection notFoundConnection(String jarFileName, String entryName) throws IOException {
		if (Optimizations.isEnabled()) {
			return NOT_FOUND_CONNECTION;
		}
		return new JarUrlConnection(
				() -> new FileNotFoundException('JAR entry ' + entryName + ' not found in ' + jarFileName));
	}
	static void clearCache() {
		jarFiles.clearCache();
	}
	/**
	 * Connection {@link InputStream}. This is not a {@link FilterInputStream} since
	 * {@link URLClassLoader} often creates streams that it doesn"t call and we want to be
	 * lazy about getting the underlying {@link InputStream}.
	 */
	class ConnectionInputStream extends LazyDelegatingInputStream {
		@Override
		public void close() throws IOException {
			try {
				super.close();
			}
			finally {
				if (!getUseCaches()) {
					JarUrlConnection.this.jarFile.close();
				}
			}
		}
		@Override
		protected InputStream getDelegateInputStream() throws IOException {
			return JarUrlConnection.this.jarFile.getInputStream(JarUrlConnection.this.jarEntry);
		}
	}
	/**
	 * Empty {@link URLStreamHandler} used to prevent the wrong JAR Handler from being
	 * Instantiated and cached.
	 */
	private static final class EmptyUrlStreamHandler extends URLStreamHandler {
		@Override
		protected URLConnection openConnection(URL url) {
			return null;
		}
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
final class JarFileUrlKey {
	private static volatile SoftReference<Map<URL, String>> cache;
	private JarFileUrlKey() {
	}
	/**
	 * Get the {@link JarFileUrlKey} for the given URL.
	 * @param url the source URL
	 * @return a {@link JarFileUrlKey} instance
	 */
	static String get(URL url) {
		Map<URL, String> cache = (JarFileUrlKey.cache != null) ? JarFileUrlKey.cache.get() : null;
		if (cache == null) {
			cache = new ConcurrentHashMap<>();
			JarFileUrlKey.cache = new SoftReference<>(cache);
		}
		return cache.computeIfAbsent(url, JarFileUrlKey::create);
	}
	private static String create(URL url) {
		StringBuilder value = new StringBuilder();
		String protocol = url.getProtocol();
		String host = url.getHost();
		int port = (url.getPort() != -1) ? url.getPort() : url.getDefaultPort();
		String file = url.getFile();
		value.append(protocol.toLowerCase(Locale.ROOT));
		value.append(':');
		if (host != null && !host.isEmpty()) {
			value.append(host.toLowerCase(Locale.ROOT));
			value.append((port != -1) ? ':' + port : '');
		}
		value.append((file != null) ? file : '');
		if ('runtime'.equals(url.getRef())) {
			value.append('#runtime');
		}
		return value.toString();
	}
	static void clearCache() {
		cache = null;
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
final class Optimizations {
	private static final ThreadLocal<Boolean> status = new ThreadLocal<>();
	private Optimizations() {
	}
	static void enable(boolean readContents) {
		status.set(readContents);
	}
	static void disable() {
		status.remove();
	}
	static boolean isEnabled() {
		return status.get() != null;
	}
	static boolean isEnabled(boolean readContents) {
		return Boolean.valueOf(readContents).equals(status.get());
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlJarManifest {
	private static final Object NONE = new Object();
	private final ManifestSupplier supplier;
	private volatile Object supplied;
	UrlJarManifest(ManifestSupplier supplier) {
		this.supplier = supplier;
	}
	Manifest get() throws IOException {
		Manifest manifest = supply();
		if (manifest == null) {
			return null;
		}
		Manifest copy = new Manifest();
		copy.getMainAttributes().putAll((Map<?, ?>) manifest.getMainAttributes().clone());
		manifest.getEntries().forEach((key, value) -> copy.getEntries().put(key, cloneAttributes(value)));
		return copy;
	}
	Attributes getEntryAttributes(JarEntry entry) throws IOException {
		Manifest manifest = supply();
		if (manifest == null) {
			return null;
		}
		Attributes attributes = manifest.getEntries().get(entry.getName());
		return cloneAttributes(attributes);
	}
	private Attributes cloneAttributes(Attributes attributes) {
		return (attributes != null) ? (Attributes) attributes.clone() : null;
	}
	private Manifest supply() throws IOException {
		Object supplied = this.supplied;
		if (supplied == null) {
			supplied = this.supplier.getManifest();
			this.supplied = (supplied != null) ? supplied : NONE;
		}
		return (supplied != NONE) ? (Manifest) supplied : null;
	}
	/**
	 * Interface used to supply the actual manifest.
	 */
	@FunctionalInterface
	interface ManifestSupplier {
		Manifest getManifest() throws IOException;
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
abstract class LazyDelegatingInputStream extends InputStream {
	private volatile InputStream in;
	@Override
	public int read() throws IOException {
		return in().read();
	}
	@Override
	public int read(byte[] b) throws IOException {
		return in().read(b);
	}
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		return in().read(b, off, len);
	}
	@Override
	public long skip(long n) throws IOException {
		return in().skip(n);
	}
	@Override
	public int available() throws IOException {
		return in().available();
	}
	@Override
	public boolean markSupported() {
		try {
			return in().markSupported();
		}
		catch (IOException ex) {
			return false;
		}
	}
	@Override
	public synchronized void mark(int readLimit) {
		try {
			in().mark(readLimit);
		}
		catch (IOException ex) {
			// Ignore
		}
	}
	@Override
	public synchronized void reset() throws IOException {
		in().reset();
	}
	private InputStream in() throws IOException {
		InputStream in = this.in;
		if (in == null) {
			synchronized (this) {
				in = this.in;
				if (in == null) {
					in = getDelegateInputStream();
					this.in = in;
				}
			}
		}
		return in;
	}
	@Override
	public void close() throws IOException {
		InputStream in = this.in;
		if (in != null) {
			synchronized (this) {
				in = this.in;
				if (in != null) {
					in.close();
				}
			}
		}
	}
	protected abstract InputStream getDelegateInputStream() throws IOException;
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
final class UrlJarEntry extends JarEntry {
	private final UrlJarManifest manifest;
	private UrlJarEntry(JarEntry entry, UrlJarManifest manifest) {
		super(entry);
		this.manifest = manifest;
	}
	@Override
	public Attributes getAttributes() throws IOException {
		return this.manifest.getEntryAttributes(this);
	}
	static UrlJarEntry of(ZipEntry entry, UrlJarManifest manifest) {
		return (entry != null) ? new UrlJarEntry((JarEntry) entry, manifest) : null;
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlJarFileFactory {
	/**
	 * Create a new {@link UrlJarFile} or {@link UrlNestedJarFile} instance.
	 * @param jarFileUrl the jar file URL
	 * @param closeAction the action to call when the file is closed
	 * @return a new {@link JarFile} instance
	 * @throws IOException on I/O error
	 */
	JarFile createJarFile(URL jarFileUrl, Consumer<JarFile> closeAction) throws IOException {
		Runtime.Version version = getVersion(jarFileUrl);
		if (isLocalFileUrl(jarFileUrl)) {
			return createJarFileForLocalFile(jarFileUrl, version, closeAction);
		}
		if (isNestedUrl(jarFileUrl)) {
			return createJarFileForNested(jarFileUrl, version, closeAction);
		}
		return createJarFileForStream(jarFileUrl, version, closeAction);
	}
	private Runtime.Version getVersion(URL url) {
		// The standard JDK handler uses #runtime to indicate that the runtime version
		// should be used. This unfortunately doesn"t work for us as
		// jdk.internal.loader.URLClassPath only adds the runtime fragment when the URL
		// is using the internal JDK handler. We need to flip the default to use
		// the runtime version. See gh-38050
		return 'base'.equals(url.getRef()) ? JarFile.baseVersion() : JarFile.runtimeVersion();
	}
	private boolean isLocalFileUrl(URL url) {
		return url.getProtocol().equalsIgnoreCase('file') && isLocal(url.getHost());
	}
	private boolean isLocal(String host) {
		return host == null || host.isEmpty() || host.equals('~') || host.equalsIgnoreCase('localhost');
	}
	private JarFile createJarFileForLocalFile(URL url, Runtime.Version version, Consumer<JarFile> closeAction)
			throws IOException {
		String path = UrlDecoder.decode(url.getPath());
		return new UrlJarFile(new File(path), version, closeAction);
	}
	private JarFile createJarFileForNested(URL url, Runtime.Version version, Consumer<JarFile> closeAction)
			throws IOException {
		NestedLocation location = NestedLocation.fromUrl(url);
		return new UrlNestedJarFile(location.path().toFile(), location.nestedEntryName(), version, closeAction);
	}
	private JarFile createJarFileForStream(URL url, Version version, Consumer<JarFile> closeAction) throws IOException {
		try (InputStream in = url.openStream()) {
			return createJarFileForStream(in, version, closeAction);
		}
	}
	private JarFile createJarFileForStream(InputStream in, Version version, Consumer<JarFile> closeAction)
			throws IOException {
		Path local = Files.createTempFile('jar_cache', null);
		try {
			Files.copy(in, local, StandardCopyOption.REPLACE_EXISTING);
			JarFile jarFile = new UrlJarFile(local.toFile(), version, closeAction);
			local.toFile().deleteOnExit();
			return jarFile;
		}
		catch (Throwable ex) {
			deleteIfPossible(local, ex);
			throw ex;
		}
	}
	private void deleteIfPossible(Path local, Throwable cause) {
		try {
			Files.delete(local);
		}
		catch (IOException ex) {
			cause.addSuppressed(ex);
		}
	}
	static boolean isNestedUrl(URL url) {
		return url.getProtocol().equalsIgnoreCase('nested');
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
public final class JarUrl {
	private JarUrl() {
	}
	/**
	 * Create a new jar URL.
	 * @param file the jar file
	 * @return a jar file URL
	 */
	public static URL create(File file) {
		return create(file, (String) null);
	}
	/**
	 * Create a new jar URL.
	 * @param file the jar file
	 * @param nestedEntry the nested entry or {@code null}
	 * @return a jar file URL
	 */
	public static URL create(File file, JarEntry nestedEntry) {
		return create(file, (nestedEntry != null) ? nestedEntry.getName() : null);
	}
	/**
	 * Create a new jar URL.
	 * @param file the jar file
	 * @param nestedEntryName the nested entry name or {@code null}
	 * @return a jar file URL
	 */
	public static URL create(File file, String nestedEntryName) {
		return create(file, nestedEntryName, null);
	}
	/**
	 * Create a new jar URL.
	 * @param file the jar file
	 * @param nestedEntryName the nested entry name or {@code null}
	 * @param path the path within the jar or nested jar
	 * @return a jar file URL
	 */
	public static URL create(File file, String nestedEntryName, String path) {
		try {
			path = (path != null) ? path : '';
			return new URL(null, 'jar:' + getJarReference(file, nestedEntryName) + '!/' + path, Handler.INSTANCE);
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException('Unable to create JarFileArchive URL', ex);
		}
	}
	private static String getJarReference(File file, String nestedEntryName) {
		String jarFilePath = file.toURI().getRawPath().replace('!', '%21');
		return (nestedEntryName != null) ? 'nested:' + jarFilePath + '/!' + nestedEntryName : 'file:' + jarFilePath;
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
public abstract class JarUrlClassLoader extends URLClassLoader {
	static {
		ClassLoader.registerAsParallelCapable();
	}
	private final URL[] urls;
	private final boolean hasJarUrls;
	private final Map<URL, JarFile> jarFiles = new ConcurrentHashMap<>();
	private final Set<String> undefinablePackages = ConcurrentHashMap.newKeySet();
	/**
	 * Create a new {@link LaunchedClassLoader} instance.
	 * @param urls the URLs from which to load classes and resources
	 * @param parent the parent class loader for delegation
	 */
	public JarUrlClassLoader(URL[] urls, ClassLoader parent) {
		super(urls, parent);
		this.urls = urls;
		this.hasJarUrls = Arrays.stream(urls).anyMatch(this::isJarUrl);
	}
	@Override
	public URL findResource(String name) {
		if (!this.hasJarUrls) {
			return super.findResource(name);
		}
		Optimizations.enable(false);
		try {
			return super.findResource(name);
		}
		finally {
			Optimizations.disable();
		}
	}
	@Override
	public Enumeration<URL> findResources(String name) throws IOException {
		if (!this.hasJarUrls) {
			return super.findResources(name);
		}
		Optimizations.enable(false);
		try {
			return new OptimizedEnumeration(super.findResources(name));
		}
		finally {
			Optimizations.disable();
		}
	}
	@Override
	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		if (!this.hasJarUrls) {
			return super.loadClass(name, resolve);
		}
		Optimizations.enable(true);
		try {
			try {
				definePackageIfNecessary(name);
			}
			catch (IllegalArgumentException ex) {
				tolerateRaceConditionDueToBeingParallelCapable(ex, name);
			}
			return super.loadClass(name, resolve);
		}
		finally {
			Optimizations.disable();
		}
	}
	/**
	 * Define a package before a {@code findClass} call is made. This is necessary to
	 * ensure that the appropriate manifest for nested JARs is associated with the
	 * package.
	 * @param className the class name being found
	 */
	protected final void definePackageIfNecessary(String className) {
		if (className.startsWith('java.')) {
			return;
		}
		int lastDot = className.lastIndexOf(".");
		if (lastDot >= 0) {
			String packageName = className.substring(0, lastDot);
			if (getDefinedPackage(packageName) == null) {
				try {
					definePackage(className, packageName);
				}
				catch (IllegalArgumentException ex) {
					tolerateRaceConditionDueToBeingParallelCapable(ex, packageName);
				}
			}
		}
	}
	private void definePackage(String className, String packageName) {
		if (this.undefinablePackages.contains(packageName)) {
			return;
		}
		String packageEntryName = packageName.replace(".", "/") + '/';
		String classEntryName = className.replace(".", "/") + '.class';
		for (URL url : this.urls) {
			try {
				JarFile jarFile = getJarFile(url);
				if (jarFile != null) {
					if (hasEntry(jarFile, classEntryName) && hasEntry(jarFile, packageEntryName)
							&& jarFile.getManifest() != null) {
						definePackage(packageName, jarFile.getManifest(), url);
						return;
					}
				}
			}
			catch (IOException ex) {
				// Ignore
			}
		}
		this.undefinablePackages.add(packageName);
	}
	private void tolerateRaceConditionDueToBeingParallelCapable(IllegalArgumentException ex, String packageName)
			throws AssertionError {
		if (getDefinedPackage(packageName) == null) {
			// This should never happen as the IllegalArgumentException indicates that the
			// package has already been defined and, therefore, getDefinedPackage(name)
			// should not have returned null.
			throw new AssertionError(
					'Package %s has already been defined but it could not be found'.formatted(packageName), ex);
		}
	}
	private boolean hasEntry(JarFile jarFile, String name) {
		return (jarFile instanceof NestedJarFile nestedJarFile) ? nestedJarFile.hasEntry(name)
				: jarFile.getEntry(name) != null;
	}
	private JarFile getJarFile(URL url) throws IOException {
		JarFile jarFile = this.jarFiles.get(url);
		if (jarFile != null) {
			return jarFile;
		}
		URLConnection connection = url.openConnection();
		if (!(connection instanceof JarURLConnection)) {
			return null;
		}
		connection.setUseCaches(false);
		jarFile = ((JarURLConnection) connection).getJarFile();
		synchronized (this.jarFiles) {
			JarFile previous = this.jarFiles.putIfAbsent(url, jarFile);
			if (previous != null) {
				jarFile.close();
				jarFile = previous;
			}
		}
		return jarFile;
	}
	/**
	 * Clear any caches. This method is called reflectively by
	 * {@code ClearCachesApplicationListener}.
	 */
	public void clearCache() {
		Handler.clearCache();
		org.springframework.boot.loader.net.protocol.nested.Handler.clearCache();
		try {
			clearJarFiles();
		}
		catch (IOException ex) {
			// Ignore
		}
		for (URL url : this.urls) {
			if (isJarUrl(url)) {
				clearCache(url);
			}
		}
	}
	private void clearCache(URL url) {
		try {
			URLConnection connection = url.openConnection();
			if (connection instanceof JarURLConnection jarUrlConnection) {
				clearCache(jarUrlConnection);
			}
		}
		catch (IOException ex) {
			// Ignore
		}
	}
	private void clearCache(JarURLConnection connection) throws IOException {
		JarFile jarFile = connection.getJarFile();
		if (jarFile instanceof NestedJarFile nestedJarFile) {
			nestedJarFile.clearCache();
		}
	}
	private boolean isJarUrl(URL url) {
		return 'jar'.equals(url.getProtocol());
	}
	@Override
	public void close() throws IOException {
		super.close();
		clearJarFiles();
	}
	private void clearJarFiles() throws IOException {
		synchronized (this.jarFiles) {
			for (JarFile jarFile : this.jarFiles.values()) {
				jarFile.close();
			}
			this.jarFiles.clear();
		}
	}
	/**
	 * {@link Enumeration} that uses fast connections.
	 */
	private static class OptimizedEnumeration implements Enumeration<URL> {
		private final Enumeration<URL> delegate;
		OptimizedEnumeration(Enumeration<URL> delegate) {
			this.delegate = delegate;
		}
		@Override
		public boolean hasMoreElements() {
			Optimizations.enable(false);
			try {
				return this.delegate.hasMoreElements();
			}
			finally {
				Optimizations.disable();
			}
		}
		@Override
		public URL nextElement() {
			Optimizations.enable(false);
			try {
				return this.delegate.nextElement();
			}
			finally {
				Optimizations.disable();
			}
		}
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlNestedJarFile extends NestedJarFile {
	private final UrlJarManifest manifest;
	private final Consumer<JarFile> closeAction;
	UrlNestedJarFile(File file, String nestedEntryName, Version version, Consumer<JarFile> closeAction)
			throws IOException {
		super(file, nestedEntryName, version);
		this.manifest = new UrlJarManifest(super::getManifest);
		this.closeAction = closeAction;
	}
	@Override
	public Manifest getManifest() throws IOException {
		return this.manifest.get();
	}
	@Override
	public JarEntry getEntry(String name) {
		return UrlJarEntry.of(super.getEntry(name), this.manifest);
	}
	@Override
	public void close() throws IOException {
		if (this.closeAction != null) {
			this.closeAction.accept(this);
		}
		super.close();
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlJarFile extends JarFile {
	private final UrlJarManifest manifest;
	private final Consumer<JarFile> closeAction;
	UrlJarFile(File file, Runtime.Version version, Consumer<JarFile> closeAction) throws IOException {
		super(file, true, ZipFile.OPEN_READ, version);
		// Registered only for test cleanup since parent class is JarFile
		Cleaner.instance.register(this, null);
		this.manifest = new UrlJarManifest(super::getManifest);
		this.closeAction = closeAction;
	}
	@Override
	public ZipEntry getEntry(String name) {
		return UrlJarEntry.of(super.getEntry(name), this.manifest);
	}
	@Override
	public Manifest getManifest() throws IOException {
		return this.manifest.get();
	}
	@Override
	public void close() throws IOException {
		if (this.closeAction != null) {
			this.closeAction.accept(this);
		}
		super.close();
	}
}
/*
/**
package org.springframework.boot.loader.net.protocol.jar;
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
final class Canonicalizer {
	private Canonicalizer() {
	}
	static String canonicalizeAfter(String path, int pos) {
		int pathLength = path.length();
		boolean noDotSlash = path.indexOf('./', pos) == -1;
		if (pos >= pathLength || (noDotSlash && path.charAt(pathLength - 1) != ".")) {
			return path;
		}
		String before = path.substring(0, pos);
		String after = path.substring(pos);
		return before + canonicalize(after);
	}
	static String canonicalize(String path) {
		path = removeEmbeddedSlashDotDotSlash(path);
		path = removeEmbeddedSlashDotSlash(path);
		path = removeTrailingSlashDotDot(path);
		path = removeTrailingSlashDot(path);
		return path;
	}
	private static String removeEmbeddedSlashDotDotSlash(String path) {
		int index;
		while ((index = path.indexOf('/../')) >= 0) {
			int priorSlash = path.lastIndexOf("/", index - 1);
			String after = path.substring(index + 3);
			path = (priorSlash >= 0) ? path.substring(0, priorSlash) + after : after;
		}
		return path;
	}
	private static String removeEmbeddedSlashDotSlash(String path) {
		int index;
		while ((index = path.indexOf('/./')) >= 0) {
			String before = path.substring(0, index);
			String after = path.substring(index + 2);
			path = before + after;
		}
		return path;
	}
	private static String removeTrailingSlashDot(String path) {
		return (!path.endsWith('/.')) ? path : path.substring(0, path.length() - 1);
	}
	private static String removeTrailingSlashDotDot(String path) {
		int index;
		while (path.endsWith('/..')) {
			index = path.indexOf('/..');
			int priorSlash = path.lastIndexOf("/", index - 1);
			path = (priorSlash >= 0) ? path.substring(0, priorSlash + 1) : path.substring(0, index);
		}
		return path;
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
public class Handler extends URLStreamHandler {
	// NOTE: in order to be found as a URL protocol handler, this class must be public,
	// must be named Handler and must be in a package ending ".jar"
	private static final String PROTOCOL = 'jar';
	private static final String SEPARATOR = '!/';
	static final Handler INSTANCE = new Handler();
	@Override
	protected URLConnection openConnection(URL url) throws IOException {
		return JarUrlConnection.open(url);
	}
	@Override
	protected void parseURL(URL url, String spec, int start, int limit) {
		if (spec.regionMatches(true, start, 'jar:', 0, 4)) {
			throw new IllegalStateException('Nested JAR URLs are not supported');
		}
		int anchorIndex = spec.indexOf("#", limit);
		String path = extractPath(url, spec, start, limit, anchorIndex);
		String ref = (anchorIndex != -1) ? spec.substring(anchorIndex + 1) : null;
		setURL(url, PROTOCOL, '', -1, null, null, path, null, ref);
	}
	private String extractPath(URL url, String spec, int start, int limit, int anchorIndex) {
		if (anchorIndex == start) {
			return extractAnchorOnlyPath(url);
		}
		if (spec.length() >= 4 && spec.regionMatches(true, 0, 'jar:', 0, 4)) {
			return extractAbsolutePath(spec, start, limit);
		}
		return extractRelativePath(url, spec, start, limit);
	}
	private String extractAnchorOnlyPath(URL url) {
		return url.getPath();
	}
	private String extractAbsolutePath(String spec, int start, int limit) {
		int indexOfSeparator = indexOfSeparator(spec, start, limit);
		if (indexOfSeparator == -1) {
			throw new IllegalStateException('no !/ in spec');
		}
		String innerUrl = spec.substring(start, indexOfSeparator);
		assertInnerUrlIsNotMalformed(spec, innerUrl);
		return spec.substring(start, limit);
	}
	private String extractRelativePath(URL url, String spec, int start, int limit) {
		String contextPath = extractContextPath(url, spec, start);
		String path = contextPath + spec.substring(start, limit);
		return Canonicalizer.canonicalizeAfter(path, indexOfSeparator(path) + 1);
	}
	private String extractContextPath(URL url, String spec, int start) {
		String contextPath = url.getPath();
		if (spec.regionMatches(false, start, '/', 0, 1)) {
			int indexOfContextPathSeparator = indexOfSeparator(contextPath);
			if (indexOfContextPathSeparator == -1) {
				throw new IllegalStateException('malformed context url:%s: no !/'.formatted(url));
			}
			return contextPath.substring(0, indexOfContextPathSeparator + 1);
		}
		int lastSlash = contextPath.lastIndexOf("/");
		if (lastSlash == -1) {
			throw new IllegalStateException('malformed context url:%s'.formatted(url));
		}
		return contextPath.substring(0, lastSlash + 1);
	}
	private void assertInnerUrlIsNotMalformed(String spec, String innerUrl) {
		if (innerUrl.startsWith('nested:')) {
			org.springframework.boot.loader.net.protocol.nested.Handler.assertUrlIsNotMalformed(innerUrl);
			return;
		}
		try {
			new URL(innerUrl);
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException('invalid url: %s (%s)'.formatted(spec, ex));
		}
	}
	@Override
	protected int hashCode(URL url) {
		String protocol = url.getProtocol();
		int hash = (protocol != null) ? protocol.hashCode() : 0;
		String file = url.getFile();
		int indexOfSeparator = file.indexOf(SEPARATOR);
		if (indexOfSeparator == -1) {
			return hash + file.hashCode();
		}
		String fileWithoutEntry = file.substring(0, indexOfSeparator);
		try {
			hash += new URL(fileWithoutEntry).hashCode();
		}
		catch (MalformedURLException ex) {
			hash += fileWithoutEntry.hashCode();
		}
		String entry = file.substring(indexOfSeparator + 2);
		return hash + entry.hashCode();
	}
	@Override
	protected boolean sameFile(URL url1, URL url2) {
		if (!url1.getProtocol().equals(PROTOCOL) || !url2.getProtocol().equals(PROTOCOL)) {
			return false;
		}
		String file1 = url1.getFile();
		String file2 = url2.getFile();
		int indexOfSeparator1 = file1.indexOf(SEPARATOR);
		int indexOfSeparator2 = file2.indexOf(SEPARATOR);
		if (indexOfSeparator1 == -1 || indexOfSeparator2 == -1) {
			return super.sameFile(url1, url2);
		}
		String entry1 = file1.substring(indexOfSeparator1 + 2);
		String entry2 = file2.substring(indexOfSeparator2 + 2);
		if (!entry1.equals(entry2)) {
			return false;
		}
		try {
			URL innerUrl1 = new URL(file1.substring(0, indexOfSeparator1));
			URL innerUrl2 = new URL(file2.substring(0, indexOfSeparator2));
			if (!super.sameFile(innerUrl1, innerUrl2)) {
				return false;
			}
		}
		catch (MalformedURLException unused) {
			return super.sameFile(url1, url2);
		}
		return true;
	}
	static int indexOfSeparator(String spec) {
		return indexOfSeparator(spec, 0, spec.length());
	}
	static int indexOfSeparator(String spec, int start, int limit) {
		for (int i = limit - 1; i >= start; i--) {
			if (spec.charAt(i) == "!" && (i + 1) < limit && spec.charAt(i + 1) == "/") {
				return i;
			}
		}
		return -1;
	}
	/**
	 * Clear any internal caches.
	 */
	public static void clearCache() {
		JarFileUrlKey.clearCache();
		JarUrlConnection.clearCache();
	}
}
/*
package org.springframework.boot.loader.net.protocol.nested;
/**
class NestedUrlConnectionResources implements Runnable {
	private final NestedLocation location;
	private volatile ZipContent zipContent;
	private volatile long size = -1;
	private volatile InputStream inputStream;
	NestedUrlConnectionResources(NestedLocation location) {
		this.location = location;
	}
	NestedLocation getLocation() {
		return this.location;
	}
	void connect() throws IOException {
		synchronized (this) {
			if (this.zipContent == null) {
				this.zipContent = ZipContent.open(this.location.path(), this.location.nestedEntryName());
				try {
					connectData();
				}
				catch (IOException | RuntimeException ex) {
					this.zipContent.close();
					this.zipContent = null;
					throw ex;
				}
			}
		}
	}
	private void connectData() throws IOException {
		CloseableDataBlock data = this.zipContent.openRawZipData();
		try {
			this.size = data.size();
			this.inputStream = data.asInputStream();
		}
		catch (IOException | RuntimeException ex) {
			data.close();
		}
	}
	InputStream getInputStream() throws IOException {
		synchronized (this) {
			if (this.inputStream == null) {
				throw new IOException('Nested location not found ' + this.location);
			}
			return this.inputStream;
		}
	}
	long getContentLength() {
		return this.size;
	}
	@Override
	public void run() {
		releaseAll();
	}
	private void releaseAll() {
		synchronized (this) {
			if (this.zipContent != null) {
				IOException exceptionChain = null;
				try {
					this.inputStream.close();
				}
				catch (IOException ex) {
					exceptionChain = addToExceptionChain(exceptionChain, ex);
				}
				try {
					this.zipContent.close();
				}
				catch (IOException ex) {
					exceptionChain = addToExceptionChain(exceptionChain, ex);
				}
				this.size = -1;
				if (exceptionChain != null) {
					throw new UncheckedIOException(exceptionChain);
				}
			}
		}
	}
	private IOException addToExceptionChain(IOException exceptionChain, IOException ex) {
		if (exceptionChain != null) {
			exceptionChain.addSuppressed(ex);
			return exceptionChain;
		}
		return ex;
	}
}
/*
package org.springframework.boot.loader.net.protocol.nested;
/**
class NestedUrlConnection extends URLConnection {
	private static final DateTimeFormatter RFC_1123_DATE_TIME = DateTimeFormatter.RFC_1123_DATE_TIME
		.withZone(ZoneId.of('GMT'));
	private static final String CONTENT_TYPE = 'x-java/jar';
	private final NestedUrlConnectionResources resources;
	private final Cleanable cleanup;
	private long lastModified = -1;
	private FilePermission permission;
	private Map<String, List<String>> headerFields;
	NestedUrlConnection(URL url) throws MalformedURLException {
		this(url, Cleaner.instance);
	}
	NestedUrlConnection(URL url, Cleaner cleaner) throws MalformedURLException {
		super(url);
		NestedLocation location = parseNestedLocation(url);
		this.resources = new NestedUrlConnectionResources(location);
		this.cleanup = cleaner.register(this, this.resources);
	}
	private NestedLocation parseNestedLocation(URL url) throws MalformedURLException {
		try {
			return NestedLocation.fromUrl(url);
		}
		catch (IllegalArgumentException ex) {
			throw new MalformedURLException(ex.getMessage());
		}
	}
	@Override
	public String getHeaderField(String name) {
		List<String> values = getHeaderFields().get(name);
		return (values != null && !values.isEmpty()) ? values.get(0) : null;
	}
	@Override
	public String getHeaderField(int n) {
		Entry<String, List<String>> entry = getHeaderEntry(n);
		List<String> values = (entry != null) ? entry.getValue() : null;
		return (values != null && !values.isEmpty()) ? values.get(0) : null;
	}
	@Override
	public String getHeaderFieldKey(int n) {
		Entry<String, List<String>> entry = getHeaderEntry(n);
		return (entry != null) ? entry.getKey() : null;
	}
	private Entry<String, List<String>> getHeaderEntry(int n) {
		Iterator<Entry<String, List<String>>> iterator = getHeaderFields().entrySet().iterator();
		Entry<String, List<String>> entry = null;
		for (int i = 0; i < n; i++) {
			entry = (!iterator.hasNext()) ? null : iterator.next();
		}
		return entry;
	}
	@Override
	public Map<String, List<String>> getHeaderFields() {
		try {
			connect();
		}
		catch (IOException ex) {
			return Collections.emptyMap();
		}
		Map<String, List<String>> headerFields = this.headerFields;
		if (headerFields == null) {
			headerFields = new LinkedHashMap<>();
			long contentLength = getContentLengthLong();
			long lastModified = getLastModified();
			if (contentLength > 0) {
				headerFields.put('content-length', List.of(String.valueOf(contentLength)));
			}
			if (getLastModified() > 0) {
				headerFields.put('last-modified',
						List.of(RFC_1123_DATE_TIME.format(Instant.ofEpochMilli(lastModified))));
			}
			headerFields = Collections.unmodifiableMap(headerFields);
			this.headerFields = headerFields;
		}
		return headerFields;
	}
	@Override
	public int getContentLength() {
		long contentLength = getContentLengthLong();
		return (contentLength <= Integer.MAX_VALUE) ? (int) contentLength : -1;
	}
	@Override
	public long getContentLengthLong() {
		try {
			connect();
			return this.resources.getContentLength();
		}
		catch (IOException ex) {
			return -1;
		}
	}
	@Override
	public String getContentType() {
		return CONTENT_TYPE;
	}
	@Override
	public long getLastModified() {
		if (this.lastModified == -1) {
			try {
				this.lastModified = Files.getLastModifiedTime(this.resources.getLocation().path()).toMillis();
			}
			catch (IOException ex) {
				this.lastModified = 0;
			}
		}
		return this.lastModified;
	}
	@Override
	public Permission getPermission() throws IOException {
		if (this.permission == null) {
			File file = this.resources.getLocation().path().toFile();
			this.permission = new FilePermission(file.getCanonicalPath(), 'read');
		}
		return this.permission;
	}
	@Override
	public InputStream getInputStream() throws IOException {
		connect();
		return new ConnectionInputStream(this.resources.getInputStream());
	}
	@Override
	public void connect() throws IOException {
		if (this.connected) {
			return;
		}
		this.resources.connect();
		this.connected = true;
	}
	/**
	 * Connection {@link InputStream}.
	 */
	class ConnectionInputStream extends FilterInputStream {
		private volatile boolean closing;
		ConnectionInputStream(InputStream in) {
			super(in);
		}
		@Override
		public void close() throws IOException {
			if (this.closing) {
				return;
			}
			this.closing = true;
			try {
				super.close();
			}
			finally {
				try {
					NestedUrlConnection.this.cleanup.clean();
				}
				catch (UncheckedIOException ex) {
					throw ex.getCause();
				}
			}
		}
	}
}
/*
package org.springframework.boot.loader.net.protocol.nested;
/**
public record NestedLocation(Path path, String nestedEntryName) {
	private static final Map<String, NestedLocation> locationCache = new ConcurrentHashMap<>();
	private static final Map<String, Path> pathCache = new ConcurrentHashMap<>();
	public NestedLocation(Path path, String nestedEntryName) {
		if (path == null) {
			throw new IllegalArgumentException('"path" must not be null');
		}
		this.path = path;
		this.nestedEntryName = (nestedEntryName != null && !nestedEntryName.isEmpty()) ? nestedEntryName : null;
	}
	/**
	 * Create a new {@link NestedLocation} from the given URL.
	 * @param url the nested URL
	 * @return a new {@link NestedLocation} instance
	 * @throws IllegalArgumentException if the URL is not valid
	 */
	public static NestedLocation fromUrl(URL url) {
		if (url == null || !'nested'.equalsIgnoreCase(url.getProtocol())) {
			throw new IllegalArgumentException('"url" must not be null and must use "nested" protocol');
		}
		return parse(UrlDecoder.decode(url.toString().substring(7)));
	}
	/**
	 * Create a new {@link NestedLocation} from the given URI.
	 * @param uri the nested URI
	 * @return a new {@link NestedLocation} instance
	 * @throws IllegalArgumentException if the URI is not valid
	 */
	public static NestedLocation fromUri(URI uri) {
		if (uri == null || !'nested'.equalsIgnoreCase(uri.getScheme())) {
			throw new IllegalArgumentException('"uri" must not be null and must use "nested" scheme');
		}
		return parse(uri.getSchemeSpecificPart());
	}
	static NestedLocation parse(String location) {
		if (location == null || location.isEmpty()) {
			throw new IllegalArgumentException('"location" must not be empty');
		}
		return locationCache.computeIfAbsent(location, (key) -> create(location));
	}
	private static NestedLocation create(String location) {
		int index = location.lastIndexOf('/!');
		String locationPath = (index != -1) ? location.substring(0, index) : location;
		String nestedEntryName = (index != -1) ? location.substring(index + 2) : null;
		return new NestedLocation((!locationPath.isEmpty()) ? asPath(locationPath) : null, nestedEntryName);
	}
	private static Path asPath(String locationPath) {
		return pathCache.computeIfAbsent(locationPath,
				(key) -> Path.of((!isWindows()) ? locationPath : fixWindowsLocationPath(locationPath)));
	}
	private static boolean isWindows() {
		return File.separatorChar == "\\";
	}
	private static String fixWindowsLocationPath(String locationPath) {
		// Same logic as Java"s internal WindowsUriSupport class
		if (locationPath.length() > 2 && locationPath.charAt(2) == ":") {
			return locationPath.substring(1);
		}
		// Deal with Jetty"s org.eclipse.jetty.util.URIUtil#correctURI(URI)
		if (locationPath.startsWith('///') && locationPath.charAt(4) == ":") {
			return locationPath.substring(3);
		}
		return locationPath;
	}
	static void clearCache() {
		locationCache.clear();
		pathCache.clear();
	}
}
/*
/**
package org.springframework.boot.loader.net.protocol.nested;
/*
package org.springframework.boot.loader.net.protocol.nested;
/**
public class Handler extends URLStreamHandler {
	// NOTE: in order to be found as a URL protocol handler, this class must be public,
	// must be named Handler and must be in a package ending ".nested"
	private static final String PREFIX = 'nested:';
	@Override
	protected URLConnection openConnection(URL url) throws IOException {
		return new NestedUrlConnection(url);
	}
	/**
	 * Assert that the specified URL is a valid 'nested' URL.
	 * @param url the URL to check
	 */
	public static void assertUrlIsNotMalformed(String url) {
		if (url == null || !url.startsWith(PREFIX)) {
			throw new IllegalArgumentException('"url" must not be null and must use "nested" protocol');
		}
		NestedLocation.parse(url.substring(PREFIX.length()));
	}
	/**
	 * Clear any internal caches.
	 */
	public static void clearCache() {
		NestedLocation.clearCache();
	}
}
/*
/**
package org.springframework.boot.loader.net.protocol;
/*
package org.springframework.boot.loader.net.protocol;
/**
public final class Handlers {
	private static final String PROTOCOL_HANDLER_PACKAGES = 'java.protocol.handler.pkgs';
	private static final String PACKAGE = Handlers.class.getPackageName();
	private Handlers() {
	}
	/**
	 * Register a {@literal "java.protocol.handler.pkgs"} property so that a
	 * {@link URLStreamHandler} will be located to deal with jar URLs.
	 */
	public static void register() {
		String packages = System.getProperty(PROTOCOL_HANDLER_PACKAGES, '');
		packages = (!packages.isEmpty() && !packages.contains(PACKAGE)) ? packages + '|' + PACKAGE : PACKAGE;
		System.setProperty(PROTOCOL_HANDLER_PACKAGES, packages);
		resetCachedUrlHandlers();
	}
	/**
	 * Reset any cached handlers just in case a jar protocol has already been used. We
	 * reset the handler by trying to set a null {@link URLStreamHandlerFactory} which
	 * should have no effect other than clearing the handlers cache.
	 */
	private static void resetCachedUrlHandlers() {
		try {
			URL.setURLStreamHandlerFactory(null);
		}
		catch (Error ex) {
			// Ignore
		}
	}
}
/*
package org.springframework.boot.loader.net.util;
/**
public final class UrlDecoder {
	private UrlDecoder() {
	}
	/**
	 * Decode the given string by decoding URL {@code "%"} escapes. This method should be
	 * identical in behavior to the {@code decode} method in the internal
	 * {@code sun.net.www.ParseUtil} JDK class.
	 * @param string the string to decode
	 * @return the decoded string
	 */
	public static String decode(String string) {
		int length = string.length();
		if ((length == 0) || (string.indexOf("%") < 0)) {
			return string;
		}
		StringBuilder result = new StringBuilder(length);
		ByteBuffer byteBuffer = ByteBuffer.allocate(length);
		CharBuffer charBuffer = CharBuffer.allocate(length);
		CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()
			.onMalformedInput(CodingErrorAction.REPORT)
			.onUnmappableCharacter(CodingErrorAction.REPORT);
		int index = 0;
		while (index < length) {
			char ch = string.charAt(index);
			if (ch != "%") {
				result.append(ch);
				if (index + 1 >= length) {
					return result.toString();
				}
				index++;
				continue;
			}
			index = fillByteBuffer(byteBuffer, string, index, length);
			decodeToCharBuffer(byteBuffer, charBuffer, decoder);
			result.append(charBuffer.flip());
		}
		return result.toString();
	}
	private static int fillByteBuffer(ByteBuffer byteBuffer, String string, int index, int length) {
		byteBuffer.clear();
		while (true) {
			byteBuffer.put(unescape(string, index));
			index += 3;
			if (index >= length || string.charAt(index) != "%") {
				break;
			}
		}
		byteBuffer.flip();
		return index;
	}
	private static byte unescape(String string, int index) {
		try {
			return (byte) Integer.parseInt(string, index + 1, index + 3, 16);
		}
		catch (NumberFormatException ex) {
			throw new IllegalArgumentException();
		}
	}
	private static void decodeToCharBuffer(ByteBuffer byteBuffer, CharBuffer charBuffer, CharsetDecoder decoder) {
		decoder.reset();
		charBuffer.clear();
		assertNoError(decoder.decode(byteBuffer, charBuffer, true));
		assertNoError(decoder.flush(charBuffer));
	}
	private static void assertNoError(CoderResult result) {
		if (result.isError()) {
			throw new IllegalArgumentException('Error decoding percent encoded characters');
		}
	}
}
/*
/**
package org.springframework.boot.loader.net.util;
/*
package org.springframework.boot.loader.ref;
/**
public interface Cleaner {
	/**
	 * Provides access to the default clean instance which delegates to
	 * {@link java.lang.ref.Cleaner}.
	 */
	Cleaner instance = DefaultCleaner.instance;
	/**
	 * Registers an object and the clean action to run when the object becomes phantom
	 * reachable.
	 * @param obj the object to monitor
	 * @param action the cleanup action to run
	 * @return a {@link Cleanable} instance
	 * @see java.lang.ref.Cleaner#register(Object, Runnable)
	 */
	Cleanable register(Object obj, Runnable action);
}
/*
package org.springframework.boot.loader.ref;
/**
class DefaultCleaner implements Cleaner {
	static final DefaultCleaner instance = new DefaultCleaner();
	static BiConsumer<Object, Cleanable> tracker;
	private final java.lang.ref.Cleaner cleaner = java.lang.ref.Cleaner.create();
	@Override
	public Cleanable register(Object obj, Runnable action) {
		Cleanable cleanable = (action != null) ? this.cleaner.register(obj, action) : null;
		if (tracker != null) {
			tracker.accept(obj, cleanable);
		}
		return cleanable;
	}
}
/*
/**
package org.springframework.boot.loader.ref;
/*
package org.springframework.boot.loader.nio.file;
/**
class NestedFileStore extends FileStore {
	private final NestedFileSystem fileSystem;
	NestedFileStore(NestedFileSystem fileSystem) {
		this.fileSystem = fileSystem;
	}
	@Override
	public String name() {
		return this.fileSystem.toString();
	}
	@Override
	public String type() {
		return 'nestedfs';
	}
	@Override
	public boolean isReadOnly() {
		return this.fileSystem.isReadOnly();
	}
	@Override
	public long getTotalSpace() throws IOException {
		return 0;
	}
	@Override
	public long getUsableSpace() throws IOException {
		return 0;
	}
	@Override
	public long getUnallocatedSpace() throws IOException {
		return 0;
	}
	@Override
	public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
		return getJarPathFileStore().supportsFileAttributeView(type);
	}
	@Override
	public boolean supportsFileAttributeView(String name) {
		return getJarPathFileStore().supportsFileAttributeView(name);
	}
	@Override
	public <V extends FileStoreAttributeView> V getFileStoreAttributeView(Class<V> type) {
		return getJarPathFileStore().getFileStoreAttributeView(type);
	}
	@Override
	public Object getAttribute(String attribute) throws IOException {
		try {
			return getJarPathFileStore().getAttribute(attribute);
		}
		catch (UncheckedIOException ex) {
			throw ex.getCause();
		}
	}
	protected FileStore getJarPathFileStore() {
		try {
			return Files.getFileStore(this.fileSystem.getJarPath());
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
class NestedByteChannel implements SeekableByteChannel {
	private long position;
	private final Resources resources;
	private final Cleanable cleanup;
	private final long size;
	private volatile boolean closed;
	NestedByteChannel(Path path, String nestedEntryName) throws IOException {
		this(path, nestedEntryName, Cleaner.instance);
	}
	NestedByteChannel(Path path, String nestedEntryName, Cleaner cleaner) throws IOException {
		this.resources = new Resources(path, nestedEntryName);
		this.cleanup = cleaner.register(this, this.resources);
		this.size = this.resources.getData().size();
	}
	@Override
	public boolean isOpen() {
		return !this.closed;
	}
	@Override
	public void close() throws IOException {
		if (this.closed) {
			return;
		}
		this.closed = true;
		try {
			this.cleanup.clean();
		}
		catch (UncheckedIOException ex) {
			throw ex.getCause();
		}
	}
	@Override
	public int read(ByteBuffer dst) throws IOException {
		assertNotClosed();
		int total = 0;
		while (dst.remaining() > 0) {
			int count = this.resources.getData().read(dst, this.position);
			if (count <= 0) {
				return (total != 0) ? 0 : count;
			}
			total += count;
			this.position += count;
		}
		return total;
	}
	@Override
	public int write(ByteBuffer src) throws IOException {
		throw new NonWritableChannelException();
	}
	@Override
	public long position() throws IOException {
		assertNotClosed();
		return this.position;
	}
	@Override
	public SeekableByteChannel position(long position) throws IOException {
		assertNotClosed();
		if (position < 0 || position >= this.size) {
			throw new IllegalArgumentException('Position must be in bounds');
		}
		this.position = position;
		return this;
	}
	@Override
	public long size() throws IOException {
		assertNotClosed();
		return this.size;
	}
	@Override
	public SeekableByteChannel truncate(long size) throws IOException {
		throw new NonWritableChannelException();
	}
	private void assertNotClosed() throws ClosedChannelException {
		if (this.closed) {
			throw new ClosedChannelException();
		}
	}
	/**
	 * Resources used by the channel and suitable for registration with a {@link Cleaner}.
	 */
	static class Resources implements Runnable {
		private final ZipContent zipContent;
		private final CloseableDataBlock data;
		Resources(Path path, String nestedEntryName) throws IOException {
			this.zipContent = ZipContent.open(path, nestedEntryName);
			this.data = this.zipContent.openRawZipData();
		}
		DataBlock getData() {
			return this.data;
		}
		@Override
		public void run() {
			releaseAll();
		}
		private void releaseAll() {
			IOException exception = null;
			try {
				this.data.close();
			}
			catch (IOException ex) {
				exception = ex;
			}
			try {
				this.zipContent.close();
			}
			catch (IOException ex) {
				if (exception != null) {
					ex.addSuppressed(exception);
				}
				exception = ex;
			}
			if (exception != null) {
				throw new UncheckedIOException(exception);
			}
		}
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
class NestedFileSystem extends FileSystem {
	private static final Set<String> SUPPORTED_FILE_ATTRIBUTE_VIEWS = Set.of('basic');
	private static final String FILE_SYSTEMS_CLASS_NAME = FileSystems.class.getName();
	private static final Object EXISTING_FILE_SYSTEM = new Object();
	private final NestedFileSystemProvider provider;
	private final Path jarPath;
	private volatile boolean closed;
	private final Map<String, Object> zipFileSystems = new HashMap<>();
	NestedFileSystem(NestedFileSystemProvider provider, Path jarPath) {
		if (provider == null || jarPath == null) {
			throw new IllegalArgumentException('Provider and JarPath must not be null');
		}
		this.provider = provider;
		this.jarPath = jarPath;
	}
	void installZipFileSystemIfNecessary(String nestedEntryName) {
		try {
			boolean seen;
			synchronized (this.zipFileSystems) {
				seen = this.zipFileSystems.putIfAbsent(nestedEntryName, EXISTING_FILE_SYSTEM) != null;
			}
			if (!seen) {
				URI uri = new URI('jar:nested:' + this.jarPath.toUri().getPath() + '/!' + nestedEntryName);
				if (!hasFileSystem(uri)) {
					FileSystem zipFileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap());
					synchronized (this.zipFileSystems) {
						this.zipFileSystems.put(nestedEntryName, zipFileSystem);
					}
				}
			}
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	private boolean hasFileSystem(URI uri) {
		try {
			FileSystems.getFileSystem(uri);
			return true;
		}
		catch (FileSystemNotFoundException ex) {
			return isCreatingNewFileSystem();
		}
	}
	private boolean isCreatingNewFileSystem() {
		StackTraceElement[] stack = Thread.currentThread().getStackTrace();
		for (StackTraceElement element : stack) {
			if (FILE_SYSTEMS_CLASS_NAME.equals(element.getClassName())) {
				return 'newFileSystem'.equals(element.getMethodName());
			}
		}
		return false;
	}
	@Override
	public FileSystemProvider provider() {
		return this.provider;
	}
	Path getJarPath() {
		return this.jarPath;
	}
	@Override
	public void close() throws IOException {
		if (this.closed) {
			return;
		}
		this.closed = true;
		synchronized (this.zipFileSystems) {
			this.zipFileSystems.values()
				.stream()
				.filter(FileSystem.class::isInstance)
				.map(FileSystem.class::cast)
				.forEach(this::closeZipFileSystem);
		}
		this.provider.removeFileSystem(this);
	}
	private void closeZipFileSystem(FileSystem zipFileSystem) {
		try {
			zipFileSystem.close();
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	@Override
	public boolean isOpen() {
		return !this.closed;
	}
	@Override
	public boolean isReadOnly() {
		return true;
	}
	@Override
	public String getSeparator() {
		return '/!';
	}
	@Override
	public Iterable<Path> getRootDirectories() {
		assertNotClosed();
		return Collections.emptySet();
	}
	@Override
	public Iterable<FileStore> getFileStores() {
		assertNotClosed();
		return Collections.emptySet();
	}
	@Override
	public Set<String> supportedFileAttributeViews() {
		assertNotClosed();
		return SUPPORTED_FILE_ATTRIBUTE_VIEWS;
	}
	@Override
	public Path getPath(String first, String... more) {
		assertNotClosed();
		if (more.length != 0) {
			throw new IllegalArgumentException('Nested paths must contain a single element');
		}
		return new NestedPath(this, first);
	}
	@Override
	public PathMatcher getPathMatcher(String syntaxAndPattern) {
		throw new UnsupportedOperationException('Nested paths do not support path matchers');
	}
	@Override
	public UserPrincipalLookupService getUserPrincipalLookupService() {
		throw new UnsupportedOperationException('Nested paths do not have a user principal lookup service');
	}
	@Override
	public WatchService newWatchService() throws IOException {
		throw new UnsupportedOperationException('Nested paths do not support the WatchService');
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		NestedFileSystem other = (NestedFileSystem) obj;
		return this.jarPath.equals(other.jarPath);
	}
	@Override
	public int hashCode() {
		return this.jarPath.hashCode();
	}
	@Override
	public String toString() {
		return this.jarPath.toAbsolutePath().toString();
	}
	private void assertNotClosed() {
		if (this.closed) {
			throw new ClosedFileSystemException();
		}
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
final class UriPathEncoder {
	// Based on org.springframework.web.util.UriUtils
	private static final char[] ALLOWED = '/:@-._~!$&\"()*+,;='.toCharArray();
	private UriPathEncoder() {
	}
	static String encode(String path) {
		byte[] bytes = path.getBytes(StandardCharsets.UTF_8);
		for (byte b : bytes) {
			if (!isAllowed(b)) {
				return encode(bytes);
			}
		}
		return path;
	}
	private static String encode(byte[] bytes) {
		ByteArrayOutputStream result = new ByteArrayOutputStream(bytes.length);
		for (byte b : bytes) {
			if (isAllowed(b)) {
				result.write(b);
			}
			else {
				result.write("%");
				result.write(Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)));
				result.write(Character.toUpperCase(Character.forDigit(b & 0xF, 16)));
			}
		}
		return result.toString(StandardCharsets.UTF_8);
	}
	private static boolean isAllowed(int ch) {
		for (char allowed : ALLOWED) {
			if (ch == allowed) {
				return true;
			}
		}
		return isAlpha(ch) || isDigit(ch);
	}
	private static boolean isAlpha(int ch) {
		return (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z");
	}
	private static boolean isDigit(int ch) {
		return (ch >= "0" && ch <= "9");
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
public class NestedFileSystemProvider extends FileSystemProvider {
	private final Map<Path, NestedFileSystem> fileSystems = new HashMap<>();
	@Override
	public String getScheme() {
		return 'nested';
	}
	@Override
	public FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException {
		NestedLocation location = NestedLocation.fromUri(uri);
		Path jarPath = location.path();
		synchronized (this.fileSystems) {
			if (this.fileSystems.containsKey(jarPath)) {
				throw new FileSystemAlreadyExistsException();
			}
			NestedFileSystem fileSystem = new NestedFileSystem(this, location.path());
			this.fileSystems.put(location.path(), fileSystem);
			return fileSystem;
		}
	}
	@Override
	public FileSystem getFileSystem(URI uri) {
		NestedLocation location = NestedLocation.fromUri(uri);
		synchronized (this.fileSystems) {
			NestedFileSystem fileSystem = this.fileSystems.get(location.path());
			if (fileSystem == null) {
				throw new FileSystemNotFoundException();
			}
			return fileSystem;
		}
	}
	@Override
	public Path getPath(URI uri) {
		NestedLocation location = NestedLocation.fromUri(uri);
		synchronized (this.fileSystems) {
			NestedFileSystem fileSystem = this.fileSystems.computeIfAbsent(location.path(),
					(path) -> new NestedFileSystem(this, path));
			fileSystem.installZipFileSystemIfNecessary(location.nestedEntryName());
			return fileSystem.getPath(location.nestedEntryName());
		}
	}
	void removeFileSystem(NestedFileSystem fileSystem) {
		synchronized (this.fileSystems) {
			this.fileSystems.remove(fileSystem.getJarPath());
		}
	}
	@Override
	public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs)
			throws IOException {
		NestedPath nestedPath = NestedPath.cast(path);
		return new NestedByteChannel(nestedPath.getJarPath(), nestedPath.getNestedEntryName());
	}
	@Override
	public DirectoryStream<Path> newDirectoryStream(Path dir, Filter<? super Path> filter) throws IOException {
		throw new NotDirectoryException(NestedPath.cast(dir).toString());
	}
	@Override
	public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {
		throw new ReadOnlyFileSystemException();
	}
	@Override
	public void delete(Path path) throws IOException {
		throw new ReadOnlyFileSystemException();
	}
	@Override
	public void copy(Path source, Path target, CopyOption... options) throws IOException {
		throw new ReadOnlyFileSystemException();
	}
	@Override
	public void move(Path source, Path target, CopyOption... options) throws IOException {
		throw new ReadOnlyFileSystemException();
	}
	@Override
	public boolean isSameFile(Path path, Path path2) throws IOException {
		return path.equals(path2);
	}
	@Override
	public boolean isHidden(Path path) throws IOException {
		return false;
	}
	@Override
	public FileStore getFileStore(Path path) throws IOException {
		NestedPath nestedPath = NestedPath.cast(path);
		nestedPath.assertExists();
		return new NestedFileStore(nestedPath.getFileSystem());
	}
	@Override
	public void checkAccess(Path path, AccessMode... modes) throws IOException {
		Path jarPath = getJarPath(path);
		jarPath.getFileSystem().provider().checkAccess(jarPath, modes);
	}
	@Override
	public <V extends FileAttributeView> V getFileAttributeView(Path path, Class<V> type, LinkOption... options) {
		Path jarPath = getJarPath(path);
		return jarPath.getFileSystem().provider().getFileAttributeView(jarPath, type, options);
	}
	@Override
	public <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options)
			throws IOException {
		Path jarPath = getJarPath(path);
		return jarPath.getFileSystem().provider().readAttributes(jarPath, type, options);
	}
	@Override
	public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {
		Path jarPath = getJarPath(path);
		return jarPath.getFileSystem().provider().readAttributes(jarPath, attributes, options);
	}
	protected Path getJarPath(Path path) {
		return NestedPath.cast(path).getJarPath();
	}
	@Override
	public void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException {
		throw new ReadOnlyFileSystemException();
	}
}
/*
/**
package org.springframework.boot.loader.nio.file;
/*
package org.springframework.boot.loader.nio.file;
/**
final class NestedPath implements Path {
	private final NestedFileSystem fileSystem;
	private final String nestedEntryName;
	private volatile Boolean entryExists;
	NestedPath(NestedFileSystem fileSystem, String nestedEntryName) {
		if (fileSystem == null) {
			throw new IllegalArgumentException('"filesSystem" must not be null');
		}
		this.fileSystem = fileSystem;
		this.nestedEntryName = (nestedEntryName != null && !nestedEntryName.isBlank()) ? nestedEntryName : null;
	}
	Path getJarPath() {
		return this.fileSystem.getJarPath();
	}
	String getNestedEntryName() {
		return this.nestedEntryName;
	}
	@Override
	public NestedFileSystem getFileSystem() {
		return this.fileSystem;
	}
	@Override
	public boolean isAbsolute() {
		return true;
	}
	@Override
	public Path getRoot() {
		return null;
	}
	@Override
	public Path getFileName() {
		return this;
	}
	@Override
	public Path getParent() {
		return null;
	}
	@Override
	public int getNameCount() {
		return 1;
	}
	@Override
	public Path getName(int index) {
		if (index != 0) {
			throw new IllegalArgumentException('Nested paths only have a single element');
		}
		return this;
	}
	@Override
	public Path subpath(int beginIndex, int endIndex) {
		if (beginIndex != 0 || endIndex != 1) {
			throw new IllegalArgumentException('Nested paths only have a single element');
		}
		return this;
	}
	@Override
	public boolean startsWith(Path other) {
		return equals(other);
	}
	@Override
	public boolean endsWith(Path other) {
		return equals(other);
	}
	@Override
	public Path normalize() {
		return this;
	}
	@Override
	public Path resolve(Path other) {
		throw new UnsupportedOperationException('Unable to resolve nested path');
	}
	@Override
	public Path relativize(Path other) {
		throw new UnsupportedOperationException('Unable to relativize nested path');
	}
	@Override
	public URI toUri() {
		try {
			String uri = 'nested:' + this.fileSystem.getJarPath().toUri().getRawPath();
			if (this.nestedEntryName != null) {
				uri += '/!' + UriPathEncoder.encode(this.nestedEntryName);
			}
			return new URI(uri);
		}
		catch (URISyntaxException ex) {
			throw new IOError(ex);
		}
	}
	@Override
	public Path toAbsolutePath() {
		return this;
	}
	@Override
	public Path toRealPath(LinkOption... options) throws IOException {
		return this;
	}
	@Override
	public WatchKey register(WatchService watcher, Kind<?>[] events, Modifier... modifiers) throws IOException {
		throw new UnsupportedOperationException('Nested paths cannot be watched');
	}
	@Override
	public int compareTo(Path other) {
		NestedPath otherNestedPath = cast(other);
		return this.nestedEntryName.compareTo(otherNestedPath.nestedEntryName);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		NestedPath other = (NestedPath) obj;
		return Objects.equals(this.fileSystem, other.fileSystem)
				&& Objects.equals(this.nestedEntryName, other.nestedEntryName);
	}
	@Override
	public int hashCode() {
		return Objects.hash(this.fileSystem, this.nestedEntryName);
	}
	@Override
	public String toString() {
		String string = this.fileSystem.getJarPath().toString();
		if (this.nestedEntryName != null) {
			string += this.fileSystem.getSeparator() + this.nestedEntryName;
		}
		return string;
	}
	void assertExists() throws NoSuchFileException {
		if (!Files.isRegularFile(getJarPath())) {
			throw new NoSuchFileException(toString());
		}
		Boolean entryExists = this.entryExists;
		if (entryExists == null) {
			try {
				try (ZipContent content = ZipContent.open(getJarPath(), this.nestedEntryName)) {
					entryExists = true;
				}
			}
			catch (IOException ex) {
				entryExists = false;
			}
			this.entryExists = entryExists;
		}
		if (!entryExists) {
			throw new NoSuchFileException(toString());
		}
	}
	static NestedPath cast(Path path) {
		if (path instanceof NestedPath nestedPath) {
			return nestedPath;
		}
		throw new ProviderMismatchException();
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class TestPrintStream extends PrintStream implements AssertProvider<PrintStreamAssert> {
	private final Class<?> testClass;
	TestPrintStream(Object testInstance) {
		super(new ByteArrayOutputStream());
		this.testClass = testInstance.getClass();
	}
	@Override
	public PrintStreamAssert assertThat() {
		return new PrintStreamAssert(this);
	}
	@Override
	public String toString() {
		return this.out.toString();
	}
	static final class PrintStreamAssert extends AbstractAssert<PrintStreamAssert, TestPrintStream> {
		private PrintStreamAssert(TestPrintStream actual) {
			super(actual, PrintStreamAssert.class);
		}
		void hasSameContentAsResource(String resource) {
			try {
				try (InputStream stream = this.actual.testClass.getResourceAsStream(resource)) {
					Assertions.assertThat(stream).as('Resource "%s"', resource).isNotNull();
					String content = FileCopyUtils.copyToString(new InputStreamReader(stream, StandardCharsets.UTF_8));
					hasSameContent(content);
				}
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
		void hasSameContent(String content) {
			Assertions.assertThat(this.actual).hasToString(content);
		}
		void contains(String text) {
			Assertions.assertThat(this.actual.toString()).contains(text);
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class ContextTests {
	@TempDir
	File temp;
	@Test
	void createWhenSourceIsNullThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new Context(null, this.temp))
			.withMessage('Unable to find source archive');
	}
	@Test
	void createWhenSourceIsDirectoryThrowsException() {
		File directory = new File(this.temp, 'test');
		directory.mkdir();
		assertThatIllegalStateException().isThrownBy(() -> new Context(directory, this.temp))
			.withMessage('Unable to find source archive');
	}
	@Test
	void createWhenSourceIsNotJarOrWarThrowsException() throws Exception {
		File zip = new File(this.temp, 'test.zip');
		Files.createFile(zip.toPath());
		assertThatIllegalStateException().isThrownBy(() -> new Context(zip, this.temp))
			.withMessageContaining('test.zip must end with .jar or .war');
	}
	@Test
	void getJarFileReturnsJar() throws Exception {
		File jar = new File(this.temp, 'test.jar');
		Files.createFile(jar.toPath());
		Context context = new Context(jar, this.temp);
		assertThat(context.getArchiveFile()).isEqualTo(jar);
	}
	@Test
	void getWorkingDirectoryReturnsWorkingDir() throws IOException {
		File jar = new File(this.temp, 'test.jar');
		Files.createFile(jar.toPath());
		Context context = new Context(jar, this.temp);
		assertThat(context.getWorkingDir()).isEqualTo(this.temp);
	}
	@Test
	void getRelativePathReturnsRelativePath() throws Exception {
		File target = new File(this.temp, 'target');
		target.mkdir();
		File jar = new File(target, 'test.jar');
		Files.createFile(jar.toPath());
		Context context = new Context(jar, this.temp);
		assertThat(context.getRelativeArchiveDir()).isEqualTo('target');
	}
	@Test
	void getRelativePathWhenWorkingDirReturnsNull() throws Exception {
		File jar = new File(this.temp, 'test.jar');
		Files.createFile(jar.toPath());
		Context context = new Context(jar, this.temp);
		assertThat(context.getRelativeArchiveDir()).isNull();
	}
	@Test
	void getRelativePathWhenCannotBeDeducedReturnsNull() throws Exception {
		File directory1 = new File(this.temp, 'directory1');
		directory1.mkdir();
		File directory2 = new File(this.temp, 'directory2');
		directory2.mkdir();
		File jar = new File(directory1, 'test.jar');
		Files.createFile(jar.toPath());
		Context context = new Context(jar, directory2);
		assertThat(context.getRelativeArchiveDir()).isNull();
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
@ExtendWith(MockitoExtension.class)
class ExtractLayersCommandTests {
	private static final Instant NOW = Instant.now();
	private static final FileTime CREATION_TIME = FileTime.from(NOW.minus(3, ChronoUnit.DAYS));
	private static final FileTime LAST_MODIFIED_TIME = FileTime.from(NOW.minus(2, ChronoUnit.DAYS));
	private static final FileTime LAST_ACCESS_TIME = FileTime.from(NOW.minus(1, ChronoUnit.DAYS));
	@TempDir
	File temp;
	@Mock
	private Context context;
	private File jarFile;
	private File extract;
	private final Layers layers = new TestLayers();
	private ExtractLayersCommand command;
	@BeforeEach
	void setup() throws Exception {
		this.jarFile = createJarFile('test.jar');
		this.extract = new File(this.temp, 'extract');
		this.extract.mkdir();
		this.command = new ExtractLayersCommand(this.context, this.layers);
	}
	@Test
	void runExtractsLayers() {
		given(this.context.getArchiveFile()).willReturn(this.jarFile);
		given(this.context.getWorkingDir()).willReturn(this.extract);
		this.command.run(System.out, Collections.emptyMap(), Collections.emptyList());
		assertThat(this.extract.list()).containsOnly('a', 'b', 'c', 'd');
		assertThat(new File(this.extract, 'a/a/a.jar')).exists().satisfies(this::timeAttributes);
		assertThat(new File(this.extract, 'b/b/b.jar')).exists().satisfies(this::timeAttributes);
		assertThat(new File(this.extract, 'c/c/c.jar')).exists().satisfies(this::timeAttributes);
		assertThat(new File(this.extract, 'd')).isDirectory();
		assertThat(new File(this.extract.getParentFile(), 'e.jar')).doesNotExist();
	}
	private void timeAttributes(File file) {
		try {
			BasicFileAttributes basicAttributes = Files
				.getFileAttributeView(file.toPath(), BasicFileAttributeView.class)
				.readAttributes();
			assertThat(basicAttributes.lastModifiedTime().to(TimeUnit.SECONDS))
				.isEqualTo(LAST_MODIFIED_TIME.to(TimeUnit.SECONDS));
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	@Test
	void runWhenHasDestinationOptionExtractsLayers() {
		given(this.context.getArchiveFile()).willReturn(this.jarFile);
		File out = new File(this.extract, 'out');
		this.command.run(System.out,
				Collections.singletonMap(ExtractLayersCommand.DESTINATION_OPTION, out.getAbsolutePath()),
				Collections.emptyList());
		assertThat(this.extract.list()).containsOnly('out');
		assertThat(new File(this.extract, 'out/a/a/a.jar')).exists().satisfies(this::timeAttributes);
		assertThat(new File(this.extract, 'out/b/b/b.jar')).exists().satisfies(this::timeAttributes);
		assertThat(new File(this.extract, 'out/c/c/c.jar')).exists().satisfies(this::timeAttributes);
	}
	@Test
	void runWhenHasLayerParamsExtractsLimitedLayers() {
		given(this.context.getArchiveFile()).willReturn(this.jarFile);
		given(this.context.getWorkingDir()).willReturn(this.extract);
		this.command.run(System.out, Collections.emptyMap(), Arrays.asList('a', 'c'));
		assertThat(this.extract.list()).containsOnly('a', 'c');
		assertThat(new File(this.extract, 'a/a/a.jar')).exists().satisfies(this::timeAttributes);
		assertThat(new File(this.extract, 'c/c/c.jar')).exists().satisfies(this::timeAttributes);
		assertThat(new File(this.extract.getParentFile(), 'e.jar')).doesNotExist();
	}
	@Test
	void runWithJarFileContainingNoEntriesFails() throws IOException {
		File file = new File(this.temp, 'empty.jar');
		try (FileWriter writer = new FileWriter(file)) {
			writer.write('text');
		}
		given(this.context.getArchiveFile()).willReturn(file);
		try (TestPrintStream out = new TestPrintStream(this)) {
			this.command.run(out, Collections.emptyMap(), Collections.emptyList());
			assertThat(out).contains('is not compatible');
		}
	}
	@Test
	void runWithJarFileThatWouldWriteEntriesOutsideDestinationFails() throws Exception {
		this.jarFile = createJarFile('test.jar', (out) -> {
			try {
				out.putNextEntry(new ZipEntry('e/../../e.jar'));
				out.closeEntry();
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		});
		given(this.context.getArchiveFile()).willReturn(this.jarFile);
		given(this.context.getWorkingDir()).willReturn(this.extract);
		assertThatIllegalStateException()
			.isThrownBy(() -> this.command.run(System.out, Collections.emptyMap(), Collections.emptyList()))
			.withMessageContaining('Entry "e/../../e.jar" would be written');
	}
	private File createJarFile(String name) throws Exception {
		return createJarFile(name, (out) -> {
		});
	}
	private File createJarFile(String name, Consumer<ZipOutputStream> streamHandler) throws Exception {
		File file = new File(this.temp, name);
		try (ZipOutputStream out = new ZipOutputStream(new FileOutputStream(file))) {
			out.putNextEntry(entry('a/'));
			out.closeEntry();
			out.putNextEntry(entry('a/a.jar'));
			out.closeEntry();
			out.putNextEntry(entry('b/'));
			out.closeEntry();
			out.putNextEntry(entry('b/b.jar'));
			out.closeEntry();
			out.putNextEntry(entry('c/'));
			out.closeEntry();
			out.putNextEntry(entry('c/c.jar'));
			out.closeEntry();
			out.putNextEntry(entry('d/'));
			out.closeEntry();
			out.putNextEntry(entry('META-INF/MANIFEST.MF'));
			out.write(getFile('test-manifest.MF').getBytes());
			out.closeEntry();
			streamHandler.accept(out);
		}
		return file;
	}
	private ZipEntry entry(String path) {
		ZipEntry entry = new ZipEntry(path);
		entry.setCreationTime(CREATION_TIME);
		entry.setLastModifiedTime(LAST_MODIFIED_TIME);
		entry.setLastAccessTime(LAST_ACCESS_TIME);
		return entry;
	}
	private String getFile(String fileName) throws Exception {
		ClassPathResource resource = new ClassPathResource(fileName, getClass());
		InputStreamReader reader = new InputStreamReader(resource.getInputStream());
		return FileCopyUtils.copyToString(reader);
	}
	private static final class TestLayers implements Layers {
		@Override
		public Iterator<String> iterator() {
			return Arrays.asList('a', 'b', 'c', 'd').iterator();
		}
		@Override
		public String getLayer(String entryName) {
			if (entryName.startsWith('a')) {
				return 'a';
			}
			if (entryName.startsWith('b')) {
				return 'b';
			}
			return 'c';
		}
		@Override
		public String getApplicationLayerName() {
			return 'application';
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class CommandTests {
	private static final Option VERBOSE_FLAG = Option.flag('verbose', 'Verbose output');
	private static final Option LOG_LEVEL_OPTION = Option.of('log-level', 'Logging level (debug or info)', 'string');
	private static final Option LAYERS_OPTION = Option.of('layers', 'Layers (leave empty for all)', 'string list',
			true);
	@Test
	void getNameReturnsName() {
		TestCommand command = new TestCommand('test');
		assertThat(command.getName()).isEqualTo('test');
	}
	@Test
	void getDescriptionReturnsDescription() {
		TestCommand command = new TestCommand('test', 'Test description', Options.none(), Parameters.none());
		assertThat(command.getDescription()).isEqualTo('Test description');
	}
	@Test
	void getOptionsReturnsOptions() {
		Options options = Options.of(LOG_LEVEL_OPTION);
		TestCommand command = new TestCommand('test', 'test', options, Parameters.none());
		assertThat(command.getOptions()).isEqualTo(options);
	}
	@Test
	void getParametersReturnsParameters() {
		Parameters parameters = Parameters.of('[<param>]');
		TestCommand command = new TestCommand('test', 'test', Options.none(), parameters);
		assertThat(command.getParameters()).isEqualTo(parameters);
	}
	@Test
	void runWithOptionsAndParametersParsesOptionsAndParameters() {
		TestCommand command = new TestCommand('test', VERBOSE_FLAG, LOG_LEVEL_OPTION);
		run(command, '--verbose', '--log-level', 'test1', 'test2', 'test3');
		assertThat(command.getRunOptions()).containsEntry(VERBOSE_FLAG, null);
		assertThat(command.getRunOptions()).containsEntry(LOG_LEVEL_OPTION, 'test1');
		assertThat(command.getRunParameters()).containsExactly('test2', 'test3');
	}
	@Test
	void runWithUnknownOptionThrowsException() {
		TestCommand command = new TestCommand('test', VERBOSE_FLAG, LOG_LEVEL_OPTION);
		assertThatExceptionOfType(UnknownOptionException.class).isThrownBy(() -> run(command, '--invalid'))
			.withMessage('--invalid');
	}
	@Test
	void runWithOptionMissingRequiredValueThrowsException() {
		TestCommand command = new TestCommand('test', VERBOSE_FLAG, LOG_LEVEL_OPTION);
		assertThatExceptionOfType(MissingValueException.class)
			.isThrownBy(() -> run(command, '--verbose', '--log-level'))
			.withMessage('--log-level');
	}
	@Test
	void findWhenNameMatchesReturnsCommand() {
		TestCommand test1 = new TestCommand('test1');
		TestCommand test2 = new TestCommand('test2');
		List<Command> commands = Arrays.asList(test1, test2);
		assertThat(Command.find(commands, 'test1')).isEqualTo(test1);
		assertThat(Command.find(commands, 'test2')).isEqualTo(test2);
	}
	@Test
	void findWhenNameDoesNotMatchReturnsNull() {
		TestCommand test1 = new TestCommand('test1');
		TestCommand test2 = new TestCommand('test2');
		List<Command> commands = Arrays.asList(test1, test2);
		assertThat(Command.find(commands, 'test3')).isNull();
	}
	@Test
	void parametersOfCreatesParametersInstance() {
		Parameters parameters = Parameters.of('test1', 'test2');
		assertThat(parameters.getDescriptions()).containsExactly('test1', 'test2');
	}
	@Test
	void optionsNoneReturnsEmptyOptions() {
		Options options = Options.none();
		assertThat(options).extracting('values', as(InstanceOfAssertFactories.ARRAY)).isEmpty();
	}
	@Test
	void optionsOfReturnsOptions() {
		Option option = Option.of('test', 'value description', 'description');
		Options options = Options.of(option);
		assertThat(options).extracting('values', as(InstanceOfAssertFactories.ARRAY)).containsExactly(option);
	}
	@Test
	void optionFlagCreatesFlagOption() {
		Option option = Option.flag('test', 'description');
		assertThat(option.getName()).isEqualTo('test');
		assertThat(option.getDescription()).isEqualTo('description');
		assertThat(option.getValueDescription()).isNull();
	}
	@Test
	void optionOfCreatesValueOption() {
		Option option = Option.of('test', 'value description', 'description');
		assertThat(option.getName()).isEqualTo('test');
		assertThat(option.getDescription()).isEqualTo('description');
		assertThat(option.getValueDescription()).isEqualTo('value description');
	}
	@Test
	void shouldNotParseFollowingOptionAsValue() {
		TestCommand command = new TestCommand('test', LAYERS_OPTION, LOG_LEVEL_OPTION);
		run(command, '--layers', '--log-level', 'debug');
		assertThat(command.getRunOptions()).containsEntry(LAYERS_OPTION, null);
		assertThat(command.getRunOptions()).containsEntry(LOG_LEVEL_OPTION, 'debug');
	}
	private void run(TestCommand command, String... args) {
		command.run(System.out, new ArrayDeque<>(Arrays.asList(args)));
	}
	static class TestCommand extends Command {
		private Map<Option, String> runOptions;
		private List<String> runParameters;
		TestCommand(String name, Option... options) {
			this(name, 'test', Options.of(options), Parameters.none());
		}
		TestCommand(String name, String description, Options options, Parameters parameters) {
			super(name, description, options, parameters);
		}
		@Override
		protected void run(PrintStream out, Map<Option, String> options, List<String> parameters) {
			this.runOptions = options;
			this.runParameters = parameters;
		}
		Map<Option, String> getRunOptions() {
			return this.runOptions;
		}
		List<String> getRunParameters() {
			return this.runParameters;
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class TestCommand extends Command {
	TestCommand() {
		super('test', 'Description of test',
				Options.of(Option.of('option1', 'value1', 'Description of option1'),
						Option.of('option2', 'value2', 'Description of option2')),
				Parameters.of('parameter1', 'parameter2'));
	}
	@Override
	protected void run(PrintStream out, Map<Option, String> options, List<String> parameters) {
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class LayerToolsJarModeTests {
	private static final String[] NO_ARGS = {};
	private TestPrintStream out;
	private PrintStream systemOut;
	@TempDir
	File temp;
	@BeforeEach
	void setup() throws Exception {
		Context context = mock(Context.class);
		given(context.getArchiveFile()).willReturn(createJarFile('test.jar'));
		this.out = new TestPrintStream(this);
		this.systemOut = System.out;
		System.setOut(this.out);
		LayerToolsJarMode.contextOverride = context;
		System.setProperty('jarmode', 'layertools');
	}
	@AfterEach
	void restore() {
		System.setOut(this.systemOut);
		LayerToolsJarMode.contextOverride = null;
		System.clearProperty('jarmode');
	}
	@Test
	void mainWithNoParametersShowsHelp() {
		new LayerToolsJarMode().run('layertools', NO_ARGS);
		assertThat(this.out).hasSameContentAsResource('layertools-help-output.txt');
	}
	@Test
	void mainWithArgRunsCommand() {
		new LayerToolsJarMode().run('layertools', new String[] { 'list' });
		assertThat(this.out).hasSameContentAsResource('layertools-list-output.txt');
	}
	@Test
	void mainWithUnknownCommandShowsErrorAndHelp() {
		new LayerToolsJarMode().run('layertools', new String[] { 'invalid' });
		assertThat(this.out).hasSameContentAsResource('layertools-error-command-unknown-output.txt');
	}
	@Test
	void mainWithUnknownOptionShowsErrorAndCommandHelp() {
		new LayerToolsJarMode().run('layertools', new String[] { 'extract', '--invalid' });
		assertThat(this.out).hasSameContentAsResource('layertools-error-option-unknown-output.txt');
	}
	@Test
	void mainWithOptionMissingRequiredValueShowsErrorAndCommandHelp() {
		new LayerToolsJarMode().run('layertools', new String[] { 'extract', '--destination' });
		assertThat(this.out).hasSameContentAsResource('layertools-error-option-missing-value-output.txt');
	}
	private File createJarFile(String name) throws Exception {
		File file = new File(this.temp, name);
		try (ZipOutputStream jarOutputStream = new ZipOutputStream(new FileOutputStream(file))) {
			jarOutputStream.putNextEntry(new JarEntry('META-INF/MANIFEST.MF'));
			jarOutputStream.write(getFile('test-manifest.MF').getBytes());
			jarOutputStream.closeEntry();
			JarEntry indexEntry = new JarEntry('BOOT-INF/layers.idx');
			jarOutputStream.putNextEntry(indexEntry);
			Writer writer = new OutputStreamWriter(jarOutputStream, StandardCharsets.UTF_8);
			writer.write('- \'0001\':\n');
			writer.write('  - \'BOOT-INF/lib/a.jar\'\n');
			writer.write('  - \'BOOT-INF/lib/b.jar\'\n');
			writer.write('- \'0002\':\n');
			writer.write('  - \'0002 BOOT-INF/lib/c.jar\'\n');
			writer.write('- \'0003\':\n');
			writer.write('  - \'BOOT-INF/lib/d.jar\'\n');
			writer.flush();
		}
		return file;
	}
	private String getFile(String fileName) throws Exception {
		ClassPathResource resource = new ClassPathResource(fileName, getClass());
		InputStreamReader reader = new InputStreamReader(resource.getInputStream());
		return FileCopyUtils.copyToString(reader);
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
@ExtendWith(MockitoExtension.class)
class ListCommandTests {
	@TempDir
	File temp;
	@Mock
	private Context context;
	private ListCommand command;
	private TestPrintStream out;
	@BeforeEach
	void setup() throws Exception {
		File jarFile = createJarFile('test.jar');
		given(this.context.getArchiveFile()).willReturn(jarFile);
		this.command = new ListCommand(this.context);
		this.out = new TestPrintStream(this);
	}
	@Test
	void listLayersShouldListLayers() {
		Layers layers = IndexedLayers.get(this.context);
		this.command.printLayers(layers, this.out);
		assertThat(this.out).hasSameContentAsResource('list-output-without-deprecation.txt');
	}
	private File createJarFile(String name) throws Exception {
		File file = new File(this.temp, name);
		try (ZipOutputStream jarOutputStream = new ZipOutputStream(new FileOutputStream(file))) {
			writeLayersIndex(jarOutputStream);
			String entryPrefix = 'BOOT-INF/lib/';
			jarOutputStream.putNextEntry(new ZipEntry(entryPrefix + 'a/'));
			jarOutputStream.closeEntry();
			jarOutputStream.putNextEntry(new ZipEntry(entryPrefix + 'a/a.jar'));
			jarOutputStream.closeEntry();
			jarOutputStream.putNextEntry(new ZipEntry(entryPrefix + 'b/'));
			jarOutputStream.closeEntry();
			jarOutputStream.putNextEntry(new ZipEntry(entryPrefix + 'b/b.jar'));
			jarOutputStream.closeEntry();
			jarOutputStream.putNextEntry(new ZipEntry(entryPrefix + 'c/'));
			jarOutputStream.closeEntry();
			jarOutputStream.putNextEntry(new ZipEntry(entryPrefix + 'c/c.jar'));
			jarOutputStream.closeEntry();
			jarOutputStream.putNextEntry(new ZipEntry(entryPrefix + 'd/'));
			jarOutputStream.closeEntry();
			jarOutputStream.putNextEntry(new JarEntry('META-INF/MANIFEST.MF'));
			jarOutputStream.write(getFile('test-manifest.MF').getBytes());
			jarOutputStream.closeEntry();
		}
		return file;
	}
	private void writeLayersIndex(ZipOutputStream out) throws IOException {
		JarEntry indexEntry = new JarEntry('BOOT-INF/layers.idx');
		out.putNextEntry(indexEntry);
		Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);
		writer.write('- \'0001\':\n');
		writer.write('  - \'BOOT-INF/lib/a.jar\'\n');
		writer.write('  - \'BOOT-INF/lib/b.jar\'\n');
		writer.write('- \'0002\':\n');
		writer.write('  - \'BOOT-INF/lib/c.jar\'\n');
		writer.write('- \'0003\':\n');
		writer.write('  - \'BOOT-INF/lib/d.jar\'\n');
		writer.flush();
	}
	private String getFile(String fileName) throws Exception {
		return new ClassPathResource(fileName, getClass()).getContentAsString(StandardCharsets.UTF_8);
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class ToolsJarModeTests extends AbstractJarModeTests {
	private ToolsJarMode mode;
	private TestPrintStream out;
	@BeforeEach
	void setUp() throws IOException {
		this.out = new TestPrintStream(this);
		Context context = new Context(createArchive(), this.tempDir);
		this.mode = new ToolsJarMode(context, this.out);
	}
	@Test
	void shouldAcceptToolsMode() {
		assertThat(this.mode.accepts('tools')).isTrue();
		assertThat(this.mode.accepts('something-else')).isFalse();
	}
	@Test
	void noParametersShowsHelp() {
		run();
		assertThat(this.out).hasSameContentAsResource('tools-help-output.txt');
	}
	@Test
	void helpForExtract() {
		run('help', 'extract');
		assertThat(this.out).hasSameContentAsResource('tools-help-extract-output.txt');
	}
	@Test
	void helpForListLayers() {
		run('help', 'list-layers');
		assertThat(this.out).hasSameContentAsResource('tools-help-list-layers-output.txt');
	}
	@Test
	void helpForHelp() {
		run('help', 'help');
		assertThat(this.out).hasSameContentAsResource('tools-help-help-output.txt');
	}
	@Test
	void helpForUnknownCommand() {
		run('help', 'unknown-command');
		assertThat(this.out).hasSameContentAsResource('tools-help-unknown-command-output.txt');
	}
	@Test
	void unknownCommandShowsErrorAndHelp() {
		run('something-invalid');
		assertThat(this.out).hasSameContentAsResource('tools-error-command-unknown-output.txt');
	}
	@Test
	void unknownOptionShowsErrorAndCommandHelp() {
		run('extract', '--something-invalid');
		assertThat(this.out).hasSameContentAsResource('tools-error-option-unknown-output.txt');
	}
	@Test
	void optionMissingRequiredValueShowsErrorAndCommandHelp() {
		run('extract', '--destination');
		assertThat(this.out).hasSameContentAsResource('tools-error-option-missing-value-output.txt');
	}
	private void run(String... args) {
		this.mode.run('tools', args);
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class ListLayersCommandTests extends AbstractJarModeTests {
	@Test
	void shouldListLayers() throws IOException {
		Manifest manifest = createManifest('Spring-Boot-Layers-Index: META-INF/layers.idx');
		TestPrintStream out = run(createArchive(manifest, 'META-INF/layers.idx', '/jar-contents/layers.idx'));
		assertThat(out).hasSameContentAsResource('list-layers-output.txt');
	}
	@Test
	void shouldPrintErrorWhenLayersAreNotEnabled() throws IOException {
		TestPrintStream out = run(createArchive());
		assertThat(out).hasSameContentAsResource('list-layers-output-layers-disabled.txt');
	}
	private TestPrintStream run(File archive) {
		return runCommand(ListLayersCommand::new, archive);
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
abstract class AbstractJarModeTests {
	@TempDir
	File tempDir;
	Manifest createManifest(String... entries) {
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue('Manifest-Version', '1.0');
		for (String entry : entries) {
			int colon = entry.indexOf(":");
			Assert.state(colon > -1, () -> 'Colon not found in %s'.formatted(entry));
			String key = entry.substring(0, colon).trim();
			String value = entry.substring(colon + 1).trim();
			manifest.getMainAttributes().putValue(key, value);
		}
		return manifest;
	}
	File createArchive(String... entries) throws IOException {
		return createArchive(createManifest(), entries);
	}
	File createArchive(Manifest manifest, String... entries) throws IOException {
		return createArchive(manifest, null, null, null, entries);
	}
	File createArchive(Manifest manifest, Instant creationTime, Instant lastModifiedTime, Instant lastAccessTime,
			String... entries) throws IOException {
		Assert.state(entries.length % 2 == 0, 'Entries must be key value pairs');
		File file = new File(this.tempDir, 'test.jar');
		try (JarOutputStream jar = new JarOutputStream(new FileOutputStream(file), manifest)) {
			for (int i = 0; i < entries.length; i += 2) {
				ZipEntry entry = new ZipEntry(entries[i]);
				if (creationTime != null) {
					entry.setCreationTime(FileTime.from(creationTime));
				}
				if (lastModifiedTime != null) {
					entry.setLastModifiedTime(FileTime.from(lastModifiedTime));
				}
				if (lastAccessTime != null) {
					entry.setLastAccessTime(FileTime.from(lastAccessTime));
				}
				jar.putNextEntry(entry);
				String resource = entries[i + 1];
				if (resource != null) {
					try (InputStream content = ListLayersCommandTests.class.getResourceAsStream(resource)) {
						assertThat(content).as('Resource ' + resource).isNotNull();
						StreamUtils.copy(content, jar);
					}
				}
				jar.closeEntry();
			}
		}
		return file;
	}
	TestPrintStream runCommand(CommandFactory<?> commandFactory, File archive, String... arguments) {
		Context context = new Context(archive, this.tempDir);
		Command command = commandFactory.create(context);
		TestPrintStream out = new TestPrintStream(this);
		command.run(out, new ArrayDeque<>(Arrays.asList(arguments)));
		return out;
	}
	Manifest getJarManifest(File jar) throws IOException {
		try (JarFile jarFile = new JarFile(jar)) {
			return jarFile.getManifest();
		}
	}
	Map<String, String> getJarManifestAttributes(File jar) throws IOException {
		assertThat(jar).exists();
		Manifest manifest = getJarManifest(jar);
		Map<String, String> result = new HashMap<>();
		manifest.getMainAttributes().forEach((key, value) -> result.put(key.toString(), value.toString()));
		return result;
	}
	List<String> getJarEntryNames(File jar) throws IOException {
		assertThat(jar).exists();
		try (JarFile jarFile = new JarFile(jar)) {
			return jarFile.stream().map(ZipEntry::getName).toList();
		}
	}
	List<String> listFilenames() throws IOException {
		return listFilenames(this.tempDir);
	}
	List<String> listFilenames(File directory) throws IOException {
		try (Stream<Path> stream = Files.walk(directory.toPath())) {
			int substring = directory.getAbsolutePath().length() + 1;
			return stream.map((file) -> file.toAbsolutePath().toString())
				.map((file) -> (file.length() >= substring) ? file.substring(substring) : '')
				.filter(StringUtils::hasLength)
				.map((file) -> file.replace(File.separatorChar, "/"))
				.toList();
		}
	}
	interface CommandFactory<T extends Command> {
		T create(Context context);
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class IndexedJarStructureTests {
	@Test
	void shouldResolveLibraryEntry() throws IOException {
		IndexedJarStructure structure = createStructure();
		Entry entry = structure.resolve('BOOT-INF/lib/spring-webmvc-6.1.4.jar');
		assertThat(entry.location()).isEqualTo('spring-webmvc-6.1.4.jar');
		assertThat(entry.originalLocation()).isEqualTo('BOOT-INF/lib/spring-webmvc-6.1.4.jar');
		assertThat(entry.type()).isEqualTo(Type.LIBRARY);
	}
	@Test
	void shouldResolveApplicationEntry() throws IOException {
		IndexedJarStructure structure = createStructure();
		Entry entry = structure.resolve('BOOT-INF/classes/application.properties');
		assertThat(entry.location()).isEqualTo('application.properties');
		assertThat(entry.originalLocation()).isEqualTo('BOOT-INF/classes/application.properties');
		assertThat(entry.type()).isEqualTo(Type.APPLICATION_CLASS_OR_RESOURCE);
	}
	@Test
	void shouldResolveLoaderEntry() throws IOException {
		IndexedJarStructure structure = createStructure();
		Entry entry = structure.resolve('org/springframework/boot/loader/launch/JarLauncher');
		assertThat(entry.location()).isEqualTo('org/springframework/boot/loader/launch/JarLauncher');
		assertThat(entry.originalLocation()).isEqualTo('org/springframework/boot/loader/launch/JarLauncher');
		assertThat(entry.type()).isEqualTo(Type.LOADER);
	}
	@Test
	void shouldNotResolveNonExistingLibs() throws IOException {
		IndexedJarStructure structure = createStructure();
		Entry entry = structure.resolve('BOOT-INF/lib/doesnt-exists.jar');
		assertThat(entry).isNull();
	}
	@Test
	void shouldCreateLauncherManifest() throws IOException {
		IndexedJarStructure structure = createStructure();
		Manifest manifest = structure.createLauncherManifest(UnaryOperator.identity());
		Map<String, String> attributes = getAttributes(manifest);
		assertThat(attributes).containsEntry('Manifest-Version', '1.0')
			.containsEntry('Implementation-Title', 'IndexedJarStructureTests')
			.containsEntry('Spring-Boot-Version', '3.3.0-SNAPSHOT')
			.containsEntry('Implementation-Version', '0.0.1-SNAPSHOT')
			.containsEntry('Build-Jdk-Spec', '17')
			.containsEntry('Class-Path',
					'spring-webmvc-6.1.4.jar spring-web-6.1.4.jar spring-boot-autoconfigure-3.3.0-SNAPSHOT.jar spring-boot-3.3.0-SNAPSHOT.jar jakarta.annotation-api-2.1.1.jar spring-context-6.1.4.jar spring-aop-6.1.4.jar spring-beans-6.1.4.jar spring-expression-6.1.4.jar spring-core-6.1.4.jar snakeyaml-2.2.jar jackson-datatype-jdk8-2.16.1.jar jackson-datatype-jsr310-2.16.1.jar jackson-module-parameter-names-2.16.1.jar jackson-databind-2.16.1.jar tomcat-embed-websocket-10.1.19.jar tomcat-embed-core-10.1.19.jar tomcat-embed-el-10.1.19.jar micrometer-observation-1.13.0-M1.jar logback-classic-1.4.14.jar log4j-to-slf4j-2.23.0.jar jul-to-slf4j-2.0.12.jar spring-jcl-6.1.4.jar jackson-annotations-2.16.1.jar jackson-core-2.16.1.jar micrometer-commons-1.13.0-M1.jar logback-core-1.4.14.jar slf4j-api-2.0.12.jar log4j-api-2.23.0.jar')
			.containsEntry('Main-Class', 'org.springframework.boot.jarmode.tools.IndexedJarStructureTests')
			.doesNotContainKeys('Start-Class', 'Spring-Boot-Classes', 'Spring-Boot-Lib', 'Spring-Boot-Classpath-Index',
					'Spring-Boot-Layers-Index');
	}
	@Test
	void shouldLoadFromFile(@TempDir File tempDir) throws IOException {
		File jarFile = new File(tempDir, 'test.jar');
		try (JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(jarFile), createManifest())) {
			outputStream.putNextEntry(new ZipEntry('BOOT-INF/classpath.idx'));
			outputStream.write(createIndexFile().getBytes(StandardCharsets.UTF_8));
			outputStream.closeEntry();
		}
		IndexedJarStructure structure = IndexedJarStructure.get(jarFile);
		assertThat(structure).isNotNull();
		assertThat(structure.resolve('BOOT-INF/lib/spring-webmvc-6.1.4.jar')).extracting(Entry::type)
			.isEqualTo(Type.LIBRARY);
		assertThat(structure.resolve('BOOT-INF/classes/application.properties')).extracting(Entry::type)
			.isEqualTo(Type.APPLICATION_CLASS_OR_RESOURCE);
	}
	private Map<String, String> getAttributes(Manifest manifest) {
		Map<String, String> result = new HashMap<>();
		manifest.getMainAttributes().forEach((key, value) -> result.put(key.toString(), value.toString()));
		return result;
	}
	private IndexedJarStructure createStructure() throws IOException {
		return new IndexedJarStructure(createManifest(), createIndexFile());
	}
	private String createIndexFile() {
		return '''
				- 'BOOT-INF/lib/spring-webmvc-6.1.4.jar'
				- 'BOOT-INF/lib/spring-web-6.1.4.jar'
				- 'BOOT-INF/lib/spring-boot-autoconfigure-3.3.0-SNAPSHOT.jar'
				- 'BOOT-INF/lib/spring-boot-3.3.0-SNAPSHOT.jar'
				- 'BOOT-INF/lib/jakarta.annotation-api-2.1.1.jar'
				- 'BOOT-INF/lib/spring-context-6.1.4.jar'
				- 'BOOT-INF/lib/spring-aop-6.1.4.jar'
				- 'BOOT-INF/lib/spring-beans-6.1.4.jar'
				- 'BOOT-INF/lib/spring-expression-6.1.4.jar'
				- 'BOOT-INF/lib/spring-core-6.1.4.jar'
				- 'BOOT-INF/lib/snakeyaml-2.2.jar'
				- 'BOOT-INF/lib/jackson-datatype-jdk8-2.16.1.jar'
				- 'BOOT-INF/lib/jackson-datatype-jsr310-2.16.1.jar'
				- 'BOOT-INF/lib/jackson-module-parameter-names-2.16.1.jar'
				- 'BOOT-INF/lib/jackson-databind-2.16.1.jar'
				- 'BOOT-INF/lib/tomcat-embed-websocket-10.1.19.jar'
				- 'BOOT-INF/lib/tomcat-embed-core-10.1.19.jar'
				- 'BOOT-INF/lib/tomcat-embed-el-10.1.19.jar'
				- 'BOOT-INF/lib/micrometer-observation-1.13.0-M1.jar'
				- 'BOOT-INF/lib/logback-classic-1.4.14.jar'
				- 'BOOT-INF/lib/log4j-to-slf4j-2.23.0.jar'
				- 'BOOT-INF/lib/jul-to-slf4j-2.0.12.jar'
				- 'BOOT-INF/lib/spring-jcl-6.1.4.jar'
				- 'BOOT-INF/lib/jackson-annotations-2.16.1.jar'
				- 'BOOT-INF/lib/jackson-core-2.16.1.jar'
				- 'BOOT-INF/lib/micrometer-commons-1.13.0-M1.jar'
				- 'BOOT-INF/lib/logback-core-1.4.14.jar'
				- 'BOOT-INF/lib/slf4j-api-2.0.12.jar'
				- 'BOOT-INF/lib/log4j-api-2.23.0.jar'
				''';
	}
	private Manifest createManifest() throws IOException {
		return new Manifest(new ByteArrayInputStream('''
				Manifest-Version: 1.0
				Main-Class: org.springframework.boot.loader.launch.JarLauncher
				Start-Class: org.springframework.boot.jarmode.tools.IndexedJarStructureTests
				Spring-Boot-Version: 3.3.0-SNAPSHOT
				Spring-Boot-Classes: BOOT-INF/classes/
				Spring-Boot-Lib: BOOT-INF/lib/
				Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx
				Spring-Boot-Layers-Index: BOOT-INF/layers.idx
				Build-Jdk-Spec: 17
				Implementation-Title: IndexedJarStructureTests
				Implementation-Version: 0.0.1-SNAPSHOT
				'''.getBytes(StandardCharsets.UTF_8)));
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class IndexedLayersTests {
	@TempDir
	File temp;
	@Test
	void createWhenIndexFileIsEmptyThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new IndexedLayers(' \n ', 'BOOT-INF/classes'))
			.withMessage('Empty layer index file loaded');
	}
	@Test
	void createWhenIndexFileIsMalformedThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new IndexedLayers('test', 'BOOT-INF/classes'))
			.withMessage('Layer index file is malformed');
	}
	@Test
	void iteratorReturnsLayers() throws Exception {
		IndexedLayers layers = new IndexedLayers(getIndex(), 'BOOT-INF/classes');
		assertThat(layers).containsExactly('test', 'empty', 'application');
	}
	@Test
	void getLayerWhenMatchesNameReturnsLayer() throws Exception {
		IndexedLayers layers = new IndexedLayers(getIndex(), 'BOOT-INF/classes');
		assertThat(layers.getLayer(mockEntry('BOOT-INF/lib/a.jar'))).isEqualTo('test');
		assertThat(layers.getLayer(mockEntry('BOOT-INF/classes/Demo.class'))).isEqualTo('application');
	}
	@Test
	void getLayerWhenMatchesNameForMissingLayerThrowsException() throws Exception {
		IndexedLayers layers = new IndexedLayers(getIndex(), 'BOOT-INF/classes');
		assertThatIllegalStateException().isThrownBy(() -> layers.getLayer(mockEntry('file.jar')))
			.withMessage('No layer defined in index for file ' + '"file.jar"');
	}
	@Test
	void getLayerWhenMatchesDirectoryReturnsLayer() throws Exception {
		IndexedLayers layers = new IndexedLayers(getIndex(), 'BOOT-INF/classes');
		assertThat(layers.getLayer(mockEntry('META-INF/MANIFEST.MF'))).isEqualTo('application');
		assertThat(layers.getLayer(mockEntry('META-INF/a/sub/directory/and/a/file'))).isEqualTo('application');
	}
	@Test
	void getLayerWhenFileHasSpaceReturnsLayer() throws Exception {
		IndexedLayers layers = new IndexedLayers(getIndex(), 'BOOT-INF/classes');
		assertThat(layers.getLayer(mockEntry('a b/c d'))).isEqualTo('application');
	}
	@Test
	void getShouldReturnIndexedLayersFromContext() throws Exception {
		Context context = mock(Context.class);
		given(context.getArchiveFile()).willReturn(createWarFile('test.war'));
		IndexedLayers layers = IndexedLayers.get(context);
		assertThat(layers.getLayer(mockEntry('WEB-INF/lib/a.jar'))).isEqualTo('test');
	}
	private String getIndex() throws Exception {
		return getFile('test-layers.idx');
	}
	private String getFile(String fileName) throws Exception {
		ClassPathResource resource = new ClassPathResource(fileName, getClass());
		InputStreamReader reader = new InputStreamReader(resource.getInputStream());
		return FileCopyUtils.copyToString(reader);
	}
	private ZipEntry mockEntry(String name) {
		ZipEntry entry = mock(ZipEntry.class);
		given(entry.getName()).willReturn(name);
		return entry;
	}
	private File createWarFile(String name) throws Exception {
		File file = new File(this.temp, name);
		try (ZipOutputStream out = new ZipOutputStream(new FileOutputStream(file))) {
			out.putNextEntry(new ZipEntry('WEB-INF/lib/a/'));
			out.closeEntry();
			out.putNextEntry(new ZipEntry('WEB-INF/lib/a/a.jar'));
			out.closeEntry();
			out.putNextEntry(new ZipEntry('WEB-INF/classes/Demo.class'));
			out.closeEntry();
			out.putNextEntry(new ZipEntry('META-INF/MANIFEST.MF'));
			out.write(getFile('test-war-manifest.MF').getBytes());
			out.closeEntry();
			out.putNextEntry(new ZipEntry('WEB-INF/layers.idx'));
			out.write(getFile('test-war-layers.idx').getBytes());
			out.closeEntry();
		}
		return file;
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class ExtractCommandTests extends AbstractJarModeTests {
	private static final Instant CREATION_TIME = Instant.parse('2020-01-01T00:00:00Z');
	private static final Instant LAST_MODIFIED_TIME = Instant.parse('2021-01-01T00:00:00Z');
	private static final Instant LAST_ACCESS_TIME = Instant.parse('2022-01-01T00:00:00Z');
	private Manifest manifest;
	private File archive;
	@BeforeEach
	void setUp() throws IOException {
		this.manifest = createManifest('Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx',
				'Spring-Boot-Lib: BOOT-INF/lib/', 'Spring-Boot-Classes: BOOT-INF/classes/',
				'Start-Class: org.example.Main', 'Spring-Boot-Layers-Index: BOOT-INF/layers.idx',
				'Some-Attribute: Some-Value');
		this.archive = createArchive(this.manifest, CREATION_TIME, LAST_MODIFIED_TIME, LAST_ACCESS_TIME,
				'BOOT-INF/classpath.idx', '/jar-contents/classpath.idx', 'BOOT-INF/layers.idx',
				'/jar-contents/layers.idx', 'BOOT-INF/lib/dependency-1.jar', '/jar-contents/dependency-1',
				'BOOT-INF/lib/dependency-2.jar', '/jar-contents/dependency-2', 'BOOT-INF/lib/dependency-3-SNAPSHOT.jar',
				'/jar-contents/dependency-3-SNAPSHOT', 'org/springframework/boot/loader/launch/JarLauncher.class',
				'/jar-contents/JarLauncher', 'BOOT-INF/classes/application.properties',
				'/jar-contents/application.properties', 'META-INF/build-info.properties',
				'/jar-contents/build-info.properties');
	}
	private File file(String name) {
		return new File(this.tempDir, name);
	}
	private TestPrintStream run(File archive, String... args) {
		return runCommand(ExtractCommand::new, archive, args);
	}
	private void timeAttributes(File file) {
		try {
			BasicFileAttributes basicAttributes = Files
				.getFileAttributeView(file.toPath(), BasicFileAttributeView.class)
				.readAttributes();
			assertThat(basicAttributes.lastModifiedTime().toInstant().truncatedTo(ChronoUnit.SECONDS))
				.as('last modified time')
				.isEqualTo(LAST_MODIFIED_TIME.truncatedTo(ChronoUnit.SECONDS));
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	@Nested
	class Extract {
		@Test
		void extractLibrariesAndCreatesApplication() throws IOException {
			run(ExtractCommandTests.this.archive);
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('test/lib/dependency-1.jar')
				.contains('test/lib/dependency-2.jar')
				.contains('test/lib/dependency-3-SNAPSHOT.jar')
				.contains('test/test.jar')
				.doesNotContain('test/org/springframework/boot/loader/launch/JarLauncher.class');
		}
		@Test
		void extractLibrariesAndCreatesApplicationInDestination() throws IOException {
			run(ExtractCommandTests.this.archive, '--destination', file('out').getAbsolutePath());
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('out/lib/dependency-1.jar')
				.contains('out/lib/dependency-2.jar')
				.contains('out/lib/dependency-3-SNAPSHOT.jar')
				.contains('out/test.jar');
		}
		@Test
		void applicationNameAndLibrariesDirectoriesCanBeCustomized() throws IOException {
			run(ExtractCommandTests.this.archive, '--application-filename', 'application-customized.jar', '--libraries',
					'dependencies');
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('test/dependencies/dependency-1.jar')
				.contains('test/dependencies/dependency-2.jar')
				.contains('test/dependencies/dependency-3-SNAPSHOT.jar');
			File application = file('test/application-customized.jar');
			assertThat(application).exists();
			Map<String, String> attributes = getJarManifestAttributes(application);
			assertThat(attributes).containsEntry('Class-Path',
					'dependencies/dependency-1.jar dependencies/dependency-2.jar dependencies/dependency-3-SNAPSHOT.jar');
		}
		@Test
		void applicationContainsManifestEntries() throws IOException {
			run(ExtractCommandTests.this.archive);
			File application = file('test/test.jar');
			Map<String, String> attributes = getJarManifestAttributes(application);
			assertThat(attributes).containsEntry('Main-Class', 'org.example.Main')
				.containsEntry('Class-Path', 'lib/dependency-1.jar lib/dependency-2.jar lib/dependency-3-SNAPSHOT.jar')
				.containsEntry('Some-Attribute', 'Some-Value')
				.doesNotContainKeys('Start-Class', 'Spring-Boot-Classes', 'Spring-Boot-Lib',
						'Spring-Boot-Classpath-Index', 'Spring-Boot-Layers-Index');
		}
		@Test
		void applicationContainsApplicationClassesAndResources() throws IOException {
			run(ExtractCommandTests.this.archive);
			File application = file('test/test.jar');
			List<String> entryNames = getJarEntryNames(application);
			assertThat(entryNames).contains('application.properties');
		}
		@Test
		void appliesFileTimes() {
			run(ExtractCommandTests.this.archive);
			assertThat(file('test/lib/dependency-1.jar')).exists().satisfies(ExtractCommandTests.this::timeAttributes);
			assertThat(file('test/lib/dependency-2.jar')).exists().satisfies(ExtractCommandTests.this::timeAttributes);
			assertThat(file('test/lib/dependency-3-SNAPSHOT.jar')).exists()
				.satisfies(ExtractCommandTests.this::timeAttributes);
		}
		@Test
		void applicationDoesntContainLibraries() throws IOException {
			run(ExtractCommandTests.this.archive);
			File application = file('test/test.jar');
			List<String> entryNames = getJarEntryNames(application);
			assertThat(entryNames).doesNotContain('BOOT-INF/lib/dependency-1.jar', 'BOOT-INF/lib/dependency-2.jar');
		}
		@Test
		void failsOnIncompatibleJar() throws IOException {
			File file = file('empty.jar');
			try (FileWriter writer = new FileWriter(file)) {
				writer.write('text');
			}
			TestPrintStream out = run(file);
			assertThat(out).contains('is not compatible; ensure jar file is valid and launch script is not enabled');
		}
		@Test
		void shouldFailIfDirectoryIsNotEmpty() throws IOException {
			File destination = file('out');
			Files.createDirectories(destination.toPath());
			Files.createFile(new File(destination, 'file.txt').toPath());
			TestPrintStream out = run(ExtractCommandTests.this.archive, '--destination', destination.getAbsolutePath());
			assertThat(out).contains('already exists and is not empty');
		}
		@Test
		void shouldNotFailIfDirectoryExistsButIsEmpty() throws IOException {
			File destination = file('out');
			Files.createDirectories(destination.toPath());
			run(ExtractCommandTests.this.archive, '--destination', destination.getAbsolutePath());
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('out/lib/dependency-1.jar')
				.contains('out/lib/dependency-2.jar')
				.contains('out/lib/dependency-3-SNAPSHOT.jar')
				.contains('out/test.jar');
		}
		@Test
		void shouldNotFailIfDirectoryIsNotEmptyButForceIsPassed() throws IOException {
			File destination = file('out');
			Files.createDirectories(destination.toPath());
			Files.createFile(new File(destination, 'file.txt').toPath());
			run(ExtractCommandTests.this.archive, '--destination', destination.getAbsolutePath(), '--force');
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('out/lib/dependency-1.jar')
				.contains('out/lib/dependency-2.jar')
				.contains('out/lib/dependency-3-SNAPSHOT.jar')
				.contains('out/test.jar');
		}
		@Test
		void shouldExtractFilesUnderMetaInf() throws IOException {
			run(ExtractCommandTests.this.archive);
			File application = file('test/test.jar');
			List<String> entryNames = getJarEntryNames(application);
			assertThat(entryNames).contains('META-INF/build-info.properties');
		}
		@Test
		void shouldNotFailOnDuplicateDirectories() throws IOException {
			File file = createArchive(ExtractCommandTests.this.manifest, 'BOOT-INF/classpath.idx',
					'/jar-contents/classpath.idx', 'META-INF/native-image/', '/jar-contents/empty-file',
					'BOOT-INF/classes/META-INF/native-image/', '/jar-contents/empty-file');
			run(file);
			File application = file('test/test.jar');
			List<String> entryNames = getJarEntryNames(application);
			assertThat(entryNames).containsExactlyInAnyOrder('META-INF/native-image/', 'META-INF/MANIFEST.MF');
		}
		@Test
		void shouldFailOnDuplicateFiles() throws IOException {
			File file = createArchive(ExtractCommandTests.this.manifest, 'BOOT-INF/classpath.idx',
					'/jar-contents/classpath.idx', 'META-INF/native-image/native-image.properties',
					'/jar-contents/empty-file', 'BOOT-INF/classes/META-INF/native-image/native-image.properties',
					'/jar-contents/empty-file');
			assertThatIllegalStateException().isThrownBy(() -> run(file))
				.withMessage(
						'Duplicate jar entry "META-INF/native-image/native-image.properties" from original location "BOOT-INF/classes/META-INF/native-image/native-image.properties"');
		}
	}
	@Nested
	class ExtractWithLayers {
		@Test
		void extractLibrariesAndCreatesApplication() throws IOException {
			run(ExtractCommandTests.this.archive, '--layers');
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('test/dependencies/lib/dependency-1.jar')
				.contains('test/dependencies/lib/dependency-2.jar')
				.contains('test/snapshot-dependencies/lib/dependency-3-SNAPSHOT.jar')
				.contains('test/application/test.jar');
		}
		@Test
		void extractsOnlySelectedLayers() throws IOException {
			run(ExtractCommandTests.this.archive, '--layers', 'dependencies');
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('test/dependencies/lib/dependency-1.jar')
				.contains('test/dependencies/lib/dependency-2.jar')
				.doesNotContain('test/snapshot-dependencies/lib/dependency-3-SNAPSHOT.jar')
				.doesNotContain('test/application/test.jar');
		}
		@Test
		void printErrorIfLayersAreNotEnabled() throws IOException {
			File archive = createArchive();
			TestPrintStream out = run(archive, '--layers');
			assertThat(out).hasSameContentAsResource('ExtractCommand-printErrorIfLayersAreNotEnabled.txt');
		}
	}
	@Nested
	class ExtractLauncher {
		@Test
		void extract() throws IOException {
			run(ExtractCommandTests.this.archive, '--launcher');
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('test/META-INF/MANIFEST.MF')
				.contains('test/BOOT-INF/classpath.idx')
				.contains('test/BOOT-INF/layers.idx')
				.contains('test/BOOT-INF/lib/dependency-1.jar')
				.contains('test/BOOT-INF/lib/dependency-2.jar')
				.contains('test/BOOT-INF/lib/dependency-3-SNAPSHOT.jar')
				.contains('test/BOOT-INF/classes/application.properties')
				.contains('test/org/springframework/boot/loader/launch/JarLauncher.class');
		}
		@Test
		void runWithJarFileThatWouldWriteEntriesOutsideDestinationFails() throws Exception {
			File file = createArchive('e/../../e.jar', null);
			assertThatIllegalStateException().isThrownBy(() -> run(file, '--launcher'))
				.withMessageContaining('Entry "e/../../e.jar" would be written');
		}
	}
	@Nested
	class ExtractLauncherWithLayers {
		@Test
		void extract() throws IOException {
			run(ExtractCommandTests.this.archive, '--launcher', '--layers');
			List<String> filenames = listFilenames();
			assertThat(filenames).contains('test/application/META-INF/MANIFEST.MF')
				.contains('test/application/BOOT-INF/classpath.idx')
				.contains('test/application/BOOT-INF/layers.idx')
				.contains('test/dependencies/BOOT-INF/lib/dependency-1.jar')
				.contains('test/dependencies/BOOT-INF/lib/dependency-2.jar')
				.contains('test/snapshot-dependencies/BOOT-INF/lib/dependency-3-SNAPSHOT.jar')
				.contains('test/application/BOOT-INF/classes/application.properties')
				.contains('test/spring-boot-loader/org/springframework/boot/loader/launch/JarLauncher.class');
		}
		@Test
		void printErrorIfLayersAreNotEnabled() throws IOException {
			File archive = createArchive();
			TestPrintStream out = run(archive, '--launcher', '--layers');
			assertThat(out).hasSameContentAsResource('ExtractCommand-printErrorIfLayersAreNotEnabled.txt');
		}
		@Test
		void extractsOnlySelectedLayers() throws IOException {
			run(ExtractCommandTests.this.archive, '--launcher', '--layers', 'dependencies');
			List<String> filenames = listFilenames();
			assertThat(filenames).doesNotContain('test/application/META-INF/MANIFEST.MF')
				.doesNotContain('test/application/BOOT-INF/classpath.idx')
				.doesNotContain('test/application/BOOT-INF/layers.idx')
				.contains('test/dependencies/BOOT-INF/lib/dependency-1.jar')
				.contains('test/dependencies/BOOT-INF/lib/dependency-2.jar')
				.doesNotContain('test/snapshot-dependencies/BOOT-INF/lib/dependency-3-SNAPSHOT.jar')
				.doesNotContain('test/application/BOOT-INF/classes/application.properties')
				.doesNotContain('test/spring-boot-loader/org/springframework/boot/loader/launch/JarLauncher.class');
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class HelpCommandTests {
	private HelpCommand command;
	private TestPrintStream out;
	@TempDir
	Path temp;
	@BeforeEach
	void setup() {
		Context context = Mockito.mock(Context.class);
		given(context.getArchiveFile()).willReturn(this.temp.resolve('test.jar').toFile());
		this.command = new HelpCommand(context, List.of(new TestCommand()), 'tools');
		this.out = new TestPrintStream(this);
	}
	@Test
	void shouldPrintAllCommands() {
		this.command.run(this.out, Collections.emptyList());
		assertThat(this.out).hasSameContentAsResource('help-output.txt');
	}
	@Test
	void shouldPrintCommandSpecificHelp() {
		this.command.run(this.out, List.of('test'));
		System.out.println(this.out);
		assertThat(this.out).hasSameContentAsResource('help-test-output.txt');
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class IndexedJarStructure implements JarStructure {
	private static final List<String> MANIFEST_DENY_LIST = List.of('Start-Class', 'Spring-Boot-Classes',
			'Spring-Boot-Lib', 'Spring-Boot-Classpath-Index', 'Spring-Boot-Layers-Index');
	private static final Set<String> ENTRY_IGNORE_LIST = Set.of('META-INF/', 'META-INF/MANIFEST.MF',
			'META-INF/services/java.nio.file.spi.FileSystemProvider');
	private final Manifest originalManifest;
	private final String libLocation;
	private final String classesLocation;
	private final List<String> classpathEntries;
	IndexedJarStructure(Manifest originalManifest, String indexFile) {
		this.originalManifest = originalManifest;
		this.libLocation = getLocation(originalManifest, 'Spring-Boot-Lib');
		this.classesLocation = getLocation(originalManifest, 'Spring-Boot-Classes');
		this.classpathEntries = readIndexFile(indexFile);
	}
	private static String getLocation(Manifest manifest, String attribute) {
		String location = getMandatoryAttribute(manifest, attribute);
		return (!location.endsWith('/')) ? location + '/' : location;
	}
	private static List<String> readIndexFile(String indexFile) {
		String[] lines = Arrays.stream(indexFile.split('\n'))
			.map((line) -> line.replace('\r', ''))
			.filter(StringUtils::hasText)
			.toArray(String[]::new);
		List<String> classpathEntries = new ArrayList<>();
		for (String line : lines) {
			Assert.state(line.startsWith('- '), 'Classpath index file is malformed');
			classpathEntries.add(line.substring(3, line.length() - 1));
		}
		Assert.state(!classpathEntries.isEmpty(), 'Empty classpath index file loaded');
		return classpathEntries;
	}
	@Override
	public String getClassesLocation() {
		return this.classesLocation;
	}
	@Override
	public Entry resolve(String name) {
		if (ENTRY_IGNORE_LIST.contains(name)) {
			return null;
		}
		if (this.classpathEntries.contains(name)) {
			return new Entry(name, toStructureDependency(name), Type.LIBRARY);
		}
		if (name.startsWith(this.classesLocation)) {
			return new Entry(name, name.substring(this.classesLocation.length()), Type.APPLICATION_CLASS_OR_RESOURCE);
		}
		if (name.startsWith('org/springframework/boot/loader')) {
			return new Entry(name, name, Type.LOADER);
		}
		if (name.startsWith('META-INF/')) {
			return new Entry(name, name, Type.META_INF);
		}
		return null;
	}
	@Override
	public Manifest createLauncherManifest(UnaryOperator<String> libraryTransformer) {
		Manifest manifest = new Manifest(this.originalManifest);
		Attributes attributes = manifest.getMainAttributes();
		for (String denied : MANIFEST_DENY_LIST) {
			attributes.remove(new Name(denied));
		}
		attributes.put(Name.MAIN_CLASS, getMandatoryAttribute(this.originalManifest, 'Start-Class'));
		attributes.put(Name.CLASS_PATH,
				this.classpathEntries.stream()
					.map(this::toStructureDependency)
					.map(libraryTransformer)
					.collect(Collectors.joining(' ')));
		return manifest;
	}
	private String toStructureDependency(String libEntryName) {
		Assert.state(libEntryName.startsWith(this.libLocation), 'Invalid library location ' + libEntryName);
		return libEntryName.substring(this.libLocation.length());
	}
	private static String getMandatoryAttribute(Manifest manifest, String attribute) {
		String value = manifest.getMainAttributes().getValue(attribute);
		Assert.state(value != null, 'Manifest attribute "' + attribute + '" is mandatory');
		return value;
	}
	static IndexedJarStructure get(File file) {
		try {
			try (JarFile jarFile = new JarFile(file)) {
				Manifest manifest = jarFile.getManifest();
				String location = getMandatoryAttribute(manifest, 'Spring-Boot-Classpath-Index');
				ZipEntry entry = jarFile.getEntry(location);
				if (entry != null) {
					String indexFile = StreamUtils.copyToString(jarFile.getInputStream(entry), StandardCharsets.UTF_8);
					return new IndexedJarStructure(manifest, indexFile);
				}
			}
			return null;
		}
		catch (FileNotFoundException | NoSuchFileException ex) {
			return null;
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class IndexedLayers implements Layers {
	private final Map<String, List<String>> layers = new LinkedHashMap<>();
	private final String classesLocation;
	IndexedLayers(String indexFile, String classesLocation) {
		this.classesLocation = classesLocation;
		String[] lines = Arrays.stream(indexFile.split('\n'))
			.map((line) -> line.replace('\r', ''))
			.filter(StringUtils::hasText)
			.toArray(String[]::new);
		List<String> contents = null;
		for (String line : lines) {
			if (line.startsWith('- ')) {
				contents = new ArrayList<>();
				this.layers.put(line.substring(3, line.length() - 2), contents);
			}
			else if (line.startsWith('  - ')) {
				Assert.notNull(contents, 'Contents must not be null. Check if the index file is malformed!');
				contents.add(line.substring(5, line.length() - 1));
			}
			else {
				throw new IllegalStateException('Layer index file is malformed');
			}
		}
		Assert.state(!this.layers.isEmpty(), 'Empty layer index file loaded');
	}
	@Override
	public String getApplicationLayerName() {
		return getLayer(this.classesLocation);
	}
	@Override
	public Iterator<String> iterator() {
		return this.layers.keySet().iterator();
	}
	@Override
	public String getLayer(String name) {
		for (Map.Entry<String, List<String>> entry : this.layers.entrySet()) {
			for (String candidate : entry.getValue()) {
				if (candidate.equals(name) || (candidate.endsWith('/') && name.startsWith(candidate))) {
					return entry.getKey();
				}
			}
		}
		throw new IllegalStateException('No layer defined in index for file "' + name + '"');
	}
	/**
	 * Get an {@link IndexedLayers} instance of possible.
	 * @param context the context
	 * @return an {@link IndexedLayers} instance or {@code null} if this not a layered
	 * jar.
	 */
	static IndexedLayers get(Context context) {
		try {
			try (JarFile jarFile = new JarFile(context.getArchiveFile())) {
				Manifest manifest = jarFile.getManifest();
				String location = manifest.getMainAttributes().getValue('Spring-Boot-Layers-Index');
				ZipEntry entry = (location != null) ? jarFile.getEntry(location) : null;
				if (entry != null) {
					String indexFile = StreamUtils.copyToString(jarFile.getInputStream(entry), StandardCharsets.UTF_8);
					String classesLocation = manifest.getMainAttributes().getValue('Spring-Boot-Classes');
					return new IndexedLayers(indexFile, classesLocation);
				}
			}
			return null;
		}
		catch (FileNotFoundException | NoSuchFileException ex) {
			return null;
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class Context {
	private final File archiveFile;
	private final File workingDir;
	private final String relativeDir;
	/**
	 * Create a new {@link Context} instance.
	 */
	Context() {
		this(getSourceArchiveFile(), Paths.get('.').toAbsolutePath().normalize().toFile());
	}
	/**
	 * Create a new {@link Context} instance with the specified value.
	 * @param archiveFile the source archive file
	 * @param workingDir the working directory
	 */
	Context(File archiveFile, File workingDir) {
		Assert.state(isExistingFile(archiveFile), 'Unable to find source archive');
		Assert.state(isJarOrWar(archiveFile), 'Source archive ' + archiveFile + ' must end with .jar or .war');
		this.archiveFile = archiveFile;
		this.workingDir = workingDir;
		this.relativeDir = deduceRelativeDir(archiveFile.getParentFile(), this.workingDir);
	}
	private boolean isExistingFile(File archiveFile) {
		return archiveFile != null && archiveFile.isFile() && archiveFile.exists();
	}
	private boolean isJarOrWar(File jarFile) {
		String name = jarFile.getName().toLowerCase(Locale.ROOT);
		return name.endsWith('.jar') || name.endsWith('.war');
	}
	private static File getSourceArchiveFile() {
		try {
			ProtectionDomain domain = Context.class.getProtectionDomain();
			CodeSource codeSource = (domain != null) ? domain.getCodeSource() : null;
			URL location = (codeSource != null) ? codeSource.getLocation() : null;
			File source = (location != null) ? findSource(location) : null;
			if (source != null && source.exists()) {
				return source.getAbsoluteFile();
			}
			return null;
		}
		catch (Exception ex) {
			return null;
		}
	}
	private static File findSource(URL location) throws IOException, URISyntaxException {
		URLConnection connection = location.openConnection();
		if (connection instanceof JarURLConnection jarURLConnection) {
			return getRootJarFile(jarURLConnection.getJarFile());
		}
		return new File(location.toURI());
	}
	private static File getRootJarFile(JarFile jarFile) {
		String name = jarFile.getName();
		int separator = name.indexOf('!/');
		if (separator > 0) {
			name = name.substring(0, separator);
		}
		return new File(name);
	}
	private String deduceRelativeDir(File sourceDirectory, File workingDir) {
		String sourcePath = sourceDirectory.getAbsolutePath();
		String workingPath = workingDir.getAbsolutePath();
		if (sourcePath.equals(workingPath) || !sourcePath.startsWith(workingPath)) {
			return null;
		}
		String relativePath = sourcePath.substring(workingPath.length() + 1);
		return !relativePath.isEmpty() ? relativePath : null;
	}
	/**
	 * Return the source archive file that is running in tools mode.
	 * @return the archive file
	 */
	File getArchiveFile() {
		return this.archiveFile;
	}
	/**
	 * Return the current working directory.
	 * @return the working dir
	 */
	File getWorkingDir() {
		return this.workingDir;
	}
	/**
	 * Return the directory relative to {@link #getWorkingDir()} that contains the archive
	 * or {@code null} if none relative directory can be deduced.
	 * @return the relative dir ending in {@code /} or {@code null}
	 */
	String getRelativeArchiveDir() {
		return this.relativeDir;
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
abstract class Command {
	private final String name;
	private final String description;
	private final Options options;
	private final Parameters parameters;
	/**
	 * Create a new {@link Command} instance.
	 * @param name the name of the command
	 * @param description a description of the command
	 * @param options the command options
	 * @param parameters the command parameters
	 */
	Command(String name, String description, Options options, Parameters parameters) {
		this.name = name;
		this.description = description;
		this.options = options;
		this.parameters = parameters;
	}
	/**
	 * Return the name of this command.
	 * @return the command name
	 */
	String getName() {
		return this.name;
	}
	/**
	 * Return the description of this command.
	 * @return the command description
	 */
	String getDescription() {
		return this.description;
	}
	/**
	 * Return options that this command accepts.
	 * @return the command options
	 */
	Options getOptions() {
		return this.options;
	}
	/**
	 * Return parameters that this command accepts.
	 * @return the command parameters
	 */
	Parameters getParameters() {
		return this.parameters;
	}
	/**
	 * Run the command by processing the remaining arguments.
	 * @param out stream for command output
	 * @param args a mutable deque of the remaining arguments
	 */
	final void run(PrintStream out, Deque<String> args) {
		List<String> parameters = new ArrayList<>();
		Map<Option, String> options = new HashMap<>();
		while (!args.isEmpty()) {
			String arg = args.removeFirst();
			Option option = this.options.find(arg);
			if (option != null) {
				options.put(option, option.claimArg(args));
			}
			else {
				parameters.add(arg);
			}
		}
		run(out, options, parameters);
	}
	/**
	 * Run the actual command.
	 * @param out stream for command output
	 * @param options any options extracted from the arguments
	 * @param parameters any parameters extracted from the arguments
	 */
	abstract void run(PrintStream out, Map<Option, String> options, List<String> parameters);
	/**
	 * Whether the command is deprecated.
	 * @return whether the command is deprecated
	 */
	boolean isDeprecated() {
		return false;
	}
	/**
	 * Returns the deprecation message.
	 * @return the deprecation message
	 */
	String getDeprecationMessage() {
		return null;
	}
	/**
	 * Static method that can be used to find a single command from a collection.
	 * @param commands the commands to search
	 * @param name the name of the command to find
	 * @return a {@link Command} instance or {@code null}.
	 */
	static Command find(Collection<? extends Command> commands, String name) {
		for (Command command : commands) {
			if (command.getName().equals(name)) {
				return command;
			}
		}
		return null;
	}
	/**
	 * Parameters that the command accepts.
	 */
	static final class Parameters {
		private final List<String> descriptions;
		private Parameters(String[] descriptions) {
			this.descriptions = Collections.unmodifiableList(Arrays.asList(descriptions));
		}
		/**
		 * Return the parameter descriptions.
		 * @return the descriptions
		 */
		List<String> getDescriptions() {
			return this.descriptions;
		}
		@Override
		public String toString() {
			return this.descriptions.toString();
		}
		/**
		 * Factory method used if there are no expected parameters.
		 * @return a new {@link Parameters} instance
		 */
		static Parameters none() {
			return of();
		}
		/**
		 * Factory method used to create a new {@link Parameters} instance with specific
		 * descriptions.
		 * @param descriptions the parameter descriptions
		 * @return a new {@link Parameters} instance with the given descriptions
		 */
		static Parameters of(String... descriptions) {
			return new Parameters(descriptions);
		}
	}
	/**
	 * Options that the command accepts.
	 */
	static final class Options {
		private final Option[] values;
		private Options(Option[] values) {
			this.values = values;
		}
		private Option find(String arg) {
			if (arg.startsWith('--')) {
				String name = arg.substring(2);
				for (Option candidate : this.values) {
					if (candidate.getName().equals(name)) {
						return candidate;
					}
				}
				throw new UnknownOptionException(name);
			}
			return null;
		}
		/**
		 * Return if this options collection is empty.
		 * @return if there are no options
		 */
		boolean isEmpty() {
			return this.values.length == 0;
		}
		/**
		 * Return a stream of each option.
		 * @return a stream of the options
		 */
		Stream<Option> stream() {
			return Arrays.stream(this.values);
		}
		/**
		 * Factory method used if there are no expected options.
		 * @return a new {@link Options} instance
		 */
		static Options none() {
			return of();
		}
		/**
		 * Factory method used to create a new {@link Options} instance with specific
		 * values.
		 * @param values the option values
		 * @return a new {@link Options} instance with the given values
		 */
		static Options of(Option... values) {
			return new Options(values);
		}
	}
	/**
	 * An individual option that the command can accepts. Can either be an option with a
	 * value (e.g. {@literal --log debug}) or a flag (e.g. {@literal
	 * --verbose}). It also can be both if the value is marked as optional.
	 */
	static final class Option {
		private final String name;
		private final String valueDescription;
		private final String description;
		private final boolean optionalValue;
		private Option(String name, String valueDescription, String description, boolean optionalValue) {
			this.name = name;
			this.description = description;
			this.valueDescription = valueDescription;
			this.optionalValue = optionalValue;
		}
		/**
		 * Return the name of the option.
		 * @return the options name
		 */
		String getName() {
			return this.name;
		}
		/**
		 * Return the description of the expected argument value or {@code null} if this
		 * option is a flag/switch.
		 * @return the option value description
		 */
		String getValueDescription() {
			return this.valueDescription;
		}
		/**
		 * Return the name and the value description combined.
		 * @return the name and value description
		 */
		String getNameAndValueDescription() {
			return this.name + ((this.valueDescription != null) ? ' ' + this.valueDescription : '');
		}
		/**
		 * Return a description of the option.
		 * @return the option description
		 */
		String getDescription() {
			return this.description;
		}
		private String claimArg(Deque<String> args) {
			if (this.valueDescription == null) {
				return null;
			}
			if (this.optionalValue) {
				String nextArg = args.peek();
				return (nextArg != null && !nextArg.startsWith('--')) ? args.removeFirst() : null;
			}
			try {
				return args.removeFirst();
			}
			catch (NoSuchElementException ex) {
				throw new MissingValueException(this.name);
			}
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.name.equals(((Option) obj).name);
		}
		@Override
		public int hashCode() {
			return this.name.hashCode();
		}
		@Override
		public String toString() {
			return this.name;
		}
		/**
		 * Factory method to create a flag/switch option.
		 * @param name the name of the option
		 * @param description a description of the option
		 * @return a new {@link Option} instance
		 */
		static Option flag(String name, String description) {
			return new Option(name, null, description, false);
		}
		/**
		 * Factory method to create value option.
		 * @param name the name of the option
		 * @param valueDescription a description of the expected value
		 * @param description a description of the option
		 * @return a new {@link Option} instance
		 */
		static Option of(String name, String valueDescription, String description) {
			return new Option(name, valueDescription, description, false);
		}
		/**
		 * Factory method to create value option.
		 * @param name the name of the option
		 * @param valueDescription a description of the expected value
		 * @param description a description of the option
		 * @param optionalValue whether the value is optional
		 * @return a new {@link Option} instance
		 */
		static Option of(String name, String valueDescription, String description, boolean optionalValue) {
			return new Option(name, valueDescription, description, optionalValue);
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class HelpCommand extends Command {
	private final Context context;
	private final List<Command> commands;
	private final String jarMode;
	HelpCommand(Context context, List<Command> commands) {
		this(context, commands, System.getProperty('jarmode'));
	}
	HelpCommand(Context context, List<Command> commands, String jarMode) {
		super('help', 'Help about any command', Options.none(), Parameters.of('[<command>]'));
		this.context = context;
		this.commands = commands;
		this.jarMode = (jarMode != null) ? jarMode : 'tools';
	}
	@Override
	void run(PrintStream out, Map<Option, String> options, List<String> parameters) {
		run(out, parameters);
	}
	void run(PrintStream out, List<String> parameters) {
		String commandName = (parameters.isEmpty()) ? null : parameters.get(0);
		if (commandName == null) {
			printUsageAndCommands(out);
			return;
		}
		if (getName().equals(commandName)) {
			printCommandHelp(out, this, true);
			return;
		}
		Command command = Command.find(this.commands, commandName);
		if (command == null) {
			printError(out, 'Unknown command \'%s\''.formatted(commandName));
			printUsageAndCommands(out);
			return;
		}
		printCommandHelp(out, command, true);
	}
	void printCommandHelp(PrintStream out, Command command, boolean printDeprecationWarning) {
		if (command.isDeprecated() && printDeprecationWarning) {
			printWarning(out, 'This command is deprecated. ' + command.getDeprecationMessage());
		}
		out.println(command.getDescription());
		out.println();
		out.println('Usage:');
		out.println('  ' + getJavaCommand() + ' ' + getUsage(command));
		if (!command.getOptions().isEmpty()) {
			out.println();
			out.println('Options:');
			int maxNameLength = getMaxLength(0, command.getOptions().stream().map(Option::getNameAndValueDescription));
			command.getOptions().stream().forEach((option) -> printOptionSummary(out, option, maxNameLength));
		}
	}
	private void printOptionSummary(PrintStream out, Option option, int padding) {
		out.printf('  --%-' + padding + 's  %s%n', option.getNameAndValueDescription(), option.getDescription());
	}
	private String getUsage(Command command) {
		StringBuilder usage = new StringBuilder();
		usage.append(command.getName());
		if (!command.getOptions().isEmpty()) {
			usage.append(' [options]');
		}
		command.getParameters().getDescriptions().forEach((param) -> usage.append(' ').append(param));
		return usage.toString();
	}
	private void printUsageAndCommands(PrintStream out) {
		out.println('Usage:');
		out.println('  ' + getJavaCommand());
		out.println();
		out.println('Available commands:');
		int maxNameLength = getMaxLength(getName().length(), this.commands.stream().map(Command::getName));
		this.commands.stream()
			.filter((command) -> !command.isDeprecated())
			.forEach((command) -> printCommandSummary(out, command, maxNameLength));
		printCommandSummary(out, this, maxNameLength);
		List<Command> deprecatedCommands = this.commands.stream().filter(Command::isDeprecated).toList();
		if (!deprecatedCommands.isEmpty()) {
			out.println('Deprecated commands:');
			for (Command command : deprecatedCommands) {
				printCommandSummary(out, command, maxNameLength);
			}
		}
	}
	private int getMaxLength(int minimum, Stream<String> strings) {
		return Math.max(minimum, strings.mapToInt(String::length).max().orElse(0));
	}
	private void printCommandSummary(PrintStream out, Command command, int padding) {
		out.printf('  %-' + padding + 's  %s%n', command.getName(), command.getDescription());
	}
	private String getJavaCommand() {
		return 'java -Djarmode=' + this.jarMode + ' -jar ' + this.context.getArchiveFile().getName();
	}
	private void printError(PrintStream out, String errorMessage) {
		out.println('Error: ' + errorMessage);
		out.println();
	}
	private void printWarning(PrintStream out, String errorMessage) {
		out.println('Warning: ' + errorMessage);
		out.println();
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class ListLayersCommand extends Command {
	private final Context context;
	ListLayersCommand(Context context) {
		super('list-layers', 'List layers from the jar that can be extracted', Options.none(), Parameters.none());
		this.context = context;
	}
	@Override
	void run(PrintStream out, Map<Option, String> options, List<String> parameters) {
		try {
			Layers layers = Layers.get(this.context);
			printLayers(out, layers);
		}
		catch (LayersNotEnabledException ex) {
			printError(out, 'Layers are not enabled');
		}
	}
	void printLayers(PrintStream out, Layers layers) {
		layers.forEach(out::println);
	}
	private void printError(PrintStream out, String message) {
		out.println('Error: ' + message);
		out.println();
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class UnknownOptionException extends RuntimeException {
	private final String optionName;
	UnknownOptionException(String optionName) {
		this.optionName = optionName;
	}
	@Override
	public String getMessage() {
		return '--' + this.optionName;
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class ExtractCommand extends Command {
	/**
	 * Option to create a launcher.
	 */
	static final Option LAUNCHER_OPTION = Option.flag('launcher', 'Whether to extract the Spring Boot launcher');
	/**
	 * Option to extract layers.
	 */
	static final Option LAYERS_OPTION = Option.of('layers', 'string list', 'Layers to extract', true);
	/**
	 * Option to specify the destination to write to.
	 */
	static final Option DESTINATION_OPTION = Option.of('destination', 'string',
			'Directory to extract files to. Defaults to a directory named after the uber JAR (without the file extension)');
	/**
	 * Option to ignore non-empty directory error.
	 */
	static final Option FORCE_OPTION = Option.flag('force', 'Whether to ignore non-empty directories, extract anyway');
	private static final Option LIBRARIES_DIRECTORY_OPTION = Option.of('libraries', 'string',
			'Name of the libraries directory. Only applicable when not using --launcher. Defaults to lib/');
	private static final Option APPLICATION_FILENAME_OPTION = Option.of('application-filename', 'string',
			'Name of the application JAR file. Only applicable when not using --launcher. Defaults to the uber JAR filename');
	private final Context context;
	private final Layers layers;
	ExtractCommand(Context context) {
		this(context, null);
	}
	ExtractCommand(Context context, Layers layers) {
		super('extract', 'Extract the contents from the jar', Options.of(LAUNCHER_OPTION, LAYERS_OPTION,
				DESTINATION_OPTION, LIBRARIES_DIRECTORY_OPTION, APPLICATION_FILENAME_OPTION, FORCE_OPTION),
				Parameters.none());
		this.context = context;
		this.layers = layers;
	}
	@Override
	void run(PrintStream out, Map<Option, String> options, List<String> parameters) {
		try {
			checkJarCompatibility();
			File destination = getDestination(options);
			checkDirectoryIsEmpty(options, destination);
			FileResolver fileResolver = getFileResolver(destination, options);
			fileResolver.createDirectories();
			if (options.containsKey(LAUNCHER_OPTION)) {
				extractArchive(fileResolver);
			}
			else {
				JarStructure jarStructure = getJarStructure();
				extractLibraries(fileResolver, jarStructure, options);
				createApplication(jarStructure, fileResolver, options);
			}
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
		catch (LayersNotEnabledException ex) {
			printError(out, 'Layers are not enabled');
		}
		catch (AbortException ex) {
			printError(out, ex.getMessage());
		}
	}
	private static void checkDirectoryIsEmpty(Map<Option, String> options, File destination) {
		if (options.containsKey(FORCE_OPTION)) {
			return;
		}
		if (!destination.exists()) {
			return;
		}
		if (!destination.isDirectory()) {
			throw new AbortException(destination.getAbsoluteFile() + ' already exists and is not a directory');
		}
		File[] files = destination.listFiles();
		if (files != null && files.length > 0) {
			throw new AbortException(destination.getAbsoluteFile() + ' already exists and is not empty');
		}
	}
	private void checkJarCompatibility() throws IOException {
		File file = this.context.getArchiveFile();
		try (ZipInputStream stream = new ZipInputStream(new FileInputStream(file))) {
			ZipEntry entry = stream.getNextEntry();
			if (entry == null) {
				throw new AbortException(
						'File "%s" is not compatible; ensure jar file is valid and launch script is not enabled'
							.formatted(file));
			}
		}
	}
	private void printError(PrintStream out, String message) {
		out.println('Error: ' + message);
		out.println();
	}
	private void extractLibraries(FileResolver fileResolver, JarStructure jarStructure, Map<Option, String> options)
			throws IOException {
		String librariesDirectory = getLibrariesDirectory(options);
		extractArchive(fileResolver, (jarEntry) -> {
			Entry entry = jarStructure.resolve(jarEntry);
			if (isType(entry, Type.LIBRARY)) {
				return librariesDirectory + entry.location();
			}
			return null;
		});
	}
	private static String getLibrariesDirectory(Map<Option, String> options) {
		if (options.containsKey(LIBRARIES_DIRECTORY_OPTION)) {
			String value = options.get(LIBRARIES_DIRECTORY_OPTION);
			if (value.endsWith('/')) {
				return value;
			}
			return value + '/';
		}
		return 'lib/';
	}
	private FileResolver getFileResolver(File destination, Map<Option, String> options) {
		String applicationFilename = getApplicationFilename(options);
		if (!options.containsKey(LAYERS_OPTION)) {
			return new NoLayersFileResolver(destination, applicationFilename);
		}
		Layers layers = getLayers();
		Set<String> layersToExtract = StringUtils.commaDelimitedListToSet(options.get(LAYERS_OPTION));
		return new LayersFileResolver(destination, layers, layersToExtract, applicationFilename);
	}
	private File getDestination(Map<Option, String> options) {
		if (options.containsKey(DESTINATION_OPTION)) {
			File destination = new File(options.get(DESTINATION_OPTION));
			if (destination.isAbsolute()) {
				return destination;
			}
			return new File(this.context.getWorkingDir(), destination.getPath());
		}
		return new File(this.context.getWorkingDir(), stripExtension(this.context.getArchiveFile().getName()));
	}
	private static String stripExtension(String name) {
		if (name.toLowerCase(Locale.ROOT).endsWith('.jar') || name.toLowerCase(Locale.ROOT).endsWith('.war')) {
			return name.substring(0, name.length() - 4);
		}
		return name;
	}
	private JarStructure getJarStructure() {
		IndexedJarStructure jarStructure = IndexedJarStructure.get(this.context.getArchiveFile());
		Assert.state(jarStructure != null, 'Couldn"t read classpath index');
		return jarStructure;
	}
	private void extractArchive(FileResolver fileResolver) throws IOException {
		extractArchive(fileResolver, JarEntry::getName);
	}
	private void extractArchive(FileResolver fileResolver, EntryNameTransformer entryNameTransformer)
			throws IOException {
		withJarEntries(this.context.getArchiveFile(), (stream, jarEntry) -> {
			if (jarEntry.isDirectory()) {
				return;
			}
			String name = entryNameTransformer.getName(jarEntry);
			if (name == null) {
				return;
			}
			File file = fileResolver.resolve(jarEntry, name);
			if (file != null) {
				extractEntry(stream, jarEntry, file);
			}
		});
	}
	private Layers getLayers() {
		return (this.layers != null) ? this.layers : Layers.get(this.context);
	}
	private void createApplication(JarStructure jarStructure, FileResolver fileResolver, Map<Option, String> options)
			throws IOException {
		File file = fileResolver.resolveApplication();
		if (file == null) {
			return;
		}
		String librariesDirectory = getLibrariesDirectory(options);
		Manifest manifest = jarStructure.createLauncherManifest((library) -> librariesDirectory + library);
		mkdirs(file.getParentFile());
		try (JarOutputStream output = new JarOutputStream(new FileOutputStream(file), manifest)) {
			EnumSet<Type> allowedTypes = EnumSet.of(Type.APPLICATION_CLASS_OR_RESOURCE, Type.META_INF);
			Set<String> writtenEntries = new HashSet<>();
			withJarEntries(this.context.getArchiveFile(), ((stream, jarEntry) -> {
				Entry entry = jarStructure.resolve(jarEntry);
				if (entry != null && allowedTypes.contains(entry.type()) && StringUtils.hasLength(entry.location())) {
					JarEntry newJarEntry = createJarEntry(entry.location(), jarEntry);
					if (writtenEntries.add(newJarEntry.getName())) {
						output.putNextEntry(newJarEntry);
						StreamUtils.copy(stream, output);
						output.closeEntry();
					}
					else {
						if (!newJarEntry.isDirectory()) {
							throw new IllegalStateException('Duplicate jar entry "%s" from original location "%s"'
								.formatted(newJarEntry.getName(), entry.originalLocation()));
						}
					}
				}
			}));
		}
	}
	private String getApplicationFilename(Map<Option, String> options) {
		if (options.containsKey(APPLICATION_FILENAME_OPTION)) {
			return options.get(APPLICATION_FILENAME_OPTION);
		}
		return this.context.getArchiveFile().getName();
	}
	private static boolean isType(Entry entry, Type type) {
		return (entry != null) && entry.type() == type;
	}
	private static void extractEntry(InputStream stream, JarEntry entry, File file) throws IOException {
		mkdirs(file.getParentFile());
		try (OutputStream out = new FileOutputStream(file)) {
			StreamUtils.copy(stream, out);
		}
		try {
			Files.getFileAttributeView(file.toPath(), BasicFileAttributeView.class)
				.setTimes(getLastModifiedTime(entry), getLastAccessTime(entry), getCreationTime(entry));
		}
		catch (IOException ex) {
			// File system does not support setting time attributes. Continue.
		}
	}
	private static FileTime getCreationTime(JarEntry entry) {
		return (entry.getCreationTime() != null) ? entry.getCreationTime() : entry.getLastModifiedTime();
	}
	private static FileTime getLastAccessTime(JarEntry entry) {
		return (entry.getLastAccessTime() != null) ? entry.getLastAccessTime() : getLastModifiedTime(entry);
	}
	private static FileTime getLastModifiedTime(JarEntry entry) {
		return (entry.getLastModifiedTime() != null) ? entry.getLastModifiedTime() : entry.getCreationTime();
	}
	private static void mkdirs(File file) throws IOException {
		if (!file.exists() && !file.mkdirs()) {
			throw new IOException('Unable to create directory ' + file);
		}
	}
	private static JarEntry createJarEntry(String location, JarEntry originalEntry) {
		JarEntry jarEntry = new JarEntry(location);
		FileTime lastModifiedTime = getLastModifiedTime(originalEntry);
		if (lastModifiedTime != null) {
			jarEntry.setLastModifiedTime(lastModifiedTime);
		}
		FileTime lastAccessTime = getLastAccessTime(originalEntry);
		if (lastAccessTime != null) {
			jarEntry.setLastAccessTime(lastAccessTime);
		}
		FileTime creationTime = getCreationTime(originalEntry);
		if (creationTime != null) {
			jarEntry.setCreationTime(creationTime);
		}
		return jarEntry;
	}
	private static void withJarEntries(File file, ThrowingConsumer callback) throws IOException {
		try (JarFile jarFile = new JarFile(file)) {
			Enumeration<JarEntry> entries = jarFile.entries();
			while (entries.hasMoreElements()) {
				JarEntry entry = entries.nextElement();
				if (StringUtils.hasLength(entry.getName())) {
					try (InputStream stream = jarFile.getInputStream(entry)) {
						callback.accept(stream, entry);
					}
				}
			}
		}
	}
	private static File assertFileIsContainedInDirectory(File directory, File file, String name) throws IOException {
		String canonicalOutputPath = directory.getCanonicalPath() + File.separator;
		String canonicalEntryPath = file.getCanonicalPath();
		Assert.state(canonicalEntryPath.startsWith(canonicalOutputPath),
				() -> 'Entry "%s" would be written to "%s". This is outside the output location of "%s". Verify the contents of your archive.'
					.formatted(name, canonicalEntryPath, canonicalOutputPath));
		return file;
	}
	@FunctionalInterface
	private interface EntryNameTransformer {
		String getName(JarEntry entry);
	}
	@FunctionalInterface
	private interface ThrowingConsumer {
		void accept(InputStream stream, JarEntry entry) throws IOException;
	}
	private interface FileResolver {
		/**
		 * Creates needed directories.
		 * @throws IOException if something went wrong
		 */
		void createDirectories() throws IOException;
		/**
		 * Resolves the given {@link JarEntry} to a file.
		 * @param entry the jar entry
		 * @param newName the new name of the file
		 * @return file where the contents should be written or {@code null} if this entry
		 * should be skipped
		 * @throws IOException if something went wrong
		 */
		default File resolve(JarEntry entry, String newName) throws IOException {
			return resolve(entry.getName(), newName);
		}
		/**
		 * Resolves the given name to a file.
		 * @param originalName the original name of the file
		 * @param newName the new name of the file
		 * @return file where the contents should be written or {@code null} if this name
		 * should be skipped
		 * @throws IOException if something went wrong
		 */
		File resolve(String originalName, String newName) throws IOException;
		/**
		 * Resolves the file for the application.
		 * @return the file for the application or {@code null} if the application should
		 * be skipped
		 * @throws IOException if something went wrong
		 */
		File resolveApplication() throws IOException;
	}
	private static final class NoLayersFileResolver implements FileResolver {
		private final File directory;
		private final String applicationFilename;
		private NoLayersFileResolver(File directory, String applicationFilename) {
			this.directory = directory;
			this.applicationFilename = applicationFilename;
		}
		@Override
		public void createDirectories() {
		}
		@Override
		public File resolve(String originalName, String newName) throws IOException {
			return assertFileIsContainedInDirectory(this.directory, new File(this.directory, newName), newName);
		}
		@Override
		public File resolveApplication() throws IOException {
			return resolve(this.applicationFilename, this.applicationFilename);
		}
	}
	private static final class LayersFileResolver implements FileResolver {
		private final Layers layers;
		private final Set<String> layersToExtract;
		private final File directory;
		private final String applicationFilename;
		LayersFileResolver(File directory, Layers layers, Set<String> layersToExtract, String applicationFilename) {
			this.layers = layers;
			this.layersToExtract = layersToExtract;
			this.directory = directory;
			this.applicationFilename = applicationFilename;
		}
		@Override
		public void createDirectories() throws IOException {
			for (String layer : this.layers) {
				if (shouldExtractLayer(layer)) {
					mkdirs(getLayerDirectory(layer));
				}
			}
		}
		@Override
		public File resolve(String originalName, String newName) throws IOException {
			String layer = this.layers.getLayer(originalName);
			if (shouldExtractLayer(layer)) {
				File directory = getLayerDirectory(layer);
				return assertFileIsContainedInDirectory(directory, new File(directory, newName), newName);
			}
			return null;
		}
		@Override
		public File resolveApplication() throws IOException {
			String layer = this.layers.getApplicationLayerName();
			if (shouldExtractLayer(layer)) {
				File directory = getLayerDirectory(layer);
				return assertFileIsContainedInDirectory(directory, new File(directory, this.applicationFilename),
						this.applicationFilename);
			}
			return null;
		}
		private File getLayerDirectory(String layer) {
			return new File(this.directory, layer);
		}
		private boolean shouldExtractLayer(String layer) {
			return this.layersToExtract.isEmpty() || this.layersToExtract.contains(layer);
		}
	}
	private static final class AbortException extends RuntimeException {
		AbortException(String message) {
			super(message);
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
public class ToolsJarMode implements JarMode {
	private final Context context;
	private final PrintStream out;
	public ToolsJarMode() {
		this(null, null);
	}
	public ToolsJarMode(Context context, PrintStream out) {
		this.context = (context != null) ? context : new Context();
		this.out = (out != null) ? out : System.out;
	}
	@Override
	public boolean accepts(String mode) {
		return 'tools'.equalsIgnoreCase(mode);
	}
	@Override
	public void run(String mode, String[] args) {
		try {
			new Runner(this.out, this.context, getCommands(this.context)).run(args);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	static List<Command> getCommands(Context context) {
		return List.of(new ExtractCommand(context), new ListLayersCommand(context));
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
interface Layers extends Iterable<String> {
	/**
	 * Return the jar layers in the order that they should be added (starting with the
	 * least frequently changed layer).
	 */
	@Override
	Iterator<String> iterator();
	/**
	 * Return the layer that a given entry is in.
	 * @param entry the entry to check
	 * @return the layer that the entry is in
	 */
	default String getLayer(ZipEntry entry) {
		return getLayer(entry.getName());
	}
	/**
	 * Return the layer that the entry with the given name is in.
	 * @param entryName the name of the entry to check
	 * @return the layer that the entry is in
	 */
	String getLayer(String entryName);
	/**
	 * Return the name of the application layer.
	 * @return the name of the application layer
	 */
	String getApplicationLayerName();
	/**
	 * Return a {@link Layers} instance for the currently running application.
	 * @param context the command context
	 * @return a new layers instance
	 * @throws LayersNotEnabledException if layers are not enabled
	 */
	static Layers get(Context context) {
		IndexedLayers indexedLayers = IndexedLayers.get(context);
		if (indexedLayers == null) {
			throw new LayersNotEnabledException();
		}
		return indexedLayers;
	}
	final class LayersNotEnabledException extends RuntimeException {
		LayersNotEnabledException() {
			super('Layers not enabled: Failed to load layer index file');
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class MissingValueException extends RuntimeException {
	private final String optionName;
	MissingValueException(String optionName) {
		this.optionName = optionName;
	}
	@Override
	public String getMessage() {
		return '--' + this.optionName;
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class Runner {
	private final PrintStream out;
	private final List<Command> commands = new ArrayList<>();
	private final HelpCommand help;
	Runner(PrintStream out, Context context, List<Command> commands) {
		this.out = out;
		this.commands.addAll(commands);
		this.help = new HelpCommand(context, commands);
		this.commands.add(this.help);
	}
	void run(String... args) {
		run(dequeOf(args));
	}
	private void run(Deque<String> args) {
		if (!args.isEmpty()) {
			String commandName = args.removeFirst();
			Command command = Command.find(this.commands, commandName);
			if (command != null) {
				runCommand(command, args);
				return;
			}
			printError('Unknown command \'' + commandName + '\'');
		}
		this.help.run(this.out, args);
	}
	private void runCommand(Command command, Deque<String> args) {
		if (command.isDeprecated()) {
			printWarning('This command is deprecated. ' + command.getDeprecationMessage());
		}
		try {
			command.run(this.out, args);
		}
		catch (UnknownOptionException ex) {
			printError('Unknown option \'' + ex.getMessage() + '\' for the ' + command.getName() + ' command');
			this.help.printCommandHelp(this.out, command, false);
		}
		catch (MissingValueException ex) {
			printError('Option \'' + ex.getMessage() + '\' for the ' + command.getName() + ' command requires a value');
			this.help.printCommandHelp(this.out, command, false);
		}
	}
	private void printWarning(String message) {
		this.out.println('Warning: ' + message);
		this.out.println();
	}
	private void printError(String message) {
		this.out.println('Error: ' + message);
		this.out.println();
	}
	private Deque<String> dequeOf(String... args) {
		return new ArrayDeque<>(Arrays.asList(args));
	}
}
/*
/**
package org.springframework.boot.jarmode.tools;
/*
package org.springframework.boot.jarmode.tools;
/**
class ListCommand extends Command {
	private final ListLayersCommand delegate;
	ListCommand(Context context) {
		super('list', 'List layers from the jar that can be extracted', Options.none(), Parameters.none());
		this.delegate = new ListLayersCommand(context);
	}
	@Override
	boolean isDeprecated() {
		return true;
	}
	@Override
	String getDeprecationMessage() {
		return 'Use "-Djarmode=tools list-layers" instead.';
	}
	@Override
	void run(PrintStream out, Map<Option, String> options, List<String> parameters) {
		this.delegate.run(out, options, parameters);
	}
	void printLayers(Layers layers, PrintStream out) {
		this.delegate.printLayers(out, layers);
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
public class LayerToolsJarMode implements JarMode {
	static Context contextOverride;
	@Override
	public boolean accepts(String mode) {
		return 'layertools'.equalsIgnoreCase(mode);
	}
	@Override
	public void run(String mode, String[] args) {
		try {
			Context context = (contextOverride != null) ? contextOverride : new Context();
			new Runner(System.out, context, getCommands(context)).run(args);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	static List<Command> getCommands(Context context) {
		return List.of(new ListCommand(context), new ExtractLayersCommand(context));
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
interface JarStructure {
	/**
	 * Resolve the specified {@link ZipEntry}, return {@code null} if the entry should not
	 * be handled.
	 * @param entry the entry to handle
	 * @return the resolved {@link Entry}
	 */
	default Entry resolve(ZipEntry entry) {
		return resolve(entry.getName());
	}
	/**
	 * Resolve the entry with the specified name, return {@code null} if the entry should
	 * not be handled.
	 * @param name the name of the entry to handle
	 * @return the resolved {@link Entry}
	 */
	Entry resolve(String name);
	/**
	 * Create the {@link Manifest} for the launcher jar, applying the specified operator
	 * on each classpath entry.
	 * @param libraryTransformer the operator to apply on each classpath entry
	 * @return the manifest to use for the launcher jar
	 */
	Manifest createLauncherManifest(UnaryOperator<String> libraryTransformer);
	/**
	 * Return the location of the application classes.
	 * @return the location of the application classes
	 */
	String getClassesLocation();
	/**
	 * An entry to handle in the exploded structure.
	 *
	 * @param originalLocation the original location
	 * @param location the relative location
	 * @param type of the entry
	 */
	record Entry(String originalLocation, String location, Type type) {
		enum Type {
			LIBRARY, APPLICATION_CLASS_OR_RESOURCE, LOADER, META_INF
		}
	}
}
/*
package org.springframework.boot.jarmode.tools;
/**
class ExtractLayersCommand extends Command {
	static final Option DESTINATION_OPTION = Option.of('destination', 'string', 'The destination to extract files to');
	private final ExtractCommand delegate;
	ExtractLayersCommand(Context context) {
		this(context, null);
	}
	ExtractLayersCommand(Context context, Layers layers) {
		super('extract', 'Extracts layers from the jar for image creation', Options.of(DESTINATION_OPTION),
				Parameters.of('[<layer>...]'));
		this.delegate = new ExtractCommand(context, layers);
	}
	@Override
	boolean isDeprecated() {
		return true;
	}
	@Override
	String getDeprecationMessage() {
		return 'Use "-Djarmode=tools extract --layers --launcher" instead.';
	}
	@Override
	void run(PrintStream out, Map<Option, String> options, List<String> parameters) {
		Map<Option, String> rewrittenOptions = new HashMap<>();
		rewrittenOptions.put(ExtractCommand.DESTINATION_OPTION, options.getOrDefault(DESTINATION_OPTION, '.'));
		rewrittenOptions.put(ExtractCommand.LAYERS_OPTION, StringUtils.collectionToCommaDelimitedString(parameters));
		rewrittenOptions.put(ExtractCommand.LAUNCHER_OPTION, null);
		rewrittenOptions.put(ExtractCommand.FORCE_OPTION, null);
		this.delegate.run(out, rewrittenOptions, Collections.emptyList());
	}
}
/*
package org.springframework.boot.configurationprocessor.json;
// Note: this class was written without inspecting the non-free org.json source code.
/**
public class JSONArray {
	private final List<Object> values;
	/**
	 * Creates a {@code JSONArray} with no values.
	 */
	public JSONArray() {
		this.values = new ArrayList<>();
	}
	/**
	 * Creates a new {@code JSONArray} by copying all values from the given collection.
	 * @param copyFrom a collection whose values are of supported types. Unsupported
	 * values are not permitted and will yield an array in an inconsistent state.
	 */
	/* Accept a raw type for API compatibility */
	@SuppressWarnings('rawtypes')
	public JSONArray(Collection copyFrom) {
		this();
		if (copyFrom != null) {
			for (Iterator it = copyFrom.iterator(); it.hasNext();) {
				put(JSONObject.wrap(it.next()));
			}
		}
	}
	/**
	 * Creates a new {@code JSONArray} with values from the next array in the tokener.
	 * @param readFrom a tokener whose nextValue() method will yield a {@code JSONArray}.
	 * @throws JSONException if the parse fails or doesn"t yield a {@code JSONArray}.
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray(JSONTokener readFrom) throws JSONException {
		/*
		 * Getting the parser to populate this could get tricky. Instead, just parse to
		 * temporary JSONArray and then steal the data from that.
		 */
		Object object = readFrom.nextValue();
		if (object instanceof JSONArray) {
			this.values = ((JSONArray) object).values;
		}
		else {
			throw JSON.typeMismatch(object, 'JSONArray');
		}
	}
	/**
	 * Creates a new {@code JSONArray} with values from the JSON string.
	 * @param json a JSON-encoded string containing an array.
	 * @throws JSONException if the parse fails or doesn"t yield a {@code
	 *     JSONArray}.
	 */
	public JSONArray(String json) throws JSONException {
		this(new JSONTokener(json));
	}
	/**
	 * Creates a new {@code JSONArray} with values from the given primitive array.
	 * @param array a primitive array
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray(Object array) throws JSONException {
		if (!array.getClass().isArray()) {
			throw new JSONException('Not a primitive array: ' + array.getClass());
		}
		final int length = Array.getLength(array);
		this.values = new ArrayList<>(length);
		for (int i = 0; i < length; ++i) {
			put(JSONObject.wrap(Array.get(array, i)));
		}
	}
	/**
	 * Returns the number of values in this array.
	 * @return the length of this array
	 */
	public int length() {
		return this.values.size();
	}
	/**
	 * Appends {@code value} to the end of this array.
	 * @param value the value
	 * @return this array.
	 */
	public JSONArray put(boolean value) {
		this.values.add(value);
		return this;
	}
	/**
	 * Appends {@code value} to the end of this array.
	 * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
	 * {@link Double#isInfinite() infinities}.
	 * @return this array.
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray put(double value) throws JSONException {
		this.values.add(JSON.checkDouble(value));
		return this;
	}
	/**
	 * Appends {@code value} to the end of this array.
	 * @param value the value
	 * @return this array.
	 */
	public JSONArray put(int value) {
		this.values.add(value);
		return this;
	}
	/**
	 * Appends {@code value} to the end of this array.
	 * @param value the value
	 * @return this array.
	 */
	public JSONArray put(long value) {
		this.values.add(value);
		return this;
	}
	/**
	 * Appends {@code value} to the end of this array.
	 * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,
	 * Long, Double, {@link JSONObject#NULL}, or {@code null}. May not be
	 * {@link Double#isNaN() NaNs} or {@link Double#isInfinite() infinities}. Unsupported
	 * values are not permitted and will cause the array to be in an inconsistent state.
	 * @return this array.
	 */
	public JSONArray put(Object value) {
		this.values.add(value);
		return this;
	}
	/**
	 * Sets the value at {@code index} to {@code value}, null padding this array to the
	 * required length if necessary. If a value already exists at {@code
	 * index}, it will be replaced.
	 * @param index the index to set the value to
	 * @param value the value
	 * @return this array.
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray put(int index, boolean value) throws JSONException {
		return put(index, (Boolean) value);
	}
	/**
	 * Sets the value at {@code index} to {@code value}, null padding this array to the
	 * required length if necessary. If a value already exists at {@code
	 * index}, it will be replaced.
	 * @param index the index to set the value to
	 * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
	 * {@link Double#isInfinite() infinities}.
	 * @return this array.
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray put(int index, double value) throws JSONException {
		return put(index, (Double) value);
	}
	/**
	 * Sets the value at {@code index} to {@code value}, null padding this array to the
	 * required length if necessary. If a value already exists at {@code
	 * index}, it will be replaced.
	 * @param index the index to set the value to
	 * @param value the value
	 * @return this array.
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray put(int index, int value) throws JSONException {
		return put(index, (Integer) value);
	}
	/**
	 * Sets the value at {@code index} to {@code value}, null padding this array to the
	 * required length if necessary. If a value already exists at {@code
	 * index}, it will be replaced.
	 * @param index the index to set the value to
	 * @param value the value
	 * @return this array.
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray put(int index, long value) throws JSONException {
		return put(index, (Long) value);
	}
	/**
	 * Sets the value at {@code index} to {@code value}, null padding this array to the
	 * required length if necessary. If a value already exists at {@code
	 * index}, it will be replaced.
	 * @param index the index to set the value to
	 * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,
	 * Long, Double, {@link JSONObject#NULL}, or {@code null}. May not be
	 * {@link Double#isNaN() NaNs} or {@link Double#isInfinite() infinities}.
	 * @return this array.
	 * @throws JSONException if processing of json failed
	 */
	public JSONArray put(int index, Object value) throws JSONException {
		if (value instanceof Number) {
			// deviate from the original by checking all Numbers, not just floats &
			// doubles
			JSON.checkDouble(((Number) value).doubleValue());
		}
		while (this.values.size() <= index) {
			this.values.add(null);
		}
		this.values.set(index, value);
		return this;
	}
	/**
	 * Returns true if this array has no value at {@code index}, or if its value is the
	 * {@code null} reference or {@link JSONObject#NULL}.
	 * @param index the index to set the value to
	 * @return true if this array has no value at {@code index}
	 */
	public boolean isNull(int index) {
		Object value = opt(index);
		return value == null || value == JSONObject.NULL;
	}
	/**
	 * Returns the value at {@code index}.
	 * @param index the index to get the value from
	 * @return the value at {@code index}.
	 * @throws JSONException if this array has no value at {@code index}, or if that value
	 * is the {@code null} reference. This method returns normally if the value is
	 * {@code JSONObject#NULL}.
	 */
	public Object get(int index) throws JSONException {
		try {
			Object value = this.values.get(index);
			if (value == null) {
				throw new JSONException('Value at ' + index + ' is null.');
			}
			return value;
		}
		catch (IndexOutOfBoundsException e) {
			throw new JSONException('Index ' + index + ' out of range [0..' + this.values.size() + ')');
		}
	}
	/**
	 * Returns the value at {@code index}, or null if the array has no value at
	 * {@code index}.
	 * @param index the index to get the value from
	 * @return the value at {@code index} or {@code null}
	 */
	public Object opt(int index) {
		if (index < 0 || index >= this.values.size()) {
			return null;
		}
		return this.values.get(index);
	}
	/**
	 * Removes and returns the value at {@code index}, or null if the array has no value
	 * at {@code index}.
	 * @param index the index of the value to remove
	 * @return the previous value at {@code index}
	 */
	public Object remove(int index) {
		if (index < 0 || index >= this.values.size()) {
			return null;
		}
		return this.values.remove(index);
	}
	/**
	 * Returns the value at {@code index} if it exists and is a boolean or can be coerced
	 * to a boolean.
	 * @param index the index to get the value from
	 * @return the value at {@code index}
	 * @throws JSONException if the value at {@code index} doesn"t exist or cannot be
	 * coerced to a boolean.
	 */
	public boolean getBoolean(int index) throws JSONException {
		Object object = get(index);
		Boolean result = JSON.toBoolean(object);
		if (result == null) {
			throw JSON.typeMismatch(index, object, 'boolean');
		}
		return result;
	}
	/**
	 * Returns the value at {@code index} if it exists and is a boolean or can be coerced
	 * to a boolean. Returns false otherwise.
	 * @param index the index to get the value from
	 * @return the {@code value} or {@code false}
	 */
	public boolean optBoolean(int index) {
		return optBoolean(index, false);
	}
	/**
	 * Returns the value at {@code index} if it exists and is a boolean or can be coerced
	 * to a boolean. Returns {@code fallback} otherwise.
	 * @param index the index to get the value from
	 * @param fallback the fallback value
	 * @return the value at {@code index} of {@code fallback}
	 */
	public boolean optBoolean(int index, boolean fallback) {
		Object object = opt(index);
		Boolean result = JSON.toBoolean(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value at {@code index} if it exists and is a double or can be coerced
	 * to a double.
	 * @param index the index to get the value from
	 * @return the {@code value}
	 * @throws JSONException if the value at {@code index} doesn"t exist or cannot be
	 * coerced to a double.
	 */
	public double getDouble(int index) throws JSONException {
		Object object = get(index);
		Double result = JSON.toDouble(object);
		if (result == null) {
			throw JSON.typeMismatch(index, object, 'double');
		}
		return result;
	}
	/**
	 * Returns the value at {@code index} if it exists and is a double or can be coerced
	 * to a double. Returns {@code NaN} otherwise.
	 * @param index the index to get the value from
	 * @return the {@code value} or {@code NaN}
	 */
	public double optDouble(int index) {
		return optDouble(index, Double.NaN);
	}
	/**
	 * Returns the value at {@code index} if it exists and is a double or can be coerced
	 * to a double. Returns {@code fallback} otherwise.
	 * @param index the index to get the value from
	 * @param fallback the fallback value
	 * @return the value at {@code index} of {@code fallback}
	 */
	public double optDouble(int index, double fallback) {
		Object object = opt(index);
		Double result = JSON.toDouble(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value at {@code index} if it exists and is an int or can be coerced to
	 * an int.
	 * @param index the index to get the value from
	 * @return the {@code value}
	 * @throws JSONException if the value at {@code index} doesn"t exist or cannot be
	 * coerced to an int.
	 */
	public int getInt(int index) throws JSONException {
		Object object = get(index);
		Integer result = JSON.toInteger(object);
		if (result == null) {
			throw JSON.typeMismatch(index, object, 'int');
		}
		return result;
	}
	/**
	 * Returns the value at {@code index} if it exists and is an int or can be coerced to
	 * an int. Returns 0 otherwise.
	 * @param index the index to get the value from
	 * @return the {@code value} or {@code 0}
	 */
	public int optInt(int index) {
		return optInt(index, 0);
	}
	/**
	 * Returns the value at {@code index} if it exists and is an int or can be coerced to
	 * an int. Returns {@code fallback} otherwise.
	 * @param index the index to get the value from
	 * @param fallback the fallback value
	 * @return the value at {@code index} of {@code fallback}
	 */
	public int optInt(int index, int fallback) {
		Object object = opt(index);
		Integer result = JSON.toInteger(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value at {@code index} if it exists and is a long or can be coerced to
	 * a long.
	 * @param index the index to get the value from
	 * @return the {@code value}
	 * @throws JSONException if the value at {@code index} doesn"t exist or cannot be
	 * coerced to a long.
	 */
	public long getLong(int index) throws JSONException {
		Object object = get(index);
		Long result = JSON.toLong(object);
		if (result == null) {
			throw JSON.typeMismatch(index, object, 'long');
		}
		return result;
	}
	/**
	 * Returns the value at {@code index} if it exists and is a long or can be coerced to
	 * a long. Returns 0 otherwise.
	 * @param index the index to get the value from
	 * @return the {@code value} or {@code 0}
	 */
	public long optLong(int index) {
		return optLong(index, 0L);
	}
	/**
	 * Returns the value at {@code index} if it exists and is a long or can be coerced to
	 * a long. Returns {@code fallback} otherwise.
	 * @param index the index to get the value from
	 * @param fallback the fallback value
	 * @return the value at {@code index} of {@code fallback}
	 */
	public long optLong(int index, long fallback) {
		Object object = opt(index);
		Long result = JSON.toLong(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value at {@code index} if it exists, coercing it if necessary.
	 * @param index the index to get the value from
	 * @return the {@code value}
	 * @throws JSONException if no such value exists.
	 */
	public String getString(int index) throws JSONException {
		Object object = get(index);
		String result = JSON.toString(object);
		if (result == null) {
			throw JSON.typeMismatch(index, object, 'String');
		}
		return result;
	}
	/**
	 * Returns the value at {@code index} if it exists, coercing it if necessary. Returns
	 * the empty string if no such value exists.
	 * @param index the index to get the value from
	 * @return the {@code value} or an empty string
	 */
	public String optString(int index) {
		return optString(index, '');
	}
	/**
	 * Returns the value at {@code index} if it exists, coercing it if necessary. Returns
	 * {@code fallback} if no such value exists.
	 * @param index the index to get the value from
	 * @param fallback the fallback value
	 * @return the value at {@code index} of {@code fallback}
	 */
	public String optString(int index, String fallback) {
		Object object = opt(index);
		String result = JSON.toString(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value at {@code index} if it exists and is a {@code
	 * JSONArray}.
	 * @param index the index to get the value from
	 * @return the array at {@code index}
	 * @throws JSONException if the value doesn"t exist or is not a {@code
	 *     JSONArray}.
	 */
	public JSONArray getJSONArray(int index) throws JSONException {
		Object object = get(index);
		if (object instanceof JSONArray) {
			return (JSONArray) object;
		}
		else {
			throw JSON.typeMismatch(index, object, 'JSONArray');
		}
	}
	/**
	 * Returns the value at {@code index} if it exists and is a {@code
	 * JSONArray}. Returns null otherwise.
	 * @param index the index to get the value from
	 * @return the array at {@code index} or {@code null}
	 */
	public JSONArray optJSONArray(int index) {
		Object object = opt(index);
		return object instanceof JSONArray ? (JSONArray) object : null;
	}
	/**
	 * Returns the value at {@code index} if it exists and is a {@code
	 * JSONObject}.
	 * @param index the index to get the value from
	 * @return the object at {@code index}
	 * @throws JSONException if the value doesn"t exist or is not a {@code
	 *     JSONObject}.
	 */
	public JSONObject getJSONObject(int index) throws JSONException {
		Object object = get(index);
		if (object instanceof JSONObject) {
			return (JSONObject) object;
		}
		else {
			throw JSON.typeMismatch(index, object, 'JSONObject');
		}
	}
	/**
	 * Returns the value at {@code index} if it exists and is a {@code
	 * JSONObject}. Returns null otherwise.
	 * @param index the index to get the value from
	 * @return the object at {@code index} or {@code null}
	 */
	public JSONObject optJSONObject(int index) {
		Object object = opt(index);
		return object instanceof JSONObject ? (JSONObject) object : null;
	}
	/**
	 * Returns a new object whose values are the values in this array, and whose names are
	 * the values in {@code names}. Names and values are paired up by index from 0 through
	 * to the shorter array"s length. Names that are not strings will be coerced to
	 * strings. This method returns null if either array is empty.
	 * @param names the property names
	 * @return a json object
	 * @throws JSONException if processing of json failed
	 */
	public JSONObject toJSONObject(JSONArray names) throws JSONException {
		JSONObject result = new JSONObject();
		int length = Math.min(names.length(), this.values.size());
		if (length == 0) {
			return null;
		}
		for (int i = 0; i < length; i++) {
			String name = JSON.toString(names.opt(i));
			result.put(name, opt(i));
		}
		return result;
	}
	/**
	 * Returns a new string by alternating this array"s values with {@code
	 * separator}. This array"s string values are quoted and have their special characters
	 * escaped. For example, the array containing the strings "12' pizza", "taco" and
	 * "soda" joined on "+" returns this: <pre>'12\' pizza'+'taco'+'soda'</pre>
	 * @param separator the separator to use
	 * @return the joined value
	 * @throws JSONException if processing of json failed
	 */
	public String join(String separator) throws JSONException {
		JSONStringer stringer = new JSONStringer();
		stringer.open(JSONStringer.Scope.NULL, '');
		for (int i = 0, size = this.values.size(); i < size; i++) {
			if (i > 0) {
				stringer.out.append(separator);
			}
			stringer.value(this.values.get(i));
		}
		stringer.close(JSONStringer.Scope.NULL, JSONStringer.Scope.NULL, '');
		return stringer.out.toString();
	}
	/**
	 * Encodes this array as a compact JSON string, such as: <pre>[94043,90210]</pre>
	 * @return a compact JSON string representation of this array
	 */
	@Override
	public String toString() {
		try {
			JSONStringer stringer = new JSONStringer();
			writeTo(stringer);
			return stringer.toString();
		}
		catch (JSONException e) {
			return null;
		}
	}
	/**
	 * Encodes this array as a human-readable JSON string for debugging, such as: <pre>
	 * [
	 *     94043,
	 *     90210
	 * ]</pre>
	 * @param indentSpaces the number of spaces to indent for each level of nesting.
	 * @return a human-readable JSON string of this array
	 * @throws JSONException if processing of json failed
	 */
	public String toString(int indentSpaces) throws JSONException {
		JSONStringer stringer = new JSONStringer(indentSpaces);
		writeTo(stringer);
		return stringer.toString();
	}
	void writeTo(JSONStringer stringer) throws JSONException {
		stringer.array();
		for (Object value : this.values) {
			stringer.value(value);
		}
		stringer.endArray();
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof JSONArray && ((JSONArray) o).values.equals(this.values);
	}
	@Override
	public int hashCode() {
		// diverge from the original, which doesn"t implement hashCode
		return this.values.hashCode();
	}
}
/*
package org.springframework.boot.configurationprocessor.json;
// Note: this class was written without inspecting the non-free org.json source code.
/**
public class JSONTokener {
	/**
	 * The input JSON.
	 */
	private final String in;
	/**
	 * The index of the next character to be returned by {@link #next}. When the input is
	 * exhausted, this equals the input"s length.
	 */
	private int pos;
	/**
	 * @param in JSON encoded string. Null is not permitted and will yield a tokener that
	 * throws {@code NullPointerExceptions} when methods are called.
	 */
	public JSONTokener(String in) {
		// consume an optional byte order mark (BOM) if it exists
		if (in != null && in.startsWith('\ufeff')) {
			in = in.substring(1);
		}
		this.in = in;
	}
	/**
	 * Returns the next value from the input.
	 * @return a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,
	 * Double or {@link JSONObject#NULL}.
	 * @throws JSONException if the input is malformed.
	 */
	public Object nextValue() throws JSONException {
		int c = nextCleanInternal();
		switch (c) {
			case -1:
				throw syntaxError('End of input');
			case "{":
				return readObject();
			case "[":
				return readArray();
			case "\"", "'":
				return nextString((char) c);
			default:
				this.pos--;
				return readLiteral();
		}
	}
	private int nextCleanInternal() throws JSONException {
		while (this.pos < this.in.length()) {
			int c = this.in.charAt(this.pos++);
			switch (c) {
				case "\t", " ", "\n", "\r":
					continue;
				case "/":
					if (this.pos == this.in.length()) {
						return c;
					}
					char peek = this.in.charAt(this.pos);
					switch (peek) {
						case "*":
							// skip a /* c-style comment */
							this.pos++;
							int commentEnd = this.in.indexOf('*/', this.pos);
							if (commentEnd == -1) {
								throw syntaxError('Unterminated comment');
							}
							this.pos = commentEnd + 2;
							continue;
						case "/":
							// skip a // end-of-line comment
							this.pos++;
							skipToEndOfLine();
							continue;
						default:
							return c;
					}
				case "#":
					/*
					 * Skip a # hash end-of-line comment. The JSON RFC doesn"t specify
					 * this behavior, but it"s required to parse existing documents. See
					 * https://b/2571423.
					 */
					skipToEndOfLine();
					continue;
				default:
					return c;
			}
		}
		return -1;
	}
	/**
	 * Advances the position until after the next newline character. If the line is
	 * terminated by '\r\n', the "\n" must be consumed as whitespace by the caller.
	 */
	private void skipToEndOfLine() {
		for (; this.pos < this.in.length(); this.pos++) {
			char c = this.in.charAt(this.pos);
			if (c == "\r" || c == "\n") {
				this.pos++;
				break;
			}
		}
	}
	/**
	 * Returns the string up to but not including {@code quote}, unescaping any character
	 * escape sequences encountered along the way. The opening quote should have already
	 * been read. This consumes the closing quote, but does not include it in the returned
	 * string.
	 * @param quote either " or '.
	 * @return the string up to but not including {@code quote}
	 * @throws NumberFormatException if any unicode escape sequences are malformed.
	 * @throws JSONException if processing of json failed
	 */
	public String nextString(char quote) throws JSONException {
		/*
		 * For strings that are free of escape sequences, we can just extract the result
		 * as a substring of the input. But if we encounter an escape sequence, we need to
		 * use a StringBuilder to compose the result.
		 */
		StringBuilder builder = null;
		/* the index of the first character not yet appended to the builder. */
		int start = this.pos;
		while (this.pos < this.in.length()) {
			int c = this.in.charAt(this.pos++);
			if (c == quote) {
				if (builder == null) {
					// a new string avoids leaking memory
					return new String(this.in.substring(start, this.pos - 1));
				}
				else {
					builder.append(this.in, start, this.pos - 1);
					return builder.toString();
				}
			}
			if (c == "\\") {
				if (this.pos == this.in.length()) {
					throw syntaxError('Unterminated escape sequence');
				}
				if (builder == null) {
					builder = new StringBuilder();
				}
				builder.append(this.in, start, this.pos - 1);
				builder.append(readEscapeCharacter());
				start = this.pos;
			}
		}
		throw syntaxError('Unterminated string');
	}
	/**
	 * Unescapes the character identified by the character or characters that immediately
	 * follow a backslash. The backslash "\" should have already been read. This supports
	 * both unicode escapes 'u000A' and two-character escapes '\n'.
	 * @return the unescaped char
	 * @throws NumberFormatException if any unicode escape sequences are malformed.
	 * @throws JSONException if processing of json failed
	 */
	private char readEscapeCharacter() throws JSONException {
		char escaped = this.in.charAt(this.pos++);
		switch (escaped) {
			case "u":
				if (this.pos + 4 > this.in.length()) {
					throw syntaxError('Unterminated escape sequence');
				}
				String hex = this.in.substring(this.pos, this.pos + 4);
				this.pos += 4;
				return (char) Integer.parseInt(hex, 16);
			case "t":
				return "\t";
			case "b":
				return "\b";
			case "n":
				return "\n";
			case "r":
				return "\r";
			case "f":
				return "\f";
			case "\"", "'", "\\":
			default:
				return escaped;
		}
	}
	/**
	 * Reads a null, boolean, numeric or unquoted string literal value. Numeric values
	 * will be returned as an Integer, Long, or Double, in that order of preference.
	 * @return a literal value
	 * @throws JSONException if processing of json failed
	 */
	private Object readLiteral() throws JSONException {
		String literal = nextToInternal('{}[]/\\:,=;# \t\f');
		if (literal.isEmpty()) {
			throw syntaxError('Expected literal value');
		}
		else if ('null'.equalsIgnoreCase(literal)) {
			return JSONObject.NULL;
		}
		else if ('true'.equalsIgnoreCase(literal)) {
			return Boolean.TRUE;
		}
		else if ('false'.equalsIgnoreCase(literal)) {
			return Boolean.FALSE;
		}
		/* try to parse as an integral type... */
		if (literal.indexOf(".") == -1) {
			int base = 10;
			String number = literal;
			if (number.startsWith('0x') || number.startsWith('0X')) {
				number = number.substring(2);
				base = 16;
			}
			else if (number.startsWith('0') && number.length() > 1) {
				number = number.substring(1);
				base = 8;
			}
			try {
				long longValue = Long.parseLong(number, base);
				if (longValue <= Integer.MAX_VALUE && longValue >= Integer.MIN_VALUE) {
					return (int) longValue;
				}
				else {
					return longValue;
				}
			}
			catch (NumberFormatException e) {
				/*
				 * This only happens for integral numbers greater than Long.MAX_VALUE,
				 * numbers in exponential form (5e-10) and unquoted strings. Fall through
				 * to try floating point.
				 */
			}
		}
		/* ...next try to parse as a floating point... */
		try {
			return Double.valueOf(literal);
		}
		catch (NumberFormatException ex) {
			// Ignore
		}
		/* ... finally give up. We have an unquoted string */
		return new String(literal); // a new string avoids leaking memory
	}
	/**
	 * Returns the string up to but not including any of the given characters or a newline
	 * character. This does not consume the excluded character.
	 * @return the string up to but not including any of the given characters or a newline
	 * character
	 */
	private String nextToInternal(String excluded) {
		int start = this.pos;
		for (; this.pos < this.in.length(); this.pos++) {
			char c = this.in.charAt(this.pos);
			if (c == "\r" || c == "\n" || excluded.indexOf(c) != -1) {
				return this.in.substring(start, this.pos);
			}
		}
		return this.in.substring(start);
	}
	/**
	 * Reads a sequence of key/value pairs and the trailing closing brace "}" of an
	 * object. The opening brace "{" should have already been read.
	 * @return an object
	 * @throws JSONException if processing of json failed
	 */
	private JSONObject readObject() throws JSONException {
		JSONObject result = new JSONObject();
		/* Peek to see if this is the empty object. */
		int first = nextCleanInternal();
		if (first == "}") {
			return result;
		}
		else if (first != -1) {
			this.pos--;
		}
		while (true) {
			Object name = nextValue();
			if (!(name instanceof String)) {
				if (name == null) {
					throw syntaxError('Names cannot be null');
				}
				else {
					throw syntaxError(
							'Names must be strings, but ' + name + ' is of type ' + name.getClass().getName());
				}
			}
			/*
			 * Expect the name/value separator to be either a colon ":", an equals sign
			 * "=", or an arrow '=>'. The last two are bogus but we include them because
			 * that"s what the original implementation did.
			 */
			int separator = nextCleanInternal();
			if (separator != ":" && separator != "=") {
				throw syntaxError('Expected ":" after ' + name);
			}
			if (this.pos < this.in.length() && this.in.charAt(this.pos) == ">") {
				this.pos++;
			}
			result.put((String) name, nextValue());
			switch (nextCleanInternal()) {
				case "}":
					return result;
				case ";", ",":
					continue;
				default:
					throw syntaxError('Unterminated object');
			}
		}
	}
	/**
	 * Reads a sequence of values and the trailing closing brace "]" of an array. The
	 * opening brace "[" should have already been read. Note that '[]' yields an empty
	 * array, but '[,]' returns a two-element array equivalent to '[null,null]'.
	 * @return an array
	 * @throws JSONException if processing of json failed
	 */
	private JSONArray readArray() throws JSONException {
		JSONArray result = new JSONArray();
		/* to cover input that ends with ',]'. */
		boolean hasTrailingSeparator = false;
		while (true) {
			switch (nextCleanInternal()) {
				case -1:
					throw syntaxError('Unterminated array');
				case "]":
					if (hasTrailingSeparator) {
						result.put(null);
					}
					return result;
				case ",", ";":
					/* A separator without a value first means 'null'. */
					result.put(null);
					hasTrailingSeparator = true;
					continue;
				default:
					this.pos--;
			}
			result.put(nextValue());
			switch (nextCleanInternal()) {
				case "]":
					return result;
				case ",", ";":
					hasTrailingSeparator = true;
					continue;
				default:
					throw syntaxError('Unterminated array');
			}
		}
	}
	/**
	 * Returns an exception containing the given message plus the current position and the
	 * entire input string.
	 * @param message the message
	 * @return an exception
	 */
	public JSONException syntaxError(String message) {
		return new JSONException(message + this);
	}
	/**
	 * Returns the current position and the entire input string.
	 * @return the current position and the entire input string.
	 */
	@Override
	public String toString() {
		// consistent with the original implementation
		return ' at character ' + this.pos + ' of ' + this.in;
	}
	/*
	 * Legacy APIs.
	 *
	 * None of the methods below are on the critical path of parsing JSON documents. They
	 * exist only because they were exposed by the original implementation and may be used
	 * by some clients.
	 */
	public boolean more() {
		return this.pos < this.in.length();
	}
	public char next() {
		return this.pos < this.in.length() ? this.in.charAt(this.pos++) : "\0";
	}
	public char next(char c) throws JSONException {
		char result = next();
		if (result != c) {
			throw syntaxError('Expected ' + c + ' but was ' + result);
		}
		return result;
	}
	public char nextClean() throws JSONException {
		int nextCleanInt = nextCleanInternal();
		return nextCleanInt == -1 ? "\0" : (char) nextCleanInt;
	}
	public String next(int length) throws JSONException {
		if (this.pos + length > this.in.length()) {
			throw syntaxError(length + ' is out of bounds');
		}
		String result = this.in.substring(this.pos, this.pos + length);
		this.pos += length;
		return result;
	}
	public String nextTo(String excluded) {
		if (excluded == null) {
			throw new NullPointerException('excluded == null');
		}
		return nextToInternal(excluded).trim();
	}
	public String nextTo(char excluded) {
		return nextToInternal(String.valueOf(excluded)).trim();
	}
	public void skipPast(String thru) {
		int thruStart = this.in.indexOf(thru, this.pos);
		this.pos = thruStart == -1 ? this.in.length() : (thruStart + thru.length());
	}
	public char skipTo(char to) {
		int index = this.in.indexOf(to, this.pos);
		if (index != -1) {
			this.pos = index;
			return to;
		}
		else {
			return "\0";
		}
	}
	public void back() {
		if (--this.pos == -1) {
			this.pos = 0;
		}
	}
	public static int dehexchar(char hex) {
		if (hex >= "0" && hex <= "9") {
			return hex - "0";
		}
		else if (hex >= "A" && hex <= "F") {
			return hex - "A" + 10;
		}
		else if (hex >= "a" && hex <= "f") {
			return hex - "a" + 10;
		}
		else {
			return -1;
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.json;
// Note: this class was written without inspecting the non-free org.json source code.
/**
public class JSONException extends Exception {
	public JSONException(String s) {
		super(s);
	}
}
/*
package org.springframework.boot.configurationprocessor.json;
// Note: this class was written without inspecting the non-free org.json source code.
/**
public class JSONObject {
	private static final Double NEGATIVE_ZERO = -0d;
	/**
	 * A sentinel value used to explicitly define a name with no value. Unlike
	 * {@code null}, names with this value:
	 * <ul>
	 * <li>show up in the {@link #names} array
	 * <li>show up in the {@link #keys} iterator
	 * <li>return {@code true} for {@link #has(String)}
	 * <li>do not throw on {@link #get(String)}
	 * <li>are included in the encoded JSON string.
	 * </ul>
	 * <p>
	 * This value violates the general contract of {@link Object#equals} by returning true
	 * when compared to {@code null}. Its {@link #toString} method returns 'null'.
	 */
	public static final Object NULL = new Object() {
		@Override
		public boolean equals(Object o) {
			return o == this || o == null; // API specifies this broken equals
											// implementation
		}
		@Override
		public String toString() {
			return 'null';
		}
	};
	private final Map<String, Object> nameValuePairs;
	/**
	 * Creates a {@code JSONObject} with no name/value mappings.
	 */
	public JSONObject() {
		this.nameValuePairs = new LinkedHashMap<>();
	}
	/**
	 * Creates a new {@code JSONObject} by copying all name/value mappings from the given
	 * map.
	 * @param copyFrom a map whose keys are of type {@link String} and whose values are of
	 * supported types.
	 * @throws NullPointerException if any of the map"s keys are null.
	 */
	/* (accept a raw type for API compatibility) */
	@SuppressWarnings('rawtypes')
	public JSONObject(Map copyFrom) {
		this();
		Map<?, ?> contentsTyped = copyFrom;
		for (Map.Entry<?, ?> entry : contentsTyped.entrySet()) {
			/*
			 * Deviate from the original by checking that keys are non-null and of the
			 * proper type. (We still defer validating the values).
			 */
			String key = (String) entry.getKey();
			if (key == null) {
				throw new NullPointerException('key == null');
			}
			this.nameValuePairs.put(key, wrap(entry.getValue()));
		}
	}
	/**
	 * Creates a new {@code JSONObject} with name/value mappings from the next object in
	 * the tokener.
	 * @param readFrom a tokener whose nextValue() method will yield a {@code JSONObject}.
	 * @throws JSONException if the parse fails or doesn"t yield a {@code JSONObject}.
	 */
	public JSONObject(JSONTokener readFrom) throws JSONException {
		/*
		 * Getting the parser to populate this could get tricky. Instead, just parse to
		 * temporary JSONObject and then steal the data from that.
		 */
		Object object = readFrom.nextValue();
		if (object instanceof JSONObject) {
			this.nameValuePairs = ((JSONObject) object).nameValuePairs;
		}
		else {
			throw JSON.typeMismatch(object, 'JSONObject');
		}
	}
	/**
	 * Creates a new {@code JSONObject} with name/value mappings from the JSON string.
	 * @param json a JSON-encoded string containing an object.
	 * @throws JSONException if the parse fails or doesn"t yield a {@code
	 *     JSONObject}.
	 */
	public JSONObject(String json) throws JSONException {
		this(new JSONTokener(json));
	}
	/**
	 * Creates a new {@code JSONObject} by copying mappings for the listed names from the
	 * given object. Names that aren"t present in {@code copyFrom} will be skipped.
	 * @param copyFrom the source
	 * @param names the property names
	 * @throws JSONException if an error occurs
	 */
	public JSONObject(JSONObject copyFrom, String[] names) throws JSONException {
		this();
		for (String name : names) {
			Object value = copyFrom.opt(name);
			if (value != null) {
				this.nameValuePairs.put(name, value);
			}
		}
	}
	/**
	 * Returns the number of name/value mappings in this object.
	 * @return the number of name/value mappings in this object
	 */
	public int length() {
		return this.nameValuePairs.size();
	}
	/**
	 * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with
	 * the same name.
	 * @param name the name of the property
	 * @param value the value of the property
	 * @return this object.
	 * @throws JSONException if an error occurs
	 */
	public JSONObject put(String name, boolean value) throws JSONException {
		this.nameValuePairs.put(checkName(name), value);
		return this;
	}
	/**
	 * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with
	 * the same name.
	 * @param name the name of the property
	 * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
	 * {@link Double#isInfinite() infinities}.
	 * @return this object.
	 * @throws JSONException if an error occurs
	 */
	public JSONObject put(String name, double value) throws JSONException {
		this.nameValuePairs.put(checkName(name), JSON.checkDouble(value));
		return this;
	}
	/**
	 * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with
	 * the same name.
	 * @param name the name of the property
	 * @param value the value of the property
	 * @return this object.
	 * @throws JSONException if an error occurs
	 */
	public JSONObject put(String name, int value) throws JSONException {
		this.nameValuePairs.put(checkName(name), value);
		return this;
	}
	/**
	 * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with
	 * the same name.
	 * @param name the name of the property
	 * @param value the value of the property
	 * @return this object.
	 * @throws JSONException if an error occurs
	 */
	public JSONObject put(String name, long value) throws JSONException {
		this.nameValuePairs.put(checkName(name), value);
		return this;
	}
	/**
	 * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with
	 * the same name. If the value is {@code null}, any existing mapping for {@code name}
	 * is removed.
	 * @param name the name of the property
	 * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,
	 * Long, Double, {@link #NULL}, or {@code null}. May not be {@link Double#isNaN()
	 * NaNs} or {@link Double#isInfinite() infinities}.
	 * @return this object.
	 * @throws JSONException if an error occurs
	 */
	public JSONObject put(String name, Object value) throws JSONException {
		if (value == null) {
			this.nameValuePairs.remove(name);
			return this;
		}
		if (value instanceof Number) {
			// deviate from the original by checking all Numbers, not just floats &
			// doubles
			JSON.checkDouble(((Number) value).doubleValue());
		}
		this.nameValuePairs.put(checkName(name), value);
		return this;
	}
	/**
	 * Equivalent to {@code put(name, value)} when both parameters are non-null; does
	 * nothing otherwise.
	 * @param name the name of the property
	 * @param value the value of the property
	 * @return this object.
	 * @throws JSONException if an error occurs
	 */
	public JSONObject putOpt(String name, Object value) throws JSONException {
		if (name == null || value == null) {
			return this;
		}
		return put(name, value);
	}
	/**
	 * Appends {@code value} to the array already mapped to {@code name}. If this object
	 * has no mapping for {@code name}, this inserts a new mapping. If the mapping exists
	 * but its value is not an array, the existing and new values are inserted in order
	 * into a new array which is itself mapped to {@code name}. In aggregate, this allows
	 * values to be added to a mapping one at a time.
	 * @param name the name of the property
	 * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,
	 * Long, Double, {@link #NULL} or null. May not be {@link Double#isNaN() NaNs} or
	 * {@link Double#isInfinite() infinities}.
	 * @return this object.
	 * @throws JSONException if an error occurs
	 */
	public JSONObject accumulate(String name, Object value) throws JSONException {
		Object current = this.nameValuePairs.get(checkName(name));
		if (current == null) {
			return put(name, value);
		}
		// check in accumulate, since array.put(Object) doesn"t do any checking
		if (value instanceof Number) {
			JSON.checkDouble(((Number) value).doubleValue());
		}
		if (current instanceof JSONArray array) {
			array.put(value);
		}
		else {
			JSONArray array = new JSONArray();
			array.put(current);
			array.put(value);
			this.nameValuePairs.put(name, array);
		}
		return this;
	}
	String checkName(String name) throws JSONException {
		if (name == null) {
			throw new JSONException('Names must be non-null');
		}
		return name;
	}
	/**
	 * Removes the named mapping if it exists; does nothing otherwise.
	 * @param name the name of the property
	 * @return the value previously mapped by {@code name}, or null if there was no such
	 * mapping.
	 */
	public Object remove(String name) {
		return this.nameValuePairs.remove(name);
	}
	/**
	 * Returns true if this object has no mapping for {@code name} or if it has a mapping
	 * whose value is {@link #NULL}.
	 * @param name the name of the property
	 * @return true if this object has no mapping for {@code name}
	 */
	public boolean isNull(String name) {
		Object value = this.nameValuePairs.get(name);
		return value == null || value == NULL;
	}
	/**
	 * Returns true if this object has a mapping for {@code name}. The mapping may be
	 * {@link #NULL}.
	 * @param name the name of the property
	 * @return true if this object has a mapping for {@code name}
	 */
	public boolean has(String name) {
		return this.nameValuePairs.containsKey(name);
	}
	/**
	 * Returns the value mapped by {@code name}.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if no such mapping exists.
	 */
	public Object get(String name) throws JSONException {
		Object result = this.nameValuePairs.get(name);
		if (result == null) {
			throw new JSONException('No value for ' + name);
		}
		return result;
	}
	/**
	 * Returns the value mapped by {@code name}, or null if no such mapping exists.
	 * @param name the name of the property
	 * @return the value or {@code null}
	 */
	public Object opt(String name) {
		return this.nameValuePairs.get(name);
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a boolean or can be
	 * coerced to a boolean.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if the mapping doesn"t exist or cannot be coerced to a
	 * boolean.
	 */
	public boolean getBoolean(String name) throws JSONException {
		Object object = get(name);
		Boolean result = JSON.toBoolean(object);
		if (result == null) {
			throw JSON.typeMismatch(name, object, 'boolean');
		}
		return result;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a boolean or can be
	 * coerced to a boolean. Returns false otherwise.
	 * @param name the name of the property
	 * @return the value or {@code null}
	 */
	public boolean optBoolean(String name) {
		return optBoolean(name, false);
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a boolean or can be
	 * coerced to a boolean. Returns {@code fallback} otherwise.
	 * @param name the name of the property
	 * @param fallback a fallback value
	 * @return the value or {@code fallback}
	 */
	public boolean optBoolean(String name, boolean fallback) {
		Object object = opt(name);
		Boolean result = JSON.toBoolean(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a double or can be
	 * coerced to a double.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if the mapping doesn"t exist or cannot be coerced to a
	 * double.
	 */
	public double getDouble(String name) throws JSONException {
		Object object = get(name);
		Double result = JSON.toDouble(object);
		if (result == null) {
			throw JSON.typeMismatch(name, object, 'double');
		}
		return result;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a double or can be
	 * coerced to a double. Returns {@code NaN} otherwise.
	 * @param name the name of the property
	 * @return the value or {@code NaN}
	 */
	public double optDouble(String name) {
		return optDouble(name, Double.NaN);
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a double or can be
	 * coerced to a double. Returns {@code fallback} otherwise.
	 * @param name the name of the property
	 * @param fallback a fallback value
	 * @return the value or {@code fallback}
	 */
	public double optDouble(String name, double fallback) {
		Object object = opt(name);
		Double result = JSON.toDouble(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is an int or can be
	 * coerced to an int.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if the mapping doesn"t exist or cannot be coerced to an int.
	 */
	public int getInt(String name) throws JSONException {
		Object object = get(name);
		Integer result = JSON.toInteger(object);
		if (result == null) {
			throw JSON.typeMismatch(name, object, 'int');
		}
		return result;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is an int or can be
	 * coerced to an int. Returns 0 otherwise.
	 * @param name the name of the property
	 * @return the value of {@code 0}
	 */
	public int optInt(String name) {
		return optInt(name, 0);
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is an int or can be
	 * coerced to an int. Returns {@code fallback} otherwise.
	 * @param name the name of the property
	 * @param fallback a fallback value
	 * @return the value or {@code fallback}
	 */
	public int optInt(String name, int fallback) {
		Object object = opt(name);
		Integer result = JSON.toInteger(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a long or can be
	 * coerced to a long. Note that JSON represents numbers as doubles, so this is
	 * <a href='#lossy'>lossy</a>; use strings to transfer numbers over JSON.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if the mapping doesn"t exist or cannot be coerced to a long.
	 */
	public long getLong(String name) throws JSONException {
		Object object = get(name);
		Long result = JSON.toLong(object);
		if (result == null) {
			throw JSON.typeMismatch(name, object, 'long');
		}
		return result;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a long or can be
	 * coerced to a long. Returns 0 otherwise. Note that JSON represents numbers as
	 * doubles, so this is <a href='#lossy'>lossy</a>; use strings to transfer numbers via
	 * JSON.
	 * @param name the name of the property
	 * @return the value or {@code 0L}
	 */
	public long optLong(String name) {
		return optLong(name, 0L);
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a long or can be
	 * coerced to a long. Returns {@code fallback} otherwise. Note that JSON represents
	 * numbers as doubles, so this is <a href='#lossy'>lossy</a>; use strings to transfer
	 * numbers over JSON.
	 * @param name the name of the property
	 * @param fallback a fallback value
	 * @return the value or {@code fallback}
	 */
	public long optLong(String name, long fallback) {
		Object object = opt(name);
		Long result = JSON.toLong(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists, coercing it if necessary.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if no such mapping exists.
	 */
	public String getString(String name) throws JSONException {
		Object object = get(name);
		String result = JSON.toString(object);
		if (result == null) {
			throw JSON.typeMismatch(name, object, 'String');
		}
		return result;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists, coercing it if necessary.
	 * Returns the empty string if no such mapping exists.
	 * @param name the name of the property
	 * @return the value or an empty string
	 */
	public String optString(String name) {
		return optString(name, '');
	}
	/**
	 * Returns the value mapped by {@code name} if it exists, coercing it if necessary.
	 * Returns {@code fallback} if no such mapping exists.
	 * @param name the name of the property
	 * @param fallback a fallback value
	 * @return the value or {@code fallback}
	 */
	public String optString(String name, String fallback) {
		Object object = opt(name);
		String result = JSON.toString(object);
		return result != null ? result : fallback;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a {@code
	 * JSONArray}.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if the mapping doesn"t exist or is not a {@code
	 *     JSONArray}.
	 */
	public JSONArray getJSONArray(String name) throws JSONException {
		Object object = get(name);
		if (object instanceof JSONArray) {
			return (JSONArray) object;
		}
		else {
			throw JSON.typeMismatch(name, object, 'JSONArray');
		}
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a {@code
	 * JSONArray}. Returns null otherwise.
	 * @param name the name of the property
	 * @return the value or {@code null}
	 */
	public JSONArray optJSONArray(String name) {
		Object object = opt(name);
		return object instanceof JSONArray ? (JSONArray) object : null;
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a {@code
	 * JSONObject}.
	 * @param name the name of the property
	 * @return the value
	 * @throws JSONException if the mapping doesn"t exist or is not a {@code
	 *     JSONObject}.
	 */
	public JSONObject getJSONObject(String name) throws JSONException {
		Object object = get(name);
		if (object instanceof JSONObject) {
			return (JSONObject) object;
		}
		else {
			throw JSON.typeMismatch(name, object, 'JSONObject');
		}
	}
	/**
	 * Returns the value mapped by {@code name} if it exists and is a {@code
	 * JSONObject}. Returns null otherwise.
	 * @param name the name of the property
	 * @return the value or {@code null}
	 */
	public JSONObject optJSONObject(String name) {
		Object object = opt(name);
		return object instanceof JSONObject ? (JSONObject) object : null;
	}
	/**
	 * Returns an array with the values corresponding to {@code names}. The array contains
	 * null for names that aren"t mapped. This method returns null if {@code names} is
	 * either null or empty.
	 * @param names the names of the properties
	 * @return the array
	 */
	public JSONArray toJSONArray(JSONArray names) {
		JSONArray result = new JSONArray();
		if (names == null) {
			return null;
		}
		int length = names.length();
		if (length == 0) {
			return null;
		}
		for (int i = 0; i < length; i++) {
			String name = JSON.toString(names.opt(i));
			result.put(opt(name));
		}
		return result;
	}
	/**
	 * Returns an iterator of the {@code String} names in this object. The returned
	 * iterator supports {@link Iterator#remove() remove}, which will remove the
	 * corresponding mapping from this object. If this object is modified after the
	 * iterator is returned, the iterator"s behavior is undefined. The order of the keys
	 * is undefined.
	 * @return the keys
	 */
	/* Return a raw type for API compatibility */
	@SuppressWarnings('rawtypes')
	public Iterator keys() {
		return this.nameValuePairs.keySet().iterator();
	}
	/**
	 * Returns an array containing the string names in this object. This method returns
	 * null if this object contains no mappings.
	 * @return the array
	 */
	public JSONArray names() {
		return this.nameValuePairs.isEmpty() ? null : new JSONArray(new ArrayList<>(this.nameValuePairs.keySet()));
	}
	/**
	 * Encodes this object as a compact JSON string, such as:
	 * <pre>{'query':'Pizza','locations':[94043,90210]}</pre>
	 * @return a string representation of the object.
	 */
	@Override
	public String toString() {
		try {
			JSONStringer stringer = new JSONStringer();
			writeTo(stringer);
			return stringer.toString();
		}
		catch (JSONException e) {
			return null;
		}
	}
	/**
	 * Encodes this object as a human-readable JSON string for debugging, such as: <pre>
	 * {
	 *     'query': 'Pizza',
	 *     'locations': [
	 *         94043,
	 *         90210
	 *     ]
	 * }</pre>
	 * @param indentSpaces the number of spaces to indent for each level of nesting.
	 * @return a string representation of the object.
	 * @throws JSONException if an error occurs
	 */
	public String toString(int indentSpaces) throws JSONException {
		JSONStringer stringer = new JSONStringer(indentSpaces);
		writeTo(stringer);
		return stringer.toString();
	}
	void writeTo(JSONStringer stringer) throws JSONException {
		stringer.object();
		for (Map.Entry<String, Object> entry : this.nameValuePairs.entrySet()) {
			stringer.key(entry.getKey()).value(entry.getValue());
		}
		stringer.endObject();
	}
	/**
	 * Encodes the number as a JSON string.
	 * @param number a finite value. May not be {@link Double#isNaN() NaNs} or
	 * {@link Double#isInfinite() infinities}.
	 * @return the encoded value
	 * @throws JSONException if an error occurs
	 */
	public static String numberToString(Number number) throws JSONException {
		if (number == null) {
			throw new JSONException('Number must be non-null');
		}
		double doubleValue = number.doubleValue();
		JSON.checkDouble(doubleValue);
		// the original returns '-0' instead of '-0.0' for negative zero
		if (number.equals(NEGATIVE_ZERO)) {
			return '-0';
		}
		long longValue = number.longValue();
		if (doubleValue == longValue) {
			return Long.toString(longValue);
		}
		return number.toString();
	}
	/**
	 * Encodes {@code data} as a JSON string. This applies quotes and any necessary
	 * character escaping.
	 * @param data the string to encode. Null will be interpreted as an empty string.
	 * @return the quoted value
	 */
	public static String quote(String data) {
		if (data == null) {
			return '\'\'';
		}
		try {
			JSONStringer stringer = new JSONStringer();
			stringer.open(JSONStringer.Scope.NULL, '');
			stringer.value(data);
			stringer.close(JSONStringer.Scope.NULL, JSONStringer.Scope.NULL, '');
			return stringer.toString();
		}
		catch (JSONException e) {
			throw new AssertionError();
		}
	}
	/**
	 * Wraps the given object if necessary.
	 * <p>
	 * If the object is null or , returns {@link #NULL}. If the object is a
	 * {@code JSONArray} or {@code JSONObject}, no wrapping is necessary. If the object is
	 * {@code NULL}, no wrapping is necessary. If the object is an array or
	 * {@code Collection}, returns an equivalent {@code JSONArray}. If the object is a
	 * {@code Map}, returns an equivalent {@code JSONObject}. If the object is a primitive
	 * wrapper type or {@code String}, returns the object. Otherwise if the object is from
	 * a {@code java} package, returns the result of {@code toString}. If wrapping fails,
	 * returns null.
	 * @param o the object to wrap
	 * @return the wrapped object
	 */
	@SuppressWarnings('rawtypes')
	public static Object wrap(Object o) {
		if (o == null) {
			return NULL;
		}
		if (o instanceof JSONArray || o instanceof JSONObject) {
			return o;
		}
		if (o.equals(NULL)) {
			return o;
		}
		try {
			if (o instanceof Collection) {
				return new JSONArray((Collection) o);
			}
			else if (o.getClass().isArray()) {
				return new JSONArray(o);
			}
			if (o instanceof Map) {
				return new JSONObject((Map) o);
			}
			if (o instanceof Boolean || o instanceof Byte || o instanceof Character || o instanceof Double
					|| o instanceof Float || o instanceof Integer || o instanceof Long || o instanceof Short
					|| o instanceof String) {
				return o;
			}
			if (o.getClass().getPackage().getName().startsWith('java.')) {
				return o.toString();
			}
		}
		catch (Exception ex) {
			// Ignore
		}
		return null;
	}
}
/*
package org.springframework.boot.configurationprocessor.json;
// Note: this class was written without inspecting the non-free org.json source code.
/**
public class JSONStringer {
	/**
	 * The output data, containing at most one top-level array or object.
	 */
	final StringBuilder out = new StringBuilder();
	/**
	 * Lexical scoping elements within this stringer, necessary to insert the appropriate
	 * separator characters (i.e. commas and colons) and to detect nesting errors.
	 */
	enum Scope {
		/**
		 * An array with no elements requires no separators or newlines before it is
		 * closed.
		 */
		EMPTY_ARRAY,
		/**
		 * An array with at least one value requires a comma and newline before the next
		 * element.
		 */
		NONEMPTY_ARRAY,
		/**
		 * An object with no keys or values requires no separators or newlines before it
		 * is closed.
		 */
		EMPTY_OBJECT,
		/**
		 * An object whose most recent element is a key. The next element must be a value.
		 */
		DANGLING_KEY,
		/**
		 * An object with at least one name/value pair requires a comma and newline before
		 * the next element.
		 */
		NONEMPTY_OBJECT,
		/**
		 * A special bracketless array needed by JSONStringer.join() and
		 * JSONObject.quote() only. Not used for JSON encoding.
		 */
		NULL
	}
	/**
	 * Unlike the original implementation, this stack isn"t limited to 20 levels of
	 * nesting.
	 */
	private final List<Scope> stack = new ArrayList<>();
	/**
	 * A string containing a full set of spaces for a single level of indentation, or null
	 * for no pretty printing.
	 */
	private final String indent;
	public JSONStringer() {
		this.indent = null;
	}
	JSONStringer(int indentSpaces) {
		char[] indentChars = new char[indentSpaces];
		Arrays.fill(indentChars, " ");
		this.indent = new String(indentChars);
	}
	/**
	 * Begins encoding a new array. Each call to this method must be paired with a call to
	 * {@link #endArray}.
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer array() throws JSONException {
		return open(Scope.EMPTY_ARRAY, '[');
	}
	/**
	 * Ends encoding the current array.
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer endArray() throws JSONException {
		return close(Scope.EMPTY_ARRAY, Scope.NONEMPTY_ARRAY, ']');
	}
	/**
	 * Begins encoding a new object. Each call to this method must be paired with a call
	 * to {@link #endObject}.
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer object() throws JSONException {
		return open(Scope.EMPTY_OBJECT, '{');
	}
	/**
	 * Ends encoding the current object.
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer endObject() throws JSONException {
		return close(Scope.EMPTY_OBJECT, Scope.NONEMPTY_OBJECT, '}');
	}
	/**
	 * Enters a new scope by appending any necessary whitespace and the given bracket.
	 * @param empty any necessary whitespace
	 * @param openBracket the open bracket
	 * @return this object
	 * @throws JSONException if processing of json failed
	 */
	JSONStringer open(Scope empty, String openBracket) throws JSONException {
		if (this.stack.isEmpty() && !this.out.isEmpty()) {
			throw new JSONException('Nesting problem: multiple top-level roots');
		}
		beforeValue();
		this.stack.add(empty);
		this.out.append(openBracket);
		return this;
	}
	/**
	 * Closes the current scope by appending any necessary whitespace and the given
	 * bracket.
	 * @param empty any necessary whitespace
	 * @param nonempty the current scope
	 * @param closeBracket the close bracket
	 * @return the JSON stringer
	 * @throws JSONException if processing of json failed
	 */
	JSONStringer close(Scope empty, Scope nonempty, String closeBracket) throws JSONException {
		Scope context = peek();
		if (context != nonempty && context != empty) {
			throw new JSONException('Nesting problem');
		}
		this.stack.remove(this.stack.size() - 1);
		if (context == nonempty) {
			newline();
		}
		this.out.append(closeBracket);
		return this;
	}
	/**
	 * Returns the value on the top of the stack.
	 * @return the scope
	 * @throws JSONException if processing of json failed
	 */
	private Scope peek() throws JSONException {
		if (this.stack.isEmpty()) {
			throw new JSONException('Nesting problem');
		}
		return this.stack.get(this.stack.size() - 1);
	}
	/**
	 * Replace the value on the top of the stack with the given value.
	 * @param topOfStack the scope at the top of the stack
	 */
	private void replaceTop(Scope topOfStack) {
		this.stack.set(this.stack.size() - 1, topOfStack);
	}
	/**
	 * Encodes {@code value}.
	 * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,
	 * Long, Double or null. May not be {@link Double#isNaN() NaNs} or
	 * {@link Double#isInfinite() infinities}.
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer value(Object value) throws JSONException {
		if (this.stack.isEmpty()) {
			throw new JSONException('Nesting problem');
		}
		if (value instanceof JSONArray) {
			((JSONArray) value).writeTo(this);
			return this;
		}
		else if (value instanceof JSONObject) {
			((JSONObject) value).writeTo(this);
			return this;
		}
		beforeValue();
		if (value == null || value instanceof Boolean || value == JSONObject.NULL) {
			this.out.append(value);
		}
		else if (value instanceof Number) {
			this.out.append(JSONObject.numberToString((Number) value));
		}
		else {
			string(value.toString());
		}
		return this;
	}
	/**
	 * Encodes {@code value} to this stringer.
	 * @param value the value to encode
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer value(boolean value) throws JSONException {
		if (this.stack.isEmpty()) {
			throw new JSONException('Nesting problem');
		}
		beforeValue();
		this.out.append(value);
		return this;
	}
	/**
	 * Encodes {@code value} to this stringer.
	 * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
	 * {@link Double#isInfinite() infinities}.
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer value(double value) throws JSONException {
		if (this.stack.isEmpty()) {
			throw new JSONException('Nesting problem');
		}
		beforeValue();
		this.out.append(JSONObject.numberToString(value));
		return this;
	}
	/**
	 * Encodes {@code value} to this stringer.
	 * @param value the value to encode
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer value(long value) throws JSONException {
		if (this.stack.isEmpty()) {
			throw new JSONException('Nesting problem');
		}
		beforeValue();
		this.out.append(value);
		return this;
	}
	private void string(String value) {
		this.out.append('\'');
		for (int i = 0, length = value.length(); i < length; i++) {
			char c = value.charAt(i);
			/*
			 * From RFC 4627, 'All Unicode characters may be placed within the quotation
			 * marks except for the characters that must be escaped: quotation mark,
			 * reverse solidus, and the control characters (U+0000 through U+001F).'
			 */
			switch (c) {
				case "'", "\\", "/" -> this.out.append("\\").append(c);
				case "\t" -> this.out.append('\\t');
				case "\b" -> this.out.append('\\b');
				case "\n" -> this.out.append('\\n');
				case "\r" -> this.out.append('\\r');
				case "\f" -> this.out.append('\\f');
				default -> {
					if (c <= 0x1F) {
						this.out.append(String.format('\\u%04x', (int) c));
					}
					else {
						this.out.append(c);
					}
				}
			}
		}
		this.out.append('\'');
	}
	private void newline() {
		if (this.indent == null) {
			return;
		}
		this.out.append('\n');
		this.out.append(this.indent.repeat(this.stack.size()));
	}
	/**
	 * Encodes the key (property name) to this stringer.
	 * @param name the name of the forthcoming value. May not be null.
	 * @return this stringer.
	 * @throws JSONException if processing of json failed
	 */
	public JSONStringer key(String name) throws JSONException {
		if (name == null) {
			throw new JSONException('Names must be non-null');
		}
		beforeKey();
		string(name);
		return this;
	}
	/**
	 * Inserts any necessary separators and whitespace before a name. Also adjusts the
	 * stack to expect the key"s value.
	 * @throws JSONException if processing of json failed
	 */
	private void beforeKey() throws JSONException {
		Scope context = peek();
		if (context == Scope.NONEMPTY_OBJECT) { // first in object
			this.out.append(",");
		}
		else if (context != Scope.EMPTY_OBJECT) { // not in an object!
			throw new JSONException('Nesting problem');
		}
		newline();
		replaceTop(Scope.DANGLING_KEY);
	}
	/**
	 * Inserts any necessary separators and whitespace before a literal value, inline
	 * array, or inline object. Also adjusts the stack to expect either a closing bracket
	 * or another element.
	 * @throws JSONException if processing of json failed
	 */
	private void beforeValue() throws JSONException {
		if (this.stack.isEmpty()) {
			return;
		}
		Scope context = peek();
		if (context == Scope.EMPTY_ARRAY) { // first in array
			replaceTop(Scope.NONEMPTY_ARRAY);
			newline();
		}
		else if (context == Scope.NONEMPTY_ARRAY) { // another in array
			this.out.append(",");
			newline();
		}
		else if (context == Scope.DANGLING_KEY) { // value for key
			this.out.append(this.indent == null ? ':' : ': ');
			replaceTop(Scope.NONEMPTY_OBJECT);
		}
		else if (context != Scope.NULL) {
			throw new JSONException('Nesting problem');
		}
	}
	/**
	 * Returns the encoded JSON string.
	 * <p>
	 * If invoked with unterminated arrays or unclosed objects, this method"s return value
	 * is undefined.
	 * <p>
	 * <strong>Warning:</strong> although it contradicts the general contract of
	 * {@link Object#toString}, this method returns null if the stringer contains no data.
	 * @return the encoded JSON string.
	 */
	@Override
	public String toString() {
		return this.out.isEmpty() ? null : this.out.toString();
	}
}
/*
package org.springframework.boot.configurationprocessor.json;
class JSON {
	static double checkDouble(double d) throws JSONException {
		if (Double.isInfinite(d) || Double.isNaN(d)) {
			throw new JSONException('Forbidden numeric value: ' + d);
		}
		return d;
	}
	static Boolean toBoolean(Object value) {
		if (value instanceof Boolean) {
			return (Boolean) value;
		}
		if (value instanceof String stringValue) {
			if ('true'.equalsIgnoreCase(stringValue)) {
				return true;
			}
			if ('false'.equalsIgnoreCase(stringValue)) {
				return false;
			}
		}
		return null;
	}
	static Double toDouble(Object value) {
		if (value instanceof Double) {
			return (Double) value;
		}
		if (value instanceof Number) {
			return ((Number) value).doubleValue();
		}
		if (value instanceof String) {
			try {
				return Double.valueOf((String) value);
			}
			catch (NumberFormatException ex) {
				// Ignore
			}
		}
		return null;
	}
	static Integer toInteger(Object value) {
		if (value instanceof Integer) {
			return (Integer) value;
		}
		if (value instanceof Number) {
			return ((Number) value).intValue();
		}
		if (value instanceof String) {
			try {
				return (int) Double.parseDouble((String) value);
			}
			catch (NumberFormatException ex) {
				// Ignore
			}
		}
		return null;
	}
	static Long toLong(Object value) {
		if (value instanceof Long) {
			return (Long) value;
		}
		if (value instanceof Number) {
			return ((Number) value).longValue();
		}
		if (value instanceof String) {
			try {
				return (long) Double.parseDouble((String) value);
			}
			catch (NumberFormatException ex) {
				// Ignore
			}
		}
		return null;
	}
	static String toString(Object value) {
		if (value instanceof String) {
			return (String) value;
		}
		if (value != null) {
			return String.valueOf(value);
		}
		return null;
	}
	public static JSONException typeMismatch(Object indexOrName, Object actual, String requiredType)
			throws JSONException {
		if (actual == null) {
			throw new JSONException('Value at ' + indexOrName + ' is null.');
		}
		throw new JSONException('Value ' + actual + ' at ' + indexOrName + ' of type ' + actual.getClass().getName()
				+ ' cannot be converted to ' + requiredType);
	}
	public static JSONException typeMismatch(Object actual, String requiredType) throws JSONException {
		if (actual == null) {
			throw new JSONException('Value is null.');
		}
		throw new JSONException('Value ' + actual + ' of type ' + actual.getClass().getName()
				+ ' cannot be converted to ' + requiredType);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class MetadataStoreTests {
	@TempDir
	File tempDir;
	private final ProcessingEnvironment environment = mock(ProcessingEnvironment.class);
	private final MetadataStore metadataStore = new MetadataStore(this.environment);
	@Test
	void additionalMetadataIsLocatedInMavenBuild() throws IOException {
		File app = new File(this.tempDir, 'app');
		File classesLocation = new File(app, 'target/classes');
		File metaInf = new File(classesLocation, 'META-INF');
		metaInf.mkdirs();
		File additionalMetadata = new File(metaInf, 'additional-spring-configuration-metadata.json');
		additionalMetadata.createNewFile();
		assertThat(this.metadataStore.locateAdditionalMetadataFile(
				new File(classesLocation, 'META-INF/additional-spring-configuration-metadata.json')))
			.isEqualTo(additionalMetadata);
	}
	@Test
	void additionalMetadataIsLocatedInGradle3Build() throws IOException {
		File app = new File(this.tempDir, 'app');
		File classesLocation = new File(app, 'build/classes/main');
		File resourcesLocation = new File(app, 'build/resources/main');
		File metaInf = new File(resourcesLocation, 'META-INF');
		metaInf.mkdirs();
		File additionalMetadata = new File(metaInf, 'additional-spring-configuration-metadata.json');
		additionalMetadata.createNewFile();
		assertThat(this.metadataStore.locateAdditionalMetadataFile(
				new File(classesLocation, 'META-INF/additional-spring-configuration-metadata.json')))
			.isEqualTo(additionalMetadata);
	}
	@Test
	void additionalMetadataIsLocatedInGradle4Build() throws IOException {
		File app = new File(this.tempDir, 'app');
		File classesLocation = new File(app, 'build/classes/java/main');
		File resourcesLocation = new File(app, 'build/resources/main');
		File metaInf = new File(resourcesLocation, 'META-INF');
		metaInf.mkdirs();
		File additionalMetadata = new File(metaInf, 'additional-spring-configuration-metadata.json');
		additionalMetadata.createNewFile();
		assertThat(this.metadataStore.locateAdditionalMetadataFile(
				new File(classesLocation, 'META-INF/additional-spring-configuration-metadata.json')))
			.isEqualTo(additionalMetadata);
	}
	@Test
	void additionalMetadataIsLocatedUsingLocationsOption() throws IOException {
		File app = new File(this.tempDir, 'app');
		File location = new File(app, 'src/main/resources');
		File metaInf = new File(location, 'META-INF');
		metaInf.mkdirs();
		File additionalMetadata = new File(metaInf, 'additional-spring-configuration-metadata.json');
		additionalMetadata.createNewFile();
		given(this.environment.getOptions()).willReturn(
				Collections.singletonMap(ConfigurationMetadataAnnotationProcessor.ADDITIONAL_METADATA_LOCATIONS_OPTION,
						location.getAbsolutePath()));
		assertThat(this.metadataStore.locateAdditionalMetadataFile(new File(app, 'foo'))).isEqualTo(additionalMetadata);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class DeducedImmutablePropertiesMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void immutableSimpleProperties() {
		ConfigurationMetadata metadata = compile(DeducedImmutableClassProperties.class);
		assertThat(metadata).has(Metadata.withGroup('test').fromSource(DeducedImmutableClassProperties.class));
		assertThat(metadata).has(Metadata.withGroup('test.nested', DeducedImmutableClassProperties.Nested.class)
			.fromSource(DeducedImmutableClassProperties.class));
		assertThat(metadata).has(Metadata.withProperty('test.nested.name', String.class)
			.fromSource(DeducedImmutableClassProperties.Nested.class));
		ItemMetadata nestedMetadata = metadata.getItems()
			.stream()
			.filter((item) -> item.getName().equals('test.nested'))
			.findFirst()
			.get();
		assertThat(nestedMetadata.getDefaultValue()).isNull();
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class ImmutablePropertiesMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void immutableSimpleProperties() {
		ConfigurationMetadata metadata = compile(ImmutableSimpleProperties.class);
		assertThat(metadata).has(Metadata.withGroup('immutable').fromSource(ImmutableSimpleProperties.class));
		assertThat(metadata).has(Metadata.withProperty('immutable.the-name', String.class)
			.fromSource(ImmutableSimpleProperties.class)
			.withDescription('The name of this simple properties.')
			.withDefaultValue('boot'));
		assertThat(metadata).has(Metadata.withProperty('immutable.flag', Boolean.class)
			.withDefaultValue(false)
			.fromSource(ImmutableSimpleProperties.class)
			.withDescription('A simple flag.')
			.withDeprecation());
		assertThat(metadata).has(Metadata.withProperty('immutable.comparator'));
		assertThat(metadata).has(Metadata.withProperty('immutable.counter'));
		assertThat(metadata.getItems()).hasSize(5);
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues;
/**
public abstract class AbstractFieldValuesProcessorTests {
	protected abstract FieldValuesParser createProcessor(ProcessingEnvironment env);
	@Test
	void getFieldValues() {
		TestProcessor processor = new TestProcessor();
		TestCompiler compiler = TestCompiler.forSystem()
			.withProcessors(processor)
			.withSources(SourceFile.forTestClass(FieldValues.class));
		compiler.compile((compiled) -> {
		});
		Map<String, Object> values = processor.getValues();
		assertThat(values.get('stringNone')).isNull();
		assertThat(values.get('stringConst')).isEqualTo('c');
		assertThat(values.get('bool')).isEqualTo(true);
		assertThat(values.get('boolNone')).isEqualTo(false);
		assertThat(values.get('boolConst')).isEqualTo(true);
		assertThat(values.get('boolObject')).isEqualTo(true);
		assertThat(values.get('boolObjectNone')).isNull();
		assertThat(values.get('boolObjectConst')).isEqualTo(true);
		assertThat(values.get('integer')).isEqualTo(1);
		assertThat(values.get('integerNone')).isEqualTo(0);
		assertThat(values.get('integerConst')).isEqualTo(2);
		assertThat(values.get('integerObject')).isEqualTo(3);
		assertThat(values.get('integerObjectNone')).isNull();
		assertThat(values.get('integerObjectConst')).isEqualTo(4);
		assertThat(values.get('charset')).isEqualTo('US-ASCII');
		assertThat(values.get('charsetConst')).isEqualTo('UTF-8');
		assertThat(values.get('mimeType')).isEqualTo('text/html');
		assertThat(values.get('mimeTypeConst')).isEqualTo('text/plain');
		assertThat(values.get('object')).isEqualTo(123);
		assertThat(values.get('objectNone')).isNull();
		assertThat(values.get('objectConst')).isEqualTo('c');
		assertThat(values.get('objectInstance')).isNull();
		assertThat(values.get('stringArray')).isEqualTo(new Object[] { 'FOO', 'BAR' });
		assertThat(values.get('stringArrayNone')).isNull();
		assertThat(values.get('stringEmptyArray')).isEqualTo(new Object[0]);
		assertThat(values.get('stringArrayConst')).isEqualTo(new Object[] { 'OK', 'KO' });
		assertThat(values.get('stringArrayConstElements')).isEqualTo(new Object[] { 'c' });
		assertThat(values.get('integerArray')).isEqualTo(new Object[] { 42, 24 });
		assertThat(values.get('unknownArray')).isNull();
		assertThat(values.get('durationNone')).isNull();
		assertThat(values.get('durationNanos')).isEqualTo('5ns');
		assertThat(values.get('durationMillis')).isEqualTo('10ms');
		assertThat(values.get('durationSeconds')).isEqualTo('20s');
		assertThat(values.get('durationMinutes')).isEqualTo('30m');
		assertThat(values.get('durationHours')).isEqualTo('40h');
		assertThat(values.get('durationDays')).isEqualTo('50d');
		assertThat(values.get('durationZero')).isEqualTo(0);
		assertThat(values.get('dataSizeNone')).isNull();
		assertThat(values.get('dataSizeBytes')).isEqualTo('5B');
		assertThat(values.get('dataSizeKilobytes')).isEqualTo('10KB');
		assertThat(values.get('dataSizeMegabytes')).isEqualTo('20MB');
		assertThat(values.get('dataSizeGigabytes')).isEqualTo('30GB');
		assertThat(values.get('dataSizeTerabytes')).isEqualTo('40TB');
		assertThat(values.get('periodNone')).isNull();
		assertThat(values.get('periodDays')).isEqualTo('3d');
		assertThat(values.get('periodWeeks')).isEqualTo('2w');
		assertThat(values.get('periodMonths')).isEqualTo('10m');
		assertThat(values.get('periodYears')).isEqualTo('15y');
		assertThat(values.get('periodZero')).isEqualTo(0);
		assertThat(values.get('enumNone')).isNull();
		assertThat(values.get('enumSimple')).isEqualTo('seconds');
		assertThat(values.get('enumQualified')).isEqualTo('hour-of-day');
		assertThat(values.get('enumWithIndirection')).isNull();
		assertThat(values.get('memberSelectInt')).isNull();
	}
	@SupportedAnnotationTypes({ 'org.springframework.boot.configurationsample.ConfigurationProperties' })
	@SupportedSourceVersion(SourceVersion.RELEASE_6)
	private final class TestProcessor extends AbstractProcessor {
		private FieldValuesParser processor;
		private final Map<String, Object> values = new HashMap<>();
		@Override
		public synchronized void init(ProcessingEnvironment env) {
			this.processor = createProcessor(env);
		}
		@Override
		public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
			for (TypeElement annotation : annotations) {
				for (Element element : roundEnv.getElementsAnnotatedWith(annotation)) {
					if (element instanceof TypeElement typeElement) {
						try {
							this.values.putAll(this.processor.getFieldValues(typeElement));
						}
						catch (Exception ex) {
							throw new IllegalStateException(ex);
						}
					}
				}
			}
			return false;
		}
		Map<String, Object> getValues() {
			return this.values;
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
class JavaCompilerFieldValuesProcessorTests extends AbstractFieldValuesProcessorTests {
	@Override
	protected FieldValuesParser createProcessor(ProcessingEnvironment env) {
		try {
			return new JavaCompilerFieldValuesParser(env);
		}
		catch (Throwable ex) {
			throw new TestAbortedException();
		}
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
public abstract class AbstractMetadataGenerationTests {
	private static final String ADDITIONAL_METADATA_FILE = 'META-INF/additional-spring-configuration-metadata.json';
	protected ConfigurationMetadata compile(Class<?>... types) {
		TestCompiler compiler = TestCompiler.forSystem().withSources(sourceFilesOf(types));
		return compile(compiler);
	}
	protected ConfigurationMetadata compile(String additionalMetadata, Class<?> type, Class<?>... types) {
		TestCompiler compiler = TestCompiler.forSystem()
			.withSources(sourceFilesOf(type))
			.withSources(sourceFilesOf(types))
			.withResources(ResourceFile.of(ADDITIONAL_METADATA_FILE, additionalMetadata));
		return compile(compiler);
	}
	protected ConfigurationMetadata compile(String... source) {
		TestCompiler compiler = TestCompiler.forSystem().withSources(sourceFilesOf(source));
		return compile(compiler);
	}
	private ConfigurationMetadata compile(TestCompiler compiler) {
		TestConfigurationMetadataAnnotationProcessor processor = new TestConfigurationMetadataAnnotationProcessor();
		compiler = compiler.withProcessors(processor);
		AtomicReference<ConfigurationMetadata> configurationMetadata = new AtomicReference<>();
		compiler.compile((compiled) -> configurationMetadata.set(CompiledMetadataReader.getMetadata(compiled)));
		return configurationMetadata.get();
	}
	private List<SourceFile> sourceFilesOf(Class<?>... types) {
		return Arrays.stream(types).map(SourceFile::forTestClass).toList();
	}
	private List<SourceFile> sourceFilesOf(String... content) {
		return Arrays.stream(content).map(SourceFile::of).toList();
	}
}
/*
package org.springframework.boot.configurationprocessor.test;
/**
public final class CompiledMetadataReader {
	private static final String METADATA_FILE = 'META-INF/spring-configuration-metadata.json';
	private CompiledMetadataReader() {
	}
	public static ConfigurationMetadata getMetadata(Compiled compiled) {
		InputStream inputStream = compiled.getClassLoader().getResourceAsStream(METADATA_FILE);
		try {
			if (inputStream != null) {
				return new JsonMarshaller().read(inputStream);
			}
			else {
				return null;
			}
		}
		catch (Exception ex) {
			throw new RuntimeException('Failed to read metadata', ex);
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.test;
/**
public class ItemMetadataAssert extends AbstractAssert<ItemMetadataAssert, ItemMetadata>
		implements AssertProvider<ItemMetadataAssert> {
	private static final Objects objects = Objects.instance();
	public ItemMetadataAssert(ItemMetadata itemMetadata) {
		super(itemMetadata, ItemMetadataAssert.class);
		objects.assertNotNull(this.info, itemMetadata);
	}
	public ItemMetadataAssert isProperty() {
		objects.assertEqual(this.info, this.actual.isOfItemType(ItemType.PROPERTY), true);
		return this;
	}
	public ItemMetadataAssert isGroup() {
		objects.assertEqual(this.info, this.actual.isOfItemType(ItemType.GROUP), true);
		return this;
	}
	public ItemMetadataAssert hasName(String name) {
		objects.assertEqual(this.info, this.actual.getName(), name);
		return this;
	}
	public ItemMetadataAssert hasType(String type) {
		objects.assertEqual(this.info, this.actual.getType(), type);
		return this;
	}
	public ItemMetadataAssert hasType(Class<?> type) {
		return hasType(type.getName());
	}
	public ItemMetadataAssert hasDescription(String description) {
		objects.assertEqual(this.info, this.actual.getDescription(), description);
		return this;
	}
	public ItemMetadataAssert hasNoDescription() {
		return hasDescription(null);
	}
	public ItemMetadataAssert hasSourceType(String type) {
		objects.assertEqual(this.info, this.actual.getSourceType(), type);
		return this;
	}
	public ItemMetadataAssert hasSourceType(Class<?> type) {
		return hasSourceType(type.getName());
	}
	public ItemMetadataAssert hasSourceMethod(String type) {
		objects.assertEqual(this.info, this.actual.getSourceMethod(), type);
		return this;
	}
	public ItemMetadataAssert hasDefaultValue(Object defaultValue) {
		objects.assertEqual(this.info, this.actual.getDefaultValue(), defaultValue);
		return this;
	}
	public ItemMetadataAssert isDeprecatedWithNoInformation() {
		assertItemDeprecation();
		return this;
	}
	public ItemMetadataAssert isDeprecatedWithReason(String reason) {
		ItemDeprecation deprecation = assertItemDeprecation();
		objects.assertEqual(this.info, deprecation.getReason(), reason);
		return this;
	}
	public ItemMetadataAssert isDeprecatedWithReplacement(String replacement) {
		ItemDeprecation deprecation = assertItemDeprecation();
		objects.assertEqual(this.info, deprecation.getReplacement(), replacement);
		return this;
	}
	public ItemMetadataAssert isNotDeprecated() {
		objects.assertNull(this.info, this.actual.getDeprecation());
		return this;
	}
	private ItemDeprecation assertItemDeprecation() {
		ItemDeprecation deprecation = this.actual.getDeprecation();
		objects.assertNotNull(this.info, deprecation);
		objects.assertNull(this.info, deprecation.getLevel());
		return deprecation;
	}
	@Override
	public ItemMetadataAssert assertThat() {
		return this;
	}
}
/*
package org.springframework.boot.configurationprocessor.test;
/**
@SupportedAnnotationTypes('*')
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class TestableAnnotationProcessor<T> extends AbstractProcessor {
	private final BiConsumer<RoundEnvironmentTester, T> consumer;
	private final Function<ProcessingEnvironment, T> factory;
	private T target;
	public TestableAnnotationProcessor(BiConsumer<RoundEnvironmentTester, T> consumer,
			Function<ProcessingEnvironment, T> factory) {
		this.consumer = consumer;
		this.factory = factory;
	}
	@Override
	public synchronized void init(ProcessingEnvironment env) {
		this.target = this.factory.apply(env);
	}
	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		RoundEnvironmentTester tester = new RoundEnvironmentTester(roundEnv);
		if (!roundEnv.getRootElements().isEmpty()) {
			this.consumer.accept(tester, this.target);
			return true;
		}
		return false;
	}
}
/*
package org.springframework.boot.configurationprocessor.test;
/**
@SupportedAnnotationTypes({ TestConfigurationMetadataAnnotationProcessor.CONFIGURATION_PROPERTIES_ANNOTATION,
		TestConfigurationMetadataAnnotationProcessor.CONTROLLER_ENDPOINT_ANNOTATION,
		TestConfigurationMetadataAnnotationProcessor.ENDPOINT_ANNOTATION,
		TestConfigurationMetadataAnnotationProcessor.JMX_ENDPOINT_ANNOTATION,
		TestConfigurationMetadataAnnotationProcessor.REST_CONTROLLER_ENDPOINT_ANNOTATION,
		TestConfigurationMetadataAnnotationProcessor.SERVLET_ENDPOINT_ANNOTATION,
		TestConfigurationMetadataAnnotationProcessor.WEB_ENDPOINT_ANNOTATION,
		'org.springframework.context.annotation.Configuration' })
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class TestConfigurationMetadataAnnotationProcessor extends ConfigurationMetadataAnnotationProcessor {
	public static final String CONFIGURATION_PROPERTIES_ANNOTATION = 'org.springframework.boot.configurationsample.ConfigurationProperties';
	public static final String NESTED_CONFIGURATION_PROPERTY_ANNOTATION = 'org.springframework.boot.configurationsample.NestedConfigurationProperty';
	public static final String DEPRECATED_CONFIGURATION_PROPERTY_ANNOTATION = 'org.springframework.boot.configurationsample.DeprecatedConfigurationProperty';
	public static final String CONSTRUCTOR_BINDING_ANNOTATION = 'org.springframework.boot.configurationsample.ConstructorBinding';
	public static final String AUTOWIRED_ANNOTATION = 'org.springframework.boot.configurationsample.Autowired';
	public static final String DEFAULT_VALUE_ANNOTATION = 'org.springframework.boot.configurationsample.DefaultValue';
	public static final String CONTROLLER_ENDPOINT_ANNOTATION = 'org.springframework.boot.configurationsample.ControllerEndpoint';
	public static final String ENDPOINT_ANNOTATION = 'org.springframework.boot.configurationsample.Endpoint';
	public static final String JMX_ENDPOINT_ANNOTATION = 'org.springframework.boot.configurationsample.JmxEndpoint';
	public static final String REST_CONTROLLER_ENDPOINT_ANNOTATION = 'org.springframework.boot.configurationsample.RestControllerEndpoint';
	public static final String SERVLET_ENDPOINT_ANNOTATION = 'org.springframework.boot.configurationsample.ServletEndpoint';
	public static final String WEB_ENDPOINT_ANNOTATION = 'org.springframework.boot.configurationsample.WebEndpoint';
	public static final String READ_OPERATION_ANNOTATION = 'org.springframework.boot.configurationsample.ReadOperation';
	public static final String NAME_ANNOTATION = 'org.springframework.boot.configurationsample.Name';
	public static final String ENDPOINT_ACCESS_ENUM = 'org.springframework.boot.configurationsample.Access';
	public TestConfigurationMetadataAnnotationProcessor() {
	}
	@Override
	protected String configurationPropertiesAnnotation() {
		return CONFIGURATION_PROPERTIES_ANNOTATION;
	}
	@Override
	protected String nestedConfigurationPropertyAnnotation() {
		return NESTED_CONFIGURATION_PROPERTY_ANNOTATION;
	}
	@Override
	protected String deprecatedConfigurationPropertyAnnotation() {
		return DEPRECATED_CONFIGURATION_PROPERTY_ANNOTATION;
	}
	@Override
	protected String constructorBindingAnnotation() {
		return CONSTRUCTOR_BINDING_ANNOTATION;
	}
	@Override
	protected String autowiredAnnotation() {
		return AUTOWIRED_ANNOTATION;
	}
	@Override
	protected String defaultValueAnnotation() {
		return DEFAULT_VALUE_ANNOTATION;
	}
	@Override
	protected Set<String> endpointAnnotations() {
		return new HashSet<>(Arrays.asList(CONTROLLER_ENDPOINT_ANNOTATION, ENDPOINT_ANNOTATION, JMX_ENDPOINT_ANNOTATION,
				REST_CONTROLLER_ENDPOINT_ANNOTATION, SERVLET_ENDPOINT_ANNOTATION, WEB_ENDPOINT_ANNOTATION));
	}
	@Override
	protected String readOperationAnnotation() {
		return READ_OPERATION_ANNOTATION;
	}
	@Override
	protected String nameAnnotation() {
		return NAME_ANNOTATION;
	}
	@Override
	protected String endpointAccessEnum() {
		return ENDPOINT_ACCESS_ENUM;
	}
}
/*
package org.springframework.boot.configurationprocessor.test;
/**
public class RoundEnvironmentTester {
	private final RoundEnvironment roundEnvironment;
	RoundEnvironmentTester(RoundEnvironment roundEnvironment) {
		this.roundEnvironment = roundEnvironment;
	}
	/**
	 * Return the root {@link TypeElement} for the specified {@code type}.
	 * @param type the type of the class
	 * @return the {@link TypeElement}
	 */
	public TypeElement getRootElement(Class<?> type) {
		return (TypeElement) this.roundEnvironment.getRootElements()
			.stream()
			.filter((element) -> element.toString().equals(type.getName()))
			.findFirst()
			.orElseThrow(() -> new IllegalStateException(
					'No element found for ' + type + ' make sure it is included in the list of classes to compile'));
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class MethodBasedMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void publicMethodConfig() {
		methodConfig(PublicMethodConfig.class, PublicMethodConfig.Foo.class);
	}
	@Test
	void protectedMethodConfig() {
		methodConfig(ProtectedMethodConfig.class, ProtectedMethodConfig.Foo.class);
	}
	@Test
	void packagePrivateMethodConfig() {
		methodConfig(PackagePrivateMethodConfig.class, PackagePrivateMethodConfig.Foo.class);
	}
	private void methodConfig(Class<?> config, Class<?> properties) {
		ConfigurationMetadata metadata = compile(config);
		assertThat(metadata).has(Metadata.withGroup('foo').fromSource(config));
		assertThat(metadata).has(Metadata.withProperty('foo.name', String.class).fromSource(properties));
		assertThat(metadata)
			.has(Metadata.withProperty('foo.flag', Boolean.class).withDefaultValue(false).fromSource(properties));
	}
	@Test
	void privateMethodConfig() {
		ConfigurationMetadata metadata = compile(PrivateMethodConfig.class);
		assertThat(metadata).isNull();
	}
	@Test
	void invalidMethodConfig() {
		ConfigurationMetadata metadata = compile(InvalidMethodConfig.class);
		assertThat(metadata)
			.has(Metadata.withProperty('something.name', String.class).fromSource(InvalidMethodConfig.class));
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('invalid.name'));
	}
	@Test
	void methodAndClassConfig() {
		ConfigurationMetadata metadata = compile(MethodAndClassConfig.class);
		assertThat(metadata)
			.has(Metadata.withProperty('conflict.name', String.class).fromSource(MethodAndClassConfig.Foo.class));
		assertThat(metadata).has(Metadata.withProperty('conflict.flag', Boolean.class)
			.withDefaultValue(false)
			.fromSource(MethodAndClassConfig.Foo.class));
		assertThat(metadata)
			.has(Metadata.withProperty('conflict.value', String.class).fromSource(MethodAndClassConfig.class));
	}
	@Test
	void singleConstructorMethodConfig() {
		ConfigurationMetadata metadata = compile(SingleConstructorMethodConfig.class);
		assertThat(metadata).doesNotHave(Metadata.withProperty('foo.my-service', Object.class)
			.fromSource(SingleConstructorMethodConfig.Foo.class));
		assertThat(metadata)
			.has(Metadata.withProperty('foo.name', String.class).fromSource(SingleConstructorMethodConfig.Foo.class));
		assertThat(metadata).has(Metadata.withProperty('foo.flag', Boolean.class)
			.withDefaultValue(false)
			.fromSource(SingleConstructorMethodConfig.Foo.class));
	}
	@Test
	void emptyTypeMethodConfig() {
		ConfigurationMetadata metadata = compile(EmptyTypeMethodConfig.class);
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('something.foo'));
	}
	@Test
	void deprecatedMethodConfig() {
		Class<DeprecatedMethodConfig> type = DeprecatedMethodConfig.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('foo').fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('foo.name', String.class)
			.fromSource(DeprecatedMethodConfig.Foo.class)
			.withDeprecation());
		assertThat(metadata).has(Metadata.withProperty('foo.flag', Boolean.class)
			.withDefaultValue(false)
			.fromSource(DeprecatedMethodConfig.Foo.class)
			.withDeprecation());
	}
	@Test
	@SuppressWarnings('deprecation')
	void deprecatedMethodConfigOnClass() {
		Class<?> type = org.springframework.boot.configurationsample.method.DeprecatedClassMethodConfig.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('foo').fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('foo.name', String.class)
			.fromSource(org.springframework.boot.configurationsample.method.DeprecatedClassMethodConfig.Foo.class)
			.withDeprecation());
		assertThat(metadata).has(Metadata.withProperty('foo.flag', Boolean.class)
			.withDefaultValue(false)
			.fromSource(org.springframework.boot.configurationsample.method.DeprecatedClassMethodConfig.Foo.class)
			.withDeprecation());
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class PropertyDescriptorResolverTests {
	@Test
	void propertiesWithJavaBeanProperties() {
		process(SimpleProperties.class,
				propertyNames((stream) -> assertThat(stream).containsExactly('theName', 'flag', 'comparator')));
	}
	@Test
	void propertiesWithJavaBeanHierarchicalProperties() {
		process(HierarchicalProperties.class,
				Arrays.asList(HierarchicalPropertiesParent.class, HierarchicalPropertiesGrandparent.class),
				(type, metadataEnv) -> {
					PropertyDescriptorResolver resolver = new PropertyDescriptorResolver(metadataEnv);
					assertThat(resolver.resolve(type, null).map(PropertyDescriptor::getName)).containsExactly('third',
							'second', 'first');
					assertThat(resolver.resolve(type, null)
						.map((descriptor) -> descriptor.getGetter().getEnclosingElement().getSimpleName().toString()))
						.containsExactly('HierarchicalProperties', 'HierarchicalPropertiesParent',
								'HierarchicalPropertiesParent');
					assertThat(resolver.resolve(type, null)
						.map((descriptor) -> descriptor.resolveItemMetadata('test', metadataEnv))
						.map(ItemMetadata::getDefaultValue)).containsExactly('three', 'two', 'one');
				});
	}
	@Test
	void propertiesWithLombokGetterSetterAtClassLevel() {
		process(LombokSimpleProperties.class, propertyNames(
				(stream) -> assertThat(stream).containsExactly('name', 'description', 'counter', 'number', 'items')));
	}
	@Test
	void propertiesWithLombokGetterSetterAtFieldLevel() {
		process(LombokExplicitProperties.class, propertyNames(
				(stream) -> assertThat(stream).containsExactly('name', 'description', 'counter', 'number', 'items')));
	}
	@Test
	void propertiesWithLombokDataClass() {
		process(LombokSimpleDataProperties.class, propertyNames(
				(stream) -> assertThat(stream).containsExactly('name', 'description', 'counter', 'number', 'items')));
	}
	@Test
	void propertiesWithLombokValueClass() {
		process(LombokSimpleValueProperties.class, propertyNames(
				(stream) -> assertThat(stream).containsExactly('name', 'description', 'counter', 'number', 'items')));
	}
	@Test
	void propertiesWithDeducedConstructorBinding() {
		process(ImmutableDeducedConstructorBindingProperties.class,
				propertyNames((stream) -> assertThat(stream).containsExactly('theName', 'flag')));
		process(ImmutableDeducedConstructorBindingProperties.class,
				properties((stream) -> assertThat(stream).isNotEmpty()
					.allMatch((predicate) -> predicate instanceof ConstructorParameterPropertyDescriptor)));
	}
	@Test
	void propertiesWithConstructorWithConstructorBinding() {
		process(ImmutableSimpleProperties.class, propertyNames(
				(stream) -> assertThat(stream).containsExactly('theName', 'flag', 'comparator', 'counter')));
		process(ImmutableSimpleProperties.class, properties((stream) -> assertThat(stream).isNotEmpty()
			.allMatch((predicate) -> predicate instanceof ConstructorParameterPropertyDescriptor)));
	}
	@Test
	void propertiesWithConstructorAndClassConstructorBinding() {
		process(ImmutableClassConstructorBindingProperties.class,
				propertyNames((stream) -> assertThat(stream).containsExactly('name', 'description')));
		process(ImmutableClassConstructorBindingProperties.class, properties((stream) -> assertThat(stream).isNotEmpty()
			.allMatch((predicate) -> predicate instanceof ConstructorParameterPropertyDescriptor)));
	}
	@Test
	void propertiesWithAutowiredConstructor() {
		process(AutowiredProperties.class, propertyNames((stream) -> assertThat(stream).containsExactly('theName')));
		process(AutowiredProperties.class, properties((stream) -> assertThat(stream).isNotEmpty()
			.allMatch((predicate) -> predicate instanceof JavaBeanPropertyDescriptor)));
	}
	@Test
	void propertiesWithMultiConstructor() {
		process(ImmutableMultiConstructorProperties.class,
				propertyNames((stream) -> assertThat(stream).containsExactly('name', 'description')));
		process(ImmutableMultiConstructorProperties.class, properties((stream) -> assertThat(stream).isNotEmpty()
			.allMatch((predicate) -> predicate instanceof ConstructorParameterPropertyDescriptor)));
	}
	@Test
	void propertiesWithMultiConstructorNoDirective() {
		process(TwoConstructorsExample.class, propertyNames((stream) -> assertThat(stream).containsExactly('name')));
		process(TwoConstructorsExample.class,
				properties((stream) -> assertThat(stream).element(0).isInstanceOf(JavaBeanPropertyDescriptor.class)));
	}
	@Test
	void contructorParameterPropertyWithNameAnnotationParameter() {
		process(ConstructorParameterNameAnnotationProperties.class,
				propertyNames((stream) -> assertThat(stream).containsExactly('import')));
	}
	@Test
	void recordComponentPropertyWithNameAnnotationParameter() {
		process(RecordComponentNameAnnotationProperties.class,
				propertyNames((stream) -> assertThat(stream).containsExactly('import')));
	}
	@Test
	void javaBeanPropertyWithNameAnnotationParameter() {
		process(JavaBeanNameAnnotationProperties.class,
				propertyNames((stream) -> assertThat(stream).containsExactly('import')));
	}
	private BiConsumer<TypeElement, MetadataGenerationEnvironment> properties(
			Consumer<Stream<PropertyDescriptor>> stream) {
		return (element, metadataEnv) -> {
			PropertyDescriptorResolver resolver = new PropertyDescriptorResolver(metadataEnv);
			stream.accept(resolver.resolve(element, null));
		};
	}
	private BiConsumer<TypeElement, MetadataGenerationEnvironment> propertyNames(Consumer<Stream<String>> stream) {
		return properties((result) -> stream.accept(result.map(PropertyDescriptor::getName)));
	}
	private void process(Class<?> target, BiConsumer<TypeElement, MetadataGenerationEnvironment> consumer) {
		process(target, Collections.emptyList(), consumer);
	}
	private void process(Class<?> target, Collection<Class<?>> additionalClasses,
			BiConsumer<TypeElement, MetadataGenerationEnvironment> consumer) {
		BiConsumer<RoundEnvironmentTester, MetadataGenerationEnvironment> internalConsumer = (roundEnv,
				metadataEnv) -> {
			TypeElement element = roundEnv.getRootElement(target);
			consumer.accept(element, metadataEnv);
		};
		TestableAnnotationProcessor<MetadataGenerationEnvironment> processor = new TestableAnnotationProcessor<>(
				internalConsumer, new MetadataGenerationEnvironmentFactory());
		SourceFile targetSource = SourceFile.forTestClass(target);
		List<SourceFile> additionalSource = additionalClasses.stream().map(SourceFile::forTestClass).toList();
		TestCompiler compiler = TestCompiler.forSystem()
			.withProcessors(processor)
			.withSources(targetSource)
			.withSources(additionalSource);
		compiler.compile((compiled) -> {
		});
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class LombokPropertyDescriptorTests extends PropertyDescriptorTests {
	@Test
	void lombokSimpleProperty() {
		process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'name');
			assertThat(property.getName()).isEqualTo('name');
			assertThat(property.getField().getSimpleName()).hasToString('name');
			assertThat(property.isProperty(metadataEnv)).isTrue();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokCollectionProperty() {
		process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'items');
			assertThat(property.getName()).isEqualTo('items');
			assertThat(property.getField().getSimpleName()).hasToString('items');
			assertThat(property.isProperty(metadataEnv)).isTrue();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokNestedPropertySameClass() {
		process(LombokInnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokInnerClassProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'first');
			assertThat(property.getName()).isEqualTo('first');
			assertThat(property.getField().getSimpleName()).hasToString('first');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isTrue();
		});
	}
	@Test
	void lombokNestedPropertyWithAnnotation() {
		process(LombokInnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokInnerClassProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'third');
			assertThat(property.getName()).isEqualTo('third');
			assertThat(property.getField().getSimpleName()).hasToString('third');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isTrue();
		});
	}
	@Test
	void lombokSimplePropertyWithOnlyGetterOnClassShouldNotBeExposed() {
		process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'ignored');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokSimplePropertyWithOnlyGetterOnDataClassShouldNotBeExposed() {
		process(LombokSimpleDataProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleDataProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'ignored');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokSimplePropertyWithOnlyGetterOnValueClassShouldNotBeExposed() {
		process(LombokSimpleValueProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleValueProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'ignored');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokSimplePropertyWithOnlyGetterOnFieldShouldNotBeExposed() {
		process(LombokExplicitProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokExplicitProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'ignoredOnlyGetter');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokSimplePropertyWithOnlySetterOnFieldShouldNotBeExposed() {
		process(LombokExplicitProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokExplicitProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'ignoredOnlySetter');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokMetadataSimpleProperty() {
		process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'description');
			assertItemMetadata(metadataEnv, property).isProperty()
				.hasName('test.description')
				.hasType(String.class)
				.hasSourceType(LombokSimpleProperties.class)
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void lombokMetadataCollectionProperty() {
		process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'items');
			assertItemMetadata(metadataEnv, property).isProperty()
				.hasName('test.items')
				.hasType('java.util.List<java.lang.String>')
				.hasSourceType(LombokSimpleProperties.class)
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void lombokMetadataNestedGroup() {
		process(LombokInnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokInnerClassProperties.class);
			VariableElement field = getField(ownerElement, 'third');
			ExecutableElement getter = getMethod(ownerElement, 'getThird');
			LombokPropertyDescriptor property = new LombokPropertyDescriptor('third', field.asType(), ownerElement,
					getter, null, field, null);
			assertItemMetadata(metadataEnv, property).isGroup()
				.hasName('test.third')
				.hasType('org.springframework.boot.configurationsample.lombok.SimpleLombokPojo')
				.hasSourceType(LombokInnerClassProperties.class)
				.hasSourceMethod('getThird()')
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void lombokMetadataNestedGroupNoGetter() {
		process(LombokInnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokInnerClassProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'first');
			assertItemMetadata(metadataEnv, property).isGroup()
				.hasName('test.first')
				.hasType('org.springframework.boot.configurationsample.lombok.LombokInnerClassProperties$Foo')
				.hasSourceType(LombokInnerClassProperties.class)
				.hasSourceMethod(null)
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void lombokMetadataNotACandidatePropertyShouldReturnNull() {
		process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'ignored');
			assertThat(property.resolveItemMetadata('test', metadataEnv)).isNull();
		});
	}
	@Test
	@SuppressWarnings('deprecation')
	void lombokDeprecatedPropertyOnClass() {
		process(org.springframework.boot.configurationsample.lombok.LombokDeprecatedProperties.class,
				(roundEnv, metadataEnv) -> {
					TypeElement ownerElement = roundEnv.getRootElement(
							org.springframework.boot.configurationsample.lombok.LombokDeprecatedProperties.class);
					LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'name');
					assertItemMetadata(metadataEnv, property).isProperty().isDeprecatedWithNoInformation();
				});
	}
	@Test
	void lombokDeprecatedPropertyOnField() {
		process(LombokDeprecatedSingleProperty.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokDeprecatedSingleProperty.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'name');
			assertItemMetadata(metadataEnv, property).isProperty().isDeprecatedWithNoInformation();
		});
	}
	@Test
	void lombokPropertyWithDescription() {
		process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'name');
			assertItemMetadata(metadataEnv, property).isProperty().hasDescription('Name description.');
		});
	}
	@Test
	void lombokPropertyWithDefaultValue() {
		process(LombokDefaultValueProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(LombokDefaultValueProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'description');
			assertItemMetadata(metadataEnv, property).isProperty().hasDefaultValue('my description');
		});
	}
	@Test
	void lombokPropertyNotCandidate() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'theName');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void lombokNestedPropertyNotCandidate() {
		process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(InnerClassProperties.class);
			LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'first');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	protected LombokPropertyDescriptor createPropertyDescriptor(TypeElement ownerElement, String name) {
		VariableElement field = getField(ownerElement, name);
		ExecutableElement getter = getMethod(ownerElement, createAccessorMethodName('get', name));
		ExecutableElement setter = getMethod(ownerElement, createAccessorMethodName('set', name));
		return new LombokPropertyDescriptor(name, field.asType(), ownerElement, getter, setter, field, null);
	}
}
/*
package org.springframework.boot.configurationprocessor;
class InheritanceMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void childProperties() {
		ConfigurationMetadata metadata = compile(ChildPropertiesConfig.class);
		assertThat(metadata).has(Metadata.withGroup('inheritance').fromSource(ChildPropertiesConfig.class));
		assertThat(metadata).has(Metadata.withGroup('inheritance.nest').fromSource(ChildProperties.class));
		assertThat(metadata).has(Metadata.withGroup('inheritance.child-nest').fromSource(ChildProperties.class));
		assertThat(metadata).has(Metadata.withProperty('inheritance.bool-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.int-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.long-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.nest.bool-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.nest.int-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.child-nest.bool-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.child-nest.int-value'));
	}
	@Test
	void overrideChildProperties() {
		ConfigurationMetadata metadata = compile(OverrideChildPropertiesConfig.class);
		assertThat(metadata).has(Metadata.withGroup('inheritance').fromSource(OverrideChildPropertiesConfig.class));
		assertThat(metadata).has(Metadata.withGroup('inheritance.nest').fromSource(OverrideChildProperties.class));
		assertThat(metadata).has(Metadata.withProperty('inheritance.bool-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.int-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.long-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.nest.bool-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.nest.int-value'));
		assertThat(metadata).has(Metadata.withProperty('inheritance.nest.long-value'));
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class ConfigurationMetadataAnnotationProcessorTests extends AbstractMetadataGenerationTests {
	@Test
	void supportedAnnotations() {
		assertThat(new ConfigurationMetadataAnnotationProcessor().getSupportedAnnotationTypes())
			.containsExactlyInAnyOrder('org.springframework.boot.autoconfigure.AutoConfiguration',
					'org.springframework.boot.context.properties.ConfigurationProperties',
					'org.springframework.context.annotation.Configuration',
					'org.springframework.boot.actuate.endpoint.annotation.Endpoint',
					'org.springframework.boot.actuate.endpoint.jmx.annotation.JmxEndpoint',
					'org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpoint',
					'org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint',
					'org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint',
					'org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint');
	}
	@Test
	void notAnnotated() {
		ConfigurationMetadata metadata = compile(NotAnnotated.class);
		assertThat(metadata).isNull();
	}
	@Test
	void simpleProperties() {
		ConfigurationMetadata metadata = compile(SimpleProperties.class);
		assertThat(metadata).has(Metadata.withGroup('simple').fromSource(SimpleProperties.class));
		assertThat(metadata).has(Metadata.withProperty('simple.the-name', String.class)
			.fromSource(SimpleProperties.class)
			.withDescription('The name of this simple properties.')
			.withDefaultValue('boot')
			.withDeprecation());
		assertThat(metadata).has(Metadata.withProperty('simple.flag', Boolean.class)
			.withDefaultValue(false)
			.fromSource(SimpleProperties.class)
			.withDescription('A simple flag.')
			.withDeprecation());
		assertThat(metadata).has(Metadata.withProperty('simple.comparator'));
		assertThat(metadata).doesNotHave(Metadata.withProperty('simple.counter'));
		assertThat(metadata).doesNotHave(Metadata.withProperty('simple.size'));
	}
	@Test
	void simplePrefixValueProperties() {
		ConfigurationMetadata metadata = compile(SimplePrefixValueProperties.class);
		assertThat(metadata).has(Metadata.withGroup('simple').fromSource(SimplePrefixValueProperties.class));
		assertThat(metadata)
			.has(Metadata.withProperty('simple.name', String.class).fromSource(SimplePrefixValueProperties.class));
	}
	@Test
	void simpleTypeProperties() {
		ConfigurationMetadata metadata = compile(SimpleTypeProperties.class);
		assertThat(metadata).has(Metadata.withGroup('simple.type').fromSource(SimpleTypeProperties.class));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-string', String.class));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-byte', Byte.class));
		assertThat(metadata)
			.has(Metadata.withProperty('simple.type.my-primitive-byte', Byte.class).withDefaultValue(0));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-char', Character.class));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-primitive-char', Character.class));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-boolean', Boolean.class));
		assertThat(metadata)
			.has(Metadata.withProperty('simple.type.my-primitive-boolean', Boolean.class).withDefaultValue(false));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-short', Short.class));
		assertThat(metadata)
			.has(Metadata.withProperty('simple.type.my-primitive-short', Short.class).withDefaultValue(0));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-integer', Integer.class));
		assertThat(metadata)
			.has(Metadata.withProperty('simple.type.my-primitive-integer', Integer.class).withDefaultValue(0));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-long', Long.class));
		assertThat(metadata)
			.has(Metadata.withProperty('simple.type.my-primitive-long', Long.class).withDefaultValue(0));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-double', Double.class));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-primitive-double', Double.class));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-float', Float.class));
		assertThat(metadata).has(Metadata.withProperty('simple.type.my-primitive-float', Float.class));
		assertThat(metadata.getItems()).hasSize(18);
	}
	@Test
	void hierarchicalProperties() {
		ConfigurationMetadata metadata = compile(HierarchicalProperties.class, HierarchicalPropertiesParent.class,
				HierarchicalPropertiesGrandparent.class);
		assertThat(metadata).has(Metadata.withGroup('hierarchical').fromSource(HierarchicalProperties.class));
		assertThat(metadata).has(Metadata.withProperty('hierarchical.first', String.class)
			.withDefaultValue('one')
			.fromSource(HierarchicalProperties.class));
		assertThat(metadata).has(Metadata.withProperty('hierarchical.second', String.class)
			.withDefaultValue('two')
			.fromSource(HierarchicalProperties.class));
		assertThat(metadata).has(Metadata.withProperty('hierarchical.third', String.class)
			.withDefaultValue('three')
			.fromSource(HierarchicalProperties.class));
	}
	@Test
	void enumValues() {
		ConfigurationMetadata metadata = compile(EnumValuesPojo.class);
		assertThat(metadata).has(Metadata.withGroup('test').fromSource(EnumValuesPojo.class));
		assertThat(metadata).has(Metadata.withProperty('test.seconds', ChronoUnit.class).withDefaultValue('seconds'));
		assertThat(metadata)
			.has(Metadata.withProperty('test.hour-of-day', ChronoField.class).withDefaultValue('hour-of-day'));
	}
	@Test
	void descriptionProperties() {
		ConfigurationMetadata metadata = compile(DescriptionProperties.class);
		assertThat(metadata).has(Metadata.withGroup('description').fromSource(DescriptionProperties.class));
		assertThat(metadata).has(Metadata.withProperty('description.simple', String.class)
			.fromSource(DescriptionProperties.class)
			.withDescription('A simple description.'));
		assertThat(metadata).has(Metadata.withProperty('description.multi-line', String.class)
			.fromSource(DescriptionProperties.class)
			.withDescription(
					'This is a lengthy description that spans across multiple lines to showcase that the line separators are cleaned automatically.'));
	}
	@Test
	@SuppressWarnings('deprecation')
	void deprecatedProperties() {
		Class<?> type = org.springframework.boot.configurationsample.simple.DeprecatedProperties.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('deprecated').fromSource(type));
		assertThat(metadata)
			.has(Metadata.withProperty('deprecated.name', String.class).fromSource(type).withDeprecation());
		assertThat(metadata)
			.has(Metadata.withProperty('deprecated.description', String.class).fromSource(type).withDeprecation());
	}
	@Test
	void singleDeprecatedProperty() {
		Class<?> type = DeprecatedSingleProperty.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('singledeprecated').fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('singledeprecated.new-name', String.class).fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('singledeprecated.name', String.class)
			.fromSource(type)
			.withDeprecation('renamed', 'singledeprecated.new-name', '1.2.3'));
	}
	@Test
	void singleDeprecatedFieldProperty() {
		Class<?> type = DeprecatedFieldSingleProperty.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('singlefielddeprecated').fromSource(type));
		assertThat(metadata)
			.has(Metadata.withProperty('singlefielddeprecated.name', String.class).fromSource(type).withDeprecation());
	}
	@Test
	void deprecatedOnUnrelatedSetter() {
		Class<?> type = DeprecatedUnrelatedMethodPojo.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('not.deprecated').fromSource(type));
		assertThat(metadata)
			.has(Metadata.withProperty('not.deprecated.counter', Integer.class).withNoDeprecation().fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('not.deprecated.flag', Boolean.class)
			.withDefaultValue(false)
			.withNoDeprecation()
			.fromSource(type));
	}
	@Test
	void deprecatedWithLessPreciseType() {
		Class<?> type = DeprecatedLessPreciseTypePojo.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('not.deprecated').fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('not.deprecated.flag', Boolean.class)
			.withDefaultValue(false)
			.withNoDeprecation()
			.fromSource(type));
	}
	@Test
	void deprecatedPropertyOnRecord() {
		Class<?> type = DeprecatedRecord.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('deprecated-record').fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('deprecated-record.alpha', String.class)
			.fromSource(type)
			.withDeprecation('some-reason', null, null));
		assertThat(metadata).has(Metadata.withProperty('deprecated-record.bravo', String.class).fromSource(type));
	}
	@Test
	void typBoxing() {
		Class<?> type = BoxingPojo.class;
		ConfigurationMetadata metadata = compile(type);
		assertThat(metadata).has(Metadata.withGroup('boxing').fromSource(type));
		assertThat(metadata)
			.has(Metadata.withProperty('boxing.flag', Boolean.class).withDefaultValue(false).fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('boxing.another-flag', Boolean.class).fromSource(type));
		assertThat(metadata).has(Metadata.withProperty('boxing.counter', Integer.class).fromSource(type));
	}
	@Test
	void parseCollectionConfig() {
		ConfigurationMetadata metadata = compile(SimpleCollectionProperties.class);
		// getter and setter
		assertThat(metadata).has(Metadata.withProperty('collection.integers-to-names',
				'java.util.Map<java.lang.Integer,java.lang.String>'));
		assertThat(metadata).has(Metadata.withProperty('collection.longs', 'java.util.Collection<java.lang.Long>'));
		assertThat(metadata).has(Metadata.withProperty('collection.floats', 'java.util.List<java.lang.Float>'));
		// getter only
		assertThat(metadata).has(Metadata.withProperty('collection.names-to-integers',
				'java.util.Map<java.lang.String,java.lang.Integer>'));
		assertThat(metadata).has(Metadata.withProperty('collection.bytes', 'java.util.Collection<java.lang.Byte>'));
		assertThat(metadata).has(Metadata.withProperty('collection.doubles', 'java.util.List<java.lang.Double>'));
		assertThat(metadata).has(Metadata.withProperty('collection.names-to-holders',
				'java.util.Map<java.lang.String,org.springframework.boot.configurationsample.simple.SimpleCollectionProperties$Holder<java.lang.String>>'));
	}
	@Test
	void parseArrayConfig() {
		ConfigurationMetadata metadata = compile(SimpleArrayProperties.class);
		assertThat(metadata).has(Metadata.withGroup('array').ofType(SimpleArrayProperties.class));
		assertThat(metadata).has(Metadata.withProperty('array.primitive', 'java.lang.Integer[]'));
		assertThat(metadata).has(Metadata.withProperty('array.simple', 'java.lang.String[]'));
		assertThat(metadata).has(Metadata.withProperty('array.inner',
				'org.springframework.boot.configurationsample.simple.SimpleArrayProperties$Holder[]'));
		assertThat(metadata)
			.has(Metadata.withProperty('array.name-to-integer', 'java.util.Map<java.lang.String,java.lang.Integer>[]'));
		assertThat(metadata.getItems()).hasSize(5);
	}
	@Test
	void annotatedGetter() {
		ConfigurationMetadata metadata = compile(AnnotatedGetter.class);
		assertThat(metadata).has(Metadata.withGroup('specific').fromSource(AnnotatedGetter.class));
		assertThat(metadata)
			.has(Metadata.withProperty('specific.name', String.class).fromSource(AnnotatedGetter.class));
	}
	@Test
	void staticAccessor() {
		ConfigurationMetadata metadata = compile(StaticAccessor.class);
		assertThat(metadata).has(Metadata.withGroup('specific').fromSource(StaticAccessor.class));
		assertThat(metadata).has(Metadata.withProperty('specific.counter', Integer.class)
			.fromSource(StaticAccessor.class)
			.withDefaultValue(42));
		assertThat(metadata)
			.doesNotHave(Metadata.withProperty('specific.name', String.class).fromSource(StaticAccessor.class));
		assertThat(metadata.getItems()).hasSize(2);
	}
	@Test
	void innerClassRootConfig() {
		ConfigurationMetadata metadata = compile(InnerClassRootConfig.class);
		assertThat(metadata).has(Metadata.withProperty('config.name'));
	}
	@Test
	void innerClassProperties() {
		ConfigurationMetadata metadata = compile(InnerClassProperties.class);
		assertThat(metadata).has(Metadata.withGroup('config').fromSource(InnerClassProperties.class));
		assertThat(metadata).has(Metadata.withGroup('config.first')
			.ofType(InnerClassProperties.Foo.class)
			.fromSource(InnerClassProperties.class));
		assertThat(metadata).has(Metadata.withProperty('config.first.name'));
		assertThat(metadata).has(Metadata.withProperty('config.first.bar.name'));
		assertThat(metadata).has(Metadata.withGroup('config.the-second', InnerClassProperties.Foo.class)
			.fromSource(InnerClassProperties.class));
		assertThat(metadata).has(Metadata.withProperty('config.the-second.name'));
		assertThat(metadata).has(Metadata.withProperty('config.the-second.bar.name'));
		assertThat(metadata)
			.has(Metadata.withGroup('config.third').ofType(SimplePojo.class).fromSource(InnerClassProperties.class));
		assertThat(metadata).has(Metadata.withProperty('config.third.value'));
		assertThat(metadata).has(Metadata.withProperty('config.fourth'));
		assertThat(metadata).isNotEqualTo(Metadata.withGroup('config.fourth'));
		assertThat(metadata).has(Metadata.withGroup('config.fifth')
			.ofType(DeprecatedSimplePojo.class)
			.fromSource(InnerClassProperties.class));
		assertThat(metadata).has(Metadata.withProperty('config.fifth.value').withDeprecation());
	}
	@Test
	void innerClassPropertiesHierarchical() {
		ConfigurationMetadata metadata = compile(InnerClassHierarchicalProperties.class);
		assertThat(metadata).has(Metadata.withGroup('config.foo').ofType(InnerClassHierarchicalProperties.Foo.class));
		assertThat(metadata)
			.has(Metadata.withGroup('config.foo.bar').ofType(InnerClassHierarchicalProperties.Bar.class));
		assertThat(metadata)
			.has(Metadata.withGroup('config.foo.bar.baz').ofType(InnerClassHierarchicalProperties.Foo.Baz.class));
		assertThat(metadata).has(Metadata.withProperty('config.foo.bar.baz.blah'));
		assertThat(metadata).has(Metadata.withProperty('config.foo.bar.bling'));
	}
	@Test
	void innerClassAnnotatedGetterConfig() {
		ConfigurationMetadata metadata = compile(InnerClassAnnotatedGetterConfig.class);
		assertThat(metadata).has(Metadata.withProperty('specific.value'));
		assertThat(metadata).has(Metadata.withProperty('foo.name'));
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('specific.foo'));
	}
	@Test
	void nestedClassMethod() {
		ConfigurationMetadata metadata = compile(NestedPropertiesMethod.class);
		assertThat(metadata).has(Metadata.withGroup('method-nested.nested'));
		assertThat(metadata).has(Metadata.withProperty('method-nested.nested.my-nested-property'));
		assertThat(metadata).has(Metadata.withGroup('method-nested.inner.nested'));
		assertThat(metadata).has(Metadata.withProperty('method-nested.inner.nested.my-nested-property'));
	}
	@Test
	void nestedClassChildProperties() {
		ConfigurationMetadata metadata = compile(ClassWithNestedProperties.class);
		assertThat(metadata)
			.has(Metadata.withGroup('nestedChildProps').fromSource(ClassWithNestedProperties.NestedChildClass.class));
		assertThat(metadata).has(Metadata.withProperty('nestedChildProps.child-class-property', Integer.class)
			.fromSource(ClassWithNestedProperties.NestedChildClass.class)
			.withDefaultValue(20));
		assertThat(metadata).has(Metadata.withProperty('nestedChildProps.parent-class-property', Integer.class)
			.fromSource(ClassWithNestedProperties.NestedChildClass.class)
			.withDefaultValue(10));
	}
	@Test
	void builderPojo() {
		ConfigurationMetadata metadata = compile(BuilderPojo.class);
		assertThat(metadata).has(Metadata.withProperty('builder.name'));
	}
	@Test
	void excludedTypesPojo() {
		ConfigurationMetadata metadata = compile(ExcludedTypesPojo.class);
		assertThat(metadata).has(Metadata.withProperty('excluded.name'));
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('excluded.class-loader'));
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('excluded.data-source'));
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('excluded.print-writer'));
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('excluded.writer'));
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('excluded.writer-array'));
	}
	@Test
	void invalidAccessor() {
		ConfigurationMetadata metadata = compile(InvalidAccessorProperties.class);
		assertThat(metadata).has(Metadata.withGroup('config'));
		assertThat(metadata.getItems()).hasSize(1);
	}
	@Test
	void doubleRegistration() {
		ConfigurationMetadata metadata = compile(DoubleRegistrationProperties.class);
		assertThat(metadata).has(Metadata.withGroup('one'));
		assertThat(metadata).has(Metadata.withGroup('two'));
		assertThat(metadata).has(Metadata.withProperty('one.value'));
		assertThat(metadata).has(Metadata.withProperty('two.value'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void invalidDoubleRegistration() {
		assertThatExceptionOfType(CompilationException.class)
			.isThrownBy(() -> compile(InvalidDoubleRegistrationProperties.class))
			.withMessageContaining('Unable to compile source');
	}
	@Test
	void constructorParameterPropertyWithInvalidDefaultValueOnNumber() {
		assertThatExceptionOfType(CompilationException.class)
			.isThrownBy(() -> compile(InvalidDefaultValueNumberProperties.class))
			.withMessageContaining('Unable to compile source');
	}
	@Test
	void constructorParameterPropertyWithInvalidDefaultValueOnFloatingPoint() {
		assertThatExceptionOfType(CompilationException.class)
			.isThrownBy(() -> compile(InvalidDefaultValueFloatingPointProperties.class))
			.withMessageContaining('Unable to compile source');
	}
	@Test
	void constructorParameterPropertyWithInvalidDefaultValueOnCharacter() {
		assertThatExceptionOfType(CompilationException.class)
			.isThrownBy(() -> compile(InvalidDefaultValueCharacterProperties.class))
			.withMessageContaining('Unable to compile source');
	}
	@Test
	void constructorParameterPropertyWithEmptyDefaultValueOnProperty() {
		ConfigurationMetadata metadata = compile(EmptyDefaultValueProperties.class);
		assertThat(metadata).has(Metadata.withProperty('test.name'));
		ItemMetadata nameMetadata = metadata.getItems()
			.stream()
			.filter((item) -> item.getName().equals('test.name'))
			.findFirst()
			.get();
		assertThat(nameMetadata.getDefaultValue()).isNull();
	}
	@Test
	void recursivePropertiesDoNotCauseAStackOverflow() {
		compile(RecursiveProperties.class);
	}
	@Test
	void recordProperties() {
		String source = '''
				@org.springframework.boot.configurationsample.ConfigurationProperties('implicit')
				public record ExampleRecord(String someString, Integer someInteger) {
				}
				''';
		ConfigurationMetadata metadata = compile(source);
		assertThat(metadata).has(Metadata.withProperty('implicit.some-string'));
		assertThat(metadata).has(Metadata.withProperty('implicit.some-integer'));
	}
	@Test
	void recordPropertiesWithDefaultValues() {
		String source = '''
				@org.springframework.boot.configurationsample.ConfigurationProperties('record.defaults')
				public record ExampleRecord(
					@org.springframework.boot.configurationsample.DefaultValue('An1s9n') String someString,
					@org.springframework.boot.configurationsample.DefaultValue('594') Integer someInteger) {
				}
				''';
		ConfigurationMetadata metadata = compile(source);
		assertThat(metadata)
			.has(Metadata.withProperty('record.defaults.some-string', String.class).withDefaultValue('An1s9n'));
		assertThat(metadata)
			.has(Metadata.withProperty('record.defaults.some-integer', Integer.class).withDefaultValue(594));
	}
	@Test
	void multiConstructorRecordProperties() {
		String source = '''
				@org.springframework.boot.configurationsample.ConfigurationProperties('multi')
				public record ExampleRecord(String someString, Integer someInteger) {
					@org.springframework.boot.configurationsample.ConstructorBinding
					public ExampleRecord(String someString) {
						this(someString, 42);
					}
					public ExampleRecord(Integer someInteger) {
						this('someString', someInteger);
					}
				}
				''';
		ConfigurationMetadata metadata = compile(source);
		assertThat(metadata).has(Metadata.withProperty('multi.some-string'));
		assertThat(metadata).doesNotHave(Metadata.withProperty('multi.some-integer'));
	}
	@Test
	void innerClassWithPrivateConstructor() {
		ConfigurationMetadata metadata = compile(InnerClassWithPrivateConstructor.class);
		assertThat(metadata).has(Metadata.withProperty('config.nested.name'));
		assertThat(metadata).doesNotHave(Metadata.withProperty('config.nested.ignored'));
	}
	@Test
	void recordWithGetter() {
		ConfigurationMetadata metadata = compile(RecordWithGetter.class);
		assertThat(metadata).has(Metadata.withProperty('record-with-getter.alpha'));
		assertThat(metadata).doesNotHave(Metadata.withProperty('record-with-getter.bravo'));
	}
	@Test
	void recordNested() {
		ConfigurationMetadata metadata = compile(NestedPropertiesRecord.class);
		assertThat(metadata).has(Metadata.withGroup('record-nested.nested'));
		assertThat(metadata).has(Metadata.withProperty('record-nested.nested.my-nested-property'));
		assertThat(metadata).has(Metadata.withGroup('record-nested.inner.nested'));
		assertThat(metadata).has(Metadata.withProperty('record-nested.inner.nested.my-nested-property'));
	}
	@Test
	void shouldNotMarkDbcp2UsernameOrPasswordAsDeprecated() {
		ConfigurationMetadata metadata = compile(Dbcp2Configuration.class);
		assertThat(metadata).has(Metadata.withProperty('spring.datasource.dbcp2.username').withNoDeprecation());
		assertThat(metadata).has(Metadata.withProperty('spring.datasource.dbcp2.password').withNoDeprecation());
	}
	@Test
	void recordPropertiesWithDescriptions() {
		ConfigurationMetadata metadata = compile(ExampleRecord.class);
		assertThat(metadata).has(Metadata.withProperty('record.descriptions.some-string', String.class)
			.withDescription('very long description that doesn"t fit single line and is indented'));
		assertThat(metadata).has(Metadata.withProperty('record.descriptions.some-integer', Integer.class)
			.withDescription('description with @param and @ pitfalls'));
		assertThat(metadata).has(Metadata.withProperty('record.descriptions.some-boolean', Boolean.class)
			.withDescription('description with extra spaces'));
		assertThat(metadata).has(Metadata.withProperty('record.descriptions.some-long', Long.class)
			.withDescription('description without space after asterisk'));
		assertThat(metadata).has(Metadata.withProperty('record.descriptions.some-byte', Byte.class)
			.withDescription('last description in Javadoc'));
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class LombokMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void lombokDataProperties() {
		ConfigurationMetadata metadata = compile(LombokSimpleDataProperties.class);
		assertSimpleLombokProperties(metadata, LombokSimpleDataProperties.class, 'data');
	}
	@Test
	void lombokValueProperties() {
		ConfigurationMetadata metadata = compile(LombokSimpleValueProperties.class);
		assertSimpleLombokProperties(metadata, LombokSimpleValueProperties.class, 'value');
	}
	@Test
	void lombokSimpleProperties() {
		ConfigurationMetadata metadata = compile(LombokSimpleProperties.class);
		assertSimpleLombokProperties(metadata, LombokSimpleProperties.class, 'simple');
	}
	@Test
	void lombokExplicitProperties() {
		ConfigurationMetadata metadata = compile(LombokExplicitProperties.class);
		assertSimpleLombokProperties(metadata, LombokExplicitProperties.class, 'explicit');
		assertThat(metadata.getItems()).hasSize(6);
	}
	@Test
	void lombokAccessLevelProperties() {
		ConfigurationMetadata metadata = compile(LombokAccessLevelProperties.class);
		assertAccessLevelLombokProperties(metadata, LombokAccessLevelProperties.class, 'accesslevel', 2);
	}
	@Test
	void lombokAccessLevelOverwriteDataProperties() {
		ConfigurationMetadata metadata = compile(LombokAccessLevelOverwriteDataProperties.class);
		assertAccessLevelOverwriteLombokProperties(metadata, LombokAccessLevelOverwriteDataProperties.class,
				'accesslevel.overwrite.data');
	}
	@Test
	void lombokAccessLevelOverwriteExplicitProperties() {
		ConfigurationMetadata metadata = compile(LombokAccessLevelOverwriteExplicitProperties.class);
		assertAccessLevelOverwriteLombokProperties(metadata, LombokAccessLevelOverwriteExplicitProperties.class,
				'accesslevel.overwrite.explicit');
	}
	@Test
	void lombokAccessLevelOverwriteDefaultProperties() {
		ConfigurationMetadata metadata = compile(LombokAccessLevelOverwriteDefaultProperties.class);
		assertAccessLevelOverwriteLombokProperties(metadata, LombokAccessLevelOverwriteDefaultProperties.class,
				'accesslevel.overwrite.default');
	}
	@Test
	void lombokInnerClassProperties() {
		ConfigurationMetadata metadata = compile(LombokInnerClassProperties.class);
		assertThat(metadata).has(Metadata.withGroup('config').fromSource(LombokInnerClassProperties.class));
		assertThat(metadata).has(Metadata.withGroup('config.first')
			.ofType(LombokInnerClassProperties.Foo.class)
			.fromSource(LombokInnerClassProperties.class));
		assertThat(metadata).has(Metadata.withProperty('config.first.name'));
		assertThat(metadata).has(Metadata.withProperty('config.first.bar.name'));
		assertThat(metadata).has(Metadata.withGroup('config.second', LombokInnerClassProperties.Foo.class)
			.fromSource(LombokInnerClassProperties.class));
		assertThat(metadata).has(Metadata.withProperty('config.second.name'));
		assertThat(metadata).has(Metadata.withProperty('config.second.bar.name'));
		assertThat(metadata).has(Metadata.withGroup('config.third')
			.ofType(SimpleLombokPojo.class)
			.fromSource(LombokInnerClassProperties.class));
		// For some reason the annotation processor resolves a type for SimpleLombokPojo
		// that is resolved (compiled) and the source annotations are gone. Because we
		// don"t see the @Data annotation anymore, no field is harvested. What is crazy is
		// that a sample project works fine so this seems to be related to the unit test
		// environment for some reason. assertThat(metadata,
		// containsProperty('config.third.value'));
		assertThat(metadata).has(Metadata.withProperty('config.fourth'));
		assertThat(metadata).isNotEqualTo(Metadata.withGroup('config.fourth'));
	}
	@Test
	void lombokInnerClassWithGetterProperties() {
		ConfigurationMetadata metadata = compile(LombokInnerClassWithGetterProperties.class);
		assertThat(metadata).has(Metadata.withGroup('config').fromSource(LombokInnerClassWithGetterProperties.class));
		assertThat(metadata).has(Metadata.withGroup('config.first')
			.ofType(LombokInnerClassWithGetterProperties.Foo.class)
			.fromSourceMethod('getFirst()')
			.fromSource(LombokInnerClassWithGetterProperties.class));
		assertThat(metadata).has(Metadata.withProperty('config.first.name'));
		assertThat(metadata.getItems()).hasSize(3);
	}
	private void assertSimpleLombokProperties(ConfigurationMetadata metadata, Class<?> source, String prefix) {
		assertThat(metadata).has(Metadata.withGroup(prefix).fromSource(source));
		assertThat(metadata).doesNotHave(Metadata.withProperty(prefix + '.id'));
		assertThat(metadata).has(Metadata.withProperty(prefix + '.name', String.class)
			.fromSource(source)
			.withDescription('Name description.'));
		assertThat(metadata).has(Metadata.withProperty(prefix + '.description'));
		assertThat(metadata).has(Metadata.withProperty(prefix + '.counter'));
		assertThat(metadata)
			.has(Metadata.withProperty(prefix + '.number').fromSource(source).withDefaultValue(0).withDeprecation());
		assertThat(metadata).has(Metadata.withProperty(prefix + '.items'));
		assertThat(metadata).doesNotHave(Metadata.withProperty(prefix + '.ignored'));
	}
	private void assertAccessLevelOverwriteLombokProperties(ConfigurationMetadata metadata, Class<?> source,
			String prefix) {
		assertAccessLevelLombokProperties(metadata, source, prefix, 7);
	}
	private void assertAccessLevelLombokProperties(ConfigurationMetadata metadata, Class<?> source, String prefix,
			int countNameFields) {
		assertThat(metadata).has(Metadata.withGroup(prefix).fromSource(source));
		for (int i = 0; i < countNameFields; i++) {
			assertThat(metadata).has(Metadata.withProperty(prefix + '.name' + i, String.class));
		}
		assertThat(metadata.getItems()).hasSize(1 + countNameFields);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class ConstructorParameterPropertyDescriptorTests extends PropertyDescriptorTests {
	@Test
	void constructorParameterSimpleProperty() {
		process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableSimpleProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'theName');
			assertThat(property.getName()).isEqualTo('theName');
			assertThat(property.getParameter()).hasToString('theName');
			assertThat(property.getGetter().getSimpleName()).hasToString('getTheName');
			assertThat(property.isProperty(metadataEnv)).isTrue();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void constructorParameterNestedPropertySameClass() {
		process(ImmutableInnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableInnerClassProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'first');
			assertThat(property.getName()).isEqualTo('first');
			assertThat(property.getParameter()).hasToString('first');
			assertThat(property.getGetter().getSimpleName()).hasToString('getFirst');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isTrue();
		});
	}
	@Test
	void constructorParameterNestedPropertyWithAnnotation() {
		process(ImmutableInnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableInnerClassProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'third');
			assertThat(property.getName()).isEqualTo('third');
			assertThat(property.getParameter()).hasToString('third');
			assertThat(property.getGetter().getSimpleName()).hasToString('getThird');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isTrue();
		});
	}
	@Test
	void constructorParameterSimplePropertyWithNoAccessorShouldBeExposed() {
		process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableSimpleProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'counter');
			assertThat(property.getName()).isEqualTo('counter');
			assertThat(property.getParameter()).hasToString('counter');
			assertThat(property.getGetter()).isNull();
			assertThat(property.isProperty(metadataEnv)).isTrue();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void constructorParameterMetadataSimpleProperty() {
		process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableSimpleProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'counter');
			assertItemMetadata(metadataEnv, property).isProperty()
				.hasName('test.counter')
				.hasType(Long.class)
				.hasSourceType(ImmutableSimpleProperties.class)
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void constructorParameterMetadataNestedGroup() {
		process(ImmutableInnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableInnerClassProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'first');
			assertItemMetadata(metadataEnv, property).isGroup()
				.hasName('test.first')
				.hasType('org.springframework.boot.configurationsample.immutable.ImmutableInnerClassProperties$Foo')
				.hasSourceType(ImmutableInnerClassProperties.class)
				.hasSourceMethod('getFirst()')
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void constructorParameterDeprecatedPropertyOnGetter() {
		process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableSimpleProperties.class);
			ExecutableElement getter = getMethod(ownerElement, 'isFlag');
			VariableElement field = getField(ownerElement, 'flag');
			VariableElement constructorParameter = getConstructorParameter(ownerElement, 'flag');
			ConstructorParameterPropertyDescriptor property = new ConstructorParameterPropertyDescriptor('flag',
					field.asType(), constructorParameter, ownerElement, getter, null, field);
			assertItemMetadata(metadataEnv, property).isProperty().isDeprecatedWithNoInformation();
		});
	}
	@Test
	void constructorParameterPropertyWithDescription() {
		process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableSimpleProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'theName');
			assertItemMetadata(metadataEnv, property).isProperty()
				.hasDescription('The name of this simple properties.');
		});
	}
	@Test
	void constructorParameterPropertyWithDefaultValue() {
		process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableSimpleProperties.class);
			ConstructorParameterPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'theName');
			assertItemMetadata(metadataEnv, property).isProperty().hasDefaultValue('boot');
		});
	}
	@Test
	void constructorParameterPropertyWithPrimitiveTypes() {
		process(ImmutablePrimitiveProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutablePrimitiveProperties.class);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'flag')).hasDefaultValue(false);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'octet')).hasDefaultValue((byte) 0);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'letter')).hasDefaultValue(null);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'number'))
				.hasDefaultValue((short) 0);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'counter')).hasDefaultValue(0);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'value')).hasDefaultValue(0L);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'percentage')).hasDefaultValue(0F);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'ratio')).hasDefaultValue(0D);
		});
	}
	@Test
	void constructorParameterPropertyWithPrimitiveTypesAndDefaultValues() {
		process(ImmutablePrimitiveWithDefaultsProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutablePrimitiveWithDefaultsProperties.class);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'flag')).hasDefaultValue(true);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'octet'))
				.hasDefaultValue((byte) 120);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'letter')).hasDefaultValue('a');
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'number'))
				.hasDefaultValue((short) 1000);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'counter')).hasDefaultValue(42);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'value')).hasDefaultValue(2000L);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'percentage')).hasDefaultValue(0.5F);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'ratio')).hasDefaultValue(42.42);
		});
	}
	@Test
	void constructorParameterPropertyWithPrimitiveWrapperTypesAndDefaultValues() {
		process(ImmutablePrimitiveWrapperWithDefaultsProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutablePrimitiveWrapperWithDefaultsProperties.class);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'flag')).hasDefaultValue(true);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'octet'))
				.hasDefaultValue((byte) 120);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'letter')).hasDefaultValue('a');
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'number'))
				.hasDefaultValue((short) 1000);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'counter')).hasDefaultValue(42);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'value')).hasDefaultValue(2000L);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'percentage')).hasDefaultValue(0.5F);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'ratio')).hasDefaultValue(42.42);
		});
	}
	@Test
	void constructorParameterPropertyWithCollectionTypesAndDefaultValues() {
		process(ImmutableCollectionProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(ImmutableCollectionProperties.class);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'names')).hasDefaultValue(null);
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'flags'))
				.hasDefaultValue(Arrays.asList(true, false));
			assertItemMetadata(metadataEnv, createPropertyDescriptor(ownerElement, 'durations'))
				.hasDefaultValue(Arrays.asList('10s', '1m', '1h'));
		});
	}
	protected ConstructorParameterPropertyDescriptor createPropertyDescriptor(TypeElement ownerElement, String name) {
		VariableElement constructorParameter = getConstructorParameter(ownerElement, name);
		VariableElement field = getField(ownerElement, name);
		ExecutableElement getter = getMethod(ownerElement, createAccessorMethodName('get', name));
		ExecutableElement setter = getMethod(ownerElement, createAccessorMethodName('set', name));
		return new ConstructorParameterPropertyDescriptor(name, field.asType(), constructorParameter, ownerElement,
				getter, setter, field);
	}
	private VariableElement getConstructorParameter(TypeElement ownerElement, String name) {
		List<ExecutableElement> constructors = ElementFilter.constructorsIn(ownerElement.getEnclosedElements())
			.stream()
			.filter((constructor) -> !constructor.getParameters().isEmpty())
			.toList();
		if (constructors.size() != 1) {
			throw new IllegalStateException('No candidate constructor for ' + ownerElement);
		}
		return constructors.get(0)
			.getParameters()
			.stream()
			.filter((parameter) -> parameter.getSimpleName().toString().equals(name))
			.findFirst()
			.orElse(null);
	}
}
/*
package org.springframework.boot.configurationprocessor.support;
/**
class ConventionUtilsTests {
	@Test
	void toDashedCaseCamelCase() {
		assertThat(toDashedCase('simpleCamelCase')).isEqualTo('simple-camel-case');
	}
	@Test
	void toDashedCaseUpperCamelCaseSuffix() {
		assertThat(toDashedCase('myDLQ')).isEqualTo('my-d-l-q');
	}
	@Test
	void toDashedCaseUpperCamelCaseMiddle() {
		assertThat(toDashedCase('someDLQKey')).isEqualTo('some-d-l-q-key');
	}
	@Test
	void toDashedCaseWordsUnderscore() {
		assertThat(toDashedCase('Word_With_underscore')).isEqualTo('word-with-underscore');
	}
	@Test
	void toDashedCaseWordsSeveralUnderscores() {
		assertThat(toDashedCase('Word___With__underscore')).isEqualTo('word---with--underscore');
	}
	@Test
	void toDashedCaseLowerCaseUnderscore() {
		assertThat(toDashedCase('lower_underscore')).isEqualTo('lower-underscore');
	}
	@Test
	void toDashedCaseUpperUnderscoreSuffix() {
		assertThat(toDashedCase('my_DLQ')).isEqualTo('my-d-l-q');
	}
	@Test
	void toDashedCaseUpperUnderscoreMiddle() {
		assertThat(toDashedCase('some_DLQ_key')).isEqualTo('some-d-l-q-key');
	}
	@Test
	void toDashedCaseMultipleUnderscores() {
		assertThat(toDashedCase('super___crazy')).isEqualTo('super---crazy');
	}
	@Test
	void toDashedCaseLowercase() {
		assertThat(toDashedCase('lowercase')).isEqualTo('lowercase');
	}
	private String toDashedCase(String name) {
		return ConventionUtils.toDashedCase(name);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class MetadataGenerationEnvironmentFactory implements Function<ProcessingEnvironment, MetadataGenerationEnvironment> {
	@Override
	public MetadataGenerationEnvironment apply(ProcessingEnvironment environment) {
		Set<String> endpointAnnotations = new HashSet<>(
				Arrays.asList(TestConfigurationMetadataAnnotationProcessor.CONTROLLER_ENDPOINT_ANNOTATION,
						TestConfigurationMetadataAnnotationProcessor.ENDPOINT_ANNOTATION,
						TestConfigurationMetadataAnnotationProcessor.REST_CONTROLLER_ENDPOINT_ANNOTATION,
						TestConfigurationMetadataAnnotationProcessor.SERVLET_ENDPOINT_ANNOTATION,
						TestConfigurationMetadataAnnotationProcessor.WEB_ENDPOINT_ANNOTATION));
		return new MetadataGenerationEnvironment(environment,
				TestConfigurationMetadataAnnotationProcessor.CONFIGURATION_PROPERTIES_ANNOTATION,
				TestConfigurationMetadataAnnotationProcessor.NESTED_CONFIGURATION_PROPERTY_ANNOTATION,
				TestConfigurationMetadataAnnotationProcessor.DEPRECATED_CONFIGURATION_PROPERTY_ANNOTATION,
				TestConfigurationMetadataAnnotationProcessor.CONSTRUCTOR_BINDING_ANNOTATION,
				TestConfigurationMetadataAnnotationProcessor.AUTOWIRED_ANNOTATION,
				TestConfigurationMetadataAnnotationProcessor.DEFAULT_VALUE_ANNOTATION, endpointAnnotations,
				TestConfigurationMetadataAnnotationProcessor.READ_OPERATION_ANNOTATION,
				TestConfigurationMetadataAnnotationProcessor.NAME_ANNOTATION);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class GenericsMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void simpleGenericProperties() {
		ConfigurationMetadata metadata = compile(AbstractGenericProperties.class, SimpleGenericProperties.class);
		assertThat(metadata).has(Metadata.withGroup('generic').fromSource(SimpleGenericProperties.class));
		assertThat(metadata).has(Metadata.withProperty('generic.name', String.class)
			.fromSource(SimpleGenericProperties.class)
			.withDescription('Generic name.')
			.withDefaultValue(null));
		assertThat(metadata)
			.has(Metadata.withProperty('generic.mappings', 'java.util.Map<java.lang.Integer,java.time.Duration>')
				.fromSource(SimpleGenericProperties.class)
				.withDescription('Generic mappings.')
				.withDefaultValue(null));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void complexGenericProperties() {
		ConfigurationMetadata metadata = compile(ComplexGenericProperties.class);
		assertThat(metadata).has(Metadata.withGroup('generic').fromSource(ComplexGenericProperties.class));
		assertThat(metadata).has(Metadata.withGroup('generic.test')
			.ofType(UpperBoundGenericPojo.class)
			.fromSource(ComplexGenericProperties.class));
		assertThat(metadata)
			.has(Metadata.withProperty('generic.test.mappings', 'java.util.Map<java.lang.Enum<T>,java.lang.String>')
				.fromSource(UpperBoundGenericPojo.class));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void unresolvedGenericProperties() {
		ConfigurationMetadata metadata = compile(AbstractGenericProperties.class, UnresolvedGenericProperties.class);
		assertThat(metadata).has(Metadata.withGroup('generic').fromSource(UnresolvedGenericProperties.class));
		assertThat(metadata).has(Metadata.withProperty('generic.name', String.class)
			.fromSource(UnresolvedGenericProperties.class)
			.withDescription('Generic name.')
			.withDefaultValue(null));
		assertThat(metadata)
			.has(Metadata.withProperty('generic.mappings', 'java.util.Map<java.lang.Number,java.lang.Object>')
				.fromSource(UnresolvedGenericProperties.class)
				.withDescription('Generic mappings.')
				.withDefaultValue(null));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void genericTypes() {
		ConfigurationMetadata metadata = compile(GenericConfig.class);
		assertThat(metadata).has(Metadata.withGroup('generic')
			.ofType('org.springframework.boot.configurationsample.generic.GenericConfig'));
		assertThat(metadata).has(Metadata.withGroup('generic.foo')
			.ofType('org.springframework.boot.configurationsample.generic.GenericConfig$Foo'));
		assertThat(metadata).has(Metadata.withGroup('generic.foo.bar')
			.ofType('org.springframework.boot.configurationsample.generic.GenericConfig$Bar'));
		assertThat(metadata).has(Metadata.withGroup('generic.foo.bar.biz')
			.ofType('org.springframework.boot.configurationsample.generic.GenericConfig$Bar$Biz'));
		assertThat(metadata)
			.has(Metadata.withProperty('generic.foo.name').ofType(String.class).fromSource(GenericConfig.Foo.class));
		assertThat(metadata).has(Metadata.withProperty('generic.foo.string-to-bar')
			.ofType('java.util.Map<java.lang.String,org.springframework.boot.configurationsample.generic.GenericConfig$Bar<java.lang.Integer>>')
			.fromSource(GenericConfig.Foo.class));
		assertThat(metadata).has(Metadata.withProperty('generic.foo.string-to-integer')
			.ofType('java.util.Map<java.lang.String,java.lang.Integer>')
			.fromSource(GenericConfig.Foo.class));
		assertThat(metadata).has(Metadata.withProperty('generic.foo.bar.name')
			.ofType('java.lang.String')
			.fromSource(GenericConfig.Bar.class));
		assertThat(metadata).has(Metadata.withProperty('generic.foo.bar.biz.name')
			.ofType('java.lang.String')
			.fromSource(GenericConfig.Bar.Biz.class));
		assertThat(metadata.getItems()).hasSize(9);
	}
	@Test
	void wildcardTypes() {
		ConfigurationMetadata metadata = compile(WildcardConfig.class);
		assertThat(metadata).has(Metadata.withGroup('wildcard').ofType(WildcardConfig.class));
		assertThat(metadata).has(Metadata.withProperty('wildcard.string-to-number')
			.ofType('java.util.Map<java.lang.String,? extends java.lang.Number>')
			.fromSource(WildcardConfig.class));
		assertThat(metadata).has(Metadata.withProperty('wildcard.integers')
			.ofType('java.util.List<? super java.lang.Integer>')
			.fromSource(WildcardConfig.class));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void builderPatternWithGenericReturnType() {
		ConfigurationMetadata metadata = compile(ConcreteBuilderProperties.class);
		assertThat(metadata).has(Metadata.withGroup('builder').fromSource(ConcreteBuilderProperties.class));
		assertThat(metadata)
			.has(Metadata.withProperty('builder.number', Integer.class).fromSource(ConcreteBuilderProperties.class));
		assertThat(metadata).has(
				Metadata.withProperty('builder.description', String.class).fromSource(ConcreteBuilderProperties.class));
		assertThat(metadata.getItems()).hasSize(3);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
public abstract class PropertyDescriptorTests {
	protected String createAccessorMethodName(String prefix, String name) {
		char[] chars = name.toCharArray();
		chars[0] = Character.toUpperCase(chars[0]);
		return prefix + new String(chars, 0, chars.length);
	}
	protected ExecutableElement getMethod(TypeElement element, String name) {
		return ElementFilter.methodsIn(element.getEnclosedElements())
			.stream()
			.filter((method) -> ((Element) method).getSimpleName().toString().equals(name))
			.findFirst()
			.orElse(null);
	}
	protected VariableElement getField(TypeElement element, String name) {
		return ElementFilter.fieldsIn(element.getEnclosedElements())
			.stream()
			.filter((method) -> ((Element) method).getSimpleName().toString().equals(name))
			.findFirst()
			.orElse(null);
	}
	protected ItemMetadataAssert assertItemMetadata(MetadataGenerationEnvironment metadataEnv,
			PropertyDescriptor property) {
		return new ItemMetadataAssert(property.resolveItemMetadata('test', metadataEnv));
	}
	protected void process(Class<?> target,
			BiConsumer<RoundEnvironmentTester, MetadataGenerationEnvironment> consumer) {
		TestableAnnotationProcessor<MetadataGenerationEnvironment> processor = new TestableAnnotationProcessor<>(
				consumer, new MetadataGenerationEnvironmentFactory());
		TestCompiler compiler = TestCompiler.forSystem()
			.withProcessors(processor)
			.withSources(SourceFile.forTestClass(target));
		compiler.compile((compiled) -> {
		});
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class JavaBeanPropertyDescriptorTests extends PropertyDescriptorTests {
	@Test
	void javaBeanSimpleProperty() {
		process(SimpleTypeProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleTypeProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'myString');
			assertThat(property.getName()).isEqualTo('myString');
			assertThat(property.getGetter().getSimpleName()).hasToString('getMyString');
			assertThat(property.getSetter().getSimpleName()).hasToString('setMyString');
			assertThat(property.isProperty(metadataEnv)).isTrue();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void javaBeanCollectionProperty() {
		process(SimpleCollectionProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleCollectionProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'doubles');
			assertThat(property.getName()).isEqualTo('doubles');
			assertThat(property.getGetter().getSimpleName()).hasToString('getDoubles');
			assertThat(property.getSetter()).isNull();
			assertThat(property.isProperty(metadataEnv)).isTrue();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void javaBeanNestedPropertySameClass() {
		process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(InnerClassProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'first');
			assertThat(property.getName()).isEqualTo('first');
			assertThat(property.getGetter().getSimpleName()).hasToString('getFirst');
			assertThat(property.getSetter()).isNull();
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isTrue();
		});
	}
	@Test
	void javaBeanNestedPropertyWithAnnotation() {
		process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(InnerClassProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'third');
			assertThat(property.getName()).isEqualTo('third');
			assertThat(property.getGetter().getSimpleName()).hasToString('getThird');
			assertThat(property.getSetter()).isNull();
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isTrue();
		});
	}
	@Test
	void javaBeanSimplePropertyWithOnlyGetterShouldNotBeExposed() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			ExecutableElement getter = getMethod(ownerElement, 'getSize');
			VariableElement field = getField(ownerElement, 'size');
			JavaBeanPropertyDescriptor property = new JavaBeanPropertyDescriptor('size', field.asType(), ownerElement,
					getter, null, field, getter);
			assertThat(property.getName()).isEqualTo('size');
			assertThat(property.getGetter().getSimpleName()).hasToString('getSize');
			assertThat(property.getSetter()).isNull();
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void javaBeanSimplePropertyWithOnlySetterShouldNotBeExposed() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			VariableElement field = getField(ownerElement, 'counter');
			JavaBeanPropertyDescriptor property = new JavaBeanPropertyDescriptor('counter', field.asType(),
					ownerElement, null, getMethod(ownerElement, 'setCounter'), field, null);
			assertThat(property.getName()).isEqualTo('counter');
			assertThat(property.getGetter()).isNull();
			assertThat(property.getSetter().getSimpleName()).hasToString('setCounter');
			assertThat(property.isProperty(metadataEnv)).isFalse();
			assertThat(property.isNested(metadataEnv)).isFalse();
		});
	}
	@Test
	void javaBeanMetadataSimpleProperty() {
		process(SimpleTypeProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleTypeProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'myString');
			assertItemMetadata(metadataEnv, property).isProperty()
				.hasName('test.my-string')
				.hasType(String.class)
				.hasSourceType(SimpleTypeProperties.class)
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void javaBeanMetadataCollectionProperty() {
		process(SimpleCollectionProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleCollectionProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'doubles');
			assertItemMetadata(metadataEnv, property).isProperty()
				.hasName('test.doubles')
				.hasType('java.util.List<java.lang.Double>')
				.hasSourceType(SimpleCollectionProperties.class)
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void javaBeanMetadataNestedGroup() {
		process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(InnerClassProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'first');
			assertItemMetadata(metadataEnv, property).isGroup()
				.hasName('test.first')
				.hasType('org.springframework.boot.configurationsample.specific.InnerClassProperties$Foo')
				.hasSourceType(InnerClassProperties.class)
				.hasSourceMethod('getFirst()')
				.hasNoDescription()
				.isNotDeprecated();
		});
	}
	@Test
	void javaBeanMetadataNotACandidatePropertyShouldReturnNull() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			VariableElement field = getField(ownerElement, 'counter');
			JavaBeanPropertyDescriptor property = new JavaBeanPropertyDescriptor('counter', field.asType(),
					ownerElement, null, getMethod(ownerElement, 'setCounter'), field, null);
			assertThat(property.resolveItemMetadata('test', metadataEnv)).isNull();
		});
	}
	@Test
	@SuppressWarnings('deprecation')
	void javaBeanDeprecatedPropertyOnClass() {
		process(org.springframework.boot.configurationsample.simple.DeprecatedProperties.class,
				(roundEnv, metadataEnv) -> {
					TypeElement ownerElement = roundEnv
						.getRootElement(org.springframework.boot.configurationsample.simple.DeprecatedProperties.class);
					JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'name');
					assertItemMetadata(metadataEnv, property).isProperty().isDeprecatedWithNoInformation();
				});
	}
	@Test
	void javaBeanMetadataDeprecatedPropertyWithAnnotation() {
		process(DeprecatedSingleProperty.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(DeprecatedSingleProperty.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'name');
			assertItemMetadata(metadataEnv, property).isProperty()
				.isDeprecatedWithReason('renamed')
				.isDeprecatedWithReplacement('singledeprecated.new-name');
		});
	}
	@Test
	void javaBeanDeprecatedPropertyOnGetter() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'flag', 'isFlag', 'setFlag');
			assertItemMetadata(metadataEnv, property).isProperty().isDeprecatedWithNoInformation();
		});
	}
	@Test
	void javaBeanDeprecatedPropertyOnSetter() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'theName');
			assertItemMetadata(metadataEnv, property).isProperty().isDeprecatedWithNoInformation();
		});
	}
	@Test
	void javaBeanPropertyWithDescription() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'theName');
			assertItemMetadata(metadataEnv, property).isProperty()
				.hasDescription('The name of this simple properties.');
		});
	}
	@Test
	void javaBeanPropertyWithDefaultValue() {
		process(SimpleProperties.class, (roundEnv, metadataEnv) -> {
			TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);
			JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, 'theName');
			assertItemMetadata(metadataEnv, property).isProperty().hasDefaultValue('boot');
		});
	}
	protected JavaBeanPropertyDescriptor createPropertyDescriptor(TypeElement ownerElement, String name) {
		return createPropertyDescriptor(ownerElement, name, createAccessorMethodName('get', name),
				createAccessorMethodName('set', name));
	}
	protected JavaBeanPropertyDescriptor createPropertyDescriptor(TypeElement ownerElement, String name,
			String getterName, String setterName) {
		ExecutableElement getter = getMethod(ownerElement, getterName);
		ExecutableElement setter = getMethod(ownerElement, setterName);
		VariableElement field = getField(ownerElement, name);
		return new JavaBeanPropertyDescriptor(name, getter.getReturnType(), ownerElement, getter, setter, field, null);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class TypeUtilsTests {
	@Test
	void resolveTypeDescriptorOnConcreteClass() {
		process(SimpleGenericProperties.class, (roundEnv, typeUtils) -> {
			TypeDescriptor typeDescriptor = typeUtils
				.resolveTypeDescriptor(roundEnv.getRootElement(SimpleGenericProperties.class));
			assertThat(typeDescriptor.getGenerics().keySet().stream().map(Object::toString)).containsOnly('A', 'B',
					'C');
			assertThat(typeDescriptor.resolveGeneric('A')).hasToString(String.class.getName());
			assertThat(typeDescriptor.resolveGeneric('B')).hasToString(Integer.class.getName());
			assertThat(typeDescriptor.resolveGeneric('C')).hasToString(Duration.class.getName());
		});
	}
	@Test
	void resolveTypeDescriptorOnIntermediateClass() {
		process(AbstractIntermediateGenericProperties.class, (roundEnv, typeUtils) -> {
			TypeDescriptor typeDescriptor = typeUtils
				.resolveTypeDescriptor(roundEnv.getRootElement(AbstractIntermediateGenericProperties.class));
			assertThat(typeDescriptor.getGenerics().keySet().stream().map(Object::toString)).containsOnly('A', 'B',
					'C');
			assertThat(typeDescriptor.resolveGeneric('A')).hasToString(String.class.getName());
			assertThat(typeDescriptor.resolveGeneric('B')).hasToString(Integer.class.getName());
			assertThat(typeDescriptor.resolveGeneric('C')).hasToString('C');
		});
	}
	@Test
	void resolveTypeDescriptorWithOnlyGenerics() {
		process(AbstractGenericProperties.class, (roundEnv, typeUtils) -> {
			TypeDescriptor typeDescriptor = typeUtils
				.resolveTypeDescriptor(roundEnv.getRootElement(AbstractGenericProperties.class));
			assertThat(typeDescriptor.getGenerics().keySet().stream().map(Object::toString)).containsOnly('A', 'B',
					'C');
		});
	}
	private void process(Class<?> target, BiConsumer<RoundEnvironmentTester, TypeUtils> consumer) {
		TestableAnnotationProcessor<TypeUtils> processor = new TestableAnnotationProcessor<>(consumer, TypeUtils::new);
		TestCompiler compiler = TestCompiler.forSystem()
			.withProcessors(processor)
			.withSources(SourceFile.forTestClass(target));
		compiler.compile((compiled) -> {
		});
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
public final class Metadata {
	private Metadata() {
	}
	public static MetadataItemCondition withGroup(String name) {
		return new MetadataItemCondition(ItemType.GROUP, name);
	}
	public static MetadataItemCondition withGroup(String name, Class<?> type) {
		return new MetadataItemCondition(ItemType.GROUP, name).ofType(type);
	}
	public static MetadataItemCondition withGroup(String name, String type) {
		return new MetadataItemCondition(ItemType.GROUP, name).ofType(type);
	}
	public static MetadataItemCondition withProperty(String name) {
		return new MetadataItemCondition(ItemType.PROPERTY, name);
	}
	public static MetadataItemCondition withProperty(String name, Class<?> type) {
		return new MetadataItemCondition(ItemType.PROPERTY, name).ofType(type);
	}
	public static MetadataItemCondition withProperty(String name, String type) {
		return new MetadataItemCondition(ItemType.PROPERTY, name).ofType(type);
	}
	public static Metadata.MetadataItemCondition withEnabledFlag(String key) {
		return withProperty(key).ofType(Boolean.class);
	}
	public static Metadata.MetadataItemCondition withAccess(String key) {
		return withProperty(key).ofType(Access.class);
	}
	public static MetadataHintCondition withHint(String name) {
		return new MetadataHintCondition(name);
	}
	public static class MetadataItemCondition extends Condition<ConfigurationMetadata> {
		private final ItemType itemType;
		private final String name;
		private final String type;
		private final Class<?> sourceType;
		private final String sourceMethod;
		private final String description;
		private final Object defaultValue;
		private final ItemDeprecation deprecation;
		public MetadataItemCondition(ItemType itemType, String name) {
			this(itemType, name, null, null, null, null, null, null);
		}
		public MetadataItemCondition(ItemType itemType, String name, String type, Class<?> sourceType,
				String sourceMethod, String description, Object defaultValue, ItemDeprecation deprecation) {
			this.itemType = itemType;
			this.name = name;
			this.type = type;
			this.sourceType = sourceType;
			this.sourceMethod = sourceMethod;
			this.description = description;
			this.defaultValue = defaultValue;
			this.deprecation = deprecation;
			describedAs(createDescription());
		}
		private String createDescription() {
			StringBuilder description = new StringBuilder();
			description.append('an item named "').append(this.name).append('"');
			if (this.type != null) {
				description.append(' with dataType:').append(this.type);
			}
			if (this.sourceType != null) {
				description.append(' with sourceType:').append(this.sourceType);
			}
			if (this.sourceMethod != null) {
				description.append(' with sourceMethod:').append(this.sourceMethod);
			}
			if (this.defaultValue != null) {
				description.append(' with defaultValue:').append(this.defaultValue);
			}
			if (this.description != null) {
				description.append(' with description:').append(this.description);
			}
			if (this.deprecation != null) {
				description.append(' with deprecation:').append(this.deprecation);
			}
			return description.toString();
		}
		@Override
		public boolean matches(ConfigurationMetadata value) {
			ItemMetadata itemMetadata = findItem(value, this.name);
			if (itemMetadata == null) {
				return false;
			}
			if (this.type != null && !this.type.equals(itemMetadata.getType())) {
				return false;
			}
			if (this.sourceType != null && !this.sourceType.getName().equals(itemMetadata.getSourceType())) {
				return false;
			}
			if (this.sourceMethod != null && !this.sourceMethod.equals(itemMetadata.getSourceMethod())) {
				return false;
			}
			if (this.defaultValue != null
					&& !ObjectUtils.nullSafeEquals(this.defaultValue, itemMetadata.getDefaultValue())) {
				return false;
			}
			if (this.defaultValue == null && itemMetadata.getDefaultValue() != null) {
				return false;
			}
			if (this.description != null && !this.description.equals(itemMetadata.getDescription())) {
				return false;
			}
			if (this.deprecation == null && itemMetadata.getDeprecation() != null) {
				return false;
			}
			return this.deprecation == null || this.deprecation.equals(itemMetadata.getDeprecation());
		}
		public MetadataItemCondition ofType(Class<?> dataType) {
			return new MetadataItemCondition(this.itemType, this.name, dataType.getName(), this.sourceType,
					this.sourceMethod, this.description, this.defaultValue, this.deprecation);
		}
		public MetadataItemCondition ofType(String dataType) {
			return new MetadataItemCondition(this.itemType, this.name, dataType, this.sourceType, this.sourceMethod,
					this.description, this.defaultValue, this.deprecation);
		}
		public MetadataItemCondition fromSource(Class<?> sourceType) {
			return new MetadataItemCondition(this.itemType, this.name, this.type, sourceType, this.sourceMethod,
					this.description, this.defaultValue, this.deprecation);
		}
		public MetadataItemCondition fromSourceMethod(String sourceMethod) {
			return new MetadataItemCondition(this.itemType, this.name, this.type, this.sourceType, sourceMethod,
					this.description, this.defaultValue, this.deprecation);
		}
		public MetadataItemCondition withDescription(String description) {
			return new MetadataItemCondition(this.itemType, this.name, this.type, this.sourceType, this.sourceMethod,
					description, this.defaultValue, this.deprecation);
		}
		public MetadataItemCondition withDefaultValue(Object defaultValue) {
			return new MetadataItemCondition(this.itemType, this.name, this.type, this.sourceType, this.sourceMethod,
					this.description, defaultValue, this.deprecation);
		}
		public MetadataItemCondition withDeprecation() {
			return withDeprecation(null, null, null, null);
		}
		public MetadataItemCondition withDeprecation(String reason, String replacement, String since) {
			return withDeprecation(reason, replacement, since, null);
		}
		public MetadataItemCondition withDeprecation(String reason, String replacement, String since, String level) {
			return new MetadataItemCondition(this.itemType, this.name, this.type, this.sourceType, this.sourceMethod,
					this.description, this.defaultValue, new ItemDeprecation(reason, replacement, since, level));
		}
		public MetadataItemCondition withNoDeprecation() {
			return new MetadataItemCondition(this.itemType, this.name, this.type, this.sourceType, this.sourceMethod,
					this.description, this.defaultValue, null);
		}
		private ItemMetadata findItem(ConfigurationMetadata metadata, String name) {
			List<ItemMetadata> candidates = metadata.getItems()
				.stream()
				.filter((item) -> item.isOfItemType(this.itemType) && name.equals(item.getName()))
				.toList();
			if (candidates.size() > 1) {
				throw new IllegalStateException('More than one metadata item with name "' + name + '": ' + candidates);
			}
			return (candidates.size() == 1) ? candidates.get(0) : null;
		}
	}
	public static class MetadataHintCondition extends Condition<ConfigurationMetadata> {
		private final String name;
		private final List<ItemHintValueCondition> valueConditions;
		private final List<ItemHintProviderCondition> providerConditions;
		public MetadataHintCondition(String name) {
			this.name = name;
			this.valueConditions = Collections.emptyList();
			this.providerConditions = Collections.emptyList();
		}
		public MetadataHintCondition(String name, List<ItemHintValueCondition> valueConditions,
				List<ItemHintProviderCondition> providerConditions) {
			this.name = name;
			this.valueConditions = valueConditions;
			this.providerConditions = providerConditions;
			describedAs(createDescription());
		}
		private String createDescription() {
			StringBuilder description = new StringBuilder();
			description.append('a hints name "').append(this.name).append('"');
			if (!this.valueConditions.isEmpty()) {
				description.append(' with values:').append(this.valueConditions);
			}
			if (!this.providerConditions.isEmpty()) {
				description.append(' with providers:').append(this.providerConditions);
			}
			return description.toString();
		}
		@Override
		public boolean matches(ConfigurationMetadata metadata) {
			ItemHint itemHint = getFirstHintWithName(metadata, this.name);
			if (itemHint == null) {
				return false;
			}
			return matches(itemHint, this.valueConditions) && matches(itemHint, this.providerConditions);
		}
		private boolean matches(ItemHint itemHint, List<? extends Condition<ItemHint>> conditions) {
			for (Condition<ItemHint> condition : conditions) {
				if (!condition.matches(itemHint)) {
					return false;
				}
			}
			return true;
		}
		private ItemHint getFirstHintWithName(ConfigurationMetadata metadata, String name) {
			for (ItemHint hint : metadata.getHints()) {
				if (name.equals(hint.getName())) {
					return hint;
				}
			}
			return null;
		}
		public MetadataHintCondition withValue(int index, Object value, String description) {
			return new MetadataHintCondition(this.name,
					add(this.valueConditions, new ItemHintValueCondition(index, value, description)),
					this.providerConditions);
		}
		public MetadataHintCondition withProvider(String provider) {
			return withProvider(this.providerConditions.size(), provider, null);
		}
		public MetadataHintCondition withProvider(String provider, String key, Object value) {
			return withProvider(this.providerConditions.size(), provider, Collections.singletonMap(key, value));
		}
		public MetadataHintCondition withProvider(int index, String provider, Map<String, Object> parameters) {
			return new MetadataHintCondition(this.name, this.valueConditions,
					add(this.providerConditions, new ItemHintProviderCondition(index, provider, parameters)));
		}
		private <T> List<T> add(List<T> items, T item) {
			List<T> result = new ArrayList<>(items);
			result.add(item);
			return result;
		}
	}
	static class ItemHintValueCondition extends Condition<ItemHint> {
		private final int index;
		private final Object value;
		private final String description;
		ItemHintValueCondition(int index, Object value, String description) {
			this.index = index;
			this.value = value;
			this.description = description;
			describedAs(createDescription());
		}
		private String createDescription() {
			StringBuilder description = new StringBuilder();
			description.append('value hint at index "').append(this.index).append('"');
			if (this.value != null) {
				description.append(' with value:').append(this.value);
			}
			if (this.description != null) {
				description.append(' with description:').append(this.description);
			}
			return description.toString();
		}
		@Override
		public boolean matches(ItemHint value) {
			if (this.index + 1 > value.getValues().size()) {
				return false;
			}
			ItemHint.ValueHint valueHint = value.getValues().get(this.index);
			if (this.value != null && !this.value.equals(valueHint.getValue())) {
				return false;
			}
			return this.description == null || this.description.equals(valueHint.getDescription());
		}
	}
	static class ItemHintProviderCondition extends Condition<ItemHint> {
		private final int index;
		private final String name;
		private final Map<String, Object> parameters;
		ItemHintProviderCondition(int index, String name, Map<String, Object> parameters) {
			this.index = index;
			this.name = name;
			this.parameters = parameters;
			describedAs(createDescription());
		}
		String createDescription() {
			StringBuilder description = new StringBuilder();
			description.append('value provider');
			if (this.name != null) {
				description.append(' with name:').append(this.name);
			}
			if (this.parameters != null) {
				description.append(' with parameters:').append(this.parameters);
			}
			return description.toString();
		}
		@Override
		public boolean matches(ItemHint hint) {
			if (this.index + 1 > hint.getProviders().size()) {
				return false;
			}
			ItemHint.ValueProvider valueProvider = hint.getProviders().get(this.index);
			if (this.name != null && !this.name.equals(valueProvider.getName())) {
				return false;
			}
			if (this.parameters != null) {
				for (Map.Entry<String, Object> entry : this.parameters.entrySet()) {
					if (!IsMapContaining.hasEntry(entry.getKey(), entry.getValue())
						.matches(valueProvider.getParameters())) {
						return false;
					}
				}
			}
			return true;
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
public class TestJsonConverter extends JsonConverter {
	@Override
	public JSONArray toJsonArray(ConfigurationMetadata metadata, ItemType itemType) throws Exception {
		return super.toJsonArray(metadata, itemType);
	}
	@Override
	public JSONArray toJsonArray(Collection<ItemHint> hints) throws Exception {
		return super.toJsonArray(hints);
	}
	@Override
	public JSONObject toJsonObject(ItemMetadata item) throws Exception {
		return super.toJsonObject(item);
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
class ItemMetadataTests {
	@Test
	void newItemMetadataPrefixWithCapitalizedPrefix() {
		assertThat(newItemMetadataPrefix('Prefix.', 'value')).isEqualTo('prefix.value');
	}
	@Test
	void newItemMetadataPrefixWithCamelCaseSuffix() {
		assertThat(newItemMetadataPrefix('prefix.', 'myValue')).isEqualTo('prefix.my-value');
	}
	@Test
	void newItemMetadataPrefixWithUpperCamelCaseSuffix() {
		assertThat(newItemMetadataPrefix('prefix.', 'MyValue')).isEqualTo('prefix.my-value');
	}
	private String newItemMetadataPrefix(String prefix, String suffix) {
		return ItemMetadata.newItemMetadataPrefix(prefix, suffix);
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
class JsonMarshallerTests {
	@Test
	void marshallAndUnmarshal() throws Exception {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		metadata.add(ItemMetadata.newProperty('a', 'b', StringBuffer.class.getName(), InputStream.class.getName(), null,
				'desc', 'x', new ItemDeprecation('Deprecation comment', 'b.c.d', '1.2.3')));
		metadata.add(ItemMetadata.newProperty('b.c.d', null, null, null, null, null, null, null));
		metadata.add(ItemMetadata.newProperty('c', null, null, null, null, null, 123, null));
		metadata.add(ItemMetadata.newProperty('d', null, null, null, null, null, true, null));
		metadata.add(ItemMetadata.newProperty('e', null, null, null, null, null, new String[] { 'y', 'n' }, null));
		metadata.add(ItemMetadata.newProperty('f', null, null, null, null, null, new Boolean[] { true, false }, null));
		metadata.add(ItemMetadata.newGroup('d', null, null, null));
		metadata.add(ItemMetadata.newGroup('e', null, null, 'sourceMethod'));
		metadata.add(ItemHint.newHint('a.b'));
		metadata.add(ItemHint.newHint('c', new ItemHint.ValueHint(123, 'hey'), new ItemHint.ValueHint(456, null)));
		metadata.add(new ItemHint('d', null,
				Arrays.asList(new ItemHint.ValueProvider('first', Collections.singletonMap('target', 'foo')),
						new ItemHint.ValueProvider('second', null))));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.write(metadata, outputStream);
		ConfigurationMetadata read = marshaller.read(new ByteArrayInputStream(outputStream.toByteArray()));
		assertThat(read).has(Metadata.withProperty('a.b', StringBuffer.class)
			.fromSource(InputStream.class)
			.withDescription('desc')
			.withDefaultValue('x')
			.withDeprecation('Deprecation comment', 'b.c.d', '1.2.3'));
		assertThat(read).has(Metadata.withProperty('b.c.d'));
		assertThat(read).has(Metadata.withProperty('c').withDefaultValue(123));
		assertThat(read).has(Metadata.withProperty('d').withDefaultValue(true));
		assertThat(read).has(Metadata.withProperty('e').withDefaultValue(new String[] { 'y', 'n' }));
		assertThat(read).has(Metadata.withProperty('f').withDefaultValue(new Object[] { true, false }));
		assertThat(read).has(Metadata.withGroup('d'));
		assertThat(read).has(Metadata.withGroup('e').fromSourceMethod('sourceMethod'));
		assertThat(read).has(Metadata.withHint('a.b'));
		assertThat(read).has(Metadata.withHint('c').withValue(0, 123, 'hey').withValue(1, 456, null));
		assertThat(read).has(Metadata.withHint('d').withProvider('first', 'target', 'foo').withProvider('second'));
	}
	@Test
	void marshallOrderItems() throws IOException {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		metadata.add(ItemHint.newHint('fff'));
		metadata.add(ItemHint.newHint('eee'));
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'bbb', null, null, null, null, null, null));
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'aaa', null, null, null, null, null, null));
		metadata.add(ItemMetadata.newProperty('com.example.alpha', 'ddd', null, null, null, null, null, null));
		metadata.add(ItemMetadata.newProperty('com.example.alpha', 'ccc', null, null, null, null, null, null));
		metadata.add(ItemMetadata.newGroup('com.acme.bravo', 'com.example.AnotherTestProperties', null, null));
		metadata.add(ItemMetadata.newGroup('com.acme.alpha', 'com.example.TestProperties', null, null));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.write(metadata, outputStream);
		String json = outputStream.toString();
		assertThat(json).containsSubsequence('\'groups\'', '\'com.acme.alpha\'', '\'com.acme.bravo\'', '\'properties\'',
				'\'com.example.alpha.ccc\'', '\'com.example.alpha.ddd\'', '\'com.example.bravo.aaa\'',
				'\'com.example.bravo.bbb\'', '\'hints\'', '\'eee\'', '\'fff\'');
	}
	@Test
	void marshallPutDeprecatedItemsAtTheEnd() throws IOException {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'bbb', null, null, null, null, null, null));
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'aaa', null, null, null, null, null,
				new ItemDeprecation(null, null, null, 'warning')));
		metadata.add(ItemMetadata.newProperty('com.example.alpha', 'ddd', null, null, null, null, null, null));
		metadata.add(ItemMetadata.newProperty('com.example.alpha', 'ccc', null, null, null, null, null,
				new ItemDeprecation(null, null, null, 'warning')));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.write(metadata, outputStream);
		String json = outputStream.toString();
		assertThat(json).containsSubsequence('\'properties\'', '\'com.example.alpha.ddd\'', '\'com.example.bravo.bbb\'',
				'\'com.example.alpha.ccc\'', '\'com.example.bravo.aaa\'');
	}
	@Test
	void orderingForSameGroupNames() throws IOException {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		metadata.add(ItemMetadata.newGroup('com.acme.alpha', null, 'com.example.Foo', null));
		metadata.add(ItemMetadata.newGroup('com.acme.alpha', null, 'com.example.Bar', null));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.write(metadata, outputStream);
		String json = outputStream.toString();
		assertThat(json).containsSubsequence('\'groups\'', '\'name\': \'com.acme.alpha\'',
				'\'sourceType\': \'com.example.Bar\'', '\'name\': \'com.acme.alpha\'',
				'\'sourceType\': \'com.example.Foo\'');
	}
	@Test
	void orderingForSamePropertyNames() throws IOException {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'aaa', 'java.lang.Boolean', 'com.example.Foo', null,
				null, null, null));
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'aaa', 'java.lang.Integer', 'com.example.Bar', null,
				null, null, null));
		metadata
			.add(ItemMetadata.newProperty('com.example.alpha', 'ddd', null, 'com.example.Bar', null, null, null, null));
		metadata
			.add(ItemMetadata.newProperty('com.example.alpha', 'ccc', null, 'com.example.Foo', null, null, null, null));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.write(metadata, outputStream);
		String json = outputStream.toString();
		assertThat(json).containsSubsequence('\'groups\'', '\'properties\'', '\'com.example.alpha.ccc\'',
				'com.example.Foo', '\'com.example.alpha.ddd\'', 'com.example.Bar', '\'com.example.bravo.aaa\'',
				'com.example.Bar', '\'com.example.bravo.aaa\'', 'com.example.Foo');
	}
	@Test
	void orderingForSameGroupWithNullSourceType() throws IOException {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		metadata.add(ItemMetadata.newGroup('com.acme.alpha', null, 'com.example.Foo', null));
		metadata.add(ItemMetadata.newGroup('com.acme.alpha', null, null, null));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.write(metadata, outputStream);
		String json = outputStream.toString();
		assertThat(json).containsSubsequence('\'groups\'', '\'name\': \'com.acme.alpha\'',
				'\'name\': \'com.acme.alpha\'', '\'sourceType\': \'com.example.Foo\'');
	}
	@Test
	void orderingForSamePropertyNamesWithNullSourceType() throws IOException {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'aaa', 'java.lang.Boolean', null, null, null, null,
				null));
		metadata.add(ItemMetadata.newProperty('com.example.bravo', 'aaa', 'java.lang.Integer', 'com.example.Bar', null,
				null, null, null));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.write(metadata, outputStream);
		String json = outputStream.toString();
		assertThat(json).containsSubsequence('\'groups\'', '\'properties\'', '\'com.example.bravo.aaa\'',
				'\'java.lang.Boolean\'', '\'com.example.bravo.aaa\'', '\'java.lang.Integer\'', '\'com.example.Bar');
	}
	@Test
	void shouldCheckRootFields() {
		String json = '''
				{
					'groups': [], 'properties': [], 'hints': [], 'dummy': []
				}''';
		assertThatException().isThrownBy(() -> read(json))
			.withMessage('Expected only keys [groups, hints, properties], but found additional keys [dummy]. Path: .');
	}
	@Test
	void shouldCheckGroupFields() {
		String json = '''
				{
					'groups': [
						{
							'name': 'g',
							'type': 'java.lang.String',
							'description': 'Some description',
							'sourceType': 'java.lang.String',
							'sourceMethod': 'some()',
							'dummy': 'dummy'
						}
					], 'properties': [], 'hints': []
				}''';
		assertThatException().isThrownBy(() -> read(json))
			.withMessage(
					'Expected only keys [description, name, sourceMethod, sourceType, type], but found additional keys [dummy]. Path: .groups.[0]');
	}
	@Test
	void shouldCheckPropertyFields() {
		String json = '''
				{
					'groups': [], 'properties': [
						{
							'name': 'name',
							'type': 'java.lang.String',
							'description': 'Some description',
							'sourceType': 'java.lang.String',
							'defaultValue': 'value',
							'deprecation': {
								'level': 'warning',
								'reason': 'some reason',
								'replacement': 'name-new',
								'since': 'v17'
							},
							'deprecated': true,
							'dummy': 'dummy'
						}
					], 'hints': []
				}''';
		assertThatException().isThrownBy(() -> read(json))
			.withMessage(
					'Expected only keys [defaultValue, deprecated, deprecation, description, name, sourceType, type], but found additional keys [dummy]. Path: .properties.[0]');
	}
	@Test
	void shouldCheckPropertyDeprecationFields() {
		String json = '''
				{
					'groups': [], 'properties': [
						{
							'name': 'name',
							'type': 'java.lang.String',
							'description': 'Some description',
							'sourceType': 'java.lang.String',
							'defaultValue': 'value',
							'deprecation': {
								'level': 'warning',
								'reason': 'some reason',
								'replacement': 'name-new',
								'since': 'v17',
								'dummy': 'dummy'
							},
							'deprecated': true
						}
					], 'hints': []
				}''';
		assertThatException().isThrownBy(() -> read(json))
			.withMessage(
					'Expected only keys [level, reason, replacement, since], but found additional keys [dummy]. Path: .properties.[0].deprecation');
	}
	@Test
	void shouldCheckHintFields() {
		String json = '''
				{
					'groups': [], 'properties': [], 'hints': [
						{
							'name': 'name',
							'values': [],
							'providers': [],
							'dummy': 'dummy'
						}
					]
				}''';
		assertThatException().isThrownBy(() -> read(json))
			.withMessage(
					'Expected only keys [name, providers, values], but found additional keys [dummy]. Path: .hints.[0]');
	}
	@Test
	void shouldCheckHintValueFields() {
		String json = '''
				{
					'groups': [], 'properties': [], 'hints': [
						{
							'name': 'name',
							'values': [
								{
									'value': 'value',
									'description': 'some description',
									'dummy': 'dummy'
								}
							],
							'providers': []
						}
					]
				}''';
		assertThatException().isThrownBy(() -> read(json))
			.withMessage(
					'Expected only keys [description, value], but found additional keys [dummy]. Path: .hints.[0].values.[0]');
	}
	@Test
	void shouldCheckHintProviderFields() {
		String json = '''
				{
					'groups': [], 'properties': [], 'hints': [
						{
							'name': 'name',
							'values': [],
							'providers': [
								{
									'name': 'name',
									'parameters': {
										'target': 'jakarta.servlet.http.HttpServlet'
									},
									'dummy': 'dummy'
								}
							]
						}
					]
				}''';
		assertThatException().isThrownBy(() -> read(json))
			.withMessage(
					'Expected only keys [name, parameters], but found additional keys [dummy]. Path: .hints.[0].providers.[0]');
	}
	private void read(String json) throws Exception {
		JsonMarshaller marshaller = new JsonMarshaller();
		marshaller.read(new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)));
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class NameAnnotationPropertiesTests extends AbstractMetadataGenerationTests {
	@Test
	void constructorParameterNameAnnotationProperties() {
		ConfigurationMetadata metadata = compile(ConstructorParameterNameAnnotationProperties.class);
		assertThat(metadata).has(Metadata.withProperty('named.import', String.class)
			.fromSource(ConstructorParameterNameAnnotationProperties.class));
	}
	@Test
	void recordComponentNameAnnotationProperties() {
		ConfigurationMetadata metadata = compile(RecordComponentNameAnnotationProperties.class);
		assertThat(metadata).has(Metadata.withProperty('named.import', String.class)
			.fromSource(RecordComponentNameAnnotationProperties.class));
	}
	@Test
	void javaBeanNameAnnotationProperties() {
		ConfigurationMetadata metadata = compile(JavaBeanNameAnnotationProperties.class);
		assertThat(metadata).has(
				Metadata.withProperty('named.import', String.class).fromSource(JavaBeanNameAnnotationProperties.class));
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class EndpointMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void simpleEndpoint() {
		ConfigurationMetadata metadata = compile(SimpleEndpoint.class);
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.simple').fromSource(SimpleEndpoint.class));
		assertThat(metadata).has(enabledFlag('simple', true));
		assertThat(metadata).has(access('simple', Access.UNRESTRICTED));
		assertThat(metadata).has(cacheTtl('simple'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void disabledEndpoint() {
		ConfigurationMetadata metadata = compile(DisabledEndpoint.class);
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.disabled').fromSource(DisabledEndpoint.class));
		assertThat(metadata).has(enabledFlag('disabled', false));
		assertThat(metadata).has(access('disabled', Access.NONE));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void enabledEndpoint() {
		ConfigurationMetadata metadata = compile(EnabledEndpoint.class);
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.enabled').fromSource(EnabledEndpoint.class));
		assertThat(metadata).has(enabledFlag('enabled', true));
		assertThat(metadata).has(access('enabled', Access.UNRESTRICTED));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void noAccessEndpoint() {
		ConfigurationMetadata metadata = compile(NoAccessEndpoint.class);
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.noaccess').fromSource(NoAccessEndpoint.class));
		assertThat(metadata).has(enabledFlag('noaccess', false));
		assertThat(metadata).has(access('noaccess', Access.NONE));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void readOnlyAccessEndpoint() {
		ConfigurationMetadata metadata = compile(ReadOnlyAccessEndpoint.class);
		assertThat(metadata)
			.has(Metadata.withGroup('management.endpoint.readonlyaccess').fromSource(ReadOnlyAccessEndpoint.class));
		assertThat(metadata).has(enabledFlag('readonlyaccess', true));
		assertThat(metadata).has(access('readonlyaccess', Access.READ_ONLY));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void unrestrictedAccessEndpoint() {
		ConfigurationMetadata metadata = compile(UnrestrictedAccessEndpoint.class);
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.unrestrictedaccess')
			.fromSource(UnrestrictedAccessEndpoint.class));
		assertThat(metadata).has(enabledFlag('unrestrictedaccess', true));
		assertThat(metadata).has(access('unrestrictedaccess', Access.UNRESTRICTED));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void customPropertiesEndpoint() {
		ConfigurationMetadata metadata = compile(CustomPropertiesEndpoint.class);
		assertThat(metadata)
			.has(Metadata.withGroup('management.endpoint.customprops').fromSource(CustomPropertiesEndpoint.class));
		assertThat(metadata).has(Metadata.withProperty('management.endpoint.customprops.name')
			.ofType(String.class)
			.withDefaultValue('test'));
		assertThat(metadata).has(enabledFlag('customprops', true));
		assertThat(metadata).has(access('customprops', Access.UNRESTRICTED));
		assertThat(metadata).has(cacheTtl('customprops'));
		assertThat(metadata.getItems()).hasSize(5);
	}
	@Test
	void specificEndpoint() {
		ConfigurationMetadata metadata = compile(SpecificEndpoint.class);
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.specific').fromSource(SpecificEndpoint.class));
		assertThat(metadata).has(enabledFlag('specific', true));
		assertThat(metadata).has(access('specific', Access.UNRESTRICTED));
		assertThat(metadata).has(cacheTtl('specific'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void camelCaseEndpoint() {
		ConfigurationMetadata metadata = compile(CamelCaseEndpoint.class);
		assertThat(metadata)
			.has(Metadata.withGroup('management.endpoint.pascal-case').fromSource(CamelCaseEndpoint.class));
		assertThat(metadata).has(enabledFlag('PascalCase', 'pascal-case', true));
		assertThat(metadata).has(defaultAccess('PascalCase', 'pascal-case', Access.UNRESTRICTED));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void incrementalEndpointBuildChangeGeneralEnabledFlag() {
		TestProject project = new TestProject(IncrementalEndpoint.class);
		ConfigurationMetadata metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withGroup('management.endpoint.incremental').fromSource(IncrementalEndpoint.class));
		assertThat(metadata).has(enabledFlag('incremental', true));
		assertThat(metadata).has(access('incremental', Access.UNRESTRICTED));
		assertThat(metadata).has(cacheTtl('incremental'));
		assertThat(metadata.getItems()).hasSize(4);
		project.replaceText(IncrementalEndpoint.class, 'id = \'incremental\'',
				'id = \'incremental\', enableByDefault = false');
		metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withGroup('management.endpoint.incremental').fromSource(IncrementalEndpoint.class));
		assertThat(metadata).has(enabledFlag('incremental', false));
		assertThat(metadata).has(access('incremental', Access.NONE));
		assertThat(metadata).has(cacheTtl('incremental'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void incrementalEndpointBuildChangeCacheFlag() {
		TestProject project = new TestProject(IncrementalEndpoint.class);
		ConfigurationMetadata metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withGroup('management.endpoint.incremental').fromSource(IncrementalEndpoint.class));
		assertThat(metadata).has(enabledFlag('incremental', true));
		assertThat(metadata).has(access('incremental', Access.UNRESTRICTED));
		assertThat(metadata).has(cacheTtl('incremental'));
		assertThat(metadata.getItems()).hasSize(4);
		project.replaceText(IncrementalEndpoint.class, '@Nullable String param', 'String param');
		metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withGroup('management.endpoint.incremental').fromSource(IncrementalEndpoint.class));
		assertThat(metadata).has(enabledFlag('incremental', true));
		assertThat(metadata).has(access('incremental', Access.UNRESTRICTED));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void incrementalEndpointBuildEnableSpecificEndpoint() {
		TestProject project = new TestProject(SpecificEndpoint.class);
		ConfigurationMetadata metadata = project.compile();
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.specific').fromSource(SpecificEndpoint.class));
		assertThat(metadata).has(enabledFlag('specific', true));
		assertThat(metadata).has(access('specific', Access.UNRESTRICTED));
		assertThat(metadata).has(cacheTtl('specific'));
		assertThat(metadata.getItems()).hasSize(4);
		project.replaceText(SpecificEndpoint.class, 'enableByDefault = true', 'enableByDefault = false');
		metadata = project.compile();
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.specific').fromSource(SpecificEndpoint.class));
		assertThat(metadata).has(enabledFlag('specific', false));
		assertThat(metadata).has(access('specific', Access.NONE));
		assertThat(metadata).has(cacheTtl('specific'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void shouldTolerateEndpointWithSameId() {
		ConfigurationMetadata metadata = compile(SimpleEndpoint.class, SimpleEndpoint2.class);
		assertThat(metadata).has(Metadata.withGroup('management.endpoint.simple').fromSource(SimpleEndpoint.class));
		assertThat(metadata).has(enabledFlag('simple', 'simple', true));
		assertThat(metadata).has(defaultAccess('simple', 'simple', Access.UNRESTRICTED));
		assertThat(metadata).has(cacheTtl('simple'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void shouldFailIfEndpointWithSameIdButWithConflictingEnabledByDefaultSetting() {
		assertThatRuntimeException().isThrownBy(() -> compile(SimpleEndpoint.class, SimpleEndpoint3.class))
			.havingRootCause()
			.isInstanceOf(IllegalStateException.class)
			.withMessage(
					'Existing property "management.endpoint.simple.enabled" from type org.springframework.boot.configurationsample.endpoint.SimpleEndpoint has a conflicting value. Existing value: true, new value from type org.springframework.boot.configurationsample.endpoint.SimpleEndpoint3: false');
	}
	private Metadata.MetadataItemCondition enabledFlag(String endpointId, Boolean defaultValue) {
		return enabledFlag(endpointId, endpointId, defaultValue);
	}
	private Metadata.MetadataItemCondition enabledFlag(String endpointId, String endpointSuffix, Boolean defaultValue) {
		return Metadata.withEnabledFlag('management.endpoint.' + endpointSuffix + '.enabled')
			.withDefaultValue(defaultValue)
			.withDescription(String.format('Whether to enable the %s endpoint.', endpointId))
			.withDeprecation(null, 'management.endpoint.%s.access'.formatted(endpointSuffix), '3.4.0');
	}
	private Metadata.MetadataItemCondition access(String endpointId, Access defaultValue) {
		return defaultAccess(endpointId, endpointId, defaultValue);
	}
	private Metadata.MetadataItemCondition defaultAccess(String endpointId, String endpointSuffix,
			Access defaultValue) {
		return Metadata.withAccess('management.endpoint.' + endpointSuffix + '.access')
			.withDefaultValue(defaultValue.name().toLowerCase(Locale.ENGLISH))
			.withDescription('Permitted level of access for the %s endpoint.'.formatted(endpointId));
	}
	private Metadata.MetadataItemCondition cacheTtl(String endpointId) {
		return Metadata.withProperty('management.endpoint.' + endpointId + '.cache.time-to-live')
			.ofType(Duration.class)
			.withDefaultValue('0ms')
			.withDescription('Maximum time that a response can be cached.');
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
public class TestProject {
	private static final Class<?>[] ALWAYS_INCLUDE = { ConfigurationProperties.class,
			NestedConfigurationProperty.class };
	private SourceFiles sources;
	public TestProject(Class<?>... classes) {
		this.sources = SourceFiles.none().and(sourceFilesOf(ALWAYS_INCLUDE)).and(sourceFilesOf(classes));
	}
	public ConfigurationMetadata compile() {
		TestConfigurationMetadataAnnotationProcessor processor = new TestConfigurationMetadataAnnotationProcessor();
		TestCompiler compiler = TestCompiler.forSystem().withProcessors(processor);
		AtomicReference<ConfigurationMetadata> configurationMetadata = new AtomicReference<>();
		compiler.compile(this.sources,
				(compiled) -> configurationMetadata.set(CompiledMetadataReader.getMetadata(compiled)));
		return configurationMetadata.get();
	}
	/**
	 * Add source code at the end of file, just before last "}"
	 * @param target the target
	 * @param snippetStream the snippet stream
	 * @throws Exception if the source cannot be added
	 */
	public void addSourceCode(Class<?> target, InputStream snippetStream) throws Exception {
		SourceFile sourceFile = SourceFile.forTestClass(target);
		String contents = sourceFile.getContent();
		int insertAt = contents.lastIndexOf("}");
		String additionalSource = FileCopyUtils.copyToString(new InputStreamReader(snippetStream));
		contents = contents.substring(0, insertAt) + additionalSource + contents.substring(insertAt);
		this.sources = this.sources.and(SourceFile.of(contents));
	}
	/**
	 * Delete source file for given class from project.
	 * @param type the class to delete
	 */
	public void delete(Class<?> type) {
		SourceFile[] newSources = this.sources.stream()
			.filter((sourceFile) -> !sourceFile.getPath().equals(SourceFile.forTestClass(type).getPath()))
			.toArray(SourceFile[]::new);
		this.sources = SourceFiles.of(newSources);
	}
	/**
	 * Restore source code of given class to its original contents.
	 * @param type the class to revert
	 */
	public void revert(Class<?> type) {
		Assert.isTrue(this.sources.stream().anyMatch((sourceFile) -> sourceFile.getClassName().equals(type.getName())),
				'Source file for type "' + type + '" does not exist');
		this.sources = this.sources.and(SourceFile.forTestClass(type));
	}
	/**
	 * Add source code of given class to this project.
	 * @param type the class to add
	 */
	public void add(Class<?> type) {
		Assert.isTrue(this.sources.stream().noneMatch((sourceFile) -> sourceFile.getClassName().equals(type.getName())),
				'Source file for type "' + type + '" already exists');
		this.sources = this.sources.and(SourceFile.forTestClass(type));
	}
	public void replaceText(Class<?> type, String find, String replace) {
		SourceFile sourceFile = SourceFile.forTestClass(type);
		String contents = sourceFile.getContent().replace(find, replace);
		this.sources = this.sources.and(SourceFile.of(contents));
	}
	private List<SourceFile> sourceFilesOf(Class<?>... types) {
		return Arrays.stream(types).map(SourceFile::forTestClass).toList();
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class MergeMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void mergingOfAdditionalProperty() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty(null, 'foo', 'java.lang.String',
				AdditionalMetadata.class.getName(), null, null, null, null);
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.comparator'));
		assertThat(metadata).has(Metadata.withProperty('foo', String.class).fromSource(AdditionalMetadata.class));
	}
	@Test
	void mergingOfAdditionalPropertyMatchingGroup() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty(null, 'simple', 'java.lang.String', null, null, null, null,
				null);
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withGroup('simple').fromSource(SimpleProperties.class));
		assertThat(metadata).has(Metadata.withProperty('simple', String.class));
	}
	@Test
	void mergeExistingPropertyDefaultValue() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty('simple', 'flag', null, null, null, null, true, null);
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.flag', Boolean.class)
			.fromSource(SimpleProperties.class)
			.withDescription('A simple flag.')
			.withDeprecation()
			.withDefaultValue(true));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void mergeExistingPropertyWithSeveralCandidates() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty('simple', 'flag', Boolean.class.getName(), null, null, null,
				true, null);
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, SimpleProperties.class,
				SimpleConflictingProperties.class);
		assertThat(metadata.getItems()).hasSize(6);
		List<ItemMetadata> items = metadata.getItems()
			.stream()
			.filter((item) -> item.getName().equals('simple.flag'))
			.toList();
		assertThat(items).hasSize(2);
		ItemMetadata matchingProperty = items.stream()
			.filter((item) -> item.getType().equals(Boolean.class.getName()))
			.findFirst()
			.orElse(null);
		assertThat(matchingProperty).isNotNull();
		assertThat(matchingProperty.getDefaultValue()).isEqualTo(true);
		assertThat(matchingProperty.getSourceType()).isEqualTo(SimpleProperties.class.getName());
		assertThat(matchingProperty.getDescription()).isEqualTo('A simple flag.');
		ItemMetadata nonMatchingProperty = items.stream()
			.filter((item) -> item.getType().equals(String.class.getName()))
			.findFirst()
			.orElse(null);
		assertThat(nonMatchingProperty).isNotNull();
		assertThat(nonMatchingProperty.getDefaultValue()).isEqualTo('hello');
		assertThat(nonMatchingProperty.getSourceType()).isEqualTo(SimpleConflictingProperties.class.getName());
		assertThat(nonMatchingProperty.getDescription()).isNull();
	}
	@Test
	void mergeExistingPropertyDescription() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty('simple', 'comparator', null, null, null, 'A nice comparator.',
				null, null);
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.comparator', 'java.util.Comparator<?>')
			.fromSource(SimpleProperties.class)
			.withDescription('A nice comparator.'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void mergeExistingPropertyDeprecation() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty('simple', 'comparator', null, null, null, null, null,
				new ItemDeprecation('Don"t use this.', 'simple.complex-comparator', '1.2.3', 'error'));
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.comparator', 'java.util.Comparator<?>')
			.fromSource(SimpleProperties.class)
			.withDeprecation('Don"t use this.', 'simple.complex-comparator', '1.2.3', 'error'));
		assertThat(metadata.getItems()).hasSize(4);
	}
	@Test
	void mergeExistingPropertyDeprecationOverride() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty('singledeprecated', 'name', null, null, null, null, null,
				new ItemDeprecation('Don"t use this.', 'single.name', '1.2.3'));
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, DeprecatedSingleProperty.class);
		assertThat(metadata).has(Metadata.withProperty('singledeprecated.name', String.class.getName())
			.fromSource(DeprecatedSingleProperty.class)
			.withDeprecation('Don"t use this.', 'single.name', '1.2.3'));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void mergeExistingPropertyDeprecationOverrideLevel() throws Exception {
		ItemMetadata property = ItemMetadata.newProperty('singledeprecated', 'name', null, null, null, null, null,
				new ItemDeprecation(null, null, null, 'error'));
		String additionalMetadata = buildAdditionalMetadata(property);
		ConfigurationMetadata metadata = compile(additionalMetadata, DeprecatedSingleProperty.class);
		assertThat(metadata).has(Metadata.withProperty('singledeprecated.name', String.class.getName())
			.fromSource(DeprecatedSingleProperty.class)
			.withDeprecation('renamed', 'singledeprecated.new-name', '1.2.3', 'error'));
		assertThat(metadata.getItems()).hasSize(3);
	}
	@Test
	void mergeOfInvalidAdditionalMetadata() {
		String metadata = 'Hello World';
		assertThatExceptionOfType(CompilationException.class)
			.isThrownBy(() -> compile(metadata, SimpleProperties.class))
			.withMessageContaining('Invalid additional meta-data');
	}
	@Test
	void mergingOfSimpleHint() throws Exception {
		String hints = buildAdditionalHints(ItemHint.newHint('simple.the-name',
				new ItemHint.ValueHint('boot', 'Bla bla'), new ItemHint.ValueHint('spring', null)));
		ConfigurationMetadata metadata = compile(hints, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.the-name', String.class)
			.fromSource(SimpleProperties.class)
			.withDescription('The name of this simple properties.')
			.withDefaultValue('boot')
			.withDeprecation());
		assertThat(metadata)
			.has(Metadata.withHint('simple.the-name').withValue(0, 'boot', 'Bla bla').withValue(1, 'spring', null));
	}
	@Test
	void mergingOfHintWithNonCanonicalName() throws Exception {
		String hints = buildAdditionalHints(
				ItemHint.newHint('simple.theName', new ItemHint.ValueHint('boot', 'Bla bla')));
		ConfigurationMetadata metadata = compile(hints, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.the-name', String.class)
			.fromSource(SimpleProperties.class)
			.withDescription('The name of this simple properties.')
			.withDefaultValue('boot')
			.withDeprecation());
		assertThat(metadata).has(Metadata.withHint('simple.the-name').withValue(0, 'boot', 'Bla bla'));
	}
	@Test
	void mergingOfHintWithProvider() throws Exception {
		String hints = buildAdditionalHints(new ItemHint('simple.theName', Collections.emptyList(),
				Arrays.asList(new ItemHint.ValueProvider('first', Collections.singletonMap('target', 'org.foo')),
						new ItemHint.ValueProvider('second', null))));
		ConfigurationMetadata metadata = compile(hints, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.the-name', String.class)
			.fromSource(SimpleProperties.class)
			.withDescription('The name of this simple properties.')
			.withDefaultValue('boot')
			.withDeprecation());
		assertThat(metadata).has(
				Metadata.withHint('simple.the-name').withProvider('first', 'target', 'org.foo').withProvider('second'));
	}
	@Test
	void mergingOfAdditionalDeprecation() throws Exception {
		String deprecations = buildPropertyDeprecations(
				ItemMetadata.newProperty('simple', 'wrongName', 'java.lang.String', null, null, null, null,
						new ItemDeprecation('Lame name.', 'simple.the-name', '1.2.3')));
		ConfigurationMetadata metadata = compile(deprecations, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.wrong-name', String.class)
			.withDeprecation('Lame name.', 'simple.the-name', '1.2.3'));
	}
	@Test
	void mergingOfAdditionalMetadata() throws Exception {
		JSONObject property = new JSONObject();
		property.put('name', 'foo');
		property.put('type', 'java.lang.String');
		property.put('sourceType', AdditionalMetadata.class.getName());
		JSONArray properties = new JSONArray();
		properties.put(property);
		JSONObject json = new JSONObject();
		json.put('properties', properties);
		String additionalMetadata = json.toString();
		ConfigurationMetadata metadata = compile(additionalMetadata, SimpleProperties.class);
		assertThat(metadata).has(Metadata.withProperty('simple.comparator'));
		assertThat(metadata).has(Metadata.withProperty('foo', String.class).fromSource(AdditionalMetadata.class));
	}
	private String buildAdditionalMetadata(ItemMetadata... metadata) throws Exception {
		TestJsonConverter converter = new TestJsonConverter();
		JSONObject additionalMetadata = new JSONObject();
		JSONArray properties = new JSONArray();
		for (ItemMetadata itemMetadata : metadata) {
			properties.put(converter.toJsonObject(itemMetadata));
		}
		additionalMetadata.put('properties', properties);
		return additionalMetadata.toString();
	}
	private String buildAdditionalHints(ItemHint... hints) throws Exception {
		TestJsonConverter converter = new TestJsonConverter();
		JSONObject additionalMetadata = new JSONObject();
		additionalMetadata.put('hints', converter.toJsonArray(Arrays.asList(hints)));
		return additionalMetadata.toString();
	}
	private String buildPropertyDeprecations(ItemMetadata... items) throws Exception {
		JSONArray propertiesArray = new JSONArray();
		for (ItemMetadata item : items) {
			JSONObject jsonObject = new JSONObject();
			jsonObject.put('name', item.getName());
			if (item.getType() != null) {
				jsonObject.put('type', item.getType());
			}
			ItemDeprecation deprecation = item.getDeprecation();
			if (deprecation != null) {
				JSONObject deprecationJson = new JSONObject();
				if (deprecation.getReason() != null) {
					deprecationJson.put('reason', deprecation.getReason());
				}
				if (deprecation.getReplacement() != null) {
					deprecationJson.put('replacement', deprecation.getReplacement());
				}
				if (deprecation.getSince() != null) {
					deprecationJson.put('since', deprecation.getSince());
				}
				jsonObject.put('deprecation', deprecationJson);
			}
			propertiesArray.put(jsonObject);
		}
		JSONObject additionalMetadata = new JSONObject();
		additionalMetadata.put('properties', propertiesArray);
		return additionalMetadata.toString();
	}
	static class AdditionalMetadata {
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class IncrementalBuildMetadataGenerationTests extends AbstractMetadataGenerationTests {
	@Test
	void incrementalBuild() throws Exception {
		TestProject project = new TestProject(FooProperties.class, BarProperties.class);
		ConfigurationMetadata metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withProperty('foo.counter').fromSource(FooProperties.class).withDefaultValue(0));
		assertThat(metadata)
			.has(Metadata.withProperty('bar.counter').fromSource(BarProperties.class).withDefaultValue(0));
		metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withProperty('foo.counter').fromSource(FooProperties.class).withDefaultValue(0));
		assertThat(metadata)
			.has(Metadata.withProperty('bar.counter').fromSource(BarProperties.class).withDefaultValue(0));
		project.addSourceCode(BarProperties.class, BarProperties.class.getResourceAsStream('BarProperties.snippet'));
		metadata = project.compile();
		assertThat(metadata).has(Metadata.withProperty('bar.extra'));
		assertThat(metadata).has(Metadata.withProperty('foo.counter').withDefaultValue(0));
		assertThat(metadata).has(Metadata.withProperty('bar.counter').withDefaultValue(0));
		project.revert(BarProperties.class);
		metadata = project.compile();
		assertThat(metadata).isNotEqualTo(Metadata.withProperty('bar.extra'));
		assertThat(metadata).has(Metadata.withProperty('foo.counter').withDefaultValue(0));
		assertThat(metadata).has(Metadata.withProperty('bar.counter').withDefaultValue(0));
	}
	@Test
	void incrementalBuildAnnotationRemoved() {
		TestProject project = new TestProject(FooProperties.class, BarProperties.class);
		ConfigurationMetadata metadata = project.compile();
		assertThat(metadata).has(Metadata.withProperty('foo.counter').withDefaultValue(0));
		assertThat(metadata).has(Metadata.withProperty('bar.counter').withDefaultValue(0));
		project.replaceText(BarProperties.class, '@ConfigurationProperties', '//@ConfigurationProperties');
		project.replaceText(FooProperties.class, '@ConfigurationProperties', '//@ConfigurationProperties');
		metadata = project.compile();
		assertThat(metadata).isNull();
	}
	@Test
	@Disabled('gh-26271')
	void incrementalBuildTypeRenamed() {
		TestProject project = new TestProject(FooProperties.class, BarProperties.class);
		ConfigurationMetadata metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withProperty('foo.counter').fromSource(FooProperties.class).withDefaultValue(0));
		assertThat(metadata)
			.has(Metadata.withProperty('bar.counter').fromSource(BarProperties.class).withDefaultValue(0));
		assertThat(metadata).doesNotHave(Metadata.withProperty('bar.counter').fromSource(RenamedBarProperties.class));
		project.delete(BarProperties.class);
		project.add(RenamedBarProperties.class);
		metadata = project.compile();
		assertThat(metadata)
			.has(Metadata.withProperty('foo.counter').fromSource(FooProperties.class).withDefaultValue(0));
		assertThat(metadata)
			.doesNotHave(Metadata.withProperty('bar.counter').fromSource(BarProperties.class).withDefaultValue(0));
		assertThat(metadata)
			.has(Metadata.withProperty('bar.counter').withDefaultValue(0).fromSource(RenamedBarProperties.class));
	}
	@Test
	void incrementalBuildDoesNotDeleteItems() {
		TestProject project = new TestProject(ClassWithNestedProperties.class, FooProperties.class);
		ConfigurationMetadata initialMetadata = project.compile();
		ConfigurationMetadata updatedMetadata = project.compile();
		assertThat(initialMetadata.getItems()).isEqualTo(updatedMetadata.getItems());
	}
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ControllerEndpoint {
	String id() default '';
	@Deprecated
	boolean enableByDefault() default true;
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.configurationsample.lombok;
@Data
@ConfigurationProperties(prefix = 'config')
@SuppressWarnings('unused')
public class LombokInnerClassWithGetterProperties {
	private final Foo first = new Foo();
	public Foo getFirst() {
		return this.first;
	}
	@Data
	public static class Foo {
		private String name;
	}
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Data
@ConfigurationProperties('default')
@SuppressWarnings('unused')
public class LombokDefaultValueProperties {
	private String description = 'my description';
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Value
@ConfigurationProperties(prefix = 'value')
@SuppressWarnings('unused')
public class LombokSimpleValueProperties {
	private final String id = 'super-id';
	/**
	 * Name description.
	 */
	private String name;
	private String description;
	private Integer counter;
	@Deprecated
	private Integer number = 0;
	private final List<String> items = new ArrayList<>();
	private final String ignored = 'foo';
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@ConfigurationProperties(prefix = 'accesslevel')
public class LombokAccessLevelProperties {
	@Getter(AccessLevel.PUBLIC)
	@Setter(AccessLevel.PUBLIC)
	private String name0;
	@Getter
	@Setter
	private String name1;
	/*
	 * AccessLevel.NONE
	 */
	@Getter(AccessLevel.NONE)
	@Setter(AccessLevel.NONE)
	private String ignoredAccessLevelNone;
	/*
	 * AccessLevel.PRIVATE
	 */
	@Getter(AccessLevel.PRIVATE)
	@Setter(AccessLevel.PRIVATE)
	private String ignoredAccessLevelPrivate;
	/*
	 * AccessLevel.PACKAGE
	 */
	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private String ignoredAccessLevelPackage;
	/*
	 * AccessLevel.PROTECTED
	 */
	@Getter(AccessLevel.PROTECTED)
	@Setter(AccessLevel.PROTECTED)
	private String ignoredAccessLevelProtected;
	/*
	 * AccessLevel.MODULE
	 */
	@Getter(AccessLevel.MODULE)
	@Setter(AccessLevel.MODULE)
	private String ignoredAccessLevelModule;
	/*
	 * Either PUBLIC getter or setter explicitly defined
	 */
	@Getter(AccessLevel.PUBLIC)
	private String ignoredOnlyPublicGetter;
	@Setter(AccessLevel.PUBLIC)
	private String ignoredOnlyPublicSetter;
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Data
@SuppressWarnings('unused')
public class SimpleLombokPojo {
	private int value;
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Data
@ConfigurationProperties(prefix = 'config')
@SuppressWarnings('unused')
public class LombokInnerClassProperties {
	private final Foo first = new Foo();
	private Foo second = new Foo();
	@NestedConfigurationProperty
	private final SimpleLombokPojo third = new SimpleLombokPojo();
	private Fourth fourth;
	// Only there to record the source method
	public SimpleLombokPojo getThird() {
		return this.third;
	}
	@Data
	public static class Foo {
		private String name;
		private final Bar bar = new Bar();
		@Data
		public static class Bar {
			private String name;
		}
	}
	public enum Fourth {
		YES, NO
	}
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Getter(AccessLevel.PUBLIC)
@Setter(AccessLevel.PUBLIC)
@ConfigurationProperties(prefix = 'accesslevel.overwrite.explicit')
@SuppressWarnings('unused')
public class LombokAccessLevelOverwriteExplicitProperties {
	private String name0;
	@Getter(AccessLevel.PUBLIC)
	@Setter(AccessLevel.PUBLIC)
	private String name1;
	@Getter(AccessLevel.PUBLIC)
	private String name2;
	@Setter(AccessLevel.PUBLIC)
	private String name3;
	@Getter
	@Setter
	private String name4;
	@Getter
	private String name5;
	@Setter
	private String name6;
	/*
	 * AccessLevel.NONE
	 */
	@Getter(AccessLevel.NONE)
	@Setter(AccessLevel.NONE)
	private String ignoredAccessLevelNone;
	/*
	 * AccessLevel.PRIVATE
	 */
	@Getter(AccessLevel.PRIVATE)
	@Setter(AccessLevel.PRIVATE)
	private String ignoredAccessLevelPrivate;
	/*
	 * AccessLevel.PACKAGE
	 */
	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private String ignoredAccessLevelPackage;
	/*
	 * AccessLevel.PROTECTED
	 */
	@Getter(AccessLevel.PROTECTED)
	@Setter(AccessLevel.PROTECTED)
	private String ignoredAccessLevelProtected;
	/*
	 * AccessLevel.MODULE
	 */
	@Getter(AccessLevel.MODULE)
	@Setter(AccessLevel.MODULE)
	private String ignoredAccessLevelModule;
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Getter
@Setter
@ConfigurationProperties(prefix = 'accesslevel.overwrite.default')
public class LombokAccessLevelOverwriteDefaultProperties {
	@SuppressWarnings('unused')
	private String name0;
	@Getter(AccessLevel.PUBLIC)
	@Setter(AccessLevel.PUBLIC)
	private String name1;
	@Getter(AccessLevel.PUBLIC)
	private String name2;
	@Setter(AccessLevel.PUBLIC)
	private String name3;
	@Getter
	@Setter
	private String name4;
	@Getter
	private String name5;
	@Setter
	private String name6;
	/*
	 * AccessLevel.NONE
	 */
	@Getter(AccessLevel.NONE)
	@Setter(AccessLevel.NONE)
	private String ignoredAccessLevelNone;
	/*
	 * AccessLevel.PRIVATE
	 */
	@Getter(AccessLevel.PRIVATE)
	@Setter(AccessLevel.PRIVATE)
	private String ignoredAccessLevelPrivate;
	/*
	 * AccessLevel.PACKAGE
	 */
	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private String ignoredAccessLevelPackage;
	/*
	 * AccessLevel.PROTECTED
	 */
	@Getter(AccessLevel.PROTECTED)
	@Setter(AccessLevel.PROTECTED)
	private String ignoredAccessLevelProtected;
	/*
	 * AccessLevel.MODULE
	 */
	@Getter(AccessLevel.MODULE)
	@Setter(AccessLevel.MODULE)
	private String ignoredAccessLevelModule;
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Getter
@Setter
@ConfigurationProperties(prefix = 'deprecated')
@Deprecated
@SuppressWarnings('unused')
public class LombokDeprecatedProperties {
	private String name;
	private String description;
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Data
@ConfigurationProperties(prefix = 'accesslevel.overwrite.data')
@SuppressWarnings('unused')
public class LombokAccessLevelOverwriteDataProperties {
	private String name0;
	@Getter(AccessLevel.PUBLIC)
	@Setter(AccessLevel.PUBLIC)
	private String name1;
	@Getter(AccessLevel.PUBLIC)
	private String name2;
	@Setter(AccessLevel.PUBLIC)
	private String name3;
	@Getter
	@Setter
	private String name4;
	@Getter
	private String name5;
	@Setter
	private String name6;
	/*
	 * AccessLevel.NONE
	 */
	@Getter(AccessLevel.NONE)
	@Setter(AccessLevel.NONE)
	private String ignoredAccessLevelNone;
	@Getter(AccessLevel.NONE)
	private String ignoredGetterAccessLevelNone;
	@Setter(AccessLevel.NONE)
	private String ignoredSetterAccessLevelNone;
	/*
	 * AccessLevel.PRIVATE
	 */
	@Getter(AccessLevel.PRIVATE)
	@Setter(AccessLevel.PRIVATE)
	private String ignoredAccessLevelPrivate;
	@Getter(AccessLevel.PRIVATE)
	private String ignoredGetterAccessLevelPrivate;
	@Setter(AccessLevel.PRIVATE)
	private String ignoredSetterAccessLevelPrivate;
	/*
	 * AccessLevel.PACKAGE
	 */
	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private String ignoredAccessLevelPackage;
	@Getter(AccessLevel.PACKAGE)
	private String ignoredGetterAccessLevelPackage;
	@Setter(AccessLevel.PACKAGE)
	private String ignoredSetterAccessLevelPackage;
	/*
	 * AccessLevel.PROTECTED
	 */
	@Getter(AccessLevel.PROTECTED)
	@Setter(AccessLevel.PROTECTED)
	private String ignoredAccessLevelProtected;
	@Getter(AccessLevel.PROTECTED)
	private String ignoredGetterAccessLevelProtected;
	@Setter(AccessLevel.PROTECTED)
	private String ignoredSetterAccessLevelProtected;
	/*
	 * AccessLevel.MODULE
	 */
	@Getter(AccessLevel.MODULE)
	@Setter(AccessLevel.MODULE)
	private String ignoredAccessLevelModule;
	@Getter(AccessLevel.MODULE)
	private String ignoredGetterAccessLevelModule;
	@Setter(AccessLevel.MODULE)
	private String ignoredSetterAccessLevelModule;
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Getter
@Setter
@ConfigurationProperties(prefix = 'simple')
@SuppressWarnings('unused')
public class LombokSimpleProperties {
	private final String id = 'super-id';
	/**
	 * Name description.
	 */
	private String name;
	private String description;
	private Integer counter;
	@Deprecated
	private Integer number = 0;
	private final List<String> items = new ArrayList<>();
	private final String ignored = 'foo';
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Data
@ConfigurationProperties(prefix = 'data')
@SuppressWarnings('unused')
public class LombokSimpleDataProperties {
	private final String id = 'super-id';
	/**
	 * Name description.
	 */
	private String name;
	private String description;
	private Integer counter;
	@Deprecated
	private Integer number = 0;
	private final List<String> items = new ArrayList<>();
	private final String ignored = 'foo';
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@ConfigurationProperties(prefix = 'explicit')
public class LombokExplicitProperties {
	@Getter
	private final String id = 'super-id';
	/**
	 * Name description.
	 */
	@Getter
	@Setter
	private String name;
	@Getter
	@Setter
	private String description;
	@Getter
	@Setter
	private Integer counter;
	@Deprecated
	@Getter
	@Setter
	private Integer number = 0;
	@Getter
	private final List<String> items = new ArrayList<>();
	// Should be ignored if no annotation is set
	@SuppressWarnings('unused')
	private String ignored;
	@Getter
	private String ignoredOnlyGetter;
	@Setter
	private String ignoredOnlySetter;
}
/*
package org.springframework.boot.configurationsample.lombok;
/**
@Data
@ConfigurationProperties('singledeprecated')
@SuppressWarnings('unused')
public class LombokDeprecatedSingleProperty {
	@Deprecated
	private String name;
	private String description;
}
/*

package org.springframework.boot.configurationsample.record;


@ConfigurationProperties('record-nested')
public record NestedPropertiesRecord(String myProperty, @NestedConfigurationProperty NestedRecord nested,
		InnerPropertiesRecord inner) {

	public record InnerPropertiesRecord(String myInnerProperty, @NestedConfigurationProperty NestedRecord nested) {
	}

}
/*
package org.springframework.boot.configurationsample.record;
@ConfigurationProperties('record-with-getter')
public record RecordWithGetter(String alpha) {
	public String getBravo() {
		return this.alpha;
	}
}
/*
package org.springframework.boot.configurationsample.record;
// @formatter:off
/**
@org.springframework.boot.configurationsample.ConfigurationProperties('record.descriptions')
public record ExampleRecord(String someString, Integer someInteger, Boolean someBoolean, Long someLong, Byte someByte) {
}
//@formatter:on
/*

package org.springframework.boot.configurationsample.record;

public record NestedRecord(String myNestedProperty) {

}
/*
package org.springframework.boot.configurationsample;
/**
@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
}
/*
package org.springframework.boot.configurationsample;
/**
@Target({ ElementType.PARAMETER, ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Name {
	String value();
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface WebEndpoint {
	String id() default '';
	@Deprecated
	boolean enableByDefault() default true;
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.configurationsample.fieldvalues;
/**
@SuppressWarnings('unused')
@ConfigurationProperties
public class FieldValues {
	private static final String STRING_CONST = 'c';
	private static final boolean BOOLEAN_CONST = true;
	private static final Boolean BOOLEAN_OBJ_CONST = true;
	private static final int INTEGER_CONST = 2;
	private static final Integer INTEGER_OBJ_CONST = 4;
	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	private static final MimeType DEFAULT_MIME_TYPE = MimeType.valueOf('text/plain');
	private static final String[] STRING_ARRAY_CONST = new String[] { 'OK', 'KO' };
	private String string = '1';
	private String stringNone;
	private String stringConst = STRING_CONST;
	private boolean bool = true;
	private boolean boolNone;
	private boolean boolConst = BOOLEAN_CONST;
	private Boolean boolObject = Boolean.TRUE;
	private Boolean boolObjectNone;
	private Boolean boolObjectConst = BOOLEAN_OBJ_CONST;
	private int integer = 1;
	private int integerNone;
	private int integerConst = INTEGER_CONST;
	private Integer integerObject = 3;
	private Integer integerObjectNone;
	private Integer integerObjectConst = INTEGER_OBJ_CONST;
	private Charset charset = StandardCharsets.US_ASCII;
	private Charset charsetConst = DEFAULT_CHARSET;
	private MimeType mimeType = MimeType.valueOf('text/html');
	private MimeType mimeTypeConst = DEFAULT_MIME_TYPE;
	private Object object = 123;
	private Object objectNone;
	private Object objectConst = STRING_CONST;
	private Object objectInstance = new StringBuffer();
	private String[] stringArray = new String[] { 'FOO', 'BAR' };
	private String[] stringArrayNone;
	private String[] stringEmptyArray = new String[0];
	private String[] stringArrayConst = STRING_ARRAY_CONST;
	private String[] stringArrayConstElements = new String[] { STRING_CONST };
	private Integer[] integerArray = new Integer[] { 42, 24 };
	private UnknownElementType[] unknownArray = new UnknownElementType[] { new UnknownElementType() };
	private Duration durationNone;
	private Duration durationNanos = Duration.ofNanos(5);
	private Duration durationMillis = Duration.ofMillis(10);
	private Duration durationSeconds = Duration.ofSeconds(20);
	private Duration durationMinutes = Duration.ofMinutes(30);
	private Duration durationHours = Duration.ofHours(40);
	private Duration durationDays = Duration.ofDays(50);
	private Duration durationZero = Duration.ZERO;
	private DataSize dataSizeNone;
	private DataSize dataSizeBytes = DataSize.ofBytes(5);
	private DataSize dataSizeKilobytes = DataSize.ofKilobytes(10);
	private DataSize dataSizeMegabytes = DataSize.ofMegabytes(20);
	private DataSize dataSizeGigabytes = DataSize.ofGigabytes(30);
	private DataSize dataSizeTerabytes = DataSize.ofTerabytes(40);
	private Period periodNone;
	private Period periodDays = Period.ofDays(3);
	private Period periodWeeks = Period.ofWeeks(2);
	private Period periodMonths = Period.ofMonths(10);
	private Period periodYears = Period.ofYears(15);
	private Period periodZero = Period.ZERO;
	private ChronoUnit enumNone;
	private ChronoUnit enumSimple = ChronoUnit.SECONDS;
	private java.time.temporal.ChronoField enumQualified = java.time.temporal.ChronoField.HOUR_OF_DAY;
	private ChronoUnit enumWithIndirection = SampleOptions.DEFAULT_UNIT;
	private int memberSelectInt = SampleOptions.DEFAULT_MAX_RETRIES;
	public static class SampleOptions {
		static final Integer DEFAULT_MAX_RETRIES = 20;
		static final ChronoUnit DEFAULT_UNIT = ChronoUnit.SECONDS;
	}
}
/*
package org.springframework.boot.configurationsample.fieldvalues;
/**
public class UnknownElementType {
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ServletEndpoint {
	String id() default '';
	@Deprecated
	boolean enableByDefault() default true;
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.configurationsample.recursive;
@ConfigurationProperties('prefix')
public class RecursiveProperties {
	private RecursiveProperties recursive;
	public RecursiveProperties getRecursive() {
		return this.recursive;
	}
	public void setRecursive(RecursiveProperties recursive) {
		this.recursive = recursive;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@ConfigurationProperties('test')
public class DeducedImmutableClassProperties {
	private final Nested nested;
	public DeducedImmutableClassProperties(@DefaultValue Nested nested) {
		this.nested = nested;
	}
	public Nested getNested() {
		return this.nested;
	}
	public static class Nested {
		private final String name;
		public Nested(String name) {
			this.name = name;
		}
		public String getName() {
			return this.name;
		}
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@ConfigurationProperties('named')
public record RecordComponentNameAnnotationProperties(@Name('import') String imports) {
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@ConfigurationProperties('immutable')
public class ImmutableSimpleProperties {
	/**
	 * The name of this simple properties.
	 */
	private final String theName;
	/**
	 * A simple flag.
	 */
	private final boolean flag;
	// An interface can still be injected because it might have a converter
	private final Comparator<?> comparator;
	// Even if it is not exposed, we"re still offering a way to bind the value through the
	// constructor, so it should be present in the metadata
	@SuppressWarnings('unused')
	private final Long counter;
	@ConstructorBinding
	public ImmutableSimpleProperties(@DefaultValue('boot') String theName, boolean flag, Comparator<?> comparator,
			Long counter) {
		this.theName = theName;
		this.flag = flag;
		this.comparator = comparator;
		this.counter = counter;
	}
	public String getTheName() {
		return this.theName;
	}
	@Deprecated
	public boolean isFlag() {
		return this.flag;
	}
	public Comparator<?> getComparator() {
		return this.comparator;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@SuppressWarnings('unused')
public class ImmutableClassConstructorBindingProperties {
	private final String name;
	private final String description;
	public ImmutableClassConstructorBindingProperties(String name, String description) {
		this.name = name;
		this.description = description;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
public class ImmutableInnerClassProperties {
	private final Foo first;
	private Foo second;
	@NestedConfigurationProperty
	private final SimplePojo third;
	private final Fourth fourth;
	public ImmutableInnerClassProperties(Foo first, Foo second, SimplePojo third, Fourth fourth) {
		this.first = first;
		this.second = second;
		this.third = third;
		this.fourth = fourth;
	}
	public Foo getFirst() {
		return this.first;
	}
	public Foo getTheSecond() {
		return this.second;
	}
	public void setTheSecond(Foo second) {
		this.second = second;
	}
	public SimplePojo getThird() {
		return this.third;
	}
	public Fourth getFourth() {
		return this.fourth;
	}
	public static class Foo {
		private String name;
		private final Bar bar = new Bar();
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public Bar getBar() {
			return this.bar;
		}
		public static class Bar {
			private String name;
			public String getName() {
				return this.name;
			}
			public void setName(String name) {
				this.name = name;
			}
		}
	}
	public enum Fourth {
		YES, NO
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@ConfigurationProperties('immutable')
public class ImmutableDeducedConstructorBindingProperties {
	/**
	 * The name of these properties.
	 */
	private final String theName;
	/**
	 * A simple flag.
	 */
	private final boolean flag;
	public ImmutableDeducedConstructorBindingProperties(@DefaultValue('boot') String theName, boolean flag) {
		this.theName = theName;
		this.flag = flag;
	}
	public String getTheName() {
		return this.theName;
	}
	public boolean isFlag() {
		return this.flag;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@ConfigurationProperties('named')
public class ConstructorParameterNameAnnotationProperties {
	private final String imports;
	public ConstructorParameterNameAnnotationProperties(@Name('import') String imports) {
		this.imports = imports;
	}
	public String getImports() {
		return this.imports;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@SuppressWarnings('unused')
public class ImmutableCollectionProperties {
	private final List<String> names;
	private final List<Boolean> flags;
	private final List<Duration> durations;
	public ImmutableCollectionProperties(List<String> names, @DefaultValue({ 'true', 'false' }) List<Boolean> flags,
			@DefaultValue({ '10s', '1m', '1h' }) List<Duration> durations) {
		this.names = names;
		this.flags = flags;
		this.durations = durations;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@SuppressWarnings('unused')
public class ImmutablePrimitiveWithDefaultsProperties {
	private final boolean flag;
	private final byte octet;
	private final char letter;
	private final short number;
	private final int counter;
	private final long value;
	private final float percentage;
	private final double ratio;
	public ImmutablePrimitiveWithDefaultsProperties(@DefaultValue('true') boolean flag, @DefaultValue('120') byte octet,
			@DefaultValue('a') char letter, @DefaultValue('1000') short number, @DefaultValue('42') int counter,
			@DefaultValue('2000') long value, @DefaultValue('0.5') float percentage,
			@DefaultValue('42.42') double ratio) {
		this.flag = flag;
		this.octet = octet;
		this.letter = letter;
		this.number = number;
		this.counter = counter;
		this.value = value;
		this.percentage = percentage;
		this.ratio = ratio;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@SuppressWarnings('unused')
public class ImmutableMultiConstructorProperties {
	private final String name;
	/**
	 * Test description.
	 */
	private final String description;
	public ImmutableMultiConstructorProperties(String name) {
		this(name, null);
	}
	@ConstructorBinding
	public ImmutableMultiConstructorProperties(String name, String description) {
		this.name = name;
		this.description = description;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@SuppressWarnings('unused')
public class ImmutablePrimitiveProperties {
	private final boolean flag;
	private final byte octet;
	private final char letter;
	private final short number;
	private final int counter;
	private final long value;
	private final float percentage;
	private final double ratio;
	public ImmutablePrimitiveProperties(boolean flag, byte octet, char letter, short number, int counter, long value,
			float percentage, double ratio) {
		this.flag = flag;
		this.octet = octet;
		this.letter = letter;
		this.number = number;
		this.counter = counter;
		this.value = value;
		this.percentage = percentage;
		this.ratio = ratio;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@SuppressWarnings('unused')
public class ImmutablePrimitiveWrapperWithDefaultsProperties {
	private final Boolean flag;
	private final Byte octet;
	private final Character letter;
	private final Short number;
	private final Integer counter;
	private final Long value;
	private final Float percentage;
	private final Double ratio;
	public ImmutablePrimitiveWrapperWithDefaultsProperties(@DefaultValue('true') Boolean flag,
			@DefaultValue('120') Byte octet, @DefaultValue('a') Character letter, @DefaultValue('1000') Short number,
			@DefaultValue('42') Integer counter, @DefaultValue('2000') Long value,
			@DefaultValue('0.5') Float percentage, @DefaultValue('42.42') Double ratio) {
		this.flag = flag;
		this.octet = octet;
		this.letter = letter;
		this.number = number;
		this.counter = counter;
		this.value = value;
		this.percentage = percentage;
		this.ratio = ratio;
	}
}
/*
package org.springframework.boot.configurationsample.immutable;
/**
@ConfigurationProperties('named')
public class JavaBeanNameAnnotationProperties {
	@Name('import')
	private String imports;
	public String getImports() {
		return this.imports;
	}
	public void setImports(String imports) {
		this.imports = imports;
	}
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Endpoint {
	String id() default '';
	@Deprecated
	boolean enableByDefault() default true;
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.configurationsample.generic;
/**
@ConfigurationProperties('generic')
public class SimpleGenericProperties extends AbstractIntermediateGenericProperties<Duration> {
}
/*
package org.springframework.boot.configurationsample.generic;
/**
public abstract class AbstractIntermediateGenericProperties<C> extends AbstractGenericProperties<String, Integer, C> {
}
/*
package org.springframework.boot.configurationsample.generic;
/**
@ConfigurationProperties('generic')
public class GenericConfig<T> {
	private final Foo foo = new Foo();
	public Foo getFoo() {
		return this.foo;
	}
	public static class Foo {
		private String name;
		@NestedConfigurationProperty
		private final Bar<String> bar = new Bar<>();
		private final Map<String, Bar<Integer>> stringToBar = new HashMap<>();
		private final Map<String, Integer> stringToInteger = new HashMap<>();
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public Bar<String> getBar() {
			return this.bar;
		}
		public Map<String, Bar<Integer>> getStringToBar() {
			return this.stringToBar;
		}
		public Map<String, Integer> getStringToInteger() {
			return this.stringToInteger;
		}
	}
	public static class Bar<U> {
		private String name;
		@NestedConfigurationProperty
		private final Biz<String> biz = new Biz<>();
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public Biz<String> getBiz() {
			return this.biz;
		}
		public static class Biz<V> {
			private String name;
			public String getName() {
				return this.name;
			}
			public void setName(String name) {
				this.name = name;
			}
		}
	}
}
/*
package org.springframework.boot.configurationsample.generic;
/**
public class GenericBuilderProperties<T extends GenericBuilderProperties<T>> {
	private int number;
	public int getNumber() {
		return this.number;
	}
	@SuppressWarnings('unchecked')
	public T setNumber(int number) {
		this.number = number;
		return (T) this;
	}
}
/*
package org.springframework.boot.configurationsample.generic;
/**
@ConfigurationProperties('wildcard')
public class WildcardConfig {
	private Map<String, ? extends Number> stringToNumber;
	private List<? super Integer> integers;
	public Map<String, ? extends Number> getStringToNumber() {
		return this.stringToNumber;
	}
	public void setStringToNumber(Map<String, ? extends Number> stringToNumber) {
		this.stringToNumber = stringToNumber;
	}
	public List<? super Integer> getIntegers() {
		return this.integers;
	}
	public void setIntegers(List<? super Integer> integers) {
		this.integers = integers;
	}
}
/*
package org.springframework.boot.configurationsample.generic;
/**
@ConfigurationProperties('generic')
public class UnresolvedGenericProperties<B extends Number, C> extends AbstractGenericProperties<String, B, C> {
}
/*
package org.springframework.boot.configurationsample.generic;
/**
public class AbstractGenericProperties<A, B, C> {
	/**
	 * Generic name.
	 */
	private A name;
	/**
	 * Generic mappings.
	 */
	private final Map<B, C> mappings = new HashMap<>();
	public A getName() {
		return this.name;
	}
	public void setName(A name) {
		this.name = name;
	}
	public Map<B, C> getMappings() {
		return this.mappings;
	}
}
/*
package org.springframework.boot.configurationsample.generic;
/**
public class UpperBoundGenericPojo<T extends Enum<T>> {
	private final Map<T, String> mappings = new HashMap<>();
	public Map<T, String> getMappings() {
		return this.mappings;
	}
}
/*
package org.springframework.boot.configurationsample.generic;
/**
@ConfigurationProperties('builder')
public class ConcreteBuilderProperties extends GenericBuilderProperties<ConcreteBuilderProperties> {
	private String description;
	public String getDescription() {
		return this.description;
	}
	public ConcreteBuilderProperties setDescription(String description) {
		this.description = description;
		return this;
	}
}
/*
package org.springframework.boot.configurationsample.generic;
/**
@ConfigurationProperties('generic')
public class ComplexGenericProperties {
	@NestedConfigurationProperty
	private final UpperBoundGenericPojo<Test> test = new UpperBoundGenericPojo<>();
	public UpperBoundGenericPojo<Test> getTest() {
		return this.test;
	}
	public enum Test {
		ONE, TWO, THREE
	}
}
/*
package org.springframework.boot.configurationsample;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ConfigurationProperties {
	String value() default '';
	String prefix() default '';
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ReadOperation {
	String[] produces() default {};
}
/*
package org.springframework.boot.configurationsample.deprecation;
/**
public class Dbcp2Configuration {
	@ConfigurationProperties(prefix = 'spring.datasource.dbcp2')
	BasicDataSource basicDataSource() {
		return new BasicDataSource();
	}
}
/*
package org.springframework.boot.configurationsample;
/**
public enum Access {
	NONE,
	READ_ONLY,
	UNRESTRICTED
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface JmxEndpoint {
	String id() default '';
	@Deprecated
	boolean enableByDefault() default true;
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.configurationsample;
/**
@Target({ ElementType.PARAMETER, ElementType.RECORD_COMPONENT })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DefaultValue {
	String[] value() default {};
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@WebEndpoint(id = 'specific', enableByDefault = true)
public class SpecificEndpoint {
	@ReadOperation
	String invoke(@Nullable String param) {
		return 'test';
	}
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'simple', enableByDefault = false)
public class SimpleEndpoint3 {
	@ReadOperation
	public String invoke() {
		return 'test';
	}
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'disabled', enableByDefault = false)
public class DisabledEndpoint {
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'customprops')
@ConfigurationProperties('management.endpoint.customprops')
public class CustomPropertiesEndpoint {
	private String name = 'test';
	@ReadOperation
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'enabled')
public class EnabledEndpoint {
	public String someMethod() {
		return 'not a read operation';
	}
	@ReadOperation
	public String retrieve(String parameter, Integer anotherParameter) {
		return 'not a main read operation';
	}
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'simple')
public class SimpleEndpoint2 {
	@ReadOperation
	public String invoke() {
		return 'test';
	}
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'unrestrictedaccess')
public class UnrestrictedAccessEndpoint {
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'simple')
public class SimpleEndpoint {
	@ReadOperation
	public String invoke() {
		return 'test';
	}
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'PascalCase')
public class CamelCaseEndpoint {
}
/*
package org.springframework.boot.configurationsample.endpoint.incremental;
/**
@JmxEndpoint(id = 'incremental')
public class IncrementalSpecificEndpoint {
}
/*
package org.springframework.boot.configurationsample.endpoint.incremental;
/**
@Endpoint(id = 'incremental')
public class IncrementalEndpoint {
	@ReadOperation
	public String invoke(@Nullable String param) {
		return 'test';
	}
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'noaccess', defaultAccess = Access.NONE)
public class NoAccessEndpoint {
}
/*
package org.springframework.boot.configurationsample.endpoint;
/**
@Endpoint(id = 'readonlyaccess', defaultAccess = Access.READ_ONLY)
public class ReadOnlyAccessEndpoint {
}
/*
package org.springframework.boot.configurationsample.inheritance;
public class ChildPropertiesConfig {
	@ConfigurationProperties(prefix = 'inheritance')
	public ChildProperties childConfig() {
		return new ChildProperties();
	}
}
/*
package org.springframework.boot.configurationsample.inheritance;
public class ChildProperties extends BaseProperties {
	private long longValue;
	private final NestInChild childNest = new NestInChild();
	public long getLongValue() {
		return this.longValue;
	}
	public void setLongValue(long longValue) {
		this.longValue = longValue;
	}
	public NestInChild getChildNest() {
		return this.childNest;
	}
	public static class NestInChild {
		private boolean boolValue;
		private int intValue;
		public boolean isBoolValue() {
			return this.boolValue;
		}
		public void setBoolValue(boolean boolValue) {
			this.boolValue = boolValue;
		}
		public int getIntValue() {
			return this.intValue;
		}
		public void setIntValue(int intValue) {
			this.intValue = intValue;
		}
	}
}
/*
package org.springframework.boot.configurationsample.inheritance;
public class OverrideChildProperties extends BaseProperties {
	private long longValue;
	private final CustomNest nest = new CustomNest();
	public long getLongValue() {
		return this.longValue;
	}
	public void setLongValue(long longValue) {
		this.longValue = longValue;
	}
	@Override
	public CustomNest getNest() {
		return this.nest;
	}
	public static class CustomNest extends Nest {
		private long longValue;
		public long getLongValue() {
			return this.longValue;
		}
		public void setLongValue(long longValue) {
			this.longValue = longValue;
		}
	}
}
/*
package org.springframework.boot.configurationsample.inheritance;
public class BaseProperties {
	private boolean boolValue;
	private int intValue;
	private final Nest nest = new Nest();
	public boolean isBoolValue() {
		return this.boolValue;
	}
	public void setBoolValue(boolean boolValue) {
		this.boolValue = boolValue;
	}
	public int getIntValue() {
		return this.intValue;
	}
	public void setIntValue(int intValue) {
		this.intValue = intValue;
	}
	public Nest getNest() {
		return this.nest;
	}
	public static class Nest {
		private boolean boolValue;
		private int intValue;
		public boolean isBoolValue() {
			return this.boolValue;
		}
		public void setBoolValue(boolean boolValue) {
			this.boolValue = boolValue;
		}
		public int getIntValue() {
			return this.intValue;
		}
		public void setIntValue(int intValue) {
			this.intValue = intValue;
		}
	}
}
/*
package org.springframework.boot.configurationsample.inheritance;
public class OverrideChildPropertiesConfig {
	@ConfigurationProperties(prefix = 'inheritance')
	public OverrideChildProperties overrideChildProperties() {
		return new OverrideChildProperties();
	}
}
/*
package org.springframework.boot.configurationsample;
/**
@Target({ ElementType.CONSTRUCTOR, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ConstructorBinding {
}
/*
package org.springframework.boot.configurationsample.method;
/**
public class PackagePrivateMethodConfig {
	@ConfigurationProperties(prefix = 'foo')
	Foo foo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		private boolean flag;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
@ConfigurationProperties('conflict')
public class MethodAndClassConfig {
	private String value;
	public String getValue() {
		return this.value;
	}
	public void setValue(String value) {
		this.value = value;
	}
	@ConfigurationProperties(prefix = 'conflict')
	public Foo foo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		private boolean flag;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
public class PrivateMethodConfig {
	@ConfigurationProperties(prefix = 'foo')
	private Foo foo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		private boolean flag;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
public class PublicMethodConfig {
	@ConfigurationProperties(prefix = 'foo')
	public Foo foo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		private boolean flag;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
@SuppressWarnings('unused')
public class SingleConstructorMethodConfig {
	@ConfigurationProperties(prefix = 'foo')
	public Foo foo() {
		return new Foo(new Object());
	}
	public static class Foo {
		private String name;
		private boolean flag;
		private final Object myService;
		public Foo(Object myService) {
			this.myService = myService;
		}
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
@ConfigurationProperties('something')
public class EmptyTypeMethodConfig {
	private String name;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@ConfigurationProperties('something')
	public Foo foo() {
		return new Foo();
	}
	static class Foo {
	}
}
/*
package org.springframework.boot.configurationsample.method;
@ConfigurationProperties('method-nested')
public class NestedPropertiesMethod {
	private String myProperty;
	private final NestedProperty nested = new NestedProperty();
	private final Inner inner = new Inner();
	public String getMyProperty() {
		return this.myProperty;
	}
	public void setMyProperty(String myProperty) {
		this.myProperty = myProperty;
	}
	@NestedConfigurationProperty
	public NestedProperty getNested() {
		return this.nested;
	}
	public Inner getInner() {
		return this.inner;
	}
	public static class Inner {
		private String myInnerProperty;
		private final NestedProperty nested = new NestedProperty();
		public String getMyInnerProperty() {
			return this.myInnerProperty;
		}
		public void setMyInnerProperty(String myInnerProperty) {
			this.myInnerProperty = myInnerProperty;
		}
		@NestedConfigurationProperty
		public NestedProperty getNested() {
			return this.nested;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
public class DeprecatedMethodConfig {
	@ConfigurationProperties(prefix = 'foo')
	@Deprecated
	public Foo foo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		private boolean flag;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
@Deprecated
public class DeprecatedClassMethodConfig {
	@ConfigurationProperties(prefix = 'foo')
	public Foo foo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		private boolean flag;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.method;
public class NestedProperty {
	private String myNestedProperty;
	public String getMyNestedProperty() {
		return this.myNestedProperty;
	}
	public void setMyNestedProperty(String myNestedProperty) {
		this.myNestedProperty = myNestedProperty;
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
@ConfigurationProperties(prefix = 'something')
public class InvalidMethodConfig {
	private String name;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@ConfigurationProperties(prefix = 'invalid')
	InvalidMethodConfig foo() {
		return new InvalidMethodConfig();
	}
}
/*
package org.springframework.boot.configurationsample.method;
/**
public class ProtectedMethodConfig {
	@ConfigurationProperties(prefix = 'foo')
	protected Foo foo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		private boolean flag;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public boolean isFlag() {
			return this.flag;
		}
		public void setFlag(boolean flag) {
			this.flag = flag;
		}
	}
}
/*
package org.springframework.boot.configurationsample.incremental;
@ConfigurationProperties('foo')
public class FooProperties {
	private String name;
	private String description;
	/**
	 * A nice counter description.
	 */
	private Integer counter = 0;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public Integer getCounter() {
		return this.counter;
	}
	public void setCounter(Integer counter) {
		this.counter = counter;
	}
}
/*
package org.springframework.boot.configurationsample.incremental;
@ConfigurationProperties('bar')
public class BarProperties {
	private String name;
	private String description;
	/**
	 * A nice counter description.
	 */
	private Integer counter = 0;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public Integer getCounter() {
		return this.counter;
	}
	public void setCounter(Integer counter) {
		this.counter = counter;
	}
}
/*
package org.springframework.boot.configurationsample.incremental;
@ConfigurationProperties('bar')
public class RenamedBarProperties {
	private String name;
	private String description;
	/**
	 * A nice counter description.
	 */
	private Integer counter = 0;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public Integer getCounter() {
		return this.counter;
	}
	public void setCounter(Integer counter) {
		this.counter = counter;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
public class InnerClassRootConfig {
	@ConfigurationProperties(prefix = 'config')
	public static class Config {
		private String name;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties(prefix = 'excluded')
public class ExcludedTypesPojo {
	private String name;
	private ClassLoader classLoader;
	private DataSource dataSource;
	private PrintWriter printWriter;
	private Writer writer;
	private Writer[] writerArray;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public ClassLoader getClassLoader() {
		return this.classLoader;
	}
	public void setClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	public DataSource getDataSource() {
		return this.dataSource;
	}
	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
	}
	public PrintWriter getPrintWriter() {
		return this.printWriter;
	}
	public void setPrintWriter(PrintWriter printWriter) {
		this.printWriter = printWriter;
	}
	public Writer getWriter() {
		return this.writer;
	}
	public void setWriter(Writer writer) {
		this.writer = writer;
	}
	public Writer[] getWriterArray() {
		return this.writerArray;
	}
	public void setWriterArray(Writer[] writerArray) {
		this.writerArray = writerArray;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('not.deprecated')
public class DeprecatedLessPreciseTypePojo {
	private boolean flag;
	@Deprecated
	public Boolean getFlag() {
		return this.flag;
	}
	public boolean isFlag() {
		return this.flag;
	}
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
	@Deprecated
	public void setFlag(Boolean flag) {
		this.flag = flag;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
public class TwoConstructorsExample {
	private String name;
	public TwoConstructorsExample() {
	}
	public TwoConstructorsExample(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
public class InvalidDoubleRegistrationProperties {
	@ConfigurationProperties('foo')
	public Foo foo() {
		return new Foo();
	}
	@ConfigurationProperties('foo')
	public static class Foo {
		private String name;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('test')
public class InvalidDefaultValueCharacterProperties {
	private final char letter;
	@ConstructorBinding
	public InvalidDefaultValueCharacterProperties(@DefaultValue('bad') char letter) {
		this.letter = letter;
	}
	public char getLetter() {
		return this.letter;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('simple')
public class SimpleConflictingProperties {
	private String flag = 'hello';
	public String getFlag() {
		return this.flag;
	}
	public void setFlag(String flag) {
		this.flag = flag;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('not.deprecated')
public class DeprecatedUnrelatedMethodPojo {
	private Integer counter;
	private boolean flag;
	public Integer getCounter() {
		return this.counter;
	}
	public void setCounter(Integer counter) {
		this.counter = counter;
	}
	@Deprecated
	public void setCounter(String counterAsString) {
		this.counter = Integer.valueOf(counterAsString);
	}
	public boolean isFlag() {
		return this.flag;
	}
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
	@Deprecated
	public void setFlag(Boolean flag) {
		this.flag = flag;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('test')
public class InvalidDefaultValueFloatingPointProperties {
	private final Double ratio;
	public InvalidDefaultValueFloatingPointProperties(@DefaultValue('55.55.33') Double ratio) {
		this.ratio = ratio;
	}
	public Double getRatio() {
		return this.ratio;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('specific')
public class StaticAccessor {
	private static String name;
	private int counter = 42;
	public static String getName() {
		return name;
	}
	public static void setName(String name) {
		StaticAccessor.name = name;
	}
	public int getCounter() {
		return this.counter;
	}
	public void setCounter(int counter) {
		this.counter = counter;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('specific')
public class AnnotatedGetter {
	private String name;
	@NotEmpty
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
public class MatchingConstructorNoDirectiveProperties {
	private String name;
	public MatchingConstructorNoDirectiveProperties(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties(prefix = 'builder')
public class BuilderPojo {
	private String name;
	public String getName() {
		return this.name;
	}
	public BuilderPojo setName(String name) {
		this.name = name;
		return this;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('test')
public class EmptyDefaultValueProperties {
	private final String name;
	@ConstructorBinding
	public EmptyDefaultValueProperties(@DefaultValue String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('test')
public class InvalidDefaultValueNumberProperties {
	private final int counter;
	public InvalidDefaultValueNumberProperties(@DefaultValue('invalid') int counter) {
		this.counter = counter;
	}
	public int getCounter() {
		return this.counter;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
public class SimplePojo {
	private int value;
	public int getValue() {
		return this.value;
	}
	public void setValue(int value) {
		this.value = value;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties(prefix = 'config')
public class InvalidAccessorProperties {
	private String name;
	private boolean flag;
	public void set(String name) {
		this.name = name;
	}
	public String get() {
		return this.name;
	}
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
	public boolean is() {
		return this.flag;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('specific')
public class InnerClassAnnotatedGetterConfig {
	private String value;
	public String getValue() {
		return this.value;
	}
	public void setValue(String value) {
		this.value = value;
	}
	@ConfigurationProperties('foo')
	public Foo getFoo() {
		return new Foo();
	}
	public static class Foo {
		private String name;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties(prefix = 'config')
public class InnerClassProperties {
	private final Foo first = new Foo();
	private Foo second = new Foo();
	@NestedConfigurationProperty
	private final SimplePojo third = new SimplePojo();
	private Fourth fourth;
	private final DeprecatedSimplePojo fifth = new DeprecatedSimplePojo();
	public Foo getFirst() {
		return this.first;
	}
	public Foo getTheSecond() {
		return this.second;
	}
	public void setTheSecond(Foo second) {
		this.second = second;
	}
	public SimplePojo getThird() {
		return this.third;
	}
	public Fourth getFourth() {
		return this.fourth;
	}
	public void setFourth(Fourth fourth) {
		this.fourth = fourth;
	}
	@NestedConfigurationProperty
	public DeprecatedSimplePojo getFifth() {
		return this.fifth;
	}
	public static class Foo {
		private String name;
		private final Bar bar = new Bar();
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public Bar getBar() {
			return this.bar;
		}
		public static class Bar {
			private String name;
			public String getName() {
				return this.name;
			}
			public void setName(String name) {
				this.name = name;
			}
		}
	}
	public enum Fourth {
		YES, NO
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
public class DoubleRegistrationProperties {
	@ConfigurationProperties('one')
	public SimplePojo one() {
		return new SimplePojo();
	}
	@ConfigurationProperties('two')
	public SimplePojo two() {
		return new SimplePojo();
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('boxing')
public class BoxingPojo {
	private boolean flag;
	private Boolean anotherFlag;
	private Integer counter;
	public boolean isFlag() {
		return this.flag;
	}
	// Setter use Boolean
	public void setFlag(Boolean flag) {
		this.flag = flag;
	}
	public boolean isAnotherFlag() {
		return Boolean.TRUE.equals(this.anotherFlag);
	}
	public void setAnotherFlag(boolean anotherFlag) {
		this.anotherFlag = anotherFlag;
	}
	public Integer getCounter() {
		return this.counter;
	}
	// Setter use int
	public void setCounter(int counter) {
		this.counter = counter;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
public class DeprecatedSimplePojo {
	private int value;
	@Deprecated
	public int getValue() {
		return this.value;
	}
	public void setValue(int value) {
		this.value = value;
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties(prefix = 'config')
public class InnerClassHierarchicalProperties {
	private Foo foo;
	public Foo getFoo() {
		return this.foo;
	}
	public void setFoo(Foo foo) {
		this.foo = foo;
	}
	public static class Foo {
		private Bar bar;
		public Bar getBar() {
			return this.bar;
		}
		public void setBar(Bar bar) {
			this.bar = bar;
		}
		public static class Baz {
			private String blah;
			public String getBlah() {
				return this.blah;
			}
			public void setBlah(String blah) {
				this.blah = blah;
			}
		}
	}
	public static class Bar {
		private String bling;
		private Foo.Baz baz;
		public String getBling() {
			return this.bling;
		}
		public void setBling(String foo) {
			this.bling = foo;
		}
		public Foo.Baz getBaz() {
			return this.baz;
		}
		public void setBaz(Foo.Baz baz) {
			this.baz = baz;
		}
	}
}
/*
package org.springframework.boot.configurationsample.specific;
/**
@ConfigurationProperties('test')
public class EnumValuesPojo {
	private ChronoUnit seconds = ChronoUnit.SECONDS;
	private ChronoField hourOfDay = ChronoField.HOUR_OF_DAY;
	public ChronoUnit getSeconds() {
		return this.seconds;
	}
	public void setSeconds(ChronoUnit seconds) {
		this.seconds = seconds;
	}
	public ChronoField getHourOfDay() {
		return this.hourOfDay;
	}
	public void setHourOfDay(ChronoField hourOfDay) {
		this.hourOfDay = hourOfDay;
	}
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DeprecatedConfigurationProperty {
	/**
	 * The reason for the deprecation.
	 * @return the deprecation reason
	 */
	String reason() default '';
	/**
	 * The field that should be used instead (if any).
	 * @return the replacement field
	 */
	String replacement() default '';
	/**
	 * The version in which the property became deprecated.
	 * @return the version
	 */
	String since() default '';
}
/*
package org.springframework.boot.configurationsample;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RestControllerEndpoint {
	String id() default '';
	@Deprecated
	boolean enableByDefault() default true;
	Access defaultAccess() default Access.UNRESTRICTED;
}
/*
package org.springframework.boot.configurationsample;
/**
@Target({ ElementType.FIELD, ElementType.RECORD_COMPONENT, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface NestedConfigurationProperty {
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties('singlefielddeprecated')
public class DeprecatedFieldSingleProperty {
	@Deprecated
	private String name;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties('singledeprecated')
public class DeprecatedSingleProperty {
	private String newName;
	@Deprecated
	@DeprecatedConfigurationProperty(reason = 'renamed', replacement = 'singledeprecated.new-name', since = '1.2.3')
	public String getName() {
		return getNewName();
	}
	@Deprecated
	public void setName(String name) {
		setNewName(name);
	}
	public String getNewName() {
		return this.newName;
	}
	public void setNewName(String newName) {
		this.newName = newName;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties(prefix = 'config')
public class InnerClassWithPrivateConstructor {
	private Nested nested = new Nested('whatever');
	public Nested getNested() {
		return this.nested;
	}
	public void setNested(Nested nested) {
		this.nested = nested;
	}
	public static final class Nested {
		private String name;
		private Nested(String ignored) {
		}
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
public abstract class HierarchicalPropertiesGrandparent {
	private String first = 'one';
	public String getFirst() {
		return this.first;
	}
	public void setFirst(String first) {
		this.first = first;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@Deprecated
@ConfigurationProperties(prefix = 'deprecated')
public class DeprecatedProperties {
	private String name;
	private String description;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties('array')
public class SimpleArrayProperties {
	private int[] primitive;
	private String[] simple;
	private Holder[] inner;
	private Map<String, Integer>[] nameToInteger;
	public int[] getPrimitive() {
		return this.primitive;
	}
	public void setPrimitive(int[] primitive) {
		this.primitive = primitive;
	}
	public String[] getSimple() {
		return this.simple;
	}
	public void setSimple(String[] simple) {
		this.simple = simple;
	}
	public Holder[] getInner() {
		return this.inner;
	}
	public void setInner(Holder[] inner) {
		this.inner = inner;
	}
	public Map<String, Integer>[] getNameToInteger() {
		return this.nameToInteger;
	}
	public void setNameToInteger(Map<String, Integer>[] nameToInteger) {
		this.nameToInteger = nameToInteger;
	}
	static class Holder {
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
public class NotAnnotated {
}
/*
package org.springframework.boot.configurationsample.simple;
/**
public class ClassWithNestedProperties {
	public static class NestedParentClass {
		private int parentClassProperty = 10;
		public int getParentClassProperty() {
			return this.parentClassProperty;
		}
		public void setParentClassProperty(int parentClassProperty) {
			this.parentClassProperty = parentClassProperty;
		}
	}
	@ConfigurationProperties(prefix = 'nestedChildProps')
	public static class NestedChildClass extends NestedParentClass {
		private int childClassProperty = 20;
		public int getChildClassProperty() {
			return this.childClassProperty;
		}
		public void setChildClassProperty(int childClassProperty) {
			this.childClassProperty = childClassProperty;
		}
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties(prefix = 'collection')
public class SimpleCollectionProperties {
	private Map<Integer, String> integersToNames;
	private Collection<Long> longs;
	private List<Float> floats;
	private final Map<String, Integer> namesToIntegers = new HashMap<>();
	private final Collection<Byte> bytes = new LinkedHashSet<>();
	private final List<Double> doubles = new ArrayList<>();
	private final Map<String, Holder<String>> namesToHolders = new HashMap<>();
	public Map<Integer, String> getIntegersToNames() {
		return this.integersToNames;
	}
	public void setIntegersToNames(Map<Integer, String> integersToNames) {
		this.integersToNames = integersToNames;
	}
	public Collection<Long> getLongs() {
		return this.longs;
	}
	public void setLongs(Collection<Long> longs) {
		this.longs = longs;
	}
	public List<Float> getFloats() {
		return this.floats;
	}
	public void setFloats(List<Float> floats) {
		this.floats = floats;
	}
	public Map<String, Integer> getNamesToIntegers() {
		return this.namesToIntegers;
	}
	public Collection<Byte> getBytes() {
		return this.bytes;
	}
	public List<Double> getDoubles() {
		return this.doubles;
	}
	public Map<String, Holder<String>> getNamesToHolders() {
		return this.namesToHolders;
	}
	public static class Holder<T> {
		@SuppressWarnings('unused')
		private T target;
		public void setTarget(T target) {
			this.target = target;
		}
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties('description')
public class DescriptionProperties {
	/**
	 * A simple description.
	 */
	private String simple;
	/**
	 * This is a lengthy description that spans across multiple lines to showcase that the
	 * line separators are cleaned automatically.
	 */
	private String multiLine;
	public String getSimple() {
		return this.simple;
	}
	public void setSimple(String simple) {
		this.simple = simple;
	}
	public String getMultiLine() {
		return this.multiLine;
	}
	public void setMultiLine(String multiLine) {
		this.multiLine = multiLine;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties(prefix = 'hierarchical')
public class HierarchicalProperties extends HierarchicalPropertiesParent {
	private String third = 'three';
	public String getThird() {
		return this.third;
	}
	public void setThird(String third) {
		this.third = third;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties(prefix = 'simple')
public class SimpleProperties {
	/**
	 * The name of this simple properties.
	 */
	private String theName = 'boot';
	// isFlag is also detected
	/**
	 * A simple flag.
	 */
	private boolean flag;
	// An interface can still be injected because it might have a converter
	private Comparator<?> comparator;
	// There is only a getter on this instance but we don"t know what to do with it ->
	// ignored
	private FeatureDescriptor featureDescriptor;
	// There is only a setter on this 'simple' property --> ignored
	@SuppressWarnings('unused')
	private Long counter;
	// There is only a getter on this 'simple' property --> ignored
	private Integer size;
	public String getTheName() {
		return this.theName;
	}
	@Deprecated
	public void setTheName(String name) {
		this.theName = name;
	}
	@Deprecated
	public boolean isFlag() {
		return this.flag;
	}
	public void setFlag(boolean flag) {
		this.flag = flag;
	}
	public Comparator<?> getComparator() {
		return this.comparator;
	}
	public void setComparator(Comparator<?> comparator) {
		this.comparator = comparator;
	}
	public FeatureDescriptor getFeatureDescriptor() {
		return this.featureDescriptor;
	}
	public void setCounter(Long counter) {
		this.counter = counter;
	}
	public Integer getSize() {
		return this.size;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
public class AutowiredProperties {
	/**
	 * The name of this simple properties.
	 */
	private String theName;
	@Autowired
	public AutowiredProperties(String theName) {
		this.theName = theName;
	}
	public String getTheName() {
		return this.theName;
	}
	public void setTheName(String name) {
		this.theName = name;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties('simple')
public class SimplePrefixValueProperties {
	private String name;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties('deprecated-record')
public record DeprecatedRecord(String alpha, String bravo) {
	@Deprecated
	@DeprecatedConfigurationProperty(reason = 'some-reason')
	public String alpha() {
		return this.alpha;
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
public abstract class HierarchicalPropertiesParent extends HierarchicalPropertiesGrandparent {
	private String second = 'two';
	public String getSecond() {
		return this.second;
	}
	public void setSecond(String second) {
		this.second = second;
	}
	// Overridden properties should belong to this class, not
	// HierarchicalPropertiesGrandparent
	@Override
	public String getFirst() {
		return super.getFirst();
	}
	@Override
	public void setFirst(String first) {
		super.setFirst(first);
	}
}
/*
package org.springframework.boot.configurationsample.simple;
/**
@ConfigurationProperties(prefix = 'simple.type')
public class SimpleTypeProperties {
	private String myString;
	private Byte myByte;
	private byte myPrimitiveByte;
	private Character myChar;
	private char myPrimitiveChar;
	private Boolean myBoolean;
	private boolean myPrimitiveBoolean;
	private Short myShort;
	private short myPrimitiveShort;
	private Integer myInteger;
	private int myPrimitiveInteger;
	private Long myLong;
	private long myPrimitiveLong;
	private Double myDouble;
	private double myPrimitiveDouble;
	private Float myFloat;
	private float myPrimitiveFloat;
	public String getMyString() {
		return this.myString;
	}
	public void setMyString(String myString) {
		this.myString = myString;
	}
	public Byte getMyByte() {
		return this.myByte;
	}
	public void setMyByte(Byte myByte) {
		this.myByte = myByte;
	}
	public byte getMyPrimitiveByte() {
		return this.myPrimitiveByte;
	}
	public void setMyPrimitiveByte(byte myPrimitiveByte) {
		this.myPrimitiveByte = myPrimitiveByte;
	}
	public Character getMyChar() {
		return this.myChar;
	}
	public void setMyChar(Character myChar) {
		this.myChar = myChar;
	}
	public char getMyPrimitiveChar() {
		return this.myPrimitiveChar;
	}
	public void setMyPrimitiveChar(char myPrimitiveChar) {
		this.myPrimitiveChar = myPrimitiveChar;
	}
	public Boolean getMyBoolean() {
		return this.myBoolean;
	}
	public void setMyBoolean(Boolean myBoolean) {
		this.myBoolean = myBoolean;
	}
	public boolean isMyPrimitiveBoolean() {
		return this.myPrimitiveBoolean;
	}
	public void setMyPrimitiveBoolean(boolean myPrimitiveBoolean) {
		this.myPrimitiveBoolean = myPrimitiveBoolean;
	}
	public Short getMyShort() {
		return this.myShort;
	}
	public void setMyShort(Short myShort) {
		this.myShort = myShort;
	}
	public short getMyPrimitiveShort() {
		return this.myPrimitiveShort;
	}
	public void setMyPrimitiveShort(short myPrimitiveShort) {
		this.myPrimitiveShort = myPrimitiveShort;
	}
	public Integer getMyInteger() {
		return this.myInteger;
	}
	public void setMyInteger(Integer myInteger) {
		this.myInteger = myInteger;
	}
	public int getMyPrimitiveInteger() {
		return this.myPrimitiveInteger;
	}
	public void setMyPrimitiveInteger(int myPrimitiveInteger) {
		this.myPrimitiveInteger = myPrimitiveInteger;
	}
	public Long getMyLong() {
		return this.myLong;
	}
	public void setMyLong(Long myLong) {
		this.myLong = myLong;
	}
	public long getMyPrimitiveLong() {
		return this.myPrimitiveLong;
	}
	public void setMyPrimitiveLong(long myPrimitiveLong) {
		this.myPrimitiveLong = myPrimitiveLong;
	}
	public Double getMyDouble() {
		return this.myDouble;
	}
	public void setMyDouble(Double myDouble) {
		this.myDouble = myDouble;
	}
	public double getMyPrimitiveDouble() {
		return this.myPrimitiveDouble;
	}
	public void setMyPrimitiveDouble(double myPrimitiveDouble) {
		this.myPrimitiveDouble = myPrimitiveDouble;
	}
	public Float getMyFloat() {
		return this.myFloat;
	}
	public void setMyFloat(Float myFloat) {
		this.myFloat = myFloat;
	}
	public float getMyPrimitiveFloat() {
		return this.myPrimitiveFloat;
	}
	public void setMyPrimitiveFloat(float myPrimitiveFloat) {
		this.myPrimitiveFloat = myPrimitiveFloat;
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
abstract class PropertyDescriptor {
	private final String name;
	private final TypeMirror type;
	private final TypeElement declaringElement;
	private final ExecutableElement getter;
	/**
	 * Create a new {@link PropertyDescriptor} instance.
	 * @param name the property name
	 * @param type the property type
	 * @param declaringElement the element that declared the item
	 * @param getter the getter for the property or {@code null}
	 */
	PropertyDescriptor(String name, TypeMirror type, TypeElement declaringElement, ExecutableElement getter) {
		this.declaringElement = declaringElement;
		this.name = name;
		this.type = type;
		this.getter = getter;
	}
	/**
	 * Return the name of the property.
	 * @return the property name
	 */
	String getName() {
		return this.name;
	}
	/**
	 * Return the type of the property.
	 * @return the property type
	 */
	TypeMirror getType() {
		return this.type;
	}
	/**
	 * Return the element that declared the property.
	 * @return the declaring element
	 */
	protected final TypeElement getDeclaringElement() {
		return this.declaringElement;
	}
	/**
	 * Return the getter for the property.
	 * @return the getter or {@code null}
	 */
	protected final ExecutableElement getGetter() {
		return this.getter;
	}
	/**
	 * Resolve the {@link ItemMetadata} for this property.
	 * @param prefix the property prefix
	 * @param environment the metadata generation environment
	 * @return the item metadata or {@code null}
	 */
	final ItemMetadata resolveItemMetadata(String prefix, MetadataGenerationEnvironment environment) {
		if (isNested(environment)) {
			return resolveItemMetadataGroup(prefix, environment);
		}
		if (isProperty(environment)) {
			return resolveItemMetadataProperty(prefix, environment);
		}
		return null;
	}
	/**
	 * Return if this is a nested property.
	 * @param environment the metadata generation environment
	 * @return if the property is nested
	 * @see #isMarkedAsNested(MetadataGenerationEnvironment)
	 */
	boolean isNested(MetadataGenerationEnvironment environment) {
		Element typeElement = environment.getTypeUtils().asElement(getType());
		if (!(typeElement instanceof TypeElement) || typeElement.getKind() == ElementKind.ENUM
				|| environment.getConfigurationPropertiesAnnotation(getGetter()) != null) {
			return false;
		}
		if (isMarkedAsNested(environment)) {
			return true;
		}
		return !isCyclePresent(typeElement, getDeclaringElement())
				&& isParentTheSame(environment, typeElement, getDeclaringElement());
	}
	/**
	 * Return if this property has been explicitly marked as nested (for example using an
	 * annotation}.
	 * @param environment the metadata generation environment
	 * @return if the property has been marked as nested
	 */
	protected abstract boolean isMarkedAsNested(MetadataGenerationEnvironment environment);
	private boolean isCyclePresent(Element returnType, Element element) {
		if (!(element.getEnclosingElement() instanceof TypeElement)) {
			return false;
		}
		if (element.getEnclosingElement().equals(returnType)) {
			return true;
		}
		return isCyclePresent(returnType, element.getEnclosingElement());
	}
	private boolean isParentTheSame(MetadataGenerationEnvironment environment, Element returnType,
			TypeElement element) {
		if (returnType == null || element == null) {
			return false;
		}
		returnType = getTopLevelType(returnType);
		Element candidate = element;
		while (candidate != null && candidate instanceof TypeElement) {
			if (returnType.equals(getTopLevelType(candidate))) {
				return true;
			}
			candidate = environment.getTypeUtils().asElement(((TypeElement) candidate).getSuperclass());
		}
		return false;
	}
	private Element getTopLevelType(Element element) {
		if (!(element.getEnclosingElement() instanceof TypeElement)) {
			return element;
		}
		return getTopLevelType(element.getEnclosingElement());
	}
	private ItemMetadata resolveItemMetadataGroup(String prefix, MetadataGenerationEnvironment environment) {
		Element propertyElement = environment.getTypeUtils().asElement(getType());
		String nestedPrefix = ConfigurationMetadata.nestedPrefix(prefix, getName());
		String dataType = environment.getTypeUtils().getQualifiedName(propertyElement);
		String ownerType = environment.getTypeUtils().getQualifiedName(getDeclaringElement());
		String sourceMethod = (getGetter() != null) ? getGetter().toString() : null;
		return ItemMetadata.newGroup(nestedPrefix, dataType, ownerType, sourceMethod);
	}
	private ItemMetadata resolveItemMetadataProperty(String prefix, MetadataGenerationEnvironment environment) {
		String dataType = resolveType(environment);
		String ownerType = environment.getTypeUtils().getQualifiedName(getDeclaringElement());
		String description = resolveDescription(environment);
		Object defaultValue = resolveDefaultValue(environment);
		ItemDeprecation deprecation = resolveItemDeprecation(environment);
		return ItemMetadata.newProperty(prefix, getName(), dataType, ownerType, null, description, defaultValue,
				deprecation);
	}
	private String resolveType(MetadataGenerationEnvironment environment) {
		return environment.getTypeUtils().getType(getDeclaringElement(), getType());
	}
	private ItemDeprecation resolveItemDeprecation(MetadataGenerationEnvironment environment) {
		boolean deprecated = getDeprecatableElements().stream().anyMatch(environment::isDeprecated);
		return deprecated ? environment.resolveItemDeprecation(getGetter()) : null;
	}
	/**
	 * Resolve the property description.
	 * @param environment the metadata generation environment
	 * @return the property description
	 */
	protected abstract String resolveDescription(MetadataGenerationEnvironment environment);
	/**
	 * Resolve the default value for this property.
	 * @param environment the metadata generation environment
	 * @return the default value or {@code null}
	 */
	protected abstract Object resolveDefaultValue(MetadataGenerationEnvironment environment);
	/**
	 * Return all the elements that should be considered when checking for deprecation
	 * annotations.
	 * @return the deprecatable elements
	 */
	protected abstract List<Element> getDeprecatableElements();
	/**
	 * Return true if this descriptor is for a property.
	 * @param environment the metadata generation environment
	 * @return if this is a property
	 */
	abstract boolean isProperty(MetadataGenerationEnvironment environment);
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues;
/**
@FunctionalInterface
public interface FieldValuesParser {
	/**
	 * Implementation of {@link FieldValuesParser} that always returns an empty result.
	 */
	FieldValuesParser NONE = (element) -> Collections.emptyMap();
	/**
	 * Return the field values for the given element.
	 * @param element the element to inspect
	 * @return a map of field names to values.
	 * @throws Exception if the values cannot be extracted
	 */
	Map<String, Object> getFieldValues(TypeElement element) throws Exception;
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
class VariableTree extends ReflectionWrapper {
	VariableTree(Object instance) {
		super('com.sun.source.tree.VariableTree', instance);
	}
	String getName() throws Exception {
		return findMethod('getName').invoke(getInstance()).toString();
	}
	String getType() throws Exception {
		return findMethod('getType').invoke(getInstance()).toString();
	}
	ExpressionTree getInitializer() throws Exception {
		Object instance = findMethod('getInitializer').invoke(getInstance());
		return (instance != null) ? new ExpressionTree(instance) : null;
	}
	@SuppressWarnings('unchecked')
	Set<Modifier> getModifierFlags() throws Exception {
		Object modifiers = findMethod('getModifiers').invoke(getInstance());
		if (modifiers == null) {
			return Collections.emptySet();
		}
		return (Set<Modifier>) findMethod(findClass('com.sun.source.tree.ModifiersTree'), 'getFlags').invoke(modifiers);
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
class ExpressionTree extends ReflectionWrapper {
	private final Class<?> literalTreeType = findClass('com.sun.source.tree.LiteralTree');
	private final Method literalValueMethod = findMethod(this.literalTreeType, 'getValue');
	private final Class<?> methodInvocationTreeType = findClass('com.sun.source.tree.MethodInvocationTree');
	private final Method methodInvocationArgumentsMethod = findMethod(this.methodInvocationTreeType, 'getArguments');
	private final Class<?> memberSelectTreeType = findClass('com.sun.source.tree.MemberSelectTree');
	private final Method memberSelectTreeExpressionMethod = findMethod(this.memberSelectTreeType, 'getExpression');
	private final Method memberSelectTreeIdentifierMethod = findMethod(this.memberSelectTreeType, 'getIdentifier');
	private final Class<?> newArrayTreeType = findClass('com.sun.source.tree.NewArrayTree');
	private final Method arrayValueMethod = findMethod(this.newArrayTreeType, 'getInitializers');
	ExpressionTree(Object instance) {
		super('com.sun.source.tree.ExpressionTree', instance);
	}
	String getKind() throws Exception {
		return findMethod('getKind').invoke(getInstance()).toString();
	}
	Object getLiteralValue() throws Exception {
		if (this.literalTreeType.isAssignableFrom(getInstance().getClass())) {
			return this.literalValueMethod.invoke(getInstance());
		}
		return null;
	}
	Object getFactoryValue() throws Exception {
		if (this.methodInvocationTreeType.isAssignableFrom(getInstance().getClass())) {
			List<?> arguments = (List<?>) this.methodInvocationArgumentsMethod.invoke(getInstance());
			if (arguments.size() == 1) {
				return new ExpressionTree(arguments.get(0)).getLiteralValue();
			}
		}
		return null;
	}
	Member getSelectedMember() throws Exception {
		if (this.memberSelectTreeType.isAssignableFrom(getInstance().getClass())) {
			String expression = this.memberSelectTreeExpressionMethod.invoke(getInstance()).toString();
			String identifier = this.memberSelectTreeIdentifierMethod.invoke(getInstance()).toString();
			if (expression != null && identifier != null) {
				return new Member(expression, identifier);
			}
		}
		return null;
	}
	List<? extends ExpressionTree> getArrayExpression() throws Exception {
		if (this.newArrayTreeType.isAssignableFrom(getInstance().getClass())) {
			List<?> elements = (List<?>) this.arrayValueMethod.invoke(getInstance());
			List<ExpressionTree> result = new ArrayList<>();
			if (elements == null) {
				return result;
			}
			for (Object element : elements) {
				result.add(new ExpressionTree(element));
			}
			return result;
		}
		return null;
	}
	record Member(String expression, String identifier) {
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
final class Trees extends ReflectionWrapper {
	private Trees(Object instance) {
		super('com.sun.source.util.Trees', instance);
	}
	Tree getTree(Element element) throws Exception {
		Object tree = findMethod('getTree', Element.class).invoke(getInstance(), element);
		return (tree != null) ? new Tree(tree) : null;
	}
	static Trees instance(ProcessingEnvironment env) throws Exception {
		try {
			ClassLoader classLoader = env.getClass().getClassLoader();
			Class<?> type = findClass(classLoader, 'com.sun.source.util.Trees');
			Method method = findMethod(type, 'instance', ProcessingEnvironment.class);
			return new Trees(method.invoke(null, env));
		}
		catch (Exception ex) {
			return instance(unwrap(env));
		}
	}
	private static ProcessingEnvironment unwrap(ProcessingEnvironment wrapper) throws Exception {
		Field delegateField = wrapper.getClass().getDeclaredField('delegate');
		delegateField.setAccessible(true);
		return (ProcessingEnvironment) delegateField.get(wrapper);
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
class Tree extends ReflectionWrapper {
	private final Class<?> treeVisitorType = findClass('com.sun.source.tree.TreeVisitor');
	private final Method acceptMethod = findMethod('accept', this.treeVisitorType, Object.class);
	private final Method getClassTreeMembers = findMethod(findClass('com.sun.source.tree.ClassTree'), 'getMembers');
	Tree(Object instance) {
		super('com.sun.source.tree.Tree', instance);
	}
	void accept(TreeVisitor visitor) throws Exception {
		this.acceptMethod.invoke(getInstance(), Proxy.newProxyInstance(getInstance().getClass().getClassLoader(),
				new Class<?>[] { this.treeVisitorType }, new TreeVisitorInvocationHandler(visitor)), 0);
	}
	/**
	 * {@link InvocationHandler} to call the {@link TreeVisitor}.
	 */
	private class TreeVisitorInvocationHandler implements InvocationHandler {
		private TreeVisitor treeVisitor;
		TreeVisitorInvocationHandler(TreeVisitor treeVisitor) {
			this.treeVisitor = treeVisitor;
		}
		@Override
		@SuppressWarnings('rawtypes')
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			if (method.getName().equals('visitClass') && (Integer) args[1] == 0) {
				Iterable members = (Iterable) Tree.this.getClassTreeMembers.invoke(args[0]);
				for (Object member : members) {
					if (member != null) {
						Tree.this.acceptMethod.invoke(member, proxy, ((Integer) args[1]) + 1);
					}
				}
			}
			if (method.getName().equals('visitVariable')) {
				this.treeVisitor.visitVariable(new VariableTree(args[0]));
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
class ReflectionWrapper {
	private final Class<?> type;
	private final Object instance;
	ReflectionWrapper(String type, Object instance) {
		this.type = findClass(instance.getClass().getClassLoader(), type);
		this.instance = this.type.cast(instance);
	}
	protected final Object getInstance() {
		return this.instance;
	}
	@Override
	public String toString() {
		return this.instance.toString();
	}
	protected Class<?> findClass(String name) {
		return findClass(getInstance().getClass().getClassLoader(), name);
	}
	protected Method findMethod(String name, Class<?>... parameterTypes) {
		return findMethod(this.type, name, parameterTypes);
	}
	protected static Class<?> findClass(ClassLoader classLoader, String name) {
		try {
			return Class.forName(name, false, classLoader);
		}
		catch (ClassNotFoundException ex) {
			throw new IllegalStateException(ex);
		}
	}
	protected static Method findMethod(Class<?> type, String name, Class<?>... parameterTypes) {
		try {
			return type.getMethod(name, parameterTypes);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
public class JavaCompilerFieldValuesParser implements FieldValuesParser {
	private final Trees trees;
	public JavaCompilerFieldValuesParser(ProcessingEnvironment env) throws Exception {
		this.trees = Trees.instance(env);
	}
	@Override
	public Map<String, Object> getFieldValues(TypeElement element) throws Exception {
		Tree tree = this.trees.getTree(element);
		if (tree != null) {
			FieldCollector fieldCollector = new FieldCollector();
			tree.accept(fieldCollector);
			return fieldCollector.getFieldValues();
		}
		return Collections.emptyMap();
	}
	/**
	 * {@link TreeVisitor} to collect fields.
	 */
	private static final class FieldCollector implements TreeVisitor {
		private static final Map<String, Class<?>> WRAPPER_TYPES;
		static {
			Map<String, Class<?>> types = new HashMap<>();
			types.put('boolean', Boolean.class);
			types.put(Boolean.class.getName(), Boolean.class);
			types.put('byte', Byte.class);
			types.put(Byte.class.getName(), Byte.class);
			types.put('short', Short.class);
			types.put(Short.class.getName(), Short.class);
			types.put('int', Integer.class);
			types.put(Integer.class.getName(), Integer.class);
			types.put('long', Long.class);
			types.put(Long.class.getName(), Long.class);
			WRAPPER_TYPES = Collections.unmodifiableMap(types);
		}
		private static final Map<Class<?>, Object> DEFAULT_TYPE_VALUES;
		static {
			Map<Class<?>, Object> values = new HashMap<>();
			values.put(Boolean.class, false);
			values.put(Byte.class, (byte) 0);
			values.put(Short.class, (short) 0);
			values.put(Integer.class, 0);
			values.put(Long.class, (long) 0);
			DEFAULT_TYPE_VALUES = Collections.unmodifiableMap(values);
		}
		private static final Map<String, Object> WELL_KNOWN_STATIC_FINALS;
		static {
			Map<String, Object> values = new HashMap<>();
			values.put('Boolean.TRUE', true);
			values.put('Boolean.FALSE', false);
			values.put('StandardCharsets.ISO_8859_1', 'ISO-8859-1');
			values.put('StandardCharsets.UTF_8', 'UTF-8');
			values.put('StandardCharsets.UTF_16', 'UTF-16');
			values.put('StandardCharsets.US_ASCII', 'US-ASCII');
			values.put('Duration.ZERO', 0);
			values.put('Period.ZERO', 0);
			WELL_KNOWN_STATIC_FINALS = Collections.unmodifiableMap(values);
		}
		private static final String DURATION_OF = 'Duration.of';
		private static final Map<String, String> DURATION_SUFFIX;
		static {
			Map<String, String> values = new HashMap<>();
			values.put('Nanos', 'ns');
			values.put('Millis', 'ms');
			values.put('Seconds', 's');
			values.put('Minutes', 'm');
			values.put('Hours', 'h');
			values.put('Days', 'd');
			DURATION_SUFFIX = Collections.unmodifiableMap(values);
		}
		private static final String PERIOD_OF = 'Period.of';
		private static final Map<String, String> PERIOD_SUFFIX;
		static {
			Map<String, String> values = new HashMap<>();
			values.put('Days', 'd');
			values.put('Weeks', 'w');
			values.put('Months', 'm');
			values.put('Years', 'y');
			PERIOD_SUFFIX = Collections.unmodifiableMap(values);
		}
		private static final String DATA_SIZE_OF = 'DataSize.of';
		private static final Map<String, String> DATA_SIZE_SUFFIX;
		static {
			Map<String, String> values = new HashMap<>();
			values.put('Bytes', 'B');
			values.put('Kilobytes', 'KB');
			values.put('Megabytes', 'MB');
			values.put('Gigabytes', 'GB');
			values.put('Terabytes', 'TB');
			DATA_SIZE_SUFFIX = Collections.unmodifiableMap(values);
		}
		private final Map<String, Object> fieldValues = new HashMap<>();
		private final Map<String, Object> staticFinals = new HashMap<>();
		@Override
		public void visitVariable(VariableTree variable) throws Exception {
			Set<Modifier> flags = variable.getModifierFlags();
			if (flags.contains(Modifier.STATIC) && flags.contains(Modifier.FINAL)) {
				this.staticFinals.put(variable.getName(), getValue(variable));
			}
			if (!flags.contains(Modifier.FINAL)) {
				this.fieldValues.put(variable.getName(), getValue(variable));
			}
		}
		private Object getValue(VariableTree variable) throws Exception {
			ExpressionTree initializer = variable.getInitializer();
			Class<?> wrapperType = WRAPPER_TYPES.get(variable.getType());
			Object defaultValue = DEFAULT_TYPE_VALUES.get(wrapperType);
			if (initializer != null) {
				return getValue(variable.getType(), initializer, defaultValue);
			}
			return defaultValue;
		}
		private Object getValue(String variableType, ExpressionTree expression, Object defaultValue) throws Exception {
			Object literalValue = expression.getLiteralValue();
			if (literalValue != null) {
				return literalValue;
			}
			Object factoryValue = expression.getFactoryValue();
			if (factoryValue != null) {
				return getFactoryValue(expression, factoryValue);
			}
			List<? extends ExpressionTree> arrayValues = expression.getArrayExpression();
			if (arrayValues != null) {
				Object[] result = new Object[arrayValues.size()];
				for (int i = 0; i < arrayValues.size(); i++) {
					Object value = getValue(variableType, arrayValues.get(i), null);
					if (value == null) { // One of the elements could not be resolved
						return defaultValue;
					}
					result[i] = value;
				}
				return result;
			}
			if (expression.getKind().equals('IDENTIFIER')) {
				return this.staticFinals.get(expression.toString());
			}
			if (expression.getKind().equals('MEMBER_SELECT')) {
				Object value = WELL_KNOWN_STATIC_FINALS.get(expression.toString());
				if (value != null) {
					return value;
				}
				Member selectedMember = expression.getSelectedMember();
				// Type matching the expression, assuming an enum
				if (selectedMember != null && selectedMember.expression().equals(variableType)) {
					return ConventionUtils.toDashedCase(selectedMember.identifier().toLowerCase(Locale.ENGLISH));
				}
				return null;
			}
			return defaultValue;
		}
		private Object getFactoryValue(ExpressionTree expression, Object factoryValue) {
			Object durationValue = getFactoryValue(expression, factoryValue, DURATION_OF, DURATION_SUFFIX);
			if (durationValue != null) {
				return durationValue;
			}
			Object dataSizeValue = getFactoryValue(expression, factoryValue, DATA_SIZE_OF, DATA_SIZE_SUFFIX);
			if (dataSizeValue != null) {
				return dataSizeValue;
			}
			Object periodValue = getFactoryValue(expression, factoryValue, PERIOD_OF, PERIOD_SUFFIX);
			if (periodValue != null) {
				return periodValue;
			}
			return factoryValue;
		}
		private Object getFactoryValue(ExpressionTree expression, Object factoryValue, String prefix,
				Map<String, String> suffixMapping) {
			Object instance = expression.getInstance();
			if (instance != null && instance.toString().startsWith(prefix)) {
				String type = instance.toString();
				type = type.substring(prefix.length(), type.indexOf("("));
				String suffix = suffixMapping.get(type);
				return (suffix != null) ? factoryValue + suffix : null;
			}
			return null;
		}
		Map<String, Object> getFieldValues() {
			return this.fieldValues;
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/**
interface TreeVisitor {
	void visitVariable(VariableTree variable) throws Exception;
}
/*
/**
package org.springframework.boot.configurationprocessor.fieldvalues.javac;
/*
/**
package org.springframework.boot.configurationprocessor.fieldvalues;
/*
package org.springframework.boot.configurationprocessor;
/**
class TypeElementMembers {
	private static final String OBJECT_CLASS_NAME = Object.class.getName();
	private static final String RECORD_CLASS_NAME = Record.class.getName();
	private final MetadataGenerationEnvironment env;
	private final TypeElement targetType;
	private final boolean isRecord;
	private final Map<String, VariableElement> fields = new LinkedHashMap<>();
	private final Map<String, RecordComponentElement> recordComponents = new LinkedHashMap<>();
	private final Map<String, List<ExecutableElement>> publicGetters = new LinkedHashMap<>();
	private final Map<String, List<ExecutableElement>> publicSetters = new LinkedHashMap<>();
	TypeElementMembers(MetadataGenerationEnvironment env, TypeElement targetType) {
		this.env = env;
		this.targetType = targetType;
		this.isRecord = RECORD_CLASS_NAME.equals(targetType.getSuperclass().toString());
		process(targetType);
	}
	private void process(TypeElement element) {
		for (VariableElement field : ElementFilter.fieldsIn(element.getEnclosedElements())) {
			processField(field);
		}
		for (RecordComponentElement recordComponent : ElementFilter.recordComponentsIn(element.getEnclosedElements())) {
			processRecordComponent(recordComponent);
		}
		for (ExecutableElement method : ElementFilter.methodsIn(element.getEnclosedElements())) {
			processMethod(method);
		}
		Element superType = this.env.getTypeUtils().asElement(element.getSuperclass());
		if (superType instanceof TypeElement && !OBJECT_CLASS_NAME.equals(superType.toString())
				&& !RECORD_CLASS_NAME.equals(superType.toString())) {
			process((TypeElement) superType);
		}
	}
	private void processMethod(ExecutableElement method) {
		if (isPublic(method)) {
			String name = method.getSimpleName().toString();
			if (isGetter(method)) {
				String propertyName = getAccessorName(name);
				List<ExecutableElement> matchingGetters = this.publicGetters.computeIfAbsent(propertyName,
						(k) -> new ArrayList<>());
				TypeMirror returnType = method.getReturnType();
				if (getMatchingGetter(matchingGetters, returnType) == null) {
					matchingGetters.add(method);
				}
			}
			else if (isSetter(method)) {
				String propertyName = getAccessorName(name);
				List<ExecutableElement> matchingSetters = this.publicSetters.computeIfAbsent(propertyName,
						(k) -> new ArrayList<>());
				TypeMirror paramType = method.getParameters().get(0).asType();
				if (getMatchingSetter(matchingSetters, paramType) == null) {
					matchingSetters.add(method);
				}
			}
		}
	}
	private boolean isPublic(ExecutableElement method) {
		Set<Modifier> modifiers = method.getModifiers();
		return modifiers.contains(Modifier.PUBLIC) && !modifiers.contains(Modifier.ABSTRACT)
				&& !modifiers.contains(Modifier.STATIC);
	}
	ExecutableElement getMatchingGetter(List<ExecutableElement> candidates, TypeMirror type) {
		return getMatchingAccessor(candidates, type, ExecutableElement::getReturnType);
	}
	private ExecutableElement getMatchingSetter(List<ExecutableElement> candidates, TypeMirror type) {
		return getMatchingAccessor(candidates, type, (candidate) -> candidate.getParameters().get(0).asType());
	}
	private ExecutableElement getMatchingAccessor(List<ExecutableElement> candidates, TypeMirror type,
			Function<ExecutableElement, TypeMirror> typeExtractor) {
		for (ExecutableElement candidate : candidates) {
			TypeMirror candidateType = typeExtractor.apply(candidate);
			if (this.env.getTypeUtils().isSameType(candidateType, type)) {
				return candidate;
			}
		}
		return null;
	}
	private boolean isGetter(ExecutableElement method) {
		boolean hasParameters = !method.getParameters().isEmpty();
		boolean returnsVoid = TypeKind.VOID == method.getReturnType().getKind();
		if (hasParameters || returnsVoid) {
			return false;
		}
		String name = method.getSimpleName().toString();
		if (this.isRecord && this.fields.containsKey(name)) {
			return true;
		}
		return (name.startsWith('get') && name.length() > 3) || (name.startsWith('is') && name.length() > 2);
	}
	private boolean isSetter(ExecutableElement method) {
		if (this.isRecord) {
			return false;
		}
		final String name = method.getSimpleName().toString();
		return (name.startsWith('set') && name.length() > 3 && method.getParameters().size() == 1
				&& isSetterReturnType(method));
	}
	private boolean isSetterReturnType(ExecutableElement method) {
		TypeMirror returnType = method.getReturnType();
		if (TypeKind.VOID == returnType.getKind()) {
			return true;
		}
		if (TypeKind.DECLARED == returnType.getKind()
				&& this.env.getTypeUtils().isSameType(method.getEnclosingElement().asType(), returnType)) {
			return true;
		}
		if (TypeKind.TYPEVAR == returnType.getKind()) {
			String resolvedType = this.env.getTypeUtils().getType(this.targetType, returnType);
			return (resolvedType != null
					&& resolvedType.equals(this.env.getTypeUtils().getQualifiedName(this.targetType)));
		}
		return false;
	}
	private String getAccessorName(String methodName) {
		if (this.isRecord && this.fields.containsKey(methodName)) {
			return methodName;
		}
		if (methodName.startsWith('is')) {
			return lowerCaseFirstCharacter(methodName.substring(2));
		}
		if (methodName.startsWith('get') || methodName.startsWith('set')) {
			return lowerCaseFirstCharacter(methodName.substring(3));
		}
		throw new IllegalStateException('methodName must start with "is", "get" or "set", was "' + methodName + '"');
	}
	private String lowerCaseFirstCharacter(String string) {
		return Character.toLowerCase(string.charAt(0)) + string.substring(1);
	}
	private void processField(VariableElement field) {
		String name = field.getSimpleName().toString();
		this.fields.putIfAbsent(name, field);
	}
	private void processRecordComponent(RecordComponentElement recordComponent) {
		String name = recordComponent.getSimpleName().toString();
		this.recordComponents.putIfAbsent(name, recordComponent);
	}
	Map<String, VariableElement> getFields() {
		return Collections.unmodifiableMap(this.fields);
	}
	Map<String, RecordComponentElement> getRecordComponents() {
		return Collections.unmodifiableMap(this.recordComponents);
	}
	Map<String, List<ExecutableElement>> getPublicGetters() {
		return Collections.unmodifiableMap(this.publicGetters);
	}
	ExecutableElement getPublicGetter(String name, TypeMirror type) {
		List<ExecutableElement> candidates = this.publicGetters.get(name);
		return getPublicAccessor(candidates, type, (specificType) -> getMatchingGetter(candidates, specificType));
	}
	ExecutableElement getPublicSetter(String name, TypeMirror type) {
		List<ExecutableElement> candidates = this.publicSetters.get(name);
		return getPublicAccessor(candidates, type, (specificType) -> getMatchingSetter(candidates, specificType));
	}
	private ExecutableElement getPublicAccessor(List<ExecutableElement> candidates, TypeMirror type,
			Function<TypeMirror, ExecutableElement> matchingAccessorExtractor) {
		if (candidates != null) {
			ExecutableElement matching = matchingAccessorExtractor.apply(type);
			if (matching != null) {
				return matching;
			}
			TypeMirror alternative = this.env.getTypeUtils().getWrapperOrPrimitiveFor(type);
			if (alternative != null) {
				return matchingAccessorExtractor.apply(alternative);
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class LombokPropertyDescriptor extends PropertyDescriptor {
	private static final String LOMBOK_DATA_ANNOTATION = 'lombok.Data';
	private static final String LOMBOK_VALUE_ANNOTATION = 'lombok.Value';
	private static final String LOMBOK_GETTER_ANNOTATION = 'lombok.Getter';
	private static final String LOMBOK_SETTER_ANNOTATION = 'lombok.Setter';
	private static final String LOMBOK_ACCESS_LEVEL_PUBLIC = 'PUBLIC';
	private final ExecutableElement setter;
	private final VariableElement field;
	private final ExecutableElement factoryMethod;
	LombokPropertyDescriptor(String name, TypeMirror type, TypeElement declaringElement, ExecutableElement getter,
			ExecutableElement setter, VariableElement field, ExecutableElement factoryMethod) {
		super(name, type, declaringElement, getter);
		this.factoryMethod = factoryMethod;
		this.field = field;
		this.setter = setter;
	}
	VariableElement getField() {
		return this.field;
	}
	@Override
	protected boolean isMarkedAsNested(MetadataGenerationEnvironment environment) {
		return environment.getNestedConfigurationPropertyAnnotation(getField()) != null;
	}
	@Override
	protected String resolveDescription(MetadataGenerationEnvironment environment) {
		return environment.getTypeUtils().getJavaDoc(this.field);
	}
	@Override
	protected Object resolveDefaultValue(MetadataGenerationEnvironment environment) {
		return environment.getFieldDefaultValue(getDeclaringElement(), getName());
	}
	@Override
	protected List<Element> getDeprecatableElements() {
		return Arrays.asList(getGetter(), this.setter, this.field, this.factoryMethod);
	}
	@Override
	public boolean isProperty(MetadataGenerationEnvironment env) {
		if (!hasLombokPublicAccessor(env, true)) {
			return false;
		}
		boolean isCollection = env.getTypeUtils().isCollectionOrMap(getType());
		return !env.isExcluded(getType()) && (hasSetter(env) || isCollection);
	}
	@Override
	public boolean isNested(MetadataGenerationEnvironment environment) {
		return hasLombokPublicAccessor(environment, true) && super.isNested(environment);
	}
	private boolean hasSetter(MetadataGenerationEnvironment env) {
		boolean nonFinalPublicField = !getField().getModifiers().contains(Modifier.FINAL)
				&& hasLombokPublicAccessor(env, false);
		return this.setter != null || nonFinalPublicField;
	}
	/**
	 * Determine if the current {@link #getField() field} defines a public accessor using
	 * lombok annotations.
	 * @param env the {@link MetadataGenerationEnvironment}
	 * @param getter {@code true} to look for the read accessor, {@code false} for the
	 * write accessor
	 * @return {@code true} if this field has a public accessor of the specified type
	 */
	private boolean hasLombokPublicAccessor(MetadataGenerationEnvironment env, boolean getter) {
		String annotation = (getter ? LOMBOK_GETTER_ANNOTATION : LOMBOK_SETTER_ANNOTATION);
		AnnotationMirror lombokMethodAnnotationOnField = env.getAnnotation(getField(), annotation);
		if (lombokMethodAnnotationOnField != null) {
			return isAccessLevelPublic(env, lombokMethodAnnotationOnField);
		}
		AnnotationMirror lombokMethodAnnotationOnElement = env.getAnnotation(getDeclaringElement(), annotation);
		if (lombokMethodAnnotationOnElement != null) {
			return isAccessLevelPublic(env, lombokMethodAnnotationOnElement);
		}
		return (env.hasAnnotation(getDeclaringElement(), LOMBOK_DATA_ANNOTATION)
				|| env.hasAnnotation(getDeclaringElement(), LOMBOK_VALUE_ANNOTATION));
	}
	private boolean isAccessLevelPublic(MetadataGenerationEnvironment env, AnnotationMirror lombokAnnotation) {
		Map<String, Object> values = env.getAnnotationElementValues(lombokAnnotation);
		Object value = values.get('value');
		return (value == null || value.toString().equals(LOMBOK_ACCESS_LEVEL_PUBLIC));
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
public class MetadataStore {
	static final String METADATA_PATH = 'META-INF/spring-configuration-metadata.json';
	private static final String ADDITIONAL_METADATA_PATH = 'META-INF/additional-spring-configuration-metadata.json';
	private static final String RESOURCES_DIRECTORY = 'resources';
	private static final String CLASSES_DIRECTORY = 'classes';
	private final ProcessingEnvironment environment;
	public MetadataStore(ProcessingEnvironment environment) {
		this.environment = environment;
	}
	public ConfigurationMetadata readMetadata() {
		try {
			return readMetadata(getMetadataResource().openInputStream());
		}
		catch (IOException ex) {
			return null;
		}
	}
	public void writeMetadata(ConfigurationMetadata metadata) throws IOException {
		if (!metadata.getItems().isEmpty()) {
			try (OutputStream outputStream = createMetadataResource().openOutputStream()) {
				new JsonMarshaller().write(metadata, outputStream);
			}
		}
	}
	public ConfigurationMetadata readAdditionalMetadata() throws IOException {
		return readMetadata(getAdditionalMetadataStream());
	}
	private ConfigurationMetadata readMetadata(InputStream in) {
		try (in) {
			return new JsonMarshaller().read(in);
		}
		catch (IOException ex) {
			return null;
		}
		catch (Exception ex) {
			throw new InvalidConfigurationMetadataException(
					'Invalid additional meta-data in "' + METADATA_PATH + '": ' + ex.getMessage(),
					Diagnostic.Kind.ERROR);
		}
	}
	private FileObject getMetadataResource() throws IOException {
		return this.environment.getFiler().getResource(StandardLocation.CLASS_OUTPUT, '', METADATA_PATH);
	}
	private FileObject createMetadataResource() throws IOException {
		return this.environment.getFiler().createResource(StandardLocation.CLASS_OUTPUT, '', METADATA_PATH);
	}
	private InputStream getAdditionalMetadataStream() throws IOException {
		// Most build systems will have copied the file to the class output location
		FileObject fileObject = this.environment.getFiler()
			.getResource(StandardLocation.CLASS_OUTPUT, '', ADDITIONAL_METADATA_PATH);
		InputStream inputStream = getMetadataStream(fileObject);
		if (inputStream != null) {
			return inputStream;
		}
		try {
			File file = locateAdditionalMetadataFile(new File(fileObject.toUri()));
			return (file.exists() ? new FileInputStream(file) : fileObject.toUri().toURL().openStream());
		}
		catch (Exception ex) {
			throw new FileNotFoundException();
		}
	}
	private InputStream getMetadataStream(FileObject fileObject) {
		try {
			return fileObject.openInputStream();
		}
		catch (IOException ex) {
			return null;
		}
	}
	File locateAdditionalMetadataFile(File standardLocation) throws IOException {
		if (standardLocation.exists()) {
			return standardLocation;
		}
		String locations = this.environment.getOptions()
			.get(ConfigurationMetadataAnnotationProcessor.ADDITIONAL_METADATA_LOCATIONS_OPTION);
		if (locations != null) {
			for (String location : locations.split(',')) {
				File candidate = new File(location, ADDITIONAL_METADATA_PATH);
				if (candidate.isFile()) {
					return candidate;
				}
			}
		}
		return new File(locateGradleResourcesDirectory(standardLocation), ADDITIONAL_METADATA_PATH);
	}
	private File locateGradleResourcesDirectory(File standardAdditionalMetadataLocation) throws FileNotFoundException {
		String path = standardAdditionalMetadataLocation.getPath();
		int index = path.lastIndexOf(CLASSES_DIRECTORY);
		if (index < 0) {
			throw new FileNotFoundException();
		}
		String buildDirectoryPath = path.substring(0, index);
		File classOutputLocation = standardAdditionalMetadataLocation.getParentFile().getParentFile();
		return new File(buildDirectoryPath, RESOURCES_DIRECTORY + "/" + classOutputLocation.getName());
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class PropertyDescriptorResolver {
	private final MetadataGenerationEnvironment environment;
	PropertyDescriptorResolver(MetadataGenerationEnvironment environment) {
		this.environment = environment;
	}
	/**
	 * Return the {@link PropertyDescriptor} instances that are valid candidates for the
	 * specified {@link TypeElement type} based on the specified {@link ExecutableElement
	 * factory method}, if any.
	 * @param type the target type
	 * @param factoryMethod the method that triggered the metadata for that {@code type}
	 * or {@code null}
	 * @return the candidate properties for metadata generation
	 */
	Stream<PropertyDescriptor> resolve(TypeElement type, ExecutableElement factoryMethod) {
		TypeElementMembers members = new TypeElementMembers(this.environment, type);
		if (factoryMethod != null) {
			return resolveJavaBeanProperties(type, members, factoryMethod);
		}
		return resolve(Bindable.of(type, this.environment), members);
	}
	private Stream<PropertyDescriptor> resolve(Bindable bindable, TypeElementMembers members) {
		if (bindable.isConstructorBindingEnabled()) {
			ExecutableElement bindConstructor = bindable.getBindConstructor();
			return (bindConstructor != null)
					? resolveConstructorBoundProperties(bindable.getType(), members, bindConstructor) : Stream.empty();
		}
		return resolveJavaBeanProperties(bindable.getType(), members, null);
	}
	private Stream<PropertyDescriptor> resolveConstructorBoundProperties(TypeElement declaringElement,
			TypeElementMembers members, ExecutableElement bindConstructor) {
		Map<String, PropertyDescriptor> candidates = new LinkedHashMap<>();
		bindConstructor.getParameters().forEach((parameter) -> {
			PropertyDescriptor descriptor = extracted(declaringElement, members, parameter);
			register(candidates, descriptor);
		});
		return candidates.values().stream();
	}
	private PropertyDescriptor extracted(TypeElement declaringElement, TypeElementMembers members,
			VariableElement parameter) {
		String name = getPropertyName(parameter);
		TypeMirror type = parameter.asType();
		ExecutableElement getter = members.getPublicGetter(name, type);
		ExecutableElement setter = members.getPublicSetter(name, type);
		VariableElement field = members.getFields().get(name);
		RecordComponentElement recordComponent = members.getRecordComponents().get(name);
		return (recordComponent != null)
				? new RecordParameterPropertyDescriptor(name, type, parameter, declaringElement, getter,
						recordComponent)
				: new ConstructorParameterPropertyDescriptor(name, type, parameter, declaringElement, getter, setter,
						field);
	}
	private String getPropertyName(VariableElement parameter) {
		return getPropertyName(parameter, parameter.getSimpleName().toString());
	}
	private String getPropertyName(VariableElement parameter, String fallback) {
		AnnotationMirror nameAnnotation = this.environment.getNameAnnotation(parameter);
		if (nameAnnotation != null) {
			return this.environment.getAnnotationElementStringValue(nameAnnotation, 'value');
		}
		return fallback;
	}
	private Stream<PropertyDescriptor> resolveJavaBeanProperties(TypeElement declaringElement,
			TypeElementMembers members, ExecutableElement factoryMethod) {
		// First check if we have regular java bean properties there
		Map<String, PropertyDescriptor> candidates = new LinkedHashMap<>();
		members.getPublicGetters().forEach((name, getters) -> {
			VariableElement field = members.getFields().get(name);
			ExecutableElement getter = findMatchingGetter(members, getters, field);
			TypeMirror propertyType = getter.getReturnType();
			register(candidates, new JavaBeanPropertyDescriptor(getPropertyName(field, name), propertyType,
					declaringElement, getter, members.getPublicSetter(name, propertyType), field, factoryMethod));
		});
		// Then check for Lombok ones
		members.getFields().forEach((name, field) -> {
			TypeMirror propertyType = field.asType();
			ExecutableElement getter = members.getPublicGetter(name, propertyType);
			ExecutableElement setter = members.getPublicSetter(name, propertyType);
			register(candidates, new LombokPropertyDescriptor(getPropertyName(field, name), propertyType,
					declaringElement, getter, setter, field, factoryMethod));
		});
		return candidates.values().stream();
	}
	private ExecutableElement findMatchingGetter(TypeElementMembers members, List<ExecutableElement> candidates,
			VariableElement field) {
		if (candidates.size() > 1 && field != null) {
			return members.getMatchingGetter(candidates, field.asType());
		}
		return candidates.get(0);
	}
	private void register(Map<String, PropertyDescriptor> candidates, PropertyDescriptor descriptor) {
		if (!candidates.containsKey(descriptor.getName()) && isCandidate(descriptor)) {
			candidates.put(descriptor.getName(), descriptor);
		}
	}
	private boolean isCandidate(PropertyDescriptor descriptor) {
		return descriptor.isProperty(this.environment) || descriptor.isNested(this.environment);
	}
	/**
	 * Wrapper around a {@link TypeElement} that could be bound.
	 */
	private static class Bindable {
		private final TypeElement type;
		private final List<ExecutableElement> constructors;
		private final List<ExecutableElement> boundConstructors;
		Bindable(TypeElement type, List<ExecutableElement> constructors, List<ExecutableElement> boundConstructors) {
			this.type = type;
			this.constructors = constructors;
			this.boundConstructors = boundConstructors;
		}
		TypeElement getType() {
			return this.type;
		}
		boolean isConstructorBindingEnabled() {
			return !this.boundConstructors.isEmpty();
		}
		ExecutableElement getBindConstructor() {
			if (this.boundConstructors.isEmpty()) {
				return findBoundConstructor();
			}
			if (this.boundConstructors.size() == 1) {
				return this.boundConstructors.get(0);
			}
			return null;
		}
		private ExecutableElement findBoundConstructor() {
			ExecutableElement boundConstructor = null;
			for (ExecutableElement candidate : this.constructors) {
				if (!candidate.getParameters().isEmpty()) {
					if (boundConstructor != null) {
						return null;
					}
					boundConstructor = candidate;
				}
			}
			return boundConstructor;
		}
		static Bindable of(TypeElement type, MetadataGenerationEnvironment env) {
			List<ExecutableElement> constructors = ElementFilter.constructorsIn(type.getEnclosedElements());
			List<ExecutableElement> boundConstructors = getBoundConstructors(type, env, constructors);
			return new Bindable(type, constructors, boundConstructors);
		}
		private static List<ExecutableElement> getBoundConstructors(TypeElement type, MetadataGenerationEnvironment env,
				List<ExecutableElement> constructors) {
			ExecutableElement bindConstructor = deduceBindConstructor(type, constructors, env);
			if (bindConstructor != null) {
				return Collections.singletonList(bindConstructor);
			}
			return constructors.stream().filter(env::hasConstructorBindingAnnotation).toList();
		}
		private static ExecutableElement deduceBindConstructor(TypeElement type, List<ExecutableElement> constructors,
				MetadataGenerationEnvironment env) {
			if (constructors.size() == 1) {
				ExecutableElement candidate = constructors.get(0);
				if (!candidate.getParameters().isEmpty() && !env.hasAutowiredAnnotation(candidate)) {
					if (type.getNestingKind() == NestingKind.MEMBER
							&& candidate.getModifiers().contains(Modifier.PRIVATE)) {
						return null;
					}
					return candidate;
				}
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class TypeUtils {
	private static final Map<TypeKind, Class<?>> PRIMITIVE_WRAPPERS;
	static {
		Map<TypeKind, Class<?>> wrappers = new EnumMap<>(TypeKind.class);
		wrappers.put(TypeKind.BOOLEAN, Boolean.class);
		wrappers.put(TypeKind.BYTE, Byte.class);
		wrappers.put(TypeKind.CHAR, Character.class);
		wrappers.put(TypeKind.DOUBLE, Double.class);
		wrappers.put(TypeKind.FLOAT, Float.class);
		wrappers.put(TypeKind.INT, Integer.class);
		wrappers.put(TypeKind.LONG, Long.class);
		wrappers.put(TypeKind.SHORT, Short.class);
		PRIMITIVE_WRAPPERS = Collections.unmodifiableMap(wrappers);
	}
	private static final Map<String, TypeKind> WRAPPER_TO_PRIMITIVE;
	static {
		Map<String, TypeKind> primitives = new HashMap<>();
		PRIMITIVE_WRAPPERS.forEach((kind, wrapperClass) -> primitives.put(wrapperClass.getName(), kind));
		WRAPPER_TO_PRIMITIVE = primitives;
	}
	private final ProcessingEnvironment env;
	private final Types types;
	private final TypeExtractor typeExtractor;
	private final TypeMirror collectionType;
	private final TypeMirror mapType;
	private final Map<TypeElement, TypeDescriptor> typeDescriptors = new HashMap<>();
	TypeUtils(ProcessingEnvironment env) {
		this.env = env;
		this.types = env.getTypeUtils();
		this.typeExtractor = new TypeExtractor(this.types);
		this.collectionType = getDeclaredType(this.types, Collection.class, 1);
		this.mapType = getDeclaredType(this.types, Map.class, 2);
	}
	private TypeMirror getDeclaredType(Types types, Class<?> typeClass, int numberOfTypeArgs) {
		TypeMirror[] typeArgs = new TypeMirror[numberOfTypeArgs];
		Arrays.setAll(typeArgs, (i) -> types.getWildcardType(null, null));
		TypeElement typeElement = this.env.getElementUtils().getTypeElement(typeClass.getName());
		try {
			return types.getDeclaredType(typeElement, typeArgs);
		}
		catch (IllegalArgumentException ex) {
			// Try again without generics for older Java versions
			return types.getDeclaredType(typeElement);
		}
	}
	boolean isSameType(TypeMirror t1, TypeMirror t2) {
		return this.types.isSameType(t1, t2);
	}
	Element asElement(TypeMirror type) {
		return this.types.asElement(type);
	}
	/**
	 * Return the qualified name of the specified element.
	 * @param element the element to handle
	 * @return the fully qualified name of the element, suitable for a call to
	 * {@link Class#forName(String)}
	 */
	String getQualifiedName(Element element) {
		return this.typeExtractor.getQualifiedName(element);
	}
	/**
	 * Return the type of the specified {@link TypeMirror} including all its generic
	 * information.
	 * @param element the {@link TypeElement} in which this {@code type} is declared
	 * @param type the type to handle
	 * @return a representation of the type including all its generic information
	 */
	String getType(TypeElement element, TypeMirror type) {
		if (type == null) {
			return null;
		}
		return type.accept(this.typeExtractor, createTypeDescriptor(element));
	}
	/**
	 * Extract the target element type from the specified container type or {@code null}
	 * if no element type was found.
	 * @param type a type, potentially wrapping an element type
	 * @return the element type or {@code null} if no specific type was found
	 */
	TypeMirror extractElementType(TypeMirror type) {
		if (!this.env.getTypeUtils().isAssignable(type, this.collectionType)) {
			return null;
		}
		return getCollectionElementType(type);
	}
	private TypeMirror getCollectionElementType(TypeMirror type) {
		if (((TypeElement) this.types.asElement(type)).getQualifiedName().contentEquals(Collection.class.getName())) {
			DeclaredType declaredType = (DeclaredType) type;
			// raw type, just 'Collection'
			if (declaredType.getTypeArguments().isEmpty()) {
				return this.types.getDeclaredType(this.env.getElementUtils().getTypeElement(Object.class.getName()));
			}
			// return type argument to Collection<...>
			return declaredType.getTypeArguments().get(0);
		}
		// recursively walk the supertypes, looking for Collection<...>
		for (TypeMirror superType : this.env.getTypeUtils().directSupertypes(type)) {
			if (this.types.isAssignable(superType, this.collectionType)) {
				return getCollectionElementType(superType);
			}
		}
		return null;
	}
	boolean isCollectionOrMap(TypeMirror type) {
		return this.env.getTypeUtils().isAssignable(type, this.collectionType)
				|| this.env.getTypeUtils().isAssignable(type, this.mapType);
	}
	String getJavaDoc(Element element) {
		if (element instanceof RecordComponentElement) {
			return getJavaDoc((RecordComponentElement) element);
		}
		String javadoc = (element != null) ? this.env.getElementUtils().getDocComment(element) : null;
		javadoc = (javadoc != null) ? cleanUpJavaDoc(javadoc) : null;
		return (javadoc == null || javadoc.isEmpty()) ? null : javadoc;
	}
	/**
	 * Return the {@link PrimitiveType} of the specified type or {@code null} if the type
	 * does not represent a valid wrapper type.
	 * @param typeMirror a type
	 * @return the primitive type or {@code null} if the type is not a wrapper type
	 */
	PrimitiveType getPrimitiveType(TypeMirror typeMirror) {
		if (getPrimitiveFor(typeMirror) != null) {
			return this.types.unboxedType(typeMirror);
		}
		return null;
	}
	TypeMirror getWrapperOrPrimitiveFor(TypeMirror typeMirror) {
		Class<?> candidate = getWrapperFor(typeMirror);
		if (candidate != null) {
			return this.env.getElementUtils().getTypeElement(candidate.getName()).asType();
		}
		TypeKind primitiveKind = getPrimitiveFor(typeMirror);
		if (primitiveKind != null) {
			return this.env.getTypeUtils().getPrimitiveType(primitiveKind);
		}
		return null;
	}
	private Class<?> getWrapperFor(TypeMirror type) {
		return PRIMITIVE_WRAPPERS.get(type.getKind());
	}
	private TypeKind getPrimitiveFor(TypeMirror type) {
		return WRAPPER_TO_PRIMITIVE.get(type.toString());
	}
	TypeDescriptor resolveTypeDescriptor(TypeElement element) {
		if (this.typeDescriptors.containsKey(element)) {
			return this.typeDescriptors.get(element);
		}
		return createTypeDescriptor(element);
	}
	private TypeDescriptor createTypeDescriptor(TypeElement element) {
		TypeDescriptor descriptor = new TypeDescriptor();
		process(descriptor, element.asType());
		this.typeDescriptors.put(element, descriptor);
		return descriptor;
	}
	private void process(TypeDescriptor descriptor, TypeMirror type) {
		if (type.getKind() == TypeKind.DECLARED) {
			DeclaredType declaredType = (DeclaredType) type;
			DeclaredType freshType = (DeclaredType) this.env.getElementUtils()
				.getTypeElement(this.types.asElement(type).toString())
				.asType();
			List<? extends TypeMirror> arguments = declaredType.getTypeArguments();
			for (int i = 0; i < arguments.size(); i++) {
				TypeMirror specificType = arguments.get(i);
				TypeMirror signatureType = freshType.getTypeArguments().get(i);
				descriptor.registerIfNecessary(signatureType, specificType);
			}
			TypeElement element = (TypeElement) this.types.asElement(type);
			process(descriptor, element.getSuperclass());
		}
	}
	private String getJavaDoc(RecordComponentElement recordComponent) {
		String recordJavadoc = this.env.getElementUtils().getDocComment(recordComponent.getEnclosingElement());
		if (recordJavadoc != null) {
			Pattern paramJavadocPattern = paramJavadocPattern(recordComponent.getSimpleName().toString());
			Matcher paramJavadocMatcher = paramJavadocPattern.matcher(recordJavadoc);
			if (paramJavadocMatcher.find()) {
				String paramJavadoc = cleanUpJavaDoc(paramJavadocMatcher.group());
				return paramJavadoc.isEmpty() ? null : paramJavadoc;
			}
		}
		return null;
	}
	private Pattern paramJavadocPattern(String paramName) {
		String pattern = String.format('(?<=@param +%s).*?(?=([\r\n]+ *@)|$)', paramName);
		return Pattern.compile(pattern, Pattern.DOTALL);
	}
	private String cleanUpJavaDoc(String javadoc) {
		StringBuilder result = new StringBuilder(javadoc.length());
		char lastChar = ".";
		for (int i = 0; i < javadoc.length(); i++) {
			char ch = javadoc.charAt(i);
			boolean repeatedSpace = ch == " " && lastChar == " ";
			if (ch != "\r" && ch != "\n" && !repeatedSpace) {
				result.append(ch);
				lastChar = ch;
			}
		}
		return result.toString().trim();
	}
	/**
	 * A visitor that extracts the fully qualified name of a type, including generic
	 * information.
	 */
	private static class TypeExtractor extends SimpleTypeVisitor8<String, TypeDescriptor> {
		private final Types types;
		TypeExtractor(Types types) {
			this.types = types;
		}
		@Override
		public String visitDeclared(DeclaredType type, TypeDescriptor descriptor) {
			TypeElement enclosingElement = getEnclosingTypeElement(type);
			String qualifiedName = determineQualifiedName(type, enclosingElement);
			if (type.getTypeArguments().isEmpty()) {
				return qualifiedName;
			}
			StringBuilder name = new StringBuilder();
			name.append(qualifiedName);
			name.append('<')
				.append(type.getTypeArguments()
					.stream()
					.map((t) -> visit(t, descriptor))
					.collect(Collectors.joining(',')))
				.append('>');
			return name.toString();
		}
		private String determineQualifiedName(DeclaredType type, TypeElement enclosingElement) {
			if (enclosingElement != null) {
				return getQualifiedName(enclosingElement) + '$' + type.asElement().getSimpleName();
			}
			return getQualifiedName(type.asElement());
		}
		@Override
		public String visitTypeVariable(TypeVariable t, TypeDescriptor descriptor) {
			TypeMirror typeMirror = descriptor.resolveGeneric(t);
			if (typeMirror != null) {
				if (typeMirror instanceof TypeVariable typeVariable) {
					// Still unresolved, let"s use the upper bound, checking first if
					// a cycle may exist
					if (!hasCycle(typeVariable)) {
						return visit(typeVariable.getUpperBound(), descriptor);
					}
				}
				else {
					return visit(typeMirror, descriptor);
				}
			}
			// Fallback to simple representation of the upper bound
			return defaultAction(t.getUpperBound(), descriptor);
		}
		private boolean hasCycle(TypeVariable variable) {
			TypeMirror upperBound = variable.getUpperBound();
			if (upperBound instanceof DeclaredType declaredType) {
				return declaredType.getTypeArguments().stream().anyMatch((candidate) -> candidate.equals(variable));
			}
			return false;
		}
		@Override
		public String visitArray(ArrayType t, TypeDescriptor descriptor) {
			return t.getComponentType().accept(this, descriptor) + '[]';
		}
		@Override
		public String visitPrimitive(PrimitiveType t, TypeDescriptor descriptor) {
			return this.types.boxedClass(t).getQualifiedName().toString();
		}
		@Override
		protected String defaultAction(TypeMirror t, TypeDescriptor descriptor) {
			return t.toString();
		}
		String getQualifiedName(Element element) {
			if (element == null) {
				return null;
			}
			TypeElement enclosingElement = getEnclosingTypeElement(element.asType());
			if (enclosingElement != null) {
				return getQualifiedName(enclosingElement) + '$'
						+ ((DeclaredType) element.asType()).asElement().getSimpleName();
			}
			if (element instanceof TypeElement typeElement) {
				return typeElement.getQualifiedName().toString();
			}
			throw new IllegalStateException('Could not extract qualified name from ' + element);
		}
		private TypeElement getEnclosingTypeElement(TypeMirror type) {
			if (type instanceof DeclaredType declaredType) {
				Element enclosingElement = declaredType.asElement().getEnclosingElement();
				if (enclosingElement instanceof TypeElement typeElement) {
					return typeElement;
				}
			}
			return null;
		}
	}
	/**
	 * Descriptor for a given type.
	 */
	static class TypeDescriptor {
		private final Map<TypeVariable, TypeMirror> generics = new HashMap<>();
		Map<TypeVariable, TypeMirror> getGenerics() {
			return Collections.unmodifiableMap(this.generics);
		}
		TypeMirror resolveGeneric(TypeVariable typeVariable) {
			return resolveGeneric(getParameterName(typeVariable));
		}
		TypeMirror resolveGeneric(String parameterName) {
			return this.generics.entrySet()
				.stream()
				.filter((e) -> getParameterName(e.getKey()).equals(parameterName))
				.findFirst()
				.map(Entry::getValue)
				.orElse(null);
		}
		private void registerIfNecessary(TypeMirror variable, TypeMirror resolution) {
			if (variable instanceof TypeVariable typeVariable) {
				if (this.generics.keySet()
					.stream()
					.noneMatch((candidate) -> getParameterName(candidate).equals(getParameterName(typeVariable)))) {
					this.generics.put(typeVariable, resolution);
				}
			}
		}
		private String getParameterName(TypeVariable typeVariable) {
			return typeVariable.asElement().getSimpleName().toString();
		}
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class JavaBeanPropertyDescriptor extends PropertyDescriptor {
	private final ExecutableElement setter;
	private final VariableElement field;
	private final ExecutableElement factoryMethod;
	JavaBeanPropertyDescriptor(String name, TypeMirror type, TypeElement declaringElement, ExecutableElement getter,
			ExecutableElement setter, VariableElement field, ExecutableElement factoryMethod) {
		super(name, type, declaringElement, getter);
		this.setter = setter;
		this.field = field;
		this.factoryMethod = factoryMethod;
	}
	ExecutableElement getSetter() {
		return this.setter;
	}
	@Override
	protected boolean isMarkedAsNested(MetadataGenerationEnvironment environment) {
		return environment.getNestedConfigurationPropertyAnnotation(this.field) != null
				|| environment.getNestedConfigurationPropertyAnnotation(getGetter()) != null;
	}
	@Override
	protected String resolveDescription(MetadataGenerationEnvironment environment) {
		return environment.getTypeUtils().getJavaDoc(this.field);
	}
	@Override
	protected Object resolveDefaultValue(MetadataGenerationEnvironment environment) {
		return environment.getFieldDefaultValue(getDeclaringElement(), getName());
	}
	@Override
	protected List<Element> getDeprecatableElements() {
		return Arrays.asList(getGetter(), this.setter, this.field, this.factoryMethod);
	}
	@Override
	public boolean isProperty(MetadataGenerationEnvironment env) {
		boolean isCollection = env.getTypeUtils().isCollectionOrMap(getType());
		boolean hasGetter = getGetter() != null;
		boolean hasSetter = getSetter() != null;
		return !env.isExcluded(getType()) && hasGetter && (hasSetter || isCollection);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class RecordParameterPropertyDescriptor extends ParameterPropertyDescriptor {
	private final RecordComponentElement recordComponent;
	RecordParameterPropertyDescriptor(String name, TypeMirror type, VariableElement parameter,
			TypeElement declaringElement, ExecutableElement getter, RecordComponentElement recordComponent) {
		super(name, type, parameter, declaringElement, getter);
		this.recordComponent = recordComponent;
	}
	@Override
	protected List<Element> getDeprecatableElements() {
		return Arrays.asList(getGetter());
	}
	@Override
	protected boolean isMarkedAsNested(MetadataGenerationEnvironment environment) {
		return environment.getNestedConfigurationPropertyAnnotation(this.recordComponent) != null;
	}
	@Override
	protected String resolveDescription(MetadataGenerationEnvironment environment) {
		return environment.getTypeUtils().getJavaDoc(this.recordComponent);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class MetadataGenerationEnvironment {
	private static final String NULLABLE_ANNOTATION = 'org.springframework.lang.Nullable';
	private static final Set<String> TYPE_EXCLUDES = Set.of('com.zaxxer.hikari.IConnectionCustomizer',
			'groovy.lang.MetaClass', 'groovy.text.markup.MarkupTemplateEngine', 'java.io.Writer', 'java.io.PrintWriter',
			'java.lang.ClassLoader', 'java.util.concurrent.ThreadFactory', 'jakarta.jms.XAConnectionFactory',
			'javax.sql.DataSource', 'javax.sql.XADataSource', 'org.apache.tomcat.jdbc.pool.PoolConfiguration',
			'org.apache.tomcat.jdbc.pool.Validator', 'org.flywaydb.core.api.callback.FlywayCallback',
			'org.flywaydb.core.api.resolver.MigrationResolver');
	private static final Set<String> DEPRECATION_EXCLUDES = Set.of(
			'org.apache.commons.dbcp2.BasicDataSource#getPassword',
			'org.apache.commons.dbcp2.BasicDataSource#getUsername');
	private final TypeUtils typeUtils;
	private final Elements elements;
	private final Messager messager;
	private final FieldValuesParser fieldValuesParser;
	private final Map<TypeElement, Map<String, Object>> defaultValues = new HashMap<>();
	private final String configurationPropertiesAnnotation;
	private final String nestedConfigurationPropertyAnnotation;
	private final String deprecatedConfigurationPropertyAnnotation;
	private final String constructorBindingAnnotation;
	private final String defaultValueAnnotation;
	private final Set<String> endpointAnnotations;
	private final String readOperationAnnotation;
	private final String nameAnnotation;
	private final String autowiredAnnotation;
	MetadataGenerationEnvironment(ProcessingEnvironment environment, String configurationPropertiesAnnotation,
			String nestedConfigurationPropertyAnnotation, String deprecatedConfigurationPropertyAnnotation,
			String constructorBindingAnnotation, String autowiredAnnotation, String defaultValueAnnotation,
			Set<String> endpointAnnotations, String readOperationAnnotation, String nameAnnotation) {
		this.typeUtils = new TypeUtils(environment);
		this.elements = environment.getElementUtils();
		this.messager = environment.getMessager();
		this.fieldValuesParser = resolveFieldValuesParser(environment);
		this.configurationPropertiesAnnotation = configurationPropertiesAnnotation;
		this.nestedConfigurationPropertyAnnotation = nestedConfigurationPropertyAnnotation;
		this.deprecatedConfigurationPropertyAnnotation = deprecatedConfigurationPropertyAnnotation;
		this.constructorBindingAnnotation = constructorBindingAnnotation;
		this.autowiredAnnotation = autowiredAnnotation;
		this.defaultValueAnnotation = defaultValueAnnotation;
		this.endpointAnnotations = endpointAnnotations;
		this.readOperationAnnotation = readOperationAnnotation;
		this.nameAnnotation = nameAnnotation;
	}
	private static FieldValuesParser resolveFieldValuesParser(ProcessingEnvironment env) {
		try {
			return new JavaCompilerFieldValuesParser(env);
		}
		catch (Throwable ex) {
			return FieldValuesParser.NONE;
		}
	}
	TypeUtils getTypeUtils() {
		return this.typeUtils;
	}
	Messager getMessager() {
		return this.messager;
	}
	/**
	 * Return the default value of the field with the specified {@code name}.
	 * @param type the type to consider
	 * @param name the name of the field
	 * @return the default value or {@code null} if the field does not exist or no default
	 * value has been detected
	 */
	Object getFieldDefaultValue(TypeElement type, String name) {
		return this.defaultValues.computeIfAbsent(type, this::resolveFieldValues).get(name);
	}
	boolean isExcluded(TypeMirror type) {
		if (type == null) {
			return false;
		}
		String typeName = type.toString();
		if (typeName.endsWith('[]')) {
			typeName = typeName.substring(0, typeName.length() - 2);
		}
		return TYPE_EXCLUDES.contains(typeName);
	}
	boolean isDeprecated(Element element) {
		if (element == null) {
			return false;
		}
		String elementName = element.getEnclosingElement() + '#' + element.getSimpleName();
		if (DEPRECATION_EXCLUDES.contains(elementName)) {
			return false;
		}
		if (isElementDeprecated(element)) {
			return true;
		}
		if (element instanceof VariableElement || element instanceof ExecutableElement) {
			return isElementDeprecated(element.getEnclosingElement());
		}
		return false;
	}
	ItemDeprecation resolveItemDeprecation(Element element) {
		AnnotationMirror annotation = getAnnotation(element, this.deprecatedConfigurationPropertyAnnotation);
		String reason = null;
		String replacement = null;
		String since = null;
		if (annotation != null) {
			reason = getAnnotationElementStringValue(annotation, 'reason');
			replacement = getAnnotationElementStringValue(annotation, 'replacement');
			since = getAnnotationElementStringValue(annotation, 'since');
		}
		return new ItemDeprecation(reason, replacement, since);
	}
	boolean hasConstructorBindingAnnotation(ExecutableElement element) {
		return hasAnnotation(element, this.constructorBindingAnnotation, true);
	}
	boolean hasAutowiredAnnotation(ExecutableElement element) {
		return hasAnnotation(element, this.autowiredAnnotation);
	}
	boolean hasAnnotation(Element element, String type) {
		return hasAnnotation(element, type, false);
	}
	boolean hasAnnotation(Element element, String type, boolean considerMetaAnnotations) {
		if (element != null) {
			for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
				if (type.equals(annotation.getAnnotationType().toString())) {
					return true;
				}
			}
			if (considerMetaAnnotations) {
				Set<Element> seen = new HashSet<>();
				for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
					if (hasMetaAnnotation(annotation.getAnnotationType().asElement(), type, seen)) {
						return true;
					}
				}
			}
		}
		return false;
	}
	private boolean hasMetaAnnotation(Element annotationElement, String type, Set<Element> seen) {
		if (seen.add(annotationElement)) {
			for (AnnotationMirror annotation : annotationElement.getAnnotationMirrors()) {
				DeclaredType annotationType = annotation.getAnnotationType();
				if (type.equals(annotationType.toString())
						|| hasMetaAnnotation(annotationType.asElement(), type, seen)) {
					return true;
				}
			}
		}
		return false;
	}
	AnnotationMirror getAnnotation(Element element, String type) {
		if (element != null) {
			for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
				if (type.equals(annotation.getAnnotationType().toString())) {
					return annotation;
				}
			}
		}
		return null;
	}
	/**
	 * Collect the annotations that are annotated or meta-annotated with the specified
	 * {@link TypeElement annotation}.
	 * @param element the element to inspect
	 * @param annotationType the annotation to discover
	 * @return the annotations that are annotated or meta-annotated with this annotation
	 */
	List<Element> getElementsAnnotatedOrMetaAnnotatedWith(Element element, TypeElement annotationType) {
		LinkedList<Element> stack = new LinkedList<>();
		stack.push(element);
		collectElementsAnnotatedOrMetaAnnotatedWith(annotationType, stack);
		stack.removeFirst();
		return Collections.unmodifiableList(stack);
	}
	private boolean collectElementsAnnotatedOrMetaAnnotatedWith(TypeElement annotationType, LinkedList<Element> stack) {
		Element element = stack.peekLast();
		for (AnnotationMirror annotation : this.elements.getAllAnnotationMirrors(element)) {
			Element annotationElement = annotation.getAnnotationType().asElement();
			if (!stack.contains(annotationElement)) {
				stack.addLast(annotationElement);
				if (annotationElement.equals(annotationType)) {
					return true;
				}
				if (!collectElementsAnnotatedOrMetaAnnotatedWith(annotationType, stack)) {
					stack.removeLast();
				}
			}
		}
		return false;
	}
	Map<String, Object> getAnnotationElementValues(AnnotationMirror annotation) {
		Map<String, Object> values = new LinkedHashMap<>();
		annotation.getElementValues()
			.forEach((name, value) -> values.put(name.getSimpleName().toString(), getAnnotationValue(value)));
		return values;
	}
	String getAnnotationElementStringValue(AnnotationMirror annotation, String name) {
		return annotation.getElementValues()
			.entrySet()
			.stream()
			.filter((element) -> element.getKey().getSimpleName().toString().equals(name))
			.map((element) -> asString(getAnnotationValue(element.getValue())))
			.findFirst()
			.orElse(null);
	}
	private Object getAnnotationValue(AnnotationValue annotationValue) {
		Object value = annotationValue.getValue();
		if (value instanceof List) {
			List<Object> values = new ArrayList<>();
			((List<?>) value).forEach((v) -> values.add(((AnnotationValue) v).getValue()));
			return values;
		}
		return value;
	}
	private String asString(Object value) {
		return (value == null || value.toString().isEmpty()) ? null : (String) value;
	}
	TypeElement getConfigurationPropertiesAnnotationElement() {
		return this.elements.getTypeElement(this.configurationPropertiesAnnotation);
	}
	AnnotationMirror getConfigurationPropertiesAnnotation(Element element) {
		return getAnnotation(element, this.configurationPropertiesAnnotation);
	}
	AnnotationMirror getNestedConfigurationPropertyAnnotation(Element element) {
		return getAnnotation(element, this.nestedConfigurationPropertyAnnotation);
	}
	AnnotationMirror getDefaultValueAnnotation(Element element) {
		return getAnnotation(element, this.defaultValueAnnotation);
	}
	Set<TypeElement> getEndpointAnnotationElements() {
		return this.endpointAnnotations.stream()
			.map(this.elements::getTypeElement)
			.filter(Objects::nonNull)
			.collect(Collectors.toSet());
	}
	AnnotationMirror getReadOperationAnnotation(Element element) {
		return getAnnotation(element, this.readOperationAnnotation);
	}
	AnnotationMirror getNameAnnotation(Element element) {
		return getAnnotation(element, this.nameAnnotation);
	}
	boolean hasNullableAnnotation(Element element) {
		return getAnnotation(element, NULLABLE_ANNOTATION) != null;
	}
	private boolean isElementDeprecated(Element element) {
		return hasAnnotation(element, 'java.lang.Deprecated')
				|| hasAnnotation(element, this.deprecatedConfigurationPropertyAnnotation);
	}
	private Map<String, Object> resolveFieldValues(TypeElement element) {
		Map<String, Object> values = new LinkedHashMap<>();
		resolveFieldValuesFor(values, element);
		return values;
	}
	private void resolveFieldValuesFor(Map<String, Object> values, TypeElement element) {
		try {
			this.fieldValuesParser.getFieldValues(element).forEach((name, value) -> {
				if (!values.containsKey(name)) {
					values.put(name, value);
				}
			});
		}
		catch (Exception ex) {
			// continue
		}
		Element superType = this.typeUtils.asElement(element.getSuperclass());
		if (superType instanceof TypeElement && superType.asType().getKind() != TypeKind.NONE) {
			resolveFieldValuesFor(values, (TypeElement) superType);
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.support;
/**
public abstract class ConventionUtils {
	private static final Set<Character> SEPARATORS;
	static {
		List<Character> chars = Arrays.asList("-", "_");
		SEPARATORS = Collections.unmodifiableSet(new HashSet<>(chars));
	}
	/**
	 * Return the idiomatic metadata format for the given {@code value}.
	 * @param value a value
	 * @return the idiomatic format for the value, or the value itself if it already
	 * complies with the idiomatic metadata format.
	 */
	public static String toDashedCase(String value) {
		StringBuilder dashed = new StringBuilder();
		Character previous = null;
		for (int i = 0; i < value.length(); i++) {
			char current = value.charAt(i);
			if (SEPARATORS.contains(current)) {
				dashed.append('-');
			}
			else if (Character.isUpperCase(current) && previous != null && !SEPARATORS.contains(previous)) {
				dashed.append('-').append(current);
			}
			else {
				dashed.append(current);
			}
			previous = current;
		}
		return dashed.toString().toLowerCase(Locale.ENGLISH);
	}
}
/*
/**
package org.springframework.boot.configurationprocessor.support;
/*
package org.springframework.boot.configurationprocessor;
/**
abstract class ParameterPropertyDescriptor extends PropertyDescriptor {
	private final VariableElement parameter;
	ParameterPropertyDescriptor(String name, TypeMirror type, VariableElement parameter, TypeElement declaringElement,
			ExecutableElement getter) {
		super(name, type, declaringElement, getter);
		this.parameter = parameter;
	}
	final VariableElement getParameter() {
		return this.parameter;
	}
	@Override
	protected Object resolveDefaultValue(MetadataGenerationEnvironment environment) {
		Object defaultValue = getDefaultValueFromAnnotation(environment, getParameter());
		return (defaultValue != null) ? defaultValue
				: getParameter().asType().accept(DefaultPrimitiveTypeVisitor.INSTANCE, null);
	}
	private Object getDefaultValueFromAnnotation(MetadataGenerationEnvironment environment, Element element) {
		AnnotationMirror annotation = environment.getDefaultValueAnnotation(element);
		List<String> defaultValue = getDefaultValue(environment, annotation);
		if (defaultValue != null) {
			TypeMirror specificType = determineSpecificType(environment);
			try {
				List<Object> coerced = defaultValue.stream().map((value) -> coerceValue(specificType, value)).toList();
				return (coerced.size() != 1) ? coerced : coerced.get(0);
			}
			catch (IllegalArgumentException ex) {
				environment.getMessager().printMessage(Kind.ERROR, ex.getMessage(), element, annotation);
			}
		}
		return null;
	}
	@SuppressWarnings('unchecked')
	private List<String> getDefaultValue(MetadataGenerationEnvironment environment, AnnotationMirror annotation) {
		if (annotation == null) {
			return null;
		}
		Map<String, Object> values = environment.getAnnotationElementValues(annotation);
		return (List<String>) values.get('value');
	}
	private TypeMirror determineSpecificType(MetadataGenerationEnvironment environment) {
		TypeMirror parameterType = getParameter().asType();
		TypeMirror elementType = environment.getTypeUtils().extractElementType(parameterType);
		parameterType = (elementType != null) ? elementType : parameterType;
		PrimitiveType primitiveType = environment.getTypeUtils().getPrimitiveType(parameterType);
		return (primitiveType != null) ? primitiveType : parameterType;
	}
	private Object coerceValue(TypeMirror type, String value) {
		Object coercedValue = type.accept(DefaultValueCoercionTypeVisitor.INSTANCE, value);
		return (coercedValue != null) ? coercedValue : value;
	}
	@Override
	public boolean isProperty(MetadataGenerationEnvironment env) {
		return !isNested(env); // We must be able to bind it to build the object.
	}
	/**
	 * Visitor that gets the default value for primitives.
	 */
	private static final class DefaultPrimitiveTypeVisitor extends TypeKindVisitor8<Object, Void> {
		static final DefaultPrimitiveTypeVisitor INSTANCE = new DefaultPrimitiveTypeVisitor();
		@Override
		public Object visitPrimitiveAsBoolean(PrimitiveType type, Void parameter) {
			return false;
		}
		@Override
		public Object visitPrimitiveAsByte(PrimitiveType type, Void parameter) {
			return (byte) 0;
		}
		@Override
		public Object visitPrimitiveAsShort(PrimitiveType type, Void parameter) {
			return (short) 0;
		}
		@Override
		public Object visitPrimitiveAsInt(PrimitiveType type, Void parameter) {
			return 0;
		}
		@Override
		public Object visitPrimitiveAsLong(PrimitiveType type, Void parameter) {
			return 0L;
		}
		@Override
		public Object visitPrimitiveAsChar(PrimitiveType type, Void parameter) {
			return null;
		}
		@Override
		public Object visitPrimitiveAsFloat(PrimitiveType type, Void parameter) {
			return 0F;
		}
		@Override
		public Object visitPrimitiveAsDouble(PrimitiveType type, Void parameter) {
			return 0D;
		}
	}
	/**
	 * Visitor that gets the default using coercion.
	 */
	private static final class DefaultValueCoercionTypeVisitor extends TypeKindVisitor8<Object, String> {
		static final DefaultValueCoercionTypeVisitor INSTANCE = new DefaultValueCoercionTypeVisitor();
		private <T extends Number> T parseNumber(String value, Function<String, T> parser,
				PrimitiveType primitiveType) {
			try {
				return parser.apply(value);
			}
			catch (NumberFormatException ex) {
				throw new IllegalArgumentException(
						String.format('Invalid %s representation "%s"', primitiveType, value));
			}
		}
		@Override
		public Object visitPrimitiveAsBoolean(PrimitiveType type, String value) {
			return Boolean.parseBoolean(value);
		}
		@Override
		public Object visitPrimitiveAsByte(PrimitiveType type, String value) {
			return parseNumber(value, Byte::parseByte, type);
		}
		@Override
		public Object visitPrimitiveAsShort(PrimitiveType type, String value) {
			return parseNumber(value, Short::parseShort, type);
		}
		@Override
		public Object visitPrimitiveAsInt(PrimitiveType type, String value) {
			return parseNumber(value, Integer::parseInt, type);
		}
		@Override
		public Object visitPrimitiveAsLong(PrimitiveType type, String value) {
			return parseNumber(value, Long::parseLong, type);
		}
		@Override
		public Object visitPrimitiveAsChar(PrimitiveType type, String value) {
			if (value.length() > 1) {
				throw new IllegalArgumentException(String.format('Invalid character representation "%s"', value));
			}
			return value;
		}
		@Override
		public Object visitPrimitiveAsFloat(PrimitiveType type, String value) {
			return parseNumber(value, Float::parseFloat, type);
		}
		@Override
		public Object visitPrimitiveAsDouble(PrimitiveType type, String value) {
			return parseNumber(value, Double::parseDouble, type);
		}
	}
}
/*
/**
package org.springframework.boot.configurationprocessor;
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
@SuppressWarnings('serial')
public class InvalidConfigurationMetadataException extends RuntimeException {
	private final Diagnostic.Kind kind;
	public InvalidConfigurationMetadataException(String message, Diagnostic.Kind kind) {
		super(message);
		this.kind = kind;
	}
	public Diagnostic.Kind getKind() {
		return this.kind;
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
public class JsonMarshaller {
	public void write(ConfigurationMetadata metadata, OutputStream outputStream) throws IOException {
		try {
			JSONObject object = new JSONObject();
			JsonConverter converter = new JsonConverter();
			object.put('groups', converter.toJsonArray(metadata, ItemType.GROUP));
			object.put('properties', converter.toJsonArray(metadata, ItemType.PROPERTY));
			object.put('hints', converter.toJsonArray(metadata.getHints()));
			outputStream.write(object.toString(2).getBytes(StandardCharsets.UTF_8));
		}
		catch (Exception ex) {
			if (ex instanceof IOException ioException) {
				throw ioException;
			}
			if (ex instanceof RuntimeException runtimeException) {
				throw runtimeException;
			}
			throw new IllegalStateException(ex);
		}
	}
	public ConfigurationMetadata read(InputStream inputStream) throws Exception {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		JSONObject object = new JSONObject(toString(inputStream));
		JsonPath path = JsonPath.root();
		checkAllowedKeys(object, path, 'groups', 'properties', 'hints');
		JSONArray groups = object.optJSONArray('groups');
		if (groups != null) {
			for (int i = 0; i < groups.length(); i++) {
				metadata
					.add(toItemMetadata((JSONObject) groups.get(i), path.resolve('groups').index(i), ItemType.GROUP));
			}
		}
		JSONArray properties = object.optJSONArray('properties');
		if (properties != null) {
			for (int i = 0; i < properties.length(); i++) {
				metadata.add(toItemMetadata((JSONObject) properties.get(i), path.resolve('properties').index(i),
						ItemType.PROPERTY));
			}
		}
		JSONArray hints = object.optJSONArray('hints');
		if (hints != null) {
			for (int i = 0; i < hints.length(); i++) {
				metadata.add(toItemHint((JSONObject) hints.get(i), path.resolve('hints').index(i)));
			}
		}
		return metadata;
	}
	private ItemMetadata toItemMetadata(JSONObject object, JsonPath path, ItemType itemType) throws Exception {
		switch (itemType) {
			case GROUP -> checkAllowedKeys(object, path, 'name', 'type', 'description', 'sourceType', 'sourceMethod');
			case PROPERTY -> checkAllowedKeys(object, path, 'name', 'type', 'description', 'sourceType', 'defaultValue',
					'deprecation', 'deprecated');
		}
		String name = object.getString('name');
		String type = object.optString('type', null);
		String description = object.optString('description', null);
		String sourceType = object.optString('sourceType', null);
		String sourceMethod = object.optString('sourceMethod', null);
		Object defaultValue = readItemValue(object.opt('defaultValue'));
		ItemDeprecation deprecation = toItemDeprecation(object, path);
		return new ItemMetadata(itemType, name, null, type, sourceType, sourceMethod, description, defaultValue,
				deprecation);
	}
	private ItemDeprecation toItemDeprecation(JSONObject object, JsonPath path) throws Exception {
		if (object.has('deprecation')) {
			JSONObject deprecationJsonObject = object.getJSONObject('deprecation');
			checkAllowedKeys(deprecationJsonObject, path.resolve('deprecation'), 'level', 'reason', 'replacement',
					'since');
			ItemDeprecation deprecation = new ItemDeprecation();
			deprecation.setLevel(deprecationJsonObject.optString('level', null));
			deprecation.setReason(deprecationJsonObject.optString('reason', null));
			deprecation.setReplacement(deprecationJsonObject.optString('replacement', null));
			deprecation.setSince(deprecationJsonObject.optString('since', null));
			return deprecation;
		}
		return object.optBoolean('deprecated') ? new ItemDeprecation() : null;
	}
	private ItemHint toItemHint(JSONObject object, JsonPath path) throws Exception {
		checkAllowedKeys(object, path, 'name', 'values', 'providers');
		String name = object.getString('name');
		List<ItemHint.ValueHint> values = new ArrayList<>();
		if (object.has('values')) {
			JSONArray valuesArray = object.getJSONArray('values');
			for (int i = 0; i < valuesArray.length(); i++) {
				values.add(toValueHint((JSONObject) valuesArray.get(i), path.resolve('values').index(i)));
			}
		}
		List<ItemHint.ValueProvider> providers = new ArrayList<>();
		if (object.has('providers')) {
			JSONArray providersObject = object.getJSONArray('providers');
			for (int i = 0; i < providersObject.length(); i++) {
				providers.add(toValueProvider((JSONObject) providersObject.get(i), path.resolve('providers').index(i)));
			}
		}
		return new ItemHint(name, values, providers);
	}
	private ItemHint.ValueHint toValueHint(JSONObject object, JsonPath path) throws Exception {
		checkAllowedKeys(object, path, 'value', 'description');
		Object value = readItemValue(object.get('value'));
		String description = object.optString('description', null);
		return new ItemHint.ValueHint(value, description);
	}
	private ItemHint.ValueProvider toValueProvider(JSONObject object, JsonPath path) throws Exception {
		checkAllowedKeys(object, path, 'name', 'parameters');
		String name = object.getString('name');
		Map<String, Object> parameters = new HashMap<>();
		if (object.has('parameters')) {
			JSONObject parametersObject = object.getJSONObject('parameters');
			for (Iterator<?> iterator = parametersObject.keys(); iterator.hasNext();) {
				String key = (String) iterator.next();
				Object value = readItemValue(parametersObject.get(key));
				parameters.put(key, value);
			}
		}
		return new ItemHint.ValueProvider(name, parameters);
	}
	private Object readItemValue(Object value) throws Exception {
		if (value instanceof JSONArray array) {
			Object[] content = new Object[array.length()];
			for (int i = 0; i < array.length(); i++) {
				content[i] = array.get(i);
			}
			return content;
		}
		return value;
	}
	private String toString(InputStream inputStream) throws IOException {
		return new String(inputStream.readAllBytes(), StandardCharsets.UTF_8);
	}
	@SuppressWarnings('unchecked')
	private void checkAllowedKeys(JSONObject object, JsonPath path, String... allowedKeys) {
		Set<String> availableKeys = new TreeSet<>();
		object.keys().forEachRemaining((key) -> availableKeys.add((String) key));
		Arrays.stream(allowedKeys).forEach(availableKeys::remove);
		if (!availableKeys.isEmpty()) {
			throw new IllegalStateException('Expected only keys %s, but found additional keys %s. Path: %s'
				.formatted(new TreeSet<>(Arrays.asList(allowedKeys)), availableKeys, path));
		}
	}
	private static final class JsonPath {
		private final String path;
		private JsonPath(String path) {
			this.path = path;
		}
		JsonPath resolve(String path) {
			if (this.path.endsWith('.')) {
				return new JsonPath(this.path + path);
			}
			return new JsonPath(this.path + '.' + path);
		}
		JsonPath index(int index) {
			return resolve('[%d]'.formatted(index));
		}
		@Override
		public String toString() {
			return this.path;
		}
		static JsonPath root() {
			return new JsonPath('.');
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
public final class ItemMetadata implements Comparable<ItemMetadata> {
	private final ItemType itemType;
	private String name;
	private String type;
	private String description;
	private String sourceType;
	private String sourceMethod;
	private Object defaultValue;
	private ItemDeprecation deprecation;
	ItemMetadata(ItemType itemType, String prefix, String name, String type, String sourceType, String sourceMethod,
			String description, Object defaultValue, ItemDeprecation deprecation) {
		this.itemType = itemType;
		this.name = buildName(prefix, name);
		this.type = type;
		this.sourceType = sourceType;
		this.sourceMethod = sourceMethod;
		this.description = description;
		this.defaultValue = defaultValue;
		this.deprecation = deprecation;
	}
	private String buildName(String prefix, String name) {
		StringBuilder fullName = new StringBuilder();
		if (prefix != null) {
			if (prefix.endsWith('.')) {
				prefix = prefix.substring(0, prefix.length() - 1);
			}
			fullName.append(prefix);
		}
		if (name != null) {
			if (!fullName.isEmpty()) {
				fullName.append(".");
			}
			fullName.append(ConventionUtils.toDashedCase(name));
		}
		return fullName.toString();
	}
	public boolean isOfItemType(ItemType itemType) {
		return this.itemType == itemType;
	}
	public boolean hasSameType(ItemMetadata metadata) {
		return this.itemType == metadata.itemType;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getType() {
		return this.type;
	}
	public void setType(String type) {
		this.type = type;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public String getSourceType() {
		return this.sourceType;
	}
	public void setSourceType(String sourceType) {
		this.sourceType = sourceType;
	}
	public String getSourceMethod() {
		return this.sourceMethod;
	}
	public void setSourceMethod(String sourceMethod) {
		this.sourceMethod = sourceMethod;
	}
	public Object getDefaultValue() {
		return this.defaultValue;
	}
	public void setDefaultValue(Object defaultValue) {
		this.defaultValue = defaultValue;
	}
	public ItemDeprecation getDeprecation() {
		return this.deprecation;
	}
	public void setDeprecation(ItemDeprecation deprecation) {
		this.deprecation = deprecation;
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		ItemMetadata other = (ItemMetadata) o;
		boolean result = true;
		result = result && nullSafeEquals(this.itemType, other.itemType);
		result = result && nullSafeEquals(this.name, other.name);
		result = result && nullSafeEquals(this.type, other.type);
		result = result && nullSafeEquals(this.description, other.description);
		result = result && nullSafeEquals(this.sourceType, other.sourceType);
		result = result && nullSafeEquals(this.sourceMethod, other.sourceMethod);
		result = result && nullSafeEquals(this.defaultValue, other.defaultValue);
		result = result && nullSafeEquals(this.deprecation, other.deprecation);
		return result;
	}
	@Override
	public int hashCode() {
		int result = nullSafeHashCode(this.itemType);
		result = 31 * result + nullSafeHashCode(this.name);
		result = 31 * result + nullSafeHashCode(this.type);
		result = 31 * result + nullSafeHashCode(this.description);
		result = 31 * result + nullSafeHashCode(this.sourceType);
		result = 31 * result + nullSafeHashCode(this.sourceMethod);
		result = 31 * result + nullSafeHashCode(this.defaultValue);
		result = 31 * result + nullSafeHashCode(this.deprecation);
		return result;
	}
	private boolean nullSafeEquals(Object o1, Object o2) {
		if (o1 == o2) {
			return true;
		}
		if (o1 == null || o2 == null) {
			return false;
		}
		return o1.equals(o2);
	}
	private int nullSafeHashCode(Object o) {
		return (o != null) ? o.hashCode() : 0;
	}
	@Override
	public String toString() {
		StringBuilder string = new StringBuilder(this.name);
		buildToStringProperty(string, 'type', this.type);
		buildToStringProperty(string, 'sourceType', this.sourceType);
		buildToStringProperty(string, 'description', this.description);
		buildToStringProperty(string, 'defaultValue', this.defaultValue);
		buildToStringProperty(string, 'deprecation', this.deprecation);
		return string.toString();
	}
	private void buildToStringProperty(StringBuilder string, String property, Object value) {
		if (value != null) {
			string.append(' ').append(property).append(':').append(value);
		}
	}
	@Override
	public int compareTo(ItemMetadata o) {
		return getName().compareTo(o.getName());
	}
	public static ItemMetadata newGroup(String name, String type, String sourceType, String sourceMethod) {
		return new ItemMetadata(ItemType.GROUP, name, null, type, sourceType, sourceMethod, null, null, null);
	}
	public static ItemMetadata newProperty(String prefix, String name, String type, String sourceType,
			String sourceMethod, String description, Object defaultValue, ItemDeprecation deprecation) {
		return new ItemMetadata(ItemType.PROPERTY, prefix, name, type, sourceType, sourceMethod, description,
				defaultValue, deprecation);
	}
	public static String newItemMetadataPrefix(String prefix, String suffix) {
		return prefix.toLowerCase(Locale.ENGLISH) + ConventionUtils.toDashedCase(suffix);
	}
	/**
	 * The item type.
	 */
	public enum ItemType {
		/**
		 * Group item type.
		 */
		GROUP,
		/**
		 * Property item type.
		 */
		PROPERTY
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
public class ConfigurationMetadata {
	private final Map<String, List<ItemMetadata>> items;
	private final Map<String, List<ItemHint>> hints;
	public ConfigurationMetadata() {
		this.items = new LinkedHashMap<>();
		this.hints = new LinkedHashMap<>();
	}
	public ConfigurationMetadata(ConfigurationMetadata metadata) {
		this.items = new LinkedHashMap<>(metadata.items);
		this.hints = new LinkedHashMap<>(metadata.hints);
	}
	/**
	 * Add item meta-data.
	 * @param itemMetadata the meta-data to add
	 */
	public void add(ItemMetadata itemMetadata) {
		add(this.items, itemMetadata.getName(), itemMetadata, false);
	}
	/**
	 * Add item meta-data if it"s not already present.
	 * @param itemMetadata the meta-data to add
	 * @since 2.4.0
	 */
	public void addIfMissing(ItemMetadata itemMetadata) {
		add(this.items, itemMetadata.getName(), itemMetadata, true);
	}
	/**
	 * Add item hint.
	 * @param itemHint the item hint to add
	 */
	public void add(ItemHint itemHint) {
		add(this.hints, itemHint.getName(), itemHint, false);
	}
	/**
	 * Merge the content from another {@link ConfigurationMetadata}.
	 * @param metadata the {@link ConfigurationMetadata} instance to merge
	 */
	public void merge(ConfigurationMetadata metadata) {
		for (ItemMetadata additionalItem : metadata.getItems()) {
			mergeItemMetadata(additionalItem);
		}
		for (ItemHint itemHint : metadata.getHints()) {
			add(itemHint);
		}
	}
	/**
	 * Return item meta-data.
	 * @return the items
	 */
	public List<ItemMetadata> getItems() {
		return flattenValues(this.items);
	}
	/**
	 * Return hint meta-data.
	 * @return the hints
	 */
	public List<ItemHint> getHints() {
		return flattenValues(this.hints);
	}
	protected void mergeItemMetadata(ItemMetadata metadata) {
		ItemMetadata matching = findMatchingItemMetadata(metadata);
		if (matching != null) {
			if (metadata.getDescription() != null) {
				matching.setDescription(metadata.getDescription());
			}
			if (metadata.getDefaultValue() != null) {
				matching.setDefaultValue(metadata.getDefaultValue());
			}
			ItemDeprecation deprecation = metadata.getDeprecation();
			ItemDeprecation matchingDeprecation = matching.getDeprecation();
			if (deprecation != null) {
				if (matchingDeprecation == null) {
					matching.setDeprecation(deprecation);
				}
				else {
					if (deprecation.getReason() != null) {
						matchingDeprecation.setReason(deprecation.getReason());
					}
					if (deprecation.getReplacement() != null) {
						matchingDeprecation.setReplacement(deprecation.getReplacement());
					}
					if (deprecation.getLevel() != null) {
						matchingDeprecation.setLevel(deprecation.getLevel());
					}
					if (deprecation.getSince() != null) {
						matchingDeprecation.setSince(deprecation.getSince());
					}
				}
			}
		}
		else {
			add(this.items, metadata.getName(), metadata, false);
		}
	}
	private <K, V> void add(Map<K, List<V>> map, K key, V value, boolean ifMissing) {
		List<V> values = map.computeIfAbsent(key, (k) -> new ArrayList<>());
		if (!ifMissing || values.isEmpty()) {
			values.add(value);
		}
	}
	private ItemMetadata findMatchingItemMetadata(ItemMetadata metadata) {
		List<ItemMetadata> candidates = this.items.get(metadata.getName());
		if (candidates == null || candidates.isEmpty()) {
			return null;
		}
		candidates = new ArrayList<>(candidates);
		candidates.removeIf((itemMetadata) -> !itemMetadata.hasSameType(metadata));
		if (candidates.size() > 1 && metadata.getType() != null) {
			candidates.removeIf((itemMetadata) -> !metadata.getType().equals(itemMetadata.getType()));
		}
		if (candidates.size() == 1) {
			return candidates.get(0);
		}
		for (ItemMetadata candidate : candidates) {
			if (nullSafeEquals(candidate.getSourceType(), metadata.getSourceType())) {
				return candidate;
			}
		}
		return null;
	}
	private boolean nullSafeEquals(Object o1, Object o2) {
		if (o1 == o2) {
			return true;
		}
		return o1 != null && o1.equals(o2);
	}
	public static String nestedPrefix(String prefix, String name) {
		String nestedPrefix = (prefix != null) ? prefix : '';
		String dashedName = ConventionUtils.toDashedCase(name);
		nestedPrefix += nestedPrefix.isEmpty() ? dashedName : '.' + dashedName;
		return nestedPrefix;
	}
	private static <T extends Comparable<T>> List<T> flattenValues(Map<?, List<T>> map) {
		List<T> content = new ArrayList<>();
		for (List<T> values : map.values()) {
			content.addAll(values);
		}
		Collections.sort(content);
		return content;
	}
	@Override
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(String.format('items: %n'));
		this.items.values().forEach((itemMetadata) -> result.append('\t').append(String.format('%s%n', itemMetadata)));
		return result.toString();
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
class JsonConverter {
	private static final ItemMetadataComparator ITEM_COMPARATOR = new ItemMetadataComparator();
	JSONArray toJsonArray(ConfigurationMetadata metadata, ItemType itemType) throws Exception {
		JSONArray jsonArray = new JSONArray();
		List<ItemMetadata> items = metadata.getItems()
			.stream()
			.filter((item) -> item.isOfItemType(itemType))
			.sorted(ITEM_COMPARATOR)
			.toList();
		for (ItemMetadata item : items) {
			if (item.isOfItemType(itemType)) {
				jsonArray.put(toJsonObject(item));
			}
		}
		return jsonArray;
	}
	JSONArray toJsonArray(Collection<ItemHint> hints) throws Exception {
		JSONArray jsonArray = new JSONArray();
		for (ItemHint hint : hints) {
			jsonArray.put(toJsonObject(hint));
		}
		return jsonArray;
	}
	JSONObject toJsonObject(ItemMetadata item) throws Exception {
		JSONObject jsonObject = new JSONObject();
		jsonObject.put('name', item.getName());
		jsonObject.putOpt('type', item.getType());
		jsonObject.putOpt('description', item.getDescription());
		jsonObject.putOpt('sourceType', item.getSourceType());
		jsonObject.putOpt('sourceMethod', item.getSourceMethod());
		Object defaultValue = item.getDefaultValue();
		if (defaultValue != null) {
			putDefaultValue(jsonObject, defaultValue);
		}
		ItemDeprecation deprecation = item.getDeprecation();
		if (deprecation != null) {
			jsonObject.put('deprecated', true); // backward compatibility
			JSONObject deprecationJsonObject = new JSONObject();
			if (deprecation.getLevel() != null) {
				deprecationJsonObject.put('level', deprecation.getLevel());
			}
			if (deprecation.getReason() != null) {
				deprecationJsonObject.put('reason', deprecation.getReason());
			}
			if (deprecation.getReplacement() != null) {
				deprecationJsonObject.put('replacement', deprecation.getReplacement());
			}
			if (deprecation.getSince() != null) {
				deprecationJsonObject.put('since', deprecation.getSince());
			}
			jsonObject.put('deprecation', deprecationJsonObject);
		}
		return jsonObject;
	}
	private JSONObject toJsonObject(ItemHint hint) throws Exception {
		JSONObject jsonObject = new JSONObject();
		jsonObject.put('name', hint.getName());
		if (!hint.getValues().isEmpty()) {
			jsonObject.put('values', getItemHintValues(hint));
		}
		if (!hint.getProviders().isEmpty()) {
			jsonObject.put('providers', getItemHintProviders(hint));
		}
		return jsonObject;
	}
	private JSONArray getItemHintValues(ItemHint hint) throws Exception {
		JSONArray values = new JSONArray();
		for (ItemHint.ValueHint value : hint.getValues()) {
			values.put(getItemHintValue(value));
		}
		return values;
	}
	private JSONObject getItemHintValue(ItemHint.ValueHint value) throws Exception {
		JSONObject result = new JSONObject();
		putHintValue(result, value.getValue());
		result.putOpt('description', value.getDescription());
		return result;
	}
	private JSONArray getItemHintProviders(ItemHint hint) throws Exception {
		JSONArray providers = new JSONArray();
		for (ItemHint.ValueProvider provider : hint.getProviders()) {
			providers.put(getItemHintProvider(provider));
		}
		return providers;
	}
	private JSONObject getItemHintProvider(ItemHint.ValueProvider provider) throws Exception {
		JSONObject result = new JSONObject();
		result.put('name', provider.getName());
		if (provider.getParameters() != null && !provider.getParameters().isEmpty()) {
			JSONObject parameters = new JSONObject();
			for (Map.Entry<String, Object> entry : provider.getParameters().entrySet()) {
				parameters.put(entry.getKey(), extractItemValue(entry.getValue()));
			}
			result.put('parameters', parameters);
		}
		return result;
	}
	private void putHintValue(JSONObject jsonObject, Object value) throws Exception {
		Object hintValue = extractItemValue(value);
		jsonObject.put('value', hintValue);
	}
	private void putDefaultValue(JSONObject jsonObject, Object value) throws Exception {
		Object defaultValue = extractItemValue(value);
		jsonObject.put('defaultValue', defaultValue);
	}
	private Object extractItemValue(Object value) {
		Object defaultValue = value;
		if (value.getClass().isArray()) {
			JSONArray array = new JSONArray();
			int length = Array.getLength(value);
			for (int i = 0; i < length; i++) {
				array.put(Array.get(value, i));
			}
			defaultValue = array;
		}
		return defaultValue;
	}
	private static final class ItemMetadataComparator implements Comparator<ItemMetadata> {
		private static final Comparator<ItemMetadata> GROUP = Comparator.comparing(ItemMetadata::getName)
			.thenComparing(ItemMetadata::getSourceType, Comparator.nullsFirst(Comparator.naturalOrder()));
		private static final Comparator<ItemMetadata> ITEM = Comparator.comparing(ItemMetadataComparator::isDeprecated)
			.thenComparing(ItemMetadata::getName)
			.thenComparing(ItemMetadata::getSourceType, Comparator.nullsFirst(Comparator.naturalOrder()));
		@Override
		public int compare(ItemMetadata o1, ItemMetadata o2) {
			if (o1.isOfItemType(ItemType.GROUP)) {
				return GROUP.compare(o1, o2);
			}
			return ITEM.compare(o1, o2);
		}
		private static boolean isDeprecated(ItemMetadata item) {
			return item.getDeprecation() != null;
		}
	}
}
/*
/**
package org.springframework.boot.configurationprocessor.metadata;
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
public class ItemHint implements Comparable<ItemHint> {
	private final String name;
	private final List<ValueHint> values;
	private final List<ValueProvider> providers;
	public ItemHint(String name, List<ValueHint> values, List<ValueProvider> providers) {
		this.name = toCanonicalName(name);
		this.values = (values != null) ? new ArrayList<>(values) : new ArrayList<>();
		this.providers = (providers != null) ? new ArrayList<>(providers) : new ArrayList<>();
	}
	private String toCanonicalName(String name) {
		int dot = name.lastIndexOf(".");
		if (dot != -1) {
			String prefix = name.substring(0, dot);
			String originalName = name.substring(dot);
			return prefix + ConventionUtils.toDashedCase(originalName);
		}
		return ConventionUtils.toDashedCase(name);
	}
	public String getName() {
		return this.name;
	}
	public List<ValueHint> getValues() {
		return Collections.unmodifiableList(this.values);
	}
	public List<ValueProvider> getProviders() {
		return Collections.unmodifiableList(this.providers);
	}
	@Override
	public int compareTo(ItemHint other) {
		return getName().compareTo(other.getName());
	}
	public static ItemHint newHint(String name, ValueHint... values) {
		return new ItemHint(name, Arrays.asList(values), Collections.emptyList());
	}
	@Override
	public String toString() {
		return 'ItemHint{name="' + this.name + '", values=' + this.values + ', providers=' + this.providers + "}";
	}
	/**
	 * A hint for a value.
	 */
	public static class ValueHint {
		private final Object value;
		private final String description;
		public ValueHint(Object value, String description) {
			this.value = value;
			this.description = description;
		}
		public Object getValue() {
			return this.value;
		}
		public String getDescription() {
			return this.description;
		}
		@Override
		public String toString() {
			return 'ValueHint{value=' + this.value + ', description="' + this.description + "\"" + "}";
		}
	}
	/**
	 * A value provider.
	 */
	public static class ValueProvider {
		private final String name;
		private final Map<String, Object> parameters;
		public ValueProvider(String name, Map<String, Object> parameters) {
			this.name = name;
			this.parameters = parameters;
		}
		public String getName() {
			return this.name;
		}
		public Map<String, Object> getParameters() {
			return this.parameters;
		}
		@Override
		public String toString() {
			return 'ValueProvider{name="' + this.name + '", parameters=' + this.parameters + "}";
		}
	}
}
/*
package org.springframework.boot.configurationprocessor.metadata;
/**
public class ItemDeprecation {
	private String reason;
	private String replacement;
	private String since;
	private String level;
	public ItemDeprecation() {
		this(null, null, null);
	}
	public ItemDeprecation(String reason, String replacement, String since) {
		this(reason, replacement, since, null);
	}
	public ItemDeprecation(String reason, String replacement, String since, String level) {
		this.reason = reason;
		this.replacement = replacement;
		this.since = since;
		this.level = level;
	}
	public String getReason() {
		return this.reason;
	}
	public void setReason(String reason) {
		this.reason = reason;
	}
	public String getReplacement() {
		return this.replacement;
	}
	public void setReplacement(String replacement) {
		this.replacement = replacement;
	}
	public String getSince() {
		return this.since;
	}
	public void setSince(String since) {
		this.since = since;
	}
	public String getLevel() {
		return this.level;
	}
	public void setLevel(String level) {
		this.level = level;
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		ItemDeprecation other = (ItemDeprecation) o;
		return nullSafeEquals(this.reason, other.reason) && nullSafeEquals(this.replacement, other.replacement)
				&& nullSafeEquals(this.level, other.level) && nullSafeEquals(this.since, other.since);
	}
	@Override
	public int hashCode() {
		int result = nullSafeHashCode(this.reason);
		result = 31 * result + nullSafeHashCode(this.replacement);
		result = 31 * result + nullSafeHashCode(this.level);
		result = 31 * result + nullSafeHashCode(this.since);
		return result;
	}
	@Override
	public String toString() {
		return 'ItemDeprecation{reason="' + this.reason + "\"" + ', replacement="' + this.replacement + "\""
				+ ', level="' + this.level + "\"" + ', since="' + this.since + "\"" + "}";
	}
	private boolean nullSafeEquals(Object o1, Object o2) {
		if (o1 == o2) {
			return true;
		}
		if (o1 == null || o2 == null) {
			return false;
		}
		return o1.equals(o2);
	}
	private int nullSafeHashCode(Object o) {
		return (o != null) ? o.hashCode() : 0;
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
@SupportedAnnotationTypes({ ConfigurationMetadataAnnotationProcessor.CONFIGURATION_PROPERTIES_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.AUTO_CONFIGURATION_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.CONFIGURATION_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.CONTROLLER_ENDPOINT_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.ENDPOINT_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.JMX_ENDPOINT_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.REST_CONTROLLER_ENDPOINT_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.SERVLET_ENDPOINT_ANNOTATION,
		ConfigurationMetadataAnnotationProcessor.WEB_ENDPOINT_ANNOTATION })
public class ConfigurationMetadataAnnotationProcessor extends AbstractProcessor {
	static final String ADDITIONAL_METADATA_LOCATIONS_OPTION = 'org.springframework.boot.configurationprocessor.additionalMetadataLocations';
	static final String CONFIGURATION_PROPERTIES_ANNOTATION = 'org.springframework.boot.context.properties.ConfigurationProperties';
	static final String NESTED_CONFIGURATION_PROPERTY_ANNOTATION = 'org.springframework.boot.context.properties.NestedConfigurationProperty';
	static final String DEPRECATED_CONFIGURATION_PROPERTY_ANNOTATION = 'org.springframework.boot.context.properties.DeprecatedConfigurationProperty';
	static final String CONSTRUCTOR_BINDING_ANNOTATION = 'org.springframework.boot.context.properties.bind.ConstructorBinding';
	static final String AUTOWIRED_ANNOTATION = 'org.springframework.beans.factory.annotation.Autowired';
	static final String DEFAULT_VALUE_ANNOTATION = 'org.springframework.boot.context.properties.bind.DefaultValue';
	static final String AUTO_CONFIGURATION_ANNOTATION = 'org.springframework.boot.autoconfigure.AutoConfiguration';
	static final String CONFIGURATION_ANNOTATION = 'org.springframework.context.annotation.Configuration';
	static final String CONTROLLER_ENDPOINT_ANNOTATION = 'org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpoint';
	static final String ENDPOINT_ANNOTATION = 'org.springframework.boot.actuate.endpoint.annotation.Endpoint';
	static final String JMX_ENDPOINT_ANNOTATION = 'org.springframework.boot.actuate.endpoint.jmx.annotation.JmxEndpoint';
	static final String REST_CONTROLLER_ENDPOINT_ANNOTATION = 'org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint';
	static final String SERVLET_ENDPOINT_ANNOTATION = 'org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint';
	static final String WEB_ENDPOINT_ANNOTATION = 'org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint';
	static final String READ_OPERATION_ANNOTATION = 'org.springframework.boot.actuate.endpoint.annotation.ReadOperation';
	static final String NAME_ANNOTATION = 'org.springframework.boot.context.properties.bind.Name';
	static final String ENDPOINT_ACCESS_ENUM = 'org.springframework.boot.actuate.endpoint.Access';
	private static final Set<String> SUPPORTED_OPTIONS = Set.of(ADDITIONAL_METADATA_LOCATIONS_OPTION);
	private MetadataStore metadataStore;
	private MetadataCollector metadataCollector;
	private MetadataGenerationEnvironment metadataEnv;
	protected String configurationPropertiesAnnotation() {
		return CONFIGURATION_PROPERTIES_ANNOTATION;
	}
	protected String nestedConfigurationPropertyAnnotation() {
		return NESTED_CONFIGURATION_PROPERTY_ANNOTATION;
	}
	protected String deprecatedConfigurationPropertyAnnotation() {
		return DEPRECATED_CONFIGURATION_PROPERTY_ANNOTATION;
	}
	protected String constructorBindingAnnotation() {
		return CONSTRUCTOR_BINDING_ANNOTATION;
	}
	protected String autowiredAnnotation() {
		return AUTOWIRED_ANNOTATION;
	}
	protected String defaultValueAnnotation() {
		return DEFAULT_VALUE_ANNOTATION;
	}
	protected Set<String> endpointAnnotations() {
		return Set.of(CONTROLLER_ENDPOINT_ANNOTATION, ENDPOINT_ANNOTATION, JMX_ENDPOINT_ANNOTATION,
				REST_CONTROLLER_ENDPOINT_ANNOTATION, SERVLET_ENDPOINT_ANNOTATION, WEB_ENDPOINT_ANNOTATION);
	}
	protected String readOperationAnnotation() {
		return READ_OPERATION_ANNOTATION;
	}
	protected String nameAnnotation() {
		return NAME_ANNOTATION;
	}
	protected String endpointAccessEnum() {
		return ENDPOINT_ACCESS_ENUM;
	}
	@Override
	public SourceVersion getSupportedSourceVersion() {
		return SourceVersion.latestSupported();
	}
	@Override
	public Set<String> getSupportedOptions() {
		return SUPPORTED_OPTIONS;
	}
	@Override
	public synchronized void init(ProcessingEnvironment env) {
		super.init(env);
		this.metadataStore = new MetadataStore(env);
		this.metadataCollector = new MetadataCollector(env, this.metadataStore.readMetadata());
		this.metadataEnv = new MetadataGenerationEnvironment(env, configurationPropertiesAnnotation(),
				nestedConfigurationPropertyAnnotation(), deprecatedConfigurationPropertyAnnotation(),
				constructorBindingAnnotation(), autowiredAnnotation(), defaultValueAnnotation(), endpointAnnotations(),
				readOperationAnnotation(), nameAnnotation());
	}
	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		this.metadataCollector.processing(roundEnv);
		TypeElement annotationType = this.metadataEnv.getConfigurationPropertiesAnnotationElement();
		if (annotationType != null) { // Is @ConfigurationProperties available
			for (Element element : roundEnv.getElementsAnnotatedWith(annotationType)) {
				processElement(element);
			}
		}
		Set<TypeElement> endpointTypes = this.metadataEnv.getEndpointAnnotationElements();
		if (!endpointTypes.isEmpty()) { // Are endpoint annotations available
			for (TypeElement endpointType : endpointTypes) {
				getElementsAnnotatedOrMetaAnnotatedWith(roundEnv, endpointType).forEach(this::processEndpoint);
			}
		}
		if (roundEnv.processingOver()) {
			try {
				writeMetadata();
			}
			catch (Exception ex) {
				throw new IllegalStateException('Failed to write metadata', ex);
			}
		}
		return false;
	}
	private Map<Element, List<Element>> getElementsAnnotatedOrMetaAnnotatedWith(RoundEnvironment roundEnv,
			TypeElement annotation) {
		Map<Element, List<Element>> result = new LinkedHashMap<>();
		for (Element element : roundEnv.getRootElements()) {
			List<Element> annotations = this.metadataEnv.getElementsAnnotatedOrMetaAnnotatedWith(element, annotation);
			if (!annotations.isEmpty()) {
				result.put(element, annotations);
			}
		}
		return result;
	}
	private void processElement(Element element) {
		try {
			AnnotationMirror annotation = this.metadataEnv.getConfigurationPropertiesAnnotation(element);
			if (annotation != null) {
				String prefix = getPrefix(annotation);
				if (element instanceof TypeElement typeElement) {
					processAnnotatedTypeElement(prefix, typeElement, new ArrayDeque<>());
				}
				else if (element instanceof ExecutableElement executableElement) {
					processExecutableElement(prefix, executableElement, new ArrayDeque<>());
				}
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Error processing configuration meta-data on ' + element, ex);
		}
	}
	private void processAnnotatedTypeElement(String prefix, TypeElement element, Deque<TypeElement> seen) {
		String type = this.metadataEnv.getTypeUtils().getQualifiedName(element);
		this.metadataCollector.add(ItemMetadata.newGroup(prefix, type, type, null));
		processTypeElement(prefix, element, null, seen);
	}
	private void processExecutableElement(String prefix, ExecutableElement element, Deque<TypeElement> seen) {
		if ((!element.getModifiers().contains(Modifier.PRIVATE))
				&& (TypeKind.VOID != element.getReturnType().getKind())) {
			Element returns = this.processingEnv.getTypeUtils().asElement(element.getReturnType());
			if (returns instanceof TypeElement typeElement) {
				ItemMetadata group = ItemMetadata.newGroup(prefix,
						this.metadataEnv.getTypeUtils().getQualifiedName(returns),
						this.metadataEnv.getTypeUtils().getQualifiedName(element.getEnclosingElement()),
						element.toString());
				if (this.metadataCollector.hasSimilarGroup(group)) {
					this.processingEnv.getMessager()
						.printMessage(Kind.ERROR,
								'Duplicate @ConfigurationProperties definition for prefix "' + prefix + '"', element);
				}
				else {
					this.metadataCollector.add(group);
					processTypeElement(prefix, typeElement, element, seen);
				}
			}
		}
	}
	private void processTypeElement(String prefix, TypeElement element, ExecutableElement source,
			Deque<TypeElement> seen) {
		if (!seen.contains(element)) {
			seen.push(element);
			new PropertyDescriptorResolver(this.metadataEnv).resolve(element, source).forEach((descriptor) -> {
				this.metadataCollector.add(descriptor.resolveItemMetadata(prefix, this.metadataEnv));
				if (descriptor.isNested(this.metadataEnv)) {
					TypeElement nestedTypeElement = (TypeElement) this.metadataEnv.getTypeUtils()
						.asElement(descriptor.getType());
					String nestedPrefix = ConfigurationMetadata.nestedPrefix(prefix, descriptor.getName());
					processTypeElement(nestedPrefix, nestedTypeElement, source, seen);
				}
			});
			seen.pop();
		}
	}
	private void processEndpoint(Element element, List<Element> annotations) {
		try {
			String annotationName = this.metadataEnv.getTypeUtils().getQualifiedName(annotations.get(0));
			AnnotationMirror annotation = this.metadataEnv.getAnnotation(element, annotationName);
			if (element instanceof TypeElement typeElement) {
				processEndpoint(annotation, typeElement);
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Error processing configuration meta-data on ' + element, ex);
		}
	}
	private void processEndpoint(AnnotationMirror annotation, TypeElement element) {
		Map<String, Object> elementValues = this.metadataEnv.getAnnotationElementValues(annotation);
		String endpointId = (String) elementValues.get('id');
		if (endpointId == null || endpointId.isEmpty()) {
			return; // Can"t process that endpoint
		}
		String endpointKey = ItemMetadata.newItemMetadataPrefix('management.endpoint.', endpointId);
		boolean enabledByDefaultAttribute = (boolean) elementValues.getOrDefault('enableByDefault', true);
		String defaultAccess = (!enabledByDefaultAttribute) ? 'none'
				: (elementValues.getOrDefault('defaultAccess', 'unrestricted').toString()).toLowerCase(Locale.ENGLISH);
		boolean enabledByDefault = !'none'.equals(defaultAccess) && enabledByDefaultAttribute;
		String type = this.metadataEnv.getTypeUtils().getQualifiedName(element);
		this.metadataCollector.addIfAbsent(ItemMetadata.newGroup(endpointKey, type, type, null));
		ItemMetadata accessProperty = ItemMetadata.newProperty(endpointKey, 'access', endpointAccessEnum(), type, null,
				'Permitted level of access for the %s endpoint.'.formatted(endpointId), defaultAccess, null);
		this.metadataCollector.add(
				ItemMetadata.newProperty(endpointKey, 'enabled', Boolean.class.getName(), type, null,
						'Whether to enable the %s endpoint.'.formatted(endpointId), enabledByDefault,
						new ItemDeprecation(null, accessProperty.getName(), '3.4.0')),
				(existing) -> checkEnabledValueMatchesExisting(existing, enabledByDefault, type));
		this.metadataCollector.add(accessProperty,
				(existing) -> checkDefaultAccessValueMatchesExisting(existing, defaultAccess, type));
		if (hasMainReadOperation(element)) {
			this.metadataCollector.addIfAbsent(ItemMetadata.newProperty(endpointKey, 'cache.time-to-live',
					Duration.class.getName(), type, null, 'Maximum time that a response can be cached.', '0ms', null));
		}
	}
	private void checkEnabledValueMatchesExisting(ItemMetadata existing, boolean enabledByDefault, String sourceType) {
		boolean existingDefaultValue = (boolean) existing.getDefaultValue();
		if (enabledByDefault != existingDefaultValue) {
			throw new IllegalStateException(
					'Existing property "%s" from type %s has a conflicting value. Existing value: %b, new value from type %s: %b'
						.formatted(existing.getName(), existing.getSourceType(), existingDefaultValue, sourceType,
								enabledByDefault));
		}
	}
	private void checkDefaultAccessValueMatchesExisting(ItemMetadata existing, String defaultAccess,
			String sourceType) {
		String existingDefaultAccess = (String) existing.getDefaultValue();
		if (!Objects.equals(defaultAccess, existingDefaultAccess)) {
			throw new IllegalStateException(
					'Existing property "%s" from type %s has a conflicting value. Existing value: %b, new value from type %s: %b'
						.formatted(existing.getName(), existing.getSourceType(), existingDefaultAccess, sourceType,
								defaultAccess));
		}
	}
	private boolean hasMainReadOperation(TypeElement element) {
		for (ExecutableElement method : ElementFilter.methodsIn(element.getEnclosedElements())) {
			if (this.metadataEnv.getReadOperationAnnotation(method) != null
					&& (TypeKind.VOID != method.getReturnType().getKind()) && hasNoOrOptionalParameters(method)) {
				return true;
			}
		}
		return false;
	}
	private boolean hasNoOrOptionalParameters(ExecutableElement method) {
		for (VariableElement parameter : method.getParameters()) {
			if (!this.metadataEnv.hasNullableAnnotation(parameter)) {
				return false;
			}
		}
		return true;
	}
	private String getPrefix(AnnotationMirror annotation) {
		String prefix = this.metadataEnv.getAnnotationElementStringValue(annotation, 'prefix');
		if (prefix != null) {
			return prefix;
		}
		return this.metadataEnv.getAnnotationElementStringValue(annotation, 'value');
	}
	protected ConfigurationMetadata writeMetadata() throws Exception {
		ConfigurationMetadata metadata = this.metadataCollector.getMetadata();
		metadata = mergeAdditionalMetadata(metadata);
		if (!metadata.getItems().isEmpty()) {
			this.metadataStore.writeMetadata(metadata);
			return metadata;
		}
		return null;
	}
	private ConfigurationMetadata mergeAdditionalMetadata(ConfigurationMetadata metadata) {
		try {
			ConfigurationMetadata merged = new ConfigurationMetadata(metadata);
			merged.merge(this.metadataStore.readAdditionalMetadata());
			return merged;
		}
		catch (FileNotFoundException ex) {
			// No additional metadata
		}
		catch (InvalidConfigurationMetadataException ex) {
			log(ex.getKind(), ex.getMessage());
		}
		catch (Exception ex) {
			logWarning('Unable to merge additional metadata');
			logWarning(getStackTrace(ex));
		}
		return metadata;
	}
	private String getStackTrace(Exception ex) {
		StringWriter writer = new StringWriter();
		ex.printStackTrace(new PrintWriter(writer, true));
		return writer.toString();
	}
	private void logWarning(String msg) {
		log(Kind.WARNING, msg);
	}
	private void log(Kind kind, String msg) {
		this.processingEnv.getMessager().printMessage(kind, msg);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
class ConstructorParameterPropertyDescriptor extends ParameterPropertyDescriptor {
	private final ExecutableElement setter;
	private final VariableElement field;
	ConstructorParameterPropertyDescriptor(String name, TypeMirror type, VariableElement parameter,
			TypeElement declaringElement, ExecutableElement getter, ExecutableElement setter, VariableElement field) {
		super(name, type, parameter, declaringElement, getter);
		this.setter = setter;
		this.field = field;
	}
	@Override
	protected List<Element> getDeprecatableElements() {
		return Arrays.asList(getGetter(), this.setter, this.field);
	}
	@Override
	protected boolean isMarkedAsNested(MetadataGenerationEnvironment environment) {
		return environment.getNestedConfigurationPropertyAnnotation(this.field) != null;
	}
	@Override
	protected String resolveDescription(MetadataGenerationEnvironment environment) {
		return environment.getTypeUtils().getJavaDoc(this.field);
	}
}
/*
package org.springframework.boot.configurationprocessor;
/**
public class MetadataCollector {
	private final Set<ItemMetadata> metadataItems = new LinkedHashSet<>();
	private final ProcessingEnvironment processingEnvironment;
	private final ConfigurationMetadata previousMetadata;
	private final TypeUtils typeUtils;
	private final Set<String> processedSourceTypes = new HashSet<>();
	/**
	 * Creates a new {@code MetadataProcessor} instance.
	 * @param processingEnvironment the processing environment of the build
	 * @param previousMetadata any previous metadata or {@code null}
	 */
	public MetadataCollector(ProcessingEnvironment processingEnvironment, ConfigurationMetadata previousMetadata) {
		this.processingEnvironment = processingEnvironment;
		this.previousMetadata = previousMetadata;
		this.typeUtils = new TypeUtils(processingEnvironment);
	}
	public void processing(RoundEnvironment roundEnv) {
		for (Element element : roundEnv.getRootElements()) {
			markAsProcessed(element);
		}
	}
	private void markAsProcessed(Element element) {
		if (element instanceof TypeElement) {
			this.processedSourceTypes.add(this.typeUtils.getQualifiedName(element));
		}
	}
	public void add(ItemMetadata metadata) {
		this.metadataItems.add(metadata);
	}
	public void add(ItemMetadata metadata, Consumer<ItemMetadata> onConflict) {
		ItemMetadata existing = find(metadata.getName());
		if (existing != null) {
			onConflict.accept(existing);
			return;
		}
		add(metadata);
	}
	public boolean addIfAbsent(ItemMetadata metadata) {
		ItemMetadata existing = find(metadata.getName());
		if (existing != null) {
			return false;
		}
		add(metadata);
		return true;
	}
	public boolean hasSimilarGroup(ItemMetadata metadata) {
		if (!metadata.isOfItemType(ItemMetadata.ItemType.GROUP)) {
			throw new IllegalStateException('item ' + metadata + ' must be a group');
		}
		for (ItemMetadata existing : this.metadataItems) {
			if (existing.isOfItemType(ItemMetadata.ItemType.GROUP) && existing.getName().equals(metadata.getName())
					&& existing.getType().equals(metadata.getType())) {
				return true;
			}
		}
		return false;
	}
	public ConfigurationMetadata getMetadata() {
		ConfigurationMetadata metadata = new ConfigurationMetadata();
		for (ItemMetadata item : this.metadataItems) {
			metadata.add(item);
		}
		if (this.previousMetadata != null) {
			List<ItemMetadata> items = this.previousMetadata.getItems();
			for (ItemMetadata item : items) {
				if (shouldBeMerged(item)) {
					metadata.addIfMissing(item);
				}
			}
		}
		return metadata;
	}
	private ItemMetadata find(String name) {
		return this.metadataItems.stream()
			.filter((candidate) -> name.equals(candidate.getName()))
			.findFirst()
			.orElse(null);
	}
	private boolean shouldBeMerged(ItemMetadata itemMetadata) {
		String sourceType = itemMetadata.getSourceType();
		return (sourceType != null && !deletedInCurrentBuild(sourceType) && !processedInCurrentBuild(sourceType));
	}
	private boolean deletedInCurrentBuild(String sourceType) {
		return this.processingEnvironment.getElementUtils().getTypeElement(sourceType.replace("$", ".")) == null;
	}
	private boolean processedInCurrentBuild(String sourceType) {
		return this.processedSourceTypes.contains(sourceType);
	}
}
/*
package org.springframework.boot.testsupport.assertj;
/**
class SimpleAsyncTaskExecutorAssertTests {
	@Test
	void usesPlatformThreads() {
		SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor();
		executor.setVirtualThreads(false);
		SimpleAsyncTaskExecutorAssert.assertThat(executor).usesPlatformThreads();
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void usesVirtualThreads() {
		SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor();
		executor.setVirtualThreads(true);
		SimpleAsyncTaskExecutorAssert.assertThat(executor).usesVirtualThreads();
	}
}
/*
package org.springframework.boot.testsupport.web.servlet;
/**
class MockServletWebServerTests {
	@Test
	void servletContextIsConfigured() {
		MockServletWebServer server = TestMockServletWebServer.create();
		assertThat(server.getServletContext()).isNotNull();
	}
	@Test
	void servletContextHasSessionCookieConfigConfigured() {
		MockServletWebServer server = TestMockServletWebServer.create();
		assertThat(server.getServletContext().getSessionCookieConfig()).isInstanceOf(MockSessionCookieConfig.class);
	}
	private static final class TestMockServletWebServer extends MockServletWebServer {
		private TestMockServletWebServer(Initializer[] initializers, int port) {
			super(initializers, port);
		}
		static MockServletWebServer create(Initializer... initializers) {
			return new TestMockServletWebServer(initializers, 8080);
		}
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
class ModifiedClassPathExtensionOverridesParameterizedTests {
	@ParameterizedTest
	@ForkedClassPath
	@MethodSource('parameter')
	void classesAreLoadedFromParameter(Class<?> type) {
		assertThat(ApplicationContext.class.getProtectionDomain().getCodeSource().getLocation().toString())
			.endsWith('spring-context-4.1.0.RELEASE.jar');
	}
	static Class<?>[] parameter() {
		return new Class<?>[] { ClassWithOverride.class };
	}
	@ParameterizedTest
	@ForkedClassPath
	@MethodSource('arrayParameter')
	void classesAreLoadedFromParameterInArray(Object[] types) {
		assertThat(ApplicationContext.class.getProtectionDomain().getCodeSource().getLocation().toString())
			.endsWith('spring-context-4.1.0.RELEASE.jar');
	}
	static Stream<Arguments> arrayParameter() {
		Object[] types = new Object[] { ClassWithOverride.class };
		return Stream.of(Arguments.of(new Object[] { types }));
	}
	@ClassPathOverrides('org.springframework:spring-context:4.1.0.RELEASE')
	static class ClassWithOverride {
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
@ForkedClassPath
class ModifiedClassPathExtensionForkTests {
	@Test
	void modifiedClassLoaderIsUsed() {
		ClassLoader classLoader = getClass().getClassLoader();
		assertThat(classLoader.getClass().getName()).isEqualTo(ModifiedClassPathClassLoader.class.getName());
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
@ClassPathOverrides('org.springframework:spring-context:4.1.0.RELEASE')
class ModifiedClassPathExtensionOverridesTests {
	@Test
	void classesAreLoadedFromOverride() {
		assertThat(ApplicationContext.class.getProtectionDomain().getCodeSource().getLocation().toString())
			.endsWith('spring-context-4.1.0.RELEASE.jar');
	}
	@Test
	void classesAreLoadedFromTransitiveDependencyOfOverride() {
		assertThat(StringUtils.class.getProtectionDomain().getCodeSource().getLocation().toString())
			.endsWith('spring-core-4.1.0.RELEASE.jar');
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
@ForkedClassPath
class ModifiedClassPathExtensionForkParameterizedTests {
	private static final List<String> arguments = new ArrayList<>();
	@ParameterizedTest
	@ValueSource(strings = { 'one', 'two', 'three' })
	void testIsInvokedOnceForEachArgument(String argument) {
		if (argument.equals('one')) {
			assertThat(arguments).isEmpty();
		}
		else if (argument.equals('two')) {
			assertThat(arguments).doesNotContain('two', 'three');
		}
		else if (argument.equals('three')) {
			assertThat(arguments).doesNotContain('three');
		}
		arguments.add(argument);
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
@ClassPathExclusions(files = 'hibernate-validator-*.jar', packages = 'java.net.http')
class ModifiedClassPathExtensionExclusionsTests {
	private static final String EXCLUDED_RESOURCE = 'META-INF/services/jakarta.validation.spi.ValidationProvider';
	@Test
	void fileExclusionsAreFilteredFromTestClassClassLoader() {
		assertThat(getClass().getClassLoader().getResource(EXCLUDED_RESOURCE)).isNull();
	}
	@Test
	void fileExclusionsAreFilteredFromThreadContextClassLoader() {
		assertThat(Thread.currentThread().getContextClassLoader().getResource(EXCLUDED_RESOURCE)).isNull();
	}
	@Test
	void packageExclusionsAreFilteredFromTestClassClassLoader() {
		assertThat(ClassUtils.isPresent('java.net.http.HttpClient', getClass().getClassLoader())).isFalse();
	}
	@Test
	void packageExclusionsAreFilteredFromThreadContextClassLoader() {
		assertThat(ClassUtils.isPresent('java.net.http.HttpClient', Thread.currentThread().getContextClassLoader()))
			.isFalse();
	}
	@Test
	void testsThatUseHamcrestWorkCorrectly() {
		Matcher<IllegalStateException> matcher = isA(IllegalStateException.class);
		assertThat(matcher.matches(new IllegalStateException())).isTrue();
	}
}
/*
package org.springframework.boot.testsupport.process;
/**
@DisabledIfProcessUnavailable('iverymuchdontexist')
class DisabledIfProcessUnavailableTests {
	@Test
	void test() {
		fail('I should have been disabled');
	}
}
/*
package org.springframework.boot.testsupport.assertj;
/**
public final class SimpleAsyncTaskExecutorAssert
		extends AbstractAssert<SimpleAsyncTaskExecutorAssert, SimpleAsyncTaskExecutor> {
	private SimpleAsyncTaskExecutorAssert(SimpleAsyncTaskExecutor actual) {
		super(actual, SimpleAsyncTaskExecutorAssert.class);
	}
	/**
	 * Verifies that the actual executor uses platform threads.
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual executor doesn"t use platform threads
	 */
	public SimpleAsyncTaskExecutorAssert usesPlatformThreads() {
		isNotNull();
		if (producesVirtualThreads()) {
			failWithMessage('Expected executor to use platform threads, but it uses virtual threads');
		}
		return this;
	}
	/**
	 * Verifies that the actual executor uses virtual threads.
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual executor doesn"t use virtual threads
	 */
	public SimpleAsyncTaskExecutorAssert usesVirtualThreads() {
		isNotNull();
		if (!producesVirtualThreads()) {
			failWithMessage('Expected executor to use virtual threads, but it uses platform threads');
		}
		return this;
	}
	private boolean producesVirtualThreads() {
		Field field = ReflectionUtils.findField(SimpleAsyncTaskExecutor.class, 'virtualThreadDelegate');
		if (field == null) {
			throw new IllegalStateException('Field SimpleAsyncTaskExecutor.virtualThreadDelegate not found');
		}
		ReflectionUtils.makeAccessible(field);
		Object virtualThreadDelegate = ReflectionUtils.getField(field, this.actual);
		return virtualThreadDelegate != null;
	}
	/**
	 * Creates a new assertion class with the given {@link SimpleAsyncTaskExecutor}.
	 * @param actual the {@link SimpleAsyncTaskExecutor}
	 * @return the assertion class
	 */
	public static SimpleAsyncTaskExecutorAssert assertThat(SimpleAsyncTaskExecutor actual) {
		return new SimpleAsyncTaskExecutorAssert(actual);
	}
}
/*
/**
package org.springframework.boot.testsupport.assertj;
/*
package org.springframework.boot.testsupport.assertj;
/**
public final class ScheduledExecutorServiceAssert
		extends AbstractAssert<ScheduledExecutorServiceAssert, ScheduledExecutorService> {
	private ScheduledExecutorServiceAssert(ScheduledExecutorService actual) {
		super(actual, ScheduledExecutorServiceAssert.class);
	}
	/**
	 * Verifies that the actual executor uses platform threads.
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual executor doesn"t use platform threads
	 */
	public ScheduledExecutorServiceAssert usesPlatformThreads() {
		isNotNull();
		if (producesVirtualThreads()) {
			failWithMessage('Expected executor to use platform threads, but it uses virtual threads');
		}
		return this;
	}
	/**
	 * Verifies that the actual executor uses virtual threads.
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual executor doesn"t use virtual threads
	 */
	public ScheduledExecutorServiceAssert usesVirtualThreads() {
		isNotNull();
		if (!producesVirtualThreads()) {
			failWithMessage('Expected executor to use virtual threads, but it uses platform threads');
		}
		return this;
	}
	private boolean producesVirtualThreads() {
		try {
			return this.actual.schedule(() -> {
				Method isVirtual = ReflectionUtils.findMethod(Thread.class, 'isVirtual');
				if (isVirtual == null) {
					return false;
				}
				return (boolean) ReflectionUtils.invokeMethod(isVirtual, Thread.currentThread());
			}, 0, TimeUnit.SECONDS).get();
		}
		catch (InterruptedException | ExecutionException ex) {
			throw new AssertionError(ex);
		}
	}
	/**
	 * Creates a new assertion class with the given {@link ScheduledExecutorService}.
	 * @param actual the {@link ScheduledExecutorService}
	 * @return the assertion class
	 */
	public static ScheduledExecutorServiceAssert assertThat(ScheduledExecutorService actual) {
		return new ScheduledExecutorServiceAssert(actual);
	}
}
/*
package org.springframework.boot.testsupport.web.servlet;
/**
@SuppressWarnings('serial')
public class ExampleServlet extends GenericServlet {
	private final boolean echoRequestInfo;
	private final boolean writeWithoutContentLength;
	public ExampleServlet() {
		this(false, false);
	}
	public ExampleServlet(boolean echoRequestInfo, boolean writeWithoutContentLength) {
		this.echoRequestInfo = echoRequestInfo;
		this.writeWithoutContentLength = writeWithoutContentLength;
	}
	@Override
	public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
		String content = 'Hello World';
		if (this.echoRequestInfo) {
			content += ' scheme=' + request.getScheme();
			content += ' remoteaddr=' + request.getRemoteAddr();
		}
		if (this.writeWithoutContentLength) {
			response.setContentType('text/plain');
			ServletOutputStream outputStream = response.getOutputStream();
			StreamUtils.copy(content.getBytes(), outputStream);
			outputStream.flush();
		}
		else {
			response.getWriter().write(content);
		}
	}
}
/*
package org.springframework.boot.testsupport.web.servlet;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@ExtendWith(DirtiesUrlFactoriesExtension.class)
public @interface DirtiesUrlFactories {
}
/*
package org.springframework.boot.testsupport.web.servlet;
/**
class DirtiesUrlFactoriesExtension implements BeforeEachCallback, AfterEachCallback {
	private static final String TOMCAT_URL_STREAM_HANDLER_FACTORY = 'org.apache.catalina.webresources.TomcatURLStreamHandlerFactory';
	@Override
	public void afterEach(ExtensionContext context) throws Exception {
		reset();
	}
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		reset();
	}
	private void reset() {
		try {
			ClassLoader classLoader = getClass().getClassLoader();
			if (ClassUtils.isPresent(TOMCAT_URL_STREAM_HANDLER_FACTORY, classLoader)) {
				Class<?> factoryClass = ClassUtils.resolveClassName(TOMCAT_URL_STREAM_HANDLER_FACTORY, classLoader);
				ReflectionTestUtils.setField(factoryClass, 'instance', null);
			}
			ReflectionTestUtils.setField(URL.class, 'factory', null);
		}
		catch (InaccessibleObjectException ex) {
			throw new IllegalStateException(
					'Unable to reset field. Please run with "--add-opens=java.base/java.net=ALL-UNNAMED"', ex);
		}
	}
}
/*
package org.springframework.boot.testsupport.web.servlet;
/**
public class ExampleFilter implements Filter {
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void destroy() {
	}
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		response.getWriter().write('[');
		chain.doFilter(request, response);
		response.getWriter().write(']');
	}
}
/*
/**
package org.springframework.boot.testsupport.web.servlet;
/*
package org.springframework.boot.testsupport.web.servlet;
/**
public abstract class MockServletWebServer {
	private ServletContext servletContext;
	private final Initializer[] initializers;
	private final List<RegisteredServlet> registeredServlets = new ArrayList<>();
	private final List<RegisteredFilter> registeredFilters = new ArrayList<>();
	private final int port;
	public MockServletWebServer(Initializer[] initializers, int port) {
		this.initializers = initializers;
		this.port = port;
		initialize();
	}
	private void initialize() {
		try {
			this.servletContext = mock(ServletContext.class);
			lenient().doAnswer((invocation) -> {
				RegisteredServlet registeredServlet = new RegisteredServlet(invocation.getArgument(1));
				MockServletWebServer.this.registeredServlets.add(registeredServlet);
				return registeredServlet.getRegistration();
			}).when(this.servletContext).addServlet(anyString(), any(Servlet.class));
			lenient().doAnswer((invocation) -> {
				RegisteredFilter registeredFilter = new RegisteredFilter(invocation.getArgument(1));
				MockServletWebServer.this.registeredFilters.add(registeredFilter);
				return registeredFilter.getRegistration();
			}).when(this.servletContext).addFilter(anyString(), any(Filter.class));
			final SessionCookieConfig sessionCookieConfig = new MockSessionCookieConfig();
			given(this.servletContext.getSessionCookieConfig()).willReturn(sessionCookieConfig);
			final Map<String, String> initParameters = new HashMap<>();
			lenient().doAnswer((invocation) -> {
				initParameters.put(invocation.getArgument(0), invocation.getArgument(1));
				return null;
			}).when(this.servletContext).setInitParameter(anyString(), anyString());
			given(this.servletContext.getInitParameterNames())
				.willReturn(Collections.enumeration(initParameters.keySet()));
			lenient().doAnswer((invocation) -> initParameters.get(invocation.getArgument(0)))
				.when(this.servletContext)
				.getInitParameter(anyString());
			given(this.servletContext.getAttributeNames()).willReturn(Collections.emptyEnumeration());
			for (Initializer initializer : this.initializers) {
				initializer.onStartup(this.servletContext);
			}
		}
		catch (ServletException ex) {
			throw new RuntimeException(ex);
		}
	}
	public void stop() {
		this.servletContext = null;
		this.registeredServlets.clear();
	}
	public ServletContext getServletContext() {
		return this.servletContext;
	}
	public Servlet[] getServlets() {
		Servlet[] servlets = new Servlet[this.registeredServlets.size()];
		Arrays.setAll(servlets, (i) -> this.registeredServlets.get(i).getServlet());
		return servlets;
	}
	public RegisteredServlet getRegisteredServlet(int index) {
		return getRegisteredServlets().get(index);
	}
	public List<RegisteredServlet> getRegisteredServlets() {
		return this.registeredServlets;
	}
	public RegisteredFilter getRegisteredFilters(int index) {
		return getRegisteredFilters().get(index);
	}
	public List<RegisteredFilter> getRegisteredFilters() {
		return this.registeredFilters;
	}
	public int getPort() {
		return this.port;
	}
	/**
	 * A registered servlet.
	 */
	public static class RegisteredServlet {
		private final Servlet servlet;
		private final ServletRegistration.Dynamic registration;
		public RegisteredServlet(Servlet servlet) {
			this.servlet = servlet;
			this.registration = mock(ServletRegistration.Dynamic.class);
		}
		public ServletRegistration.Dynamic getRegistration() {
			return this.registration;
		}
		public Servlet getServlet() {
			return this.servlet;
		}
	}
	/**
	 * A registered filter.
	 */
	public static class RegisteredFilter {
		private final Filter filter;
		private final FilterRegistration.Dynamic registration;
		public RegisteredFilter(Filter filter) {
			this.filter = filter;
			this.registration = mock(FilterRegistration.Dynamic.class);
		}
		public FilterRegistration.Dynamic getRegistration() {
			return this.registration;
		}
		public Filter getFilter() {
			return this.filter;
		}
	}
	/**
	 * Initializer (usually implement by adapting {@code Initializer}).
	 */
	@FunctionalInterface
	protected interface Initializer {
		void onStartup(ServletContext context) throws ServletException;
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
final class ModifiedClassPathClassLoader extends URLClassLoader {
	private static final Map<List<AnnotatedElement>, ModifiedClassPathClassLoader> cache = new ConcurrentReferenceHashMap<>();
	private static final Pattern INTELLIJ_CLASSPATH_JAR_PATTERN = Pattern.compile('.*classpath(\\d+)?\\.jar');
	private static final int MAX_RESOLUTION_ATTEMPTS = 5;
	private final Set<String> excludedPackages;
	private final ClassLoader junitLoader;
	ModifiedClassPathClassLoader(URL[] urls, Set<String> excludedPackages, ClassLoader parent,
			ClassLoader junitLoader) {
		super(urls, parent);
		this.excludedPackages = excludedPackages;
		this.junitLoader = junitLoader;
	}
	@Override
	public Class<?> loadClass(String name) throws ClassNotFoundException {
		if (name.startsWith('org.junit.') || name.startsWith('org.hamcrest.')
				|| name.startsWith('io.netty.internal.tcnative.')) {
			return Class.forName(name, false, this.junitLoader);
		}
		String packageName = ClassUtils.getPackageName(name);
		if (this.excludedPackages.contains(packageName)) {
			throw new ClassNotFoundException();
		}
		return super.loadClass(name);
	}
	static ModifiedClassPathClassLoader get(Class<?> testClass, Method testMethod, List<Object> arguments) {
		Set<AnnotatedElement> candidates = new LinkedHashSet<>();
		candidates.add(testClass);
		candidates.add(testMethod);
		candidates.addAll(getAnnotatedElements(arguments.toArray()));
		List<AnnotatedElement> annotatedElements = candidates.stream()
			.filter(ModifiedClassPathClassLoader::hasAnnotation)
			.toList();
		if (annotatedElements.isEmpty()) {
			return null;
		}
		return cache.computeIfAbsent(annotatedElements, (key) -> compute(testClass.getClassLoader(), key));
	}
	private static Collection<AnnotatedElement> getAnnotatedElements(Object[] array) {
		Set<AnnotatedElement> result = new LinkedHashSet<>();
		for (Object item : array) {
			if (item instanceof AnnotatedElement annotatedElement) {
				result.add(annotatedElement);
			}
			else if (ObjectUtils.isArray(item)) {
				result.addAll(getAnnotatedElements(ObjectUtils.toObjectArray(item)));
			}
		}
		return result;
	}
	private static boolean hasAnnotation(AnnotatedElement element) {
		MergedAnnotations annotations = MergedAnnotations.from(element,
				MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);
		return annotations.isPresent(ForkedClassPath.class) || annotations.isPresent(ClassPathOverrides.class)
				|| annotations.isPresent(ClassPathExclusions.class);
	}
	private static ModifiedClassPathClassLoader compute(ClassLoader classLoader,
			List<AnnotatedElement> annotatedClasses) {
		List<MergedAnnotations> annotations = annotatedClasses.stream()
			.map((source) -> MergedAnnotations.from(source, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY))
			.toList();
		return new ModifiedClassPathClassLoader(processUrls(extractUrls(classLoader), annotations),
				excludedPackages(annotations), classLoader.getParent(), classLoader);
	}
	private static URL[] extractUrls(ClassLoader classLoader) {
		List<URL> extractedUrls = new ArrayList<>();
		doExtractUrls(classLoader).forEach((URL url) -> {
			if (isManifestOnlyJar(url)) {
				extractedUrls.addAll(extractUrlsFromManifestClassPath(url));
			}
			else {
				extractedUrls.add(url);
			}
		});
		return extractedUrls.toArray(new URL[0]);
	}
	private static Stream<URL> doExtractUrls(ClassLoader classLoader) {
		if (classLoader instanceof URLClassLoader urlClassLoader) {
			return Stream.of(urlClassLoader.getURLs());
		}
		return Stream.of(ManagementFactory.getRuntimeMXBean().getClassPath().split(File.pathSeparator))
			.map(ModifiedClassPathClassLoader::toURL);
	}
	private static URL toURL(String entry) {
		try {
			return new File(entry).toURI().toURL();
		}
		catch (Exception ex) {
			throw new IllegalArgumentException(ex);
		}
	}
	private static boolean isManifestOnlyJar(URL url) {
		return isShortenedIntelliJJar(url);
	}
	private static boolean isShortenedIntelliJJar(URL url) {
		String urlPath = url.getPath();
		boolean isCandidate = INTELLIJ_CLASSPATH_JAR_PATTERN.matcher(urlPath).matches();
		if (isCandidate) {
			try {
				Attributes attributes = getManifestMainAttributesFromUrl(url);
				String createdBy = attributes.getValue('Created-By');
				return createdBy != null && createdBy.contains('IntelliJ');
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return false;
	}
	private static List<URL> extractUrlsFromManifestClassPath(URL booterJar) {
		List<URL> urls = new ArrayList<>();
		try {
			for (String entry : getClassPath(booterJar)) {
				urls.add(new URL(entry));
			}
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
		return urls;
	}
	private static String[] getClassPath(URL booterJar) throws Exception {
		Attributes attributes = getManifestMainAttributesFromUrl(booterJar);
		return StringUtils.delimitedListToStringArray(attributes.getValue(Attributes.Name.CLASS_PATH), ' ');
	}
	private static Attributes getManifestMainAttributesFromUrl(URL url) throws Exception {
		try (JarFile jarFile = new JarFile(new File(url.toURI()))) {
			return jarFile.getManifest().getMainAttributes();
		}
	}
	private static URL[] processUrls(URL[] urls, List<MergedAnnotations> annotations) {
		ClassPathEntryFilter filter = new ClassPathEntryFilter(annotations);
		List<URL> additionalUrls = getAdditionalUrls(annotations);
		List<URL> processedUrls = new ArrayList<>(additionalUrls);
		for (URL url : urls) {
			if (!filter.isExcluded(url)) {
				processedUrls.add(url);
			}
		}
		return processedUrls.toArray(new URL[0]);
	}
	private static List<URL> getAdditionalUrls(List<MergedAnnotations> annotations) {
		Set<URL> urls = new LinkedHashSet<>();
		for (MergedAnnotations candidate : annotations) {
			MergedAnnotation<ClassPathOverrides> annotation = candidate.get(ClassPathOverrides.class);
			if (annotation.isPresent()) {
				urls.addAll(resolveCoordinates(annotation.getStringArray(MergedAnnotation.VALUE)));
			}
		}
		return urls.stream().toList();
	}
	private static List<URL> resolveCoordinates(String[] coordinates) {
		Exception latestFailure = null;
		RepositorySystem repositorySystem = createRepositorySystem();
		DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();
		session.setSystemProperties(System.getProperties());
		LocalRepository localRepository = new LocalRepository(System.getProperty('user.home') + '/.m2/repository');
		RemoteRepository remoteRepository = new RemoteRepository.Builder('central', 'default',
				'https://repo.maven.apache.org/maven2')
			.build();
		session.setLocalRepositoryManager(repositorySystem.newLocalRepositoryManager(session, localRepository));
		for (int i = 0; i < MAX_RESOLUTION_ATTEMPTS; i++) {
			CollectRequest collectRequest = new CollectRequest(null, Arrays.asList(remoteRepository));
			collectRequest.setDependencies(createDependencies(coordinates));
			DependencyRequest dependencyRequest = new DependencyRequest(collectRequest, null);
			try {
				DependencyResult result = repositorySystem.resolveDependencies(session, dependencyRequest);
				List<URL> resolvedArtifacts = new ArrayList<>();
				for (ArtifactResult artifact : result.getArtifactResults()) {
					resolvedArtifacts.add(artifact.getArtifact().getFile().toURI().toURL());
				}
				return resolvedArtifacts;
			}
			catch (Exception ex) {
				latestFailure = ex;
			}
		}
		throw new IllegalStateException('Resolution failed after ' + MAX_RESOLUTION_ATTEMPTS + ' attempts',
				latestFailure);
	}
	@SuppressWarnings('deprecation')
	private static RepositorySystem createRepositorySystem() {
		org.eclipse.aether.impl.DefaultServiceLocator serviceLocator = MavenRepositorySystemUtils.newServiceLocator();
		serviceLocator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
		serviceLocator.addService(TransporterFactory.class, HttpTransporterFactory.class);
		RepositorySystem repositorySystem = serviceLocator.getService(RepositorySystem.class);
		return repositorySystem;
	}
	private static List<Dependency> createDependencies(String[] allCoordinates) {
		List<Dependency> dependencies = new ArrayList<>();
		for (String coordinate : allCoordinates) {
			dependencies.add(new Dependency(new DefaultArtifact(coordinate), null));
		}
		return dependencies;
	}
	private static Set<String> excludedPackages(List<MergedAnnotations> annotations) {
		Set<String> excludedPackages = new HashSet<>();
		for (MergedAnnotations candidate : annotations) {
			MergedAnnotation<ClassPathExclusions> annotation = candidate.get(ClassPathExclusions.class);
			if (annotation.isPresent()) {
				excludedPackages.addAll(Arrays.asList(annotation.getStringArray('packages')));
			}
		}
		return excludedPackages;
	}
	/**
	 * Filter for class path entries.
	 */
	private static final class ClassPathEntryFilter {
		private final List<String> exclusions;
		private final AntPathMatcher matcher = new AntPathMatcher();
		private ClassPathEntryFilter(List<MergedAnnotations> annotations) {
			Set<String> exclusions = new LinkedHashSet<>();
			for (MergedAnnotations candidate : annotations) {
				MergedAnnotation<ClassPathExclusions> annotation = candidate.get(ClassPathExclusions.class);
				if (annotation.isPresent()) {
					exclusions.addAll(Arrays.asList(annotation.getStringArray(MergedAnnotation.VALUE)));
				}
			}
			this.exclusions = exclusions.stream().toList();
		}
		private boolean isExcluded(URL url) {
			if ('file'.equals(url.getProtocol())) {
				try {
					URI uri = url.toURI();
					File file = new File(uri);
					String name = (!uri.toString().endsWith('/')) ? file.getName()
							: file.getParentFile().getParentFile().getName();
					for (String exclusion : this.exclusions) {
						if (this.matcher.match(exclusion, name)) {
							return true;
						}
					}
				}
				catch (URISyntaxException ex) {
					// Ignore
				}
			}
			return false;
		}
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@ExtendWith(ModifiedClassPathExtension.class)
public @interface ClassPathOverrides {
	/**
	 * One or more sets of Maven coordinates ({@code groupId:artifactId:version}) to be
	 * added to the classpath. The additions will take precedence over any existing
	 * classes on the classpath.
	 * @return the coordinates
	 */
	String[] value();
}
/*
package org.springframework.boot.testsupport.classpath;
/**
class ModifiedClassPathExtension implements InvocationInterceptor {
	@Override
	public void interceptBeforeAllMethod(Invocation<Void> invocation,
			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
		intercept(invocation, extensionContext);
	}
	@Override
	public void interceptBeforeEachMethod(Invocation<Void> invocation,
			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
		intercept(invocation, extensionContext);
	}
	@Override
	public void interceptAfterEachMethod(Invocation<Void> invocation,
			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
		intercept(invocation, extensionContext);
	}
	@Override
	public void interceptAfterAllMethod(Invocation<Void> invocation,
			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
		intercept(invocation, extensionContext);
	}
	@Override
	public void interceptTestMethod(Invocation<Void> invocation, ReflectiveInvocationContext<Method> invocationContext,
			ExtensionContext extensionContext) throws Throwable {
		interceptMethod(invocation, invocationContext, extensionContext);
	}
	@Override
	public void interceptTestTemplateMethod(Invocation<Void> invocation,
			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
		interceptMethod(invocation, invocationContext, extensionContext);
	}
	private void interceptMethod(Invocation<Void> invocation, ReflectiveInvocationContext<Method> invocationContext,
			ExtensionContext extensionContext) throws Throwable {
		if (isModifiedClassPathClassLoader(extensionContext)) {
			invocation.proceed();
			return;
		}
		Class<?> testClass = extensionContext.getRequiredTestClass();
		Method testMethod = invocationContext.getExecutable();
		URLClassLoader modifiedClassLoader = ModifiedClassPathClassLoader.get(testClass, testMethod,
				invocationContext.getArguments());
		if (modifiedClassLoader == null) {
			invocation.proceed();
			return;
		}
		invocation.skip();
		ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(modifiedClassLoader);
		try {
			runTest(extensionContext.getUniqueId());
		}
		finally {
			Thread.currentThread().setContextClassLoader(originalClassLoader);
		}
	}
	private void runTest(String testId) throws Throwable {
		LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
			.selectors(DiscoverySelectors.selectUniqueId(testId))
			.build();
		Launcher launcher = LauncherFactory.create();
		TestPlan testPlan = launcher.discover(request);
		SummaryGeneratingListener listener = new SummaryGeneratingListener();
		launcher.registerTestExecutionListeners(listener);
		launcher.execute(testPlan);
		TestExecutionSummary summary = listener.getSummary();
		if (!CollectionUtils.isEmpty(summary.getFailures())) {
			throw summary.getFailures().get(0).getException();
		}
	}
	private void intercept(Invocation<Void> invocation, ExtensionContext extensionContext) throws Throwable {
		if (isModifiedClassPathClassLoader(extensionContext)) {
			invocation.proceed();
			return;
		}
		invocation.skip();
	}
	private boolean isModifiedClassPathClassLoader(ExtensionContext extensionContext) {
		Class<?> testClass = extensionContext.getRequiredTestClass();
		ClassLoader classLoader = testClass.getClassLoader();
		return classLoader.getClass().getName().equals(ModifiedClassPathClassLoader.class.getName());
	}
}
/*
package org.springframework.boot.testsupport.classpath;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@ExtendWith(ModifiedClassPathExtension.class)
public @interface ForkedClassPath {
}
/*
package org.springframework.boot.testsupport.classpath;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@ExtendWith(ModifiedClassPathExtension.class)
public @interface ClassPathExclusions {
	/**
	 * Alias for {@code files}.
	 * <p>
	 * One or more Ant-style patterns that identify entries to be excluded from the class
	 * path. Matching is performed against an entry"s {@link File#getName() file name}.
	 * For example, to exclude Hibernate Validator from the classpath,
	 * {@code 'hibernate-validator-*.jar'} can be used.
	 * @return the exclusion patterns
	 */
	@AliasFor('files')
	String[] value() default {};
	/**
	 * One or more Ant-style patterns that identify entries to be excluded from the class
	 * path. Matching is performed against an entry"s {@link File#getName() file name}.
	 * For example, to exclude Hibernate Validator from the classpath,
	 * {@code 'hibernate-validator-*.jar'} can be used.
	 * @return the exclusion patterns
	 */
	@AliasFor('value')
	String[] files() default {};
	/**
	 * One or more packages that should be excluded from the classpath.
	 * @return the excluded packages
	 */
	String[] packages() default {};
}
/*
/**
package org.springframework.boot.testsupport.classpath;
/*
package org.springframework.boot.testsupport.process;
/**
class DisabledIfProcessUnavailableCondition implements ExecutionCondition {
	private static final String USR_LOCAL_BIN = '/usr/local/bin';
	private static final boolean MAC_OS = System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('mac');
	@Override
	public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {
		List<String[]> commands = new ArrayList<>();
		context.getTestClass().map(this::getAnnotationValue).orElse(Stream.empty()).forEach(commands::add);
		context.getTestMethod().map(this::getAnnotationValue).orElse(Stream.empty()).forEach(commands::add);
		try {
			commands.forEach(this::check);
			return ConditionEvaluationResult.enabled('All processes available');
		}
		catch (Throwable ex) {
			return ConditionEvaluationResult.disabled('Process unavailable', ex.getMessage());
		}
	}
	private Stream<String[]> getAnnotationValue(AnnotatedElement testElement) {
		return MergedAnnotations.from(testElement, SearchStrategy.TYPE_HIERARCHY)
			.stream(DisabledIfProcessUnavailable.class)
			.map((annotation) -> annotation.getStringArray(MergedAnnotation.VALUE));
	}
	private void check(String[] command) {
		ProcessBuilder processBuilder = new ProcessBuilder(command);
		try {
			Process process = processBuilder.start();
			Assert.isTrue(process.waitFor(30, TimeUnit.SECONDS), 'Process did not exit within 30 seconds');
			Assert.state(process.exitValue() == 0, () -> 'Process exited with %d'.formatted(process.exitValue()));
			process.destroy();
		}
		catch (Exception ex) {
			String path = processBuilder.environment().get('PATH');
			if (MAC_OS && path != null && !path.contains(USR_LOCAL_BIN)
					&& !command[0].startsWith(USR_LOCAL_BIN + '/')) {
				String[] localCommand = command.clone();
				localCommand[0] = USR_LOCAL_BIN + '/' + localCommand[0];
				check(localCommand);
				return;
			}
			throw new RuntimeException(
					'Unable to start process "%s"'.formatted(StringUtils.arrayToDelimitedString(command, ' ')));
		}
	}
}
/*
package org.springframework.boot.testsupport.process;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ExtendWith(DisabledIfProcessUnavailableCondition.class)
@Repeatable(DisabledIfProcessUnavailables.class)
public @interface DisabledIfProcessUnavailable {
	String[] value();
}
/*
/**
package org.springframework.boot.testsupport.process;
/*
package org.springframework.boot.testsupport.process;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ExtendWith(DisabledIfProcessUnavailableCondition.class)
public @interface DisabledIfProcessUnavailables {
	DisabledIfProcessUnavailable[] value();
}
/*
package org.springframework.boot.testsupport;
/**
public class BuildOutput {
	private final Class<?> testClass;
	public BuildOutput(Class<?> testClass) {
		this.testClass = testClass;
	}
	/**
	 * Returns the location into which test classes have been built.
	 * @return test classes location
	 */
	public File getTestClassesLocation() {
		try {
			File location = new File(this.testClass.getProtectionDomain().getCodeSource().getLocation().toURI());
			if (location.getPath().endsWith(path('bin', 'test')) || location.getPath().endsWith(path('bin', 'intTest'))
					|| location.getPath().endsWith(path('build', 'classes', 'java', 'test'))
					|| location.getPath().endsWith(path('build', 'classes', 'java', 'intTest'))) {
				return location;
			}
			throw new IllegalStateException('Unexpected test classes location "' + location + '"');
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException('Invalid test class code source location', ex);
		}
	}
	/**
	 * Returns the location into which test resources have been built.
	 * @return test resources location
	 */
	public File getTestResourcesLocation() {
		File testClassesLocation = getTestClassesLocation();
		if (testClassesLocation.getPath().endsWith(path('bin', 'test'))
				|| testClassesLocation.getPath().endsWith(path('bin', 'intTest'))) {
			return testClassesLocation;
		}
		if (testClassesLocation.getPath().endsWith(path('build', 'classes', 'java', 'test'))) {
			return new File(testClassesLocation.getParentFile().getParentFile().getParentFile(), 'resources/test');
		}
		if (testClassesLocation.getPath().endsWith(path('build', 'classes', 'java', 'intTest'))) {
			return new File(testClassesLocation.getParentFile().getParentFile().getParentFile(), 'resources/intTest');
		}
		throw new IllegalStateException(
				'Cannot determine test resources location from classes location "' + testClassesLocation + '"');
	}
	/**
	 * Returns the root location into which build output is written.
	 * @return root location
	 */
	public File getRootLocation() {
		return new File('build');
	}
	private String path(String... components) {
		return File.separator + String.join(File.separator, components);
	}
}
/*
package org.springframework.boot.testsupport.junit;
/**
@Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ArgumentsSource(BooleanArgumentsProvider.class)
public @interface BooleanValueSource {
}
/*
package org.springframework.boot.testsupport.junit;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(DisabledOnOsCondition.class)
public @interface DisabledOnOs {
	/**
	 * The operating systems on which the annotated class or method should be disabled.
	 * @return the operating systems where the test is disabled
	 */
	OS[] value() default {};
	/**
	 * The operating systems on which the annotated class or method should be disabled.
	 * @return the operating systems where the test is disabled
	 */
	OS[] os() default {};
	/**
	 * The architectures on which the annotated class or method should be disabled.
	 * @return the architectures where the test is disabled
	 */
	String[] architecture() default {};
	/**
	 * See {@link org.junit.jupiter.api.condition.DisabledOnOs#disabledReason()}.
	 * @return disabled reason
	 */
	String disabledReason() default '';
}
/*
package org.springframework.boot.testsupport.junit;
/**
class BooleanArgumentsProvider implements ArgumentsProvider {
	@Override
	public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
		Method testMethod = context.getRequiredTestMethod();
		Preconditions.condition(testMethod.getParameterCount() > 0, () -> String.format(
				'@BooleanValueSource cannot provide arguments to method [%s]: the method does not declare any formal parameters.',
				testMethod.toGenericString()));
		return Stream.of(Arguments.arguments(false), Arguments.arguments(true));
	}
}
/*
package org.springframework.boot.testsupport.junit;
/**
class DisabledOnOsCondition implements ExecutionCondition {
	@Override
	public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {
		if (context.getElement().isEmpty()) {
			return ConditionEvaluationResult.enabled('No element for @DisabledOnOs found');
		}
		MergedAnnotation<DisabledOnOs> annotation = MergedAnnotations
			.from(context.getElement().get(), SearchStrategy.TYPE_HIERARCHY)
			.get(DisabledOnOs.class);
		if (!annotation.isPresent()) {
			return ConditionEvaluationResult.enabled('No @DisabledOnOs found');
		}
		return evaluate(annotation.synthesize());
	}
	private ConditionEvaluationResult evaluate(DisabledOnOs annotation) {
		String architecture = System.getProperty('os.arch');
		String os = System.getProperty('os.name');
		boolean onDisabledOs = Arrays.stream(annotation.os()).anyMatch(OS::isCurrentOs);
		boolean onDisabledArchitecture = Arrays.asList(annotation.architecture()).contains(architecture);
		if (onDisabledOs && onDisabledArchitecture) {
			String reason = annotation.disabledReason().isEmpty()
					? String.format('Disabled on OS = %s, architecture = %s', os, architecture)
					: annotation.disabledReason();
			return ConditionEvaluationResult.disabled(reason);
		}
		return ConditionEvaluationResult
			.enabled(String.format('Enabled on OS = %s, architecture = %s', os, architecture));
	}
}
/*
/**
package org.springframework.boot.testsupport.junit;
/*
package org.springframework.boot.testsupport.logging;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@ClassPathExclusions('log4j-to-slf4j-*.jar')
@ClassPathOverrides({ 'org.apache.logging.log4j:log4j-core:2.19.0',
		'org.apache.logging.log4j:log4j-slf4j-impl:2.19.0' })
public @interface ConfigureClasspathToPreferLog4j2 {
}
/*
/**
package org.springframework.boot.testsupport.logging;
/*
package org.springframework.boot.testsupport.system;
/**
public interface CapturedOutput extends CharSequence {
	@Override
	default int length() {
		return toString().length();
	}
	@Override
	default char charAt(int index) {
		return toString().charAt(index);
	}
	@Override
	default CharSequence subSequence(int start, int end) {
		return toString().subSequence(start, end);
	}
	/**
	 * Return all content (both {@link System#out System.out} and {@link System#err
	 * System.err}) in the order that it was captured.
	 * @return all captured output
	 */
	String getAll();
	/**
	 * Return {@link System#out System.out} content in the order that it was captured.
	 * @return {@link System#out System.out} captured output
	 */
	String getOut();
	/**
	 * Return {@link System#err System.err} content in the order that it was captured.
	 * @return {@link System#err System.err} captured output
	 */
	String getErr();
}
/*
/**
package org.springframework.boot.testsupport.system;
/*
package org.springframework.boot.testsupport.system;
/**
class OutputCapture implements CapturedOutput {
	private final Deque<SystemCapture> systemCaptures = new ArrayDeque<>();
	/**
	 * Push a new system capture session onto the stack.
	 */
	final void push() {
		this.systemCaptures.addLast(new SystemCapture());
	}
	/**
	 * Pop the last system capture session from the stack.
	 */
	final void pop() {
		this.systemCaptures.removeLast().release();
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj instanceof CharSequence) {
			return getAll().equals(obj.toString());
		}
		return false;
	}
	@Override
	public int hashCode() {
		return toString().hashCode();
	}
	@Override
	public String toString() {
		return getAll();
	}
	/**
	 * Return all content (both {@link System#out System.out} and {@link System#err
	 * System.err}) in the order that it was captured.
	 * @return all captured output
	 */
	@Override
	public String getAll() {
		return get((type) -> true);
	}
	/**
	 * Return {@link System#out System.out} content in the order that it was captured.
	 * @return {@link System#out System.out} captured output
	 */
	@Override
	public String getOut() {
		return get(Type.OUT::equals);
	}
	/**
	 * Return {@link System#err System.err} content in the order that it was captured.
	 * @return {@link System#err System.err} captured output
	 */
	@Override
	public String getErr() {
		return get(Type.ERR::equals);
	}
	/**
	 * Resets the current capture session, clearing its captured output.
	 */
	void reset() {
		this.systemCaptures.peek().reset();
	}
	private String get(Predicate<Type> filter) {
		Assert.state(!this.systemCaptures.isEmpty(),
				'No system captures found. Please check your output capture registration.');
		StringBuilder builder = new StringBuilder();
		for (SystemCapture systemCapture : this.systemCaptures) {
			systemCapture.append(builder, filter);
		}
		return builder.toString();
	}
	/**
	 * A capture session that captures {@link System#out System.out} and {@link System#err
	 * System.err}.
	 */
	private static class SystemCapture {
		private final PrintStreamCapture out;
		private final PrintStreamCapture err;
		private final Object monitor = new Object();
		private final List<CapturedString> capturedStrings = new ArrayList<>();
		SystemCapture() {
			this.out = new PrintStreamCapture(System.out, this::captureOut);
			this.err = new PrintStreamCapture(System.err, this::captureErr);
			System.setOut(this.out);
			System.setErr(this.err);
		}
		void release() {
			System.setOut(this.out.getParent());
			System.setErr(this.err.getParent());
		}
		private void captureOut(String string) {
			synchronized (this.monitor) {
				this.capturedStrings.add(new CapturedString(Type.OUT, string));
			}
		}
		private void captureErr(String string) {
			synchronized (this.monitor) {
				this.capturedStrings.add(new CapturedString(Type.ERR, string));
			}
		}
		void append(StringBuilder builder, Predicate<Type> filter) {
			synchronized (this.monitor) {
				for (CapturedString stringCapture : this.capturedStrings) {
					if (filter.test(stringCapture.getType())) {
						builder.append(stringCapture);
					}
				}
			}
		}
		void reset() {
			synchronized (this.monitor) {
				this.capturedStrings.clear();
			}
		}
	}
	/**
	 * A {@link PrintStream} implementation that captures written strings.
	 */
	private static class PrintStreamCapture extends PrintStream {
		private final PrintStream parent;
		PrintStreamCapture(PrintStream parent, Consumer<String> copy) {
			super(new OutputStreamCapture(getSystemStream(parent), copy));
			this.parent = parent;
		}
		PrintStream getParent() {
			return this.parent;
		}
		private static PrintStream getSystemStream(PrintStream printStream) {
			while (printStream instanceof PrintStreamCapture printStreamCapture) {
				printStream = printStreamCapture.getParent();
			}
			return printStream;
		}
	}
	/**
	 * An {@link OutputStream} implementation that captures written strings.
	 */
	private static class OutputStreamCapture extends OutputStream {
		private final PrintStream systemStream;
		private final Consumer<String> copy;
		OutputStreamCapture(PrintStream systemStream, Consumer<String> copy) {
			this.systemStream = systemStream;
			this.copy = copy;
		}
		@Override
		public void write(int b) throws IOException {
			write(new byte[] { (byte) (b & 0xFF) });
		}
		@Override
		public void write(byte[] b, int off, int len) throws IOException {
			this.copy.accept(new String(b, off, len));
			this.systemStream.write(b, off, len);
		}
		@Override
		public void flush() throws IOException {
			this.systemStream.flush();
		}
	}
	/**
	 * A captured string that forms part of the full output.
	 */
	private static class CapturedString {
		private final Type type;
		private final String string;
		CapturedString(Type type, String string) {
			this.type = type;
			this.string = string;
		}
		Type getType() {
			return this.type;
		}
		@Override
		public String toString() {
			return this.string;
		}
	}
	/**
	 * Types of content that can be captured.
	 */
	private enum Type {
		OUT, ERR
	}
}
/*
package org.springframework.boot.testsupport.system;
/**
public class OutputCaptureExtension
		implements BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback, ParameterResolver {
	OutputCaptureExtension() {
		// Package private to prevent users from directly creating an instance.
	}
	@Override
	public void beforeAll(ExtensionContext context) throws Exception {
		getOutputCapture(context).push();
	}
	@Override
	public void afterAll(ExtensionContext context) throws Exception {
		getOutputCapture(context).pop();
	}
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		getOutputCapture(context).push();
	}
	@Override
	public void afterEach(ExtensionContext context) throws Exception {
		getOutputCapture(context).pop();
	}
	@Override
	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
			throws ParameterResolutionException {
		return CapturedOutput.class.equals(parameterContext.getParameter().getType());
	}
	@Override
	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
		return getOutputCapture(extensionContext);
	}
	private OutputCapture getOutputCapture(ExtensionContext context) {
		return getStore(context).getOrComputeIfAbsent(OutputCapture.class);
	}
	private Store getStore(ExtensionContext context) {
		return context.getStore(Namespace.create(getClass()));
	}
}
/*
/**
package org.springframework.boot.testsupport;
/*
package org.springframework.boot.buildpack.platform.docker;
/**
@DisabledIfDockerUnavailable
class DockerApiIntegrationTests {
	private final DockerApi docker = new DockerApi();
	@Test
	void pullImage() throws IOException {
		this.docker.image()
			.pull(ImageReference.of('gcr.io/paketo-buildpacks/builder:base'), null,
					new TotalProgressPullListener(new TotalProgressBar('Pulling: ')));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
class PrivateKeyParserTests {
	private PemFileWriter fileWriter;
	@BeforeEach
	void setUp() throws IOException {
		this.fileWriter = new PemFileWriter();
	}
	@AfterEach
	void tearDown() throws IOException {
		this.fileWriter.cleanup();
	}
	@Test
	void parsePkcs8RsaKeyFile() throws IOException {
		Path path = this.fileWriter.writeFile('key.pem', PemFileWriter.PKCS8_PRIVATE_RSA_KEY);
		PrivateKey privateKey = PrivateKeyParser.parse(path);
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
	}
	@ParameterizedTest
	@ValueSource(strings = { PemFileWriter.PKCS8_PRIVATE_EC_NIST_P256_KEY, PemFileWriter.PKCS8_PRIVATE_EC_NIST_P384_KEY,
			PemFileWriter.PKCS8_PRIVATE_EC_PRIME256V1_KEY, PemFileWriter.PKCS8_PRIVATE_EC_SECP256R1_KEY })
	void parsePkcs8EcKeyFile(String contents) throws IOException {
		Path path = this.fileWriter.writeFile('key.pem', contents);
		PrivateKey privateKey = PrivateKeyParser.parse(path);
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('EC');
	}
	@Test
	void parsePkcs8DsaKeyFile() throws IOException {
		Path path = this.fileWriter.writeFile('key.pem', PemFileWriter.PRIVATE_DSA_KEY);
		PrivateKey privateKey = PrivateKeyParser.parse(path);
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('DSA');
	}
	@Test
	void parsePkcs1RsaKeyFile() throws IOException {
		Path path = this.fileWriter.writeFile('key.pem', PemFileWriter.PRIVATE_RSA_KEY);
		PrivateKey privateKey = PrivateKeyParser.parse(path);
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
	}
	@Test
	void parsePemEcKeyFile() throws IOException {
		Path path = this.fileWriter.writeFile('key.pem', PemFileWriter.PRIVATE_EC_KEY);
		ECPrivateKey privateKey = (ECPrivateKey) PrivateKeyParser.parse(path);
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('EC');
		assertThat(privateKey.getParams().toString()).contains('1.3.132.0.34').doesNotContain('prime256v1');
	}
	@Test
	void parsePemEcKeyFilePrime256v1() throws IOException {
		Path path = this.fileWriter.writeFile('key.pem', PemFileWriter.PRIVATE_EC_KEY_PRIME_256_V1);
		ECPrivateKey privateKey = (ECPrivateKey) PrivateKeyParser.parse(path);
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('EC');
		assertThat(privateKey.getParams().toString()).contains('prime256v1').doesNotContain('1.3.132.0.34');
	}
	@Test
	void parsePkcs8Ed25519KeyFile() throws IOException {
		Path path = this.fileWriter.writeFile('key.pem', PemFileWriter.PKCS8_PRIVATE_EC_ED25519_KEY);
		PrivateKey privateKey = PrivateKeyParser.parse(path);
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('EdDSA');
	}
	@Test
	void parseWithNonKeyFileWillThrowException() throws IOException {
		Path path = this.fileWriter.writeFile('text.pem', 'plain text');
		assertThatIllegalStateException().isThrownBy(() -> PrivateKeyParser.parse(path))
			.withMessageContaining(path.toString());
	}
	@Test
	void parseWithInvalidPathWillThrowException() throws URISyntaxException {
		Path path = Paths.get(new URI('file:///bad/path/key.pem'));
		assertThatIllegalStateException().isThrownBy(() -> PrivateKeyParser.parse(path))
			.withMessageContaining(path.toString());
	}
	@Nested
	class DerEncoderTests {
		@Test
		void codeLengthBytesShort() throws Exception {
			DerEncoder encoder = new DerEncoder();
			encoder.codeLengthBytes(0, new byte[127]);
			assertThat(encoder.toByteArray()).startsWith(0x0, 0x7F);
		}
		@Test
		void codeLengthBytesMedium() throws Exception {
			DerEncoder encoder = new DerEncoder();
			encoder.codeLengthBytes(0, new byte[130]);
			assertThat(encoder.toByteArray()).startsWith(0x0, 0x81, 0x82);
		}
		@Test
		void codeLengthBytesLong() throws Exception {
			DerEncoder encoder = new DerEncoder();
			encoder.codeLengthBytes(0, new byte[258]);
			assertThat(encoder.toByteArray()).startsWith(0x0, 0x82, 0x01, 0x02);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
class CertificateParserTests {
	private PemFileWriter fileWriter;
	@BeforeEach
	void setUp() throws IOException {
		this.fileWriter = new PemFileWriter();
	}
	@AfterEach
	void tearDown() throws IOException {
		this.fileWriter.cleanup();
	}
	@Test
	void parseCertificates() throws IOException {
		Path caPath = this.fileWriter.writeFile('ca.pem', PemFileWriter.CA_CERTIFICATE);
		Path certPath = this.fileWriter.writeFile('cert.pem', PemFileWriter.CERTIFICATE);
		X509Certificate[] certificates = CertificateParser.parse(caPath, certPath);
		assertThat(certificates).isNotNull();
		assertThat(certificates).hasSize(2);
		assertThat(certificates[0].getType()).isEqualTo('X.509');
		assertThat(certificates[1].getType()).isEqualTo('X.509');
	}
	@Test
	void parseCertificateChain() throws IOException {
		Path path = this.fileWriter.writeFile('ca.pem', PemFileWriter.CA_CERTIFICATE, PemFileWriter.CERTIFICATE);
		X509Certificate[] certificates = CertificateParser.parse(path);
		assertThat(certificates).isNotNull();
		assertThat(certificates).hasSize(2);
		assertThat(certificates[0].getType()).isEqualTo('X.509');
		assertThat(certificates[1].getType()).isEqualTo('X.509');
	}
	@Test
	void parseWithInvalidPathWillThrowException() throws URISyntaxException {
		Path path = Paths.get(new URI('file:///bad/path/cert.pem'));
		assertThatIllegalStateException().isThrownBy(() -> CertificateParser.parse(path))
			.withMessageContaining(path.toString());
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
class KeyStoreFactoryTests {
	private PemFileWriter fileWriter;
	@BeforeEach
	void setUp() throws IOException {
		this.fileWriter = new PemFileWriter();
	}
	@AfterEach
	void tearDown() throws IOException {
		this.fileWriter.cleanup();
	}
	@Test
	void createKeyStoreWithCertChain()
			throws IOException, KeyStoreException, UnrecoverableKeyException, NoSuchAlgorithmException {
		Path certPath = this.fileWriter.writeFile('cert.pem', PemFileWriter.CA_CERTIFICATE, PemFileWriter.CERTIFICATE);
		KeyStore keyStore = KeyStoreFactory.create(certPath, null, 'test-alias');
		assertThat(keyStore.containsAlias('test-alias-0')).isTrue();
		assertThat(keyStore.getCertificate('test-alias-0')).isNotNull();
		assertThat(keyStore.getKey('test-alias-0', new char[] {})).isNull();
		assertThat(keyStore.containsAlias('test-alias-1')).isTrue();
		assertThat(keyStore.getCertificate('test-alias-1')).isNotNull();
		assertThat(keyStore.getKey('test-alias-1', new char[] {})).isNull();
	}
	@Test
	void createKeyStoreWithCertChainAndRsaPrivateKey()
			throws IOException, KeyStoreException, UnrecoverableKeyException, NoSuchAlgorithmException {
		Path certPath = this.fileWriter.writeFile('cert.pem', PemFileWriter.CA_CERTIFICATE, PemFileWriter.CERTIFICATE);
		Path keyPath = this.fileWriter.writeFile('key.pem', PemFileWriter.PRIVATE_RSA_KEY);
		KeyStore keyStore = KeyStoreFactory.create(certPath, keyPath, 'test-alias');
		assertThat(keyStore.containsAlias('test-alias')).isTrue();
		assertThat(keyStore.getCertificate('test-alias')).isNotNull();
		assertThat(keyStore.getKey('test-alias', new char[] {})).isNotNull();
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
class SslContextFactoryTests {
	private PemFileWriter fileWriter;
	@BeforeEach
	void setUp() throws IOException {
		this.fileWriter = new PemFileWriter();
	}
	@AfterEach
	void tearDown() throws IOException {
		this.fileWriter.cleanup();
	}
	@Test
	void createKeyStoreWithCertChain() throws IOException {
		this.fileWriter.writeFile('cert.pem', PemFileWriter.CERTIFICATE);
		this.fileWriter.writeFile('key.pem', PemFileWriter.PRIVATE_RSA_KEY);
		this.fileWriter.writeFile('ca.pem', PemFileWriter.CA_CERTIFICATE);
		SSLContext sslContext = new SslContextFactory().forDirectory(this.fileWriter.getTempDir().toString());
		assertThat(sslContext).isNotNull();
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
public class PemFileWriter {
	private static final String EXAMPLE_SECRET_QUALIFIER = 'example';
	public static final String CA_CERTIFICATE = '''
			-----BEGIN TRUSTED CERTIFICATE-----
			MIIClzCCAgACCQCPbjkRoMVEQDANBgkqhkiG9w0BAQUFADCBjzELMAkGA1UEBhMC
			VVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28x
			DTALBgNVBAoMBFRlc3QxDTALBgNVBAsMBFRlc3QxFDASBgNVBAMMC2V4YW1wbGUu
			Y29tMR8wHQYJKoZIhvcNAQkBFhB0ZXN0QGV4YW1wbGUuY29tMB4XDTIwMDMyNzIx
			NTgwNFoXDTIxMDMyNzIxNTgwNFowgY8xCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApD
			YWxpZm9ybmlhMRYwFAYDVQQHDA1TYW4gRnJhbmNpc2NvMQ0wCwYDVQQKDARUZXN0
			MQ0wCwYDVQQLDARUZXN0MRQwEgYDVQQDDAtleGFtcGxlLmNvbTEfMB0GCSqGSIb3
			DQEJARYQdGVzdEBleGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkC
			gYEA1YzixWEoyzrd20C2R1gjyPCoPfFLlG6UYTyT0tueNy6yjv6qbJ8lcZg7616O
			3I9LuOHhZh9U+fCDCgPfiDdyJfDEW/P+dsOMFyMUXPrJPze2yPpOnvV8iJ5DM93u
			fEVhCCyzLdYu0P2P3hU2W+T3/Im9DA7FOPA2vF1SrIJ2qtUCAwEAATANBgkqhkiG
			9w0BAQUFAAOBgQBdShkwUv78vkn1jAdtfbB+7mpV9tufVdo29j7pmotTCz3ny5fc
			zLEfeu6JPugAR71JYbc2CqGrMneSk1zT91EH6ohIz8OR5VNvzB7N7q65Ci7OFMPl
			ly6k3rHpMCBtHoyNFhNVfPLxGJ9VlWFKLgIAbCmL4OIQm1l6Fr1MSM38Zw==
			-----END TRUSTED CERTIFICATE-----
			''';
	public static final String CERTIFICATE = '''
			-----BEGIN CERTIFICATE-----
			MIICjzCCAfgCAQEwDQYJKoZIhvcNAQEFBQAwgY8xCzAJBgNVBAYTAlVTMRMwEQYD
			VQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1TYW4gRnJhbmNpc2NvMQ0wCwYDVQQK
			DARUZXN0MQ0wCwYDVQQLDARUZXN0MRQwEgYDVQQDDAtleGFtcGxlLmNvbTEfMB0G
			CSqGSIb3DQEJARYQdGVzdEBleGFtcGxlLmNvbTAeFw0yMDAzMjcyMjAxNDZaFw0y
			MTAzMjcyMjAxNDZaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5p
			YTEWMBQGA1UEBwwNU2FuIEZyYW5jaXNjbzENMAsGA1UECgwEVGVzdDENMAsGA1UE
			CwwEVGVzdDEUMBIGA1UEAwwLZXhhbXBsZS5jb20xHzAdBgkqhkiG9w0BCQEWEHRl
			c3RAZXhhbXBsZS5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAM7kd2cj
			F49wm1+OQ7Q5GE96cXueWNPr/Nwei71tf6G4BmE0B+suXHEvnLpHTj9pdX/ZzBIK
			8jIZ/x8RnSduK/Ky+zm1QMYUWZtWCAgCW8WzgB69Cn/hQG8KSX3S9bqODuQAvP54
			GQJD7+4kVuNBGjFb4DaD4nvMmPtALSZf8ZCZAgMBAAEwDQYJKoZIhvcNAQEFBQAD
			gYEAOn6X8+0VVlDjF+TvTgI0KIasA6nDm+KXe7LVtfvqWqQZH4qyd2uiwcDM3Aux
			a/OsPdOw0j+NqFDBd3mSMhSVgfvXdK6j9WaxY1VGXyaidLARgvn63wfzgr857sQW
			c8eSxbwEQxwlMvVxW6Os4VhCfUQr8VrBrvPa2zs+6IlK+Ug=
			-----END CERTIFICATE-----
			''';
	public static final String PRIVATE_RSA_KEY = '''
			%s-----BEGIN RSA PRIVATE KEY-----
			MIICXAIBAAKBgQDO5HdnIxePcJtfjkO0ORhPenF7nljT6/zcHou9bX+huAZhNAfr
			LlxxL5y6R04/aXV/2cwSCvIyGf8fEZ0nbivysvs5tUDGFFmbVggIAlvFs4AevQp/
			4UBvCkl90vW6jg7kALz+eBkCQ+/uJFbjQRoxW+A2g+J7zJj7QC0mX/GQmQIDAQAB
			AoGAIWPsBWA7gDHrUYuzT5XbX5BiWlIfAezXPWtMoEDY1W/Oz8dG8+TilH3brJCv
			hzps9TpgXhUYK4/Yhdog4+k6/EEY80RvcObOnflazTCVS041B0Ipm27uZjIq2+1F
			ZfbWP+B3crpzh8wvIYA+6BCcZV9zi8Od32NEs39CtrOrFPUCQQDxnt9+JlWjtteR
			VttRSKjtzKIF08BzNuZlRP9HNWveLhphIvdwBfjASwqgtuslqziEnGG8kniWzyYB
			a/ZZVoT3AkEA2zSBMpvGPDkGbOMqbnR8UL3uijkOj+blQe1gsyu3dUa9T42O1u9h
			Iz5SdCYlSFHbDNRFrwuW2QnhippqIQqC7wJAbVeyWEpM0yu5XiJqWdyB5iuG3xA2
			tW0Q0p9ozvbT+9XtRiwmweFR8uOCybw9qexURV7ntAis3cKctmP/Neq7fQJBAKGa
			59UjutYTRIVqRJICFtR/8ii9P9sfYs1j7/KnvC0d5duMhU44VOjivW8b4Eic8F1Y
			8bbHWILSIhFJHg0V7skCQDa8/YkRWF/3pwIZNWQr4ce4OzvYsFMkRvGRdX8B2a0p
			wSKcVTdEdO2DhBlYddN0zG0rjq4vDMtdmldEl4BdldQ=
			-----END RSA PRIVATE KEY-----
			'''.formatted(EXAMPLE_SECRET_QUALIFIER);
	public static final String PRIVATE_EC_KEY = EXAMPLE_SECRET_QUALIFIER + '-----BEGIN EC PRIVATE KEY-----\n'
			+ 'MIGkAgEBBDB21WGGOb1DokKW0MUHO7RQ6jZSUYXfO2iyfCbjmSJhyK8fSuq1V0N2\n'
			+ 'Bj7X+XYhS6ygBwYFK4EEACKhZANiAATsRaYri/tDMvrrB2NJlxWFOZ4YBLYdSM+a\n'
			+ 'FlGh1FuLjOHW9cx8w0iRHd1Hxn4sxqsa62KzGoCj63lGoaJgi67YNCF0lBa/zCLy\n'
			+ 'ktaMsQePDOR8UR0Cfi2J9bh+IjxXd+o=\n' + '-----END EC PRIVATE KEY-----';
	public static final String PRIVATE_EC_KEY_PRIME_256_V1 = EXAMPLE_SECRET_QUALIFIER
			+ '-----BEGIN EC PRIVATE KEY-----\n' + 'MHcCAQEEIIwZkO8Zjbggzi8wwrk5rzSPzUX31gqTRhBYw4AL6w44oAoGCCqGSM49\n'
			+ 'AwEHoUQDQgAE8y28khug747bA68M90IAMCPHAYyen+RsN6i84LORpNDUhv00QZWd\n'
			+ 'hOhjWFCQjnewR98Y8pEb1fnORll4LhHPlQ==\n' + '-----END EC PRIVATE KEY-----';
	public static final String PRIVATE_DSA_KEY = EXAMPLE_SECRET_QUALIFIER + '-----BEGIN PRIVATE KEY-----\n'
			+ 'MIICXAIBADCCAjUGByqGSM44BAEwggIoAoIBAQCPeTXZuarpv6vtiHrPSVG28y7F\n'
			+ 'njuvNxjo6sSWHz79NgbnQ1GpxBgzObgJ58KuHFObp0dbhdARrbi0eYd1SYRpXKwO\n'
			+ 'jxSzNggooi/6JxEKPWKpk0U0CaD+aWxGWPhL3SCBnDcJoBBXsZWtzQAjPbpUhLYp\n'
			+ 'H51kjviDRIZ3l5zsBLQ0pqwudemYXeI9sCkvwRGMn/qdgYHnM423krcw17njSVkv\n'
			+ 'aAmYchU5Feo9a4tGU8YzRY+AOzKkwuDycpAlbk4/ijsIOKHEUOThjBopo33fXqFD\n'
			+ '3ktm/wSQPtXPFiPhWNSHxgjpfyEc2B3KI8tuOAdl+CLjQr5ITAV2OTlgHNZnAh0A\n'
			+ 'uvaWpoV499/e5/pnyXfHhe8ysjO65YDAvNVpXQKCAQAWplxYIEhQcE51AqOXVwQN\n'
			+ 'NNo6NHjBVNTkpcAtJC7gT5bmHkvQkEq9rI837rHgnzGC0jyQQ8tkL4gAQWDt+coJ\n'
			+ 'syB2p5wypifyRz6Rh5uixOdEvSCBVEy1W4AsNo0fqD7UielOD6BojjJCilx4xHjG\n'
			+ 'jQUntxyaOrsLC+EsRGiWOefTznTbEBplqiuH9kxoJts+xy9LVZmDS7TtsC98kOmk\n'
			+ 'ltOlXVNb6/xF1PYZ9j897buHOSXC8iTgdzEpbaiH7B5HSPh++1/et1SEMWsiMt7l\n'
			+ 'U92vAhErDR8C2jCXMiT+J67ai51LKSLZuovjntnhA6Y8UoELxoi34u1DFuHvF9ve\n'
			+ 'BB4CHHBQgJ3ST6U8rIxoTqGe42TiVckPf1PoSiJy8GY=\n' + '-----END PRIVATE KEY-----\n';
	public static final String PKCS8_PRIVATE_EC_NIST_P256_KEY = EXAMPLE_SECRET_QUALIFIER
			+ '-----BEGIN PRIVATE KEY-----\n' + 'MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgd6SePFfpaTKFd1Gm\n'
			+ '+WeHZNkORkot5hx6X9elPdICL9ygCgYIKoZIzj0DAQehRANCAASnMAMgeFBv9ks0\n'
			+ 'd0jP+utQ3mohwmxY93xljfaBofdg1IeHgDd4I4pBzPxEnvXrU3kcz+SgPZyH1ybl\n' + 'P6mSXDXu\n'
			+ '-----END PRIVATE KEY-----\n';
	public static final String PKCS8_PRIVATE_EC_NIST_P384_KEY = EXAMPLE_SECRET_QUALIFIER
			+ '-----BEGIN PRIVATE KEY-----\n' + 'MIG/AgEAMBAGByqGSM49AgEGBSuBBAAiBIGnMIGkAgEBBDCexXiWKrtrqV1+d1Tv\n'
			+ 't1n5huuw2A+204mQHRuPL9UC8l0XniJjx/PVELCciyJM/7+gBwYFK4EEACKhZANi\n'
			+ 'AASHEELZSdrHiSXqU1B+/jrOCr6yjxCMqQsetTb0q5WZdCXOhggGXfbzlRynqphQ\n'
			+ 'i4G7azBUklgLaXfxN5eFk6C+E38SYOR7iippcQsSR2ZsCiTk7rnur4b40gQ7IgLA\n' + '/sU=\n'
			+ '-----END PRIVATE KEY-----\n';
	public static final String PKCS8_PRIVATE_EC_PRIME256V1_KEY = EXAMPLE_SECRET_QUALIFIER
			+ '-----BEGIN PRIVATE KEY-----\n' + 'MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQg4dVuddgQ6enDvPPw\n'
			+ 'Dd1mmS6FMm/kzTJjDVsltrNmRuSgCgYIKoZIzj0DAQehRANCAAR1WMrRADEaVj9m\n'
			+ 'uoUfPhUefJK+lS89NHikQ0ZdkHkybyVKLFMLe1hCynhzpKQmnpgud3E10F0P2PZQ\n' + 'L9RCEpGf\n'
			+ '-----END PRIVATE KEY-----\n';
	public static final String PKCS8_PRIVATE_EC_SECP256R1_KEY = EXAMPLE_SECRET_QUALIFIER
			+ '-----BEGIN PRIVATE KEY-----\n' + 'MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgU9+v5hUNnTKix8fe\n'
			+ 'Pfz+NfXFlGxQZMReSCT2Id9PfKagCgYIKoZIzj0DAQehRANCAATeJg+YS4BrJ35A\n'
			+ 'KgRlZ59yKLDpmENCMoaYUuWbQ9hqHzdybQGzQsrNJqgH0nzWghPwP4nFaLPN+pgB\n' + 'bqiRgbjG\n'
			+ '-----END PRIVATE KEY-----\n';
	public static final String PKCS8_PRIVATE_RSA_KEY = EXAMPLE_SECRET_QUALIFIER + '-----BEGIN PRIVATE KEY-----\n'
			+ 'MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDR0KfxUw7MF/8R\n'
			+ 'B5/YXOM7yLnoHYb/M/6dyoulMbtEdKKhQhU28o5FiDkHcEG9PJQLgqrRgAjl3VmC\n'
			+ 'C9omtfZJQ2EpfkTttkJjnKOOroXhYE51/CYSckapBYCVh8GkjUEJuEfnp07cTfYZ\n'
			+ 'FqViIgIWPZyjkzl3w4girS7kCuzNdDntVJVx5F/EsFwMA8n3C0QazHQoM5s00Fer\n'
			+ '6aTwd6AW0JD5QkADavpfzZ554e4HrVGwHlM28WKQQkFzzGu44FFXyVuEF3HeyVPu\n'
			+ 'g8GRHAc8UU7ijVgJB5TmbvRGYowIErD5i4VvGLuOv9mgR3aVyN0SdJ1N7aJnXpeS\n'
			+ 'QjAgf03jAgMBAAECggEBAIhQyzwj3WJGWOZkkLqOpufJotcmj/Wwf0VfOdkq9WMl\n'
			+ 'cB/bAlN/xWVxerPVgDCFch4EWBzi1WUaqbOvJZ2u7QNubmr56aiTmJCFTVI/GyZx\n'
			+ 'XqiTGN01N6lKtN7xo6LYTyAUhUsBTWAemrx0FSErvTVb9C/mUBj6hbEZ2XQ5kN5t\n'
			+ '7qYX4Lu0zyn7s1kX5SLtm5I+YRq7HSwB6wLy+DSroO71izZ/VPwME3SwT5SN+c87\n'
			+ '3dkklR7fumNd9dOpSWKrLPnq4aMko00rvIGc63xD1HrEpXUkB5v24YEn7HwCLEH7\n'
			+ 'b8jrp79j2nCvvR47inpf+BR8FIWAHEOUUqCEzjQkdiECgYEA6ifjMM0f02KPeIs7\n'
			+ 'zXd1lI7CUmJmzkcklCIpEbKWf/t/PHv3QgqIkJzERzRaJ8b+GhQ4zrSwAhrGUmI8\n'
			+ 'kDkXIqe2/2ONgIOX2UOHYHyTDQZHnlXyDecvHUTqs2JQZCGBZkXyZ9i0j3BnTymC\n'
			+ 'iZ8DvEa0nxsbP+U3rgzPQmXiQVMCgYEA5WN2Y/RndbriNsNrsHYRldbPO5nfV9rp\n'
			+ 'cDzcQU66HRdK5VIdbXT9tlMYCJIZsSqE0tkOwTgEB/sFvF/tIHSCY5iO6hpIyk6g\n'
			+ 'kkUzPcld4eM0dEPAge7SYUbakB9CMvA7MkDQSXQNFyZ0mH83+UikwT6uYHFh7+ox\n'
			+ 'N1P+psDhXzECgYEA1gXLVQnIcy/9LxMkgDMWV8j8uMyUZysDthpbK3/uq+A2dhRg\n'
			+ '9g4msPd5OBQT65OpIjElk1n4HpRWfWqpLLHiAZ0GWPynk7W0D7P3gyuaRSdeQs0P\n'
			+ 'x8FtgPVDCN9t13gAjHiWjnC26Py2kNbCKAQeJ/MAmQTvrUFX2VCACJKTcV0CgYAj\n'
			+ 'xJWSUmrLfb+GQISLOG3Xim434e9keJsLyEGj4U29+YLRLTOvfJ2PD3fg5j8hU/rw\n'
			+ 'Ea5uTHi8cdTcIa0M8X3fX8txD3YoLYh2JlouGTcNYOst8d6TpBSj3HN6I5Wj8beZ\n'
			+ 'R2fy/CiKYpGtsbCdq0kdZNO18BgQW9kewncjs1GxEQKBgQCf8q34h6KuHpHSDh9h\n'
			+ 'YkDTypk0FReWBAVJCzDNDUMhVLFivjcwtaMd2LiC3FMKZYodr52iKg60cj43vbYI\n'
			+ 'frmFFxoL37rTmUocCTBKc0LhWj6MicI+rcvQYe1uwTrpWdFf1aZJMYRLRczeKtev\n' + 'OWaE/9hVZ5+9pild1NukGpOydw==\n'
			+ '-----END PRIVATE KEY-----\n';
	public static final String PKCS8_PRIVATE_EC_ED25519_KEY = EXAMPLE_SECRET_QUALIFIER + '-----BEGIN PRIVATE KEY-----\n'
			+ 'MC4CAQAwBQYDK2VwBCIEIJOKNTaIJQTVuEqZ+yvclnjnlWJG6F+K+VsNCOlWRda+\n' + '-----END PRIVATE KEY-----';
	private final Path tempDir;
	public PemFileWriter() throws IOException {
		this.tempDir = Files.createTempDirectory('buildpack-platform-docker-ssl-tests');
	}
	Path writeFile(String name, String... contents) throws IOException {
		Path path = Paths.get(this.tempDir.toString(), name);
		for (String content : contents) {
			Files.write(path, content.replaceAll(EXAMPLE_SECRET_QUALIFIER, '').getBytes(), StandardOpenOption.CREATE,
					StandardOpenOption.APPEND);
		}
		return path;
	}
	public Path getTempDir() {
		return this.tempDir;
	}
	void cleanup() throws IOException {
		FileSystemUtils.deleteRecursively(this.tempDir);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class PullImageUpdateEventTests extends ProgressUpdateEventTests<PullImageUpdateEvent> {
	@Test
	void getIdReturnsId() {
		PullImageUpdateEvent event = createEvent();
		assertThat(event.getId()).isEqualTo('id');
	}
	@Override
	protected PullImageUpdateEvent createEvent(String status, ProgressDetail progressDetail, String progress) {
		return new PullImageUpdateEvent('id', status, progressDetail, progress);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class DockerRegistryTokenAuthenticationTests extends AbstractJsonTests {
	@Test
	void createAuthHeaderReturnsEncodedHeader() throws IOException, JSONException {
		DockerRegistryTokenAuthentication auth = new DockerRegistryTokenAuthentication('tokenvalue');
		String header = auth.getAuthHeader();
		String expectedJson = StreamUtils.copyToString(getContent('auth-token.json'), StandardCharsets.UTF_8);
		JSONAssert.assertEquals(expectedJson, new String(Base64.getUrlDecoder().decode(header)), false);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class DockerConfigurationMetadataTests extends AbstractJsonTests {
	private final Map<String, String> environment = new LinkedHashMap<>();
	@Test
	void configWithContextIsRead() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-context/config.json'));
		DockerConfigurationMetadata config = DockerConfigurationMetadata.from(this.environment::get);
		assertThat(config.getConfiguration().getCurrentContext()).isEqualTo('test-context');
		assertThat(config.getContext().getDockerHost()).isEqualTo('unix:///home/user/.docker/docker.sock');
		assertThat(config.getContext().isTlsVerify()).isFalse();
		assertThat(config.getContext().getTlsPath()).isNull();
	}
	@Test
	void configWithoutContextIsRead() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('without-context/config.json'));
		DockerConfigurationMetadata config = DockerConfigurationMetadata.from(this.environment::get);
		assertThat(config.getConfiguration().getCurrentContext()).isNull();
		assertThat(config.getContext().getDockerHost()).isNull();
		assertThat(config.getContext().isTlsVerify()).isFalse();
		assertThat(config.getContext().getTlsPath()).isNull();
	}
	@Test
	void configWithDefaultContextIsRead() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-default-context/config.json'));
		DockerConfigurationMetadata config = DockerConfigurationMetadata.from(this.environment::get);
		assertThat(config.getConfiguration().getCurrentContext()).isEqualTo('default');
		assertThat(config.getContext().getDockerHost()).isNull();
		assertThat(config.getContext().isTlsVerify()).isFalse();
		assertThat(config.getContext().getTlsPath()).isNull();
	}
	@Test
	void configIsReadWithProvidedContext() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-default-context/config.json'));
		DockerConfigurationMetadata config = DockerConfigurationMetadata.from(this.environment::get);
		DockerContext context = config.forContext('test-context');
		assertThat(context.getDockerHost()).isEqualTo('unix:///home/user/.docker/docker.sock');
		assertThat(context.isTlsVerify()).isTrue();
		assertThat(context.getTlsPath()).matches(String.join(Pattern.quote(File.separator), '^.*',
				'with-default-context', 'contexts', 'tls', '[a-zA-z0-9]*', 'docker$'));
	}
	@Test
	void invalidContextThrowsException() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-default-context/config.json'));
		assertThatIllegalArgumentException()
			.isThrownBy(() -> DockerConfigurationMetadata.from(this.environment::get).forContext('invalid-context'))
			.withMessageContaining('Docker context "invalid-context" does not exist');
	}
	@Test
	void configIsEmptyWhenConfigFileDoesNotExist() {
		this.environment.put('DOCKER_CONFIG', 'docker-config-dummy-path');
		DockerConfigurationMetadata config = DockerConfigurationMetadata.from(this.environment::get);
		assertThat(config.getConfiguration().getCurrentContext()).isNull();
		assertThat(config.getContext().getDockerHost()).isNull();
		assertThat(config.getContext().isTlsVerify()).isFalse();
	}
	private String pathToResource(String resource) throws URISyntaxException {
		URL url = getClass().getResource(resource);
		return Paths.get(url.toURI()).getParent().toAbsolutePath().toString();
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class DockerRegistryUserAuthenticationTests extends AbstractJsonTests {
	@Test
	void createMinimalAuthHeaderReturnsEncodedHeader() throws IOException, JSONException {
		DockerRegistryUserAuthentication auth = new DockerRegistryUserAuthentication('user', 'secret',
				'https://docker.example.com', 'docker@example.com');
		JSONAssert.assertEquals(jsonContent('auth-user-full.json'), decoded(auth.getAuthHeader()), false);
	}
	@Test
	void createFullAuthHeaderReturnsEncodedHeader() throws IOException, JSONException {
		DockerRegistryUserAuthentication auth = new DockerRegistryUserAuthentication('user', 'secret', null, null);
		JSONAssert.assertEquals(jsonContent('auth-user-minimal.json'), decoded(auth.getAuthHeader()), false);
	}
	private String jsonContent(String s) throws IOException {
		return StreamUtils.copyToString(getContent(s), StandardCharsets.UTF_8);
	}
	private String decoded(String header) {
		return new String(Base64.getUrlDecoder().decode(header));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class DockerConfigurationTests {
	@Test
	void createDockerConfigurationWithDefaults() {
		DockerConfiguration configuration = new DockerConfiguration();
		assertThat(configuration.getBuilderRegistryAuthentication()).isNull();
	}
	@Test
	void createDockerConfigurationWithUserAuth() {
		DockerConfiguration configuration = new DockerConfiguration().withBuilderRegistryUserAuthentication('user',
				'secret', 'https://docker.example.com', 'docker@example.com');
		DockerRegistryAuthentication auth = configuration.getBuilderRegistryAuthentication();
		assertThat(auth).isNotNull();
		assertThat(auth).isInstanceOf(DockerRegistryUserAuthentication.class);
		DockerRegistryUserAuthentication userAuth = (DockerRegistryUserAuthentication) auth;
		assertThat(userAuth.getUrl()).isEqualTo('https://docker.example.com');
		assertThat(userAuth.getUsername()).isEqualTo('user');
		assertThat(userAuth.getPassword()).isEqualTo('secret');
		assertThat(userAuth.getEmail()).isEqualTo('docker@example.com');
	}
	@Test
	void createDockerConfigurationWithTokenAuth() {
		DockerConfiguration configuration = new DockerConfiguration().withBuilderRegistryTokenAuthentication('token');
		DockerRegistryAuthentication auth = configuration.getBuilderRegistryAuthentication();
		assertThat(auth).isNotNull();
		assertThat(auth).isInstanceOf(DockerRegistryTokenAuthentication.class);
		DockerRegistryTokenAuthentication tokenAuth = (DockerRegistryTokenAuthentication) auth;
		assertThat(tokenAuth.getToken()).isEqualTo('token');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class ResolvedDockerHostTests {
	private final Map<String, String> environment = new LinkedHashMap<>();
	@Test
	@DisabledOnOs(OS.WINDOWS)
	void resolveWhenDockerHostIsNullReturnsLinuxDefault() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-default-context/config.json'));
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get, null);
		assertThat(dockerHost.getAddress()).isEqualTo('/var/run/docker.sock');
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	@EnabledOnOs(OS.WINDOWS)
	void resolveWhenDockerHostIsNullReturnsWindowsDefault() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-default-context/config.json'));
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get, null);
		assertThat(dockerHost.getAddress()).isEqualTo('//./pipe/docker_engine');
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	@DisabledOnOs(OS.WINDOWS)
	void resolveWhenDockerHostAddressIsNullReturnsLinuxDefault() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-default-context/config.json'));
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress(null));
		assertThat(dockerHost.getAddress()).isEqualTo('/var/run/docker.sock');
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	void resolveWhenDockerHostAddressIsLocalReturnsAddress(@TempDir Path tempDir) throws IOException {
		String socketFilePath = Files.createTempFile(tempDir, 'remote-transport', null).toAbsolutePath().toString();
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress(socketFilePath));
		assertThat(dockerHost.isLocalFileReference()).isTrue();
		assertThat(dockerHost.isRemote()).isFalse();
		assertThat(dockerHost.getAddress()).isEqualTo(socketFilePath);
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	void resolveWhenDockerHostAddressIsLocalWithSchemeReturnsAddress(@TempDir Path tempDir) throws IOException {
		String socketFilePath = Files.createTempFile(tempDir, 'remote-transport', null).toAbsolutePath().toString();
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress('unix://' + socketFilePath));
		assertThat(dockerHost.isLocalFileReference()).isTrue();
		assertThat(dockerHost.isRemote()).isFalse();
		assertThat(dockerHost.getAddress()).isEqualTo(socketFilePath);
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	void resolveWhenDockerHostAddressIsHttpReturnsAddress() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress('http://docker.example.com'));
		assertThat(dockerHost.isLocalFileReference()).isFalse();
		assertThat(dockerHost.isRemote()).isTrue();
		assertThat(dockerHost.getAddress()).isEqualTo('http://docker.example.com');
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	void resolveWhenDockerHostAddressIsHttpsReturnsAddress() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress('https://docker.example.com', true, '/cert-path'));
		assertThat(dockerHost.isLocalFileReference()).isFalse();
		assertThat(dockerHost.isRemote()).isTrue();
		assertThat(dockerHost.getAddress()).isEqualTo('https://docker.example.com');
		assertThat(dockerHost.isSecure()).isTrue();
		assertThat(dockerHost.getCertificatePath()).isEqualTo('/cert-path');
	}
	@Test
	void resolveWhenDockerHostAddressIsTcpReturnsAddress() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress('tcp://192.168.99.100:2376', true, '/cert-path'));
		assertThat(dockerHost.isLocalFileReference()).isFalse();
		assertThat(dockerHost.isRemote()).isTrue();
		assertThat(dockerHost.getAddress()).isEqualTo('tcp://192.168.99.100:2376');
		assertThat(dockerHost.isSecure()).isTrue();
		assertThat(dockerHost.getCertificatePath()).isEqualTo('/cert-path');
	}
	@Test
	void resolveWhenEnvironmentAddressIsLocalReturnsAddress(@TempDir Path tempDir) throws IOException {
		String socketFilePath = Files.createTempFile(tempDir, 'remote-transport', null).toAbsolutePath().toString();
		this.environment.put('DOCKER_HOST', socketFilePath);
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress('/unused'));
		assertThat(dockerHost.isLocalFileReference()).isTrue();
		assertThat(dockerHost.isRemote()).isFalse();
		assertThat(dockerHost.getAddress()).isEqualTo(socketFilePath);
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	void resolveWhenEnvironmentAddressIsLocalWithSchemeReturnsAddress(@TempDir Path tempDir) throws IOException {
		String socketFilePath = Files.createTempFile(tempDir, 'remote-transport', null).toAbsolutePath().toString();
		this.environment.put('DOCKER_HOST', 'unix://' + socketFilePath);
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress('/unused'));
		assertThat(dockerHost.isLocalFileReference()).isTrue();
		assertThat(dockerHost.isRemote()).isFalse();
		assertThat(dockerHost.getAddress()).isEqualTo(socketFilePath);
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	void resolveWhenEnvironmentAddressIsTcpReturnsAddress() {
		this.environment.put('DOCKER_HOST', 'tcp://192.168.99.100:2376');
		this.environment.put('DOCKER_TLS_VERIFY', '1');
		this.environment.put('DOCKER_CERT_PATH', '/cert-path');
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forAddress('tcp://1.1.1.1'));
		assertThat(dockerHost.isLocalFileReference()).isFalse();
		assertThat(dockerHost.isRemote()).isTrue();
		assertThat(dockerHost.getAddress()).isEqualTo('tcp://192.168.99.100:2376');
		assertThat(dockerHost.isSecure()).isTrue();
		assertThat(dockerHost.getCertificatePath()).isEqualTo('/cert-path');
	}
	@Test
	void resolveWithDockerHostContextReturnsAddress() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-default-context/config.json'));
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get,
				DockerHostConfiguration.forContext('test-context'));
		assertThat(dockerHost.getAddress()).isEqualTo('/home/user/.docker/docker.sock');
		assertThat(dockerHost.isSecure()).isTrue();
		assertThat(dockerHost.getCertificatePath()).isNotNull();
	}
	@Test
	void resolveWithDockerConfigMetadataContextReturnsAddress() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-context/config.json'));
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get, null);
		assertThat(dockerHost.getAddress()).isEqualTo('/home/user/.docker/docker.sock');
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	@Test
	void resolveWhenEnvironmentHasAddressAndContextPrefersContext() throws Exception {
		this.environment.put('DOCKER_CONFIG', pathToResource('with-context/config.json'));
		this.environment.put('DOCKER_CONTEXT', 'test-context');
		this.environment.put('DOCKER_HOST', 'notused');
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(this.environment::get, null);
		assertThat(dockerHost.getAddress()).isEqualTo('/home/user/.docker/docker.sock');
		assertThat(dockerHost.isSecure()).isFalse();
		assertThat(dockerHost.getCertificatePath()).isNull();
	}
	private String pathToResource(String resource) throws URISyntaxException {
		URL url = getClass().getResource(resource);
		return Paths.get(url.toURI()).getParent().toAbsolutePath().toString();
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
@ExtendWith(MockitoExtension.class)
class DockerApiTests {
	private static final String API_URL = '/v' + DockerApi.MINIMUM_API_VERSION;
	public static final String PING_URL = '/_ping';
	private static final String IMAGES_URL = API_URL + '/images';
	private static final String IMAGES_1_41_URL = '/v' + ApiVersion.of(1, 41) + '/images';
	private static final String CONTAINERS_URL = API_URL + '/containers';
	private static final String CONTAINERS_1_41_URL = '/v' + ApiVersion.of(1, 41) + '/containers';
	private static final String VOLUMES_URL = API_URL + '/volumes';
	@Mock
	private HttpTransport http;
	private DockerApi dockerApi;
	@BeforeEach
	void setup() {
		this.dockerApi = new DockerApi(this.http);
	}
	private HttpTransport http() {
		return this.http;
	}
	private Response emptyResponse() {
		return responseOf(null);
	}
	private Response responseOf(String name) {
		return new Response() {
			@Override
			public void close() {
			}
			@Override
			public InputStream getContent() {
				if (name == null) {
					return null;
				}
				return getClass().getResourceAsStream(name);
			}
		};
	}
	private Response responseWithHeaders(Header... headers) {
		return new Response() {
			@Override
			public InputStream getContent() {
				return null;
			}
			@Override
			public Header getHeader(String name) {
				return Arrays.stream(headers)
					.filter((header) -> header.getName().equals(name))
					.findFirst()
					.orElse(null);
			}
			@Override
			public void close() {
			}
		};
	}
	@Test
	void createDockerApi() {
		DockerApi api = new DockerApi();
		assertThat(api).isNotNull();
	}
	@Nested
	class ImageDockerApiTests {
		private ImageApi api;
		@Mock
		private UpdateListener<PullImageUpdateEvent> pullListener;
		@Mock
		private UpdateListener<PushImageUpdateEvent> pushListener;
		@Mock
		private UpdateListener<LoadImageUpdateEvent> loadListener;
		@Captor
		private ArgumentCaptor<IOConsumer<OutputStream>> writer;
		@BeforeEach
		void setup() {
			this.api = DockerApiTests.this.dockerApi.image();
		}
		@Test
		void pullWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.pull(null, null, this.pullListener))
				.withMessage('Reference must not be null');
		}
		@Test
		void pullWhenListenerIsNullThrowsException() {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> this.api.pull(ImageReference.of('ubuntu'), null, null))
				.withMessage('Listener must not be null');
		}
		@Test
		void pullPullsImageAndProducesEvents() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			URI createUri = new URI(IMAGES_URL + '/create?fromImage=gcr.io%2Fpaketo-buildpacks%2Fbuilder%3Abase');
			URI imageUri = new URI(IMAGES_URL + '/gcr.io/paketo-buildpacks/builder:base/json');
			given(http().post(eq(createUri), isNull())).willReturn(responseOf('pull-stream.json'));
			given(http().get(imageUri)).willReturn(responseOf('type/image.json'));
			Image image = this.api.pull(reference, null, this.pullListener);
			assertThat(image.getLayers()).hasSize(46);
			InOrder ordered = inOrder(this.pullListener);
			ordered.verify(this.pullListener).onStart();
			ordered.verify(this.pullListener, times(595)).onUpdate(any());
			ordered.verify(this.pullListener).onFinish();
		}
		@Test
		void pullWithRegistryAuthPullsImageAndProducesEvents() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			URI createUri = new URI(IMAGES_URL + '/create?fromImage=gcr.io%2Fpaketo-buildpacks%2Fbuilder%3Abase');
			URI imageUri = new URI(IMAGES_URL + '/gcr.io/paketo-buildpacks/builder:base/json');
			given(http().post(eq(createUri), eq('auth token'))).willReturn(responseOf('pull-stream.json'));
			given(http().get(imageUri)).willReturn(responseOf('type/image.json'));
			Image image = this.api.pull(reference, null, this.pullListener, 'auth token');
			assertThat(image.getLayers()).hasSize(46);
			InOrder ordered = inOrder(this.pullListener);
			ordered.verify(this.pullListener).onStart();
			ordered.verify(this.pullListener, times(595)).onUpdate(any());
			ordered.verify(this.pullListener).onFinish();
		}
		@Test
		void pullWithPlatformPullsImageAndProducesEvents() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			ImagePlatform platform = ImagePlatform.of('linux/arm64/v1');
			URI createUri = new URI(IMAGES_1_41_URL
					+ '/create?fromImage=gcr.io%2Fpaketo-buildpacks%2Fbuilder%3Abase&platform=linux%2Farm64%2Fv1');
			URI imageUri = new URI(IMAGES_1_41_URL + '/gcr.io/paketo-buildpacks/builder:base/json');
			given(http().head(eq(new URI(PING_URL))))
				.willReturn(responseWithHeaders(new BasicHeader(DockerApi.API_VERSION_HEADER_NAME, '1.41')));
			given(http().post(eq(createUri), isNull())).willReturn(responseOf('pull-stream.json'));
			given(http().get(imageUri)).willReturn(responseOf('type/image.json'));
			Image image = this.api.pull(reference, platform, this.pullListener);
			assertThat(image.getLayers()).hasSize(46);
			InOrder ordered = inOrder(this.pullListener);
			ordered.verify(this.pullListener).onStart();
			ordered.verify(this.pullListener, times(595)).onUpdate(any());
			ordered.verify(this.pullListener).onFinish();
		}
		@Test
		void pullWithPlatformAndInsufficientApiVersionThrowsException() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			ImagePlatform platform = ImagePlatform.of('linux/arm64/v1');
			given(http().head(eq(new URI(PING_URL)))).willReturn(responseWithHeaders(
					new BasicHeader(DockerApi.API_VERSION_HEADER_NAME, DockerApi.MINIMUM_API_VERSION)));
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.pull(reference, platform, this.pullListener))
				.withMessageContaining('must be at least 1.41')
				.withMessageContaining('current API version is 1.24');
		}
		@Test
		void pushWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.push(null, this.pushListener, null))
				.withMessage('Reference must not be null');
		}
		@Test
		void pushWhenListenerIsNullThrowsException() {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> this.api.push(ImageReference.of('ubuntu'), null, null))
				.withMessage('Listener must not be null');
		}
		@Test
		void pushPushesImageAndProducesEvents() throws Exception {
			ImageReference reference = ImageReference.of('localhost:5000/ubuntu');
			URI pushUri = new URI(IMAGES_URL + '/localhost:5000/ubuntu/push');
			given(http().post(pushUri, 'auth token')).willReturn(responseOf('push-stream.json'));
			this.api.push(reference, this.pushListener, 'auth token');
			InOrder ordered = inOrder(this.pushListener);
			ordered.verify(this.pushListener).onStart();
			ordered.verify(this.pushListener, times(44)).onUpdate(any());
			ordered.verify(this.pushListener).onFinish();
		}
		@Test
		void pushWithErrorInStreamThrowsException() throws Exception {
			ImageReference reference = ImageReference.of('localhost:5000/ubuntu');
			URI pushUri = new URI(IMAGES_URL + '/localhost:5000/ubuntu/push');
			given(http().post(pushUri, 'auth token')).willReturn(responseOf('push-stream-with-error.json'));
			assertThatIllegalStateException()
				.isThrownBy(() -> this.api.push(reference, this.pushListener, 'auth token'))
				.withMessageContaining('test message');
		}
		@Test
		void loadWhenArchiveIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.load(null, UpdateListener.none()))
				.withMessage('Archive must not be null');
		}
		@Test
		void loadWhenListenerIsNullThrowsException() {
			ImageArchive archive = mock(ImageArchive.class);
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.load(archive, null))
				.withMessage('Listener must not be null');
		}
		@Test // gh-23130
		void loadWithEmptyResponseThrowsException() throws Exception {
			Image image = Image.of(getClass().getResourceAsStream('type/image.json'));
			ImageArchive archive = ImageArchive.from(image);
			URI loadUri = new URI(IMAGES_URL + '/load');
			given(http().post(eq(loadUri), eq('application/x-tar'), any())).willReturn(emptyResponse());
			assertThatIllegalStateException().isThrownBy(() -> this.api.load(archive, this.loadListener))
				.withMessageContaining('Invalid response received');
		}
		@Test
		void loadLoadsImage() throws Exception {
			Image image = Image.of(getClass().getResourceAsStream('type/image.json'));
			ImageArchive archive = ImageArchive.from(image);
			URI loadUri = new URI(IMAGES_URL + '/load');
			given(http().post(eq(loadUri), eq('application/x-tar'), any())).willReturn(responseOf('load-stream.json'));
			this.api.load(archive, this.loadListener);
			InOrder ordered = inOrder(this.loadListener);
			ordered.verify(this.loadListener).onStart();
			ordered.verify(this.loadListener).onUpdate(any());
			ordered.verify(this.loadListener).onFinish();
			then(http()).should().post(any(), any(), this.writer.capture());
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			this.writer.getValue().accept(out);
			assertThat(out.toByteArray()).hasSizeGreaterThan(21000);
		}
		@Test
		void removeWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.remove(null, true))
				.withMessage('Reference must not be null');
		}
		@Test
		void removeRemovesContainer() throws Exception {
			ImageReference reference = ImageReference
				.of('ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
			URI removeUri = new URI(IMAGES_URL
					+ '/docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
			given(http().delete(removeUri)).willReturn(emptyResponse());
			this.api.remove(reference, false);
			then(http()).should().delete(removeUri);
		}
		@Test
		void removeWhenForceIsTrueRemovesContainer() throws Exception {
			ImageReference reference = ImageReference
				.of('ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
			URI removeUri = new URI(IMAGES_URL
					+ '/docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d?force=1');
			given(http().delete(removeUri)).willReturn(emptyResponse());
			this.api.remove(reference, true);
			then(http()).should().delete(removeUri);
		}
		@Test
		void inspectWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.inspect(null))
				.withMessage('Reference must not be null');
		}
		@Test
		void inspectInspectImage() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			URI imageUri = new URI(IMAGES_URL + '/gcr.io/paketo-buildpacks/builder:base/json');
			given(http().get(imageUri)).willReturn(responseOf('type/image.json'));
			Image image = this.api.inspect(reference);
			assertThat(image.getLayers()).hasSize(46);
		}
		@Test
		@SuppressWarnings('removal')
		void exportLayersWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.exportLayerFiles(null, (name, archive) -> {
			})).withMessage('Reference must not be null');
		}
		@Test
		@SuppressWarnings('removal')
		void exportLayersWhenExportsIsNullThrowsException() {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.exportLayerFiles(reference, null))
				.withMessage('Exports must not be null');
		}
		@Test
		void exportLayersExportsLayerTars() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			URI exportUri = new URI(IMAGES_URL + '/gcr.io/paketo-buildpacks/builder:base/get');
			given(DockerApiTests.this.http.get(exportUri)).willReturn(responseOf('export.tar'));
			MultiValueMap<String, String> contents = new LinkedMultiValueMap<>();
			this.api.exportLayers(reference, (name, archive) -> {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				archive.writeTo(out);
				try (TarArchiveInputStream in = new TarArchiveInputStream(
						new ByteArrayInputStream(out.toByteArray()))) {
					TarArchiveEntry entry = in.getNextEntry();
					while (entry != null) {
						contents.add(name, entry.getName());
						entry = in.getNextEntry();
					}
				}
			});
			assertThat(contents).hasSize(3)
				.containsKeys('70bb7a3115f3d5c01099852112c7e05bf593789e510468edb06b6a9a11fa3b73/layer.tar',
						'74a9a50ece13c025cf10e9110d9ddc86c995079c34e2a22a28d1a3d523222c6e/layer.tar',
						'a69532b5b92bb891fbd9fa1a6b3af9087ea7050255f59ba61a796f8555ecd783/layer.tar');
			assertThat(contents.get('70bb7a3115f3d5c01099852112c7e05bf593789e510468edb06b6a9a11fa3b73/layer.tar'))
				.containsExactly('/cnb/order.toml');
			assertThat(contents.get('74a9a50ece13c025cf10e9110d9ddc86c995079c34e2a22a28d1a3d523222c6e/layer.tar'))
				.containsExactly('/cnb/stack.toml');
		}
		@Test
		void exportLayersWithSymlinksExportsLayerTars() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			URI exportUri = new URI(IMAGES_URL + '/gcr.io/paketo-buildpacks/builder:base/get');
			given(DockerApiTests.this.http.get(exportUri)).willReturn(responseOf('export-symlinks.tar'));
			MultiValueMap<String, String> contents = new LinkedMultiValueMap<>();
			this.api.exportLayers(reference, (name, archive) -> {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				archive.writeTo(out);
				try (TarArchiveInputStream in = new TarArchiveInputStream(
						new ByteArrayInputStream(out.toByteArray()))) {
					TarArchiveEntry entry = in.getNextEntry();
					while (entry != null) {
						contents.add(name, entry.getName());
						entry = in.getNextEntry();
					}
				}
			});
			assertThat(contents).hasSize(3)
				.containsKeys('6aa3691a73805f608e5fce69fb6bc89aec8362f58a6b4be2682515e9cfa3cc1a.tar',
						'762e198f655bc2580ef3e56b538810fd2b9981bd707f8a44c70344b58f9aee68.tar',
						'd3cc975ad97fdfbb73d9daf157e7f658d6117249fd9c237e3856ad173c87e1d2.tar');
			assertThat(contents.get('d3cc975ad97fdfbb73d9daf157e7f658d6117249fd9c237e3856ad173c87e1d2.tar'))
				.containsExactly('/cnb/order.toml');
			assertThat(contents.get('762e198f655bc2580ef3e56b538810fd2b9981bd707f8a44c70344b58f9aee68.tar'))
				.containsExactly('/cnb/stack.toml');
		}
		@Test
		@SuppressWarnings('removal')
		void exportLayerFilesDeletesTempFiles() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			URI exportUri = new URI(IMAGES_URL + '/gcr.io/paketo-buildpacks/builder:base/get');
			given(DockerApiTests.this.http.get(exportUri)).willReturn(responseOf('export.tar'));
			List<Path> layerFilePaths = new ArrayList<>();
			this.api.exportLayerFiles(reference, (name, path) -> layerFilePaths.add(path));
			layerFilePaths.forEach((path) -> assertThat(path.toFile()).doesNotExist());
		}
		@Test
		@SuppressWarnings('removal')
		void exportLayersWithNoManifestThrowsException() throws Exception {
			ImageReference reference = ImageReference.of('gcr.io/paketo-buildpacks/builder:base');
			URI exportUri = new URI(IMAGES_URL + '/gcr.io/paketo-buildpacks/builder:base/get');
			given(DockerApiTests.this.http.get(exportUri)).willReturn(responseOf('export-no-manifest.tar'));
			String expectedMessage = 'Exported image "%s" does not contain "index.json" or "manifest.json"'
				.formatted(reference);
			assertThatIllegalStateException().isThrownBy(() -> this.api.exportLayerFiles(reference, (name, archive) -> {
			})).withMessageContaining(expectedMessage);
		}
		@Test
		void tagWhenReferenceIsNullThrowsException() {
			ImageReference tag = ImageReference.of('localhost:5000/ubuntu');
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.tag(null, tag))
				.withMessage('SourceReference must not be null');
		}
		@Test
		void tagWhenTargetIsNullThrowsException() {
			ImageReference reference = ImageReference.of('localhost:5000/ubuntu');
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.tag(reference, null))
				.withMessage('TargetReference must not be null');
		}
		@Test
		void tagTagsImage() throws Exception {
			ImageReference sourceReference = ImageReference.of('localhost:5000/ubuntu');
			ImageReference targetReference = ImageReference.of('localhost:5000/ubuntu:tagged');
			URI tagURI = new URI(IMAGES_URL + '/localhost:5000/ubuntu/tag?repo=localhost%3A5000%2Fubuntu&tag=tagged');
			given(http().post(tagURI)).willReturn(emptyResponse());
			this.api.tag(sourceReference, targetReference);
			then(http()).should().post(tagURI);
		}
		@Test
		void tagRenamesImage() throws Exception {
			ImageReference sourceReference = ImageReference.of('localhost:5000/ubuntu');
			ImageReference targetReference = ImageReference.of('localhost:5000/ubuntu-2');
			URI tagURI = new URI(IMAGES_URL + '/localhost:5000/ubuntu/tag?repo=localhost%3A5000%2Fubuntu-2');
			given(http().post(tagURI)).willReturn(emptyResponse());
			this.api.tag(sourceReference, targetReference);
			then(http()).should().post(tagURI);
		}
	}
	@Nested
	class ContainerDockerApiTests {
		private ContainerApi api;
		@Captor
		private ArgumentCaptor<IOConsumer<OutputStream>> writer;
		@Mock
		private UpdateListener<LogUpdateEvent> logListener;
		@BeforeEach
		void setup() {
			this.api = DockerApiTests.this.dockerApi.container();
		}
		@Test
		void createWhenConfigIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.create(null, null))
				.withMessage('Config must not be null');
		}
		@Test
		void createCreatesContainer() throws Exception {
			ImageReference imageReference = ImageReference.of('ubuntu:bionic');
			ContainerConfig config = ContainerConfig.of(imageReference, (update) -> update.withCommand('/bin/bash'));
			URI createUri = new URI(CONTAINERS_URL + '/create');
			given(http().post(eq(createUri), eq('application/json'), any()))
				.willReturn(responseOf('create-container-response.json'));
			ContainerReference containerReference = this.api.create(config, null);
			assertThat(containerReference).hasToString('e90e34656806');
			then(http()).should().post(any(), any(), this.writer.capture());
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			this.writer.getValue().accept(out);
			assertThat(out.toByteArray()).hasSize(config.toString().length());
		}
		@Test
		void createWhenHasContentContainerWithContent() throws Exception {
			ImageReference imageReference = ImageReference.of('ubuntu:bionic');
			ContainerConfig config = ContainerConfig.of(imageReference, (update) -> update.withCommand('/bin/bash'));
			TarArchive archive = TarArchive.of((layout) -> {
				layout.directory('/test', Owner.ROOT);
				layout.file('/test/file', Owner.ROOT, Content.of('test'));
			});
			ContainerContent content = ContainerContent.of(archive);
			URI createUri = new URI(CONTAINERS_URL + '/create');
			given(http().post(eq(createUri), eq('application/json'), any()))
				.willReturn(responseOf('create-container-response.json'));
			URI uploadUri = new URI(CONTAINERS_URL + '/e90e34656806/archive?path=%2F');
			given(http().put(eq(uploadUri), eq('application/x-tar'), any())).willReturn(emptyResponse());
			ContainerReference containerReference = this.api.create(config, null, content);
			assertThat(containerReference).hasToString('e90e34656806');
			then(http()).should().post(any(), any(), this.writer.capture());
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			this.writer.getValue().accept(out);
			assertThat(out.toByteArray()).hasSize(config.toString().length());
			then(http()).should().put(any(), any(), this.writer.capture());
			this.writer.getValue().accept(out);
			assertThat(out.toByteArray()).hasSizeGreaterThan(2000);
		}
		@Test
		void createWithPlatformCreatesContainer() throws Exception {
			ImageReference imageReference = ImageReference.of('ubuntu:bionic');
			ContainerConfig config = ContainerConfig.of(imageReference, (update) -> update.withCommand('/bin/bash'));
			ImagePlatform platform = ImagePlatform.of('linux/arm64/v1');
			given(http().head(eq(new URI(PING_URL))))
				.willReturn(responseWithHeaders(new BasicHeader(DockerApi.API_VERSION_HEADER_NAME, '1.41')));
			URI createUri = new URI(CONTAINERS_1_41_URL + '/create?platform=linux%2Farm64%2Fv1');
			given(http().post(eq(createUri), eq('application/json'), any()))
				.willReturn(responseOf('create-container-response.json'));
			ContainerReference containerReference = this.api.create(config, platform);
			assertThat(containerReference).hasToString('e90e34656806');
			then(http()).should().post(any(), any(), this.writer.capture());
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			this.writer.getValue().accept(out);
			assertThat(out.toByteArray()).hasSize(config.toString().length());
		}
		@Test
		void createWithPlatformAndInsufficientApiVersionThrowsException() throws Exception {
			ImageReference imageReference = ImageReference.of('ubuntu:bionic');
			ContainerConfig config = ContainerConfig.of(imageReference, (update) -> update.withCommand('/bin/bash'));
			ImagePlatform platform = ImagePlatform.of('linux/arm64/v1');
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.create(config, platform))
				.withMessageContaining('must be at least 1.41')
				.withMessageContaining('current API version is 1.24');
		}
		@Test
		void startWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.start(null))
				.withMessage('Reference must not be null');
		}
		@Test
		void startStartsContainer() throws Exception {
			ContainerReference reference = ContainerReference.of('e90e34656806');
			URI startContainerUri = new URI(CONTAINERS_URL + '/e90e34656806/start');
			given(http().post(startContainerUri)).willReturn(emptyResponse());
			this.api.start(reference);
			then(http()).should().post(startContainerUri);
		}
		@Test
		void logsWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.logs(null, UpdateListener.none()))
				.withMessage('Reference must not be null');
		}
		@Test
		void logsWhenListenerIsNullThrowsException() {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> this.api.logs(ContainerReference.of('e90e34656806'), null))
				.withMessage('Listener must not be null');
		}
		@Test
		void logsProducesEvents() throws Exception {
			ContainerReference reference = ContainerReference.of('e90e34656806');
			URI logsUri = new URI(CONTAINERS_URL + '/e90e34656806/logs?stdout=1&stderr=1&follow=1');
			given(http().get(logsUri)).willReturn(responseOf('log-update-event.stream'));
			this.api.logs(reference, this.logListener);
			InOrder ordered = inOrder(this.logListener);
			ordered.verify(this.logListener).onStart();
			ordered.verify(this.logListener, times(7)).onUpdate(any());
			ordered.verify(this.logListener).onFinish();
		}
		@Test
		void waitWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.wait(null))
				.withMessage('Reference must not be null');
		}
		@Test
		void waitReturnsStatus() throws Exception {
			ContainerReference reference = ContainerReference.of('e90e34656806');
			URI waitUri = new URI(CONTAINERS_URL + '/e90e34656806/wait');
			given(http().post(waitUri)).willReturn(responseOf('container-wait-response.json'));
			ContainerStatus status = this.api.wait(reference);
			assertThat(status.getStatusCode()).isOne();
		}
		@Test
		void removeWhenReferenceIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.remove(null, true))
				.withMessage('Reference must not be null');
		}
		@Test
		void removeRemovesContainer() throws Exception {
			ContainerReference reference = ContainerReference.of('e90e34656806');
			URI removeUri = new URI(CONTAINERS_URL + '/e90e34656806');
			given(http().delete(removeUri)).willReturn(emptyResponse());
			this.api.remove(reference, false);
			then(http()).should().delete(removeUri);
		}
		@Test
		void removeWhenForceIsTrueRemovesContainer() throws Exception {
			ContainerReference reference = ContainerReference.of('e90e34656806');
			URI removeUri = new URI(CONTAINERS_URL + '/e90e34656806?force=1');
			given(http().delete(removeUri)).willReturn(emptyResponse());
			this.api.remove(reference, true);
			then(http()).should().delete(removeUri);
		}
	}
	@Nested
	class VolumeDockerApiTests {
		private VolumeApi api;
		@BeforeEach
		void setup() {
			this.api = DockerApiTests.this.dockerApi.volume();
		}
		@Test
		void deleteWhenNameIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> this.api.delete(null, false))
				.withMessage('Name must not be null');
		}
		@Test
		void deleteDeletesContainer() throws Exception {
			VolumeName name = VolumeName.of('test');
			URI removeUri = new URI(VOLUMES_URL + '/test');
			given(http().delete(removeUri)).willReturn(emptyResponse());
			this.api.delete(name, false);
			then(http()).should().delete(removeUri);
		}
		@Test
		void deleteWhenForceIsTrueDeletesContainer() throws Exception {
			VolumeName name = VolumeName.of('test');
			URI removeUri = new URI(VOLUMES_URL + '/test?force=1');
			given(http().delete(removeUri)).willReturn(emptyResponse());
			this.api.delete(name, true);
			then(http()).should().delete(removeUri);
		}
	}
	@Nested
	class SystemDockerApiTests {
		private SystemApi api;
		@BeforeEach
		void setup() {
			this.api = DockerApiTests.this.dockerApi.system();
		}
		@Test
		void getApiVersionWithVersionHeaderReturnsVersion() throws Exception {
			given(http().head(eq(new URI(PING_URL))))
				.willReturn(responseWithHeaders(new BasicHeader(DockerApi.API_VERSION_HEADER_NAME, '1.44')));
			assertThat(this.api.getApiVersion()).isEqualTo(ApiVersion.of(1, 44));
		}
		@Test
		void getApiVersionWithEmptyVersionHeaderReturnsDefaultVersion() throws Exception {
			given(http().head(eq(new URI(PING_URL))))
				.willReturn(responseWithHeaders(new BasicHeader(DockerApi.API_VERSION_HEADER_NAME, '')));
			assertThat(this.api.getApiVersion()).isEqualTo(DockerApi.MINIMUM_API_VERSION);
		}
		@Test
		void getApiVersionWithNoVersionHeaderReturnsDefaultVersion() throws Exception {
			given(http().head(eq(new URI(PING_URL)))).willReturn(emptyResponse());
			assertThat(this.api.getApiVersion()).isEqualTo(DockerApi.MINIMUM_API_VERSION);
		}
		@Test
		void getApiVersionWithExceptionReturnsDefaultVersion() throws Exception {
			given(http().head(eq(new URI(PING_URL)))).willThrow(new IOException('simulated error'));
			assertThat(this.api.getApiVersion()).isEqualTo(DockerApi.MINIMUM_API_VERSION);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class LogUpdateEventTests {
	@Test
	void readAllWhenSimpleStreamReturnsEvents() throws Exception {
		List<LogUpdateEvent> events = readAll('log-update-event.stream');
		assertThat(events).hasSize(7);
		assertThat(events.get(0))
			.hasToString('Analyzing image "307c032c4ceaa6330b6c02af945a1fe56a8c3c27c28268574b217c1d38b093cf"');
		assertThat(events.get(1))
			.hasToString('Writing metadata for uncached layer "org.cloudfoundry.openjdk:openjdk-jre"');
		assertThat(events.get(2))
			.hasToString('Using cached launch layer "org.cloudfoundry.jvmapplication:executable-jar"');
	}
	@Test
	void readAllWhenAnsiStreamReturnsEvents() throws Exception {
		List<LogUpdateEvent> events = readAll('log-update-event-ansi.stream');
		assertThat(events).hasSize(20);
		assertThat(events.get(0).toString()).isEmpty();
		assertThat(events.get(1)).hasToString('Cloud Foundry OpenJDK Buildpack v1.0.64');
		assertThat(events.get(2)).hasToString('  OpenJDK JRE 11.0.5: Reusing cached layer');
	}
	@Test
	void readSucceedsWhenStreamTypeIsInvalid() throws IOException {
		List<LogUpdateEvent> events = readAll('log-update-event-invalid-stream-type.stream');
		assertThat(events).hasSize(1);
		assertThat(events.get(0)).hasToString('Stream type is out of bounds. Must be >= 0 and < 3, but was 3');
	}
	private List<LogUpdateEvent> readAll(String name) throws IOException {
		List<LogUpdateEvent> events = new ArrayList<>();
		try (InputStream inputStream = getClass().getResourceAsStream(name)) {
			LogUpdateEvent.readAll(inputStream, events::add);
		}
		return events;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
class RemoteHttpClientTransportTests {
	@Test
	void createIfPossibleWhenDockerHostIsNotSetReturnsNull() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(null);
		RemoteHttpClientTransport transport = RemoteHttpClientTransport.createIfPossible(dockerHost);
		assertThat(transport).isNull();
	}
	@Test
	void createIfPossibleWhenDockerHostIsDefaultReturnsNull() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(DockerHostConfiguration.forAddress(null));
		RemoteHttpClientTransport transport = RemoteHttpClientTransport.createIfPossible(dockerHost);
		assertThat(transport).isNull();
	}
	@Test
	void createIfPossibleWhenDockerHostIsFileReturnsNull() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost
			.from(DockerHostConfiguration.forAddress('unix:///var/run/socket.sock'));
		RemoteHttpClientTransport transport = RemoteHttpClientTransport.createIfPossible(dockerHost);
		assertThat(transport).isNull();
	}
	@Test
	void createIfPossibleWhenDockerHostIsAddressReturnsTransport() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost
			.from(DockerHostConfiguration.forAddress('tcp://192.168.1.2:2376'));
		RemoteHttpClientTransport transport = RemoteHttpClientTransport.createIfPossible(dockerHost);
		assertThat(transport).isNotNull();
	}
	@Test
	void createIfPossibleWhenNoTlsVerifyUsesHttp() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost
			.from(DockerHostConfiguration.forAddress('tcp://192.168.1.2:2376'));
		RemoteHttpClientTransport transport = RemoteHttpClientTransport.createIfPossible(dockerHost);
		assertThat(transport.getHost()).satisfies(hostOf('http', '192.168.1.2', 2376));
	}
	@Test
	void createIfPossibleWhenTlsVerifyUsesHttps() throws Exception {
		SslContextFactory sslContextFactory = mock(SslContextFactory.class);
		given(sslContextFactory.forDirectory('/test-cert-path')).willReturn(SSLContext.getDefault());
		ResolvedDockerHost dockerHost = ResolvedDockerHost
			.from(DockerHostConfiguration.forAddress('tcp://192.168.1.2:2376', true, '/test-cert-path'));
		RemoteHttpClientTransport transport = RemoteHttpClientTransport.createIfPossible(dockerHost, sslContextFactory);
		assertThat(transport.getHost()).satisfies(hostOf('https', '192.168.1.2', 2376));
	}
	@Test
	void createIfPossibleWhenTlsVerifyWithMissingCertPathThrowsException() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost
			.from(DockerHostConfiguration.forAddress('tcp://192.168.1.2:2376', true, null));
		assertThatIllegalArgumentException().isThrownBy(() -> RemoteHttpClientTransport.createIfPossible(dockerHost))
			.withMessageContaining('Docker host TLS verification requires trust material');
	}
	private Consumer<HttpHost> hostOf(String scheme, String hostName, int port) {
		return (host) -> {
			assertThat(host).isNotNull();
			assertThat(host.getSchemeName()).isEqualTo(scheme);
			assertThat(host.getHostName()).isEqualTo(hostName);
			assertThat(host.getPort()).isEqualTo(port);
		};
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
class ErrorsTests extends AbstractJsonTests {
	@Test
	void readValueDeserializesJson() throws Exception {
		Errors errors = getObjectMapper().readValue(getContent('errors.json'), Errors.class);
		Iterator<Error> iterator = errors.iterator();
		Error error1 = iterator.next();
		Error error2 = iterator.next();
		assertThat(iterator.hasNext()).isFalse();
		assertThat(error1.getCode()).isEqualTo('TEST1');
		assertThat(error1.getMessage()).isEqualTo('Test One');
		assertThat(error2.getCode()).isEqualTo('TEST2');
		assertThat(error2.getMessage()).isEqualTo('Test Two');
	}
	@Test
	void toStringHasErrorDetails() throws Exception {
		Errors errors = getObjectMapper().readValue(getContent('errors.json'), Errors.class);
		assertThat(errors).hasToString('[TEST1: Test One, TEST2: Test Two]');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
class LocalHttpClientTransportTests {
	@Test
	void createWhenDockerHostIsFileReturnsTransport(@TempDir Path tempDir) throws IOException {
		String socketFilePath = Files.createTempFile(tempDir, 'remote-transport', null).toAbsolutePath().toString();
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(DockerHostConfiguration.forAddress(socketFilePath));
		LocalHttpClientTransport transport = LocalHttpClientTransport.create(dockerHost);
		assertThat(transport).isNotNull();
		assertThat(transport.getHost().toHostString()).isEqualTo(socketFilePath);
	}
	@Test
	void createWhenDockerHostIsFileThatDoesNotExistReturnsTransport(@TempDir Path tempDir) {
		String socketFilePath = Paths.get(tempDir.toString(), 'dummy').toAbsolutePath().toString();
		ResolvedDockerHost dockerHost = ResolvedDockerHost.from(DockerHostConfiguration.forAddress(socketFilePath));
		LocalHttpClientTransport transport = LocalHttpClientTransport.create(dockerHost);
		assertThat(transport).isNotNull();
		assertThat(transport.getHost().toHostString()).isEqualTo(socketFilePath);
	}
	@Test
	void createWhenDockerHostIsAddressReturnsTransport() {
		ResolvedDockerHost dockerHost = ResolvedDockerHost
			.from(DockerHostConfiguration.forAddress('tcp://192.168.1.2:2376'));
		LocalHttpClientTransport transport = LocalHttpClientTransport.create(dockerHost);
		assertThat(transport).isNotNull();
		assertThat(transport.getHost().toHostString()).isEqualTo('tcp://192.168.1.2:2376');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
class DockerEngineExceptionTests {
	private static final String HOST = 'docker://localhost/';
	private static final URI URI;
	static {
		try {
			URI = new URI('example');
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private static final Errors NO_ERRORS = new Errors(Collections.emptyList());
	private static final Errors ERRORS = new Errors(Collections.singletonList(new Errors.Error('code', 'message')));
	private static final Message NO_MESSAGE = new Message(null);
	private static final Message MESSAGE = new Message('response message');
	@Test
	void createWhenHostIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DockerEngineException(null, null, 404, null, NO_ERRORS, NO_MESSAGE))
			.withMessage('Host must not be null');
	}
	@Test
	void createWhenUriIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DockerEngineException(HOST, null, 404, null, NO_ERRORS, NO_MESSAGE))
			.withMessage('URI must not be null');
	}
	@Test
	void create() {
		DockerEngineException exception = new DockerEngineException(HOST, URI, 404, 'missing', ERRORS, MESSAGE);
		assertThat(exception.getMessage()).isEqualTo(
				'Docker API call to "docker://localhost/example" failed with status code 404 \'missing\' and message \'response message\' [code: message]');
		assertThat(exception.getStatusCode()).isEqualTo(404);
		assertThat(exception.getReasonPhrase()).isEqualTo('missing');
		assertThat(exception.getErrors()).isSameAs(ERRORS);
		assertThat(exception.getResponseMessage()).isSameAs(MESSAGE);
	}
	@Test
	void createWhenReasonPhraseIsNull() {
		DockerEngineException exception = new DockerEngineException(HOST, URI, 404, null, ERRORS, MESSAGE);
		assertThat(exception.getMessage()).isEqualTo(
				'Docker API call to "docker://localhost/example" failed with status code 404 and message \'response message\' [code: message]');
		assertThat(exception.getStatusCode()).isEqualTo(404);
		assertThat(exception.getReasonPhrase()).isNull();
		assertThat(exception.getErrors()).isSameAs(ERRORS);
		assertThat(exception.getResponseMessage()).isSameAs(MESSAGE);
	}
	@Test
	void createWhenErrorsIsNull() {
		DockerEngineException exception = new DockerEngineException(HOST, URI, 404, 'missing', null, MESSAGE);
		assertThat(exception.getMessage()).isEqualTo(
				'Docker API call to "docker://localhost/example" failed with status code 404 \'missing\' and message \'response message\'');
		assertThat(exception.getErrors()).isNull();
	}
	@Test
	void createWhenErrorsIsEmpty() {
		DockerEngineException exception = new DockerEngineException(HOST, URI, 404, 'missing', NO_ERRORS, MESSAGE);
		assertThat(exception.getMessage()).isEqualTo(
				'Docker API call to "docker://localhost/example" failed with status code 404 \'missing\' and message \'response message\'');
		assertThat(exception.getStatusCode()).isEqualTo(404);
		assertThat(exception.getReasonPhrase()).isEqualTo('missing');
		assertThat(exception.getErrors()).isSameAs(NO_ERRORS);
	}
	@Test
	void createWhenMessageIsNull() {
		DockerEngineException exception = new DockerEngineException(HOST, URI, 404, 'missing', ERRORS, null);
		assertThat(exception.getMessage()).isEqualTo(
				'Docker API call to "docker://localhost/example" failed with status code 404 \'missing\' [code: message]');
		assertThat(exception.getResponseMessage()).isNull();
	}
	@Test
	void createWhenMessageIsEmpty() {
		DockerEngineException exception = new DockerEngineException(HOST, URI, 404, 'missing', ERRORS, NO_MESSAGE);
		assertThat(exception.getMessage()).isEqualTo(
				'Docker API call to "docker://localhost/example" failed with status code 404 \'missing\' [code: message]');
		assertThat(exception.getResponseMessage()).isSameAs(NO_MESSAGE);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
class MessageTests extends AbstractJsonTests {
	@Test
	void readValueDeserializesJson() throws Exception {
		Message message = getObjectMapper().readValue(getContent('message.json'), Message.class);
		assertThat(message.getMessage()).isEqualTo('test message');
	}
	@Test
	void toStringHasErrorDetails() throws Exception {
		Message errors = getObjectMapper().readValue(getContent('message.json'), Message.class);
		assertThat(errors).hasToString('test message');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
class HttpTransportTests {
	@Test
	void createWhenDockerHostVariableIsAddressReturnsRemote() {
		HttpTransport transport = HttpTransport.create(DockerHostConfiguration.forAddress('tcp://192.168.1.0'));
		assertThat(transport).isInstanceOf(RemoteHttpClientTransport.class);
	}
	@Test
	void createWhenDockerHostVariableIsFileReturnsLocal(@TempDir Path tempDir) throws IOException {
		String dummySocketFilePath = Files.createTempFile(tempDir, 'http-transport', null).toAbsolutePath().toString();
		HttpTransport transport = HttpTransport.create(DockerHostConfiguration.forAddress(dummySocketFilePath));
		assertThat(transport).isInstanceOf(LocalHttpClientTransport.class);
	}
	@Test
	void createWhenDockerHostVariableIsUnixSchemePrefixedFileReturnsLocal(@TempDir Path tempDir) throws IOException {
		String dummySocketFilePath = 'unix://' + Files.createTempFile(tempDir, 'http-transport', null).toAbsolutePath();
		HttpTransport transport = HttpTransport.create(DockerHostConfiguration.forAddress(dummySocketFilePath));
		assertThat(transport).isInstanceOf(LocalHttpClientTransport.class);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
@ExtendWith(MockitoExtension.class)
class HttpClientTransportTests {
	private static final String APPLICATION_JSON = 'application/json';
	private static final String APPLICATION_X_TAR = 'application/x-tar';
	@Mock
	private HttpClient client;
	@Mock
	private ClassicHttpResponse response;
	@Mock
	private HttpEntity entity;
	@Mock
	private InputStream content;
	private HttpClientTransport http;
	private URI uri;
	@BeforeEach
	void setup() throws Exception {
		this.http = new TestHttpClientTransport(this.client);
		this.uri = new URI('example');
	}
	@Test
	void getShouldExecuteHttpGet() throws Exception {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.get(this.uri);
		then(this.client).should().executeOpen(any(HttpHost.class), assertArg((request) -> {
			try {
				assertThat(request).isInstanceOf(HttpGet.class);
				assertThat(request.getUri()).isEqualTo(this.uri);
				assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull();
				assertThat(response.getContent()).isSameAs(this.content);
			}
			catch (Exception ex) {
				throw new RuntimeException(ex);
			}
		}), isNull());
	}
	@Test
	void postShouldExecuteHttpPost() throws Exception {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.post(this.uri);
		then(this.client).should()
			.executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpPost>) (request) -> {
				assertThat(request).isInstanceOf(HttpPost.class);
				assertThat(request.getUri()).isEqualTo(this.uri);
				assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull();
				assertThat(request.getFirstHeader(HttpClientTransport.REGISTRY_AUTH_HEADER)).isNull();
				assertThat(response.getContent()).isSameAs(this.content);
			}), isNull());
	}
	@Test
	void postWithRegistryAuthShouldExecuteHttpPostWithHeader() throws Exception {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.post(this.uri, 'auth token');
		then(this.client).should()
			.executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpPost>) (request) -> {
				assertThat(request).isInstanceOf(HttpPost.class);
				assertThat(request.getUri()).isEqualTo(this.uri);
				assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull();
				assertThat(request.getFirstHeader(HttpClientTransport.REGISTRY_AUTH_HEADER).getValue())
					.isEqualTo('auth token');
				assertThat(response.getContent()).isSameAs(this.content);
			}), isNull());
	}
	@Test
	void postWithEmptyRegistryAuthShouldExecuteHttpPostWithoutHeader() throws Exception {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.post(this.uri, '');
		then(this.client).should()
			.executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpPost>) (request) -> {
				assertThat(request).isInstanceOf(HttpPost.class);
				assertThat(request.getUri()).isEqualTo(this.uri);
				assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull();
				assertThat(request.getFirstHeader(HttpClientTransport.REGISTRY_AUTH_HEADER)).isNull();
				assertThat(response.getContent()).isSameAs(this.content);
			}), isNull());
	}
	@Test
	void postWithJsonContentShouldExecuteHttpPost() throws Exception {
		String content = 'test';
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.post(this.uri, APPLICATION_JSON,
				(out) -> StreamUtils.copy(content, StandardCharsets.UTF_8, out));
		then(this.client).should()
			.executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpPost>) (request) -> {
				HttpEntity entity = request.getEntity();
				assertThat(request).isInstanceOf(HttpPost.class);
				assertThat(request.getUri()).isEqualTo(this.uri);
				assertThat(entity.isRepeatable()).isFalse();
				assertThat(entity.getContentLength()).isEqualTo(content.length());
				assertThat(entity.getContentType()).isEqualTo(APPLICATION_JSON);
				assertThat(entity.isStreaming()).isTrue();
				assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent);
				assertThat(writeToString(entity)).isEqualTo(content);
				assertThat(response.getContent()).isSameAs(this.content);
			}), isNull());
	}
	@Test
	void postWithArchiveContentShouldExecuteHttpPost() throws Exception {
		String content = 'test';
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.post(this.uri, APPLICATION_X_TAR,
				(out) -> StreamUtils.copy(content, StandardCharsets.UTF_8, out));
		then(this.client).should()
			.executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpPost>) (request) -> {
				HttpEntity entity = request.getEntity();
				assertThat(request).isInstanceOf(HttpPost.class);
				assertThat(request.getUri()).isEqualTo(this.uri);
				assertThat(entity.isRepeatable()).isFalse();
				assertThat(entity.getContentLength()).isEqualTo(-1);
				assertThat(entity.getContentType()).isEqualTo(APPLICATION_X_TAR);
				assertThat(entity.isStreaming()).isTrue();
				assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent);
				assertThat(writeToString(entity)).isEqualTo(content);
				assertThat(response.getContent()).isSameAs(this.content);
			}), isNull());
	}
	@Test
	void putWithJsonContentShouldExecuteHttpPut() throws Exception {
		String content = 'test';
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.put(this.uri, APPLICATION_JSON,
				(out) -> StreamUtils.copy(content, StandardCharsets.UTF_8, out));
		then(this.client).should().executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpPut>) (request) -> {
			HttpEntity entity = request.getEntity();
			assertThat(request).isInstanceOf(HttpPut.class);
			assertThat(request.getUri()).isEqualTo(this.uri);
			assertThat(entity.isRepeatable()).isFalse();
			assertThat(entity.getContentLength()).isEqualTo(content.length());
			assertThat(entity.getContentType()).isEqualTo(APPLICATION_JSON);
			assertThat(entity.isStreaming()).isTrue();
			assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent);
			assertThat(writeToString(entity)).isEqualTo(content);
			assertThat(response.getContent()).isSameAs(this.content);
		}), isNull());
	}
	@Test
	void putWithArchiveContentShouldExecuteHttpPut() throws Exception {
		String content = 'test';
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.put(this.uri, APPLICATION_X_TAR,
				(out) -> StreamUtils.copy(content, StandardCharsets.UTF_8, out));
		then(this.client).should().executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpPut>) (request) -> {
			HttpEntity entity = request.getEntity();
			assertThat(request).isInstanceOf(HttpPut.class);
			assertThat(request.getUri()).isEqualTo(this.uri);
			assertThat(entity.isRepeatable()).isFalse();
			assertThat(entity.getContentLength()).isEqualTo(-1);
			assertThat(entity.getContentType()).isEqualTo(APPLICATION_X_TAR);
			assertThat(entity.isStreaming()).isTrue();
			assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent);
			assertThat(writeToString(entity)).isEqualTo(content);
			assertThat(response.getContent()).isSameAs(this.content);
		}), isNull());
	}
	@Test
	void deleteShouldExecuteHttpDelete() throws Exception {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(200);
		Response response = this.http.delete(this.uri);
		then(this.client).should()
			.executeOpen(any(HttpHost.class), assertArg((ThrowingConsumer<HttpDelete>) (request) -> {
				assertThat(request).isInstanceOf(HttpDelete.class);
				assertThat(request.getUri()).isEqualTo(this.uri);
				assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull();
				assertThat(response.getContent()).isSameAs(this.content);
			}), isNull());
	}
	@Test
	void executeWhenResponseIsIn400RangeShouldThrowDockerException() throws IOException {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(getClass().getResourceAsStream('errors.json'));
		given(this.response.getCode()).willReturn(404);
		assertThatExceptionOfType(DockerEngineException.class).isThrownBy(() -> this.http.get(this.uri))
			.satisfies((ex) -> {
				assertThat(ex.getErrors()).hasSize(2);
				assertThat(ex.getResponseMessage()).isNull();
			});
	}
	@Test
	void executeWhenResponseIsIn500RangeWithNoContentShouldThrowDockerException() throws IOException {
		givenClientWillReturnResponse();
		given(this.response.getCode()).willReturn(500);
		assertThatExceptionOfType(DockerEngineException.class).isThrownBy(() -> this.http.get(this.uri))
			.satisfies((ex) -> {
				assertThat(ex.getErrors()).isNull();
				assertThat(ex.getResponseMessage()).isNull();
			});
	}
	@Test
	void executeWhenResponseIsIn500RangeWithMessageShouldThrowDockerException() throws IOException {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(getClass().getResourceAsStream('message.json'));
		given(this.response.getCode()).willReturn(500);
		assertThatExceptionOfType(DockerEngineException.class).isThrownBy(() -> this.http.get(this.uri))
			.satisfies((ex) -> {
				assertThat(ex.getErrors()).isNull();
				assertThat(ex.getResponseMessage().getMessage()).contains('test message');
			});
	}
	@Test
	void executeWhenResponseIsIn500RangeWithOtherContentShouldThrowDockerException() throws IOException {
		givenClientWillReturnResponse();
		given(this.entity.getContent()).willReturn(this.content);
		given(this.response.getCode()).willReturn(500);
		assertThatExceptionOfType(DockerEngineException.class).isThrownBy(() -> this.http.get(this.uri))
			.satisfies((ex) -> {
				assertThat(ex.getErrors()).isNull();
				assertThat(ex.getResponseMessage()).isNull();
			});
	}
	@Test
	void executeWhenClientThrowsIOExceptionRethrowsAsDockerException() throws IOException {
		given(this.client.executeOpen(any(HttpHost.class), any(HttpUriRequest.class), isNull()))
			.willThrow(new IOException('test IO exception'));
		assertThatExceptionOfType(DockerConnectionException.class).isThrownBy(() -> this.http.get(this.uri))
			.satisfies((ex) -> assertThat(ex.getMessage()).contains('test IO exception'));
	}
	private String writeToString(HttpEntity entity) throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		entity.writeTo(out);
		return out.toString(StandardCharsets.UTF_8);
	}
	private void givenClientWillReturnResponse() throws IOException {
		given(this.client.executeOpen(any(HttpHost.class), any(HttpUriRequest.class), isNull()))
			.willReturn(this.response);
		given(this.response.getEntity()).willReturn(this.entity);
	}
	/**
	 * Test {@link HttpClientTransport} implementation.
	 */
	static class TestHttpClientTransport extends HttpClientTransport {
		protected TestHttpClientTransport(HttpClient client) throws URISyntaxException {
			super(client, HttpHost.create('docker://localhost'));
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
class DockerConnectionExceptionTests {
	private static final String HOST = 'docker://localhost/';
	@Test
	void createWhenHostIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DockerConnectionException(null, null))
			.withMessage('Host must not be null');
	}
	@Test
	void createWhenCauseIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DockerConnectionException(HOST, null))
			.withMessage('Cause must not be null');
	}
	@Test
	void createWithIOException() {
		DockerConnectionException exception = new DockerConnectionException(HOST, new IOException('error'));
		assertThat(exception.getMessage())
			.contains('Connection to the Docker daemon at "docker://localhost/" failed with error \'error\'');
	}
	@Test
	void createWithLastErrorException() {
		DockerConnectionException exception = new DockerConnectionException(HOST,
				new IOException(new com.sun.jna.LastErrorException('root cause')));
		assertThat(exception.getMessage())
			.contains('Connection to the Docker daemon at "docker://localhost/" failed with error \'root cause\'');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class PushImageUpdateEventTests extends ProgressUpdateEventTests<PushImageUpdateEvent> {
	@Test
	void getIdReturnsId() {
		PushImageUpdateEvent event = createEvent();
		assertThat(event.getId()).isEqualTo('id');
	}
	@Test
	void getErrorReturnsErrorDetail() {
		PushImageUpdateEvent event = new PushImageUpdateEvent(null, null, null, null,
				new PushImageUpdateEvent.ErrorDetail('test message'));
		assertThat(event.getErrorDetail().getMessage()).isEqualTo('test message');
	}
	@Override
	protected PushImageUpdateEvent createEvent(String status, ProgressDetail progressDetail, String progress) {
		return new PushImageUpdateEvent('id', status, progressDetail, progress, null);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ImageConfigTests extends AbstractJsonTests {
	@Test
	void getEnvContainsParsedValues() throws Exception {
		ImageConfig imageConfig = getImageConfig();
		Map<String, String> env = imageConfig.getEnv();
		assertThat(env).contains(entry('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'),
				entry('CNB_USER_ID', '2000'), entry('CNB_GROUP_ID', '2000'),
				entry('CNB_STACK_ID', 'org.cloudfoundry.stacks.cflinuxfs3'));
	}
	@Test
	void whenConfigHasNoEnvThenImageConfigEnvIsEmpty() throws Exception {
		ImageConfig imageConfig = getMinimalImageConfig();
		Map<String, String> env = imageConfig.getEnv();
		assertThat(env).isEmpty();
	}
	@Test
	void whenConfigHasNoLabelsThenImageConfigLabelsIsEmpty() throws Exception {
		ImageConfig imageConfig = getMinimalImageConfig();
		Map<String, String> env = imageConfig.getLabels();
		assertThat(env).isEmpty();
	}
	@Test
	void getLabelsReturnsLabels() throws Exception {
		ImageConfig imageConfig = getImageConfig();
		Map<String, String> labels = imageConfig.getLabels();
		assertThat(labels).hasSize(4).contains(entry('io.buildpacks.stack.id', 'org.cloudfoundry.stacks.cflinuxfs3'));
	}
	@Test
	void updateWithLabelUpdatesLabels() throws Exception {
		ImageConfig imageConfig = getImageConfig();
		ImageConfig updatedImageConfig = imageConfig
			.copy((update) -> update.withLabel('io.buildpacks.stack.id', 'test'));
		assertThat(imageConfig.getLabels()).hasSize(4)
			.contains(entry('io.buildpacks.stack.id', 'org.cloudfoundry.stacks.cflinuxfs3'));
		assertThat(updatedImageConfig.getLabels()).hasSize(4).contains(entry('io.buildpacks.stack.id', 'test'));
	}
	private ImageConfig getImageConfig() throws IOException {
		return new ImageConfig(getObjectMapper().readTree(getContent('image-config.json')));
	}
	private ImageConfig getMinimalImageConfig() throws IOException {
		return new ImageConfig(getObjectMapper().readTree(getContent('minimal-image-config.json')));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class RandomStringTests {
	@Test
	void generateWhenPrefixIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> RandomString.generate(null, 10))
			.withMessage('Prefix must not be null');
	}
	@Test
	void generateGeneratesRandomString() {
		String s1 = RandomString.generate('abc-', 10);
		String s2 = RandomString.generate('abc-', 10);
		String s3 = RandomString.generate('abc-', 20);
		assertThat(s1).hasSize(14).startsWith('abc-').isNotEqualTo(s2);
		assertThat(s3).hasSize(24).startsWith('abc-');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class VolumeNameTests {
	@Test
	void randomWhenPrefixIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> VolumeName.random(null))
			.withMessage('Prefix must not be null');
	}
	@Test
	void randomGeneratesRandomString() {
		VolumeName v1 = VolumeName.random('abc-');
		VolumeName v2 = VolumeName.random('abc-');
		assertThat(v1.toString()).startsWith('abc-').hasSize(14);
		assertThat(v2.toString()).startsWith('abc-').hasSize(14);
		assertThat(v1).isNotEqualTo(v2);
		assertThat(v1.toString()).isNotEqualTo(v2.toString());
	}
	@Test
	void randomStringWithLengthGeneratesRandomString() {
		VolumeName v1 = VolumeName.random('abc-', 20);
		VolumeName v2 = VolumeName.random('abc-', 20);
		assertThat(v1.toString()).startsWith('abc-').hasSize(24);
		assertThat(v2.toString()).startsWith('abc-').hasSize(24);
		assertThat(v1).isNotEqualTo(v2);
		assertThat(v1.toString()).isNotEqualTo(v2.toString());
	}
	@Test
	void basedOnWhenSourceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> VolumeName.basedOn(null, 'prefix', 'suffix', 6))
			.withMessage('Source must not be null');
	}
	@Test
	void basedOnWhenNameExtractorIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> VolumeName.basedOn('test', null, 'prefix', 'suffix', 6))
			.withMessage('NameExtractor must not be null');
	}
	@Test
	void basedOnWhenPrefixIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> VolumeName.basedOn('test', null, 'suffix', 6))
			.withMessage('Prefix must not be null');
	}
	@Test
	void basedOnWhenSuffixIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> VolumeName.basedOn('test', 'prefix', null, 6))
			.withMessage('Suffix must not be null');
	}
	@Test
	void basedOnGeneratesHashBasedName() {
		VolumeName name = VolumeName.basedOn('index.docker.io/library/myapp:latest', 'pack-cache-', '.build', 6);
		assertThat(name).hasToString('pack-cache-40a311b545d7.build');
	}
	@Test
	void basedOnWhenSizeIsTooBigThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> VolumeName.basedOn('name', 'prefix', 'suffix', 33))
			.withMessage('DigestLength must be less than or equal to 32');
	}
	@Test
	void ofWhenValueIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> VolumeName.of(null))
			.withMessage('Value must not be null');
	}
	@Test
	void ofGeneratesValue() {
		VolumeName name = VolumeName.of('test');
		assertThat(name).hasToString('test');
	}
	@Test
	void equalsAndHashCode() {
		VolumeName n1 = VolumeName.of('test1');
		VolumeName n2 = VolumeName.of('test1');
		VolumeName n3 = VolumeName.of('test2');
		assertThat(n1).hasSameHashCodeAs(n2);
		assertThat(n1).isEqualTo(n1).isEqualTo(n2).isNotEqualTo(n3);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ImageArchiveTests extends AbstractJsonTests {
	private static final int EXISTING_IMAGE_LAYER_COUNT = 46;
	@Test
	void fromImageWritesToValidArchiveTar() throws Exception {
		Image image = Image.of(getContent('image.json'));
		ImageArchive archive = ImageArchive.from(image, (update) -> {
			update.withNewLayer(Layer.of((layout) -> layout.directory('/spring', Owner.ROOT)));
			update.withTag(ImageReference.of('pack.local/builder/6b7874626575656b6162'));
		});
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		archive.writeTo(outputStream);
		try (TarArchiveInputStream tar = new TarArchiveInputStream(
				new ByteArrayInputStream(outputStream.toByteArray()))) {
			for (int i = 0; i < EXISTING_IMAGE_LAYER_COUNT; i++) {
				TarArchiveEntry blankEntry = tar.getNextEntry();
				assertThat(blankEntry.getName()).isEqualTo('blank_' + i);
			}
			TarArchiveEntry layerEntry = tar.getNextEntry();
			byte[] layerContent = read(tar, layerEntry.getSize());
			TarArchiveEntry configEntry = tar.getNextEntry();
			byte[] configContent = read(tar, configEntry.getSize());
			TarArchiveEntry manifestEntry = tar.getNextEntry();
			byte[] manifestContent = read(tar, manifestEntry.getSize());
			assertExpectedLayer(layerEntry, layerContent);
			assertExpectedConfig(configEntry, configContent);
			assertExpectedManifest(manifestEntry, manifestContent);
		}
	}
	private void assertExpectedLayer(TarArchiveEntry entry, byte[] content) throws Exception {
		assertThat(entry.getName()).isEqualTo('bb09e17fd1bd2ee47155f1349645fcd9fff31e1247c7ed99cad469f1c16a4216.tar');
		try (TarArchiveInputStream tar = new TarArchiveInputStream(new ByteArrayInputStream(content))) {
			TarArchiveEntry contentEntry = tar.getNextEntry();
			assertThat(contentEntry.getName()).isEqualTo('/spring/');
		}
	}
	private void assertExpectedConfig(TarArchiveEntry entry, byte[] content) throws Exception {
		assertThat(entry.getName()).isEqualTo('416c76dc7f691f91e80516ff039e056f32f996b59af4b1cb8114e6ae8171a374.json');
		String actualJson = new String(content, StandardCharsets.UTF_8);
		String expectedJson = StreamUtils.copyToString(getContent('image-archive-config.json'), StandardCharsets.UTF_8);
		JSONAssert.assertEquals(expectedJson, actualJson, false);
	}
	private void assertExpectedManifest(TarArchiveEntry entry, byte[] content) throws Exception {
		assertThat(entry.getName()).isEqualTo('manifest.json');
		String actualJson = new String(content, StandardCharsets.UTF_8);
		String expectedJson = StreamUtils.copyToString(getContent('image-archive-manifest.json'),
				StandardCharsets.UTF_8);
		JSONAssert.assertEquals(expectedJson, actualJson, false);
	}
	private byte[] read(TarArchiveInputStream tar, long size) throws IOException {
		byte[] content = new byte[(int) size];
		tar.read(content);
		return content;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ContainerReferenceTests {
	@Test
	void ofCreatesInstance() {
		ContainerReference reference = ContainerReference
			.of('92691aec176333f7ae890de9aaeeafef11166efcaa3908edf83eb44a5c943781');
		assertThat(reference).hasToString('92691aec176333f7ae890de9aaeeafef11166efcaa3908edf83eb44a5c943781');
	}
	@Test
	void ofWhenNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ContainerReference.of(null))
			.withMessage('Value must not be empty');
	}
	@Test
	void ofWhenEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ContainerReference.of(''))
			.withMessage('Value must not be empty');
	}
	@Test
	void hashCodeAndEquals() {
		ContainerReference r1 = ContainerReference
			.of('92691aec176333f7ae890de9aaeeafef11166efcaa3908edf83eb44a5c943781');
		ContainerReference r2 = ContainerReference
			.of('92691aec176333f7ae890de9aaeeafef11166efcaa3908edf83eb44a5c943781');
		ContainerReference r3 = ContainerReference
			.of('02691aec176333f7ae890de9aaeeafef11166efcaa3908edf83eb44a5c943781');
		assertThat(r1).hasSameHashCodeAs(r2);
		assertThat(r1).isEqualTo(r1).isEqualTo(r2).isNotEqualTo(r3);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ApiVersionTests {
	@Test
	void parseWhenVersionIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ApiVersion.parse(null))
			.withMessage('Value must not be empty');
	}
	@Test
	void parseWhenVersionIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ApiVersion.parse(''))
			.withMessage('Value must not be empty');
	}
	@Test
	void parseWhenVersionDoesNotMatchPatternThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ApiVersion.parse('bad'))
			.withMessage('Malformed version number "bad"');
	}
	@Test
	void parseReturnsVersion() {
		ApiVersion version = ApiVersion.parse('1.2');
		assertThat(version.getMajor()).isOne();
		assertThat(version.getMinor()).isEqualTo(2);
	}
	@Test
	void supportsWhenSame() {
		assertThat(supports('0.0', '0.0')).isTrue();
		assertThat(supports('0.1', '0.1')).isTrue();
		assertThat(supports('1.0', '1.0')).isTrue();
		assertThat(supports('1.1', '1.1')).isTrue();
	}
	@Test
	void supportsWhenDifferentMajor() {
		assertThat(supports('0.0', '1.0')).isFalse();
		assertThat(supports('1.0', '0.0')).isFalse();
		assertThat(supports('1.0', '2.0')).isFalse();
		assertThat(supports('2.0', '1.0')).isFalse();
		assertThat(supports('1.1', '2.1')).isFalse();
		assertThat(supports('2.1', '1.1')).isFalse();
	}
	@Test
	void supportsWhenDifferentMinor() {
		assertThat(supports('1.2', '1.1')).isTrue();
		assertThat(supports('1.2', '1.3')).isFalse();
	}
	@Test
	void supportsWhenMajorZeroAndDifferentMinor() {
		assertThat(supports('0.2', '0.1')).isFalse();
		assertThat(supports('0.2', '0.3')).isFalse();
	}
	@Test
	void supportsAnyWhenOneMatches() {
		assertThat(supportsAny('0.2', '0.1', '0.2')).isTrue();
	}
	@Test
	void supportsAnyWhenNoneMatch() {
		assertThat(supportsAny('0.2', '0.3', '0.4')).isFalse();
	}
	@Test
	void toStringReturnsString() {
		assertThat(ApiVersion.parse('1.2')).hasToString('1.2');
	}
	@Test
	void equalsAndHashCode() {
		ApiVersion v12a = ApiVersion.parse('1.2');
		ApiVersion v12b = ApiVersion.parse('1.2');
		ApiVersion v13 = ApiVersion.parse('1.3');
		assertThat(v12a).hasSameHashCodeAs(v12b);
		assertThat(v12a).isEqualTo(v12a).isEqualTo(v12b).isNotEqualTo(v13);
	}
	private boolean supports(String v1, String v2) {
		return ApiVersion.parse(v1).supports(ApiVersion.parse(v2));
	}
	private boolean supportsAny(String v1, String... others) {
		return ApiVersion.parse(v1)
			.supportsAny(Arrays.stream(others).map(ApiVersion::parse).toArray(ApiVersion[]::new));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class LayerIdTests {
	@Test
	void ofReturnsLayerId() {
		LayerId id = LayerId.of('sha256:9a183e56c86d376b408bdf922746d0a657f62b0e18c7c8f82a496b87710c576f');
		assertThat(id.getAlgorithm()).isEqualTo('sha256');
		assertThat(id.getHash()).isEqualTo('9a183e56c86d376b408bdf922746d0a657f62b0e18c7c8f82a496b87710c576f');
		assertThat(id).hasToString('sha256:9a183e56c86d376b408bdf922746d0a657f62b0e18c7c8f82a496b87710c576f');
	}
	@Test
	void hashCodeAndEquals() {
		LayerId id1 = LayerId.of('sha256:9a183e56c86d376b408bdf922746d0a657f62b0e18c7c8f82a496b87710c576f');
		LayerId id2 = LayerId.of('sha256:9a183e56c86d376b408bdf922746d0a657f62b0e18c7c8f82a496b87710c576f');
		LayerId id3 = LayerId.of('sha256:ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
		assertThat(id1).hasSameHashCodeAs(id2);
		assertThat(id1).isEqualTo(id1).isEqualTo(id2).isNotEqualTo(id3);
	}
	@Test
	void ofWhenValueIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LayerId.of((String) null))
			.withMessage('Value must not be empty');
	}
	@Test
	void ofWhenValueIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LayerId.of(' ')).withMessage('Value must not be empty');
	}
	@Test
	void ofSha256Digest() throws Exception {
		MessageDigest digest = MessageDigest.getInstance('SHA-256');
		digest.update('test'.getBytes(StandardCharsets.UTF_8));
		LayerId id = LayerId.ofSha256Digest(digest.digest());
		assertThat(id).hasToString('sha256:9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08');
	}
	@Test
	void ofSha256DigestWithZeroPadding() {
		byte[] digest = new byte[32];
		Arrays.fill(digest, (byte) 127);
		digest[0] = 1;
		LayerId id = LayerId.ofSha256Digest(digest);
		assertThat(id).hasToString('sha256:017f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f');
	}
	@Test
	void ofSha256DigestWhenNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LayerId.ofSha256Digest((byte[]) null))
			.withMessage('Digest must not be null');
	}
	@Test
	void ofSha256DigestWhenWrongLengthThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LayerId.ofSha256Digest(new byte[31]))
			.withMessage('Digest must be exactly 32 bytes');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ImageReferenceTests {
	@Test
	void ofSimpleName() {
		ImageReference reference = ImageReference.of('ubuntu');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu');
	}
	@Test
	void ofSimpleNameWithSingleCharacterSuffix() {
		ImageReference reference = ImageReference.of('ubuntu-a');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu-a');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu-a');
	}
	@Test
	void ofLibrarySlashName() {
		ImageReference reference = ImageReference.of('library/ubuntu');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu');
	}
	@Test
	void ofSlashName() {
		ImageReference reference = ImageReference.of('adoptopenjdk/openjdk11');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('adoptopenjdk/openjdk11');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/adoptopenjdk/openjdk11');
	}
	@Test
	void ofCustomDomain() {
		ImageReference reference = ImageReference.of('repo.example.com/java/jdk');
		assertThat(reference.getDomain()).isEqualTo('repo.example.com');
		assertThat(reference.getName()).isEqualTo('java/jdk');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('repo.example.com/java/jdk');
	}
	@Test
	void ofCustomDomainAndPort() {
		ImageReference reference = ImageReference.of('repo.example.com:8080/java/jdk');
		assertThat(reference.getDomain()).isEqualTo('repo.example.com:8080');
		assertThat(reference.getName()).isEqualTo('java/jdk');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('repo.example.com:8080/java/jdk');
	}
	@Test
	void ofLegacyDomain() {
		ImageReference reference = ImageReference.of('index.docker.io/ubuntu');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu');
	}
	@Test
	void ofNameAndTag() {
		ImageReference reference = ImageReference.of('ubuntu:bionic');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isEqualTo('bionic');
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu:bionic');
	}
	@Test
	void ofDomainPortAndTag() {
		ImageReference reference = ImageReference.of('repo.example.com:8080/library/ubuntu:v1');
		assertThat(reference.getDomain()).isEqualTo('repo.example.com:8080');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isEqualTo('v1');
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('repo.example.com:8080/library/ubuntu:v1');
	}
	@Test
	void ofNameAndDigest() {
		ImageReference reference = ImageReference
			.of('ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest())
			.isEqualTo('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference).hasToString(
				'docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void ofNameAndTagAndDigest() {
		ImageReference reference = ImageReference
			.of('ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isEqualTo('bionic');
		assertThat(reference.getDigest())
			.isEqualTo('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference).hasToString(
				'docker.io/library/ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void ofCustomDomainAndPortWithTag() {
		ImageReference reference = ImageReference
			.of('example.com:8080/canonical/ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference.getDomain()).isEqualTo('example.com:8080');
		assertThat(reference.getName()).isEqualTo('canonical/ubuntu');
		assertThat(reference.getTag()).isEqualTo('bionic');
		assertThat(reference.getDigest())
			.isEqualTo('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference).hasToString(
				'example.com:8080/canonical/ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void ofImageName() {
		ImageReference reference = ImageReference.of(ImageName.of('ubuntu'));
		assertThat(reference).hasToString('docker.io/library/ubuntu');
	}
	@Test
	void ofImageNameAndTag() {
		ImageReference reference = ImageReference.of(ImageName.of('ubuntu'), 'bionic');
		assertThat(reference).hasToString('docker.io/library/ubuntu:bionic');
	}
	@Test
	void ofImageNameTagAndDigest() {
		ImageReference reference = ImageReference.of(ImageName.of('ubuntu'), 'bionic',
				'sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference).hasToString(
				'docker.io/library/ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void ofWhenHasIllegalCharacterThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ImageReference
				.of('registry.example.com/example/example-app:1.6.0-dev.2.uncommitted+wip.foo.c75795d'))
			.withMessageContaining('Unable to parse image reference');
	}
	@Test
	void ofWhenContainsUpperCaseThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ImageReference
				.of('europe-west1-docker.pkg.dev/aaaaaa-bbbbb-123456/docker-registry/bootBuildImage:0.0.1'))
			.withMessageContaining('Unable to parse image reference');
	}
	@Test
	@Timeout(value = 1, threadMode = ThreadMode.SEPARATE_THREAD)
	void ofWhenIsVeryLongAndHasIllegalCharacter() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageReference
			.of('docker.io/library/this-image-has-a-long-name-with-an-invalid-tag-which-is-at-danger-of-catastrophic-backtracking:1.0.0+1234'))
			.withMessageContaining('Unable to parse image reference');
	}
	@Test
	void forJarFile() {
		assertForJarFile('spring-boot.2.0.0.BUILD-SNAPSHOT.jar', 'library/spring-boot', '2.0.0.BUILD-SNAPSHOT');
		assertForJarFile('spring-boot.2.0.0.M1.jar', 'library/spring-boot', '2.0.0.M1');
		assertForJarFile('spring-boot.2.0.0.RC1.jar', 'library/spring-boot', '2.0.0.RC1');
		assertForJarFile('spring-boot.2.0.0.RELEASE.jar', 'library/spring-boot', '2.0.0.RELEASE');
		assertForJarFile('sample-0.0.1-SNAPSHOT.jar', 'library/sample', '0.0.1-SNAPSHOT');
		assertForJarFile('sample-0.0.1.jar', 'library/sample', '0.0.1');
	}
	private void assertForJarFile(String jarFile, String expectedName, String expectedTag) {
		ImageReference reference = ImageReference.forJarFile(new File(jarFile));
		assertThat(reference.getName()).isEqualTo(expectedName);
		assertThat(reference.getTag()).isEqualTo(expectedTag);
	}
	@Test
	void randomGeneratesRandomName() {
		String prefix = 'pack.local/builder/';
		ImageReference random = ImageReference.random(prefix);
		assertThat(random.toString()).startsWith(prefix).hasSize(prefix.length() + 10);
		ImageReference another = ImageReference.random(prefix);
		int attempts = 0;
		while (another.equals(random)) {
			assertThat(attempts).as('Duplicate results').isLessThan(10);
			another = ImageReference.random(prefix);
			attempts++;
		}
	}
	@Test
	void randomWithLengthGeneratesRandomName() {
		String prefix = 'pack.local/builder/';
		ImageReference random = ImageReference.random(prefix, 20);
		assertThat(random.toString()).startsWith(prefix).hasSize(prefix.length() + 20);
	}
	@Test
	void randomWherePrefixIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageReference.random(null))
			.withMessage('Prefix must not be null');
	}
	@Test
	void inTaggedFormWhenHasDigestThrowsException() {
		ImageReference reference = ImageReference
			.of('ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThatIllegalStateException().isThrownBy(reference::inTaggedForm)
			.withMessage(
					'Image reference "docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d" cannot contain a digest');
	}
	@Test
	void inTaggedFormWhenHasNoTagUsesLatest() {
		ImageReference reference = ImageReference.of('ubuntu');
		assertThat(reference.inTaggedForm()).hasToString('docker.io/library/ubuntu:latest');
	}
	@Test
	void inTaggedFormWhenHasTagUsesTag() {
		ImageReference reference = ImageReference.of('ubuntu:bionic');
		assertThat(reference.inTaggedForm()).hasToString('docker.io/library/ubuntu:bionic');
	}
	@Test
	void inTaggedOrDigestFormWhenHasDigestUsesDigest() {
		ImageReference reference = ImageReference
			.of('ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference.inTaggedOrDigestForm()).hasToString(
				'docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void inTaggedOrDigestFormWhenHasTagUsesTag() {
		ImageReference reference = ImageReference.of('ubuntu:bionic');
		assertThat(reference.inTaggedOrDigestForm()).hasToString('docker.io/library/ubuntu:bionic');
	}
	@Test
	void inTaggedOrDigestFormWhenHasNoTagOrDigestUsesLatest() {
		ImageReference reference = ImageReference.of('ubuntu');
		assertThat(reference.inTaggedOrDigestForm()).hasToString('docker.io/library/ubuntu:latest');
	}
	@Test
	void equalsAndHashCode() {
		ImageReference r1 = ImageReference.of('ubuntu:bionic');
		ImageReference r2 = ImageReference.of('docker.io/library/ubuntu:bionic');
		ImageReference r3 = ImageReference.of('docker.io/library/ubuntu:latest');
		assertThat(r1).hasSameHashCodeAs(r2);
		assertThat(r1).isEqualTo(r1).isEqualTo(r2).isNotEqualTo(r3);
	}
	@Test
	void withDigest() {
		ImageReference reference = ImageReference.of('docker.io/library/ubuntu:bionic');
		ImageReference updated = reference
			.withDigest('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(updated).hasToString(
				'docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void inTaglessFormWithDigest() {
		ImageReference reference = ImageReference
			.of('docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		ImageReference updated = reference.inTaglessForm();
		assertThat(updated).hasToString(
				'docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void inTaglessForm() {
		ImageReference reference = ImageReference.of('docker.io/library/ubuntu:bionic');
		ImageReference updated = reference.inTaglessForm();
		assertThat(updated).hasToString('docker.io/library/ubuntu');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ImageArchiveManifestTests extends AbstractJsonTests {
	@Test
	void getLayersReturnsLayers() throws Exception {
		String content = getContentAsString('image-archive-manifest.json');
		ImageArchiveManifest manifest = getManifest(content);
		List<String> expectedLayers = new ArrayList<>();
		for (int blankLayersCount = 0; blankLayersCount < 46; blankLayersCount++) {
			expectedLayers.add('blank_' + blankLayersCount);
		}
		expectedLayers.add('bb09e17fd1bd2ee47155f1349645fcd9fff31e1247c7ed99cad469f1c16a4216.tar');
		assertThat(manifest.getEntries()).hasSize(1);
		assertThat(manifest.getEntries().get(0).getLayers()).hasSize(47);
		assertThat(manifest.getEntries().get(0).getLayers()).isEqualTo(expectedLayers);
	}
	@Test
	void getLayersWithNoLayersReturnsEmptyList() throws Exception {
		String content = '[{\'Layers\': []}]';
		ImageArchiveManifest manifest = getManifest(content);
		assertThat(manifest.getEntries()).hasSize(1);
		assertThat(manifest.getEntries().get(0).getLayers()).isEmpty();
	}
	@Test
	void getLayersWithEmptyManifestReturnsEmptyList() throws Exception {
		String content = '[]';
		ImageArchiveManifest manifest = getManifest(content);
		assertThat(manifest.getEntries()).isEmpty();
	}
	private ImageArchiveManifest getManifest(String content) throws IOException {
		return new ImageArchiveManifest(getObjectMapper().readTree(content));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class LayerTests {
	@Test
	void ofWhenLayoutIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Layer.of((IOConsumer<Layout>) null))
			.withMessage('Layout must not be null');
	}
	@Test
	void fromTarArchiveWhenTarArchiveIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Layer.fromTarArchive(null))
			.withMessage('TarArchive must not be null');
	}
	@Test
	void ofCreatesLayer() throws Exception {
		Layer layer = Layer.of((layout) -> {
			layout.directory('/directory', Owner.ROOT);
			layout.file('/directory/file', Owner.ROOT, Content.of('test'));
		});
		assertThat(layer.getId())
			.hasToString('sha256:d03a34f73804698c875eb56ff694fc2fceccc69b645e4adceb004ed13588613b');
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		layer.writeTo(outputStream);
		try (TarArchiveInputStream tarStream = new TarArchiveInputStream(
				new ByteArrayInputStream(outputStream.toByteArray()))) {
			assertThat(tarStream.getNextEntry().getName()).isEqualTo('/directory/');
			assertThat(tarStream.getNextEntry().getName()).isEqualTo('/directory/file');
			assertThat(tarStream.getNextEntry()).isNull();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class BindingTests {
	@Test
	void ofReturnsValue() {
		Binding binding = Binding.of('host-src:container-dest:ro');
		assertThat(binding).hasToString('host-src:container-dest:ro');
	}
	@Test
	void ofWithNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Binding.of(null))
			.withMessageContaining('Value must not be null');
	}
	@Test
	void fromReturnsValue() {
		Binding binding = Binding.from('host-src', 'container-dest');
		assertThat(binding).hasToString('host-src:container-dest');
	}
	@Test
	void fromWithNullSourceThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Binding.from((String) null, 'container-dest'))
			.withMessageContaining('Source must not be null');
	}
	@Test
	void fromWithNullDestinationThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Binding.from('host-src', null))
			.withMessageContaining('Destination must not be null');
	}
	@Test
	void fromVolumeNameSourceReturnsValue() {
		Binding binding = Binding.from(VolumeName.of('host-src'), 'container-dest');
		assertThat(binding).hasToString('host-src:container-dest');
	}
	@Test
	void fromVolumeNameSourceWithNullSourceThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Binding.from((VolumeName) null, 'container-dest'))
			.withMessageContaining('SourceVolume must not be null');
	}
	@Test
	void shouldReturnContainerDestinationPath() {
		Binding binding = Binding.from('/host', '/container');
		assertThat(binding.getContainerDestinationPath()).isEqualTo('/container');
	}
	@Test
	void shouldReturnContainerDestinationPathWithOptions() {
		Binding binding = Binding.of('/host:/container:ro');
		assertThat(binding.getContainerDestinationPath()).isEqualTo('/container');
	}
	@Test
	void shouldReturnContainerDestinationPathOnWindows() {
		Binding binding = Binding.from('C:\\host', 'C:\\container');
		assertThat(binding.getContainerDestinationPath()).isEqualTo('C:\\container');
	}
	@Test
	void shouldReturnContainerDestinationPathOnWindowsWithOptions() {
		Binding binding = Binding.of('C:\\host:C:\\container:ro');
		assertThat(binding.getContainerDestinationPath()).isEqualTo('C:\\container');
	}
	@Test
	void shouldFailIfBindingIsMalformed() {
		Binding binding = Binding.of('some-invalid-binding');
		assertThatIllegalStateException().isThrownBy(binding::getContainerDestinationPath)
			.withMessage('Expected 2 or more parts, but found 1');
	}
	@ParameterizedTest
	@CsvSource(textBlock = '''
			/cnb, true
			/layers, true
			/workspace, true
			/something, false
			c:\\cnb, true
			c:\\layers, true
			c:\\workspace, true
			c:\\something, false
			''')
	void shouldDetectSensitiveContainerPaths(String containerPath, boolean sensitive) {
		Binding binding = Binding.from('/host', containerPath);
		assertThat(binding.usesSensitiveContainerPath()).isEqualTo(sensitive);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ImageNameTests {
	@Test
	void ofWhenNameOnlyCreatesImageName() {
		ImageName imageName = ImageName.of('ubuntu');
		assertThat(imageName).hasToString('docker.io/library/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('library/ubuntu');
	}
	@Test
	void ofWhenSlashedNameCreatesImageName() {
		ImageName imageName = ImageName.of('canonical/ubuntu');
		assertThat(imageName).hasToString('docker.io/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenLocalhostNameCreatesImageName() {
		ImageName imageName = ImageName.of('localhost/canonical/ubuntu');
		assertThat(imageName).hasToString('localhost/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('localhost');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenDomainAndNameCreatesImageName() {
		ImageName imageName = ImageName.of('repo.spring.io/canonical/ubuntu');
		assertThat(imageName).hasToString('repo.spring.io/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo.spring.io');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenDomainNameAndPortCreatesImageName() {
		ImageName imageName = ImageName.of('repo.spring.io:8080/canonical/ubuntu');
		assertThat(imageName).hasToString('repo.spring.io:8080/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo.spring.io:8080');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenSimpleNameAndPortCreatesImageName() {
		ImageName imageName = ImageName.of('repo:8080/ubuntu');
		assertThat(imageName).hasToString('repo:8080/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo:8080');
		assertThat(imageName.getName()).isEqualTo('ubuntu');
	}
	@Test
	void ofWhenSimplePathAndPortCreatesImageName() {
		ImageName imageName = ImageName.of('repo:8080/canonical/ubuntu');
		assertThat(imageName).hasToString('repo:8080/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo:8080');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenNameWithLongPathCreatesImageName() {
		ImageName imageName = ImageName.of('path1/path2/path3/ubuntu');
		assertThat(imageName).hasToString('docker.io/path1/path2/path3/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('path1/path2/path3/ubuntu');
	}
	@Test
	void ofWhenLocalhostDomainCreatesImageName() {
		ImageName imageName = ImageName.of('localhost/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('localhost');
		assertThat(imageName.getName()).isEqualTo('ubuntu');
	}
	@Test
	void ofWhenLocalhostDomainAndPathCreatesImageName() {
		ImageName imageName = ImageName.of('localhost/library/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('localhost');
		assertThat(imageName.getName()).isEqualTo('library/ubuntu');
	}
	@Test
	void ofWhenLegacyDomainUsesNewDomain() {
		ImageName imageName = ImageName.of('index.docker.io/ubuntu');
		assertThat(imageName).hasToString('docker.io/library/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('library/ubuntu');
	}
	@Test
	void ofWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of(null))
			.withMessage('Value must not be empty');
	}
	@Test
	void ofWhenNameIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of('')).withMessage('Value must not be empty');
	}
	@Test
	void ofWhenContainsUppercaseThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of('Test'))
			.withMessageContaining('Unable to parse name')
			.withMessageContaining('Test');
	}
	@Test
	void ofWhenNameIncludesTagThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of('ubuntu:latest'))
			.withMessageContaining('Unable to parse name')
			.withMessageContaining(':latest');
	}
	@Test
	void ofWhenNameIncludeDigestThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(
				() -> ImageName.of('ubuntu@sha256:47bfdb88c3ae13e488167607973b7688f69d9e8c142c2045af343ec199649c09'))
			.withMessageContaining('Unable to parse name')
			.withMessageContaining('@sha256:47b');
	}
	@Test
	void hashCodeAndEquals() {
		ImageName n1 = ImageName.of('ubuntu');
		ImageName n2 = ImageName.of('library/ubuntu');
		ImageName n3 = ImageName.of('docker.io/ubuntu');
		ImageName n4 = ImageName.of('docker.io/library/ubuntu');
		ImageName n5 = ImageName.of('index.docker.io/library/ubuntu');
		ImageName n6 = ImageName.of('alpine');
		assertThat(n1).hasSameHashCodeAs(n2).hasSameHashCodeAs(n3).hasSameHashCodeAs(n4).hasSameHashCodeAs(n5);
		assertThat(n1).isEqualTo(n1).isEqualTo(n2).isEqualTo(n3).isEqualTo(n4).isNotEqualTo(n6);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ImageTests extends AbstractJsonTests {
	@Test
	void getConfigEnvContainsParsedValues() throws Exception {
		Image image = getImage();
		Map<String, String> env = image.getConfig().getEnv();
		assertThat(env).contains(entry('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'),
				entry('CNB_USER_ID', '2000'), entry('CNB_GROUP_ID', '2000'),
				entry('CNB_STACK_ID', 'org.cloudfoundry.stacks.cflinuxfs3'));
	}
	@Test
	void getConfigLabelsReturnsLabels() throws Exception {
		Image image = getImage();
		Map<String, String> labels = image.getConfig().getLabels();
		assertThat(labels).contains(entry('io.buildpacks.stack.id', 'org.cloudfoundry.stacks.cflinuxfs3'));
	}
	@Test
	void getLayersReturnsImageLayers() throws Exception {
		Image image = getImage();
		List<LayerId> layers = image.getLayers();
		assertThat(layers).hasSize(46);
		assertThat(layers.get(0))
			.hasToString('sha256:733a8e5ce32984099ef675fce04730f6e2a6dcfdf5bd292fea01a8f936265342');
		assertThat(layers.get(45))
			.hasToString('sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef');
	}
	@Test
	void getOsReturnsOs() throws Exception {
		Image image = getImage();
		assertThat(image.getOs()).isEqualTo('linux');
	}
	@Test
	void getArchitectureReturnsArchitecture() throws Exception {
		Image image = getImage();
		assertThat(image.getArchitecture()).isEqualTo('amd64');
	}
	@Test
	void getVariantReturnsVariant() throws Exception {
		Image image = getImage();
		assertThat(image.getVariant()).isEqualTo('v1');
	}
	@Test
	void getCreatedReturnsDate() throws Exception {
		Image image = getImage();
		assertThat(image.getCreated()).isEqualTo('2019-10-30T19:34:56.296666503Z');
	}
	private Image getImage() throws IOException {
		return Image.of(getContent('image.json'));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ManifestListTests extends AbstractJsonTests {
	@Test
	void loadJsonFromDistributionManifestList() throws IOException {
		String content = getContentAsString('distribution-manifest-list.json');
		ManifestList manifestList = getManifestList(content);
		assertThat(manifestList.getSchemaVersion()).isEqualTo(2);
		assertThat(manifestList.getMediaType()).isEqualTo('application/vnd.docker.distribution.manifest.list.v2+json');
		assertThat(manifestList.getManifests()).hasSize(2);
	}
	private ManifestList getManifestList(String content) throws IOException {
		return new ManifestList(getObjectMapper().readTree(content));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ContainerContentTests {
	@Test
	void ofWhenArchiveIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ContainerContent.of(null))
			.withMessage('Archive must not be null');
	}
	@Test
	void ofWhenDestinationPathIsNullThrowsException() {
		TarArchive archive = mock(TarArchive.class);
		assertThatIllegalArgumentException().isThrownBy(() -> ContainerContent.of(archive, null))
			.withMessage('DestinationPath must not be empty');
	}
	@Test
	void ofWhenDestinationPathIsEmptyThrowsException() {
		TarArchive archive = mock(TarArchive.class);
		assertThatIllegalArgumentException().isThrownBy(() -> ContainerContent.of(archive, ''))
			.withMessage('DestinationPath must not be empty');
	}
	@Test
	void ofCreatesContainerContent() {
		TarArchive archive = mock(TarArchive.class);
		ContainerContent content = ContainerContent.of(archive);
		assertThat(content.getArchive()).isSameAs(archive);
		assertThat(content.getDestinationPath()).isEqualTo('/');
	}
	@Test
	void ofWithDestinationPathCreatesContainerContent() {
		TarArchive archive = mock(TarArchive.class);
		ContainerContent content = ContainerContent.of(archive, '/test');
		assertThat(content.getArchive()).isSameAs(archive);
		assertThat(content.getDestinationPath()).isEqualTo('/test');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ContainerStatusTests {
	@Test
	void ofCreatesFromJson() throws IOException {
		ContainerStatus status = ContainerStatus.of(getClass().getResourceAsStream('container-status-error.json'));
		assertThat(status.getStatusCode()).isOne();
		assertThat(status.getWaitingErrorMessage()).isEqualTo('error detail');
	}
	@Test
	void ofCreatesFromValues() {
		ContainerStatus status = ContainerStatus.of(1, 'error detail');
		assertThat(status.getStatusCode()).isOne();
		assertThat(status.getWaitingErrorMessage()).isEqualTo('error detail');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ContainerConfigTests extends AbstractJsonTests {
	@Test
	void ofWhenImageReferenceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ContainerConfig.of(null, (update) -> {
		})).withMessage('ImageReference must not be null');
	}
	@Test
	void ofWhenUpdateIsNullThrowsException() {
		ImageReference imageReference = ImageReference.of('ubuntu:bionic');
		assertThatIllegalArgumentException().isThrownBy(() -> ContainerConfig.of(imageReference, null))
			.withMessage('Update must not be null');
	}
	@Test
	void writeToWritesJson() throws Exception {
		ImageReference imageReference = ImageReference.of('ubuntu:bionic');
		ContainerConfig containerConfig = ContainerConfig.of(imageReference, (update) -> {
			update.withUser('root');
			update.withCommand('ls', '-l');
			update.withArgs('-h');
			update.withLabel('spring', 'boot');
			update.withBinding(Binding.from('bind-source', 'bind-dest'));
			update.withEnv('name1', 'value1');
			update.withEnv('name2', 'value2');
			update.withNetworkMode('test');
			update.withSecurityOption('option=value');
		});
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		containerConfig.writeTo(outputStream);
		String actualJson = outputStream.toString(StandardCharsets.UTF_8);
		String expectedJson = StreamUtils.copyToString(getContent('container-config.json'), StandardCharsets.UTF_8);
		JSONAssert.assertEquals(expectedJson, actualJson, true);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ImageArchiveIndexTests extends AbstractJsonTests {
	@Test
	void loadJson() throws IOException {
		String content = getContentAsString('image-archive-index.json');
		ImageArchiveIndex index = getIndex(content);
		assertThat(index.getSchemaVersion()).isEqualTo(2);
		assertThat(index.getManifests()).hasSize(1);
		BlobReference manifest = index.getManifests().get(0);
		assertThat(manifest.getMediaType()).isEqualTo('application/vnd.docker.distribution.manifest.list.v2+json');
		assertThat(manifest.getDigest())
			.isEqualTo('sha256:3bbe02431d8e5124ffe816ec27bf6508b50edd1d10218be1a03e799a186b9004');
	}
	private ImageArchiveIndex getIndex(String content) throws IOException {
		return new ImageArchiveIndex(getObjectMapper().readTree(content));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
class ManifestTests extends AbstractJsonTests {
	@Test
	void loadJsonFromDistributionManifest() throws IOException {
		String content = getContentAsString('distribution-manifest.json');
		Manifest manifestList = getManifest(content);
		assertThat(manifestList.getSchemaVersion()).isEqualTo(2);
		assertThat(manifestList.getMediaType()).isEqualTo('application/vnd.docker.distribution.manifest.v2+json');
		assertThat(manifestList.getLayers()).hasSize(1);
	}
	@Test
	void loadJsonFromImageManifest() throws IOException {
		String content = getContentAsString('image-manifest.json');
		Manifest manifestList = getManifest(content);
		assertThat(manifestList.getSchemaVersion()).isEqualTo(2);
		assertThat(manifestList.getMediaType()).isEqualTo('application/vnd.oci.image.manifest.v1+json');
		assertThat(manifestList.getLayers()).hasSize(1);
	}
	private Manifest getManifest(String content) throws IOException {
		return new Manifest(getObjectMapper().readTree(content));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
class ImagePlatformTests extends AbstractJsonTests {
	@Test
	void ofWithOsParses() {
		ImagePlatform platform = ImagePlatform.of('linux');
		assertThat(platform.toString()).isEqualTo('linux');
	}
	@Test
	void ofWithOsAndArchitectureParses() {
		ImagePlatform platform = ImagePlatform.of('linux/amd64');
		assertThat(platform.toString()).isEqualTo('linux/amd64');
	}
	@Test
	void ofWithOsAndArchitectureAndVariantParses() {
		ImagePlatform platform = ImagePlatform.of('linux/amd64/v1');
		assertThat(platform.toString()).isEqualTo('linux/amd64/v1');
	}
	@Test
	void ofWithEmptyValueFails() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImagePlatform.of(''))
			.withMessageContaining('Value must not be empty');
	}
	@Test
	void ofWithTooManySegmentsFails() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImagePlatform.of('linux/amd64/v1/extra'))
			.withMessageContaining('value "linux/amd64/v1/extra"');
	}
	@Test
	void fromImageMatchesImage() throws IOException {
		ImagePlatform platform = ImagePlatform.from(getImage());
		assertThat(platform.toString()).isEqualTo('linux/amd64/v1');
	}
	private Image getImage() throws IOException {
		return Image.of(getContent('image.json'));
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class TotalProgressBarTests {
	@Test
	void withPrefixAndBookends() {
		TestPrintStream out = new TestPrintStream();
		TotalProgressBar bar = new TotalProgressBar('prefix:', "#", true, out);
		assertThat(out).hasToString('prefix: [ ');
		bar.accept(new TotalProgressEvent(10));
		assertThat(out).hasToString('prefix: [ #####');
		bar.accept(new TotalProgressEvent(50));
		assertThat(out).hasToString('prefix: [ #########################');
		bar.accept(new TotalProgressEvent(100));
		assertThat(out).hasToString(String.format('prefix: [ ################################################## ]%n'));
	}
	@Test
	void withoutPrefix() {
		TestPrintStream out = new TestPrintStream();
		TotalProgressBar bar = new TotalProgressBar(null, "#", true, out);
		assertThat(out).hasToString('[ ');
		bar.accept(new TotalProgressEvent(10));
		assertThat(out).hasToString('[ #####');
		bar.accept(new TotalProgressEvent(50));
		assertThat(out).hasToString('[ #########################');
		bar.accept(new TotalProgressEvent(100));
		assertThat(out).hasToString(String.format('[ ################################################## ]%n'));
	}
	@Test
	void withoutBookends() {
		TestPrintStream out = new TestPrintStream();
		TotalProgressBar bar = new TotalProgressBar('', ".", false, out);
		assertThat(out).hasToString('');
		bar.accept(new TotalProgressEvent(10));
		assertThat(out).hasToString('.....');
		bar.accept(new TotalProgressEvent(50));
		assertThat(out).hasToString('.........................');
		bar.accept(new TotalProgressEvent(100));
		assertThat(out).hasToString(String.format('..................................................%n'));
	}
	static class TestPrintStream extends PrintStream {
		TestPrintStream() {
			super(new ByteArrayOutputStream());
		}
		@Override
		public String toString() {
			return this.out.toString();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class TotalProgressListenerTests extends AbstractJsonTests {
	@Test
	void totalProgress() throws Exception {
		List<Integer> progress = new ArrayList<>();
		TestTotalProgressListener listener = new TestTotalProgressListener((event) -> progress.add(event.getPercent()));
		run(listener);
		int last = 0;
		for (Integer update : progress) {
			assertThat(update).isGreaterThanOrEqualTo(last);
			last = update;
		}
		assertThat(last).isEqualTo(100);
	}
	@Test
	@Disabled('For visual inspection')
	void totalProgressUpdatesSmoothly() throws Exception {
		TestTotalProgressListener listener = new TestTotalProgressListener(new TotalProgressBar('Pulling layers:'));
		run(listener);
	}
	private void run(TestTotalProgressListener listener) throws IOException {
		JsonStream jsonStream = new JsonStream(getObjectMapper());
		listener.onStart();
		jsonStream.get(getContent('pull-stream.json'), TestImageUpdateEvent.class, listener::onUpdate);
		listener.onFinish();
	}
	private static class TestTotalProgressListener extends TotalProgressListener<TestImageUpdateEvent> {
		TestTotalProgressListener(Consumer<TotalProgressEvent> consumer) {
			super(consumer, new String[] { 'Pulling', 'Downloading', 'Extracting' });
		}
		@Override
		public void onUpdate(TestImageUpdateEvent event) {
			super.onUpdate(event);
			try {
				Thread.sleep(10);
			}
			catch (InterruptedException ex) {
				// Ignore
			}
		}
	}
	private static class TestImageUpdateEvent extends ImageProgressUpdateEvent {
		@JsonCreator
		TestImageUpdateEvent(String id, String status, ProgressDetail progressDetail, String progress) {
			super(id, status, progressDetail, progress);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
abstract class ProgressUpdateEventTests<E extends ProgressUpdateEvent> {
	@Test
	void getStatusReturnsStatus() {
		ProgressUpdateEvent event = createEvent();
		assertThat(event.getStatus()).isEqualTo('status');
	}
	@Test
	void getProgressDetailsReturnsProgressDetails() {
		ProgressUpdateEvent event = createEvent();
		assertThat(event.getProgressDetail().getCurrent()).isOne();
		assertThat(event.getProgressDetail().getTotal()).isEqualTo(2);
	}
	@Test
	void getProgressReturnsProgress() {
		ProgressUpdateEvent event = createEvent();
		assertThat(event.getProgress()).isEqualTo('progress');
	}
	@Test
	void progressDetailIsEmptyWhenCurrentIsNullReturnsTrue() {
		ProgressDetail detail = new ProgressDetail(null, 2);
		assertThat(ProgressDetail.isEmpty(detail)).isTrue();
	}
	@Test
	void progressDetailIsEmptyWhenTotalIsNullReturnsTrue() {
		ProgressDetail detail = new ProgressDetail(1, null);
		assertThat(ProgressDetail.isEmpty(detail)).isTrue();
	}
	@Test
	void progressDetailIsEmptyWhenTotalAndCurrentAreNotNullReturnsFalse() {
		ProgressDetail detail = new ProgressDetail(1, 2);
		assertThat(ProgressDetail.isEmpty(detail)).isFalse();
	}
	protected E createEvent() {
		return createEvent('status', new ProgressDetail(1, 2), 'progress');
	}
	protected abstract E createEvent(String status, ProgressDetail progressDetail, String progress);
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class PullUpdateEventTests extends AbstractJsonTests {
	@Test
	void readValueWhenFullDeserializesJson() throws Exception {
		PullImageUpdateEvent event = getObjectMapper().readValue(getContent('pull-update-full.json'),
				PullImageUpdateEvent.class);
		assertThat(event.getId()).isEqualTo('4f4fb700ef54');
		assertThat(event.getStatus()).isEqualTo('Extracting');
		assertThat(event.getProgressDetail().getCurrent()).isEqualTo(16);
		assertThat(event.getProgressDetail().getTotal()).isEqualTo(32);
		assertThat(event.getProgress()).isEqualTo('[==================================================>]      32B/32B');
	}
	@Test
	void readValueWhenMinimalDeserializesJson() throws Exception {
		PullImageUpdateEvent event = getObjectMapper().readValue(getContent('pull-update-minimal.json'),
				PullImageUpdateEvent.class);
		assertThat(event.getId()).isNull();
		assertThat(event.getStatus()).isEqualTo('Status: Downloaded newer image for paketo-buildpacks/cnb:base');
		assertThat(event.getProgressDetail()).isNull();
		assertThat(event.getProgress()).isNull();
	}
	@Test
	void readValueWhenEmptyDetailsDeserializesJson() throws Exception {
		PullImageUpdateEvent event = getObjectMapper().readValue(getContent('pull-with-empty-details.json'),
				PullImageUpdateEvent.class);
		assertThat(event.getId()).isEqualTo('d837a2a1365e');
		assertThat(event.getStatus()).isEqualTo('Pulling fs layer');
		assertThat(event.getProgressDetail()).isNull();
		assertThat(event.getProgress()).isNull();
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class TotalProgressEventTests {
	@Test
	void create() {
		assertThat(new TotalProgressEvent(0).getPercent()).isZero();
		assertThat(new TotalProgressEvent(10).getPercent()).isEqualTo(10);
		assertThat(new TotalProgressEvent(100).getPercent()).isEqualTo(100);
	}
	@Test
	void createWhenPercentLessThanZeroThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TotalProgressEvent(-1))
			.withMessage('Percent must be in the range 0 to 100');
	}
	@Test
	void createWhenEventMoreThanOneHundredThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TotalProgressEvent(101))
			.withMessage('Percent must be in the range 0 to 100');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class LoadImageUpdateEventTests extends ProgressUpdateEventTests<LoadImageUpdateEvent> {
	@Test
	void getStreamReturnsStream() {
		LoadImageUpdateEvent event = createEvent();
		assertThat(event.getStream()).isEqualTo('stream');
	}
	@Override
	protected LoadImageUpdateEvent createEvent(String status, ProgressDetail progressDetail, String progress) {
		return new LoadImageUpdateEvent('stream', status, progressDetail, progress);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class ExportedImageTarTests {
	@ParameterizedTest
	@ValueSource(strings = { 'export-docker-desktop.tar', 'export-docker-desktop-containerd.tar',
			'export-docker-desktop-containerd-manifest-list.tar', 'export-docker-engine.tar', 'export-podman.tar' })
	void test(String tarFile) throws Exception {
		ImageReference reference = ImageReference.of('test:latest');
		try (ExportedImageTar exportedImageTar = new ExportedImageTar(reference,
				getClass().getResourceAsStream(tarFile))) {
			Compression expectedCompression = (!tarFile.contains('containerd')) ? Compression.NONE : Compression.GZIP;
			String expectedName = (expectedCompression != Compression.GZIP)
					? '5caae51697b248b905dca1a4160864b0e1a15c300981736555cdce6567e8d477'
					: 'f0f1fd1bdc71ac6a4dc99cea5f5e45c86c5ec26fe4d1daceeb78207303606429';
			exportedImageTar.exportLayers((name, tarArchive) -> {
				assertThat(name).contains(expectedName);
				assertThat(tarArchive.getCompression()).isEqualTo(expectedCompression);
			});
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class ContentTests {
	@Test
	void ofWhenStreamIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Content.of(1, (IOSupplier<InputStream>) null))
			.withMessage('Supplier must not be null');
	}
	@Test
	void ofWhenStreamReturnsWritable() throws Exception {
		byte[] bytes = { 1, 2, 3, 4 };
		ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
		Content writable = Content.of(4, () -> inputStream);
		assertThat(writeToAndGetBytes(writable)).isEqualTo(bytes);
	}
	@Test
	void ofWhenStringIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Content.of((String) null))
			.withMessage('String must not be null');
	}
	@Test
	void ofWhenStringReturnsWritable() throws Exception {
		Content writable = Content.of('spring');
		assertThat(writeToAndGetBytes(writable)).isEqualTo('spring'.getBytes(StandardCharsets.UTF_8));
	}
	@Test
	void ofWhenBytesIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Content.of((byte[]) null))
			.withMessage('Bytes must not be null');
	}
	@Test
	void ofWhenBytesReturnsWritable() throws Exception {
		byte[] bytes = { 1, 2, 3, 4 };
		Content writable = Content.of(bytes);
		assertThat(writeToAndGetBytes(writable)).isEqualTo(bytes);
	}
	private byte[] writeToAndGetBytes(Content writable) throws IOException {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		writable.writeTo(outputStream);
		return outputStream.toByteArray();
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class ZipFileTarArchiveTests {
	@TempDir
	File tempDir;
	@Test
	void createWhenZipIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ZipFileTarArchive(null, Owner.ROOT))
			.withMessage('Zip must not be null');
	}
	@Test
	void createWhenOwnerIsNullThrowsException() throws Exception {
		File file = new File(this.tempDir, 'test.zip');
		writeTestZip(file);
		assertThatIllegalArgumentException().isThrownBy(() -> new ZipFileTarArchive(file, null))
			.withMessage('Owner must not be null');
	}
	@Test
	void writeToAdaptsContent() throws Exception {
		Owner owner = Owner.of(123, 456);
		File file = new File(this.tempDir, 'test.zip');
		writeTestZip(file);
		TarArchive tarArchive = TarArchive.fromZip(file, owner);
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		tarArchive.writeTo(outputStream);
		try (TarArchiveInputStream tarStream = new TarArchiveInputStream(
				new ByteArrayInputStream(outputStream.toByteArray()))) {
			TarArchiveEntry dirEntry = tarStream.getNextEntry();
			assertThat(dirEntry.getName()).isEqualTo('spring/');
			assertThat(dirEntry.getLongUserId()).isEqualTo(123);
			assertThat(dirEntry.getLongGroupId()).isEqualTo(456);
			TarArchiveEntry fileEntry = tarStream.getNextEntry();
			assertThat(fileEntry.getName()).isEqualTo('spring/boot');
			assertThat(fileEntry.getLongUserId()).isEqualTo(123);
			assertThat(fileEntry.getLongGroupId()).isEqualTo(456);
			assertThat(fileEntry.getSize()).isEqualTo(4);
			assertThat(fileEntry.getMode()).isEqualTo(0755);
			assertThat(tarStream).hasContent('test');
		}
	}
	private void writeTestZip(File file) throws IOException {
		try (ZipArchiveOutputStream zip = new ZipArchiveOutputStream(file)) {
			ZipArchiveEntry dirEntry = new ZipArchiveEntry('spring/');
			zip.putArchiveEntry(dirEntry);
			zip.closeArchiveEntry();
			ZipArchiveEntry fileEntry = new ZipArchiveEntry('spring/boot');
			fileEntry.setUnixMode(0755);
			zip.putArchiveEntry(fileEntry);
			zip.write('test'.getBytes(StandardCharsets.UTF_8));
			zip.closeArchiveEntry();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class InspectedContentTests {
	@Test
	void ofWhenInputStreamThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> InspectedContent.of((InputStream) null))
			.withMessage('InputStream must not be null');
	}
	@Test
	void ofWhenContentIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> InspectedContent.of((Content) null))
			.withMessage('Content must not be null');
	}
	@Test
	void ofWhenConsumerIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> InspectedContent.of((IOConsumer<OutputStream>) null))
			.withMessage('Writer must not be null');
	}
	@Test
	void ofFromContent() throws Exception {
		InspectedContent content = InspectedContent.of(Content.of('test'));
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		content.writeTo(outputStream);
		assertThat(outputStream.toByteArray()).containsExactly('test'.getBytes(StandardCharsets.UTF_8));
	}
	@Test
	void ofSmallContent() throws Exception {
		InputStream inputStream = new ByteArrayInputStream(new byte[] { 0, 1, 2 });
		InspectedContent content = InspectedContent.of(inputStream);
		assertThat(content.size()).isEqualTo(3);
		assertThat(readBytes(content)).containsExactly(0, 1, 2);
	}
	@Test
	void ofLargeContent() throws Exception {
		byte[] bytes = new byte[InspectedContent.MEMORY_LIMIT + 3];
		System.arraycopy(new byte[] { 0, 1, 2 }, 0, bytes, 0, 3);
		InputStream inputStream = new ByteArrayInputStream(bytes);
		InspectedContent content = InspectedContent.of(inputStream);
		assertThat(content.size()).isEqualTo(bytes.length);
		assertThat(readBytes(content)).isEqualTo(bytes);
	}
	@Test
	void ofWithInspector() throws Exception {
		InputStream inputStream = new ByteArrayInputStream('test'.getBytes(StandardCharsets.UTF_8));
		MessageDigest digest = MessageDigest.getInstance('SHA-256');
		InspectedContent.of(inputStream, digest::update);
		assertThat(digest.digest()).inHexadecimal()
			.contains(0x9f, 0x86, 0xd0, 0x81, 0x88, 0x4c, 0x7d, 0x65, 0x9a, 0x2f, 0xea, 0xa0, 0xc5, 0x5a, 0xd0, 0x15,
					0xa3, 0xbf, 0x4f, 0x1b, 0x2b, 0x0b, 0x82, 0x2c, 0xd1, 0x5d, 0x6c, 0x15, 0xb0, 0xf0, 0x0a, 0x08);
	}
	private byte[] readBytes(InspectedContent content) throws IOException {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		content.writeTo(outputStream);
		return outputStream.toByteArray();
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class OwnerTests {
	@Test
	void ofReturnsNewOwner() {
		Owner owner = Owner.of(123, 456);
		assertThat(owner.getUid()).isEqualTo(123);
		assertThat(owner.getGid()).isEqualTo(456);
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class FilePermissionsTests {
	@TempDir
	Path tempDir;
	@Test
	@DisabledOnOs(OS.WINDOWS)
	void umaskForPath() throws IOException {
		FileAttribute<Set<PosixFilePermission>> fileAttribute = PosixFilePermissions
			.asFileAttribute(PosixFilePermissions.fromString('rw-r-----'));
		Path tempFile = Files.createTempFile(this.tempDir, 'umask', null, fileAttribute);
		assertThat(FilePermissions.umaskForPath(tempFile)).isEqualTo(0640);
	}
	@Test
	@DisabledOnOs(OS.WINDOWS)
	void umaskForPathWithNonExistentFile() {
		assertThatIOException()
			.isThrownBy(() -> FilePermissions.umaskForPath(Paths.get(this.tempDir.toString(), 'does-not-exist')));
	}
	@Test
	@EnabledOnOs(OS.WINDOWS)
	void umaskForPathOnWindowsFails() throws IOException {
		Path tempFile = Files.createTempFile('umask', null);
		assertThatIllegalStateException().isThrownBy(() -> FilePermissions.umaskForPath(tempFile))
			.withMessageContaining('Unsupported file type for retrieving Posix attributes');
	}
	@Test
	void umaskForPathWithNullPath() {
		assertThatIllegalArgumentException().isThrownBy(() -> FilePermissions.umaskForPath(null));
	}
	@Test
	void posixPermissionsToUmask() {
		Set<PosixFilePermission> permissions = PosixFilePermissions.fromString('rwxrw-r--');
		assertThat(FilePermissions.posixPermissionsToUmask(permissions)).isEqualTo(0764);
	}
	@Test
	void posixPermissionsToUmaskWithEmptyPermissions() {
		Set<PosixFilePermission> permissions = Collections.emptySet();
		assertThat(FilePermissions.posixPermissionsToUmask(permissions)).isZero();
	}
	@Test
	void posixPermissionsToUmaskWithNullPermissions() {
		assertThatIllegalArgumentException().isThrownBy(() -> FilePermissions.posixPermissionsToUmask(null));
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class TarArchiveTests {
	@TempDir
	File tempDir;
	@Test
	void ofWritesTarContent() throws Exception {
		Owner owner = Owner.of(123, 456);
		TarArchive tarArchive = TarArchive.of((content) -> {
			content.directory('/workspace', owner);
			content.directory('/layers', owner);
			content.directory('/cnb', Owner.ROOT);
			content.directory('/cnb/buildpacks', Owner.ROOT);
			content.directory('/platform', Owner.ROOT);
			content.directory('/platform/env', Owner.ROOT);
		});
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		tarArchive.writeTo(outputStream);
		try (TarArchiveInputStream tarStream = new TarArchiveInputStream(
				new ByteArrayInputStream(outputStream.toByteArray()))) {
			List<TarArchiveEntry> entries = new ArrayList<>();
			TarArchiveEntry entry = tarStream.getNextEntry();
			while (entry != null) {
				entries.add(entry);
				entry = tarStream.getNextEntry();
			}
			assertThat(entries).hasSize(6);
			assertThat(entries.get(0).getName()).isEqualTo('/workspace/');
			assertThat(entries.get(0).getLongUserId()).isEqualTo(123);
			assertThat(entries.get(0).getLongGroupId()).isEqualTo(456);
			assertThat(entries.get(2).getName()).isEqualTo('/cnb/');
			assertThat(entries.get(2).getLongUserId()).isZero();
			assertThat(entries.get(2).getLongGroupId()).isZero();
		}
	}
	@Test
	void fromZipFileReturnsZipFileAdapter() throws Exception {
		Owner owner = Owner.of(123, 456);
		File file = new File(this.tempDir, 'test.zip');
		writeTestZip(file);
		TarArchive tarArchive = TarArchive.fromZip(file, owner);
		assertThat(tarArchive).isInstanceOf(ZipFileTarArchive.class);
	}
	private void writeTestZip(File file) throws IOException {
		try (ZipArchiveOutputStream zip = new ZipArchiveOutputStream(file)) {
			ZipArchiveEntry dirEntry = new ZipArchiveEntry('spring/');
			zip.putArchiveEntry(dirEntry);
			zip.closeArchiveEntry();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class TarLayoutWriterTests {
	@Test
	void writesTarArchive() throws Exception {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		try (TarLayoutWriter writer = new TarLayoutWriter(outputStream)) {
			writer.directory('/foo', Owner.ROOT);
			writer.file('/foo/bar.txt', Owner.of(1, 1), 0777, Content.of('test'));
		}
		try (TarArchiveInputStream tarInputStream = new TarArchiveInputStream(
				new ByteArrayInputStream(outputStream.toByteArray()))) {
			TarArchiveEntry directoryEntry = tarInputStream.getNextEntry();
			TarArchiveEntry fileEntry = tarInputStream.getNextEntry();
			byte[] fileContent = new byte[(int) fileEntry.getSize()];
			tarInputStream.read(fileContent);
			assertThat(tarInputStream.getNextEntry()).isNull();
			assertThat(directoryEntry.getName()).isEqualTo('/foo/');
			assertThat(directoryEntry.getMode()).isEqualTo(0755);
			assertThat(directoryEntry.getLongUserId()).isZero();
			assertThat(directoryEntry.getLongGroupId()).isZero();
			assertThat(directoryEntry.getModTime()).isEqualTo(new Date(TarLayoutWriter.NORMALIZED_MOD_TIME));
			assertThat(fileEntry.getName()).isEqualTo('/foo/bar.txt');
			assertThat(fileEntry.getMode()).isEqualTo(0777);
			assertThat(fileEntry.getLongUserId()).isOne();
			assertThat(fileEntry.getLongGroupId()).isOne();
			assertThat(fileEntry.getModTime()).isEqualTo(new Date(TarLayoutWriter.NORMALIZED_MOD_TIME));
			assertThat(fileContent).isEqualTo('test'.getBytes(StandardCharsets.UTF_8));
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class DefaultOwnerTests {
	@Test
	void getUidReturnsUid() {
		DefaultOwner owner = new DefaultOwner(123, 456);
		assertThat(owner.getUid()).isEqualTo(123);
	}
	@Test
	void getGidReturnsGid() {
		DefaultOwner owner = new DefaultOwner(123, 456);
		assertThat(owner.getGid()).isEqualTo(456);
	}
	@Test
	void toStringReturnsString() {
		DefaultOwner owner = new DefaultOwner(123, 456);
		assertThat(owner).hasToString('123/456');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildpackLayersMetadataTests extends AbstractJsonTests {
	@Test
	void fromImageLoadsMetadata() throws IOException {
		Image image = Image.of(getContent('buildpack-image.json'));
		BuildpackLayersMetadata metadata = BuildpackLayersMetadata.fromImage(image);
		assertThat(metadata.getBuildpack('example/hello-moon', '0.0.3')).extracting('homepage', 'layerDiffId')
			.containsExactly('https://github.com/example/tree/main/buildpacks/hello-moon',
					'sha256:4bfdc8714aee68da6662c43bc28d3b41202c88e915641c356523dabe729814c2');
		assertThat(metadata.getBuildpack('example/hello-world', '0.0.2')).extracting('homepage', 'layerDiffId')
			.containsExactly('https://github.com/example/tree/main/buildpacks/hello-world',
					'sha256:f752fe099c846e501bdc991d1a22f98c055ddc62f01cfc0495fff2c69f8eb940');
		assertThat(metadata.getBuildpack('example/hello-world', 'version-does-not-exist')).isNull();
		assertThat(metadata.getBuildpack('id-does-not-exist', '9.9.9')).isNull();
	}
	@Test
	void fromImageWhenImageIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackLayersMetadata.fromImage(null))
			.withMessage('Image must not be null');
	}
	@Test
	void fromImageWhenImageConfigIsNullThrowsException() {
		Image image = mock(Image.class);
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackLayersMetadata.fromImage(image))
			.withMessage('ImageConfig must not be null');
	}
	@Test
	void fromImageConfigWhenLabelIsMissingThrowsException() {
		Image image = mock(Image.class);
		ImageConfig imageConfig = mock(ImageConfig.class);
		given(image.getConfig()).willReturn(imageConfig);
		given(imageConfig.getLabels()).willReturn(Collections.singletonMap('alpha', 'a'));
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackLayersMetadata.fromImage(image))
			.withMessage('No "io.buildpacks.buildpack.layers" label found in image config labels "alpha"');
	}
	@Test
	void fromJsonLoadsMetadata() throws IOException {
		BuildpackLayersMetadata metadata = BuildpackLayersMetadata
			.fromJson(getContentAsString('buildpack-layers-metadata.json'));
		assertThat(metadata.getBuildpack('example/hello-moon', '0.0.3')).extracting('name', 'homepage', 'layerDiffId')
			.containsExactly('Example hello-moon buildpack',
					'https://github.com/example/tree/main/buildpacks/hello-moon',
					'sha256:4bfdc8714aee68da6662c43bc28d3b41202c88e915641c356523dabe729814c2');
		assertThat(metadata.getBuildpack('example/hello-world', '0.0.1')).extracting('name', 'homepage', 'layerDiffId')
			.containsExactly('Example hello-world buildpack',
					'https://github.com/example/tree/main/buildpacks/hello-world',
					'sha256:1c90e0b80d92555a0523c9ee6500845328fc39ba9dca9d30a877ff759ffbff28');
		assertThat(metadata.getBuildpack('example/hello-world', '0.0.2')).extracting('name', 'homepage', 'layerDiffId')
			.containsExactly('Example hello-world buildpack',
					'https://github.com/example/tree/main/buildpacks/hello-world',
					'sha256:f752fe099c846e501bdc991d1a22f98c055ddc62f01cfc0495fff2c69f8eb940');
		assertThat(metadata.getBuildpack('example/hello-world', 'version-does-not-exist')).isNull();
		assertThat(metadata.getBuildpack('id-does-not-exist', '9.9.9')).isNull();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildpacksTests {
	@Test
	void ofWhenBuildpacksIsNullReturnsEmpty() {
		Buildpacks buildpacks = Buildpacks.of(null);
		assertThat(buildpacks).isSameAs(Buildpacks.EMPTY);
		assertThat(buildpacks.getBuildpacks()).isEmpty();
	}
	@Test
	void ofReturnsBuildpacks() {
		List<Buildpack> buildpackList = new ArrayList<>();
		buildpackList.add(new TestBuildpack('example/buildpack1', '0.0.1'));
		buildpackList.add(new TestBuildpack('example/buildpack2', '0.0.2'));
		Buildpacks buildpacks = Buildpacks.of(buildpackList);
		assertThat(buildpacks.getBuildpacks()).isEqualTo(buildpackList);
	}
	@Test
	void applyWritesLayersAndOrderLayer() throws Exception {
		List<Buildpack> buildpackList = new ArrayList<>();
		buildpackList.add(new TestBuildpack('example/buildpack1', '0.0.1'));
		buildpackList.add(new TestBuildpack('example/buildpack2', '0.0.2'));
		buildpackList.add(new TestBuildpack('example/buildpack3', null));
		Buildpacks buildpacks = Buildpacks.of(buildpackList);
		List<Layer> layers = new ArrayList<>();
		buildpacks.apply(layers::add);
		assertThat(layers).hasSize(4);
		assertThatLayerContentIsCorrect(layers.get(0), 'example_buildpack1/0.0.1');
		assertThatLayerContentIsCorrect(layers.get(1), 'example_buildpack2/0.0.2');
		assertThatLayerContentIsCorrect(layers.get(2), 'example_buildpack3/null');
		assertThatOrderLayerContentIsCorrect(layers.get(3));
	}
	private void assertThatLayerContentIsCorrect(Layer layer, String path) throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		layer.writeTo(out);
		try (TarArchiveInputStream tar = new TarArchiveInputStream(new ByteArrayInputStream(out.toByteArray()))) {
			assertThat(tar.getNextEntry().getName()).isEqualTo('/cnb/buildpacks/' + path + '/buildpack.toml');
			assertThat(tar.getNextEntry()).isNull();
		}
	}
	private void assertThatOrderLayerContentIsCorrect(Layer layer) throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		layer.writeTo(out);
		try (TarArchiveInputStream tar = new TarArchiveInputStream(new ByteArrayInputStream(out.toByteArray()))) {
			assertThat(tar.getNextEntry().getName()).isEqualTo('/cnb/order.toml');
			byte[] content = StreamUtils.copyToByteArray(tar);
			String toml = new String(content, StandardCharsets.UTF_8);
			assertThat(toml).isEqualTo(getExpectedToml());
		}
	}
	private String getExpectedToml() {
		StringBuilder toml = new StringBuilder();
		toml.append('[[order]]\n');
		toml.append('\n');
		toml.append('  [[order.group]]\n');
		toml.append('    id = \'example/buildpack1\'\n');
		toml.append('    version = \'0.0.1\'\n');
		toml.append('\n');
		toml.append('  [[order.group]]\n');
		toml.append('    id = \'example/buildpack2\'\n');
		toml.append('    version = \'0.0.2\'\n');
		toml.append('\n');
		toml.append('  [[order.group]]\n');
		toml.append('    id = \'example/buildpack3\'\n');
		toml.append('\n');
		return toml.toString();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class StackIdTests {
	@Test
	void fromImageWhenImageIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> StackId.fromImage(null))
			.withMessage('Image must not be null');
	}
	@Test
	void fromImageWhenLabelIsMissingHasNoId() {
		Image image = mock(Image.class);
		ImageConfig imageConfig = mock(ImageConfig.class);
		given(image.getConfig()).willReturn(imageConfig);
		StackId stackId = StackId.fromImage(image);
		assertThat(stackId.hasId()).isFalse();
	}
	@Test
	void fromImageCreatesStackId() {
		Image image = mock(Image.class);
		ImageConfig imageConfig = mock(ImageConfig.class);
		given(image.getConfig()).willReturn(imageConfig);
		given(imageConfig.getLabels()).willReturn(Collections.singletonMap('io.buildpacks.stack.id', 'test'));
		StackId stackId = StackId.fromImage(image);
		assertThat(stackId).hasToString('test');
		assertThat(stackId.hasId()).isTrue();
	}
	@Test
	void ofCreatesStackId() {
		StackId stackId = StackId.of('test');
		assertThat(stackId).hasToString('test');
	}
	@Test
	void equalsAndHashCode() {
		StackId s1 = StackId.of('a');
		StackId s2 = StackId.of('a');
		StackId s3 = StackId.of('b');
		assertThat(s1).hasSameHashCodeAs(s2);
		assertThat(s1).isEqualTo(s1).isEqualTo(s2).isNotEqualTo(s3);
	}
	@Test
	void toStringReturnsValue() {
		StackId stackId = StackId.of('test');
		assertThat(stackId).hasToString('test');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class ApiVersionsTests {
	@Test
	void findsLatestWhenOneMatchesMajor() {
		ApiVersion version = ApiVersions.parse('1.1', '2.2').findLatestSupported('1.0');
		assertThat(version).isEqualTo(ApiVersion.parse('1.1'));
	}
	@Test
	void findsLatestWhenOneMatchesWithReleaseVersions() {
		ApiVersion version = ApiVersions.parse('1.1', '1.2').findLatestSupported('1.1');
		assertThat(version).isEqualTo(ApiVersion.parse('1.2'));
	}
	@Test
	void findsLatestWhenOneMatchesWithPreReleaseVersions() {
		ApiVersion version = ApiVersions.parse('0.2', '0.3').findLatestSupported('0.2');
		assertThat(version).isEqualTo(ApiVersion.parse('0.2'));
	}
	@Test
	void findsLatestWhenMultipleMatchesWithReleaseVersions() {
		ApiVersion version = ApiVersions.parse('1.1', '1.2').findLatestSupported('1.1', '1.2');
		assertThat(version).isEqualTo(ApiVersion.parse('1.2'));
	}
	@Test
	void findsLatestWhenMultipleMatchesWithPreReleaseVersions() {
		ApiVersion version = ApiVersions.parse('0.2', '0.3').findLatestSupported('0.2', '0.3');
		assertThat(version).isEqualTo(ApiVersion.parse('0.3'));
	}
	@Test
	void findLatestWhenNoneSupportedThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> ApiVersions.parse('1.1', '1.2').findLatestSupported('1.3', '1.4'))
			.withMessage('Detected platform API versions "1.3,1.4" are not included in supported versions "1.1,1.2"');
	}
	@Test
	void createFromRange() {
		ApiVersions versions = ApiVersions.of(1, IntStream.rangeClosed(2, 7));
		assertThat(versions).hasToString('1.2,1.3,1.4,1.5,1.6,1.7');
	}
	@Test
	void toStringReturnsString() {
		assertThat(ApiVersions.parse('1.1', '2.2', '3.3')).hasToString('1.1,2.2,3.3');
	}
	@Test
	void equalsAndHashCode() {
		ApiVersions v12a = ApiVersions.parse('1.2', '2.3');
		ApiVersions v12b = ApiVersions.parse('1.2', '2.3');
		ApiVersions v13 = ApiVersions.parse('1.3', '2.4');
		assertThat(v12a).hasSameHashCodeAs(v12b);
		assertThat(v12a).isEqualTo(v12a).isEqualTo(v12b).isNotEqualTo(v13);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildpackCoordinatesTests extends AbstractJsonTests {
	private final Path archive = Paths.get('/buildpack/path');
	@Test
	void fromToml() throws IOException {
		BuildpackCoordinates coordinates = BuildpackCoordinates
			.fromToml(createTomlStream('example/buildpack1', '0.0.1', true, false), this.archive);
		assertThat(coordinates.getId()).isEqualTo('example/buildpack1');
		assertThat(coordinates.getVersion()).isEqualTo('0.0.1');
	}
	@Test
	void fromTomlWhenMissingDescriptorThrowsException() {
		ByteArrayInputStream coordinates = new ByteArrayInputStream(''.getBytes());
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackCoordinates.fromToml(coordinates, this.archive))
			.withMessageContaining('Buildpack descriptor "buildpack.toml" is required')
			.withMessageContaining(this.archive.toString());
	}
	@Test
	void fromTomlWhenMissingIDThrowsException() throws IOException {
		try (InputStream coordinates = createTomlStream(null, null, true, false)) {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> BuildpackCoordinates.fromToml(coordinates, this.archive))
				.withMessageContaining('Buildpack descriptor must contain ID')
				.withMessageContaining(this.archive.toString());
		}
	}
	@Test
	void fromTomlWhenMissingVersionThrowsException() throws IOException {
		try (InputStream coordinates = createTomlStream('example/buildpack1', null, true, false)) {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> BuildpackCoordinates.fromToml(coordinates, this.archive))
				.withMessageContaining('Buildpack descriptor must contain version')
				.withMessageContaining(this.archive.toString());
		}
	}
	@Test
	void fromTomlWhenMissingStacksAndOrderThrowsException() throws IOException {
		try (InputStream coordinates = createTomlStream('example/buildpack1', '0.0.1', false, false)) {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> BuildpackCoordinates.fromToml(coordinates, this.archive))
				.withMessageContaining('Buildpack descriptor must contain either "stacks" or "order"')
				.withMessageContaining(this.archive.toString());
		}
	}
	@Test
	void fromTomlWhenContainsBothStacksAndOrderThrowsException() throws IOException {
		try (InputStream coordinates = createTomlStream('example/buildpack1', '0.0.1', true, true)) {
			assertThatIllegalArgumentException()
				.isThrownBy(() -> BuildpackCoordinates.fromToml(coordinates, this.archive))
				.withMessageContaining('Buildpack descriptor must not contain both "stacks" and "order"')
				.withMessageContaining(this.archive.toString());
		}
	}
	@Test
	void fromBuildpackMetadataWhenMetadataIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackCoordinates.fromBuildpackMetadata(null))
			.withMessage('BuildpackMetadata must not be null');
	}
	@Test
	void fromBuildpackMetadataReturnsCoordinates() throws Exception {
		BuildpackMetadata metadata = BuildpackMetadata.fromJson(getContentAsString('buildpack-metadata.json'));
		BuildpackCoordinates coordinates = BuildpackCoordinates.fromBuildpackMetadata(metadata);
		assertThat(coordinates.getId()).isEqualTo('example/hello-universe');
		assertThat(coordinates.getVersion()).isEqualTo('0.0.1');
	}
	@Test
	void ofWhenIdIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackCoordinates.of(null, null))
			.withMessage('ID must not be empty');
	}
	@Test
	void ofReturnsCoordinates() {
		BuildpackCoordinates coordinates = BuildpackCoordinates.of('id', '1');
		assertThat(coordinates).hasToString('id@1');
	}
	@Test
	void getIdReturnsId() {
		BuildpackCoordinates coordinates = BuildpackCoordinates.of('id', '1');
		assertThat(coordinates.getId()).isEqualTo('id');
	}
	@Test
	void getVersionReturnsVersion() {
		BuildpackCoordinates coordinates = BuildpackCoordinates.of('id', '1');
		assertThat(coordinates.getVersion()).isEqualTo('1');
	}
	@Test
	void getVersionWhenVersionIsNullReturnsNull() {
		BuildpackCoordinates coordinates = BuildpackCoordinates.of('id', null);
		assertThat(coordinates.getVersion()).isNull();
	}
	@Test
	void toStringReturnsNiceString() {
		BuildpackCoordinates coordinates = BuildpackCoordinates.of('id', '1');
		assertThat(coordinates).hasToString('id@1');
	}
	@Test
	void equalsAndHashCode() {
		BuildpackCoordinates c1a = BuildpackCoordinates.of('id', '1');
		BuildpackCoordinates c1b = BuildpackCoordinates.of('id', '1');
		BuildpackCoordinates c2 = BuildpackCoordinates.of('id', '2');
		assertThat(c1a).isEqualTo(c1a).isEqualTo(c1b).isNotEqualTo(c2);
		assertThat(c1a).hasSameHashCodeAs(c1b);
	}
	private InputStream createTomlStream(String id, String version, boolean includeStacks, boolean includeOrder) {
		StringBuilder builder = new StringBuilder();
		builder.append('[buildpack]\n');
		if (id != null) {
			builder.append('id = \'').append(id).append('\'\n');
		}
		if (version != null) {
			builder.append('version = \'').append(version).append('\'\n');
		}
		builder.append('name = \'Example buildpack\'\n');
		builder.append('homepage = \'https://github.com/example/example-buildpack\'\n');
		if (includeStacks) {
			builder.append('[[stacks]]\n');
			builder.append('id = \'io.buildpacks.stacks.bionic\'\n');
		}
		if (includeOrder) {
			builder.append('[[order]]\n');
			builder.append('group = [ { id = \'example/buildpack2\', version=\'0.0.2\' } ]\n');
		}
		return new ByteArrayInputStream(builder.toString().getBytes(StandardCharsets.UTF_8));
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class ImageBuildpackTests extends AbstractJsonTests {
	private String longFilePath;
	@BeforeEach
	void setUp() {
		StringBuilder path = new StringBuilder();
		new Random().ints("a", "z" + 1).limit(100).forEach((i) -> path.append((char) i));
		this.longFilePath = path.toString();
	}
	@Test
	void resolveWhenFullyQualifiedReferenceReturnsBuildpack() throws Exception {
		Image image = Image.of(getContent('buildpack-image.json'));
		ImageReference imageReference = ImageReference.of('example/buildpack1:1.0.0');
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.getBuildpackLayersMetadata()).willReturn(BuildpackLayersMetadata.fromJson('{}'));
		given(resolverContext.fetchImage(eq(imageReference), eq(ImageType.BUILDPACK))).willReturn(image);
		willAnswer(this::withMockLayers).given(resolverContext).exportImageLayers(eq(imageReference), any());
		BuildpackReference reference = BuildpackReference.of('docker://example/buildpack1:1.0.0');
		Buildpack buildpack = ImageBuildpack.resolve(resolverContext, reference);
		assertThat(buildpack.getCoordinates()).hasToString('example/hello-universe@0.0.1');
		assertAppliesExpectedLayers(buildpack);
	}
	@Test
	void resolveWhenUnqualifiedReferenceReturnsBuildpack() throws Exception {
		Image image = Image.of(getContent('buildpack-image.json'));
		ImageReference imageReference = ImageReference.of('example/buildpack1:1.0.0');
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.getBuildpackLayersMetadata()).willReturn(BuildpackLayersMetadata.fromJson('{}'));
		given(resolverContext.fetchImage(eq(imageReference), eq(ImageType.BUILDPACK))).willReturn(image);
		willAnswer(this::withMockLayers).given(resolverContext).exportImageLayers(eq(imageReference), any());
		BuildpackReference reference = BuildpackReference.of('example/buildpack1:1.0.0');
		Buildpack buildpack = ImageBuildpack.resolve(resolverContext, reference);
		assertThat(buildpack.getCoordinates()).hasToString('example/hello-universe@0.0.1');
		assertAppliesExpectedLayers(buildpack);
	}
	@Test
	void resolveReferenceWithoutTagUsesLatestTag() throws Exception {
		Image image = Image.of(getContent('buildpack-image.json'));
		ImageReference imageReference = ImageReference.of('example/buildpack1:latest');
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.getBuildpackLayersMetadata()).willReturn(BuildpackLayersMetadata.fromJson('{}'));
		given(resolverContext.fetchImage(eq(imageReference), eq(ImageType.BUILDPACK))).willReturn(image);
		willAnswer(this::withMockLayers).given(resolverContext).exportImageLayers(eq(imageReference), any());
		BuildpackReference reference = BuildpackReference.of('example/buildpack1');
		Buildpack buildpack = ImageBuildpack.resolve(resolverContext, reference);
		assertThat(buildpack.getCoordinates()).hasToString('example/hello-universe@0.0.1');
		assertAppliesExpectedLayers(buildpack);
	}
	@Test
	void resolveReferenceWithDigestUsesDigest() throws Exception {
		Image image = Image.of(getContent('buildpack-image.json'));
		String digest = 'sha256:4acb6bfd6c4f0cabaf7f3690e444afe51f1c7de54d51da7e63fac709c56f1c30';
		ImageReference imageReference = ImageReference.of('example/buildpack1@' + digest);
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.getBuildpackLayersMetadata()).willReturn(BuildpackLayersMetadata.fromJson('{}'));
		given(resolverContext.fetchImage(eq(imageReference), eq(ImageType.BUILDPACK))).willReturn(image);
		willAnswer(this::withMockLayers).given(resolverContext).exportImageLayers(eq(imageReference), any());
		BuildpackReference reference = BuildpackReference.of('example/buildpack1@' + digest);
		Buildpack buildpack = ImageBuildpack.resolve(resolverContext, reference);
		assertThat(buildpack.getCoordinates()).hasToString('example/hello-universe@0.0.1');
		assertAppliesExpectedLayers(buildpack);
	}
	@Test
	void resolveWhenBuildpackExistsInBuilderSkipsLayers() throws Exception {
		Image image = Image.of(getContent('buildpack-image.json'));
		ImageReference imageReference = ImageReference.of('example/buildpack1:1.0.0');
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.getBuildpackLayersMetadata())
			.willReturn(BuildpackLayersMetadata.fromJson(getContentAsString('buildpack-layers-metadata.json')));
		given(resolverContext.fetchImage(eq(imageReference), eq(ImageType.BUILDPACK))).willReturn(image);
		willAnswer(this::withMockLayers).given(resolverContext).exportImageLayers(eq(imageReference), any());
		BuildpackReference reference = BuildpackReference.of('docker://example/buildpack1:1.0.0');
		Buildpack buildpack = ImageBuildpack.resolve(resolverContext, reference);
		assertThat(buildpack.getCoordinates()).hasToString('example/hello-universe@0.0.1');
		assertAppliesNoLayers(buildpack);
	}
	@Test
	void resolveWhenWhenImageNotPulledThrowsException() throws Exception {
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.fetchImage(any(), any())).willThrow(IOException.class);
		BuildpackReference reference = BuildpackReference.of('docker://example/buildpack1');
		assertThatIllegalArgumentException().isThrownBy(() -> ImageBuildpack.resolve(resolverContext, reference))
			.withMessageContaining('Error pulling buildpack image')
			.withMessageContaining('example/buildpack1:latest');
	}
	@Test
	void resolveWhenMissingMetadataLabelThrowsException() throws Exception {
		Image image = Image.of(getContent('image.json'));
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.fetchImage(any(), any())).willReturn(image);
		BuildpackReference reference = BuildpackReference.of('docker://example/buildpack1:latest');
		assertThatIllegalArgumentException().isThrownBy(() -> ImageBuildpack.resolve(resolverContext, reference))
			.withMessageContaining('No "io.buildpacks.buildpackage.metadata" label found');
	}
	@Test
	void resolveWhenFullyQualifiedReferenceWithInvalidImageReferenceThrowsException() {
		BuildpackReference reference = BuildpackReference.of('docker://buildpack@0.0.1');
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		assertThatIllegalArgumentException().isThrownBy(() -> ImageBuildpack.resolve(resolverContext, reference))
			.withMessageContaining('Unable to parse image reference \'buildpack@0.0.1\'');
	}
	@Test
	void resolveWhenUnqualifiedReferenceWithInvalidImageReferenceReturnsNull() {
		BuildpackReference reference = BuildpackReference.of('buildpack@0.0.1');
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		Buildpack buildpack = ImageBuildpack.resolve(resolverContext, reference);
		assertThat(buildpack).isNull();
	}
	private Object withMockLayers(InvocationOnMock invocation) {
		try {
			IOBiConsumer<String, TarArchive> consumer = invocation.getArgument(1);
			File tarFile = File.createTempFile('create-builder-test-', null);
			try (TarArchiveOutputStream tarOut = new TarArchiveOutputStream(new FileOutputStream(tarFile))) {
				tarOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);
				writeTarEntry(tarOut, '/cnb/');
				writeTarEntry(tarOut, '/cnb/buildpacks/');
				writeTarEntry(tarOut, '/cnb/buildpacks/example_buildpack/');
				writeTarEntry(tarOut, '/cnb/buildpacks/example_buildpack/0.0.1/');
				writeTarEntry(tarOut, '/cnb/buildpacks/example_buildpack/0.0.1/buildpack.toml');
				writeTarEntry(tarOut, '/cnb/buildpacks/example_buildpack/0.0.1/' + this.longFilePath);
				tarOut.finish();
			}
			try (FileInputStream tarFileStream = new FileInputStream(tarFile)) {
				consumer.accept('test', TarArchive.fromInputStream(tarFileStream, Compression.NONE));
			}
			Files.delete(tarFile.toPath());
		}
		catch (IOException ex) {
			fail('Error writing mock layers', ex);
		}
		return null;
	}
	private void writeTarEntry(TarArchiveOutputStream tarOut, String name) throws IOException {
		TarArchiveEntry entry = new TarArchiveEntry(name);
		tarOut.putArchiveEntry(entry);
		tarOut.closeArchiveEntry();
	}
	private void assertAppliesExpectedLayers(Buildpack buildpack) throws IOException {
		List<ByteArrayOutputStream> layers = new ArrayList<>();
		buildpack.apply((layer) -> {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			layer.writeTo(out);
			layers.add(out);
		});
		assertThat(layers).hasSize(1);
		byte[] content = layers.get(0).toByteArray();
		List<TarArchiveEntry> entries = new ArrayList<>();
		try (TarArchiveInputStream tar = new TarArchiveInputStream(new ByteArrayInputStream(content))) {
			TarArchiveEntry entry = tar.getNextEntry();
			while (entry != null) {
				entries.add(entry);
				entry = tar.getNextEntry();
			}
		}
		assertThat(entries).extracting('name', 'mode')
			.containsExactlyInAnyOrder(tuple('cnb/', TarArchiveEntry.DEFAULT_DIR_MODE),
					tuple('cnb/buildpacks/', TarArchiveEntry.DEFAULT_DIR_MODE),
					tuple('cnb/buildpacks/example_buildpack/', TarArchiveEntry.DEFAULT_DIR_MODE),
					tuple('cnb/buildpacks/example_buildpack/0.0.1/', TarArchiveEntry.DEFAULT_DIR_MODE),
					tuple('cnb/buildpacks/example_buildpack/0.0.1/buildpack.toml', TarArchiveEntry.DEFAULT_FILE_MODE),
					tuple('cnb/buildpacks/example_buildpack/0.0.1/' + this.longFilePath,
							TarArchiveEntry.DEFAULT_FILE_MODE));
	}
	private void assertAppliesNoLayers(Buildpack buildpack) throws IOException {
		List<ByteArrayOutputStream> layers = new ArrayList<>();
		buildpack.apply((layer) -> {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			layer.writeTo(out);
			layers.add(out);
		});
		assertThat(layers).isEmpty();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
@DisabledOnOs(OS.WINDOWS)
class DirectoryBuildpackTests {
	@TempDir
	File temp;
	private File buildpackDir;
	private BuildpackResolverContext resolverContext;
	@BeforeEach
	void setUp() {
		this.buildpackDir = new File(this.temp, 'buildpack');
		this.buildpackDir.mkdirs();
		this.resolverContext = mock(BuildpackResolverContext.class);
	}
	@Test
	void resolveWhenPath() throws Exception {
		writeBuildpackDescriptor();
		writeScripts();
		BuildpackReference reference = BuildpackReference.of(this.buildpackDir.toString());
		Buildpack buildpack = DirectoryBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNotNull();
		assertThat(buildpack.getCoordinates()).hasToString('example/buildpack1@0.0.1');
		assertHasExpectedLayers(buildpack);
	}
	@Test
	void resolveWhenFileUrl() throws Exception {
		writeBuildpackDescriptor();
		writeScripts();
		BuildpackReference reference = BuildpackReference.of('file://' + this.buildpackDir.toString());
		Buildpack buildpack = DirectoryBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNotNull();
		assertThat(buildpack.getCoordinates()).hasToString('example/buildpack1@0.0.1');
		assertHasExpectedLayers(buildpack);
	}
	@Test
	void resolveWhenDirectoryWithoutBuildpackTomlThrowsException() throws Exception {
		Files.createDirectories(this.buildpackDir.toPath());
		BuildpackReference reference = BuildpackReference.of(this.buildpackDir.toString());
		assertThatIllegalArgumentException()
			.isThrownBy(() -> DirectoryBuildpack.resolve(this.resolverContext, reference))
			.withMessageContaining('Buildpack descriptor "buildpack.toml" is required')
			.withMessageContaining(this.buildpackDir.getAbsolutePath());
	}
	@Test
	void resolveWhenFileReturnsNull() throws Exception {
		Path file = Files.createFile(Paths.get(this.buildpackDir.toString(), 'test'));
		BuildpackReference reference = BuildpackReference.of(file.toString());
		Buildpack buildpack = DirectoryBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNull();
	}
	@Test
	void resolveWhenDirectoryDoesNotExistReturnsNull() {
		BuildpackReference reference = BuildpackReference.of('/test/a/missing/buildpack');
		Buildpack buildpack = DirectoryBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNull();
	}
	@Test
	void locateDirectoryAsUrlThatDoesNotExistThrowsException() {
		BuildpackReference reference = BuildpackReference.of('file:///test/a/missing/buildpack');
		Buildpack buildpack = DirectoryBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNull();
	}
	private void assertHasExpectedLayers(Buildpack buildpack) throws IOException {
		List<ByteArrayOutputStream> layers = new ArrayList<>();
		buildpack.apply((layer) -> {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			layer.writeTo(out);
			layers.add(out);
		});
		assertThat(layers).hasSize(1);
		byte[] content = layers.get(0).toByteArray();
		try (TarArchiveInputStream tar = new TarArchiveInputStream(new ByteArrayInputStream(content))) {
			List<TarArchiveEntry> entries = new ArrayList<>();
			TarArchiveEntry entry = tar.getNextEntry();
			while (entry != null) {
				entries.add(entry);
				entry = tar.getNextEntry();
			}
			assertThat(entries).extracting('name', 'mode')
				.containsExactlyInAnyOrder(tuple('/cnb/', 0755), tuple('/cnb/buildpacks/', 0755),
						tuple('/cnb/buildpacks/example_buildpack1/', 0755),
						tuple('/cnb/buildpacks/example_buildpack1/0.0.1/', 0755),
						tuple('/cnb/buildpacks/example_buildpack1/0.0.1/buildpack.toml', 0644),
						tuple('/cnb/buildpacks/example_buildpack1/0.0.1/bin/', 0755),
						tuple('/cnb/buildpacks/example_buildpack1/0.0.1/bin/detect', 0744),
						tuple('/cnb/buildpacks/example_buildpack1/0.0.1/bin/build', 0744));
		}
	}
	private void writeBuildpackDescriptor() throws IOException {
		Path descriptor = Files.createFile(Paths.get(this.buildpackDir.getAbsolutePath(), 'buildpack.toml'),
				PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString('rw-r--r--')));
		try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(descriptor))) {
			writer.println('[buildpack]');
			writer.println('id = \'example/buildpack1\'');
			writer.println('version = \'0.0.1\'');
			writer.println('name = \'Example buildpack\'');
			writer.println('homepage = \'https://github.com/example/example-buildpack\'');
			writer.println('[[stacks]]');
			writer.println('id = \'io.buildpacks.stacks.bionic\'');
		}
	}
	private void writeScripts() throws IOException {
		Path binDirectory = Files.createDirectory(Paths.get(this.buildpackDir.getAbsolutePath(), 'bin'),
				PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString('rwxr-xr-x')));
		binDirectory.toFile().mkdirs();
		Path detect = Files.createFile(Paths.get(binDirectory.toString(), 'detect'),
				PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString('rwxr--r--')));
		try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(detect))) {
			writer.println('#!/usr/bin/env bash');
			writer.println('echo \'---> detect\'');
		}
		Path build = Files.createFile(Paths.get(binDirectory.toString(), 'build'),
				PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString('rwxr--r--')));
		try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(build))) {
			writer.println('#!/usr/bin/env bash');
			writer.println('echo \'---> build\'');
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class TestTarGzip {
	private final File buildpackDir;
	TestTarGzip(File buildpackDir) {
		this.buildpackDir = buildpackDir;
	}
	Path createArchive() throws Exception {
		return createArchive(true);
	}
	Path createEmptyArchive() throws Exception {
		return createArchive(false);
	}
	private Path createArchive(boolean addContent) throws Exception {
		Path path = Paths.get(this.buildpackDir.getAbsolutePath(), 'buildpack.tar');
		Path archive = Files.createFile(path);
		if (addContent) {
			writeBuildpackContentToArchive(archive);
		}
		return compressBuildpackArchive(archive);
	}
	private Path compressBuildpackArchive(Path archive) throws Exception {
		Path tgzPath = Paths.get(this.buildpackDir.getAbsolutePath(), 'buildpack.tgz');
		FileCopyUtils.copy(Files.newInputStream(archive),
				new GzipCompressorOutputStream(Files.newOutputStream(tgzPath)));
		return tgzPath;
	}
	private void writeBuildpackContentToArchive(Path archive) throws Exception {
		StringBuilder buildpackToml = new StringBuilder();
		buildpackToml.append('[buildpack]\n');
		buildpackToml.append('id = \'example/buildpack1\'\n');
		buildpackToml.append('version = \'0.0.1\'\n');
		buildpackToml.append('name = \'Example buildpack\'\n');
		buildpackToml.append('homepage = \'https://github.com/example/example-buildpack\'\n');
		buildpackToml.append('[[stacks]]\n');
		buildpackToml.append('id = \'io.buildpacks.stacks.bionic\'\n');
		String detectScript = '''
				#!/usr/bin/env bash
				echo '---> detect'
				''';
		String buildScript = '''
				#!/usr/bin/env bash
				echo '---> build'
				''';
		try (TarArchiveOutputStream tar = new TarArchiveOutputStream(Files.newOutputStream(archive))) {
			writeEntry(tar, 'buildpack.toml', buildpackToml.toString());
			writeEntry(tar, 'bin/');
			writeEntry(tar, 'bin/detect', detectScript);
			writeEntry(tar, 'bin/build', buildScript);
			tar.finish();
		}
	}
	private void writeEntry(TarArchiveOutputStream tar, String entryName) throws IOException {
		TarArchiveEntry entry = new TarArchiveEntry(entryName);
		tar.putArchiveEntry(entry);
		tar.closeArchiveEntry();
	}
	private void writeEntry(TarArchiveOutputStream tar, String entryName, String content) throws IOException {
		TarArchiveEntry entry = new TarArchiveEntry(entryName);
		entry.setSize(content.length());
		tar.putArchiveEntry(entry);
		IOUtils.copy(new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8)), tar);
		tar.closeArchiveEntry();
	}
	void assertHasExpectedLayers(Buildpack buildpack) throws IOException {
		List<ByteArrayOutputStream> layers = new ArrayList<>();
		buildpack.apply((layer) -> {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			layer.writeTo(out);
			layers.add(out);
		});
		assertThat(layers).hasSize(1);
		byte[] content = layers.get(0).toByteArray();
		try (TarArchiveInputStream tar = new TarArchiveInputStream(new ByteArrayInputStream(content))) {
			assertThat(tar.getNextEntry().getName()).isEqualTo('cnb/');
			assertThat(tar.getNextEntry().getName()).isEqualTo('cnb/buildpacks/');
			assertThat(tar.getNextEntry().getName()).isEqualTo('cnb/buildpacks/example_buildpack1/');
			assertThat(tar.getNextEntry().getName()).isEqualTo('cnb/buildpacks/example_buildpack1/0.0.1/');
			assertThat(tar.getNextEntry().getName())
				.isEqualTo('cnb/buildpacks/example_buildpack1/0.0.1/buildpack.toml');
			assertThat(tar.getNextEntry().getName()).isEqualTo('cnb/buildpacks/example_buildpack1/0.0.1/bin/');
			assertThat(tar.getNextEntry().getName()).isEqualTo('cnb/buildpacks/example_buildpack1/0.0.1/bin/detect');
			assertThat(tar.getNextEntry().getName()).isEqualTo('cnb/buildpacks/example_buildpack1/0.0.1/bin/build');
			assertThat(tar.getNextEntry()).isNull();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildRequestTests {
	private static final ZoneId UTC = ZoneId.of('UTC');
	@TempDir
	File tempDir;
	@Test
	void forJarFileReturnsRequest() throws IOException {
		File jarFile = new File(this.tempDir, 'my-app-0.0.1.jar');
		writeTestJarFile(jarFile);
		BuildRequest request = BuildRequest.forJarFile(jarFile);
		assertThat(request.getName()).hasToString('docker.io/library/my-app:0.0.1');
		assertThat(request.getBuilder()).hasToString('docker.io/' + BuildRequest.DEFAULT_BUILDER_IMAGE_REF);
		assertThat(request.getApplicationContent(Owner.ROOT)).satisfies(this::hasExpectedJarContent);
		assertThat(request.getEnv()).isEmpty();
	}
	@Test
	void forJarFileWithNameReturnsRequest() throws IOException {
		File jarFile = new File(this.tempDir, 'my-app-0.0.1.jar');
		writeTestJarFile(jarFile);
		BuildRequest request = BuildRequest.forJarFile(ImageReference.of('test-app'), jarFile);
		assertThat(request.getName()).hasToString('docker.io/library/test-app:latest');
		assertThat(request.getBuilder()).hasToString('docker.io/' + BuildRequest.DEFAULT_BUILDER_IMAGE_REF);
		assertThat(request.getApplicationContent(Owner.ROOT)).satisfies(this::hasExpectedJarContent);
		assertThat(request.getEnv()).isEmpty();
	}
	@Test
	void forJarFileWhenJarFileIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildRequest.forJarFile(null))
			.withMessage('JarFile must not be null');
	}
	@Test
	void forJarFileWhenJarFileIsMissingThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> BuildRequest.forJarFile(new File(this.tempDir, 'missing.jar')))
			.withMessage('JarFile must exist');
	}
	@Test
	void forJarFileWhenJarFileIsDirectoryThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildRequest.forJarFile(this.tempDir))
			.withMessage('JarFile must be a file');
	}
	@Test
	void withBuilderUpdatesBuilder() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'))
			.withBuilder(ImageReference.of('spring/builder'));
		assertThat(request.getBuilder()).hasToString('docker.io/spring/builder:latest');
		assertThat(request.isTrustBuilder()).isFalse();
	}
	@Test
	void withBuilderWhenHasDigestUpdatesBuilder() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'))
			.withBuilder(ImageReference
				.of('spring/builder@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d'));
		assertThat(request.getBuilder()).hasToString(
				'docker.io/spring/builder@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(request.isTrustBuilder()).isFalse();
	}
	@Test
	void withoutBuilderTrustsDefaultBuilder() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThat(request.isTrustBuilder()).isTrue();
	}
	@Test
	void withoutBuilderTrustsDefaultBuilderWithDifferentTag() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'))
			.withBuilder(ImageReference.of(ImageName.of(BuildRequest.DEFAULT_BUILDER_IMAGE_NAME), 'other'));
		assertThat(request.isTrustBuilder()).isTrue();
	}
	@Test
	void withoutBuilderTrustsDefaultBuilderWithDigest() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'))
			.withBuilder(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)
				.withDigest('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d'));
		assertThat(request.isTrustBuilder()).isTrue();
	}
	@ParameterizedTest
	@MethodSource('trustedBuilders')
	void withKnownTrustedBuilderTrustsBuilder(ImageReference builder) throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar')).withBuilder(builder);
		assertThat(request.isTrustBuilder()).isTrue();
	}
	static Stream<ImageReference> trustedBuilders() {
		return BuildRequest.KNOWN_TRUSTED_BUILDERS.stream();
	}
	@Test
	void withoutTrustBuilderAndDefaultBuilderUpdatesTrustsBuilder() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar')).withTrustBuilder(false);
		assertThat(request.isTrustBuilder()).isFalse();
	}
	@Test
	void withTrustBuilderAndBuilderUpdatesTrustBuilder() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'))
			.withBuilder(ImageReference.of('spring/builder'))
			.withTrustBuilder(true);
		assertThat(request.isTrustBuilder()).isTrue();
	}
	@Test
	void withRunImageUpdatesRunImage() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'))
			.withRunImage(ImageReference.of('example.com/custom/run-image:latest'));
		assertThat(request.getRunImage()).hasToString('example.com/custom/run-image:latest');
	}
	@Test
	void withRunImageWhenHasDigestUpdatesRunImage() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'))
			.withRunImage(ImageReference
				.of('example.com/custom/run-image@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d'));
		assertThat(request.getRunImage()).hasToString(
				'example.com/custom/run-image@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void withCreatorUpdatesCreator() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withCreator = request.withCreator(Creator.withVersion('1.0.0'));
		assertThat(request.getCreator().getName()).isEqualTo('Spring Boot');
		assertThat(request.getCreator().getVersion()).isEmpty();
		assertThat(withCreator.getCreator().getName()).isEqualTo('Spring Boot');
		assertThat(withCreator.getCreator().getVersion()).isEqualTo('1.0.0');
	}
	@Test
	void withEnvAddsEnvEntry() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withEnv = request.withEnv('spring', 'boot');
		assertThat(request.getEnv()).isEmpty();
		assertThat(withEnv.getEnv()).containsExactly(entry('spring', 'boot'));
	}
	@Test
	void withEnvMapAddsEnvEntries() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		Map<String, String> env = new LinkedHashMap<>();
		env.put('spring', 'boot');
		env.put('test', 'test');
		BuildRequest withEnv = request.withEnv(env);
		assertThat(request.getEnv()).isEmpty();
		assertThat(withEnv.getEnv()).containsExactly(entry('spring', 'boot'), entry('test', 'test'));
	}
	@Test
	void withEnvWhenKeyIsNullThrowsException() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withEnv(null, 'test'))
			.withMessage('Name must not be empty');
	}
	@Test
	void withEnvWhenValueIsNullThrowsException() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withEnv('test', null))
			.withMessage('Value must not be empty');
	}
	@Test
	void withBuildpacksAddsBuildpacks() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildpackReference buildpackReference1 = BuildpackReference.of('example/buildpack1');
		BuildpackReference buildpackReference2 = BuildpackReference.of('example/buildpack2');
		BuildRequest withBuildpacks = request.withBuildpacks(buildpackReference1, buildpackReference2);
		assertThat(request.getBuildpacks()).isEmpty();
		assertThat(withBuildpacks.getBuildpacks()).containsExactly(buildpackReference1, buildpackReference2);
	}
	@Test
	void withBuildpacksWhenBuildpacksIsNullThrowsException() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withBuildpacks((List<BuildpackReference>) null))
			.withMessage('Buildpacks must not be null');
	}
	@Test
	void withBindingsAddsBindings() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withBindings = request.withBindings(Binding.of('/host/path:/container/path:ro'),
				Binding.of('volume-name:/container/path:rw'));
		assertThat(request.getBindings()).isEmpty();
		assertThat(withBindings.getBindings()).containsExactly(Binding.of('/host/path:/container/path:ro'),
				Binding.of('volume-name:/container/path:rw'));
	}
	@Test
	void withBindingsWhenBindingsIsNullThrowsException() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withBindings((List<Binding>) null))
			.withMessage('Bindings must not be null');
	}
	@Test
	void withNetworkUpdatesNetwork() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar')).withNetwork('test');
		assertThat(request.getNetwork()).isEqualTo('test');
	}
	@Test
	void withTagsAddsTags() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withTags = request.withTags(ImageReference.of('docker.io/library/my-app:latest'),
				ImageReference.of('example.com/custom/my-app:0.0.1'),
				ImageReference.of('example.com/custom/my-app:latest'));
		assertThat(request.getTags()).isEmpty();
		assertThat(withTags.getTags()).containsExactly(ImageReference.of('docker.io/library/my-app:latest'),
				ImageReference.of('example.com/custom/my-app:0.0.1'),
				ImageReference.of('example.com/custom/my-app:latest'));
	}
	@Test
	void withTagsWhenTagsIsNullThrowsException() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withTags((List<ImageReference>) null))
			.withMessage('Tags must not be null');
	}
	@Test
	void withBuildWorkspaceVolumeAddsWorkspace() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withWorkspace = request.withBuildWorkspace(Cache.volume('build-workspace'));
		assertThat(request.getBuildWorkspace()).isNull();
		assertThat(withWorkspace.getBuildWorkspace()).isEqualTo(Cache.volume('build-workspace'));
	}
	@Test
	void withBuildWorkspaceBindAddsWorkspace() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withWorkspace = request.withBuildWorkspace(Cache.bind('/tmp/build-workspace'));
		assertThat(request.getBuildWorkspace()).isNull();
		assertThat(withWorkspace.getBuildWorkspace()).isEqualTo(Cache.bind('/tmp/build-workspace'));
	}
	@Test
	void withBuildVolumeCacheAddsCache() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withCache = request.withBuildCache(Cache.volume('build-volume'));
		assertThat(request.getBuildCache()).isNull();
		assertThat(withCache.getBuildCache()).isEqualTo(Cache.volume('build-volume'));
	}
	@Test
	void withBuildBindCacheAddsCache() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withCache = request.withBuildCache(Cache.bind('/tmp/build-cache'));
		assertThat(request.getBuildCache()).isNull();
		assertThat(withCache.getBuildCache()).isEqualTo(Cache.bind('/tmp/build-cache'));
	}
	@Test
	void withBuildVolumeCacheWhenCacheIsNullThrowsException() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withBuildCache(null))
			.withMessage('BuildCache must not be null');
	}
	@Test
	void withLaunchVolumeCacheAddsCache() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withCache = request.withLaunchCache(Cache.volume('launch-volume'));
		assertThat(request.getLaunchCache()).isNull();
		assertThat(withCache.getLaunchCache()).isEqualTo(Cache.volume('launch-volume'));
	}
	@Test
	void withLaunchBindCacheAddsCache() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withCache = request.withLaunchCache(Cache.bind('/tmp/launch-cache'));
		assertThat(request.getLaunchCache()).isNull();
		assertThat(withCache.getLaunchCache()).isEqualTo(Cache.bind('/tmp/launch-cache'));
	}
	@Test
	void withLaunchVolumeCacheWhenCacheIsNullThrowsException() throws IOException {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withLaunchCache(null))
			.withMessage('LaunchCache must not be null');
	}
	@Test
	void withCreatedDateSetsCreatedDate() throws Exception {
		Instant createDate = Instant.now();
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withCreatedDate = request.withCreatedDate(createDate.toString());
		assertThat(withCreatedDate.getCreatedDate()).isEqualTo(createDate);
	}
	@Test
	void withCreatedDateNowSetsCreatedDate() throws Exception {
		OffsetDateTime now = OffsetDateTime.now(UTC);
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withCreatedDate = request.withCreatedDate('now');
		OffsetDateTime createdDate = OffsetDateTime.ofInstant(withCreatedDate.getCreatedDate(), UTC);
		assertThat(createdDate.getYear()).isEqualTo(now.getYear());
		assertThat(createdDate.getMonth()).isEqualTo(now.getMonth());
		assertThat(createdDate.getDayOfMonth()).isEqualTo(now.getDayOfMonth());
		withCreatedDate = request.withCreatedDate('NOW');
		createdDate = OffsetDateTime.ofInstant(withCreatedDate.getCreatedDate(), UTC);
		assertThat(createdDate.getYear()).isEqualTo(now.getYear());
		assertThat(createdDate.getMonth()).isEqualTo(now.getMonth());
		assertThat(createdDate.getDayOfMonth()).isEqualTo(now.getDayOfMonth());
	}
	@Test
	void withCreatedDateAndInvalidDateThrowsException() throws Exception {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		assertThatIllegalArgumentException().isThrownBy(() -> request.withCreatedDate('not a date'))
			.withMessageContaining('"not a date"');
	}
	@Test
	void withApplicationDirectorySetsApplicationDirectory() throws Exception {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withAppDir = request.withApplicationDirectory('/application');
		assertThat(withAppDir.getApplicationDirectory()).isEqualTo('/application');
	}
	@Test
	void withSecurityOptionsSetsSecurityOptions() throws Exception {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withAppDir = request.withSecurityOptions(List.of('label=user:USER', 'label=role:ROLE'));
		assertThat(withAppDir.getSecurityOptions()).containsExactly('label=user:USER', 'label=role:ROLE');
	}
	@Test
	void withPlatformSetsPlatform() throws Exception {
		BuildRequest request = BuildRequest.forJarFile(writeTestJarFile('my-app-0.0.1.jar'));
		BuildRequest withAppDir = request.withImagePlatform('linux/arm64');
		assertThat(withAppDir.getImagePlatform()).isEqualTo(ImagePlatform.of('linux/arm64'));
	}
	private void hasExpectedJarContent(TarArchive archive) {
		try {
			ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
			archive.writeTo(outputStream);
			try (TarArchiveInputStream tar = new TarArchiveInputStream(
					new ByteArrayInputStream(outputStream.toByteArray()))) {
				assertThat(tar.getNextEntry().getName()).isEqualTo('spring/');
				assertThat(tar.getNextEntry().getName()).isEqualTo('spring/boot');
				assertThat(tar.getNextEntry()).isNull();
			}
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private File writeTestJarFile(String name) throws IOException {
		File file = new File(this.tempDir, name);
		writeTestJarFile(file);
		return file;
	}
	private void writeTestJarFile(File file) throws IOException {
		try (ZipArchiveOutputStream zip = new ZipArchiveOutputStream(file)) {
			ZipArchiveEntry dirEntry = new ZipArchiveEntry('spring/');
			zip.putArchiveEntry(dirEntry);
			zip.closeArchiveEntry();
			ZipArchiveEntry fileEntry = new ZipArchiveEntry('spring/boot');
			zip.putArchiveEntry(fileEntry);
			zip.write('test'.getBytes(StandardCharsets.UTF_8));
			zip.closeArchiveEntry();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildOwnerTests {
	@Test
	void fromEnvReturnsOwner() {
		Map<String, String> env = new LinkedHashMap<>();
		env.put('CNB_USER_ID', '123');
		env.put('CNB_GROUP_ID', '456');
		BuildOwner owner = BuildOwner.fromEnv(env);
		assertThat(owner.getUid()).isEqualTo(123);
		assertThat(owner.getGid()).isEqualTo(456);
		assertThat(owner).hasToString('123/456');
	}
	@Test
	void fromEnvWhenEnvIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildOwner.fromEnv(null))
			.withMessage('Env must not be null');
	}
	@Test
	void fromEnvWhenUserPropertyIsMissingThrowsException() {
		Map<String, String> env = new LinkedHashMap<>();
		env.put('CNB_GROUP_ID', '456');
		assertThatIllegalStateException().isThrownBy(() -> BuildOwner.fromEnv(env))
			.withMessage('Missing "CNB_USER_ID" value from the builder environment "' + env + '"');
	}
	@Test
	void fromEnvWhenGroupPropertyIsMissingThrowsException() {
		Map<String, String> env = new LinkedHashMap<>();
		env.put('CNB_USER_ID', '123');
		assertThatIllegalStateException().isThrownBy(() -> BuildOwner.fromEnv(env))
			.withMessage('Missing "CNB_GROUP_ID" value from the builder environment "' + env + '"');
	}
	@Test
	void fromEnvWhenUserPropertyIsMalformedThrowsException() {
		Map<String, String> env = new LinkedHashMap<>();
		env.put('CNB_USER_ID', 'nope');
		env.put('CNB_GROUP_ID', '456');
		assertThatIllegalStateException().isThrownBy(() -> BuildOwner.fromEnv(env))
			.withMessage('Malformed "CNB_USER_ID" value "nope" in the builder environment "' + env + '"');
	}
	@Test
	void fromEnvWhenGroupPropertyIsMalformedThrowsException() {
		Map<String, String> env = new LinkedHashMap<>();
		env.put('CNB_USER_ID', '123');
		env.put('CNB_GROUP_ID', 'nope');
		assertThatIllegalStateException().isThrownBy(() -> BuildOwner.fromEnv(env))
			.withMessage('Malformed "CNB_GROUP_ID" value "nope" in the builder environment "' + env + '"');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class PhaseTests {
	private static final String[] NO_ARGS = {};
	@Test
	void getNameReturnsName() {
		Phase phase = new Phase('test', false);
		assertThat(phase.getName()).isEqualTo('test');
	}
	@Test
	void toStringReturnsName() {
		Phase phase = new Phase('test', false);
		assertThat(phase).hasToString('test');
	}
	@Test
	void applyUpdatesConfiguration() {
		Phase phase = new Phase('test', false);
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test', NO_ARGS);
		then(update).should().withLabel('author', 'spring-boot');
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithDaemonAccessUpdatesConfigurationWithRootUser() {
		Phase phase = new Phase('test', false);
		phase.withDaemonAccess();
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withUser('root');
		then(update).should().withCommand('/cnb/lifecycle/test', '-daemon');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithLogLevelArgAndVerboseLoggingUpdatesConfigurationWithLogLevel() {
		Phase phase = new Phase('test', true);
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test', '-log-level', 'debug');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithLogLevelArgAndNonVerboseLoggingDoesNotUpdateLogLevel() {
		Phase phase = new Phase('test', false);
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithArgsUpdatesConfigurationWithArguments() {
		Phase phase = new Phase('test', false);
		phase.withArgs('a', 'b', 'c');
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test', 'a', 'b', 'c');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithBindsUpdatesConfigurationWithBinds() {
		Phase phase = new Phase('test', false);
		VolumeName volumeName = VolumeName.of('test');
		phase.withBinding(Binding.from(volumeName, '/test'));
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).should().withBinding(Binding.from(volumeName, '/test'));
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithEnvUpdatesConfigurationWithEnv() {
		Phase phase = new Phase('test', false);
		phase.withEnv('name1', 'value1');
		phase.withEnv('name2', 'value2');
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).should().withEnv('name1', 'value1');
		then(update).should().withEnv('name2', 'value2');
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithNetworkModeUpdatesConfigurationWithNetworkMode() {
		Phase phase = new Phase('test', false);
		phase.withNetworkMode('test');
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test');
		then(update).should().withNetworkMode('test');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).shouldHaveNoMoreInteractions();
	}
	@Test
	void applyWhenWithSecurityOptionsUpdatesConfigurationWithSecurityOptions() {
		Phase phase = new Phase('test', false);
		phase.withSecurityOption('option1=value1');
		phase.withSecurityOption('option2=value2');
		Update update = mock(Update.class);
		phase.apply(update);
		then(update).should().withCommand('/cnb/lifecycle/test');
		then(update).should().withLabel('author', 'spring-boot');
		then(update).should().withSecurityOption('option1=value1');
		then(update).should().withSecurityOption('option2=value2');
		then(update).shouldHaveNoMoreInteractions();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class LifecycleVersionTests {
	@Test
	void parseWhenValueIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LifecycleVersion.parse(null))
			.withMessage('Value must not be empty');
	}
	@Test
	void parseWhenTooLongThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LifecycleVersion.parse('v1.2.3.4'))
			.withMessage('Malformed version number "1.2.3.4"');
	}
	@Test
	void parseWhenNonNumericThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LifecycleVersion.parse('v1.2.3a'))
			.withMessage('Malformed version number "1.2.3a"');
	}
	@Test
	void compareTo() {
		LifecycleVersion v4 = LifecycleVersion.parse('0.0.4');
		assertThat(LifecycleVersion.parse('0.0.3')).isLessThan(v4);
		assertThat(LifecycleVersion.parse('0.0.4')).isEqualByComparingTo(v4);
		assertThat(LifecycleVersion.parse('0.0.5')).isGreaterThan(v4);
	}
	@Test
	void isEqualOrGreaterThan() {
		LifecycleVersion v4 = LifecycleVersion.parse('0.0.4');
		assertThat(LifecycleVersion.parse('0.0.3').isEqualOrGreaterThan(v4)).isFalse();
		assertThat(LifecycleVersion.parse('0.0.4').isEqualOrGreaterThan(v4)).isTrue();
		assertThat(LifecycleVersion.parse('0.0.5').isEqualOrGreaterThan(v4)).isTrue();
	}
	@Test
	void parseReturnsVersion() {
		assertThat(LifecycleVersion.parse('1.2.3')).hasToString('v1.2.3');
		assertThat(LifecycleVersion.parse('1.2')).hasToString('v1.2.0');
		assertThat(LifecycleVersion.parse('1')).hasToString('v1.0.0');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildLogTests {
	@Test
	void toSystemOutPrintsToSystemOut() {
		BuildLog log = BuildLog.toSystemOut();
		assertThat(log).isInstanceOf(PrintStreamBuildLog.class);
		assertThat(log).extracting('out').isSameAs(System.out);
	}
	@Test
	void toPrintsToOutput() {
		BuildLog log = BuildLog.to(System.err);
		assertThat(log).isInstanceOf(PrintStreamBuildLog.class);
		assertThat(log).extracting('out').isSameAs(System.err);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class PrintStreamBuildLogTests {
	@Test
	void printsExpectedOutput() throws Exception {
		TestPrintStream out = new TestPrintStream();
		PrintStreamBuildLog log = new PrintStreamBuildLog(out);
		BuildRequest request = mock(BuildRequest.class);
		ImageReference name = ImageReference.of('my-app:latest');
		ImageReference builderImageReference = ImageReference.of('cnb/builder');
		ImagePlatform platform = ImagePlatform.of('linux/arm64/v1');
		Image builderImage = mock(Image.class);
		given(builderImage.getDigests()).willReturn(Collections.singletonList('00000001'));
		ImageReference runImageReference = ImageReference.of('cnb/runner');
		Image runImage = mock(Image.class);
		given(runImage.getDigests()).willReturn(Collections.singletonList('00000002'));
		given(request.getName()).willReturn(name);
		ImageReference tag = ImageReference.of('my-app:1.0');
		given(request.getTags()).willReturn(Collections.singletonList(tag));
		log.start(request);
		Consumer<TotalProgressEvent> pullBuildImageConsumer = log.pullingImage(builderImageReference, null,
				ImageType.BUILDER);
		pullBuildImageConsumer.accept(new TotalProgressEvent(100));
		log.pulledImage(builderImage, ImageType.BUILDER);
		Consumer<TotalProgressEvent> pullRunImageConsumer = log.pullingImage(runImageReference, platform,
				ImageType.RUNNER);
		pullRunImageConsumer.accept(new TotalProgressEvent(100));
		log.pulledImage(runImage, ImageType.RUNNER);
		log.executingLifecycle(request, LifecycleVersion.parse('0.5'), Cache.volume(VolumeName.of('pack-abc.cache')));
		Consumer<LogUpdateEvent> phase1Consumer = log.runningPhase(request, 'alphabet');
		phase1Consumer.accept(mockLogEvent('one'));
		phase1Consumer.accept(mockLogEvent('two'));
		phase1Consumer.accept(mockLogEvent('three'));
		Consumer<LogUpdateEvent> phase2Consumer = log.runningPhase(request, 'basket');
		phase2Consumer.accept(mockLogEvent('spring'));
		phase2Consumer.accept(mockLogEvent('boot'));
		log.executedLifecycle(request);
		log.taggedImage(tag);
		String expected = FileCopyUtils.copyToString(new InputStreamReader(
				getClass().getResourceAsStream('print-stream-build-log.txt'), StandardCharsets.UTF_8));
		assertThat(out.toString()).isEqualToIgnoringNewLines(expected);
	}
	private LogUpdateEvent mockLogEvent(String string) {
		LogUpdateEvent event = mock(LogUpdateEvent.class);
		given(event.toString()).willReturn(string);
		return event;
	}
	static class TestPrintStream extends PrintStream {
		TestPrintStream() {
			super(new ByteArrayOutputStream());
		}
		@Override
		public String toString() {
			return this.out.toString();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuilderTests {
	@Test
	void createWhenLogIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Builder((BuildLog) null))
			.withMessage('Log must not be null');
	}
	@Test
	void createWithDockerConfiguration() {
		Builder builder = new Builder(BuildLog.toSystemOut());
		assertThat(builder).isNotNull();
	}
	@Test
	void buildWhenRequestIsNullThrowsException() {
		Builder builder = new Builder();
		assertThatIllegalArgumentException().isThrownBy(() -> builder.build(null))
			.withMessage('Request must not be null');
	}
	@Test
	void buildInvokesBuilder() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest();
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull());
		then(docker.image()).should()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull());
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
		then(docker.image()).shouldHaveNoMoreInteractions();
	}
	@Test
	void buildInvokesBuilderAndPublishesImage() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		DockerConfiguration dockerConfiguration = new DockerConfiguration()
			.withBuilderRegistryTokenAuthentication('builder token')
			.withPublishRegistryTokenAuthentication('publish token');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(),
					eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader())))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader())))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, dockerConfiguration);
		BuildRequest request = getTestRequest().withPublish(true);
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(),
					eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()));
		then(docker.image()).should()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()));
		then(docker.image()).should()
			.push(eq(request.getName()), any(),
					eq(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()));
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
		then(docker.image()).shouldHaveNoMoreInteractions();
	}
	@Test
	void buildInvokesBuilderWithDefaultImageTags() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image-with-no-run-image-tag.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of('gcr.io/paketo-buildpacks/builder:latest')), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:latest')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withBuilder(ImageReference.of('gcr.io/paketo-buildpacks/builder'));
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
	}
	@Test
	void buildInvokesBuilderWithRunImageInDigestForm() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image-with-run-image-digest.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference
				.of('docker.io/cloudfoundry/run@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d')),
					eq(ImagePlatform.from(builderImage)), any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest();
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
	}
	@Test
	void buildInvokesBuilderWithNoStack() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image-with-empty-stack.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of('gcr.io/paketo-buildpacks/builder:latest')), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withBuilder(ImageReference.of('gcr.io/paketo-buildpacks/builder'));
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
	}
	@Test
	void buildInvokesBuilderWithRunImageFromRequest() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('example.com/custom/run:latest')), eq(ImagePlatform.from(builderImage)), any(),
					isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withRunImage(ImageReference.of('example.com/custom/run:latest'));
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
	}
	@Test
	void buildInvokesBuilderWithNeverPullPolicy() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		given(docker.image().inspect(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF))))
			.willReturn(builderImage);
		given(docker.image().inspect(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb'))))
			.willReturn(runImage);
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withPullPolicy(PullPolicy.NEVER);
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
		then(docker.image()).should(never()).pull(any(), any(), any());
		then(docker.image()).should(times(2)).inspect(any());
	}
	@Test
	void buildInvokesBuilderWithAlwaysPullPolicy() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		given(docker.image().inspect(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF))))
			.willReturn(builderImage);
		given(docker.image().inspect(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb'))))
			.willReturn(runImage);
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withPullPolicy(PullPolicy.ALWAYS);
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
		then(docker.image()).should(times(2)).pull(any(), any(), any(), isNull());
		then(docker.image()).should(never()).inspect(any());
	}
	@Test
	void buildInvokesBuilderWithIfNotPresentPullPolicy() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		given(docker.image().inspect(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF))))
			.willThrow(
					new DockerEngineException('docker://localhost/', new URI('example'), 404, 'NOT FOUND', null, null))
			.willReturn(builderImage);
		given(docker.image().inspect(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb'))))
			.willThrow(
					new DockerEngineException('docker://localhost/', new URI('example'), 404, 'NOT FOUND', null, null))
			.willReturn(runImage);
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withPullPolicy(PullPolicy.IF_NOT_PRESENT);
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
		then(docker.image()).should(times(2)).inspect(any());
		then(docker.image()).should(times(2)).pull(any(), any(), any(), isNull());
	}
	@Test
	void buildInvokesBuilderWithTags() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withTags(ImageReference.of('my-application:1.2.3'));
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		assertThat(out.toString()).contains('Successfully created image tag "docker.io/library/my-application:1.2.3"');
		then(docker.image()).should().tag(eq(request.getName()), eq(ImageReference.of('my-application:1.2.3')));
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
	}
	@Test
	void buildInvokesBuilderWithTagsAndPublishesImageAndTags() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		DockerConfiguration dockerConfiguration = new DockerConfiguration()
			.withBuilderRegistryTokenAuthentication('builder token')
			.withPublishRegistryTokenAuthentication('publish token');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(),
					eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader())))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader())))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, dockerConfiguration);
		BuildRequest request = getTestRequest().withPublish(true).withTags(ImageReference.of('my-application:1.2.3'));
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		assertThat(out.toString()).contains('Successfully created image tag "docker.io/library/my-application:1.2.3"');
		then(docker.image()).should()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(),
					eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()));
		then(docker.image()).should()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()));
		then(docker.image()).should()
			.push(eq(request.getName()), any(),
					eq(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()));
		then(docker.image()).should().tag(eq(request.getName()), eq(ImageReference.of('my-application:1.2.3')));
		then(docker.image()).should()
			.push(eq(ImageReference.of('my-application:1.2.3')), any(),
					eq(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()));
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
		then(docker.image()).shouldHaveNoMoreInteractions();
	}
	@Test
	void buildInvokesBuilderWithPlatform() throws Exception {
		TestPrintStream out = new TestPrintStream();
		ImagePlatform platform = ImagePlatform.of('linux/arm64/v1');
		DockerApi docker = mockDockerApi(platform);
		Image builderImage = loadImage('image-with-platform.json');
		Image runImage = loadImage('run-image-with-platform.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), eq(platform), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(platform), any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withImagePlatform('linux/arm64/v1');
		builder.build(request);
		assertThat(out.toString()).contains('Running creator');
		assertThat(out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
		ArgumentCaptor<ImageArchive> archive = ArgumentCaptor.forClass(ImageArchive.class);
		then(docker.image()).should()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), eq(platform), any(), isNull());
		then(docker.image()).should()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(platform), any(), isNull());
		then(docker.image()).should().load(archive.capture(), any());
		then(docker.image()).should().remove(archive.getValue().getTag(), true);
		then(docker.image()).shouldHaveNoMoreInteractions();
	}
	@Test
	void buildWhenStackIdDoesNotMatchThrowsException() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image-with-bad-stack.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest();
		assertThatIllegalStateException().isThrownBy(() -> builder.build(request))
			.withMessage(
					'Run image stack "org.cloudfoundry.stacks.cfwindowsfs3" does not match builder stack "io.buildpacks.stacks.bionic"');
	}
	@Test
	void buildWhenBuilderReturnsErrorThrowsException() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApiLifecycleError();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest();
		assertThatExceptionOfType(BuilderException.class).isThrownBy(() -> builder.build(request))
			.withMessage('Builder lifecycle "creator" failed with status code 9');
	}
	@Test
	void buildWhenDetectedRunImageInDifferentAuthenticatedRegistryThrowsException() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image-with-run-image-different-registry.json');
		DockerConfiguration dockerConfiguration = new DockerConfiguration()
			.withBuilderRegistryTokenAuthentication('builder token');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), any(), any(),
					eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader())))
			.willAnswer(withPulledImage(builderImage));
		Builder builder = new Builder(BuildLog.to(out), docker, dockerConfiguration);
		BuildRequest request = getTestRequest();
		assertThatIllegalStateException().isThrownBy(() -> builder.build(request))
			.withMessage(
					'Run image "example.com/custom/run:latest" must be pulled from the "docker.io" authenticated registry');
	}
	@Test
	void buildWhenRequestedRunImageInDifferentAuthenticatedRegistryThrowsException() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		DockerConfiguration dockerConfiguration = new DockerConfiguration()
			.withBuilderRegistryTokenAuthentication('builder token');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), any(), any(),
					eq(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader())))
			.willAnswer(withPulledImage(builderImage));
		Builder builder = new Builder(BuildLog.to(out), docker, dockerConfiguration);
		BuildRequest request = getTestRequest().withRunImage(ImageReference.of('example.com/custom/run:latest'));
		assertThatIllegalStateException().isThrownBy(() -> builder.build(request))
			.withMessage(
					'Run image "example.com/custom/run:latest" must be pulled from the "docker.io" authenticated registry');
	}
	@Test
	void buildWhenRequestedBuildpackNotInBuilderThrowsException() throws Exception {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApiLifecycleError();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), any(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image().pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), any(), any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildpackReference reference = BuildpackReference.of('urn:cnb:builder:example/buildpack@1.2.3');
		BuildRequest request = getTestRequest().withBuildpacks(reference);
		assertThatIllegalArgumentException().isThrownBy(() -> builder.build(request))
			.withMessageContaining('"urn:cnb:builder:example/buildpack@1.2.3"')
			.withMessageContaining('not found in builder');
	}
	@Test
	void logsWarningIfBindingWithSensitiveTargetIsDetected() throws IOException {
		TestPrintStream out = new TestPrintStream();
		DockerApi docker = mockDockerApi();
		Image builderImage = loadImage('image.json');
		Image runImage = loadImage('run-image.json');
		given(docker.image()
			.pull(eq(ImageReference.of(BuildRequest.DEFAULT_BUILDER_IMAGE_REF)), isNull(), any(), isNull()))
			.willAnswer(withPulledImage(builderImage));
		given(docker.image()
			.pull(eq(ImageReference.of('docker.io/cloudfoundry/run:base-cnb')), eq(ImagePlatform.from(builderImage)),
					any(), isNull()))
			.willAnswer(withPulledImage(runImage));
		Builder builder = new Builder(BuildLog.to(out), docker, null);
		BuildRequest request = getTestRequest().withBindings(Binding.from('/host', '/cnb'));
		builder.build(request);
		assertThat(out.toString()).contains(
				'Warning: Binding "/host:/cnb" uses a container path which is used by buildpacks while building. Binding to it can cause problems!');
	}
	private DockerApi mockDockerApi() throws IOException {
		return mockDockerApi(null);
	}
	private DockerApi mockDockerApi(ImagePlatform platform) throws IOException {
		ContainerApi containerApi = mock(ContainerApi.class);
		ContainerReference reference = ContainerReference.of('container-ref');
		given(containerApi.create(any(), eq(platform), any())).willReturn(reference);
		given(containerApi.wait(eq(reference))).willReturn(ContainerStatus.of(0, null));
		ImageApi imageApi = mock(ImageApi.class);
		VolumeApi volumeApi = mock(VolumeApi.class);
		DockerApi docker = mock(DockerApi.class);
		given(docker.image()).willReturn(imageApi);
		given(docker.container()).willReturn(containerApi);
		given(docker.volume()).willReturn(volumeApi);
		return docker;
	}
	private DockerApi mockDockerApiLifecycleError() throws IOException {
		ContainerApi containerApi = mock(ContainerApi.class);
		ContainerReference reference = ContainerReference.of('container-ref');
		given(containerApi.create(any(), isNull(), any())).willReturn(reference);
		given(containerApi.wait(eq(reference))).willReturn(ContainerStatus.of(9, null));
		ImageApi imageApi = mock(ImageApi.class);
		VolumeApi volumeApi = mock(VolumeApi.class);
		DockerApi docker = mock(DockerApi.class);
		given(docker.image()).willReturn(imageApi);
		given(docker.container()).willReturn(containerApi);
		given(docker.volume()).willReturn(volumeApi);
		return docker;
	}
	private BuildRequest getTestRequest() {
		TarArchive content = mock(TarArchive.class);
		ImageReference name = ImageReference.of('my-application');
		return BuildRequest.of(name, (owner) -> content).withTrustBuilder(true);
	}
	private Image loadImage(String name) throws IOException {
		return Image.of(getClass().getResourceAsStream(name));
	}
	private Answer<Image> withPulledImage(Image image) {
		return (invocation) -> {
			TotalProgressPullListener listener = invocation.getArgument(2, TotalProgressPullListener.class);
			listener.onStart();
			listener.onFinish();
			return image;
		};
	}
	static class TestPrintStream extends PrintStream {
		TestPrintStream() {
			super(new ByteArrayOutputStream());
		}
		@Override
		public String toString() {
			return this.out.toString();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class TarGzipBuildpackTests {
	private File buildpackDir;
	private TestTarGzip testTarGzip;
	private BuildpackResolverContext resolverContext;
	@BeforeEach
	void setUp(@TempDir File temp) {
		this.buildpackDir = new File(temp, 'buildpack');
		this.buildpackDir.mkdirs();
		this.testTarGzip = new TestTarGzip(this.buildpackDir);
		this.resolverContext = mock(BuildpackResolverContext.class);
	}
	@Test
	void resolveWhenFilePathReturnsBuildpack() throws Exception {
		Path compressedArchive = this.testTarGzip.createArchive();
		BuildpackReference reference = BuildpackReference.of(compressedArchive.toString());
		Buildpack buildpack = TarGzipBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNotNull();
		assertThat(buildpack.getCoordinates()).hasToString('example/buildpack1@0.0.1');
		this.testTarGzip.assertHasExpectedLayers(buildpack);
	}
	@Test
	void resolveWhenFileUrlReturnsBuildpack() throws Exception {
		Path compressedArchive = this.testTarGzip.createArchive();
		BuildpackReference reference = BuildpackReference.of(compressedArchive.toUri().toString());
		Buildpack buildpack = TarGzipBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).as('Buildpack %s resolved from reference %s', buildpack, reference).isNotNull();
		assertThat(buildpack.getCoordinates()).hasToString('example/buildpack1@0.0.1');
		this.testTarGzip.assertHasExpectedLayers(buildpack);
	}
	@Test
	void resolveWhenArchiveWithoutDescriptorThrowsException() throws Exception {
		Path compressedArchive = this.testTarGzip.createEmptyArchive();
		BuildpackReference reference = BuildpackReference.of(compressedArchive.toString());
		assertThatIllegalArgumentException().isThrownBy(() -> TarGzipBuildpack.resolve(this.resolverContext, reference))
			.withMessageContaining('Buildpack descriptor "buildpack.toml" is required')
			.withMessageContaining(compressedArchive.toString());
	}
	@Test
	void resolveWhenArchiveWithDirectoryReturnsNull() {
		BuildpackReference reference = BuildpackReference.of(this.buildpackDir.getAbsolutePath());
		Buildpack buildpack = TarGzipBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNull();
	}
	@Test
	void resolveWhenArchiveThatDoesNotExistReturnsNull() {
		BuildpackReference reference = BuildpackReference.of('/test/i/am/missing/buildpack.tar');
		Buildpack buildpack = TarGzipBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNull();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuilderExceptionTests {
	@Test
	void create() {
		BuilderException exception = new BuilderException('detector', 1);
		assertThat(exception.getOperation()).isEqualTo('detector');
		assertThat(exception.getStatusCode()).isOne();
		assertThat(exception.getMessage()).isEqualTo('Builder lifecycle "detector" failed with status code 1');
	}
	@Test
	void createWhenOperationIsNull() {
		BuilderException exception = new BuilderException(null, 1);
		assertThat(exception.getOperation()).isNull();
		assertThat(exception.getStatusCode()).isOne();
		assertThat(exception.getMessage()).isEqualTo('Builder failed with status code 1');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class LifecycleTests {
	private TestPrintStream out;
	private DockerApi docker;
	private final Map<String, ContainerConfig> configs = new LinkedHashMap<>();
	private final Map<String, ContainerContent> content = new LinkedHashMap<>();
	@BeforeEach
	void setup() {
		this.out = new TestPrintStream();
		this.docker = mockDockerApi();
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		createLifecycle(trustBuilder).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@Test
	void executeWithBindingsExecutesPhases() throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(true).withBindings(Binding.of('/host/src/path:/container/dest/path:ro'),
				Binding.of('volume-name:/container/volume/path:rw'));
		createLifecycle(request).execute();
		assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-bindings.json'));
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@Test
	void executeExecutesPhasesWithPlatformApi03() throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		createLifecycle(true, 'builder-metadata-platform-api-0.3.json').execute();
		assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-platform-api-0.3.json'));
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeOnlyUploadsContentOnce(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		createLifecycle(trustBuilder).execute();
		assertThat(this.content).hasSize(1);
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWhenAlreadyRunThrowsException(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		Lifecycle lifecycle = createLifecycle(trustBuilder);
		lifecycle.execute();
		assertThatIllegalStateException().isThrownBy(lifecycle::execute)
			.withMessage('Lifecycle has already been executed');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWhenBuilderReturnsErrorThrowsException(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(9, null));
		assertThatExceptionOfType(BuilderException.class).isThrownBy(() -> createLifecycle(trustBuilder).execute())
			.withMessage(
					'Builder lifecycle "' + ((trustBuilder) ? 'creator' : 'analyzer') + '" failed with status code 9');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWhenCleanCacheClearsCache(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder).withCleanCache(true);
		createLifecycle(request).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-clean-cache.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter.json'));
			assertThat(this.out.toString()).contains('Skipping restorer because "cleanCache" is enabled');
		}
		VolumeName name = VolumeName.of('pack-cache-b35197ac41ea.build');
		then(this.docker.volume()).should().delete(name, true);
	}
	@Test
	void executeWhenPlatformApiNotSupportedThrowsException() throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		assertThatIllegalStateException()
			.isThrownBy(() -> createLifecycle(true, 'builder-metadata-unsupported-api.json').execute())
			.withMessageContaining('Detected platform API versions "0.2" are not included in supported versions');
	}
	@Test
	void executeWhenMultiplePlatformApisNotSupportedThrowsException() throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		assertThatIllegalStateException()
			.isThrownBy(() -> createLifecycle(true, 'builder-metadata-unsupported-apis.json').execute())
			.withMessageContaining('Detected platform API versions "0.1,0.2" are not included in supported versions');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWhenMultiplePlatformApisSupportedExecutesPhase(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		createLifecycle(trustBuilder, 'builder-metadata-supported-apis.json').execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter.json'));
		}
	}
	@Test
	void closeClearsVolumes() throws Exception {
		createLifecycle(true).close();
		then(this.docker.volume()).should().delete(VolumeName.of('pack-layers-aaaaaaaaaa'), true);
		then(this.docker.volume()).should().delete(VolumeName.of('pack-app-aaaaaaaaaa'), true);
	}
	@Test
	void executeWithNetworkExecutesPhases() throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(true).withNetwork('test');
		createLifecycle(request).execute();
		assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-network.json'));
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithCacheVolumeNamesExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder).withBuildWorkspace(Cache.volume('work-volume'))
			.withBuildCache(Cache.volume('build-volume'))
			.withLaunchCache(Cache.volume('launch-volume'));
		createLifecycle(request).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-cache-volumes.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer-cache-volumes.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector-cache-volumes.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer-cache-volumes.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder-cache-volumes.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter-cache-volumes.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithCacheBindMountsExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder).withBuildWorkspace(Cache.bind('/tmp/work'))
			.withBuildCache(Cache.bind('/tmp/build-cache'))
			.withLaunchCache(Cache.bind('/tmp/launch-cache'));
		createLifecycle(request).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-cache-bind-mounts.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer-cache-bind-mounts.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector-cache-bind-mounts.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer-cache-bind-mounts.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder-cache-bind-mounts.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter-cache-bind-mounts.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithCreatedDateExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder).withCreatedDate('2020-07-01T12:34:56Z');
		createLifecycle(request).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-created-date.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter-created-date.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithApplicationDirectoryExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder).withApplicationDirectory('/application');
		createLifecycle(request).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-app-dir.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector-app-dir.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder-app-dir.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter-app-dir.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithSecurityOptionsExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder)
			.withSecurityOptions(List.of('label=user:USER', 'label=role:ROLE'));
		createLifecycle(request).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-security-opts.json', true));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer-security-opts.json', true));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer-security-opts.json', true));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter-security-opts.json', true));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithDockerHostAndRemoteAddressExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder);
		createLifecycle(request, ResolvedDockerHost.from(DockerHostConfiguration.forAddress('tcp://192.168.1.2:2376')))
			.execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-inherit-remote.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer-inherit-remote.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer-inherit-remote.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter-inherit-remote.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithDockerHostAndLocalAddressExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), isNull())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), isNull(), any())).willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder);
		createLifecycle(request, ResolvedDockerHost.from(DockerHostConfiguration.forAddress('/var/alt.sock')))
			.execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator-inherit-local.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer-inherit-local.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer-inherit-local.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter-inherit-local.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	@ParameterizedTest
	@BooleanValueSource
	void executeWithImagePlatformExecutesPhases(boolean trustBuilder) throws Exception {
		given(this.docker.container().create(any(), eq(ImagePlatform.of('linux/arm64'))))
			.willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().create(any(), eq(ImagePlatform.of('linux/arm64')), any()))
			.willAnswer(answerWithGeneratedContainerId());
		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null));
		BuildRequest request = getTestRequest(trustBuilder).withImagePlatform('linux/arm64');
		createLifecycle(request).execute();
		if (trustBuilder) {
			assertPhaseWasRun('creator', withExpectedConfig('lifecycle-creator.json'));
		}
		else {
			assertPhaseWasRun('analyzer', withExpectedConfig('lifecycle-analyzer.json'));
			assertPhaseWasRun('detector', withExpectedConfig('lifecycle-detector.json'));
			assertPhaseWasRun('restorer', withExpectedConfig('lifecycle-restorer.json'));
			assertPhaseWasRun('builder', withExpectedConfig('lifecycle-builder.json'));
			assertPhaseWasRun('exporter', withExpectedConfig('lifecycle-exporter.json'));
		}
		assertThat(this.out.toString()).contains('Successfully built image "docker.io/library/my-application:latest"');
	}
	private DockerApi mockDockerApi() {
		DockerApi docker = mock(DockerApi.class);
		ImageApi imageApi = mock(ImageApi.class);
		ContainerApi containerApi = mock(ContainerApi.class);
		VolumeApi volumeApi = mock(VolumeApi.class);
		given(docker.image()).willReturn(imageApi);
		given(docker.container()).willReturn(containerApi);
		given(docker.volume()).willReturn(volumeApi);
		return docker;
	}
	private BuildRequest getTestRequest(boolean trustBuilder) {
		TarArchive content = mock(TarArchive.class);
		ImageReference name = ImageReference.of('my-application');
		return BuildRequest.of(name, (owner) -> content)
			.withRunImage(ImageReference.of('cloudfoundry/run'))
			.withTrustBuilder(trustBuilder);
	}
	private Lifecycle createLifecycle(boolean trustBuilder) throws IOException {
		return createLifecycle(getTestRequest(trustBuilder));
	}
	private Lifecycle createLifecycle(BuildRequest request) throws IOException {
		EphemeralBuilder builder = mockEphemeralBuilder();
		return createLifecycle(request, builder);
	}
	private Lifecycle createLifecycle(boolean trustBuilder, String builderMetadata) throws IOException {
		EphemeralBuilder builder = mockEphemeralBuilder(builderMetadata);
		return createLifecycle(getTestRequest(trustBuilder), builder);
	}
	private Lifecycle createLifecycle(BuildRequest request, ResolvedDockerHost dockerHost) throws IOException {
		EphemeralBuilder builder = mockEphemeralBuilder();
		return new TestLifecycle(BuildLog.to(this.out), this.docker, dockerHost, request, builder);
	}
	private Lifecycle createLifecycle(BuildRequest request, EphemeralBuilder ephemeralBuilder) {
		return new TestLifecycle(BuildLog.to(this.out), this.docker, null, request, ephemeralBuilder);
	}
	private EphemeralBuilder mockEphemeralBuilder() throws IOException {
		return mockEphemeralBuilder('builder-metadata.json');
	}
	private EphemeralBuilder mockEphemeralBuilder(String builderMetadata) throws IOException {
		EphemeralBuilder builder = mock(EphemeralBuilder.class);
		byte[] metadataContent = FileCopyUtils.copyToByteArray(getClass().getResourceAsStream(builderMetadata));
		BuilderMetadata metadata = BuilderMetadata.fromJson(new String(metadataContent, StandardCharsets.UTF_8));
		given(builder.getName()).willReturn(ImageReference.of('pack.local/ephemeral-builder'));
		given(builder.getBuilderMetadata()).willReturn(metadata);
		return builder;
	}
	private Answer<ContainerReference> answerWithGeneratedContainerId() {
		return (invocation) -> {
			ContainerConfig config = invocation.getArgument(0, ContainerConfig.class);
			ArrayNode command = getCommand(config);
			String name = command.get(0).asText().substring(1).replaceAll('/', '-');
			this.configs.put(name, config);
			if (invocation.getArguments().length > 2) {
				this.content.put(name, invocation.getArgument(2, ContainerContent.class));
			}
			return ContainerReference.of(name);
		};
	}
	private ArrayNode getCommand(ContainerConfig config) throws JsonProcessingException {
		JsonNode node = SharedObjectMapper.get().readTree(config.toString());
		return (ArrayNode) node.at('/Cmd');
	}
	private void assertPhaseWasRun(String name, IOConsumer<ContainerConfig> configConsumer) throws IOException {
		ContainerReference containerReference = ContainerReference.of('cnb-lifecycle-' + name);
		then(this.docker.container()).should().start(containerReference);
		then(this.docker.container()).should().logs(eq(containerReference), any());
		then(this.docker.container()).should().remove(containerReference, true);
		configConsumer.accept(this.configs.get(containerReference.toString()));
	}
	private IOConsumer<ContainerConfig> withExpectedConfig(String name) {
		return withExpectedConfig(name, false);
	}
	private IOConsumer<ContainerConfig> withExpectedConfig(String name, boolean expectSecurityOptAlways) {
		return (config) -> {
			try {
				InputStream in = getClass().getResourceAsStream(name);
				String jsonString = FileCopyUtils.copyToString(new InputStreamReader(in, StandardCharsets.UTF_8));
				JSONObject json = new JSONObject(jsonString);
				if (!expectSecurityOptAlways && Platform.isWindows()) {
					JSONObject hostConfig = json.getJSONObject('HostConfig');
					hostConfig.remove('SecurityOpt');
				}
				JSONAssert.assertEquals(config.toString(), json, true);
			}
			catch (JSONException ex) {
				throw new IOException(ex);
			}
		};
	}
	static class TestLifecycle extends Lifecycle {
		TestLifecycle(BuildLog log, DockerApi docker, ResolvedDockerHost dockerHost, BuildRequest request,
				EphemeralBuilder builder) {
			super(log, docker, dockerHost, request, builder);
		}
		@Override
		protected VolumeName createRandomVolumeName(String prefix) {
			return VolumeName.of(prefix + 'aaaaaaaaaa');
		}
	}
	static class TestPrintStream extends PrintStream {
		TestPrintStream() {
			super(new ByteArrayOutputStream());
		}
		@Override
		public String toString() {
			return this.out.toString();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildpackMetadataTests extends AbstractJsonTests {
	@Test
	void fromImageLoadsMetadata() throws IOException {
		Image image = Image.of(getContent('buildpack-image.json'));
		BuildpackMetadata metadata = BuildpackMetadata.fromImage(image);
		assertThat(metadata.getId()).isEqualTo('example/hello-universe');
		assertThat(metadata.getVersion()).isEqualTo('0.0.1');
	}
	@Test
	void fromImageWhenImageIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackMetadata.fromImage(null))
			.withMessage('Image must not be null');
	}
	@Test
	void fromImageWhenImageConfigIsNullThrowsException() {
		Image image = mock(Image.class);
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackMetadata.fromImage(image))
			.withMessage('ImageConfig must not be null');
	}
	@Test
	void fromImageConfigWhenLabelIsMissingThrowsException() {
		Image image = mock(Image.class);
		ImageConfig imageConfig = mock(ImageConfig.class);
		given(image.getConfig()).willReturn(imageConfig);
		given(imageConfig.getLabels()).willReturn(Collections.singletonMap('alpha', 'a'));
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackMetadata.fromImage(image))
			.withMessage('No "io.buildpacks.buildpackage.metadata" label found in image config labels "alpha"');
	}
	@Test
	void fromJsonLoadsMetadata() throws IOException {
		BuildpackMetadata metadata = BuildpackMetadata.fromJson(getContentAsString('buildpack-metadata.json'));
		assertThat(metadata.getId()).isEqualTo('example/hello-universe');
		assertThat(metadata.getVersion()).isEqualTo('0.0.1');
		assertThat(metadata.getHomepage()).isEqualTo('https://github.com/example/tree/main/buildpacks/hello-universe');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class EphemeralBuilderTests extends AbstractJsonTests {
	private static final int EXISTING_IMAGE_LAYER_COUNT = 43;
	@TempDir
	File temp;
	private final BuildOwner owner = BuildOwner.of(123, 456);
	private Image image;
	private ImageReference targetImage;
	private BuilderMetadata metadata;
	private Map<String, String> env;
	private Buildpacks buildpacks;
	private final Creator creator = Creator.withVersion('dev');
	@BeforeEach
	void setup() throws Exception {
		this.image = Image.of(getContent('image.json'));
		this.targetImage = ImageReference.of('my-image:latest');
		this.metadata = BuilderMetadata.fromImage(this.image);
		this.env = new HashMap<>();
		this.env.put('spring', 'boot');
		this.env.put('empty', null);
	}
	@Test
	void getNameHasRandomName() throws Exception {
		EphemeralBuilder b1 = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, this.env, this.buildpacks);
		EphemeralBuilder b2 = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, this.env, this.buildpacks);
		assertThat(b1.getName().toString()).startsWith('pack.local/builder/').endsWith(':latest');
		assertThat(b1.getName().toString()).isNotEqualTo(b2.getName().toString());
	}
	@Test
	void getArchiveHasCreatedByConfig() throws Exception {
		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, this.env, this.buildpacks);
		ImageConfig config = builder.getArchive().getImageConfig();
		BuilderMetadata ephemeralMetadata = BuilderMetadata.fromImageConfig(config);
		assertThat(ephemeralMetadata.getCreatedBy().getName()).isEqualTo('Spring Boot');
		assertThat(ephemeralMetadata.getCreatedBy().getVersion()).isEqualTo('dev');
	}
	@Test
	void getArchiveHasTag() throws Exception {
		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, this.env, this.buildpacks);
		ImageReference tag = builder.getArchive().getTag();
		assertThat(tag.toString()).startsWith('pack.local/builder/').endsWith(':latest');
	}
	@Test
	void getArchiveHasFixedCreatedDate() throws Exception {
		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, this.env, this.buildpacks);
		Instant createInstant = builder.getArchive().getCreateDate();
		OffsetDateTime createDateTime = OffsetDateTime.ofInstant(createInstant, ZoneId.of('UTC'));
		assertThat(createDateTime.getYear()).isEqualTo(1980);
		assertThat(createDateTime.getMonthValue()).isOne();
		assertThat(createDateTime.getDayOfMonth()).isOne();
		assertThat(createDateTime.getHour()).isZero();
		assertThat(createDateTime.getMinute()).isZero();
		assertThat(createDateTime.getSecond()).isOne();
	}
	@Test
	void getArchiveContainsEnvLayer() throws Exception {
		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, this.env, this.buildpacks);
		File directory = unpack(getLayer(builder.getArchive(), EXISTING_IMAGE_LAYER_COUNT), 'env');
		assertThat(new File(directory, 'platform/env/spring')).usingCharset(StandardCharsets.UTF_8).hasContent('boot');
		assertThat(new File(directory, 'platform/env/empty')).usingCharset(StandardCharsets.UTF_8).hasContent('');
	}
	@Test
	void getArchiveHasBuilderForLabel() throws Exception {
		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, this.env, this.buildpacks);
		ImageConfig config = builder.getArchive().getImageConfig();
		assertThat(config.getLabels())
			.contains(entry(EphemeralBuilder.BUILDER_FOR_LABEL_NAME, this.targetImage.toString()));
	}
	@Test
	void getArchiveContainsBuildpackLayers() throws Exception {
		List<Buildpack> buildpackList = new ArrayList<>();
		buildpackList.add(new TestBuildpack('example/buildpack1', '0.0.1'));
		buildpackList.add(new TestBuildpack('example/buildpack2', '0.0.2'));
		buildpackList.add(new TestBuildpack('example/buildpack3', '0.0.3'));
		this.buildpacks = Buildpacks.of(buildpackList);
		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata,
				this.creator, null, this.buildpacks);
		assertBuildpackLayerContent(builder, EXISTING_IMAGE_LAYER_COUNT,
				'/cnb/buildpacks/example_buildpack1/0.0.1/buildpack.toml');
		assertBuildpackLayerContent(builder, EXISTING_IMAGE_LAYER_COUNT + 1,
				'/cnb/buildpacks/example_buildpack2/0.0.2/buildpack.toml');
		assertBuildpackLayerContent(builder, EXISTING_IMAGE_LAYER_COUNT + 2,
				'/cnb/buildpacks/example_buildpack3/0.0.3/buildpack.toml');
		File orderDirectory = unpack(getLayer(builder.getArchive(), EXISTING_IMAGE_LAYER_COUNT + 3), 'order');
		assertThat(new File(orderDirectory, 'cnb/order.toml')).usingCharset(StandardCharsets.UTF_8)
			.hasContent(content('order.toml'));
	}
	private void assertBuildpackLayerContent(EphemeralBuilder builder, int index, String s) throws Exception {
		File buildpackDirectory = unpack(getLayer(builder.getArchive(), index), 'buildpack');
		assertThat(new File(buildpackDirectory, s)).usingCharset(StandardCharsets.UTF_8).hasContent('[test]');
	}
	private TarArchiveInputStream getLayer(ImageArchive archive, int index) throws Exception {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		archive.writeTo(outputStream);
		TarArchiveInputStream tar = new TarArchiveInputStream(new ByteArrayInputStream(outputStream.toByteArray()));
		for (int i = 0; i <= index; i++) {
			tar.getNextEntry();
		}
		return new TarArchiveInputStream(tar);
	}
	private File unpack(TarArchiveInputStream archive, String name) throws Exception {
		File directory = new File(this.temp, name);
		directory.mkdirs();
		ArchiveEntry entry = archive.getNextEntry();
		while (entry != null) {
			File file = new File(directory, entry.getName());
			if (entry.isDirectory()) {
				file.mkdirs();
			}
			else {
				file.getParentFile().mkdirs();
				try (OutputStream out = new FileOutputStream(file)) {
					IOUtils.copy(archive, out);
				}
			}
			entry = archive.getNextEntry();
		}
		return directory;
	}
	private String content(String fileName) throws IOException {
		InputStream in = getClass().getResourceAsStream(fileName);
		return FileCopyUtils.copyToString(new InputStreamReader(in, StandardCharsets.UTF_8));
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildpackReferenceTests {
	@Test
	void ofWhenValueIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuildpackReference.of(''))
			.withMessage('Value must not be empty');
	}
	@Test
	void ofCreatesInstance() {
		BuildpackReference reference = BuildpackReference.of('test');
		assertThat(reference).isNotNull();
	}
	@Test
	void toStringReturnsValue() {
		BuildpackReference reference = BuildpackReference.of('test');
		assertThat(reference).hasToString('test');
	}
	@Test
	void equalsAndHashCode() {
		BuildpackReference a = BuildpackReference.of('test1');
		BuildpackReference b = BuildpackReference.of('test1');
		BuildpackReference c = BuildpackReference.of('test2');
		assertThat(a).isEqualTo(a).isEqualTo(b).isNotEqualTo(c);
		assertThat(a).hasSameHashCodeAs(b);
	}
	@Test
	void hasPrefixWhenPrefixMatchReturnsTrue() {
		BuildpackReference reference = BuildpackReference.of('test');
		assertThat(reference.hasPrefix('te')).isTrue();
	}
	@Test
	void hasPrefixWhenPrefixMismatchReturnsFalse() {
		BuildpackReference reference = BuildpackReference.of('test');
		assertThat(reference.hasPrefix('st')).isFalse();
	}
	@Test
	void getSubReferenceWhenPrefixMatchReturnsSubReference() {
		BuildpackReference reference = BuildpackReference.of('test');
		assertThat(reference.getSubReference('te')).isEqualTo('st');
	}
	@Test
	void getSubReferenceWhenPrefixMismatchReturnsNull() {
		BuildpackReference reference = BuildpackReference.of('test');
		assertThat(reference.getSubReference('st')).isNull();
	}
	@Test
	void asPathWhenFileUrlReturnsPath() {
		BuildpackReference reference = BuildpackReference.of('file:///test.dat');
		assertThat(reference.asPath()).isEqualTo(Paths.get('/test.dat'));
	}
	@Test
	void asPathWhenPathReturnsPath() {
		BuildpackReference reference = BuildpackReference.of('/test.dat');
		assertThat(reference.asPath()).isEqualTo(Paths.get('/test.dat'));
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuilderMetadataTests extends AbstractJsonTests {
	@Test
	void fromImageLoadsMetadata() throws IOException {
		Image image = Image.of(getContent('image.json'));
		BuilderMetadata metadata = BuilderMetadata.fromImage(image);
		assertThat(metadata.getStack().getRunImage().getImage()).isEqualTo('cloudfoundry/run:base-cnb');
		assertThat(metadata.getStack().getRunImage().getMirrors()).isEmpty();
		assertThat(metadata.getRunImages()).isEmpty();
		assertThat(metadata.getLifecycle().getVersion()).isEqualTo('0.7.2');
		assertThat(metadata.getLifecycle().getApi().getBuildpack()).isEqualTo('0.2');
		assertThat(metadata.getLifecycle().getApi().getPlatform()).isEqualTo('0.3');
		assertThat(metadata.getCreatedBy().getName()).isEqualTo('Pack CLI');
		assertThat(metadata.getCreatedBy().getVersion())
			.isEqualTo('v0.9.0 (git sha: d42c384a39f367588f2653f2a99702db910e5ad7)');
		assertThat(metadata.getBuildpacks()).extracting(BuildpackMetadata::getId, BuildpackMetadata::getVersion)
			.contains(tuple('paketo-buildpacks/java', '4.10.0'))
			.contains(tuple('paketo-buildpacks/spring-boot', '3.5.0'))
			.contains(tuple('paketo-buildpacks/executable-jar', '3.1.3'))
			.contains(tuple('paketo-buildpacks/graalvm', '4.1.0'))
			.contains(tuple('paketo-buildpacks/java-native-image', '4.7.0'))
			.contains(tuple('paketo-buildpacks/spring-boot-native-image', '2.0.1'))
			.contains(tuple('paketo-buildpacks/bellsoft-liberica', '6.2.0'));
	}
	@Test
	void fromImageWithoutStackLoadsMetadata() throws IOException {
		Image image = Image.of(getContent('image-with-empty-stack.json'));
		BuilderMetadata metadata = BuilderMetadata.fromImage(image);
		assertThat(metadata.getRunImages()).extracting(RunImage::getImage, RunImage::getMirrors)
			.contains(tuple('cloudfoundry/run:base-cnb', Collections.emptyList()));
		assertThat(metadata.getLifecycle().getVersion()).isEqualTo('0.7.2');
		assertThat(metadata.getLifecycle().getApi().getBuildpack()).isEqualTo('0.2');
		assertThat(metadata.getLifecycle().getApi().getPlatform()).isEqualTo('0.3');
		assertThat(metadata.getCreatedBy().getName()).isEqualTo('Pack CLI');
		assertThat(metadata.getCreatedBy().getVersion())
			.isEqualTo('v0.9.0 (git sha: d42c384a39f367588f2653f2a99702db910e5ad7)');
		assertThat(metadata.getBuildpacks()).extracting(BuildpackMetadata::getId, BuildpackMetadata::getVersion)
			.contains(tuple('paketo-buildpacks/java', '4.10.0'))
			.contains(tuple('paketo-buildpacks/spring-boot', '3.5.0'))
			.contains(tuple('paketo-buildpacks/executable-jar', '3.1.3'))
			.contains(tuple('paketo-buildpacks/graalvm', '4.1.0'))
			.contains(tuple('paketo-buildpacks/java-native-image', '4.7.0'))
			.contains(tuple('paketo-buildpacks/spring-boot-native-image', '2.0.1'))
			.contains(tuple('paketo-buildpacks/bellsoft-liberica', '6.2.0'));
	}
	@Test
	void fromImageWhenImageIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> BuilderMetadata.fromImage(null))
			.withMessage('Image must not be null');
	}
	@Test
	void fromImageWhenImageConfigIsNullThrowsException() {
		Image image = mock(Image.class);
		assertThatIllegalArgumentException().isThrownBy(() -> BuilderMetadata.fromImage(image))
			.withMessage('ImageConfig must not be null');
	}
	@Test
	void fromImageConfigWhenLabelIsMissingThrowsException() {
		Image image = mock(Image.class);
		ImageConfig imageConfig = mock(ImageConfig.class);
		given(image.getConfig()).willReturn(imageConfig);
		given(imageConfig.getLabels()).willReturn(Collections.singletonMap('alpha', 'a'));
		assertThatIllegalArgumentException().isThrownBy(() -> BuilderMetadata.fromImage(image))
			.withMessage('No "io.buildpacks.builder.metadata" label found in image config labels "alpha"');
	}
	@Test
	void fromJsonLoadsMetadataWithoutSupportedApis() throws IOException {
		BuilderMetadata metadata = BuilderMetadata.fromJson(getContentAsString('builder-metadata.json'));
		assertThat(metadata.getStack().getRunImage().getImage()).isEqualTo('cloudfoundry/run:base-cnb');
		assertThat(metadata.getStack().getRunImage().getMirrors()).isEmpty();
		assertThat(metadata.getLifecycle().getVersion()).isEqualTo('0.7.2');
		assertThat(metadata.getLifecycle().getApi().getBuildpack()).isEqualTo('0.2');
		assertThat(metadata.getLifecycle().getApi().getPlatform()).isEqualTo('0.8');
		assertThat(metadata.getLifecycle().getApis().getBuildpack()).isNull();
		assertThat(metadata.getLifecycle().getApis().getPlatform()).isNull();
	}
	@Test
	void fromJsonLoadsMetadataWithSupportedApis() throws IOException {
		BuilderMetadata metadata = BuilderMetadata.fromJson(getContentAsString('builder-metadata-supported-apis.json'));
		assertThat(metadata.getLifecycle().getVersion()).isEqualTo('0.7.2');
		assertThat(metadata.getLifecycle().getApi().getBuildpack()).isEqualTo('0.2');
		assertThat(metadata.getLifecycle().getApi().getPlatform()).isEqualTo('0.8');
		assertThat(metadata.getLifecycle().getApis().getBuildpack()).containsExactly('0.1', '0.2', '0.3');
		assertThat(metadata.getLifecycle().getApis().getPlatform()).containsExactly('0.3', '0.4', '0.5', '0.6', '0.7',
				'0.8');
	}
	@Test
	void copyWithUpdatedCreatedByReturnsNewMetadata() throws IOException {
		Image image = Image.of(getContent('image.json'));
		BuilderMetadata metadata = BuilderMetadata.fromImage(image);
		BuilderMetadata copy = metadata.copy((update) -> update.withCreatedBy('test123', 'test456'));
		assertThat(copy).isNotSameAs(metadata);
		assertThat(copy.getCreatedBy().getName()).isEqualTo('test123');
		assertThat(copy.getCreatedBy().getVersion()).isEqualTo('test456');
	}
	@Test
	void attachToUpdatesMetadata() throws IOException {
		Image image = Image.of(getContent('image.json'));
		ImageConfig imageConfig = image.getConfig();
		BuilderMetadata metadata = BuilderMetadata.fromImage(image);
		ImageConfig imageConfigCopy = imageConfig.copy(metadata::attachTo);
		String label = imageConfigCopy.getLabels().get('io.buildpacks.builder.metadata');
		BuilderMetadata metadataCopy = BuilderMetadata.fromJson(label);
		assertThat(metadataCopy.getStack().getRunImage().getImage())
			.isEqualTo(metadata.getStack().getRunImage().getImage());
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuilderBuildpackTests extends AbstractJsonTests {
	private BuildpackResolverContext resolverContext;
	@BeforeEach
	void setUp() throws Exception {
		BuilderMetadata metadata = BuilderMetadata.fromJson(getContentAsString('builder-metadata.json'));
		this.resolverContext = mock(BuildpackResolverContext.class);
		given(this.resolverContext.getBuildpackMetadata()).willReturn(metadata.getBuildpacks());
	}
	@Test
	void resolveWhenFullyQualifiedBuildpackWithVersionResolves() throws Exception {
		BuildpackReference reference = BuildpackReference.of('urn:cnb:builder:paketo-buildpacks/spring-boot@3.5.0');
		Buildpack buildpack = BuilderBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack.getCoordinates())
			.isEqualTo(BuildpackCoordinates.of('paketo-buildpacks/spring-boot', '3.5.0'));
		assertThatNoLayersAreAdded(buildpack);
	}
	@Test
	void resolveWhenFullyQualifiedBuildpackWithoutVersionResolves() throws Exception {
		BuildpackReference reference = BuildpackReference.of('urn:cnb:builder:paketo-buildpacks/spring-boot');
		Buildpack buildpack = BuilderBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack.getCoordinates())
			.isEqualTo(BuildpackCoordinates.of('paketo-buildpacks/spring-boot', '3.5.0'));
		assertThatNoLayersAreAdded(buildpack);
	}
	@Test
	void resolveWhenUnqualifiedBuildpackWithVersionResolves() throws Exception {
		BuildpackReference reference = BuildpackReference.of('paketo-buildpacks/spring-boot@3.5.0');
		Buildpack buildpack = BuilderBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack.getCoordinates())
			.isEqualTo(BuildpackCoordinates.of('paketo-buildpacks/spring-boot', '3.5.0'));
		assertThatNoLayersAreAdded(buildpack);
	}
	@Test
	void resolveWhenUnqualifiedBuildpackWithoutVersionResolves() throws Exception {
		BuildpackReference reference = BuildpackReference.of('paketo-buildpacks/spring-boot');
		Buildpack buildpack = BuilderBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack.getCoordinates())
			.isEqualTo(BuildpackCoordinates.of('paketo-buildpacks/spring-boot', '3.5.0'));
		assertThatNoLayersAreAdded(buildpack);
	}
	@Test
	void resolveWhenFullyQualifiedBuildpackWithVersionNotInBuilderThrowsException() {
		BuildpackReference reference = BuildpackReference.of('urn:cnb:builder:example/buildpack1@1.2.3');
		assertThatIllegalArgumentException().isThrownBy(() -> BuilderBuildpack.resolve(this.resolverContext, reference))
			.withMessageContaining('"urn:cnb:builder:example/buildpack1@1.2.3"')
			.withMessageContaining('not found in builder');
	}
	@Test
	void resolveWhenFullyQualifiedBuildpackWithoutVersionNotInBuilderThrowsException() {
		BuildpackReference reference = BuildpackReference.of('urn:cnb:builder:example/buildpack1');
		assertThatIllegalArgumentException().isThrownBy(() -> BuilderBuildpack.resolve(this.resolverContext, reference))
			.withMessageContaining('"urn:cnb:builder:example/buildpack1"')
			.withMessageContaining('not found in builder');
	}
	@Test
	void resolveWhenUnqualifiedBuildpackNotInBuilderReturnsNull() {
		BuildpackReference reference = BuildpackReference.of('example/buildpack1@1.2.3');
		Buildpack buildpack = BuilderBuildpack.resolve(this.resolverContext, reference);
		assertThat(buildpack).isNull();
	}
	private void assertThatNoLayersAreAdded(Buildpack buildpack) throws IOException {
		List<Layer> layers = new ArrayList<>();
		buildpack.apply(layers::add);
		assertThat(layers).isEmpty();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class TestBuildpack implements Buildpack {
	private final BuildpackCoordinates coordinates;
	TestBuildpack(String id, String version) {
		this.coordinates = BuildpackCoordinates.of(id, version);
	}
	@Override
	public BuildpackCoordinates getCoordinates() {
		return this.coordinates;
	}
	@Override
	public void apply(IOConsumer<Layer> layers) throws IOException {
		layers.accept(Layer.of(this::getContent));
	}
	private void getContent(Layout layout) throws IOException {
		String id = this.coordinates.getSanitizedId();
		String dir = '/cnb/buildpacks/' + id + '/' + this.coordinates.getVersion();
		layout.file(dir + '/buildpack.toml', Owner.ROOT, Content.of('[test]'));
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildpackResolversTests extends AbstractJsonTests {
	private BuildpackResolverContext resolverContext;
	@BeforeEach
	void setup() throws Exception {
		BuilderMetadata metadata = BuilderMetadata.fromJson(getContentAsString('builder-metadata.json'));
		this.resolverContext = mock(BuildpackResolverContext.class);
		given(this.resolverContext.getBuildpackMetadata()).willReturn(metadata.getBuildpacks());
	}
	@Test
	void resolveAllWithBuilderBuildpackReferenceReturnsExpectedBuildpack() {
		BuildpackReference reference = BuildpackReference.of('urn:cnb:builder:paketo-buildpacks/spring-boot@3.5.0');
		Buildpacks buildpacks = BuildpackResolvers.resolveAll(this.resolverContext, Collections.singleton(reference));
		assertThat(buildpacks.getBuildpacks()).hasSize(1);
		assertThat(buildpacks.getBuildpacks().get(0)).isInstanceOf(BuilderBuildpack.class);
	}
	@Test
	void resolveAllWithDirectoryBuildpackReferenceReturnsExpectedBuildpack(@TempDir Path temp) throws IOException {
		FileCopyUtils.copy(getClass().getResourceAsStream('buildpack.toml'),
				Files.newOutputStream(temp.resolve('buildpack.toml')));
		BuildpackReference reference = BuildpackReference.of(temp.toAbsolutePath().toString());
		Buildpacks buildpacks = BuildpackResolvers.resolveAll(this.resolverContext, Collections.singleton(reference));
		assertThat(buildpacks.getBuildpacks()).hasSize(1);
		assertThat(buildpacks.getBuildpacks().get(0)).isInstanceOf(DirectoryBuildpack.class);
	}
	@Test
	void resolveAllWithTarGzipBuildpackReferenceReturnsExpectedBuildpack(@TempDir File temp) throws Exception {
		TestTarGzip testTarGzip = new TestTarGzip(temp);
		Path archive = testTarGzip.createArchive();
		BuildpackReference reference = BuildpackReference.of(archive.toString());
		Buildpacks buildpacks = BuildpackResolvers.resolveAll(this.resolverContext, Collections.singleton(reference));
		assertThat(buildpacks.getBuildpacks()).hasSize(1);
		assertThat(buildpacks.getBuildpacks().get(0)).isInstanceOf(TarGzipBuildpack.class);
	}
	@Test
	void resolveAllWithImageBuildpackReferenceReturnsExpectedBuildpack() throws IOException {
		Image image = Image.of(getContent('buildpack-image.json'));
		BuildpackResolverContext resolverContext = mock(BuildpackResolverContext.class);
		given(resolverContext.getBuildpackLayersMetadata()).willReturn(BuildpackLayersMetadata.fromJson('{}'));
		given(resolverContext.fetchImage(any(), any())).willReturn(image);
		BuildpackReference reference = BuildpackReference.of('docker://example/buildpack1:latest');
		Buildpacks buildpacks = BuildpackResolvers.resolveAll(resolverContext, Collections.singleton(reference));
		assertThat(buildpacks.getBuildpacks()).hasSize(1);
		assertThat(buildpacks.getBuildpacks().get(0)).isInstanceOf(ImageBuildpack.class);
	}
	@Test
	void resolveAllWithInvalidLocatorThrowsException() {
		BuildpackReference reference = BuildpackReference.of('unknown-buildpack@0.0.1');
		assertThatIllegalArgumentException()
			.isThrownBy(() -> BuildpackResolvers.resolveAll(this.resolverContext, Collections.singleton(reference)))
			.withMessageContaining('Invalid buildpack reference')
			.withMessageContaining('"unknown-buildpack@0.0.1"');
	}
}
/*
package org.springframework.boot.buildpack.platform.socket;
/**
class FileDescriptorTests {
	private final int sourceHandle = 123;
	private int closedHandle = 0;
	@Test
	void acquireReturnsHandle() throws Exception {
		FileDescriptor descriptor = new FileDescriptor(this.sourceHandle, this::close);
		try (Handle handle = descriptor.acquire()) {
			assertThat(handle.intValue()).isEqualTo(this.sourceHandle);
			assertThat(handle.isClosed()).isFalse();
		}
	}
	@Test
	void acquireWhenClosedReturnsClosedHandle() throws Exception {
		FileDescriptor descriptor = new FileDescriptor(this.sourceHandle, this::close);
		descriptor.close();
		try (Handle handle = descriptor.acquire()) {
			assertThat(handle.intValue()).isEqualTo(-1);
			assertThat(handle.isClosed()).isTrue();
		}
	}
	@Test
	void acquireWhenPendingCloseReturnsClosedHandle() throws Exception {
		FileDescriptor descriptor = new FileDescriptor(this.sourceHandle, this::close);
		try (Handle handle1 = descriptor.acquire()) {
			descriptor.close();
			try (Handle handle2 = descriptor.acquire()) {
				assertThat(handle2.intValue()).isEqualTo(-1);
				assertThat(handle2.isClosed()).isTrue();
			}
		}
	}
	@Test
	void finalizeTriggersClose() {
		FileDescriptor descriptor = new FileDescriptor(this.sourceHandle, this::close);
		descriptor.close();
		assertThat(this.closedHandle).isEqualTo(this.sourceHandle);
	}
	@Test
	void closeWhenHandleAcquiredClosesOnRelease() throws Exception {
		FileDescriptor descriptor = new FileDescriptor(this.sourceHandle, this::close);
		try (Handle handle = descriptor.acquire()) {
			descriptor.close();
			assertThat(this.closedHandle).isZero();
		}
		assertThat(this.closedHandle).isEqualTo(this.sourceHandle);
	}
	@Test
	void closeWhenHandleNotAcquiredClosesImmediately() {
		FileDescriptor descriptor = new FileDescriptor(this.sourceHandle, this::close);
		descriptor.close();
		assertThat(this.closedHandle).isEqualTo(this.sourceHandle);
	}
	private void close(int handle) {
		this.closedHandle = handle;
	}
}
/*
package org.springframework.boot.buildpack.platform.json;
/**
class MappedObjectTests extends AbstractJsonTests {
	private final TestMappedObject mapped;
	MappedObjectTests() throws IOException {
		this.mapped = TestMappedObject.of(getContent('test-mapped-object.json'));
	}
	@Test
	void ofReadsJson() {
		assertThat(this.mapped.getNode()).isNotNull();
	}
	@Test
	void valueAtWhenStringReturnsValue() {
		assertThat(this.mapped.valueAt('/string', String.class)).isEqualTo('stringvalue');
	}
	@Test
	void valueAtWhenStringArrayReturnsValue() {
		assertThat(this.mapped.valueAt('/stringarray', String[].class)).containsExactly('a', 'b');
	}
	@Test
	void valueAtWhenMissingReturnsNull() {
		assertThat(this.mapped.valueAt('/missing', String.class)).isNull();
	}
	@Test
	void valueAtWhenInterfaceReturnsProxy() {
		Person person = this.mapped.valueAt('/person', Person.class);
		assertThat(person.getName().getFirst()).isEqualTo('spring');
		assertThat(person.getName().getLast()).isEqualTo('boot');
	}
	@Test
	void valueAtWhenInterfaceAndMissingReturnsProxy() {
		Person person = this.mapped.valueAt('/missing', Person.class);
		assertThat(person.getName().getFirst()).isNull();
		assertThat(person.getName().getLast()).isNull();
	}
	@Test
	void valueAtWhenActualPropertyStartsWithUppercaseReturnsValue() {
		assertThat(this.mapped.valueAt('/startsWithUppercase', String.class)).isEqualTo('value');
	}
	@Test
	void valueAtWhenDefaultMethodReturnsValue() {
		Person person = this.mapped.valueAt('/person', Person.class);
		assertThat(person.getName().getFullName()).isEqualTo('dr spring boot');
	}
	/**
	 * {@link MappedObject} for testing.
	 */
	static class TestMappedObject extends MappedObject {
		TestMappedObject(JsonNode node) {
			super(node, MethodHandles.lookup());
		}
		static TestMappedObject of(InputStream content) throws IOException {
			return of(content, TestMappedObject::new);
		}
		interface Person {
			Name getName();
			interface Name {
				String getFirst();
				String getLast();
				default String getFullName() {
					String title = valueAt(this, '/title', String.class);
					return title + ' ' + getFirst() + ' ' + getLast();
				}
			}
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.json;
/**
public abstract class AbstractJsonTests {
	protected final ObjectMapper getObjectMapper() {
		return SharedObjectMapper.get();
	}
	protected final InputStream getContent(String name) {
		InputStream result = getClass().getResourceAsStream(name);
		assertThat(result).as('JSON source ' + name).isNotNull();
		return result;
	}
	protected final String getContentAsString(String name) {
		return new BufferedReader(new InputStreamReader(getContent(name), StandardCharsets.UTF_8)).lines()
			.collect(Collectors.joining('\n'));
	}
}
/*
package org.springframework.boot.buildpack.platform.json;
/**
class SharedObjectMapperTests {
	@Test
	void getReturnsConfiguredObjectMapper() {
		ObjectMapper mapper = SharedObjectMapper.get();
		assertThat(mapper).isNotNull();
		assertThat(mapper.getRegisteredModuleIds()).contains(new ParameterNamesModule().getTypeId());
		assertThat(SerializationFeature.INDENT_OUTPUT
			.enabledIn(mapper.getSerializationConfig().getSerializationFeatures())).isTrue();
		assertThat(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES
			.enabledIn(mapper.getDeserializationConfig().getDeserializationFeatures())).isFalse();
		assertThat(mapper.getSerializationConfig().getPropertyNamingStrategy())
			.isEqualTo(PropertyNamingStrategies.LOWER_CAMEL_CASE);
		assertThat(mapper.getDeserializationConfig().getPropertyNamingStrategy())
			.isEqualTo(PropertyNamingStrategies.LOWER_CAMEL_CASE);
	}
}
/*
package org.springframework.boot.buildpack.platform.json;
/**
class JsonStreamTests extends AbstractJsonTests {
	private final JsonStream jsonStream;
	JsonStreamTests() {
		this.jsonStream = new JsonStream(getObjectMapper());
	}
	@Test
	void getWhenReadingObjectNodeReturnsNodes() throws Exception {
		List<ObjectNode> result = new ArrayList<>();
		this.jsonStream.get(getContent('stream.json'), result::add);
		assertThat(result).hasSize(595);
		assertThat(result.get(594).toString())
			.contains('Status: Downloaded newer image for paketo-buildpacks/cnb:base');
	}
	@Test
	void getWhenReadTypesReturnsTypes() throws Exception {
		List<TestEvent> result = new ArrayList<>();
		this.jsonStream.get(getContent('stream.json'), TestEvent.class, result::add);
		assertThat(result).hasSize(595);
		assertThat(result.get(1).getId()).isEqualTo('5667fdb72017');
		assertThat(result.get(594).getStatus())
			.isEqualTo('Status: Downloaded newer image for paketo-buildpacks/cnb:base');
	}
	/**
	 * Event for type deserialization tests.
	 */
	static class TestEvent {
		private final String id;
		private final String status;
		@JsonCreator
		TestEvent(String id, String status) {
			this.id = id;
			this.status = status;
		}
		String getId() {
			return this.id;
		}
		String getStatus() {
			return this.status;
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
final class PrivateKeyParser {
	private static final String PKCS1_RSA_HEADER = '-+BEGIN\\s+RSA\\s+PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String PKCS1_RSA_FOOTER = '-+END\\s+RSA\\s+PRIVATE\\s+KEY[^-]*-+';
	private static final String PKCS8_HEADER = '-+BEGIN\\s+PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String PKCS8_FOOTER = '-+END\\s+PRIVATE\\s+KEY[^-]*-+';
	private static final String SEC1_EC_HEADER = '-+BEGIN\\s+EC\\s+PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String SEC1_EC_FOOTER = '-+END\\s+EC\\s+PRIVATE\\s+KEY[^-]*-+';
	private static final String BASE64_TEXT = '([a-z0-9+/=\\r\\n]+)';
	private static final List<PemParser> PEM_PARSERS;
	static {
		List<PemParser> parsers = new ArrayList<>();
		parsers
			.add(new PemParser(PKCS1_RSA_HEADER, PKCS1_RSA_FOOTER, PrivateKeyParser::createKeySpecForPkcs1Rsa, 'RSA'));
		parsers.add(new PemParser(SEC1_EC_HEADER, SEC1_EC_FOOTER, PrivateKeyParser::createKeySpecForSec1Ec, 'EC'));
		parsers.add(new PemParser(PKCS8_HEADER, PKCS8_FOOTER, PKCS8EncodedKeySpec::new, 'RSA', 'RSASSA-PSS', 'EC',
				'DSA', 'EdDSA', 'XDH'));
		PEM_PARSERS = Collections.unmodifiableList(parsers);
	}
	/**
	 * ASN.1 encoded object identifier {@literal 1.2.840.113549.1.1.1}.
	 */
	private static final int[] RSA_ALGORITHM = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01 };
	/**
	 * ASN.1 encoded object identifier {@literal 1.2.840.10045.2.1}.
	 */
	private static final int[] EC_ALGORITHM = { 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01 };
	/**
	 * ASN.1 encoded object identifier {@literal 1.3.132.0.34}.
	 */
	private static final int[] EC_PARAMETERS = { 0x2b, 0x81, 0x04, 0x00, 0x22 };
	private PrivateKeyParser() {
	}
	private static PKCS8EncodedKeySpec createKeySpecForPkcs1Rsa(byte[] bytes) {
		return createKeySpecForAlgorithm(bytes, RSA_ALGORITHM, null);
	}
	private static PKCS8EncodedKeySpec createKeySpecForSec1Ec(byte[] bytes) {
		DerElement ecPrivateKey = DerElement.of(bytes);
		Assert.state(ecPrivateKey.isType(ValueType.ENCODED, TagType.SEQUENCE),
				'Key spec should be an ASN.1 encoded sequence');
		DerElement version = DerElement.of(ecPrivateKey.getContents());
		Assert.state(version != null && version.isType(ValueType.PRIMITIVE, TagType.INTEGER),
				'Key spec should start with version');
		Assert.state(version.getContents().remaining() == 1 && version.getContents().get() == 1,
				'Key spec version must be 1');
		DerElement privateKey = DerElement.of(ecPrivateKey.getContents());
		Assert.state(privateKey != null && privateKey.isType(ValueType.PRIMITIVE, TagType.OCTET_STRING),
				'Key spec should contain private key');
		DerElement parameters = DerElement.of(ecPrivateKey.getContents());
		return createKeySpecForAlgorithm(bytes, EC_ALGORITHM, getEcParameters(parameters));
	}
	private static int[] getEcParameters(DerElement parameters) {
		if (parameters == null) {
			return EC_PARAMETERS;
		}
		Assert.state(parameters.isType(ValueType.ENCODED), 'Key spec should contain encoded parameters');
		DerElement contents = DerElement.of(parameters.getContents());
		Assert.state(contents.isType(ValueType.PRIMITIVE, TagType.OBJECT_IDENTIFIER),
				'Key spec parameters should contain object identifier');
		return getEcParameters(contents.getContents());
	}
	private static int[] getEcParameters(ByteBuffer bytes) {
		int[] result = new int[bytes.remaining()];
		for (int i = 0; i < result.length; i++) {
			result[i] = bytes.get() & 0xFF;
		}
		return result;
	}
	private static PKCS8EncodedKeySpec createKeySpecForAlgorithm(byte[] bytes, int[] algorithm, int[] parameters) {
		try {
			DerEncoder encoder = new DerEncoder();
			encoder.integer(0x00); // Version 0
			DerEncoder algorithmIdentifier = new DerEncoder();
			algorithmIdentifier.objectIdentifier(algorithm);
			algorithmIdentifier.objectIdentifier(parameters);
			byte[] byteArray = algorithmIdentifier.toByteArray();
			encoder.sequence(byteArray);
			encoder.octetString(bytes);
			return new PKCS8EncodedKeySpec(encoder.toSequence());
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	/**
	 * Load a private key from the specified file paths.
	 * @param path the path to the private key file
	 * @return private key from specified file path
	 */
	static PrivateKey parse(Path path) {
		try {
			String text = Files.readString(path);
			for (PemParser pemParser : PEM_PARSERS) {
				PrivateKey privateKey = pemParser.parse(text);
				if (privateKey != null) {
					return privateKey;
				}
			}
			throw new IllegalStateException('Unrecognized private key format');
		}
		catch (Exception ex) {
			throw new IllegalStateException('Error loading private key file ' + path, ex);
		}
	}
	/**
	 * Parser for a specific PEM format.
	 */
	private static class PemParser {
		private final Pattern pattern;
		private final Function<byte[], PKCS8EncodedKeySpec> keySpecFactory;
		private final String[] algorithms;
		PemParser(String header, String footer, Function<byte[], PKCS8EncodedKeySpec> keySpecFactory,
				String... algorithms) {
			this.pattern = Pattern.compile(header + BASE64_TEXT + footer, Pattern.CASE_INSENSITIVE);
			this.algorithms = algorithms;
			this.keySpecFactory = keySpecFactory;
		}
		PrivateKey parse(String text) {
			Matcher matcher = this.pattern.matcher(text);
			return (!matcher.find()) ? null : parse(decodeBase64(matcher.group(1)));
		}
		private static byte[] decodeBase64(String content) {
			byte[] contentBytes = content.replaceAll('\r', '').replaceAll('\n', '').getBytes();
			return Base64.getDecoder().decode(contentBytes);
		}
		private PrivateKey parse(byte[] bytes) {
			PKCS8EncodedKeySpec keySpec = this.keySpecFactory.apply(bytes);
			for (String algorithm : this.algorithms) {
				try {
					KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
					return keyFactory.generatePrivate(keySpec);
				}
				catch (InvalidKeySpecException | NoSuchAlgorithmException ex) {
					// Ignore
				}
			}
			return null;
		}
	}
	/**
	 * Simple ASN.1 DER encoder.
	 */
	static class DerEncoder {
		private final ByteArrayOutputStream stream = new ByteArrayOutputStream();
		void objectIdentifier(int... encodedObjectIdentifier) throws IOException {
			int code = (encodedObjectIdentifier != null) ? 0x06 : 0x05;
			codeLengthBytes(code, bytes(encodedObjectIdentifier));
		}
		void integer(int... encodedInteger) throws IOException {
			codeLengthBytes(0x02, bytes(encodedInteger));
		}
		void octetString(byte[] bytes) throws IOException {
			codeLengthBytes(0x04, bytes);
		}
		void sequence(int... elements) throws IOException {
			sequence(bytes(elements));
		}
		void sequence(byte[] bytes) throws IOException {
			codeLengthBytes(0x30, bytes);
		}
		void codeLengthBytes(int code, byte[] bytes) throws IOException {
			this.stream.write(code);
			int length = (bytes != null) ? bytes.length : 0;
			if (length <= 127) {
				this.stream.write(length & 0xFF);
			}
			else {
				ByteArrayOutputStream lengthStream = new ByteArrayOutputStream();
				while (length != 0) {
					lengthStream.write(length & 0xFF);
					length = length >> 8;
				}
				byte[] lengthBytes = lengthStream.toByteArray();
				this.stream.write(0x80 | lengthBytes.length);
				for (int i = lengthBytes.length - 1; i >= 0; i--) {
					this.stream.write(lengthBytes[i]);
				}
			}
			if (bytes != null) {
				this.stream.write(bytes);
			}
		}
		private static byte[] bytes(int... elements) {
			if (elements == null) {
				return null;
			}
			byte[] result = new byte[elements.length];
			for (int i = 0; i < elements.length; i++) {
				result[i] = (byte) elements[i];
			}
			return result;
		}
		byte[] toSequence() throws IOException {
			DerEncoder sequenceEncoder = new DerEncoder();
			sequenceEncoder.sequence(toByteArray());
			return sequenceEncoder.toByteArray();
		}
		byte[] toByteArray() {
			return this.stream.toByteArray();
		}
	}
	/**
	 * An ASN.1 DER encoded element.
	 */
	static final class DerElement {
		private final ValueType valueType;
		private final long tagType;
		private final ByteBuffer contents;
		private DerElement(ByteBuffer bytes) {
			byte b = bytes.get();
			this.valueType = ((b & 0x20) == 0) ? ValueType.PRIMITIVE : ValueType.ENCODED;
			this.tagType = decodeTagType(b, bytes);
			int length = decodeLength(bytes);
			bytes.limit(bytes.position() + length);
			this.contents = bytes.slice();
			bytes.limit(bytes.capacity());
			bytes.position(bytes.position() + length);
		}
		private long decodeTagType(byte b, ByteBuffer bytes) {
			long tagType = (b & 0x1F);
			if (tagType != 0x1F) {
				return tagType;
			}
			tagType = 0;
			b = bytes.get();
			while ((b & 0x80) != 0) {
				tagType <<= 7;
				tagType = tagType | (b & 0x7F);
				b = bytes.get();
			}
			return tagType;
		}
		private int decodeLength(ByteBuffer bytes) {
			byte b = bytes.get();
			if ((b & 0x80) == 0) {
				return b & 0x7F;
			}
			int numberOfLengthBytes = (b & 0x7F);
			Assert.state(numberOfLengthBytes != 0, 'Infinite length encoding is not supported');
			Assert.state(numberOfLengthBytes != 0x7F, 'Reserved length encoding is not supported');
			Assert.state(numberOfLengthBytes <= 4, 'Length overflow');
			int length = 0;
			for (int i = 0; i < numberOfLengthBytes; i++) {
				length <<= 8;
				length |= (bytes.get() & 0xFF);
			}
			return length;
		}
		boolean isType(ValueType valueType) {
			return this.valueType == valueType;
		}
		boolean isType(ValueType valueType, TagType tagType) {
			return this.valueType == valueType && this.tagType == tagType.getNumber();
		}
		ByteBuffer getContents() {
			return this.contents;
		}
		static DerElement of(byte[] bytes) {
			return of(ByteBuffer.wrap(bytes));
		}
		static DerElement of(ByteBuffer bytes) {
			return (bytes.remaining() > 0) ? new DerElement(bytes) : null;
		}
		enum ValueType {
			PRIMITIVE, ENCODED
		}
		enum TagType {
			INTEGER(0x02), OCTET_STRING(0x04), OBJECT_IDENTIFIER(0x06), SEQUENCE(0x10);
			private final int number;
			TagType(int number) {
				this.number = number;
			}
			int getNumber() {
				return this.number;
			}
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
public class SslContextFactory {
	private static final char[] NO_PASSWORD = {};
	private static final String KEY_STORE_ALIAS = 'spring-boot-docker';
	public SslContextFactory() {
	}
	/**
	 * Create an {@link SSLContext} from files in the specified directory. The directory
	 * must contain files with the names "key.pem", "cert.pem", and "ca.pem".
	 * @param directory the path to a directory containing certificate and key files
	 * @return the {@code SSLContext}
	 */
	public SSLContext forDirectory(String directory) {
		try {
			Path keyPath = Paths.get(directory, 'key.pem');
			Path certPath = Paths.get(directory, 'cert.pem');
			Path caPath = Paths.get(directory, 'ca.pem');
			Path caKeyPath = Paths.get(directory, 'ca-key.pem');
			verifyCertificateFiles(keyPath, certPath, caPath);
			KeyManagerFactory keyManagerFactory = getKeyManagerFactory(keyPath, certPath);
			TrustManagerFactory trustManagerFactory = getTrustManagerFactory(caPath, caKeyPath);
			SSLContext sslContext = SSLContext.getInstance('TLS');
			sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);
			return sslContext;
		}
		catch (RuntimeException ex) {
			throw ex;
		}
		catch (Exception ex) {
			throw new RuntimeException(ex.getMessage(), ex);
		}
	}
	private KeyManagerFactory getKeyManagerFactory(Path keyPath, Path certPath) throws Exception {
		KeyStore store = KeyStoreFactory.create(certPath, keyPath, KEY_STORE_ALIAS);
		KeyManagerFactory factory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
		factory.init(store, NO_PASSWORD);
		return factory;
	}
	private TrustManagerFactory getTrustManagerFactory(Path caPath, Path caKeyPath)
			throws NoSuchAlgorithmException, KeyStoreException {
		KeyStore store = KeyStoreFactory.create(caPath, caKeyPath, KEY_STORE_ALIAS);
		TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
		factory.init(store);
		return factory;
	}
	private static void verifyCertificateFiles(Path... paths) {
		for (Path path : paths) {
			Assert.state(Files.exists(path) && Files.isRegularFile(path),
					'Certificate path must contain the files "ca.pem", "cert.pem", and "key.pem" files');
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
final class KeyStoreFactory {
	private static final char[] NO_PASSWORD = {};
	private KeyStoreFactory() {
	}
	/**
	 * Create a new {@link KeyStore} populated with the certificate stored at the
	 * specified file path and an optional private key.
	 * @param certPath the path to the certificate authority file
	 * @param keyPath the path to the private file
	 * @param alias the alias to use for KeyStore entries
	 * @return the {@code KeyStore}
	 */
	static KeyStore create(Path certPath, Path keyPath, String alias) {
		try {
			KeyStore keyStore = getKeyStore();
			X509Certificate[] certificates = CertificateParser.parse(certPath);
			PrivateKey privateKey = getPrivateKey(keyPath);
			try {
				addCertificates(keyStore, certificates, privateKey, alias);
			}
			catch (KeyStoreException ex) {
				throw new IllegalStateException('Error adding certificates to KeyStore: ' + ex.getMessage(), ex);
			}
			return keyStore;
		}
		catch (GeneralSecurityException | IOException ex) {
			throw new IllegalStateException('Error creating KeyStore: ' + ex.getMessage(), ex);
		}
	}
	private static KeyStore getKeyStore()
			throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
		KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
		keyStore.load(null);
		return keyStore;
	}
	private static PrivateKey getPrivateKey(Path path) {
		if (path != null && Files.exists(path)) {
			return PrivateKeyParser.parse(path);
		}
		return null;
	}
	private static void addCertificates(KeyStore keyStore, X509Certificate[] certificates, PrivateKey privateKey,
			String alias) throws KeyStoreException {
		if (privateKey != null) {
			keyStore.setKeyEntry(alias, privateKey, NO_PASSWORD, certificates);
		}
		else {
			for (int index = 0; index < certificates.length; index++) {
				keyStore.setCertificateEntry(alias + '-' + index, certificates[index]);
			}
		}
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.docker.ssl;
/*
package org.springframework.boot.buildpack.platform.docker.ssl;
/**
final class CertificateParser {
	private static final String HEADER = '-+BEGIN\\s+.*CERTIFICATE[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String BASE64_TEXT = '([a-z0-9+/=\\r\\n]+)';
	private static final String FOOTER = '-+END\\s+.*CERTIFICATE[^-]*-+';
	private static final Pattern PATTERN = Pattern.compile(HEADER + BASE64_TEXT + FOOTER, Pattern.CASE_INSENSITIVE);
	private CertificateParser() {
	}
	/**
	 * Load certificates from the specified file paths.
	 * @param paths one or more paths to certificate files
	 * @return certificates parsed from specified file paths
	 */
	static X509Certificate[] parse(Path... paths) {
		CertificateFactory factory = getCertificateFactory();
		List<X509Certificate> certificates = new ArrayList<>();
		for (Path path : paths) {
			readCertificates(path, factory, certificates::add);
		}
		return certificates.toArray(new X509Certificate[0]);
	}
	private static CertificateFactory getCertificateFactory() {
		try {
			return CertificateFactory.getInstance('X.509');
		}
		catch (CertificateException ex) {
			throw new IllegalStateException('Unable to get X.509 certificate factory', ex);
		}
	}
	private static void readCertificates(Path path, CertificateFactory factory, Consumer<X509Certificate> consumer) {
		try {
			String text = Files.readString(path);
			Matcher matcher = PATTERN.matcher(text);
			while (matcher.find()) {
				String encodedText = matcher.group(1);
				byte[] decodedBytes = decodeBase64(encodedText);
				ByteArrayInputStream inputStream = new ByteArrayInputStream(decodedBytes);
				while (inputStream.available() > 0) {
					consumer.accept((X509Certificate) factory.generateCertificate(inputStream));
				}
			}
		}
		catch (CertificateException | IOException ex) {
			throw new IllegalStateException('Error reading certificate from "' + path + '" : ' + ex.getMessage(), ex);
		}
	}
	private static byte[] decodeBase64(String content) {
		byte[] bytes = content.replaceAll('\r', '').replaceAll('\n', '').getBytes();
		return Base64.getDecoder().decode(bytes);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class JsonEncodedDockerRegistryAuthentication implements DockerRegistryAuthentication {
	private String authHeader;
	@Override
	public String getAuthHeader() {
		return this.authHeader;
	}
	protected void createAuthHeader() {
		try {
			this.authHeader = Base64.getUrlEncoder().encodeToString(SharedObjectMapper.get().writeValueAsBytes(this));
		}
		catch (JsonProcessingException ex) {
			throw new IllegalStateException('Error creating Docker registry authentication header', ex);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
public final class DockerConfiguration {
	private final DockerHostConfiguration host;
	private final DockerRegistryAuthentication builderAuthentication;
	private final DockerRegistryAuthentication publishAuthentication;
	private final boolean bindHostToBuilder;
	public DockerConfiguration() {
		this(null, null, null, false);
	}
	private DockerConfiguration(DockerHostConfiguration host, DockerRegistryAuthentication builderAuthentication,
			DockerRegistryAuthentication publishAuthentication, boolean bindHostToBuilder) {
		this.host = host;
		this.builderAuthentication = builderAuthentication;
		this.publishAuthentication = publishAuthentication;
		this.bindHostToBuilder = bindHostToBuilder;
	}
	public DockerHostConfiguration getHost() {
		return this.host;
	}
	public boolean isBindHostToBuilder() {
		return this.bindHostToBuilder;
	}
	public DockerRegistryAuthentication getBuilderRegistryAuthentication() {
		return this.builderAuthentication;
	}
	public DockerRegistryAuthentication getPublishRegistryAuthentication() {
		return this.publishAuthentication;
	}
	public DockerConfiguration withHost(String address, boolean secure, String certificatePath) {
		Assert.notNull(address, 'Address must not be null');
		return new DockerConfiguration(DockerHostConfiguration.forAddress(address, secure, certificatePath),
				this.builderAuthentication, this.publishAuthentication, this.bindHostToBuilder);
	}
	public DockerConfiguration withContext(String context) {
		Assert.notNull(context, 'Context must not be null');
		return new DockerConfiguration(DockerHostConfiguration.forContext(context), this.builderAuthentication,
				this.publishAuthentication, this.bindHostToBuilder);
	}
	public DockerConfiguration withBindHostToBuilder(boolean bindHostToBuilder) {
		return new DockerConfiguration(this.host, this.builderAuthentication, this.publishAuthentication,
				bindHostToBuilder);
	}
	public DockerConfiguration withBuilderRegistryTokenAuthentication(String token) {
		Assert.notNull(token, 'Token must not be null');
		return new DockerConfiguration(this.host, new DockerRegistryTokenAuthentication(token),
				this.publishAuthentication, this.bindHostToBuilder);
	}
	public DockerConfiguration withBuilderRegistryUserAuthentication(String username, String password, String url,
			String email) {
		Assert.notNull(username, 'Username must not be null');
		Assert.notNull(password, 'Password must not be null');
		return new DockerConfiguration(this.host, new DockerRegistryUserAuthentication(username, password, url, email),
				this.publishAuthentication, this.bindHostToBuilder);
	}
	public DockerConfiguration withPublishRegistryTokenAuthentication(String token) {
		Assert.notNull(token, 'Token must not be null');
		return new DockerConfiguration(this.host, this.builderAuthentication,
				new DockerRegistryTokenAuthentication(token), this.bindHostToBuilder);
	}
	public DockerConfiguration withPublishRegistryUserAuthentication(String username, String password, String url,
			String email) {
		Assert.notNull(username, 'Username must not be null');
		Assert.notNull(password, 'Password must not be null');
		return new DockerConfiguration(this.host, this.builderAuthentication,
				new DockerRegistryUserAuthentication(username, password, url, email), this.bindHostToBuilder);
	}
	public DockerConfiguration withEmptyPublishRegistryAuthentication() {
		return new DockerConfiguration(this.host, this.builderAuthentication,
				new DockerRegistryUserAuthentication('', '', '', ''), this.bindHostToBuilder);
	}
	public static class DockerHostConfiguration {
		private final String address;
		private final String context;
		private final boolean secure;
		private final String certificatePath;
		public DockerHostConfiguration(String address, String context, boolean secure, String certificatePath) {
			this.address = address;
			this.context = context;
			this.secure = secure;
			this.certificatePath = certificatePath;
		}
		public String getAddress() {
			return this.address;
		}
		public String getContext() {
			return this.context;
		}
		public boolean isSecure() {
			return this.secure;
		}
		public String getCertificatePath() {
			return this.certificatePath;
		}
		public static DockerHostConfiguration forAddress(String address) {
			return new DockerHostConfiguration(address, null, false, null);
		}
		public static DockerHostConfiguration forAddress(String address, boolean secure, String certificatePath) {
			return new DockerHostConfiguration(address, null, secure, certificatePath);
		}
		static DockerHostConfiguration forContext(String context) {
			return new DockerHostConfiguration(null, context, false, null);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
final class DockerConfigurationMetadata {
	private static final String DOCKER_CONFIG = 'DOCKER_CONFIG';
	private static final String DEFAULT_CONTEXT = 'default';
	private static final String CONFIG_DIR = '.docker';
	private static final String CONTEXTS_DIR = 'contexts';
	private static final String META_DIR = 'meta';
	private static final String TLS_DIR = 'tls';
	private static final String DOCKER_ENDPOINT = 'docker';
	private static final String CONFIG_FILE_NAME = 'config.json';
	private static final String CONTEXT_FILE_NAME = 'meta.json';
	private final String configLocation;
	private final DockerConfig config;
	private final DockerContext context;
	private DockerConfigurationMetadata(String configLocation, DockerConfig config, DockerContext context) {
		this.configLocation = configLocation;
		this.config = config;
		this.context = context;
	}
	DockerConfig getConfiguration() {
		return this.config;
	}
	DockerContext getContext() {
		return this.context;
	}
	DockerContext forContext(String context) {
		return createDockerContext(this.configLocation, context);
	}
	static DockerConfigurationMetadata from(Environment environment) {
		String configLocation = (environment.get(DOCKER_CONFIG) != null) ? environment.get(DOCKER_CONFIG)
				: Path.of(System.getProperty('user.home'), CONFIG_DIR).toString();
		DockerConfig dockerConfig = createDockerConfig(configLocation);
		DockerContext dockerContext = createDockerContext(configLocation, dockerConfig.getCurrentContext());
		return new DockerConfigurationMetadata(configLocation, dockerConfig, dockerContext);
	}
	private static DockerConfig createDockerConfig(String configLocation) {
		Path path = Path.of(configLocation, CONFIG_FILE_NAME);
		if (!path.toFile().exists()) {
			return DockerConfig.empty();
		}
		try {
			return DockerConfig.fromJson(readPathContent(path));
		}
		catch (JsonProcessingException ex) {
			throw new IllegalStateException('Error parsing Docker configuration file "' + path + '"', ex);
		}
	}
	private static DockerContext createDockerContext(String configLocation, String currentContext) {
		if (currentContext == null || DEFAULT_CONTEXT.equals(currentContext)) {
			return DockerContext.empty();
		}
		Path metaPath = Path.of(configLocation, CONTEXTS_DIR, META_DIR, asHash(currentContext), CONTEXT_FILE_NAME);
		Path tlsPath = Path.of(configLocation, CONTEXTS_DIR, TLS_DIR, asHash(currentContext), DOCKER_ENDPOINT);
		if (!metaPath.toFile().exists()) {
			throw new IllegalArgumentException('Docker context "' + currentContext + '" does not exist');
		}
		try {
			DockerContext context = DockerContext.fromJson(readPathContent(metaPath));
			if (tlsPath.toFile().isDirectory()) {
				return context.withTlsPath(tlsPath.toString());
			}
			return context;
		}
		catch (JsonProcessingException ex) {
			throw new IllegalStateException('Error parsing Docker context metadata file "' + metaPath + '"', ex);
		}
	}
	private static String asHash(String currentContext) {
		try {
			MessageDigest digest = MessageDigest.getInstance('SHA-256');
			byte[] hash = digest.digest(currentContext.getBytes(StandardCharsets.UTF_8));
			return HexFormat.of().formatHex(hash);
		}
		catch (NoSuchAlgorithmException ex) {
			return null;
		}
	}
	private static String readPathContent(Path path) {
		try {
			return Files.readString(path);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Error reading Docker configuration file "' + path + '"', ex);
		}
	}
	static final class DockerConfig extends MappedObject {
		private final String currentContext;
		private DockerConfig(JsonNode node) {
			super(node, MethodHandles.lookup());
			this.currentContext = valueAt('/currentContext', String.class);
		}
		String getCurrentContext() {
			return this.currentContext;
		}
		static DockerConfig fromJson(String json) throws JsonProcessingException {
			return new DockerConfig(SharedObjectMapper.get().readTree(json));
		}
		static DockerConfig empty() {
			return new DockerConfig(NullNode.instance);
		}
	}
	static final class DockerContext extends MappedObject {
		private final String dockerHost;
		private final Boolean skipTlsVerify;
		private final String tlsPath;
		private DockerContext(JsonNode node, String tlsPath) {
			super(node, MethodHandles.lookup());
			this.dockerHost = valueAt('/Endpoints/' + DOCKER_ENDPOINT + '/Host', String.class);
			this.skipTlsVerify = valueAt('/Endpoints/' + DOCKER_ENDPOINT + '/SkipTLSVerify', Boolean.class);
			this.tlsPath = tlsPath;
		}
		String getDockerHost() {
			return this.dockerHost;
		}
		Boolean isTlsVerify() {
			return this.skipTlsVerify != null && !this.skipTlsVerify;
		}
		String getTlsPath() {
			return this.tlsPath;
		}
		DockerContext withTlsPath(String tlsPath) {
			return new DockerContext(this.getNode(), tlsPath);
		}
		static DockerContext fromJson(String json) throws JsonProcessingException {
			return new DockerContext(SharedObjectMapper.get().readTree(json), null);
		}
		static DockerContext empty() {
			return new DockerContext(NullNode.instance, null);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class DockerRegistryUserAuthentication extends JsonEncodedDockerRegistryAuthentication {
	@JsonProperty
	private final String username;
	@JsonProperty
	private final String password;
	@JsonProperty('serveraddress')
	private final String url;
	@JsonProperty
	private final String email;
	DockerRegistryUserAuthentication(String username, String password, String url, String email) {
		this.username = username;
		this.password = password;
		this.url = url;
		this.email = email;
		createAuthHeader();
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
	String getUrl() {
		return this.url;
	}
	String getEmail() {
		return this.email;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
public class ResolvedDockerHost extends DockerHost {
	private static final String UNIX_SOCKET_PREFIX = 'unix://';
	private static final String DOMAIN_SOCKET_PATH = '/var/run/docker.sock';
	private static final String WINDOWS_NAMED_PIPE_PATH = '//./pipe/docker_engine';
	private static final String DOCKER_HOST = 'DOCKER_HOST';
	private static final String DOCKER_TLS_VERIFY = 'DOCKER_TLS_VERIFY';
	private static final String DOCKER_CERT_PATH = 'DOCKER_CERT_PATH';
	private static final String DOCKER_CONTEXT = 'DOCKER_CONTEXT';
	ResolvedDockerHost(String address) {
		super(address);
	}
	ResolvedDockerHost(String address, boolean secure, String certificatePath) {
		super(address, secure, certificatePath);
	}
	@Override
	public String getAddress() {
		return super.getAddress().startsWith(UNIX_SOCKET_PREFIX)
				? super.getAddress().substring(UNIX_SOCKET_PREFIX.length()) : super.getAddress();
	}
	public boolean isRemote() {
		return getAddress().startsWith('http') || getAddress().startsWith('tcp');
	}
	public boolean isLocalFileReference() {
		try {
			return Files.exists(Paths.get(getAddress()));
		}
		catch (Exception ex) {
			return false;
		}
	}
	public static ResolvedDockerHost from(DockerHostConfiguration dockerHost) {
		return from(Environment.SYSTEM, dockerHost);
	}
	static ResolvedDockerHost from(Environment environment, DockerHostConfiguration dockerHost) {
		DockerConfigurationMetadata config = DockerConfigurationMetadata.from(environment);
		if (environment.get(DOCKER_CONTEXT) != null) {
			DockerContext context = config.forContext(environment.get(DOCKER_CONTEXT));
			return new ResolvedDockerHost(context.getDockerHost(), context.isTlsVerify(), context.getTlsPath());
		}
		if (dockerHost != null && dockerHost.getContext() != null) {
			DockerContext context = config.forContext(dockerHost.getContext());
			return new ResolvedDockerHost(context.getDockerHost(), context.isTlsVerify(), context.getTlsPath());
		}
		if (environment.get(DOCKER_HOST) != null) {
			return new ResolvedDockerHost(environment.get(DOCKER_HOST), isTrue(environment.get(DOCKER_TLS_VERIFY)),
					environment.get(DOCKER_CERT_PATH));
		}
		if (dockerHost != null && dockerHost.getAddress() != null) {
			return new ResolvedDockerHost(dockerHost.getAddress(), dockerHost.isSecure(),
					dockerHost.getCertificatePath());
		}
		if (config.getContext().getDockerHost() != null) {
			DockerContext context = config.getContext();
			return new ResolvedDockerHost(context.getDockerHost(), context.isTlsVerify(), context.getTlsPath());
		}
		return new ResolvedDockerHost(Platform.isWindows() ? WINDOWS_NAMED_PIPE_PATH : DOMAIN_SOCKET_PATH);
	}
	private static boolean isTrue(String value) {
		try {
			return (value != null) && (Integer.parseInt(value) == 1);
		}
		catch (NumberFormatException ex) {
			return false;
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
class DockerRegistryTokenAuthentication extends JsonEncodedDockerRegistryAuthentication {
	@JsonProperty('identitytoken')
	private final String token;
	DockerRegistryTokenAuthentication(String token) {
		this.token = token;
		createAuthHeader();
	}
	String getToken() {
		return this.token;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
public interface DockerRegistryAuthentication {
	/**
	 * Returns the auth header that should be used for docker authentication.
	 * @return the auth header
	 */
	String getAuthHeader();
}
/*
package org.springframework.boot.buildpack.platform.docker.configuration;
/**
public class DockerHost {
	private final String address;
	private final boolean secure;
	private final String certificatePath;
	public DockerHost(String address) {
		this(address, false, null);
	}
	public DockerHost(String address, boolean secure, String certificatePath) {
		this.address = address;
		this.secure = secure;
		this.certificatePath = certificatePath;
	}
	public String getAddress() {
		return this.address;
	}
	public boolean isSecure() {
		return this.secure;
	}
	public String getCertificatePath() {
		return this.certificatePath;
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.docker.configuration;
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class PullImageUpdateEvent extends ImageProgressUpdateEvent {
	@JsonCreator
	public PullImageUpdateEvent(String id, String status, ProgressDetail progressDetail, String progress) {
		super(id, status, progressDetail, progress);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class ImageProgressUpdateEvent extends ProgressUpdateEvent {
	private final String id;
	protected ImageProgressUpdateEvent(String id, String status, ProgressDetail progressDetail, String progress) {
		super(status, progressDetail, progress);
		this.id = id;
	}
	/**
	 * Returns the ID of the image layer being updated if available.
	 * @return the ID of the updated layer or {@code null}
	 */
	public String getId() {
		return this.id;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class TotalProgressBar implements Consumer<TotalProgressEvent> {
	private final char progressChar;
	private final boolean bookend;
	private final PrintStream out;
	private int printed;
	/**
	 * Create a new {@link TotalProgressBar} instance.
	 * @param prefix the prefix to output
	 */
	public TotalProgressBar(String prefix) {
		this(prefix, System.out);
	}
	/**
	 * Create a new {@link TotalProgressBar} instance.
	 * @param prefix the prefix to output
	 * @param out the output print stream to use
	 */
	public TotalProgressBar(String prefix, PrintStream out) {
		this(prefix, "#", true, out);
	}
	/**
	 * Create a new {@link TotalProgressBar} instance.
	 * @param prefix the prefix to output
	 * @param progressChar the progress char to print
	 * @param bookend if bookends should be printed
	 * @param out the output print stream to use
	 */
	public TotalProgressBar(String prefix, char progressChar, boolean bookend, PrintStream out) {
		this.progressChar = progressChar;
		this.bookend = bookend;
		if (StringUtils.hasLength(prefix)) {
			out.print(prefix);
			out.print(' ');
		}
		if (bookend) {
			out.print('[ ');
		}
		this.out = out;
	}
	@Override
	public void accept(TotalProgressEvent event) {
		int percent = event.getPercent() / 2;
		while (this.printed < percent) {
			this.out.print(this.progressChar);
			this.printed++;
		}
		if (event.getPercent() == 100) {
			this.out.println(this.bookend ? ' ]' : '');
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
public class DockerEngineException extends RuntimeException {
	private final int statusCode;
	private final String reasonPhrase;
	private final Errors errors;
	private final Message responseMessage;
	public DockerEngineException(String host, URI uri, int statusCode, String reasonPhrase, Errors errors,
			Message responseMessage) {
		super(buildMessage(host, uri, statusCode, reasonPhrase, errors, responseMessage));
		this.statusCode = statusCode;
		this.reasonPhrase = reasonPhrase;
		this.errors = errors;
		this.responseMessage = responseMessage;
	}
	/**
	 * Return the status code returned by the Docker API.
	 * @return the statusCode the status code
	 */
	public int getStatusCode() {
		return this.statusCode;
	}
	/**
	 * Return the reason phrase returned by the Docker API.
	 * @return the reasonPhrase
	 */
	public String getReasonPhrase() {
		return this.reasonPhrase;
	}
	/**
	 * Return the errors from the body of the Docker API response, or {@code null} if the
	 * errors JSON could not be read.
	 * @return the errors or {@code null}
	 */
	public Errors getErrors() {
		return this.errors;
	}
	/**
	 * Return the message from the body of the Docker API response, or {@code null} if the
	 * message JSON could not be read.
	 * @return the message or {@code null}
	 */
	public Message getResponseMessage() {
		return this.responseMessage;
	}
	private static String buildMessage(String host, URI uri, int statusCode, String reasonPhrase, Errors errors,
			Message responseMessage) {
		Assert.notNull(host, 'Host must not be null');
		Assert.notNull(uri, 'URI must not be null');
		StringBuilder message = new StringBuilder(
				'Docker API call to "' + host + uri + '" failed with status code ' + statusCode);
		if (StringUtils.hasLength(reasonPhrase)) {
			message.append(' \'').append(reasonPhrase).append('\'');
		}
		if (responseMessage != null && StringUtils.hasLength(responseMessage.getMessage())) {
			message.append(' and message \'').append(responseMessage.getMessage()).append('\'');
		}
		if (errors != null && !errors.isEmpty()) {
			message.append(' ').append(errors);
		}
		return message.toString();
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
public class Errors implements Iterable<Errors.Error> {
	private final List<Error> errors;
	@JsonCreator
	Errors(@JsonProperty('errors') List<Error> errors) {
		this.errors = (errors != null) ? errors : Collections.emptyList();
	}
	@Override
	public Iterator<Errors.Error> iterator() {
		return this.errors.iterator();
	}
	/**
	 * Returns a sequential {@code Stream} of the errors.
	 * @return a stream of the errors
	 */
	public Stream<Error> stream() {
		return this.errors.stream();
	}
	/**
	 * Return if there are any contained errors.
	 * @return if the errors are empty
	 */
	public boolean isEmpty() {
		return this.errors.isEmpty();
	}
	@Override
	public String toString() {
		return this.errors.toString();
	}
	/**
	 * An individual Docker error.
	 */
	public static class Error {
		private final String code;
		private final String message;
		@JsonCreator
		Error(String code, String message) {
			this.code = code;
			this.message = message;
		}
		/**
		 * Return the error code.
		 * @return the error code
		 */
		public String getCode() {
			return this.code;
		}
		/**
		 * Return the error message.
		 * @return the error message
		 */
		public String getMessage() {
			return this.message;
		}
		@Override
		public String toString() {
			return this.code + ': ' + this.message;
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
public class DockerConnectionException extends RuntimeException {
	private static final String JNA_EXCEPTION_CLASS_NAME = 'com.sun.jna.LastErrorException';
	public DockerConnectionException(String host, Exception cause) {
		super(buildMessage(host, cause), cause);
	}
	private static String buildMessage(String host, Exception cause) {
		Assert.notNull(host, 'Host must not be null');
		Assert.notNull(cause, 'Cause must not be null');
		StringBuilder message = new StringBuilder('Connection to the Docker daemon at "' + host + '" failed');
		String causeMessage = getCauseMessage(cause);
		if (StringUtils.hasText(causeMessage)) {
			message.append(' with error \'').append(causeMessage).append('\'');
		}
		message.append('; ensure the Docker daemon is running and accessible');
		return message.toString();
	}
	private static String getCauseMessage(Exception cause) {
		if (cause.getCause() != null && cause.getCause().getClass().getName().equals(JNA_EXCEPTION_CLASS_NAME)) {
			return cause.getCause().getMessage();
		}
		return cause.getMessage();
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
final class RemoteHttpClientTransport extends HttpClientTransport {
	private static final Timeout SOCKET_TIMEOUT = Timeout.of(30, TimeUnit.MINUTES);
	private RemoteHttpClientTransport(HttpClient client, HttpHost host) {
		super(client, host);
	}
	static RemoteHttpClientTransport createIfPossible(ResolvedDockerHost dockerHost) {
		return createIfPossible(dockerHost, new SslContextFactory());
	}
	static RemoteHttpClientTransport createIfPossible(ResolvedDockerHost dockerHost,
			SslContextFactory sslContextFactory) {
		if (!dockerHost.isRemote()) {
			return null;
		}
		try {
			return create(dockerHost, sslContextFactory, HttpHost.create(dockerHost.getAddress()));
		}
		catch (URISyntaxException ex) {
			return null;
		}
	}
	private static RemoteHttpClientTransport create(DockerHost host, SslContextFactory sslContextFactory,
			HttpHost tcpHost) {
		SocketConfig socketConfig = SocketConfig.copy(SocketConfig.DEFAULT).setSoTimeout(SOCKET_TIMEOUT).build();
		PoolingHttpClientConnectionManagerBuilder connectionManagerBuilder = PoolingHttpClientConnectionManagerBuilder
			.create()
			.setDefaultSocketConfig(socketConfig);
		if (host.isSecure()) {
			connectionManagerBuilder.setTlsSocketStrategy(getTlsSocketStrategy(host, sslContextFactory));
		}
		HttpClientBuilder builder = HttpClients.custom();
		builder.setConnectionManager(connectionManagerBuilder.build());
		String scheme = host.isSecure() ? 'https' : 'http';
		HttpHost httpHost = new HttpHost(scheme, tcpHost.getHostName(), tcpHost.getPort());
		return new RemoteHttpClientTransport(builder.build(), httpHost);
	}
	private static TlsSocketStrategy getTlsSocketStrategy(DockerHost host, SslContextFactory sslContextFactory) {
		String directory = host.getCertificatePath();
		Assert.hasText(directory,
				() -> 'Docker host TLS verification requires trust material location to be specified with certificate path');
		SSLContext sslContext = sslContextFactory.forDirectory(directory);
		return new DefaultClientTlsStrategy(sslContext);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
public class Message {
	private final String message;
	@JsonCreator
	Message(@JsonProperty('message') String message) {
		this.message = message;
	}
	/**
	 * Return the message contained in the response.
	 * @return the message
	 */
	public String getMessage() {
		return this.message;
	}
	@Override
	public String toString() {
		return this.message;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
public interface HttpTransport {
	/**
	 * Perform an HTTP GET operation.
	 * @param uri the destination URI (excluding any host/port)
	 * @return the operation response
	 * @throws IOException on IO error
	 */
	Response get(URI uri) throws IOException;
	/**
	 * Perform an HTTP POST operation.
	 * @param uri the destination URI (excluding any host/port)
	 * @return the operation response
	 * @throws IOException on IO error
	 */
	Response post(URI uri) throws IOException;
	/**
	 * Perform an HTTP POST operation.
	 * @param uri the destination URI (excluding any host/port)
	 * @param registryAuth registry authentication credentials
	 * @return the operation response
	 * @throws IOException on IO error
	 */
	Response post(URI uri, String registryAuth) throws IOException;
	/**
	 * Perform an HTTP POST operation.
	 * @param uri the destination URI (excluding any host/port)
	 * @param contentType the content type to write
	 * @param writer a content writer
	 * @return the operation response
	 * @throws IOException on IO error
	 */
	Response post(URI uri, String contentType, IOConsumer<OutputStream> writer) throws IOException;
	/**
	 * Perform an HTTP PUT operation.
	 * @param uri the destination URI (excluding any host/port)
	 * @param contentType the content type to write
	 * @param writer a content writer
	 * @return the operation response
	 * @throws IOException on IO error
	 */
	Response put(URI uri, String contentType, IOConsumer<OutputStream> writer) throws IOException;
	/**
	 * Perform an HTTP DELETE operation.
	 * @param uri the destination URI (excluding any host/port)
	 * @return the operation response
	 * @throws IOException on IO error
	 */
	Response delete(URI uri) throws IOException;
	/**
	 * Perform an HTTP HEAD operation.
	 * @param uri the destination URI (excluding any host/port)
	 * @return the operation response
	 * @throws IOException on IO error
	 */
	Response head(URI uri) throws IOException;
	/**
	 * Create the most suitable {@link HttpTransport} based on the {@link DockerHost}.
	 * @param dockerHost the Docker host information
	 * @return a {@link HttpTransport} instance
	 */
	static HttpTransport create(DockerHostConfiguration dockerHost) {
		ResolvedDockerHost host = ResolvedDockerHost.from(dockerHost);
		HttpTransport remote = RemoteHttpClientTransport.createIfPossible(host);
		return (remote != null) ? remote : LocalHttpClientTransport.create(host);
	}
	/**
	 * An HTTP operation response.
	 */
	interface Response extends Closeable {
		/**
		 * Return the content of the response.
		 * @return the response content
		 * @throws IOException on IO error
		 */
		InputStream getContent() throws IOException;
		default Header getHeader(String name) {
			throw new UnsupportedOperationException();
		}
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.docker.transport;
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
final class LocalHttpClientTransport extends HttpClientTransport {
	private static final String DOCKER_SCHEME = 'docker';
	private static final int DEFAULT_DOCKER_PORT = 2376;
	private static final HttpHost LOCAL_DOCKER_HOST = new HttpHost(DOCKER_SCHEME, 'localhost', DEFAULT_DOCKER_PORT);
	private LocalHttpClientTransport(HttpClient client, HttpHost host) {
		super(client, host);
	}
	static LocalHttpClientTransport create(ResolvedDockerHost dockerHost) {
		HttpClientBuilder builder = HttpClients.custom()
			.setConnectionManager(new LocalConnectionManager(dockerHost))
			.setRoutePlanner(new LocalRoutePlanner());
		HttpHost host = new HttpHost(DOCKER_SCHEME, dockerHost.getAddress());
		return new LocalHttpClientTransport(builder.build(), host);
	}
	/**
	 * {@link HttpClientConnectionManager} for local Docker.
	 */
	private static class LocalConnectionManager extends BasicHttpClientConnectionManager {
		private static final ConnectionConfig CONNECTION_CONFIG = ConnectionConfig.copy(ConnectionConfig.DEFAULT)
			.setValidateAfterInactivity(TimeValue.NEG_ONE_MILLISECOND)
			.build();
		LocalConnectionManager(ResolvedDockerHost dockerHost) {
			super(new DefaultHttpClientConnectionOperator(new LocalDetachedSocketFactory(dockerHost), null,
					new LocalDnsResolver(), (name) -> null), null);
			setConnectionConfig(CONNECTION_CONFIG);
		}
	}
	/**
	 * {@link DetachedSocketFactory} for local Docker.
	 */
	static class LocalDetachedSocketFactory implements DetachedSocketFactory {
		private static final String NPIPE_PREFIX = 'npipe://';
		private final ResolvedDockerHost dockerHost;
		LocalDetachedSocketFactory(ResolvedDockerHost dockerHost) {
			this.dockerHost = dockerHost;
		}
		@Override
		public Socket create(Proxy proxy) throws IOException {
			String address = this.dockerHost.getAddress();
			if (address.startsWith(NPIPE_PREFIX)) {
				return NamedPipeSocket.get(address.substring(NPIPE_PREFIX.length()));
			}
			return (!Platform.isWindows()) ? UnixDomainSocket.get(address) : NamedPipeSocket.get(address);
		}
	}
	/**
	 * {@link DnsResolver} that ensures only the loopback address is used.
	 */
	private static final class LocalDnsResolver implements DnsResolver {
		private static final InetAddress LOOPBACK = InetAddress.getLoopbackAddress();
		@Override
		public InetAddress[] resolve(String host) {
			return new InetAddress[] { LOOPBACK };
		}
		@Override
		public String resolveCanonicalHostname(String host) {
			return LOOPBACK.getCanonicalHostName();
		}
	}
	/**
	 * {@link HttpRoutePlanner} for local Docker.
	 */
	private static final class LocalRoutePlanner implements HttpRoutePlanner {
		@Override
		public HttpRoute determineRoute(HttpHost target, HttpContext context) {
			return new HttpRoute(LOCAL_DOCKER_HOST);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.transport;
/**
abstract class HttpClientTransport implements HttpTransport {
	static final String REGISTRY_AUTH_HEADER = 'X-Registry-Auth';
	private final HttpClient client;
	private final HttpHost host;
	protected HttpClientTransport(HttpClient client, HttpHost host) {
		Assert.notNull(client, 'Client must not be null');
		Assert.notNull(host, 'Host must not be null');
		this.client = client;
		this.host = host;
	}
	/**
	 * Perform an HTTP GET operation.
	 * @param uri the destination URI
	 * @return the operation response
	 */
	@Override
	public Response get(URI uri) {
		return execute(new HttpGet(uri));
	}
	/**
	 * Perform an HTTP POST operation.
	 * @param uri the destination URI
	 * @return the operation response
	 */
	@Override
	public Response post(URI uri) {
		return execute(new HttpPost(uri));
	}
	/**
	 * Perform an HTTP POST operation.
	 * @param uri the destination URI
	 * @param registryAuth registry authentication credentials
	 * @return the operation response
	 */
	@Override
	public Response post(URI uri, String registryAuth) {
		return execute(new HttpPost(uri), registryAuth);
	}
	/**
	 * Perform an HTTP POST operation.
	 * @param uri the destination URI
	 * @param contentType the content type to write
	 * @param writer a content writer
	 * @return the operation response
	 */
	@Override
	public Response post(URI uri, String contentType, IOConsumer<OutputStream> writer) {
		return execute(new HttpPost(uri), contentType, writer);
	}
	/**
	 * Perform an HTTP PUT operation.
	 * @param uri the destination URI
	 * @param contentType the content type to write
	 * @param writer a content writer
	 * @return the operation response
	 */
	@Override
	public Response put(URI uri, String contentType, IOConsumer<OutputStream> writer) {
		return execute(new HttpPut(uri), contentType, writer);
	}
	/**
	 * Perform an HTTP DELETE operation.
	 * @param uri the destination URI
	 * @return the operation response
	 */
	@Override
	public Response delete(URI uri) {
		return execute(new HttpDelete(uri));
	}
	/**
	 * Perform an HTTP HEAD operation.
	 * @param uri the destination URI
	 * @return the operation response
	 */
	@Override
	public Response head(URI uri) {
		return execute(new HttpHead(uri));
	}
	private Response execute(HttpUriRequestBase request, String contentType, IOConsumer<OutputStream> writer) {
		request.setEntity(new WritableHttpEntity(contentType, writer));
		return execute(request);
	}
	private Response execute(HttpUriRequestBase request, String registryAuth) {
		if (StringUtils.hasText(registryAuth)) {
			request.setHeader(REGISTRY_AUTH_HEADER, registryAuth);
		}
		return execute(request);
	}
	private Response execute(HttpUriRequest request) {
		try {
			ClassicHttpResponse response = this.client.executeOpen(this.host, request, null);
			int statusCode = response.getCode();
			if (statusCode >= 400 && statusCode <= 500) {
				HttpEntity entity = response.getEntity();
				Errors errors = (statusCode != 500) ? getErrorsFromResponse(entity) : null;
				Message message = getMessageFromResponse(entity);
				StatusLine statusLine = new StatusLine(response);
				throw new DockerEngineException(this.host.toHostString(), request.getUri(), statusCode,
						statusLine.getReasonPhrase(), errors, message);
			}
			return new HttpClientResponse(response);
		}
		catch (IOException | URISyntaxException ex) {
			throw new DockerConnectionException(this.host.toHostString(), ex);
		}
	}
	private Errors getErrorsFromResponse(HttpEntity entity) {
		try {
			return SharedObjectMapper.get().readValue(entity.getContent(), Errors.class);
		}
		catch (IOException ex) {
			return null;
		}
	}
	private Message getMessageFromResponse(HttpEntity entity) {
		try {
			return (entity.getContent() != null)
					? SharedObjectMapper.get().readValue(entity.getContent(), Message.class) : null;
		}
		catch (IOException ex) {
			return null;
		}
	}
	HttpHost getHost() {
		return this.host;
	}
	/**
	 * {@link HttpEntity} to send {@link Content} content.
	 */
	private static class WritableHttpEntity extends AbstractHttpEntity {
		private final IOConsumer<OutputStream> writer;
		WritableHttpEntity(String contentType, IOConsumer<OutputStream> writer) {
			super(contentType, 'UTF-8');
			this.writer = writer;
		}
		@Override
		public boolean isRepeatable() {
			return false;
		}
		@Override
		public long getContentLength() {
			if (this.getContentType() != null && this.getContentType().equals('application/json')) {
				return calculateStringContentLength();
			}
			return -1;
		}
		@Override
		public InputStream getContent() throws UnsupportedOperationException {
			throw new UnsupportedOperationException();
		}
		@Override
		public void writeTo(OutputStream outputStream) throws IOException {
			this.writer.accept(outputStream);
		}
		@Override
		public boolean isStreaming() {
			return true;
		}
		private int calculateStringContentLength() {
			try {
				ByteArrayOutputStream bytes = new ByteArrayOutputStream();
				this.writer.accept(bytes);
				return bytes.toByteArray().length;
			}
			catch (IOException ex) {
				return -1;
			}
		}
		@Override
		public void close() throws IOException {
		}
	}
	/**
	 * An HTTP operation response.
	 */
	private static class HttpClientResponse implements Response {
		private final ClassicHttpResponse response;
		HttpClientResponse(ClassicHttpResponse response) {
			this.response = response;
		}
		@Override
		public InputStream getContent() throws IOException {
			return this.response.getEntity().getContent();
		}
		@Override
		public Header getHeader(String name) {
			return this.response.getFirstHeader(name);
		}
		@Override
		public void close() throws IOException {
			this.response.close();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
final class RandomString {
	private static final Random random = new Random();
	private RandomString() {
	}
	static String generate(String prefix, int randomLength) {
		Assert.notNull(prefix, 'Prefix must not be null');
		return prefix + generateRandom(randomLength);
	}
	static CharSequence generateRandom(int length) {
		IntStream chars = random.ints("a", "z" + 1).limit(length);
		return chars.collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ImageConfig extends MappedObject {
	private final Map<String, String> labels;
	private final Map<String, String> configEnv;
	ImageConfig(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.labels = extractLabels();
		this.configEnv = parseConfigEnv();
	}
	@SuppressWarnings('unchecked')
	private Map<String, String> extractLabels() {
		Map<String, String> labels = valueAt('/Labels', Map.class);
		if (labels == null) {
			return Collections.emptyMap();
		}
		return labels;
	}
	private Map<String, String> parseConfigEnv() {
		String[] entries = valueAt('/Env', String[].class);
		if (entries == null) {
			return Collections.emptyMap();
		}
		Map<String, String> env = new LinkedHashMap<>();
		for (String entry : entries) {
			int i = entry.indexOf("=");
			String name = (i != -1) ? entry.substring(0, i) : entry;
			String value = (i != -1) ? entry.substring(i + 1) : null;
			env.put(name, value);
		}
		return Collections.unmodifiableMap(env);
	}
	JsonNode getNodeCopy() {
		return super.getNode().deepCopy();
	}
	/**
	 * Return the image labels. If the image has no labels, an empty {@code Map} is
	 * returned.
	 * @return the image labels, never {@code null}
	 */
	public Map<String, String> getLabels() {
		return this.labels;
	}
	/**
	 * Return the image environment variables. If the image has no environment variables,
	 * an empty {@code Map} is returned.
	 * @return the env, never {@code null}
	 */
	public Map<String, String> getEnv() {
		return this.configEnv;
	}
	/**
	 * Create an updated copy of this image config.
	 * @param update consumer to apply updates
	 * @return an updated image config
	 */
	public ImageConfig copy(Consumer<Update> update) {
		return new Update(this).run(update);
	}
	/**
	 * Update class used to change data when creating a copy.
	 */
	public static final class Update {
		private final ObjectNode copy;
		private Update(ImageConfig source) {
			this.copy = source.getNode().deepCopy();
		}
		private ImageConfig run(Consumer<Update> update) {
			update.accept(this);
			return new ImageConfig(this.copy);
		}
		/**
		 * Update the image config with an additional label.
		 * @param label the label name
		 * @param value the label value
		 */
		public void withLabel(String label, String value) {
			JsonNode labels = this.copy.at('/Labels');
			if (labels.isMissingNode()) {
				labels = this.copy.putObject('Labels');
			}
			((ObjectNode) labels).put(label, value);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ImageArchive implements TarArchive {
	private static final Instant WINDOWS_EPOCH_PLUS_SECOND = OffsetDateTime.of(1980, 1, 1, 0, 0, 1, 0, ZoneOffset.UTC)
		.toInstant();
	private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ISO_ZONED_DATE_TIME
		.withZone(ZoneOffset.UTC);
	private static final String EMPTY_LAYER_NAME_PREFIX = 'blank_';
	private static final IOConsumer<Update> NO_UPDATES = (update) -> {
	};
	private final ObjectMapper objectMapper;
	private final ImageConfig imageConfig;
	private final Instant createDate;
	private final ImageReference tag;
	private final String os;
	private final String architecture;
	private final String variant;
	private final List<LayerId> existingLayers;
	private final List<Layer> newLayers;
	ImageArchive(ObjectMapper objectMapper, ImageConfig imageConfig, Instant createDate, ImageReference tag, String os,
			String architecture, String variant, List<LayerId> existingLayers, List<Layer> newLayers) {
		this.objectMapper = objectMapper;
		this.imageConfig = imageConfig;
		this.createDate = createDate;
		this.tag = tag;
		this.os = os;
		this.architecture = architecture;
		this.variant = variant;
		this.existingLayers = existingLayers;
		this.newLayers = newLayers;
	}
	/**
	 * Return the image config for the archive.
	 * @return the image config
	 */
	public ImageConfig getImageConfig() {
		return this.imageConfig;
	}
	/**
	 * Return the create date of the archive.
	 * @return the create date
	 */
	public Instant getCreateDate() {
		return this.createDate;
	}
	/**
	 * Return the tag of the archive.
	 * @return the tag
	 */
	public ImageReference getTag() {
		return this.tag;
	}
	@Override
	public void writeTo(OutputStream outputStream) throws IOException {
		TarArchive.of(this::write).writeTo(outputStream);
	}
	private void write(Layout writer) throws IOException {
		List<LayerId> writtenLayers = writeLayers(writer);
		String config = writeConfig(writer, writtenLayers);
		writeManifest(writer, config, writtenLayers);
	}
	private List<LayerId> writeLayers(Layout writer) throws IOException {
		for (int i = 0; i < this.existingLayers.size(); i++) {
			writeEmptyLayer(writer, EMPTY_LAYER_NAME_PREFIX + i);
		}
		List<LayerId> writtenLayers = new ArrayList<>();
		for (Layer layer : this.newLayers) {
			writtenLayers.add(writeLayer(writer, layer));
		}
		return Collections.unmodifiableList(writtenLayers);
	}
	private void writeEmptyLayer(Layout writer, String name) throws IOException {
		writer.file(name, Owner.ROOT, Content.of(''));
	}
	private LayerId writeLayer(Layout writer, Layer layer) throws IOException {
		LayerId id = layer.getId();
		writer.file(id.getHash() + '.tar', Owner.ROOT, layer);
		return id;
	}
	private String writeConfig(Layout writer, List<LayerId> writtenLayers) throws IOException {
		try {
			ObjectNode config = createConfig(writtenLayers);
			String json = this.objectMapper.writeValueAsString(config).replace('\r\n', '\n');
			MessageDigest digest = MessageDigest.getInstance('SHA-256');
			InspectedContent content = InspectedContent.of(Content.of(json), digest::update);
			String name = LayerId.ofSha256Digest(digest.digest()).getHash() + '.json';
			writer.file(name, Owner.ROOT, content);
			return name;
		}
		catch (NoSuchAlgorithmException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private ObjectNode createConfig(List<LayerId> writtenLayers) {
		ObjectNode config = this.objectMapper.createObjectNode();
		config.set('Config', this.imageConfig.getNodeCopy());
		config.set('Created', config.textNode(getCreatedDate()));
		config.set('History', createHistory(writtenLayers));
		config.set('Os', config.textNode(this.os));
		config.set('Architecture', config.textNode(this.architecture));
		config.set('Variant', config.textNode(this.variant));
		config.set('RootFS', createRootFs(writtenLayers));
		return config;
	}
	private String getCreatedDate() {
		return DATE_FORMATTER.format(this.createDate);
	}
	private JsonNode createHistory(List<LayerId> writtenLayers) {
		ArrayNode history = this.objectMapper.createArrayNode();
		int size = this.existingLayers.size() + writtenLayers.size();
		for (int i = 0; i < size; i++) {
			history.addObject();
		}
		return history;
	}
	private JsonNode createRootFs(List<LayerId> writtenLayers) {
		ObjectNode rootFs = this.objectMapper.createObjectNode();
		ArrayNode diffIds = rootFs.putArray('diff_ids');
		this.existingLayers.stream().map(Object::toString).forEach(diffIds::add);
		writtenLayers.stream().map(Object::toString).forEach(diffIds::add);
		return rootFs;
	}
	private void writeManifest(Layout writer, String config, List<LayerId> writtenLayers) throws IOException {
		ArrayNode manifest = createManifest(config, writtenLayers);
		String manifestJson = this.objectMapper.writeValueAsString(manifest);
		writer.file('manifest.json', Owner.ROOT, Content.of(manifestJson));
	}
	private ArrayNode createManifest(String config, List<LayerId> writtenLayers) {
		ArrayNode manifest = this.objectMapper.createArrayNode();
		ObjectNode entry = manifest.addObject();
		entry.set('Config', entry.textNode(config));
		entry.set('Layers', getManifestLayers(writtenLayers));
		if (this.tag != null) {
			entry.set('RepoTags', entry.arrayNode().add(this.tag.toString()));
		}
		return manifest;
	}
	private ArrayNode getManifestLayers(List<LayerId> writtenLayers) {
		ArrayNode layers = this.objectMapper.createArrayNode();
		for (int i = 0; i < this.existingLayers.size(); i++) {
			layers.add(EMPTY_LAYER_NAME_PREFIX + i);
		}
		writtenLayers.stream().map((id) -> id.getHash() + '.tar').forEach(layers::add);
		return layers;
	}
	/**
	 * Create a new {@link ImageArchive} based on an existing {@link Image}.
	 * @param image the image that this archive is based on
	 * @return the new image archive.
	 * @throws IOException on IO error
	 */
	public static ImageArchive from(Image image) throws IOException {
		return from(image, NO_UPDATES);
	}
	/**
	 * Create a new {@link ImageArchive} based on an existing {@link Image}.
	 * @param image the image that this archive is based on
	 * @param update consumer to apply updates
	 * @return the new image archive.
	 * @throws IOException on IO error
	 */
	public static ImageArchive from(Image image, IOConsumer<Update> update) throws IOException {
		return new Update(image).applyTo(update);
	}
	/**
	 * Update class used to change data when creating an image archive.
	 */
	public static final class Update {
		private final Image image;
		private ImageConfig config;
		private Instant createDate;
		private ImageReference tag;
		private final List<Layer> newLayers = new ArrayList<>();
		private Update(Image image) {
			this.image = image;
			this.config = image.getConfig();
		}
		private ImageArchive applyTo(IOConsumer<Update> update) throws IOException {
			update.accept(this);
			Instant createDate = (this.createDate != null) ? this.createDate : WINDOWS_EPOCH_PLUS_SECOND;
			return new ImageArchive(SharedObjectMapper.get(), this.config, createDate, this.tag, this.image.getOs(),
					this.image.getArchitecture(), this.image.getVariant(), this.image.getLayers(),
					Collections.unmodifiableList(this.newLayers));
		}
		/**
		 * Apply updates to the {@link ImageConfig}.
		 * @param update consumer to apply updates
		 */
		public void withUpdatedConfig(Consumer<ImageConfig.Update> update) {
			this.config = this.config.copy(update);
		}
		/**
		 * Add a new layer to the image archive.
		 * @param layer the layer to add
		 */
		public void withNewLayer(Layer layer) {
			Assert.notNull(layer, 'Layer must not be null');
			this.newLayers.add(layer);
		}
		/**
		 * Set the create date for the image archive.
		 * @param createDate the create date
		 */
		public void withCreateDate(Instant createDate) {
			Assert.notNull(createDate, 'CreateDate must not be null');
			this.createDate = createDate;
		}
		/**
		 * Set the tag for the image archive.
		 * @param tag the tag
		 */
		public void withTag(ImageReference tag) {
			Assert.notNull(tag, 'Tag must not be null');
			this.tag = tag.inTaggedForm();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ImageArchiveIndex extends MappedObject {
	private final Integer schemaVersion;
	private final List<BlobReference> manifests;
	protected ImageArchiveIndex(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.schemaVersion = valueAt('/schemaVersion', Integer.class);
		this.manifests = childrenAt('/manifests', BlobReference::new);
	}
	public Integer getSchemaVersion() {
		return this.schemaVersion;
	}
	public List<BlobReference> getManifests() {
		return this.manifests;
	}
	/**
	 * Create an {@link ImageArchiveIndex} from the provided JSON input stream.
	 * @param content the JSON input stream
	 * @return a new {@link ImageArchiveIndex} instance
	 * @throws IOException on IO error
	 */
	public static ImageArchiveIndex of(InputStream content) throws IOException {
		return of(content, ImageArchiveIndex::new);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class Image extends MappedObject {
	private final List<String> digests;
	private final ImageConfig config;
	private final List<LayerId> layers;
	private final String os;
	private final String architecture;
	private final String variant;
	private final String created;
	Image(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.digests = childrenAt('/RepoDigests', JsonNode::asText);
		this.config = new ImageConfig(getNode().at('/Config'));
		this.layers = extractLayers(valueAt('/RootFS/Layers', String[].class));
		this.os = valueAt('/Os', String.class);
		this.architecture = valueAt('/Architecture', String.class);
		this.variant = valueAt('/Variant', String.class);
		this.created = valueAt('/Created', String.class);
	}
	private List<LayerId> extractLayers(String[] layers) {
		if (layers == null) {
			return Collections.emptyList();
		}
		return Arrays.stream(layers).map(LayerId::of).toList();
	}
	/**
	 * Return the digests of the image.
	 * @return the image digests
	 */
	public List<String> getDigests() {
		return this.digests;
	}
	/**
	 * Return image config information.
	 * @return the image config
	 */
	public ImageConfig getConfig() {
		return this.config;
	}
	/**
	 * Return the layer IDs contained in the image.
	 * @return the layer IDs.
	 */
	public List<LayerId> getLayers() {
		return this.layers;
	}
	/**
	 * Return the OS of the image.
	 * @return the image OS
	 */
	public String getOs() {
		return (this.os != null) ? this.os : 'linux';
	}
	/**
	 * Return the architecture of the image.
	 * @return the image architecture
	 */
	public String getArchitecture() {
		return this.architecture;
	}
	/**
	 * Return the variant of the image.
	 * @return the image variant
	 */
	public String getVariant() {
		return this.variant;
	}
	/**
	 * Return the created date of the image.
	 * @return the image created date
	 */
	public String getCreated() {
		return this.created;
	}
	/**
	 * Create a new {@link Image} instance from the specified JSON content.
	 * @param content the JSON content
	 * @return a new {@link Image} instance
	 * @throws IOException on IO error
	 */
	public static Image of(InputStream content) throws IOException {
		return of(content, Image::new);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ImagePlatform {
	private final String os;
	private final String architecture;
	private final String variant;
	ImagePlatform(String os, String architecture, String variant) {
		Assert.hasText(os, 'OS must not be empty');
		this.os = os;
		this.architecture = architecture;
		this.variant = variant;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ImagePlatform other = (ImagePlatform) obj;
		return Objects.equals(this.architecture, other.architecture) && Objects.equals(this.os, other.os)
				&& Objects.equals(this.variant, other.variant);
	}
	@Override
	public int hashCode() {
		return Objects.hash(this.architecture, this.os, this.variant);
	}
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder(this.os);
		if (this.architecture != null) {
			builder.append('/').append(this.architecture);
		}
		if (this.variant != null) {
			builder.append('/').append(this.variant);
		}
		return builder.toString();
	}
	/**
	 * Create a new {@link ImagePlatform} from the given value in the form
	 * {@code os[/architecture[/variant]]}.
	 * @param value the value to parse
	 * @return an {@link ImagePlatform} instance
	 */
	public static ImagePlatform of(String value) {
		Assert.hasText(value, 'Value must not be empty');
		String[] split = value.split('/+');
		return switch (split.length) {
			case 1 -> new ImagePlatform(split[0], null, null);
			case 2 -> new ImagePlatform(split[0], split[1], null);
			case 3 -> new ImagePlatform(split[0], split[1], split[2]);
			default -> throw new IllegalArgumentException(
					'ImagePlatform value "' + value + '" must be in the form of os[/architecture[/variant]]');
		};
	}
	/**
	 * Create a new {@link ImagePlatform} matching the platform information from the
	 * provided {@link Image}.
	 * @param image the image to get platform information from
	 * @return an {@link ImagePlatform} instance
	 */
	public static ImagePlatform from(Image image) {
		return new ImagePlatform(image.getOs(), image.getArchitecture(), image.getVariant());
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class Manifest extends MappedObject {
	private final Integer schemaVersion;
	private final String mediaType;
	private final List<BlobReference> layers;
	protected Manifest(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.schemaVersion = valueAt('/schemaVersion', Integer.class);
		this.mediaType = valueAt('/mediaType', String.class);
		this.layers = childrenAt('/layers', BlobReference::new);
	}
	public Integer getSchemaVersion() {
		return this.schemaVersion;
	}
	public String getMediaType() {
		return this.mediaType;
	}
	public List<BlobReference> getLayers() {
		return this.layers;
	}
	/**
	 * Create an {@link Manifest} from the provided JSON input stream.
	 * @param content the JSON input stream
	 * @return a new {@link Manifest} instance
	 * @throws IOException on IO error
	 */
	public static Manifest of(InputStream content) throws IOException {
		return of(content, Manifest::new);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public final class LayerId {
	private final String value;
	private final String algorithm;
	private final String hash;
	private LayerId(String value, String algorithm, String hash) {
		this.value = value;
		this.algorithm = algorithm;
		this.hash = hash;
	}
	/**
	 * Return the algorithm of layer.
	 * @return the algorithm
	 */
	public String getAlgorithm() {
		return this.algorithm;
	}
	/**
	 * Return the hash of the layer.
	 * @return the layer hash
	 */
	public String getHash() {
		return this.hash;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.value.equals(((LayerId) obj).value);
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Create a new {@link LayerId} with the specified value.
	 * @param value the layer ID value of the form {@code algorithm: hash}
	 * @return a new layer ID instance
	 */
	public static LayerId of(String value) {
		Assert.hasText(value, 'Value must not be empty');
		int i = value.indexOf(":");
		Assert.isTrue(i >= 0, () -> 'Invalid layer ID "' + value + '"');
		return new LayerId(value, value.substring(0, i), value.substring(i + 1));
	}
	/**
	 * Create a new {@link LayerId} from a SHA-256 digest.
	 * @param digest the digest
	 * @return a new layer ID instance
	 */
	public static LayerId ofSha256Digest(byte[] digest) {
		Assert.notNull(digest, 'Digest must not be null');
		Assert.isTrue(digest.length == 32, 'Digest must be exactly 32 bytes');
		String algorithm = 'sha256';
		String hash = String.format('%064x', new BigInteger(1, digest));
		return new LayerId(algorithm + ':' + hash, algorithm, hash);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public final class ApiVersion {
	private static final Pattern PATTERN = Pattern.compile('^v?(\\d+)\\.(\\d*)$');
	private final int major;
	private final int minor;
	private ApiVersion(int major, int minor) {
		this.major = major;
		this.minor = minor;
	}
	/**
	 * Return the major version number.
	 * @return the major version
	 */
	int getMajor() {
		return this.major;
	}
	/**
	 * Return the minor version number.
	 * @return the minor version
	 */
	int getMinor() {
		return this.minor;
	}
	/**
	 * Returns if this API version supports the given version. A {@code 0.x} matches only
	 * the same version number. A 1.x or higher release matches when the versions have the
	 * same major version and a minor that is equal or greater.
	 * @param other the version to check against
	 * @return if the specified API version is supported
	 */
	public boolean supports(ApiVersion other) {
		if (equals(other)) {
			return true;
		}
		if (this.major == 0 || this.major != other.major) {
			return false;
		}
		return this.minor >= other.minor;
	}
	/**
	 * Returns if this API version supports any of the given versions.
	 * @param others the versions to check against
	 * @return if any of the specified API versions are supported
	 * @see #supports(ApiVersion)
	 */
	public boolean supportsAny(ApiVersion... others) {
		for (ApiVersion other : others) {
			if (supports(other)) {
				return true;
			}
		}
		return false;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ApiVersion other = (ApiVersion) obj;
		return (this.major == other.major) && (this.minor == other.minor);
	}
	@Override
	public int hashCode() {
		return this.major * 31 + this.minor;
	}
	@Override
	public String toString() {
		return this.major + '.' + this.minor;
	}
	/**
	 * Factory method to parse a string into an {@link ApiVersion} instance.
	 * @param value the value to parse.
	 * @return the corresponding {@link ApiVersion}
	 * @throws IllegalArgumentException if the value could not be parsed
	 */
	public static ApiVersion parse(String value) {
		Assert.hasText(value, 'Value must not be empty');
		Matcher matcher = PATTERN.matcher(value);
		Assert.isTrue(matcher.matches(), () -> 'Malformed version number "' + value + '"');
		try {
			int major = Integer.parseInt(matcher.group(1));
			int minor = Integer.parseInt(matcher.group(2));
			return new ApiVersion(major, minor);
		}
		catch (NumberFormatException ex) {
			throw new IllegalArgumentException('Malformed version number "' + value + '"', ex);
		}
	}
	public static ApiVersion of(int major, int minor) {
		return new ApiVersion(major, minor);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public final class ContainerReference {
	private final String value;
	private ContainerReference(String value) {
		Assert.hasText(value, 'Value must not be empty');
		this.value = value;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ContainerReference other = (ContainerReference) obj;
		return this.value.equals(other.value);
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Factory method to create a {@link ContainerReference} with a specific value.
	 * @param value the container reference value
	 * @return a new container reference instance
	 */
	public static ContainerReference of(String value) {
		return new ContainerReference(value);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ContainerStatus extends MappedObject {
	private final int statusCode;
	private final String waitingErrorMessage;
	ContainerStatus(int statusCode, String waitingErrorMessage) {
		super(null, null);
		this.statusCode = statusCode;
		this.waitingErrorMessage = waitingErrorMessage;
	}
	ContainerStatus(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.statusCode = valueAt('/StatusCode', Integer.class);
		this.waitingErrorMessage = valueAt('/Error/Message', String.class);
	}
	/**
	 * Return the container exit status code.
	 * @return the exit status code
	 */
	public int getStatusCode() {
		return this.statusCode;
	}
	/**
	 * Return a message indicating an error waiting for a container to stop.
	 * @return the waiting error message
	 */
	public String getWaitingErrorMessage() {
		return this.waitingErrorMessage;
	}
	/**
	 * Create a new {@link ContainerStatus} instance from the specified JSON content
	 * stream.
	 * @param content the JSON content stream
	 * @return a new {@link ContainerStatus} instance
	 * @throws IOException on IO error
	 */
	public static ContainerStatus of(InputStream content) throws IOException {
		return of(content, ContainerStatus::new);
	}
	/**
	 * Create a new {@link ContainerStatus} instance with the specified values.
	 * @param statusCode the status code
	 * @param errorMessage the error message
	 * @return a new {@link ContainerStatus} instance
	 */
	public static ContainerStatus of(int statusCode, String errorMessage) {
		return new ContainerStatus(statusCode, errorMessage);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class Layer implements Content {
	private final Content content;
	private final LayerId id;
	Layer(TarArchive tarArchive) throws NoSuchAlgorithmException, IOException {
		MessageDigest digest = MessageDigest.getInstance('SHA-256');
		this.content = InspectedContent.of(tarArchive::writeTo, digest::update);
		this.id = LayerId.ofSha256Digest(digest.digest());
	}
	/**
	 * Return the ID of the layer.
	 * @return the layer ID
	 */
	public LayerId getId() {
		return this.id;
	}
	@Override
	public int size() {
		return this.content.size();
	}
	@Override
	public void writeTo(OutputStream outputStream) throws IOException {
		this.content.writeTo(outputStream);
	}
	/**
	 * Factory method to create a new {@link Layer} with a specific {@link Layout}.
	 * @param layout the layer layout
	 * @return a new layer instance
	 * @throws IOException on IO error
	 */
	public static Layer of(IOConsumer<Layout> layout) throws IOException {
		Assert.notNull(layout, 'Layout must not be null');
		return fromTarArchive(TarArchive.of(layout));
	}
	/**
	 * Factory method to create a new {@link Layer} from a {@link TarArchive}.
	 * @param tarArchive the contents of the layer
	 * @return a new layer instance
	 * @throws IOException on error
	 */
	public static Layer fromTarArchive(TarArchive tarArchive) throws IOException {
		Assert.notNull(tarArchive, 'TarArchive must not be null');
		try {
			return new Layer(tarArchive);
		}
		catch (NoSuchAlgorithmException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ImageName {
	private static final String DEFAULT_DOMAIN = 'docker.io';
	private static final String OFFICIAL_REPOSITORY_NAME = 'library';
	private static final String LEGACY_DOMAIN = 'index.docker.io';
	private final String domain;
	private final String name;
	private final String string;
	ImageName(String domain, String path) {
		Assert.hasText(path, 'Path must not be empty');
		this.domain = getDomainOrDefault(domain);
		this.name = getNameWithDefaultPath(this.domain, path);
		this.string = this.domain + '/' + this.name;
	}
	/**
	 * Return the domain for this image name.
	 * @return the domain
	 */
	public String getDomain() {
		return this.domain;
	}
	/**
	 * Return the name of this image.
	 * @return the image name
	 */
	public String getName() {
		return this.name;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ImageName other = (ImageName) obj;
		boolean result = true;
		result = result && this.domain.equals(other.domain);
		result = result && this.name.equals(other.name);
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.domain.hashCode();
		result = prime * result + this.name.hashCode();
		return result;
	}
	@Override
	public String toString() {
		return this.string;
	}
	public String toLegacyString() {
		if (DEFAULT_DOMAIN.equals(this.domain)) {
			return LEGACY_DOMAIN + '/' + this.name;
		}
		return this.string;
	}
	private String getDomainOrDefault(String domain) {
		if (domain == null || LEGACY_DOMAIN.equals(domain)) {
			return DEFAULT_DOMAIN;
		}
		return domain;
	}
	private String getNameWithDefaultPath(String domain, String name) {
		if (DEFAULT_DOMAIN.equals(domain) && !name.contains('/')) {
			return OFFICIAL_REPOSITORY_NAME + '/' + name;
		}
		return name;
	}
	/**
	 * Create a new {@link ImageName} from the given value. The following value forms can
	 * be used:
	 * <ul>
	 * <li>{@code name} (maps to {@code docker.io/library/name})</li>
	 * <li>{@code domain/name}</li>
	 * <li>{@code domain:port/name}</li>
	 * </ul>
	 * @param value the value to parse
	 * @return an {@link ImageName} instance
	 */
	public static ImageName of(String value) {
		Assert.hasText(value, 'Value must not be empty');
		String domain = parseDomain(value);
		String path = (domain != null) ? value.substring(domain.length() + 1) : value;
		Assert.isTrue(Regex.PATH.matcher(path).matches(),
				() -> 'Unable to parse name \'' + value + '\'. '
						+ 'Image name must be in the form "[domainHost:port/][path/]name", '
						+ 'with "path" and "name" containing only [a-z0-9][.][_][-]');
		return new ImageName(domain, path);
	}
	static String parseDomain(String value) {
		int firstSlash = value.indexOf("/");
		String candidate = (firstSlash != -1) ? value.substring(0, firstSlash) : null;
		if (candidate != null && Regex.DOMAIN.matcher(candidate).matches()) {
			return candidate;
		}
		return null;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ContainerConfig {
	private final String json;
	ContainerConfig(String user, ImageReference image, String command, List<String> args, Map<String, String> labels,
			List<Binding> bindings, Map<String, String> env, String networkMode, List<String> securityOptions)
			throws IOException {
		Assert.notNull(image, 'Image must not be null');
		Assert.hasText(command, 'Command must not be empty');
		ObjectMapper objectMapper = SharedObjectMapper.get();
		ObjectNode node = objectMapper.createObjectNode();
		if (StringUtils.hasText(user)) {
			node.put('User', user);
		}
		node.put('Image', image.toString());
		ArrayNode commandNode = node.putArray('Cmd');
		commandNode.add(command);
		args.forEach(commandNode::add);
		ArrayNode envNode = node.putArray('Env');
		env.forEach((name, value) -> envNode.add(name + '=' + value));
		ObjectNode labelsNode = node.putObject('Labels');
		labels.forEach(labelsNode::put);
		ObjectNode hostConfigNode = node.putObject('HostConfig');
		if (networkMode != null) {
			hostConfigNode.put('NetworkMode', networkMode);
		}
		ArrayNode bindsNode = hostConfigNode.putArray('Binds');
		bindings.forEach((binding) -> bindsNode.add(binding.toString()));
		if (!CollectionUtils.isEmpty(securityOptions)) {
			ArrayNode securityOptsNode = hostConfigNode.putArray('SecurityOpt');
			securityOptions.forEach(securityOptsNode::add);
		}
		this.json = objectMapper.writeValueAsString(node);
	}
	/**
	 * Write this container configuration to the specified {@link OutputStream}.
	 * @param outputStream the output stream
	 * @throws IOException on IO error
	 */
	public void writeTo(OutputStream outputStream) throws IOException {
		StreamUtils.copy(this.json, StandardCharsets.UTF_8, outputStream);
	}
	@Override
	public String toString() {
		return this.json;
	}
	/**
	 * Factory method to create a {@link ContainerConfig} with specific settings.
	 * @param imageReference the source image for the container config
	 * @param update an update callback used to customize the config
	 * @return a new {@link ContainerConfig} instance
	 */
	public static ContainerConfig of(ImageReference imageReference, Consumer<Update> update) {
		Assert.notNull(imageReference, 'ImageReference must not be null');
		Assert.notNull(update, 'Update must not be null');
		return new Update(imageReference).run(update);
	}
	/**
	 * Update class used to change data when creating a container config.
	 */
	public static class Update {
		private final ImageReference image;
		private String user;
		private String command;
		private final List<String> args = new ArrayList<>();
		private final Map<String, String> labels = new LinkedHashMap<>();
		private final List<Binding> bindings = new ArrayList<>();
		private final Map<String, String> env = new LinkedHashMap<>();
		private String networkMode;
		private final List<String> securityOptions = new ArrayList<>();
		Update(ImageReference image) {
			this.image = image;
		}
		private ContainerConfig run(Consumer<Update> update) {
			update.accept(this);
			try {
				return new ContainerConfig(this.user, this.image, this.command, this.args, this.labels, this.bindings,
						this.env, this.networkMode, this.securityOptions);
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
		/**
		 * Update the container config with a specific user.
		 * @param user the user to set
		 */
		public void withUser(String user) {
			this.user = user;
		}
		/**
		 * Update the container config with a specific command.
		 * @param command the command to set
		 * @param args additional arguments to add
		 * @see #withArgs(String...)
		 */
		public void withCommand(String command, String... args) {
			this.command = command;
			withArgs(args);
		}
		/**
		 * Update the container config with additional args.
		 * @param args the arguments to add
		 */
		public void withArgs(String... args) {
			this.args.addAll(Arrays.asList(args));
		}
		/**
		 * Update the container config with an additional label.
		 * @param name the label name
		 * @param value the label value
		 */
		public void withLabel(String name, String value) {
			this.labels.put(name, value);
		}
		/**
		 * Update the container config with an additional binding.
		 * @param binding the binding
		 */
		public void withBinding(Binding binding) {
			this.bindings.add(binding);
		}
		/**
		 * Update the container config with an additional environment variable.
		 * @param name the variable name
		 * @param value the variable value
		 */
		public void withEnv(String name, String value) {
			this.env.put(name, value);
		}
		/**
		 * Update the container config with the network that the build container will
		 * connect to.
		 * @param networkMode the network
		 */
		public void withNetworkMode(String networkMode) {
			this.networkMode = networkMode;
		}
		/**
		 * Update the container config with a security option.
		 * @param option the security option
		 */
		public void withSecurityOption(String option) {
			this.securityOptions.add(option);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public final class ImageReference {
	private static final Pattern JAR_VERSION_PATTERN = Pattern.compile('^(.*)(-\\d+)$');
	private static final String LATEST = 'latest';
	private final ImageName name;
	private final String tag;
	private final String digest;
	private final String string;
	private ImageReference(ImageName name, String tag, String digest) {
		Assert.notNull(name, 'Name must not be null');
		this.name = name;
		this.tag = tag;
		this.digest = digest;
		this.string = buildString(name.toString(), tag, digest);
	}
	/**
	 * Return the domain for this image name.
	 * @return the domain
	 * @see ImageName#getDomain()
	 */
	public String getDomain() {
		return this.name.getDomain();
	}
	/**
	 * Return the name of this image.
	 * @return the image name
	 * @see ImageName#getName()
	 */
	public String getName() {
		return this.name.getName();
	}
	/**
	 * Return the tag from the reference or {@code null}.
	 * @return the referenced tag
	 */
	public String getTag() {
		return this.tag;
	}
	/**
	 * Return the digest from the reference or {@code null}.
	 * @return the referenced digest
	 */
	public String getDigest() {
		return this.digest;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ImageReference other = (ImageReference) obj;
		boolean result = true;
		result = result && this.name.equals(other.name);
		result = result && ObjectUtils.nullSafeEquals(this.tag, other.tag);
		result = result && ObjectUtils.nullSafeEquals(this.digest, other.digest);
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.name.hashCode();
		result = prime * result + ObjectUtils.nullSafeHashCode(this.tag);
		result = prime * result + ObjectUtils.nullSafeHashCode(this.digest);
		return result;
	}
	@Override
	public String toString() {
		return this.string;
	}
	public String toLegacyString() {
		return buildString(this.name.toLegacyString(), this.tag, this.digest);
	}
	private String buildString(String name, String tag, String digest) {
		StringBuilder string = new StringBuilder(name);
		if (tag != null) {
			string.append(':').append(tag);
		}
		if (digest != null) {
			string.append('@').append(digest);
		}
		return string.toString();
	}
	/**
	 * Create a new {@link ImageReference} with an updated digest.
	 * @param digest the new digest
	 * @return an updated image reference
	 */
	public ImageReference withDigest(String digest) {
		return new ImageReference(this.name, null, digest);
	}
	/**
	 * Return an {@link ImageReference} in the form {@code 'imagename:tag'}. If the tag
	 * has not been defined then {@code latest} is used.
	 * @return the image reference in tagged form
	 * @throws IllegalStateException if the image reference contains a digest
	 */
	public ImageReference inTaggedForm() {
		Assert.state(this.digest == null, () -> 'Image reference "' + this + '" cannot contain a digest');
		return new ImageReference(this.name, (this.tag != null) ? this.tag : LATEST, null);
	}
	/**
	 * Return an {@link ImageReference} without the tag.
	 * @return the image reference in tagless form
	 * @since 2.7.12
	 */
	public ImageReference inTaglessForm() {
		if (this.tag == null) {
			return this;
		}
		return new ImageReference(this.name, null, this.digest);
	}
	/**
	 * Return an {@link ImageReference} containing either a tag or a digest. If neither
	 * the digest nor the tag has been defined then tag {@code latest} is used.
	 * @return the image reference in tagged or digest form
	 */
	public ImageReference inTaggedOrDigestForm() {
		if (this.digest != null) {
			return this;
		}
		return inTaggedForm();
	}
	/**
	 * Create a new {@link ImageReference} instance deduced from a source JAR file that
	 * follows common Java naming conventions.
	 * @param jarFile the source jar file
	 * @return an {@link ImageName} for the jar file.
	 */
	public static ImageReference forJarFile(File jarFile) {
		String filename = jarFile.getName();
		Assert.isTrue(filename.toLowerCase(Locale.ROOT).endsWith('.jar'), () -> 'File "' + jarFile + '" is not a JAR');
		filename = filename.substring(0, filename.length() - 4);
		int firstDot = filename.indexOf(".");
		if (firstDot == -1) {
			return of(filename);
		}
		String name = filename.substring(0, firstDot);
		String version = filename.substring(firstDot + 1);
		Matcher matcher = JAR_VERSION_PATTERN.matcher(name);
		if (matcher.matches()) {
			name = matcher.group(1);
			version = matcher.group(2).substring(1) + '.' + version;
		}
		return of(ImageName.of(name), version);
	}
	/**
	 * Generate an image name with a random suffix.
	 * @param prefix the name prefix
	 * @return a random image reference
	 */
	public static ImageReference random(String prefix) {
		return ImageReference.random(prefix, 10);
	}
	/**
	 * Generate an image name with a random suffix.
	 * @param prefix the name prefix
	 * @param randomLength the number of chars in the random part of the name
	 * @return a random image reference
	 */
	public static ImageReference random(String prefix, int randomLength) {
		return of(RandomString.generate(prefix, randomLength));
	}
	/**
	 * Create a new {@link ImageReference} from the given value. The following value forms
	 * can be used:
	 * <ul>
	 * <li>{@code name} (maps to {@code docker.io/library/name})</li>
	 * <li>{@code domain/name}</li>
	 * <li>{@code domain:port/name}</li>
	 * <li>{@code domain:port/name:tag}</li>
	 * <li>{@code domain:port/name@digest}</li>
	 * </ul>
	 * @param value the value to parse
	 * @return an {@link ImageName} instance
	 */
	public static ImageReference of(String value) {
		Assert.hasText(value, 'Value must not be null');
		String domain = ImageName.parseDomain(value);
		String path = (domain != null) ? value.substring(domain.length() + 1) : value;
		String digest = null;
		int digestSplit = path.indexOf('@');
		if (digestSplit != -1) {
			String remainder = path.substring(digestSplit + 1);
			Matcher matcher = Regex.DIGEST.matcher(remainder);
			if (matcher.find()) {
				digest = remainder.substring(0, matcher.end());
				remainder = remainder.substring(matcher.end());
				path = path.substring(0, digestSplit) + remainder;
			}
		}
		String tag = null;
		int tagSplit = path.lastIndexOf(':');
		if (tagSplit != -1) {
			String remainder = path.substring(tagSplit + 1);
			Matcher matcher = Regex.TAG.matcher(remainder);
			if (matcher.find()) {
				tag = remainder.substring(0, matcher.end());
				remainder = remainder.substring(matcher.end());
				path = path.substring(0, tagSplit) + remainder;
			}
		}
		Assert.isTrue(isLowerCase(path) && matchesPathRegex(path),
				() -> 'Unable to parse image reference \'' + value + '\'. '
						+ 'Image reference must be in the form "[domainHost:port/][path/]name[:tag][@digest]", '
						+ 'with "path" and "name" containing only [a-z0-9][.][_][-]');
		ImageName name = new ImageName(domain, path);
		return new ImageReference(name, tag, digest);
	}
	private static boolean isLowerCase(String path) {
		return path.toLowerCase(Locale.ENGLISH).equals(path);
	}
	private static boolean matchesPathRegex(String path) {
		return Regex.PATH.matcher(path).matches();
	}
	/**
	 * Create a new {@link ImageReference} from the given {@link ImageName}.
	 * @param name the image name
	 * @return a new image reference
	 */
	public static ImageReference of(ImageName name) {
		return new ImageReference(name, null, null);
	}
	/**
	 * Create a new {@link ImageReference} from the given {@link ImageName} and tag.
	 * @param name the image name
	 * @param tag the referenced tag
	 * @return a new image reference
	 */
	public static ImageReference of(ImageName name, String tag) {
		return new ImageReference(name, tag, null);
	}
	/**
	 * Create a new {@link ImageReference} from the given {@link ImageName}, tag and
	 * digest.
	 * @param name the image name
	 * @param tag the referenced tag
	 * @param digest the referenced digest
	 * @return a new image reference
	 */
	public static ImageReference of(ImageName name, String tag, String digest) {
		return new ImageReference(name, tag, digest);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
final class Regex implements CharSequence {
	static final Pattern DOMAIN;
	static {
		Regex component = Regex.oneOf('[a-zA-Z0-9]', '[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]');
		Regex dotComponent = Regex.group('[.]', component);
		Regex colonPort = Regex.of('[:][0-9]+');
		Regex dottedDomain = Regex.group(component, dotComponent.oneOrMoreTimes());
		Regex dottedDomainAndPort = Regex.group(component, dotComponent.oneOrMoreTimes(), colonPort);
		Regex nameAndPort = Regex.group(component, colonPort);
		DOMAIN = Regex.oneOf(dottedDomain, nameAndPort, dottedDomainAndPort, 'localhost').compile();
	}
	private static final Regex PATH_COMPONENT;
	static {
		Regex segment = Regex.of('[a-z0-9]+');
		Regex separator = Regex.group('[._-]{1,2}');
		Regex separatedSegment = Regex.group(separator, segment).oneOrMoreTimes();
		PATH_COMPONENT = Regex.of(segment, Regex.group(separatedSegment).zeroOrOnce());
	}
	static final Pattern PATH;
	static {
		Regex component = PATH_COMPONENT;
		Regex slashComponent = Regex.group('[/]', component);
		Regex slashComponents = Regex.group(slashComponent.oneOrMoreTimes());
		PATH = Regex.of(component, slashComponents.zeroOrOnce()).compile();
	}
	static final Pattern TAG = Regex.of('^[\\w][\\w.-]{0,127}').compile();
	static final Pattern DIGEST = Regex.of('^[A-Za-z][A-Za-z0-9]*(?:[-_+.][A-Za-z][A-Za-z0-9]*)*[:][[A-Fa-f0-9]]{32,}')
		.compile();
	private final String value;
	private Regex(CharSequence value) {
		this.value = value.toString();
	}
	private Regex oneOrMoreTimes() {
		return new Regex(this.value + '+');
	}
	private Regex zeroOrOnce() {
		return new Regex(this.value + '?');
	}
	Pattern compile() {
		return Pattern.compile('^' + this.value + '$');
	}
	@Override
	public int length() {
		return this.value.length();
	}
	@Override
	public char charAt(int index) {
		return this.value.charAt(index);
	}
	@Override
	public CharSequence subSequence(int start, int end) {
		return this.value.subSequence(start, end);
	}
	@Override
	public String toString() {
		return this.value;
	}
	private static Regex of(CharSequence... expressions) {
		return new Regex(String.join('', expressions));
	}
	private static Regex oneOf(CharSequence... expressions) {
		return new Regex('(?:' + String.join('|', expressions) + ')');
	}
	private static Regex group(CharSequence... expressions) {
		return new Regex('(?:' + String.join('', expressions) + ')');
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class BlobReference extends MappedObject {
	private final String digest;
	private final String mediaType;
	BlobReference(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.digest = valueAt('/digest', String.class);
		this.mediaType = valueAt('/mediaType', String.class);
	}
	/**
	 * Return the digest of the blob.
	 * @return the blob digest
	 */
	public String getDigest() {
		return this.digest;
	}
	/**
	 * Return the media type of the blob.
	 * @return the blob media type
	 */
	public String getMediaType() {
		return this.mediaType;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ImageArchiveManifest extends MappedObject {
	private final List<ManifestEntry> entries;
	protected ImageArchiveManifest(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.entries = childrenAt(null, ManifestEntry::new);
	}
	/**
	 * Return the entries contained in the manifest.
	 * @return the manifest entries
	 */
	public List<ManifestEntry> getEntries() {
		return this.entries;
	}
	/**
	 * Create an {@link ImageArchiveManifest} from the provided JSON input stream.
	 * @param content the JSON input stream
	 * @return a new {@link ImageArchiveManifest} instance
	 * @throws IOException on IO error
	 */
	public static ImageArchiveManifest of(InputStream content) throws IOException {
		return of(content, ImageArchiveManifest::new);
	}
	public static class ManifestEntry extends MappedObject {
		private final List<String> layers;
		protected ManifestEntry(JsonNode node) {
			super(node, MethodHandles.lookup());
			this.layers = extractLayers();
		}
		/**
		 * Return the collection of layer IDs from a section of the manifest.
		 * @return a collection of layer IDs
		 */
		public List<String> getLayers() {
			return this.layers;
		}
		@SuppressWarnings('unchecked')
		private List<String> extractLayers() {
			List<String> layers = valueAt('/Layers', List.class);
			if (layers == null) {
				return Collections.emptyList();
			}
			return layers;
		}
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.docker.type;
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public class ManifestList extends MappedObject {
	private final Integer schemaVersion;
	private final String mediaType;
	private final List<BlobReference> manifests;
	protected ManifestList(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.schemaVersion = valueAt('/schemaVersion', Integer.class);
		this.mediaType = valueAt('/mediaType', String.class);
		this.manifests = childrenAt('/manifests', BlobReference::new);
	}
	public Integer getSchemaVersion() {
		return this.schemaVersion;
	}
	public String getMediaType() {
		return this.mediaType;
	}
	public Stream<BlobReference> streamManifests() {
		return getManifests().stream();
	}
	public List<BlobReference> getManifests() {
		return this.manifests;
	}
	/**
	 * Create an {@link ManifestList} from the provided JSON input stream.
	 * @param content the JSON input stream
	 * @return a new {@link ManifestList} instance
	 * @throws IOException on IO error
	 */
	public static ManifestList of(InputStream content) throws IOException {
		return of(content, ManifestList::new);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public final class Binding {
	/**
	 * Sensitive container paths, which lead to problems if used in a binding.
	 */
	private static final Set<String> SENSITIVE_CONTAINER_PATHS = Set.of('/cnb', '/layers', '/workspace', 'c:\\cnb',
			'c:\\layers', 'c:\\workspace');
	private final String value;
	private Binding(String value) {
		this.value = value;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof Binding binding)) {
			return false;
		}
		return Objects.equals(this.value, binding.value);
	}
	@Override
	public int hashCode() {
		return Objects.hash(this.value);
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Whether the binding uses a sensitive container path.
	 * @return whether the binding uses a sensitive container path
	 * @since 3.4.0
	 */
	public boolean usesSensitiveContainerPath() {
		return SENSITIVE_CONTAINER_PATHS.contains(getContainerDestinationPath());
	}
	/**
	 * Returns the container destination path.
	 * @return the container destination path
	 */
	String getContainerDestinationPath() {
		List<String> parts = getParts();
		Assert.state(parts.size() >= 2, () -> 'Expected 2 or more parts, but found %d'.formatted(parts.size()));
		return parts.get(1);
	}
	private List<String> getParts() {
		// Format is <host>:<container>:[<options>]
		List<String> parts = new ArrayList<>();
		StringBuilder buffer = new StringBuilder();
		for (int i = 0; i < this.value.length(); i++) {
			char ch = this.value.charAt(i);
			char nextChar = (i + 1 < this.value.length()) ? this.value.charAt(i + 1) : "\0";
			if (ch == ":" && nextChar != "\\") {
				parts.add(buffer.toString());
				buffer.setLength(0);
			}
			else {
				buffer.append(ch);
			}
		}
		parts.add(buffer.toString());
		return parts;
	}
	/**
	 * Create a {@link Binding} with the specified value containing a host source,
	 * container destination, and options.
	 * @param value the volume binding value
	 * @return a new {@link Binding} instance
	 */
	public static Binding of(String value) {
		Assert.notNull(value, 'Value must not be null');
		return new Binding(value);
	}
	/**
	 * Create a {@link Binding} from the specified source and destination.
	 * @param sourceVolume the volume binding host source
	 * @param destination the volume binding container destination
	 * @return a new {@link Binding} instance
	 */
	public static Binding from(VolumeName sourceVolume, String destination) {
		Assert.notNull(sourceVolume, 'SourceVolume must not be null');
		return from(sourceVolume.toString(), destination);
	}
	/**
	 * Create a {@link Binding} from the specified source and destination.
	 * @param source the volume binding host source
	 * @param destination the volume binding container destination
	 * @return a new {@link Binding} instance
	 */
	public static Binding from(String source, String destination) {
		Assert.notNull(source, 'Source must not be null');
		Assert.notNull(destination, 'Destination must not be null');
		return new Binding(source + ':' + destination);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public final class VolumeName {
	private final String value;
	private VolumeName(String value) {
		this.value = value;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.value.equals(((VolumeName) obj).value);
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Factory method to create a new {@link VolumeName} with a random name.
	 * @param prefix the prefix to use with the random name
	 * @return a randomly named volume
	 */
	public static VolumeName random(String prefix) {
		return random(prefix, 10);
	}
	/**
	 * Factory method to create a new {@link VolumeName} with a random name.
	 * @param prefix the prefix to use with the random name
	 * @param randomLength the number of chars in the random part of the name
	 * @return a randomly named volume reference
	 */
	public static VolumeName random(String prefix, int randomLength) {
		return of(RandomString.generate(prefix, randomLength));
	}
	/**
	 * Factory method to create a new {@link VolumeName} based on an object. The resulting
	 * name will be based off a SHA-256 digest of the given object"s {@code toString()}
	 * method.
	 * @param <S> the source object type
	 * @param source the source object
	 * @param prefix the prefix to use with the volume name
	 * @param suffix the suffix to use with the volume name
	 * @param digestLength the number of chars in the digest part of the name
	 * @return a name based off the image reference
	 */
	public static <S> VolumeName basedOn(S source, String prefix, String suffix, int digestLength) {
		return basedOn(source, Object::toString, prefix, suffix, digestLength);
	}
	/**
	 * Factory method to create a new {@link VolumeName} based on an object. The resulting
	 * name will be based off a SHA-256 digest of the given object"s name.
	 * @param <S> the source object type
	 * @param source the source object
	 * @param nameExtractor a method to extract the name of the object
	 * @param prefix the prefix to use with the volume name
	 * @param suffix the suffix to use with the volume name
	 * @param digestLength the number of chars in the digest part of the name
	 * @return a name based off the image reference
	 */
	public static <S> VolumeName basedOn(S source, Function<S, String> nameExtractor, String prefix, String suffix,
			int digestLength) {
		Assert.notNull(source, 'Source must not be null');
		Assert.notNull(nameExtractor, 'NameExtractor must not be null');
		Assert.notNull(prefix, 'Prefix must not be null');
		Assert.notNull(suffix, 'Suffix must not be null');
		return of(prefix + getDigest(nameExtractor.apply(source), digestLength) + suffix);
	}
	private static String getDigest(String name, int length) {
		try {
			MessageDigest digest = MessageDigest.getInstance('sha-256');
			return asHexString(digest.digest(name.getBytes(StandardCharsets.UTF_8)), length);
		}
		catch (NoSuchAlgorithmException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private static String asHexString(byte[] digest, int digestLength) {
		Assert.isTrue(digestLength <= digest.length,
				() -> 'DigestLength must be less than or equal to ' + digest.length);
		return HexFormat.of().formatHex(digest, 0, digestLength);
	}
	/**
	 * Factory method to create a {@link VolumeName} with a specific value.
	 * @param value the volume reference value
	 * @return a new {@link VolumeName} instance
	 */
	public static VolumeName of(String value) {
		Assert.notNull(value, 'Value must not be null');
		return new VolumeName(value);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker.type;
/**
public interface ContainerContent {
	/**
	 * Return the actual content to be added.
	 * @return the content
	 */
	TarArchive getArchive();
	/**
	 * Return the destination path where the content should be added.
	 * @return the destination path
	 */
	String getDestinationPath();
	/**
	 * Factory method to create a new {@link ContainerContent} instance written to the
	 * root of the container.
	 * @param archive the archive to add
	 * @return a new {@link ContainerContent} instance
	 */
	static ContainerContent of(TarArchive archive) {
		return of(archive, '/');
	}
	/**
	 * Factory method to create a new {@link ContainerContent} instance.
	 * @param archive the archive to add
	 * @param destinationPath the destination path within the container
	 * @return a new {@link ContainerContent} instance
	 */
	static ContainerContent of(TarArchive archive, String destinationPath) {
		Assert.notNull(archive, 'Archive must not be null');
		Assert.hasText(destinationPath, 'DestinationPath must not be empty');
		return new ContainerContent() {
			@Override
			public TarArchive getArchive() {
				return archive;
			}
			@Override
			public String getDestinationPath() {
				return destinationPath;
			}
		};
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public abstract class ProgressUpdateEvent extends UpdateEvent {
	private final String status;
	private final ProgressDetail progressDetail;
	private final String progress;
	protected ProgressUpdateEvent(String status, ProgressDetail progressDetail, String progress) {
		this.status = status;
		this.progressDetail = (ProgressDetail.isEmpty(progressDetail)) ? null : progressDetail;
		this.progress = progress;
	}
	/**
	 * Return the status for the update. For example, 'Extracting' or 'Downloading'.
	 * @return the status of the update.
	 */
	public String getStatus() {
		return this.status;
	}
	/**
	 * Return progress details if available.
	 * @return progress details or {@code null}
	 */
	public ProgressDetail getProgressDetail() {
		return this.progressDetail;
	}
	/**
	 * Return a text based progress bar if progress information is available.
	 * @return the progress bar or {@code null}
	 */
	public String getProgress() {
		return this.progress;
	}
	/**
	 * Provide details about the progress of a task.
	 */
	public static class ProgressDetail {
		private final Integer current;
		private final Integer total;
		@JsonCreator
		public ProgressDetail(Integer current, Integer total) {
			this.current = current;
			this.total = total;
		}
		/**
		 * Return the current progress value.
		 * @return the current progress
		 */
		public int getCurrent() {
			return this.current;
		}
		/**
		 * Return the total progress possible value.
		 * @return the total progress possible
		 */
		public int getTotal() {
			return this.total;
		}
		public static boolean isEmpty(ProgressDetail progressDetail) {
			return progressDetail == null || progressDetail.current == null || progressDetail.total == null;
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class LogUpdateEvent extends UpdateEvent {
	private static final Pattern ANSI_PATTERN = Pattern.compile('\u001B\\[[;\\d]*m');
	private static final Pattern TRAILING_NEW_LINE_PATTERN = Pattern.compile('\\n$');
	private final StreamType streamType;
	private final byte[] payload;
	private final String string;
	LogUpdateEvent(StreamType streamType, byte[] payload) {
		this.streamType = streamType;
		this.payload = payload;
		String string = new String(payload, StandardCharsets.UTF_8);
		string = ANSI_PATTERN.matcher(string).replaceAll('');
		string = TRAILING_NEW_LINE_PATTERN.matcher(string).replaceAll('');
		this.string = string;
	}
	public void print() {
		switch (this.streamType) {
			case STD_OUT -> System.out.println(this);
			case STD_ERR -> System.err.println(this);
		}
	}
	public StreamType getStreamType() {
		return this.streamType;
	}
	public byte[] getPayload() {
		return this.payload;
	}
	@Override
	public String toString() {
		return this.string;
	}
	static void readAll(InputStream inputStream, Consumer<LogUpdateEvent> consumer) throws IOException {
		try {
			LogUpdateEvent event;
			while ((event = LogUpdateEvent.read(inputStream)) != null) {
				consumer.accept(event);
			}
		}
		catch (IllegalStateException ex) {
			byte[] message = ex.getMessage().getBytes(StandardCharsets.UTF_8);
			consumer.accept(new LogUpdateEvent(StreamType.STD_ERR, message));
			StreamUtils.drain(inputStream);
		}
		finally {
			inputStream.close();
		}
	}
	private static LogUpdateEvent read(InputStream inputStream) throws IOException {
		byte[] header = read(inputStream, 8);
		if (header == null) {
			return null;
		}
		StreamType streamType = StreamType.forId(header[0]);
		long size = 0;
		for (int i = 0; i < 4; i++) {
			size = (size << 8) + (header[i + 4] & 0xff);
		}
		byte[] payload = read(inputStream, size);
		return new LogUpdateEvent(streamType, payload);
	}
	private static byte[] read(InputStream inputStream, long size) throws IOException {
		byte[] data = new byte[(int) size];
		int offset = 0;
		do {
			int amountRead = inputStream.read(data, offset, data.length - offset);
			if (amountRead == -1) {
				return null;
			}
			offset += amountRead;
		}
		while (offset < data.length);
		return data;
	}
	/**
	 * Stream types supported by the event.
	 */
	public enum StreamType {
		/**
		 * Input from {@code stdin}.
		 */
		STD_IN,
		/**
		 * Output to {@code stdout}.
		 */
		STD_OUT,
		/**
		 * Output to {@code stderr}.
		 */
		STD_ERR;
		static StreamType forId(byte id) {
			int upperBound = values().length;
			Assert.state(id > 0 && id < upperBound,
					() -> 'Stream type is out of bounds. Must be >= 0 and < ' + upperBound + ', but was ' + id);
			return values()[id];
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
@FunctionalInterface
public interface UpdateListener<E extends UpdateEvent> {
	/**
	 * A no-op update listener.
	 * @see #none()
	 */
	UpdateListener<UpdateEvent> NONE = (event) -> {
	};
	/**
	 * Called when the operation starts.
	 */
	default void onStart() {
	}
	/**
	 * Called when an update event is available.
	 * @param event the update event
	 */
	void onUpdate(E event);
	/**
	 * Called when the operation finishes (with or without error).
	 */
	default void onFinish() {
	}
	/**
	 * A no-op update listener that does nothing.
	 * @param <E> the event type
	 * @return a no-op update listener
	 */
	@SuppressWarnings('unchecked')
	static <E extends UpdateEvent> UpdateListener<E> none() {
		return (UpdateListener<E>) NONE;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
class ExportedImageTar implements Closeable {
	private final Path tarFile;
	private final LayerArchiveFactory layerArchiveFactory;
	ExportedImageTar(ImageReference reference, InputStream inputStream) throws IOException {
		this.tarFile = Files.createTempFile('docker-layers-', null);
		Files.copy(inputStream, this.tarFile, StandardCopyOption.REPLACE_EXISTING);
		this.layerArchiveFactory = LayerArchiveFactory.create(reference, this.tarFile);
	}
	void exportLayers(IOBiConsumer<String, TarArchive> exports) throws IOException {
		try (TarArchiveInputStream tar = openTar(this.tarFile)) {
			TarArchiveEntry entry = tar.getNextEntry();
			while (entry != null) {
				TarArchive layerArchive = this.layerArchiveFactory.getLayerArchive(tar, entry);
				if (layerArchive != null) {
					exports.accept(entry.getName(), layerArchive);
				}
				entry = tar.getNextEntry();
			}
		}
	}
	private static TarArchiveInputStream openTar(Path path) throws IOException {
		return new TarArchiveInputStream(Files.newInputStream(path));
	}
	@Override
	public void close() throws IOException {
		Files.delete(this.tarFile);
	}
	/**
	 * Factory class used to create a {@link TarArchiveEntry} for layer.
	 */
	private abstract static class LayerArchiveFactory {
		/**
		 * Create a new {@link TarArchive} if the given entry represents a layer.
		 * @param tar the tar input stream
		 * @param entry the candidate entry
		 * @return a new {@link TarArchive} instance or {@code null} if this entry is not
		 * a layer.
		 */
		abstract TarArchive getLayerArchive(TarArchiveInputStream tar, TarArchiveEntry entry);
		/**
		 * Create a new {@link LayerArchiveFactory} for the given tar file using either
		 * the {@code index.json} or {@code manifest.json} to detect layers.
		 * @param reference the image that was referenced
		 * @param tarFile the source tar file
		 * @return a new {@link LayerArchiveFactory} instance
		 * @throws IOException on IO error
		 */
		static LayerArchiveFactory create(ImageReference reference, Path tarFile) throws IOException {
			try (TarArchiveInputStream tar = openTar(tarFile)) {
				ImageArchiveIndex index = null;
				ImageArchiveManifest manifest = null;
				TarArchiveEntry entry = tar.getNextEntry();
				while (entry != null) {
					if ('index.json'.equals(entry.getName())) {
						index = ImageArchiveIndex.of(tar);
						break;
					}
					if ('manifest.json'.equals(entry.getName())) {
						manifest = ImageArchiveManifest.of(tar);
					}
					entry = tar.getNextEntry();
				}
				Assert.state(index != null || manifest != null,
						'Exported image "%s" does not contain "index.json" or "manifest.json"'.formatted(reference));
				return (index != null) ? new IndexLayerArchiveFactory(tarFile, index)
						: new ManifestLayerArchiveFactory(tarFile, manifest);
			}
		}
	}
	/**
	 * {@link LayerArchiveFactory} backed by the more recent {@code index.json} file.
	 */
	private static class IndexLayerArchiveFactory extends LayerArchiveFactory {
		private final Map<String, String> layerMediaTypes;
		IndexLayerArchiveFactory(Path tarFile, ImageArchiveIndex index) throws IOException {
			Set<String> manifestDigests = getDigests(index, this::isManifest);
			List<ManifestList> manifestLists = getManifestLists(tarFile, getDigests(index, this::isManifestList));
			List<Manifest> manifests = getManifests(tarFile, manifestDigests, manifestLists);
			this.layerMediaTypes = manifests.stream()
				.flatMap((manifest) -> manifest.getLayers().stream())
				.collect(Collectors.toMap(this::getEntryName, BlobReference::getMediaType));
		}
		private Set<String> getDigests(ImageArchiveIndex index, Predicate<BlobReference> predicate) {
			return index.getManifests()
				.stream()
				.filter(predicate)
				.map(BlobReference::getDigest)
				.collect(Collectors.toUnmodifiableSet());
		}
		private List<ManifestList> getManifestLists(Path tarFile, Set<String> digests) throws IOException {
			return getDigestMatches(tarFile, digests, ManifestList::of);
		}
		private List<Manifest> getManifests(Path tarFile, Set<String> manifestDigests, List<ManifestList> manifestLists)
				throws IOException {
			Set<String> digests = new HashSet<>(manifestDigests);
			manifestLists.stream()
				.flatMap(ManifestList::streamManifests)
				.filter(this::isManifest)
				.map(BlobReference::getDigest)
				.forEach(digests::add);
			return getDigestMatches(tarFile, digests, Manifest::of);
		}
		private <T> List<T> getDigestMatches(Path tarFile, Set<String> digests,
				ThrowingFunction<InputStream, T> factory) throws IOException {
			if (digests.isEmpty()) {
				return Collections.emptyList();
			}
			Set<String> names = digests.stream().map(this::getEntryName).collect(Collectors.toUnmodifiableSet());
			List<T> result = new ArrayList<>();
			try (TarArchiveInputStream tar = openTar(tarFile)) {
				TarArchiveEntry entry = tar.getNextEntry();
				while (entry != null) {
					if (names.contains(entry.getName())) {
						result.add(factory.apply(tar));
					}
					entry = tar.getNextEntry();
				}
			}
			return Collections.unmodifiableList(result);
		}
		private boolean isManifest(BlobReference reference) {
			return isJsonWithPrefix(reference.getMediaType(), 'application/vnd.oci.image.manifest.v')
					|| isJsonWithPrefix(reference.getMediaType(), 'application/vnd.docker.distribution.manifest.v');
		}
		private boolean isManifestList(BlobReference reference) {
			return isJsonWithPrefix(reference.getMediaType(), 'application/vnd.docker.distribution.manifest.list.v');
		}
		private boolean isJsonWithPrefix(String mediaType, String prefix) {
			return mediaType.startsWith(prefix) && mediaType.endsWith('+json');
		}
		private String getEntryName(BlobReference reference) {
			return getEntryName(reference.getDigest());
		}
		private String getEntryName(String digest) {
			return 'blobs/' + digest.replace(":", "/");
		}
		@Override
		TarArchive getLayerArchive(TarArchiveInputStream tar, TarArchiveEntry entry) {
			String mediaType = this.layerMediaTypes.get(entry.getName());
			if (mediaType == null) {
				return null;
			}
			return TarArchive.fromInputStream(tar, getCompression(mediaType));
		}
		private Compression getCompression(String mediaType) {
			if (mediaType.endsWith('.tar.gzip')) {
				return Compression.GZIP;
			}
			if (mediaType.endsWith('.tar.zstd')) {
				return Compression.ZSTD;
			}
			return Compression.NONE;
		}
	}
	/**
	 * {@link LayerArchiveFactory} backed by the legacy {@code manifest.json} file.
	 */
	private static class ManifestLayerArchiveFactory extends LayerArchiveFactory {
		private Set<String> layers;
		ManifestLayerArchiveFactory(Path tarFile, ImageArchiveManifest manifest) {
			this.layers = manifest.getEntries()
				.stream()
				.flatMap((entry) -> entry.getLayers().stream())
				.collect(Collectors.toUnmodifiableSet());
		}
		@Override
		TarArchive getLayerArchive(TarArchiveInputStream tar, TarArchiveEntry entry) {
			if (!this.layers.contains(entry.getName())) {
				return null;
			}
			return TarArchive.fromInputStream(tar, Compression.NONE);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public abstract class TotalProgressListener<E extends ImageProgressUpdateEvent> implements UpdateListener<E> {
	private final Map<String, Layer> layers = new ConcurrentHashMap<>();
	private final Consumer<TotalProgressEvent> consumer;
	private final String[] trackedStatusKeys;
	private boolean progressStarted;
	/**
	 * Create a new {@link TotalProgressListener} that sends {@link TotalProgressEvent
	 * events} to the given consumer.
	 * @param consumer the consumer that receives {@link TotalProgressEvent progress
	 * events}
	 * @param trackedStatusKeys a list of status event keys to track the progress of
	 */
	protected TotalProgressListener(Consumer<TotalProgressEvent> consumer, String[] trackedStatusKeys) {
		this.consumer = consumer;
		this.trackedStatusKeys = trackedStatusKeys;
	}
	@Override
	public void onStart() {
	}
	@Override
	public void onUpdate(E event) {
		if (event.getId() != null) {
			this.layers.computeIfAbsent(event.getId(), (value) -> new Layer(this.trackedStatusKeys)).update(event);
		}
		this.progressStarted = this.progressStarted || event.getProgress() != null;
		if (this.progressStarted) {
			publish(0);
		}
	}
	@Override
	public void onFinish() {
		this.layers.values().forEach(Layer::finish);
		publish(100);
	}
	private void publish(int fallback) {
		int count = 0;
		int total = 0;
		for (Layer layer : this.layers.values()) {
			count++;
			total += layer.getProgress();
		}
		TotalProgressEvent event = new TotalProgressEvent(
				(count != 0) ? withinPercentageBounds(total / count) : fallback);
		this.consumer.accept(event);
	}
	private static int withinPercentageBounds(int value) {
		if (value < 0) {
			return 0;
		}
		return Math.min(value, 100);
	}
	/**
	 * Progress for an individual layer.
	 */
	private static class Layer {
		private final Map<String, Integer> progressByStatus = new HashMap<>();
		Layer(String[] trackedStatusKeys) {
			Arrays.stream(trackedStatusKeys).forEach((status) -> this.progressByStatus.put(status, 0));
		}
		void update(ImageProgressUpdateEvent event) {
			String status = event.getStatus();
			if (event.getProgressDetail() != null && this.progressByStatus.containsKey(status)) {
				int current = this.progressByStatus.get(status);
				this.progressByStatus.put(status, updateProgress(current, event.getProgressDetail()));
			}
		}
		private int updateProgress(int current, ProgressDetail detail) {
			int result = withinPercentageBounds((int) ((100.0 / detail.getTotal()) * detail.getCurrent()));
			return Math.max(result, current);
		}
		void finish() {
			this.progressByStatus.keySet().forEach((key) -> this.progressByStatus.put(key, 100));
		}
		int getProgress() {
			return withinPercentageBounds((this.progressByStatus.values().stream().mapToInt(Integer::valueOf).sum())
					/ this.progressByStatus.size());
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class DockerApi {
	private static final List<String> FORCE_PARAMS = Collections.unmodifiableList(Arrays.asList('force', '1'));
	static final ApiVersion MINIMUM_API_VERSION = ApiVersion.of(1, 24);
	static final ApiVersion MINIMUM_PLATFORM_API_VERSION = ApiVersion.of(1, 41);
	static final String API_VERSION_HEADER_NAME = 'API-Version';
	private final HttpTransport http;
	private final JsonStream jsonStream;
	private final ImageApi image;
	private final ContainerApi container;
	private final VolumeApi volume;
	private final SystemApi system;
	private volatile ApiVersion apiVersion = null;
	/**
	 * Create a new {@link DockerApi} instance.
	 */
	public DockerApi() {
		this(HttpTransport.create(null));
	}
	/**
	 * Create a new {@link DockerApi} instance.
	 * @param dockerHost the Docker daemon host information
	 * @since 2.4.0
	 */
	public DockerApi(DockerHostConfiguration dockerHost) {
		this(HttpTransport.create(dockerHost));
	}
	/**
	 * Create a new {@link DockerApi} instance backed by a specific {@link HttpTransport}
	 * implementation.
	 * @param http the http implementation
	 */
	DockerApi(HttpTransport http) {
		this.http = http;
		this.jsonStream = new JsonStream(SharedObjectMapper.get());
		this.image = new ImageApi();
		this.container = new ContainerApi();
		this.volume = new VolumeApi();
		this.system = new SystemApi();
	}
	private HttpTransport http() {
		return this.http;
	}
	private JsonStream jsonStream() {
		return this.jsonStream;
	}
	private URI buildUrl(String path, Collection<?> params) {
		return buildUrl(path, (params != null) ? params.toArray() : null);
	}
	private URI buildUrl(String path, Object... params) {
		try {
			URIBuilder builder = new URIBuilder('/v' + getApiVersion() + path);
			int param = 0;
			while (param < params.length) {
				builder.addParameter(Objects.toString(params[param++]), Objects.toString(params[param++]));
			}
			return builder.build();
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private void verifyApiVersionForPlatform(ImagePlatform platform) {
		Assert.isTrue(platform == null || getApiVersion().supports(MINIMUM_PLATFORM_API_VERSION),
				() -> 'Docker API version must be at least ' + MINIMUM_PLATFORM_API_VERSION
						+ ' to support the "imagePlatform" option, but current API version is ' + getApiVersion());
	}
	private ApiVersion getApiVersion() {
		ApiVersion apiVersion = this.apiVersion;
		if (this.apiVersion == null) {
			apiVersion = this.system.getApiVersion();
			this.apiVersion = apiVersion;
		}
		return apiVersion;
	}
	/**
	 * Return the Docker API for image operations.
	 * @return the image API
	 */
	public ImageApi image() {
		return this.image;
	}
	/**
	 * Return the Docker API for container operations.
	 * @return the container API
	 */
	public ContainerApi container() {
		return this.container;
	}
	public VolumeApi volume() {
		return this.volume;
	}
	SystemApi system() {
		return this.system;
	}
	/**
	 * Docker API for image operations.
	 */
	public class ImageApi {
		ImageApi() {
		}
		/**
		 * Pull an image from a registry.
		 * @param reference the image reference to pull
		 * @param platform the platform (os/architecture/variant) of the image to pull
		 * @param listener a pull listener to receive update events
		 * @return the {@link ImageApi pulled image} instance
		 * @throws IOException on IO error
		 */
		public Image pull(ImageReference reference, ImagePlatform platform,
				UpdateListener<PullImageUpdateEvent> listener) throws IOException {
			return pull(reference, platform, listener, null);
		}
		/**
		 * Pull an image from a registry.
		 * @param reference the image reference to pull
		 * @param platform the platform (os/architecture/variant) of the image to pull
		 * @param listener a pull listener to receive update events
		 * @param registryAuth registry authentication credentials
		 * @return the {@link ImageApi pulled image} instance
		 * @throws IOException on IO error
		 */
		public Image pull(ImageReference reference, ImagePlatform platform,
				UpdateListener<PullImageUpdateEvent> listener, String registryAuth) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			Assert.notNull(listener, 'Listener must not be null');
			verifyApiVersionForPlatform(platform);
			URI createUri = (platform != null)
					? buildUrl('/images/create', 'fromImage', reference, 'platform', platform)
					: buildUrl('/images/create', 'fromImage', reference);
			DigestCaptureUpdateListener digestCapture = new DigestCaptureUpdateListener();
			listener.onStart();
			try {
				try (Response response = http().post(createUri, registryAuth)) {
					jsonStream().get(response.getContent(), PullImageUpdateEvent.class, (event) -> {
						digestCapture.onUpdate(event);
						listener.onUpdate(event);
					});
				}
				return inspect(reference);
			}
			finally {
				listener.onFinish();
			}
		}
		/**
		 * Push an image to a registry.
		 * @param reference the image reference to push
		 * @param listener a push listener to receive update events
		 * @param registryAuth registry authentication credentials
		 * @throws IOException on IO error
		 */
		public void push(ImageReference reference, UpdateListener<PushImageUpdateEvent> listener, String registryAuth)
				throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			Assert.notNull(listener, 'Listener must not be null');
			URI pushUri = buildUrl('/images/' + reference + '/push');
			ErrorCaptureUpdateListener errorListener = new ErrorCaptureUpdateListener();
			listener.onStart();
			try {
				try (Response response = http().post(pushUri, registryAuth)) {
					jsonStream().get(response.getContent(), PushImageUpdateEvent.class, (event) -> {
						errorListener.onUpdate(event);
						listener.onUpdate(event);
					});
				}
			}
			finally {
				listener.onFinish();
			}
		}
		/**
		 * Load an {@link ImageArchive} into Docker.
		 * @param archive the archive to load
		 * @param listener a pull listener to receive update events
		 * @throws IOException on IO error
		 */
		public void load(ImageArchive archive, UpdateListener<LoadImageUpdateEvent> listener) throws IOException {
			Assert.notNull(archive, 'Archive must not be null');
			Assert.notNull(listener, 'Listener must not be null');
			URI loadUri = buildUrl('/images/load');
			StreamCaptureUpdateListener streamListener = new StreamCaptureUpdateListener();
			listener.onStart();
			try {
				try (Response response = http().post(loadUri, 'application/x-tar', archive::writeTo)) {
					jsonStream().get(response.getContent(), LoadImageUpdateEvent.class, (event) -> {
						streamListener.onUpdate(event);
						listener.onUpdate(event);
					});
				}
				Assert.state(StringUtils.hasText(streamListener.getCapturedStream()),
						'Invalid response received when loading image '
								+ ((archive.getTag() != null) ? '\'' + archive.getTag() + '\'' : ''));
			}
			finally {
				listener.onFinish();
			}
		}
		/**
		 * Export the layers of an image as paths to layer tar files.
		 * @param reference the reference to export
		 * @param exports a consumer to receive the layer tar file paths (file can only be
		 * accessed during the callback)
		 * @throws IOException on IO error
		 * @since 2.7.10
		 * @deprecated since 3.2.6 for removal in 3.5.0 in favor of
		 * {@link #exportLayers(ImageReference, IOBiConsumer)}
		 */
		@Deprecated(since = '3.2.6', forRemoval = true)
		public void exportLayerFiles(ImageReference reference, IOBiConsumer<String, Path> exports) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			Assert.notNull(exports, 'Exports must not be null');
			exportLayers(reference, (name, archive) -> {
				Path path = Files.createTempFile('docker-export-layer-files-', null);
				try {
					try (OutputStream out = Files.newOutputStream(path)) {
						archive.writeTo(out);
						exports.accept(name, path);
					}
				}
				finally {
					Files.delete(path);
				}
			});
		}
		/**
		 * Export the layers of an image as {@link TarArchive TarArchives}.
		 * @param reference the reference to export
		 * @param exports a consumer to receive the layers (contents can only be accessed
		 * during the callback)
		 * @throws IOException on IO error
		 */
		public void exportLayers(ImageReference reference, IOBiConsumer<String, TarArchive> exports)
				throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			Assert.notNull(exports, 'Exports must not be null');
			URI uri = buildUrl('/images/' + reference + '/get');
			try (Response response = http().get(uri)) {
				try (ExportedImageTar exportedImageTar = new ExportedImageTar(reference, response.getContent())) {
					exportedImageTar.exportLayers(exports);
				}
			}
		}
		/**
		 * Remove a specific image.
		 * @param reference the reference the remove
		 * @param force if removal should be forced
		 * @throws IOException on IO error
		 */
		public void remove(ImageReference reference, boolean force) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			Collection<String> params = force ? FORCE_PARAMS : Collections.emptySet();
			URI uri = buildUrl('/images/' + reference, params);
			http().delete(uri).close();
		}
		/**
		 * Inspect an image.
		 * @param reference the image reference
		 * @return the image from the local repository
		 * @throws IOException on IO error
		 */
		public Image inspect(ImageReference reference) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			URI imageUri = buildUrl('/images/' + reference + '/json');
			try (Response response = http().get(imageUri)) {
				return Image.of(response.getContent());
			}
		}
		public void tag(ImageReference sourceReference, ImageReference targetReference) throws IOException {
			Assert.notNull(sourceReference, 'SourceReference must not be null');
			Assert.notNull(targetReference, 'TargetReference must not be null');
			String tag = targetReference.getTag();
			String path = '/images/' + sourceReference + '/tag';
			URI uri = (tag != null) ? buildUrl(path, 'repo', targetReference.inTaglessForm(), 'tag', tag)
					: buildUrl(path, 'repo', targetReference);
			http().post(uri).close();
		}
	}
	/**
	 * Docker API for container operations.
	 */
	public class ContainerApi {
		ContainerApi() {
		}
		/**
		 * Create a new container a {@link ContainerConfig}.
		 * @param config the container config
		 * @param platform the platform (os/architecture/variant) of the image the
		 * container should be created from
		 * @param contents additional contents to include
		 * @return a {@link ContainerReference} for the newly created container
		 * @throws IOException on IO error
		 */
		public ContainerReference create(ContainerConfig config, ImagePlatform platform, ContainerContent... contents)
				throws IOException {
			Assert.notNull(config, 'Config must not be null');
			Assert.noNullElements(contents, 'Contents must not contain null elements');
			ContainerReference containerReference = createContainer(config, platform);
			for (ContainerContent content : contents) {
				uploadContainerContent(containerReference, content);
			}
			return containerReference;
		}
		private ContainerReference createContainer(ContainerConfig config, ImagePlatform platform) throws IOException {
			verifyApiVersionForPlatform(platform);
			URI createUri = (platform != null) ? buildUrl('/containers/create', 'platform', platform)
					: buildUrl('/containers/create');
			try (Response response = http().post(createUri, 'application/json', config::writeTo)) {
				return ContainerReference
					.of(SharedObjectMapper.get().readTree(response.getContent()).at('/Id').asText());
			}
		}
		private void uploadContainerContent(ContainerReference reference, ContainerContent content) throws IOException {
			URI uri = buildUrl('/containers/' + reference + '/archive', 'path', content.getDestinationPath());
			http().put(uri, 'application/x-tar', content.getArchive()::writeTo).close();
		}
		/**
		 * Start a specific container.
		 * @param reference the container reference to start
		 * @throws IOException on IO error
		 */
		public void start(ContainerReference reference) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			URI uri = buildUrl('/containers/' + reference + '/start');
			http().post(uri).close();
		}
		/**
		 * Return and follow logs for a specific container.
		 * @param reference the container reference
		 * @param listener a listener to receive log update events
		 * @throws IOException on IO error
		 */
		public void logs(ContainerReference reference, UpdateListener<LogUpdateEvent> listener) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			Assert.notNull(listener, 'Listener must not be null');
			Object[] params = { 'stdout', '1', 'stderr', '1', 'follow', '1' };
			URI uri = buildUrl('/containers/' + reference + '/logs', params);
			listener.onStart();
			try {
				try (Response response = http().get(uri)) {
					LogUpdateEvent.readAll(response.getContent(), listener::onUpdate);
				}
			}
			finally {
				listener.onFinish();
			}
		}
		/**
		 * Wait for a container to stop and retrieve the status.
		 * @param reference the container reference
		 * @return a {@link ContainerStatus} indicating the exit status of the container
		 * @throws IOException on IO error
		 */
		public ContainerStatus wait(ContainerReference reference) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			URI uri = buildUrl('/containers/' + reference + '/wait');
			try (Response response = http().post(uri)) {
				return ContainerStatus.of(response.getContent());
			}
		}
		/**
		 * Remove a specific container.
		 * @param reference the container to remove
		 * @param force if removal should be forced
		 * @throws IOException on IO error
		 */
		public void remove(ContainerReference reference, boolean force) throws IOException {
			Assert.notNull(reference, 'Reference must not be null');
			Collection<String> params = force ? FORCE_PARAMS : Collections.emptySet();
			URI uri = buildUrl('/containers/' + reference, params);
			http().delete(uri).close();
		}
	}
	/**
	 * Docker API for volume operations.
	 */
	public class VolumeApi {
		VolumeApi() {
		}
		/**
		 * Delete a volume.
		 * @param name the name of the volume to delete
		 * @param force if the deletion should be forced
		 * @throws IOException on IO error
		 */
		public void delete(VolumeName name, boolean force) throws IOException {
			Assert.notNull(name, 'Name must not be null');
			Collection<String> params = force ? FORCE_PARAMS : Collections.emptySet();
			URI uri = buildUrl('/volumes/' + name, params);
			http().delete(uri).close();
		}
	}
	/**
	 * Docker API for system operations.
	 */
	class SystemApi {
		SystemApi() {
		}
		/**
		 * Get the API version supported by the Docker daemon.
		 * @return the Docker daemon API version
		 */
		ApiVersion getApiVersion() {
			try {
				URI uri = new URIBuilder('/_ping').build();
				try (Response response = http().head(uri)) {
					Header apiVersionHeader = response.getHeader(API_VERSION_HEADER_NAME);
					if (apiVersionHeader != null) {
						return ApiVersion.parse(apiVersionHeader.getValue());
					}
				}
				catch (Exception ex) {
					// fall through to return default value
				}
				return MINIMUM_API_VERSION;
			}
			catch (URISyntaxException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
	/**
	 * {@link UpdateListener} used to capture the image digest.
	 */
	private static final class DigestCaptureUpdateListener implements UpdateListener<ProgressUpdateEvent> {
		private static final String PREFIX = 'Digest:';
		private String digest;
		@Override
		public void onUpdate(ProgressUpdateEvent event) {
			String status = event.getStatus();
			if (status != null && status.startsWith(PREFIX)) {
				String digest = status.substring(PREFIX.length()).trim();
				Assert.state(this.digest == null || this.digest.equals(digest), 'Different digests IDs provided');
				this.digest = digest;
			}
		}
	}
	/**
	 * {@link UpdateListener} used to ensure an image load response stream.
	 */
	private static final class StreamCaptureUpdateListener implements UpdateListener<LoadImageUpdateEvent> {
		private String stream;
		@Override
		public void onUpdate(LoadImageUpdateEvent event) {
			this.stream = event.getStream();
		}
		String getCapturedStream() {
			return this.stream;
		}
	}
	/**
	 * {@link UpdateListener} used to capture the details of an error in a response
	 * stream.
	 */
	private static final class ErrorCaptureUpdateListener implements UpdateListener<PushImageUpdateEvent> {
		@Override
		public void onUpdate(PushImageUpdateEvent event) {
			Assert.state(event.getErrorDetail() == null,
					() -> 'Error response received when pushing image: ' + event.getErrorDetail().getMessage());
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public abstract class UpdateEvent {
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class TotalProgressPullListener extends TotalProgressListener<PullImageUpdateEvent> {
	private static final String[] TRACKED_STATUS_KEYS = { 'Downloading', 'Extracting' };
	/**
	 * Create a new {@link TotalProgressPullListener} that prints a progress bar to
	 * {@link System#out}.
	 * @param prefix the prefix to output
	 */
	public TotalProgressPullListener(String prefix) {
		this(new TotalProgressBar(prefix));
	}
	/**
	 * Create a new {@link TotalProgressPullListener} that sends {@link TotalProgressEvent
	 * events} to the given consumer.
	 * @param consumer the consumer that receives {@link TotalProgressEvent progress
	 * events}
	 */
	public TotalProgressPullListener(Consumer<TotalProgressEvent> consumer) {
		super(consumer, TRACKED_STATUS_KEYS);
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class TotalProgressPushListener extends TotalProgressListener<PushImageUpdateEvent> {
	private static final String[] TRACKED_STATUS_KEYS = { 'Pushing' };
	/**
	 * Create a new {@link TotalProgressPushListener} that prints a progress bar to
	 * {@link System#out}.
	 * @param prefix the prefix to output
	 */
	public TotalProgressPushListener(String prefix) {
		this(new TotalProgressBar(prefix));
	}
	/**
	 * Create a new {@link TotalProgressPushListener} that sends {@link TotalProgressEvent
	 * events} to the given consumer.
	 * @param consumer the consumer that receives {@link TotalProgressEvent progress
	 * events}
	 */
	public TotalProgressPushListener(Consumer<TotalProgressEvent> consumer) {
		super(consumer, TRACKED_STATUS_KEYS);
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.docker;
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class LoadImageUpdateEvent extends ProgressUpdateEvent {
	private final String stream;
	@JsonCreator
	public LoadImageUpdateEvent(String stream, String status, ProgressDetail progressDetail, String progress) {
		super(status, progressDetail, progress);
		this.stream = stream;
	}
	/**
	 * Return the stream response or {@code null} if no response is available.
	 * @return the stream response.
	 */
	public String getStream() {
		return this.stream;
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class PushImageUpdateEvent extends ImageProgressUpdateEvent {
	private final ErrorDetail errorDetail;
	@JsonCreator
	public PushImageUpdateEvent(String id, String status, ProgressDetail progressDetail, String progress,
			ErrorDetail errorDetail) {
		super(id, status, progressDetail, progress);
		this.errorDetail = errorDetail;
	}
	/**
	 * Returns the details of any error encountered during processing.
	 * @return the error
	 */
	public ErrorDetail getErrorDetail() {
		return this.errorDetail;
	}
	/**
	 * Details of an error embedded in a response stream.
	 */
	public static class ErrorDetail {
		private final String message;
		@JsonCreator
		public ErrorDetail(@JsonProperty('message') String message) {
			this.message = message;
		}
		/**
		 * Returns the message field from the error detail.
		 * @return the message
		 */
		public String getMessage() {
			return this.message;
		}
		@Override
		public String toString() {
			return this.message;
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.docker;
/**
public class TotalProgressEvent {
	private final int percent;
	/**
	 * Create a new {@link TotalProgressEvent} with a specific percent value.
	 * @param percent the progress as a percentage
	 */
	public TotalProgressEvent(int percent) {
		Assert.isTrue(percent >= 0 && percent <= 100, 'Percent must be in the range 0 to 100');
		this.percent = percent;
	}
	/**
	 * Return the total progress.
	 * @return the total progress
	 */
	public int getPercent() {
		return this.percent;
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
@FunctionalInterface
public interface IOConsumer<T> {
	/**
	 * Performs this operation on the given argument.
	 * @param t the instance to consume
	 * @throws IOException on IO error
	 */
	void accept(T t) throws IOException;
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
@FunctionalInterface
public interface IOBiConsumer<T, U> {
	/**
	 * Performs this operation on the given argument.
	 * @param t the first instance to consume
	 * @param u the second instance to consumer
	 * @throws IOException on IO error
	 */
	void accept(T t, U u) throws IOException;
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
public class ZipFileTarArchive implements TarArchive {
	static final long NORMALIZED_MOD_TIME = TarArchive.NORMALIZED_TIME.toEpochMilli();
	private final File zip;
	private final Owner owner;
	/**
	 * Creates an archive from the contents of the given {@code zip}. Each entry in the
	 * archive will be owned by the given {@code owner}.
	 * @param zip the zip to use as a source
	 * @param owner the owner of the tar entries
	 */
	public ZipFileTarArchive(File zip, Owner owner) {
		Assert.notNull(zip, 'Zip must not be null');
		Assert.notNull(owner, 'Owner must not be null');
		assertArchiveHasEntries(zip);
		this.zip = zip;
		this.owner = owner;
	}
	@Override
	public void writeTo(OutputStream outputStream) throws IOException {
		TarArchiveOutputStream tar = new TarArchiveOutputStream(outputStream);
		tar.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);
		try (ZipFile zipFile = new ZipFile(this.zip)) {
			Enumeration<ZipArchiveEntry> entries = zipFile.getEntries();
			while (entries.hasMoreElements()) {
				ZipArchiveEntry zipEntry = entries.nextElement();
				copy(zipEntry, zipFile.getInputStream(zipEntry), tar);
			}
		}
		tar.finish();
	}
	private void assertArchiveHasEntries(File file) {
		try (ZipFile zipFile = new ZipFile(file)) {
			Assert.state(zipFile.getEntries().hasMoreElements(), () -> 'Archive file "' + file + '" is not valid');
		}
		catch (IOException ex) {
			throw new IllegalStateException('File "' + file + '" is not readable', ex);
		}
	}
	private void copy(ZipArchiveEntry zipEntry, InputStream zip, TarArchiveOutputStream tar) throws IOException {
		TarArchiveEntry tarEntry = convert(zipEntry);
		tar.putArchiveEntry(tarEntry);
		if (tarEntry.isFile()) {
			StreamUtils.copyRange(zip, tar, 0, tarEntry.getSize());
		}
		tar.closeArchiveEntry();
	}
	private TarArchiveEntry convert(ZipArchiveEntry zipEntry) {
		byte linkFlag = (zipEntry.isDirectory()) ? TarConstants.LF_DIR : TarConstants.LF_NORMAL;
		TarArchiveEntry tarEntry = new TarArchiveEntry(zipEntry.getName(), linkFlag, true);
		tarEntry.setUserId(this.owner.getUid());
		tarEntry.setGroupId(this.owner.getGid());
		tarEntry.setModTime(NORMALIZED_MOD_TIME);
		tarEntry.setMode(zipEntry.getUnixMode());
		if (!zipEntry.isDirectory()) {
			tarEntry.setSize(zipEntry.getSize());
		}
		return tarEntry;
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class DefaultOwner implements Owner {
	private final long uid;
	private final long gid;
	DefaultOwner(long uid, long gid) {
		this.uid = uid;
		this.gid = gid;
	}
	@Override
	public long getUid() {
		return this.uid;
	}
	@Override
	public long getGid() {
		return this.gid;
	}
	@Override
	public String toString() {
		return this.uid + '/' + this.gid;
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
public interface Content {
	/**
	 * The size of the content in bytes.
	 * @return the content size
	 */
	int size();
	/**
	 * Write the content to the given output stream.
	 * @param outputStream the output stream to write to
	 * @throws IOException on IO error
	 */
	void writeTo(OutputStream outputStream) throws IOException;
	/**
	 * Create a new {@link Content} from the given UTF-8 string.
	 * @param string the string to write
	 * @return a new {@link Content} instance
	 */
	static Content of(String string) {
		Assert.notNull(string, 'String must not be null');
		return of(string.getBytes(StandardCharsets.UTF_8));
	}
	/**
	 * Create a new {@link Content} from the given input stream.
	 * @param bytes the bytes to write
	 * @return a new {@link Content} instance
	 */
	static Content of(byte[] bytes) {
		Assert.notNull(bytes, 'Bytes must not be null');
		return of(bytes.length, () -> new ByteArrayInputStream(bytes));
	}
	/**
	 * Create a new {@link Content} from the given file.
	 * @param file the file to write
	 * @return a new {@link Content} instance
	 */
	static Content of(File file) {
		Assert.notNull(file, 'File must not be null');
		return of((int) file.length(), () -> new FileInputStream(file));
	}
	/**
	 * Create a new {@link Content} from the given input stream. The stream will be closed
	 * after it has been written.
	 * @param size the size of the supplied input stream
	 * @param supplier the input stream supplier
	 * @return a new {@link Content} instance
	 */
	static Content of(int size, IOSupplier<InputStream> supplier) {
		Assert.isTrue(size >= 0, 'Size must not be negative');
		Assert.notNull(supplier, 'Supplier must not be null');
		return new Content() {
			@Override
			public int size() {
				return size;
			}
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				FileCopyUtils.copy(supplier.get(), outputStream);
			}
		};
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
public class InspectedContent implements Content {
	static final int MEMORY_LIMIT = 4 * 1024 + 3;
	private final int size;
	private final Object content;
	InspectedContent(int size, Object content) {
		this.size = size;
		this.content = content;
	}
	@Override
	public int size() {
		return this.size;
	}
	@Override
	public void writeTo(OutputStream outputStream) throws IOException {
		if (this.content instanceof byte[] bytes) {
			FileCopyUtils.copy(bytes, outputStream);
		}
		else if (this.content instanceof File file) {
			InputStream inputStream = new FileInputStream(file);
			FileCopyUtils.copy(inputStream, outputStream);
		}
		else {
			throw new IllegalStateException('Unknown content type');
		}
	}
	/**
	 * Factory method to create an {@link InspectedContent} instance from a source input
	 * stream.
	 * @param inputStream the content input stream
	 * @param inspectors any inspectors to apply
	 * @return a new inspected content instance
	 * @throws IOException on IO error
	 */
	public static InspectedContent of(InputStream inputStream, Inspector... inspectors) throws IOException {
		Assert.notNull(inputStream, 'InputStream must not be null');
		return of((outputStream) -> FileCopyUtils.copy(inputStream, outputStream), inspectors);
	}
	/**
	 * Factory method to create an {@link InspectedContent} instance from source content.
	 * @param content the content
	 * @param inspectors any inspectors to apply
	 * @return a new inspected content instance
	 * @throws IOException on IO error
	 */
	public static InspectedContent of(Content content, Inspector... inspectors) throws IOException {
		Assert.notNull(content, 'Content must not be null');
		return of(content::writeTo, inspectors);
	}
	/**
	 * Factory method to create an {@link InspectedContent} instance from a source write
	 * method.
	 * @param writer a consumer representing the write method
	 * @param inspectors any inspectors to apply
	 * @return a new inspected content instance
	 * @throws IOException on IO error
	 */
	public static InspectedContent of(IOConsumer<OutputStream> writer, Inspector... inspectors) throws IOException {
		Assert.notNull(writer, 'Writer must not be null');
		InspectingOutputStream outputStream = new InspectingOutputStream(inspectors);
		try (outputStream) {
			writer.accept(outputStream);
		}
		return new InspectedContent(outputStream.getSize(), outputStream.getContent());
	}
	/**
	 * Interface that can be used to inspect content as it is initially read.
	 */
	public interface Inspector {
		/**
		 * Update inspected information based on the provided bytes.
		 * @param input the array of bytes.
		 * @param offset the offset to start from in the array of bytes.
		 * @param len the number of bytes to use, starting at {@code offset}.
		 * @throws IOException on IO error
		 */
		void update(byte[] input, int offset, int len) throws IOException;
	}
	/**
	 * Internal {@link OutputStream} used to capture the content either as bytes, or to a
	 * File if the content is too large.
	 */
	private static final class InspectingOutputStream extends OutputStream {
		private final Inspector[] inspectors;
		private int size;
		private OutputStream delegate;
		private File tempFile;
		private final byte[] singleByteBuffer = new byte[0];
		private InspectingOutputStream(Inspector[] inspectors) {
			this.inspectors = inspectors;
			this.delegate = new ByteArrayOutputStream();
		}
		@Override
		public void write(int b) throws IOException {
			this.singleByteBuffer[0] = (byte) (b & 0xFF);
			write(this.singleByteBuffer);
		}
		@Override
		public void write(byte[] b, int off, int len) throws IOException {
			int size = len - off;
			if (this.tempFile == null && (this.size + size) > MEMORY_LIMIT) {
				convertToTempFile();
			}
			this.delegate.write(b, off, len);
			for (Inspector inspector : this.inspectors) {
				inspector.update(b, off, len);
			}
			this.size += size;
		}
		private void convertToTempFile() throws IOException {
			this.tempFile = File.createTempFile('buildpack', '.tmp');
			byte[] bytes = ((ByteArrayOutputStream) this.delegate).toByteArray();
			this.delegate = new FileOutputStream(this.tempFile);
			StreamUtils.copy(bytes, this.delegate);
		}
		private Object getContent() {
			return (this.tempFile != null) ? this.tempFile : ((ByteArrayOutputStream) this.delegate).toByteArray();
		}
		private int getSize() {
			return this.size;
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
@FunctionalInterface
public interface TarArchive {
	/**
	 * {@link Instant} that can be used to normalize TAR files so all entries have the
	 * same modification time.
	 */
	Instant NORMALIZED_TIME = OffsetDateTime.of(1980, 1, 1, 0, 0, 1, 0, ZoneOffset.UTC).toInstant();
	/**
	 * Write the TAR archive to the given output stream.
	 * @param outputStream the output stream to write to
	 * @throws IOException on IO error
	 */
	void writeTo(OutputStream outputStream) throws IOException;
	/**
	 * Return the compression being used with the tar archive.
	 * @return the used compression
	 * @since 3.2.6
	 */
	default Compression getCompression() {
		return Compression.NONE;
	}
	/**
	 * Factory method to create a new {@link TarArchive} instance with a specific layout.
	 * @param layout the TAR layout
	 * @return a new {@link TarArchive} instance
	 */
	static TarArchive of(IOConsumer<Layout> layout) {
		return (outputStream) -> {
			TarLayoutWriter writer = new TarLayoutWriter(outputStream);
			layout.accept(writer);
			writer.finish();
		};
	}
	/**
	 * Factory method to adapt a ZIP file to {@link TarArchive}.
	 * @param zip the source zip file
	 * @param owner the owner of the entries in the TAR
	 * @return a new {@link TarArchive} instance
	 */
	static TarArchive fromZip(File zip, Owner owner) {
		return new ZipFileTarArchive(zip, owner);
	}
	/**
	 * Factory method to adapt a ZIP file to {@link TarArchive}. Assumes that
	 * {@link #writeTo(OutputStream)} will only be called once.
	 * @param inputStream the source input stream
	 * @param compression the compression used
	 * @return a new {@link TarArchive} instance
	 * @since 3.2.6
	 */
	static TarArchive fromInputStream(InputStream inputStream, Compression compression) {
		return new TarArchive() {
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				StreamUtils.copy(compression.uncompress(inputStream), outputStream);
			}
			@Override
			public Compression getCompression() {
				return compression;
			}
		};
	}
	/**
	 * Compression type applied to the archive.
	 *
	 * @since 3.2.6
	 */
	enum Compression {
		/**
		 * The tar file is not compressed.
		 */
		NONE((inputStream) -> inputStream),
		/**
		 * The tar file is compressed using gzip.
		 */
		GZIP(GZIPInputStream::new),
		/**
		 * The tar file is compressed using zstd.
		 */
		ZSTD('zstd compression is not supported');
		private final ThrowingFunction<InputStream, InputStream> uncompressor;
		Compression(String uncompressError) {
			this((inputStream) -> {
				throw new IllegalStateException(uncompressError);
			});
		}
		Compression(ThrowingFunction<InputStream, InputStream> wrapper) {
			this.uncompressor = wrapper;
		}
		InputStream uncompress(InputStream inputStream) {
			return this.uncompressor.apply(inputStream);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
class TarLayoutWriter implements Layout, Closeable {
	static final long NORMALIZED_MOD_TIME = TarArchive.NORMALIZED_TIME.toEpochMilli();
	private final TarArchiveOutputStream outputStream;
	TarLayoutWriter(OutputStream outputStream) {
		this.outputStream = new TarArchiveOutputStream(outputStream);
		this.outputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);
	}
	@Override
	public void directory(String name, Owner owner, int mode) throws IOException {
		this.outputStream.putArchiveEntry(createDirectoryEntry(name, owner, mode));
		this.outputStream.closeArchiveEntry();
	}
	@Override
	public void file(String name, Owner owner, int mode, Content content) throws IOException {
		this.outputStream.putArchiveEntry(createFileEntry(name, owner, mode, content.size()));
		content.writeTo(StreamUtils.nonClosing(this.outputStream));
		this.outputStream.closeArchiveEntry();
	}
	private TarArchiveEntry createDirectoryEntry(String name, Owner owner, int mode) {
		return createEntry(name, owner, TarConstants.LF_DIR, mode, 0);
	}
	private TarArchiveEntry createFileEntry(String name, Owner owner, int mode, int size) {
		return createEntry(name, owner, TarConstants.LF_NORMAL, mode, size);
	}
	private TarArchiveEntry createEntry(String name, Owner owner, byte linkFlag, int mode, int size) {
		TarArchiveEntry entry = new TarArchiveEntry(name, linkFlag, true);
		entry.setUserId(owner.getUid());
		entry.setGroupId(owner.getGid());
		entry.setMode(mode);
		entry.setModTime(NORMALIZED_MOD_TIME);
		entry.setSize(size);
		return entry;
	}
	void finish() throws IOException {
		this.outputStream.finish();
	}
	@Override
	public void close() throws IOException {
		this.outputStream.close();
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
@FunctionalInterface
public interface IOSupplier<T> {
	/**
	 * Gets the supplied value.
	 * @return the supplied value
	 * @throws IOException on IO error
	 */
	T get() throws IOException;
}
/*
/**
package org.springframework.boot.buildpack.platform.io;
/*
package org.springframework.boot.buildpack.platform.io;
/**
public interface Owner {
	/**
	 * Owner for root ownership.
	 */
	Owner ROOT = Owner.of(0, 0);
	/**
	 * Return the user identifier (UID) of the owner.
	 * @return the user identifier
	 */
	long getUid();
	/**
	 * Return the group identifier (GID) of the owner.
	 * @return the group identifier
	 */
	long getGid();
	/**
	 * Factory method to create a new {@link Owner} with specified user/group identifier.
	 * @param uid the user identifier
	 * @param gid the group identifier
	 * @return a new {@link Owner} instance
	 */
	static Owner of(long uid, long gid) {
		return new DefaultOwner(uid, gid);
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
public final class FilePermissions {
	private FilePermissions() {
	}
	/**
	 * Return the integer representation of the file permissions for a path, where the
	 * integer value conforms to the
	 * <a href='https://en.wikipedia.org/wiki/Umask'>umask</a> octal notation.
	 * @param path the file path
	 * @return the integer representation
	 * @throws IOException if path permissions cannot be read
	 */
	public static int umaskForPath(Path path) throws IOException {
		Assert.notNull(path, 'Path must not be null');
		PosixFileAttributeView attributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class);
		Assert.state(attributeView != null, 'Unsupported file type for retrieving Posix attributes');
		return posixPermissionsToUmask(attributeView.readAttributes().permissions());
	}
	/**
	 * Return the integer representation of a set of Posix file permissions, where the
	 * integer value conforms to the
	 * <a href='https://en.wikipedia.org/wiki/Umask'>umask</a> octal notation.
	 * @param permissions the set of {@code PosixFilePermission}s
	 * @return the integer representation
	 */
	public static int posixPermissionsToUmask(Collection<PosixFilePermission> permissions) {
		Assert.notNull(permissions, 'Permissions must not be null');
		int owner = permissionToUmask(permissions, PosixFilePermission.OWNER_EXECUTE, PosixFilePermission.OWNER_WRITE,
				PosixFilePermission.OWNER_READ);
		int group = permissionToUmask(permissions, PosixFilePermission.GROUP_EXECUTE, PosixFilePermission.GROUP_WRITE,
				PosixFilePermission.GROUP_READ);
		int other = permissionToUmask(permissions, PosixFilePermission.OTHERS_EXECUTE, PosixFilePermission.OTHERS_WRITE,
				PosixFilePermission.OTHERS_READ);
		return Integer.parseInt('' + owner + group + other, 8);
	}
	private static int permissionToUmask(Collection<PosixFilePermission> permissions, PosixFilePermission execute,
			PosixFilePermission write, PosixFilePermission read) {
		int value = 0;
		if (permissions.contains(execute)) {
			value += 1;
		}
		if (permissions.contains(write)) {
			value += 2;
		}
		if (permissions.contains(read)) {
			value += 4;
		}
		return value;
	}
}
/*
package org.springframework.boot.buildpack.platform.io;
/**
public interface Layout {
	/**
	 * Add a directory to the content.
	 * @param name the full name of the directory to add
	 * @param owner the owner of the directory
	 * @throws IOException on IO error
	 */
	default void directory(String name, Owner owner) throws IOException {
		directory(name, owner, 0755);
	}
	/**
	 * Add a directory to the content.
	 * @param name the full name of the directory to add
	 * @param owner the owner of the directory
	 * @param mode the permissions for the file
	 * @throws IOException on IO error
	 */
	void directory(String name, Owner owner, int mode) throws IOException;
	/**
	 * Write a file to the content.
	 * @param name the full name of the file to add
	 * @param owner the owner of the file
	 * @param content the content to add
	 * @throws IOException on IO error
	 */
	default void file(String name, Owner owner, Content content) throws IOException {
		file(name, owner, 0644, content);
	}
	/**
	 * Write a file to the content.
	 * @param name the full name of the file to add
	 * @param owner the owner of the file
	 * @param mode the permissions for the file
	 * @param content the content to add
	 * @throws IOException on IO error
	 */
	void file(String name, Owner owner, int mode, Content content) throws IOException;
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class EphemeralBuilder {
	static final String BUILDER_FOR_LABEL_NAME = 'org.springframework.boot.builderFor';
	private final BuildOwner buildOwner;
	private final BuilderMetadata builderMetadata;
	private final ImageArchive archive;
	private final Creator creator;
	/**
	 * Create a new {@link EphemeralBuilder} instance.
	 * @param buildOwner the build owner
	 * @param builderImage the base builder image
	 * @param targetImage the image being built
	 * @param builderMetadata the builder metadata
	 * @param creator the builder creator
	 * @param env the builder env
	 * @param buildpacks an optional set of buildpacks to apply
	 * @throws IOException on IO error
	 */
	EphemeralBuilder(BuildOwner buildOwner, Image builderImage, ImageReference targetImage,
			BuilderMetadata builderMetadata, Creator creator, Map<String, String> env, Buildpacks buildpacks)
			throws IOException {
		ImageReference name = ImageReference.random('pack.local/builder/').inTaggedForm();
		this.buildOwner = buildOwner;
		this.creator = creator;
		this.builderMetadata = builderMetadata.copy(this::updateMetadata);
		this.archive = ImageArchive.from(builderImage, (update) -> {
			update.withUpdatedConfig(this.builderMetadata::attachTo);
			update.withUpdatedConfig((config) -> config.withLabel(BUILDER_FOR_LABEL_NAME, targetImage.toString()));
			update.withTag(name);
			if (!CollectionUtils.isEmpty(env)) {
				update.withNewLayer(getEnvLayer(env));
			}
			if (buildpacks != null) {
				buildpacks.apply(update::withNewLayer);
			}
		});
	}
	private void updateMetadata(BuilderMetadata.Update update) {
		update.withCreatedBy(this.creator.getName(), this.creator.getVersion());
	}
	private Layer getEnvLayer(Map<String, String> env) throws IOException {
		return Layer.of((layout) -> {
			for (Map.Entry<String, String> entry : env.entrySet()) {
				String name = '/platform/env/' + entry.getKey();
				Content content = Content.of((entry.getValue() != null) ? entry.getValue() : '');
				layout.file(name, Owner.ROOT, content);
			}
		});
	}
	/**
	 * Return the name of this archive as tagged in Docker.
	 * @return the ephemeral builder name
	 */
	ImageReference getName() {
		return this.archive.getTag();
	}
	/**
	 * Return the build owner that should be used for written content.
	 * @return the builder owner
	 */
	Owner getBuildOwner() {
		return this.buildOwner;
	}
	/**
	 * Return the builder meta-data that was used to create this ephemeral builder.
	 * @return the builder meta-data
	 */
	BuilderMetadata getBuilderMetadata() {
		return this.builderMetadata;
	}
	/**
	 * Return the contents of ephemeral builder for passing to Docker.
	 * @return the ephemeral builder archive
	 */
	ImageArchive getArchive() {
		return this.archive;
	}
	@Override
	public String toString() {
		return this.archive.getTag().toString();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class BuildpackLayersMetadata extends MappedObject {
	private static final String LABEL_NAME = 'io.buildpacks.buildpack.layers';
	private final Buildpacks buildpacks;
	private BuildpackLayersMetadata(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.buildpacks = Buildpacks.fromJson(getNode());
	}
	/**
	 * Return the metadata details of a buildpack with the given ID and version.
	 * @param id the buildpack ID
	 * @param version the buildpack version
	 * @return the buildpack details or {@code null} if a buildpack with the given ID and
	 * version does not exist in the metadata
	 */
	BuildpackLayerDetails getBuildpack(String id, String version) {
		return this.buildpacks.getBuildpack(id, version);
	}
	/**
	 * Create a {@link BuildpackLayersMetadata} from an image.
	 * @param image the source image
	 * @return the buildpack layers metadata
	 * @throws IOException on IO error
	 */
	static BuildpackLayersMetadata fromImage(Image image) throws IOException {
		Assert.notNull(image, 'Image must not be null');
		return fromImageConfig(image.getConfig());
	}
	/**
	 * Create a {@link BuildpackLayersMetadata} from image config.
	 * @param imageConfig the source image config
	 * @return the buildpack layers metadata
	 * @throws IOException on IO error
	 */
	static BuildpackLayersMetadata fromImageConfig(ImageConfig imageConfig) throws IOException {
		Assert.notNull(imageConfig, 'ImageConfig must not be null');
		String json = imageConfig.getLabels().get(LABEL_NAME);
		Assert.notNull(json, () -> 'No "' + LABEL_NAME + '" label found in image config labels "'
				+ StringUtils.collectionToCommaDelimitedString(imageConfig.getLabels().keySet()) + '"');
		return fromJson(json);
	}
	/**
	 * Create a {@link BuildpackLayersMetadata} from JSON.
	 * @param json the source JSON
	 * @return the buildpack layers metadata
	 * @throws IOException on IO error
	 */
	static BuildpackLayersMetadata fromJson(String json) throws IOException {
		return fromJson(SharedObjectMapper.get().readTree(json));
	}
	/**
	 * Create a {@link BuildpackLayersMetadata} from JSON.
	 * @param node the source JSON
	 * @return the buildpack layers metadata
	 */
	static BuildpackLayersMetadata fromJson(JsonNode node) {
		return new BuildpackLayersMetadata(node);
	}
	private static final class Buildpacks {
		private final Map<String, BuildpackVersions> buildpacks = new HashMap<>();
		private BuildpackLayerDetails getBuildpack(String id, String version) {
			if (this.buildpacks.containsKey(id)) {
				return this.buildpacks.get(id).getBuildpack(version);
			}
			return null;
		}
		private void addBuildpackVersions(String id, BuildpackVersions versions) {
			this.buildpacks.put(id, versions);
		}
		private static Buildpacks fromJson(JsonNode node) {
			Buildpacks buildpacks = new Buildpacks();
			node.fields()
				.forEachRemaining((field) -> buildpacks.addBuildpackVersions(field.getKey(),
						BuildpackVersions.fromJson(field.getValue())));
			return buildpacks;
		}
	}
	private static final class BuildpackVersions {
		private final Map<String, BuildpackLayerDetails> versions = new HashMap<>();
		private BuildpackLayerDetails getBuildpack(String version) {
			return this.versions.get(version);
		}
		private void addBuildpackVersion(String version, BuildpackLayerDetails details) {
			this.versions.put(version, details);
		}
		private static BuildpackVersions fromJson(JsonNode node) {
			BuildpackVersions versions = new BuildpackVersions();
			node.fields()
				.forEachRemaining((field) -> versions.addBuildpackVersion(field.getKey(),
						BuildpackLayerDetails.fromJson(field.getValue())));
			return versions;
		}
	}
	static final class BuildpackLayerDetails extends MappedObject {
		private final String name;
		private final String homepage;
		private final String layerDiffId;
		private BuildpackLayerDetails(JsonNode node) {
			super(node, MethodHandles.lookup());
			this.name = valueAt('/name', String.class);
			this.homepage = valueAt('/homepage', String.class);
			this.layerDiffId = valueAt('/layerDiffID', String.class);
		}
		/**
		 * Return the buildpack name.
		 * @return the name
		 */
		String getName() {
			return this.name;
		}
		/**
		 * Return the buildpack homepage address.
		 * @return the homepage address
		 */
		String getHomepage() {
			return this.homepage;
		}
		/**
		 * Return the buildpack layer {@code diffID}.
		 * @return the layer {@code diffID}
		 */
		String getLayerDiffId() {
			return this.layerDiffId;
		}
		private static BuildpackLayerDetails fromJson(JsonNode node) {
			return new BuildpackLayerDetails(node);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public enum PullPolicy {
	/**
	 * Always pull the image from the registry.
	 */
	ALWAYS,
	/**
	 * Never pull the image from the registry.
	 */
	NEVER,
	/**
	 * Pull the image from the registry only if it does not exist locally.
	 */
	IF_NOT_PRESENT
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class Lifecycle implements Closeable {
	private static final LifecycleVersion LOGGING_MINIMUM_VERSION = LifecycleVersion.parse('0.0.5');
	private static final String PLATFORM_API_VERSION_KEY = 'CNB_PLATFORM_API';
	private static final String SOURCE_DATE_EPOCH_KEY = 'SOURCE_DATE_EPOCH';
	private static final String DOMAIN_SOCKET_PATH = '/var/run/docker.sock';
	private static final List<String> DEFAULT_SECURITY_OPTIONS = List.of('label=disable');
	private final BuildLog log;
	private final DockerApi docker;
	private final ResolvedDockerHost dockerHost;
	private final BuildRequest request;
	private final EphemeralBuilder builder;
	private final LifecycleVersion lifecycleVersion;
	private final ApiVersion platformVersion;
	private final Cache layers;
	private final Cache application;
	private final Cache buildCache;
	private final Cache launchCache;
	private final String applicationDirectory;
	private final List<String> securityOptions;
	private boolean executed;
	private boolean applicationVolumePopulated;
	/**
	 * Create a new {@link Lifecycle} instance.
	 * @param log build output log
	 * @param docker the Docker API
	 * @param dockerHost the Docker host information
	 * @param request the request to process
	 * @param builder the ephemeral builder used to run the phases
	 */
	Lifecycle(BuildLog log, DockerApi docker, ResolvedDockerHost dockerHost, BuildRequest request,
			EphemeralBuilder builder) {
		this.log = log;
		this.docker = docker;
		this.dockerHost = dockerHost;
		this.request = request;
		this.builder = builder;
		this.lifecycleVersion = LifecycleVersion.parse(builder.getBuilderMetadata().getLifecycle().getVersion());
		this.platformVersion = getPlatformVersion(builder.getBuilderMetadata().getLifecycle());
		this.layers = getLayersBindingSource(request);
		this.application = getApplicationBindingSource(request);
		this.buildCache = getBuildCache(request);
		this.launchCache = getLaunchCache(request);
		this.applicationDirectory = getApplicationDirectory(request);
		this.securityOptions = getSecurityOptions(request);
	}
	private Cache getBuildCache(BuildRequest request) {
		if (request.getBuildCache() != null) {
			return request.getBuildCache();
		}
		return createVolumeCache(request, 'build');
	}
	private Cache getLaunchCache(BuildRequest request) {
		if (request.getLaunchCache() != null) {
			return request.getLaunchCache();
		}
		return createVolumeCache(request, 'launch');
	}
	private String getApplicationDirectory(BuildRequest request) {
		return (request.getApplicationDirectory() != null) ? request.getApplicationDirectory() : Directory.APPLICATION;
	}
	private List<String> getSecurityOptions(BuildRequest request) {
		if (request.getSecurityOptions() != null) {
			return request.getSecurityOptions();
		}
		return (Platform.isWindows()) ? Collections.emptyList() : DEFAULT_SECURITY_OPTIONS;
	}
	private ApiVersion getPlatformVersion(BuilderMetadata.Lifecycle lifecycle) {
		if (lifecycle.getApis().getPlatform() != null) {
			String[] supportedVersions = lifecycle.getApis().getPlatform();
			return ApiVersions.SUPPORTED_PLATFORMS.findLatestSupported(supportedVersions);
		}
		String version = lifecycle.getApi().getPlatform();
		return ApiVersions.SUPPORTED_PLATFORMS.findLatestSupported(version);
	}
	/**
	 * Execute this lifecycle by running each phase in turn.
	 * @throws IOException on IO error
	 */
	void execute() throws IOException {
		Assert.state(!this.executed, 'Lifecycle has already been executed');
		this.executed = true;
		this.log.executingLifecycle(this.request, this.lifecycleVersion, this.buildCache);
		if (this.request.isCleanCache()) {
			deleteCache(this.buildCache);
		}
		if (this.request.isTrustBuilder()) {
			run(createPhase());
		}
		else {
			run(analyzePhase());
			run(detectPhase());
			if (!this.request.isCleanCache()) {
				run(restorePhase());
			}
			else {
				this.log.skippingPhase('restorer', 'because "cleanCache" is enabled');
			}
			run(buildPhase());
			run(exportPhase());
		}
		this.log.executedLifecycle(this.request);
	}
	private Phase createPhase() {
		Phase phase = new Phase('creator', isVerboseLogging());
		phase.withApp(this.applicationDirectory,
				Binding.from(getCacheBindingSource(this.application), this.applicationDirectory));
		phase.withPlatform(Directory.PLATFORM);
		phase.withRunImage(this.request.getRunImage());
		phase.withLayers(Directory.LAYERS, Binding.from(getCacheBindingSource(this.layers), Directory.LAYERS));
		phase.withBuildCache(Directory.CACHE, Binding.from(getCacheBindingSource(this.buildCache), Directory.CACHE));
		phase.withLaunchCache(Directory.LAUNCH_CACHE,
				Binding.from(getCacheBindingSource(this.launchCache), Directory.LAUNCH_CACHE));
		configureDaemonAccess(phase);
		if (this.request.isCleanCache()) {
			phase.withSkipRestore();
		}
		if (requiresProcessTypeDefault()) {
			phase.withProcessType('web');
		}
		phase.withImageName(this.request.getName());
		configureOptions(phase);
		configureCreatedDate(phase);
		return phase;
	}
	private Phase analyzePhase() {
		Phase phase = new Phase('analyzer', isVerboseLogging());
		configureDaemonAccess(phase);
		phase.withLaunchCache(Directory.LAUNCH_CACHE,
				Binding.from(getCacheBindingSource(this.launchCache), Directory.LAUNCH_CACHE));
		phase.withLayers(Directory.LAYERS, Binding.from(getCacheBindingSource(this.layers), Directory.LAYERS));
		phase.withRunImage(this.request.getRunImage());
		phase.withImageName(this.request.getName());
		configureOptions(phase);
		return phase;
	}
	private Phase detectPhase() {
		Phase phase = new Phase('detector', isVerboseLogging());
		phase.withApp(this.applicationDirectory,
				Binding.from(getCacheBindingSource(this.application), this.applicationDirectory));
		phase.withLayers(Directory.LAYERS, Binding.from(getCacheBindingSource(this.layers), Directory.LAYERS));
		phase.withPlatform(Directory.PLATFORM);
		configureOptions(phase);
		return phase;
	}
	private Phase restorePhase() {
		Phase phase = new Phase('restorer', isVerboseLogging());
		configureDaemonAccess(phase);
		phase.withBuildCache(Directory.CACHE, Binding.from(getCacheBindingSource(this.buildCache), Directory.CACHE));
		phase.withLayers(Directory.LAYERS, Binding.from(getCacheBindingSource(this.layers), Directory.LAYERS));
		configureOptions(phase);
		return phase;
	}
	private Phase buildPhase() {
		Phase phase = new Phase('builder', isVerboseLogging());
		phase.withApp(this.applicationDirectory,
				Binding.from(getCacheBindingSource(this.application), this.applicationDirectory));
		phase.withLayers(Directory.LAYERS, Binding.from(getCacheBindingSource(this.layers), Directory.LAYERS));
		phase.withPlatform(Directory.PLATFORM);
		configureOptions(phase);
		return phase;
	}
	private Phase exportPhase() {
		Phase phase = new Phase('exporter', isVerboseLogging());
		configureDaemonAccess(phase);
		phase.withApp(this.applicationDirectory,
				Binding.from(getCacheBindingSource(this.application), this.applicationDirectory));
		phase.withBuildCache(Directory.CACHE, Binding.from(getCacheBindingSource(this.buildCache), Directory.CACHE));
		phase.withLaunchCache(Directory.LAUNCH_CACHE,
				Binding.from(getCacheBindingSource(this.launchCache), Directory.LAUNCH_CACHE));
		phase.withLayers(Directory.LAYERS, Binding.from(getCacheBindingSource(this.layers), Directory.LAYERS));
		if (requiresProcessTypeDefault()) {
			phase.withProcessType('web');
		}
		phase.withImageName(this.request.getName());
		configureOptions(phase);
		configureCreatedDate(phase);
		return phase;
	}
	private Cache getLayersBindingSource(BuildRequest request) {
		if (request.getBuildWorkspace() != null) {
			return getBuildWorkspaceBindingSource(request.getBuildWorkspace(), 'layers');
		}
		return createVolumeCache('pack-layers-');
	}
	private Cache getApplicationBindingSource(BuildRequest request) {
		if (request.getBuildWorkspace() != null) {
			return getBuildWorkspaceBindingSource(request.getBuildWorkspace(), 'app');
		}
		return createVolumeCache('pack-app-');
	}
	private Cache getBuildWorkspaceBindingSource(Cache buildWorkspace, String suffix) {
		return (buildWorkspace.getVolume() != null) ? Cache.volume(buildWorkspace.getVolume().getName() + '-' + suffix)
				: Cache.bind(buildWorkspace.getBind().getSource() + '-' + suffix);
	}
	private String getCacheBindingSource(Cache cache) {
		return (cache.getVolume() != null) ? cache.getVolume().getName() : cache.getBind().getSource();
	}
	private Cache createVolumeCache(String prefix) {
		return Cache.volume(createRandomVolumeName(prefix));
	}
	private Cache createVolumeCache(BuildRequest request, String suffix) {
		return Cache.volume(
				VolumeName.basedOn(request.getName(), ImageReference::toLegacyString, 'pack-cache-', '.' + suffix, 6));
	}
	protected VolumeName createRandomVolumeName(String prefix) {
		return VolumeName.random(prefix);
	}
	private void configureDaemonAccess(Phase phase) {
		phase.withDaemonAccess();
		if (this.dockerHost != null) {
			if (this.dockerHost.isRemote()) {
				phase.withEnv('DOCKER_HOST', this.dockerHost.getAddress());
				if (this.dockerHost.isSecure()) {
					phase.withEnv('DOCKER_TLS_VERIFY', '1');
					phase.withEnv('DOCKER_CERT_PATH', this.dockerHost.getCertificatePath());
				}
			}
			else {
				phase.withBinding(Binding.from(this.dockerHost.getAddress(), DOMAIN_SOCKET_PATH));
			}
		}
		else {
			phase.withBinding(Binding.from(DOMAIN_SOCKET_PATH, DOMAIN_SOCKET_PATH));
		}
		if (this.securityOptions != null) {
			this.securityOptions.forEach(phase::withSecurityOption);
		}
	}
	private void configureCreatedDate(Phase phase) {
		if (this.request.getCreatedDate() != null) {
			phase.withEnv(SOURCE_DATE_EPOCH_KEY, Long.toString(this.request.getCreatedDate().getEpochSecond()));
		}
	}
	private void configureOptions(Phase phase) {
		if (this.request.getBindings() != null) {
			this.request.getBindings().forEach(phase::withBinding);
		}
		if (this.request.getNetwork() != null) {
			phase.withNetworkMode(this.request.getNetwork());
		}
		phase.withEnv(PLATFORM_API_VERSION_KEY, this.platformVersion.toString());
	}
	private boolean isVerboseLogging() {
		return this.request.isVerboseLogging() && this.lifecycleVersion.isEqualOrGreaterThan(LOGGING_MINIMUM_VERSION);
	}
	private boolean requiresProcessTypeDefault() {
		return this.platformVersion.supportsAny(ApiVersion.of(0, 4), ApiVersion.of(0, 5));
	}
	private void run(Phase phase) throws IOException {
		Consumer<LogUpdateEvent> logConsumer = this.log.runningPhase(this.request, phase.getName());
		ContainerConfig containerConfig = ContainerConfig.of(this.builder.getName(), phase::apply);
		ContainerReference reference = createContainer(containerConfig, phase.requiresApp());
		try {
			this.docker.container().start(reference);
			this.docker.container().logs(reference, logConsumer::accept);
			ContainerStatus status = this.docker.container().wait(reference);
			if (status.getStatusCode() != 0) {
				throw new BuilderException(phase.getName(), status.getStatusCode());
			}
		}
		finally {
			this.docker.container().remove(reference, true);
		}
	}
	private ContainerReference createContainer(ContainerConfig config, boolean requiresAppUpload) throws IOException {
		if (!requiresAppUpload || this.applicationVolumePopulated) {
			return this.docker.container().create(config, this.request.getImagePlatform());
		}
		try {
			if (this.application.getBind() != null) {
				Files.createDirectories(Path.of(this.application.getBind().getSource()));
			}
			TarArchive applicationContent = this.request.getApplicationContent(this.builder.getBuildOwner());
			return this.docker.container()
				.create(config, this.request.getImagePlatform(),
						ContainerContent.of(applicationContent, this.applicationDirectory));
		}
		finally {
			this.applicationVolumePopulated = true;
		}
	}
	@Override
	public void close() throws IOException {
		deleteCache(this.layers);
		deleteCache(this.application);
	}
	private void deleteCache(Cache cache) throws IOException {
		if (cache.getVolume() != null) {
			deleteVolume(cache.getVolume().getVolumeName());
		}
		if (cache.getBind() != null) {
			deleteBind(cache.getBind());
		}
	}
	private void deleteVolume(VolumeName name) throws IOException {
		this.docker.volume().delete(name, true);
	}
	private void deleteBind(Cache.Bind bind) {
		try {
			FileSystemUtils.deleteRecursively(Path.of(bind.getSource()));
		}
		catch (Exception ex) {
			this.log.failedCleaningWorkDir(bind, ex);
		}
	}
	/**
	 * Common directories used by the various phases.
	 */
	private static final class Directory {
		/**
		 * The directory used by buildpacks to write their layer contributions. A new
		 * layer directory is created for each lifecycle execution.
		 * <p>
		 * Maps to the {@code <layers...>} concept in the
		 * <a href='https://github.com/buildpacks/spec/blob/master/buildpack.md'>buildpack
		 * specification</a> and the {@code -layers} argument to lifecycle phases.
		 */
		static final String LAYERS = '/layers';
		/**
		 * The directory containing the original contributed application. A new
		 * application directory is created for each lifecycle execution.
		 * <p>
		 * Maps to the {@code <app...>} concept in the
		 * <a href='https://github.com/buildpacks/spec/blob/master/buildpack.md'>buildpack
		 * specification</a> and the {@code -app} argument from the reference lifecycle
		 * implementation. The reference lifecycle follows the Kubernetes/Docker
		 * convention of using {@code "/workspace"}.
		 * <p>
		 * Note that application content is uploaded to the container with the first phase
		 * that runs and saved in a volume that is passed to subsequent phases. The
		 * directory is mutable and buildpacks may modify the content.
		 */
		static final String APPLICATION = '/workspace';
		/**
		 * The directory used by buildpacks to obtain environment variables and platform
		 * specific concerns. The platform directory is read-only and is created/populated
		 * by the {@link EphemeralBuilder}.
		 * <p>
		 * Maps to the {@code <platform>/env} and {@code <platform>/#} concepts in the
		 * <a href='https://github.com/buildpacks/spec/blob/master/buildpack.md'>buildpack
		 * specification</a> and the {@code -platform} argument to lifecycle phases.
		 */
		static final String PLATFORM = '/platform';
		/**
		 * The directory used by buildpacks for caching. The volume name is based on the
		 * image {@link BuildRequest#getName() name} being built, and is persistent across
		 * invocations even if the application content has changed.
		 * <p>
		 * Maps to the {@code -path} argument to lifecycle phases.
		 */
		static final String CACHE = '/cache';
		/**
		 * The directory used by buildpacks for launch related caching. The volume name is
		 * based on the image {@link BuildRequest#getName() name} being built, and is
		 * persistent across invocations even if the application content has changed.
		 * <p>
		 * Maps to the {@code -launch-cache} argument to lifecycle phases.
		 */
		static final String LAUNCH_CACHE = '/launch-cache';
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class Phase {
	private final String name;
	private boolean daemonAccess = false;
	private final List<String> args = new ArrayList<>();
	private final List<Binding> bindings = new ArrayList<>();
	private final Map<String, String> env = new LinkedHashMap<>();
	private final List<String> securityOptions = new ArrayList<>();
	private String networkMode;
	private boolean requiresApp = false;
	/**
	 * Create a new {@link Phase} instance.
	 * @param name the name of the phase
	 * @param verboseLogging if verbose logging is requested
	 */
	Phase(String name, boolean verboseLogging) {
		this.name = name;
		withLogLevelArg(verboseLogging);
	}
	void withApp(String path, Binding binding) {
		withArgs('-app', path);
		withBinding(binding);
		this.requiresApp = true;
	}
	void withBuildCache(String path, Binding binding) {
		withArgs('-cache-dir', path);
		withBinding(binding);
	}
	/**
	 * Update this phase with Docker daemon access.
	 */
	void withDaemonAccess() {
		this.withArgs('-daemon');
		this.daemonAccess = true;
	}
	void withImageName(ImageReference imageName) {
		withArgs(imageName);
	}
	void withLaunchCache(String path, Binding binding) {
		withArgs('-launch-cache', path);
		withBinding(binding);
	}
	void withLayers(String path, Binding binding) {
		withArgs('-layers', path);
		withBinding(binding);
	}
	void withPlatform(String path) {
		withArgs('-platform', path);
	}
	void withProcessType(String type) {
		withArgs('-process-type', type);
	}
	void withRunImage(ImageReference runImage) {
		withArgs('-run-image', runImage);
	}
	void withSkipRestore() {
		withArgs('-skip-restore');
	}
	/**
	 * Update this phase with a debug log level arguments if verbose logging has been
	 * requested.
	 * @param verboseLogging if verbose logging is requested
	 */
	private void withLogLevelArg(boolean verboseLogging) {
		if (verboseLogging) {
			this.args.add('-log-level');
			this.args.add('debug');
		}
	}
	/**
	 * Update this phase with additional run arguments.
	 * @param args the arguments to add
	 */
	void withArgs(Object... args) {
		Arrays.stream(args).map(Object::toString).forEach(this.args::add);
	}
	/**
	 * Update this phase with an addition volume binding.
	 * @param binding the binding
	 */
	void withBinding(Binding binding) {
		this.bindings.add(binding);
	}
	/**
	 * Update this phase with an additional environment variable.
	 * @param name the variable name
	 * @param value the variable value
	 */
	void withEnv(String name, String value) {
		this.env.put(name, value);
	}
	/**
	 * Update this phase with the network the build container will connect to.
	 * @param networkMode the network
	 */
	void withNetworkMode(String networkMode) {
		this.networkMode = networkMode;
	}
	/**
	 * Update this phase with a security option.
	 * @param option the security option
	 */
	void withSecurityOption(String option) {
		this.securityOptions.add(option);
	}
	/**
	 * Return the name of the phase.
	 * @return the phase name
	 */
	String getName() {
		return this.name;
	}
	boolean requiresApp() {
		return this.requiresApp;
	}
	@Override
	public String toString() {
		return this.name;
	}
	/**
	 * Apply this phase settings to a {@link ContainerConfig} update.
	 * @param update the update to apply the phase to
	 */
	void apply(ContainerConfig.Update update) {
		if (this.daemonAccess) {
			update.withUser('root');
		}
		update.withCommand('/cnb/lifecycle/' + this.name, StringUtils.toStringArray(this.args));
		update.withLabel('author', 'spring-boot');
		this.bindings.forEach(update::withBinding);
		this.env.forEach(update::withEnv);
		if (this.networkMode != null) {
			update.withNetworkMode(this.networkMode);
		}
		this.securityOptions.forEach(update::withSecurityOption);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class ImageBuildpack implements Buildpack {
	private static final String PREFIX = 'docker://';
	private final BuildpackCoordinates coordinates;
	private final ExportedLayers exportedLayers;
	private ImageBuildpack(BuildpackResolverContext context, ImageReference imageReference) {
		ImageReference reference = imageReference.inTaggedOrDigestForm();
		try {
			Image image = context.fetchImage(reference, ImageType.BUILDPACK);
			BuildpackMetadata buildpackMetadata = BuildpackMetadata.fromImage(image);
			this.coordinates = BuildpackCoordinates.fromBuildpackMetadata(buildpackMetadata);
			this.exportedLayers = (!buildpackExistsInBuilder(context, image.getLayers()))
					? new ExportedLayers(context, reference) : null;
		}
		catch (IOException | DockerEngineException ex) {
			throw new IllegalArgumentException('Error pulling buildpack image "' + reference + '"', ex);
		}
	}
	private boolean buildpackExistsInBuilder(BuildpackResolverContext context, List<LayerId> imageLayers) {
		BuildpackLayerDetails buildpackLayerDetails = context.getBuildpackLayersMetadata()
			.getBuildpack(this.coordinates.getId(), this.coordinates.getVersion());
		String layerDiffId = (buildpackLayerDetails != null) ? buildpackLayerDetails.getLayerDiffId() : null;
		return (layerDiffId != null) && imageLayers.stream().map(LayerId::toString).anyMatch(layerDiffId::equals);
	}
	@Override
	public BuildpackCoordinates getCoordinates() {
		return this.coordinates;
	}
	@Override
	public void apply(IOConsumer<Layer> layers) throws IOException {
		if (this.exportedLayers != null) {
			this.exportedLayers.apply(layers);
		}
	}
	/**
	 * A {@link BuildpackResolver} compatible method to resolve image buildpacks.
	 * @param context the resolver context
	 * @param reference the buildpack reference
	 * @return the resolved {@link Buildpack} or {@code null}
	 */
	static Buildpack resolve(BuildpackResolverContext context, BuildpackReference reference) {
		boolean unambiguous = reference.hasPrefix(PREFIX);
		try {
			ImageReference imageReference = ImageReference
				.of((unambiguous) ? reference.getSubReference(PREFIX) : reference.toString());
			return new ImageBuildpack(context, imageReference);
		}
		catch (IllegalArgumentException ex) {
			if (unambiguous) {
				throw ex;
			}
			return null;
		}
	}
	private static class ExportedLayers {
		private final List<Path> layerFiles;
		ExportedLayers(BuildpackResolverContext context, ImageReference imageReference) throws IOException {
			List<Path> layerFiles = new ArrayList<>();
			context.exportImageLayers(imageReference,
					(name, tarArchive) -> layerFiles.add(createLayerFile(tarArchive)));
			this.layerFiles = Collections.unmodifiableList(layerFiles);
		}
		private Path createLayerFile(TarArchive tarArchive) throws IOException {
			Path sourceTarFile = Files.createTempFile('create-builder-scratch-source-', null);
			try (OutputStream out = Files.newOutputStream(sourceTarFile)) {
				tarArchive.writeTo(out);
			}
			Path layerFile = Files.createTempFile('create-builder-scratch-', null);
			try (TarArchiveOutputStream out = new TarArchiveOutputStream(Files.newOutputStream(layerFile))) {
				try (TarArchiveInputStream in = new TarArchiveInputStream(Files.newInputStream(sourceTarFile))) {
					out.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);
					TarArchiveEntry entry = in.getNextEntry();
					while (entry != null) {
						out.putArchiveEntry(entry);
						StreamUtils.copy(in, out);
						out.closeArchiveEntry();
						entry = in.getNextEntry();
					}
					out.finish();
				}
			}
			return layerFile;
		}
		void apply(IOConsumer<Layer> layers) throws IOException {
			for (Path path : this.layerFiles) {
				layers.accept(Layer.fromTarArchive((out) -> {
					InputStream in = Files.newInputStream(path);
					StreamUtils.copy(in, out);
				}));
				Files.delete(path);
			}
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
interface Buildpack {
	/**
	 * Return the coordinates of the builder.
	 * @return the builder coordinates
	 */
	BuildpackCoordinates getCoordinates();
	/**
	 * Apply the necessary buildpack layers.
	 * @param layers a consumer that should accept the layers
	 * @throws IOException on IO error
	 */
	void apply(IOConsumer<Layer> layers) throws IOException;
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuilderMetadata extends MappedObject {
	private static final String LABEL_NAME = 'io.buildpacks.builder.metadata';
	private static final String[] EMPTY_MIRRORS = {};
	private final Stack stack;
	private final List<RunImage> runImages;
	private final Lifecycle lifecycle;
	private final CreatedBy createdBy;
	private final List<BuildpackMetadata> buildpacks;
	BuilderMetadata(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.stack = valueAt('/stack', Stack.class);
		this.runImages = childrenAt('/images', RunImage::new);
		this.lifecycle = valueAt('/lifecycle', Lifecycle.class);
		this.createdBy = valueAt('/createdBy', CreatedBy.class);
		this.buildpacks = extractBuildpacks(getNode().at('/buildpacks'));
	}
	private List<BuildpackMetadata> extractBuildpacks(JsonNode node) {
		if (node.isEmpty()) {
			return Collections.emptyList();
		}
		List<BuildpackMetadata> entries = new ArrayList<>();
		node.forEach((child) -> entries.add(BuildpackMetadata.fromJson(child)));
		return entries;
	}
	/**
	 * Return stack metadata.
	 * @return the stack metadata
	 */
	Stack getStack() {
		return this.stack;
	}
	/**
	 * Return run images metadata.
	 * @return the run images metadata
	 */
	List<RunImage> getRunImages() {
		return this.runImages;
	}
	/**
	 * Return lifecycle metadata.
	 * @return the lifecycle metadata
	 */
	Lifecycle getLifecycle() {
		return this.lifecycle;
	}
	/**
	 * Return information about who created the builder.
	 * @return the created by metadata
	 */
	CreatedBy getCreatedBy() {
		return this.createdBy;
	}
	/**
	 * Return the buildpacks that are bundled in the builder.
	 * @return the buildpacks
	 */
	List<BuildpackMetadata> getBuildpacks() {
		return this.buildpacks;
	}
	/**
	 * Create an updated copy of this metadata.
	 * @param update consumer to apply updates
	 * @return an updated metadata instance
	 */
	BuilderMetadata copy(Consumer<Update> update) {
		return new Update(this).run(update);
	}
	/**
	 * Attach this metadata to the given update callback.
	 * @param update the update used to attach the metadata
	 */
	void attachTo(ImageConfig.Update update) {
		try {
			String json = SharedObjectMapper.get().writeValueAsString(getNode());
			update.withLabel(LABEL_NAME, json);
		}
		catch (JsonProcessingException ex) {
			throw new IllegalStateException(ex);
		}
	}
	/**
	 * Factory method to extract {@link BuilderMetadata} from an image.
	 * @param image the source image
	 * @return the builder metadata
	 * @throws IOException on IO error
	 */
	static BuilderMetadata fromImage(Image image) throws IOException {
		Assert.notNull(image, 'Image must not be null');
		return fromImageConfig(image.getConfig());
	}
	/**
	 * Factory method to extract {@link BuilderMetadata} from image config.
	 * @param imageConfig the image config
	 * @return the builder metadata
	 * @throws IOException on IO error
	 */
	static BuilderMetadata fromImageConfig(ImageConfig imageConfig) throws IOException {
		Assert.notNull(imageConfig, 'ImageConfig must not be null');
		String json = imageConfig.getLabels().get(LABEL_NAME);
		Assert.notNull(json, () -> 'No "' + LABEL_NAME + '" label found in image config labels "'
				+ StringUtils.collectionToCommaDelimitedString(imageConfig.getLabels().keySet()) + '"');
		return fromJson(json);
	}
	/**
	 * Factory method create {@link BuilderMetadata} from some JSON.
	 * @param json the source JSON
	 * @return the builder metadata
	 * @throws IOException on IO error
	 */
	static BuilderMetadata fromJson(String json) throws IOException {
		return new BuilderMetadata(SharedObjectMapper.get().readTree(json));
	}
	/**
	 * Stack metadata.
	 */
	interface Stack {
		/**
		 * Return run image metadata.
		 * @return the run image metadata
		 */
		RunImage getRunImage();
		/**
		 * Run image metadata.
		 */
		interface RunImage {
			/**
			 * Return the builder image reference.
			 * @return the image reference
			 */
			String getImage();
			/**
			 * Return stack mirrors.
			 * @return the stack mirrors
			 */
			default String[] getMirrors() {
				return EMPTY_MIRRORS;
			}
		}
	}
	static class RunImage extends MappedObject {
		private final String image;
		private final List<String> mirrors;
		/**
		 * Create a new {@link MappedObject} instance.
		 * @param node the source node
		 */
		RunImage(JsonNode node) {
			super(node, MethodHandles.lookup());
			this.image = valueAt('/image', String.class);
			this.mirrors = childrenAt('/mirrors', JsonNode::asText);
		}
		String getImage() {
			return this.image;
		}
		List<String> getMirrors() {
			return this.mirrors;
		}
	}
	/**
	 * Lifecycle metadata.
	 */
	interface Lifecycle {
		/**
		 * Return the lifecycle version.
		 * @return the lifecycle version
		 */
		String getVersion();
		/**
		 * Return the default API versions.
		 * @return the API versions
		 */
		Api getApi();
		/**
		 * Return the supported API versions.
		 * @return the API versions
		 */
		Apis getApis();
		/**
		 * Default API versions.
		 */
		interface Api {
			/**
			 * Return the default buildpack API version.
			 * @return the buildpack version
			 */
			String getBuildpack();
			/**
			 * Return the default platform API version.
			 * @return the platform version
			 */
			String getPlatform();
		}
		/**
		 * Supported API versions.
		 */
		interface Apis {
			/**
			 * Return the supported buildpack API versions.
			 * @return the buildpack versions
			 */
			default String[] getBuildpack() {
				return valueAt(this, '/buildpack/supported', String[].class);
			}
			/**
			 * Return the supported platform API versions.
			 * @return the platform versions
			 */
			default String[] getPlatform() {
				return valueAt(this, '/platform/supported', String[].class);
			}
		}
	}
	/**
	 * Created-by metadata.
	 */
	interface CreatedBy {
		/**
		 * Return the name of the creator.
		 * @return the creator name
		 */
		String getName();
		/**
		 * Return the version of the creator.
		 * @return the creator version
		 */
		String getVersion();
	}
	/**
	 * Update class used to change data when creating a copy.
	 */
	static final class Update {
		private final ObjectNode copy;
		private Update(BuilderMetadata source) {
			this.copy = source.getNode().deepCopy();
		}
		private BuilderMetadata run(Consumer<Update> update) {
			update.accept(this);
			return new BuilderMetadata(this.copy);
		}
		/**
		 * Update the builder meta-data with a specific created by section.
		 * @param name the name of the creator
		 * @param version the version of the creator
		 */
		void withCreatedBy(String name, String version) {
			ObjectNode createdBy = (ObjectNode) this.copy.at('/createdBy');
			if (createdBy == null) {
				createdBy = this.copy.putObject('createdBy');
			}
			createdBy.put('name', name);
			createdBy.put('version', version);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
enum ImageType {
	/**
	 * Builder image.
	 */
	BUILDER('builder image'),
	/**
	 * Run image.
	 */
	RUNNER('run image'),
	/**
	 * Buildpack image.
	 */
	BUILDPACK('buildpack image');
	private final String description;
	ImageType(String description) {
		this.description = description;
	}
	String getDescription() {
		return this.description;
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class BuildpackResolvers {
	private static final List<BuildpackResolver> resolvers = getResolvers();
	private BuildpackResolvers() {
	}
	private static List<BuildpackResolver> getResolvers() {
		List<BuildpackResolver> resolvers = new ArrayList<>();
		resolvers.add(BuilderBuildpack::resolve);
		resolvers.add(DirectoryBuildpack::resolve);
		resolvers.add(TarGzipBuildpack::resolve);
		resolvers.add(ImageBuildpack::resolve);
		return Collections.unmodifiableList(resolvers);
	}
	/**
	 * Resolve a collection of {@link BuildpackReference BuildpackReferences} to a
	 * {@link Buildpacks} instance.
	 * @param context the resolver context
	 * @param references the references to resolve
	 * @return a {@link Buildpacks} instance
	 */
	static Buildpacks resolveAll(BuildpackResolverContext context, Collection<BuildpackReference> references) {
		Assert.notNull(context, 'Context must not be null');
		if (CollectionUtils.isEmpty(references)) {
			return Buildpacks.EMPTY;
		}
		List<Buildpack> buildpacks = new ArrayList<>(references.size());
		for (BuildpackReference reference : references) {
			buildpacks.add(resolve(context, reference));
		}
		return Buildpacks.of(buildpacks);
	}
	private static Buildpack resolve(BuildpackResolverContext context, BuildpackReference reference) {
		Assert.notNull(reference, 'Reference must not be null');
		for (BuildpackResolver resolver : resolvers) {
			Buildpack buildpack = resolver.resolve(context, reference);
			if (buildpack != null) {
				return buildpack;
			}
		}
		throw new IllegalArgumentException('Invalid buildpack reference "' + reference + '"');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public class Cache {
	/**
	 * The format of the cache.
	 */
	public enum Format {
		/**
		 * A cache stored as a volume in the Docker daemon.
		 */
		VOLUME('volume'),
		/**
		 * A cache stored as a bind mount.
		 */
		BIND('bind mount');
		private final String description;
		Format(String description) {
			this.description = description;
		}
		public String getDescription() {
			return this.description;
		}
	}
	protected final Format format;
	Cache(Format format) {
		this.format = format;
	}
	/**
	 * Return the details of the cache if it is a volume cache.
	 * @return the cache, or {@code null} if it is not a volume cache
	 */
	public Volume getVolume() {
		return (this.format.equals(Format.VOLUME)) ? (Volume) this : null;
	}
	/**
	 * Return the details of the cache if it is a bind cache.
	 * @return the cache, or {@code null} if it is not a bind cache
	 */
	public Bind getBind() {
		return (this.format.equals(Format.BIND)) ? (Bind) this : null;
	}
	/**
	 * Create a new {@code Cache} that uses a volume with the provided name.
	 * @param name the cache volume name
	 * @return a new cache instance
	 */
	public static Cache volume(String name) {
		Assert.notNull(name, 'Name must not be null');
		return new Volume(VolumeName.of(name));
	}
	/**
	 * Create a new {@code Cache} that uses a volume with the provided name.
	 * @param name the cache volume name
	 * @return a new cache instance
	 */
	public static Cache volume(VolumeName name) {
		Assert.notNull(name, 'Name must not be null');
		return new Volume(name);
	}
	/**
	 * Create a new {@code Cache} that uses a bind mount with the provided source.
	 * @param source the cache bind mount source
	 * @return a new cache instance
	 */
	public static Cache bind(String source) {
		Assert.notNull(source, 'Source must not be null');
		return new Bind(source);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		Cache other = (Cache) obj;
		return Objects.equals(this.format, other.format);
	}
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHashCode(this.format);
	}
	/**
	 * Details of a cache stored in a Docker volume.
	 */
	public static class Volume extends Cache {
		private final VolumeName name;
		Volume(VolumeName name) {
			super(Format.VOLUME);
			this.name = name;
		}
		public String getName() {
			return this.name.toString();
		}
		public VolumeName getVolumeName() {
			return this.name;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			if (!super.equals(obj)) {
				return false;
			}
			Volume other = (Volume) obj;
			return Objects.equals(this.name, other.name);
		}
		@Override
		public int hashCode() {
			int result = super.hashCode();
			result = 31 * result + ObjectUtils.nullSafeHashCode(this.name);
			return result;
		}
		@Override
		public String toString() {
			return this.format.getDescription() + ' "' + this.name + '"';
		}
	}
	/**
	 * Details of a cache stored in a bind mount.
	 */
	public static class Bind extends Cache {
		private final String source;
		Bind(String source) {
			super(Format.BIND);
			this.source = source;
		}
		public String getSource() {
			return this.source;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			if (!super.equals(obj)) {
				return false;
			}
			Bind other = (Bind) obj;
			return Objects.equals(this.source, other.source);
		}
		@Override
		public int hashCode() {
			int result = super.hashCode();
			result = 31 * result + ObjectUtils.nullSafeHashCode(this.source);
			return result;
		}
		@Override
		public String toString() {
			return this.format.getDescription() + ' "' + this.source + '"';
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class BuildpackCoordinates {
	private final String id;
	private final String version;
	private BuildpackCoordinates(String id, String version) {
		Assert.hasText(id, 'ID must not be empty');
		this.id = id;
		this.version = version;
	}
	String getId() {
		return this.id;
	}
	/**
	 * Return the buildpack ID with all '/' replaced by '_'.
	 * @return the ID
	 */
	String getSanitizedId() {
		return this.id.replace('/', '_');
	}
	String getVersion() {
		return this.version;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		BuildpackCoordinates other = (BuildpackCoordinates) obj;
		return this.id.equals(other.id) && ObjectUtils.nullSafeEquals(this.version, other.version);
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.id.hashCode();
		result = prime * result + ObjectUtils.nullSafeHashCode(this.version);
		return result;
	}
	@Override
	public String toString() {
		return this.id + ((StringUtils.hasText(this.version)) ? '@' + this.version : '');
	}
	/**
	 * Create {@link BuildpackCoordinates} from a <a href=
	 * 'https://github.com/buildpacks/spec/blob/main/buildpack.md#buildpacktoml-toml'>{@code buildpack.toml}</a>
	 * file.
	 * @param inputStream an input stream containing {@code buildpack.toml} content
	 * @param path the path to the buildpack containing the {@code buildpack.toml} file
	 * @return a new {@link BuildpackCoordinates} instance
	 * @throws IOException on IO error
	 */
	static BuildpackCoordinates fromToml(InputStream inputStream, Path path) throws IOException {
		return fromToml(Toml.parse(inputStream), path);
	}
	private static BuildpackCoordinates fromToml(TomlParseResult toml, Path path) {
		Assert.isTrue(!toml.isEmpty(),
				() -> 'Buildpack descriptor "buildpack.toml" is required in buildpack "' + path + '"');
		Assert.hasText(toml.getString('buildpack.id'),
				() -> 'Buildpack descriptor must contain ID in buildpack "' + path + '"');
		Assert.hasText(toml.getString('buildpack.version'),
				() -> 'Buildpack descriptor must contain version in buildpack "' + path + '"');
		Assert.isTrue(toml.contains('stacks') || toml.contains('order'),
				() -> 'Buildpack descriptor must contain either "stacks" or "order" in buildpack "' + path + '"');
		Assert.isTrue(!(toml.contains('stacks') && toml.contains('order')),
				() -> 'Buildpack descriptor must not contain both "stacks" and "order" in buildpack "' + path + '"');
		return new BuildpackCoordinates(toml.getString('buildpack.id'), toml.getString('buildpack.version'));
	}
	/**
	 * Create {@link BuildpackCoordinates} by extracting values from
	 * {@link BuildpackMetadata}.
	 * @param buildpackMetadata the buildpack metadata
	 * @return a new {@link BuildpackCoordinates} instance
	 */
	static BuildpackCoordinates fromBuildpackMetadata(BuildpackMetadata buildpackMetadata) {
		Assert.notNull(buildpackMetadata, 'BuildpackMetadata must not be null');
		return new BuildpackCoordinates(buildpackMetadata.getId(), buildpackMetadata.getVersion());
	}
	/**
	 * Create {@link BuildpackCoordinates} from an ID and version.
	 * @param id the buildpack ID
	 * @param version the buildpack version
	 * @return a new {@link BuildpackCoordinates} instance
	 */
	static BuildpackCoordinates of(String id, String version) {
		return new BuildpackCoordinates(id, version);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuilderBuildpack implements Buildpack {
	private static final String PREFIX = 'urn:cnb:builder:';
	private final BuildpackCoordinates coordinates;
	BuilderBuildpack(BuildpackMetadata buildpackMetadata) {
		this.coordinates = BuildpackCoordinates.fromBuildpackMetadata(buildpackMetadata);
	}
	@Override
	public BuildpackCoordinates getCoordinates() {
		return this.coordinates;
	}
	@Override
	public void apply(IOConsumer<Layer> layers) throws IOException {
	}
	/**
	 * A {@link BuildpackResolver} compatible method to resolve builder buildpacks.
	 * @param context the resolver context
	 * @param reference the buildpack reference
	 * @return the resolved {@link Buildpack} or {@code null}
	 */
	static Buildpack resolve(BuildpackResolverContext context, BuildpackReference reference) {
		boolean unambiguous = reference.hasPrefix(PREFIX);
		BuilderReference builderReference = BuilderReference
			.of(unambiguous ? reference.getSubReference(PREFIX) : reference.toString());
		BuildpackMetadata buildpackMetadata = findBuildpackMetadata(context, builderReference);
		if (unambiguous) {
			Assert.isTrue(buildpackMetadata != null, () -> 'Buildpack "' + reference + '" not found in builder');
		}
		return (buildpackMetadata != null) ? new BuilderBuildpack(buildpackMetadata) : null;
	}
	private static BuildpackMetadata findBuildpackMetadata(BuildpackResolverContext context,
			BuilderReference builderReference) {
		for (BuildpackMetadata candidate : context.getBuildpackMetadata()) {
			if (builderReference.matches(candidate)) {
				return candidate;
			}
		}
		return null;
	}
	/**
	 * A reference to a buildpack builder.
	 */
	static class BuilderReference {
		private final String id;
		private final String version;
		BuilderReference(String id, String version) {
			this.id = id;
			this.version = version;
		}
		@Override
		public String toString() {
			return (this.version != null) ? this.id + '@' + this.version : this.id;
		}
		boolean matches(BuildpackMetadata candidate) {
			return this.id.equals(candidate.getId())
					&& (this.version == null || this.version.equals(candidate.getVersion()));
		}
		static BuilderReference of(String value) {
			if (value.contains('@')) {
				String[] parts = value.split('@');
				return new BuilderReference(parts[0], parts[1]);
			}
			return new BuilderReference(value, null);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public class BuildRequest {
	static final String DEFAULT_BUILDER_IMAGE_NAME = 'paketobuildpacks/builder-jammy-java-tiny';
	static final String DEFAULT_BUILDER_IMAGE_REF = DEFAULT_BUILDER_IMAGE_NAME + ':latest';
	static final List<ImageReference> KNOWN_TRUSTED_BUILDERS = List.of(
			ImageReference.of('paketobuildpacks/builder-noble-java-tiny'),
			ImageReference.of('paketobuildpacks/builder-jammy-java-tiny'),
			ImageReference.of('paketobuildpacks/builder-jammy-tiny'),
			ImageReference.of('paketobuildpacks/builder-jammy-base'),
			ImageReference.of('paketobuildpacks/builder-jammy-full'),
			ImageReference.of('paketobuildpacks/builder-jammy-buildpackless-tiny'),
			ImageReference.of('paketobuildpacks/builder-jammy-buildpackless-base'),
			ImageReference.of('paketobuildpacks/builder-jammy-buildpackless-full'),
			ImageReference.of('gcr.io/buildpacks/builder'), ImageReference.of('heroku/builder'));
	private static final ImageReference DEFAULT_BUILDER = ImageReference.of(DEFAULT_BUILDER_IMAGE_REF);
	private final ImageReference name;
	private final Function<Owner, TarArchive> applicationContent;
	private final ImageReference builder;
	private final Boolean trustBuilder;
	private final ImageReference runImage;
	private final Creator creator;
	private final Map<String, String> env;
	private final boolean cleanCache;
	private final boolean verboseLogging;
	private final PullPolicy pullPolicy;
	private final boolean publish;
	private final List<BuildpackReference> buildpacks;
	private final List<Binding> bindings;
	private final String network;
	private final List<ImageReference> tags;
	private final Cache buildWorkspace;
	private final Cache buildCache;
	private final Cache launchCache;
	private final Instant createdDate;
	private final String applicationDirectory;
	private final List<String> securityOptions;
	private final ImagePlatform platform;
	BuildRequest(ImageReference name, Function<Owner, TarArchive> applicationContent) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(applicationContent, 'ApplicationContent must not be null');
		this.name = name.inTaggedForm();
		this.applicationContent = applicationContent;
		this.builder = DEFAULT_BUILDER;
		this.trustBuilder = null;
		this.runImage = null;
		this.env = Collections.emptyMap();
		this.cleanCache = false;
		this.verboseLogging = false;
		this.pullPolicy = PullPolicy.ALWAYS;
		this.publish = false;
		this.creator = Creator.withVersion('');
		this.buildpacks = Collections.emptyList();
		this.bindings = Collections.emptyList();
		this.network = null;
		this.tags = Collections.emptyList();
		this.buildWorkspace = null;
		this.buildCache = null;
		this.launchCache = null;
		this.createdDate = null;
		this.applicationDirectory = null;
		this.securityOptions = null;
		this.platform = null;
	}
	BuildRequest(ImageReference name, Function<Owner, TarArchive> applicationContent, ImageReference builder,
			Boolean trustBuilder, ImageReference runImage, Creator creator, Map<String, String> env, boolean cleanCache,
			boolean verboseLogging, PullPolicy pullPolicy, boolean publish, List<BuildpackReference> buildpacks,
			List<Binding> bindings, String network, List<ImageReference> tags, Cache buildWorkspace, Cache buildCache,
			Cache launchCache, Instant createdDate, String applicationDirectory, List<String> securityOptions,
			ImagePlatform platform) {
		this.name = name;
		this.applicationContent = applicationContent;
		this.builder = builder;
		this.trustBuilder = trustBuilder;
		this.runImage = runImage;
		this.creator = creator;
		this.env = env;
		this.cleanCache = cleanCache;
		this.verboseLogging = verboseLogging;
		this.pullPolicy = pullPolicy;
		this.publish = publish;
		this.buildpacks = buildpacks;
		this.bindings = bindings;
		this.network = network;
		this.tags = tags;
		this.buildWorkspace = buildWorkspace;
		this.buildCache = buildCache;
		this.launchCache = launchCache;
		this.createdDate = createdDate;
		this.applicationDirectory = applicationDirectory;
		this.securityOptions = securityOptions;
		this.platform = platform;
	}
	/**
	 * Return a new {@link BuildRequest} with an updated builder.
	 * @param builder the new builder to use
	 * @return an updated build request
	 */
	public BuildRequest withBuilder(ImageReference builder) {
		Assert.notNull(builder, 'Builder must not be null');
		return new BuildRequest(this.name, this.applicationContent, builder.inTaggedOrDigestForm(), this.trustBuilder,
				this.runImage, this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy,
				this.publish, this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace,
				this.buildCache, this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions,
				this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated trust builder setting.
	 * @param trustBuilder {@code true} if the builder should be treated as trusted,
	 * {@code false} otherwise
	 * @return an updated build request
	 * @since 3.4.0
	 */
	public BuildRequest withTrustBuilder(boolean trustBuilder) {
		return new BuildRequest(this.name, this.applicationContent, this.builder, trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated run image.
	 * @param runImageName the run image to use
	 * @return an updated build request
	 */
	public BuildRequest withRunImage(ImageReference runImageName) {
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder,
				runImageName.inTaggedOrDigestForm(), this.creator, this.env, this.cleanCache, this.verboseLogging,
				this.pullPolicy, this.publish, this.buildpacks, this.bindings, this.network, this.tags,
				this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, this.applicationDirectory,
				this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated creator.
	 * @param creator the new {@code Creator} to use
	 * @return an updated build request
	 */
	public BuildRequest withCreator(Creator creator) {
		Assert.notNull(creator, 'Creator must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks,
				this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache,
				this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an additional env variable.
	 * @param name the variable name
	 * @param value the variable value
	 * @return an updated build request
	 */
	public BuildRequest withEnv(String name, String value) {
		Assert.hasText(name, 'Name must not be empty');
		Assert.hasText(value, 'Value must not be empty');
		Map<String, String> env = new LinkedHashMap<>(this.env);
		env.put(name, value);
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, Collections.unmodifiableMap(env), this.cleanCache, this.verboseLogging, this.pullPolicy,
				this.publish, this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace,
				this.buildCache, this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions,
				this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with additional env variables.
	 * @param env the additional variables
	 * @return an updated build request
	 */
	public BuildRequest withEnv(Map<String, String> env) {
		Assert.notNull(env, 'Env must not be null');
		Map<String, String> updatedEnv = new LinkedHashMap<>(this.env);
		updatedEnv.putAll(env);
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, Collections.unmodifiableMap(updatedEnv), this.cleanCache, this.verboseLogging,
				this.pullPolicy, this.publish, this.buildpacks, this.bindings, this.network, this.tags,
				this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, this.applicationDirectory,
				this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated clean cache setting.
	 * @param cleanCache if the cache should be cleaned
	 * @return an updated build request
	 */
	public BuildRequest withCleanCache(boolean cleanCache) {
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks,
				this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache,
				this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated verbose logging setting.
	 * @param verboseLogging if verbose logging should be used
	 * @return an updated build request
	 */
	public BuildRequest withVerboseLogging(boolean verboseLogging) {
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, verboseLogging, this.pullPolicy, this.publish, this.buildpacks,
				this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache,
				this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with the updated image pull policy.
	 * @param pullPolicy image pull policy {@link PullPolicy}
	 * @return an updated build request
	 */
	public BuildRequest withPullPolicy(PullPolicy pullPolicy) {
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, pullPolicy, this.publish, this.buildpacks,
				this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache,
				this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated publish setting.
	 * @param publish if the built image should be pushed to a registry
	 * @return an updated build request
	 */
	public BuildRequest withPublish(boolean publish) {
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, publish, this.buildpacks,
				this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache,
				this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated buildpacks setting.
	 * @param buildpacks a collection of buildpacks to use when building the image
	 * @return an updated build request
	 * @since 2.5.0
	 */
	public BuildRequest withBuildpacks(BuildpackReference... buildpacks) {
		Assert.notEmpty(buildpacks, 'Buildpacks must not be empty');
		return withBuildpacks(Arrays.asList(buildpacks));
	}
	/**
	 * Return a new {@link BuildRequest} with an updated buildpacks setting.
	 * @param buildpacks a collection of buildpacks to use when building the image
	 * @return an updated build request
	 * @since 2.5.0
	 */
	public BuildRequest withBuildpacks(List<BuildpackReference> buildpacks) {
		Assert.notNull(buildpacks, 'Buildpacks must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, buildpacks,
				this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache,
				this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with updated bindings.
	 * @param bindings a collection of bindings to mount to the build container
	 * @return an updated build request
	 * @since 2.5.0
	 */
	public BuildRequest withBindings(Binding... bindings) {
		Assert.notEmpty(bindings, 'Bindings must not be empty');
		return withBindings(Arrays.asList(bindings));
	}
	/**
	 * Return a new {@link BuildRequest} with updated bindings.
	 * @param bindings a collection of bindings to mount to the build container
	 * @return an updated build request
	 * @since 2.5.0
	 */
	public BuildRequest withBindings(List<Binding> bindings) {
		Assert.notNull(bindings, 'Bindings must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, bindings, this.network, this.tags, this.buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated network setting.
	 * @param network the network the build container will connect to
	 * @return an updated build request
	 * @since 2.6.0
	 */
	public BuildRequest withNetwork(String network) {
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, network, this.tags, this.buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with updated tags.
	 * @param tags a collection of tags to be created for the built image
	 * @return an updated build request
	 */
	public BuildRequest withTags(ImageReference... tags) {
		Assert.notEmpty(tags, 'Tags must not be empty');
		return withTags(Arrays.asList(tags));
	}
	/**
	 * Return a new {@link BuildRequest} with updated tags.
	 * @param tags a collection of tags to be created for the built image
	 * @return an updated build request
	 */
	public BuildRequest withTags(List<ImageReference> tags) {
		Assert.notNull(tags, 'Tags must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, tags, this.buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated build workspace.
	 * @param buildWorkspace the build workspace
	 * @return an updated build request
	 * @since 3.2.0
	 */
	public BuildRequest withBuildWorkspace(Cache buildWorkspace) {
		Assert.notNull(buildWorkspace, 'BuildWorkspace must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated build cache.
	 * @param buildCache the build cache
	 * @return an updated build request
	 */
	public BuildRequest withBuildCache(Cache buildCache) {
		Assert.notNull(buildCache, 'BuildCache must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated launch cache.
	 * @param launchCache the cache
	 * @return an updated build request
	 */
	public BuildRequest withLaunchCache(Cache launchCache) {
		Assert.notNull(launchCache, 'LaunchCache must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache,
				launchCache, this.createdDate, this.applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated created date.
	 * @param createdDate the created date
	 * @return an updated build request
	 */
	public BuildRequest withCreatedDate(String createdDate) {
		Assert.notNull(createdDate, 'CreatedDate must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache,
				this.launchCache, parseCreatedDate(createdDate), this.applicationDirectory, this.securityOptions,
				this.platform);
	}
	private Instant parseCreatedDate(String createdDate) {
		if ('now'.equalsIgnoreCase(createdDate)) {
			return Instant.now();
		}
		try {
			return Instant.parse(createdDate);
		}
		catch (DateTimeParseException ex) {
			throw new IllegalArgumentException('Error parsing "' + createdDate + '" as an image created date', ex);
		}
	}
	/**
	 * Return a new {@link BuildRequest} with an updated application directory.
	 * @param applicationDirectory the application directory
	 * @return an updated build request
	 */
	public BuildRequest withApplicationDirectory(String applicationDirectory) {
		Assert.notNull(applicationDirectory, 'ApplicationDirectory must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, applicationDirectory, this.securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated security options.
	 * @param securityOptions the security options
	 * @return an updated build request
	 * @since 3.2.0
	 */
	public BuildRequest withSecurityOptions(List<String> securityOptions) {
		Assert.notNull(securityOptions, 'SecurityOption must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, securityOptions, this.platform);
	}
	/**
	 * Return a new {@link BuildRequest} with an updated image platform.
	 * @param platform the image platform
	 * @return an updated build request
	 * @since 3.4.0
	 */
	public BuildRequest withImagePlatform(String platform) {
		Assert.notNull(platform, 'Platform must not be null');
		return new BuildRequest(this.name, this.applicationContent, this.builder, this.trustBuilder, this.runImage,
				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish,
				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache,
				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions,
				ImagePlatform.of(platform));
	}
	/**
	 * Return the name of the image that should be created.
	 * @return the name of the image
	 */
	public ImageReference getName() {
		return this.name;
	}
	/**
	 * Return a {@link TarArchive} containing the application content that the buildpack
	 * should package. This is typically the contents of the Jar.
	 * @param owner the owner of the tar entries
	 * @return the application content
	 * @see TarArchive#fromZip(File, Owner)
	 */
	public TarArchive getApplicationContent(Owner owner) {
		return this.applicationContent.apply(owner);
	}
	/**
	 * Return the builder that should be used.
	 * @return the builder to use
	 */
	public ImageReference getBuilder() {
		return this.builder;
	}
	/**
	 * Return whether the builder should be treated as trusted.
	 * @return the trust builder flag
	 * @since 3.4.0
	 */
	public boolean isTrustBuilder() {
		return (this.trustBuilder != null) ? this.trustBuilder : isBuilderKnownAndTrusted();
	}
	private boolean isBuilderKnownAndTrusted() {
		return KNOWN_TRUSTED_BUILDERS.stream().anyMatch((builder) -> builder.getName().equals(this.builder.getName()));
	}
	/**
	 * Return the run image that should be used, if provided.
	 * @return the run image
	 */
	public ImageReference getRunImage() {
		return this.runImage;
	}
	/**
	 * Return the {@link Creator} the builder should use.
	 * @return the {@code Creator}
	 */
	public Creator getCreator() {
		return this.creator;
	}
	/**
	 * Return any env variable that should be passed to the builder.
	 * @return the builder env
	 */
	public Map<String, String> getEnv() {
		return this.env;
	}
	/**
	 * Return if caches should be cleaned before packaging.
	 * @return if caches should be cleaned
	 */
	public boolean isCleanCache() {
		return this.cleanCache;
	}
	/**
	 * Return if verbose logging output should be used.
	 * @return if verbose logging should be used
	 */
	public boolean isVerboseLogging() {
		return this.verboseLogging;
	}
	/**
	 * Return if the built image should be pushed to a registry.
	 * @return if the built image should be pushed to a registry
	 */
	public boolean isPublish() {
		return this.publish;
	}
	/**
	 * Return the image {@link PullPolicy} that the builder should use.
	 * @return image pull policy
	 */
	public PullPolicy getPullPolicy() {
		return this.pullPolicy;
	}
	/**
	 * Return the collection of buildpacks to use when building the image, if provided.
	 * @return the buildpacks
	 */
	public List<BuildpackReference> getBuildpacks() {
		return this.buildpacks;
	}
	/**
	 * Return the collection of bindings to mount to the build container.
	 * @return the bindings
	 * @since 2.5.0
	 */
	public List<Binding> getBindings() {
		return this.bindings;
	}
	/**
	 * Return the network the build container will connect to.
	 * @return the network
	 * @since 2.6.0
	 */
	public String getNetwork() {
		return this.network;
	}
	/**
	 * Return the collection of tags that should be created.
	 * @return the tags
	 */
	public List<ImageReference> getTags() {
		return this.tags;
	}
	/**
	 * Return the build workspace that should be used by the lifecycle.
	 * @return the build workspace or {@code null}
	 * @since 3.2.0
	 */
	public Cache getBuildWorkspace() {
		return this.buildWorkspace;
	}
	/**
	 * Return the custom build cache that should be used by the lifecycle.
	 * @return the build cache
	 */
	public Cache getBuildCache() {
		return this.buildCache;
	}
	/**
	 * Return the custom launch cache that should be used by the lifecycle.
	 * @return the launch cache
	 */
	public Cache getLaunchCache() {
		return this.launchCache;
	}
	/**
	 * Return the custom created date that should be used by the lifecycle.
	 * @return the created date
	 */
	public Instant getCreatedDate() {
		return this.createdDate;
	}
	/**
	 * Return the application directory that should be used by the lifecycle.
	 * @return the application directory
	 */
	public String getApplicationDirectory() {
		return this.applicationDirectory;
	}
	/**
	 * Return the security options that should be used by the lifecycle.
	 * @return the security options or {@code null}
	 * @since 3.2.0
	 */
	public List<String> getSecurityOptions() {
		return this.securityOptions;
	}
	/**
	 * Return the platform that should be used when pulling images.
	 * @return the platform or {@code null}
	 * @since 3.4.0
	 */
	public ImagePlatform getImagePlatform() {
		return this.platform;
	}
	/**
	 * Factory method to create a new {@link BuildRequest} from a JAR file.
	 * @param jarFile the source jar file
	 * @return a new build request instance
	 */
	public static BuildRequest forJarFile(File jarFile) {
		assertJarFile(jarFile);
		return forJarFile(ImageReference.forJarFile(jarFile).inTaggedForm(), jarFile);
	}
	/**
	 * Factory method to create a new {@link BuildRequest} from a JAR file.
	 * @param name the name of the image that should be created
	 * @param jarFile the source jar file
	 * @return a new build request instance
	 */
	public static BuildRequest forJarFile(ImageReference name, File jarFile) {
		assertJarFile(jarFile);
		return new BuildRequest(name, (owner) -> TarArchive.fromZip(jarFile, owner));
	}
	/**
	 * Factory method to create a new {@link BuildRequest} with specific content.
	 * @param name the name of the image that should be created
	 * @param applicationContent function to provide the application content
	 * @return a new build request instance
	 */
	public static BuildRequest of(ImageReference name, Function<Owner, TarArchive> applicationContent) {
		return new BuildRequest(name, applicationContent);
	}
	private static void assertJarFile(File jarFile) {
		Assert.notNull(jarFile, 'JarFile must not be null');
		Assert.isTrue(jarFile.exists(), 'JarFile must exist');
		Assert.isTrue(jarFile.isFile(), 'JarFile must be a file');
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public abstract class AbstractBuildLog implements BuildLog {
	@Override
	public void start(BuildRequest request) {
		log('Building image "' + request.getName() + '"');
		log();
	}
	@Override
	public Consumer<TotalProgressEvent> pullingImage(ImageReference imageReference, ImagePlatform platform,
			ImageType imageType) {
		return (platform != null)
				? getProgressConsumer(' > Pulling %s "%s" for platform "%s"'.formatted(imageType.getDescription(),
						imageReference, platform))
				: getProgressConsumer(' > Pulling %s "%s"'.formatted(imageType.getDescription(), imageReference));
	}
	@Override
	public void pulledImage(Image image, ImageType imageType) {
		log(String.format(' > Pulled %s "%s"', imageType.getDescription(), getDigest(image)));
	}
	@Override
	public Consumer<TotalProgressEvent> pushingImage(ImageReference imageReference) {
		return getProgressConsumer(String.format(' > Pushing image "%s"', imageReference));
	}
	@Override
	public void pushedImage(ImageReference imageReference) {
		log(String.format(' > Pushed image "%s"', imageReference));
	}
	@Override
	public void executingLifecycle(BuildRequest request, LifecycleVersion version, VolumeName buildCacheVolume) {
		log(' > Executing lifecycle version ' + version);
		log(' > Using build cache volume "' + buildCacheVolume + '"');
	}
	@Override
	public void executingLifecycle(BuildRequest request, LifecycleVersion version, Cache buildCache) {
		log(' > Executing lifecycle version ' + version);
		log(' > Using build cache ' + buildCache);
	}
	@Override
	public Consumer<LogUpdateEvent> runningPhase(BuildRequest request, String name) {
		log();
		log(' > Running ' + name);
		String prefix = String.format('    %-14s', '[' + name + '] ');
		return (event) -> log(prefix + event);
	}
	@Override
	public void skippingPhase(String name, String reason) {
		log();
		log(' > Skipping ' + name + ' ' + reason);
		log();
	}
	@Override
	public void executedLifecycle(BuildRequest request) {
		log();
		log('Successfully built image "' + request.getName() + '"');
		log();
	}
	@Override
	public void taggedImage(ImageReference tag) {
		log('Successfully created image tag "' + tag + '"');
		log();
	}
	@Override
	public void failedCleaningWorkDir(Cache cache, Exception exception) {
		StringBuilder message = new StringBuilder('Warning: Working location ' + cache + ' could not be cleaned');
		if (exception != null) {
			message.append(': ').append(exception.getMessage());
		}
		log();
		log(message.toString());
		log();
	}
	@Override
	public void sensitiveTargetBindingDetected(Binding binding) {
		log('Warning: Binding "%s" uses a container path which is used by buildpacks while building. Binding to it can cause problems!'
			.formatted(binding));
		log();
	}
	private String getDigest(Image image) {
		List<String> digests = image.getDigests();
		return (digests.isEmpty() ? '' : digests.get(0));
	}
	protected void log() {
		log('');
	}
	protected abstract void log(String message);
	protected abstract Consumer<TotalProgressEvent> getProgressConsumer(String message);
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class LifecycleVersion implements Comparable<LifecycleVersion> {
	private static final Comparator<LifecycleVersion> COMPARATOR = Comparator.comparingInt(LifecycleVersion::getMajor)
		.thenComparingInt(LifecycleVersion::getMinor)
		.thenComparing(LifecycleVersion::getPatch);
	private final int major;
	private final int minor;
	private final int patch;
	LifecycleVersion(int major, int minor, int patch) {
		this.major = major;
		this.minor = minor;
		this.patch = patch;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		LifecycleVersion other = (LifecycleVersion) obj;
		boolean result = true;
		result = result && this.major == other.major;
		result = result && this.minor == other.minor;
		result = result && this.patch == other.patch;
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.major;
		result = prime * result + this.minor;
		result = prime * result + this.patch;
		return result;
	}
	@Override
	public String toString() {
		return 'v' + this.major + '.' + this.minor + '.' + this.patch;
	}
	/**
	 * Return if this version is greater than or equal to the specified version.
	 * @param other the version to compare
	 * @return {@code true} if this version is greater than or equal to the specified
	 * version
	 */
	boolean isEqualOrGreaterThan(LifecycleVersion other) {
		return compareTo(other) >= 0;
	}
	@Override
	public int compareTo(LifecycleVersion other) {
		return COMPARATOR.compare(this, other);
	}
	/**
	 * Return the major version number.
	 * @return the major version
	 */
	int getMajor() {
		return this.major;
	}
	/**
	 * Return the minor version number.
	 * @return the minor version
	 */
	int getMinor() {
		return this.minor;
	}
	/**
	 * Return the patch version number.
	 * @return the patch version
	 */
	int getPatch() {
		return this.patch;
	}
	/**
	 * Factory method to parse a string into a {@link LifecycleVersion} instance.
	 * @param value the value to parse.
	 * @return the corresponding {@link LifecycleVersion}
	 * @throws IllegalArgumentException if the value could not be parsed
	 */
	static LifecycleVersion parse(String value) {
		Assert.hasText(value, 'Value must not be empty');
		if (value.startsWith('v') || value.startsWith('V')) {
			value = value.substring(1);
		}
		String[] components = value.split('\\.');
		Assert.isTrue(components.length <= 3, 'Malformed version number "' + value + '"');
		int[] versions = new int[3];
		for (int i = 0; i < components.length; i++) {
			try {
				versions[i] = Integer.parseInt(components[i]);
			}
			catch (NumberFormatException ex) {
				throw new IllegalArgumentException('Malformed version number "' + value + '"', ex);
			}
		}
		return new LifecycleVersion(versions[0], versions[1], versions[2]);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class BuildOwner implements Owner {
	private static final String USER_PROPERTY_NAME = 'CNB_USER_ID';
	private static final String GROUP_PROPERTY_NAME = 'CNB_GROUP_ID';
	private final long uid;
	private final long gid;
	BuildOwner(Map<String, String> env) {
		this.uid = getValue(env, USER_PROPERTY_NAME);
		this.gid = getValue(env, GROUP_PROPERTY_NAME);
	}
	BuildOwner(long uid, long gid) {
		this.uid = uid;
		this.gid = gid;
	}
	private long getValue(Map<String, String> env, String name) {
		String value = env.get(name);
		Assert.state(StringUtils.hasText(value),
				() -> 'Missing "' + name + '" value from the builder environment "' + env + '"');
		try {
			return Long.parseLong(value);
		}
		catch (NumberFormatException ex) {
			throw new IllegalStateException(
					'Malformed "' + name + '" value "' + value + '" in the builder environment "' + env + '"', ex);
		}
	}
	@Override
	public long getUid() {
		return this.uid;
	}
	@Override
	public long getGid() {
		return this.gid;
	}
	@Override
	public String toString() {
		return this.uid + '/' + this.gid;
	}
	/**
	 * Factory method to create the {@link BuildOwner} by inspecting the image env for
	 * {@code CNB_USER_ID}/{@code CNB_GROUP_ID} variables.
	 * @param env the env to parse
	 * @return a {@link BuildOwner} instance extracted from the env
	 * @throws IllegalStateException if the env does not contain the correct CNB variables
	 */
	static BuildOwner fromEnv(Map<String, String> env) {
		Assert.notNull(env, 'Env must not be null');
		return new BuildOwner(env);
	}
	/**
	 * Factory method to create a new {@link BuildOwner} with specified user/group
	 * identifier.
	 * @param uid the user identifier
	 * @param gid the group identifier
	 * @return a new {@link BuildOwner} instance
	 */
	static BuildOwner of(long uid, long gid) {
		return new BuildOwner(uid, gid);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public class BuilderException extends RuntimeException {
	private final String operation;
	private final int statusCode;
	BuilderException(String operation, int statusCode) {
		super(buildMessage(operation, statusCode));
		this.operation = operation;
		this.statusCode = statusCode;
	}
	/**
	 * Return the Builder operation that failed.
	 * @return the operation description
	 */
	public String getOperation() {
		return this.operation;
	}
	/**
	 * Return the status code returned from a Builder operation.
	 * @return the statusCode the status code
	 */
	public int getStatusCode() {
		return this.statusCode;
	}
	private static String buildMessage(String operation, int statusCode) {
		StringBuilder message = new StringBuilder('Builder');
		if (StringUtils.hasLength(operation)) {
			message.append(' lifecycle "').append(operation).append('"');
		}
		message.append(' failed with status code ').append(statusCode);
		return message.toString();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public final class BuildpackReference {
	private final String value;
	private BuildpackReference(String value) {
		this.value = value;
	}
	boolean hasPrefix(String prefix) {
		return this.value.startsWith(prefix);
	}
	String getSubReference(String prefix) {
		return this.value.startsWith(prefix) ? this.value.substring(prefix.length()) : null;
	}
	Path asPath() {
		try {
			URL url = new URL(this.value);
			if (url.getProtocol().equals('file')) {
				return Paths.get(url.toURI());
			}
			return null;
		}
		catch (MalformedURLException | URISyntaxException ex) {
			// not a URL, fall through to attempting to find a plain file path
		}
		try {
			return Paths.get(this.value);
		}
		catch (Exception ex) {
			return null;
		}
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.value.equals(((BuildpackReference) obj).value);
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Create a new {@link BuildpackReference} from the given value.
	 * @param value the value to use
	 * @return a new {@link BuildpackReference}
	 */
	public static BuildpackReference of(String value) {
		Assert.hasText(value, 'Value must not be empty');
		return new BuildpackReference(value);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public class Builder {
	private final BuildLog log;
	private final DockerApi docker;
	private final DockerConfiguration dockerConfiguration;
	/**
	 * Create a new builder instance.
	 */
	public Builder() {
		this(BuildLog.toSystemOut());
	}
	/**
	 * Create a new builder instance.
	 * @param dockerConfiguration the docker configuration
	 * @since 2.4.0
	 */
	public Builder(DockerConfiguration dockerConfiguration) {
		this(BuildLog.toSystemOut(), dockerConfiguration);
	}
	/**
	 * Create a new builder instance.
	 * @param log a logger used to record output
	 */
	public Builder(BuildLog log) {
		this(log, new DockerApi(), null);
	}
	/**
	 * Create a new builder instance.
	 * @param log a logger used to record output
	 * @param dockerConfiguration the docker configuration
	 * @since 2.4.0
	 */
	public Builder(BuildLog log, DockerConfiguration dockerConfiguration) {
		this(log, new DockerApi((dockerConfiguration != null) ? dockerConfiguration.getHost() : null),
				dockerConfiguration);
	}
	Builder(BuildLog log, DockerApi docker, DockerConfiguration dockerConfiguration) {
		Assert.notNull(log, 'Log must not be null');
		this.log = log;
		this.docker = docker;
		this.dockerConfiguration = dockerConfiguration;
	}
	public void build(BuildRequest request) throws DockerEngineException, IOException {
		Assert.notNull(request, 'Request must not be null');
		this.log.start(request);
		validateBindings(request.getBindings());
		String domain = request.getBuilder().getDomain();
		PullPolicy pullPolicy = request.getPullPolicy();
		ImageFetcher imageFetcher = new ImageFetcher(domain, getBuilderAuthHeader(), pullPolicy,
				request.getImagePlatform());
		Image builderImage = imageFetcher.fetchImage(ImageType.BUILDER, request.getBuilder());
		BuilderMetadata builderMetadata = BuilderMetadata.fromImage(builderImage);
		request = withRunImageIfNeeded(request, builderMetadata);
		Image runImage = imageFetcher.fetchImage(ImageType.RUNNER, request.getRunImage());
		assertStackIdsMatch(runImage, builderImage);
		BuildOwner buildOwner = BuildOwner.fromEnv(builderImage.getConfig().getEnv());
		BuildpackLayersMetadata buildpackLayersMetadata = BuildpackLayersMetadata.fromImage(builderImage);
		Buildpacks buildpacks = getBuildpacks(request, imageFetcher, builderMetadata, buildpackLayersMetadata);
		EphemeralBuilder ephemeralBuilder = new EphemeralBuilder(buildOwner, builderImage, request.getName(),
				builderMetadata, request.getCreator(), request.getEnv(), buildpacks);
		this.docker.image().load(ephemeralBuilder.getArchive(), UpdateListener.none());
		try {
			executeLifecycle(request, ephemeralBuilder);
			tagImage(request.getName(), request.getTags());
			if (request.isPublish()) {
				pushImages(request.getName(), request.getTags());
			}
		}
		finally {
			this.docker.image().remove(ephemeralBuilder.getName(), true);
		}
	}
	private void validateBindings(List<Binding> bindings) {
		for (Binding binding : bindings) {
			if (binding.usesSensitiveContainerPath()) {
				this.log.sensitiveTargetBindingDetected(binding);
			}
		}
	}
	private BuildRequest withRunImageIfNeeded(BuildRequest request, BuilderMetadata metadata) {
		if (request.getRunImage() != null) {
			return request;
		}
		return request.withRunImage(getRunImageReference(metadata));
	}
	private ImageReference getRunImageReference(BuilderMetadata metadata) {
		if (metadata.getRunImages() != null && !metadata.getRunImages().isEmpty()) {
			String runImageName = metadata.getRunImages().get(0).getImage();
			return ImageReference.of(runImageName).inTaggedOrDigestForm();
		}
		String runImageName = metadata.getStack().getRunImage().getImage();
		Assert.state(StringUtils.hasText(runImageName), 'Run image must be specified in the builder image metadata');
		return ImageReference.of(runImageName).inTaggedOrDigestForm();
	}
	private void assertStackIdsMatch(Image runImage, Image builderImage) {
		StackId runImageStackId = StackId.fromImage(runImage);
		StackId builderImageStackId = StackId.fromImage(builderImage);
		if (runImageStackId.hasId() && builderImageStackId.hasId()) {
			Assert.state(runImageStackId.equals(builderImageStackId), () -> 'Run image stack "' + runImageStackId
					+ '" does not match builder stack "' + builderImageStackId + '"');
		}
	}
	private Buildpacks getBuildpacks(BuildRequest request, ImageFetcher imageFetcher, BuilderMetadata builderMetadata,
			BuildpackLayersMetadata buildpackLayersMetadata) {
		BuildpackResolverContext resolverContext = new BuilderResolverContext(imageFetcher, builderMetadata,
				buildpackLayersMetadata);
		return BuildpackResolvers.resolveAll(resolverContext, request.getBuildpacks());
	}
	private void executeLifecycle(BuildRequest request, EphemeralBuilder builder) throws IOException {
		ResolvedDockerHost dockerHost = null;
		if (this.dockerConfiguration != null && this.dockerConfiguration.isBindHostToBuilder()) {
			dockerHost = ResolvedDockerHost.from(this.dockerConfiguration.getHost());
		}
		try (Lifecycle lifecycle = new Lifecycle(this.log, this.docker, dockerHost, request, builder)) {
			lifecycle.execute();
		}
	}
	private void tagImage(ImageReference sourceReference, List<ImageReference> tags) throws IOException {
		for (ImageReference tag : tags) {
			this.docker.image().tag(sourceReference, tag);
			this.log.taggedImage(tag);
		}
	}
	private void pushImages(ImageReference name, List<ImageReference> tags) throws IOException {
		pushImage(name);
		for (ImageReference tag : tags) {
			pushImage(tag);
		}
	}
	private void pushImage(ImageReference reference) throws IOException {
		Consumer<TotalProgressEvent> progressConsumer = this.log.pushingImage(reference);
		TotalProgressPushListener listener = new TotalProgressPushListener(progressConsumer);
		this.docker.image().push(reference, listener, getPublishAuthHeader());
		this.log.pushedImage(reference);
	}
	private String getBuilderAuthHeader() {
		return (this.dockerConfiguration != null && this.dockerConfiguration.getBuilderRegistryAuthentication() != null)
				? this.dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader() : null;
	}
	private String getPublishAuthHeader() {
		return (this.dockerConfiguration != null && this.dockerConfiguration.getPublishRegistryAuthentication() != null)
				? this.dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader() : null;
	}
	/**
	 * Internal utility class used to fetch images.
	 */
	private class ImageFetcher {
		private final String domain;
		private final String authHeader;
		private final PullPolicy pullPolicy;
		private ImagePlatform defaultPlatform;
		ImageFetcher(String domain, String authHeader, PullPolicy pullPolicy, ImagePlatform platform) {
			this.domain = domain;
			this.authHeader = authHeader;
			this.pullPolicy = pullPolicy;
			this.defaultPlatform = platform;
		}
		Image fetchImage(ImageType type, ImageReference reference) throws IOException {
			Assert.notNull(type, 'Type must not be null');
			Assert.notNull(reference, 'Reference must not be null');
			Assert.state(this.authHeader == null || reference.getDomain().equals(this.domain),
					() -> String.format('%s "%s" must be pulled from the "%s" authenticated registry',
							StringUtils.capitalize(type.getDescription()), reference, this.domain));
			if (this.pullPolicy == PullPolicy.ALWAYS) {
				return pullImage(reference, type);
			}
			try {
				return Builder.this.docker.image().inspect(reference);
			}
			catch (DockerEngineException ex) {
				if (this.pullPolicy == PullPolicy.IF_NOT_PRESENT && ex.getStatusCode() == 404) {
					return pullImage(reference, type);
				}
				throw ex;
			}
		}
		private Image pullImage(ImageReference reference, ImageType imageType) throws IOException {
			TotalProgressPullListener listener = new TotalProgressPullListener(
					Builder.this.log.pullingImage(reference, this.defaultPlatform, imageType));
			Image image = Builder.this.docker.image().pull(reference, this.defaultPlatform, listener, this.authHeader);
			Builder.this.log.pulledImage(image, imageType);
			if (this.defaultPlatform == null) {
				this.defaultPlatform = ImagePlatform.from(image);
			}
			return image;
		}
	}
	/**
	 * {@link BuildpackResolverContext} implementation for the {@link Builder}.
	 */
	private class BuilderResolverContext implements BuildpackResolverContext {
		private final ImageFetcher imageFetcher;
		private final BuilderMetadata builderMetadata;
		private final BuildpackLayersMetadata buildpackLayersMetadata;
		BuilderResolverContext(ImageFetcher imageFetcher, BuilderMetadata builderMetadata,
				BuildpackLayersMetadata buildpackLayersMetadata) {
			this.imageFetcher = imageFetcher;
			this.builderMetadata = builderMetadata;
			this.buildpackLayersMetadata = buildpackLayersMetadata;
		}
		@Override
		public List<BuildpackMetadata> getBuildpackMetadata() {
			return this.builderMetadata.getBuildpacks();
		}
		@Override
		public BuildpackLayersMetadata getBuildpackLayersMetadata() {
			return this.buildpackLayersMetadata;
		}
		@Override
		public Image fetchImage(ImageReference reference, ImageType imageType) throws IOException {
			return this.imageFetcher.fetchImage(imageType, reference);
		}
		@Override
		public void exportImageLayers(ImageReference reference, IOBiConsumer<String, TarArchive> exports)
				throws IOException {
			Builder.this.docker.image().exportLayers(reference, exports);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class Buildpacks {
	static final Buildpacks EMPTY = new Buildpacks(Collections.emptyList());
	private final List<Buildpack> buildpacks;
	private Buildpacks(List<Buildpack> buildpacks) {
		this.buildpacks = buildpacks;
	}
	List<Buildpack> getBuildpacks() {
		return this.buildpacks;
	}
	void apply(IOConsumer<Layer> layers) throws IOException {
		if (!this.buildpacks.isEmpty()) {
			for (Buildpack buildpack : this.buildpacks) {
				buildpack.apply(layers);
			}
			layers.accept(Layer.of(this::addOrderLayerContent));
		}
	}
	void addOrderLayerContent(Layout layout) throws IOException {
		layout.file('/cnb/order.toml', Owner.ROOT, Content.of(getOrderToml()));
	}
	private String getOrderToml() {
		StringBuilder builder = new StringBuilder();
		builder.append('[[order]]\n\n');
		for (Buildpack buildpack : this.buildpacks) {
			appendToOrderToml(builder, buildpack.getCoordinates());
		}
		return builder.toString();
	}
	private void appendToOrderToml(StringBuilder builder, BuildpackCoordinates coordinates) {
		builder.append('  [[order.group]]\n');
		builder.append('    id = \'' + coordinates.getId() + '\'\n');
		if (StringUtils.hasText(coordinates.getVersion())) {
			builder.append('    version = \'' + coordinates.getVersion() + '\'\n');
		}
		builder.append('\n');
	}
	static Buildpacks of(List<Buildpack> buildpacks) {
		return CollectionUtils.isEmpty(buildpacks) ? EMPTY : new Buildpacks(buildpacks);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class PrintStreamBuildLog extends AbstractBuildLog {
	private final PrintStream out;
	PrintStreamBuildLog(PrintStream out) {
		this.out = out;
	}
	@Override
	protected void log(String message) {
		this.out.println(message);
	}
	@Override
	protected Consumer<TotalProgressEvent> getProgressConsumer(String prefix) {
		return new TotalProgressBar(prefix, ".", false, this.out);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class BuildpackMetadata extends MappedObject {
	private static final String LABEL_NAME = 'io.buildpacks.buildpackage.metadata';
	private final String id;
	private final String version;
	private final String homepage;
	private BuildpackMetadata(JsonNode node) {
		super(node, MethodHandles.lookup());
		this.id = valueAt('/id', String.class);
		this.version = valueAt('/version', String.class);
		this.homepage = valueAt('/homepage', String.class);
	}
	/**
	 * Return the buildpack ID.
	 * @return the ID
	 */
	String getId() {
		return this.id;
	}
	/**
	 * Return the buildpack version.
	 * @return the version
	 */
	String getVersion() {
		return this.version;
	}
	/**
	 * Return the buildpack homepage address.
	 * @return the homepage
	 */
	String getHomepage() {
		return this.homepage;
	}
	/**
	 * Factory method to extract {@link BuildpackMetadata} from an image.
	 * @param image the source image
	 * @return the builder metadata
	 * @throws IOException on IO error
	 */
	static BuildpackMetadata fromImage(Image image) throws IOException {
		Assert.notNull(image, 'Image must not be null');
		return fromImageConfig(image.getConfig());
	}
	/**
	 * Factory method to extract {@link BuildpackMetadata} from image config.
	 * @param imageConfig the source image config
	 * @return the builder metadata
	 * @throws IOException on IO error
	 */
	static BuildpackMetadata fromImageConfig(ImageConfig imageConfig) throws IOException {
		Assert.notNull(imageConfig, 'ImageConfig must not be null');
		String json = imageConfig.getLabels().get(LABEL_NAME);
		Assert.notNull(json, () -> 'No "' + LABEL_NAME + '" label found in image config labels "'
				+ StringUtils.collectionToCommaDelimitedString(imageConfig.getLabels().keySet()) + '"');
		return fromJson(json);
	}
	/**
	 * Factory method create {@link BuildpackMetadata} from JSON.
	 * @param json the source JSON
	 * @return the builder metadata
	 * @throws IOException on IO error
	 */
	static BuildpackMetadata fromJson(String json) throws IOException {
		return fromJson(SharedObjectMapper.get().readTree(json));
	}
	/**
	 * Factory method create {@link BuildpackMetadata} from JSON.
	 * @param node the source JSON
	 * @return the builder metadata
	 */
	static BuildpackMetadata fromJson(JsonNode node) {
		return new BuildpackMetadata(node);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class DirectoryBuildpack implements Buildpack {
	private final Path path;
	private final BuildpackCoordinates coordinates;
	private DirectoryBuildpack(Path path) {
		this.path = path;
		this.coordinates = findBuildpackCoordinates(path);
	}
	private BuildpackCoordinates findBuildpackCoordinates(Path path) {
		Path buildpackToml = path.resolve('buildpack.toml');
		Assert.isTrue(Files.exists(buildpackToml),
				() -> 'Buildpack descriptor "buildpack.toml" is required in buildpack "' + path + '"');
		try {
			try (InputStream inputStream = Files.newInputStream(buildpackToml)) {
				return BuildpackCoordinates.fromToml(inputStream, path);
			}
		}
		catch (IOException ex) {
			throw new IllegalArgumentException('Error parsing descriptor for buildpack "' + path + '"', ex);
		}
	}
	@Override
	public BuildpackCoordinates getCoordinates() {
		return this.coordinates;
	}
	@Override
	public void apply(IOConsumer<Layer> layers) throws IOException {
		layers.accept(Layer.of(this::addLayerContent));
	}
	private void addLayerContent(Layout layout) throws IOException {
		String id = this.coordinates.getSanitizedId();
		Path cnbPath = Paths.get('/cnb/buildpacks/', id, this.coordinates.getVersion());
		writeBasePathEntries(layout, cnbPath);
		Files.walkFileTree(this.path, new LayoutFileVisitor(this.path, cnbPath, layout));
	}
	private void writeBasePathEntries(Layout layout, Path basePath) throws IOException {
		int pathCount = basePath.getNameCount();
		for (int pathIndex = 1; pathIndex < pathCount + 1; pathIndex++) {
			String name = '/' + basePath.subpath(0, pathIndex) + '/';
			layout.directory(name, Owner.ROOT);
		}
	}
	/**
	 * A {@link BuildpackResolver} compatible method to resolve directory buildpacks.
	 * @param context the resolver context
	 * @param reference the buildpack reference
	 * @return the resolved {@link Buildpack} or {@code null}
	 */
	static Buildpack resolve(BuildpackResolverContext context, BuildpackReference reference) {
		Path path = reference.asPath();
		if (path != null && Files.exists(path) && Files.isDirectory(path)) {
			return new DirectoryBuildpack(path);
		}
		return null;
	}
	/**
	 * {@link SimpleFileVisitor} to used to create the {@link Layout}.
	 */
	private static class LayoutFileVisitor extends SimpleFileVisitor<Path> {
		private final Path basePath;
		private final Path layerPath;
		private final Layout layout;
		LayoutFileVisitor(Path basePath, Path layerPath, Layout layout) {
			this.basePath = basePath;
			this.layerPath = layerPath;
			this.layout = layout;
		}
		@Override
		public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
			if (!dir.equals(this.basePath)) {
				this.layout.directory(relocate(dir), Owner.ROOT, getMode(dir));
			}
			return FileVisitResult.CONTINUE;
		}
		@Override
		public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
			this.layout.file(relocate(file), Owner.ROOT, getMode(file), Content.of(file.toFile()));
			return FileVisitResult.CONTINUE;
		}
		private int getMode(Path path) throws IOException {
			try {
				return FilePermissions.umaskForPath(path);
			}
			catch (IllegalStateException ex) {
				throw new IllegalStateException(
						'Buildpack content in a directory is not supported on this operating system');
			}
		}
		private String relocate(Path path) {
			Path node = path.subpath(this.basePath.getNameCount(), path.getNameCount());
			return Paths.get(this.layerPath.toString(), node.toString()).toString();
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public interface BuildLog {
	/**
	 * Log that a build is starting.
	 * @param request the build request
	 */
	void start(BuildRequest request);
	/**
	 * Log that an image is being pulled.
	 * @param imageReference the image reference
	 * @param platform the platform of the image
	 * @param imageType the image type
	 * @return a consumer for progress update events
	 */
	Consumer<TotalProgressEvent> pullingImage(ImageReference imageReference, ImagePlatform platform,
			ImageType imageType);
	/**
	 * Log that an image has been pulled.
	 * @param image the image that was pulled
	 * @param imageType the image type that was pulled
	 */
	void pulledImage(Image image, ImageType imageType);
	/**
	 * Log that an image is being pushed.
	 * @param imageReference the image reference
	 * @return a consumer for progress update events
	 */
	Consumer<TotalProgressEvent> pushingImage(ImageReference imageReference);
	/**
	 * Log that an image has been pushed.
	 * @param imageReference the image reference
	 */
	void pushedImage(ImageReference imageReference);
	/**
	 * Log that the lifecycle is executing.
	 * @param request the build request
	 * @param version the lifecycle version
	 * @param buildCacheVolume the name of the build cache volume in use
	 */
	void executingLifecycle(BuildRequest request, LifecycleVersion version, VolumeName buildCacheVolume);
	/**
	 * Log that the lifecycle is executing.
	 * @param request the build request
	 * @param version the lifecycle version
	 * @param buildCache the build cache in use
	 */
	void executingLifecycle(BuildRequest request, LifecycleVersion version, Cache buildCache);
	/**
	 * Log that a specific phase is running.
	 * @param request the build request
	 * @param name the name of the phase
	 * @return a consumer for log updates
	 */
	Consumer<LogUpdateEvent> runningPhase(BuildRequest request, String name);
	/**
	 * Log that a specific phase is being skipped.
	 * @param name the name of the phase
	 * @param reason the reason the phase is skipped
	 */
	void skippingPhase(String name, String reason);
	/**
	 * Log that the lifecycle has executed.
	 * @param request the build request
	 */
	void executedLifecycle(BuildRequest request);
	/**
	 * Log that a tag has been created.
	 * @param tag the tag reference
	 */
	void taggedImage(ImageReference tag);
	/**
	 * Log that a cache cleanup step was not completed successfully.
	 * @param cache the cache
	 * @param exception any exception that caused the failure
	 * @since 3.2.6
	 */
	void failedCleaningWorkDir(Cache cache, Exception exception);
	/**
	 * Log that a binding with a sensitive target has been detected.
	 * @param binding the binding
	 * @since 3.4.0
	 */
	void sensitiveTargetBindingDetected(Binding binding);
	/**
	 * Factory method that returns a {@link BuildLog} the outputs to {@link System#out}.
	 * @return a build log instance that logs to system out
	 */
	static BuildLog toSystemOut() {
		return to(System.out);
	}
	/**
	 * Factory method that returns a {@link BuildLog} the outputs to a given
	 * {@link PrintStream}.
	 * @param out the print stream used to output the log
	 * @return a build log instance that logs to the given print stream
	 */
	static BuildLog to(PrintStream out) {
		return new PrintStreamBuildLog(out);
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
public class Creator {
	private final String version;
	Creator(String version) {
		this.version = version;
	}
	/**
	 * Return the name of the builder creator.
	 * @return the name
	 */
	public String getName() {
		return 'Spring Boot';
	}
	/**
	 * Return the version of the builder creator.
	 * @return the version
	 */
	public String getVersion() {
		return this.version;
	}
	/**
	 * Create a new {@code Creator} using the provided version.
	 * @param version the creator version
	 * @return a new creator instance
	 */
	public static Creator withVersion(String version) {
		Assert.notNull(version, 'Version must not be null');
		return new Creator(version);
	}
	@Override
	public String toString() {
		return getName() + ' version ' + getVersion();
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
class StackId {
	private static final String LABEL_NAME = 'io.buildpacks.stack.id';
	private final String value;
	StackId(String value) {
		this.value = value;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.value.equals(((StackId) obj).value);
	}
	boolean hasId() {
		return this.value != null;
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
	/**
	 * Factory method to create a {@link StackId} from an {@link Image}.
	 * @param image the source image
	 * @return the extracted stack ID
	 */
	static StackId fromImage(Image image) {
		Assert.notNull(image, 'Image must not be null');
		return fromImageConfig(image.getConfig());
	}
	/**
	 * Factory method to create a {@link StackId} from an {@link ImageConfig}.
	 * @param imageConfig the source image config
	 * @return the extracted stack ID
	 */
	private static StackId fromImageConfig(ImageConfig imageConfig) {
		String value = imageConfig.getLabels().get(LABEL_NAME);
		return new StackId(value);
	}
	/**
	 * Factory method to create a {@link StackId} with a given value.
	 * @param value the stack ID value
	 * @return a new stack ID instance
	 */
	static StackId of(String value) {
		Assert.hasText(value, 'Value must not be empty');
		return new StackId(value);
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.build;
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class TarGzipBuildpack implements Buildpack {
	private final Path path;
	private final BuildpackCoordinates coordinates;
	private TarGzipBuildpack(Path path) {
		this.path = path;
		this.coordinates = findBuildpackCoordinates(path);
	}
	private BuildpackCoordinates findBuildpackCoordinates(Path path) {
		try {
			try (TarArchiveInputStream tar = new TarArchiveInputStream(
					new GzipCompressorInputStream(Files.newInputStream(path)))) {
				ArchiveEntry entry = tar.getNextEntry();
				while (entry != null) {
					if ('buildpack.toml'.equals(entry.getName())) {
						return BuildpackCoordinates.fromToml(tar, path);
					}
					entry = tar.getNextEntry();
				}
				throw new IllegalArgumentException(
						'Buildpack descriptor "buildpack.toml" is required in buildpack "' + path + '"');
			}
		}
		catch (IOException ex) {
			throw new RuntimeException('Error parsing descriptor for buildpack "' + path + '"', ex);
		}
	}
	@Override
	public BuildpackCoordinates getCoordinates() {
		return this.coordinates;
	}
	@Override
	public void apply(IOConsumer<Layer> layers) throws IOException {
		layers.accept(Layer.fromTarArchive(this::copyAndRebaseEntries));
	}
	private void copyAndRebaseEntries(OutputStream outputStream) throws IOException {
		String id = this.coordinates.getSanitizedId();
		Path basePath = Paths.get('/cnb/buildpacks/', id, this.coordinates.getVersion());
		try (TarArchiveInputStream tar = new TarArchiveInputStream(
				new GzipCompressorInputStream(Files.newInputStream(this.path)));
				TarArchiveOutputStream output = new TarArchiveOutputStream(outputStream)) {
			writeBasePathEntries(output, basePath);
			TarArchiveEntry entry = tar.getNextEntry();
			while (entry != null) {
				entry.setName(basePath + '/' + entry.getName());
				output.putArchiveEntry(entry);
				StreamUtils.copy(tar, output);
				output.closeArchiveEntry();
				entry = tar.getNextEntry();
			}
			output.finish();
		}
	}
	private void writeBasePathEntries(TarArchiveOutputStream output, Path basePath) throws IOException {
		int pathCount = basePath.getNameCount();
		for (int pathIndex = 1; pathIndex < pathCount + 1; pathIndex++) {
			String name = '/' + basePath.subpath(0, pathIndex) + '/';
			TarArchiveEntry entry = new TarArchiveEntry(name);
			output.putArchiveEntry(entry);
			output.closeArchiveEntry();
		}
	}
	/**
	 * A {@link BuildpackResolver} compatible method to resolve tar-gzip buildpacks.
	 * @param context the resolver context
	 * @param reference the buildpack reference
	 * @return the resolved {@link Buildpack} or {@code null}
	 */
	static Buildpack resolve(BuildpackResolverContext context, BuildpackReference reference) {
		Path path = reference.asPath();
		if (path != null && Files.exists(path) && Files.isRegularFile(path)) {
			return new TarGzipBuildpack(path);
		}
		return null;
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
final class ApiVersions {
	/**
	 * The platform API versions supported by this release.
	 */
	static final ApiVersions SUPPORTED_PLATFORMS = ApiVersions.of(0, IntStream.rangeClosed(3, 14));
	private final ApiVersion[] apiVersions;
	private ApiVersions(ApiVersion... versions) {
		this.apiVersions = versions;
	}
	/**
	 * Find the latest version among the specified versions that is supported by these API
	 * versions.
	 * @param others the versions to check against
	 * @return the version
	 */
	ApiVersion findLatestSupported(String... others) {
		for (int versionsIndex = this.apiVersions.length - 1; versionsIndex >= 0; versionsIndex--) {
			ApiVersion apiVersion = this.apiVersions[versionsIndex];
			for (int otherIndex = others.length - 1; otherIndex >= 0; otherIndex--) {
				ApiVersion other = ApiVersion.parse(others[otherIndex]);
				if (apiVersion.supports(other)) {
					return apiVersion;
				}
			}
		}
		throw new IllegalStateException(
				'Detected platform API versions "' + StringUtils.arrayToCommaDelimitedString(others)
						+ '" are not included in supported versions "' + this + '"');
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ApiVersions other = (ApiVersions) obj;
		return Arrays.equals(this.apiVersions, other.apiVersions);
	}
	@Override
	public int hashCode() {
		return Arrays.hashCode(this.apiVersions);
	}
	@Override
	public String toString() {
		return StringUtils.arrayToCommaDelimitedString(this.apiVersions);
	}
	/**
	 * Factory method to parse strings into an {@link ApiVersions} instance.
	 * @param values the values to parse.
	 * @return the corresponding {@link ApiVersions}
	 * @throws IllegalArgumentException if any values could not be parsed
	 */
	static ApiVersions parse(String... values) {
		return new ApiVersions(Arrays.stream(values).map(ApiVersion::parse).toArray(ApiVersion[]::new));
	}
	static ApiVersions of(int major, IntStream minorsInclusive) {
		return new ApiVersions(
				minorsInclusive.mapToObj((minor) -> ApiVersion.of(major, minor)).toArray(ApiVersion[]::new));
	}
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
interface BuildpackResolver {
	/**
	 * Attempt to resolve the given {@link BuildpackReference}.
	 * @param context the resolver context
	 * @param reference the reference to resolve
	 * @return a resolved {@link Buildpack} instance or {@code null}
	 */
	Buildpack resolve(BuildpackResolverContext context, BuildpackReference reference);
}
/*
package org.springframework.boot.buildpack.platform.build;
/**
interface BuildpackResolverContext {
	List<BuildpackMetadata> getBuildpackMetadata();
	BuildpackLayersMetadata getBuildpackLayersMetadata();
	/**
	 * Retrieve an image.
	 * @param reference the image reference
	 * @param type the type of image
	 * @return the retrieved image
	 * @throws IOException on IO error
	 */
	Image fetchImage(ImageReference reference, ImageType type) throws IOException;
	/**
	 * Export the layers of an image.
	 * @param reference the reference to export
	 * @param exports a consumer to receive the layers (contents can only be accessed
	 * during the callback)
	 * @throws IOException on IO error
	 */
	void exportImageLayers(ImageReference reference, IOBiConsumer<String, TarArchive> exports) throws IOException;
}
/*
package org.springframework.boot.buildpack.platform.socket;
/**
class AbstractSocket extends Socket {
	@Override
	public void connect(SocketAddress endpoint) throws IOException {
	}
	@Override
	public void connect(SocketAddress endpoint, int timeout) throws IOException {
	}
	@Override
	public boolean isConnected() {
		return true;
	}
	@Override
	public boolean isBound() {
		return true;
	}
	@Override
	public void shutdownInput() throws IOException {
		throw new UnsupportedSocketOperationException();
	}
	@Override
	public void shutdownOutput() throws IOException {
		throw new UnsupportedSocketOperationException();
	}
	@Override
	public InetAddress getInetAddress() {
		return null;
	}
	@Override
	public InetAddress getLocalAddress() {
		return null;
	}
	@Override
	public SocketAddress getLocalSocketAddress() {
		return null;
	}
	@Override
	public SocketAddress getRemoteSocketAddress() {
		return null;
	}
	private static class UnsupportedSocketOperationException extends UnsupportedOperationException {
		UnsupportedSocketOperationException() {
			super('Unsupported socket operation');
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.socket;
/**
public class NamedPipeSocket extends Socket {
	private static final int WAIT_INTERVAL = 100;
	private static final long TIMEOUT = TimeUnit.MILLISECONDS.toNanos(1000);
	private final AsynchronousFileByteChannel channel;
	NamedPipeSocket(String path) throws IOException {
		this.channel = open(path);
	}
	private AsynchronousFileByteChannel open(String path) throws IOException {
		Consumer<String> awaiter = Platform.isWindows() ? new WindowsAwaiter() : new SleepAwaiter();
		long startTime = System.nanoTime();
		while (true) {
			try {
				return new AsynchronousFileByteChannel(AsynchronousFileChannel.open(Paths.get(path),
						StandardOpenOption.READ, StandardOpenOption.WRITE));
			}
			catch (FileSystemException ex) {
				if (System.nanoTime() - startTime >= TIMEOUT) {
					throw ex;
				}
				awaiter.accept(path);
			}
		}
	}
	@Override
	public InputStream getInputStream() {
		return Channels.newInputStream(this.channel);
	}
	@Override
	public OutputStream getOutputStream() {
		return Channels.newOutputStream(this.channel);
	}
	@Override
	public void close() throws IOException {
		if (this.channel != null) {
			this.channel.close();
		}
	}
	/**
	 * Return a new {@link NamedPipeSocket} for the given path.
	 * @param path the path to the domain socket
	 * @return a {@link NamedPipeSocket} instance
	 * @throws IOException if the socket cannot be opened
	 */
	public static NamedPipeSocket get(String path) throws IOException {
		return new NamedPipeSocket(path);
	}
	/**
	 * Adapt an {@code AsynchronousByteChannel} to an {@code AsynchronousFileChannel}.
	 */
	private static class AsynchronousFileByteChannel implements AsynchronousByteChannel {
		private final AsynchronousFileChannel fileChannel;
		AsynchronousFileByteChannel(AsynchronousFileChannel fileChannel) {
			this.fileChannel = fileChannel;
		}
		@Override
		public <A> void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, ? super A> handler) {
			this.fileChannel.read(dst, 0, attachment, new CompletionHandler<>() {
				@Override
				public void completed(Integer read, A attachment) {
					handler.completed((read > 0) ? read : -1, attachment);
				}
				@Override
				public void failed(Throwable exc, A attachment) {
					if (exc instanceof AsynchronousCloseException) {
						handler.completed(-1, attachment);
						return;
					}
					handler.failed(exc, attachment);
				}
			});
		}
		@Override
		public Future<Integer> read(ByteBuffer dst) {
			CompletableFutureHandler future = new CompletableFutureHandler();
			this.fileChannel.read(dst, 0, null, future);
			return future;
		}
		@Override
		public <A> void write(ByteBuffer src, A attachment, CompletionHandler<Integer, ? super A> handler) {
			this.fileChannel.write(src, 0, attachment, handler);
		}
		@Override
		public Future<Integer> write(ByteBuffer src) {
			return this.fileChannel.write(src, 0);
		}
		@Override
		public void close() throws IOException {
			this.fileChannel.close();
		}
		@Override
		public boolean isOpen() {
			return this.fileChannel.isOpen();
		}
		private static final class CompletableFutureHandler extends CompletableFuture<Integer>
				implements CompletionHandler<Integer, Object> {
			@Override
			public void completed(Integer read, Object attachment) {
				complete((read > 0) ? read : -1);
			}
			@Override
			public void failed(Throwable exc, Object attachment) {
				if (exc instanceof AsynchronousCloseException) {
					complete(-1);
					return;
				}
				completeExceptionally(exc);
			}
		}
	}
	/**
	 * Waits for the name pipe file using a simple sleep.
	 */
	private static final class SleepAwaiter implements Consumer<String> {
		@Override
		public void accept(String path) {
			try {
				Thread.sleep(WAIT_INTERVAL);
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
	}
	/**
	 * Waits for the name pipe file using Windows specific logic.
	 */
	private static final class WindowsAwaiter implements Consumer<String> {
		@Override
		public void accept(String path) {
			Kernel32.INSTANCE.WaitNamedPipe(path, WAIT_INTERVAL);
		}
	}
}
/*
package org.springframework.boot.buildpack.platform.socket;
/**
public final class UnixDomainSocket extends AbstractSocket {
	/**
	 * Create a new {@link Socket} for the given path.
	 * @param path the path to the domain socket
	 * @return a {@link Socket} instance
	 * @throws IOException if the socket cannot be opened
	 */
	public static Socket get(String path) throws IOException {
		return new UnixDomainSocket(path);
	}
	private final SocketAddress socketAddress;
	private final SocketChannel socketChannel;
	private UnixDomainSocket(String path) throws IOException {
		this.socketAddress = UnixDomainSocketAddress.of(path);
		this.socketChannel = SocketChannel.open(this.socketAddress);
	}
	@Override
	public InputStream getInputStream() throws IOException {
		if (isClosed()) {
			throw new SocketException('Socket is closed');
		}
		if (!isConnected()) {
			throw new SocketException('Socket is not connected');
		}
		if (isInputShutdown()) {
			throw new SocketException('Socket input is shutdown');
		}
		return Channels.newInputStream(this.socketChannel);
	}
	@Override
	public OutputStream getOutputStream() throws IOException {
		if (isClosed()) {
			throw new SocketException('Socket is closed');
		}
		if (!isConnected()) {
			throw new SocketException('Socket is not connected');
		}
		if (isOutputShutdown()) {
			throw new SocketException('Socket output is shutdown');
		}
		return Channels.newOutputStream(this.socketChannel);
	}
	@Override
	public SocketAddress getLocalSocketAddress() {
		return this.socketAddress;
	}
	@Override
	public SocketAddress getRemoteSocketAddress() {
		return this.socketAddress;
	}
	@Override
	public void close() throws IOException {
		super.close();
		this.socketChannel.close();
	}
}
/*
package org.springframework.boot.buildpack.platform.socket;
/**
class FileDescriptor {
	private final Handle openHandle;
	private final Handle closedHandler;
	private final IntConsumer closer;
	private Status status = Status.OPEN;
	private int referenceCount;
	FileDescriptor(int handle, IntConsumer closer) {
		this.openHandle = new Handle(handle);
		this.closedHandler = new Handle(-1);
		this.closer = closer;
	}
	/**
	 * Acquire an instance of the actual {@link Handle}. The caller must
	 * {@link Handle#close() close} the resulting handle when done.
	 * @return the handle
	 */
	synchronized Handle acquire() {
		this.referenceCount++;
		return (this.status != Status.OPEN) ? this.closedHandler : this.openHandle;
	}
	private synchronized void release() {
		this.referenceCount--;
		if (this.referenceCount == 0 && this.status == Status.CLOSE_PENDING) {
			this.closer.accept(this.openHandle.value);
			this.status = Status.CLOSED;
		}
	}
	/**
	 * Close the underlying file when all handles have been released.
	 */
	synchronized void close() {
		if (this.status == Status.OPEN) {
			if (this.referenceCount == 0) {
				this.closer.accept(this.openHandle.value);
				this.status = Status.CLOSED;
			}
			else {
				this.status = Status.CLOSE_PENDING;
			}
		}
	}
	/**
	 * The status of the file descriptor.
	 */
	private enum Status {
		OPEN, CLOSE_PENDING, CLOSED
	}
	/**
	 * Provides access to the actual file descriptor handle.
	 */
	final class Handle implements Closeable {
		private final int value;
		private Handle(int value) {
			this.value = value;
		}
		boolean isClosed() {
			return this.value == -1;
		}
		int intValue() {
			return this.value;
		}
		@Override
		public void close() throws IOException {
			if (!isClosed()) {
				release();
			}
		}
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.socket;
/*
/**
package org.springframework.boot.buildpack.platform.system;
/*
package org.springframework.boot.buildpack.platform.system;
/**
@FunctionalInterface
public interface Environment {
	/**
	 * Standard {@link Environment} implementation backed by
	 * {@link System#getenv(String)}.
	 */
	Environment SYSTEM = System::getenv;
	/**
	 * Gets the value of the specified environment variable.
	 * @param name the name of the environment variable
	 * @return the string value of the variable, or {@code null} if the variable is not
	 * defined in the environment
	 */
	String get(String name);
}
/*
package org.springframework.boot.buildpack.platform.json;
/**
public class MappedObject {
	private final JsonNode node;
	private final Lookup lookup;
	/**
	 * Create a new {@link MappedObject} instance.
	 * @param node the source node
	 * @param lookup method handle lookup
	 */
	protected MappedObject(JsonNode node, Lookup lookup) {
		this.node = node;
		this.lookup = lookup;
	}
	/**
	 * Return the source node of the mapped object.
	 * @return the source node
	 */
	protected final JsonNode getNode() {
		return this.node;
	}
	/**
	 * Get the value at the given JSON path expression as a specific type.
	 * @param <T> the data type
	 * @param expression the JSON path expression
	 * @param type the desired type. May be a simple JSON type or an interface
	 * @return the value
	 */
	protected <T> T valueAt(String expression, Class<T> type) {
		return valueAt(this, this.node, this.lookup, expression, type);
	}
	/**
	 * Get children at the given JSON path expression by constructing them using the given
	 * factory.
	 * @param <T> the child type
	 * @param expression the JSON path expression
	 * @param factory factory used to create the child
	 * @return a list of children
	 * @since 3.2.6
	 */
	protected <T> List<T> childrenAt(String expression, Function<JsonNode, T> factory) {
		JsonNode node = (expression != null) ? this.node.at(expression) : this.node;
		if (node.isEmpty()) {
			return Collections.emptyList();
		}
		List<T> children = new ArrayList<>();
		node.elements().forEachRemaining((childNode) -> children.add(factory.apply(childNode)));
		return Collections.unmodifiableList(children);
	}
	@SuppressWarnings('unchecked')
	protected static <T extends MappedObject> T getRoot(Object proxy) {
		MappedInvocationHandler handler = (MappedInvocationHandler) Proxy.getInvocationHandler(proxy);
		return (T) handler.root;
	}
	protected static <T> T valueAt(Object proxy, String expression, Class<T> type) {
		MappedInvocationHandler handler = (MappedInvocationHandler) Proxy.getInvocationHandler(proxy);
		return valueAt(handler.root, handler.node, handler.lookup, expression, type);
	}
	@SuppressWarnings('unchecked')
	private static <T> T valueAt(MappedObject root, JsonNode node, Lookup lookup, String expression, Class<T> type) {
		JsonNode result = node.at(expression);
		if (result.isMissingNode() && expression.startsWith('/') && expression.length() > 1
				&& Character.isLowerCase(expression.charAt(1))) {
			StringBuilder alternative = new StringBuilder(expression);
			alternative.setCharAt(1, Character.toUpperCase(alternative.charAt(1)));
			result = node.at(alternative.toString());
		}
		if (type.isInterface() && !type.getName().startsWith('java')) {
			return (T) Proxy.newProxyInstance(MappedObject.class.getClassLoader(), new Class<?>[] { type },
					new MappedInvocationHandler(root, result, lookup));
		}
		if (result.isMissingNode()) {
			return null;
		}
		try {
			return SharedObjectMapper.get().treeToValue(result, type);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	/**
	 * Factory method to create a new {@link MappedObject} instance.
	 * @param <T> the mapped object type
	 * @param content the JSON content for the object
	 * @param factory a factory to create the mapped object from a {@link JsonNode}
	 * @return the mapped object
	 * @throws IOException on IO error
	 */
	protected static <T extends MappedObject> T of(String content, Function<JsonNode, T> factory) throws IOException {
		return of(content, ObjectMapper::readTree, factory);
	}
	/**
	 * Factory method to create a new {@link MappedObject} instance.
	 * @param <T> the mapped object type
	 * @param content the JSON content for the object
	 * @param factory a factory to create the mapped object from a {@link JsonNode}
	 * @return the mapped object
	 * @throws IOException on IO error
	 */
	protected static <T extends MappedObject> T of(InputStream content, Function<JsonNode, T> factory)
			throws IOException {
		return of(StreamUtils.nonClosing(content), ObjectMapper::readTree, factory);
	}
	/**
	 * Factory method to create a new {@link MappedObject} instance.
	 * @param <T> the mapped object type
	 * @param <C> the content type
	 * @param content the JSON content for the object
	 * @param reader the content reader
	 * @param factory a factory to create the mapped object from a {@link JsonNode}
	 * @return the mapped object
	 * @throws IOException on IO error
	 */
	protected static <T extends MappedObject, C> T of(C content, ContentReader<C> reader, Function<JsonNode, T> factory)
			throws IOException {
		ObjectMapper objectMapper = SharedObjectMapper.get();
		JsonNode node = reader.read(objectMapper, content);
		return factory.apply(node);
	}
	/**
	 * Strategy used to read JSON content.
	 *
	 * @param <C> the content type
	 */
	@FunctionalInterface
	protected interface ContentReader<C> {
		/**
		 * Read JSON content as a {@link JsonNode}.
		 * @param objectMapper the source object mapper
		 * @param content the content to read
		 * @return a {@link JsonNode}
		 * @throws IOException on IO error
		 */
		JsonNode read(ObjectMapper objectMapper, C content) throws IOException;
	}
	/**
	 * {@link InvocationHandler} used to support
	 * {@link MappedObject#valueAt(String, Class) valueAt} with {@code interface} types.
	 */
	private static class MappedInvocationHandler implements InvocationHandler {
		private static final String GET = 'get';
		private static final String IS = 'is';
		private final MappedObject root;
		private final JsonNode node;
		private final Lookup lookup;
		MappedInvocationHandler(MappedObject root, JsonNode node, Lookup lookup) {
			this.root = root;
			this.node = node;
			this.lookup = lookup;
		}
		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			Class<?> declaringClass = method.getDeclaringClass();
			if (method.isDefault()) {
				Lookup lookup = this.lookup.in(declaringClass);
				MethodHandle methodHandle = lookup.unreflectSpecial(method, declaringClass).bindTo(proxy);
				return methodHandle.invokeWithArguments();
			}
			if (declaringClass == Object.class) {
				method.invoke(proxy, args);
			}
			Assert.state(args == null || args.length == 0, () -> 'Unsupported method ' + method);
			String name = getName(method.getName());
			Class<?> type = method.getReturnType();
			return valueForProperty(name, type);
		}
		private String getName(String name) {
			StringBuilder result = new StringBuilder(name);
			if (name.startsWith(GET)) {
				result = new StringBuilder(name.substring(GET.length()));
			}
			if (name.startsWith(IS)) {
				result = new StringBuilder(name.substring(IS.length()));
			}
			Assert.state(result.length() >= 0, 'Missing name');
			result.setCharAt(0, Character.toLowerCase(result.charAt(0)));
			return result.toString();
		}
		private Object valueForProperty(String name, Class<?> type) {
			return valueAt(this.root, this.node, this.lookup, '/' + name, type);
		}
	}
}
/*
/**
package org.springframework.boot.buildpack.platform.json;
/*
package org.springframework.boot.buildpack.platform.json;
/**
public class JsonStream {
	private final ObjectMapper objectMapper;
	/**
	 * Create a new {@link JsonStream} backed by the given object mapper.
	 * @param objectMapper the object mapper to use
	 */
	public JsonStream(ObjectMapper objectMapper) {
		this.objectMapper = objectMapper;
	}
	/**
	 * Stream {@link ObjectNode object nodes} from the content as they become available.
	 * @param content the source content
	 * @param consumer the {@link ObjectNode} consumer
	 * @throws IOException on IO error
	 */
	public void get(InputStream content, Consumer<ObjectNode> consumer) throws IOException {
		get(content, ObjectNode.class, consumer);
	}
	/**
	 * Stream objects from the content as they become available.
	 * @param <T> the object type
	 * @param content the source content
	 * @param type the object type
	 * @param consumer the {@link ObjectNode} consumer
	 * @throws IOException on IO error
	 */
	public <T> void get(InputStream content, Class<T> type, Consumer<T> consumer) throws IOException {
		JsonFactory jsonFactory = this.objectMapper.getFactory();
		try (JsonParser parser = jsonFactory.createParser(content)) {
			while (!parser.isClosed()) {
				JsonToken token = parser.nextToken();
				if (token != null && token != JsonToken.END_OBJECT) {
					T node = read(parser, type);
					if (node != null) {
						consumer.accept(node);
					}
				}
			}
		}
	}
	@SuppressWarnings('unchecked')
	private <T> T read(JsonParser parser, Class<T> type) throws IOException {
		if (ObjectNode.class.isAssignableFrom(type)) {
			ObjectNode node = this.objectMapper.readTree(parser);
			if (node == null || node.isMissingNode() || node.isEmpty()) {
				return null;
			}
			return (T) node;
		}
		return this.objectMapper.readValue(parser, type);
	}
}
/*
package org.springframework.boot.buildpack.platform.json;
/**
public final class SharedObjectMapper {
	private static final ObjectMapper INSTANCE;
	static {
		ObjectMapper objectMapper = new ObjectMapper();
		objectMapper.registerModule(new ParameterNamesModule());
		objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
		objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		objectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.LOWER_CAMEL_CASE);
		INSTANCE = objectMapper;
	}
	private SharedObjectMapper() {
	}
	public static ObjectMapper get() {
		return INSTANCE;
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public final class FakeJarLauncher {
	public static Consumer<String[]> action;
	private FakeJarLauncher() {
	}
	public static void main(String... args) {
		action.accept(args);
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
class HttpStatusHandlerTests {
	private MockHttpServletRequest servletRequest;
	private MockHttpServletResponse servletResponse;
	private ServerHttpResponse response;
	private ServerHttpRequest request;
	@BeforeEach
	void setup() {
		this.servletRequest = new MockHttpServletRequest();
		this.servletResponse = new MockHttpServletResponse();
		this.request = new ServletServerHttpRequest(this.servletRequest);
		this.response = new ServletServerHttpResponse(this.servletResponse);
	}
	@Test
	void statusMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpStatusHandler(null))
			.withMessageContaining('Status must not be null');
	}
	@Test
	void respondsOk() throws Exception {
		HttpStatusHandler handler = new HttpStatusHandler();
		handler.handle(this.request, this.response);
		assertThat(this.servletResponse.getStatus()).isEqualTo(200);
	}
	@Test
	void respondsWithStatus() throws Exception {
		HttpStatusHandler handler = new HttpStatusHandler(HttpStatus.I_AM_A_TEAPOT);
		handler.handle(this.request, this.response);
		assertThat(this.servletResponse.getStatus()).isEqualTo(418);
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
@ExtendWith(MockitoExtension.class)
class DispatcherTests {
	@Mock
	private AccessManager accessManager;
	private final MockHttpServletResponse response = new MockHttpServletResponse();
	private final ServerHttpRequest serverRequest = new ServletServerHttpRequest(new MockHttpServletRequest());
	private final ServerHttpResponse serverResponse = new ServletServerHttpResponse(this.response);
	@Test
	void accessManagerMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Dispatcher(null, Collections.emptyList()))
			.withMessageContaining('AccessManager must not be null');
	}
	@Test
	void mappersMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Dispatcher(this.accessManager, null))
			.withMessageContaining('Mappers must not be null');
	}
	@Test
	void accessManagerVetoRequest() throws Exception {
		given(this.accessManager.isAllowed(any(ServerHttpRequest.class))).willReturn(false);
		HandlerMapper mapper = mock(HandlerMapper.class);
		Handler handler = mock(Handler.class);
		given(mapper.getHandler(any(ServerHttpRequest.class))).willReturn(handler);
		Dispatcher dispatcher = new Dispatcher(this.accessManager, Collections.singleton(mapper));
		dispatcher.handle(this.serverRequest, this.serverResponse);
		then(handler).shouldHaveNoInteractions();
		assertThat(this.response.getStatus()).isEqualTo(403);
	}
	@Test
	void accessManagerAllowRequest() throws Exception {
		given(this.accessManager.isAllowed(any(ServerHttpRequest.class))).willReturn(true);
		HandlerMapper mapper = mock(HandlerMapper.class);
		Handler handler = mock(Handler.class);
		given(mapper.getHandler(any(ServerHttpRequest.class))).willReturn(handler);
		Dispatcher dispatcher = new Dispatcher(this.accessManager, Collections.singleton(mapper));
		dispatcher.handle(this.serverRequest, this.serverResponse);
		then(handler).should().handle(this.serverRequest, this.serverResponse);
	}
	@Test
	void ordersMappers() throws Exception {
		HandlerMapper mapper1 = mock(HandlerMapper.class, withSettings().extraInterfaces(Ordered.class));
		HandlerMapper mapper2 = mock(HandlerMapper.class, withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) mapper1).getOrder()).willReturn(1);
		given(((Ordered) mapper2).getOrder()).willReturn(2);
		List<HandlerMapper> mappers = Arrays.asList(mapper2, mapper1);
		Dispatcher dispatcher = new Dispatcher(AccessManager.PERMIT_ALL, mappers);
		dispatcher.handle(this.serverRequest, this.serverResponse);
		InOrder inOrder = inOrder(mapper1, mapper2);
		then(mapper1).should(inOrder).getHandler(this.serverRequest);
		then(mapper2).should(inOrder).getHandler(this.serverRequest);
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
@ExtendWith(MockitoExtension.class)
class DispatcherFilterTests {
	@Mock
	private Dispatcher dispatcher;
	@Mock
	private FilterChain chain;
	private DispatcherFilter filter;
	@BeforeEach
	void setup() {
		this.filter = new DispatcherFilter(this.dispatcher);
	}
	@Test
	void dispatcherMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DispatcherFilter(null))
			.withMessageContaining('Dispatcher must not be null');
	}
	@Test
	void ignoresNotServletRequests() throws Exception {
		ServletRequest request = mock(ServletRequest.class);
		ServletResponse response = mock(ServletResponse.class);
		this.filter.doFilter(request, response, this.chain);
		then(this.dispatcher).shouldHaveNoInteractions();
		then(this.chain).should().doFilter(request, response);
	}
	@Test
	void ignoredByDispatcher() throws Exception {
		HttpServletRequest request = new MockHttpServletRequest('GET', '/hello');
		HttpServletResponse response = new MockHttpServletResponse();
		this.filter.doFilter(request, response, this.chain);
		then(this.chain).should().doFilter(request, response);
	}
	@Test
	void handledByDispatcher() throws Exception {
		HttpServletRequest request = new MockHttpServletRequest('GET', '/hello');
		HttpServletResponse response = new MockHttpServletResponse();
		willReturn(true).given(this.dispatcher).handle(any(ServerHttpRequest.class), any(ServerHttpResponse.class));
		this.filter.doFilter(request, response, this.chain);
		then(this.chain).shouldHaveNoInteractions();
		then(this.dispatcher).should()
			.handle(assertArg((serverHttpRequest) -> assertThat(serverHttpRequest).isInstanceOfSatisfying(
					ServletServerHttpRequest.class,
					(servletServerHttpRequest) -> assertThat(servletServerHttpRequest.getServletRequest())
						.isEqualTo(request))),
					assertArg((serverHttpResponse) -> assertThat(serverHttpResponse).isInstanceOfSatisfying(
							ServletServerHttpResponse.class,
							(servletServerHttpResponse) -> assertThat(servletServerHttpResponse.getServletResponse())
								.isEqualTo(response))));
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
class UrlHandlerMapperTests {
	private final Handler handler = mock(Handler.class);
	@Test
	void requestUriMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new UrlHandlerMapper(null, this.handler))
			.withMessageContaining('URL must not be empty');
	}
	@Test
	void requestUriMustNotBeEmpty() {
		assertThatIllegalArgumentException().isThrownBy(() -> new UrlHandlerMapper('', this.handler))
			.withMessageContaining('URL must not be empty');
	}
	@Test
	void requestUrlMustStartWithSlash() {
		assertThatIllegalArgumentException().isThrownBy(() -> new UrlHandlerMapper('tunnel', this.handler))
			.withMessageContaining('URL must start with "/"');
	}
	@Test
	void handlesMatchedUrl() {
		UrlHandlerMapper mapper = new UrlHandlerMapper('/tunnel', this.handler);
		HttpServletRequest servletRequest = new MockHttpServletRequest('GET', '/tunnel');
		ServerHttpRequest request = new ServletServerHttpRequest(servletRequest);
		assertThat(mapper.getHandler(request)).isEqualTo(this.handler);
	}
	@Test
	void ignoresDifferentUrl() {
		UrlHandlerMapper mapper = new UrlHandlerMapper('/tunnel', this.handler);
		HttpServletRequest servletRequest = new MockHttpServletRequest('GET', '/tunnel/other');
		ServerHttpRequest request = new ServletServerHttpRequest(servletRequest);
		assertThat(mapper.getHandler(request)).isNull();
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
class HttpHeaderAccessManagerTests {
	private static final String HEADER = 'X-AUTH_TOKEN';
	private static final String SECRET = 'password';
	private MockHttpServletRequest request;
	private ServerHttpRequest serverRequest;
	private HttpHeaderAccessManager manager;
	@BeforeEach
	void setup() {
		this.request = new MockHttpServletRequest('GET', '/');
		this.serverRequest = new ServletServerHttpRequest(this.request);
		this.manager = new HttpHeaderAccessManager(HEADER, SECRET);
	}
	@Test
	void headerNameMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderAccessManager(null, SECRET))
			.withMessageContaining('HeaderName must not be empty');
	}
	@Test
	void headerNameMustNotBeEmpty() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderAccessManager('', SECRET))
			.withMessageContaining('HeaderName must not be empty');
	}
	@Test
	void expectedSecretMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderAccessManager(HEADER, null))
			.withMessageContaining('ExpectedSecret must not be empty');
	}
	@Test
	void expectedSecretMustNotBeEmpty() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderAccessManager(HEADER, ''))
			.withMessageContaining('ExpectedSecret must not be empty');
	}
	@Test
	void allowsMatching() {
		this.request.addHeader(HEADER, SECRET);
		assertThat(this.manager.isAllowed(this.serverRequest)).isTrue();
	}
	@Test
	void disallowsWrongSecret() {
		this.request.addHeader(HEADER, 'wrong');
		assertThat(this.manager.isAllowed(this.serverRequest)).isFalse();
	}
	@Test
	void disallowsNoSecret() {
		assertThat(this.manager.isAllowed(this.serverRequest)).isFalse();
	}
	@Test
	void disallowsWrongHeader() {
		this.request.addHeader('X-WRONG', SECRET);
		assertThat(this.manager.isAllowed(this.serverRequest)).isFalse();
	}
}
/*
package org.springframework.boot.devtools.remote.client;
/**
@ExtendWith(MockitoExtension.class)
class HttpHeaderInterceptorTests {
	private String name;
	private String value;
	private HttpHeaderInterceptor interceptor;
	private HttpRequest request;
	private byte[] body;
	@Mock
	private ClientHttpRequestExecution execution;
	@Mock
	private ClientHttpResponse response;
	private MockHttpServletRequest httpRequest;
	@BeforeEach
	void setup() {
		this.body = new byte[] {};
		this.httpRequest = new MockHttpServletRequest();
		this.request = new ServletServerHttpRequest(this.httpRequest);
		this.name = 'X-AUTH-TOKEN';
		this.value = 'secret';
		this.interceptor = new HttpHeaderInterceptor(this.name, this.value);
	}
	@Test
	void constructorNullHeaderName() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderInterceptor(null, this.value))
			.withMessageContaining('Name must not be empty');
	}
	@Test
	void constructorEmptyHeaderName() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderInterceptor('', this.value))
			.withMessageContaining('Name must not be empty');
	}
	@Test
	void constructorNullHeaderValue() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderInterceptor(this.name, null))
			.withMessageContaining('Value must not be empty');
	}
	@Test
	void constructorEmptyHeaderValue() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpHeaderInterceptor(this.name, ''))
			.withMessageContaining('Value must not be empty');
	}
	@Test
	void intercept() throws IOException {
		given(this.execution.execute(this.request, this.body)).willReturn(this.response);
		ClientHttpResponse result = this.interceptor.intercept(this.request, this.body, this.execution);
		assertThat(this.request.getHeaders().getFirst(this.name)).isEqualTo(this.value);
		assertThat(result).isEqualTo(this.response);
	}
}
/*
package org.springframework.boot.devtools.remote.client;
/**
@ExtendWith({ OutputCaptureExtension.class, MockRestarter.class })
class RemoteClientConfigurationTests {
	private AnnotationConfigServletWebServerApplicationContext context;
	private AnnotationConfigApplicationContext clientContext;
	@AfterEach
	void cleanup() {
		if (this.context != null) {
			this.context.close();
		}
		if (this.clientContext != null) {
			this.clientContext.close();
		}
	}
	@Test
	void warnIfRestartDisabled(CapturedOutput output) {
		configure('spring.devtools.remote.restart.enabled:false');
		assertThat(output).contains('Remote restart is disabled');
	}
	@Test
	void warnIfNotHttps(CapturedOutput output) {
		configure('http://localhost', true);
		assertThat(output).contains('is insecure');
	}
	@Test
	void doesntWarnIfUsingHttps(CapturedOutput output) {
		configure('https://localhost', true);
		assertThat(output).doesNotContain('is insecure');
	}
	@Test
	void failIfNoSecret() {
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(() -> configure('http://localhost', false))
			.withMessageContaining('required to secure your connection');
	}
	@Test
	void liveReloadOnClassPathChanged() throws Exception {
		configure();
		Set<ChangedFiles> changeSet = new HashSet<>();
		ClassPathChangedEvent event = new ClassPathChangedEvent(this, changeSet, false);
		this.clientContext.publishEvent(event);
		LiveReloadServer server = this.clientContext.getBean(LiveReloadServer.class);
		Awaitility.await().atMost(Duration.ofMinutes(1)).untilAsserted(() -> then(server).should().triggerReload());
	}
	@Test
	void liveReloadDisabled() {
		configure('spring.devtools.livereload.enabled:false');
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(OptionalLiveReloadServer.class));
	}
	@Test
	void remoteRestartDisabled() {
		configure('spring.devtools.remote.restart.enabled:false');
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(ClassPathFileSystemWatcher.class));
	}
	private void configure(String... pairs) {
		configure('http://localhost', true, pairs);
	}
	private void configure(String remoteUrl, boolean setSecret, String... pairs) {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.register(Config.class);
		if (setSecret) {
			TestPropertyValues.of('spring.devtools.remote.secret:secret').applyTo(this.context);
		}
		this.context.refresh();
		this.clientContext = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(pairs).applyTo(this.clientContext);
		new RestartScopeInitializer().initialize(this.clientContext);
		this.clientContext.register(ClientConfig.class, RemoteClientConfiguration.class);
		if (setSecret) {
			TestPropertyValues.of('spring.devtools.remote.secret:secret').applyTo(this.clientContext);
		}
		String remoteUrlProperty = 'remoteUrl:' + remoteUrl + ':' + this.context.getWebServer().getPort();
		TestPropertyValues.of(remoteUrlProperty).applyTo(this.clientContext);
		this.clientContext.refresh();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			TomcatServletWebServerFactory webServerFactory = new TomcatServletWebServerFactory(0);
			webServerFactory.setRegisterDefaultServlet(true);
			return webServerFactory;
		}
		@Bean
		DispatcherFilter dispatcherFilter() throws IOException {
			return new DispatcherFilter(dispatcher());
		}
		Dispatcher dispatcher() throws IOException {
			Dispatcher dispatcher = mock(Dispatcher.class);
			ServerHttpRequest anyRequest = any(ServerHttpRequest.class);
			ServerHttpResponse anyResponse = any(ServerHttpResponse.class);
			given(dispatcher.handle(anyRequest, anyResponse)).willReturn(true);
			return dispatcher;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClientConfig {
		@Bean
		LiveReloadServer liveReloadServer() {
			return mock(LiveReloadServer.class);
		}
	}
}
/*
package org.springframework.boot.devtools.remote.client;
/**
@ExtendWith(MockitoExtension.class)
class DelayedLiveReloadTriggerTests {
	private static final String URL = 'http://localhost:8080';
	@Mock
	private OptionalLiveReloadServer liveReloadServer;
	@Mock
	private ClientHttpRequestFactory requestFactory;
	@Mock
	private ClientHttpRequest errorRequest;
	@Mock
	private ClientHttpRequest okRequest;
	@Mock
	private ClientHttpResponse errorResponse;
	@Mock
	private ClientHttpResponse okResponse;
	private DelayedLiveReloadTrigger trigger;
	@BeforeEach
	void setup() {
		this.trigger = new DelayedLiveReloadTrigger(this.liveReloadServer, this.requestFactory, URL);
	}
	@Test
	void liveReloadServerMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DelayedLiveReloadTrigger(null, this.requestFactory, URL))
			.withMessageContaining('LiveReloadServer must not be null');
	}
	@Test
	void requestFactoryMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DelayedLiveReloadTrigger(this.liveReloadServer, null, URL))
			.withMessageContaining('RequestFactory must not be null');
	}
	@Test
	void urlMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DelayedLiveReloadTrigger(this.liveReloadServer, this.requestFactory, null))
			.withMessageContaining('URL must not be empty');
	}
	@Test
	void urlMustNotBeEmpty() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DelayedLiveReloadTrigger(this.liveReloadServer, this.requestFactory, ''))
			.withMessageContaining('URL must not be empty');
	}
	@Test
	void triggerReloadOnStatus() throws Exception {
		given(this.errorRequest.execute()).willReturn(this.errorResponse);
		given(this.okRequest.execute()).willReturn(this.okResponse);
		given(this.errorResponse.getStatusCode()).willReturn(HttpStatus.INTERNAL_SERVER_ERROR);
		given(this.okResponse.getStatusCode()).willReturn(HttpStatus.OK);
		given(this.requestFactory.createRequest(new URI(URL), HttpMethod.GET)).willThrow(new IOException())
			.willReturn(this.errorRequest, this.okRequest);
		long startTime = System.currentTimeMillis();
		this.trigger.setTimings(10, 200, 30000);
		this.trigger.run();
		assertThat(System.currentTimeMillis() - startTime).isGreaterThan(300L);
		then(this.liveReloadServer).should().triggerReload();
	}
	@Test
	void timeout() throws Exception {
		given(this.requestFactory.createRequest(new URI(URL), HttpMethod.GET)).willThrow(new IOException());
		this.trigger.setTimings(10, 0, 10);
		this.trigger.run();
		then(this.liveReloadServer).should(never()).triggerReload();
	}
}
/*
package org.springframework.boot.devtools.remote.client;
/**
class ClassPathChangeUploaderTests {
	private MockClientHttpRequestFactory requestFactory;
	private ClassPathChangeUploader uploader;
	@BeforeEach
	void setup() {
		this.requestFactory = new MockClientHttpRequestFactory();
		this.uploader = new ClassPathChangeUploader('http://localhost/upload', this.requestFactory);
	}
	@Test
	void urlMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassPathChangeUploader(null, this.requestFactory))
			.withMessageContaining('URL must not be empty');
	}
	@Test
	void urlMustNotBeEmpty() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassPathChangeUploader('', this.requestFactory))
			.withMessageContaining('URL must not be empty');
	}
	@Test
	void requestFactoryMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ClassPathChangeUploader('http://localhost:8080', null))
			.withMessageContaining('RequestFactory must not be null');
	}
	@Test
	void urlMustNotBeMalformed() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ClassPathChangeUploader('htttttp:///ttest', this.requestFactory))
			.withMessageContaining('Malformed URL "htttttp:///ttest"');
	}
	@Test
	void sendsClassLoaderFiles(@TempDir File sourceDirectory) throws Exception {
		ClassPathChangedEvent event = createClassPathChangedEvent(sourceDirectory);
		this.requestFactory.willRespond(HttpStatus.OK);
		this.uploader.onApplicationEvent(event);
		assertThat(this.requestFactory.getExecutedRequests()).hasSize(1);
		MockClientHttpRequest request = this.requestFactory.getExecutedRequests().get(0);
		verifyUploadRequest(sourceDirectory, request);
	}
	@Test
	void retriesOnSocketException(@TempDir File sourceDirectory) throws Exception {
		ClassPathChangedEvent event = createClassPathChangedEvent(sourceDirectory);
		this.requestFactory.willRespond(new SocketException());
		this.requestFactory.willRespond(HttpStatus.OK);
		this.uploader.onApplicationEvent(event);
		assertThat(this.requestFactory.getExecutedRequests()).hasSize(2);
		verifyUploadRequest(sourceDirectory, this.requestFactory.getExecutedRequests().get(1));
	}
	private void verifyUploadRequest(File sourceDirectory, MockClientHttpRequest request)
			throws IOException, ClassNotFoundException {
		ClassLoaderFiles classLoaderFiles = deserialize(request.getBodyAsBytes());
		Collection<SourceDirectory> sourceDirectories = classLoaderFiles.getSourceDirectories();
		assertThat(sourceDirectories).hasSize(1);
		SourceDirectory classSourceDirectory = sourceDirectories.iterator().next();
		assertThat(classSourceDirectory.getName()).isEqualTo(sourceDirectory.getAbsolutePath());
		Iterator<ClassLoaderFile> classFiles = classSourceDirectory.getFiles().iterator();
		assertClassFile(classFiles.next(), 'File1', ClassLoaderFile.Kind.ADDED);
		assertClassFile(classFiles.next(), 'File2', ClassLoaderFile.Kind.MODIFIED);
		assertClassFile(classFiles.next(), null, ClassLoaderFile.Kind.DELETED);
		assertThat(classFiles.hasNext()).isFalse();
	}
	private void assertClassFile(ClassLoaderFile file, String content, Kind kind) {
		assertThat(file.getContents()).isEqualTo((content != null) ? content.getBytes() : null);
		assertThat(file.getKind()).isEqualTo(kind);
	}
	private ClassPathChangedEvent createClassPathChangedEvent(File sourceDirectory) throws IOException {
		Set<ChangedFile> files = new LinkedHashSet<>();
		File file1 = createFile(sourceDirectory, 'File1');
		File file2 = createFile(sourceDirectory, 'File2');
		File file3 = createFile(sourceDirectory, 'File3');
		files.add(new ChangedFile(sourceDirectory, file1, Type.ADD));
		files.add(new ChangedFile(sourceDirectory, file2, Type.MODIFY));
		files.add(new ChangedFile(sourceDirectory, file3, Type.DELETE));
		Set<ChangedFiles> changeSet = new LinkedHashSet<>();
		changeSet.add(new ChangedFiles(sourceDirectory, files));
		return new ClassPathChangedEvent(this, changeSet, false);
	}
	private File createFile(File sourceDirectory, String name) throws IOException {
		File file = new File(sourceDirectory, name);
		FileCopyUtils.copy(name.getBytes(), file);
		return file;
	}
	private ClassLoaderFiles deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
		ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));
		return (ClassLoaderFiles) objectInputStream.readObject();
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class OptionalLiveReloadServerTests {
	@Test
	void nullServer() {
		OptionalLiveReloadServer server = new OptionalLiveReloadServer(null);
		server.startServer();
		server.triggerReload();
	}
	@Test
	void serverWontStart() throws Exception {
		LiveReloadServer delegate = mock(LiveReloadServer.class);
		OptionalLiveReloadServer server = new OptionalLiveReloadServer(delegate);
		willThrow(new RuntimeException('Error')).given(delegate).start();
		server.startServer();
		server.triggerReload();
		then(delegate).should(never()).triggerReload();
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class DevToolsPropertiesTests {
	private final DevToolsProperties devToolsProperties = new DevToolsProperties();
	@Test
	void additionalExcludeKeepsDefaults() {
		DevToolsProperties.Restart restart = this.devToolsProperties.getRestart();
		restart.setAdditionalExclude('foo/**,bar/**');
		assertThat(restart.getAllExclude()).containsOnly('META-INF/maven/**', 'META-INF/resources/**', 'resources/**',
				'static/**', 'public/**', 'templates/**', '**/*Test.class', '**/*Tests.class', 'git.properties',
				'META-INF/build-info.properties', 'foo/**', 'bar/**');
	}
	@Test
	void additionalExcludeNoDefault() {
		DevToolsProperties.Restart restart = this.devToolsProperties.getRestart();
		restart.setExclude('');
		restart.setAdditionalExclude('foo/**,bar/**');
		assertThat(restart.getAllExclude()).containsOnly('foo/**', 'bar/**');
	}
	@Test
	void additionalExcludeCustomDefault() {
		DevToolsProperties.Restart restart = this.devToolsProperties.getRestart();
		restart.setExclude('biz/**');
		restart.setAdditionalExclude('foo/**,bar/**');
		assertThat(restart.getAllExclude()).containsOnly('biz/**', 'foo/**', 'bar/**');
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class OnEnabledDevToolsConditionTests {
	private AnnotationConfigApplicationContext context;
	@BeforeEach
	void setup() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(TestConfiguration.class);
	}
	@Test
	void outcomeWhenDevtoolsShouldBeEnabledIsTrueShouldMatch() throws Exception {
		AtomicBoolean containsBean = new AtomicBoolean();
		Thread thread = new Thread(() -> {
			OnEnabledDevToolsConditionTests.this.context.refresh();
			containsBean.set(OnEnabledDevToolsConditionTests.this.context.containsBean('test'));
		});
		thread.start();
		thread.join();
		assertThat(containsBean).isTrue();
	}
	@Test
	void outcomeWhenDevtoolsShouldBeEnabledIsFalseShouldNotMatch() {
		OnEnabledDevToolsConditionTests.this.context.refresh();
		assertThat(OnEnabledDevToolsConditionTests.this.context.containsBean('test')).isFalse();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		@Conditional(OnEnabledDevToolsCondition.class)
		String test() {
			return 'hello';
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class DevToolsR2dbcAutoConfigurationTests {
	static List<ConnectionFactory> shutdowns = Collections.synchronizedList(new ArrayList<>());
	abstract static class Common {
		@BeforeEach
		void reset() {
			shutdowns.clear();
		}
		@Test
		void autoConfiguredInMemoryConnectionFactoryIsShutdown() throws Exception {
			ConfigurableApplicationContext context = getContext(this::createContext);
			ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
			context.close();
			assertThat(shutdowns).contains(connectionFactory);
		}
		@Test
		void nonEmbeddedConnectionFactoryIsNotShutdown() throws Exception {
			ConfigurableApplicationContext context = getContext(() -> createContext('r2dbc:h2:file:///testdb'));
			ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
			context.close();
			assertThat(shutdowns).doesNotContain(connectionFactory);
		}
		@Test
		void singleManuallyConfiguredConnectionFactoryIsNotClosed() throws Exception {
			ConfigurableApplicationContext context = getContext(
					() -> createContext(SingleConnectionFactoryConfiguration.class));
			ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
			context.close();
			assertThat(shutdowns).doesNotContain(connectionFactory);
		}
		@Test
		void multipleConnectionFactoriesAreIgnored() throws Exception {
			ConfigurableApplicationContext context = getContext(
					() -> createContext(MultipleConnectionFactoriesConfiguration.class));
			Collection<ConnectionFactory> connectionFactory = context.getBeansOfType(ConnectionFactory.class).values();
			context.close();
			assertThat(shutdowns).doesNotContainAnyElementsOf(connectionFactory);
		}
		@Test
		void emptyFactoryMethodMetadataIgnored() throws Exception {
			ConfigurableApplicationContext context = getContext(this::getEmptyFactoryMethodMetadataIgnoredContext);
			ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
			context.close();
			assertThat(shutdowns).doesNotContain(connectionFactory);
		}
		private ConfigurableApplicationContext getEmptyFactoryMethodMetadataIgnoredContext() {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			ConnectionFactory connectionFactory = new MockConnectionFactory();
			AnnotatedGenericBeanDefinition beanDefinition = new AnnotatedGenericBeanDefinition(
					connectionFactory.getClass());
			context.registerBeanDefinition('connectionFactory', beanDefinition);
			context.register(R2dbcAutoConfiguration.class, DevToolsR2dbcAutoConfiguration.class);
			context.refresh();
			return context;
		}
		protected ConfigurableApplicationContext getContext(Supplier<ConfigurableApplicationContext> supplier)
				throws Exception {
			AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>();
			Thread thread = new Thread(() -> {
				ConfigurableApplicationContext context = supplier.get();
				atomicReference.getAndSet(context);
			});
			thread.start();
			thread.join();
			return atomicReference.get();
		}
		protected final ConfigurableApplicationContext createContext(Class<?>... classes) {
			return createContext(null, classes);
		}
		protected final ConfigurableApplicationContext createContext(String url, Class<?>... classes) {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			if (!ObjectUtils.isEmpty(classes)) {
				context.register(classes);
			}
			context.register(R2dbcAutoConfiguration.class, DevToolsR2dbcAutoConfiguration.class);
			if (url != null) {
				TestPropertyValues.of('spring.r2dbc.url:' + url).applyTo(context);
			}
			context.addApplicationListener(ApplicationListener.forPayload(this::onEvent));
			context.refresh();
			return context;
		}
		private void onEvent(R2dbcDatabaseShutdownEvent event) {
			shutdowns.add(event.getConnectionFactory());
		}
	}
	@Nested
	@ClassPathExclusions('r2dbc-pool*.jar')
	class Embedded extends Common {
	}
	@Nested
	class Pooled extends Common {
	}
	@Configuration(proxyBeanMethods = false)
	static class SingleConnectionFactoryConfiguration {
		@Bean
		ConnectionFactory connectionFactory() {
			return new MockConnectionFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleConnectionFactoriesConfiguration {
		@Bean
		ConnectionFactory connectionFactoryOne() {
			return new MockConnectionFactory();
		}
		@Bean
		ConnectionFactory connectionFactoryTwo() {
			return new MockConnectionFactory();
		}
	}
	private static final class MockConnectionFactory implements ConnectionFactory {
		@Override
		public Publisher<? extends Connection> create() {
			return null;
		}
		@Override
		public ConnectionFactoryMetadata getMetadata() {
			return null;
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@ExtendWith(MockRestarter.class)
class RemoteDevToolsAutoConfigurationTests {
	private static final String DEFAULT_CONTEXT_PATH = RemoteDevToolsProperties.DEFAULT_CONTEXT_PATH;
	private static final String DEFAULT_SECRET_HEADER_NAME = RemoteDevToolsProperties.DEFAULT_SECRET_HEADER_NAME;
	private AnnotationConfigServletWebApplicationContext context;
	private MockHttpServletRequest request;
	private MockHttpServletResponse response;
	private MockFilterChain chain;
	@BeforeEach
	void setup() {
		this.request = new MockHttpServletRequest();
		this.response = new MockHttpServletResponse();
		this.chain = new MockFilterChain();
	}
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void disabledIfRemoteSecretIsMissing() throws Exception {
		this.context = getContext(() -> loadContext('a:b'));
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(DispatcherFilter.class));
	}
	@Test
	void ignoresUnmappedUrl() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		this.request.setRequestURI('/restart');
		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, 'supersecret');
		filter.doFilter(this.request, this.response, this.chain);
		assertRestartInvoked(false);
	}
	@Test
	void ignoresIfMissingSecretFromRequest() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		this.request.setRequestURI(DEFAULT_CONTEXT_PATH + '/restart');
		filter.doFilter(this.request, this.response, this.chain);
		assertRestartInvoked(false);
	}
	@Test
	void ignoresInvalidSecretInRequest() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		this.request.setRequestURI(DEFAULT_CONTEXT_PATH + '/restart');
		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, 'invalid');
		filter.doFilter(this.request, this.response, this.chain);
		assertRestartInvoked(false);
	}
	@Test
	void invokeRestartWithDefaultSetup() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		this.request.setRequestURI(DEFAULT_CONTEXT_PATH + '/restart');
		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, 'supersecret');
		filter.doFilter(this.request, this.response, this.chain);
		assertRestartInvoked(true);
	}
	@Test
	void invokeRestartWithCustomServerContextPath() throws Exception {
		this.context = getContext(
				() -> loadContext('spring.devtools.remote.secret:supersecret', 'server.servlet.context-path:/test'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		this.request.setRequestURI('/test' + DEFAULT_CONTEXT_PATH + '/restart');
		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, 'supersecret');
		filter.doFilter(this.request, this.response, this.chain);
		assertRestartInvoked(true);
	}
	@Test
	void securityConfigurationShouldAllowAccess() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		MockMvcTester mvc = MockMvcTester.from(this.context,
				(builder) -> builder.apply(springSecurity()).addFilter(filter).build());
		assertThat(mvc.get().uri(DEFAULT_CONTEXT_PATH + '/restart').header(DEFAULT_SECRET_HEADER_NAME, 'supersecret'))
			.hasStatusOk();
		assertRestartInvoked(true);
		assertThat(this.context.containsBean('devtoolsSecurityFilterChain')).isTrue();
	}
	@Test
	void securityConfigurationShouldAllowAccessToCustomPath() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret',
				'server.servlet.context-path:/test', 'spring.devtools.remote.context-path:/custom'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		MockMvcTester mvc = MockMvcTester.from(this.context,
				(builder) -> builder.apply(springSecurity()).addFilter(filter).build());
		assertThat(mvc.get().uri('/test/custom/restart').header(DEFAULT_SECRET_HEADER_NAME, 'supersecret'))
			.hasStatusOk();
		assertRestartInvoked(true);
	}
	@Test
	void securityConfigurationDoesNotAffectOtherPaths() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class);
		MockMvcTester mvc = MockMvcTester.from(this.context,
				(builder) -> builder.addFilter(securityFilterChain).addFilter(filter).build());
		assertThat(mvc.get().uri('/my-path')).hasStatus(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void disableRestart() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret',
				'spring.devtools.remote.restart.enabled:false'));
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean('remoteRestartHandlerMapper'));
	}
	@Test
	void devToolsHealthReturns200() throws Exception {
		this.context = getContext(() -> loadContext('spring.devtools.remote.secret:supersecret'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		this.request.setRequestURI(DEFAULT_CONTEXT_PATH);
		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, 'supersecret');
		this.response.setStatus(500);
		filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.response.getStatus()).isEqualTo(200);
	}
	@Test
	void devToolsHealthWithCustomServerContextPathReturns200() throws Exception {
		this.context = getContext(
				() -> loadContext('spring.devtools.remote.secret:supersecret', 'server.servlet.context-path:/test'));
		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);
		this.request.setRequestURI('/test' + DEFAULT_CONTEXT_PATH);
		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, 'supersecret');
		this.response.setStatus(500);
		filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.response.getStatus()).isEqualTo(200);
	}
	private AnnotationConfigServletWebApplicationContext getContext(
			Supplier<AnnotationConfigServletWebApplicationContext> supplier) throws Exception {
		AtomicReference<AnnotationConfigServletWebApplicationContext> atomicReference = new AtomicReference<>();
		Thread thread = new Thread(() -> {
			AnnotationConfigServletWebApplicationContext context = supplier.get();
			atomicReference.getAndSet(context);
		});
		thread.start();
		thread.join();
		return atomicReference.get();
	}
	private void assertRestartInvoked(boolean value) {
		assertThat(this.context.getBean(MockHttpRestartServer.class).invoked).isEqualTo(value);
	}
	private AnnotationConfigServletWebApplicationContext loadContext(String... properties) {
		AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext();
		context.setServletContext(new MockServletContext());
		context.register(Config.class, SecurityAutoConfiguration.class, RemoteDevToolsAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		TestPropertyValues.of(properties).applyTo(context);
		context.refresh();
		return context;
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		HttpRestartServer remoteRestartHttpRestartServer() {
			SourceDirectoryUrlFilter sourceDirectoryUrlFilter = mock(SourceDirectoryUrlFilter.class);
			return new MockHttpRestartServer(sourceDirectoryUrlFilter);
		}
	}
	/**
	 * Mock {@link HttpRestartServer} implementation.
	 */
	static class MockHttpRestartServer extends HttpRestartServer {
		private boolean invoked;
		MockHttpRestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter) {
			super(sourceDirectoryUrlFilter);
		}
		@Override
		public void handle(ServerHttpRequest request, ServerHttpResponse response) {
			this.invoked = true;
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@ClassPathExclusions('HikariCP-*.jar')
class DevToolsEmbeddedDataSourceAutoConfigurationTests extends AbstractDevToolsDataSourceAutoConfigurationTests {
	@Test
	void autoConfiguredDataSourceIsNotShutdown() throws SQLException {
		ConfigurableApplicationContext context = createContext(DataSourceAutoConfiguration.class,
				DataSourceSpyConfiguration.class);
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should(never()).execute('SHUTDOWN');
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
abstract class AbstractDevToolsDataSourceAutoConfigurationTests {
	@Test
	void singleManuallyConfiguredDataSourceIsNotClosed() throws Exception {
		ConfigurableApplicationContext context = getContext(() -> createContext(SingleDataSourceConfiguration.class));
		DataSource dataSource = context.getBean(DataSource.class);
		Statement statement = configureDataSourceBehavior(dataSource);
		then(statement).should(never()).execute('SHUTDOWN');
	}
	@Test
	void multipleDataSourcesAreIgnored() throws Exception {
		ConfigurableApplicationContext context = getContext(
				() -> createContext(MultipleDataSourcesConfiguration.class));
		Collection<DataSource> dataSources = context.getBeansOfType(DataSource.class).values();
		for (DataSource dataSource : dataSources) {
			Statement statement = configureDataSourceBehavior(dataSource);
			then(statement).should(never()).execute('SHUTDOWN');
		}
	}
	@Test
	void emptyFactoryMethodMetadataIgnored() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		DataSource dataSource = mock(DataSource.class);
		AnnotatedGenericBeanDefinition beanDefinition = new AnnotatedGenericBeanDefinition(dataSource.getClass());
		context.registerBeanDefinition('dataSource', beanDefinition);
		context.register(DevToolsDataSourceAutoConfiguration.class);
		context.refresh();
		context.close();
	}
	protected final Statement configureDataSourceBehavior(DataSource dataSource) throws SQLException {
		Connection connection = mock(Connection.class);
		Statement statement = mock(Statement.class);
		willReturn(connection).given(dataSource).getConnection();
		given(connection.createStatement()).willReturn(statement);
		return statement;
	}
	protected ConfigurableApplicationContext getContext(Supplier<ConfigurableApplicationContext> supplier)
			throws Exception {
		AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>();
		Thread thread = new Thread(() -> {
			ConfigurableApplicationContext context = supplier.get();
			atomicReference.getAndSet(context);
		});
		thread.start();
		thread.join();
		return atomicReference.get();
	}
	protected final ConfigurableApplicationContext createContext(Class<?>... classes) {
		return createContext(null, classes);
	}
	protected final ConfigurableApplicationContext createContext(String driverClassName, Class<?>... classes) {
		return createContext(driverClassName, null, classes);
	}
	protected final ConfigurableApplicationContext createContext(String driverClassName, String url,
			Class<?>... classes) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(classes);
		context.register(DevToolsDataSourceAutoConfiguration.class);
		if (driverClassName != null) {
			TestPropertyValues.of('spring.datasource.driver-class-name:' + driverClassName).applyTo(context);
		}
		if (url != null) {
			TestPropertyValues.of('spring.datasource.url:' + url).applyTo(context);
		}
		context.refresh();
		return context;
	}
	@Configuration(proxyBeanMethods = false)
	static class SingleDataSourceConfiguration {
		@Bean
		DataSource dataSource() {
			return mock(DataSource.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleDataSourcesConfiguration {
		@Bean
		DataSource dataSourceOne() {
			return mock(DataSource.class);
		}
		@Bean
		DataSource dataSourceTwo() {
			return mock(DataSource.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataSourceSpyConfiguration {
		@Bean
		static DataSourceSpyBeanPostProcessor dataSourceSpyBeanPostProcessor() {
			return new DataSourceSpyBeanPostProcessor();
		}
	}
	static class DataSourceSpyBeanPostProcessor implements BeanPostProcessor {
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			if (bean instanceof DataSource) {
				bean = spy(bean);
			}
			return bean;
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) {
			return bean;
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class DevToolsPooledDataSourceAutoConfigurationTests extends AbstractDevToolsDataSourceAutoConfigurationTests {
	@BeforeEach
	void before(@TempDir File tempDir) {
		System.setProperty('derby.stream.error.file', new File(tempDir, 'derby.log').getAbsolutePath());
	}
	@AfterEach
	void after() {
		System.clearProperty('derby.stream.error.file');
	}
	@Test
	void autoConfiguredInMemoryDataSourceIsShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(
				() -> createContext(DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should().execute('SHUTDOWN');
	}
	@Test
	void autoConfiguredExternalDataSourceIsNotShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(() -> createContext('org.postgresql.Driver',
				DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should(never()).execute('SHUTDOWN');
	}
	@Test
	void h2ServerIsNotShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(() -> createContext('org.h2.Driver',
				'jdbc:h2:hsql://localhost', DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should(never()).execute('SHUTDOWN');
	}
	@Test
	void inMemoryH2IsShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(() -> createContext('org.h2.Driver', 'jdbc:h2:mem:test',
				DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should().execute('SHUTDOWN');
	}
	@Test
	void hsqlServerIsNotShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(() -> createContext('org.hsqldb.jdbcDriver',
				'jdbc:hsqldb:hsql://localhost', DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should(never()).execute('SHUTDOWN');
	}
	@Test
	void inMemoryHsqlIsShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(() -> createContext('org.hsqldb.jdbcDriver',
				'jdbc:hsqldb:mem:test', DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should().execute('SHUTDOWN');
	}
	@Test
	void derbyClientIsNotShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(() -> createContext('org.apache.derby.jdbc.ClientDriver',
				'jdbc:derby://localhost', DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		Statement statement = configureDataSourceBehavior(context.getBean(DataSource.class));
		context.close();
		then(statement).should(never()).execute('SHUTDOWN');
	}
	@Test
	void inMemoryDerbyIsShutdown() throws Exception {
		ConfigurableApplicationContext context = getContext(
				() -> createContext('org.apache.derby.jdbc.EmbeddedDriver', 'jdbc:derby:memory:test;create=true',
						DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));
		HikariDataSource dataSource = context.getBean(HikariDataSource.class);
		JdbcTemplate jdbc = new JdbcTemplate(dataSource);
		jdbc.execute('SELECT 1 FROM SYSIBM.SYSDUMMY1');
		HikariPoolMXBean pool = dataSource.getHikariPoolMXBean();
		// Prevent a race between Hikari"s initialization and Derby shutdown
		Awaitility.await()
			.atMost(Duration.ofSeconds(30))
			.until(pool::getIdleConnections, (idle) -> idle == dataSource.getMinimumIdle());
		context.close();
		// Connect should fail as DB no longer exists
		assertThatExceptionOfType(SQLException.class)
			.isThrownBy(() -> new EmbeddedDriver().connect('jdbc:derby:memory:test', new Properties()))
			.satisfies((ex) -> assertThat(ex.getSQLState()).isEqualTo('XJ004'));
		// Shut Derby down fully so that it closes its log file
		assertThatExceptionOfType(SQLException.class)
			.isThrownBy(() -> new EmbeddedDriver().connect('jdbc:derby:;shutdown=true', new Properties()));
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@ExtendWith(MockRestarter.class)
class LocalDevToolsAutoConfigurationTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void cleanup() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void defaultPropertyCanBeOverriddenFromCommandLine() throws Exception {
		this.context = getContext(() -> initializeAndRun(Config.class, '--spring.freemarker.cache=true'));
		AbstractTemplateViewResolver resolver = this.context.getBean(AbstractTemplateViewResolver.class);
		assertThat(resolver.isCache()).isTrue();
	}
	@Test
	void defaultPropertyCanBeOverriddenFromUserHomeProperties() throws Exception {
		String userHome = System.getProperty('user.home');
		System.setProperty('user.home', new File('src/test/resources/user-home').getAbsolutePath());
		try {
			this.context = getContext(() -> initializeAndRun(Config.class));
			AbstractTemplateViewResolver resolver = this.context.getBean(AbstractTemplateViewResolver.class);
			assertThat(resolver.isCache()).isTrue();
		}
		finally {
			System.setProperty('user.home', userHome);
		}
	}
	@Test
	void resourceCachePeriodIsZero() throws Exception {
		this.context = getContext(() -> initializeAndRun(WebResourcesConfig.class));
		Resources properties = this.context.getBean(WebProperties.class).getResources();
		assertThat(properties.getCache().getPeriod()).isZero();
	}
	@Test
	void liveReloadServer() throws Exception {
		this.context = getContext(() -> initializeAndRun(Config.class));
		LiveReloadServer server = this.context.getBean(LiveReloadServer.class);
		assertThat(server.isStarted()).isTrue();
	}
	@Test
	void liveReloadTriggeredOnContextRefresh() throws Exception {
		this.context = getContext(() -> initializeAndRun(ConfigWithMockLiveReload.class));
		LiveReloadServer server = this.context.getBean(LiveReloadServer.class);
		reset(server);
		this.context.publishEvent(new ContextRefreshedEvent(this.context));
		then(server).should().triggerReload();
	}
	@Test
	void liveReloadTriggeredOnClassPathChangeWithoutRestart() throws Exception {
		this.context = getContext(() -> initializeAndRun(ConfigWithMockLiveReload.class));
		LiveReloadServer server = this.context.getBean(LiveReloadServer.class);
		reset(server);
		ClassPathChangedEvent event = new ClassPathChangedEvent(this.context, Collections.emptySet(), false);
		this.context.publishEvent(event);
		then(server).should().triggerReload();
	}
	@Test
	void liveReloadNotTriggeredOnClassPathChangeWithRestart() throws Exception {
		this.context = getContext(() -> initializeAndRun(ConfigWithMockLiveReload.class));
		LiveReloadServer server = this.context.getBean(LiveReloadServer.class);
		reset(server);
		ClassPathChangedEvent event = new ClassPathChangedEvent(this.context, Collections.emptySet(), true);
		this.context.publishEvent(event);
		then(server).should(never()).triggerReload();
	}
	@Test
	void liveReloadDisabled() throws Exception {
		Map<String, Object> properties = new HashMap<>();
		properties.put('spring.devtools.livereload.enabled', false);
		this.context = getContext(() -> initializeAndRun(Config.class, properties));
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(OptionalLiveReloadServer.class));
	}
	@Test
	void restartTriggeredOnClassPathChangeWithRestart(Restarter restarter) throws Exception {
		this.context = getContext(() -> initializeAndRun(Config.class));
		ClassPathChangedEvent event = new ClassPathChangedEvent(this.context, Collections.emptySet(), true);
		this.context.publishEvent(event);
		then(restarter).should().restart(any(FailureHandler.class));
	}
	@Test
	void restartNotTriggeredOnClassPathChangeWithRestart(Restarter restarter) throws Exception {
		this.context = getContext(() -> initializeAndRun(Config.class));
		ClassPathChangedEvent event = new ClassPathChangedEvent(this.context, Collections.emptySet(), false);
		this.context.publishEvent(event);
		then(restarter).should(never()).restart();
	}
	@Test
	void restartWatchingClassPath() throws Exception {
		this.context = getContext(() -> initializeAndRun(Config.class));
		ClassPathFileSystemWatcher watcher = this.context.getBean(ClassPathFileSystemWatcher.class);
		assertThat(watcher).isNotNull();
	}
	@Test
	void restartDisabled() throws Exception {
		Map<String, Object> properties = new HashMap<>();
		properties.put('spring.devtools.restart.enabled', false);
		this.context = getContext(() -> initializeAndRun(Config.class, properties));
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(ClassPathFileSystemWatcher.class));
	}
	@Test
	void restartWithTriggerFile() throws Exception {
		Map<String, Object> properties = new HashMap<>();
		properties.put('spring.devtools.restart.trigger-file', 'somefile.txt');
		this.context = getContext(() -> initializeAndRun(Config.class, properties));
		ClassPathFileSystemWatcher classPathWatcher = this.context.getBean(ClassPathFileSystemWatcher.class);
		Object watcher = ReflectionTestUtils.getField(classPathWatcher, 'fileSystemWatcher');
		Object filter = ReflectionTestUtils.getField(watcher, 'triggerFilter');
		assertThat(filter).isInstanceOf(TriggerFileFilter.class);
	}
	@Test
	void watchingAdditionalPaths() throws Exception {
		Map<String, Object> properties = new HashMap<>();
		properties.put('spring.devtools.restart.additional-paths', 'src/main/java,src/test/java');
		this.context = getContext(() -> initializeAndRun(Config.class, properties));
		ClassPathFileSystemWatcher classPathWatcher = this.context.getBean(ClassPathFileSystemWatcher.class);
		Object watcher = ReflectionTestUtils.getField(classPathWatcher, 'fileSystemWatcher');
		@SuppressWarnings('unchecked')
		Map<File, Object> directories = (Map<File, Object>) ReflectionTestUtils.getField(watcher, 'directories');
		assertThat(directories).hasSize(2)
			.containsKey(new File('src/main/java').getAbsoluteFile())
			.containsKey(new File('src/test/java').getAbsoluteFile());
	}
	@Test
	void devToolsSwitchesJspServletToDevelopmentMode() throws Exception {
		this.context = getContext(() -> initializeAndRun(Config.class));
		TomcatWebServer tomcatContainer = (TomcatWebServer) ((ServletWebServerApplicationContext) this.context)
			.getWebServer();
		Container context = tomcatContainer.getTomcat().getHost().findChildren()[0];
		StandardWrapper jspServletWrapper = (StandardWrapper) context.findChild('jsp');
		EmbeddedServletOptions options = (EmbeddedServletOptions) ReflectionTestUtils
			.getField(jspServletWrapper.getServlet(), 'options');
		assertThat(options.getDevelopment()).isTrue();
	}
	private ConfigurableApplicationContext getContext(Supplier<ConfigurableApplicationContext> supplier)
			throws Exception {
		AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>();
		Thread thread = new Thread(() -> {
			ConfigurableApplicationContext context = supplier.get();
			atomicReference.getAndSet(context);
		});
		thread.start();
		thread.join();
		return atomicReference.get();
	}
	private ConfigurableApplicationContext initializeAndRun(Class<?> config, String... args) {
		return initializeAndRun(config, Collections.emptyMap(), args);
	}
	private ConfigurableApplicationContext initializeAndRun(Class<?> config, Map<String, Object> properties,
			String... args) {
		Restarter.initialize(new String[0], false, new MockRestartInitializer(), false);
		SpringApplication application = new SpringApplication(config);
		application.setDefaultProperties(getDefaultProperties(properties));
		return application.run(args);
	}
	private Map<String, Object> getDefaultProperties(Map<String, Object> specifiedProperties) {
		Map<String, Object> properties = new HashMap<>();
		properties.put('spring.devtools.livereload.port', 0);
		properties.put('server.port', 0);
		properties.putAll(specifiedProperties);
		return properties;
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ServletWebServerFactoryAutoConfiguration.class, LocalDevToolsAutoConfiguration.class,
			FreeMarkerAutoConfiguration.class })
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ ServletWebServerFactoryAutoConfiguration.class, LocalDevToolsAutoConfiguration.class,
			FreeMarkerAutoConfiguration.class })
	static class ConfigWithMockLiveReload {
		@Bean
		LiveReloadServer liveReloadServer() {
			return mock(LiveReloadServer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ServletWebServerFactoryAutoConfiguration.class, LocalDevToolsAutoConfiguration.class,
			WebProperties.class })
	static class WebResourcesConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class SessionRedisTemplateConfig {
		@Bean
		RedisTemplate<Object, Object> sessionRedisTemplate() {
			RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();
			redisTemplate.setConnectionFactory(mock(RedisConnectionFactory.class));
			return redisTemplate;
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class TriggerFileFilterTests {
	@TempDir
	File tempDir;
	@Test
	void nameMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TriggerFileFilter(null))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void acceptNameMatch() throws Exception {
		File file = new File(this.tempDir, 'thefile.txt');
		file.createNewFile();
		assertThat(new TriggerFileFilter('thefile.txt').accept(file)).isTrue();
	}
	@Test
	void doesNotAcceptNameMismatch() throws Exception {
		File file = new File(this.tempDir, 'notthefile.txt');
		file.createNewFile();
		assertThat(new TriggerFileFilter('thefile.txt').accept(file)).isFalse();
	}
	@Test
	void testName() throws Exception {
		File file = new File(this.tempDir, '.triggerfile');
		file.createNewFile();
		assertThat(new TriggerFileFilter('.triggerfile').accept(file)).isTrue();
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
class PatternClassPathRestartStrategyTests {
	@Test
	void nullPattern() {
		ClassPathRestartStrategy strategy = createStrategy(null);
		assertRestartRequired(strategy, 'a/b.txt', true);
	}
	@Test
	void emptyPattern() {
		ClassPathRestartStrategy strategy = createStrategy('');
		assertRestartRequired(strategy, 'a/b.txt', true);
	}
	@Test
	void singlePattern() {
		ClassPathRestartStrategy strategy = createStrategy('static/**');
		assertRestartRequired(strategy, 'static/file.txt', false);
		assertRestartRequired(strategy, 'static/directory/file.txt', false);
		assertRestartRequired(strategy, 'public/file.txt', true);
		assertRestartRequired(strategy, 'public/directory/file.txt', true);
	}
	@Test
	void multiplePatterns() {
		ClassPathRestartStrategy strategy = createStrategy('static/**,public/**');
		assertRestartRequired(strategy, 'static/file.txt', false);
		assertRestartRequired(strategy, 'static/directory/file.txt', false);
		assertRestartRequired(strategy, 'public/file.txt', false);
		assertRestartRequired(strategy, 'public/directory/file.txt', false);
		assertRestartRequired(strategy, 'src/file.txt', true);
		assertRestartRequired(strategy, 'src/directory/file.txt', true);
	}
	@Test
	void pomChange() {
		ClassPathRestartStrategy strategy = createStrategy('META-INF/maven/**');
		assertRestartRequired(strategy, 'pom.xml', true);
		String mavenDirectory = 'META-INF/maven/org.springframework.boot/spring-boot-devtools';
		assertRestartRequired(strategy, mavenDirectory + '/pom.xml', false);
		assertRestartRequired(strategy, mavenDirectory + '/pom.properties', false);
	}
	@Test
	void testChange() {
		ClassPathRestartStrategy strategy = createStrategy('**/*Test.class,**/*Tests.class');
		assertRestartRequired(strategy, 'com/example/ExampleTests.class', false);
		assertRestartRequired(strategy, 'com/example/ExampleTest.class', false);
		assertRestartRequired(strategy, 'com/example/Example.class', true);
	}
	private ClassPathRestartStrategy createStrategy(String pattern) {
		return new PatternClassPathRestartStrategy(pattern);
	}
	private void assertRestartRequired(ClassPathRestartStrategy strategy, String relativeName, boolean expected) {
		assertThat(strategy.isRestartRequired(mockFile(relativeName))).isEqualTo(expected);
	}
	private ChangedFile mockFile(String relativeName) {
		return new ChangedFile(new File('.'), new File('./' + relativeName), Type.ADD);
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
@ExtendWith(MockitoExtension.class)
class ClassPathFileChangeListenerTests {
	@Mock
	private ApplicationEventPublisher eventPublisher;
	@Mock
	private ClassPathRestartStrategy restartStrategy;
	@Mock
	private FileSystemWatcher fileSystemWatcher;
	@Test
	void eventPublisherMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ClassPathFileChangeListener(null, this.restartStrategy, this.fileSystemWatcher))
			.withMessageContaining('EventPublisher must not be null');
	}
	@Test
	void restartStrategyMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ClassPathFileChangeListener(this.eventPublisher, null, this.fileSystemWatcher))
			.withMessageContaining('RestartStrategy must not be null');
	}
	@Test
	void sendsEventWithoutRestart() {
		testSendsEvent(false);
		then(this.fileSystemWatcher).should(never()).stop();
	}
	@Test
	void sendsEventWithRestart() {
		testSendsEvent(true);
		then(this.fileSystemWatcher).should().stop();
	}
	private void testSendsEvent(boolean restart) {
		ClassPathFileChangeListener listener = new ClassPathFileChangeListener(this.eventPublisher,
				this.restartStrategy, this.fileSystemWatcher);
		File directory = new File('s1');
		File file = new File('f1');
		ChangedFile file1 = new ChangedFile(directory, file, ChangedFile.Type.ADD);
		ChangedFile file2 = new ChangedFile(directory, file, ChangedFile.Type.ADD);
		Set<ChangedFile> files = new LinkedHashSet<>();
		files.add(file1);
		files.add(file2);
		ChangedFiles changedFiles = new ChangedFiles(new File('source'), files);
		Set<ChangedFiles> changeSet = Collections.singleton(changedFiles);
		if (restart) {
			given(this.restartStrategy.isRestartRequired(file2)).willReturn(true);
		}
		listener.onChange(changeSet);
		then(this.eventPublisher).should()
			.publishEvent(assertArg((applicationEvent) -> assertThat(applicationEvent)
				.isInstanceOfSatisfying(ClassPathChangedEvent.class, (classPathChangedEvent) -> {
					assertThat(classPathChangedEvent.getChangeSet()).isEqualTo(changeSet);
					assertThat(classPathChangedEvent.isRestartRequired()).isEqualTo(restart);
				})));
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
class ClassPathChangedEventTests {
	private final Object source = new Object();
	@Test
	void changeSetMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassPathChangedEvent(this.source, null, false))
			.withMessageContaining('ChangeSet must not be null');
	}
	@Test
	void getChangeSet() {
		Set<ChangedFiles> changeSet = new LinkedHashSet<>();
		ClassPathChangedEvent event = new ClassPathChangedEvent(this.source, changeSet, false);
		assertThat(event.getChangeSet()).isSameAs(changeSet);
	}
	@Test
	void getRestartRequired() {
		Set<ChangedFiles> changeSet = new LinkedHashSet<>();
		ClassPathChangedEvent event;
		event = new ClassPathChangedEvent(this.source, changeSet, false);
		assertThat(event.isRestartRequired()).isFalse();
		event = new ClassPathChangedEvent(this.source, changeSet, true);
		assertThat(event.isRestartRequired()).isTrue();
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
class ClassPathFileSystemWatcherTests {
	@Test
	void urlsMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ClassPathFileSystemWatcher(mock(FileSystemWatcherFactory.class),
					mock(ClassPathRestartStrategy.class), (URL[]) null))
			.withMessageContaining('Urls must not be null');
	}
	@Test
	void configuredWithRestartStrategy(@TempDir File directory) throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		Map<String, Object> properties = new HashMap<>();
		List<URL> urls = new ArrayList<>();
		urls.add(new URL('https://spring.io'));
		urls.add(directory.toURI().toURL());
		properties.put('urls', urls);
		MapPropertySource propertySource = new MapPropertySource('test', properties);
		context.getEnvironment().getPropertySources().addLast(propertySource);
		context.register(Config.class);
		context.refresh();
		Thread.sleep(200);
		File classFile = new File(directory, 'Example.class');
		FileCopyUtils.copy('file'.getBytes(), classFile);
		Thread.sleep(1000);
		List<ClassPathChangedEvent> events = context.getBean(Listener.class).getEvents();
		for (int i = 0; i < 20; i++) {
			if (!events.isEmpty()) {
				break;
			}
			Thread.sleep(500);
		}
		assertThat(events).hasSize(1);
		assertThat(events.get(0).getChangeSet().iterator().next()).extracting(ChangedFile::getFile)
			.containsExactly(classFile);
		context.close();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		public final Environment environment;
		Config(Environment environment) {
			this.environment = environment;
		}
		@Bean
		ClassPathFileSystemWatcher watcher(ClassPathRestartStrategy restartStrategy) {
			FileSystemWatcher watcher = new FileSystemWatcher(false, Duration.ofMillis(100), Duration.ofMillis(10));
			URL[] urls = this.environment.getProperty('urls', URL[].class);
			return new ClassPathFileSystemWatcher(new MockFileSystemWatcherFactory(watcher), restartStrategy, urls);
		}
		@Bean
		ClassPathRestartStrategy restartStrategy() {
			return (file) -> false;
		}
		@Bean
		Listener listener() {
			return new Listener();
		}
	}
	static class Listener implements ApplicationListener<ClassPathChangedEvent> {
		private final List<ClassPathChangedEvent> events = new CopyOnWriteArrayList<>();
		@Override
		public void onApplicationEvent(ClassPathChangedEvent event) {
			this.events.add(event);
		}
		List<ClassPathChangedEvent> getEvents() {
			return this.events;
		}
	}
	static class MockFileSystemWatcherFactory implements FileSystemWatcherFactory {
		private final FileSystemWatcher watcher;
		MockFileSystemWatcherFactory(FileSystemWatcher watcher) {
			this.watcher = watcher;
		}
		@Override
		public FileSystemWatcher getFileSystemWatcher() {
			return this.watcher;
		}
	}
}
/*
package org.springframework.boot.devtools.test;
/**
public class MockClientHttpRequestFactory implements ClientHttpRequestFactory {
	private static final byte[] NO_DATA = {};
	private final AtomicLong seq = new AtomicLong();
	private final Deque<Object> responses = new ArrayDeque<>();
	private final List<MockClientHttpRequest> executedRequests = new ArrayList<>();
	@Override
	public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {
		return new MockRequest(uri, httpMethod);
	}
	public void willRespond(HttpStatus... response) {
		for (HttpStatus status : response) {
			this.responses.add(new Response(0, null, status));
		}
	}
	public void willRespond(IOException... response) {
		for (IOException exception : response) {
			this.responses.addLast(exception);
		}
	}
	public void willRespond(String... response) {
		for (String payload : response) {
			this.responses.add(new Response(0, payload.getBytes(), HttpStatus.OK));
		}
	}
	public void willRespondAfterDelay(int delay, HttpStatus status) {
		this.responses.add(new Response(delay, null, status));
	}
	public List<MockClientHttpRequest> getExecutedRequests() {
		return this.executedRequests;
	}
	private class MockRequest extends MockClientHttpRequest {
		MockRequest(URI uri, HttpMethod httpMethod) {
			super(httpMethod, uri);
		}
		@Override
		protected ClientHttpResponse executeInternal() throws IOException {
			MockClientHttpRequestFactory.this.executedRequests.add(this);
			Object response = MockClientHttpRequestFactory.this.responses.pollFirst();
			if (response instanceof IOException ioException) {
				throw ioException;
			}
			if (response == null) {
				response = new Response(0, null, HttpStatus.GONE);
			}
			return ((Response) response).asHttpResponse(MockClientHttpRequestFactory.this.seq);
		}
	}
	static class Response {
		private final int delay;
		private final byte[] payload;
		private final HttpStatus status;
		Response(int delay, byte[] payload, HttpStatus status) {
			this.delay = delay;
			this.payload = payload;
			this.status = status;
		}
		ClientHttpResponse asHttpResponse(AtomicLong seq) {
			MockClientHttpResponse httpResponse = new MockClientHttpResponse(
					(this.payload != null) ? this.payload : NO_DATA, this.status);
			waitForDelay();
			if (this.payload != null) {
				httpResponse.getHeaders().setContentLength(this.payload.length);
				httpResponse.getHeaders().setContentType(MediaType.APPLICATION_OCTET_STREAM);
				httpResponse.getHeaders().add('x-seq', Long.toString(seq.incrementAndGet()));
			}
			return httpResponse;
		}
		private void waitForDelay() {
			if (this.delay > 0) {
				try {
					Thread.sleep(this.delay);
				}
				catch (InterruptedException ex) {
					// Ignore
				}
			}
		}
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
@SuppressWarnings('resource')
class ConnectionInputStreamTests {
	private static final byte[] NO_BYTES = {};
	@Test
	void readHeader() throws Exception {
		String header = '';
		for (int i = 0; i < 100; i++) {
			header += 'x-something-' + i + ': xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
		}
		String data = header + '\r\n\r\ncontent\r\n';
		ConnectionInputStream inputStream = new ConnectionInputStream(new ByteArrayInputStream(data.getBytes()));
		assertThat(inputStream.readHeader()).isEqualTo(header);
	}
	@Test
	void readFully() throws Exception {
		byte[] bytes = 'the data that we want to read fully'.getBytes();
		LimitedInputStream source = new LimitedInputStream(new ByteArrayInputStream(bytes), 2);
		ConnectionInputStream inputStream = new ConnectionInputStream(source);
		byte[] buffer = new byte[bytes.length];
		inputStream.readFully(buffer, 0, buffer.length);
		assertThat(buffer).isEqualTo(bytes);
	}
	@Test
	void checkedRead() {
		ConnectionInputStream inputStream = new ConnectionInputStream(new ByteArrayInputStream(NO_BYTES));
		assertThatIOException().isThrownBy(inputStream::checkedRead).withMessageContaining('End of stream');
	}
	@Test
	void checkedReadArray() {
		byte[] buffer = new byte[100];
		ConnectionInputStream inputStream = new ConnectionInputStream(new ByteArrayInputStream(NO_BYTES));
		assertThatIOException().isThrownBy(() -> inputStream.checkedRead(buffer, 0, buffer.length))
			.withMessageContaining('End of stream');
	}
	static class LimitedInputStream extends FilterInputStream {
		private final int max;
		protected LimitedInputStream(InputStream in, int max) {
			super(in);
			this.max = max;
		}
		@Override
		public int read(byte[] b, int off, int len) throws IOException {
			return super.read(b, off, Math.min(len, this.max));
		}
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
class LiveReloadServerTests {
	private static final String HANDSHAKE = '{command: "hello", '
			+ 'protocols: ["http://livereload.com/protocols/official-7"]}';
	private int port;
	private MonitoredLiveReloadServer server;
	@BeforeEach
	void setUp() throws Exception {
		this.server = new MonitoredLiveReloadServer(0);
		this.port = this.server.start();
	}
	@AfterEach
	void tearDown() throws Exception {
		this.server.stop();
	}
	@Test
	@Disabled
	void servesLivereloadJs() throws Exception {
		RestTemplate template = new RestTemplate();
		URI uri = new URI('http://localhost:' + this.port + '/livereload.js');
		String script = template.getForObject(uri, String.class);
		assertThat(script).contains('livereload.com/protocols/official-7');
	}
	@Test
	void triggerReload() throws Exception {
		LiveReloadWebSocketHandler handler = connect();
		this.server.triggerReload();
		List<String> messages = await().atMost(Duration.ofSeconds(10))
			.until(handler::getMessages, (msgs) -> msgs.size() == 2);
		assertThat(messages.get(0)).contains('http://livereload.com/protocols/official-7');
		assertThat(messages.get(1)).contains('command\':\'reload\'');
	}
	@Test // gh-26813
	void triggerReloadWithUppercaseHeaders() throws Exception {
		LiveReloadWebSocketHandler handler = connect(UppercaseWebSocketClient::new);
		this.server.triggerReload();
		List<String> messages = await().atMost(Duration.ofSeconds(10))
			.until(handler::getMessages, (msgs) -> msgs.size() == 2);
		assertThat(messages.get(0)).contains('http://livereload.com/protocols/official-7');
		assertThat(messages.get(1)).contains('command\':\'reload\'');
	}
	@Test
	void pingPong() throws Exception {
		LiveReloadWebSocketHandler handler = connect();
		handler.sendMessage(new PingMessage());
		await().atMost(Duration.ofSeconds(10)).until(handler::getPongCount, is(1));
	}
	@Test
	void clientClose() throws Exception {
		LiveReloadWebSocketHandler handler = connect();
		handler.close();
		awaitClosedException();
		assertThat(this.server.getClosedExceptions()).isNotEmpty();
	}
	private void awaitClosedException() {
		Awaitility.waitAtMost(Duration.ofSeconds(10)).until(this.server::getClosedExceptions, is(not(empty())));
	}
	@Test
	void serverClose() throws Exception {
		LiveReloadWebSocketHandler handler = connect();
		this.server.stop();
		CloseStatus closeStatus = await().atMost(Duration.ofSeconds(10))
			.until(handler::getCloseStatus, Objects::nonNull);
		assertThat(closeStatus.getCode()).isEqualTo(1006);
	}
	private LiveReloadWebSocketHandler connect() throws Exception {
		return connect(StandardWebSocketClient::new);
	}
	private LiveReloadWebSocketHandler connect(Function<WebSocketContainer, WebSocketClient> clientFactory)
			throws Exception {
		WsWebSocketContainer webSocketContainer = new WsWebSocketContainer();
		WebSocketClient client = clientFactory.apply(webSocketContainer);
		LiveReloadWebSocketHandler handler = new LiveReloadWebSocketHandler();
		client.execute(handler, 'ws://localhost:' + this.port + '/livereload');
		handler.awaitHello();
		return handler;
	}
	/**
	 * {@link LiveReloadServer} with additional monitoring.
	 */
	static class MonitoredLiveReloadServer extends LiveReloadServer {
		private final List<ConnectionClosedException> closedExceptions = new ArrayList<>();
		private final Object monitor = new Object();
		MonitoredLiveReloadServer(int port) {
			super(port);
		}
		@Override
		protected Connection createConnection(java.net.Socket socket, InputStream inputStream,
				OutputStream outputStream) throws IOException {
			return new MonitoredConnection(socket, inputStream, outputStream);
		}
		List<ConnectionClosedException> getClosedExceptions() {
			synchronized (this.monitor) {
				return new ArrayList<>(this.closedExceptions);
			}
		}
		private class MonitoredConnection extends Connection {
			MonitoredConnection(java.net.Socket socket, InputStream inputStream, OutputStream outputStream)
					throws IOException {
				super(socket, inputStream, outputStream);
			}
			@Override
			public void run() throws Exception {
				try {
					super.run();
				}
				catch (ConnectionClosedException ex) {
					synchronized (MonitoredLiveReloadServer.this.monitor) {
						MonitoredLiveReloadServer.this.closedExceptions.add(ex);
					}
					throw ex;
				}
			}
		}
	}
	class LiveReloadWebSocketHandler extends TextWebSocketHandler {
		private volatile WebSocketSession session;
		private final CountDownLatch helloLatch = new CountDownLatch(2);
		private final List<String> messages = new CopyOnWriteArrayList<>();
		private final AtomicInteger pongCount = new AtomicInteger();
		private volatile CloseStatus closeStatus;
		@Override
		public void afterConnectionEstablished(WebSocketSession session) throws Exception {
			this.session = session;
			session.sendMessage(new TextMessage(HANDSHAKE));
			this.helloLatch.countDown();
		}
		void awaitHello() throws InterruptedException {
			this.helloLatch.await(1, TimeUnit.MINUTES);
		}
		@Override
		protected void handleTextMessage(WebSocketSession session, TextMessage message) {
			String payload = message.getPayload();
			this.messages.add(payload);
			if (payload.contains('hello')) {
				this.helloLatch.countDown();
			}
		}
		@Override
		protected void handlePongMessage(WebSocketSession session, PongMessage message) {
			this.pongCount.incrementAndGet();
		}
		@Override
		public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
			this.closeStatus = status;
		}
		void sendMessage(WebSocketMessage<?> message) throws IOException {
			this.session.sendMessage(message);
		}
		void close() throws IOException {
			this.session.close();
		}
		List<String> getMessages() {
			return this.messages;
		}
		int getPongCount() {
			return this.pongCount.get();
		}
		CloseStatus getCloseStatus() {
			return this.closeStatus;
		}
	}
	static class UppercaseWebSocketClient extends StandardWebSocketClient {
		private final WebSocketContainer webSocketContainer;
		UppercaseWebSocketClient(WebSocketContainer webSocketContainer) {
			super(webSocketContainer);
			this.webSocketContainer = webSocketContainer;
		}
		@Override
		protected CompletableFuture<WebSocketSession> executeInternal(WebSocketHandler webSocketHandler,
				HttpHeaders headers, URI uri, List<String> protocols, List<WebSocketExtension> extensions,
				Map<String, Object> attributes) {
			InetSocketAddress localAddress = new InetSocketAddress(getLocalHost(), uri.getPort());
			InetSocketAddress remoteAddress = new InetSocketAddress(uri.getHost(), uri.getPort());
			StandardWebSocketSession session = new StandardWebSocketSession(headers, attributes, localAddress,
					remoteAddress);
			Stream<Extension> adaptedExtensions = extensions.stream().map(WebSocketToStandardExtensionAdapter::new);
			ClientEndpointConfig endpointConfig = ClientEndpointConfig.Builder.create()
				.configurator(new UppercaseWebSocketClientConfigurator(headers))
				.preferredSubprotocols(protocols)
				.extensions(adaptedExtensions.toList())
				.build();
			endpointConfig.getUserProperties().putAll(getUserProperties());
			Endpoint endpoint = new StandardWebSocketHandlerAdapter(webSocketHandler, session);
			Callable<WebSocketSession> connectTask = () -> {
				this.webSocketContainer.connectToServer(endpoint, endpointConfig, uri);
				return session;
			};
			return getTaskExecutor().submitCompletable(connectTask);
		}
		private InetAddress getLocalHost() {
			try {
				return InetAddress.getLocalHost();
			}
			catch (UnknownHostException ex) {
				return InetAddress.getLoopbackAddress();
			}
		}
	}
	private static class UppercaseWebSocketClientConfigurator extends Configurator {
		private final HttpHeaders headers;
		UppercaseWebSocketClientConfigurator(HttpHeaders headers) {
			this.headers = headers;
		}
		@Override
		public void beforeRequest(Map<String, List<String>> requestHeaders) {
			Map<String, List<String>> uppercaseRequestHeaders = new LinkedHashMap<>();
			requestHeaders.forEach((key, value) -> uppercaseRequestHeaders.put(key.toUpperCase(Locale.ROOT), value));
			requestHeaders.clear();
			requestHeaders.putAll(uppercaseRequestHeaders);
			requestHeaders.putAll(this.headers);
		}
		@Override
		public void afterResponse(HandshakeResponse response) {
		}
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
@SuppressWarnings('resource')
class ConnectionOutputStreamTests {
	@Test
	void write() throws Exception {
		OutputStream out = mock(OutputStream.class);
		ConnectionOutputStream outputStream = new ConnectionOutputStream(out);
		byte[] b = new byte[100];
		outputStream.write(b, 1, 2);
		then(out).should().write(b, 1, 2);
	}
	@Test
	void writeHttp() throws Exception {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		ConnectionOutputStream outputStream = new ConnectionOutputStream(out);
		outputStream.writeHttp(new ByteArrayInputStream('hi'.getBytes()), 'x-type');
		String expected = '';
		expected += 'HTTP/1.1 200 OK\r\n';
		expected += 'Content-Type: x-type\r\n';
		expected += 'Content-Length: 2\r\n';
		expected += 'Connection: close\r\n\r\n';
		expected += 'hi';
		assertThat(out).hasToString(expected);
	}
	@Test
	void writeHeaders() throws Exception {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		ConnectionOutputStream outputStream = new ConnectionOutputStream(out);
		outputStream.writeHeaders('A: a', 'B: b');
		outputStream.flush();
		String expected = '';
		expected += 'A: a\r\n';
		expected += 'B: b\r\n\r\n';
		assertThat(out).hasToString(expected);
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
class FrameTests {
	@Test
	void payloadMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Frame((String) null))
			.withMessageContaining('Payload must not be null');
	}
	@Test
	void typeMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Frame((Frame.Type) null))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void textPayload() {
		Frame frame = new Frame('abc');
		assertThat(frame.getType()).isEqualTo(Frame.Type.TEXT);
		assertThat(frame.getPayload()).isEqualTo('abc'.getBytes());
	}
	@Test
	void typedPayload() {
		Frame frame = new Frame(Frame.Type.CLOSE);
		assertThat(frame.getType()).isEqualTo(Frame.Type.CLOSE);
		assertThat(frame.getPayload()).isEqualTo(new byte[] {});
	}
	@Test
	void writeSmallPayload() throws Exception {
		String payload = createString(1);
		Frame frame = new Frame(payload);
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		frame.write(bos);
		assertThat(bos.toByteArray()).isEqualTo(new byte[] { (byte) 0x81, 0x01, 0x41 });
	}
	@Test
	void writeLargePayload() throws Exception {
		String payload = createString(126);
		Frame frame = new Frame(payload);
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		frame.write(bos);
		byte[] bytes = bos.toByteArray();
		assertThat(bytes).hasSize(130);
		assertThat(bytes[0]).isEqualTo((byte) 0x81);
		assertThat(bytes[1]).isEqualTo((byte) 0x7E);
		assertThat(bytes[2]).isEqualTo((byte) 0x00);
		assertThat(bytes[3]).isEqualTo((byte) 126);
		assertThat(bytes[4]).isEqualTo((byte) 0x41);
		assertThat(bytes[5]).isEqualTo((byte) 0x41);
	}
	@Test
	void readFragmentedNotSupported() {
		byte[] bytes = new byte[] { 0x0F };
		assertThatIllegalStateException().isThrownBy(() -> Frame.read(newConnectionInputStream(bytes)))
			.withMessageContaining('Fragmented frames are not supported');
	}
	@Test
	void readLargeFramesNotSupported() {
		byte[] bytes = new byte[] { (byte) 0x80, (byte) 0xFF };
		assertThatIllegalStateException().isThrownBy(() -> Frame.read(newConnectionInputStream(bytes)))
			.withMessageContaining('Large frames are not supported');
	}
	@Test
	void readSmallTextFrame() throws Exception {
		byte[] bytes = new byte[] { (byte) 0x81, (byte) 0x02, 0x41, 0x41 };
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.TEXT);
		assertThat(frame.getPayload()).isEqualTo(new byte[] { 0x41, 0x41 });
	}
	@Test
	void readMaskedTextFrame() throws Exception {
		byte[] bytes = new byte[] { (byte) 0x81, (byte) 0x82, 0x0F, 0x0F, 0x0F, 0x0F, 0x4E, 0x4E };
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.TEXT);
		assertThat(frame.getPayload()).isEqualTo(new byte[] { 0x41, 0x41 });
	}
	@Test
	void readLargeTextFrame() throws Exception {
		byte[] bytes = new byte[134];
		Arrays.fill(bytes, (byte) 0x4E);
		bytes[0] = (byte) 0x81;
		bytes[1] = (byte) 0xFE;
		bytes[2] = 0x00;
		bytes[3] = 126;
		bytes[4] = 0x0F;
		bytes[5] = 0x0F;
		bytes[6] = 0x0F;
		bytes[7] = 0x0F;
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.TEXT);
		assertThat(frame.getPayload()).isEqualTo(createString(126).getBytes());
	}
	@Test
	void readContinuation() throws Exception {
		byte[] bytes = new byte[] { (byte) 0x80, (byte) 0x00 };
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.CONTINUATION);
	}
	@Test
	void readBinary() throws Exception {
		byte[] bytes = new byte[] { (byte) 0x82, (byte) 0x00 };
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.BINARY);
	}
	@Test
	void readClose() throws Exception {
		byte[] bytes = new byte[] { (byte) 0x88, (byte) 0x00 };
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.CLOSE);
	}
	@Test
	void readPing() throws Exception {
		byte[] bytes = new byte[] { (byte) 0x89, (byte) 0x00 };
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.PING);
	}
	@Test
	void readPong() throws Exception {
		byte[] bytes = new byte[] { (byte) 0x8A, (byte) 0x00 };
		Frame frame = Frame.read(newConnectionInputStream(bytes));
		assertThat(frame.getType()).isEqualTo(Frame.Type.PONG);
	}
	private ConnectionInputStream newConnectionInputStream(byte[] bytes) {
		return new ConnectionInputStream(new ByteArrayInputStream(bytes));
	}
	private String createString(int length) {
		char[] chars = new char[length];
		Arrays.fill(chars, "A");
		return new String(chars);
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
class DirectorySnapshotTests {
	@TempDir
	File tempDir;
	private File directory;
	private DirectorySnapshot initialSnapshot;
	@BeforeEach
	void setup() throws Exception {
		this.directory = createTestDirectoryStructure();
		this.initialSnapshot = new DirectorySnapshot(this.directory);
	}
	@Test
	void directoryMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DirectorySnapshot(null))
			.withMessageContaining('Directory must not be null');
	}
	@Test
	void directoryMustNotBeFile() throws Exception {
		File file = new File(this.tempDir, 'file');
		file.createNewFile();
		assertThatIllegalArgumentException().isThrownBy(() -> new DirectorySnapshot(file))
			.withMessageContaining('Directory "' + file + '" must not be a file');
	}
	@Test
	void directoryDoesNotHaveToExist() {
		File file = new File(this.tempDir, 'does/not/exist');
		DirectorySnapshot snapshot = new DirectorySnapshot(file);
		assertThat(snapshot).isEqualTo(new DirectorySnapshot(file));
	}
	@Test
	void equalsWhenNothingHasChanged() {
		DirectorySnapshot updatedSnapshot = new DirectorySnapshot(this.directory);
		assertThat(this.initialSnapshot).isEqualTo(updatedSnapshot);
		assertThat(this.initialSnapshot).hasSameHashCodeAs(updatedSnapshot);
	}
	@Test
	void notEqualsWhenAFileIsAdded() throws Exception {
		new File(new File(this.directory, 'directory1'), 'newfile').createNewFile();
		DirectorySnapshot updatedSnapshot = new DirectorySnapshot(this.directory);
		assertThat(this.initialSnapshot).isNotEqualTo(updatedSnapshot);
	}
	@Test
	void notEqualsWhenAFileIsDeleted() {
		new File(new File(this.directory, 'directory1'), 'file1').delete();
		DirectorySnapshot updatedSnapshot = new DirectorySnapshot(this.directory);
		assertThat(this.initialSnapshot).isNotEqualTo(updatedSnapshot);
	}
	@Test
	void notEqualsWhenAFileIsModified() throws Exception {
		File file1 = new File(new File(this.directory, 'directory1'), 'file1');
		FileCopyUtils.copy('updatedcontent'.getBytes(), file1);
		DirectorySnapshot updatedSnapshot = new DirectorySnapshot(this.directory);
		assertThat(this.initialSnapshot).isNotEqualTo(updatedSnapshot);
	}
	@Test
	void getChangedFilesSnapshotMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.initialSnapshot.getChangedFiles(null, null))
			.withMessageContaining('Snapshot must not be null');
	}
	@Test
	void getChangedFilesSnapshotMustBeTheSameSourceDirectory() {
		assertThatIllegalArgumentException().isThrownBy(
				() -> this.initialSnapshot.getChangedFiles(new DirectorySnapshot(createTestDirectoryStructure()), null))
			.withMessageContaining('Snapshot source directory must be "' + this.directory + '"');
	}
	@Test
	void getChangedFilesWhenNothingHasChanged() {
		DirectorySnapshot updatedSnapshot = new DirectorySnapshot(this.directory);
		this.initialSnapshot.getChangedFiles(updatedSnapshot, null);
	}
	@Test
	void getChangedFilesWhenAFileIsAddedAndDeletedAndChanged() throws Exception {
		File directory1 = new File(this.directory, 'directory1');
		File file1 = new File(directory1, 'file1');
		File file2 = new File(directory1, 'file2');
		File newFile = new File(directory1, 'newfile');
		FileCopyUtils.copy('updatedcontent'.getBytes(), file1);
		file2.delete();
		newFile.createNewFile();
		DirectorySnapshot updatedSnapshot = new DirectorySnapshot(this.directory);
		ChangedFiles changedFiles = this.initialSnapshot.getChangedFiles(updatedSnapshot, null);
		assertThat(changedFiles.getSourceDirectory()).isEqualTo(this.directory);
		assertThat(getChangedFile(changedFiles, file1).getType()).isEqualTo(Type.MODIFY);
		assertThat(getChangedFile(changedFiles, file2).getType()).isEqualTo(Type.DELETE);
		assertThat(getChangedFile(changedFiles, newFile).getType()).isEqualTo(Type.ADD);
	}
	private ChangedFile getChangedFile(ChangedFiles changedFiles, File file) {
		for (ChangedFile changedFile : changedFiles) {
			if (changedFile.getFile().equals(file)) {
				return changedFile;
			}
		}
		return null;
	}
	private File createTestDirectoryStructure() throws IOException {
		File root = new File(this.tempDir, UUID.randomUUID().toString());
		File directory1 = new File(root, 'directory1');
		directory1.mkdirs();
		FileCopyUtils.copy('abc'.getBytes(), new File(directory1, 'file1'));
		FileCopyUtils.copy('abc'.getBytes(), new File(directory1, 'file2'));
		return root;
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
class ChangedFileTests {
	@TempDir
	File tempDir;
	@Test
	void sourceDirectoryMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ChangedFile(null, new File(this.tempDir, 'file'), Type.ADD))
			.withMessageContaining('SourceDirectory must not be null');
	}
	@Test
	void fileMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ChangedFile(new File(this.tempDir, 'directory'), null, Type.ADD))
			.withMessageContaining('File must not be null');
	}
	@Test
	void typeMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new ChangedFile(new File(this.tempDir, 'file'), new File(this.tempDir, 'directory'), null))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void getFile() {
		File file = new File(this.tempDir, 'file');
		ChangedFile changedFile = new ChangedFile(new File(this.tempDir, 'directory'), file, Type.ADD);
		assertThat(changedFile.getFile()).isEqualTo(file);
	}
	@Test
	void getType() {
		ChangedFile changedFile = new ChangedFile(new File(this.tempDir, 'directory'), new File(this.tempDir, 'file'),
				Type.DELETE);
		assertThat(changedFile.getType()).isEqualTo(Type.DELETE);
	}
	@Test
	void getRelativeName() {
		File subDirectory = new File(this.tempDir, 'A');
		File file = new File(subDirectory, 'B.txt');
		ChangedFile changedFile = new ChangedFile(this.tempDir, file, Type.ADD);
		assertThat(changedFile.getRelativeName()).isEqualTo('A/B.txt');
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
class FileSystemWatcherTests {
	private FileSystemWatcher watcher;
	private final List<Set<ChangedFiles>> changes = Collections.synchronizedList(new ArrayList<>());
	@TempDir
	File tempDir;
	@BeforeEach
	void setup() {
		setupWatcher(20, 10);
	}
	@Test
	void pollIntervalMustBePositive() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new FileSystemWatcher(true, Duration.ofMillis(0), Duration.ofMillis(1)))
			.withMessageContaining('PollInterval must be positive');
	}
	@Test
	void quietPeriodMustBePositive() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new FileSystemWatcher(true, Duration.ofMillis(1), Duration.ofMillis(0)))
			.withMessageContaining('QuietPeriod must be positive');
	}
	@Test
	void pollIntervalMustBeGreaterThanQuietPeriod() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new FileSystemWatcher(true, Duration.ofMillis(1), Duration.ofMillis(1)))
			.withMessageContaining('PollInterval must be greater than QuietPeriod');
	}
	@Test
	void listenerMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.watcher.addListener(null))
			.withMessageContaining('FileChangeListener must not be null');
	}
	@Test
	void cannotAddListenerToStartedListener() {
		this.watcher.start();
		assertThatIllegalStateException().isThrownBy(() -> this.watcher.addListener(mock(FileChangeListener.class)))
			.withMessageContaining('FileSystemWatcher already started');
	}
	@Test
	void sourceDirectoryMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.watcher.addSourceDirectory(null))
			.withMessageContaining('Directory must not be null');
	}
	@Test
	void sourceDirectoryMustNotBeAFile() throws IOException {
		File file = new File(this.tempDir, 'file');
		assertThat(file.createNewFile()).isTrue();
		assertThat(file).isFile();
		assertThatIllegalArgumentException().isThrownBy(() -> this.watcher.addSourceDirectory(file))
			.withMessageContaining('Directory "' + file + '" must not be a file');
	}
	@Test
	void cannotAddSourceDirectoryToStartedListener() {
		this.watcher.start();
		assertThatIllegalStateException().isThrownBy(() -> this.watcher.addSourceDirectory(this.tempDir))
			.withMessageContaining('FileSystemWatcher already started');
	}
	@Test
	void addFile() throws Exception {
		File directory = startWithNewDirectory();
		File file = touch(new File(directory, 'test.txt'));
		this.watcher.stopAfter(1);
		ChangedFile expected = new ChangedFile(directory, file, Type.ADD);
		assertThat(getAllFileChanges()).containsExactly(expected);
	}
	@Test
	void addNestedFile() throws Exception {
		File directory = startWithNewDirectory();
		File file = touch(new File(new File(directory, 'sub'), 'text.txt'));
		this.watcher.stopAfter(1);
		ChangedFile expected = new ChangedFile(directory, file, Type.ADD);
		assertThat(getAllFileChanges()).containsExactly(expected);
	}
	@Test
	void createSourceDirectoryAndAddFile() throws IOException {
		File directory = new File(this.tempDir, 'does/not/exist');
		assertThat(directory).doesNotExist();
		this.watcher.addSourceDirectory(directory);
		this.watcher.start();
		directory.mkdirs();
		File file = touch(new File(directory, 'text.txt'));
		this.watcher.stopAfter(1);
		ChangedFile expected = new ChangedFile(directory, file, Type.ADD);
		assertThat(getAllFileChanges()).containsExactly(expected);
	}
	@Test
	void waitsForPollingInterval() throws Exception {
		setupWatcher(10, 1);
		File directory = startWithNewDirectory();
		touch(new File(directory, 'test1.txt'));
		while (this.changes.size() != 1) {
			Thread.sleep(10);
		}
		touch(new File(directory, 'test2.txt'));
		this.watcher.stopAfter(1);
		assertThat(this.changes).hasSize(2);
	}
	@Test
	void waitsForQuietPeriod() throws Exception {
		setupWatcher(300, 200);
		File directory = startWithNewDirectory();
		for (int i = 0; i < 100; i++) {
			touch(new File(directory, i + 'test.txt'));
			Thread.sleep(10);
		}
		this.watcher.stopAfter(1);
		assertThat(getAllFileChanges()).hasSize(100);
	}
	@Test
	void withExistingFiles() throws Exception {
		File directory = new File(this.tempDir, UUID.randomUUID().toString());
		directory.mkdir();
		touch(new File(directory, 'test.txt'));
		this.watcher.addSourceDirectory(directory);
		this.watcher.start();
		File file = touch(new File(directory, 'test2.txt'));
		this.watcher.stopAfter(1);
		ChangedFile expected = new ChangedFile(directory, file, Type.ADD);
		assertThat(getAllFileChanges()).contains(expected);
	}
	@Test
	void multipleSources() throws Exception {
		File directory1 = new File(this.tempDir, UUID.randomUUID().toString());
		directory1.mkdir();
		File directory2 = new File(this.tempDir, UUID.randomUUID().toString());
		directory2.mkdir();
		this.watcher.addSourceDirectory(directory1);
		this.watcher.addSourceDirectory(directory2);
		this.watcher.start();
		File file1 = touch(new File(directory1, 'test.txt'));
		File file2 = touch(new File(directory2, 'test.txt'));
		this.watcher.stopAfter(1);
		Set<ChangedFiles> change = this.changes.stream().flatMap(Set<ChangedFiles>::stream).collect(Collectors.toSet());
		assertThat(change).hasSize(2);
		for (ChangedFiles changedFiles : change) {
			if (changedFiles.getSourceDirectory().equals(directory1)) {
				ChangedFile file = new ChangedFile(directory1, file1, Type.ADD);
				assertThat(changedFiles.getFiles()).containsOnly(file);
			}
			else {
				ChangedFile file = new ChangedFile(directory2, file2, Type.ADD);
				assertThat(changedFiles.getFiles()).containsOnly(file);
			}
		}
	}
	@Test
	void multipleListeners() throws Exception {
		File directory = new File(this.tempDir, UUID.randomUUID().toString());
		directory.mkdir();
		final List<Set<ChangedFiles>> listener2Changes = new ArrayList<>();
		this.watcher.addSourceDirectory(directory);
		this.watcher.addListener(listener2Changes::add);
		this.watcher.start();
		File file = touch(new File(directory, 'test.txt'));
		this.watcher.stopAfter(1);
		ChangedFile expected = new ChangedFile(directory, file, Type.ADD);
		Set<ChangedFile> changeSet = getAllFileChanges();
		assertThat(changeSet).contains(expected);
		assertThat(getAllFileChanges(listener2Changes)).isEqualTo(changeSet);
	}
	@Test
	void modifyDeleteAndAdd() throws Exception {
		File directory = new File(this.tempDir, UUID.randomUUID().toString());
		directory.mkdir();
		File modify = touch(new File(directory, 'modify.txt'));
		File delete = touch(new File(directory, 'delete.txt'));
		this.watcher.addSourceDirectory(directory);
		this.watcher.start();
		FileCopyUtils.copy('abc'.getBytes(), modify);
		delete.delete();
		File add = touch(new File(directory, 'add.txt'));
		this.watcher.stopAfter(1);
		Set<ChangedFile> actual = getAllFileChanges();
		Set<ChangedFile> expected = new HashSet<>();
		expected.add(new ChangedFile(directory, modify, Type.MODIFY));
		expected.add(new ChangedFile(directory, delete, Type.DELETE));
		expected.add(new ChangedFile(directory, add, Type.ADD));
		assertThat(actual).isEqualTo(expected);
	}
	@Test
	void withTriggerFilter() throws Exception {
		File directory = new File(this.tempDir, UUID.randomUUID().toString());
		directory.mkdir();
		File file = touch(new File(directory, 'file.txt'));
		File trigger = touch(new File(directory, 'trigger.txt'));
		this.watcher.addSourceDirectory(directory);
		this.watcher.setTriggerFilter((candidate) -> candidate.getName().equals('trigger.txt'));
		this.watcher.start();
		FileCopyUtils.copy('abc'.getBytes(), file);
		Thread.sleep(100);
		assertThat(this.changes).isEmpty();
		FileCopyUtils.copy('abc'.getBytes(), trigger);
		this.watcher.stopAfter(1);
		Set<ChangedFile> actual = getAllFileChanges();
		Set<ChangedFile> expected = new HashSet<>();
		expected.add(new ChangedFile(directory, file, Type.MODIFY));
		assertThat(actual).isEqualTo(expected);
	}
	@Test
	void withSnapshotRepository() throws Exception {
		SnapshotStateRepository repository = new TestSnapshotStateRepository();
		setupWatcher(20, 10, repository);
		File directory = new File(this.tempDir, UUID.randomUUID().toString());
		directory.mkdir();
		File file = touch(new File(directory, 'file.txt'));
		this.watcher.addSourceDirectory(directory);
		this.watcher.start();
		file.delete();
		this.watcher.stopAfter(1);
		this.changes.clear();
		File recreate = touch(new File(directory, 'file.txt'));
		setupWatcher(20, 10, repository);
		this.watcher.addSourceDirectory(directory);
		this.watcher.start();
		this.watcher.stopAfter(1);
		Set<ChangedFile> actual = getAllFileChanges();
		Set<ChangedFile> expected = new HashSet<>();
		expected.add(new ChangedFile(directory, recreate, Type.ADD));
		assertThat(actual).isEqualTo(expected);
	}
	private void setupWatcher(long pollingInterval, long quietPeriod) {
		setupWatcher(pollingInterval, quietPeriod, null);
	}
	private void setupWatcher(long pollingInterval, long quietPeriod, SnapshotStateRepository snapshotStateRepository) {
		this.watcher = new FileSystemWatcher(false, Duration.ofMillis(pollingInterval), Duration.ofMillis(quietPeriod),
				snapshotStateRepository);
		this.watcher.addListener(FileSystemWatcherTests.this.changes::add);
	}
	private File startWithNewDirectory() {
		File directory = new File(this.tempDir, UUID.randomUUID().toString());
		directory.mkdir();
		this.watcher.addSourceDirectory(directory);
		this.watcher.start();
		return directory;
	}
	private Set<ChangedFile> getAllFileChanges() {
		return getAllFileChanges(this.changes);
	}
	private Set<ChangedFile> getAllFileChanges(List<Set<ChangedFiles>> changes) {
		return changes.stream()
			.flatMap(Set<ChangedFiles>::stream)
			.flatMap((changedFiles) -> changedFiles.getFiles().stream())
			.collect(Collectors.toSet());
	}
	private File touch(File file) throws IOException {
		file.getParentFile().mkdirs();
		FileOutputStream fileOutputStream = new FileOutputStream(file);
		fileOutputStream.close();
		return file;
	}
	private static final class TestSnapshotStateRepository implements SnapshotStateRepository {
		private Object state;
		@Override
		public void save(Object state) {
			this.state = state;
		}
		@Override
		public Object restore() {
			return this.state;
		}
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
class FileSnapshotTests {
	private static final long TWO_MINS = TimeUnit.MINUTES.toMillis(2);
	private static final long MODIFIED = new Date().getTime() - TimeUnit.DAYS.toMillis(10);
	@TempDir
	File tempDir;
	@Test
	void fileMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new FileSnapshot(null))
			.withMessageContaining('File must not be null');
	}
	@Test
	void fileMustNotBeADirectory() {
		File file = new File(this.tempDir, 'file');
		file.mkdir();
		assertThatIllegalArgumentException().isThrownBy(() -> new FileSnapshot(file))
			.withMessageContaining('File must not be a directory');
	}
	@Test
	void equalsIfTheSame() throws Exception {
		File file = createNewFile('abc', MODIFIED);
		File fileCopy = new File(file, 'x').getParentFile();
		FileSnapshot snapshot1 = new FileSnapshot(file);
		FileSnapshot snapshot2 = new FileSnapshot(fileCopy);
		assertThat(snapshot1).isEqualTo(snapshot2);
		assertThat(snapshot1).hasSameHashCodeAs(snapshot2);
	}
	@Test
	void notEqualsIfDeleted() throws Exception {
		File file = createNewFile('abc', MODIFIED);
		FileSnapshot snapshot1 = new FileSnapshot(file);
		file.delete();
		assertThat(snapshot1).isNotEqualTo(new FileSnapshot(file));
	}
	@Test
	void notEqualsIfLengthChanges() throws Exception {
		File file = createNewFile('abc', MODIFIED);
		FileSnapshot snapshot1 = new FileSnapshot(file);
		setupFile(file, 'abcd', MODIFIED);
		assertThat(snapshot1).isNotEqualTo(new FileSnapshot(file));
	}
	@Test
	void notEqualsIfLastModifiedChanges() throws Exception {
		File file = createNewFile('abc', MODIFIED);
		FileSnapshot snapshot1 = new FileSnapshot(file);
		setupFile(file, 'abc', MODIFIED + TWO_MINS);
		assertThat(snapshot1).isNotEqualTo(new FileSnapshot(file));
	}
	private File createNewFile(String content, long lastModified) throws IOException {
		File file = new File(this.tempDir, UUID.randomUUID().toString());
		setupFile(file, content, lastModified);
		return file;
	}
	private void setupFile(File file, String content, long lastModified) throws IOException {
		FileCopyUtils.copy(content.getBytes(), file);
		file.setLastModified(lastModified);
	}
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
class ClassLoaderFileTests {
	public static final byte[] BYTES = 'ABC'.getBytes();
	@Test
	void kindMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassLoaderFile(null, null))
			.withMessageContaining('Kind must not be null');
	}
	@Test
	void addedContentsMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassLoaderFile(Kind.ADDED, null))
			.withMessageContaining('Contents must not be null');
	}
	@Test
	void modifiedContentsMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassLoaderFile(Kind.MODIFIED, null))
			.withMessageContaining('Contents must not be null');
	}
	@Test
	void deletedContentsMustBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassLoaderFile(Kind.DELETED, new byte[10]))
			.withMessageContaining('Contents must be null');
	}
	@Test
	void added() {
		ClassLoaderFile file = new ClassLoaderFile(Kind.ADDED, BYTES);
		assertThat(file.getKind()).isEqualTo(ClassLoaderFile.Kind.ADDED);
		assertThat(file.getContents()).isEqualTo(BYTES);
	}
	@Test
	void modified() {
		ClassLoaderFile file = new ClassLoaderFile(Kind.MODIFIED, BYTES);
		assertThat(file.getKind()).isEqualTo(ClassLoaderFile.Kind.MODIFIED);
		assertThat(file.getContents()).isEqualTo(BYTES);
	}
	@Test
	void deleted() {
		ClassLoaderFile file = new ClassLoaderFile(Kind.DELETED, null);
		assertThat(file.getKind()).isEqualTo(ClassLoaderFile.Kind.DELETED);
		assertThat(file.getContents()).isNull();
	}
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
public class Sample {
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
public class SampleParent {
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
@SuppressWarnings('resource')
class RestartClassLoaderTests {
	private static final String PACKAGE = RestartClassLoaderTests.class.getPackage().getName();
	private static final String PACKAGE_PATH = PACKAGE.replace(".", "/");
	private File sampleJarFile;
	private URLClassLoader parentClassLoader;
	private ClassLoaderFiles updatedFiles;
	private RestartClassLoader reloadClassLoader;
	@BeforeEach
	void setup(@TempDir File tempDir) throws Exception {
		this.sampleJarFile = createSampleJarFile(tempDir);
		URL url = this.sampleJarFile.toURI().toURL();
		ClassLoader classLoader = getClass().getClassLoader();
		URL[] urls = new URL[] { url };
		this.parentClassLoader = new URLClassLoader(urls, classLoader);
		this.updatedFiles = new ClassLoaderFiles();
		this.reloadClassLoader = new RestartClassLoader(this.parentClassLoader, urls, this.updatedFiles);
	}
	@AfterEach
	void tearDown() throws Exception {
		this.reloadClassLoader.close();
		this.parentClassLoader.close();
	}
	private File createSampleJarFile(File tempDir) throws IOException {
		File file = new File(tempDir, 'sample.jar');
		JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(file));
		jarOutputStream.putNextEntry(new ZipEntry(PACKAGE_PATH + '/Sample.class'));
		StreamUtils.copy(getClass().getResourceAsStream('Sample.class'), jarOutputStream);
		jarOutputStream.closeEntry();
		jarOutputStream.putNextEntry(new ZipEntry(PACKAGE_PATH + '/Sample.txt'));
		StreamUtils.copy('fromchild', StandardCharsets.UTF_8, jarOutputStream);
		jarOutputStream.closeEntry();
		jarOutputStream.close();
		return file;
	}
	@Test
	void parentMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new RestartClassLoader(null, new URL[] {}))
			.withMessageContaining('Parent must not be null');
	}
	@Test
	void updatedFilesMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new RestartClassLoader(this.parentClassLoader, new URL[] {}, null))
			.withMessageContaining('UpdatedFiles must not be null');
	}
	@Test
	void getResourceFromReloadableUrl() throws Exception {
		String content = readString(this.reloadClassLoader.getResourceAsStream(PACKAGE_PATH + '/Sample.txt'));
		assertThat(content).startsWith('fromchild');
	}
	@Test
	void getResourceFromParent() throws Exception {
		String content = readString(this.reloadClassLoader.getResourceAsStream(PACKAGE_PATH + '/Parent.txt'));
		assertThat(content).startsWith('fromparent');
	}
	@Test
	void getResourcesFiltersDuplicates() throws Exception {
		List<URL> resources = toList(this.reloadClassLoader.getResources(PACKAGE_PATH + '/Sample.txt'));
		assertThat(resources).hasSize(1);
	}
	@Test
	void loadClassFromReloadableUrl() throws Exception {
		Class<?> loaded = Class.forName(PACKAGE + '.Sample', false, this.reloadClassLoader);
		assertThat(loaded.getClassLoader()).isEqualTo(this.reloadClassLoader);
	}
	@Test
	void loadClassFromParent() throws Exception {
		Class<?> loaded = Class.forName(PACKAGE + '.SampleParent', false, this.reloadClassLoader);
		assertThat(loaded.getClassLoader()).isEqualTo(getClass().getClassLoader());
	}
	@Test
	void getDeletedResource() {
		String name = PACKAGE_PATH + '/Sample.txt';
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.DELETED, null));
		assertThat(this.reloadClassLoader.getResource(name)).isNull();
	}
	@Test
	void getDeletedResourceAsStream() {
		String name = PACKAGE_PATH + '/Sample.txt';
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.DELETED, null));
		assertThat(this.reloadClassLoader.getResourceAsStream(name)).isNull();
	}
	@Test
	void getUpdatedResource() throws Exception {
		String name = PACKAGE_PATH + '/Sample.txt';
		byte[] bytes = 'abc'.getBytes();
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.MODIFIED, bytes));
		URL resource = this.reloadClassLoader.getResource(name);
		assertThat(FileCopyUtils.copyToByteArray(resource.openStream())).isEqualTo(bytes);
	}
	@Test
	void getResourcesWithDeleted() throws Exception {
		String name = PACKAGE_PATH + '/Sample.txt';
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.DELETED, null));
		List<URL> resources = toList(this.reloadClassLoader.getResources(name));
		assertThat(resources).isEmpty();
	}
	@Test
	void getResourcesWithUpdated() throws Exception {
		String name = PACKAGE_PATH + '/Sample.txt';
		byte[] bytes = 'abc'.getBytes();
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.MODIFIED, bytes));
		List<URL> resources = toList(this.reloadClassLoader.getResources(name));
		assertThat(FileCopyUtils.copyToByteArray(resources.get(0).openStream())).isEqualTo(bytes);
	}
	@Test
	void getDeletedClass() {
		String name = PACKAGE_PATH + '/Sample.class';
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.DELETED, null));
		assertThatExceptionOfType(ClassNotFoundException.class)
			.isThrownBy(() -> Class.forName(PACKAGE + '.Sample', false, this.reloadClassLoader));
	}
	@Test
	void getUpdatedClass() {
		String name = PACKAGE_PATH + '/Sample.class';
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.MODIFIED, new byte[10]));
		assertThatExceptionOfType(ClassFormatError.class)
			.isThrownBy(() -> Class.forName(PACKAGE + '.Sample', false, this.reloadClassLoader));
	}
	@Test
	void getAddedClass() throws Exception {
		String name = PACKAGE_PATH + '/SampleParent.class';
		byte[] bytes = FileCopyUtils.copyToByteArray(getClass().getResourceAsStream('SampleParent.class'));
		this.updatedFiles.addFile(name, new ClassLoaderFile(Kind.ADDED, bytes));
		Class<?> loaded = Class.forName(PACKAGE + '.SampleParent', false, this.reloadClassLoader);
		assertThat(loaded.getClassLoader()).isEqualTo(this.reloadClassLoader);
	}
	@Test
	void proxyOnClassFromSystemClassLoaderDoesNotYieldWarning() {
		ProxyFactory pf = new ProxyFactory(new HashMap<>());
		pf.setProxyTargetClass(true);
		pf.getProxy(this.reloadClassLoader);
		// Warning would happen outside the boundary of the test
	}
	@Test
	void packagePrivateClassLoadedByParentClassLoaderCanBeProxied() throws IOException {
		try (RestartClassLoader restartClassLoader = new RestartClassLoader(ExampleTransactional.class.getClassLoader(),
				new URL[] { this.sampleJarFile.toURI().toURL() }, this.updatedFiles)) {
			new ApplicationContextRunner().withClassLoader(restartClassLoader)
				.withUserConfiguration(ProxyConfiguration.class)
				.run((context) -> assertThat(context).getBean(ExampleTransactional.class)
					.matches(AopUtils::isCglibProxy)
					.extracting(Object::getClass)
					.extracting(Class::getClassLoader)
					.isEqualTo(ExampleTransactional.class.getClassLoader()));
		}
	}
	private String readString(InputStream in) throws IOException {
		return new String(FileCopyUtils.copyToByteArray(in));
	}
	private <T> List<T> toList(Enumeration<T> enumeration) {
		return (enumeration != null) ? Collections.list(enumeration) : Collections.emptyList();
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAspectJAutoProxy(proxyTargetClass = true)
	@EnableTransactionManagement
	static class ProxyConfiguration {
		@Bean
		ExampleTransactional exampleTransactional() {
			return new ExampleTransactional();
		}
	}
	static class ExampleTransactional implements ExampleInterface {
		@Override
		@Transactional
		public String doIt() {
			return 'hello';
		}
	}
	interface ExampleInterface {
		String doIt();
	}
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
class ClassLoaderFilesTests {
	private final ClassLoaderFiles files = new ClassLoaderFiles();
	@Test
	void addFileNameMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.files.addFile(null, mock(ClassLoaderFile.class)))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void addFileFileMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.files.addFile('test', null))
			.withMessageContaining('File must not be null');
	}
	@Test
	void getFileWithNullName() {
		assertThat(this.files.getFile(null)).isNull();
	}
	@Test
	void addAndGet() {
		ClassLoaderFile file = new ClassLoaderFile(Kind.ADDED, new byte[10]);
		this.files.addFile('myfile', file);
		assertThat(this.files.getFile('myfile')).isEqualTo(file);
	}
	@Test
	void getMissing() {
		assertThat(this.files.getFile('missing')).isNull();
	}
	@Test
	void addTwice() {
		ClassLoaderFile file1 = new ClassLoaderFile(Kind.ADDED, new byte[10]);
		ClassLoaderFile file2 = new ClassLoaderFile(Kind.MODIFIED, new byte[10]);
		this.files.addFile('myfile', file1);
		this.files.addFile('myfile', file2);
		assertThat(this.files.getFile('myfile')).isEqualTo(file2);
	}
	@Test
	void addTwiceInDifferentSourceDirectories() {
		ClassLoaderFile file1 = new ClassLoaderFile(Kind.ADDED, new byte[10]);
		ClassLoaderFile file2 = new ClassLoaderFile(Kind.MODIFIED, new byte[10]);
		this.files.addFile('a', 'myfile', file1);
		this.files.addFile('b', 'myfile', file2);
		assertThat(this.files.getFile('myfile')).isEqualTo(file2);
		assertThat(this.files.getOrCreateSourceDirectory('a').getFiles()).isEmpty();
		assertThat(this.files.getOrCreateSourceDirectory('b').getFiles()).hasSize(1);
	}
	@Test
	void getSourceDirectories() {
		ClassLoaderFile file1 = new ClassLoaderFile(Kind.ADDED, new byte[10]);
		ClassLoaderFile file2 = new ClassLoaderFile(Kind.MODIFIED, new byte[10]);
		ClassLoaderFile file3 = new ClassLoaderFile(Kind.MODIFIED, new byte[10]);
		ClassLoaderFile file4 = new ClassLoaderFile(Kind.MODIFIED, new byte[10]);
		this.files.addFile('a', 'myfile1', file1);
		this.files.addFile('a', 'myfile2', file2);
		this.files.addFile('b', 'myfile3', file3);
		this.files.addFile('b', 'myfile4', file4);
		Iterator<SourceDirectory> sourceDirectories = this.files.getSourceDirectories().iterator();
		SourceDirectory sourceDirectory1 = sourceDirectories.next();
		SourceDirectory sourceDirectory2 = sourceDirectories.next();
		assertThat(sourceDirectories.hasNext()).isFalse();
		assertThat(sourceDirectory1.getName()).isEqualTo('a');
		assertThat(sourceDirectory2.getName()).isEqualTo('b');
		assertThat(sourceDirectory1.getFiles()).containsOnly(file1, file2);
		assertThat(sourceDirectory2.getFiles()).containsOnly(file3, file4);
	}
	@Test
	void serialize() throws Exception {
		ClassLoaderFile file = new ClassLoaderFile(Kind.ADDED, new byte[10]);
		this.files.addFile('myfile', file);
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new ObjectOutputStream(bos);
		oos.writeObject(this.files);
		oos.close();
		ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
		ClassLoaderFiles readObject = (ClassLoaderFiles) ois.readObject();
		assertThat(readObject.getFile('myfile')).isNotNull();
	}
	@Test
	void addAll() {
		ClassLoaderFile file1 = new ClassLoaderFile(Kind.ADDED, new byte[10]);
		this.files.addFile('a', 'myfile1', file1);
		ClassLoaderFiles toAdd = new ClassLoaderFiles();
		ClassLoaderFile file2 = new ClassLoaderFile(Kind.MODIFIED, new byte[10]);
		ClassLoaderFile file3 = new ClassLoaderFile(Kind.MODIFIED, new byte[10]);
		toAdd.addFile('a', 'myfile2', file2);
		toAdd.addFile('b', 'myfile3', file3);
		this.files.addAll(toAdd);
		Iterator<SourceDirectory> sourceDirectories = this.files.getSourceDirectories().iterator();
		SourceDirectory sourceDirectory1 = sourceDirectories.next();
		SourceDirectory sourceDirectory2 = sourceDirectories.next();
		assertThat(sourceDirectories.hasNext()).isFalse();
		assertThat(sourceDirectory1.getName()).isEqualTo('a');
		assertThat(sourceDirectory2.getName()).isEqualTo('b');
		assertThat(sourceDirectory1.getFiles()).containsOnly(file1, file2);
	}
	@Test
	void getSize() {
		this.files.addFile('s1', 'n1', mock(ClassLoaderFile.class));
		this.files.addFile('s1', 'n2', mock(ClassLoaderFile.class));
		this.files.addFile('s2', 'n3', mock(ClassLoaderFile.class));
		this.files.addFile('s2', 'n1', mock(ClassLoaderFile.class));
		assertThat(this.files.size()).isEqualTo(3);
	}
	@Test
	void classLoaderFilesMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ClassLoaderFiles(null))
			.withMessageContaining('ClassLoaderFiles must not be null');
	}
	@Test
	void constructFromExistingSet() {
		this.files.addFile('s1', 'n1', mock(ClassLoaderFile.class));
		this.files.addFile('s1', 'n2', mock(ClassLoaderFile.class));
		ClassLoaderFiles copy = new ClassLoaderFiles(this.files);
		this.files.addFile('s2', 'n3', mock(ClassLoaderFile.class));
		assertThat(this.files.size()).isEqualTo(3);
		assertThat(copy.size()).isEqualTo(2);
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class MainMethodTests {
	private static final ThreadLocal<MainMethod> mainMethod = new ThreadLocal<>();
	private Method actualMain;
	@BeforeEach
	void setup() throws Exception {
		this.actualMain = Valid.class.getMethod('main', String[].class);
	}
	@Test
	void threadMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new MainMethod(null))
			.withMessageContaining('Thread must not be null');
	}
	@Test
	void validMainMethod() throws Exception {
		MainMethod method = new TestThread(Valid::main).test();
		assertThat(method.getMethod()).isEqualTo(this.actualMain);
		assertThat(method.getDeclaringClassName()).isEqualTo(this.actualMain.getDeclaringClass().getName());
	}
	@Test // gh-35214
	void nestedMainMethod() throws Exception {
		MainMethod method = new TestThread(Nested::main).test();
		Method nestedMain = Nested.class.getMethod('main', String[].class);
		assertThat(method.getMethod()).isEqualTo(nestedMain);
		assertThat(method.getDeclaringClassName()).isEqualTo(nestedMain.getDeclaringClass().getName());
	}
	@Test // gh-39733
	void viaJarLauncher() throws Exception {
		FakeJarLauncher.action = (args) -> Valid.main(args);
		MainMethod method = new TestThread(FakeJarLauncher::main).test();
		Method expectedMain = Valid.class.getMethod('main', String[].class);
		assertThat(method.getMethod()).isEqualTo(expectedMain);
		assertThat(method.getDeclaringClassName()).isEqualTo(expectedMain.getDeclaringClass().getName());
	}
	@Test
	void missingArgsMainMethod() {
		assertThatIllegalStateException().isThrownBy(() -> new TestThread(MissingArgs::main).test())
			.withMessageContaining('Unable to find main method');
	}
	@Test
	void nonStatic() {
		assertThatIllegalStateException().isThrownBy(() -> new TestThread(() -> new NonStaticMain().main()).test())
			.withMessageContaining('Unable to find main method');
	}
	static class TestThread extends Thread {
		private final Runnable runnable;
		private Exception exception;
		private MainMethod mainMethod;
		TestThread(Runnable runnable) {
			this.runnable = runnable;
		}
		MainMethod test() throws InterruptedException {
			start();
			join();
			if (this.exception != null) {
				ReflectionUtils.rethrowRuntimeException(this.exception);
			}
			return this.mainMethod;
		}
		@Override
		public void run() {
			try {
				this.runnable.run();
				this.mainMethod = MainMethodTests.mainMethod.get();
			}
			catch (Exception ex) {
				this.exception = ex;
			}
		}
	}
	public static class Valid {
		public static void main(String... args) {
			someOtherMethod();
		}
		private static void someOtherMethod() {
			mainMethod.set(new MainMethod());
		}
	}
	public static class Nested {
		public static void main(String... args) {
			mainMethod.set(new MainMethod());
			Valid.main(args);
		}
	}
	public static class MissingArgs {
		public static void main() {
			mainMethod.set(new MainMethod());
		}
	}
	public static class NonStaticMain {
		void main(String... args) {
			mainMethod.set(new MainMethod());
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class ClassLoaderFilesResourcePatternResolverTests {
	private ClassLoaderFiles files;
	private ClassLoaderFilesResourcePatternResolver resolver;
	@BeforeEach
	void setup() {
		this.files = new ClassLoaderFiles();
		this.resolver = new ClassLoaderFilesResourcePatternResolver(new GenericApplicationContext(), this.files);
	}
	@Test
	void getClassLoaderShouldReturnClassLoader() {
		assertThat(this.resolver.getClassLoader()).isNotNull();
	}
	@Test
	void getResourceShouldReturnResource() {
		Resource resource = this.resolver.getResource('index.html');
		assertThat(resource).isInstanceOf(ClassPathResource.class);
	}
	@Test
	void getResourceWhenHasServletContextShouldReturnServletResource() {
		GenericWebApplicationContext context = new GenericWebApplicationContext(new MockServletContext());
		this.resolver = new ClassLoaderFilesResourcePatternResolver(context, this.files);
		Resource resource = this.resolver.getResource('index.html');
		assertThat(resource).isInstanceOf(ServletContextResource.class);
	}
	@Test
	void getResourceWhenDeletedShouldReturnDeletedResource(@TempDir File directory) throws Exception {
		File file = createFile(directory, 'name.class');
		this.files.addFile(directory.getName(), 'name.class', new ClassLoaderFile(Kind.DELETED, null));
		Resource resource = this.resolver.getResource('file:' + file.getAbsolutePath());
		assertThat(resource).isInstanceOf(DeletedClassLoaderFileResource.class);
	}
	@Test
	void getResourcesShouldReturnResources(@TempDir File directory) throws Exception {
		File file = createFile(directory, 'name.class');
		Resource[] resources = this.resolver.getResources('file:' + directory.getAbsolutePath() + '/**');
		assertThat(resources).extracting(Resource::getFile).containsExactly(file);
	}
	@Test
	void getResourcesWhenDeletedShouldFilterDeleted(@TempDir File directory) throws Exception {
		createFile(directory, 'name.class');
		this.files.addFile(directory.getName(), 'name.class', new ClassLoaderFile(Kind.DELETED, null));
		Resource[] resources = this.resolver.getResources('file:' + directory.getAbsolutePath() + '/**');
		assertThat(resources).isEmpty();
	}
	@Test
	void customResourceLoaderIsUsedInNonWebApplication() {
		GenericApplicationContext context = new GenericApplicationContext();
		ResourceLoader resourceLoader = mock(ResourceLoader.class);
		context.setResourceLoader(resourceLoader);
		this.resolver = new ClassLoaderFilesResourcePatternResolver(context, this.files);
		this.resolver.getResource('foo.txt');
		then(resourceLoader).should().getResource('foo.txt');
	}
	@Test
	void customProtocolResolverIsUsedInNonWebApplication() {
		GenericApplicationContext context = new GenericApplicationContext();
		Resource resource = mock(Resource.class);
		ProtocolResolver resolver = mockProtocolResolver('foo:some-file.txt', resource);
		context.addProtocolResolver(resolver);
		this.resolver = new ClassLoaderFilesResourcePatternResolver(context, this.files);
		Resource actual = this.resolver.getResource('foo:some-file.txt');
		assertThat(actual).isSameAs(resource);
		then(resolver).should().resolve(eq('foo:some-file.txt'), any(ResourceLoader.class));
	}
	@Test
	void customProtocolResolverRegisteredAfterCreationIsUsedInNonWebApplication() {
		GenericApplicationContext context = new GenericApplicationContext();
		Resource resource = mock(Resource.class);
		this.resolver = new ClassLoaderFilesResourcePatternResolver(context, this.files);
		ProtocolResolver resolver = mockProtocolResolver('foo:some-file.txt', resource);
		context.addProtocolResolver(resolver);
		Resource actual = this.resolver.getResource('foo:some-file.txt');
		assertThat(actual).isSameAs(resource);
		then(resolver).should().resolve(eq('foo:some-file.txt'), any(ResourceLoader.class));
	}
	@Test
	void customResourceLoaderIsUsedInWebApplication() {
		GenericWebApplicationContext context = new GenericWebApplicationContext(new MockServletContext());
		ResourceLoader resourceLoader = mock(ResourceLoader.class);
		context.setResourceLoader(resourceLoader);
		this.resolver = new ClassLoaderFilesResourcePatternResolver(context, this.files);
		this.resolver.getResource('foo.txt');
		then(resourceLoader).should().getResource('foo.txt');
	}
	@Test
	void customProtocolResolverIsUsedInWebApplication() {
		GenericWebApplicationContext context = new GenericWebApplicationContext(new MockServletContext());
		Resource resource = mock(Resource.class);
		ProtocolResolver resolver = mockProtocolResolver('foo:some-file.txt', resource);
		context.addProtocolResolver(resolver);
		this.resolver = new ClassLoaderFilesResourcePatternResolver(context, this.files);
		Resource actual = this.resolver.getResource('foo:some-file.txt');
		assertThat(actual).isSameAs(resource);
		then(resolver).should().resolve(eq('foo:some-file.txt'), any(ResourceLoader.class));
	}
	@Test
	void customProtocolResolverRegisteredAfterCreationIsUsedInWebApplication() {
		GenericWebApplicationContext context = new GenericWebApplicationContext(new MockServletContext());
		Resource resource = mock(Resource.class);
		this.resolver = new ClassLoaderFilesResourcePatternResolver(context, this.files);
		ProtocolResolver resolver = mockProtocolResolver('foo:some-file.txt', resource);
		context.addProtocolResolver(resolver);
		Resource actual = this.resolver.getResource('foo:some-file.txt');
		assertThat(actual).isSameAs(resource);
		then(resolver).should().resolve(eq('foo:some-file.txt'), any(ResourceLoader.class));
	}
	private ProtocolResolver mockProtocolResolver(String path, Resource resource) {
		ProtocolResolver resolver = mock(ProtocolResolver.class);
		given(resolver.resolve(eq(path), any(ResourceLoader.class))).willReturn(resource);
		return resolver;
	}
	private File createFile(File directory, String name) throws IOException {
		File file = new File(directory, name);
		FileCopyUtils.copy('test'.getBytes(), file);
		return file;
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class OnInitializedRestarterConditionTests {
	@BeforeEach
	@AfterEach
	void cleanup() {
		Restarter.clearInstance();
	}
	@Test
	void noInstance() {
		Restarter.clearInstance();
		ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
		assertThat(context.containsBean('bean')).isFalse();
		context.close();
	}
	@Test
	void noInitialization() {
		Restarter.initialize(new String[0], false, RestartInitializer.NONE);
		ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
		assertThat(context.containsBean('bean')).isFalse();
		context.close();
	}
	@Test
	void initialized() throws Exception {
		Thread thread = new Thread(TestInitialized::main);
		thread.start();
		thread.join(30000);
		assertThat(thread.isAlive()).isFalse();
	}
	static class TestInitialized {
		static void main(String... args) {
			RestartInitializer initializer = mock(RestartInitializer.class);
			given(initializer.getInitialUrls(any(Thread.class))).willReturn(new URL[0]);
			Restarter.initialize(new String[0], false, initializer);
			ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
			assertThat(context.containsBean('bean')).isTrue();
			context.close();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		@ConditionalOnInitializedRestarter
		String bean() {
			return 'bean';
		}
	}
}
/*
package org.springframework.boot.devtools.restart.server;
/**
class HttpRestartServerHandlerTests {
	@Test
	void serverMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpRestartServerHandler(null))
			.withMessageContaining('Server must not be null');
	}
	@Test
	void handleDelegatesToServer() throws Exception {
		HttpRestartServer server = mock(HttpRestartServer.class);
		HttpRestartServerHandler handler = new HttpRestartServerHandler(server);
		ServerHttpRequest request = mock(ServerHttpRequest.class);
		ServerHttpResponse response = mock(ServerHttpResponse.class);
		handler.handle(request, response);
		then(server).should().handle(request, response);
	}
}
/*
package org.springframework.boot.devtools.restart.server;
/**
class DefaultSourceDirectoryUrlFilterTests {
	private static final String SOURCE_ROOT = '/Users/me/code/some-root/';
	private static final List<String> COMMON_POSTFIXES;
	static {
		List<String> postfixes = new ArrayList<>();
		postfixes.add('.jar');
		postfixes.add('-1.3.0.jar');
		postfixes.add('-1.3.0-SNAPSHOT.jar');
		postfixes.add('-1.3.0.BUILD-SNAPSHOT.jar');
		postfixes.add('-1.3.0.M1.jar');
		postfixes.add('-1.3.0.RC1.jar');
		postfixes.add('-1.3.0.RELEASE.jar');
		postfixes.add('-1.3.0.Final.jar');
		postfixes.add('-1.3.0.GA.jar');
		postfixes.add('-1.3.0.0.0.0.jar');
		COMMON_POSTFIXES = Collections.unmodifiableList(postfixes);
	}
	private final DefaultSourceDirectoryUrlFilter filter = new DefaultSourceDirectoryUrlFilter();
	@Test
	void mavenSourceDirectory() throws Exception {
		doTest('my-module/target/classes/');
	}
	@Test
	void gradleEclipseSourceDirectory() throws Exception {
		doTest('my-module/bin/');
	}
	@Test
	void unusualSourceDirectory() throws Exception {
		doTest('my-module/something/quite/quite/mad/');
	}
	private void doTest(String sourcePostfix) throws MalformedURLException {
		doTest(sourcePostfix, 'my-module', true);
		doTest(sourcePostfix, 'my-module-other', false);
		doTest(sourcePostfix, 'my-module-other-again', false);
		doTest(sourcePostfix, 'my-module.other', false);
	}
	private void doTest(String sourcePostfix, String moduleRoot, boolean expected) throws MalformedURLException {
		String sourceDirectory = SOURCE_ROOT + sourcePostfix;
		for (String postfix : COMMON_POSTFIXES) {
			for (URL url : getUrls(moduleRoot + postfix)) {
				boolean match = this.filter.isMatch(sourceDirectory, url);
				assertThat(match).as(url + ' against ' + sourceDirectory).isEqualTo(expected);
			}
		}
	}
	private List<URL> getUrls(String name) throws MalformedURLException {
		List<URL> urls = new ArrayList<>();
		urls.add(new URL('file:/some/path/' + name));
		urls.add(new URL('file:/some/path/' + name + '!/'));
		for (String postfix : COMMON_POSTFIXES) {
			urls.add(new URL('jar:file:/some/path/lib-module' + postfix + '!/lib/' + name));
			urls.add(new URL('jar:file:/some/path/lib-module' + postfix + '!/lib/' + name + '!/'));
		}
		return urls;
	}
}
/*
package org.springframework.boot.devtools.restart.server;
/**
@ExtendWith(MockitoExtension.class)
class HttpRestartServerTests {
	@Mock
	private RestartServer delegate;
	private HttpRestartServer server;
	@BeforeEach
	void setup() {
		this.server = new HttpRestartServer(this.delegate);
	}
	@Test
	void sourceDirectoryUrlFilterMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpRestartServer((SourceDirectoryUrlFilter) null))
			.withMessageContaining('SourceDirectoryUrlFilter must not be null');
	}
	@Test
	void restartServerMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new HttpRestartServer((RestartServer) null))
			.withMessageContaining('RestartServer must not be null');
	}
	@Test
	void sendClassLoaderFiles() throws Exception {
		MockHttpServletRequest request = new MockHttpServletRequest();
		MockHttpServletResponse response = new MockHttpServletResponse();
		ClassLoaderFiles files = new ClassLoaderFiles();
		files.addFile('name', new ClassLoaderFile(Kind.ADDED, new byte[0]));
		byte[] bytes = serialize(files);
		request.setContent(bytes);
		this.server.handle(new ServletServerHttpRequest(request), new ServletServerHttpResponse(response));
		then(this.delegate).should()
			.updateAndRestart(
					assertArg((classLoaderFiles) -> assertThat(classLoaderFiles.getFile('name')).isNotNull()));
		assertThat(response.getStatus()).isEqualTo(200);
	}
	@Test
	void sendNoContent() throws Exception {
		MockHttpServletRequest request = new MockHttpServletRequest();
		MockHttpServletResponse response = new MockHttpServletResponse();
		this.server.handle(new ServletServerHttpRequest(request), new ServletServerHttpResponse(response));
		then(this.delegate).shouldHaveNoInteractions();
		assertThat(response.getStatus()).isEqualTo(500);
	}
	@Test
	void sendBadData() throws Exception {
		MockHttpServletRequest request = new MockHttpServletRequest();
		MockHttpServletResponse response = new MockHttpServletResponse();
		request.setContent(new byte[] { 0, 0, 0 });
		this.server.handle(new ServletServerHttpRequest(request), new ServletServerHttpResponse(response));
		then(this.delegate).shouldHaveNoInteractions();
		assertThat(response.getStatus()).isEqualTo(500);
	}
	private byte[] serialize(Object object) throws IOException {
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new ObjectOutputStream(bos);
		oos.writeObject(object);
		oos.close();
		return bos.toByteArray();
	}
}
/*
package org.springframework.boot.devtools.restart.server;
/**
class RestartServerTests {
	@Test
	void sourceDirectoryUrlFilterMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new RestartServer((SourceDirectoryUrlFilter) null))
			.withMessageContaining('SourceDirectoryUrlFilter must not be null');
	}
	@Test
	void updateAndRestart() throws Exception {
		URL url1 = new URL('file:/proj/module-a.jar!/');
		URL url2 = new URL('file:/proj/module-b.jar!/');
		URL url3 = new URL('file:/proj/module-c.jar!/');
		URL url4 = new URL('file:/proj/module-d.jar!/');
		URLClassLoader classLoaderA = new URLClassLoader(new URL[] { url1, url2 });
		URLClassLoader classLoaderB = new URLClassLoader(new URL[] { url3, url4 }, classLoaderA);
		SourceDirectoryUrlFilter filter = new DefaultSourceDirectoryUrlFilter();
		MockRestartServer server = new MockRestartServer(filter, classLoaderB);
		ClassLoaderFiles files = new ClassLoaderFiles();
		ClassLoaderFile fileA = new ClassLoaderFile(Kind.ADDED, new byte[0]);
		ClassLoaderFile fileB = new ClassLoaderFile(Kind.ADDED, new byte[0]);
		files.addFile('my/module-a', 'ClassA.class', fileA);
		files.addFile('my/module-c', 'ClassB.class', fileB);
		server.updateAndRestart(files);
		Set<URL> expectedUrls = new LinkedHashSet<>(Arrays.asList(url1, url3));
		assertThat(server.restartUrls).isEqualTo(expectedUrls);
		assertThat(server.restartFiles).isEqualTo(files);
	}
	@Test
	void updateSetsJarLastModified(@TempDir File directory) throws Exception {
		long startTime = System.currentTimeMillis();
		File jarFile = new File(directory, 'module-a.jar');
		new FileOutputStream(jarFile).close();
		jarFile.setLastModified(0);
		URL url = jarFile.toURI().toURL();
		URLClassLoader classLoader = new URLClassLoader(new URL[] { url });
		SourceDirectoryUrlFilter filter = new DefaultSourceDirectoryUrlFilter();
		MockRestartServer server = new MockRestartServer(filter, classLoader);
		ClassLoaderFiles files = new ClassLoaderFiles();
		ClassLoaderFile fileA = new ClassLoaderFile(Kind.ADDED, new byte[0]);
		files.addFile('my/module-a', 'ClassA.class', fileA);
		server.updateAndRestart(files);
		assertThat(jarFile.lastModified()).isGreaterThan(startTime - 1000);
	}
	@Test
	void updateReplacesLocalFilesWhenPossible(@TempDir File directory) throws Exception {
		// This is critical for Cloud Foundry support where the application is
		// run exploded and resources can be found from the servlet root (outside the
		// classloader)
		File classFile = new File(directory, 'ClassA.class');
		FileCopyUtils.copy('abc'.getBytes(), classFile);
		URL url = directory.toURI().toURL();
		URLClassLoader classLoader = new URLClassLoader(new URL[] { url });
		SourceDirectoryUrlFilter filter = new DefaultSourceDirectoryUrlFilter();
		MockRestartServer server = new MockRestartServer(filter, classLoader);
		ClassLoaderFiles files = new ClassLoaderFiles();
		ClassLoaderFile fileA = new ClassLoaderFile(Kind.ADDED, 'def'.getBytes());
		files.addFile('my/module-a', 'ClassA.class', fileA);
		server.updateAndRestart(files);
		assertThat(FileCopyUtils.copyToByteArray(classFile)).isEqualTo('def'.getBytes());
	}
	static class MockRestartServer extends RestartServer {
		MockRestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter, ClassLoader classLoader) {
			super(sourceDirectoryUrlFilter, classLoader);
		}
		private Set<URL> restartUrls;
		private ClassLoaderFiles restartFiles;
		@Override
		protected void restart(Set<URL> urls, ClassLoaderFiles files) {
			this.restartUrls = urls;
			this.restartFiles = files;
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class RestartScopeInitializerTests {
	private static AtomicInteger createCount;
	private static AtomicInteger refreshCount;
	@Test
	void restartScope() {
		createCount = new AtomicInteger();
		refreshCount = new AtomicInteger();
		ConfigurableApplicationContext context = runApplication();
		context.close();
		context = runApplication();
		context.close();
		assertThat(createCount.get()).isOne();
		assertThat(refreshCount.get()).isEqualTo(2);
	}
	private ConfigurableApplicationContext runApplication() {
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		return application.run();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		@RestartScope
		ScopeTestBean scopeTestBean() {
			return new ScopeTestBean();
		}
	}
	static class ScopeTestBean implements ApplicationListener<ContextRefreshedEvent> {
		ScopeTestBean() {
			createCount.incrementAndGet();
		}
		@Override
		public void onApplicationEvent(ContextRefreshedEvent event) {
			refreshCount.incrementAndGet();
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
@ExtendWith(OutputCaptureExtension.class)
class RestarterTests {
	@BeforeEach
	void setup() {
		RestarterInitializer.setRestarterInstance();
	}
	@AfterEach
	void cleanup() {
		Restarter.clearInstance();
	}
	@Test
	void cantGetInstanceBeforeInitialize() {
		Restarter.clearInstance();
		assertThatIllegalStateException().isThrownBy(Restarter::getInstance)
			.withMessageContaining('Restarter has not been initialized');
	}
	@Test
	void testRestart(CapturedOutput output) {
		Restarter.clearInstance();
		Thread thread = new Thread(SampleApplication::main);
		thread.start();
		Awaitility.await().atMost(Duration.ofSeconds(30)).untilAsserted(() -> {
			assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Tick 0')).isGreaterThan(1);
			assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Tick 1')).isGreaterThan(1);
			assertThat(CloseCountingApplicationListener.closed).isGreaterThan(0);
		});
	}
	@Test
	void testDisabled() {
		Restarter.disable();
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		Restarter.getInstance().prepare(context);
		assertThat(Restarter.getInstance()).extracting('rootContexts', as(InstanceOfAssertFactories.LIST)).isEmpty();
	}
	@Test
	@SuppressWarnings('rawtypes')
	void getOrAddAttributeWithNewAttribute() {
		ObjectFactory objectFactory = mock(ObjectFactory.class);
		given(objectFactory.getObject()).willReturn('abc');
		Object attribute = Restarter.getInstance().getOrAddAttribute('x', objectFactory);
		assertThat(attribute).isEqualTo('abc');
	}
	@Test
	void addUrlsMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> Restarter.getInstance().addUrls(null))
			.withMessageContaining('Urls must not be null');
	}
	@Test
	void addUrls() throws Exception {
		URL url = new URL('file:/proj/module-a.jar!/');
		Collection<URL> urls = Collections.singleton(url);
		Restarter restarter = Restarter.getInstance();
		restarter.addUrls(urls);
		restarter.restart();
		ClassLoader classLoader = ((TestableRestarter) restarter).getRelaunchClassLoader();
		assertThat(((URLClassLoader) classLoader).getURLs()[0]).isEqualTo(url);
	}
	@Test
	void addClassLoaderFilesMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> Restarter.getInstance().addClassLoaderFiles(null))
			.withMessageContaining('ClassLoaderFiles must not be null');
	}
	@Test
	void addClassLoaderFiles() {
		ClassLoaderFiles classLoaderFiles = new ClassLoaderFiles();
		classLoaderFiles.addFile('f', new ClassLoaderFile(Kind.ADDED, 'abc'.getBytes()));
		Restarter restarter = Restarter.getInstance();
		restarter.addClassLoaderFiles(classLoaderFiles);
		restarter.restart();
		ClassLoader classLoader = ((TestableRestarter) restarter).getRelaunchClassLoader();
		assertThat(classLoader.getResourceAsStream('f')).hasContent('abc');
	}
	@Test
	void getOrAddAttributeWithExistingAttribute() {
		Restarter.getInstance().getOrAddAttribute('x', () -> 'abc');
		ObjectFactory<?> objectFactory = mock(ObjectFactory.class);
		Object attribute = Restarter.getInstance().getOrAddAttribute('x', objectFactory);
		assertThat(attribute).isEqualTo('abc');
		then(objectFactory).shouldHaveNoInteractions();
	}
	@Test
	void getOrAddAttributeWithRecursion() {
		Restarter restarter = Restarter.getInstance();
		Object added = restarter.getOrAddAttribute('postgresContainer', () -> {
			restarter.getOrAddAttribute('rabbitContainer', () -> 'def');
			return 'abc';
		});
		ObjectFactory<?> objectFactory = mock(ObjectFactory.class);
		assertThat(added).isEqualTo('abc');
		assertThat(restarter.getOrAddAttribute('postgresContainer', objectFactory)).isEqualTo('abc');
		assertThat(restarter.getOrAddAttribute('rabbitContainer', objectFactory)).isEqualTo('def');
		then(objectFactory).shouldHaveNoInteractions();
	}
	@Test
	void getThreadFactory() throws Exception {
		final ClassLoader parentLoader = Thread.currentThread().getContextClassLoader();
		final ClassLoader contextClassLoader = new URLClassLoader(new URL[0]);
		Thread thread = new Thread(() -> {
			Runnable runnable = mock(Runnable.class);
			Thread regular = new Thread();
			ThreadFactory factory = Restarter.getInstance().getThreadFactory();
			Thread viaFactory = factory.newThread(runnable);
			// Regular threads will inherit the current thread
			assertThat(regular.getContextClassLoader()).isEqualTo(contextClassLoader);
			// Factory threads should inherit from the initial thread
			assertThat(viaFactory.getContextClassLoader()).isEqualTo(parentLoader);
		});
		thread.setContextClassLoader(contextClassLoader);
		thread.start();
		thread.join();
	}
	@Test
	void getInitialUrls() throws Exception {
		Restarter.clearInstance();
		RestartInitializer initializer = mock(RestartInitializer.class);
		URL[] urls = new URL[] { new URL('file:/proj/module-a.jar!/') };
		given(initializer.getInitialUrls(any(Thread.class))).willReturn(urls);
		Restarter.initialize(new String[0], false, initializer, false);
		assertThat(Restarter.getInstance().getInitialUrls()).isEqualTo(urls);
	}
	@Component
	@EnableScheduling
	static class SampleApplication {
		private int count = 0;
		private static final AtomicBoolean restart = new AtomicBoolean();
		@Scheduled(fixedDelay = 200)
		void tickBean() {
			System.out.println('Tick ' + this.count++ + ' ' + Thread.currentThread());
		}
		@Scheduled(initialDelay = 500, fixedDelay = 500)
		void restart() {
			if (SampleApplication.restart.compareAndSet(false, true)) {
				Restarter.getInstance().restart();
			}
		}
		static void main(String... args) {
			Restarter.initialize(args, false, new MockRestartInitializer(), true);
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
					SampleApplication.class);
			context.addApplicationListener(new CloseCountingApplicationListener());
			Restarter.getInstance().prepare(context);
		}
	}
	static class CloseCountingApplicationListener implements ApplicationListener<ContextClosedEvent> {
		static int closed = 0;
		@Override
		public void onApplicationEvent(ContextClosedEvent event) {
			closed++;
		}
	}
	static class TestableRestarter extends Restarter {
		private ClassLoader relaunchClassLoader;
		TestableRestarter() {
			this(Thread.currentThread(), new String[] {}, false, new MockRestartInitializer());
		}
		protected TestableRestarter(Thread thread, String[] args, boolean forceReferenceCleanup,
				RestartInitializer initializer) {
			super(thread, args, forceReferenceCleanup, initializer);
		}
		@Override
		public void restart(FailureHandler failureHandler) {
			try {
				stop();
				start(failureHandler);
			}
			catch (Exception ex) {
				throw new IllegalStateException(ex);
			}
		}
		@Override
		protected Throwable relaunch(ClassLoader classLoader) {
			this.relaunchClassLoader = classLoader;
			return null;
		}
		@Override
		protected void stop() {
		}
		ClassLoader getRelaunchClassLoader() {
			return this.relaunchClassLoader;
		}
	}
	static class RestarterInitializer {
		static void setRestarterInstance() {
			main(new String[0]);
		}
		static void main(String[] args) {
			Restarter.setInstance(new TestableRestarter());
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
@ExtendWith(OutputCaptureExtension.class)
class RestartApplicationListenerTests {
	private static final String ENABLED_PROPERTY = 'spring.devtools.restart.enabled';
	private static final String[] ARGS = new String[] { 'a', 'b', 'c' };
	@BeforeEach
	@AfterEach
	void cleanup() {
		Restarter.clearInstance();
		System.clearProperty(ENABLED_PROPERTY);
	}
	@Test
	void isHighestPriority() {
		assertThat(new RestartApplicationListener().getOrder()).isEqualTo(Ordered.HIGHEST_PRECEDENCE);
	}
	@Test
	void initializeWithReady() {
		testInitialize(false, new ImplicitlyEnabledRestartApplicationListener());
		assertThat(Restarter.getInstance()).hasFieldOrPropertyWithValue('args', ARGS);
		assertThat(Restarter.getInstance().isFinished()).isTrue();
		assertThat((List<?>) ReflectionTestUtils.getField(Restarter.getInstance(), 'rootContexts')).isNotEmpty();
	}
	@Test
	void initializeWithFail() {
		testInitialize(true, new ImplicitlyEnabledRestartApplicationListener());
		assertThat(Restarter.getInstance()).hasFieldOrPropertyWithValue('args', ARGS);
		assertThat(Restarter.getInstance().isFinished()).isTrue();
		assertThat((List<?>) ReflectionTestUtils.getField(Restarter.getInstance(), 'rootContexts')).isEmpty();
	}
	@Test
	void disableWithSystemProperty(CapturedOutput output) {
		System.setProperty(ENABLED_PROPERTY, 'false');
		testInitialize(false, new ImplicitlyEnabledRestartApplicationListener());
		assertThat(Restarter.getInstance()).hasFieldOrPropertyWithValue('enabled', false);
		assertThat(output).contains('Restart disabled due to System property');
	}
	@Test
	void enableWithSystemProperty(CapturedOutput output) {
		System.setProperty(ENABLED_PROPERTY, 'true');
		testInitialize(false, new ImplicitlyEnabledRestartApplicationListener());
		assertThat(Restarter.getInstance()).hasFieldOrPropertyWithValue('enabled', true);
		assertThat(output).contains('Restart enabled irrespective of application packaging due to System property');
	}
	@Test
	void enableWithSystemPropertyWhenImplicitlyDisabled(CapturedOutput output) {
		System.setProperty(ENABLED_PROPERTY, 'true');
		testInitialize(false, new RestartApplicationListener());
		assertThat(Restarter.getInstance()).hasFieldOrPropertyWithValue('enabled', true);
		assertThat(output).contains('Restart enabled irrespective of application packaging due to System property');
	}
	@Test
	void implicitlyDisabledInTests(CapturedOutput output) {
		testInitialize(false, new RestartApplicationListener());
		assertThat(Restarter.getInstance()).hasFieldOrPropertyWithValue('enabled', false);
		assertThat(output).contains('Restart disabled due to context in which it is running');
	}
	private void testInitialize(boolean failed, RestartApplicationListener listener) {
		Restarter.clearInstance();
		DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
		SpringApplication application = new SpringApplication();
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		listener.onApplicationEvent(new ApplicationStartingEvent(bootstrapContext, application, ARGS));
		assertThat(Restarter.getInstance()).isNotNull();
		assertThat(Restarter.getInstance().isFinished()).isFalse();
		listener.onApplicationEvent(new ApplicationPreparedEvent(application, ARGS, context));
		if (failed) {
			listener.onApplicationEvent(new ApplicationFailedEvent(application, ARGS, context, new RuntimeException()));
		}
		else {
			listener.onApplicationEvent(new ApplicationReadyEvent(application, ARGS, context, null));
		}
	}
	private static final class ImplicitlyEnabledRestartApplicationListener extends RestartApplicationListener {
		@Override
		boolean implicitlyEnableRestart() {
			return true;
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
public class MockRestartInitializer implements RestartInitializer {
	@Override
	public URL[] getInitialUrls(Thread thread) {
		return new URL[] {};
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
public class MockRestarter implements BeforeEachCallback, AfterEachCallback, ParameterResolver {
	private final Map<String, Object> attributes = new HashMap<>();
	private final Restarter mock = mock(Restarter.class);
	public Restarter getMock() {
		return this.mock;
	}
	@Override
	public void afterEach(ExtensionContext context) throws Exception {
		this.attributes.clear();
		Restarter.clearInstance();
	}
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		Restarter.setInstance(this.mock);
		given(this.mock.getInitialUrls()).willReturn(new URL[] {});
		given(this.mock.getOrAddAttribute(anyString(), any(ObjectFactory.class))).willAnswer((invocation) -> {
			String name = invocation.getArgument(0);
			ObjectFactory<?> factory = invocation.getArgument(1);
			Object attribute = MockRestarter.this.attributes.get(name);
			if (attribute == null) {
				attribute = factory.getObject();
				MockRestarter.this.attributes.put(name, attribute);
			}
			return attribute;
		});
		given(this.mock.getThreadFactory()).willReturn(Thread::new);
	}
	@Override
	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
		return parameterContext.getParameter().getType().equals(Restarter.class);
	}
	@Override
	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
		return this.mock;
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class DefaultRestartInitializerTests {
	@Test
	void jUnitStackShouldReturnNull() {
		testSkippedStacks('org.junit.runners.Something');
	}
	@Test
	void jUnit5StackShouldReturnNull() {
		testSkippedStacks('org.junit.platform.Something');
	}
	@Test
	void springTestStackShouldReturnNull() {
		testSkippedStacks('org.springframework.boot.test.Something');
	}
	@Test
	void cucumberStackShouldReturnNull() {
		testSkippedStacks('cucumber.runtime.Runtime.run');
	}
	@Test
	void validMainThreadShouldReturnUrls() {
		DefaultRestartInitializer initializer = new DefaultRestartInitializer();
		ClassLoader classLoader = new MockAppClassLoader(getClass().getClassLoader());
		Thread thread = new Thread();
		thread.setName('main');
		thread.setContextClassLoader(classLoader);
		assertThat(initializer.getInitialUrls(thread)).isNotNull();
	}
	@Test
	void threadNotNamedMainShouldReturnNull() {
		DefaultRestartInitializer initializer = new DefaultRestartInitializer();
		ClassLoader classLoader = new MockAppClassLoader(getClass().getClassLoader());
		Thread thread = new Thread();
		thread.setName('buscuit');
		thread.setContextClassLoader(classLoader);
		assertThat(initializer.getInitialUrls(thread)).isNull();
	}
	@Test
	void threadNotUsingAppClassLoader() {
		DefaultRestartInitializer initializer = new DefaultRestartInitializer();
		ClassLoader classLoader = new MockLauncherClassLoader(getClass().getClassLoader());
		Thread thread = new Thread();
		thread.setName('main');
		thread.setContextClassLoader(classLoader);
		assertThat(initializer.getInitialUrls(thread)).isNull();
	}
	@Test
	void urlsCanBeRetrieved() throws IOException {
		Thread thread = Thread.currentThread();
		ClassLoader classLoader = thread.getContextClassLoader();
		try (URLClassLoader contextClassLoader = new URLClassLoader(
				new URL[] { new URL('file:test-app/build/classes/main/') }, classLoader)) {
			thread.setContextClassLoader(contextClassLoader);
			assertThat(new DefaultRestartInitializer().getUrls(thread)).isNotEmpty();
		}
		finally {
			thread.setContextClassLoader(classLoader);
		}
	}
	protected void testSkippedStacks(String s) {
		DefaultRestartInitializer initializer = new DefaultRestartInitializer();
		ClassLoader classLoader = new MockAppClassLoader(getClass().getClassLoader());
		Thread thread = mock(Thread.class);
		given(thread.getName()).willReturn('main');
		StackTraceElement element = new StackTraceElement(s, 'someMethod', 'someFile', 123);
		given(thread.getStackTrace()).willReturn(new StackTraceElement[] { element });
		given(thread.getContextClassLoader()).willReturn(classLoader);
		assertThat(initializer.getInitialUrls(thread)).isNull();
	}
	static class MockAppClassLoader extends ClassLoader {
		MockAppClassLoader(ClassLoader parent) {
			super(parent);
		}
	}
	static class MockLauncherClassLoader extends ClassLoader {
		MockLauncherClassLoader(ClassLoader parent) {
			super(parent);
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class ChangeableUrlsTests {
	@TempDir
	File tempDir;
	@Test
	void directoryUrl() throws Exception {
		URL url = makeUrl('myproject');
		assertThat(ChangeableUrls.fromUrls(url)).hasSize(1);
	}
	@Test
	void fileUrl() throws Exception {
		File file = new File(this.tempDir, 'file');
		file.createNewFile();
		URL url = file.toURI().toURL();
		assertThat(ChangeableUrls.fromUrls(url)).isEmpty();
	}
	@Test
	void httpUrl() throws Exception {
		URL url = new URL('https://spring.io');
		assertThat(ChangeableUrls.fromUrls(url)).isEmpty();
	}
	@Test
	void httpsUrl() throws Exception {
		URL url = new URL('https://spring.io');
		assertThat(ChangeableUrls.fromUrls(url)).isEmpty();
	}
	@Test
	void skipsUrls() throws Exception {
		ChangeableUrls urls = ChangeableUrls.fromUrls(makeUrl('spring-boot'), makeUrl('spring-boot-autoconfigure'),
				makeUrl('spring-boot-actuator'), makeUrl('spring-boot-starter'),
				makeUrl('spring-boot-starter-some-thing'));
		assertThat(urls).isEmpty();
	}
	@Test
	void urlsFromJarClassPathAreConsidered() throws Exception {
		File relative = new File(this.tempDir, UUID.randomUUID().toString());
		relative.mkdir();
		File absolute = new File(this.tempDir, UUID.randomUUID().toString());
		absolute.mkdirs();
		URL absoluteUrl = absolute.toURI().toURL();
		File jarWithClassPath = makeJarFileWithUrlsInManifestClassPath('project-core/target/classes/',
				'project-web/target/classes/', 'project%20space/target/classes/', 'does-not-exist/target/classes/',
				relative.getName() + '/', absoluteUrl);
		new File(jarWithClassPath.getParentFile(), 'project-core/target/classes').mkdirs();
		new File(jarWithClassPath.getParentFile(), 'project-web/target/classes').mkdirs();
		new File(jarWithClassPath.getParentFile(), 'project space/target/classes').mkdirs();
		ChangeableUrls urls = ChangeableUrls.fromClassLoader(
				new URLClassLoader(new URL[] { jarWithClassPath.toURI().toURL(), makeJarFileWithNoManifest() }));
		assertThat(urls.toList()).containsExactly(
				new URL(jarWithClassPath.toURI().toURL(), 'project-core/target/classes/'),
				new URL(jarWithClassPath.toURI().toURL(), 'project-web/target/classes/'),
				new URL(jarWithClassPath.toURI().toURL(), 'project space/target/classes/'), relative.toURI().toURL(),
				absoluteUrl);
	}
	private URL makeUrl(String name) throws IOException {
		File file = new File(this.tempDir, UUID.randomUUID().toString());
		file = new File(file, name);
		file = new File(file, 'build');
		file = new File(file, 'classes');
		file.mkdirs();
		return file.toURI().toURL();
	}
	private File makeJarFileWithUrlsInManifestClassPath(Object... urls) throws Exception {
		File classpathJar = new File(this.tempDir, 'classpath.jar');
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue(Attributes.Name.MANIFEST_VERSION.toString(), '1.0');
		manifest.getMainAttributes()
			.putValue(Attributes.Name.CLASS_PATH.toString(), StringUtils.arrayToDelimitedString(urls, ' '));
		new JarOutputStream(new FileOutputStream(classpathJar), manifest).close();
		return classpathJar;
	}
	private URL makeJarFileWithNoManifest() throws Exception {
		File classpathJar = new File(this.tempDir, 'no-manifest.jar');
		new ZipOutputStream(new FileOutputStream(classpathJar)).close();
		return classpathJar.toURI().toURL();
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class SilentExitExceptionHandlerTests {
	@Test
	void setupAndExit() throws Exception {
		TestThread testThread = new TestThread() {
			@Override
			public void run() {
				SilentExitExceptionHandler.exitCurrentThread();
				fail('Didn"t exit');
			}
		};
		SilentExitExceptionHandler.setup(testThread);
		testThread.startAndJoin();
		assertThat(testThread.getThrown()).isNull();
	}
	@Test
	void doesntInterfereWithOtherExceptions() throws Exception {
		TestThread testThread = new TestThread() {
			@Override
			public void run() {
				throw new IllegalStateException('Expected');
			}
		};
		SilentExitExceptionHandler.setup(testThread);
		testThread.startAndJoin();
		assertThat(testThread.getThrown().getMessage()).isEqualTo('Expected');
	}
	@Test
	void preventsNonZeroExitCodeWhenAllOtherThreadsAreDaemonThreads() {
		try {
			SilentExitExceptionHandler.exitCurrentThread();
		}
		catch (Exception ex) {
			TestSilentExitExceptionHandler silentExitExceptionHandler = new TestSilentExitExceptionHandler();
			silentExitExceptionHandler.uncaughtException(Thread.currentThread(), ex);
			try {
				assertThat(silentExitExceptionHandler.nonZeroExitCodePrevented).isTrue();
			}
			finally {
				silentExitExceptionHandler.cleanUp();
			}
		}
	}
	static class TestThread extends Thread {
		private Throwable thrown;
		TestThread() {
			setUncaughtExceptionHandler((thread, exception) -> TestThread.this.thrown = exception);
		}
		Throwable getThrown() {
			return this.thrown;
		}
		void startAndJoin() throws InterruptedException {
			start();
			join();
		}
	}
	static class TestSilentExitExceptionHandler extends SilentExitExceptionHandler {
		private boolean nonZeroExitCodePrevented;
		private final Object monitor = new Object();
		TestSilentExitExceptionHandler() {
			super(null);
		}
		@Override
		protected void preventNonZeroExitCode() {
			this.nonZeroExitCodePrevented = true;
		}
		@Override
		protected Thread[] getAllThreads() {
			final CountDownLatch threadRunning = new CountDownLatch(1);
			Thread daemonThread = new Thread(() -> {
				synchronized (TestSilentExitExceptionHandler.this.monitor) {
					threadRunning.countDown();
					try {
						TestSilentExitExceptionHandler.this.monitor.wait();
					}
					catch (InterruptedException ex) {
						Thread.currentThread().interrupt();
					}
				}
			});
			daemonThread.setDaemon(true);
			daemonThread.start();
			try {
				threadRunning.await();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
			return new Thread[] { Thread.currentThread(), daemonThread };
		}
		private void cleanUp() {
			synchronized (this.monitor) {
				this.monitor.notifyAll();
			}
		}
	}
}
/*
package org.springframework.boot.devtools;
/**
class RemoteUrlPropertyExtractorTests {
	@AfterEach
	void preventRunFailuresFromPollutingLoggerContext() {
		((Logger) LoggerFactory.getLogger(RemoteUrlPropertyExtractorTests.class)).getLoggerContext()
			.getTurboFilterList()
			.clear();
	}
	@Test
	void missingUrl() {
		assertThatIllegalStateException().isThrownBy(this::doTest).withMessageContaining('No remote URL specified');
	}
	@Test
	void malformedUrl() {
		assertThatIllegalStateException().isThrownBy(() -> doTest('::://wibble'))
			.withMessageContaining('Malformed URL "::://wibble"');
	}
	@Test
	void multipleUrls() {
		assertThatIllegalStateException().isThrownBy(() -> doTest('http://localhost:8080', 'http://localhost:9090'))
			.withMessageContaining('Multiple URLs specified');
	}
	@Test
	void validUrl() {
		ApplicationContext context = doTest('http://localhost:8080');
		assertThat(context.getEnvironment().getProperty('remoteUrl')).isEqualTo('http://localhost:8080');
	}
	@Test
	void cleanValidUrl() {
		ApplicationContext context = doTest('http://localhost:8080/');
		assertThat(context.getEnvironment().getProperty('remoteUrl')).isEqualTo('http://localhost:8080');
	}
	private ApplicationContext doTest(String... args) {
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.addListeners(new RemoteUrlPropertyExtractor());
		return application.run(args);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.devtools.settings;
/**
class DevToolsSettingsTests {
	private static final String ROOT = DevToolsSettingsTests.class.getPackage().getName().replace(".", "/") + '/';
	@Test
	void includePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings.load(ROOT + 'spring-devtools-include.properties');
		assertThat(settings.isRestartInclude(new URL('file://test/a'))).isTrue();
		assertThat(settings.isRestartInclude(new URL('file://test/b'))).isTrue();
		assertThat(settings.isRestartInclude(new URL('file://test/c'))).isFalse();
	}
	@Test
	void excludePatterns() throws Exception {
		DevToolsSettings settings = DevToolsSettings.load(ROOT + 'spring-devtools-exclude.properties');
		assertThat(settings.isRestartExclude(new URL('file://test/a'))).isTrue();
		assertThat(settings.isRestartExclude(new URL('file://test/b'))).isTrue();
		assertThat(settings.isRestartExclude(new URL('file://test/c'))).isFalse();
	}
	@Test
	void defaultIncludePatterns(@TempDir File tempDir) throws Exception {
		DevToolsSettings settings = DevToolsSettings.get();
		assertThat(settings.isRestartExclude(makeUrl(tempDir, 'spring-boot'))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(tempDir, 'spring-boot-autoconfigure'))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(tempDir, 'spring-boot-actuator'))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(tempDir, 'spring-boot-starter'))).isTrue();
		assertThat(settings.isRestartExclude(makeUrl(tempDir, 'spring-boot-starter-some-thing'))).isTrue();
	}
	private URL makeUrl(File file, String name) throws IOException {
		file = new File(file, name);
		file = new File(file, 'build');
		file = new File(file, 'classes');
		file.mkdirs();
		return file.toURI().toURL();
	}
}
/*
package org.springframework.boot.devtools.env;
/**
class DevToolsHomePropertiesPostProcessorTests {
	private String configDir;
	private File home;
	private File customHome;
	@BeforeEach
	void setup(@TempDir File tempDir) {
		this.home = new File(tempDir, 'default-home');
		this.customHome = new File(tempDir, 'custom-home');
		this.configDir = this.home + '/.config/spring-boot/';
		new File(this.configDir).mkdirs();
	}
	@Test
	void loadsPropertiesFromHomeDirectoryUsingProperties() throws Exception {
		Properties properties = new Properties();
		properties.put('abc', 'def');
		writeFile(properties, '.spring-boot-devtools.properties');
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc')).isEqualTo('def');
	}
	@Test
	void loadsPropertiesFromCustomHomeDirectorySetUsingSystemProperty() throws Exception {
		Properties properties = new Properties();
		properties.put('uvw', 'xyz');
		writeFile(properties, this.customHome, '.config/spring-boot/spring-boot-devtools.properties');
		Properties systemProperties = new Properties();
		systemProperties.setProperty('spring.devtools.home', this.customHome.getAbsolutePath());
		ConfigurableEnvironment environment = getPostProcessedEnvironment(systemProperties);
		assertThat(environment.getProperty('uvw')).isEqualTo('xyz');
	}
	@Test
	void loadsPropertiesFromCustomHomeDirectorySetUsingEnvironmentVariable() throws Exception {
		Properties properties = new Properties();
		properties.put('uvw', 'xyz');
		writeFile(properties, this.customHome, '.config/spring-boot/spring-boot-devtools.properties');
		ConfigurableEnvironment environment = getPostProcessedEnvironment(
				Collections.singletonMap('SPRING_DEVTOOLS_HOME', this.customHome.getAbsolutePath()));
		assertThat(environment.getProperty('uvw')).isEqualTo('xyz');
	}
	@Test
	void loadsPropertiesFromConfigDirectoryUsingProperties() throws Exception {
		Properties properties = new Properties();
		properties.put('abc', 'def');
		OutputStream out = new FileOutputStream(new File(this.configDir, 'spring-boot-devtools.properties'));
		properties.store(out, null);
		out.close();
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc')).isEqualTo('def');
	}
	@Test
	void loadsPropertiesFromConfigDirectoryUsingYml() throws Exception {
		OutputStream out = new FileOutputStream(new File(this.configDir, 'spring-boot-devtools.yml'));
		File file = new ClassPathResource('spring-devtools.yaml', getClass()).getFile();
		byte[] content = Files.readAllBytes(file.toPath());
		out.write(content);
		out.close();
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc.xyz')).isEqualTo('def');
	}
	@Test
	void loadsPropertiesFromConfigDirectoryUsingYaml() throws Exception {
		OutputStream out = new FileOutputStream(new File(this.configDir, 'spring-boot-devtools.yaml'));
		File file = new ClassPathResource('spring-devtools.yaml', getClass()).getFile();
		byte[] content = Files.readAllBytes(file.toPath());
		out.write(content);
		out.close();
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc.xyz')).isEqualTo('def');
	}
	@Test
	void loadFromConfigDirectoryWithPropertiesTakingPrecedence() throws Exception {
		OutputStream out = new FileOutputStream(new File(this.configDir, 'spring-boot-devtools.yaml'));
		File file = new ClassPathResource('spring-devtools.yaml', getClass()).getFile();
		byte[] content = Files.readAllBytes(file.toPath());
		out.write(content);
		out.close();
		Properties properties2 = new Properties();
		properties2.put('abc.xyz', 'jkl');
		OutputStream out2 = new FileOutputStream(new File(this.configDir, 'spring-boot-devtools.properties'));
		properties2.store(out2, null);
		out2.close();
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc.xyz')).isEqualTo('jkl');
		assertThat(environment.getProperty('bing')).isEqualTo('blip');
	}
	@Test
	void loadFromConfigDirectoryTakesPrecedenceOverHomeDirectory() throws Exception {
		Properties properties = new Properties();
		properties.put('abc', 'def');
		properties.put('bar', 'baz');
		writeFile(properties, '.spring-boot-devtools.properties');
		Properties properties2 = new Properties();
		properties2.put('abc', 'jkl');
		OutputStream out2 = new FileOutputStream(new File(this.configDir, 'spring-boot-devtools.properties'));
		properties2.store(out2, null);
		out2.close();
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc')).isEqualTo('jkl');
		assertThat(environment.getProperty('bar')).isNull();
	}
	@Test
	void loadFromConfigDirectoryWithYamlTakesPrecedenceOverHomeDirectory() throws Exception {
		Properties properties = new Properties();
		properties.put('abc.xyz', 'jkl');
		properties.put('bar', 'baz');
		writeFile(properties, '.spring-boot-devtools.properties');
		OutputStream out2 = new FileOutputStream(new File(this.configDir, 'spring-boot-devtools.yml'));
		File file = new ClassPathResource('spring-devtools.yaml', getClass()).getFile();
		byte[] content = Files.readAllBytes(file.toPath());
		out2.write(content);
		out2.close();
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc.xyz')).isEqualTo('def');
		assertThat(environment.getProperty('bar')).isNull();
	}
	@Test
	void ignoresMissingHomeProperties() throws Exception {
		ConfigurableEnvironment environment = getPostProcessedEnvironment();
		assertThat(environment.getProperty('abc')).isNull();
	}
	private void writeFile(Properties properties, String path) throws IOException {
		writeFile(properties, this.home, path);
	}
	private void writeFile(Properties properties, File home, String path) throws IOException {
		File file = new File(home, path);
		file.getParentFile().mkdirs();
		try (OutputStream out = new FileOutputStream(file)) {
			properties.store(out, null);
		}
	}
	private ConfigurableEnvironment getPostProcessedEnvironment() throws Exception {
		return getPostProcessedEnvironment(null, null);
	}
	private ConfigurableEnvironment getPostProcessedEnvironment(Properties systemProperties) throws Exception {
		return getPostProcessedEnvironment(null, systemProperties);
	}
	private ConfigurableEnvironment getPostProcessedEnvironment(Map<String, String> env) throws Exception {
		return getPostProcessedEnvironment(env, null);
	}
	private ConfigurableEnvironment getPostProcessedEnvironment(Map<String, String> env, Properties systemProperties)
			throws Exception {
		if (systemProperties == null) {
			systemProperties = new Properties();
			systemProperties.setProperty('user.home', this.home.getAbsolutePath());
		}
		ConfigurableEnvironment environment = new MockEnvironment();
		DevToolsHomePropertiesPostProcessor postProcessor = new DevToolsHomePropertiesPostProcessor(
				(env != null) ? env : Collections.emptyMap(), systemProperties);
		runPostProcessor(() -> postProcessor.postProcessEnvironment(environment, null));
		return environment;
	}
	protected void runPostProcessor(Runnable runnable) throws Exception {
		Thread thread = new Thread(runnable);
		thread.start();
		thread.join();
	}
}
/*
package org.springframework.boot.devtools.env;
/**
class DevToolPropertiesIntegrationTests {
	private ConfigurableApplicationContext context;
	@BeforeEach
	void setup() {
		Restarter.initialize(new String[] {}, false, new MockInitializer(), false);
	}
	@AfterEach
	void cleanup() {
		if (this.context != null) {
			this.context.close();
		}
		Restarter.clearInstance();
	}
	@Test
	void classPropertyConditionIsAffectedByDevToolProperties() throws Exception {
		SpringApplication application = new SpringApplication(ClassConditionConfiguration.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = getContext(application::run);
		this.context.getBean(ClassConditionConfiguration.class);
	}
	@Test
	void beanMethodPropertyConditionIsAffectedByDevToolProperties() throws Exception {
		SpringApplication application = new SpringApplication(BeanConditionConfiguration.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = getContext(application::run);
		this.context.getBean(MyBean.class);
	}
	@Test
	void postProcessWhenRestarterDisabledAndRemoteSecretNotSetShouldNotAddPropertySource() throws Exception {
		Restarter.clearInstance();
		Restarter.disable();
		SpringApplication application = new SpringApplication(BeanConditionConfiguration.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = getContext(application::run);
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(MyBean.class));
	}
	@Test
	void postProcessWhenRestarterDisabledAndRemoteSecretSetShouldAddPropertySource() throws Exception {
		Restarter.clearInstance();
		Restarter.disable();
		SpringApplication application = new SpringApplication(BeanConditionConfiguration.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setDefaultProperties(Collections.singletonMap('spring.devtools.remote.secret', 'donttell'));
		this.context = getContext(application::run);
		this.context.getBean(MyBean.class);
	}
	@Test
	void postProcessEnablesIncludeStackTraceProperty() throws Exception {
		SpringApplication application = new SpringApplication(TestConfiguration.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = getContext(application::run);
		ConfigurableEnvironment environment = this.context.getEnvironment();
		String includeStackTrace = environment.getProperty('server.error.include-stacktrace');
		assertThat(includeStackTrace)
			.isEqualTo(ErrorProperties.IncludeAttribute.ALWAYS.toString().toLowerCase(Locale.ENGLISH));
		String includeMessage = environment.getProperty('server.error.include-message');
		assertThat(includeMessage)
			.isEqualTo(ErrorProperties.IncludeAttribute.ALWAYS.toString().toLowerCase(Locale.ENGLISH));
	}
	protected ConfigurableApplicationContext getContext(Supplier<ConfigurableApplicationContext> supplier)
			throws Exception {
		AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>();
		Thread thread = new Thread(() -> {
			ConfigurableApplicationContext context = supplier.get();
			atomicReference.getAndSet(context);
		});
		thread.start();
		thread.join();
		return atomicReference.get();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty('spring.h2.console.enabled')
	static class ClassConditionConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class BeanConditionConfiguration {
		@Bean
		@ConditionalOnProperty('spring.h2.console.enabled')
		MyBean myBean() {
			return new MyBean();
		}
	}
	static class MyBean {
	}
	static class MockInitializer implements RestartInitializer {
		@Override
		public URL[] getInitialUrls(Thread thread) {
			return new URL[] {};
		}
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
@FunctionalInterface
public interface AccessManager {
	/**
	 * {@link AccessManager} that permits all requests.
	 */
	AccessManager PERMIT_ALL = (request) -> true;
	/**
	 * Determine if the specific request is allowed to be handled by the
	 * {@link Dispatcher}.
	 * @param request the request to check
	 * @return {@code true} if access is allowed.
	 */
	boolean isAllowed(ServerHttpRequest request);
}
/*
package org.springframework.boot.devtools.remote.server;
/**
public class Dispatcher {
	private final AccessManager accessManager;
	private final List<HandlerMapper> mappers;
	public Dispatcher(AccessManager accessManager, Collection<HandlerMapper> mappers) {
		Assert.notNull(accessManager, 'AccessManager must not be null');
		Assert.notNull(mappers, 'Mappers must not be null');
		this.accessManager = accessManager;
		this.mappers = new ArrayList<>(mappers);
		AnnotationAwareOrderComparator.sort(this.mappers);
	}
	/**
	 * Dispatch the specified request to an appropriate {@link Handler}.
	 * @param request the request
	 * @param response the response
	 * @return {@code true} if the request was dispatched
	 * @throws IOException in case of I/O errors
	 */
	public boolean handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {
		for (HandlerMapper mapper : this.mappers) {
			Handler handler = mapper.getHandler(request);
			if (handler != null) {
				handle(handler, request, response);
				return true;
			}
		}
		return false;
	}
	private void handle(Handler handler, ServerHttpRequest request, ServerHttpResponse response) throws IOException {
		if (!this.accessManager.isAllowed(request)) {
			response.setStatusCode(HttpStatus.FORBIDDEN);
			return;
		}
		handler.handle(request, response);
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
public class HttpHeaderAccessManager implements AccessManager {
	private final String headerName;
	private final String expectedSecret;
	public HttpHeaderAccessManager(String headerName, String expectedSecret) {
		Assert.hasLength(headerName, 'HeaderName must not be empty');
		Assert.hasLength(expectedSecret, 'ExpectedSecret must not be empty');
		this.headerName = headerName;
		this.expectedSecret = expectedSecret;
	}
	@Override
	public boolean isAllowed(ServerHttpRequest request) {
		String providedSecret = request.getHeaders().getFirst(this.headerName);
		return this.expectedSecret.equals(providedSecret);
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
public class DispatcherFilter implements Filter {
	private final Dispatcher dispatcher;
	public DispatcherFilter(Dispatcher dispatcher) {
		Assert.notNull(dispatcher, 'Dispatcher must not be null');
		this.dispatcher = dispatcher;
	}
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {
			doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);
		}
		else {
			chain.doFilter(request, response);
		}
	}
	private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		ServerHttpRequest serverRequest = new ServletServerHttpRequest(request);
		ServerHttpResponse serverResponse = new ServletServerHttpResponse(response);
		if (!this.dispatcher.handle(serverRequest, serverResponse)) {
			chain.doFilter(request, response);
		}
	}
	@Override
	public void destroy() {
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
public class UrlHandlerMapper implements HandlerMapper {
	private final String requestUri;
	private final Handler handler;
	/**
	 * Create a new {@link UrlHandlerMapper}.
	 * @param url the URL to map
	 * @param handler the handler to use
	 */
	public UrlHandlerMapper(String url, Handler handler) {
		Assert.hasLength(url, 'URL must not be empty');
		Assert.isTrue(url.startsWith('/'), 'URL must start with "/"');
		this.requestUri = url;
		this.handler = handler;
	}
	@Override
	public Handler getHandler(ServerHttpRequest request) {
		if (this.requestUri.equals(request.getURI().getPath())) {
			return this.handler;
		}
		return null;
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
public class HttpStatusHandler implements Handler {
	private final HttpStatus status;
	/**
	 * Create a new {@link HttpStatusHandler} instance that will respond with an HTTP OK
	 * 200 status.
	 */
	public HttpStatusHandler() {
		this(HttpStatus.OK);
	}
	/**
	 * Create a new {@link HttpStatusHandler} instance that will respond with the
	 * specified status.
	 * @param status the status
	 */
	public HttpStatusHandler(HttpStatus status) {
		Assert.notNull(status, 'Status must not be null');
		this.status = status;
	}
	@Override
	public void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {
		response.setStatusCode(this.status);
	}
}
/*
package org.springframework.boot.devtools.remote.server;
/**
@FunctionalInterface
public interface HandlerMapper {
	/**
	 * Return the handler for the given request or {@code null}.
	 * @param request the request
	 * @return a {@link Handler} or {@code null}
	 */
	Handler getHandler(ServerHttpRequest request);
}
/*
/**
package org.springframework.boot.devtools.remote.server;
/*
package org.springframework.boot.devtools.remote.server;
/**
@FunctionalInterface
public interface Handler {
	/**
	 * Handle the request.
	 * @param request the request
	 * @param response the response
	 * @throws IOException in case of I/O errors
	 */
	void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;
}
/*
package org.springframework.boot.devtools.remote.client;
/**
public class ClassPathChangeUploader implements ApplicationListener<ClassPathChangedEvent> {
	private static final Map<ChangedFile.Type, ClassLoaderFile.Kind> TYPE_MAPPINGS;
	static {
		Map<ChangedFile.Type, ClassLoaderFile.Kind> map = new EnumMap<>(ChangedFile.Type.class);
		map.put(ChangedFile.Type.ADD, ClassLoaderFile.Kind.ADDED);
		map.put(ChangedFile.Type.DELETE, ClassLoaderFile.Kind.DELETED);
		map.put(ChangedFile.Type.MODIFY, ClassLoaderFile.Kind.MODIFIED);
		TYPE_MAPPINGS = Collections.unmodifiableMap(map);
	}
	private static final Log logger = LogFactory.getLog(ClassPathChangeUploader.class);
	private final URI uri;
	private final ClientHttpRequestFactory requestFactory;
	public ClassPathChangeUploader(String url, ClientHttpRequestFactory requestFactory) {
		Assert.hasLength(url, 'URL must not be empty');
		Assert.notNull(requestFactory, 'RequestFactory must not be null');
		try {
			this.uri = new URL(url).toURI();
		}
		catch (URISyntaxException | MalformedURLException ex) {
			throw new IllegalArgumentException('Malformed URL "' + url + '"');
		}
		this.requestFactory = requestFactory;
	}
	@Override
	public void onApplicationEvent(ClassPathChangedEvent event) {
		try {
			ClassLoaderFiles classLoaderFiles = getClassLoaderFiles(event);
			byte[] bytes = serialize(classLoaderFiles);
			performUpload(bytes, event);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private void performUpload(byte[] bytes, ClassPathChangedEvent event) throws IOException {
		try {
			while (true) {
				try {
					ClientHttpRequest request = this.requestFactory.createRequest(this.uri, HttpMethod.POST);
					HttpHeaders headers = request.getHeaders();
					headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
					headers.setContentLength(bytes.length);
					FileCopyUtils.copy(bytes, request.getBody());
					logUpload(event);
					try (ClientHttpResponse response = request.execute()) {
						HttpStatusCode statusCode = response.getStatusCode();
						Assert.state(statusCode == HttpStatus.OK,
								() -> 'Unexpected ' + statusCode + ' response uploading class files');
					}
					return;
				}
				catch (SocketException ex) {
					logger.warn(LogMessage.format(
							'A failure occurred when uploading to %s. Upload will be retried in 2 seconds', this.uri));
					logger.debug('Upload failure', ex);
					Thread.sleep(2000);
				}
			}
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			throw new IllegalStateException(ex);
		}
	}
	private void logUpload(ClassPathChangedEvent event) {
		logger.info(LogMessage.format('Uploading %s', event.overview()));
	}
	private byte[] serialize(ClassLoaderFiles classLoaderFiles) throws IOException {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
		objectOutputStream.writeObject(classLoaderFiles);
		objectOutputStream.close();
		return outputStream.toByteArray();
	}
	private ClassLoaderFiles getClassLoaderFiles(ClassPathChangedEvent event) throws IOException {
		ClassLoaderFiles files = new ClassLoaderFiles();
		for (ChangedFiles changedFiles : event.getChangeSet()) {
			String sourceDirectory = changedFiles.getSourceDirectory().getAbsolutePath();
			for (ChangedFile changedFile : changedFiles) {
				files.addFile(sourceDirectory, changedFile.getRelativeName(), asClassLoaderFile(changedFile));
			}
		}
		return files;
	}
	private ClassLoaderFile asClassLoaderFile(ChangedFile changedFile) throws IOException {
		ClassLoaderFile.Kind kind = TYPE_MAPPINGS.get(changedFile.getType());
		byte[] bytes = (kind != Kind.DELETED) ? FileCopyUtils.copyToByteArray(changedFile.getFile()) : null;
		long lastModified = (kind != Kind.DELETED) ? changedFile.getFile().lastModified() : System.currentTimeMillis();
		return new ClassLoaderFile(kind, lastModified, bytes);
	}
}
/*
package org.springframework.boot.devtools.remote.client;
/**
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(DevToolsProperties.class)
public class RemoteClientConfiguration implements InitializingBean {
	private static final Log logger = LogFactory.getLog(RemoteClientConfiguration.class);
	private final DevToolsProperties properties;
	@Value('${remoteUrl}')
	private String remoteUrl;
	public RemoteClientConfiguration(DevToolsProperties properties) {
		this.properties = properties;
	}
	@Bean
	public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
		return new PropertySourcesPlaceholderConfigurer();
	}
	@Bean
	public ClientHttpRequestFactory clientHttpRequestFactory() {
		List<ClientHttpRequestInterceptor> interceptors = Collections.singletonList(getSecurityInterceptor());
		SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
		Proxy proxy = this.properties.getRemote().getProxy();
		if (proxy.getHost() != null && proxy.getPort() != null) {
			requestFactory
				.setProxy(new java.net.Proxy(Type.HTTP, new InetSocketAddress(proxy.getHost(), proxy.getPort())));
		}
		return new InterceptingClientHttpRequestFactory(requestFactory, interceptors);
	}
	private ClientHttpRequestInterceptor getSecurityInterceptor() {
		RemoteDevToolsProperties remoteProperties = this.properties.getRemote();
		String secretHeaderName = remoteProperties.getSecretHeaderName();
		String secret = remoteProperties.getSecret();
		Assert.state(secret != null,
				'The environment value "spring.devtools.remote.secret" is required to secure your connection.');
		return new HttpHeaderInterceptor(secretHeaderName, secret);
	}
	@Override
	public void afterPropertiesSet() {
		logWarnings();
	}
	private void logWarnings() {
		RemoteDevToolsProperties remoteProperties = this.properties.getRemote();
		if (!remoteProperties.getRestart().isEnabled()) {
			logger.warn('Remote restart is disabled.');
		}
		if (!this.remoteUrl.startsWith('https://')) {
			logger.warn(LogMessage.format(
					'The connection to %s is insecure. You should use a URL starting with "https://".',
					this.remoteUrl));
		}
	}
	/**
	 * LiveReload configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.devtools.livereload', name = 'enabled', matchIfMissing = true)
	static class LiveReloadConfiguration {
		private final DevToolsProperties properties;
		private final ClientHttpRequestFactory clientHttpRequestFactory;
		private final String remoteUrl;
		private final ExecutorService executor = Executors.newSingleThreadExecutor();
		LiveReloadConfiguration(DevToolsProperties properties, ClientHttpRequestFactory clientHttpRequestFactory,
				@Value('${remoteUrl}') String remoteUrl) {
			this.properties = properties;
			this.clientHttpRequestFactory = clientHttpRequestFactory;
			this.remoteUrl = remoteUrl;
		}
		@Bean
		@RestartScope
		@ConditionalOnMissingBean
		LiveReloadServer liveReloadServer() {
			return new LiveReloadServer(this.properties.getLivereload().getPort(),
					Restarter.getInstance().getThreadFactory());
		}
		@Bean
		ApplicationListener<ClassPathChangedEvent> liveReloadTriggeringClassPathChangedEventListener(
				OptionalLiveReloadServer optionalLiveReloadServer) {
			return (event) -> {
				String url = this.remoteUrl + this.properties.getRemote().getContextPath();
				this.executor.execute(
						new DelayedLiveReloadTrigger(optionalLiveReloadServer, this.clientHttpRequestFactory, url));
			};
		}
		@Bean
		OptionalLiveReloadServer optionalLiveReloadServer(ObjectProvider<LiveReloadServer> liveReloadServer) {
			return new OptionalLiveReloadServer(liveReloadServer.getIfAvailable());
		}
		final ExecutorService getExecutor() {
			return this.executor;
		}
	}
	/**
	 * Client configuration for remote update and restarts.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.devtools.remote.restart', name = 'enabled', matchIfMissing = true)
	static class RemoteRestartClientConfiguration {
		private final DevToolsProperties properties;
		RemoteRestartClientConfiguration(DevToolsProperties properties) {
			this.properties = properties;
		}
		@Bean
		ClassPathFileSystemWatcher classPathFileSystemWatcher(FileSystemWatcherFactory fileSystemWatcherFactory,
				ClassPathRestartStrategy classPathRestartStrategy) {
			DefaultRestartInitializer restartInitializer = new DefaultRestartInitializer();
			URL[] urls = restartInitializer.getInitialUrls(Thread.currentThread());
			if (urls == null) {
				urls = new URL[0];
			}
			return new ClassPathFileSystemWatcher(fileSystemWatcherFactory, classPathRestartStrategy, urls);
		}
		@Bean
		FileSystemWatcherFactory getFileSystemWatcherFactory() {
			return this::newFileSystemWatcher;
		}
		private FileSystemWatcher newFileSystemWatcher() {
			Restart restartProperties = this.properties.getRestart();
			FileSystemWatcher watcher = new FileSystemWatcher(true, restartProperties.getPollInterval(),
					restartProperties.getQuietPeriod());
			String triggerFile = restartProperties.getTriggerFile();
			if (StringUtils.hasLength(triggerFile)) {
				watcher.setTriggerFilter(new TriggerFileFilter(triggerFile));
			}
			return watcher;
		}
		@Bean
		ClassPathRestartStrategy classPathRestartStrategy() {
			return new PatternClassPathRestartStrategy(this.properties.getRestart().getAllExclude());
		}
		@Bean
		ClassPathChangeUploader classPathChangeUploader(ClientHttpRequestFactory requestFactory,
				@Value('${remoteUrl}') String remoteUrl) {
			String url = remoteUrl + this.properties.getRemote().getContextPath() + '/restart';
			return new ClassPathChangeUploader(url, requestFactory);
		}
	}
}
/*
package org.springframework.boot.devtools.remote.client;
/**
public class HttpHeaderInterceptor implements ClientHttpRequestInterceptor {
	private final String name;
	private final String value;
	/**
	 * Creates a new {@link HttpHeaderInterceptor} instance.
	 * @param name the header name to populate. Cannot be null or empty.
	 * @param value the header value to populate. Cannot be null or empty.
	 */
	public HttpHeaderInterceptor(String name, String value) {
		Assert.hasLength(name, 'Name must not be empty');
		Assert.hasLength(value, 'Value must not be empty');
		this.name = name;
		this.value = value;
	}
	@Override
	public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)
			throws IOException {
		request.getHeaders().add(this.name, this.value);
		return execution.execute(request, body);
	}
}
/*
/**
package org.springframework.boot.devtools.remote.client;
/*
package org.springframework.boot.devtools.remote.client;
/**
class DelayedLiveReloadTrigger implements Runnable {
	private static final long SHUTDOWN_TIME = 1000;
	private static final long SLEEP_TIME = 500;
	private static final long TIMEOUT = 30000;
	private static final Log logger = LogFactory.getLog(DelayedLiveReloadTrigger.class);
	private final OptionalLiveReloadServer liveReloadServer;
	private final ClientHttpRequestFactory requestFactory;
	private final URI uri;
	private long shutdownTime = SHUTDOWN_TIME;
	private long sleepTime = SLEEP_TIME;
	private long timeout = TIMEOUT;
	DelayedLiveReloadTrigger(OptionalLiveReloadServer liveReloadServer, ClientHttpRequestFactory requestFactory,
			String url) {
		Assert.notNull(liveReloadServer, 'LiveReloadServer must not be null');
		Assert.notNull(requestFactory, 'RequestFactory must not be null');
		Assert.hasLength(url, 'URL must not be empty');
		this.liveReloadServer = liveReloadServer;
		this.requestFactory = requestFactory;
		try {
			this.uri = new URI(url);
		}
		catch (URISyntaxException ex) {
			throw new IllegalArgumentException(ex);
		}
	}
	protected void setTimings(long shutdown, long sleep, long timeout) {
		this.shutdownTime = shutdown;
		this.sleepTime = sleep;
		this.timeout = timeout;
	}
	@Override
	public void run() {
		try {
			Thread.sleep(this.shutdownTime);
			long start = System.currentTimeMillis();
			while (!isUp()) {
				long runTime = System.currentTimeMillis() - start;
				if (runTime > this.timeout) {
					return;
				}
				Thread.sleep(this.sleepTime);
			}
			logger.info('Remote server has changed, triggering LiveReload');
			this.liveReloadServer.triggerReload();
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
	private boolean isUp() {
		try {
			ClientHttpRequest request = createRequest();
			try (ClientHttpResponse response = request.execute()) {
				return response.getStatusCode() == HttpStatus.OK;
			}
		}
		catch (Exception ex) {
			return false;
		}
	}
	private ClientHttpRequest createRequest() throws IOException {
		return this.requestFactory.createRequest(this.uri, HttpMethod.GET);
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@ConditionalOnClass(ConnectionFactory.class)
@Conditional({ OnEnabledDevToolsCondition.class, DevToolsConnectionFactoryCondition.class })
@AutoConfiguration(after = R2dbcAutoConfiguration.class)
public class DevToolsR2dbcAutoConfiguration {
	@Bean
	InMemoryR2dbcDatabaseShutdownExecutor inMemoryR2dbcDatabaseShutdownExecutor(
			ApplicationEventPublisher eventPublisher, ConnectionFactory connectionFactory) {
		return new InMemoryR2dbcDatabaseShutdownExecutor(eventPublisher, connectionFactory);
	}
	final class InMemoryR2dbcDatabaseShutdownExecutor implements DisposableBean {
		private final ApplicationEventPublisher eventPublisher;
		private final ConnectionFactory connectionFactory;
		InMemoryR2dbcDatabaseShutdownExecutor(ApplicationEventPublisher eventPublisher,
				ConnectionFactory connectionFactory) {
			this.eventPublisher = eventPublisher;
			this.connectionFactory = connectionFactory;
		}
		@Override
		public void destroy() throws Exception {
			if (shouldShutdown()) {
				Mono.usingWhen(this.connectionFactory.create(), this::executeShutdown, this::closeConnection,
						this::closeConnection, this::closeConnection)
					.block();
				this.eventPublisher.publishEvent(new R2dbcDatabaseShutdownEvent(this.connectionFactory));
			}
		}
		private boolean shouldShutdown() {
			try {
				return EmbeddedDatabaseConnection.isEmbedded(this.connectionFactory);
			}
			catch (Exception ex) {
				return false;
			}
		}
		private Mono<?> executeShutdown(Connection connection) {
			return Mono.from(connection.createStatement('SHUTDOWN').execute());
		}
		private Publisher<Void> closeConnection(Connection connection) {
			return closeConnection(connection, null);
		}
		private Publisher<Void> closeConnection(Connection connection, Throwable ex) {
			return connection.close();
		}
	}
	static class DevToolsConnectionFactoryCondition extends SpringBootCondition implements ConfigurationCondition {
		@Override
		public ConfigurationPhase getConfigurationPhase() {
			return ConfigurationPhase.REGISTER_BEAN;
		}
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('DevTools ConnectionFactory Condition');
			String[] beanNames = context.getBeanFactory().getBeanNamesForType(ConnectionFactory.class, true, false);
			if (beanNames.length != 1) {
				return ConditionOutcome.noMatch(message.didNotFind('a single ConnectionFactory bean').atAll());
			}
			BeanDefinition beanDefinition = context.getRegistry().getBeanDefinition(beanNames[0]);
			if (beanDefinition instanceof AnnotatedBeanDefinition annotatedBeanDefinition
					&& isAutoConfigured(annotatedBeanDefinition)) {
				return ConditionOutcome.match(message.foundExactly('auto-configured ConnectionFactory'));
			}
			return ConditionOutcome.noMatch(message.didNotFind('an auto-configured ConnectionFactory').atAll());
		}
		private boolean isAutoConfigured(AnnotatedBeanDefinition beanDefinition) {
			MethodMetadata methodMetadata = beanDefinition.getFactoryMethodMetadata();
			return methodMetadata != null && methodMetadata.getDeclaringClassName()
				.startsWith(R2dbcAutoConfiguration.class.getPackage().getName());
		}
	}
	static class R2dbcDatabaseShutdownEvent {
		private final ConnectionFactory connectionFactory;
		R2dbcDatabaseShutdownEvent(ConnectionFactory connectionFactory) {
			this.connectionFactory = connectionFactory;
		}
		ConnectionFactory getConnectionFactory() {
			return this.connectionFactory;
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@ConditionalOnClass(DataSource.class)
@Conditional({ OnEnabledDevToolsCondition.class, DevToolsDataSourceCondition.class })
@AutoConfiguration(after = DataSourceAutoConfiguration.class)
@Import(DatabaseShutdownExecutorEntityManagerFactoryDependsOnPostProcessor.class)
public class DevToolsDataSourceAutoConfiguration {
	@Bean
	NonEmbeddedInMemoryDatabaseShutdownExecutor inMemoryDatabaseShutdownExecutor(DataSource dataSource,
			DataSourceProperties dataSourceProperties) {
		return new NonEmbeddedInMemoryDatabaseShutdownExecutor(dataSource, dataSourceProperties);
	}
	/**
	 * Post processor to ensure that {@link jakarta.persistence.EntityManagerFactory}
	 * beans depend on the {@code inMemoryDatabaseShutdownExecutor} bean.
	 */
	@ConditionalOnClass(LocalContainerEntityManagerFactoryBean.class)
	@ConditionalOnBean(AbstractEntityManagerFactoryBean.class)
	static class DatabaseShutdownExecutorEntityManagerFactoryDependsOnPostProcessor
			extends EntityManagerFactoryDependsOnPostProcessor {
		DatabaseShutdownExecutorEntityManagerFactoryDependsOnPostProcessor() {
			super('inMemoryDatabaseShutdownExecutor');
		}
	}
	static final class NonEmbeddedInMemoryDatabaseShutdownExecutor implements DisposableBean {
		private final DataSource dataSource;
		private final DataSourceProperties dataSourceProperties;
		NonEmbeddedInMemoryDatabaseShutdownExecutor(DataSource dataSource, DataSourceProperties dataSourceProperties) {
			this.dataSource = dataSource;
			this.dataSourceProperties = dataSourceProperties;
		}
		@Override
		public void destroy() throws Exception {
			for (InMemoryDatabase inMemoryDatabase : InMemoryDatabase.values()) {
				if (inMemoryDatabase.matches(this.dataSourceProperties)) {
					inMemoryDatabase.shutdown(this.dataSource);
					return;
				}
			}
		}
		private enum InMemoryDatabase {
			DERBY(null, Set.of('org.apache.derby.jdbc.EmbeddedDriver'), (dataSource) -> {
				String url;
				try (Connection connection = dataSource.getConnection()) {
					url = connection.getMetaData().getURL();
				}
				try {
					new EmbeddedDriver().connect(url + ';drop=true', new Properties()).close();
				}
				catch (SQLException ex) {
					if (!'08006'.equals(ex.getSQLState())) {
						throw ex;
					}
				}
			}),
			H2('jdbc:h2:mem:', Set.of('org.h2.Driver', 'org.h2.jdbcx.JdbcDataSource')),
			HSQLDB('jdbc:hsqldb:mem:', Set.of('org.hsqldb.jdbcDriver', 'org.hsqldb.jdbc.JDBCDriver',
					'org.hsqldb.jdbc.pool.JDBCXADataSource'));
			private final String urlPrefix;
			private final ShutdownHandler shutdownHandler;
			private final Set<String> driverClassNames;
			InMemoryDatabase(String urlPrefix, Set<String> driverClassNames) {
				this(urlPrefix, driverClassNames, (dataSource) -> {
					try (Connection connection = dataSource.getConnection()) {
						try (Statement statement = connection.createStatement()) {
							statement.execute('SHUTDOWN');
						}
					}
				});
			}
			InMemoryDatabase(String urlPrefix, Set<String> driverClassNames, ShutdownHandler shutdownHandler) {
				this.urlPrefix = urlPrefix;
				this.driverClassNames = driverClassNames;
				this.shutdownHandler = shutdownHandler;
			}
			boolean matches(DataSourceProperties properties) {
				String url = properties.getUrl();
				return (url == null || this.urlPrefix == null || url.startsWith(this.urlPrefix))
						&& this.driverClassNames.contains(properties.determineDriverClassName());
			}
			void shutdown(DataSource dataSource) throws SQLException {
				this.shutdownHandler.shutdown(dataSource);
			}
			@FunctionalInterface
			interface ShutdownHandler {
				void shutdown(DataSource dataSource) throws SQLException;
			}
		}
	}
	static class DevToolsDataSourceCondition extends SpringBootCondition implements ConfigurationCondition {
		@Override
		public ConfigurationPhase getConfigurationPhase() {
			return ConfigurationPhase.REGISTER_BEAN;
		}
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('DevTools DataSource Condition');
			String[] dataSourceBeanNames = context.getBeanFactory().getBeanNamesForType(DataSource.class, true, false);
			if (dataSourceBeanNames.length != 1) {
				return ConditionOutcome.noMatch(message.didNotFind('a single DataSource bean').atAll());
			}
			if (context.getBeanFactory().getBeanNamesForType(DataSourceProperties.class, true, false).length != 1) {
				return ConditionOutcome.noMatch(message.didNotFind('a single DataSourceProperties bean').atAll());
			}
			BeanDefinition dataSourceDefinition = context.getRegistry().getBeanDefinition(dataSourceBeanNames[0]);
			if (dataSourceDefinition instanceof AnnotatedBeanDefinition annotatedBeanDefinition
					&& annotatedBeanDefinition.getFactoryMethodMetadata() != null
					&& annotatedBeanDefinition.getFactoryMethodMetadata()
						.getDeclaringClassName()
						.startsWith(DataSourceAutoConfiguration.class.getPackage().getName()
								+ '.DataSourceConfiguration$')) {
				return ConditionOutcome.match(message.foundExactly('auto-configured DataSource'));
			}
			return ConditionOutcome.noMatch(message.didNotFind('an auto-configured DataSource').atAll());
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
public class RemoteDevToolsProperties {
	public static final String DEFAULT_CONTEXT_PATH = '/.~~spring-boot!~';
	public static final String DEFAULT_SECRET_HEADER_NAME = 'X-AUTH-TOKEN';
	/**
	 * Context path used to handle the remote connection.
	 */
	private String contextPath = DEFAULT_CONTEXT_PATH;
	/**
	 * A shared secret required to establish a connection (required to enable remote
	 * support).
	 */
	private String secret;
	/**
	 * HTTP header used to transfer the shared secret.
	 */
	private String secretHeaderName = DEFAULT_SECRET_HEADER_NAME;
	private final Restart restart = new Restart();
	private final Proxy proxy = new Proxy();
	public String getContextPath() {
		return this.contextPath;
	}
	public void setContextPath(String contextPath) {
		this.contextPath = contextPath;
	}
	public String getSecret() {
		return this.secret;
	}
	public void setSecret(String secret) {
		this.secret = secret;
	}
	public String getSecretHeaderName() {
		return this.secretHeaderName;
	}
	public void setSecretHeaderName(String secretHeaderName) {
		this.secretHeaderName = secretHeaderName;
	}
	public Restart getRestart() {
		return this.restart;
	}
	public Proxy getProxy() {
		return this.proxy;
	}
	public static class Restart {
		/**
		 * Whether to enable remote restart.
		 */
		private boolean enabled = true;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
	public static class Proxy {
		/**
		 * The host of the proxy to use to connect to the remote application.
		 */
		private String host;
		/**
		 * The port of the proxy to use to connect to the remote application.
		 */
		private Integer port;
		public String getHost() {
			return this.host;
		}
		public void setHost(String host) {
			this.host = host;
		}
		public Integer getPort() {
			return this.port;
		}
		public void setPort(Integer port) {
			this.port = port;
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@ConfigurationProperties(prefix = 'spring.devtools')
public class DevToolsProperties {
	private final Restart restart = new Restart();
	private final Livereload livereload = new Livereload();
	@NestedConfigurationProperty
	private final RemoteDevToolsProperties remote = new RemoteDevToolsProperties();
	public Restart getRestart() {
		return this.restart;
	}
	public Livereload getLivereload() {
		return this.livereload;
	}
	public RemoteDevToolsProperties getRemote() {
		return this.remote;
	}
	/**
	 * Restart properties.
	 */
	public static class Restart {
		private static final String DEFAULT_RESTART_EXCLUDES = 'META-INF/maven/**,'
				+ 'META-INF/resources/**,resources/**,static/**,public/**,templates/**,'
				+ '**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties';
		/**
		 * Whether to enable automatic restart.
		 */
		private boolean enabled = true;
		/**
		 * Patterns that should be excluded from triggering a full restart.
		 */
		private String exclude = DEFAULT_RESTART_EXCLUDES;
		/**
		 * Additional patterns that should be excluded from triggering a full restart.
		 */
		private String additionalExclude;
		/**
		 * Amount of time to wait between polling for classpath changes.
		 */
		private Duration pollInterval = Duration.ofSeconds(1);
		/**
		 * Amount of quiet time required without any classpath changes before a restart is
		 * triggered.
		 */
		private Duration quietPeriod = Duration.ofMillis(400);
		/**
		 * Name of a specific file that, when changed, triggers the restart check. Must be
		 * a simple name (without any path) of a file that appears on your classpath. If
		 * not specified, any classpath file change triggers the restart.
		 */
		private String triggerFile;
		/**
		 * Additional paths to watch for changes.
		 */
		private List<File> additionalPaths = new ArrayList<>();
		/**
		 * Whether to log the condition evaluation delta upon restart.
		 */
		private boolean logConditionEvaluationDelta = true;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public String[] getAllExclude() {
			List<String> allExclude = new ArrayList<>();
			if (StringUtils.hasText(this.exclude)) {
				allExclude.addAll(StringUtils.commaDelimitedListToSet(this.exclude));
			}
			if (StringUtils.hasText(this.additionalExclude)) {
				allExclude.addAll(StringUtils.commaDelimitedListToSet(this.additionalExclude));
			}
			return StringUtils.toStringArray(allExclude);
		}
		public String getExclude() {
			return this.exclude;
		}
		public void setExclude(String exclude) {
			this.exclude = exclude;
		}
		public String getAdditionalExclude() {
			return this.additionalExclude;
		}
		public void setAdditionalExclude(String additionalExclude) {
			this.additionalExclude = additionalExclude;
		}
		public Duration getPollInterval() {
			return this.pollInterval;
		}
		public void setPollInterval(Duration pollInterval) {
			this.pollInterval = pollInterval;
		}
		public Duration getQuietPeriod() {
			return this.quietPeriod;
		}
		public void setQuietPeriod(Duration quietPeriod) {
			this.quietPeriod = quietPeriod;
		}
		public String getTriggerFile() {
			return this.triggerFile;
		}
		public void setTriggerFile(String triggerFile) {
			this.triggerFile = triggerFile;
		}
		public List<File> getAdditionalPaths() {
			return this.additionalPaths;
		}
		public void setAdditionalPaths(List<File> additionalPaths) {
			this.additionalPaths = additionalPaths;
		}
		public boolean isLogConditionEvaluationDelta() {
			return this.logConditionEvaluationDelta;
		}
		public void setLogConditionEvaluationDelta(boolean logConditionEvaluationDelta) {
			this.logConditionEvaluationDelta = logConditionEvaluationDelta;
		}
	}
	/**
	 * LiveReload properties.
	 */
	public static class Livereload {
		/**
		 * Whether to enable a livereload.com-compatible server.
		 */
		private boolean enabled = true;
		/**
		 * Server port.
		 */
		private int port = 35729;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public int getPort() {
			return this.port;
		}
		public void setPort(int port) {
			this.port = port;
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@ConditionalOnClass({ SecurityFilterChain.class, HttpSecurity.class })
@Configuration(proxyBeanMethods = false)
class RemoteDevtoolsSecurityConfiguration {
	private final String url;
	RemoteDevtoolsSecurityConfiguration(DevToolsProperties devToolsProperties, ServerProperties serverProperties) {
		ServerProperties.Servlet servlet = serverProperties.getServlet();
		String servletContextPath = (servlet.getContextPath() != null) ? servlet.getContextPath() : '';
		this.url = servletContextPath + devToolsProperties.getRemote().getContextPath() + '/restart';
	}
	@Bean
	@Order(SecurityProperties.BASIC_AUTH_ORDER - 1)
	SecurityFilterChain devtoolsSecurityFilterChain(HttpSecurity http) throws Exception {
		http.securityMatcher(new AntPathRequestMatcher(this.url));
		http.authorizeHttpRequests((requests) -> requests.anyRequest().anonymous());
		http.csrf(CsrfConfigurer::disable);
		return http.build();
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@AutoConfiguration
@ConditionalOnInitializedRestarter
@EnableConfigurationProperties(DevToolsProperties.class)
public class LocalDevToolsAutoConfiguration {
	/**
	 * Local LiveReload configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.devtools.livereload', name = 'enabled', matchIfMissing = true)
	static class LiveReloadConfiguration {
		@Bean
		@RestartScope
		@ConditionalOnMissingBean
		LiveReloadServer liveReloadServer(DevToolsProperties properties) {
			return new LiveReloadServer(properties.getLivereload().getPort(),
					Restarter.getInstance().getThreadFactory());
		}
		@Bean
		OptionalLiveReloadServer optionalLiveReloadServer(LiveReloadServer liveReloadServer) {
			return new OptionalLiveReloadServer(liveReloadServer);
		}
		@Bean
		LiveReloadServerEventListener liveReloadServerEventListener(OptionalLiveReloadServer liveReloadServer) {
			return new LiveReloadServerEventListener(liveReloadServer);
		}
	}
	/**
	 * Local Restart Configuration.
	 */
	@Lazy(false)
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.devtools.restart', name = 'enabled', matchIfMissing = true)
	static class RestartConfiguration {
		private final DevToolsProperties properties;
		RestartConfiguration(DevToolsProperties properties) {
			this.properties = properties;
		}
		@Bean
		RestartingClassPathChangeChangedEventListener restartingClassPathChangedEventListener(
				FileSystemWatcherFactory fileSystemWatcherFactory) {
			return new RestartingClassPathChangeChangedEventListener(fileSystemWatcherFactory);
		}
		@Bean
		@ConditionalOnMissingBean
		ClassPathFileSystemWatcher classPathFileSystemWatcher(FileSystemWatcherFactory fileSystemWatcherFactory,
				ClassPathRestartStrategy classPathRestartStrategy) {
			URL[] urls = Restarter.getInstance().getInitialUrls();
			ClassPathFileSystemWatcher watcher = new ClassPathFileSystemWatcher(fileSystemWatcherFactory,
					classPathRestartStrategy, urls);
			watcher.setStopWatcherOnRestart(true);
			return watcher;
		}
		@Bean
		@ConditionalOnMissingBean
		ClassPathRestartStrategy classPathRestartStrategy() {
			return new PatternClassPathRestartStrategy(this.properties.getRestart().getAllExclude());
		}
		@Bean
		FileSystemWatcherFactory fileSystemWatcherFactory() {
			return this::newFileSystemWatcher;
		}
		@Bean
		@ConditionalOnProperty(prefix = 'spring.devtools.restart', name = 'log-condition-evaluation-delta',
				matchIfMissing = true)
		ConditionEvaluationDeltaLoggingListener conditionEvaluationDeltaLoggingListener() {
			return new ConditionEvaluationDeltaLoggingListener();
		}
		private FileSystemWatcher newFileSystemWatcher() {
			Restart restartProperties = this.properties.getRestart();
			FileSystemWatcher watcher = new FileSystemWatcher(true, restartProperties.getPollInterval(),
					restartProperties.getQuietPeriod(), SnapshotStateRepository.STATIC);
			String triggerFile = restartProperties.getTriggerFile();
			if (StringUtils.hasLength(triggerFile)) {
				watcher.setTriggerFilter(new TriggerFileFilter(triggerFile));
			}
			List<File> additionalPaths = restartProperties.getAdditionalPaths();
			for (File path : additionalPaths) {
				watcher.addSourceDirectory(path.getAbsoluteFile());
			}
			return watcher;
		}
	}
	static class LiveReloadServerEventListener implements GenericApplicationListener {
		private final OptionalLiveReloadServer liveReloadServer;
		LiveReloadServerEventListener(OptionalLiveReloadServer liveReloadServer) {
			this.liveReloadServer = liveReloadServer;
		}
		@Override
		public boolean supportsEventType(ResolvableType eventType) {
			Class<?> type = eventType.getRawClass();
			if (type == null) {
				return false;
			}
			return ContextRefreshedEvent.class.isAssignableFrom(type)
					|| ClassPathChangedEvent.class.isAssignableFrom(type);
		}
		@Override
		public boolean supportsSourceType(Class<?> sourceType) {
			return true;
		}
		@Override
		public void onApplicationEvent(ApplicationEvent event) {
			if (event instanceof ContextRefreshedEvent || (event instanceof ClassPathChangedEvent classPathChangedEvent
					&& !classPathChangedEvent.isRestartRequired())) {
				this.liveReloadServer.triggerReload();
			}
		}
		@Override
		public int getOrder() {
			return 0;
		}
	}
	static class RestartingClassPathChangeChangedEventListener implements ApplicationListener<ClassPathChangedEvent> {
		private static final Log logger = LogFactory.getLog(RestartingClassPathChangeChangedEventListener.class);
		private final FileSystemWatcherFactory fileSystemWatcherFactory;
		RestartingClassPathChangeChangedEventListener(FileSystemWatcherFactory fileSystemWatcherFactory) {
			this.fileSystemWatcherFactory = fileSystemWatcherFactory;
		}
		@Override
		public void onApplicationEvent(ClassPathChangedEvent event) {
			if (event.isRestartRequired()) {
				logger.info(LogMessage.format('Restarting due to %s', event.overview()));
				logger.debug(LogMessage.format('Change set: %s', event.getChangeSet()));
				Restarter.getInstance().restart(new FileWatchingFailureHandler(this.fileSystemWatcherFactory));
			}
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class FileWatchingFailureHandler implements FailureHandler {
	private final FileSystemWatcherFactory fileSystemWatcherFactory;
	FileWatchingFailureHandler(FileSystemWatcherFactory fileSystemWatcherFactory) {
		this.fileSystemWatcherFactory = fileSystemWatcherFactory;
	}
	@Override
	public Outcome handle(Throwable failure) {
		CountDownLatch latch = new CountDownLatch(1);
		FileSystemWatcher watcher = this.fileSystemWatcherFactory.getFileSystemWatcher();
		watcher.addSourceDirectories(new ClassPathDirectories(Restarter.getInstance().getInitialUrls()));
		watcher.addListener(new Listener(latch));
		watcher.start();
		try {
			latch.await();
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
		return Outcome.RETRY;
	}
	private static class Listener implements FileChangeListener {
		private final CountDownLatch latch;
		Listener(CountDownLatch latch) {
			this.latch = latch;
		}
		@Override
		public void onChange(Set<ChangedFiles> changeSet) {
			this.latch.countDown();
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
public class OnEnabledDevToolsCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('Devtools');
		boolean shouldEnable = DevToolsEnablementDeducer.shouldEnable(Thread.currentThread());
		if (!shouldEnable) {
			return ConditionOutcome.noMatch(message.because('devtools is disabled for current context.'));
		}
		return ConditionOutcome.match(message.because('devtools enabled.'));
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
class ConditionEvaluationDeltaLoggingListener
		implements ApplicationListener<ApplicationReadyEvent>, ApplicationContextAware {
	private static final ConcurrentHashMap<String, ConditionEvaluationReport> previousReports = new ConcurrentHashMap<>();
	private static final Log logger = LogFactory.getLog(ConditionEvaluationDeltaLoggingListener.class);
	private volatile ApplicationContext context;
	@Override
	public void onApplicationEvent(ApplicationReadyEvent event) {
		if (!event.getApplicationContext().equals(this.context)) {
			return;
		}
		ConditionEvaluationReport report = event.getApplicationContext().getBean(ConditionEvaluationReport.class);
		ConditionEvaluationReport previousReport = previousReports.get(event.getApplicationContext().getId());
		if (previousReport != null) {
			ConditionEvaluationReport delta = report.getDelta(previousReport);
			if (!delta.getConditionAndOutcomesBySource().isEmpty() || !delta.getExclusions().isEmpty()
					|| !delta.getUnconditionalClasses().isEmpty()) {
				if (logger.isInfoEnabled()) {
					logger.info('Condition evaluation delta:'
							+ new ConditionEvaluationReportMessage(delta, 'CONDITION EVALUATION DELTA'));
				}
			}
			else {
				logger.info('Condition evaluation unchanged');
			}
		}
		previousReports.put(event.getApplicationContext().getId(), report);
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) {
		this.context = applicationContext;
	}
}
/*
/**
package org.springframework.boot.devtools.autoconfigure;
/*
package org.springframework.boot.devtools.autoconfigure;
/**
public class TriggerFileFilter implements FileFilter {
	private final String name;
	public TriggerFileFilter(String name) {
		Assert.notNull(name, 'Name must not be null');
		this.name = name;
	}
	@Override
	public boolean accept(File file) {
		return file.getName().equals(this.name);
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
@AutoConfiguration(after = SecurityAutoConfiguration.class)
@Conditional(OnEnabledDevToolsCondition.class)
@ConditionalOnProperty(prefix = 'spring.devtools.remote', name = 'secret')
@ConditionalOnClass({ Filter.class, ServerHttpRequest.class })
@Import(RemoteDevtoolsSecurityConfiguration.class)
@EnableConfigurationProperties({ ServerProperties.class, DevToolsProperties.class })
public class RemoteDevToolsAutoConfiguration {
	private static final Log logger = LogFactory.getLog(RemoteDevToolsAutoConfiguration.class);
	private final DevToolsProperties properties;
	public RemoteDevToolsAutoConfiguration(DevToolsProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public AccessManager remoteDevToolsAccessManager() {
		RemoteDevToolsProperties remoteProperties = this.properties.getRemote();
		return new HttpHeaderAccessManager(remoteProperties.getSecretHeaderName(), remoteProperties.getSecret());
	}
	@Bean
	public HandlerMapper remoteDevToolsHealthCheckHandlerMapper(ServerProperties serverProperties) {
		Handler handler = new HttpStatusHandler();
		Servlet servlet = serverProperties.getServlet();
		String servletContextPath = (servlet.getContextPath() != null) ? servlet.getContextPath() : '';
		return new UrlHandlerMapper(servletContextPath + this.properties.getRemote().getContextPath(), handler);
	}
	@Bean
	@ConditionalOnMissingBean
	public DispatcherFilter remoteDevToolsDispatcherFilter(AccessManager accessManager,
			Collection<HandlerMapper> mappers) {
		Dispatcher dispatcher = new Dispatcher(accessManager, mappers);
		return new DispatcherFilter(dispatcher);
	}
	/**
	 * Configuration for remote update and restarts.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.devtools.remote.restart', name = 'enabled', matchIfMissing = true)
	static class RemoteRestartConfiguration {
		@Bean
		@ConditionalOnMissingBean
		SourceDirectoryUrlFilter remoteRestartSourceDirectoryUrlFilter() {
			return new DefaultSourceDirectoryUrlFilter();
		}
		@Bean
		@ConditionalOnMissingBean
		HttpRestartServer remoteRestartHttpRestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter) {
			return new HttpRestartServer(sourceDirectoryUrlFilter);
		}
		@Bean
		@ConditionalOnMissingBean(name = 'remoteRestartHandlerMapper')
		UrlHandlerMapper remoteRestartHandlerMapper(HttpRestartServer server, ServerProperties serverProperties,
				DevToolsProperties properties) {
			Servlet servlet = serverProperties.getServlet();
			RemoteDevToolsProperties remote = properties.getRemote();
			String servletContextPath = (servlet.getContextPath() != null) ? servlet.getContextPath() : '';
			String url = servletContextPath + remote.getContextPath() + '/restart';
			logger.warn(LogMessage.format('Listening for remote restart updates on %s', url));
			Handler handler = new HttpRestartServerHandler(server);
			return new UrlHandlerMapper(url, handler);
		}
	}
}
/*
package org.springframework.boot.devtools.autoconfigure;
/**
public class OptionalLiveReloadServer implements InitializingBean {
	private static final Log logger = LogFactory.getLog(OptionalLiveReloadServer.class);
	private LiveReloadServer server;
	/**
	 * Create a new {@link OptionalLiveReloadServer} instance.
	 * @param server the server to manage or {@code null}
	 */
	public OptionalLiveReloadServer(LiveReloadServer server) {
		this.server = server;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		startServer();
	}
	void startServer() {
		if (this.server != null) {
			try {
				int port = this.server.getPort();
				if (!this.server.isStarted()) {
					port = this.server.start();
				}
				logger.info(LogMessage.format('LiveReload server is running on port %s', port));
			}
			catch (Exception ex) {
				logger.warn('Unable to start LiveReload server');
				logger.debug('Live reload start error', ex);
				this.server = null;
			}
		}
	}
	/**
	 * Trigger LiveReload if the server is up and running.
	 */
	public void triggerReload() {
		if (this.server != null) {
			this.server.triggerReload();
		}
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
public class ClassPathDirectories implements Iterable<File> {
	private static final Log logger = LogFactory.getLog(ClassPathDirectories.class);
	private final List<File> directories = new ArrayList<>();
	public ClassPathDirectories(URL[] urls) {
		if (urls != null) {
			addUrls(urls);
		}
	}
	private void addUrls(URL[] urls) {
		for (URL url : urls) {
			addUrl(url);
		}
	}
	private void addUrl(URL url) {
		if (url.getProtocol().equals('file') && url.getPath().endsWith('/')) {
			try {
				this.directories.add(ResourceUtils.getFile(url));
			}
			catch (Exception ex) {
				logger.warn(LogMessage.format('Unable to get classpath URL %s', url));
				logger.trace(LogMessage.format('Unable to get classpath URL %s', url), ex);
			}
		}
	}
	@Override
	public Iterator<File> iterator() {
		return Collections.unmodifiableList(this.directories).iterator();
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
@FunctionalInterface
public interface ClassPathRestartStrategy {
	/**
	 * Return true if a full restart is required.
	 * @param file the changed file
	 * @return {@code true} if a full restart is required
	 */
	boolean isRestartRequired(ChangedFile file);
}
/*
package org.springframework.boot.devtools.classpath;
/**
class ClassPathFileChangeListener implements FileChangeListener {
	private final ApplicationEventPublisher eventPublisher;
	private final ClassPathRestartStrategy restartStrategy;
	private final FileSystemWatcher fileSystemWatcherToStop;
	/**
	 * Create a new {@link ClassPathFileChangeListener} instance.
	 * @param eventPublisher the event publisher used send events
	 * @param restartStrategy the restart strategy to use
	 * @param fileSystemWatcherToStop the file system watcher to stop on a restart (or
	 * {@code null})
	 */
	ClassPathFileChangeListener(ApplicationEventPublisher eventPublisher, ClassPathRestartStrategy restartStrategy,
			FileSystemWatcher fileSystemWatcherToStop) {
		Assert.notNull(eventPublisher, 'EventPublisher must not be null');
		Assert.notNull(restartStrategy, 'RestartStrategy must not be null');
		this.eventPublisher = eventPublisher;
		this.restartStrategy = restartStrategy;
		this.fileSystemWatcherToStop = fileSystemWatcherToStop;
	}
	@Override
	public void onChange(Set<ChangedFiles> changeSet) {
		boolean restart = isRestartRequired(changeSet);
		publishEvent(new ClassPathChangedEvent(this, changeSet, restart));
	}
	private void publishEvent(ClassPathChangedEvent event) {
		this.eventPublisher.publishEvent(event);
		if (event.isRestartRequired() && this.fileSystemWatcherToStop != null) {
			this.fileSystemWatcherToStop.stop();
		}
	}
	private boolean isRestartRequired(Set<ChangedFiles> changeSet) {
		if (AgentReloader.isActive()) {
			return false;
		}
		for (ChangedFiles changedFiles : changeSet) {
			for (ChangedFile changedFile : changedFiles) {
				if (this.restartStrategy.isRestartRequired(changedFile)) {
					return true;
				}
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
public class PatternClassPathRestartStrategy implements ClassPathRestartStrategy {
	private final AntPathMatcher matcher = new AntPathMatcher();
	private final String[] excludePatterns;
	public PatternClassPathRestartStrategy(String[] excludePatterns) {
		this.excludePatterns = excludePatterns;
	}
	public PatternClassPathRestartStrategy(String excludePatterns) {
		this(StringUtils.commaDelimitedListToStringArray(excludePatterns));
	}
	@Override
	public boolean isRestartRequired(ChangedFile file) {
		for (String pattern : this.excludePatterns) {
			if (this.matcher.match(pattern, file.getRelativeName())) {
				return false;
			}
		}
		return true;
	}
}
/*
/**
package org.springframework.boot.devtools.classpath;
/*
package org.springframework.boot.devtools.classpath;
/**
public class ClassPathChangedEvent extends ApplicationEvent {
	private final Set<ChangedFiles> changeSet;
	private final boolean restartRequired;
	/**
	 * Create a new {@link ClassPathChangedEvent}.
	 * @param source the source of the event
	 * @param changeSet the changed files
	 * @param restartRequired if a restart is required due to the change
	 */
	public ClassPathChangedEvent(Object source, Set<ChangedFiles> changeSet, boolean restartRequired) {
		super(source);
		Assert.notNull(changeSet, 'ChangeSet must not be null');
		this.changeSet = changeSet;
		this.restartRequired = restartRequired;
	}
	/**
	 * Return details of the files that changed.
	 * @return the changed files
	 */
	public Set<ChangedFiles> getChangeSet() {
		return this.changeSet;
	}
	/**
	 * Return if an application restart is required due to the change.
	 * @return if an application restart is required
	 */
	public boolean isRestartRequired() {
		return this.restartRequired;
	}
	@Override
	public String toString() {
		return new ToStringCreator(this).append('changeSet', this.changeSet)
			.append('restartRequired', this.restartRequired)
			.toString();
	}
	/**
	 * Return an overview of the changes that triggered this event.
	 * @return an overview of the changes
	 * @since 2.6.11
	 */
	public String overview() {
		int added = 0;
		int deleted = 0;
		int modified = 0;
		for (ChangedFiles changedFiles : this.changeSet) {
			for (ChangedFile changedFile : changedFiles) {
				Type type = changedFile.getType();
				if (type == Type.ADD) {
					added++;
				}
				else if (type == Type.DELETE) {
					deleted++;
				}
				else if (type == Type.MODIFY) {
					modified++;
				}
			}
		}
		int size = added + deleted + modified;
		return String.format('%s (%s, %s, %s)', quantityOfUnit(size, 'class path change'),
				quantityOfUnit(added, 'addition'), quantityOfUnit(deleted, 'deletion'),
				quantityOfUnit(modified, 'modification'));
	}
	private String quantityOfUnit(int quantity, String unit) {
		return quantity + ' ' + ((quantity != 1) ? unit + 's' : unit);
	}
}
/*
package org.springframework.boot.devtools.classpath;
/**
public class ClassPathFileSystemWatcher implements InitializingBean, DisposableBean, ApplicationContextAware {
	private final FileSystemWatcher fileSystemWatcher;
	private final ClassPathRestartStrategy restartStrategy;
	private ApplicationContext applicationContext;
	private boolean stopWatcherOnRestart;
	/**
	 * Create a new {@link ClassPathFileSystemWatcher} instance.
	 * @param fileSystemWatcherFactory a factory to create the underlying
	 * {@link FileSystemWatcher} used to monitor the local file system
	 * @param restartStrategy the classpath restart strategy
	 * @param urls the URLs to watch
	 */
	public ClassPathFileSystemWatcher(FileSystemWatcherFactory fileSystemWatcherFactory,
			ClassPathRestartStrategy restartStrategy, URL[] urls) {
		Assert.notNull(fileSystemWatcherFactory, 'FileSystemWatcherFactory must not be null');
		Assert.notNull(urls, 'Urls must not be null');
		this.fileSystemWatcher = fileSystemWatcherFactory.getFileSystemWatcher();
		this.restartStrategy = restartStrategy;
		this.fileSystemWatcher.addSourceDirectories(new ClassPathDirectories(urls));
	}
	/**
	 * Set if the {@link FileSystemWatcher} should be stopped when a full restart occurs.
	 * @param stopWatcherOnRestart if the watcher should be stopped when a restart occurs
	 */
	public void setStopWatcherOnRestart(boolean stopWatcherOnRestart) {
		this.stopWatcherOnRestart = stopWatcherOnRestart;
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		if (this.restartStrategy != null) {
			FileSystemWatcher watcherToStop = null;
			if (this.stopWatcherOnRestart) {
				watcherToStop = this.fileSystemWatcher;
			}
			this.fileSystemWatcher.addListener(
					new ClassPathFileChangeListener(this.applicationContext, this.restartStrategy, watcherToStop));
		}
		this.fileSystemWatcher.start();
	}
	@Override
	public void destroy() throws Exception {
		this.fileSystemWatcher.stop();
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
class ConnectionInputStream extends FilterInputStream {
	private static final String HEADER_END = '\r\n\r\n';
	private static final int BUFFER_SIZE = 4096;
	ConnectionInputStream(InputStream in) {
		super(in);
	}
	/**
	 * Read the HTTP header from the {@link InputStream}. Note: This method doesn"t expect
	 * any HTTP content after the header since the initial request is usually just a
	 * WebSocket upgrade.
	 * @return the HTTP header
	 * @throws IOException in case of I/O errors
	 */
	String readHeader() throws IOException {
		byte[] buffer = new byte[BUFFER_SIZE];
		StringBuilder content = new StringBuilder(BUFFER_SIZE);
		while (content.indexOf(HEADER_END) == -1) {
			int amountRead = checkedRead(buffer, 0, BUFFER_SIZE);
			content.append(new String(buffer, 0, amountRead));
		}
		return content.substring(0, content.indexOf(HEADER_END));
	}
	/**
	 * Repeatedly read the underlying {@link InputStream} until the requested number of
	 * bytes have been loaded.
	 * @param buffer the destination buffer
	 * @param offset the buffer offset
	 * @param length the amount of data to read
	 * @throws IOException in case of I/O errors
	 */
	void readFully(byte[] buffer, int offset, int length) throws IOException {
		while (length > 0) {
			int amountRead = checkedRead(buffer, offset, length);
			offset += amountRead;
			length -= amountRead;
		}
	}
	/**
	 * Read a single byte from the stream (checking that the end of the stream hasn"t been
	 * reached).
	 * @return the content
	 * @throws IOException in case of I/O errors
	 */
	int checkedRead() throws IOException {
		int b = read();
		if (b == -1) {
			throw new IOException('End of stream');
		}
		return (b & 0xff);
	}
	/**
	 * Read a number of bytes from the stream (checking that the end of the stream hasn"t
	 * been reached).
	 * @param buffer the destination buffer
	 * @param offset the buffer offset
	 * @param length the length to read
	 * @return the amount of data read
	 * @throws IOException in case of I/O errors
	 */
	int checkedRead(byte[] buffer, int offset, int length) throws IOException {
		int amountRead = read(buffer, offset, length);
		if (amountRead == -1) {
			throw new IOException('End of stream');
		}
		return amountRead;
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
class ConnectionOutputStream extends FilterOutputStream {
	ConnectionOutputStream(OutputStream out) {
		super(out);
	}
	@Override
	public void write(byte[] b, int off, int len) throws IOException {
		this.out.write(b, off, len);
	}
	void writeHttp(InputStream content, String contentType) throws IOException {
		byte[] bytes = FileCopyUtils.copyToByteArray(content);
		writeHeaders('HTTP/1.1 200 OK', 'Content-Type: ' + contentType, 'Content-Length: ' + bytes.length,
				'Connection: close');
		write(bytes);
		flush();
	}
	void writeHeaders(String... headers) throws IOException {
		StringBuilder response = new StringBuilder();
		for (String header : headers) {
			response.append(header).append('\r\n');
		}
		response.append('\r\n');
		write(response.toString().getBytes());
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
public class LiveReloadServer {
	/**
	 * The default live reload server port.
	 */
	public static final int DEFAULT_PORT = 35729;
	private static final Log logger = LogFactory.getLog(LiveReloadServer.class);
	private static final int READ_TIMEOUT = (int) TimeUnit.SECONDS.toMillis(4);
	private final ExecutorService executor = Executors.newCachedThreadPool(new WorkerThreadFactory());
	private final List<Connection> connections = new ArrayList<>();
	private final Object monitor = new Object();
	private final int port;
	private final ThreadFactory threadFactory;
	private ServerSocket serverSocket;
	private Thread listenThread;
	/**
	 * Create a new {@link LiveReloadServer} listening on the default port.
	 */
	public LiveReloadServer() {
		this(DEFAULT_PORT);
	}
	/**
	 * Create a new {@link LiveReloadServer} listening on the default port with a specific
	 * {@link ThreadFactory}.
	 * @param threadFactory the thread factory
	 */
	public LiveReloadServer(ThreadFactory threadFactory) {
		this(DEFAULT_PORT, threadFactory);
	}
	/**
	 * Create a new {@link LiveReloadServer} listening on the specified port.
	 * @param port the listen port
	 */
	public LiveReloadServer(int port) {
		this(port, Thread::new);
	}
	/**
	 * Create a new {@link LiveReloadServer} listening on the specified port with a
	 * specific {@link ThreadFactory}.
	 * @param port the listen port
	 * @param threadFactory the thread factory
	 */
	public LiveReloadServer(int port, ThreadFactory threadFactory) {
		this.port = port;
		this.threadFactory = threadFactory;
	}
	/**
	 * Start the livereload server and accept incoming connections.
	 * @return the port on which the server is listening
	 * @throws IOException in case of I/O errors
	 */
	public int start() throws IOException {
		synchronized (this.monitor) {
			Assert.state(!isStarted(), 'Server already started');
			logger.debug(LogMessage.format('Starting live reload server on port %s', this.port));
			this.serverSocket = new ServerSocket(this.port);
			int localPort = this.serverSocket.getLocalPort();
			this.listenThread = this.threadFactory.newThread(this::acceptConnections);
			this.listenThread.setDaemon(true);
			this.listenThread.setName('Live Reload Server');
			this.listenThread.start();
			return localPort;
		}
	}
	/**
	 * Return if the server has been started.
	 * @return {@code true} if the server is running
	 */
	public boolean isStarted() {
		synchronized (this.monitor) {
			return this.listenThread != null;
		}
	}
	/**
	 * Return the port that the server is listening on.
	 * @return the server port
	 */
	public int getPort() {
		return this.port;
	}
	private void acceptConnections() {
		do {
			try {
				Socket socket = this.serverSocket.accept();
				socket.setSoTimeout(READ_TIMEOUT);
				this.executor.execute(new ConnectionHandler(socket));
			}
			catch (SocketTimeoutException ex) {
				// Ignore
			}
			catch (Exception ex) {
				if (logger.isDebugEnabled()) {
					logger.debug('LiveReload server error', ex);
				}
			}
		}
		while (!this.serverSocket.isClosed());
	}
	/**
	 * Gracefully stop the livereload server.
	 * @throws IOException in case of I/O errors
	 */
	public void stop() throws IOException {
		synchronized (this.monitor) {
			if (this.listenThread != null) {
				closeAllConnections();
				try {
					this.executor.shutdown();
					this.executor.awaitTermination(1, TimeUnit.MINUTES);
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
				this.serverSocket.close();
				try {
					this.listenThread.join();
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
				this.listenThread = null;
				this.serverSocket = null;
			}
		}
	}
	private void closeAllConnections() throws IOException {
		synchronized (this.connections) {
			for (Connection connection : this.connections) {
				connection.close();
			}
		}
	}
	/**
	 * Trigger livereload of all connected clients.
	 */
	public void triggerReload() {
		synchronized (this.monitor) {
			synchronized (this.connections) {
				for (Connection connection : this.connections) {
					try {
						connection.triggerReload();
					}
					catch (Exception ex) {
						logger.debug('Unable to send reload message', ex);
					}
				}
			}
		}
	}
	private void addConnection(Connection connection) {
		synchronized (this.connections) {
			this.connections.add(connection);
		}
	}
	private void removeConnection(Connection connection) {
		synchronized (this.connections) {
			this.connections.remove(connection);
		}
	}
	/**
	 * Factory method used to create the {@link Connection}.
	 * @param socket the source socket
	 * @param inputStream the socket input stream
	 * @param outputStream the socket output stream
	 * @return a connection
	 * @throws IOException in case of I/O errors
	 */
	protected Connection createConnection(Socket socket, InputStream inputStream, OutputStream outputStream)
			throws IOException {
		return new Connection(socket, inputStream, outputStream);
	}
	/**
	 * {@link Runnable} to handle a single connection.
	 *
	 * @see Connection
	 */
	private class ConnectionHandler implements Runnable {
		private final Socket socket;
		private final InputStream inputStream;
		ConnectionHandler(Socket socket) throws IOException {
			this.socket = socket;
			this.inputStream = socket.getInputStream();
		}
		@Override
		public void run() {
			try {
				handle();
			}
			catch (ConnectionClosedException ex) {
				logger.debug('LiveReload connection closed');
			}
			catch (Exception ex) {
				if (logger.isDebugEnabled()) {
					logger.debug('LiveReload error', ex);
				}
			}
		}
		private void handle() throws Exception {
			try {
				try (OutputStream outputStream = this.socket.getOutputStream()) {
					Connection connection = createConnection(this.socket, this.inputStream, outputStream);
					runConnection(connection);
				}
				finally {
					this.inputStream.close();
				}
			}
			finally {
				this.socket.close();
			}
		}
		private void runConnection(Connection connection) throws Exception {
			try {
				addConnection(connection);
				connection.run();
			}
			finally {
				removeConnection(connection);
			}
		}
	}
	/**
	 * {@link ThreadFactory} to create the worker threads.
	 */
	private static final class WorkerThreadFactory implements ThreadFactory {
		private final AtomicInteger threadNumber = new AtomicInteger(1);
		@Override
		public Thread newThread(Runnable r) {
			Thread thread = new Thread(r);
			thread.setDaemon(true);
			thread.setName('Live Reload #' + this.threadNumber.getAndIncrement());
			return thread;
		}
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
class ConnectionClosedException extends IOException {
	ConnectionClosedException() {
		super('Connection closed');
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
class Frame {
	private static final byte[] NO_BYTES = new byte[0];
	private final Type type;
	private final byte[] payload;
	/**
	 * Create a new {@link Type#TEXT text} {@link Frame} instance with the specified
	 * payload.
	 * @param payload the text payload
	 */
	Frame(String payload) {
		Assert.notNull(payload, 'Payload must not be null');
		this.type = Type.TEXT;
		this.payload = payload.getBytes();
	}
	Frame(Type type) {
		Assert.notNull(type, 'Type must not be null');
		this.type = type;
		this.payload = NO_BYTES;
	}
	Frame(Type type, byte[] payload) {
		this.type = type;
		this.payload = payload;
	}
	Type getType() {
		return this.type;
	}
	byte[] getPayload() {
		return this.payload;
	}
	@Override
	public String toString() {
		return new String(this.payload);
	}
	void write(OutputStream outputStream) throws IOException {
		outputStream.write(0x80 | this.type.code);
		if (this.payload.length < 126) {
			outputStream.write(this.payload.length & 0x7F);
		}
		else {
			outputStream.write(0x7E);
			outputStream.write(this.payload.length >> 8 & 0xFF);
			outputStream.write(this.payload.length & 0xFF);
		}
		outputStream.write(this.payload);
		outputStream.flush();
	}
	static Frame read(ConnectionInputStream inputStream) throws IOException {
		int firstByte = inputStream.checkedRead();
		Assert.state((firstByte & 0x80) != 0, 'Fragmented frames are not supported');
		int maskAndLength = inputStream.checkedRead();
		boolean hasMask = (maskAndLength & 0x80) != 0;
		int length = (maskAndLength & 0x7F);
		Assert.state(length != 127, 'Large frames are not supported');
		if (length == 126) {
			length = ((inputStream.checkedRead()) << 8 | inputStream.checkedRead());
		}
		byte[] mask = new byte[4];
		if (hasMask) {
			inputStream.readFully(mask, 0, mask.length);
		}
		byte[] payload = new byte[length];
		inputStream.readFully(payload, 0, length);
		if (hasMask) {
			for (int i = 0; i < payload.length; i++) {
				payload[i] ^= mask[i % 4];
			}
		}
		return new Frame(Type.forCode(firstByte & 0x0F), payload);
	}
	/**
	 * Frame types.
	 */
	enum Type {
		/**
		 * Continuation frame.
		 */
		CONTINUATION(0x00),
		/**
		 * Text frame.
		 */
		TEXT(0x01),
		/**
		 * Binary frame.
		 */
		BINARY(0x02),
		/**
		 * Close frame.
		 */
		CLOSE(0x08),
		/**
		 * Ping frame.
		 */
		PING(0x09),
		/**
		 * Pong frame.
		 */
		PONG(0x0A);
		private final int code;
		Type(int code) {
			this.code = code;
		}
		static Type forCode(int code) {
			for (Type type : values()) {
				if (type.code == code) {
					return type;
				}
			}
			throw new IllegalStateException('Unknown code ' + code);
		}
	}
}
/*
package org.springframework.boot.devtools.livereload;
/**
class Connection {
	private static final Log logger = LogFactory.getLog(Connection.class);
	private static final Pattern WEBSOCKET_KEY_PATTERN = Pattern.compile('^sec-websocket-key:(.*)$',
			Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);
	public static final String WEBSOCKET_GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
	private final Socket socket;
	private final ConnectionInputStream inputStream;
	private final ConnectionOutputStream outputStream;
	private final String header;
	private volatile boolean webSocket;
	private volatile boolean running = true;
	/**
	 * Create a new {@link Connection} instance.
	 * @param socket the source socket
	 * @param inputStream the socket input stream
	 * @param outputStream the socket output stream
	 * @throws IOException in case of I/O errors
	 */
	Connection(Socket socket, InputStream inputStream, OutputStream outputStream) throws IOException {
		this.socket = socket;
		this.inputStream = new ConnectionInputStream(inputStream);
		this.outputStream = new ConnectionOutputStream(outputStream);
		String header = this.inputStream.readHeader();
		logger.debug(LogMessage.format('Established livereload connection [%s]', header));
		this.header = header;
	}
	/**
	 * Run the connection.
	 * @throws Exception in case of errors
	 */
	void run() throws Exception {
		String lowerCaseHeader = this.header.toLowerCase(Locale.ROOT);
		if (lowerCaseHeader.contains('upgrade: websocket') && lowerCaseHeader.contains('sec-websocket-version: 13')) {
			runWebSocket();
		}
		if (lowerCaseHeader.contains('get /livereload.js')) {
			this.outputStream.writeHttp(getClass().getResourceAsStream('livereload.js'), 'text/javascript');
		}
	}
	private void runWebSocket() throws Exception {
		this.webSocket = true;
		String accept = getWebsocketAcceptResponse();
		this.outputStream.writeHeaders('HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade',
				'Sec-WebSocket-Accept: ' + accept);
		new Frame('{\'command\':\'hello\',\'protocols\':[\'http://livereload.com/protocols/official-7\'],'
				+ '\'serverName\':\'spring-boot\'}')
			.write(this.outputStream);
		while (this.running) {
			readWebSocketFrame();
		}
	}
	private void readWebSocketFrame() throws IOException {
		try {
			Frame frame = Frame.read(this.inputStream);
			if (frame.getType() == Frame.Type.PING) {
				writeWebSocketFrame(new Frame(Frame.Type.PONG));
			}
			else if (frame.getType() == Frame.Type.CLOSE) {
				throw new ConnectionClosedException();
			}
			else if (frame.getType() == Frame.Type.TEXT) {
				logger.debug(LogMessage.format('Received LiveReload text frame %s', frame));
			}
			else {
				throw new IOException('Unexpected Frame Type ' + frame.getType());
			}
		}
		catch (SocketTimeoutException ex) {
			writeWebSocketFrame(new Frame(Frame.Type.PING));
			Frame frame = Frame.read(this.inputStream);
			if (frame.getType() != Frame.Type.PONG) {
				throw new IllegalStateException('No Pong');
			}
		}
	}
	/**
	 * Trigger livereload for the client using this connection.
	 * @throws IOException in case of I/O errors
	 */
	void triggerReload() throws IOException {
		if (this.webSocket) {
			logger.debug('Triggering LiveReload');
			writeWebSocketFrame(new Frame('{\'command\':\'reload\',\'path\':\'/\'}'));
		}
	}
	private void writeWebSocketFrame(Frame frame) throws IOException {
		frame.write(this.outputStream);
	}
	private String getWebsocketAcceptResponse() throws NoSuchAlgorithmException {
		Matcher matcher = WEBSOCKET_KEY_PATTERN.matcher(this.header);
		Assert.state(matcher.find(), 'No Sec-WebSocket-Key');
		String response = matcher.group(1).trim() + WEBSOCKET_GUID;
		MessageDigest messageDigest = MessageDigest.getInstance('SHA-1');
		messageDigest.update(response.getBytes(), 0, response.length());
		return Base64.getEncoder().encodeToString(messageDigest.digest());
	}
	/**
	 * Close the connection.
	 * @throws IOException in case of I/O errors
	 */
	void close() throws IOException {
		this.running = false;
		this.socket.close();
	}
}
/*
/**
package org.springframework.boot.devtools.livereload;
/*
package org.springframework.boot.devtools.logger;
/**
public final class DevToolsLogFactory {
	private static final Map<Log, Class<?>> logs = new LinkedHashMap<>();
	private DevToolsLogFactory() {
	}
	/**
	 * Get a {@link Log} instance for the specified source that will be automatically
	 * {@link DeferredLog#switchTo(Class) switched} when the
	 * {@link ApplicationPreparedEvent context is prepared}.
	 * @param source the source for logging
	 * @return a {@link DeferredLog} instance
	 */
	public static Log getLog(Class<?> source) {
		synchronized (logs) {
			Log log = new DeferredLog();
			logs.put(log, source);
			return log;
		}
	}
	/**
	 * Listener used to log and switch when the context is ready.
	 */
	static class Listener implements ApplicationListener<ApplicationPreparedEvent> {
		@Override
		public void onApplicationEvent(ApplicationPreparedEvent event) {
			synchronized (logs) {
				logs.forEach((log, source) -> {
					if (log instanceof DeferredLog deferredLog) {
						deferredLog.switchTo(source);
					}
				});
				logs.clear();
			}
		}
	}
}
/*
/**
package org.springframework.boot.devtools.logger;
/*
/**
package org.springframework.boot.devtools.system;
/*
package org.springframework.boot.devtools.system;
/**
public final class DevToolsEnablementDeducer {
	private static final Set<String> SKIPPED_STACK_ELEMENTS;
	static {
		Set<String> skipped = new LinkedHashSet<>();
		skipped.add('org.junit.runners.');
		skipped.add('org.junit.platform.');
		skipped.add('org.springframework.boot.test.');
		skipped.add(SpringApplicationAotProcessor.class.getName());
		skipped.add('cucumber.runtime.');
		SKIPPED_STACK_ELEMENTS = Collections.unmodifiableSet(skipped);
	}
	private DevToolsEnablementDeducer() {
	}
	/**
	 * Checks if a specific {@link StackTraceElement} in the current thread"s stacktrace
	 * should cause devtools to be disabled. Devtools will also be disabled if running in
	 * a native image.
	 * @param thread the current thread
	 * @return {@code true} if devtools should be enabled
	 */
	public static boolean shouldEnable(Thread thread) {
		if (NativeDetector.inNativeImage()) {
			return false;
		}
		for (StackTraceElement element : thread.getStackTrace()) {
			if (isSkippedStackElement(element)) {
				return false;
			}
		}
		return true;
	}
	private static boolean isSkippedStackElement(StackTraceElement element) {
		for (String skipped : SKIPPED_STACK_ELEMENTS) {
			if (element.getClassName().startsWith(skipped)) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.devtools;
/**
class RemoteUrlPropertyExtractor implements ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
	private static final String NON_OPTION_ARGS = CommandLinePropertySource.DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME;
	@Override
	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
		ConfigurableEnvironment environment = event.getEnvironment();
		String url = cleanRemoteUrl(environment.getProperty(NON_OPTION_ARGS));
		Assert.state(StringUtils.hasLength(url), 'No remote URL specified');
		Assert.state(url.indexOf(",") == -1, 'Multiple URLs specified');
		try {
			new URI(url);
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException('Malformed URL "' + url + '"');
		}
		Map<String, Object> source = Collections.singletonMap('remoteUrl', url);
		PropertySource<?> propertySource = new MapPropertySource('remoteUrl', source);
		environment.getPropertySources().addLast(propertySource);
	}
	private String cleanRemoteUrl(String url) {
		if (StringUtils.hasText(url) && url.endsWith('/')) {
			return url.substring(0, url.length() - 1);
		}
		return url;
	}
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE;
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
public interface SnapshotStateRepository {
	/**
	 * A No-op {@link SnapshotStateRepository} that does not save state.
	 */
	SnapshotStateRepository NONE = new SnapshotStateRepository() {
		@Override
		public void save(Object state) {
		}
		@Override
		public Object restore() {
			return null;
		}
	};
	/**
	 * A {@link SnapshotStateRepository} that uses a static instance to keep state across
	 * restarts.
	 */
	SnapshotStateRepository STATIC = StaticSnapshotStateRepository.INSTANCE;
	/**
	 * Save the given state in the repository.
	 * @param state the state to save
	 */
	void save(Object state);
	/**
	 * Restore any previously saved state.
	 * @return the previously saved state or {@code null}
	 */
	Object restore();
}
/*
package org.springframework.boot.devtools.filewatch;
/**
class FileSnapshot {
	private final File file;
	private final boolean exists;
	private final long length;
	private final long lastModified;
	FileSnapshot(File file) {
		Assert.notNull(file, 'File must not be null');
		Assert.isTrue(file.isFile() || !file.exists(), 'File must not be a directory');
		this.file = file;
		this.exists = file.exists();
		this.length = file.length();
		this.lastModified = file.lastModified();
	}
	File getFile() {
		return this.file;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (obj instanceof FileSnapshot other) {
			boolean equals = this.file.equals(other.file);
			equals = equals && this.exists == other.exists;
			equals = equals && this.length == other.length;
			equals = equals && this.lastModified == other.lastModified;
			return equals;
		}
		return super.equals(obj);
	}
	@Override
	public int hashCode() {
		int hashCode = this.file.hashCode();
		hashCode = 31 * hashCode + Boolean.hashCode(this.exists);
		hashCode = 31 * hashCode + Long.hashCode(this.length);
		hashCode = 31 * hashCode + Long.hashCode(this.lastModified);
		return hashCode;
	}
	@Override
	public String toString() {
		return this.file.toString();
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
class DirectorySnapshot {
	private static final Set<String> DOTS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList('.', '..')));
	private final File directory;
	private final Date time;
	private final Set<FileSnapshot> files;
	/**
	 * Create a new {@link DirectorySnapshot} for the given directory.
	 * @param directory the source directory
	 */
	DirectorySnapshot(File directory) {
		Assert.notNull(directory, 'Directory must not be null');
		Assert.isTrue(!directory.isFile(), () -> 'Directory "' + directory + '" must not be a file');
		this.directory = directory;
		this.time = new Date();
		Set<FileSnapshot> files = new LinkedHashSet<>();
		collectFiles(directory, files);
		this.files = Collections.unmodifiableSet(files);
	}
	private void collectFiles(File source, Set<FileSnapshot> result) {
		File[] children = source.listFiles();
		if (children != null) {
			for (File child : children) {
				if (child.isDirectory() && !DOTS.contains(child.getName())) {
					collectFiles(child, result);
				}
				else if (child.isFile()) {
					result.add(new FileSnapshot(child));
				}
			}
		}
	}
	ChangedFiles getChangedFiles(DirectorySnapshot snapshot, FileFilter triggerFilter) {
		Assert.notNull(snapshot, 'Snapshot must not be null');
		File directory = this.directory;
		Assert.isTrue(snapshot.directory.equals(directory),
				() -> 'Snapshot source directory must be "' + directory + '"');
		Set<ChangedFile> changes = new LinkedHashSet<>();
		Map<File, FileSnapshot> previousFiles = getFilesMap();
		for (FileSnapshot currentFile : snapshot.files) {
			if (acceptChangedFile(triggerFilter, currentFile)) {
				FileSnapshot previousFile = previousFiles.remove(currentFile.getFile());
				if (previousFile == null) {
					changes.add(new ChangedFile(directory, currentFile.getFile(), Type.ADD));
				}
				else if (!previousFile.equals(currentFile)) {
					changes.add(new ChangedFile(directory, currentFile.getFile(), Type.MODIFY));
				}
			}
		}
		for (FileSnapshot previousFile : previousFiles.values()) {
			if (acceptChangedFile(triggerFilter, previousFile)) {
				changes.add(new ChangedFile(directory, previousFile.getFile(), Type.DELETE));
			}
		}
		return new ChangedFiles(directory, changes);
	}
	private boolean acceptChangedFile(FileFilter triggerFilter, FileSnapshot file) {
		return (triggerFilter == null || !triggerFilter.accept(file.getFile()));
	}
	private Map<File, FileSnapshot> getFilesMap() {
		Map<File, FileSnapshot> files = new LinkedHashMap<>();
		for (FileSnapshot file : this.files) {
			files.put(file.getFile(), file);
		}
		return files;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (obj instanceof DirectorySnapshot other) {
			return equals(other, null);
		}
		return super.equals(obj);
	}
	boolean equals(DirectorySnapshot other, FileFilter filter) {
		if (this.directory.equals(other.directory)) {
			Set<FileSnapshot> ourFiles = filter(this.files, filter);
			Set<FileSnapshot> otherFiles = filter(other.files, filter);
			return ourFiles.equals(otherFiles);
		}
		return false;
	}
	private Set<FileSnapshot> filter(Set<FileSnapshot> source, FileFilter filter) {
		if (filter == null) {
			return source;
		}
		Set<FileSnapshot> filtered = new LinkedHashSet<>();
		for (FileSnapshot file : source) {
			if (filter.accept(file.getFile())) {
				filtered.add(file);
			}
		}
		return filtered;
	}
	@Override
	public int hashCode() {
		int hashCode = this.directory.hashCode();
		hashCode = 31 * hashCode + this.files.hashCode();
		return hashCode;
	}
	/**
	 * Return the source directory of this snapshot.
	 * @return the source directory
	 */
	File getDirectory() {
		return this.directory;
	}
	@Override
	public String toString() {
		return this.directory + ' snapshot at ' + this.time;
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
public class FileSystemWatcher {
	private static final Duration DEFAULT_POLL_INTERVAL = Duration.ofMillis(1000);
	private static final Duration DEFAULT_QUIET_PERIOD = Duration.ofMillis(400);
	private final List<FileChangeListener> listeners = new ArrayList<>();
	private final boolean daemon;
	private final long pollInterval;
	private final long quietPeriod;
	private final SnapshotStateRepository snapshotStateRepository;
	private final AtomicInteger remainingScans = new AtomicInteger(-1);
	private final Map<File, DirectorySnapshot> directories = new HashMap<>();
	private Thread watchThread;
	private FileFilter triggerFilter;
	private final Object monitor = new Object();
	/**
	 * Create a new {@link FileSystemWatcher} instance.
	 */
	public FileSystemWatcher() {
		this(true, DEFAULT_POLL_INTERVAL, DEFAULT_QUIET_PERIOD);
	}
	/**
	 * Create a new {@link FileSystemWatcher} instance.
	 * @param daemon if a daemon thread used to monitor changes
	 * @param pollInterval the amount of time to wait between checking for changes
	 * @param quietPeriod the amount of time required after a change has been detected to
	 * ensure that updates have completed
	 */
	public FileSystemWatcher(boolean daemon, Duration pollInterval, Duration quietPeriod) {
		this(daemon, pollInterval, quietPeriod, null);
	}
	/**
	 * Create a new {@link FileSystemWatcher} instance.
	 * @param daemon if a daemon thread used to monitor changes
	 * @param pollInterval the amount of time to wait between checking for changes
	 * @param quietPeriod the amount of time required after a change has been detected to
	 * ensure that updates have completed
	 * @param snapshotStateRepository the snapshot state repository
	 * @since 2.4.0
	 */
	public FileSystemWatcher(boolean daemon, Duration pollInterval, Duration quietPeriod,
			SnapshotStateRepository snapshotStateRepository) {
		Assert.notNull(pollInterval, 'PollInterval must not be null');
		Assert.notNull(quietPeriod, 'QuietPeriod must not be null');
		Assert.isTrue(pollInterval.toMillis() > 0, 'PollInterval must be positive');
		Assert.isTrue(quietPeriod.toMillis() > 0, 'QuietPeriod must be positive');
		Assert.isTrue(pollInterval.toMillis() > quietPeriod.toMillis(),
				'PollInterval must be greater than QuietPeriod');
		this.daemon = daemon;
		this.pollInterval = pollInterval.toMillis();
		this.quietPeriod = quietPeriod.toMillis();
		this.snapshotStateRepository = (snapshotStateRepository != null) ? snapshotStateRepository
				: SnapshotStateRepository.NONE;
	}
	/**
	 * Add listener for file change events. Cannot be called after the watcher has been
	 * {@link #start() started}.
	 * @param fileChangeListener the listener to add
	 */
	public void addListener(FileChangeListener fileChangeListener) {
		Assert.notNull(fileChangeListener, 'FileChangeListener must not be null');
		synchronized (this.monitor) {
			checkNotStarted();
			this.listeners.add(fileChangeListener);
		}
	}
	/**
	 * Add source directories to monitor. Cannot be called after the watcher has been
	 * {@link #start() started}.
	 * @param directories the directories to monitor
	 */
	public void addSourceDirectories(Iterable<File> directories) {
		Assert.notNull(directories, 'Directories must not be null');
		synchronized (this.monitor) {
			directories.forEach(this::addSourceDirectory);
		}
	}
	/**
	 * Add a source directory to monitor. Cannot be called after the watcher has been
	 * {@link #start() started}.
	 * @param directory the directory to monitor
	 */
	public void addSourceDirectory(File directory) {
		Assert.notNull(directory, 'Directory must not be null');
		Assert.isTrue(!directory.isFile(), () -> 'Directory "' + directory + '" must not be a file');
		synchronized (this.monitor) {
			checkNotStarted();
			this.directories.put(directory, null);
		}
	}
	/**
	 * Set an optional {@link FileFilter} used to limit the files that trigger a change.
	 * @param triggerFilter a trigger filter or null
	 */
	public void setTriggerFilter(FileFilter triggerFilter) {
		synchronized (this.monitor) {
			this.triggerFilter = triggerFilter;
		}
	}
	private void checkNotStarted() {
		Assert.state(this.watchThread == null, 'FileSystemWatcher already started');
	}
	/**
	 * Start monitoring the source directory for changes.
	 */
	public void start() {
		synchronized (this.monitor) {
			createOrRestoreInitialSnapshots();
			if (this.watchThread == null) {
				Map<File, DirectorySnapshot> localDirectories = new HashMap<>(this.directories);
				Watcher watcher = new Watcher(this.remainingScans, new ArrayList<>(this.listeners), this.triggerFilter,
						this.pollInterval, this.quietPeriod, localDirectories, this.snapshotStateRepository);
				this.watchThread = new Thread(watcher);
				this.watchThread.setName('File Watcher');
				this.watchThread.setDaemon(this.daemon);
				this.watchThread.start();
			}
		}
	}
	@SuppressWarnings('unchecked')
	private void createOrRestoreInitialSnapshots() {
		Map<File, DirectorySnapshot> restored = (Map<File, DirectorySnapshot>) this.snapshotStateRepository.restore();
		this.directories.replaceAll((f, v) -> {
			DirectorySnapshot restoredSnapshot = (restored != null) ? restored.get(f) : null;
			return (restoredSnapshot != null) ? restoredSnapshot : new DirectorySnapshot(f);
		});
	}
	/**
	 * Stop monitoring the source directories.
	 */
	public void stop() {
		stopAfter(0);
	}
	/**
	 * Stop monitoring the source directories.
	 * @param remainingScans the number of remaining scans
	 */
	void stopAfter(int remainingScans) {
		Thread thread;
		synchronized (this.monitor) {
			thread = this.watchThread;
			if (thread != null) {
				this.remainingScans.set(remainingScans);
				if (remainingScans <= 0) {
					thread.interrupt();
				}
			}
			this.watchThread = null;
		}
		if (thread != null && Thread.currentThread() != thread) {
			try {
				thread.join();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
	}
	private static final class Watcher implements Runnable {
		private final AtomicInteger remainingScans;
		private final List<FileChangeListener> listeners;
		private final FileFilter triggerFilter;
		private final long pollInterval;
		private final long quietPeriod;
		private Map<File, DirectorySnapshot> directories;
		private final SnapshotStateRepository snapshotStateRepository;
		private Watcher(AtomicInteger remainingScans, List<FileChangeListener> listeners, FileFilter triggerFilter,
				long pollInterval, long quietPeriod, Map<File, DirectorySnapshot> directories,
				SnapshotStateRepository snapshotStateRepository) {
			this.remainingScans = remainingScans;
			this.listeners = listeners;
			this.triggerFilter = triggerFilter;
			this.pollInterval = pollInterval;
			this.quietPeriod = quietPeriod;
			this.directories = directories;
			this.snapshotStateRepository = snapshotStateRepository;
		}
		@Override
		public void run() {
			int remainingScans = this.remainingScans.get();
			while (remainingScans > 0 || remainingScans == -1) {
				try {
					if (remainingScans > 0) {
						this.remainingScans.decrementAndGet();
					}
					scan();
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
				remainingScans = this.remainingScans.get();
			}
		}
		private void scan() throws InterruptedException {
			Thread.sleep(this.pollInterval - this.quietPeriod);
			Map<File, DirectorySnapshot> previous;
			Map<File, DirectorySnapshot> current = this.directories;
			do {
				previous = current;
				current = getCurrentSnapshots();
				Thread.sleep(this.quietPeriod);
			}
			while (isDifferent(previous, current));
			if (isDifferent(this.directories, current)) {
				updateSnapshots(current.values());
			}
		}
		private boolean isDifferent(Map<File, DirectorySnapshot> previous, Map<File, DirectorySnapshot> current) {
			if (!previous.keySet().equals(current.keySet())) {
				return true;
			}
			for (Map.Entry<File, DirectorySnapshot> entry : previous.entrySet()) {
				DirectorySnapshot previousDirectory = entry.getValue();
				DirectorySnapshot currentDirectory = current.get(entry.getKey());
				if (!previousDirectory.equals(currentDirectory, this.triggerFilter)) {
					return true;
				}
			}
			return false;
		}
		private Map<File, DirectorySnapshot> getCurrentSnapshots() {
			Map<File, DirectorySnapshot> snapshots = new LinkedHashMap<>();
			for (File directory : this.directories.keySet()) {
				snapshots.put(directory, new DirectorySnapshot(directory));
			}
			return snapshots;
		}
		private void updateSnapshots(Collection<DirectorySnapshot> snapshots) {
			Map<File, DirectorySnapshot> updated = new LinkedHashMap<>();
			Set<ChangedFiles> changeSet = new LinkedHashSet<>();
			for (DirectorySnapshot snapshot : snapshots) {
				DirectorySnapshot previous = this.directories.get(snapshot.getDirectory());
				updated.put(snapshot.getDirectory(), snapshot);
				ChangedFiles changedFiles = previous.getChangedFiles(snapshot, this.triggerFilter);
				if (!changedFiles.getFiles().isEmpty()) {
					changeSet.add(changedFiles);
				}
			}
			this.directories = updated;
			this.snapshotStateRepository.save(updated);
			if (!changeSet.isEmpty()) {
				fireListeners(Collections.unmodifiableSet(changeSet));
			}
		}
		private void fireListeners(Set<ChangedFiles> changeSet) {
			for (FileChangeListener listener : this.listeners) {
				listener.onChange(changeSet);
			}
		}
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
@FunctionalInterface
public interface FileChangeListener {
	/**
	 * Called when files have been changed.
	 * @param changeSet a set of the {@link ChangedFiles}
	 */
	void onChange(Set<ChangedFiles> changeSet);
}
/*
package org.springframework.boot.devtools.filewatch;
/**
class StaticSnapshotStateRepository implements SnapshotStateRepository {
	static final StaticSnapshotStateRepository INSTANCE = new StaticSnapshotStateRepository();
	private volatile Object state;
	@Override
	public void save(Object state) {
		this.state = state;
	}
	@Override
	public Object restore() {
		return this.state;
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
public final class ChangedFiles implements Iterable<ChangedFile> {
	private final File sourceDirectory;
	private final Set<ChangedFile> files;
	public ChangedFiles(File sourceDirectory, Set<ChangedFile> files) {
		this.sourceDirectory = sourceDirectory;
		this.files = Collections.unmodifiableSet(files);
	}
	/**
	 * The source directory being watched.
	 * @return the source directory
	 */
	public File getSourceDirectory() {
		return this.sourceDirectory;
	}
	@Override
	public Iterator<ChangedFile> iterator() {
		return getFiles().iterator();
	}
	/**
	 * The files that have been changed.
	 * @return the changed files
	 */
	public Set<ChangedFile> getFiles() {
		return this.files;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null) {
			return false;
		}
		if (obj == this) {
			return true;
		}
		if (obj instanceof ChangedFiles other) {
			return this.sourceDirectory.equals(other.sourceDirectory) && this.files.equals(other.files);
		}
		return super.equals(obj);
	}
	@Override
	public int hashCode() {
		return this.files.hashCode();
	}
	@Override
	public String toString() {
		return this.sourceDirectory + ' ' + this.files;
	}
}
/*
package org.springframework.boot.devtools.filewatch;
/**
@FunctionalInterface
public interface FileSystemWatcherFactory {
	/**
	 * Create a new {@link FileSystemWatcher}.
	 * @return a new {@link FileSystemWatcher}
	 */
	FileSystemWatcher getFileSystemWatcher();
}
/*
/**
package org.springframework.boot.devtools.filewatch;
/*
package org.springframework.boot.devtools.filewatch;
/**
public final class ChangedFile {
	private final File sourceDirectory;
	private final File file;
	private final Type type;
	/**
	 * Create a new {@link ChangedFile} instance.
	 * @param sourceDirectory the source directory
	 * @param file the file
	 * @param type the type of change
	 */
	public ChangedFile(File sourceDirectory, File file, Type type) {
		Assert.notNull(sourceDirectory, 'SourceDirectory must not be null');
		Assert.notNull(file, 'File must not be null');
		Assert.notNull(type, 'Type must not be null');
		this.sourceDirectory = sourceDirectory;
		this.file = file;
		this.type = type;
	}
	/**
	 * Return the file that was changed.
	 * @return the file
	 */
	public File getFile() {
		return this.file;
	}
	/**
	 * Return the type of change.
	 * @return the type of change
	 */
	public Type getType() {
		return this.type;
	}
	/**
	 * Return the name of the file relative to the source directory.
	 * @return the relative name
	 */
	public String getRelativeName() {
		File directory = this.sourceDirectory.getAbsoluteFile();
		File file = this.file.getAbsoluteFile();
		String directoryName = StringUtils.cleanPath(directory.getPath());
		String fileName = StringUtils.cleanPath(file.getPath());
		Assert.state(fileName.startsWith(directoryName),
				() -> 'The file ' + fileName + ' is not contained in the source directory ' + directoryName);
		return fileName.substring(directoryName.length() + 1);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (obj instanceof ChangedFile other) {
			return this.file.equals(other.file) && this.type.equals(other.type);
		}
		return super.equals(obj);
	}
	@Override
	public int hashCode() {
		return this.file.hashCode() * 31 + this.type.hashCode();
	}
	@Override
	public String toString() {
		return this.file + ' (' + this.type + ')';
	}
	/**
	 * Change types.
	 */
	public enum Type {
		/**
		 * A new file has been added.
		 */
		ADD,
		/**
		 * An existing file has been modified.
		 */
		MODIFY,
		/**
		 * An existing file has been deleted.
		 */
		DELETE
	}
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
public class ClassLoaderFileURLStreamHandler extends URLStreamHandler {
	private final ClassLoaderFile file;
	public ClassLoaderFileURLStreamHandler(ClassLoaderFile file) {
		this.file = file;
	}
	@Override
	protected URLConnection openConnection(URL url) throws IOException {
		return new Connection(url);
	}
	private class Connection extends URLConnection {
		Connection(URL url) {
			super(url);
		}
		@Override
		public void connect() throws IOException {
		}
		@Override
		public InputStream getInputStream() throws IOException {
			return new ByteArrayInputStream(ClassLoaderFileURLStreamHandler.this.file.getContents());
		}
		@Override
		public long getLastModified() {
			return ClassLoaderFileURLStreamHandler.this.file.getLastModified();
		}
	}
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
public class ClassLoaderFiles implements ClassLoaderFileRepository, Serializable {
	private static final long serialVersionUID = 1;
	private final Map<String, SourceDirectory> sourceDirectories;
	/**
	 * Create a new {@link ClassLoaderFiles} instance.
	 */
	public ClassLoaderFiles() {
		this.sourceDirectories = new LinkedHashMap<>();
	}
	/**
	 * Create a new {@link ClassLoaderFiles} instance.
	 * @param classLoaderFiles the source classloader files.
	 */
	public ClassLoaderFiles(ClassLoaderFiles classLoaderFiles) {
		Assert.notNull(classLoaderFiles, 'ClassLoaderFiles must not be null');
		this.sourceDirectories = new LinkedHashMap<>(classLoaderFiles.sourceDirectories);
	}
	/**
	 * Add all elements items from the specified {@link ClassLoaderFiles} to this
	 * instance.
	 * @param files the files to add
	 */
	public void addAll(ClassLoaderFiles files) {
		Assert.notNull(files, 'Files must not be null');
		for (SourceDirectory directory : files.getSourceDirectories()) {
			for (Map.Entry<String, ClassLoaderFile> entry : directory.getFilesEntrySet()) {
				addFile(directory.getName(), entry.getKey(), entry.getValue());
			}
		}
	}
	/**
	 * Add a single {@link ClassLoaderFile} to the collection.
	 * @param name the name of the file
	 * @param file the file to add
	 */
	public void addFile(String name, ClassLoaderFile file) {
		addFile('', name, file);
	}
	/**
	 * Add a single {@link ClassLoaderFile} to the collection.
	 * @param sourceDirectory the source directory of the file
	 * @param name the name of the file
	 * @param file the file to add
	 */
	public void addFile(String sourceDirectory, String name, ClassLoaderFile file) {
		Assert.notNull(sourceDirectory, 'SourceDirectory must not be null');
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(file, 'File must not be null');
		removeAll(name);
		getOrCreateSourceDirectory(sourceDirectory).add(name, file);
	}
	private void removeAll(String name) {
		for (SourceDirectory sourceDirectory : this.sourceDirectories.values()) {
			sourceDirectory.remove(name);
		}
	}
	/**
	 * Get or create a {@link SourceDirectory} with the given name.
	 * @param name the name of the directory
	 * @return an existing or newly added {@link SourceDirectory}
	 */
	protected final SourceDirectory getOrCreateSourceDirectory(String name) {
		return this.sourceDirectories.computeIfAbsent(name, (key) -> new SourceDirectory(name));
	}
	/**
	 * Return all {@link SourceDirectory SourceDirectories} that have been added to the
	 * collection.
	 * @return a collection of {@link SourceDirectory} items
	 */
	public Collection<SourceDirectory> getSourceDirectories() {
		return Collections.unmodifiableCollection(this.sourceDirectories.values());
	}
	/**
	 * Return the size of the collection.
	 * @return the size of the collection
	 */
	public int size() {
		int size = 0;
		for (SourceDirectory sourceDirectory : this.sourceDirectories.values()) {
			size += sourceDirectory.getFiles().size();
		}
		return size;
	}
	@Override
	public ClassLoaderFile getFile(String name) {
		for (SourceDirectory sourceDirectory : this.sourceDirectories.values()) {
			ClassLoaderFile file = sourceDirectory.get(name);
			if (file != null) {
				return file;
			}
		}
		return null;
	}
	/**
	 * An individual source directory that is being managed by the collection.
	 */
	public static class SourceDirectory implements Serializable {
		private static final long serialVersionUID = 1;
		private final String name;
		private final Map<String, ClassLoaderFile> files = new LinkedHashMap<>();
		SourceDirectory(String name) {
			this.name = name;
		}
		public Set<Entry<String, ClassLoaderFile>> getFilesEntrySet() {
			return this.files.entrySet();
		}
		protected final void add(String name, ClassLoaderFile file) {
			this.files.put(name, file);
		}
		protected final void remove(String name) {
			this.files.remove(name);
		}
		protected final ClassLoaderFile get(String name) {
			return this.files.get(name);
		}
		/**
		 * Return the name of the source directory.
		 * @return the name of the source directory
		 */
		public String getName() {
			return this.name;
		}
		/**
		 * Return all {@link ClassLoaderFile ClassLoaderFiles} in the collection that are
		 * contained in this source directory.
		 * @return the files contained in the source directory
		 */
		public Collection<ClassLoaderFile> getFiles() {
			return Collections.unmodifiableCollection(this.files.values());
		}
	}
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
public class RestartClassLoader extends URLClassLoader implements SmartClassLoader {
	private final ClassLoaderFileRepository updatedFiles;
	/**
	 * Create a new {@link RestartClassLoader} instance.
	 * @param parent the parent classloader
	 * @param urls the urls managed by the classloader
	 */
	public RestartClassLoader(ClassLoader parent, URL[] urls) {
		this(parent, urls, ClassLoaderFileRepository.NONE);
	}
	/**
	 * Create a new {@link RestartClassLoader} instance.
	 * @param parent the parent classloader
	 * @param updatedFiles any files that have been updated since the JARs referenced in
	 * URLs were created.
	 * @param urls the urls managed by the classloader
	 */
	public RestartClassLoader(ClassLoader parent, URL[] urls, ClassLoaderFileRepository updatedFiles) {
		super(urls, parent);
		Assert.notNull(parent, 'Parent must not be null');
		Assert.notNull(updatedFiles, 'UpdatedFiles must not be null');
		this.updatedFiles = updatedFiles;
	}
	@Override
	public Enumeration<URL> getResources(String name) throws IOException {
		// Use the parent since we"re shadowing resource and we don"t want duplicates
		Enumeration<URL> resources = getParent().getResources(name);
		ClassLoaderFile file = this.updatedFiles.getFile(name);
		if (file != null) {
			// Assume that we"re replacing just the first item
			if (resources.hasMoreElements()) {
				resources.nextElement();
			}
			if (file.getKind() != Kind.DELETED) {
				return new CompoundEnumeration<>(createFileUrl(name, file), resources);
			}
		}
		return resources;
	}
	@Override
	public URL getResource(String name) {
		ClassLoaderFile file = this.updatedFiles.getFile(name);
		if (file != null && file.getKind() == Kind.DELETED) {
			return null;
		}
		URL resource = findResource(name);
		if (resource != null) {
			return resource;
		}
		return getParent().getResource(name);
	}
	@Override
	public URL findResource(String name) {
		final ClassLoaderFile file = this.updatedFiles.getFile(name);
		if (file == null) {
			return super.findResource(name);
		}
		if (file.getKind() == Kind.DELETED) {
			return null;
		}
		return createFileUrl(name, file);
	}
	@Override
	public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		String path = name.replace(".", "/").concat('.class');
		ClassLoaderFile file = this.updatedFiles.getFile(path);
		if (file != null && file.getKind() == Kind.DELETED) {
			throw new ClassNotFoundException(name);
		}
		synchronized (getClassLoadingLock(name)) {
			Class<?> loadedClass = findLoadedClass(name);
			if (loadedClass == null) {
				try {
					loadedClass = findClass(name);
				}
				catch (ClassNotFoundException ex) {
					loadedClass = Class.forName(name, false, getParent());
				}
			}
			if (resolve) {
				resolveClass(loadedClass);
			}
			return loadedClass;
		}
	}
	@Override
	protected Class<?> findClass(String name) throws ClassNotFoundException {
		String path = name.replace(".", "/").concat('.class');
		final ClassLoaderFile file = this.updatedFiles.getFile(path);
		if (file == null) {
			return super.findClass(name);
		}
		if (file.getKind() == Kind.DELETED) {
			throw new ClassNotFoundException(name);
		}
		byte[] bytes = file.getContents();
		return defineClass(name, bytes, 0, bytes.length);
	}
	@Override
	public Class<?> publicDefineClass(String name, byte[] b, ProtectionDomain protectionDomain) {
		return defineClass(name, b, 0, b.length, protectionDomain);
	}
	@Override
	public ClassLoader getOriginalClassLoader() {
		return getParent();
	}
	private URL createFileUrl(String name, ClassLoaderFile file) {
		try {
			return new URL('reloaded', null, -1, '/' + name, new ClassLoaderFileURLStreamHandler(file));
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	@Override
	public boolean isClassReloadable(Class<?> classType) {
		return (classType.getClassLoader() instanceof RestartClassLoader);
	}
	/**
	 * Compound {@link Enumeration} that adds an additional item to the front.
	 */
	private static class CompoundEnumeration<E> implements Enumeration<E> {
		private E firstElement;
		private final Enumeration<E> enumeration;
		CompoundEnumeration(E firstElement, Enumeration<E> enumeration) {
			this.firstElement = firstElement;
			this.enumeration = enumeration;
		}
		@Override
		public boolean hasMoreElements() {
			return (this.firstElement != null || this.enumeration.hasMoreElements());
		}
		@Override
		public E nextElement() {
			if (this.firstElement == null) {
				return this.enumeration.nextElement();
			}
			E element = this.firstElement;
			this.firstElement = null;
			return element;
		}
	}
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
@FunctionalInterface
public interface ClassLoaderFileRepository {
	/**
	 * Empty {@link ClassLoaderFileRepository} implementation.
	 */
	ClassLoaderFileRepository NONE = (name) -> null;
	/**
	 * Return a {@link ClassLoaderFile} for the given name or {@code null} if no file is
	 * contained in this collection.
	 * @param name the name of the file
	 * @return a {@link ClassLoaderFile} or {@code null}
	 */
	ClassLoaderFile getFile(String name);
}
/*
package org.springframework.boot.devtools.restart.classloader;
/**
public class ClassLoaderFile implements Serializable {
	private static final long serialVersionUID = 1;
	private final Kind kind;
	private final byte[] contents;
	private final long lastModified;
	/**
	 * Create a new {@link ClassLoaderFile} instance.
	 * @param kind the kind of file
	 * @param contents the file contents
	 */
	public ClassLoaderFile(Kind kind, byte[] contents) {
		this(kind, System.currentTimeMillis(), contents);
	}
	/**
	 * Create a new {@link ClassLoaderFile} instance.
	 * @param kind the kind of file
	 * @param lastModified the last modified time
	 * @param contents the file contents
	 */
	public ClassLoaderFile(Kind kind, long lastModified, byte[] contents) {
		Assert.notNull(kind, 'Kind must not be null');
		if (kind == Kind.DELETED) {
			Assert.isTrue(contents == null, 'Contents must be null');
		}
		else {
			Assert.isTrue(contents != null, 'Contents must not be null');
		}
		this.kind = kind;
		this.lastModified = lastModified;
		this.contents = contents;
	}
	/**
	 * Return the file {@link Kind} (added, modified, deleted).
	 * @return the kind
	 */
	public Kind getKind() {
		return this.kind;
	}
	/**
	 * Return the time that the file was last modified.
	 * @return the last modified time
	 */
	public long getLastModified() {
		return this.lastModified;
	}
	/**
	 * Return the contents of the file as a byte array or {@code null} if
	 * {@link #getKind()} is {@link Kind#DELETED}.
	 * @return the contents or {@code null}
	 */
	public byte[] getContents() {
		return this.contents;
	}
	/**
	 * The kinds of class load files.
	 */
	public enum Kind {
		/**
		 * The file has been added since the original JAR was created.
		 */
		ADDED,
		/**
		 * The file has been modified since the original JAR was created.
		 */
		MODIFIED,
		/**
		 * The file has been deleted since the original JAR was created.
		 */
		DELETED
	}
}
/*
/**
package org.springframework.boot.devtools.restart.classloader;
/*
package org.springframework.boot.devtools.restart.server;
/**
public class RestartServer {
	private static final Log logger = LogFactory.getLog(RestartServer.class);
	private final SourceDirectoryUrlFilter sourceDirectoryUrlFilter;
	private final ClassLoader classLoader;
	/**
	 * Create a new {@link RestartServer} instance.
	 * @param sourceDirectoryUrlFilter the source filter used to link remote directory to
	 * the local classpath
	 */
	public RestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter) {
		this(sourceDirectoryUrlFilter, Thread.currentThread().getContextClassLoader());
	}
	/**
	 * Create a new {@link RestartServer} instance.
	 * @param sourceDirectoryUrlFilter the source filter used to link remote directory to
	 * the local classpath
	 * @param classLoader the application classloader
	 */
	public RestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter, ClassLoader classLoader) {
		Assert.notNull(sourceDirectoryUrlFilter, 'SourceDirectoryUrlFilter must not be null');
		Assert.notNull(classLoader, 'ClassLoader must not be null');
		this.sourceDirectoryUrlFilter = sourceDirectoryUrlFilter;
		this.classLoader = classLoader;
	}
	/**
	 * Update the current running application with the specified {@link ClassLoaderFiles}
	 * and trigger a reload.
	 * @param files updated class loader files
	 */
	public void updateAndRestart(ClassLoaderFiles files) {
		Set<URL> urls = new LinkedHashSet<>();
		Set<URL> classLoaderUrls = getClassLoaderUrls();
		for (SourceDirectory directory : files.getSourceDirectories()) {
			for (Entry<String, ClassLoaderFile> entry : directory.getFilesEntrySet()) {
				for (URL url : classLoaderUrls) {
					if (updateFileSystem(url, entry.getKey(), entry.getValue())) {
						urls.add(url);
					}
				}
			}
			urls.addAll(getMatchingUrls(classLoaderUrls, directory.getName()));
		}
		updateTimeStamp(urls);
		restart(urls, files);
	}
	private boolean updateFileSystem(URL url, String name, ClassLoaderFile classLoaderFile) {
		if (!isDirectoryUrl(url.toString())) {
			return false;
		}
		try {
			File directory = ResourceUtils.getFile(url);
			File file = new File(directory, name);
			if (file.exists() && file.canWrite()) {
				if (classLoaderFile.getKind() == Kind.DELETED) {
					return file.delete();
				}
				FileCopyUtils.copy(classLoaderFile.getContents(), file);
				return true;
			}
		}
		catch (IOException ex) {
			// Ignore
		}
		return false;
	}
	private boolean isDirectoryUrl(String urlString) {
		return urlString.startsWith('file:') && urlString.endsWith('/');
	}
	private Set<URL> getMatchingUrls(Set<URL> urls, String sourceDirectory) {
		Set<URL> matchingUrls = new LinkedHashSet<>();
		for (URL url : urls) {
			if (this.sourceDirectoryUrlFilter.isMatch(sourceDirectory, url)) {
				if (logger.isDebugEnabled()) {
					logger.debug('URL ' + url + ' matched against source directory ' + sourceDirectory);
				}
				matchingUrls.add(url);
			}
		}
		return matchingUrls;
	}
	private Set<URL> getClassLoaderUrls() {
		Set<URL> urls = new LinkedHashSet<>();
		ClassLoader classLoader = this.classLoader;
		while (classLoader != null) {
			if (classLoader instanceof URLClassLoader urlClassLoader) {
				Collections.addAll(urls, urlClassLoader.getURLs());
			}
			classLoader = classLoader.getParent();
		}
		return urls;
	}
	private void updateTimeStamp(Iterable<URL> urls) {
		for (URL url : urls) {
			updateTimeStamp(url);
		}
	}
	private void updateTimeStamp(URL url) {
		try {
			URL actualUrl = ResourceUtils.extractJarFileURL(url);
			File file = ResourceUtils.getFile(actualUrl, 'Jar URL');
			file.setLastModified(System.currentTimeMillis());
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	/**
	 * Called to restart the application.
	 * @param urls the updated URLs
	 * @param files the updated files
	 */
	protected void restart(Set<URL> urls, ClassLoaderFiles files) {
		Restarter restarter = Restarter.getInstance();
		restarter.addUrls(urls);
		restarter.addClassLoaderFiles(files);
		restarter.restart();
	}
}
/*
package org.springframework.boot.devtools.restart.server;
/**
public class HttpRestartServer {
	private static final Log logger = LogFactory.getLog(HttpRestartServer.class);
	private final RestartServer server;
	/**
	 * Create a new {@link HttpRestartServer} instance.
	 * @param sourceDirectoryUrlFilter the source filter used to link remote directory to
	 * the local classpath
	 */
	public HttpRestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter) {
		Assert.notNull(sourceDirectoryUrlFilter, 'SourceDirectoryUrlFilter must not be null');
		this.server = new RestartServer(sourceDirectoryUrlFilter);
	}
	/**
	 * Create a new {@link HttpRestartServer} instance.
	 * @param restartServer the underlying restart server
	 */
	public HttpRestartServer(RestartServer restartServer) {
		Assert.notNull(restartServer, 'RestartServer must not be null');
		this.server = restartServer;
	}
	/**
	 * Handle a server request.
	 * @param request the request
	 * @param response the response
	 * @throws IOException in case of I/O errors
	 */
	public void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {
		try {
			Assert.state(request.getHeaders().getContentLength() > 0, 'No content');
			ObjectInputStream objectInputStream = new ObjectInputStream(request.getBody());
			ClassLoaderFiles files = (ClassLoaderFiles) objectInputStream.readObject();
			objectInputStream.close();
			this.server.updateAndRestart(files);
			response.setStatusCode(HttpStatus.OK);
		}
		catch (Exception ex) {
			logger.warn('Unable to handler restart server HTTP request', ex);
			response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
}
/*
package org.springframework.boot.devtools.restart.server;
/**
@FunctionalInterface
public interface SourceDirectoryUrlFilter {
	/**
	 * Determine if the specified URL matches a source directory.
	 * @param sourceDirectory the source directory
	 * @param url the URL to check
	 * @return {@code true} if the URL matches
	 */
	boolean isMatch(String sourceDirectory, URL url);
}
/*
package org.springframework.boot.devtools.restart.server;
/**
public class DefaultSourceDirectoryUrlFilter implements SourceDirectoryUrlFilter {
	private static final String[] COMMON_ENDINGS = { '/target/classes', '/bin' };
	private static final Pattern URL_MODULE_PATTERN = Pattern.compile('.*/(.+)\\.jar');
	private static final Pattern VERSION_PATTERN = Pattern.compile('^-\\d+(?:\\.\\d+)*(?:[.-].+)?$');
	@Override
	public boolean isMatch(String sourceDirectory, URL url) {
		String jarName = getJarName(url);
		if (!StringUtils.hasLength(jarName)) {
			return false;
		}
		return isMatch(sourceDirectory, jarName);
	}
	private String getJarName(URL url) {
		Matcher matcher = URL_MODULE_PATTERN.matcher(url.toString());
		if (matcher.find()) {
			return matcher.group(1);
		}
		return null;
	}
	private boolean isMatch(String sourceDirectory, String jarName) {
		sourceDirectory = stripTrailingSlash(sourceDirectory);
		sourceDirectory = stripCommonEnds(sourceDirectory);
		String[] directories = StringUtils.delimitedListToStringArray(sourceDirectory, '/');
		for (int i = directories.length - 1; i >= 0; i--) {
			if (isDirectoryMatch(directories[i], jarName)) {
				return true;
			}
		}
		return false;
	}
	private boolean isDirectoryMatch(String directory, String jarName) {
		if (!jarName.startsWith(directory)) {
			return false;
		}
		String version = jarName.substring(directory.length());
		return version.isEmpty() || VERSION_PATTERN.matcher(version).matches();
	}
	private String stripTrailingSlash(String string) {
		if (string.endsWith('/')) {
			return string.substring(0, string.length() - 1);
		}
		return string;
	}
	private String stripCommonEnds(String string) {
		for (String ending : COMMON_ENDINGS) {
			if (string.endsWith(ending)) {
				return string.substring(0, string.length() - ending.length());
			}
		}
		return string;
	}
}
/*
package org.springframework.boot.devtools.restart.server;
/**
public class HttpRestartServerHandler implements Handler {
	private final HttpRestartServer server;
	/**
	 * Create a new {@link HttpRestartServerHandler} instance.
	 * @param server the server to adapt
	 */
	public HttpRestartServerHandler(HttpRestartServer server) {
		Assert.notNull(server, 'Server must not be null');
		this.server = server;
	}
	@Override
	public void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {
		this.server.handle(request, response);
	}
}
/*
/**
package org.springframework.boot.devtools.restart.server;
/*
package org.springframework.boot.devtools.restart;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope('restart')
public @interface RestartScope {
}
/*
package org.springframework.boot.devtools.restart;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnInitializedRestarterCondition.class)
public @interface ConditionalOnInitializedRestarter {
}
/*
package org.springframework.boot.devtools.restart;
/**
@FunctionalInterface
public interface RestartListener {
	/**
	 * Called before an application restart.
	 */
	void beforeRestart();
}
/*
package org.springframework.boot.devtools.restart;
/**
final class ClassLoaderFilesResourcePatternResolver implements ResourcePatternResolver {
	private static final String[] LOCATION_PATTERN_PREFIXES = { CLASSPATH_ALL_URL_PREFIX, CLASSPATH_URL_PREFIX };
	private static final String WEB_CONTEXT_CLASS = 'org.springframework.web.context.WebApplicationContext';
	private final ResourcePatternResolver patternResolverDelegate;
	private final PathMatcher antPathMatcher = new AntPathMatcher();
	private final ClassLoaderFiles classLoaderFiles;
	ClassLoaderFilesResourcePatternResolver(AbstractApplicationContext applicationContext,
			ClassLoaderFiles classLoaderFiles) {
		this.classLoaderFiles = classLoaderFiles;
		this.patternResolverDelegate = getResourcePatternResolverFactory()
			.getResourcePatternResolver(applicationContext, retrieveResourceLoader(applicationContext));
	}
	private ResourceLoader retrieveResourceLoader(ApplicationContext applicationContext) {
		Field field = ReflectionUtils.findField(applicationContext.getClass(), 'resourceLoader', ResourceLoader.class);
		if (field == null) {
			return null;
		}
		ReflectionUtils.makeAccessible(field);
		return (ResourceLoader) ReflectionUtils.getField(field, applicationContext);
	}
	private ResourcePatternResolverFactory getResourcePatternResolverFactory() {
		if (ClassUtils.isPresent(WEB_CONTEXT_CLASS, null)) {
			return new WebResourcePatternResolverFactory();
		}
		return new ResourcePatternResolverFactory();
	}
	@Override
	public ClassLoader getClassLoader() {
		return this.patternResolverDelegate.getClassLoader();
	}
	@Override
	public Resource getResource(String location) {
		Resource candidate = this.patternResolverDelegate.getResource(location);
		if (isDeleted(candidate)) {
			return new DeletedClassLoaderFileResource(location);
		}
		return candidate;
	}
	@Override
	public Resource[] getResources(String locationPattern) throws IOException {
		List<Resource> resources = new ArrayList<>();
		Resource[] candidates = this.patternResolverDelegate.getResources(locationPattern);
		for (Resource candidate : candidates) {
			if (!isDeleted(candidate)) {
				resources.add(candidate);
			}
		}
		resources.addAll(getAdditionalResources(locationPattern));
		return resources.toArray(new Resource[0]);
	}
	private List<Resource> getAdditionalResources(String locationPattern) throws MalformedURLException {
		List<Resource> additionalResources = new ArrayList<>();
		String trimmedLocationPattern = trimLocationPattern(locationPattern);
		for (SourceDirectory sourceDirectory : this.classLoaderFiles.getSourceDirectories()) {
			for (Entry<String, ClassLoaderFile> entry : sourceDirectory.getFilesEntrySet()) {
				String name = entry.getKey();
				ClassLoaderFile file = entry.getValue();
				if (file.getKind() != Kind.DELETED && this.antPathMatcher.match(trimmedLocationPattern, name)) {
					URL url = new URL('reloaded', null, -1, '/' + name, new ClassLoaderFileURLStreamHandler(file));
					UrlResource resource = new UrlResource(url);
					additionalResources.add(resource);
				}
			}
		}
		return additionalResources;
	}
	private String trimLocationPattern(String pattern) {
		for (String prefix : LOCATION_PATTERN_PREFIXES) {
			if (pattern.startsWith(prefix)) {
				return pattern.substring(prefix.length());
			}
		}
		return pattern;
	}
	private boolean isDeleted(Resource resource) {
		for (SourceDirectory sourceDirectory : this.classLoaderFiles.getSourceDirectories()) {
			for (Entry<String, ClassLoaderFile> entry : sourceDirectory.getFilesEntrySet()) {
				try {
					String name = entry.getKey();
					ClassLoaderFile file = entry.getValue();
					if (file.getKind() == Kind.DELETED && resource.exists()
							&& resource.getURI().toString().endsWith(name)) {
						return true;
					}
				}
				catch (IOException ex) {
					throw new IllegalStateException('Failed to retrieve URI from "' + resource + '"', ex);
				}
			}
		}
		return false;
	}
	/**
	 * A {@link Resource} that represents a {@link ClassLoaderFile} that has been
	 * {@link Kind#DELETED deleted}.
	 */
	static final class DeletedClassLoaderFileResource extends AbstractResource {
		private final String name;
		private DeletedClassLoaderFileResource(String name) {
			this.name = name;
		}
		@Override
		public boolean exists() {
			return false;
		}
		@Override
		public String getDescription() {
			return 'Deleted: ' + this.name;
		}
		@Override
		public InputStream getInputStream() throws IOException {
			throw new IOException(this.name + ' has been deleted');
		}
	}
	/**
	 * Factory used to create the {@link ResourcePatternResolver} delegate.
	 */
	private static class ResourcePatternResolverFactory {
		ResourcePatternResolver getResourcePatternResolver(AbstractApplicationContext applicationContext,
				ResourceLoader resourceLoader) {
			ResourceLoader targetResourceLoader = (resourceLoader != null) ? resourceLoader
					: new ApplicationContextResourceLoader(applicationContext::getProtocolResolvers);
			return new PathMatchingResourcePatternResolver(targetResourceLoader);
		}
	}
	/**
	 * {@link ResourcePatternResolverFactory} to be used when the classloader can access
	 * {@link WebApplicationContext}.
	 */
	private static final class WebResourcePatternResolverFactory extends ResourcePatternResolverFactory {
		@Override
		public ResourcePatternResolver getResourcePatternResolver(AbstractApplicationContext applicationContext,
				ResourceLoader resourceLoader) {
			if (applicationContext instanceof WebApplicationContext) {
				return getServletContextResourcePatternResolver(applicationContext, resourceLoader);
			}
			return super.getResourcePatternResolver(applicationContext, resourceLoader);
		}
		private ResourcePatternResolver getServletContextResourcePatternResolver(
				AbstractApplicationContext applicationContext, ResourceLoader resourceLoader) {
			ResourceLoader targetResourceLoader = (resourceLoader != null) ? resourceLoader
					: new WebApplicationContextResourceLoader(applicationContext::getProtocolResolvers,
							(WebApplicationContext) applicationContext);
			return new ServletContextResourcePatternResolver(targetResourceLoader);
		}
	}
	private static class ApplicationContextResourceLoader extends DefaultResourceLoader {
		private final Supplier<Collection<ProtocolResolver>> protocolResolvers;
		ApplicationContextResourceLoader(Supplier<Collection<ProtocolResolver>> protocolResolvers) {
			super(null);
			this.protocolResolvers = protocolResolvers;
		}
		@Override
		public Collection<ProtocolResolver> getProtocolResolvers() {
			return this.protocolResolvers.get();
		}
	}
	/**
	 * {@link ResourceLoader} that optionally supports {@link ServletContextResource
	 * ServletContextResources}.
	 */
	private static class WebApplicationContextResourceLoader extends ApplicationContextResourceLoader {
		private final WebApplicationContext applicationContext;
		WebApplicationContextResourceLoader(Supplier<Collection<ProtocolResolver>> protocolResolvers,
				WebApplicationContext applicationContext) {
			super(protocolResolvers);
			this.applicationContext = applicationContext;
		}
		@Override
		protected Resource getResourceByPath(String path) {
			if (this.applicationContext.getServletContext() != null) {
				return new ServletContextResource(this.applicationContext.getServletContext(), path);
			}
			return super.getResourceByPath(path);
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
@FunctionalInterface
public interface RestartInitializer {
	/**
	 * {@link RestartInitializer} that doesn"t return any URLs.
	 */
	RestartInitializer NONE = (thread) -> null;
	/**
	 * Return the initial set of URLs for the {@link Restarter} or {@code null} if no
	 * initial restart is required.
	 * @param thread the source thread
	 * @return initial URLs or {@code null}
	 */
	URL[] getInitialUrls(Thread thread);
}
/*
package org.springframework.boot.devtools.restart;
/**
class OnInitializedRestarterCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('Initialized Restarter Condition');
		Restarter restarter = getRestarter();
		if (restarter == null) {
			return ConditionOutcome.noMatch(message.because('unavailable'));
		}
		if (restarter.getInitialUrls() == null) {
			return ConditionOutcome.noMatch(message.because('initialized without URLs'));
		}
		return ConditionOutcome.match(message.because('available and initialized'));
	}
	private Restarter getRestarter() {
		try {
			return Restarter.getInstance();
		}
		catch (Exception ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class RestartLauncher extends Thread {
	private final String mainClassName;
	private final String[] args;
	private Throwable error;
	RestartLauncher(ClassLoader classLoader, String mainClassName, String[] args,
			UncaughtExceptionHandler exceptionHandler) {
		this.mainClassName = mainClassName;
		this.args = args;
		setName('restartedMain');
		setUncaughtExceptionHandler(exceptionHandler);
		setDaemon(false);
		setContextClassLoader(classLoader);
	}
	@Override
	public void run() {
		try {
			Class<?> mainClass = Class.forName(this.mainClassName, false, getContextClassLoader());
			Method mainMethod = mainClass.getDeclaredMethod('main', String[].class);
			mainMethod.setAccessible(true);
			mainMethod.invoke(null, new Object[] { this.args });
		}
		catch (Throwable ex) {
			this.error = ex;
			getUncaughtExceptionHandler().uncaughtException(this, ex);
		}
	}
	Throwable getError() {
		return this.error;
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
public class Restarter {
	private static final Object INSTANCE_MONITOR = new Object();
	private static final String[] NO_ARGS = {};
	private static Restarter instance;
	private final Set<URL> urls = new LinkedHashSet<>();
	private final ClassLoaderFiles classLoaderFiles = new ClassLoaderFiles();
	private final Map<String, Object> attributes = new ConcurrentHashMap<>();
	private final BlockingDeque<LeakSafeThread> leakSafeThreads = new LinkedBlockingDeque<>();
	private final Lock stopLock = new ReentrantLock();
	private final Object monitor = new Object();
	private Log logger = new DeferredLog();
	private final boolean forceReferenceCleanup;
	private boolean enabled = true;
	private final URL[] initialUrls;
	private final String mainClassName;
	private final ClassLoader applicationClassLoader;
	private final String[] args;
	private final UncaughtExceptionHandler exceptionHandler;
	private boolean finished = false;
	private final List<ConfigurableApplicationContext> rootContexts = new CopyOnWriteArrayList<>();
	/**
	 * Internal constructor to create a new {@link Restarter} instance.
	 * @param thread the source thread
	 * @param args the application arguments
	 * @param forceReferenceCleanup if soft/weak reference cleanup should be forced
	 * @param initializer the restart initializer
	 * @see #initialize(String[])
	 */
	protected Restarter(Thread thread, String[] args, boolean forceReferenceCleanup, RestartInitializer initializer) {
		Assert.notNull(thread, 'Thread must not be null');
		Assert.notNull(args, 'Args must not be null');
		Assert.notNull(initializer, 'Initializer must not be null');
		if (this.logger.isDebugEnabled()) {
			this.logger.debug('Creating new Restarter for thread ' + thread);
		}
		SilentExitExceptionHandler.setup(thread);
		this.forceReferenceCleanup = forceReferenceCleanup;
		this.initialUrls = initializer.getInitialUrls(thread);
		this.mainClassName = getMainClassName(thread);
		this.applicationClassLoader = thread.getContextClassLoader();
		this.args = args;
		this.exceptionHandler = thread.getUncaughtExceptionHandler();
		this.leakSafeThreads.add(new LeakSafeThread());
	}
	private String getMainClassName(Thread thread) {
		try {
			return new MainMethod(thread).getDeclaringClassName();
		}
		catch (Exception ex) {
			return null;
		}
	}
	protected void initialize(boolean restartOnInitialize) {
		preInitializeLeakyClasses();
		if (this.initialUrls != null) {
			this.urls.addAll(Arrays.asList(this.initialUrls));
			if (restartOnInitialize) {
				this.logger.debug('Immediately restarting application');
				immediateRestart();
			}
		}
	}
	private void immediateRestart() {
		try {
			getLeakSafeThread().callAndWait(() -> {
				start(FailureHandler.NONE);
				cleanupCaches();
				return null;
			});
		}
		catch (Exception ex) {
			this.logger.warn('Unable to initialize restarter', ex);
		}
		SilentExitExceptionHandler.exitCurrentThread();
	}
	/**
	 * CGLIB has a private exception field which needs to initialized early to ensure that
	 * the stacktrace doesn"t retain a reference to the RestartClassLoader.
	 */
	private void preInitializeLeakyClasses() {
		try {
			Class<?> readerClass = ClassNameReader.class;
			Field field = readerClass.getDeclaredField('EARLY_EXIT');
			field.setAccessible(true);
			((Throwable) field.get(null)).fillInStackTrace();
		}
		catch (Exception ex) {
			this.logger.warn('Unable to pre-initialize classes', ex);
		}
	}
	/**
	 * Set if restart support is enabled.
	 * @param enabled if restart support is enabled
	 */
	private void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	/**
	 * Add additional URLs to be includes in the next restart.
	 * @param urls the urls to add
	 */
	public void addUrls(Collection<URL> urls) {
		Assert.notNull(urls, 'Urls must not be null');
		this.urls.addAll(urls);
	}
	/**
	 * Add additional {@link ClassLoaderFiles} to be included in the next restart.
	 * @param classLoaderFiles the files to add
	 */
	public void addClassLoaderFiles(ClassLoaderFiles classLoaderFiles) {
		Assert.notNull(classLoaderFiles, 'ClassLoaderFiles must not be null');
		this.classLoaderFiles.addAll(classLoaderFiles);
	}
	/**
	 * Return a {@link ThreadFactory} that can be used to create leak safe threads.
	 * @return a leak safe thread factory
	 */
	public ThreadFactory getThreadFactory() {
		return new LeakSafeThreadFactory();
	}
	/**
	 * Restart the running application.
	 */
	public void restart() {
		restart(FailureHandler.NONE);
	}
	/**
	 * Restart the running application.
	 * @param failureHandler a failure handler to deal with application that doesn"t start
	 */
	public void restart(FailureHandler failureHandler) {
		if (!this.enabled) {
			this.logger.debug('Application restart is disabled');
			return;
		}
		this.logger.debug('Restarting application');
		getLeakSafeThread().call(() -> {
			Restarter.this.stop();
			Restarter.this.start(failureHandler);
			return null;
		});
	}
	/**
	 * Start the application.
	 * @param failureHandler a failure handler for application that won"t start
	 * @throws Exception in case of errors
	 */
	protected void start(FailureHandler failureHandler) throws Exception {
		do {
			Throwable error = doStart();
			if (error == null) {
				return;
			}
			if (failureHandler.handle(error) == Outcome.ABORT) {
				return;
			}
		}
		while (true);
	}
	private Throwable doStart() throws Exception {
		Assert.notNull(this.mainClassName, 'Unable to find the main class to restart');
		URL[] urls = this.urls.toArray(new URL[0]);
		ClassLoaderFiles updatedFiles = new ClassLoaderFiles(this.classLoaderFiles);
		ClassLoader classLoader = new RestartClassLoader(this.applicationClassLoader, urls, updatedFiles);
		if (this.logger.isDebugEnabled()) {
			this.logger.debug('Starting application ' + this.mainClassName + ' with URLs ' + Arrays.asList(urls));
		}
		return relaunch(classLoader);
	}
	/**
	 * Relaunch the application using the specified classloader.
	 * @param classLoader the classloader to use
	 * @return any exception that caused the launch to fail or {@code null}
	 * @throws Exception in case of errors
	 */
	protected Throwable relaunch(ClassLoader classLoader) throws Exception {
		RestartLauncher launcher = new RestartLauncher(classLoader, this.mainClassName, this.args,
				this.exceptionHandler);
		launcher.start();
		launcher.join();
		return launcher.getError();
	}
	/**
	 * Stop the application.
	 * @throws Exception in case of errors
	 */
	protected void stop() throws Exception {
		this.logger.debug('Stopping application');
		this.stopLock.lock();
		try {
			for (ConfigurableApplicationContext context : this.rootContexts) {
				context.close();
				this.rootContexts.remove(context);
			}
			cleanupCaches();
			if (this.forceReferenceCleanup) {
				forceReferenceCleanup();
			}
		}
		finally {
			this.stopLock.unlock();
		}
		System.gc();
		System.runFinalization();
	}
	private void cleanupCaches() {
		Introspector.flushCaches();
		cleanupKnownCaches();
	}
	private void cleanupKnownCaches() {
		// Whilst not strictly necessary it helps to clean up soft reference caches
		// early rather than waiting for memory limits to be reached
		ResolvableType.clearCache();
		cleanCachedIntrospectionResultsCache();
		ReflectionUtils.clearCache();
		clearAnnotationUtilsCache();
	}
	private void cleanCachedIntrospectionResultsCache() {
		clear(CachedIntrospectionResults.class, 'acceptedClassLoaders');
		clear(CachedIntrospectionResults.class, 'strongClassCache');
		clear(CachedIntrospectionResults.class, 'softClassCache');
	}
	private void clearAnnotationUtilsCache() {
		try {
			AnnotationUtils.clearCache();
		}
		catch (Throwable ex) {
			clear(AnnotationUtils.class, 'findAnnotationCache');
			clear(AnnotationUtils.class, 'annotatedInterfaceCache');
		}
	}
	private void clear(Class<?> type, String fieldName) {
		try {
			Field field = type.getDeclaredField(fieldName);
			field.setAccessible(true);
			Object instance = field.get(null);
			if (instance instanceof Set) {
				((Set<?>) instance).clear();
			}
			if (instance instanceof Map) {
				((Map<?, ?>) instance).keySet().removeIf(this::isFromRestartClassLoader);
			}
		}
		catch (Exception ex) {
			if (this.logger.isDebugEnabled()) {
				this.logger.debug('Unable to clear field ' + type + ' ' + fieldName, ex);
			}
		}
	}
	private boolean isFromRestartClassLoader(Object object) {
		return (object instanceof Class && ((Class<?>) object).getClassLoader() instanceof RestartClassLoader);
	}
	/**
	 * Cleanup any soft/weak references by forcing an {@link OutOfMemoryError} error.
	 */
	private void forceReferenceCleanup() {
		try {
			final List<long[]> memory = new LinkedList<>();
			while (true) {
				memory.add(new long[102400]);
			}
		}
		catch (OutOfMemoryError ex) {
			// Expected
		}
	}
	/**
	 * Called to finish {@link Restarter} initialization when application logging is
	 * available.
	 */
	void finish() {
		synchronized (this.monitor) {
			if (!isFinished()) {
				this.logger = DeferredLog.replay(this.logger, LogFactory.getLog(getClass()));
				this.finished = true;
			}
		}
	}
	boolean isFinished() {
		synchronized (this.monitor) {
			return this.finished;
		}
	}
	void prepare(ConfigurableApplicationContext applicationContext) {
		if (!this.enabled || (applicationContext != null && applicationContext.getParent() != null)) {
			return;
		}
		if (applicationContext instanceof GenericApplicationContext genericContext) {
			prepare(genericContext);
		}
		this.rootContexts.add(applicationContext);
	}
	void remove(ConfigurableApplicationContext applicationContext) {
		if (applicationContext != null) {
			this.rootContexts.remove(applicationContext);
		}
	}
	private void prepare(GenericApplicationContext applicationContext) {
		ResourceLoader resourceLoader = new ClassLoaderFilesResourcePatternResolver(applicationContext,
				this.classLoaderFiles);
		applicationContext.setResourceLoader(resourceLoader);
	}
	private LeakSafeThread getLeakSafeThread() {
		try {
			return this.leakSafeThreads.takeFirst();
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			throw new IllegalStateException(ex);
		}
	}
	public Object getOrAddAttribute(String name, final ObjectFactory<?> objectFactory) {
		Object value = this.attributes.get(name);
		if (value == null) {
			value = objectFactory.getObject();
			this.attributes.put(name, value);
		}
		return value;
	}
	public Object removeAttribute(String name) {
		return this.attributes.remove(name);
	}
	/**
	 * Return the initial set of URLs as configured by the {@link RestartInitializer}.
	 * @return the initial URLs or {@code null}
	 */
	public URL[] getInitialUrls() {
		return this.initialUrls;
	}
	/**
	 * Initialize and disable restart support.
	 */
	public static void disable() {
		initialize(NO_ARGS, false, RestartInitializer.NONE);
		getInstance().setEnabled(false);
	}
	/**
	 * Initialize restart support. See
	 * {@link #initialize(String[], boolean, RestartInitializer)} for details.
	 * @param args main application arguments
	 * @see #initialize(String[], boolean, RestartInitializer)
	 */
	public static void initialize(String[] args) {
		initialize(args, false, new DefaultRestartInitializer());
	}
	/**
	 * Initialize restart support. See
	 * {@link #initialize(String[], boolean, RestartInitializer)} for details.
	 * @param args main application arguments
	 * @param initializer the restart initializer
	 * @see #initialize(String[], boolean, RestartInitializer)
	 */
	public static void initialize(String[] args, RestartInitializer initializer) {
		initialize(args, false, initializer, true);
	}
	/**
	 * Initialize restart support. See
	 * {@link #initialize(String[], boolean, RestartInitializer)} for details.
	 * @param args main application arguments
	 * @param forceReferenceCleanup if forcing of soft/weak reference should happen on
	 * @see #initialize(String[], boolean, RestartInitializer)
	 */
	public static void initialize(String[] args, boolean forceReferenceCleanup) {
		initialize(args, forceReferenceCleanup, new DefaultRestartInitializer());
	}
	/**
	 * Initialize restart support. See
	 * {@link #initialize(String[], boolean, RestartInitializer, boolean)} for details.
	 * @param args main application arguments
	 * @param forceReferenceCleanup if forcing of soft/weak reference should happen on
	 * @param initializer the restart initializer
	 * @see #initialize(String[], boolean, RestartInitializer)
	 */
	public static void initialize(String[] args, boolean forceReferenceCleanup, RestartInitializer initializer) {
		initialize(args, forceReferenceCleanup, initializer, true);
	}
	/**
	 * Initialize restart support for the current application. Called automatically by
	 * {@link RestartApplicationListener} but can also be called directly if main
	 * application arguments are not the same as those passed to the
	 * {@link SpringApplication}.
	 * @param args main application arguments
	 * @param forceReferenceCleanup if forcing of soft/weak reference should happen on
	 * each restart. This will slow down restarts and is intended primarily for testing
	 * @param initializer the restart initializer
	 * @param restartOnInitialize if the restarter should be restarted immediately when
	 * the {@link RestartInitializer} returns non {@code null} results
	 */
	public static void initialize(String[] args, boolean forceReferenceCleanup, RestartInitializer initializer,
			boolean restartOnInitialize) {
		Restarter localInstance = null;
		synchronized (INSTANCE_MONITOR) {
			if (instance == null) {
				localInstance = new Restarter(Thread.currentThread(), args, forceReferenceCleanup, initializer);
				instance = localInstance;
			}
		}
		if (localInstance != null) {
			localInstance.initialize(restartOnInitialize);
		}
	}
	/**
	 * Return the active {@link Restarter} instance. Cannot be called before
	 * {@link #initialize(String[]) initialization}.
	 * @return the restarter
	 */
	public static Restarter getInstance() {
		synchronized (INSTANCE_MONITOR) {
			Assert.state(instance != null, 'Restarter has not been initialized');
			return instance;
		}
	}
	/**
	 * Set the restarter instance (useful for testing).
	 * @param instance the instance to set
	 */
	static void setInstance(Restarter instance) {
		synchronized (INSTANCE_MONITOR) {
			Restarter.instance = instance;
		}
	}
	/**
	 * Clear the instance. Primarily provided for tests and not usually used in
	 * application code.
	 */
	public static void clearInstance() {
		synchronized (INSTANCE_MONITOR) {
			instance = null;
		}
	}
	/**
	 * Thread that is created early so not to retain the {@link RestartClassLoader}.
	 */
	private class LeakSafeThread extends Thread {
		private Callable<?> callable;
		private Object result;
		LeakSafeThread() {
			setDaemon(false);
		}
		void call(Callable<?> callable) {
			this.callable = callable;
			start();
		}
		@SuppressWarnings('unchecked')
		<V> V callAndWait(Callable<V> callable) {
			this.callable = callable;
			start();
			try {
				join();
				return (V) this.result;
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
				throw new IllegalStateException(ex);
			}
		}
		@Override
		public void run() {
			// We are safe to refresh the ActionThread (and indirectly call
			// AccessController.getContext()) since our stack doesn"t include the
			// RestartClassLoader
			try {
				Restarter.this.leakSafeThreads.put(new LeakSafeThread());
				this.result = this.callable.call();
			}
			catch (Exception ex) {
				ex.printStackTrace();
				System.exit(1);
			}
		}
	}
	/**
	 * {@link ThreadFactory} that creates a leak safe thread.
	 */
	private final class LeakSafeThreadFactory implements ThreadFactory {
		@Override
		public Thread newThread(Runnable runnable) {
			return getLeakSafeThread().callAndWait(() -> {
				Thread thread = new Thread(runnable);
				thread.setContextClassLoader(Restarter.this.applicationClassLoader);
				return thread;
			});
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
final class ChangeableUrls implements Iterable<URL> {
	private static final Log logger = DevToolsLogFactory.getLog(ChangeableUrls.class);
	private final List<URL> urls;
	private ChangeableUrls(URL... urls) {
		DevToolsSettings settings = DevToolsSettings.get();
		List<URL> reloadableUrls = new ArrayList<>(urls.length);
		for (URL url : urls) {
			if ((settings.isRestartInclude(url) || isDirectoryUrl(url.toString())) && !settings.isRestartExclude(url)) {
				reloadableUrls.add(url);
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug('Matching URLs for reloading : ' + reloadableUrls);
		}
		this.urls = Collections.unmodifiableList(reloadableUrls);
	}
	private boolean isDirectoryUrl(String urlString) {
		return urlString.startsWith('file:') && urlString.endsWith('/');
	}
	@Override
	public Iterator<URL> iterator() {
		return this.urls.iterator();
	}
	int size() {
		return this.urls.size();
	}
	URL[] toArray() {
		return this.urls.toArray(new URL[0]);
	}
	List<URL> toList() {
		return Collections.unmodifiableList(this.urls);
	}
	@Override
	public String toString() {
		return this.urls.toString();
	}
	static ChangeableUrls fromClassLoader(ClassLoader classLoader) {
		List<URL> urls = new ArrayList<>();
		for (URL url : urlsFromClassLoader(classLoader)) {
			urls.add(url);
			urls.addAll(getUrlsFromClassPathOfJarManifestIfPossible(url));
		}
		return fromUrls(urls);
	}
	private static URL[] urlsFromClassLoader(ClassLoader classLoader) {
		if (classLoader instanceof URLClassLoader urlClassLoader) {
			return urlClassLoader.getURLs();
		}
		return Stream.of(ManagementFactory.getRuntimeMXBean().getClassPath().split(File.pathSeparator))
			.map(ChangeableUrls::toURL)
			.toArray(URL[]::new);
	}
	private static URL toURL(String classPathEntry) {
		try {
			return new File(classPathEntry).toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalArgumentException('URL could not be created from "' + classPathEntry + '"', ex);
		}
	}
	private static List<URL> getUrlsFromClassPathOfJarManifestIfPossible(URL url) {
		try {
			File file = new File(url.toURI());
			if (file.isFile()) {
				try (JarFile jarFile = new JarFile(file)) {
					try {
						return getUrlsFromManifestClassPathAttribute(url, jarFile);
					}
					catch (IOException ex) {
						throw new IllegalStateException(
								'Failed to read Class-Path attribute from manifest of jar ' + url, ex);
					}
				}
			}
		}
		catch (Exception ex) {
			// Assume it"s not a jar and continue
		}
		return Collections.emptyList();
	}
	private static List<URL> getUrlsFromManifestClassPathAttribute(URL jarUrl, JarFile jarFile) throws IOException {
		Manifest manifest = jarFile.getManifest();
		if (manifest == null) {
			return Collections.emptyList();
		}
		String classPath = manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH);
		if (!StringUtils.hasText(classPath)) {
			return Collections.emptyList();
		}
		String[] entries = StringUtils.delimitedListToStringArray(classPath, ' ');
		List<URL> urls = new ArrayList<>(entries.length);
		List<URL> nonExistentEntries = new ArrayList<>();
		for (String entry : entries) {
			try {
				URL referenced = new URL(jarUrl, entry);
				if (new File(referenced.getFile()).exists()) {
					urls.add(referenced);
				}
				else {
					referenced = new URL(jarUrl, URLDecoder.decode(entry, StandardCharsets.UTF_8));
					if (new File(referenced.getFile()).exists()) {
						urls.add(referenced);
					}
					else {
						nonExistentEntries.add(referenced);
					}
				}
			}
			catch (MalformedURLException ex) {
				throw new IllegalStateException('Class-Path attribute contains malformed URL', ex);
			}
		}
		if (!nonExistentEntries.isEmpty()) {
			logger.info(LogMessage.of(() -> 'The Class-Path manifest attribute in ' + jarFile.getName()
					+ ' referenced one or more files that do not exist: '
					+ StringUtils.collectionToCommaDelimitedString(nonExistentEntries)));
		}
		return urls;
	}
	static ChangeableUrls fromUrls(Collection<URL> urls) {
		return fromUrls(new ArrayList<>(urls).toArray(new URL[urls.size()]));
	}
	static ChangeableUrls fromUrls(URL... urls) {
		return new ChangeableUrls(urls);
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
public class DefaultRestartInitializer implements RestartInitializer {
	@Override
	public URL[] getInitialUrls(Thread thread) {
		if (!isMain(thread)) {
			return null;
		}
		if (!DevToolsEnablementDeducer.shouldEnable(thread)) {
			return null;
		}
		return getUrls(thread);
	}
	/**
	 * Returns if the thread is for a main invocation. By default {@link #isMain(Thread)
	 * checks the name of the thread} and {@link #isDevelopmentClassLoader(ClassLoader)
	 * the context classloader}.
	 * @param thread the thread to check
	 * @return {@code true} if the thread is a main invocation
	 * @see #isMainThread
	 * @see #isDevelopmentClassLoader(ClassLoader)
	 */
	protected boolean isMain(Thread thread) {
		return isMainThread(thread) && isDevelopmentClassLoader(thread.getContextClassLoader());
	}
	/**
	 * Returns whether the given {@code thread} is considered to be the main thread.
	 * @param thread the thread to check
	 * @return {@code true} if it"s the main thread, otherwise {@code false}
	 * @since 2.4.0
	 */
	protected boolean isMainThread(Thread thread) {
		return thread.getName().equals('main');
	}
	/**
	 * Returns whether the given {@code classLoader} is one that is typically used during
	 * development.
	 * @param classLoader the ClassLoader to check
	 * @return {@code true} if it"s a ClassLoader typically used during development,
	 * otherwise {@code false}
	 * @since 2.4.0
	 */
	protected boolean isDevelopmentClassLoader(ClassLoader classLoader) {
		return classLoader.getClass().getName().contains('AppClassLoader');
	}
	/**
	 * Return the URLs that should be used with initialization.
	 * @param thread the source thread
	 * @return the URLs
	 */
	protected URL[] getUrls(Thread thread) {
		return ChangeableUrls.fromClassLoader(thread.getContextClassLoader()).toArray();
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
@FunctionalInterface
public interface FailureHandler {
	/**
	 * {@link FailureHandler} that always aborts.
	 */
	FailureHandler NONE = (failure) -> Outcome.ABORT;
	/**
	 * Handle a run failure. Implementations may block, for example to wait until specific
	 * files are updated.
	 * @param failure the exception
	 * @return the outcome
	 */
	Outcome handle(Throwable failure);
	/**
	 * Various outcomes for the handler.
	 */
	enum Outcome {
		/**
		 * Abort the relaunch.
		 */
		ABORT,
		/**
		 * Try again to relaunch the application.
		 */
		RETRY
	}
}
/*
/**
package org.springframework.boot.devtools.restart;
/*
package org.springframework.boot.devtools.restart;
/**
public class RestartApplicationListener implements ApplicationListener<ApplicationEvent>, Ordered {
	private static final String ENABLED_PROPERTY = 'spring.devtools.restart.enabled';
	private static final Log logger = LogFactory.getLog(RestartApplicationListener.class);
	private int order = HIGHEST_PRECEDENCE;
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof ApplicationStartingEvent startingEvent) {
			onApplicationStartingEvent(startingEvent);
		}
		if (event instanceof ApplicationPreparedEvent preparedEvent) {
			onApplicationPreparedEvent(preparedEvent);
		}
		if (event instanceof ApplicationReadyEvent || event instanceof ApplicationFailedEvent) {
			Restarter.getInstance().finish();
		}
		if (event instanceof ApplicationFailedEvent failedEvent) {
			onApplicationFailedEvent(failedEvent);
		}
	}
	private void onApplicationStartingEvent(ApplicationStartingEvent event) {
		// It"s too early to use the Spring environment but we should still allow
		// users to disable restart using a System property.
		String enabled = System.getProperty(ENABLED_PROPERTY);
		RestartInitializer restartInitializer = null;
		if (enabled == null) {
			if (implicitlyEnableRestart()) {
				restartInitializer = new DefaultRestartInitializer();
			}
			else {
				logger.info('Restart disabled due to context in which it is running');
				Restarter.disable();
				return;
			}
		}
		else if (Boolean.parseBoolean(enabled)) {
			restartInitializer = new DefaultRestartInitializer() {
				@Override
				protected boolean isDevelopmentClassLoader(ClassLoader classLoader) {
					return true;
				}
			};
			logger.info(LogMessage.format(
					'Restart enabled irrespective of application packaging due to System property "%s" being set to true',
					ENABLED_PROPERTY));
		}
		if (restartInitializer != null) {
			String[] args = event.getArgs();
			boolean restartOnInitialize = !AgentReloader.isActive();
			if (!restartOnInitialize) {
				logger.info('Restart disabled due to an agent-based reloader being active');
			}
			Restarter.initialize(args, false, restartInitializer, restartOnInitialize);
		}
		else {
			logger.info(LogMessage.format('Restart disabled due to System property "%s" being set to false',
					ENABLED_PROPERTY));
			Restarter.disable();
		}
	}
	boolean implicitlyEnableRestart() {
		return DevToolsEnablementDeducer.shouldEnable(Thread.currentThread());
	}
	private void onApplicationPreparedEvent(ApplicationPreparedEvent event) {
		Restarter.getInstance().prepare(event.getApplicationContext());
	}
	private void onApplicationFailedEvent(ApplicationFailedEvent event) {
		Restarter.getInstance().remove(event.getApplicationContext());
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Set the order of the listener.
	 * @param order the order of the listener
	 */
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class MainMethod {
	private final Method method;
	MainMethod() {
		this(Thread.currentThread());
	}
	MainMethod(Thread thread) {
		Assert.notNull(thread, 'Thread must not be null');
		this.method = getMainMethod(thread);
	}
	private Method getMainMethod(Thread thread) {
		StackTraceElement[] stackTrace = thread.getStackTrace();
		for (int i = stackTrace.length - 1; i >= 0; i--) {
			StackTraceElement element = stackTrace[i];
			if ('main'.equals(element.getMethodName()) && !isLoaderClass(element.getClassName())) {
				Method method = getMainMethod(element);
				if (method != null) {
					return method;
				}
			}
		}
		throw new IllegalStateException('Unable to find main method');
	}
	private boolean isLoaderClass(String className) {
		return className.startsWith('org.springframework.boot.loader.');
	}
	private Method getMainMethod(StackTraceElement element) {
		try {
			Class<?> elementClass = Class.forName(element.getClassName());
			Method method = elementClass.getDeclaredMethod('main', String[].class);
			if (Modifier.isStatic(method.getModifiers())) {
				return method;
			}
		}
		catch (Exception ex) {
			// Ignore
		}
		return null;
	}
	/**
	 * Returns the actual main method.
	 * @return the main method
	 */
	Method getMethod() {
		return this.method;
	}
	/**
	 * Return the name of the declaring class.
	 * @return the declaring class name
	 */
	String getDeclaringClassName() {
		return this.method.getDeclaringClass().getName();
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
public class RestartScopeInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		applicationContext.getBeanFactory().registerScope('restart', new RestartScope());
	}
	/**
	 * {@link Scope} that stores beans as {@link Restarter} attributes.
	 */
	private static final class RestartScope implements Scope {
		@Override
		public Object get(String name, ObjectFactory<?> objectFactory) {
			return Restarter.getInstance().getOrAddAttribute(name, objectFactory);
		}
		@Override
		public Object remove(String name) {
			return Restarter.getInstance().removeAttribute(name);
		}
		@Override
		public void registerDestructionCallback(String name, Runnable callback) {
		}
		@Override
		public Object resolveContextualObject(String key) {
			return null;
		}
		@Override
		public String getConversationId() {
			return null;
		}
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
public abstract class AgentReloader {
	private static final Set<String> AGENT_CLASSES;
	static {
		Set<String> agentClasses = new LinkedHashSet<>();
		agentClasses.add('org.zeroturnaround.javarebel.Integration');
		agentClasses.add('org.zeroturnaround.javarebel.ReloaderFactory');
		agentClasses.add('org.hotswap.agent.HotswapAgent');
		AGENT_CLASSES = Collections.unmodifiableSet(agentClasses);
	}
	private AgentReloader() {
	}
	/**
	 * Determine if any agent reloader is active.
	 * @return true if agent reloading is active
	 */
	public static boolean isActive() {
		return isActive(null) || isActive(AgentReloader.class.getClassLoader())
				|| isActive(ClassLoader.getSystemClassLoader());
	}
	private static boolean isActive(ClassLoader classLoader) {
		for (String agentClass : AGENT_CLASSES) {
			if (ClassUtils.isPresent(agentClass, classLoader)) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.devtools.restart;
/**
class SilentExitExceptionHandler implements UncaughtExceptionHandler {
	private final UncaughtExceptionHandler delegate;
	SilentExitExceptionHandler(UncaughtExceptionHandler delegate) {
		this.delegate = delegate;
	}
	@Override
	public void uncaughtException(Thread thread, Throwable exception) {
		if (exception instanceof SilentExitException || (exception instanceof InvocationTargetException targetException
				&& targetException.getTargetException() instanceof SilentExitException)) {
			if (isJvmExiting(thread)) {
				preventNonZeroExitCode();
			}
			return;
		}
		if (this.delegate != null) {
			this.delegate.uncaughtException(thread, exception);
		}
	}
	private boolean isJvmExiting(Thread exceptionThread) {
		for (Thread thread : getAllThreads()) {
			if (thread != exceptionThread && thread.isAlive() && !thread.isDaemon()) {
				return false;
			}
		}
		return true;
	}
	protected Thread[] getAllThreads() {
		ThreadGroup rootThreadGroup = getRootThreadGroup();
		Thread[] threads = new Thread[32];
		int count = rootThreadGroup.enumerate(threads);
		while (count == threads.length) {
			threads = new Thread[threads.length * 2];
			count = rootThreadGroup.enumerate(threads);
		}
		return Arrays.copyOf(threads, count);
	}
	private ThreadGroup getRootThreadGroup() {
		ThreadGroup candidate = Thread.currentThread().getThreadGroup();
		while (candidate.getParent() != null) {
			candidate = candidate.getParent();
		}
		return candidate;
	}
	protected void preventNonZeroExitCode() {
		System.exit(0);
	}
	static void setup(Thread thread) {
		UncaughtExceptionHandler handler = thread.getUncaughtExceptionHandler();
		if (!(handler instanceof SilentExitExceptionHandler)) {
			handler = new SilentExitExceptionHandler(handler);
			thread.setUncaughtExceptionHandler(handler);
		}
	}
	static void exitCurrentThread() {
		throw new SilentExitException();
	}
	private static final class SilentExitException extends RuntimeException {
	}
}
/*
package org.springframework.boot.devtools;
/**
public final class RemoteSpringApplication {
	private RemoteSpringApplication() {
	}
	private void run(String[] args) {
		Restarter.initialize(args, RestartInitializer.NONE);
		SpringApplication application = new SpringApplication(RemoteClientConfiguration.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setBanner(getBanner());
		application.setInitializers(getInitializers());
		application.setListeners(getListeners());
		application.run(args);
		waitIndefinitely();
	}
	private Collection<ApplicationContextInitializer<?>> getInitializers() {
		List<ApplicationContextInitializer<?>> initializers = new ArrayList<>();
		initializers.add(new RestartScopeInitializer());
		return initializers;
	}
	private Collection<ApplicationListener<?>> getListeners() {
		List<ApplicationListener<?>> listeners = new ArrayList<>();
		listeners.add(new AnsiOutputApplicationListener());
		listeners.add(EnvironmentPostProcessorApplicationListener
			.with(EnvironmentPostProcessorsFactory.of(ConfigDataEnvironmentPostProcessor.class)));
		listeners.add(new LoggingApplicationListener());
		listeners.add(new RemoteUrlPropertyExtractor());
		return listeners;
	}
	private Banner getBanner() {
		ClassPathResource banner = new ClassPathResource('remote-banner.txt', RemoteSpringApplication.class);
		return new ResourceBanner(banner);
	}
	private void waitIndefinitely() {
		while (true) {
			try {
				Thread.sleep(1000);
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
	}
	/**
	 * Run the {@link RemoteSpringApplication}.
	 * @param args the program arguments (including the remote URL as a non-option
	 * argument)
	 */
	public static void main(String[] args) {
		new RemoteSpringApplication().run(args);
	}
}
/*
/**
package org.springframework.boot.devtools;
/*
package org.springframework.boot.devtools.settings;
/**
public class DevToolsSettings {
	/**
	 * The location to look for settings properties. Can be present in multiple JAR files.
	 */
	public static final String SETTINGS_RESOURCE_LOCATION = 'META-INF/spring-devtools.properties';
	private static final Log logger = DevToolsLogFactory.getLog(DevToolsSettings.class);
	private static DevToolsSettings settings;
	private final List<Pattern> restartIncludePatterns = new ArrayList<>();
	private final List<Pattern> restartExcludePatterns = new ArrayList<>();
	DevToolsSettings() {
	}
	void add(Map<?, ?> properties) {
		Map<String, Pattern> includes = getPatterns(properties, 'restart.include.');
		this.restartIncludePatterns.addAll(includes.values());
		Map<String, Pattern> excludes = getPatterns(properties, 'restart.exclude.');
		this.restartExcludePatterns.addAll(excludes.values());
	}
	private Map<String, Pattern> getPatterns(Map<?, ?> properties, String prefix) {
		Map<String, Pattern> patterns = new LinkedHashMap<>();
		properties.forEach((key, value) -> {
			String name = String.valueOf(key);
			if (name.startsWith(prefix)) {
				Pattern pattern = Pattern.compile((String) value);
				patterns.put(name, pattern);
			}
		});
		return patterns;
	}
	public boolean isRestartInclude(URL url) {
		return isMatch(url.toString(), this.restartIncludePatterns);
	}
	public boolean isRestartExclude(URL url) {
		return isMatch(url.toString(), this.restartExcludePatterns);
	}
	private boolean isMatch(String url, List<Pattern> patterns) {
		for (Pattern pattern : patterns) {
			if (pattern.matcher(url).find()) {
				return true;
			}
		}
		return false;
	}
	public static DevToolsSettings get() {
		if (settings == null) {
			settings = load();
		}
		return settings;
	}
	static DevToolsSettings load() {
		return load(SETTINGS_RESOURCE_LOCATION);
	}
	static DevToolsSettings load(String location) {
		try {
			DevToolsSettings settings = new DevToolsSettings();
			Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(location);
			while (urls.hasMoreElements()) {
				settings.add(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement())));
			}
			if (logger.isDebugEnabled()) {
				logger.debug('Included patterns for restart : ' + settings.restartIncludePatterns);
				logger.debug('Excluded patterns for restart : ' + settings.restartExcludePatterns);
			}
			return settings;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to load devtools settings from location [' + location + ']', ex);
		}
	}
}
/*
/**
package org.springframework.boot.devtools.settings;
/*
package org.springframework.boot.devtools.env;
/**
public class DevToolsHomePropertiesPostProcessor implements EnvironmentPostProcessor {
	private static final String LEGACY_FILE_NAME = '.spring-boot-devtools.properties';
	private static final String[] FILE_NAMES = new String[] { 'spring-boot-devtools.yml', 'spring-boot-devtools.yaml',
			'spring-boot-devtools.properties' };
	private static final String CONFIG_PATH = '/.config/spring-boot/';
	private static final Set<PropertySourceLoader> PROPERTY_SOURCE_LOADERS;
	private final Properties systemProperties;
	private final Map<String, String> environmentVariables;
	static {
		Set<PropertySourceLoader> propertySourceLoaders = new HashSet<>();
		propertySourceLoaders.add(new PropertiesPropertySourceLoader());
		if (ClassUtils.isPresent('org.yaml.snakeyaml.Yaml', null)) {
			propertySourceLoaders.add(new YamlPropertySourceLoader());
		}
		PROPERTY_SOURCE_LOADERS = Collections.unmodifiableSet(propertySourceLoaders);
	}
	public DevToolsHomePropertiesPostProcessor() {
		this(System.getenv(), System.getProperties());
	}
	DevToolsHomePropertiesPostProcessor(Map<String, String> environmentVariables, Properties systemProperties) {
		this.environmentVariables = environmentVariables;
		this.systemProperties = systemProperties;
	}
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		if (DevToolsEnablementDeducer.shouldEnable(Thread.currentThread())) {
			List<PropertySource<?>> propertySources = getPropertySources();
			if (propertySources.isEmpty()) {
				addPropertySource(propertySources, LEGACY_FILE_NAME, (file) -> 'devtools-local');
			}
			propertySources.forEach(environment.getPropertySources()::addFirst);
		}
	}
	private List<PropertySource<?>> getPropertySources() {
		List<PropertySource<?>> propertySources = new ArrayList<>();
		for (String fileName : FILE_NAMES) {
			addPropertySource(propertySources, CONFIG_PATH + fileName, this::getPropertySourceName);
		}
		return propertySources;
	}
	private String getPropertySourceName(File file) {
		return 'devtools-local: [' + file.toURI() + ']';
	}
	private void addPropertySource(List<PropertySource<?>> propertySources, String fileName,
			Function<File, String> propertySourceNamer) {
		File home = getHomeDirectory();
		File file = (home != null) ? new File(home, fileName) : null;
		FileSystemResource resource = (file != null) ? new FileSystemResource(file) : null;
		if (resource != null && resource.exists() && resource.isFile()) {
			addPropertySource(propertySources, resource, propertySourceNamer);
		}
	}
	private void addPropertySource(List<PropertySource<?>> propertySources, FileSystemResource resource,
			Function<File, String> propertySourceNamer) {
		try {
			String name = propertySourceNamer.apply(resource.getFile());
			for (PropertySourceLoader loader : PROPERTY_SOURCE_LOADERS) {
				if (canLoadFileExtension(loader, resource.getFilename())) {
					propertySources.addAll(loader.load(name, resource));
				}
			}
		}
		catch (IOException ex) {
			throw new IllegalStateException('Unable to load ' + resource.getFilename(), ex);
		}
	}
	private boolean canLoadFileExtension(PropertySourceLoader loader, String name) {
		return Arrays.stream(loader.getFileExtensions())
			.anyMatch((fileExtension) -> StringUtils.endsWithIgnoreCase(name, fileExtension));
	}
	protected File getHomeDirectory() {
		return getHomeDirectory(() -> this.environmentVariables.get('SPRING_DEVTOOLS_HOME'),
				() -> this.systemProperties.getProperty('spring.devtools.home'),
				() -> this.systemProperties.getProperty('user.home'));
	}
	@SafeVarargs
	private File getHomeDirectory(Supplier<String>... pathSuppliers) {
		for (Supplier<String> pathSupplier : pathSuppliers) {
			String path = pathSupplier.get();
			if (StringUtils.hasText(path)) {
				return new File(path);
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.devtools.env;
/**
@Order(Ordered.LOWEST_PRECEDENCE)
public class DevToolsPropertyDefaultsPostProcessor implements EnvironmentPostProcessor {
	private static final Log logger = DevToolsLogFactory.getLog(DevToolsPropertyDefaultsPostProcessor.class);
	private static final String ENABLED = 'spring.devtools.add-properties';
	private static final String WEB_LOGGING = 'logging.level.web';
	private static final String[] WEB_ENVIRONMENT_CLASSES = {
			'org.springframework.web.context.ConfigurableWebEnvironment',
			'org.springframework.boot.web.reactive.context.ConfigurableReactiveWebEnvironment' };
	private static final Map<String, Object> PROPERTIES;
	static {
		if (NativeDetector.inNativeImage()) {
			PROPERTIES = Collections.emptyMap();
		}
		else {
			PROPERTIES = loadDefaultProperties();
		}
	}
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		if (DevToolsEnablementDeducer.shouldEnable(Thread.currentThread()) && isLocalApplication(environment)) {
			if (canAddProperties(environment)) {
				logger.info(LogMessage.format('Devtools property defaults active! Set "%s" to "false" to disable',
						ENABLED));
				environment.getPropertySources().addLast(new MapPropertySource('devtools', PROPERTIES));
			}
			if (isWebApplication(environment) && !environment.containsProperty(WEB_LOGGING)) {
				logger.info(LogMessage.format(
						'For additional web related logging consider setting the "%s" property to "DEBUG"',
						WEB_LOGGING));
			}
		}
	}
	private boolean isLocalApplication(ConfigurableEnvironment environment) {
		return environment.getPropertySources().get('remoteUrl') == null;
	}
	private boolean canAddProperties(Environment environment) {
		if (environment.getProperty(ENABLED, Boolean.class, true)) {
			return isRestarterInitialized() || isRemoteRestartEnabled(environment);
		}
		return false;
	}
	private boolean isRestarterInitialized() {
		try {
			Restarter restarter = Restarter.getInstance();
			return (restarter != null && restarter.getInitialUrls() != null);
		}
		catch (Exception ex) {
			return false;
		}
	}
	private boolean isRemoteRestartEnabled(Environment environment) {
		return environment.containsProperty('spring.devtools.remote.secret');
	}
	private boolean isWebApplication(Environment environment) {
		for (String candidate : WEB_ENVIRONMENT_CLASSES) {
			Class<?> environmentClass = resolveClassName(candidate, environment.getClass().getClassLoader());
			if (environmentClass != null && environmentClass.isInstance(environment)) {
				return true;
			}
		}
		return false;
	}
	private Class<?> resolveClassName(String candidate, ClassLoader classLoader) {
		try {
			return ClassUtils.resolveClassName(candidate, classLoader);
		}
		catch (IllegalArgumentException ex) {
			return null;
		}
	}
	private static Map<String, Object> loadDefaultProperties() {
		Properties properties = new Properties();
		try (InputStream stream = DevToolsPropertyDefaultsPostProcessor.class
			.getResourceAsStream('devtools-property-defaults.properties')) {
			if (stream == null) {
				throw new RuntimeException(
						'Failed to load devtools-property-defaults.properties because it doesn"t exist');
			}
			properties.load(stream);
		}
		catch (IOException ex) {
			throw new RuntimeException('Failed to load devtools-property-defaults.properties', ex);
		}
		Map<String, Object> map = new HashMap<>();
		for (String name : properties.stringPropertyNames()) {
			map.put(name, properties.getProperty(name));
		}
		return Collections.unmodifiableMap(map);
	}
}
/*
/**
package org.springframework.boot.devtools.env;
/*
package org.springframework.boot.devtools.tests;
/**
public interface ApplicationLauncher {
	LaunchedApplication launchApplication(JvmLauncher javaLauncher, File serverPortFile) throws Exception;
	LaunchedApplication launchApplication(JvmLauncher jvmLauncher, File serverPortFile, String... additionalArgs)
			throws Exception;
}
/*
package org.springframework.boot.devtools.tests;
/**
public class ExplodedRemoteApplicationLauncher extends RemoteApplicationLauncher {
	public ExplodedRemoteApplicationLauncher(Directories directories) {
		super(directories);
	}
	@Override
	protected String createApplicationClassPath() throws Exception {
		File appDirectory = getDirectories().getAppDirectory();
		copyApplicationTo(appDirectory);
		List<String> entries = new ArrayList<>();
		entries.add(appDirectory.getAbsolutePath());
		entries.addAll(getDependencyJarPaths());
		return StringUtils.collectionToDelimitedString(entries, File.pathSeparator);
	}
	@Override
	public String toString() {
		return 'exploded remote';
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
abstract class AbstractDevToolsIntegrationTests {
	protected static final BuildOutput buildOutput = new BuildOutput(AbstractDevToolsIntegrationTests.class);
	protected final File serverPortFile = new File(buildOutput.getRootLocation(), 'server.port');
	@RegisterExtension
	protected final JvmLauncher javaLauncher = new JvmLauncher();
	@TempDir
	protected static File temp;
	protected LaunchedApplication launchedApplication;
	protected void launchApplication(ApplicationLauncher applicationLauncher, String... args) throws Exception {
		this.serverPortFile.delete();
		this.launchedApplication = applicationLauncher.launchApplication(this.javaLauncher, this.serverPortFile, args);
	}
	@AfterEach
	void stopApplication() throws InterruptedException {
		this.launchedApplication.stop();
	}
	protected int awaitServerPort() throws Exception {
		int port = Awaitility.waitAtMost(Duration.ofMinutes(3))
			.until(() -> new ApplicationState(this.serverPortFile, this.launchedApplication),
					ApplicationState::hasServerPort)
			.getServerPort();
		this.serverPortFile.delete();
		this.launchedApplication.restartRemote(port);
		Thread.sleep(1000);
		return port;
	}
	protected ControllerBuilder controller(String name) {
		return new ControllerBuilder(name, this.launchedApplication.getClassesDirectory());
	}
	protected static final class ControllerBuilder {
		private final List<String> mappings = new ArrayList<>();
		private final String name;
		private final File classesDirectory;
		protected ControllerBuilder(String name, File classesDirectory) {
			this.name = name;
			this.classesDirectory = classesDirectory;
		}
		protected ControllerBuilder withRequestMapping(String mapping) {
			this.mappings.add(mapping);
			return this;
		}
		protected void build() throws Exception {
			DynamicType.Builder<Object> builder = new ByteBuddy().subclass(Object.class)
				.name(this.name)
				.annotateType(AnnotationDescription.Builder.ofType(RestController.class).build());
			for (String mapping : this.mappings) {
				builder = builder.defineMethod(mapping, String.class, Visibility.PUBLIC)
					.intercept(FixedValue.value(mapping))
					.annotateMethod(AnnotationDescription.Builder.ofType(RequestMapping.class)
						.defineArray('value', mapping)
						.build());
			}
			builder.make().saveIn(this.classesDirectory);
		}
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
class DevToolsWithLazyInitializationIntegrationTests extends AbstractDevToolsIntegrationTests {
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void addARequestMappingToAnExistingControllerWhenLazyInit(ApplicationLauncher applicationLauncher)
			throws Exception {
		launchApplication(applicationLauncher, '--spring.main.lazy-initialization=true');
		TestRestTemplate template = new TestRestTemplate();
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(template.getForEntity(urlBase + '/two', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
		controller('com.example.ControllerOne').withRequestMapping('one').withRequestMapping('two').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(template.getForObject(urlBase + '/two', String.class)).isEqualTo('two');
	}
	static Object[] parameters() {
		Directories directories = new Directories(buildOutput, temp);
		return new Object[] { new Object[] { new LocalApplicationLauncher(directories) },
				new Object[] { new ExplodedRemoteApplicationLauncher(directories) },
				new Object[] { new JarFileRemoteApplicationLauncher(directories) } };
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
class DevToolsIntegrationTests extends AbstractDevToolsIntegrationTests {
	private final TestRestTemplate template = new TestRestTemplate(new RestTemplateBuilder()
		.requestFactory(() -> new HttpComponentsClientHttpRequestFactory(HttpClients.custom()
			.setRetryStrategy(new DefaultHttpRequestRetryStrategy(10, TimeValue.of(1, TimeUnit.SECONDS)))
			.build())));
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void addARequestMappingToAnExistingController(ApplicationLauncher applicationLauncher) throws Exception {
		launchApplication(applicationLauncher);
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForEntity(urlBase + '/two', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
		controller('com.example.ControllerOne').withRequestMapping('one').withRequestMapping('two').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForObject(urlBase + '/two', String.class)).isEqualTo('two');
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void removeARequestMappingFromAnExistingController(ApplicationLauncher applicationLauncher) throws Exception {
		launchApplication(applicationLauncher);
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		controller('com.example.ControllerOne').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForEntity(urlBase + '/one', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void createAController(ApplicationLauncher applicationLauncher) throws Exception {
		launchApplication(applicationLauncher);
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForEntity(urlBase + '/two', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
		controller('com.example.ControllerTwo').withRequestMapping('two').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForObject(urlBase + '/two', String.class)).isEqualTo('two');
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void createAControllerAndThenAddARequestMapping(ApplicationLauncher applicationLauncher) throws Exception {
		launchApplication(applicationLauncher);
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForEntity(urlBase + '/two', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
		controller('com.example.ControllerTwo').withRequestMapping('two').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForObject(urlBase + '/two', String.class)).isEqualTo('two');
		controller('com.example.ControllerTwo').withRequestMapping('two').withRequestMapping('three').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/three', String.class)).isEqualTo('three');
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void createAControllerAndThenAddARequestMappingToAnExistingController(ApplicationLauncher applicationLauncher)
			throws Exception {
		launchApplication(applicationLauncher);
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForEntity(urlBase + '/two', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
		controller('com.example.ControllerTwo').withRequestMapping('two').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForObject(urlBase + '/two', String.class)).isEqualTo('two');
		controller('com.example.ControllerOne').withRequestMapping('one').withRequestMapping('three').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForObject(urlBase + '/two', String.class)).isEqualTo('two');
		assertThat(this.template.getForObject(urlBase + '/three', String.class)).isEqualTo('three');
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void deleteAController(ApplicationLauncher applicationLauncher) throws Exception {
		launchApplication(applicationLauncher);
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(new File(this.launchedApplication.getClassesDirectory(), 'com/example/ControllerOne.class').delete())
			.isTrue();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForEntity(urlBase + '/one', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('parameters')
	void createAControllerAndThenDeleteIt(ApplicationLauncher applicationLauncher) throws Exception {
		launchApplication(applicationLauncher);
		String urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForEntity(urlBase + '/two', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
		controller('com.example.ControllerTwo').withRequestMapping('two').build();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForObject(urlBase + '/one', String.class)).isEqualTo('one');
		assertThat(this.template.getForObject(urlBase + '/two', String.class)).isEqualTo('two');
		assertThat(new File(this.launchedApplication.getClassesDirectory(), 'com/example/ControllerTwo.class').delete())
			.isTrue();
		urlBase = 'http://localhost:' + awaitServerPort();
		assertThat(this.template.getForEntity(urlBase + '/two', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
	}
	static Object[] parameters() {
		Directories directories = new Directories(buildOutput, temp);
		return new Object[] { new Object[] { new LocalApplicationLauncher(directories) },
				new Object[] { new ExplodedRemoteApplicationLauncher(directories) },
				new Object[] { new JarFileRemoteApplicationLauncher(directories) } };
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
public class JarFileRemoteApplicationLauncher extends RemoteApplicationLauncher {
	public JarFileRemoteApplicationLauncher(Directories directories) {
		super(directories);
	}
	@Override
	protected String createApplicationClassPath() throws Exception {
		File appDirectory = getDirectories().getAppDirectory();
		copyApplicationTo(appDirectory);
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, '1.0');
		File appJar = new File(appDirectory, 'app.jar');
		JarOutputStream output = new JarOutputStream(new FileOutputStream(appJar), manifest);
		addToJar(output, appDirectory, appDirectory);
		output.close();
		List<String> entries = new ArrayList<>();
		entries.add(appJar.getAbsolutePath());
		entries.addAll(getDependencyJarPaths());
		String classpath = StringUtils.collectionToDelimitedString(entries, File.pathSeparator);
		return classpath;
	}
	private void addToJar(JarOutputStream output, File root, File current) throws IOException {
		for (File file : current.listFiles()) {
			if (file.isDirectory()) {
				addToJar(output, root, file);
			}
			output.putNextEntry(new ZipEntry(
					file.getAbsolutePath().substring(root.getAbsolutePath().length() + 1).replace('\\', '/')
							+ (file.isDirectory() ? '/' : '')));
			if (file.isFile()) {
				try (FileInputStream input = new FileInputStream(file)) {
					StreamUtils.copy(input, output);
				}
			}
			output.closeEntry();
		}
	}
	@Override
	public String toString() {
		return 'jar file remote';
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
abstract class RemoteApplicationLauncher extends AbstractApplicationLauncher {
	RemoteApplicationLauncher(Directories directories) {
		super(directories);
	}
	@Override
	public LaunchedApplication launchApplication(JvmLauncher javaLauncher, File serverPortFile) throws Exception {
		LaunchedJvm applicationJvm = javaLauncher.launch('app', createApplicationClassPath(),
				'com.example.DevToolsTestApplication', serverPortFile.getAbsolutePath(), '--server.port=0',
				'--spring.devtools.remote.secret=secret');
		int port = awaitServerPort(applicationJvm, serverPortFile);
		BiFunction<Integer, File, Process> remoteRestarter = getRemoteRestarter(javaLauncher);
		return new LaunchedApplication(getDirectories().getRemoteAppDirectory(), applicationJvm.getStandardOut(),
				applicationJvm.getStandardError(), applicationJvm.getProcess(), remoteRestarter.apply(port, null),
				remoteRestarter);
	}
	@Override
	public LaunchedApplication launchApplication(JvmLauncher javaLauncher, File serverPortFile,
			String... additionalArgs) throws Exception {
		List<String> args = new ArrayList<>(Arrays.asList('com.example.DevToolsTestApplication',
				serverPortFile.getAbsolutePath(), '--server.port=0', '--spring.devtools.remote.secret=secret'));
		args.addAll(Arrays.asList(additionalArgs));
		LaunchedJvm applicationJvm = javaLauncher.launch('app', createApplicationClassPath(),
				args.toArray(new String[] {}));
		int port = awaitServerPort(applicationJvm, serverPortFile);
		BiFunction<Integer, File, Process> remoteRestarter = getRemoteRestarter(javaLauncher);
		return new LaunchedApplication(getDirectories().getRemoteAppDirectory(), applicationJvm.getStandardOut(),
				applicationJvm.getStandardError(), applicationJvm.getProcess(), remoteRestarter.apply(port, null),
				remoteRestarter);
	}
	private BiFunction<Integer, File, Process> getRemoteRestarter(JvmLauncher javaLauncher) {
		return (port, classesDirectory) -> {
			try {
				LaunchedJvm remoteSpringApplicationJvm = javaLauncher.launch('remote-spring-application',
						createRemoteSpringApplicationClassPath(classesDirectory),
						RemoteSpringApplication.class.getName(), '--spring.devtools.remote.secret=secret',
						'http://localhost:' + port);
				awaitRemoteSpringApplication(remoteSpringApplicationJvm);
				return remoteSpringApplicationJvm.getProcess();
			}
			catch (Exception ex) {
				throw new IllegalStateException(ex);
			}
		};
	}
	protected abstract String createApplicationClassPath() throws Exception;
	private String createRemoteSpringApplicationClassPath(File classesDirectory) throws Exception {
		File remoteAppDirectory = getDirectories().getRemoteAppDirectory();
		if (classesDirectory == null) {
			copyApplicationTo(remoteAppDirectory);
		}
		List<String> entries = new ArrayList<>();
		entries.add(remoteAppDirectory.getAbsolutePath());
		entries.addAll(getDependencyJarPaths());
		return StringUtils.collectionToDelimitedString(entries, File.pathSeparator);
	}
	private int awaitServerPort(LaunchedJvm jvm, File serverPortFile) {
		return Awaitility.waitAtMost(Duration.ofMinutes(3))
			.until(() -> new ApplicationState(serverPortFile, jvm), ApplicationState::hasServerPort)
			.getServerPort();
	}
	private void awaitRemoteSpringApplication(LaunchedJvm launchedJvm) {
		FileContents contents = new FileContents(launchedJvm.getStandardOut());
		try {
			Awaitility.waitAtMost(Duration.ofMinutes(3))
				.until(contents::get, containsString('Started RemoteSpringApplication'));
		}
		catch (ConditionTimeoutException ex) {
			if (!launchedJvm.getProcess().isAlive()) {
				throw new IllegalStateException(
						'Process exited with status ' + launchedJvm.getProcess().exitValue()
								+ ' before producing expected standard output.\n\nStandard output:\n\n' + contents.get()
								+ '\n\nStandard error:\n\n' + new FileContents(launchedJvm.getStandardError()).get(),
						ex);
			}
			throw ex;
		}
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
class FileContents {
	private final File file;
	FileContents(File file) {
		this.file = file;
	}
	String get() {
		return get(Function.identity());
	}
	<T> T get(Function<String, T> transformer) {
		if ((!this.file.exists()) || this.file.length() == 0) {
			return null;
		}
		try {
			return transformer.apply(FileCopyUtils.copyToString(new FileReader(this.file)));
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	@Override
	public String toString() {
		return get();
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
abstract class AbstractApplicationLauncher implements ApplicationLauncher {
	private final Directories directories;
	AbstractApplicationLauncher(Directories directories) {
		this.directories = directories;
	}
	protected final void copyApplicationTo(File location) throws IOException {
		FileSystemUtils.deleteRecursively(location);
		location.mkdirs();
		FileSystemUtils.copyRecursively(new File(this.directories.getTestClassesDirectory(), 'com'),
				new File(location, 'com'));
	}
	protected final List<String> getDependencyJarPaths() {
		return Stream.of(this.directories.getDependenciesDirectory().listFiles()).map(File::getAbsolutePath).toList();
	}
	protected final Directories getDirectories() {
		return this.directories;
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
class LaunchedApplication {
	private final File classesDirectory;
	private final File standardOut;
	private final File standardError;
	private final Process localProcess;
	private Process remoteProcess;
	private final Instant launchTime = Instant.now();
	private final BiFunction<Integer, File, Process> remoteProcessRestarter;
	LaunchedApplication(File classesDirectory, File standardOut, File standardError, Process localProcess,
			Process remoteProcess, BiFunction<Integer, File, Process> remoteProcessRestarter) {
		this.classesDirectory = classesDirectory;
		this.standardOut = standardOut;
		this.standardError = standardError;
		this.localProcess = localProcess;
		this.remoteProcess = remoteProcess;
		this.remoteProcessRestarter = remoteProcessRestarter;
	}
	void restartRemote(int port) throws InterruptedException {
		if (this.remoteProcessRestarter != null) {
			stop(this.remoteProcess);
			this.remoteProcess = this.remoteProcessRestarter.apply(port, this.classesDirectory);
		}
	}
	void stop() throws InterruptedException {
		stop(this.localProcess);
		stop(this.remoteProcess);
	}
	private void stop(Process process) throws InterruptedException {
		if (process != null) {
			process.destroy();
			process.waitFor();
		}
	}
	File getStandardOut() {
		return this.standardOut;
	}
	File getStandardError() {
		return this.standardError;
	}
	File getClassesDirectory() {
		return this.classesDirectory;
	}
	Instant getLaunchTime() {
		return this.launchTime;
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
final class ApplicationState {
	private final Instant launchTime;
	private final Integer serverPort;
	private final FileContents out;
	private final FileContents err;
	ApplicationState(File serverPortFile, LaunchedJvm jvm) {
		this(serverPortFile, jvm.getStandardOut(), jvm.getStandardError(), jvm.getLaunchTime());
	}
	ApplicationState(File serverPortFile, LaunchedApplication application) {
		this(serverPortFile, application.getStandardOut(), application.getStandardError(), application.getLaunchTime());
	}
	private ApplicationState(File serverPortFile, File out, File err, Instant launchTime) {
		this.serverPort = new FileContents(serverPortFile).get(Integer::parseInt);
		this.out = new FileContents(out);
		this.err = new FileContents(err);
		this.launchTime = launchTime;
	}
	boolean hasServerPort() {
		return this.serverPort != null;
	}
	int getServerPort() {
		return this.serverPort;
	}
	@Override
	public String toString() {
		return String.format('Application launched at %s produced output:%n%s%n%s', this.launchTime, this.out,
				this.err);
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
public class LocalApplicationLauncher extends AbstractApplicationLauncher {
	LocalApplicationLauncher(Directories directories) {
		super(directories);
	}
	@Override
	public LaunchedApplication launchApplication(JvmLauncher jvmLauncher, File serverPortFile) throws Exception {
		LaunchedJvm jvm = jvmLauncher.launch('local', createApplicationClassPath(),
				'com.example.DevToolsTestApplication', serverPortFile.getAbsolutePath(), '--server.port=0');
		return new LaunchedApplication(getDirectories().getAppDirectory(), jvm.getStandardOut(), jvm.getStandardError(),
				jvm.getProcess(), null, null);
	}
	@Override
	public LaunchedApplication launchApplication(JvmLauncher jvmLauncher, File serverPortFile, String... additionalArgs)
			throws Exception {
		List<String> args = new ArrayList<>(Arrays.asList('com.example.DevToolsTestApplication',
				serverPortFile.getAbsolutePath(), '--server.port=0'));
		args.addAll(Arrays.asList(additionalArgs));
		LaunchedJvm jvm = jvmLauncher.launch('local', createApplicationClassPath(), args.toArray(new String[] {}));
		return new LaunchedApplication(getDirectories().getAppDirectory(), jvm.getStandardOut(), jvm.getStandardError(),
				jvm.getProcess(), null, null);
	}
	protected String createApplicationClassPath() throws Exception {
		File appDirectory = getDirectories().getAppDirectory();
		copyApplicationTo(appDirectory);
		List<String> entries = new ArrayList<>();
		entries.add(appDirectory.getAbsolutePath());
		entries.addAll(getDependencyJarPaths());
		return StringUtils.collectionToDelimitedString(entries, File.pathSeparator);
	}
	@Override
	public String toString() {
		return 'local';
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
class JvmLauncher implements BeforeTestExecutionCallback {
	private static final Pattern NON_ALPHABET_PATTERN = Pattern.compile('[^A-Za-z]+');
	private final BuildOutput buildOutput = new BuildOutput(getClass());
	private File outputDirectory;
	@Override
	public void beforeTestExecution(ExtensionContext context) throws Exception {
		this.outputDirectory = new File(this.buildOutput.getRootLocation(),
				'output/' + NON_ALPHABET_PATTERN.matcher(context.getRequiredTestMethod().getName()).replaceAll(''));
		this.outputDirectory.mkdirs();
	}
	LaunchedJvm launch(String name, String classpath, String... args) throws IOException {
		List<String> command = new ArrayList<>(
				Arrays.asList(System.getProperty('java.home') + '/bin/java', '-cp', classpath));
		command.addAll(Arrays.asList(args));
		File standardOut = new File(this.outputDirectory, name + '.out');
		File standardError = new File(this.outputDirectory, name + '.err');
		Process process = new ProcessBuilder(StringUtils.toStringArray(command)).redirectError(standardError)
			.redirectOutput(standardOut)
			.start();
		return new LaunchedJvm(process, standardOut, standardError);
	}
	static class LaunchedJvm {
		private final Process process;
		private final Instant launchTime = Instant.now();
		private final File standardOut;
		private final File standardError;
		LaunchedJvm(Process process, File standardOut, File standardError) {
			this.process = process;
			this.standardOut = standardOut;
			this.standardError = standardError;
		}
		Process getProcess() {
			return this.process;
		}
		Instant getLaunchTime() {
			return this.launchTime;
		}
		File getStandardOut() {
			return this.standardOut;
		}
		File getStandardError() {
			return this.standardError;
		}
	}
}
/*
package org.springframework.boot.devtools.tests;
/**
class Directories {
	private final BuildOutput buildOutput;
	private final File temp;
	Directories(BuildOutput buildOutput, File temp) {
		this.buildOutput = buildOutput;
		this.temp = temp;
	}
	File getTestClassesDirectory() {
		return this.buildOutput.getTestClassesLocation();
	}
	File getRemoteAppDirectory() {
		return new File(this.temp, 'remote');
	}
	File getDependenciesDirectory() {
		return new File(this.buildOutput.getRootLocation(), 'dependencies');
	}
	File getAppDirectory() {
		return new File(this.temp, 'app');
	}
}
/*
package com.example;
@RestController
public class ControllerOne {
	@RequestMapping('/one')
	public String one() {
		return 'one';
	}
}
/*
package com.example;
@SpringBootApplication
class DevToolsTestApplication {
	public static void main(String[] args) {
		new SpringApplicationBuilder(DevToolsTestApplication.class).listeners(new WebServerPortFileWriter(args[0]))
			.run(args);
	}
}
/*
package org.springframework.boot.actuate.metrics.cache;
/**
@Testcontainers(disabledWithoutDocker = true)
class RedisCacheMetricsTests {
	@Container
	static final RedisContainer redis = TestImage.container(RedisContainer.class);
	private static final Tags TAGS = Tags.of('app', 'test').and('cache', 'test');
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class, CacheAutoConfiguration.class))
		.withUserConfiguration(CachingConfiguration.class)
		.withPropertyValues('spring.data.redis.host=' + redis.getHost(),
				'spring.data.redis.port=' + redis.getFirstMappedPort(), 'spring.cache.type=redis',
				'spring.cache.redis.enable-statistics=true');
	@Test
	void cacheStatisticsAreExposed() {
		this.contextRunner.run(withCacheMetrics((cache, meterRegistry) -> {
			assertThat(meterRegistry.find('cache.size').tags(TAGS).functionCounter()).isNull();
			assertThat(meterRegistry.find('cache.gets').tags(TAGS.and('result', 'hit')).functionCounter()).isNotNull();
			assertThat(meterRegistry.find('cache.gets').tags(TAGS.and('result', 'miss')).functionCounter()).isNotNull();
			assertThat(meterRegistry.find('cache.gets').tags(TAGS.and('result', 'pending')).functionCounter())
				.isNotNull();
			assertThat(meterRegistry.find('cache.evictions').tags(TAGS).functionCounter()).isNull();
			assertThat(meterRegistry.find('cache.puts').tags(TAGS).functionCounter()).isNotNull();
			assertThat(meterRegistry.find('cache.removals').tags(TAGS).functionCounter()).isNotNull();
			assertThat(meterRegistry.find('cache.lock.duration').tags(TAGS).timeGauge()).isNotNull();
		}));
	}
	@Test
	void cacheHitsAreExposed() {
		this.contextRunner.run(withCacheMetrics((cache, meterRegistry) -> {
			String key = UUID.randomUUID().toString();
			cache.put(key, 'test');
			cache.get(key);
			cache.get(key);
			assertThat(meterRegistry.get('cache.gets').tags(TAGS.and('result', 'hit')).functionCounter().count())
				.isEqualTo(2.0d);
		}));
	}
	@Test
	void cacheMissesAreExposed() {
		this.contextRunner.run(withCacheMetrics((cache, meterRegistry) -> {
			String key = UUID.randomUUID().toString();
			cache.get(key);
			cache.get(key);
			cache.get(key);
			assertThat(meterRegistry.get('cache.gets').tags(TAGS.and('result', 'miss')).functionCounter().count())
				.isEqualTo(3.0d);
		}));
	}
	@Test
	void cacheMetricsMatchCacheStatistics() {
		this.contextRunner.run((context) -> {
			RedisCache cache = getTestCache(context);
			RedisCacheMetrics cacheMetrics = new RedisCacheMetrics(cache, TAGS);
			assertThat(cacheMetrics.hitCount()).isEqualTo(cache.getStatistics().getHits());
			assertThat(cacheMetrics.missCount()).isEqualTo(cache.getStatistics().getMisses());
			assertThat(cacheMetrics.putCount()).isEqualTo(cache.getStatistics().getPuts());
			assertThat(cacheMetrics.size()).isNull();
			assertThat(cacheMetrics.evictionCount()).isNull();
		});
	}
	private ContextConsumer<AssertableApplicationContext> withCacheMetrics(
			BiConsumer<RedisCache, MeterRegistry> stats) {
		return (context) -> {
			RedisCache cache = getTestCache(context);
			SimpleMeterRegistry meterRegistry = new SimpleMeterRegistry();
			new RedisCacheMetrics(cache, Tags.of('app', 'test')).bindTo(meterRegistry);
			stats.accept(cache, meterRegistry);
		};
	}
	private RedisCache getTestCache(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(RedisCacheManager.class);
		RedisCacheManager cacheManager = context.getBean(RedisCacheManager.class);
		RedisCache cache = (RedisCache) cacheManager.getCache('test');
		assertThat(cache).isNotNull();
		return cache;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CachingConfiguration {
	}
}
/*
package org.springframework.boot.actuate.neo4j;
/**
@SpringBootTest
@Testcontainers(disabledWithoutDocker = true)
class Neo4jReactiveHealthIndicatorIntegrationTests {
	// gh-33428
	@Container
	private static final Neo4jContainer<?> neo4jServer = TestImage.container(Neo4jContainer.class);
	@DynamicPropertySource
	static void neo4jProperties(DynamicPropertyRegistry registry) {
		registry.add('spring.neo4j.uri', neo4jServer::getBoltUrl);
		registry.add('spring.neo4j.authentication.username', () -> 'neo4j');
		registry.add('spring.neo4j.authentication.password', neo4jServer::getAdminPassword);
	}
	@Autowired
	private Neo4jReactiveHealthIndicator healthIndicator;
	@Test
	void health() {
		Health health = this.healthIndicator.getHealth(true).block(Duration.ofSeconds(20));
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('edition', 'community');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(Neo4jAutoConfiguration.class)
	@Import(Neo4jReactiveHealthIndicator.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.actuate.mongo;
/**
@Testcontainers(disabledWithoutDocker = true)
class MongoHealthIndicatorIntegrationTests {
	@Container
	static MongoDBContainer mongo = TestImage.container(MongoDBContainer.class);
	@Test
	void standardApi() {
		Health health = mongoHealth();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void strictV1Api() {
		Health health = mongoHealth(ServerApi.builder().strict(true).version(ServerApiVersion.V1).build());
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	private Health mongoHealth() {
		return mongoHealth(null);
	}
	private Health mongoHealth(ServerApi serverApi) {
		Builder settingsBuilder = MongoClientSettings.builder()
			.applyConnectionString(new ConnectionString(mongo.getConnectionString()));
		if (serverApi != null) {
			settingsBuilder.serverApi(serverApi);
		}
		MongoClientSettings settings = settingsBuilder.build();
		MongoClient mongoClient = MongoClients.create(settings);
		MongoHealthIndicator healthIndicator = new MongoHealthIndicator(new MongoTemplate(mongoClient, 'db'));
		return healthIndicator.getHealth(true);
	}
}
/*
package org.springframework.boot.actuate.mongo;
/**
@Testcontainers(disabledWithoutDocker = true)
class MongoReactiveHealthIndicatorIntegrationTests {
	@Container
	static MongoDBContainer mongo = TestImage.container(MongoDBContainer.class);
	@Test
	void standardApi() {
		Health health = mongoHealth();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	@Test
	void strictV1Api() {
		Health health = mongoHealth(ServerApi.builder().strict(true).version(ServerApiVersion.V1).build());
		assertThat(health.getStatus()).isEqualTo(Status.UP);
	}
	private Health mongoHealth() {
		return mongoHealth(null);
	}
	private Health mongoHealth(ServerApi serverApi) {
		Builder settingsBuilder = MongoClientSettings.builder()
			.applyConnectionString(new ConnectionString(mongo.getConnectionString()));
		if (serverApi != null) {
			settingsBuilder.serverApi(serverApi);
		}
		MongoClientSettings settings = settingsBuilder.build();
		MongoClient mongoClient = MongoClients.create(settings);
		MongoReactiveHealthIndicator healthIndicator = new MongoReactiveHealthIndicator(
				new ReactiveMongoTemplate(mongoClient, 'db'));
		return healthIndicator.getHealth(true).block(Duration.ofSeconds(30));
	}
}
/*
package org.springframework.boot.actuate.ssl;
/**
class SslHealthIndicatorTests {
	private HealthIndicator healthIndicator;
	private CertificateValidityInfo validity;
	@BeforeEach
	void setUp() {
		SslInfo sslInfo = mock(SslInfo.class);
		BundleInfo bundle = mock(BundleInfo.class);
		CertificateChainInfo certificateChain = mock(CertificateChainInfo.class);
		CertificateInfo certificateInfo = mock(CertificateInfo.class);
		this.healthIndicator = new SslHealthIndicator(sslInfo);
		this.validity = mock(CertificateValidityInfo.class);
		given(sslInfo.getBundles()).willReturn(List.of(bundle));
		given(bundle.getCertificateChains()).willReturn(List.of(certificateChain));
		given(certificateChain.getCertificates()).willReturn(List.of(certificateInfo));
		given(certificateInfo.getValidity()).willReturn(this.validity);
	}
	@Test
	void shouldBeUpIfNoSslIssuesDetected() {
		given(this.validity.getStatus()).willReturn(CertificateValidityInfo.Status.VALID);
		Health health = this.healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertDetailsKeys(health);
		List<CertificateChainInfo> validChains = getValidChains(health);
		assertThat(validChains).hasSize(1);
		assertThat(validChains.get(0)).isInstanceOf(CertificateChainInfo.class);
		List<CertificateChainInfo> invalidChains = getInvalidChains(health);
		assertThat(invalidChains).isEmpty();
	}
	@Test
	void shouldBeOutOfServiceIfACertificateIsExpired() {
		given(this.validity.getStatus()).willReturn(CertificateValidityInfo.Status.EXPIRED);
		Health health = this.healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
		assertDetailsKeys(health);
		List<CertificateChainInfo> validChains = getValidChains(health);
		assertThat(validChains).isEmpty();
		List<CertificateChainInfo> invalidChains = getInvalidChains(health);
		assertThat(invalidChains).hasSize(1);
		assertThat(invalidChains.get(0)).isInstanceOf(CertificateChainInfo.class);
	}
	@Test
	void shouldBeOutOfServiceIfACertificateIsNotYetValid() {
		given(this.validity.getStatus()).willReturn(CertificateValidityInfo.Status.NOT_YET_VALID);
		Health health = this.healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.OUT_OF_SERVICE);
		assertDetailsKeys(health);
		List<CertificateChainInfo> validChains = getValidChains(health);
		assertThat(validChains).isEmpty();
		List<CertificateChainInfo> invalidChains = getInvalidChains(health);
		assertThat(invalidChains).hasSize(1);
		assertThat(invalidChains.get(0)).isInstanceOf(CertificateChainInfo.class);
	}
	@Test
	void shouldReportWarningIfACertificateWillExpireSoon() {
		given(this.validity.getStatus()).willReturn(CertificateValidityInfo.Status.WILL_EXPIRE_SOON);
		Health health = this.healthIndicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertDetailsKeys(health);
		List<CertificateChainInfo> validChains = getValidChains(health);
		assertThat(validChains).hasSize(1);
		assertThat(validChains.get(0)).isInstanceOf(CertificateChainInfo.class);
		List<CertificateChainInfo> invalidChains = getInvalidChains(health);
		assertThat(invalidChains).isEmpty();
	}
	private static void assertDetailsKeys(Health health) {
		assertThat(health.getDetails()).containsOnlyKeys('validChains', 'invalidChains');
	}
	@SuppressWarnings('unchecked')
	private static List<CertificateChainInfo> getInvalidChains(Health health) {
		return (List<CertificateChainInfo>) health.getDetails().get('invalidChains');
	}
	@SuppressWarnings('unchecked')
	private static List<CertificateChainInfo> getValidChains(Health health) {
		return (List<CertificateChainInfo>) health.getDetails().get('validChains');
	}
}
/*
package org.springframework.boot.actuate.scheduling;
/**
class ScheduledTasksEndpointTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(BaseConfiguration.class);
	@Test
	void cronScheduledMethodIsReported() {
		run(CronScheduledMethod.class, (tasks) -> {
			assertThat(tasks.getFixedDelay()).isEmpty();
			assertThat(tasks.getFixedRate()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getCron()).hasSize(1);
			CronTaskDescriptor description = (CronTaskDescriptor) tasks.getCron().get(0);
			assertThat(description.getExpression()).isEqualTo('0 0 0/3 1/1 * ?');
			assertThat(description.getRunnable().getTarget()).isEqualTo(CronScheduledMethod.class.getName() + '.cron');
			assertThat(description.getNextExecution().getTime()).isInTheFuture();
			assertThat(description.getLastExecution()).isNull();
		});
	}
	@Test
	void cronTriggerIsReported() {
		run(CronTriggerTask.class, (tasks) -> {
			assertThat(tasks.getFixedRate()).isEmpty();
			assertThat(tasks.getFixedDelay()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getCron()).hasSize(1);
			CronTaskDescriptor description = (CronTaskDescriptor) tasks.getCron().get(0);
			assertThat(description.getExpression()).isEqualTo('0 0 0/6 1/1 * ?');
			assertThat(description.getRunnable().getTarget()).contains(CronTriggerRunnable.class.getName());
			assertThat(description.getLastExecution()).isNull();
		});
	}
	@Test
	void fixedDelayScheduledMethodIsReported() {
		run(FixedDelayScheduledMethod.class, (tasks) -> {
			assertThat(tasks.getCron()).isEmpty();
			assertThat(tasks.getFixedRate()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getFixedDelay()).hasSize(1);
			FixedDelayTaskDescriptor description = (FixedDelayTaskDescriptor) tasks.getFixedDelay().get(0);
			assertThat(description.getInitialDelay()).isEqualTo(2000);
			assertThat(description.getInterval()).isEqualTo(1000);
			assertThat(description.getRunnable().getTarget())
				.isEqualTo(FixedDelayScheduledMethod.class.getName() + '.fixedDelay');
			assertThat(description.getLastExecution()).isNull();
		});
	}
	@Test
	void fixedDelayTriggerIsReported() {
		run(FixedDelayTriggerTask.class, (tasks) -> {
			assertThat(tasks.getCron()).isEmpty();
			assertThat(tasks.getFixedRate()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getFixedDelay()).hasSize(1);
			FixedDelayTaskDescriptor description = (FixedDelayTaskDescriptor) tasks.getFixedDelay().get(0);
			assertThat(description.getInitialDelay()).isEqualTo(2000);
			assertThat(description.getInterval()).isEqualTo(1000);
			assertThat(description.getRunnable().getTarget()).contains(FixedDelayTriggerRunnable.class.getName());
			assertThat(description.getLastExecution()).isNull();
		});
	}
	@Test
	void noInitialDelayFixedDelayTriggerIsReported() {
		run(NoInitialDelayFixedDelayTriggerTask.class, (tasks) -> {
			assertThat(tasks.getCron()).isEmpty();
			assertThat(tasks.getFixedRate()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getFixedDelay()).hasSize(1);
			FixedDelayTaskDescriptor description = (FixedDelayTaskDescriptor) tasks.getFixedDelay().get(0);
			assertThat(description.getInitialDelay()).isEqualTo(0);
			assertThat(description.getInterval()).isEqualTo(1000);
			assertThat(description.getRunnable().getTarget()).contains(FixedDelayTriggerRunnable.class.getName());
			assertThatTaskMayHaveBeenExecuted(description);
		});
	}
	@Test
	void fixedRateScheduledMethodIsReported() {
		run(FixedRateScheduledMethod.class, (tasks) -> {
			assertThat(tasks.getCron()).isEmpty();
			assertThat(tasks.getFixedDelay()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getFixedRate()).hasSize(1);
			FixedRateTaskDescriptor description = (FixedRateTaskDescriptor) tasks.getFixedRate().get(0);
			assertThat(description.getInitialDelay()).isEqualTo(4000);
			assertThat(description.getInterval()).isEqualTo(3000);
			assertThat(description.getRunnable().getTarget())
				.isEqualTo(FixedRateScheduledMethod.class.getName() + '.fixedRate');
			assertThat(description.getLastExecution()).isNull();
		});
	}
	@Test
	void fixedRateTriggerIsReported() {
		run(FixedRateTriggerTask.class, (tasks) -> {
			assertThat(tasks.getCron()).isEmpty();
			assertThat(tasks.getFixedDelay()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getFixedRate()).hasSize(1);
			FixedRateTaskDescriptor description = (FixedRateTaskDescriptor) tasks.getFixedRate().get(0);
			assertThat(description.getInitialDelay()).isEqualTo(3000);
			assertThat(description.getInterval()).isEqualTo(2000);
			assertThat(description.getRunnable().getTarget()).contains(FixedRateTriggerRunnable.class.getName());
			assertThat(description.getLastExecution()).isNull();
		});
	}
	@Test
	void noInitialDelayFixedRateTriggerIsReported() {
		run(NoInitialDelayFixedRateTriggerTask.class, (tasks) -> {
			assertThat(tasks.getCron()).isEmpty();
			assertThat(tasks.getFixedDelay()).isEmpty();
			assertThat(tasks.getCustom()).isEmpty();
			assertThat(tasks.getFixedRate()).hasSize(1);
			FixedRateTaskDescriptor description = (FixedRateTaskDescriptor) tasks.getFixedRate().get(0);
			assertThat(description.getInitialDelay()).isEqualTo(0);
			assertThat(description.getInterval()).isEqualTo(2000);
			assertThat(description.getRunnable().getTarget()).contains(FixedRateTriggerRunnable.class.getName());
			assertThatTaskMayHaveBeenExecuted(description);
		});
	}
	@Test
	void taskWithCustomTriggerIsReported() {
		run(CustomTriggerTask.class, (tasks) -> {
			assertThat(tasks.getCron()).isEmpty();
			assertThat(tasks.getFixedDelay()).isEmpty();
			assertThat(tasks.getFixedRate()).isEmpty();
			assertThat(tasks.getCustom()).hasSize(1);
			CustomTriggerTaskDescriptor description = (CustomTriggerTaskDescriptor) tasks.getCustom().get(0);
			assertThat(description.getRunnable().getTarget()).contains(CustomTriggerRunnable.class.getName());
			assertThat(description.getTrigger()).isEqualTo(CustomTriggerTask.trigger.toString());
			assertThatTaskMayHaveBeenExecuted(description);
		});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new ScheduledTasksEndpointRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		Set<Class<?>> bindingTypes = Set.of(FixedRateTaskDescriptor.class, FixedDelayTaskDescriptor.class,
				CronTaskDescriptor.class, CustomTriggerTaskDescriptor.class);
		for (Class<?> bindingType : bindingTypes) {
			assertThat(RuntimeHintsPredicates.reflection()
				.onType(bindingType)
				.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
				.accepts(runtimeHints);
		}
	}
	private void assertThatTaskMayHaveBeenExecuted(TaskDescriptor descriptor) {
		LastExecution lastExecution = descriptor.getLastExecution();
		if (lastExecution != null) {
			if (lastExecution.getStatus() == Status.SUCCESS) {
				assertThat(lastExecution.getTime()).isInThePast();
				assertThat(lastExecution.getException()).isNull();
			}
		}
	}
	private void run(Class<?> configuration, Consumer<ScheduledTasksDescriptor> consumer) {
		this.contextRunner.withUserConfiguration(configuration)
			.run((context) -> consumer.accept(context.getBean(ScheduledTasksEndpoint.class).scheduledTasks()));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableScheduling
	static class BaseConfiguration {
		@Bean
		ScheduledTasksEndpoint endpoint(Collection<ScheduledTaskHolder> scheduledTaskHolders) {
			return new ScheduledTasksEndpoint(scheduledTaskHolders);
		}
	}
	static class FixedDelayScheduledMethod {
		@Scheduled(fixedDelay = 1000, initialDelay = 2000)
		void fixedDelay() {
		}
	}
	static class FixedRateScheduledMethod {
		@Scheduled(fixedRate = 3000, initialDelay = 4000)
		void fixedRate() {
		}
	}
	static class CronScheduledMethod {
		@Scheduled(cron = '0 0 0/3 1/1 * ?')
		void cron() {
		}
	}
	static class FixedDelayTriggerTask implements SchedulingConfigurer {
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			PeriodicTrigger trigger = new PeriodicTrigger(Duration.ofSeconds(1));
			trigger.setInitialDelay(Duration.ofSeconds(2));
			taskRegistrar.addTriggerTask(new FixedDelayTriggerRunnable(), trigger);
		}
	}
	static class NoInitialDelayFixedDelayTriggerTask implements SchedulingConfigurer {
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			PeriodicTrigger trigger = new PeriodicTrigger(Duration.ofSeconds(1));
			taskRegistrar.addTriggerTask(new FixedDelayTriggerRunnable(), trigger);
		}
	}
	static class FixedRateTriggerTask implements SchedulingConfigurer {
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			PeriodicTrigger trigger = new PeriodicTrigger(Duration.ofSeconds(2));
			trigger.setInitialDelay(Duration.ofSeconds(3));
			trigger.setFixedRate(true);
			taskRegistrar.addTriggerTask(new FixedRateTriggerRunnable(), trigger);
		}
	}
	static class NoInitialDelayFixedRateTriggerTask implements SchedulingConfigurer {
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			PeriodicTrigger trigger = new PeriodicTrigger(Duration.ofSeconds(2));
			trigger.setFixedRate(true);
			taskRegistrar.addTriggerTask(new FixedRateTriggerRunnable(), trigger);
		}
	}
	static class CronTriggerTask implements SchedulingConfigurer {
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			taskRegistrar.addTriggerTask(new CronTriggerRunnable(), new CronTrigger('0 0 0/6 1/1 * ?'));
		}
	}
	static class CustomTriggerTask implements SchedulingConfigurer {
		private static final Trigger trigger = (context) -> Instant.now();
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			taskRegistrar.addTriggerTask(new CustomTriggerRunnable(), trigger);
		}
	}
	static class CronTriggerRunnable implements Runnable {
		@Override
		public void run() {
		}
	}
	static class FixedDelayTriggerRunnable implements Runnable {
		@Override
		public void run() {
		}
	}
	static class FixedRateTriggerRunnable implements Runnable {
		@Override
		public void run() {
		}
	}
	static class CustomTriggerRunnable implements Runnable {
		@Override
		public void run() {
		}
	}
}
/*
package org.springframework.boot.actuate.jdbc;
/**
class DataSourceHealthIndicatorTests {
	private final DataSourceHealthIndicator indicator = new DataSourceHealthIndicator();
	private SingleConnectionDataSource dataSource;
	@BeforeEach
	void init() {
		EmbeddedDatabaseConnection db = EmbeddedDatabaseConnection.HSQLDB;
		this.dataSource = new SingleConnectionDataSource(db.getUrl('testdb') + ';shutdown=true', 'sa', '', false);
		this.dataSource.setDriverClassName(db.getDriverClassName());
	}
	@AfterEach
	void close() {
		if (this.dataSource != null) {
			this.dataSource.destroy();
		}
	}
	@Test
	void healthIndicatorWithDefaultSettings() {
		this.indicator.setDataSource(this.dataSource);
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsOnly(entry('database', 'HSQL Database Engine'),
				entry('validationQuery', 'isValid()'));
	}
	@Test
	void healthIndicatorWithCustomValidationQuery() {
		String customValidationQuery = 'SELECT COUNT(*) from FOO';
		new JdbcTemplate(this.dataSource).execute('CREATE TABLE FOO (id INTEGER IDENTITY PRIMARY KEY)');
		this.indicator.setDataSource(this.dataSource);
		this.indicator.setQuery(customValidationQuery);
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsOnly(entry('database', 'HSQL Database Engine'), entry('result', 0L),
				entry('validationQuery', customValidationQuery));
	}
	@Test
	void healthIndicatorWithInvalidValidationQuery() {
		String invalidValidationQuery = 'SELECT COUNT(*) from BAR';
		this.indicator.setDataSource(this.dataSource);
		this.indicator.setQuery(invalidValidationQuery);
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).contains(entry('database', 'HSQL Database Engine'),
				entry('validationQuery', invalidValidationQuery));
		assertThat(health.getDetails()).containsOnlyKeys('database', 'error', 'validationQuery');
	}
	@Test
	void healthIndicatorCloseConnection() throws Exception {
		DataSource dataSource = mock(DataSource.class);
		Connection connection = mock(Connection.class);
		given(connection.getMetaData()).willReturn(this.dataSource.getConnection().getMetaData());
		given(dataSource.getConnection()).willReturn(connection);
		this.indicator.setDataSource(dataSource);
		Health health = this.indicator.health();
		assertThat(health.getDetails()).containsKey('database');
		then(connection).should(times(2)).close();
	}
	@Test
	void healthIndicatorWithConnectionValidationFailure() throws SQLException {
		DataSource dataSource = mock(DataSource.class);
		Connection connection = mock(Connection.class);
		given(connection.isValid(0)).willReturn(false);
		given(connection.getMetaData()).willReturn(this.dataSource.getConnection().getMetaData());
		given(dataSource.getConnection()).willReturn(connection);
		this.indicator.setDataSource(dataSource);
		Health health = this.indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).containsOnly(entry('database', 'HSQL Database Engine'),
				entry('validationQuery', 'isValid()'));
	}
}
/*
package org.springframework.boot.actuate.jms;
/**
class JmsHealthIndicatorTests {
	@Test
	void jmsBrokerIsUp() throws JMSException {
		ConnectionMetaData connectionMetaData = mock(ConnectionMetaData.class);
		given(connectionMetaData.getJMSProviderName()).willReturn('JMS test provider');
		Connection connection = mock(Connection.class);
		given(connection.getMetaData()).willReturn(connectionMetaData);
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		given(connectionFactory.createConnection()).willReturn(connection);
		JmsHealthIndicator indicator = new JmsHealthIndicator(connectionFactory);
		Health health = indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.UP);
		assertThat(health.getDetails()).containsEntry('provider', 'JMS test provider');
		then(connection).should().close();
	}
	@Test
	void jmsBrokerIsDown() throws JMSException {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		given(connectionFactory.createConnection()).willThrow(new JMSException('test', '123'));
		JmsHealthIndicator indicator = new JmsHealthIndicator(connectionFactory);
		Health health = indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).doesNotContainKey('provider');
	}
	@Test
	void jmsBrokerCouldNotRetrieveProviderMetadata() throws JMSException {
		ConnectionMetaData connectionMetaData = mock(ConnectionMetaData.class);
		given(connectionMetaData.getJMSProviderName()).willThrow(new JMSException('test', '123'));
		Connection connection = mock(Connection.class);
		given(connection.getMetaData()).willReturn(connectionMetaData);
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		given(connectionFactory.createConnection()).willReturn(connection);
		JmsHealthIndicator indicator = new JmsHealthIndicator(connectionFactory);
		Health health = indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).doesNotContainKey('provider');
		then(connection).should().close();
	}
	@Test
	void jmsBrokerUsesFailover() throws JMSException {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		ConnectionMetaData connectionMetaData = mock(ConnectionMetaData.class);
		given(connectionMetaData.getJMSProviderName()).willReturn('JMS test provider');
		Connection connection = mock(Connection.class);
		given(connection.getMetaData()).willReturn(connectionMetaData);
		willThrow(new JMSException('Could not start', '123')).given(connection).start();
		given(connectionFactory.createConnection()).willReturn(connection);
		JmsHealthIndicator indicator = new JmsHealthIndicator(connectionFactory);
		Health health = indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat(health.getDetails()).doesNotContainKey('provider');
	}
	@Test
	void whenConnectionStartIsUnresponsiveStatusIsDown() throws JMSException {
		ConnectionMetaData connectionMetaData = mock(ConnectionMetaData.class);
		given(connectionMetaData.getJMSProviderName()).willReturn('JMS test provider');
		Connection connection = mock(Connection.class);
		UnresponsiveStartAnswer unresponsiveStartAnswer = new UnresponsiveStartAnswer();
		willAnswer(unresponsiveStartAnswer).given(connection).start();
		willAnswer((invocation) -> {
			unresponsiveStartAnswer.connectionClosed();
			return null;
		}).given(connection).close();
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		given(connectionFactory.createConnection()).willReturn(connection);
		JmsHealthIndicator indicator = new JmsHealthIndicator(connectionFactory);
		Health health = indicator.health();
		assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		assertThat((String) health.getDetails().get('error')).contains('Connection closed');
	}
	private static final class UnresponsiveStartAnswer implements Answer<Void> {
		private boolean connectionClosed = false;
		private final Object monitor = new Object();
		@Override
		public Void answer(InvocationOnMock invocation) throws Throwable {
			synchronized (this.monitor) {
				while (!this.connectionClosed) {
					this.monitor.wait();
				}
			}
			throw new JMSException('Connection closed');
		}
		private void connectionClosed() {
			synchronized (this.monitor) {
				this.connectionClosed = true;
				this.monitor.notifyAll();
			}
		}
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
@SuppressWarnings('unchecked')
class ConfigurationPropertiesReportEndpointTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(EndpointConfig.class);
	@Test
	void descriptorWithJavaBeanBindMethodDetectsRelevantProperties() {
		this.contextRunner.withUserConfiguration(TestPropertiesConfiguration.class)
			.run(assertProperties('test', (properties) -> assertThat(properties).containsOnlyKeys('dbPassword',
					'myTestProperty', 'duration')));
	}
	@Test
	void descriptorWithAutowiredConstructorBindMethodDetectsRelevantProperties() {
		this.contextRunner.withUserConfiguration(AutowiredPropertiesConfiguration.class)
			.run(assertProperties('autowired', (properties) -> assertThat(properties).containsOnlyKeys('counter')));
	}
	@Test
	void descriptorWithValueObjectBindMethodDetectsRelevantProperties() {
		this.contextRunner.withUserConfiguration(ImmutablePropertiesConfiguration.class)
			.run(assertProperties('immutable',
					(properties) -> assertThat(properties).containsOnlyKeys('dbPassword', 'myTestProperty', 'for')));
	}
	@Test
	void descriptorWithValueObjectBindMethodUseDedicatedConstructor() {
		this.contextRunner.withUserConfiguration(MultiConstructorPropertiesConfiguration.class)
			.run(assertProperties('multiconstructor',
					(properties) -> assertThat(properties).containsOnly(entry('name', 'test'))));
	}
	@Test
	void descriptorWithValueObjectBindMethodHandleNestedType() {
		this.contextRunner.withPropertyValues('immutablenested.nested.name=nested', 'immutablenested.nested.counter=42')
			.withUserConfiguration(ImmutableNestedPropertiesConfiguration.class)
			.run(assertProperties('immutablenested', (properties) -> {
				assertThat(properties).containsOnlyKeys('name', 'nested');
				Map<String, Object> nested = (Map<String, Object>) properties.get('nested');
				assertThat(nested).containsOnly(entry('name', 'nested'), entry('counter', 42));
			}, (inputs) -> {
				Map<String, Object> nested = (Map<String, Object>) inputs.get('nested');
				Map<String, Object> name = (Map<String, Object>) nested.get('name');
				Map<String, Object> counter = (Map<String, Object>) nested.get('counter');
				assertThat(name).containsEntry('value', 'nested');
				assertThat(name).containsEntry('origin',
						'\'immutablenested.nested.name\' from property source \'test\'');
				assertThat(counter).containsEntry('origin',
						'\'immutablenested.nested.counter\' from property source \'test\'');
				assertThat(counter).containsEntry('value', '42');
			}));
	}
	@Test
	void descriptorWithSimpleList() {
		this.contextRunner.withUserConfiguration(SensiblePropertiesConfiguration.class)
			.withPropertyValues('sensible.simpleList=a,b')
			.run(assertProperties('sensible', (properties) -> {
				assertThat(properties.get('simpleList')).isInstanceOf(List.class);
				List<String> list = (List<String>) properties.get('simpleList');
				assertThat(list).hasSize(2);
				assertThat(list.get(0)).isEqualTo('a');
				assertThat(list.get(1)).isEqualTo('b');
			}, (inputs) -> {
				List<Object> list = (List<Object>) inputs.get('simpleList');
				assertThat(list).hasSize(2);
				Map<String, String> item = (Map<String, String>) list.get(0);
				String origin = item.get('origin');
				String value = item.get('value');
				assertThat(value).isEqualTo('a,b');
				assertThat(origin).isEqualTo('\'sensible.simpleList\' from property source \'test\'');
			}));
	}
	@Test
	void descriptorDoesNotIncludePropertyWithNullValue() {
		this.contextRunner.withUserConfiguration(TestPropertiesConfiguration.class)
			.run(assertProperties('test', (properties) -> assertThat(properties).doesNotContainKey('nullValue')));
	}
	@Test
	void descriptorWithDurationProperty() {
		this.contextRunner.withUserConfiguration(TestPropertiesConfiguration.class)
			.run(assertProperties('test', (properties) -> assertThat(properties.get('duration'))
				.isEqualTo(Duration.ofSeconds(10).toString())));
	}
	@Test // gh-36076
	void descriptorWithWrapperProperty() {
		this.contextRunner.withUserConfiguration(TestPropertiesConfiguration.class).withInitializer((context) -> {
			ConfigurableEnvironment environment = context.getEnvironment();
			Map<String, Object> map = Collections.singletonMap('test.wrapper', 10);
			PropertySource<?> propertySource = new MapPropertySource('test', map);
			environment.getPropertySources().addLast(propertySource);
		})
			.run(assertProperties('test', (properties) -> assertThat(properties.get('wrapper')).isEqualTo(10),
					(inputs) -> {
						Map<String, Object> wrapper = (Map<String, Object>) inputs.get('wrapper');
						assertThat(wrapper.get('value')).isEqualTo(10);
					}));
	}
	@Test
	void descriptorWithNonCamelCaseProperty() {
		this.contextRunner.withUserConfiguration(MixedCasePropertiesConfiguration.class)
			.run(assertProperties('mixedcase',
					(properties) -> assertThat(properties.get('myURL')).isEqualTo('https://example.com')));
	}
	@Test
	void descriptorWithMixedCaseProperty() {
		this.contextRunner.withUserConfiguration(MixedCasePropertiesConfiguration.class)
			.run(assertProperties('mixedcase',
					(properties) -> assertThat(properties.get('mIxedCase')).isEqualTo('mixed')));
	}
	@Test
	void descriptorWithSingleLetterProperty() {
		this.contextRunner.withUserConfiguration(MixedCasePropertiesConfiguration.class)
			.run(assertProperties('mixedcase', (properties) -> assertThat(properties.get('z')).isEqualTo('zzz')));
	}
	@Test
	void descriptorWithSimpleBooleanProperty() {
		this.contextRunner.withUserConfiguration(BooleanPropertiesConfiguration.class)
			.run(assertProperties('boolean',
					(properties) -> assertThat(properties.get('simpleBoolean')).isEqualTo(true)));
	}
	@Test
	void descriptorWithMixedBooleanProperty() {
		this.contextRunner.withUserConfiguration(BooleanPropertiesConfiguration.class)
			.run(assertProperties('boolean',
					(properties) -> assertThat(properties.get('mixedBoolean')).isEqualTo(true)));
	}
	@Test
	void descriptorWithDataSizeProperty() {
		String configSize = '1MB';
		String stringifySize = DataSize.parse(configSize).toString();
		this.contextRunner.withUserConfiguration(DataSizePropertiesConfiguration.class)
			.withPropertyValues(String.format('data.size=%s', configSize))
			.run(assertProperties('data', (properties) -> assertThat(properties.get('size')).isEqualTo(stringifySize),
					(inputs) -> {
						Map<String, Object> size = (Map<String, Object>) inputs.get('size');
						assertThat(size).containsEntry('value', configSize);
						assertThat(size).containsEntry('origin', '\'data.size\' from property source \'test\'');
					}));
	}
	@Test
	void sanitizeLists() {
		new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfigWithShowNever.class, SensiblePropertiesConfiguration.class)
			.withPropertyValues('sensible.listItems[0].some-password=password')
			.run(assertProperties('sensible', (properties) -> {
				assertThat(properties.get('listItems')).isInstanceOf(List.class);
				List<Object> list = (List<Object>) properties.get('listItems');
				assertThat(list).hasSize(1);
				Map<String, Object> item = (Map<String, Object>) list.get(0);
				assertThat(item).containsEntry('somePassword', '******');
			}, (inputs) -> {
				List<Object> list = (List<Object>) inputs.get('listItems');
				assertThat(list).hasSize(1);
				Map<String, Object> item = (Map<String, Object>) list.get(0);
				Map<String, Object> somePassword = (Map<String, Object>) item.get('somePassword');
				assertThat(somePassword).containsEntry('value', '******');
				assertThat(somePassword).containsEntry('origin',
						'\'sensible.listItems[0].some-password\' from property source \'test\'');
			}));
	}
	@Test
	void listsOfListsAreSanitized() {
		new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfigWithShowNever.class, SensiblePropertiesConfiguration.class)
			.withPropertyValues('sensible.listOfListItems[0][0].some-password=password')
			.run(assertProperties('sensible', (properties) -> {
				assertThat(properties.get('listOfListItems')).isInstanceOf(List.class);
				List<List<Object>> listOfLists = (List<List<Object>>) properties.get('listOfListItems');
				assertThat(listOfLists).hasSize(1);
				List<Object> list = listOfLists.get(0);
				assertThat(list).hasSize(1);
				Map<String, Object> item = (Map<String, Object>) list.get(0);
				assertThat(item).containsEntry('somePassword', '******');
			}, (inputs) -> {
				assertThat(inputs.get('listOfListItems')).isInstanceOf(List.class);
				List<List<Object>> listOfLists = (List<List<Object>>) inputs.get('listOfListItems');
				assertThat(listOfLists).hasSize(1);
				List<Object> list = listOfLists.get(0);
				assertThat(list).hasSize(1);
				Map<String, Object> item = (Map<String, Object>) list.get(0);
				Map<String, Object> somePassword = (Map<String, Object>) item.get('somePassword');
				assertThat(somePassword).containsEntry('value', '******');
				assertThat(somePassword).containsEntry('origin',
						'\'sensible.listOfListItems[0][0].some-password\' from property source \'test\'');
			}));
	}
	@Test
	void sanitizeWithCustomSanitizingFunction() {
		new ApplicationContextRunner()
			.withUserConfiguration(CustomSanitizingEndpointConfig.class, SanitizingFunctionConfiguration.class,
					TestPropertiesConfiguration.class)
			.run(assertProperties('test', (properties) -> {
				assertThat(properties).containsEntry('dbPassword', '$$$');
				assertThat(properties).containsEntry('myTestProperty', '$$$');
			}));
	}
	@Test
	void sanitizeWithCustomPropertySourceBasedSanitizingFunction() {
		new ApplicationContextRunner()
			.withUserConfiguration(CustomSanitizingEndpointConfig.class,
					PropertySourceBasedSanitizingFunctionConfiguration.class, TestPropertiesConfiguration.class)
			.withPropertyValues('test.my-test-property=abcde')
			.run(assertProperties('test', (properties) -> {
				assertThat(properties).containsEntry('dbPassword', '123456');
				assertThat(properties).containsEntry('myTestProperty', '$$$');
			}));
	}
	@Test
	void sanitizeListsWithCustomSanitizingFunction() {
		new ApplicationContextRunner()
			.withUserConfiguration(CustomSanitizingEndpointConfig.class, SanitizingFunctionConfiguration.class,
					SensiblePropertiesConfiguration.class)
			.withPropertyValues('sensible.listItems[0].custom=my-value')
			.run(assertProperties('sensible', (properties) -> {
				assertThat(properties.get('listItems')).isInstanceOf(List.class);
				List<Object> list = (List<Object>) properties.get('listItems');
				assertThat(list).hasSize(1);
				Map<String, Object> item = (Map<String, Object>) list.get(0);
				assertThat(item).containsEntry('custom', '$$$');
			}, (inputs) -> {
				List<Object> list = (List<Object>) inputs.get('listItems');
				assertThat(list).hasSize(1);
				Map<String, Object> item = (Map<String, Object>) list.get(0);
				Map<String, Object> somePassword = (Map<String, Object>) item.get('custom');
				assertThat(somePassword).containsEntry('value', '$$$');
				assertThat(somePassword).containsEntry('origin',
						'\'sensible.listItems[0].custom\' from property source \'test\'');
			}));
	}
	@Test
	void noSanitizationWhenShowAlways() {
		new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfigWithShowAlways.class, TestPropertiesConfiguration.class)
			.run(assertProperties('test', (properties) -> {
				assertThat(properties).containsEntry('dbPassword', '123456');
				assertThat(properties).containsEntry('myTestProperty', '654321');
			}));
	}
	@Test
	void sanitizationWhenShowNever() {
		new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfigWithShowNever.class, TestPropertiesConfiguration.class)
			.run(assertProperties('test', (properties) -> {
				assertThat(properties).containsEntry('dbPassword', '******');
				assertThat(properties).containsEntry('myTestProperty', '******');
			}));
	}
	@Test
	void originParents() {
		this.contextRunner.withUserConfiguration(SensiblePropertiesConfiguration.class)
			.withInitializer(this::initializeOriginParents)
			.run(assertProperties('sensible', (properties) -> {
			}, (inputs) -> {
				Map<String, Object> stringInputs = (Map<String, Object>) inputs.get('string');
				String[] originParents = (String[]) stringInputs.get('originParents');
				assertThat(originParents).containsExactly('spring', 'boot');
			}));
	}
	private void initializeOriginParents(ConfigurableApplicationContext context) {
		MockPropertySource propertySource = new OriginParentMockPropertySource();
		propertySource.setProperty('sensible.string', 'spring');
		context.getEnvironment().getPropertySources().addFirst(propertySource);
	}
	private ContextConsumer<AssertableApplicationContext> assertProperties(String prefix,
			Consumer<Map<String, Object>> properties) {
		return assertProperties(prefix, properties, (inputs) -> {
		});
	}
	private ContextConsumer<AssertableApplicationContext> assertProperties(String prefix,
			Consumer<Map<String, Object>> properties, Consumer<Map<String, Object>> inputs) {
		return (context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesReportEndpoint.ConfigurationPropertiesDescriptor configurationProperties = endpoint
				.configurationProperties();
			ContextConfigurationPropertiesDescriptor allProperties = configurationProperties.getContexts()
				.get(context.getId());
			Optional<String> key = allProperties.getBeans()
				.keySet()
				.stream()
				.filter((id) -> findIdFromPrefix(prefix, id))
				.findAny();
			assertThat(key).describedAs('No configuration properties with prefix "%s" found', prefix).isPresent();
			ConfigurationPropertiesBeanDescriptor descriptor = allProperties.getBeans().get(key.get());
			assertThat(descriptor.getPrefix()).isEqualTo(prefix);
			properties.accept(descriptor.getProperties());
			inputs.accept(descriptor.getInputs());
		};
	}
	private boolean findIdFromPrefix(String prefix, String id) {
		int separator = id.indexOf('-');
		String candidate = (separator != -1) ? id.substring(0, separator) : id;
		return prefix.equals(candidate);
	}
	static class OriginParentMockPropertySource extends MockPropertySource implements OriginLookup<String> {
		@Override
		public Origin getOrigin(String key) {
			return new MockOrigin(key, new MockOrigin('spring', new MockOrigin('boot', null)));
		}
	}
	static class MockOrigin implements Origin {
		private final String value;
		private final MockOrigin parent;
		MockOrigin(String value, MockOrigin parent) {
			this.value = value;
			this.parent = parent;
		}
		@Override
		public Origin getParent() {
			return this.parent;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointConfig {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			ConfigurationPropertiesReportEndpoint endpoint = new ConfigurationPropertiesReportEndpoint(
					Collections.emptyList(), Show.WHEN_AUTHORIZED);
			return endpoint;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointConfigWithShowAlways {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			ConfigurationPropertiesReportEndpoint endpoint = new ConfigurationPropertiesReportEndpoint(
					Collections.emptyList(), Show.ALWAYS);
			return endpoint;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointConfigWithShowNever {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			ConfigurationPropertiesReportEndpoint endpoint = new ConfigurationPropertiesReportEndpoint(
					Collections.emptyList(), Show.NEVER);
			return endpoint;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(TestProperties.class)
	static class TestPropertiesConfiguration {
	}
	@ConfigurationProperties(prefix = 'test')
	public static class TestProperties {
		private String dbPassword = '123456';
		private String myTestProperty = '654321';
		private String nullValue = null;
		private Duration duration = Duration.ofSeconds(10);
		private final String ignored = 'dummy';
		private Integer wrapper;
		public String getDbPassword() {
			return this.dbPassword;
		}
		public void setDbPassword(String dbPassword) {
			this.dbPassword = dbPassword;
		}
		public String getMyTestProperty() {
			return this.myTestProperty;
		}
		public void setMyTestProperty(String myTestProperty) {
			this.myTestProperty = myTestProperty;
		}
		public String getNullValue() {
			return this.nullValue;
		}
		public void setNullValue(String nullValue) {
			this.nullValue = nullValue;
		}
		public Duration getDuration() {
			return this.duration;
		}
		public void setDuration(Duration duration) {
			this.duration = duration;
		}
		public String getIgnored() {
			return this.ignored;
		}
		public Integer getWrapper() {
			return this.wrapper;
		}
		public void setWrapper(Integer wrapper) {
			this.wrapper = wrapper;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ImmutableProperties.class)
	static class ImmutablePropertiesConfiguration {
	}
	@ConfigurationProperties(prefix = 'immutable')
	public static class ImmutableProperties {
		private final String dbPassword;
		private final String myTestProperty;
		private final String nullValue;
		private final Duration forDuration;
		private final String ignored;
		ImmutableProperties(@DefaultValue('123456') String dbPassword, @DefaultValue('654321') String myTestProperty,
				String nullValue, @DefaultValue('10s') @Name('for') Duration forDuration) {
			this.dbPassword = dbPassword;
			this.myTestProperty = myTestProperty;
			this.nullValue = nullValue;
			this.forDuration = forDuration;
			this.ignored = 'dummy';
		}
		public String getDbPassword() {
			return this.dbPassword;
		}
		public String getMyTestProperty() {
			return this.myTestProperty;
		}
		public String getNullValue() {
			return this.nullValue;
		}
		public Duration getFor() {
			return this.forDuration;
		}
		public String getIgnored() {
			return this.ignored;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(MultiConstructorProperties.class)
	static class MultiConstructorPropertiesConfiguration {
	}
	@ConfigurationProperties(prefix = 'multiconstructor')
	public static class MultiConstructorProperties {
		private final String name;
		private final int counter;
		MultiConstructorProperties(String name, int counter) {
			this.name = name;
			this.counter = counter;
		}
		@ConstructorBinding
		MultiConstructorProperties(@DefaultValue('test') String name) {
			this.name = name;
			this.counter = 42;
		}
		public String getName() {
			return this.name;
		}
		public int getCounter() {
			return this.counter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(AutowiredProperties.class)
	static class AutowiredPropertiesConfiguration {
		@Bean
		String hello() {
			return 'hello';
		}
	}
	@ConfigurationProperties(prefix = 'autowired')
	public static class AutowiredProperties {
		private final String name;
		private int counter;
		@Autowired
		AutowiredProperties(String name) {
			this.name = name;
		}
		public String getName() {
			return this.name;
		}
		public int getCounter() {
			return this.counter;
		}
		public void setCounter(int counter) {
			this.counter = counter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ImmutableNestedProperties.class)
	static class ImmutableNestedPropertiesConfiguration {
	}
	@ConfigurationProperties('immutablenested')
	public static class ImmutableNestedProperties {
		private final String name;
		private final Nested nested;
		ImmutableNestedProperties(@DefaultValue('parent') String name, Nested nested) {
			this.name = name;
			this.nested = nested;
		}
		public String getName() {
			return this.name;
		}
		public Nested getNested() {
			return this.nested;
		}
		public static class Nested {
			private final String name;
			private final int counter;
			Nested(String name, int counter) {
				this.name = name;
				this.counter = counter;
			}
			public String getName() {
				return this.name;
			}
			public int getCounter() {
				return this.counter;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(MixedCaseProperties.class)
	static class MixedCasePropertiesConfiguration {
	}
	@ConfigurationProperties('mixedcase')
	public static class MixedCaseProperties {
		private String myURL = 'https://example.com';
		private String mIxedCase = 'mixed';
		private String z = 'zzz';
		public String getMyURL() {
			return this.myURL;
		}
		public void setMyURL(String myURL) {
			this.myURL = myURL;
		}
		public String getmIxedCase() {
			return this.mIxedCase;
		}
		public void setmIxedCase(String mIxedCase) {
			this.mIxedCase = mIxedCase;
		}
		public String getZ() {
			return this.z;
		}
		public void setZ(String z) {
			this.z = z;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(BooleanProperties.class)
	static class BooleanPropertiesConfiguration {
	}
	@ConfigurationProperties('boolean')
	public static class BooleanProperties {
		private boolean simpleBoolean = true;
		private Boolean mixedBoolean = true;
		public boolean isSimpleBoolean() {
			return this.simpleBoolean;
		}
		public void setSimpleBoolean(boolean simpleBoolean) {
			this.simpleBoolean = simpleBoolean;
		}
		public boolean isMixedBoolean() {
			return (this.mixedBoolean != null) ? this.mixedBoolean : false;
		}
		public void setMixedBoolean(Boolean mixedBoolean) {
			this.mixedBoolean = mixedBoolean;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(DataSizeProperties.class)
	static class DataSizePropertiesConfiguration {
	}
	@ConfigurationProperties('data')
	public static class DataSizeProperties {
		private DataSize size;
		public DataSize getSize() {
			return this.size;
		}
		public void setSize(DataSize size) {
			this.size = size;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(Gh4415Properties.class)
	static class Gh4415PropertiesConfiguration {
	}
	@ConfigurationProperties('gh4415')
	public static class Gh4415Properties {
		private Hidden hidden = new Hidden();
		private Map<String, Object> secrets = new HashMap<>();
		Gh4415Properties() {
			this.secrets.put('mine', 'myPrivateThing');
			this.secrets.put('yours', 'yourPrivateThing');
		}
		public Hidden getHidden() {
			return this.hidden;
		}
		public void setHidden(Hidden hidden) {
			this.hidden = hidden;
		}
		public Map<String, Object> getSecrets() {
			return this.secrets;
		}
		public void setSecrets(Map<String, Object> secrets) {
			this.secrets = secrets;
		}
		public static class Hidden {
			private String mine = 'mySecret';
			public String getMine() {
				return this.mine;
			}
			public void setMine(String mine) {
				this.mine = mine;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(SensibleProperties.class)
	static class SensiblePropertiesConfiguration {
	}
	@ConfigurationProperties('sensible')
	public static class SensibleProperties {
		private String string;
		private URI sensitiveUri = URI.create('http://user:password@localhost:8080');
		private URI noPasswordUri = URI.create('http://user:@localhost:8080');
		private final List<String> simpleList = new ArrayList<>();
		private String rawSensitiveAddresses = 'http://user:password@localhost:8080,http://user2:password2@localhost:8082';
		private List<ListItem> listItems = new ArrayList<>();
		private List<List<ListItem>> listOfListItems = new ArrayList<>();
		SensibleProperties() {
			this.listItems.add(new ListItem());
			this.listOfListItems.add(Collections.singletonList(new ListItem()));
		}
		public void setString(String string) {
			this.string = string;
		}
		public String getString() {
			return this.string;
		}
		public void setSensitiveUri(URI sensitiveUri) {
			this.sensitiveUri = sensitiveUri;
		}
		public URI getSensitiveUri() {
			return this.sensitiveUri;
		}
		public void setNoPasswordUri(URI noPasswordUri) {
			this.noPasswordUri = noPasswordUri;
		}
		public URI getNoPasswordUri() {
			return this.noPasswordUri;
		}
		public String getRawSensitiveAddresses() {
			return this.rawSensitiveAddresses;
		}
		public void setRawSensitiveAddresses(final String rawSensitiveAddresses) {
			this.rawSensitiveAddresses = rawSensitiveAddresses;
		}
		public List<ListItem> getListItems() {
			return this.listItems;
		}
		public void setListItems(List<ListItem> listItems) {
			this.listItems = listItems;
		}
		public List<List<ListItem>> getListOfListItems() {
			return this.listOfListItems;
		}
		public void setListOfListItems(List<List<ListItem>> listOfListItems) {
			this.listOfListItems = listOfListItems;
		}
		public List<String> getSimpleList() {
			return this.simpleList;
		}
		public static class ListItem {
			private String somePassword = 'secret';
			private String custom;
			public String getSomePassword() {
				return this.somePassword;
			}
			public void setSomePassword(String somePassword) {
				this.somePassword = somePassword;
			}
			public String getCustom() {
				return this.custom;
			}
			public void setCustom(String custom) {
				this.custom = custom;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSanitizingEndpointConfig {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint(SanitizingFunction sanitizingFunction) {
			ConfigurationPropertiesReportEndpoint endpoint = new ConfigurationPropertiesReportEndpoint(
					Collections.singletonList(sanitizingFunction), Show.ALWAYS);
			return endpoint;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SanitizingFunctionConfiguration {
		@Bean
		SanitizingFunction testSanitizingFunction() {
			return (data) -> {
				if (data.getKey().contains('custom') || data.getKey().contains('test')) {
					return data.withValue('$$$');
				}
				return data;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PropertySourceBasedSanitizingFunctionConfiguration {
		@Bean
		SanitizingFunction testSanitizingFunction() {
			return (data) -> {
				if (data.getPropertySource() != null && data.getPropertySource().getName().startsWith('test')) {
					return data.withValue('$$$');
				}
				return data;
			};
		}
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
class ConfigurationPropertiesReportEndpointParentTests {
	@Test
	void configurationPropertiesClass() {
		new ApplicationContextRunner().withUserConfiguration(Parent.class).run((parent) -> {
			new ApplicationContextRunner().withUserConfiguration(ClassConfigurationProperties.class)
				.withParent(parent)
				.run((child) -> {
					ConfigurationPropertiesReportEndpoint endpoint = child
						.getBean(ConfigurationPropertiesReportEndpoint.class);
					ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
					assertThat(applicationProperties.getContexts()).containsOnlyKeys(child.getId(), parent.getId());
					assertThat(applicationProperties.getContexts().get(child.getId()).getBeans().keySet())
						.containsExactly('someProperties');
					assertThat((applicationProperties.getContexts().get(parent.getId()).getBeans().keySet()))
						.containsExactly('testProperties');
				});
		});
	}
	@Test
	void configurationPropertiesBeanMethod() {
		new ApplicationContextRunner().withUserConfiguration(Parent.class).run((parent) -> {
			new ApplicationContextRunner().withUserConfiguration(BeanMethodConfigurationProperties.class)
				.withParent(parent)
				.run((child) -> {
					ConfigurationPropertiesReportEndpoint endpoint = child
						.getBean(ConfigurationPropertiesReportEndpoint.class);
					ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
					assertThat(applicationProperties.getContexts().get(child.getId()).getBeans().keySet())
						.containsExactlyInAnyOrder('otherProperties');
					assertThat((applicationProperties.getContexts().get(parent.getId()).getBeans().keySet()))
						.containsExactly('testProperties');
				});
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class Parent {
		@Bean
		TestProperties testProperties() {
			return new TestProperties();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class ClassConfigurationProperties {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
		@Bean
		TestProperties someProperties() {
			return new TestProperties();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class BeanMethodConfigurationProperties {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
		@Bean
		@ConfigurationProperties(prefix = 'other')
		OtherProperties otherProperties() {
			return new OtherProperties();
		}
	}
	static class OtherProperties {
	}
	@ConfigurationProperties(prefix = 'test')
	static class TestProperties {
		private String myTestProperty = '654321';
		String getMyTestProperty() {
			return this.myTestProperty;
		}
		void setMyTestProperty(String myTestProperty) {
			this.myTestProperty = myTestProperty;
		}
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
@Validated
@ConfigurationProperties(prefix = 'validated')
public class ValidatedConstructorBindingProperties {
	private final String name;
	ValidatedConstructorBindingProperties(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
class ConfigurationPropertiesReportEndpointMethodAnnotationsTests {
	@Test
	void testNaming() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(Config.class)
			.withPropertyValues('other.name:foo', 'first.name:bar');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			assertThat(applicationProperties.getContexts()).containsOnlyKeys(context.getId());
			ContextConfigurationPropertiesDescriptor contextProperties = applicationProperties.getContexts()
				.get(context.getId());
			ConfigurationPropertiesBeanDescriptor other = contextProperties.getBeans().get('other');
			assertThat(other).isNotNull();
			assertThat(other.getPrefix()).isEqualTo('other');
			assertThat(other.getProperties()).isNotNull();
			assertThat(other.getProperties()).isNotEmpty();
		});
	}
	@Test
	void prefixFromBeanMethodConfigurationPropertiesCanOverridePrefixOnClass() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(OverriddenPrefix.class)
			.withPropertyValues('other.name:foo');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			assertThat(applicationProperties.getContexts()).containsOnlyKeys(context.getId());
			ContextConfigurationPropertiesDescriptor contextProperties = applicationProperties.getContexts()
				.get(context.getId());
			ConfigurationPropertiesBeanDescriptor bar = contextProperties.getBeans().get('bar');
			assertThat(bar).isNotNull();
			assertThat(bar.getPrefix()).isEqualTo('other');
			assertThat(bar.getProperties()).isNotNull();
			assertThat(bar.getProperties()).isNotEmpty();
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class Config {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
		@Bean
		@ConfigurationProperties(prefix = 'first')
		Foo foo() {
			return new Foo();
		}
		@Bean
		@ConfigurationProperties(prefix = 'other')
		Foo other() {
			return new Foo();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class OverriddenPrefix {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
		@Bean
		@ConfigurationProperties(prefix = 'other')
		Bar bar() {
			return new Bar();
		}
	}
	public static class Foo {
		private String name = '654321';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
	@ConfigurationProperties(prefix = 'test')
	public static class Bar {
		private String name = '654321';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
class ConfigurationPropertiesReportEndpointProxyTests {
	@Test
	void testWithProxyClass() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(Config.class,
				SqlExecutor.class);
		contextRunner.run((context) -> {
			ConfigurationPropertiesDescriptor applicationProperties = context
				.getBean(ConfigurationPropertiesReportEndpoint.class)
				.configurationProperties();
			assertThat(applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.values()
				.stream()
				.map(ConfigurationPropertiesBeanDescriptor::getPrefix)
				.filter('executor.sql'::equals)
				.findFirst()).isNotEmpty();
		});
	}
	@Test
	void proxiedConstructorBoundPropertiesShouldBeAvailableInReport() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(ValidatedConfiguration.class)
			.withPropertyValues('validated.name=baz');
		contextRunner.run((context) -> {
			ConfigurationPropertiesDescriptor applicationProperties = context
				.getBean(ConfigurationPropertiesReportEndpoint.class)
				.configurationProperties();
			Map<String, Object> properties = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.values()
				.stream()
				.map(ConfigurationPropertiesBeanDescriptor::getProperties)
				.findFirst()
				.get();
			assertThat(properties).containsEntry('name', 'baz');
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableTransactionManagement(proxyTargetClass = false)
	@EnableConfigurationProperties
	static class Config {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
		@Bean
		PlatformTransactionManager transactionManager(DataSource dataSource) {
			return new DataSourceTransactionManager(dataSource);
		}
		@Bean
		static MethodValidationPostProcessor testPostProcessor() {
			return new MethodValidationPostProcessor();
		}
		@Bean
		DataSource dataSource() {
			return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.HSQL).build();
		}
	}
	interface Executor {
		void execute();
	}
	abstract static class AbstractExecutor implements Executor {
	}
	@Component
	@ConfigurationProperties('executor.sql')
	static class SqlExecutor extends AbstractExecutor {
		@Override
		@Transactional(propagation = Propagation.REQUIRES_NEW)
		public void execute() {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ValidatedConstructorBindingProperties.class)
	@Import(Config.class)
	static class ValidatedConfiguration {
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
class ConfigurationPropertiesReportEndpointFilteringTests {
	@Test
	void filterByPrefixSingleMatch() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(Config.class)
			.withPropertyValues('foo.primary.name:foo1', 'foo.secondary.name:foo2', 'only.bar.name:solo1');
		assertProperties(contextRunner, 'solo1');
	}
	@Test
	void filterByPrefixMultipleMatches() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(Config.class)
			.withPropertyValues('foo.primary.name:foo1', 'foo.secondary.name:foo2', 'only.bar.name:solo1');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint
				.configurationPropertiesWithPrefix('foo.');
			assertThat(applicationProperties.getContexts()).containsOnlyKeys(context.getId());
			ContextConfigurationPropertiesDescriptor contextProperties = applicationProperties.getContexts()
				.get(context.getId());
			assertThat(contextProperties.getBeans()).containsOnlyKeys('primaryFoo', 'secondaryFoo');
		});
	}
	@Test
	void filterByPrefixNoMatches() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(Config.class)
			.withPropertyValues('foo.primary.name:foo1', 'foo.secondary.name:foo2', 'only.bar.name:solo1');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint
				.configurationPropertiesWithPrefix('foo.third');
			assertThat(applicationProperties.getContexts()).containsOnlyKeys(context.getId());
			ContextConfigurationPropertiesDescriptor contextProperties = applicationProperties.getContexts()
				.get(context.getId());
			assertThat(contextProperties.getBeans()).isEmpty();
		});
	}
	@Test
	void noSanitizationWhenShowAlways() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(ConfigWithAlways.class)
			.withPropertyValues('foo.primary.name:foo1', 'foo.secondary.name:foo2', 'only.bar.name:solo1');
		assertProperties(contextRunner, 'solo1');
	}
	@Test
	void sanitizationWhenShowNever() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(ConfigWithNever.class)
			.withPropertyValues('foo.primary.name:foo1', 'foo.secondary.name:foo2', 'only.bar.name:solo1');
		assertProperties(contextRunner, '******');
	}
	private void assertProperties(ApplicationContextRunner contextRunner, String value) {
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint
				.configurationPropertiesWithPrefix('only.bar');
			assertThat(applicationProperties.getContexts()).containsOnlyKeys(context.getId());
			ContextConfigurationPropertiesDescriptor contextProperties = applicationProperties.getContexts()
				.get(context.getId());
			Optional<String> key = contextProperties.getBeans()
				.keySet()
				.stream()
				.filter((id) -> findIdFromPrefix('only.bar', id))
				.findAny();
			ConfigurationPropertiesBeanDescriptor descriptor = contextProperties.getBeans().get(key.get());
			assertThat(descriptor.getPrefix()).isEqualTo('only.bar');
			assertThat(descriptor.getProperties()).containsEntry('name', value);
		});
	}
	private boolean findIdFromPrefix(String prefix, String id) {
		int separator = id.indexOf('-');
		String candidate = (separator != -1) ? id.substring(0, separator) : id;
		return prefix.equals(candidate);
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	@EnableConfigurationProperties(Bar.class)
	static class Config {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.WHEN_AUTHORIZED);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	@EnableConfigurationProperties(Bar.class)
	static class ConfigWithNever {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.NEVER);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	@EnableConfigurationProperties(Bar.class)
	static class ConfigWithAlways {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(Bar.class)
	static class BaseConfiguration {
		@Bean
		@ConfigurationProperties(prefix = 'foo.primary')
		Foo primaryFoo() {
			return new Foo();
		}
		@Bean
		@ConfigurationProperties(prefix = 'foo.secondary')
		Foo secondaryFoo() {
			return new Foo();
		}
	}
	public static class Foo {
		private String name = '5150';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
	@ConfigurationProperties(prefix = 'only.bar')
	public static class Bar {
		private String name = '123456';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
class ConfigurationPropertiesReportEndpointWebIntegrationTests {
	private WebTestClient client;
	@BeforeEach
	void prepareEnvironment(ConfigurableApplicationContext context, WebTestClient client) {
		TestPropertyValues.of('com.foo.name=fooz', 'com.bar.name=barz').applyTo(context);
		this.client = client;
	}
	@WebEndpointTest
	void noFilters() {
		this.client.get()
			.uri('/actuator/configprops')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$..beans[*]')
			.value(hasSize(greaterThanOrEqualTo(2)))
			.jsonPath('$..beans["fooDotCom"]')
			.exists()
			.jsonPath('$..beans["barDotCom"]')
			.exists();
	}
	@WebEndpointTest
	void filterByExactPrefix() {
		this.client.get()
			.uri('/actuator/configprops/com.foo')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$..beans[*]')
			.value(hasSize(1))
			.jsonPath('$..beans["fooDotCom"]')
			.exists();
	}
	@WebEndpointTest
	void filterByGeneralPrefix() {
		this.client.get()
			.uri('/actuator/configprops/com.')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('$..beans[*]')
			.value(hasSize(2))
			.jsonPath('$..beans["fooDotCom"]')
			.exists()
			.jsonPath('$..beans["barDotCom"]')
			.exists();
	}
	@WebEndpointTest
	void filterByNonExistentPrefix() {
		this.client.get().uri('/actuator/configprops/com.zoo').exchange().expectStatus().isNotFound();
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class TestConfiguration {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), null);
		}
		@Bean
		ConfigurationPropertiesReportEndpointWebExtension endpointWebExtension(
				ConfigurationPropertiesReportEndpoint endpoint) {
			return new ConfigurationPropertiesReportEndpointWebExtension(endpoint, Show.ALWAYS, Collections.emptySet());
		}
		@Bean
		@ConfigurationProperties(prefix = 'com.foo')
		Foo fooDotCom() {
			return new Foo();
		}
		@Bean
		@ConfigurationProperties(prefix = 'com.bar')
		Bar barDotCom() {
			return new Bar();
		}
	}
	public static class Foo {
		private String name = '5150';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
	public static class Bar {
		private String name = '6160';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
class ConfigurationPropertiesReportEndpointWebExtensionTests {
	private ConfigurationPropertiesReportEndpointWebExtension webExtension;
	private ConfigurationPropertiesReportEndpoint delegate;
	@BeforeEach
	void setup() {
		this.delegate = mock(ConfigurationPropertiesReportEndpoint.class);
	}
	@Test
	void whenShowValuesIsNever() {
		this.webExtension = new ConfigurationPropertiesReportEndpointWebExtension(this.delegate, Show.NEVER,
				Collections.emptySet());
		this.webExtension.configurationProperties(null);
		then(this.delegate).should().getConfigurationProperties(false);
		verifyPrefixed(null, false);
	}
	@Test
	void whenShowValuesIsAlways() {
		this.webExtension = new ConfigurationPropertiesReportEndpointWebExtension(this.delegate, Show.ALWAYS,
				Collections.emptySet());
		this.webExtension.configurationProperties(null);
		then(this.delegate).should().getConfigurationProperties(true);
		verifyPrefixed(null, true);
	}
	@Test
	void whenShowValuesIsWhenAuthorizedAndSecurityContextIsAuthorized() {
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
		this.webExtension = new ConfigurationPropertiesReportEndpointWebExtension(this.delegate, Show.WHEN_AUTHORIZED,
				Collections.emptySet());
		this.webExtension.configurationProperties(securityContext);
		then(this.delegate).should().getConfigurationProperties(true);
		verifyPrefixed(securityContext, true);
	}
	@Test
	void whenShowValuesIsWhenAuthorizedAndSecurityContextIsNotAuthorized() {
		SecurityContext securityContext = mock(SecurityContext.class);
		this.webExtension = new ConfigurationPropertiesReportEndpointWebExtension(this.delegate, Show.WHEN_AUTHORIZED,
				Collections.emptySet());
		this.webExtension.configurationProperties(securityContext);
		then(this.delegate).should().getConfigurationProperties(false);
		verifyPrefixed(securityContext, false);
	}
	private void verifyPrefixed(SecurityContext securityContext, boolean showUnsanitized) {
		given(this.delegate.getConfigurationProperties('test', showUnsanitized))
			.willReturn(new ConfigurationPropertiesDescriptor(Collections.emptyMap()));
		this.webExtension.configurationPropertiesWithPrefix(securityContext, 'test');
		then(this.delegate).should().getConfigurationProperties('test', showUnsanitized);
	}
}
/*
package org.springframework.boot.actuate.context.properties;
/**
class ConfigurationPropertiesReportEndpointSerializationTests {
	@Test
	void testNaming() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(FooConfig.class)
			.withPropertyValues('foo.name:foo');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor foo = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(foo).isNotNull();
			assertThat(foo.getPrefix()).isEqualTo('foo');
			Map<String, Object> map = foo.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).hasSize(2);
			assertThat(map).containsEntry('name', 'foo');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testNestedNaming() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(FooConfig.class)
			.withPropertyValues('foo.bar.name:foo');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor foo = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(foo).isNotNull();
			Map<String, Object> map = foo.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).hasSize(2);
			assertThat(((Map<String, Object>) map.get('bar'))).containsEntry('name', 'foo');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testSelfReferentialProperty() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(SelfReferentialConfig.class)
			.withPropertyValues('foo.name:foo');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor foo = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(foo.getPrefix()).isEqualTo('foo');
			Map<String, Object> map = foo.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).containsOnlyKeys('bar', 'name');
			assertThat(map).containsEntry('name', 'foo');
			Map<String, Object> bar = (Map<String, Object>) map.get('bar');
			assertThat(bar).containsOnlyKeys('name');
			assertThat(bar).containsEntry('name', '123456');
		});
	}
	@Test
	void testCycle() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(CycleConfig.class);
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor cycle = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('cycle');
			assertThat(cycle.getPrefix()).isEqualTo('cycle');
			Map<String, Object> map = cycle.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).containsOnlyKeys('error');
			assertThat(map).containsEntry('error', 'Cannot serialize "cycle"');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testMap() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class)
			.withPropertyValues('foo.map.name:foo');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor fooProperties = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(fooProperties).isNotNull();
			assertThat(fooProperties.getPrefix()).isEqualTo('foo');
			Map<String, Object> map = fooProperties.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).hasSize(3);
			assertThat(((Map<String, Object>) map.get('map'))).containsEntry('name', 'foo');
		});
	}
	@Test
	void testEmptyMapIsNotAdded() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class);
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor foo = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(foo).isNotNull();
			assertThat(foo.getPrefix()).isEqualTo('foo');
			Map<String, Object> map = foo.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).hasSize(2);
			assertThat(map).doesNotContainKey('map');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testList() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(ListConfig.class)
			.withPropertyValues('foo.list[0]:foo');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor foo = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(foo).isNotNull();
			assertThat(foo.getPrefix()).isEqualTo('foo');
			Map<String, Object> map = foo.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).hasSize(3);
			assertThat(((List<String>) map.get('list')).get(0)).isEqualTo('foo');
		});
	}
	@Test
	void testInetAddress() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(AddressedConfig.class)
			.withPropertyValues('foo.address:192.168.1.10');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor foo = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(foo).isNotNull();
			assertThat(foo.getPrefix()).isEqualTo('foo');
			Map<String, Object> map = foo.getProperties();
			assertThat(map).isNotNull();
			assertThat(map).hasSize(3);
			assertThat(map).containsEntry('address', '192.168.1.10');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testInitializedMapAndList() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(InitializedMapAndListPropertiesConfig.class)
			.withPropertyValues('foo.map.entryOne:true', 'foo.list[0]:abc');
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor foo = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat(foo.getPrefix()).isEqualTo('foo');
			Map<String, Object> propertiesMap = foo.getProperties();
			assertThat(propertiesMap).containsOnlyKeys('bar', 'name', 'map', 'list');
			Map<String, Object> map = (Map<String, Object>) propertiesMap.get('map');
			assertThat(map).containsOnly(entry('entryOne', true));
			List<String> list = (List<String>) propertiesMap.get('list');
			assertThat(list).containsExactly('abc');
		});
	}
	@Test
	void hikariDataSourceConfigurationPropertiesBeanCanBeSerialized() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(HikariDataSourceConfig.class);
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor hikariDataSource = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('hikariDataSource');
			Map<String, Object> nestedProperties = hikariDataSource.getProperties();
			assertThat(nestedProperties).doesNotContainKey('error');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void endpointResponseUsesToStringOfCharSequenceAsPropertyValue() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withInitializer((context) -> {
			ConfigurableEnvironment environment = context.getEnvironment();
			environment.getPropertySources()
				.addFirst(new MapPropertySource('test',
						Collections.singletonMap('foo.name', new CharSequenceProperty('Spring Boot'))));
		}).withUserConfiguration(FooConfig.class);
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor descriptor = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat((Map<String, Object>) descriptor.getInputs().get('name')).containsEntry('value', 'Spring Boot');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void endpointResponseUsesPlaceholderForComplexValueAsPropertyValue() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner().withInitializer((context) -> {
			ConfigurableEnvironment environment = context.getEnvironment();
			environment.getPropertySources()
				.addFirst(new MapPropertySource('test',
						Collections.singletonMap('foo.name', new ComplexProperty('Spring Boot'))));
		}).withUserConfiguration(ComplexPropertyToStringConverter.class, FooConfig.class);
		contextRunner.run((context) -> {
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor applicationProperties = endpoint.configurationProperties();
			ConfigurationPropertiesBeanDescriptor descriptor = applicationProperties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('foo');
			assertThat((Map<String, Object>) descriptor.getInputs().get('name')).containsEntry('value',
					'Complex property value ' + ComplexProperty.class.getName());
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class Base {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class FooConfig {
		@Bean
		@ConfigurationProperties(prefix = 'foo')
		Foo foo() {
			return new Foo();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class SelfReferentialConfig {
		@Bean
		@ConfigurationProperties(prefix = 'foo')
		SelfReferential foo() {
			return new SelfReferential();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class MetadataCycleConfig {
		@Bean
		@ConfigurationProperties(prefix = 'bar')
		SelfReferential foo() {
			return new SelfReferential();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class MapConfig {
		@Bean
		@ConfigurationProperties(prefix = 'foo')
		MapHolder foo() {
			return new MapHolder();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class ListConfig {
		@Bean
		@ConfigurationProperties(prefix = 'foo')
		ListHolder foo() {
			return new ListHolder();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class MetadataMapConfig {
		@Bean
		@ConfigurationProperties(prefix = 'spam')
		MapHolder foo() {
			return new MapHolder();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class AddressedConfig {
		@Bean
		@ConfigurationProperties(prefix = 'foo')
		Addressed foo() {
			return new Addressed();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class InitializedMapAndListPropertiesConfig {
		@Bean
		@ConfigurationProperties(prefix = 'foo')
		InitializedMapAndListProperties foo() {
			return new InitializedMapAndListProperties();
		}
	}
	public static class Foo {
		private String name = '654321';
		private Bar bar = new Bar();
		public Bar getBar() {
			return this.bar;
		}
		public void setBar(Bar bar) {
			this.bar = bar;
		}
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		// No setter so it doesn"t appear in the report
		public String getSummary() {
			return 'Name: ' + this.name;
		}
		public static class Bar {
			private String name = '123456';
			public String getName() {
				return this.name;
			}
			public void setName(String name) {
				this.name = name;
			}
		}
	}
	public static class SelfReferential extends Foo {
		private Foo self;
		SelfReferential() {
			this.self = this;
		}
		public Foo getSelf() {
			return this.self;
		}
		public void setSelf(Foo self) {
			this.self = self;
		}
	}
	public static class MapHolder extends Foo {
		private Map<String, Object> map;
		public Map<String, Object> getMap() {
			return this.map;
		}
		public void setMap(Map<String, Object> map) {
			this.map = map;
		}
	}
	public static class ListHolder extends Foo {
		private List<String> list;
		public List<String> getList() {
			return this.list;
		}
		public void setList(List<String> list) {
			this.list = list;
		}
	}
	public static class Addressed extends Foo {
		private InetAddress address;
		public InetAddress getAddress() {
			return this.address;
		}
		public void setAddress(InetAddress address) {
			this.address = address;
		}
	}
	public static class InitializedMapAndListProperties extends Foo {
		private final Map<String, Boolean> map = new HashMap<>();
		private final List<String> list = new ArrayList<>();
		public Map<String, Boolean> getMap() {
			return this.map;
		}
		public List<String> getList() {
			return this.list;
		}
	}
	public static class Cycle {
		private final Alpha alpha = new Alpha(this);
		public Alpha getAlpha() {
			return this.alpha;
		}
		public static class Alpha {
			private final Cycle cycle;
			Alpha(Cycle cycle) {
				this.cycle = cycle;
			}
			public Cycle getCycle() {
				return this.cycle;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Base.class)
	static class CycleConfig {
		@Bean
		// gh-11037
		@ConfigurationProperties(prefix = 'cycle')
		Cycle cycle() {
			return new Cycle();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class HikariDataSourceConfig {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
		@Bean
		@ConfigurationProperties(prefix = 'test.datasource')
		HikariDataSource hikariDataSource() {
			return new HikariDataSource();
		}
	}
	static class CharSequenceProperty implements CharSequence, InputStreamSource {
		private final String value;
		CharSequenceProperty(String value) {
			this.value = value;
		}
		@Override
		public int length() {
			return this.value.length();
		}
		@Override
		public char charAt(int index) {
			return this.value.charAt(index);
		}
		@Override
		public CharSequence subSequence(int start, int end) {
			return this.value.subSequence(start, end);
		}
		@Override
		public String toString() {
			return this.value;
		}
		@Override
		public InputStream getInputStream() throws IOException {
			return new ByteArrayInputStream(this.value.getBytes());
		}
	}
	static class ComplexProperty {
		private final String value;
		ComplexProperty(String value) {
			this.value = value;
		}
	}
	@ConfigurationPropertiesBinding
	static class ComplexPropertyToStringConverter implements Converter<ComplexProperty, String> {
		@Override
		public String convert(ComplexProperty source) {
			return source.value;
		}
	}
}
/*
package org.springframework.boot.actuate.context;
/**
class ShutdownEndpointTests {
	@Test
	void shutdown() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withUserConfiguration(EndpointConfig.class);
		contextRunner.run((context) -> {
			EndpointConfig config = context.getBean(EndpointConfig.class);
			ClassLoader previousTccl = Thread.currentThread().getContextClassLoader();
			ShutdownDescriptor result;
			Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[0], getClass().getClassLoader()));
			try {
				result = context.getBean(ShutdownEndpoint.class).shutdown();
			}
			finally {
				Thread.currentThread().setContextClassLoader(previousTccl);
			}
			assertThat(result.getMessage()).startsWith('Shutting down');
			assertThat(context.isActive()).isTrue();
			assertThat(config.latch.await(10, TimeUnit.SECONDS)).isTrue();
			assertThat(config.threadContextClassLoader).isEqualTo(getClass().getClassLoader());
		});
	}
	@Test
	void shutdownChild() throws Exception {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(EmptyConfig.class)
			.child(EndpointConfig.class)
			.web(WebApplicationType.NONE)
			.run();
		CountDownLatch latch = context.getBean(EndpointConfig.class).latch;
		assertThat(context.getBean(ShutdownEndpoint.class).shutdown().getMessage()).startsWith('Shutting down');
		assertThat(context.isActive()).isTrue();
		assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
	}
	@Test
	void shutdownParent() throws Exception {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(EndpointConfig.class)
			.child(EmptyConfig.class)
			.web(WebApplicationType.NONE)
			.run();
		CountDownLatch parentLatch = context.getBean(EndpointConfig.class).latch;
		CountDownLatch childLatch = context.getBean(EmptyConfig.class).latch;
		assertThat(context.getBean(ShutdownEndpoint.class).shutdown().getMessage()).startsWith('Shutting down');
		assertThat(context.isActive()).isTrue();
		assertThat(parentLatch.await(10, TimeUnit.SECONDS)).isTrue();
		assertThat(childLatch.await(10, TimeUnit.SECONDS)).isTrue();
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointConfig {
		private final CountDownLatch latch = new CountDownLatch(1);
		private volatile ClassLoader threadContextClassLoader;
		@Bean
		ShutdownEndpoint endpoint() {
			return new ShutdownEndpoint();
		}
		@Bean
		ApplicationListener<ContextClosedEvent> listener() {
			return (event) -> {
				EndpointConfig.this.threadContextClassLoader = Thread.currentThread().getContextClassLoader();
				EndpointConfig.this.latch.countDown();
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfig {
		private final CountDownLatch latch = new CountDownLatch(1);
		@Bean
		ApplicationListener<ContextClosedEvent> listener() {
			return (event) -> EmptyConfig.this.latch.countDown();
		}
	}
}
/*
package org.springframework.boot.actuate.quartz;
/**
class QuartzEndpointTests {
	private static final JobDetail jobOne = JobBuilder.newJob(Job.class).withIdentity('jobOne').build();
	private static final JobDetail jobTwo = JobBuilder.newJob(DelegatingJob.class).withIdentity('jobTwo').build();
	private static final JobDetail jobThree = JobBuilder.newJob(Job.class).withIdentity('jobThree', 'samples').build();
	private static final Trigger triggerOne = TriggerBuilder.newTrigger()
		.forJob(jobOne)
		.withIdentity('triggerOne')
		.build();
	private static final Trigger triggerTwo = TriggerBuilder.newTrigger()
		.forJob(jobOne)
		.withIdentity('triggerTwo')
		.build();
	private static final Trigger triggerThree = TriggerBuilder.newTrigger()
		.forJob(jobThree)
		.withIdentity('triggerThree', 'samples')
		.build();
	private final Scheduler scheduler;
	private final QuartzEndpoint endpoint;
	QuartzEndpointTests() {
		this.scheduler = mock(Scheduler.class);
		this.endpoint = new QuartzEndpoint(this.scheduler, Collections.emptyList());
	}
	@Test
	void quartzReport() throws SchedulerException {
		given(this.scheduler.getJobGroupNames()).willReturn(Arrays.asList('jobSamples', 'DEFAULT'));
		given(this.scheduler.getTriggerGroupNames()).willReturn(Collections.singletonList('triggerSamples'));
		QuartzDescriptor quartzReport = this.endpoint.quartzReport();
		assertThat(quartzReport.getJobs().getGroups()).containsOnly('jobSamples', 'DEFAULT');
		assertThat(quartzReport.getTriggers().getGroups()).containsOnly('triggerSamples');
		then(this.scheduler).should().getJobGroupNames();
		then(this.scheduler).should().getTriggerGroupNames();
		then(this.scheduler).shouldHaveNoMoreInteractions();
	}
	@Test
	void quartzReportWithNoJob() throws SchedulerException {
		given(this.scheduler.getJobGroupNames()).willReturn(Collections.emptyList());
		given(this.scheduler.getTriggerGroupNames()).willReturn(Arrays.asList('triggerSamples', 'DEFAULT'));
		QuartzDescriptor quartzReport = this.endpoint.quartzReport();
		assertThat(quartzReport.getJobs().getGroups()).isEmpty();
		assertThat(quartzReport.getTriggers().getGroups()).containsOnly('triggerSamples', 'DEFAULT');
	}
	@Test
	void quartzReportWithNoTrigger() throws SchedulerException {
		given(this.scheduler.getJobGroupNames()).willReturn(Collections.singletonList('jobSamples'));
		given(this.scheduler.getTriggerGroupNames()).willReturn(Collections.emptyList());
		QuartzDescriptor quartzReport = this.endpoint.quartzReport();
		assertThat(quartzReport.getJobs().getGroups()).containsOnly('jobSamples');
		assertThat(quartzReport.getTriggers().getGroups()).isEmpty();
	}
	@Test
	void quartzJobGroupsWithExistingGroups() throws SchedulerException {
		mockJobs(jobOne, jobTwo, jobThree);
		Map<String, Object> jobGroups = this.endpoint.quartzJobGroups().getGroups();
		assertThat(jobGroups).containsOnlyKeys('DEFAULT', 'samples');
		assertThat(jobGroups).extractingByKey('DEFAULT', nestedMap())
			.containsOnly(entry('jobs', Arrays.asList('jobOne', 'jobTwo')));
		assertThat(jobGroups).extractingByKey('samples', nestedMap())
			.containsOnly(entry('jobs', Collections.singletonList('jobThree')));
	}
	@Test
	void quartzJobGroupsWithNoGroup() throws SchedulerException {
		given(this.scheduler.getJobGroupNames()).willReturn(Collections.emptyList());
		Map<String, Object> jobGroups = this.endpoint.quartzJobGroups().getGroups();
		assertThat(jobGroups).isEmpty();
	}
	@Test
	void quartzTriggerGroupsWithExistingGroups() throws SchedulerException {
		mockTriggers(triggerOne, triggerTwo, triggerThree);
		given(this.scheduler.getPausedTriggerGroups()).willReturn(Collections.singleton('samples'));
		Map<String, Object> triggerGroups = this.endpoint.quartzTriggerGroups().getGroups();
		assertThat(triggerGroups).containsOnlyKeys('DEFAULT', 'samples');
		assertThat(triggerGroups).extractingByKey('DEFAULT', nestedMap())
			.containsOnly(entry('paused', false), entry('triggers', Arrays.asList('triggerOne', 'triggerTwo')));
		assertThat(triggerGroups).extractingByKey('samples', nestedMap())
			.containsOnly(entry('paused', true), entry('triggers', Collections.singletonList('triggerThree')));
	}
	@Test
	void quartzTriggerGroupsWithNoGroup() throws SchedulerException {
		given(this.scheduler.getTriggerGroupNames()).willReturn(Collections.emptyList());
		Map<String, Object> triggerGroups = this.endpoint.quartzTriggerGroups().getGroups();
		assertThat(triggerGroups).isEmpty();
	}
	@Test
	void quartzJobGroupSummaryWithInvalidGroup() throws SchedulerException {
		given(this.scheduler.getJobGroupNames()).willReturn(Collections.singletonList('DEFAULT'));
		QuartzJobGroupSummaryDescriptor summary = this.endpoint.quartzJobGroupSummary('unknown');
		assertThat(summary).isNull();
	}
	@Test
	void quartzJobGroupSummaryWithEmptyGroup() throws SchedulerException {
		given(this.scheduler.getJobGroupNames()).willReturn(Collections.singletonList('samples'));
		given(this.scheduler.getJobKeys(GroupMatcher.jobGroupEquals('samples'))).willReturn(Collections.emptySet());
		QuartzJobGroupSummaryDescriptor summary = this.endpoint.quartzJobGroupSummary('samples');
		assertThat(summary).isNotNull();
		assertThat(summary.getGroup()).isEqualTo('samples');
		assertThat(summary.getJobs()).isEmpty();
	}
	@Test
	void quartzJobGroupSummaryWithJobs() throws SchedulerException {
		mockJobs(jobOne, jobTwo);
		QuartzJobGroupSummaryDescriptor summary = this.endpoint.quartzJobGroupSummary('DEFAULT');
		assertThat(summary).isNotNull();
		assertThat(summary.getGroup()).isEqualTo('DEFAULT');
		Map<String, QuartzJobSummaryDescriptor> jobSummaries = summary.getJobs();
		assertThat(jobSummaries).containsOnlyKeys('jobOne', 'jobTwo');
		assertThat(jobSummaries.get('jobOne').getClassName()).isEqualTo(Job.class.getName());
		assertThat(jobSummaries.get('jobTwo').getClassName()).isEqualTo(DelegatingJob.class.getName());
	}
	@Test
	void quartzTriggerGroupSummaryWithInvalidGroup() throws SchedulerException {
		given(this.scheduler.getTriggerGroupNames()).willReturn(Collections.singletonList('DEFAULT'));
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('unknown');
		assertThat(summary).isNull();
	}
	@Test
	void quartzTriggerGroupSummaryWithEmptyGroup() throws SchedulerException {
		given(this.scheduler.getTriggerGroupNames()).willReturn(Collections.singletonList('samples'));
		given(this.scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals('samples')))
			.willReturn(Collections.emptySet());
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		assertThat(summary).isNotNull();
		assertThat(summary.getGroup()).isEqualTo('samples');
		assertThat(summary.isPaused()).isFalse();
		assertThat(summary.getTriggers().getCron()).isEmpty();
		assertThat(summary.getTriggers().getSimple()).isEmpty();
		assertThat(summary.getTriggers().getDailyTimeInterval()).isEmpty();
		assertThat(summary.getTriggers().getCalendarInterval()).isEmpty();
		assertThat(summary.getTriggers().getCustom()).isEmpty();
	}
	@Test
	void quartzTriggerGroupSummaryWithCronTrigger() throws SchedulerException {
		CronTrigger cronTrigger = TriggerBuilder.newTrigger()
			.withIdentity('3am-every-day', 'samples')
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0))
			.build();
		mockTriggers(cronTrigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		assertThat(summary.getGroup()).isEqualTo('samples');
		assertThat(summary.isPaused()).isFalse();
		assertThat(summary.getTriggers().getCron()).containsOnlyKeys('3am-every-day');
		assertThat(summary.getTriggers().getSimple()).isEmpty();
		assertThat(summary.getTriggers().getDailyTimeInterval()).isEmpty();
		assertThat(summary.getTriggers().getCalendarInterval()).isEmpty();
		assertThat(summary.getTriggers().getCustom()).isEmpty();
	}
	@Test
	void quartzTriggerGroupSummaryWithCronTriggerDetails() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		TimeZone timeZone = TimeZone.getTimeZone('Europe/Paris');
		CronTrigger cronTrigger = TriggerBuilder.newTrigger()
			.withIdentity('3am-every-day', 'samples')
			.withPriority(3)
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0).inTimeZone(timeZone))
			.build();
		((OperableTrigger) cronTrigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) cronTrigger).setNextFireTime(nextFireTime);
		mockTriggers(cronTrigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		Map<String, Object> triggers = summary.getTriggers().getCron();
		assertThat(triggers).containsOnlyKeys('3am-every-day');
		assertThat(triggers).extractingByKey('3am-every-day', nestedMap())
			.containsOnly(entry('previousFireTime', previousFireTime), entry('nextFireTime', nextFireTime),
					entry('priority', 3), entry('expression', '0 0 3 ? * *'), entry('timeZone', timeZone));
	}
	@Test
	void quartzTriggerGroupSummaryWithSimpleTrigger() throws SchedulerException {
		SimpleTrigger simpleTrigger = TriggerBuilder.newTrigger()
			.withIdentity('every-hour', 'samples')
			.withSchedule(SimpleScheduleBuilder.repeatHourlyForever(1))
			.build();
		mockTriggers(simpleTrigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		assertThat(summary.getGroup()).isEqualTo('samples');
		assertThat(summary.isPaused()).isFalse();
		assertThat(summary.getTriggers().getCron()).isEmpty();
		assertThat(summary.getTriggers().getSimple()).containsOnlyKeys('every-hour');
		assertThat(summary.getTriggers().getDailyTimeInterval()).isEmpty();
		assertThat(summary.getTriggers().getCalendarInterval()).isEmpty();
		assertThat(summary.getTriggers().getCustom()).isEmpty();
	}
	@Test
	void quartzTriggerGroupSummaryWithSimpleTriggerDetails() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		SimpleTrigger simpleTrigger = TriggerBuilder.newTrigger()
			.withIdentity('every-hour', 'samples')
			.withPriority(7)
			.withSchedule(SimpleScheduleBuilder.repeatHourlyForever(1))
			.build();
		((OperableTrigger) simpleTrigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) simpleTrigger).setNextFireTime(nextFireTime);
		mockTriggers(simpleTrigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		Map<String, Object> triggers = summary.getTriggers().getSimple();
		assertThat(triggers).containsOnlyKeys('every-hour');
		assertThat(triggers).extractingByKey('every-hour', nestedMap())
			.containsOnly(entry('previousFireTime', previousFireTime), entry('nextFireTime', nextFireTime),
					entry('priority', 7), entry('interval', 3600000L));
	}
	@Test
	void quartzTriggerGroupSummaryWithDailyIntervalTrigger() throws SchedulerException {
		DailyTimeIntervalTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('every-hour-9am', 'samples')
			.withSchedule(DailyTimeIntervalScheduleBuilder.dailyTimeIntervalSchedule()
				.startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0))
				.withInterval(1, IntervalUnit.HOUR))
			.build();
		mockTriggers(trigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		assertThat(summary.getGroup()).isEqualTo('samples');
		assertThat(summary.isPaused()).isFalse();
		assertThat(summary.getTriggers().getCron()).isEmpty();
		assertThat(summary.getTriggers().getSimple()).isEmpty();
		assertThat(summary.getTriggers().getDailyTimeInterval()).containsOnlyKeys('every-hour-9am');
		assertThat(summary.getTriggers().getCalendarInterval()).isEmpty();
		assertThat(summary.getTriggers().getCustom()).isEmpty();
	}
	@Test
	void quartzTriggerGroupSummaryWithDailyIntervalTriggerDetails() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		DailyTimeIntervalTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('every-hour-tue-thu', 'samples')
			.withPriority(4)
			.withSchedule(DailyTimeIntervalScheduleBuilder.dailyTimeIntervalSchedule()
				.onDaysOfTheWeek(Calendar.TUESDAY, Calendar.THURSDAY)
				.startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0))
				.endingDailyAt(TimeOfDay.hourAndMinuteOfDay(18, 0))
				.withInterval(1, IntervalUnit.HOUR))
			.build();
		((OperableTrigger) trigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) trigger).setNextFireTime(nextFireTime);
		mockTriggers(trigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		Map<String, Object> triggers = summary.getTriggers().getDailyTimeInterval();
		assertThat(triggers).containsOnlyKeys('every-hour-tue-thu');
		assertThat(triggers).extractingByKey('every-hour-tue-thu', nestedMap())
			.containsOnly(entry('previousFireTime', previousFireTime), entry('nextFireTime', nextFireTime),
					entry('priority', 4), entry('interval', 3600000L), entry('startTimeOfDay', LocalTime.of(9, 0)),
					entry('endTimeOfDay', LocalTime.of(18, 0)),
					entry('daysOfWeek', new LinkedHashSet<>(Arrays.asList(3, 5))));
	}
	@Test
	void quartzTriggerGroupSummaryWithCalendarIntervalTrigger() throws SchedulerException {
		CalendarIntervalTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('once-a-week', 'samples')
			.withSchedule(CalendarIntervalScheduleBuilder.calendarIntervalSchedule().withIntervalInWeeks(1))
			.build();
		mockTriggers(trigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		assertThat(summary.getGroup()).isEqualTo('samples');
		assertThat(summary.isPaused()).isFalse();
		assertThat(summary.getTriggers().getCron()).isEmpty();
		assertThat(summary.getTriggers().getSimple()).isEmpty();
		assertThat(summary.getTriggers().getDailyTimeInterval()).isEmpty();
		assertThat(summary.getTriggers().getCalendarInterval()).containsOnlyKeys('once-a-week');
		assertThat(summary.getTriggers().getCustom()).isEmpty();
	}
	@Test
	void quartzTriggerGroupSummaryWithCalendarIntervalTriggerDetails() throws SchedulerException {
		TimeZone timeZone = TimeZone.getTimeZone('Europe/Paris');
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		CalendarIntervalTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('once-a-week', 'samples')
			.withPriority(8)
			.withSchedule(CalendarIntervalScheduleBuilder.calendarIntervalSchedule()
				.withIntervalInWeeks(1)
				.inTimeZone(timeZone))
			.build();
		((OperableTrigger) trigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) trigger).setNextFireTime(nextFireTime);
		mockTriggers(trigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		Map<String, Object> triggers = summary.getTriggers().getCalendarInterval();
		assertThat(triggers).containsOnlyKeys('once-a-week');
		assertThat(triggers).extractingByKey('once-a-week', nestedMap())
			.containsOnly(entry('previousFireTime', previousFireTime), entry('nextFireTime', nextFireTime),
					entry('priority', 8), entry('interval', 604800000L), entry('timeZone', timeZone));
	}
	@Test
	void quartzTriggerGroupSummaryWithCustomTrigger() throws SchedulerException {
		Trigger trigger = mock(Trigger.class);
		given(trigger.getKey()).willReturn(TriggerKey.triggerKey('custom', 'samples'));
		mockTriggers(trigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		assertThat(summary.getGroup()).isEqualTo('samples');
		assertThat(summary.isPaused()).isFalse();
		assertThat(summary.getTriggers().getCron()).isEmpty();
		assertThat(summary.getTriggers().getSimple()).isEmpty();
		assertThat(summary.getTriggers().getDailyTimeInterval()).isEmpty();
		assertThat(summary.getTriggers().getCalendarInterval()).isEmpty();
		assertThat(summary.getTriggers().getCustom()).containsOnlyKeys('custom');
	}
	@Test
	void quartzTriggerGroupSummaryWithCustomTriggerDetails() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		Trigger trigger = mock(Trigger.class);
		given(trigger.getKey()).willReturn(TriggerKey.triggerKey('custom', 'samples'));
		given(trigger.getPreviousFireTime()).willReturn(previousFireTime);
		given(trigger.getNextFireTime()).willReturn(nextFireTime);
		given(trigger.getPriority()).willReturn(9);
		mockTriggers(trigger);
		QuartzTriggerGroupSummaryDescriptor summary = this.endpoint.quartzTriggerGroupSummary('samples');
		Map<String, Object> triggers = summary.getTriggers().getCustom();
		assertThat(triggers).containsOnlyKeys('custom');
		assertThat(triggers).extractingByKey('custom', nestedMap())
			.containsOnly(entry('previousFireTime', previousFireTime), entry('nextFireTime', nextFireTime),
					entry('priority', 9), entry('trigger', trigger.toString()));
	}
	@Test
	void quartzTriggerWithCronTrigger() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		TimeZone timeZone = TimeZone.getTimeZone('Europe/Paris');
		CronTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('3am-every-day', 'samples')
			.withPriority(3)
			.withDescription('Sample description')
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0).inTimeZone(timeZone))
			.build();
		((OperableTrigger) trigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) trigger).setNextFireTime(nextFireTime);
		mockTriggers(trigger);
		given(this.scheduler.getTriggerState(TriggerKey.triggerKey('3am-every-day', 'samples')))
			.willReturn(TriggerState.NORMAL);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', '3am-every-day', true);
		assertThat(triggerDetails).contains(entry('group', 'samples'), entry('name', '3am-every-day'),
				entry('description', 'Sample description'), entry('type', 'cron'), entry('state', TriggerState.NORMAL),
				entry('priority', 3));
		assertThat(triggerDetails).contains(entry('previousFireTime', previousFireTime),
				entry('nextFireTime', nextFireTime));
		assertThat(triggerDetails).doesNotContainKeys('simple', 'dailyTimeInterval', 'calendarInterval', 'custom');
		assertThat(triggerDetails).extractingByKey('cron', nestedMap())
			.containsOnly(entry('expression', '0 0 3 ? * *'), entry('timeZone', timeZone));
	}
	@Test
	void quartzTriggerWithSimpleTrigger() throws SchedulerException {
		Date startTime = Date.from(Instant.parse('2020-01-01T09:00:00Z'));
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		Date endTime = Date.from(Instant.parse('2020-01-31T09:00:00Z'));
		SimpleTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('every-hour', 'samples')
			.withPriority(20)
			.withDescription('Every hour')
			.startAt(startTime)
			.endAt(endTime)
			.withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInHours(1).withRepeatCount(2000))
			.build();
		((OperableTrigger) trigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) trigger).setNextFireTime(nextFireTime);
		mockTriggers(trigger);
		given(this.scheduler.getTriggerState(TriggerKey.triggerKey('every-hour', 'samples')))
			.willReturn(TriggerState.COMPLETE);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', 'every-hour', true);
		assertThat(triggerDetails).contains(entry('group', 'samples'), entry('name', 'every-hour'),
				entry('description', 'Every hour'), entry('type', 'simple'), entry('state', TriggerState.COMPLETE),
				entry('priority', 20));
		assertThat(triggerDetails).contains(entry('startTime', startTime), entry('previousFireTime', previousFireTime),
				entry('nextFireTime', nextFireTime), entry('endTime', endTime));
		assertThat(triggerDetails).doesNotContainKeys('cron', 'dailyTimeInterval', 'calendarInterval', 'custom');
		assertThat(triggerDetails).extractingByKey('simple', nestedMap())
			.containsOnly(entry('interval', 3600000L), entry('repeatCount', 2000), entry('timesTriggered', 0));
	}
	@Test
	void quartzTriggerWithDailyTimeIntervalTrigger() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		DailyTimeIntervalTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('every-hour-mon-wed', 'samples')
			.withDescription('Every working hour Mon Wed')
			.withPriority(4)
			.withSchedule(DailyTimeIntervalScheduleBuilder.dailyTimeIntervalSchedule()
				.onDaysOfTheWeek(Calendar.MONDAY, Calendar.WEDNESDAY)
				.startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0))
				.endingDailyAt(TimeOfDay.hourAndMinuteOfDay(18, 0))
				.withInterval(1, IntervalUnit.HOUR))
			.build();
		((OperableTrigger) trigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) trigger).setNextFireTime(nextFireTime);
		mockTriggers(trigger);
		given(this.scheduler.getTriggerState(TriggerKey.triggerKey('every-hour-mon-wed', 'samples')))
			.willReturn(TriggerState.NORMAL);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', 'every-hour-mon-wed', true);
		assertThat(triggerDetails).contains(entry('group', 'samples'), entry('name', 'every-hour-mon-wed'),
				entry('description', 'Every working hour Mon Wed'), entry('type', 'dailyTimeInterval'),
				entry('state', TriggerState.NORMAL), entry('priority', 4));
		assertThat(triggerDetails).contains(entry('previousFireTime', previousFireTime),
				entry('nextFireTime', nextFireTime));
		assertThat(triggerDetails).doesNotContainKeys('cron', 'simple', 'calendarInterval', 'custom');
		assertThat(triggerDetails).extractingByKey('dailyTimeInterval', nestedMap())
			.containsOnly(entry('interval', 3600000L), entry('startTimeOfDay', LocalTime.of(9, 0)),
					entry('endTimeOfDay', LocalTime.of(18, 0)),
					entry('daysOfWeek', new LinkedHashSet<>(Arrays.asList(2, 4))), entry('repeatCount', -1),
					entry('timesTriggered', 0));
	}
	@Test
	void quartzTriggerWithCalendarTimeIntervalTrigger() throws SchedulerException {
		TimeZone timeZone = TimeZone.getTimeZone('Europe/Paris');
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		CalendarIntervalTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('once-a-week', 'samples')
			.withDescription('Once a week')
			.withPriority(8)
			.withSchedule(CalendarIntervalScheduleBuilder.calendarIntervalSchedule()
				.withIntervalInWeeks(1)
				.inTimeZone(timeZone)
				.preserveHourOfDayAcrossDaylightSavings(true))
			.build();
		((OperableTrigger) trigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) trigger).setNextFireTime(nextFireTime);
		mockTriggers(trigger);
		given(this.scheduler.getTriggerState(TriggerKey.triggerKey('once-a-week', 'samples')))
			.willReturn(TriggerState.BLOCKED);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', 'once-a-week', true);
		assertThat(triggerDetails).contains(entry('group', 'samples'), entry('name', 'once-a-week'),
				entry('description', 'Once a week'), entry('type', 'calendarInterval'),
				entry('state', TriggerState.BLOCKED), entry('priority', 8));
		assertThat(triggerDetails).contains(entry('previousFireTime', previousFireTime),
				entry('nextFireTime', nextFireTime));
		assertThat(triggerDetails).doesNotContainKeys('cron', 'simple', 'dailyTimeInterval', 'custom');
		assertThat(triggerDetails).extractingByKey('calendarInterval', nestedMap())
			.containsOnly(entry('interval', 604800000L), entry('timeZone', timeZone),
					entry('preserveHourOfDayAcrossDaylightSavings', true), entry('skipDayIfHourDoesNotExist', false),
					entry('timesTriggered', 0));
	}
	@Test
	void quartzTriggerWithCustomTrigger() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		Trigger trigger = mock(Trigger.class);
		given(trigger.getKey()).willReturn(TriggerKey.triggerKey('custom', 'samples'));
		given(trigger.getPreviousFireTime()).willReturn(previousFireTime);
		given(trigger.getNextFireTime()).willReturn(nextFireTime);
		given(trigger.getPriority()).willReturn(9);
		mockTriggers(trigger);
		given(this.scheduler.getTriggerState(TriggerKey.triggerKey('custom', 'samples')))
			.willReturn(TriggerState.ERROR);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', 'custom', true);
		assertThat(triggerDetails).contains(entry('group', 'samples'), entry('name', 'custom'), entry('type', 'custom'),
				entry('state', TriggerState.ERROR), entry('priority', 9));
		assertThat(triggerDetails).contains(entry('previousFireTime', previousFireTime),
				entry('nextFireTime', nextFireTime));
		assertThat(triggerDetails).doesNotContainKeys('cron', 'simple', 'calendarInterval', 'dailyTimeInterval');
		assertThat(triggerDetails).extractingByKey('custom', nestedMap())
			.containsOnly(entry('trigger', trigger.toString()));
	}
	@Test
	void quartzTriggerWithDataMap() throws SchedulerException {
		CronTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('3am-every-day', 'samples')
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0))
			.usingJobData('user', 'user')
			.usingJobData('password', 'secret')
			.usingJobData('url', 'https://user:secret@example.com')
			.build();
		mockTriggers(trigger);
		given(this.scheduler.getTriggerState(TriggerKey.triggerKey('3am-every-day', 'samples')))
			.willReturn(TriggerState.NORMAL);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', '3am-every-day', true);
		assertThat(triggerDetails).extractingByKey('data', nestedMap())
			.containsOnly(entry('user', 'user'), entry('password', 'secret'),
					entry('url', 'https://user:secret@example.com'));
	}
	@Test
	void quartzTriggerWithDataMapAndShowUnsanitizedFalse() throws SchedulerException {
		CronTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('3am-every-day', 'samples')
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0))
			.usingJobData('user', 'user')
			.usingJobData('password', 'secret')
			.usingJobData('url', 'https://user:secret@example.com')
			.build();
		mockTriggers(trigger);
		given(this.scheduler.getTriggerState(TriggerKey.triggerKey('3am-every-day', 'samples')))
			.willReturn(TriggerState.NORMAL);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', '3am-every-day', false);
		assertThat(triggerDetails).extractingByKey('data', nestedMap())
			.containsOnly(entry('user', '******'), entry('password', '******'), entry('url', '******'));
	}
	@ParameterizedTest(name = 'unit {1}')
	@MethodSource('intervalUnitParameters')
	void canConvertIntervalUnit(int amount, IntervalUnit unit, Duration expectedDuration) throws SchedulerException {
		CalendarIntervalTrigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('trigger', 'samples')
			.withSchedule(CalendarIntervalScheduleBuilder.calendarIntervalSchedule().withInterval(amount, unit))
			.build();
		mockTriggers(trigger);
		Map<String, Object> triggerDetails = this.endpoint.quartzTrigger('samples', 'trigger', true);
		assertThat(triggerDetails).extractingByKey('calendarInterval', nestedMap())
			.contains(entry('interval', expectedDuration.toMillis()));
	}
	static Stream<Arguments> intervalUnitParameters() {
		return Stream.of(Arguments.of(3, IntervalUnit.DAY, Duration.ofDays(3)),
				Arguments.of(2, IntervalUnit.HOUR, Duration.ofHours(2)),
				Arguments.of(5, IntervalUnit.MINUTE, Duration.ofMinutes(5)),
				Arguments.of(1, IntervalUnit.MONTH, ChronoUnit.MONTHS.getDuration()),
				Arguments.of(30, IntervalUnit.SECOND, Duration.ofSeconds(30)),
				Arguments.of(100, IntervalUnit.MILLISECOND, Duration.ofMillis(100)),
				Arguments.of(1, IntervalUnit.WEEK, ChronoUnit.WEEKS.getDuration()),
				Arguments.of(1, IntervalUnit.YEAR, ChronoUnit.YEARS.getDuration()));
	}
	@Test
	void quartzJobWithoutTrigger() throws SchedulerException {
		JobDetail job = JobBuilder.newJob(Job.class)
			.withIdentity('hello', 'samples')
			.withDescription('A sample job')
			.storeDurably()
			.requestRecovery(false)
			.build();
		mockJobs(job);
		QuartzJobDetailsDescriptor jobDetails = this.endpoint.quartzJob('samples', 'hello', true);
		assertThat(jobDetails.getGroup()).isEqualTo('samples');
		assertThat(jobDetails.getName()).isEqualTo('hello');
		assertThat(jobDetails.getDescription()).isEqualTo('A sample job');
		assertThat(jobDetails.getClassName()).isEqualTo(Job.class.getName());
		assertThat(jobDetails.isDurable()).isTrue();
		assertThat(jobDetails.isRequestRecovery()).isFalse();
		assertThat(jobDetails.getData()).isEmpty();
		assertThat(jobDetails.getTriggers()).isEmpty();
	}
	@Test
	void quartzJobWithTrigger() throws SchedulerException {
		Date previousFireTime = Date.from(Instant.parse('2020-11-30T03:00:00Z'));
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		JobDetail job = JobBuilder.newJob(Job.class).withIdentity('hello', 'samples').build();
		TimeZone timeZone = TimeZone.getTimeZone('Europe/Paris');
		Trigger trigger = TriggerBuilder.newTrigger()
			.withIdentity('3am-every-day', 'samples')
			.withPriority(4)
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0).inTimeZone(timeZone))
			.build();
		((OperableTrigger) trigger).setPreviousFireTime(previousFireTime);
		((OperableTrigger) trigger).setNextFireTime(nextFireTime);
		mockJobs(job);
		mockTriggers(trigger);
		given(this.scheduler.getTriggersOfJob(JobKey.jobKey('hello', 'samples')))
			.willAnswer((invocation) -> Collections.singletonList(trigger));
		QuartzJobDetailsDescriptor jobDetails = this.endpoint.quartzJob('samples', 'hello', true);
		assertThat(jobDetails.getTriggers()).hasSize(1);
		Map<String, Object> triggerDetails = jobDetails.getTriggers().get(0);
		assertThat(triggerDetails).containsOnly(entry('group', 'samples'), entry('name', '3am-every-day'),
				entry('previousFireTime', previousFireTime), entry('nextFireTime', nextFireTime), entry('priority', 4));
	}
	@Test
	void quartzJobOrdersTriggersAccordingToNextFireTime() throws SchedulerException {
		JobDetail job = JobBuilder.newJob(Job.class).withIdentity('hello', 'samples').build();
		mockJobs(job);
		Date triggerOneNextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		CronTrigger triggerOne = TriggerBuilder.newTrigger()
			.withIdentity('one', 'samples')
			.withPriority(5)
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0))
			.build();
		((OperableTrigger) triggerOne).setNextFireTime(triggerOneNextFireTime);
		Date triggerTwoNextFireTime = Date.from(Instant.parse('2020-12-01T02:00:00Z'));
		CronTrigger triggerTwo = TriggerBuilder.newTrigger()
			.withIdentity('two', 'samples')
			.withPriority(10)
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(2, 0))
			.build();
		((OperableTrigger) triggerTwo).setNextFireTime(triggerTwoNextFireTime);
		mockTriggers(triggerOne, triggerTwo);
		given(this.scheduler.getTriggersOfJob(JobKey.jobKey('hello', 'samples')))
			.willAnswer((invocation) -> Arrays.asList(triggerOne, triggerTwo));
		QuartzJobDetailsDescriptor jobDetails = this.endpoint.quartzJob('samples', 'hello', true);
		assertThat(jobDetails.getTriggers()).hasSize(2);
		assertThat(jobDetails.getTriggers().get(0)).containsEntry('name', 'two');
		assertThat(jobDetails.getTriggers().get(1)).containsEntry('name', 'one');
	}
	@Test
	void quartzJobOrdersTriggersAccordingNextFireTimeAndPriority() throws SchedulerException {
		JobDetail job = JobBuilder.newJob(Job.class).withIdentity('hello', 'samples').build();
		mockJobs(job);
		Date nextFireTime = Date.from(Instant.parse('2020-12-01T03:00:00Z'));
		CronTrigger triggerOne = TriggerBuilder.newTrigger()
			.withIdentity('one', 'samples')
			.withPriority(3)
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0))
			.build();
		((OperableTrigger) triggerOne).setNextFireTime(nextFireTime);
		CronTrigger triggerTwo = TriggerBuilder.newTrigger()
			.withIdentity('two', 'samples')
			.withPriority(7)
			.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0))
			.build();
		((OperableTrigger) triggerTwo).setNextFireTime(nextFireTime);
		mockTriggers(triggerOne, triggerTwo);
		given(this.scheduler.getTriggersOfJob(JobKey.jobKey('hello', 'samples')))
			.willAnswer((invocation) -> Arrays.asList(triggerOne, triggerTwo));
		QuartzJobDetailsDescriptor jobDetails = this.endpoint.quartzJob('samples', 'hello', true);
		assertThat(jobDetails.getTriggers()).hasSize(2);
		assertThat(jobDetails.getTriggers().get(0)).containsEntry('name', 'two');
		assertThat(jobDetails.getTriggers().get(1)).containsEntry('name', 'one');
	}
	@Test
	void quartzJobWithDataMap() throws SchedulerException {
		JobDetail job = JobBuilder.newJob(Job.class)
			.withIdentity('hello', 'samples')
			.usingJobData('user', 'user')
			.usingJobData('password', 'secret')
			.usingJobData('url', 'https://user:secret@example.com')
			.build();
		mockJobs(job);
		QuartzJobDetailsDescriptor jobDetails = this.endpoint.quartzJob('samples', 'hello', true);
		assertThat(jobDetails.getData()).containsOnly(entry('user', 'user'), entry('password', 'secret'),
				entry('url', 'https://user:secret@example.com'));
	}
	@Test
	void quartzJobWithDataMapAndShowUnsanitizedFalse() throws SchedulerException {
		JobDetail job = JobBuilder.newJob(Job.class)
			.withIdentity('hello', 'samples')
			.usingJobData('user', 'user')
			.usingJobData('password', 'secret')
			.usingJobData('url', 'https://user:secret@example.com')
			.build();
		mockJobs(job);
		QuartzJobDetailsDescriptor jobDetails = this.endpoint.quartzJob('samples', 'hello', false);
		assertThat(jobDetails.getData()).containsOnly(entry('user', '******'), entry('password', '******'),
				entry('url', '******'));
	}
	private void mockJobs(JobDetail... jobs) throws SchedulerException {
		MultiValueMap<String, JobKey> jobKeys = new LinkedMultiValueMap<>();
		for (JobDetail jobDetail : jobs) {
			JobKey key = jobDetail.getKey();
			given(this.scheduler.getJobDetail(key)).willReturn(jobDetail);
			jobKeys.add(key.getGroup(), key);
		}
		given(this.scheduler.getJobGroupNames()).willReturn(new ArrayList<>(jobKeys.keySet()));
		for (Entry<String, List<JobKey>> entry : jobKeys.entrySet()) {
			given(this.scheduler.getJobKeys(GroupMatcher.jobGroupEquals(entry.getKey())))
				.willReturn(new LinkedHashSet<>(entry.getValue()));
		}
	}
	private void mockTriggers(Trigger... triggers) throws SchedulerException {
		MultiValueMap<String, TriggerKey> triggerKeys = new LinkedMultiValueMap<>();
		for (Trigger trigger : triggers) {
			TriggerKey key = trigger.getKey();
			given(this.scheduler.getTrigger(key)).willReturn(trigger);
			triggerKeys.add(key.getGroup(), key);
		}
		given(this.scheduler.getTriggerGroupNames()).willReturn(new ArrayList<>(triggerKeys.keySet()));
		for (Entry<String, List<TriggerKey>> entry : triggerKeys.entrySet()) {
			given(this.scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(entry.getKey())))
				.willReturn(new LinkedHashSet<>(entry.getValue()));
		}
	}
	@SuppressWarnings('rawtypes')
	private static InstanceOfAssertFactory<Map, MapAssert<String, Object>> nestedMap() {
		return InstanceOfAssertFactories.map(String.class, Object.class);
	}
}
/*
package org.springframework.boot.actuate.quartz;
/**
class QuartzEndpointWebExtensionTests {
	private QuartzEndpointWebExtension webExtension;
	private QuartzEndpoint delegate;
	@BeforeEach
	void setup() {
		this.delegate = mock(QuartzEndpoint.class);
	}
	@Test
	void whenShowValuesIsNever() throws Exception {
		this.webExtension = new QuartzEndpointWebExtension(this.delegate, Show.NEVER, Collections.emptySet());
		this.webExtension.quartzJobOrTrigger(null, 'jobs', 'a', 'b');
		this.webExtension.quartzJobOrTrigger(null, 'triggers', 'a', 'b');
		then(this.delegate).should().quartzJob('a', 'b', false);
		then(this.delegate).should().quartzTrigger('a', 'b', false);
	}
	@Test
	void whenShowValuesIsAlways() throws Exception {
		this.webExtension = new QuartzEndpointWebExtension(this.delegate, Show.ALWAYS, Collections.emptySet());
		this.webExtension.quartzJobOrTrigger(null, 'a', 'b', 'c');
		this.webExtension.quartzJobOrTrigger(null, 'jobs', 'a', 'b');
		this.webExtension.quartzJobOrTrigger(null, 'triggers', 'a', 'b');
		then(this.delegate).should().quartzJob('a', 'b', true);
		then(this.delegate).should().quartzTrigger('a', 'b', true);
	}
	@Test
	void whenShowValuesIsWhenAuthorizedAndSecurityContextIsAuthorized() throws Exception {
		SecurityContext securityContext = mock(SecurityContext.class);
		given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
		this.webExtension = new QuartzEndpointWebExtension(this.delegate, Show.WHEN_AUTHORIZED, Collections.emptySet());
		this.webExtension.quartzJobOrTrigger(securityContext, 'jobs', 'a', 'b');
		this.webExtension.quartzJobOrTrigger(securityContext, 'triggers', 'a', 'b');
		then(this.delegate).should().quartzJob('a', 'b', true);
		then(this.delegate).should().quartzTrigger('a', 'b', true);
	}
	@Test
	void whenShowValuesIsWhenAuthorizedAndSecurityContextIsNotAuthorized() throws Exception {
		SecurityContext securityContext = mock(SecurityContext.class);
		this.webExtension = new QuartzEndpointWebExtension(this.delegate, Show.WHEN_AUTHORIZED, Collections.emptySet());
		this.webExtension.quartzJobOrTrigger(securityContext, 'jobs', 'a', 'b');
		this.webExtension.quartzJobOrTrigger(securityContext, 'triggers', 'a', 'b');
		then(this.delegate).should().quartzJob('a', 'b', false);
		then(this.delegate).should().quartzTrigger('a', 'b', false);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new QuartzEndpointWebExtensionRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		Set<Class<?>> bindingTypes = Set.of(QuartzGroupsDescriptor.class, QuartzJobDetailsDescriptor.class,
				QuartzJobGroupSummaryDescriptor.class, QuartzTriggerGroupSummaryDescriptor.class);
		for (Class<?> bindingType : bindingTypes) {
			assertThat(RuntimeHintsPredicates.reflection()
				.onType(bindingType)
				.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.DECLARED_FIELDS))
				.accepts(runtimeHints);
		}
	}
}
/*
package org.springframework.boot.actuate.quartz;
/**
class QuartzEndpointWebIntegrationTests {
	private static final JobDetail jobOne = JobBuilder.newJob(Job.class)
		.withIdentity('jobOne', 'samples')
		.usingJobData(new JobDataMap(Collections.singletonMap('name', 'test')))
		.withDescription('A sample job')
		.build();
	private static final JobDetail jobTwo = JobBuilder.newJob(DelegatingJob.class)
		.withIdentity('jobTwo', 'samples')
		.build();
	private static final JobDetail jobThree = JobBuilder.newJob(Job.class).withIdentity('jobThree').build();
	private static final CronTrigger triggerOne = TriggerBuilder.newTrigger()
		.withDescription('Once a day 3AM')
		.withIdentity('triggerOne')
		.withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(3, 0))
		.build();
	private static final SimpleTrigger triggerTwo = TriggerBuilder.newTrigger()
		.withDescription('Once a day')
		.withIdentity('triggerTwo', 'tests')
		.withSchedule(SimpleScheduleBuilder.repeatHourlyForever(24))
		.build();
	private static final CalendarIntervalTrigger triggerThree = TriggerBuilder.newTrigger()
		.withDescription('Once a week')
		.withIdentity('triggerThree', 'tests')
		.withSchedule(CalendarIntervalScheduleBuilder.calendarIntervalSchedule().withIntervalInWeeks(1))
		.build();
	@WebEndpointTest
	void quartzReport(WebTestClient client) {
		client.get()
			.uri('/actuator/quartz')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('jobs.groups')
			.isEqualTo(new JSONArray().appendElement('samples').appendElement('DEFAULT'))
			.jsonPath('triggers.groups')
			.isEqualTo(new JSONArray().appendElement('DEFAULT').appendElement('tests'));
	}
	@WebEndpointTest
	void quartzJobNames(WebTestClient client) {
		client.get()
			.uri('/actuator/quartz/jobs')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('groups.samples.jobs')
			.isEqualTo(new JSONArray().appendElement('jobOne').appendElement('jobTwo'))
			.jsonPath('groups.DEFAULT.jobs')
			.isEqualTo(new JSONArray().appendElement('jobThree'));
	}
	@WebEndpointTest
	void quartzTriggerNames(WebTestClient client) {
		client.get()
			.uri('/actuator/quartz/triggers')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('groups.DEFAULT.paused')
			.isEqualTo(false)
			.jsonPath('groups.DEFAULT.triggers')
			.isEqualTo(new JSONArray().appendElement('triggerOne'))
			.jsonPath('groups.tests.paused')
			.isEqualTo(false)
			.jsonPath('groups.tests.triggers')
			.isEqualTo(new JSONArray().appendElement('triggerTwo').appendElement('triggerThree'));
	}
	@WebEndpointTest
	void quartzTriggersOrJobsAreAllowed(WebTestClient client) {
		client.get().uri('/actuator/quartz/something-else').exchange().expectStatus().isBadRequest();
	}
	@WebEndpointTest
	void quartzJobGroupSummary(WebTestClient client) {
		client.get()
			.uri('/actuator/quartz/jobs/samples')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('group')
			.isEqualTo('samples')
			.jsonPath('jobs.jobOne.className')
			.isEqualTo(Job.class.getName())
			.jsonPath('jobs.jobTwo.className')
			.isEqualTo(DelegatingJob.class.getName());
	}
	@WebEndpointTest
	void quartzJobGroupSummaryWithUnknownGroup(WebTestClient client) {
		client.get().uri('/actuator/quartz/jobs/does-not-exist').exchange().expectStatus().isNotFound();
	}
	@WebEndpointTest
	void quartzTriggerGroupSummary(WebTestClient client) {
		client.get()
			.uri('/actuator/quartz/triggers/tests')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('group')
			.isEqualTo('tests')
			.jsonPath('paused')
			.isEqualTo('false')
			.jsonPath('triggers.cron')
			.isEmpty()
			.jsonPath('triggers.simple.triggerTwo.interval')
			.isEqualTo(86400000)
			.jsonPath('triggers.dailyTimeInterval')
			.isEmpty()
			.jsonPath('triggers.calendarInterval.triggerThree.interval')
			.isEqualTo(604800000)
			.jsonPath('triggers.custom')
			.isEmpty();
	}
	@WebEndpointTest
	void quartzTriggerGroupSummaryWithUnknownGroup(WebTestClient client) {
		client.get().uri('/actuator/quartz/triggers/does-not-exist').exchange().expectStatus().isNotFound();
	}
	@WebEndpointTest
	void quartzJobDetail(WebTestClient client) {
		client.get()
			.uri('/actuator/quartz/jobs/samples/jobOne')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('group')
			.isEqualTo('samples')
			.jsonPath('name')
			.isEqualTo('jobOne')
			.jsonPath('data.name')
			.isEqualTo('test');
	}
	@WebEndpointTest
	void quartzJobDetailWithUnknownKey(WebTestClient client) {
		client.get().uri('/actuator/quartz/jobs/samples/does-not-exist').exchange().expectStatus().isNotFound();
	}
	@WebEndpointTest
	void quartzTriggerDetail(WebTestClient client) {
		client.get()
			.uri('/actuator/quartz/triggers/DEFAULT/triggerOne')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('group')
			.isEqualTo('DEFAULT')
			.jsonPath('name')
			.isEqualTo('triggerOne')
			.jsonPath('description')
			.isEqualTo('Once a day 3AM')
			.jsonPath('state')
			.isEqualTo('NORMAL')
			.jsonPath('type')
			.isEqualTo('cron')
			.jsonPath('simple')
			.doesNotExist()
			.jsonPath('calendarInterval')
			.doesNotExist()
			.jsonPath('dailyInterval')
			.doesNotExist()
			.jsonPath('custom')
			.doesNotExist()
			.jsonPath('cron.expression')
			.isEqualTo('0 0 3 ? * *');
	}
	@WebEndpointTest
	void quartzTriggerDetailWithUnknownKey(WebTestClient client) {
		client.get().uri('/actuator/quartz/triggers/tests/does-not-exist').exchange().expectStatus().isNotFound();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		Scheduler scheduler() throws SchedulerException {
			Scheduler scheduler = mock(Scheduler.class);
			mockJobs(scheduler, jobOne, jobTwo, jobThree);
			mockTriggers(scheduler, triggerOne, triggerTwo, triggerThree);
			return scheduler;
		}
		@Bean
		QuartzEndpoint endpoint(Scheduler scheduler) {
			return new QuartzEndpoint(scheduler, Collections.emptyList());
		}
		@Bean
		QuartzEndpointWebExtension quartzEndpointWebExtension(QuartzEndpoint endpoint) {
			return new QuartzEndpointWebExtension(endpoint, Show.ALWAYS, Collections.emptySet());
		}
		private void mockJobs(Scheduler scheduler, JobDetail... jobs) throws SchedulerException {
			MultiValueMap<String, JobKey> jobKeys = new LinkedMultiValueMap<>();
			for (JobDetail jobDetail : jobs) {
				JobKey key = jobDetail.getKey();
				given(scheduler.getJobDetail(key)).willReturn(jobDetail);
				jobKeys.add(key.getGroup(), key);
			}
			given(scheduler.getJobGroupNames()).willReturn(new ArrayList<>(jobKeys.keySet()));
			for (Entry<String, List<JobKey>> entry : jobKeys.entrySet()) {
				given(scheduler.getJobKeys(GroupMatcher.jobGroupEquals(entry.getKey())))
					.willReturn(new LinkedHashSet<>(entry.getValue()));
			}
		}
		void mockTriggers(Scheduler scheduler, Trigger... triggers) throws SchedulerException {
			MultiValueMap<String, TriggerKey> triggerKeys = new LinkedMultiValueMap<>();
			for (Trigger trigger : triggers) {
				TriggerKey key = trigger.getKey();
				given(scheduler.getTrigger(key)).willReturn(trigger);
				given(scheduler.getTriggerState(key)).willReturn(TriggerState.NORMAL);
				triggerKeys.add(key.getGroup(), key);
			}
			given(scheduler.getTriggerGroupNames()).willReturn(new ArrayList<>(triggerKeys.keySet()));
			for (Entry<String, List<TriggerKey>> entry : triggerKeys.entrySet()) {
				given(scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(entry.getKey())))
					.willReturn(new LinkedHashSet<>(entry.getValue()));
			}
		}
	}
}
/*
package org.springframework.boot.actuate.cache;
/**
class CachesEndpointWebIntegrationTests {
	@WebEndpointTest
	void allCaches(WebTestClient client) {
		client.get()
			.uri('/actuator/caches')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('cacheManagers.one.caches.a.target')
			.isEqualTo(ConcurrentHashMap.class.getName())
			.jsonPath('cacheManagers.one.caches.b.target')
			.isEqualTo(ConcurrentHashMap.class.getName())
			.jsonPath('cacheManagers.two.caches.a.target')
			.isEqualTo(ConcurrentHashMap.class.getName())
			.jsonPath('cacheManagers.two.caches.c.target')
			.isEqualTo(ConcurrentHashMap.class.getName());
	}
	@WebEndpointTest
	void namedCache(WebTestClient client) {
		client.get()
			.uri('/actuator/caches/b')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('name')
			.isEqualTo('b')
			.jsonPath('cacheManager')
			.isEqualTo('one')
			.jsonPath('target')
			.isEqualTo(ConcurrentHashMap.class.getName());
	}
	@WebEndpointTest
	void namedCacheWithUnknownName(WebTestClient client) {
		client.get().uri('/actuator/caches/does-not-exist').exchange().expectStatus().isNotFound();
	}
	@WebEndpointTest
	void namedCacheWithNonUniqueName(WebTestClient client) {
		client.get().uri('/actuator/caches/a').exchange().expectStatus().isBadRequest();
	}
	@WebEndpointTest
	void clearNamedCache(WebTestClient client, ApplicationContext context) {
		Cache b = context.getBean('one', CacheManager.class).getCache('b');
		b.put('test', 'value');
		client.delete().uri('/actuator/caches/b').exchange().expectStatus().isNoContent();
		assertThat(b.get('test')).isNull();
	}
	@WebEndpointTest
	void cleanNamedCacheWithUnknownName(WebTestClient client) {
		client.delete().uri('/actuator/caches/does-not-exist').exchange().expectStatus().isNotFound();
	}
	@WebEndpointTest
	void clearNamedCacheWithNonUniqueName(WebTestClient client) {
		client.get().uri('/actuator/caches/a').exchange().expectStatus().isBadRequest();
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		CacheManager one() {
			return new ConcurrentMapCacheManager('a', 'b');
		}
		@Bean
		CacheManager two() {
			return new ConcurrentMapCacheManager('a', 'c');
		}
		@Bean
		CachesEndpoint endpoint(Map<String, CacheManager> cacheManagers) {
			return new CachesEndpoint(cacheManagers);
		}
		@Bean
		CachesEndpointWebExtension cachesEndpointWebExtension(CachesEndpoint endpoint) {
			return new CachesEndpointWebExtension(endpoint);
		}
	}
}
/*
package org.springframework.boot.actuate.cache;
/**
class CachesEndpointTests {
	@Test
	void allCachesWithSingleCacheManager() {
		CachesEndpoint endpoint = new CachesEndpoint(
				Collections.singletonMap('test', new ConcurrentMapCacheManager('a', 'b')));
		Map<String, CacheManagerDescriptor> allDescriptors = endpoint.caches().getCacheManagers();
		assertThat(allDescriptors).containsOnlyKeys('test');
		CacheManagerDescriptor descriptors = allDescriptors.get('test');
		assertThat(descriptors.getCaches()).containsOnlyKeys('a', 'b');
		assertThat(descriptors.getCaches().get('a').getTarget()).isEqualTo(ConcurrentHashMap.class.getName());
		assertThat(descriptors.getCaches().get('b').getTarget()).isEqualTo(ConcurrentHashMap.class.getName());
	}
	@Test
	void allCachesWithSeveralCacheManagers() {
		Map<String, CacheManager> cacheManagers = new LinkedHashMap<>();
		cacheManagers.put('test', new ConcurrentMapCacheManager('a', 'b'));
		cacheManagers.put('another', new ConcurrentMapCacheManager('a', 'c'));
		CachesEndpoint endpoint = new CachesEndpoint(cacheManagers);
		Map<String, CacheManagerDescriptor> allDescriptors = endpoint.caches().getCacheManagers();
		assertThat(allDescriptors).containsOnlyKeys('test', 'another');
		assertThat(allDescriptors.get('test').getCaches()).containsOnlyKeys('a', 'b');
		assertThat(allDescriptors.get('another').getCaches()).containsOnlyKeys('a', 'c');
	}
	@Test
	void namedCacheWithSingleCacheManager() {
		CachesEndpoint endpoint = new CachesEndpoint(
				Collections.singletonMap('test', new ConcurrentMapCacheManager('b', 'a')));
		CacheEntryDescriptor entry = endpoint.cache('a', null);
		assertThat(entry).isNotNull();
		assertThat(entry.getCacheManager()).isEqualTo('test');
		assertThat(entry.getName()).isEqualTo('a');
		assertThat(entry.getTarget()).isEqualTo(ConcurrentHashMap.class.getName());
	}
	@Test
	void namedCacheWithSeveralCacheManagers() {
		Map<String, CacheManager> cacheManagers = new LinkedHashMap<>();
		cacheManagers.put('test', new ConcurrentMapCacheManager('b', 'dupe-cache'));
		cacheManagers.put('another', new ConcurrentMapCacheManager('c', 'dupe-cache'));
		CachesEndpoint endpoint = new CachesEndpoint(cacheManagers);
		assertThatExceptionOfType(NonUniqueCacheException.class).isThrownBy(() -> endpoint.cache('dupe-cache', null))
			.withMessageContaining('dupe-cache')
			.withMessageContaining('test')
			.withMessageContaining('another');
	}
	@Test
	void namedCacheWithUnknownCache() {
		CachesEndpoint endpoint = new CachesEndpoint(
				Collections.singletonMap('test', new ConcurrentMapCacheManager('b', 'a')));
		CacheEntryDescriptor entry = endpoint.cache('unknown', null);
		assertThat(entry).isNull();
	}
	@Test
	void namedCacheWithWrongCacheManager() {
		Map<String, CacheManager> cacheManagers = new LinkedHashMap<>();
		cacheManagers.put('test', new ConcurrentMapCacheManager('b', 'a'));
		cacheManagers.put('another', new ConcurrentMapCacheManager('c', 'a'));
		CachesEndpoint endpoint = new CachesEndpoint(cacheManagers);
		CacheEntryDescriptor entry = endpoint.cache('c', 'test');
		assertThat(entry).isNull();
	}
	@Test
	void namedCacheWithSeveralCacheManagersWithCacheManagerFilter() {
		Map<String, CacheManager> cacheManagers = new LinkedHashMap<>();
		cacheManagers.put('test', new ConcurrentMapCacheManager('b', 'a'));
		cacheManagers.put('another', new ConcurrentMapCacheManager('c', 'a'));
		CachesEndpoint endpoint = new CachesEndpoint(cacheManagers);
		CacheEntryDescriptor entry = endpoint.cache('a', 'test');
		assertThat(entry).isNotNull();
		assertThat(entry.getCacheManager()).isEqualTo('test');
		assertThat(entry.getName()).isEqualTo('a');
	}
	@Test
	void clearAllCaches() {
		Cache a = mockCache('a');
		Cache b = mockCache('b');
		CachesEndpoint endpoint = new CachesEndpoint(Collections.singletonMap('test', cacheManager(a, b)));
		endpoint.clearCaches();
		then(a).should().clear();
		then(b).should().clear();
	}
	@Test
	void clearCache() {
		Cache a = mockCache('a');
		Cache b = mockCache('b');
		CachesEndpoint endpoint = new CachesEndpoint(Collections.singletonMap('test', cacheManager(a, b)));
		assertThat(endpoint.clearCache('a', null)).isTrue();
		then(a).should().clear();
		then(b).should(never()).clear();
	}
	@Test
	void clearCacheWithSeveralCacheManagers() {
		Map<String, CacheManager> cacheManagers = new LinkedHashMap<>();
		cacheManagers.put('test', cacheManager(mockCache('dupe-cache'), mockCache('b')));
		cacheManagers.put('another', cacheManager(mockCache('dupe-cache')));
		CachesEndpoint endpoint = new CachesEndpoint(cacheManagers);
		assertThatExceptionOfType(NonUniqueCacheException.class)
			.isThrownBy(() -> endpoint.clearCache('dupe-cache', null))
			.withMessageContaining('dupe-cache')
			.withMessageContaining('test')
			.withMessageContaining('another');
	}
	@Test
	void clearCacheWithSeveralCacheManagersWithCacheManagerFilter() {
		Map<String, CacheManager> cacheManagers = new LinkedHashMap<>();
		Cache a = mockCache('a');
		Cache b = mockCache('b');
		cacheManagers.put('test', cacheManager(a, b));
		Cache anotherA = mockCache('a');
		cacheManagers.put('another', cacheManager(anotherA));
		CachesEndpoint endpoint = new CachesEndpoint(cacheManagers);
		assertThat(endpoint.clearCache('a', 'another')).isTrue();
		then(a).should(never()).clear();
		then(anotherA).should().clear();
		then(b).should(never()).clear();
	}
	@Test
	void clearCacheWithUnknownCache() {
		Cache a = mockCache('a');
		CachesEndpoint endpoint = new CachesEndpoint(Collections.singletonMap('test', cacheManager(a)));
		assertThat(endpoint.clearCache('unknown', null)).isFalse();
		then(a).should(never()).clear();
	}
	@Test
	void clearCacheWithUnknownCacheManager() {
		Cache a = mockCache('a');
		CachesEndpoint endpoint = new CachesEndpoint(Collections.singletonMap('test', cacheManager(a)));
		assertThat(endpoint.clearCache('a', 'unknown')).isFalse();
		then(a).should(never()).clear();
	}
	private CacheManager cacheManager(Cache... caches) {
		SimpleCacheManager cacheManager = new SimpleCacheManager();
		cacheManager.setCaches(Arrays.asList(caches));
		cacheManager.afterPropertiesSet();
		return cacheManager;
	}
	private Cache mockCache(String name) {
		Cache cache = mock(Cache.class);
		given(cache.getName()).willReturn(name);
		given(cache.getNativeCache()).willReturn(new Object());
		return cache;
	}
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
class InMemoryHttpExchangeRepositoryTests {
	private static final Supplier<Principal> NO_PRINCIPAL = () -> null;
	private static final Supplier<String> NO_SESSION_ID = () -> null;
	private final InMemoryHttpExchangeRepository repository = new InMemoryHttpExchangeRepository();
	@Test
	void adWhenHasLimitedCapacityRestrictsSize() {
		this.repository.setCapacity(2);
		this.repository.add(createHttpExchange('GET'));
		this.repository.add(createHttpExchange('POST'));
		this.repository.add(createHttpExchange('DELETE'));
		List<HttpExchange> exchanges = this.repository.findAll();
		assertThat(exchanges).hasSize(2);
		assertThat(exchanges.get(0).getRequest().getMethod()).isEqualTo('DELETE');
		assertThat(exchanges.get(1).getRequest().getMethod()).isEqualTo('POST');
	}
	@Test
	void addWhenReverseFalseReturnsInCorrectOrder() {
		this.repository.setReverse(false);
		this.repository.setCapacity(2);
		this.repository.add(createHttpExchange('GET'));
		this.repository.add(createHttpExchange('POST'));
		this.repository.add(createHttpExchange('DELETE'));
		List<HttpExchange> exchanges = this.repository.findAll();
		assertThat(exchanges).hasSize(2);
		assertThat(exchanges.get(0).getRequest().getMethod()).isEqualTo('POST');
		assertThat(exchanges.get(1).getRequest().getMethod()).isEqualTo('DELETE');
	}
	private HttpExchange createHttpExchange(String method) {
		RecordableHttpRequest request = mock(RecordableHttpRequest.class);
		given(request.getMethod()).willReturn(method);
		RecordableHttpResponse response = mock(RecordableHttpResponse.class);
		return HttpExchange.start(request).finish(response, NO_PRINCIPAL, NO_SESSION_ID);
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.servlet;
/**
class HttpExchangesFilterTests {
	private final InMemoryHttpExchangeRepository repository = new InMemoryHttpExchangeRepository();
	private final HttpExchangesFilter filter = new HttpExchangesFilter(this.repository, EnumSet.allOf(Include.class));
	@Test
	void filterRecordsExchange() throws ServletException, IOException {
		this.filter.doFilter(new MockHttpServletRequest(), new MockHttpServletResponse(), new MockFilterChain());
		assertThat(this.repository.findAll()).hasSize(1);
	}
	@Test
	void filterRecordsSessionId() throws ServletException, IOException {
		this.filter.doFilter(new MockHttpServletRequest(), new MockHttpServletResponse(),
				new MockFilterChain(new HttpServlet() {
					@Override
					protected void service(HttpServletRequest req, HttpServletResponse resp)
							throws ServletException, IOException {
						req.getSession(true);
					}
				}));
		assertThat(this.repository.findAll()).hasSize(1);
		Session session = this.repository.findAll().get(0).getSession();
		assertThat(session).isNotNull();
		assertThat(session.getId()).isNotNull();
	}
	@Test
	void filterRecordsPrincipal() throws ServletException, IOException {
		MockHttpServletRequest request = new MockHttpServletRequest();
		Principal principal = mock(Principal.class);
		given(principal.getName()).willReturn('alice');
		request.setUserPrincipal(principal);
		this.filter.doFilter(request, new MockHttpServletResponse(), new MockFilterChain());
		assertThat(this.repository.findAll()).hasSize(1);
		org.springframework.boot.actuate.web.exchanges.HttpExchange.Principal recordedPrincipal = this.repository
			.findAll()
			.get(0)
			.getPrincipal();
		assertThat(recordedPrincipal).isNotNull();
		assertThat(recordedPrincipal.getName()).isEqualTo('alice');
	}
	@Test
	void statusIsAssumedToBe500WhenChainFails() {
		assertThatIOException().isThrownBy(() -> this.filter.doFilter(new MockHttpServletRequest(),
				new MockHttpServletResponse(), new MockFilterChain(new HttpServlet() {
					@Override
					protected void service(HttpServletRequest req, HttpServletResponse resp)
							throws ServletException, IOException {
						throw new IOException();
					}
				})))
			.satisfies((ex) -> {
				assertThat(this.repository.findAll()).hasSize(1);
				assertThat(this.repository.findAll().get(0).getResponse().getStatus()).isEqualTo(500);
			});
	}
	@Test
	void filterRejectsInvalidRequests() throws ServletException, IOException {
		MockHttpServletRequest request = new MockHttpServletRequest();
		request.setServerName('<script>alert(document.domain)</script>');
		this.filter.doFilter(request, new MockHttpServletResponse(), new MockFilterChain());
		assertThat(this.repository.findAll()).isEmpty();
	}
}
/*
package org.springframework.boot.actuate.web.exchanges.servlet;
/**
class RecordableServletHttpRequestTests {
	private MockHttpServletRequest request;
	@BeforeEach
	void setup() {
		this.request = new MockHttpServletRequest('GET', '/script');
	}
	@Test
	void getUriWithoutQueryStringShouldReturnUri() {
		validate('http://localhost/script');
	}
	@Test
	void getUriShouldReturnUriWithQueryString() {
		this.request.setQueryString('a=b');
		validate('http://localhost/script?a=b');
	}
	@Test
	void getUriWithSpecialCharactersInQueryStringShouldEncode() {
		this.request.setQueryString('a=${b}');
		validate('http://localhost/script?a=$%7Bb%7D');
	}
	@Test
	void getUriWithSpecialCharactersEncodedShouldNotDoubleEncode() {
		this.request.setQueryString('a=$%7Bb%7D');
		validate('http://localhost/script?a=$%7Bb%7D');
	}
	private void validate(String expectedUri) {
		RecordableServletHttpRequest sourceRequest = new RecordableServletHttpRequest(this.request);
		assertThat(sourceRequest.getUri()).hasToString(expectedUri);
	}
}
/*
package org.springframework.boot.actuate.web.exchanges;
/**
class HttpExchangeTests {
	private static final Map<String, List<String>> AUTHORIZATION_HEADER = Map.of(HttpHeaders.AUTHORIZATION,
