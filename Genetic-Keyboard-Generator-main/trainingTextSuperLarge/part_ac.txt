.springframework.boot.context;
/**
public class TypeExcludeFilter implements TypeFilter, BeanFactoryAware {
	private BeanFactory beanFactory;
	private Collection<TypeExcludeFilter> delegates;
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		this.beanFactory = beanFactory;
	}
	@Override
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		if (this.beanFactory instanceof ListableBeanFactory && getClass() == TypeExcludeFilter.class) {
			for (TypeExcludeFilter delegate : getDelegates()) {
				if (delegate.match(metadataReader, metadataReaderFactory)) {
					return true;
				}
			}
		}
		return false;
	}
	private Collection<TypeExcludeFilter> getDelegates() {
		Collection<TypeExcludeFilter> delegates = this.delegates;
		if (delegates == null) {
			delegates = ((ListableBeanFactory) this.beanFactory).getBeansOfType(TypeExcludeFilter.class).values();
			this.delegates = delegates;
		}
		return delegates;
	}
	@Override
	public boolean equals(Object obj) {
		throw new IllegalStateException('TypeExcludeFilter ' + getClass() + ' has not implemented equals');
	}
	@Override
	public int hashCode() {
		throw new IllegalStateException('TypeExcludeFilter ' + getClass() + ' has not implemented hashCode');
	}
}
/*
package org.springframework.boot.context.event;
/**
class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {
	private final SpringApplication application;
	private final String[] args;
	private final SimpleApplicationEventMulticaster initialMulticaster;
	EventPublishingRunListener(SpringApplication application, String[] args) {
		this.application = application;
		this.args = args;
		this.initialMulticaster = new SimpleApplicationEventMulticaster();
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public void starting(ConfigurableBootstrapContext bootstrapContext) {
		multicastInitialEvent(new ApplicationStartingEvent(bootstrapContext, this.application, this.args));
	}
	@Override
	public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext,
			ConfigurableEnvironment environment) {
		multicastInitialEvent(
				new ApplicationEnvironmentPreparedEvent(bootstrapContext, this.application, this.args, environment));
	}
	@Override
	public void contextPrepared(ConfigurableApplicationContext context) {
		multicastInitialEvent(new ApplicationContextInitializedEvent(this.application, this.args, context));
	}
	@Override
	public void contextLoaded(ConfigurableApplicationContext context) {
		for (ApplicationListener<?> listener : this.application.getListeners()) {
			if (listener instanceof ApplicationContextAware contextAware) {
				contextAware.setApplicationContext(context);
			}
			context.addApplicationListener(listener);
		}
		multicastInitialEvent(new ApplicationPreparedEvent(this.application, this.args, context));
	}
	@Override
	public void started(ConfigurableApplicationContext context, Duration timeTaken) {
		context.publishEvent(new ApplicationStartedEvent(this.application, this.args, context, timeTaken));
		AvailabilityChangeEvent.publish(context, LivenessState.CORRECT);
	}
	@Override
	public void ready(ConfigurableApplicationContext context, Duration timeTaken) {
		context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context, timeTaken));
		AvailabilityChangeEvent.publish(context, ReadinessState.ACCEPTING_TRAFFIC);
	}
	@Override
	public void failed(ConfigurableApplicationContext context, Throwable exception) {
		ApplicationFailedEvent event = new ApplicationFailedEvent(this.application, this.args, context, exception);
		if (context != null && context.isActive()) {
			// Listeners have been registered to the application context so we should
			// use it at this point if we can
			context.publishEvent(event);
		}
		else {
			// An inactive context may not have a multicaster so we use our multicaster to
			// call all the context"s listeners instead
			if (context instanceof AbstractApplicationContext abstractApplicationContext) {
				for (ApplicationListener<?> listener : abstractApplicationContext.getApplicationListeners()) {
					this.initialMulticaster.addApplicationListener(listener);
				}
			}
			this.initialMulticaster.setErrorHandler(new LoggingErrorHandler());
			this.initialMulticaster.multicastEvent(event);
		}
	}
	private void multicastInitialEvent(ApplicationEvent event) {
		refreshApplicationListeners();
		this.initialMulticaster.multicastEvent(event);
	}
	private void refreshApplicationListeners() {
		this.application.getListeners().forEach(this.initialMulticaster::addApplicationListener);
	}
	private static final class LoggingErrorHandler implements ErrorHandler {
		private static final Log logger = LogFactory.getLog(EventPublishingRunListener.class);
		@Override
		public void handleError(Throwable throwable) {
			logger.warn('Error calling ApplicationEventListener', throwable);
		}
	}
}
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public class ApplicationFailedEvent extends SpringApplicationEvent {
	private final ConfigurableApplicationContext context;
	private final Throwable exception;
	/**
	 * Create a new {@link ApplicationFailedEvent} instance.
	 * @param application the current application
	 * @param args the arguments the application was running with
	 * @param context the context that was being created (maybe null)
	 * @param exception the exception that caused the error
	 */
	public ApplicationFailedEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context,
			Throwable exception) {
		super(application, args);
		this.context = context;
		this.exception = exception;
	}
	/**
	 * Return the application context.
	 * @return the context
	 */
	public ConfigurableApplicationContext getApplicationContext() {
		return this.context;
	}
	/**
	 * Return the exception that caused the failure.
	 * @return the exception
	 */
	public Throwable getException() {
		return this.exception;
	}
}
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public class ApplicationEnvironmentPreparedEvent extends SpringApplicationEvent {
	private final ConfigurableBootstrapContext bootstrapContext;
	private final ConfigurableEnvironment environment;
	/**
	 * Create a new {@link ApplicationEnvironmentPreparedEvent} instance.
	 * @param bootstrapContext the bootstrap context
	 * @param application the current application
	 * @param args the arguments the application is running with
	 * @param environment the environment that was just created
	 */
	public ApplicationEnvironmentPreparedEvent(ConfigurableBootstrapContext bootstrapContext,
			SpringApplication application, String[] args, ConfigurableEnvironment environment) {
		super(application, args);
		this.bootstrapContext = bootstrapContext;
		this.environment = environment;
	}
	/**
	 * Return the bootstrap context.
	 * @return the bootstrap context
	 * @since 2.4.0
	 */
	public ConfigurableBootstrapContext getBootstrapContext() {
		return this.bootstrapContext;
	}
	/**
	 * Return the environment.
	 * @return the environment
	 */
	public ConfigurableEnvironment getEnvironment() {
		return this.environment;
	}
}
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public class ApplicationContextInitializedEvent extends SpringApplicationEvent {
	private final ConfigurableApplicationContext context;
	/**
	 * Create a new {@link ApplicationContextInitializedEvent} instance.
	 * @param application the current application
	 * @param args the arguments the application is running with
	 * @param context the context that has been initialized
	 */
	public ApplicationContextInitializedEvent(SpringApplication application, String[] args,
			ConfigurableApplicationContext context) {
		super(application, args);
		this.context = context;
	}
	/**
	 * Return the application context.
	 * @return the context
	 */
	public ConfigurableApplicationContext getApplicationContext() {
		return this.context;
	}
}
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public class ApplicationStartingEvent extends SpringApplicationEvent {
	private final ConfigurableBootstrapContext bootstrapContext;
	/**
	 * Create a new {@link ApplicationStartingEvent} instance.
	 * @param bootstrapContext the bootstrap context
	 * @param application the current application
	 * @param args the arguments the application is running with
	 */
	public ApplicationStartingEvent(ConfigurableBootstrapContext bootstrapContext, SpringApplication application,
			String[] args) {
		super(application, args);
		this.bootstrapContext = bootstrapContext;
	}
	/**
	 * Return the bootstrap context.
	 * @return the bootstrap context
	 * @since 2.4.0
	 */
	public ConfigurableBootstrapContext getBootstrapContext() {
		return this.bootstrapContext;
	}
}
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public abstract class SpringApplicationEvent extends ApplicationEvent {
	private final String[] args;
	public SpringApplicationEvent(SpringApplication application, String[] args) {
		super(application);
		this.args = args;
	}
	public SpringApplication getSpringApplication() {
		return (SpringApplication) getSource();
	}
	public final String[] getArgs() {
		return this.args;
	}
}
/*
/**
package org.springframework.boot.context.event;
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public class ApplicationPreparedEvent extends SpringApplicationEvent {
	private final ConfigurableApplicationContext context;
	/**
	 * Create a new {@link ApplicationPreparedEvent} instance.
	 * @param application the current application
	 * @param args the arguments the application is running with
	 * @param context the ApplicationContext about to be refreshed
	 */
	public ApplicationPreparedEvent(SpringApplication application, String[] args,
			ConfigurableApplicationContext context) {
		super(application, args);
		this.context = context;
	}
	/**
	 * Return the application context.
	 * @return the context
	 */
	public ConfigurableApplicationContext getApplicationContext() {
		return this.context;
	}
}
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public class ApplicationStartedEvent extends SpringApplicationEvent {
	private final ConfigurableApplicationContext context;
	private final Duration timeTaken;
	/**
	 * Create a new {@link ApplicationStartedEvent} instance.
	 * @param application the current application
	 * @param args the arguments the application is running with
	 * @param context the context that was being created
	 * @param timeTaken the time taken to start the application
	 * @since 2.6.0
	 */
	public ApplicationStartedEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context,
			Duration timeTaken) {
		super(application, args);
		this.context = context;
		this.timeTaken = timeTaken;
	}
	/**
	 * Return the application context.
	 * @return the context
	 */
	public ConfigurableApplicationContext getApplicationContext() {
		return this.context;
	}
	/**
	 * Return the time taken to start the application, or {@code null} if unknown.
	 * @return the startup time
	 * @since 2.6.0
	 */
	public Duration getTimeTaken() {
		return this.timeTaken;
	}
}
/*
package org.springframework.boot.context.event;
/**
@SuppressWarnings('serial')
public class ApplicationReadyEvent extends SpringApplicationEvent {
	private final ConfigurableApplicationContext context;
	private final Duration timeTaken;
	/**
	 * Create a new {@link ApplicationReadyEvent} instance.
	 * @param application the current application
	 * @param args the arguments the application is running with
	 * @param context the context that was being created
	 * @param timeTaken the time taken to get the application ready to service requests
	 * @since 2.6.0
	 */
	public ApplicationReadyEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context,
			Duration timeTaken) {
		super(application, args);
		this.context = context;
		this.timeTaken = timeTaken;
	}
	/**
	 * Return the application context.
	 * @return the context
	 */
	public ConfigurableApplicationContext getApplicationContext() {
		return this.context;
	}
	/**
	 * Return the time taken for the application to be ready to service requests, or
	 * {@code null} if unknown.
	 * @return the time taken to be ready to service requests
	 * @since 2.6.0
	 */
	public Duration getTimeTaken() {
		return this.timeTaken;
	}
}
/*
package org.springframework.boot.context;
/**
public class FileEncodingApplicationListener
		implements ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
	private static final Log logger = LogFactory.getLog(FileEncodingApplicationListener.class);
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE;
	}
	@Override
	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
		ConfigurableEnvironment environment = event.getEnvironment();
		String desired = environment.getProperty('spring.mandatory-file-encoding');
		if (desired == null) {
			return;
		}
		String encoding = System.getProperty('file.encoding');
		if (encoding != null && !desired.equalsIgnoreCase(encoding)) {
			if (logger.isErrorEnabled()) {
				logger.error('System property "file.encoding" is currently "' + encoding + '". It should be "' + desired
						+ '" (as defined in "spring.mandatoryFileEncoding").');
				logger.error('Environment variable LANG is "' + System.getenv('LANG')
						+ '". You could use a locale setting that matches encoding="' + desired + '".');
				logger.error('Environment variable LC_ALL is "' + System.getenv('LC_ALL')
						+ '". You could use a locale setting that matches encoding="' + desired + '".');
			}
			throw new IllegalStateException('The Java Virtual Machine has not been configured to use the '
					+ 'desired default character encoding (' + desired + ').');
		}
	}
}
/*
/**
package org.springframework.boot.context;
/*
package org.springframework.boot;
/**
public interface SpringApplicationRunListener {
	/**
	 * Called immediately when the run method has first started. Can be used for very
	 * early initialization.
	 * @param bootstrapContext the bootstrap context
	 */
	default void starting(ConfigurableBootstrapContext bootstrapContext) {
	}
	/**
	 * Called once the environment has been prepared, but before the
	 * {@link ApplicationContext} has been created.
	 * @param bootstrapContext the bootstrap context
	 * @param environment the environment
	 */
	default void environmentPrepared(ConfigurableBootstrapContext bootstrapContext,
			ConfigurableEnvironment environment) {
	}
	/**
	 * Called once the {@link ApplicationContext} has been created and prepared, but
	 * before sources have been loaded.
	 * @param context the application context
	 */
	default void contextPrepared(ConfigurableApplicationContext context) {
	}
	/**
	 * Called once the application context has been loaded but before it has been
	 * refreshed.
	 * @param context the application context
	 */
	default void contextLoaded(ConfigurableApplicationContext context) {
	}
	/**
	 * The context has been refreshed and the application has started but
	 * {@link CommandLineRunner CommandLineRunners} and {@link ApplicationRunner
	 * ApplicationRunners} have not been called.
	 * @param context the application context.
	 * @param timeTaken the time taken to start the application or {@code null} if unknown
	 * @since 2.6.0
	 */
	default void started(ConfigurableApplicationContext context, Duration timeTaken) {
	}
	/**
	 * Called immediately before the run method finishes, when the application context has
	 * been refreshed and all {@link CommandLineRunner CommandLineRunners} and
	 * {@link ApplicationRunner ApplicationRunners} have been called.
	 * @param context the application context.
	 * @param timeTaken the time taken for the application to be ready or {@code null} if
	 * unknown
	 * @since 2.6.0
	 */
	default void ready(ConfigurableApplicationContext context, Duration timeTaken) {
	}
	/**
	 * Called when a failure occurs when running the application.
	 * @param context the application context or {@code null} if a failure occurred before
	 * the context was created
	 * @param exception the failure
	 * @since 2.0.0
	 */
	default void failed(ConfigurableApplicationContext context, Throwable exception) {
	}
}
/*
package org.springframework.boot.task;
/**
public class ThreadPoolTaskSchedulerBuilder {
	private final Integer poolSize;
	private final Boolean awaitTermination;
	private final Duration awaitTerminationPeriod;
	private final String threadNamePrefix;
	private final Set<ThreadPoolTaskSchedulerCustomizer> customizers;
	public ThreadPoolTaskSchedulerBuilder() {
		this.poolSize = null;
		this.awaitTermination = null;
		this.awaitTerminationPeriod = null;
		this.threadNamePrefix = null;
		this.customizers = null;
	}
	public ThreadPoolTaskSchedulerBuilder(Integer poolSize, Boolean awaitTermination, Duration awaitTerminationPeriod,
			String threadNamePrefix, Set<ThreadPoolTaskSchedulerCustomizer> taskSchedulerCustomizers) {
		this.poolSize = poolSize;
		this.awaitTermination = awaitTermination;
		this.awaitTerminationPeriod = awaitTerminationPeriod;
		this.threadNamePrefix = threadNamePrefix;
		this.customizers = taskSchedulerCustomizers;
	}
	/**
	 * Set the maximum allowed number of threads.
	 * @param poolSize the pool size to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskSchedulerBuilder poolSize(int poolSize) {
		return new ThreadPoolTaskSchedulerBuilder(poolSize, this.awaitTermination, this.awaitTerminationPeriod,
				this.threadNamePrefix, this.customizers);
	}
	/**
	 * Set whether the executor should wait for scheduled tasks to complete on shutdown,
	 * not interrupting running tasks and executing all tasks in the queue.
	 * @param awaitTermination whether the executor needs to wait for the tasks to
	 * complete on shutdown
	 * @return a new builder instance
	 * @see #awaitTerminationPeriod(Duration)
	 */
	public ThreadPoolTaskSchedulerBuilder awaitTermination(boolean awaitTermination) {
		return new ThreadPoolTaskSchedulerBuilder(this.poolSize, awaitTermination, this.awaitTerminationPeriod,
				this.threadNamePrefix, this.customizers);
	}
	/**
	 * Set the maximum time the executor is supposed to block on shutdown. When set, the
	 * executor blocks on shutdown in order to wait for remaining tasks to complete their
	 * execution before the rest of the container continues to shut down. This is
	 * particularly useful if your remaining tasks are likely to need access to other
	 * resources that are also managed by the container.
	 * @param awaitTerminationPeriod the await termination period to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskSchedulerBuilder awaitTerminationPeriod(Duration awaitTerminationPeriod) {
		return new ThreadPoolTaskSchedulerBuilder(this.poolSize, this.awaitTermination, awaitTerminationPeriod,
				this.threadNamePrefix, this.customizers);
	}
	/**
	 * Set the prefix to use for the names of newly created threads.
	 * @param threadNamePrefix the thread name prefix to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskSchedulerBuilder threadNamePrefix(String threadNamePrefix) {
		return new ThreadPoolTaskSchedulerBuilder(this.poolSize, this.awaitTermination, this.awaitTerminationPeriod,
				threadNamePrefix, this.customizers);
	}
	/**
	 * Set the {@link ThreadPoolTaskSchedulerCustomizer
	 * threadPoolTaskSchedulerCustomizers} that should be applied to the
	 * {@link ThreadPoolTaskScheduler}. Customizers are applied in the order that they
	 * were added after builder configuration has been applied. Setting this value will
	 * replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(ThreadPoolTaskSchedulerCustomizer...)
	 */
	public ThreadPoolTaskSchedulerBuilder customizers(ThreadPoolTaskSchedulerCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return customizers(Arrays.asList(customizers));
	}
	/**
	 * Set the {@link ThreadPoolTaskSchedulerCustomizer
	 * threadPoolTaskSchedulerCustomizers} that should be applied to the
	 * {@link ThreadPoolTaskScheduler}. Customizers are applied in the order that they
	 * were added after builder configuration has been applied. Setting this value will
	 * replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(ThreadPoolTaskSchedulerCustomizer...)
	 */
	public ThreadPoolTaskSchedulerBuilder customizers(
			Iterable<? extends ThreadPoolTaskSchedulerCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new ThreadPoolTaskSchedulerBuilder(this.poolSize, this.awaitTermination, this.awaitTerminationPeriod,
				this.threadNamePrefix, append(null, customizers));
	}
	/**
	 * Add {@link ThreadPoolTaskSchedulerCustomizer threadPoolTaskSchedulerCustomizers}
	 * that should be applied to the {@link ThreadPoolTaskScheduler}. Customizers are
	 * applied in the order that they were added after builder configuration has been
	 * applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(ThreadPoolTaskSchedulerCustomizer...)
	 */
	public ThreadPoolTaskSchedulerBuilder additionalCustomizers(ThreadPoolTaskSchedulerCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return additionalCustomizers(Arrays.asList(customizers));
	}
	/**
	 * Add {@link ThreadPoolTaskSchedulerCustomizer threadPoolTaskSchedulerCustomizers}
	 * that should be applied to the {@link ThreadPoolTaskScheduler}. Customizers are
	 * applied in the order that they were added after builder configuration has been
	 * applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(ThreadPoolTaskSchedulerCustomizer...)
	 */
	public ThreadPoolTaskSchedulerBuilder additionalCustomizers(
			Iterable<? extends ThreadPoolTaskSchedulerCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new ThreadPoolTaskSchedulerBuilder(this.poolSize, this.awaitTermination, this.awaitTerminationPeriod,
				this.threadNamePrefix, append(this.customizers, customizers));
	}
	/**
	 * Build a new {@link ThreadPoolTaskScheduler} instance and configure it using this
	 * builder.
	 * @return a configured {@link ThreadPoolTaskScheduler} instance.
	 * @see #configure(ThreadPoolTaskScheduler)
	 */
	public ThreadPoolTaskScheduler build() {
		return configure(new ThreadPoolTaskScheduler());
	}
	/**
	 * Configure the provided {@link ThreadPoolTaskScheduler} instance using this builder.
	 * @param <T> the type of task scheduler
	 * @param taskScheduler the {@link ThreadPoolTaskScheduler} to configure
	 * @return the task scheduler instance
	 * @see #build()
	 */
	public <T extends ThreadPoolTaskScheduler> T configure(T taskScheduler) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.poolSize).to(taskScheduler::setPoolSize);
		map.from(this.awaitTermination).to(taskScheduler::setWaitForTasksToCompleteOnShutdown);
		map.from(this.awaitTerminationPeriod).asInt(Duration::getSeconds).to(taskScheduler::setAwaitTerminationSeconds);
		map.from(this.threadNamePrefix).to(taskScheduler::setThreadNamePrefix);
		if (!CollectionUtils.isEmpty(this.customizers)) {
			this.customizers.forEach((customizer) -> customizer.customize(taskScheduler));
		}
		return taskScheduler;
	}
	private <T> Set<T> append(Set<T> set, Iterable<? extends T> additions) {
		Set<T> result = new LinkedHashSet<>((set != null) ? set : Collections.emptySet());
		additions.forEach(result::add);
		return Collections.unmodifiableSet(result);
	}
}
/*
package org.springframework.boot.task;
/**
@FunctionalInterface
public interface SimpleAsyncTaskSchedulerCustomizer {
	/**
	 * Callback to customize a {@link SimpleAsyncTaskScheduler} instance.
	 * @param taskScheduler the task scheduler to customize
	 */
	void customize(SimpleAsyncTaskScheduler taskScheduler);
}
/*
package org.springframework.boot.task;
/**
@FunctionalInterface
public interface ThreadPoolTaskExecutorCustomizer {
	/**
	 * Callback to customize a {@link ThreadPoolTaskExecutor} instance.
	 * @param taskExecutor the task executor to customize
	 */
	void customize(ThreadPoolTaskExecutor taskExecutor);
}
/*
package org.springframework.boot.task;
/**
@FunctionalInterface
public interface SimpleAsyncTaskExecutorCustomizer {
	/**
	 * Callback to customize a {@link SimpleAsyncTaskExecutor} instance.
	 * @param taskExecutor the task executor to customize
	 */
	void customize(SimpleAsyncTaskExecutor taskExecutor);
}
/*
package org.springframework.boot.task;
/**
public class ThreadPoolTaskExecutorBuilder {
	private final Integer queueCapacity;
	private final Integer corePoolSize;
	private final Integer maxPoolSize;
	private final Boolean allowCoreThreadTimeOut;
	private final Duration keepAlive;
	private final Boolean acceptTasksAfterContextClose;
	private final Boolean awaitTermination;
	private final Duration awaitTerminationPeriod;
	private final String threadNamePrefix;
	private final TaskDecorator taskDecorator;
	private final Set<ThreadPoolTaskExecutorCustomizer> customizers;
	public ThreadPoolTaskExecutorBuilder() {
		this.queueCapacity = null;
		this.corePoolSize = null;
		this.maxPoolSize = null;
		this.allowCoreThreadTimeOut = null;
		this.keepAlive = null;
		this.acceptTasksAfterContextClose = null;
		this.awaitTermination = null;
		this.awaitTerminationPeriod = null;
		this.threadNamePrefix = null;
		this.taskDecorator = null;
		this.customizers = null;
	}
	private ThreadPoolTaskExecutorBuilder(Integer queueCapacity, Integer corePoolSize, Integer maxPoolSize,
			Boolean allowCoreThreadTimeOut, Duration keepAlive, Boolean acceptTasksAfterContextClose,
			Boolean awaitTermination, Duration awaitTerminationPeriod, String threadNamePrefix,
			TaskDecorator taskDecorator, Set<ThreadPoolTaskExecutorCustomizer> customizers) {
		this.queueCapacity = queueCapacity;
		this.corePoolSize = corePoolSize;
		this.maxPoolSize = maxPoolSize;
		this.allowCoreThreadTimeOut = allowCoreThreadTimeOut;
		this.keepAlive = keepAlive;
		this.acceptTasksAfterContextClose = acceptTasksAfterContextClose;
		this.awaitTermination = awaitTermination;
		this.awaitTerminationPeriod = awaitTerminationPeriod;
		this.threadNamePrefix = threadNamePrefix;
		this.taskDecorator = taskDecorator;
		this.customizers = customizers;
	}
	/**
	 * Set the capacity of the queue. An unbounded capacity does not increase the pool and
	 * therefore ignores {@link #maxPoolSize(int) maxPoolSize}.
	 * @param queueCapacity the queue capacity to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder queueCapacity(int queueCapacity) {
		return new ThreadPoolTaskExecutorBuilder(queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set the core number of threads. Effectively that maximum number of threads as long
	 * as the queue is not full.
	 * <p>
	 * Core threads can grow and shrink if {@link #allowCoreThreadTimeOut(boolean)} is
	 * enabled.
	 * @param corePoolSize the core pool size to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder corePoolSize(int corePoolSize) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set the maximum allowed number of threads. When the {@link #queueCapacity(int)
	 * queue} is full, the pool can expand up to that size to accommodate the load.
	 * <p>
	 * If the {@link #queueCapacity(int) queue capacity} is unbounded, this setting is
	 * ignored.
	 * @param maxPoolSize the max pool size to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder maxPoolSize(int maxPoolSize) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set whether core threads are allowed to time out. When enabled, this enables
	 * dynamic growing and shrinking of the pool.
	 * @param allowCoreThreadTimeOut if core threads are allowed to time out
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder allowCoreThreadTimeOut(boolean allowCoreThreadTimeOut) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set the time limit for which threads may remain idle before being terminated.
	 * @param keepAlive the keep alive to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder keepAlive(Duration keepAlive) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set whether to accept further tasks after the application context close phase has
	 * begun.
	 * @param acceptTasksAfterContextClose whether to accept further tasks after the
	 * application context close phase has begun
	 * @return a new builder instance
	 * @since 3.3.0
	 */
	public ThreadPoolTaskExecutorBuilder acceptTasksAfterContextClose(boolean acceptTasksAfterContextClose) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set whether the executor should wait for scheduled tasks to complete on shutdown,
	 * not interrupting running tasks and executing all tasks in the queue.
	 * @param awaitTermination whether the executor needs to wait for the tasks to
	 * complete on shutdown
	 * @return a new builder instance
	 * @see #awaitTerminationPeriod(Duration)
	 */
	public ThreadPoolTaskExecutorBuilder awaitTermination(boolean awaitTermination) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set the maximum time the executor is supposed to block on shutdown. When set, the
	 * executor blocks on shutdown in order to wait for remaining tasks to complete their
	 * execution before the rest of the container continues to shut down. This is
	 * particularly useful if your remaining tasks are likely to need access to other
	 * resources that are also managed by the container.
	 * @param awaitTerminationPeriod the await termination period to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder awaitTerminationPeriod(Duration awaitTerminationPeriod) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set the prefix to use for the names of newly created threads.
	 * @param threadNamePrefix the thread name prefix to set
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder threadNamePrefix(String threadNamePrefix) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, threadNamePrefix, this.taskDecorator, this.customizers);
	}
	/**
	 * Set the {@link TaskDecorator} to use or {@code null} to not use any.
	 * @param taskDecorator the task decorator to use
	 * @return a new builder instance
	 */
	public ThreadPoolTaskExecutorBuilder taskDecorator(TaskDecorator taskDecorator) {
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, taskDecorator, this.customizers);
	}
	/**
	 * Set the {@link ThreadPoolTaskExecutorCustomizer ThreadPoolTaskExecutorCustomizers}
	 * that should be applied to the {@link ThreadPoolTaskExecutor}. Customizers are
	 * applied in the order that they were added after builder configuration has been
	 * applied. Setting this value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(ThreadPoolTaskExecutorCustomizer...)
	 */
	public ThreadPoolTaskExecutorBuilder customizers(ThreadPoolTaskExecutorCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return customizers(Arrays.asList(customizers));
	}
	/**
	 * Set the {@link ThreadPoolTaskExecutorCustomizer ThreadPoolTaskExecutorCustomizers}
	 * that should be applied to the {@link ThreadPoolTaskExecutor}. Customizers are
	 * applied in the order that they were added after builder configuration has been
	 * applied. Setting this value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(ThreadPoolTaskExecutorCustomizer...)
	 */
	public ThreadPoolTaskExecutorBuilder customizers(Iterable<? extends ThreadPoolTaskExecutorCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator, append(null, customizers));
	}
	/**
	 * Add {@link ThreadPoolTaskExecutorCustomizer ThreadPoolTaskExecutorCustomizers} that
	 * should be applied to the {@link ThreadPoolTaskExecutor}. Customizers are applied in
	 * the order that they were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(ThreadPoolTaskExecutorCustomizer...)
	 */
	public ThreadPoolTaskExecutorBuilder additionalCustomizers(ThreadPoolTaskExecutorCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return additionalCustomizers(Arrays.asList(customizers));
	}
	/**
	 * Add {@link ThreadPoolTaskExecutorCustomizer ThreadPoolTaskExecutorCustomizers} that
	 * should be applied to the {@link ThreadPoolTaskExecutor}. Customizers are applied in
	 * the order that they were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(ThreadPoolTaskExecutorCustomizer...)
	 */
	public ThreadPoolTaskExecutorBuilder additionalCustomizers(
			Iterable<? extends ThreadPoolTaskExecutorCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new ThreadPoolTaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize,
				this.allowCoreThreadTimeOut, this.keepAlive, this.acceptTasksAfterContextClose, this.awaitTermination,
				this.awaitTerminationPeriod, this.threadNamePrefix, this.taskDecorator,
				append(this.customizers, customizers));
	}
	/**
	 * Build a new {@link ThreadPoolTaskExecutor} instance and configure it using this
	 * builder.
	 * @return a configured {@link ThreadPoolTaskExecutor} instance.
	 * @see #build(Class)
	 * @see #configure(ThreadPoolTaskExecutor)
	 */
	public ThreadPoolTaskExecutor build() {
		return configure(new ThreadPoolTaskExecutor());
	}
	/**
	 * Build a new {@link ThreadPoolTaskExecutor} instance of the specified type and
	 * configure it using this builder.
	 * @param <T> the type of task executor
	 * @param taskExecutorClass the template type to create
	 * @return a configured {@link ThreadPoolTaskExecutor} instance.
	 * @see #build()
	 * @see #configure(ThreadPoolTaskExecutor)
	 */
	public <T extends ThreadPoolTaskExecutor> T build(Class<T> taskExecutorClass) {
		return configure(BeanUtils.instantiateClass(taskExecutorClass));
	}
	/**
	 * Configure the provided {@link ThreadPoolTaskExecutor} instance using this builder.
	 * @param <T> the type of task executor
	 * @param taskExecutor the {@link ThreadPoolTaskExecutor} to configure
	 * @return the task executor instance
	 * @see #build()
	 * @see #build(Class)
	 */
	public <T extends ThreadPoolTaskExecutor> T configure(T taskExecutor) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.queueCapacity).to(taskExecutor::setQueueCapacity);
		map.from(this.corePoolSize).to(taskExecutor::setCorePoolSize);
		map.from(this.maxPoolSize).to(taskExecutor::setMaxPoolSize);
		map.from(this.keepAlive).asInt(Duration::getSeconds).to(taskExecutor::setKeepAliveSeconds);
		map.from(this.allowCoreThreadTimeOut).to(taskExecutor::setAllowCoreThreadTimeOut);
		map.from(this.acceptTasksAfterContextClose).to(taskExecutor::setAcceptTasksAfterContextClose);
		map.from(this.awaitTermination).to(taskExecutor::setWaitForTasksToCompleteOnShutdown);
		map.from(this.awaitTerminationPeriod).as(Duration::toMillis).to(taskExecutor::setAwaitTerminationMillis);
		map.from(this.threadNamePrefix).whenHasText().to(taskExecutor::setThreadNamePrefix);
		map.from(this.taskDecorator).to(taskExecutor::setTaskDecorator);
		if (!CollectionUtils.isEmpty(this.customizers)) {
			this.customizers.forEach((customizer) -> customizer.customize(taskExecutor));
		}
		return taskExecutor;
	}
	private <T> Set<T> append(Set<T> set, Iterable<? extends T> additions) {
		Set<T> result = new LinkedHashSet<>((set != null) ? set : Collections.emptySet());
		additions.forEach(result::add);
		return Collections.unmodifiableSet(result);
	}
}
/*
package org.springframework.boot.task;
/**
@FunctionalInterface
public interface ThreadPoolTaskSchedulerCustomizer {
	/**
	 * Callback to customize a {@link ThreadPoolTaskScheduler} instance.
	 * @param taskScheduler the task scheduler to customize
	 */
	void customize(ThreadPoolTaskScheduler taskScheduler);
}
/*
package org.springframework.boot.task;
/**
public class SimpleAsyncTaskSchedulerBuilder {
	private final String threadNamePrefix;
	private final Integer concurrencyLimit;
	private final Boolean virtualThreads;
	private final Set<SimpleAsyncTaskSchedulerCustomizer> customizers;
	private final Duration taskTerminationTimeout;
	public SimpleAsyncTaskSchedulerBuilder() {
		this(null, null, null, null, null);
	}
	private SimpleAsyncTaskSchedulerBuilder(String threadNamePrefix, Integer concurrencyLimit, Boolean virtualThreads,
			Set<SimpleAsyncTaskSchedulerCustomizer> taskSchedulerCustomizers, Duration taskTerminationTimeout) {
		this.threadNamePrefix = threadNamePrefix;
		this.concurrencyLimit = concurrencyLimit;
		this.virtualThreads = virtualThreads;
		this.customizers = taskSchedulerCustomizers;
		this.taskTerminationTimeout = taskTerminationTimeout;
	}
	/**
	 * Set the prefix to use for the names of newly created threads.
	 * @param threadNamePrefix the thread name prefix to set
	 * @return a new builder instance
	 */
	public SimpleAsyncTaskSchedulerBuilder threadNamePrefix(String threadNamePrefix) {
		return new SimpleAsyncTaskSchedulerBuilder(threadNamePrefix, this.concurrencyLimit, this.virtualThreads,
				this.customizers, this.taskTerminationTimeout);
	}
	/**
	 * Set the concurrency limit.
	 * @param concurrencyLimit the concurrency limit
	 * @return a new builder instance
	 */
	public SimpleAsyncTaskSchedulerBuilder concurrencyLimit(Integer concurrencyLimit) {
		return new SimpleAsyncTaskSchedulerBuilder(this.threadNamePrefix, concurrencyLimit, this.virtualThreads,
				this.customizers, this.taskTerminationTimeout);
	}
	/**
	 * Set whether to use virtual threads.
	 * @param virtualThreads whether to use virtual threads
	 * @return a new builder instance
	 */
	public SimpleAsyncTaskSchedulerBuilder virtualThreads(Boolean virtualThreads) {
		return new SimpleAsyncTaskSchedulerBuilder(this.threadNamePrefix, this.concurrencyLimit, virtualThreads,
				this.customizers, this.taskTerminationTimeout);
	}
	/**
	 * Set the task termination timeout.
	 * @param taskTerminationTimeout the task termination timeout
	 * @return a new builder instance
	 * @since 3.2.1
	 */
	public SimpleAsyncTaskSchedulerBuilder taskTerminationTimeout(Duration taskTerminationTimeout) {
		return new SimpleAsyncTaskSchedulerBuilder(this.threadNamePrefix, this.concurrencyLimit, this.virtualThreads,
				this.customizers, taskTerminationTimeout);
	}
	/**
	 * Set the {@link SimpleAsyncTaskSchedulerCustomizer customizers} that should be
	 * applied to the {@link SimpleAsyncTaskScheduler}. Customizers are applied in the
	 * order that they were added after builder configuration has been applied. Setting
	 * this value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(SimpleAsyncTaskSchedulerCustomizer...)
	 */
	public SimpleAsyncTaskSchedulerBuilder customizers(SimpleAsyncTaskSchedulerCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return customizers(Arrays.asList(customizers));
	}
	/**
	 * Set the {@link SimpleAsyncTaskSchedulerCustomizer customizers} that should be
	 * applied to the {@link SimpleAsyncTaskScheduler}. Customizers are applied in the
	 * order that they were added after builder configuration has been applied. Setting
	 * this value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(Iterable)
	 */
	public SimpleAsyncTaskSchedulerBuilder customizers(
			Iterable<? extends SimpleAsyncTaskSchedulerCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new SimpleAsyncTaskSchedulerBuilder(this.threadNamePrefix, this.concurrencyLimit, this.virtualThreads,
				append(null, customizers), this.taskTerminationTimeout);
	}
	/**
	 * Add {@link SimpleAsyncTaskSchedulerCustomizer customizers} that should be applied
	 * to the {@link SimpleAsyncTaskScheduler}. Customizers are applied in the order that
	 * they were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(SimpleAsyncTaskSchedulerCustomizer...)
	 */
	public SimpleAsyncTaskSchedulerBuilder additionalCustomizers(SimpleAsyncTaskSchedulerCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return additionalCustomizers(Arrays.asList(customizers));
	}
	/**
	 * Add {@link SimpleAsyncTaskSchedulerCustomizer customizers} that should be applied
	 * to the {@link SimpleAsyncTaskScheduler}. Customizers are applied in the order that
	 * they were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(Iterable)
	 */
	public SimpleAsyncTaskSchedulerBuilder additionalCustomizers(
			Iterable<? extends SimpleAsyncTaskSchedulerCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new SimpleAsyncTaskSchedulerBuilder(this.threadNamePrefix, this.concurrencyLimit, this.virtualThreads,
				append(this.customizers, customizers), this.taskTerminationTimeout);
	}
	/**
	 * Build a new {@link SimpleAsyncTaskScheduler} instance and configure it using this
	 * builder.
	 * @return a configured {@link SimpleAsyncTaskScheduler} instance.
	 * @see #configure(SimpleAsyncTaskScheduler)
	 */
	public SimpleAsyncTaskScheduler build() {
		return configure(new SimpleAsyncTaskScheduler());
	}
	/**
	 * Configure the provided {@link SimpleAsyncTaskScheduler} instance using this
	 * builder.
	 * @param <T> the type of task scheduler
	 * @param taskScheduler the {@link SimpleAsyncTaskScheduler} to configure
	 * @return the task scheduler instance
	 * @see #build()
	 */
	public <T extends SimpleAsyncTaskScheduler> T configure(T taskScheduler) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.threadNamePrefix).to(taskScheduler::setThreadNamePrefix);
		map.from(this.concurrencyLimit).to(taskScheduler::setConcurrencyLimit);
		map.from(this.virtualThreads).to(taskScheduler::setVirtualThreads);
		map.from(this.taskTerminationTimeout).as(Duration::toMillis).to(taskScheduler::setTaskTerminationTimeout);
		if (!CollectionUtils.isEmpty(this.customizers)) {
			this.customizers.forEach((customizer) -> customizer.customize(taskScheduler));
		}
		return taskScheduler;
	}
	private <T> Set<T> append(Set<T> set, Iterable<? extends T> additions) {
		Set<T> result = new LinkedHashSet<>((set != null) ? set : Collections.emptySet());
		additions.forEach(result::add);
		return Collections.unmodifiableSet(result);
	}
}
/*
/**
package org.springframework.boot.task;
/*
package org.springframework.boot.task;
/**
public class SimpleAsyncTaskExecutorBuilder {
	private final Boolean virtualThreads;
	private final String threadNamePrefix;
	private final Integer concurrencyLimit;
	private final TaskDecorator taskDecorator;
	private final Set<SimpleAsyncTaskExecutorCustomizer> customizers;
	private final Duration taskTerminationTimeout;
	public SimpleAsyncTaskExecutorBuilder() {
		this(null, null, null, null, null, null);
	}
	private SimpleAsyncTaskExecutorBuilder(Boolean virtualThreads, String threadNamePrefix, Integer concurrencyLimit,
			TaskDecorator taskDecorator, Set<SimpleAsyncTaskExecutorCustomizer> customizers,
			Duration taskTerminationTimeout) {
		this.virtualThreads = virtualThreads;
		this.threadNamePrefix = threadNamePrefix;
		this.concurrencyLimit = concurrencyLimit;
		this.taskDecorator = taskDecorator;
		this.customizers = customizers;
		this.taskTerminationTimeout = taskTerminationTimeout;
	}
	/**
	 * Set the prefix to use for the names of newly created threads.
	 * @param threadNamePrefix the thread name prefix to set
	 * @return a new builder instance
	 */
	public SimpleAsyncTaskExecutorBuilder threadNamePrefix(String threadNamePrefix) {
		return new SimpleAsyncTaskExecutorBuilder(this.virtualThreads, threadNamePrefix, this.concurrencyLimit,
				this.taskDecorator, this.customizers, this.taskTerminationTimeout);
	}
	/**
	 * Set whether to use virtual threads.
	 * @param virtualThreads whether to use virtual threads
	 * @return a new builder instance
	 */
	public SimpleAsyncTaskExecutorBuilder virtualThreads(Boolean virtualThreads) {
		return new SimpleAsyncTaskExecutorBuilder(virtualThreads, this.threadNamePrefix, this.concurrencyLimit,
				this.taskDecorator, this.customizers, this.taskTerminationTimeout);
	}
	/**
	 * Set the concurrency limit.
	 * @param concurrencyLimit the concurrency limit
	 * @return a new builder instance
	 */
	public SimpleAsyncTaskExecutorBuilder concurrencyLimit(Integer concurrencyLimit) {
		return new SimpleAsyncTaskExecutorBuilder(this.virtualThreads, this.threadNamePrefix, concurrencyLimit,
				this.taskDecorator, this.customizers, this.taskTerminationTimeout);
	}
	/**
	 * Set the {@link TaskDecorator} to use or {@code null} to not use any.
	 * @param taskDecorator the task decorator to use
	 * @return a new builder instance
	 */
	public SimpleAsyncTaskExecutorBuilder taskDecorator(TaskDecorator taskDecorator) {
		return new SimpleAsyncTaskExecutorBuilder(this.virtualThreads, this.threadNamePrefix, this.concurrencyLimit,
				taskDecorator, this.customizers, this.taskTerminationTimeout);
	}
	/**
	 * Set the task termination timeout.
	 * @param taskTerminationTimeout the task termination timeout
	 * @return a new builder instance
	 * @since 3.2.1
	 */
	public SimpleAsyncTaskExecutorBuilder taskTerminationTimeout(Duration taskTerminationTimeout) {
		return new SimpleAsyncTaskExecutorBuilder(this.virtualThreads, this.threadNamePrefix, this.concurrencyLimit,
				this.taskDecorator, this.customizers, taskTerminationTimeout);
	}
	/**
	 * Set the {@link SimpleAsyncTaskExecutorCustomizer customizers} that should be
	 * applied to the {@link SimpleAsyncTaskExecutor}. Customizers are applied in the
	 * order that they were added after builder configuration has been applied. Setting
	 * this value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(SimpleAsyncTaskExecutorCustomizer...)
	 */
	public SimpleAsyncTaskExecutorBuilder customizers(SimpleAsyncTaskExecutorCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return customizers(Arrays.asList(customizers));
	}
	/**
	 * Set the {@link SimpleAsyncTaskExecutorCustomizer customizers} that should be
	 * applied to the {@link SimpleAsyncTaskExecutor}. Customizers are applied in the
	 * order that they were added after builder configuration has been applied. Setting
	 * this value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(Iterable)
	 */
	public SimpleAsyncTaskExecutorBuilder customizers(
			Iterable<? extends SimpleAsyncTaskExecutorCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new SimpleAsyncTaskExecutorBuilder(this.virtualThreads, this.threadNamePrefix, this.concurrencyLimit,
				this.taskDecorator, append(null, customizers), this.taskTerminationTimeout);
	}
	/**
	 * Add {@link SimpleAsyncTaskExecutorCustomizer customizers} that should be applied to
	 * the {@link SimpleAsyncTaskExecutor}. Customizers are applied in the order that they
	 * were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(SimpleAsyncTaskExecutorCustomizer...)
	 */
	public SimpleAsyncTaskExecutorBuilder additionalCustomizers(SimpleAsyncTaskExecutorCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return additionalCustomizers(Arrays.asList(customizers));
	}
	/**
	 * Add {@link SimpleAsyncTaskExecutorCustomizer customizers} that should be applied to
	 * the {@link SimpleAsyncTaskExecutor}. Customizers are applied in the order that they
	 * were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(Iterable)
	 */
	public SimpleAsyncTaskExecutorBuilder additionalCustomizers(
			Iterable<? extends SimpleAsyncTaskExecutorCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new SimpleAsyncTaskExecutorBuilder(this.virtualThreads, this.threadNamePrefix, this.concurrencyLimit,
				this.taskDecorator, append(this.customizers, customizers), this.taskTerminationTimeout);
	}
	/**
	 * Build a new {@link SimpleAsyncTaskExecutor} instance and configure it using this
	 * builder.
	 * @return a configured {@link SimpleAsyncTaskExecutor} instance.
	 * @see #build(Class)
	 * @see #configure(SimpleAsyncTaskExecutor)
	 */
	public SimpleAsyncTaskExecutor build() {
		return configure(new SimpleAsyncTaskExecutor());
	}
	/**
	 * Build a new {@link SimpleAsyncTaskExecutor} instance of the specified type and
	 * configure it using this builder.
	 * @param <T> the type of task executor
	 * @param taskExecutorClass the template type to create
	 * @return a configured {@link SimpleAsyncTaskExecutor} instance.
	 * @see #build()
	 * @see #configure(SimpleAsyncTaskExecutor)
	 */
	public <T extends SimpleAsyncTaskExecutor> T build(Class<T> taskExecutorClass) {
		return configure(BeanUtils.instantiateClass(taskExecutorClass));
	}
	/**
	 * Configure the provided {@link SimpleAsyncTaskExecutor} instance using this builder.
	 * @param <T> the type of task executor
	 * @param taskExecutor the {@link SimpleAsyncTaskExecutor} to configure
	 * @return the task executor instance
	 * @see #build()
	 * @see #build(Class)
	 */
	public <T extends SimpleAsyncTaskExecutor> T configure(T taskExecutor) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.virtualThreads).to(taskExecutor::setVirtualThreads);
		map.from(this.threadNamePrefix).whenHasText().to(taskExecutor::setThreadNamePrefix);
		map.from(this.concurrencyLimit).to(taskExecutor::setConcurrencyLimit);
		map.from(this.taskDecorator).to(taskExecutor::setTaskDecorator);
		map.from(this.taskTerminationTimeout).as(Duration::toMillis).to(taskExecutor::setTaskTerminationTimeout);
		if (!CollectionUtils.isEmpty(this.customizers)) {
			this.customizers.forEach((customizer) -> customizer.customize(taskExecutor));
		}
		return taskExecutor;
	}
	private <T> Set<T> append(Set<T> set, Iterable<? extends T> additions) {
		Set<T> result = new LinkedHashSet<>((set != null) ? set : Collections.emptySet());
		additions.forEach(result::add);
		return Collections.unmodifiableSet(result);
	}
}
/*
package org.springframework.boot;
/**
public class SpringApplication {
	/**
	 * Default banner location.
	 */
	public static final String BANNER_LOCATION_PROPERTY_VALUE = SpringApplicationBannerPrinter.DEFAULT_BANNER_LOCATION;
	/**
	 * Banner location property key.
	 */
	public static final String BANNER_LOCATION_PROPERTY = SpringApplicationBannerPrinter.BANNER_LOCATION_PROPERTY;
	private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = 'java.awt.headless';
	private static final Log logger = LogFactory.getLog(SpringApplication.class);
	static final SpringApplicationShutdownHook shutdownHook = new SpringApplicationShutdownHook();
	private static final ThreadLocal<SpringApplicationHook> applicationHook = new ThreadLocal<>();
	private final Set<Class<?>> primarySources;
	private Class<?> mainApplicationClass;
	private boolean addCommandLineProperties = true;
	private boolean addConversionService = true;
	private Banner banner;
	private ResourceLoader resourceLoader;
	private BeanNameGenerator beanNameGenerator;
	private ConfigurableEnvironment environment;
	private boolean headless = true;
	private List<ApplicationContextInitializer<?>> initializers;
	private List<ApplicationListener<?>> listeners;
	private Map<String, Object> defaultProperties;
	private final List<BootstrapRegistryInitializer> bootstrapRegistryInitializers;
	private Set<String> additionalProfiles = Collections.emptySet();
	private boolean isCustomEnvironment = false;
	private String environmentPrefix;
	private ApplicationContextFactory applicationContextFactory = ApplicationContextFactory.DEFAULT;
	private ApplicationStartup applicationStartup = ApplicationStartup.DEFAULT;
	final ApplicationProperties properties = new ApplicationProperties();
	/**
	 * Create a new {@link SpringApplication} instance. The application context will load
	 * beans from the specified primary sources (see {@link SpringApplication class-level}
	 * documentation for details). The instance can be customized before calling
	 * {@link #run(String...)}.
	 * @param primarySources the primary bean sources
	 * @see #run(Class, String[])
	 * @see #SpringApplication(ResourceLoader, Class...)
	 * @see #setSources(Set)
	 */
	public SpringApplication(Class<?>... primarySources) {
		this(null, primarySources);
	}
	/**
	 * Create a new {@link SpringApplication} instance. The application context will load
	 * beans from the specified primary sources (see {@link SpringApplication class-level}
	 * documentation for details). The instance can be customized before calling
	 * {@link #run(String...)}.
	 * @param resourceLoader the resource loader to use
	 * @param primarySources the primary bean sources
	 * @see #run(Class, String[])
	 * @see #setSources(Set)
	 */
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, 'PrimarySources must not be null');
		this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
		this.properties.setWebApplicationType(WebApplicationType.deduceFromClasspath());
		this.bootstrapRegistryInitializers = new ArrayList<>(
				getSpringFactoriesInstances(BootstrapRegistryInitializer.class));
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		this.mainApplicationClass = deduceMainApplicationClass();
	}
	private Class<?> deduceMainApplicationClass() {
		return StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)
			.walk(this::findMainClass)
			.orElse(null);
	}
	private Optional<Class<?>> findMainClass(Stream<StackFrame> stack) {
		return stack.filter((frame) -> Objects.equals(frame.getMethodName(), 'main'))
			.findFirst()
			.map(StackWalker.StackFrame::getDeclaringClass);
	}
	/**
	 * Run the Spring application, creating and refreshing a new
	 * {@link ApplicationContext}.
	 * @param args the application arguments (usually passed from a Java main method)
	 * @return a running {@link ApplicationContext}
	 */
	public ConfigurableApplicationContext run(String... args) {
		Startup startup = Startup.create();
		if (this.properties.isRegisterShutdownHook()) {
			SpringApplication.shutdownHook.enableShutdownHookAddition();
		}
		DefaultBootstrapContext bootstrapContext = createBootstrapContext();
		ConfigurableApplicationContext context = null;
		configureHeadlessProperty();
		SpringApplicationRunListeners listeners = getRunListeners(args);
		listeners.starting(bootstrapContext, this.mainApplicationClass);
		try {
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
			Banner printedBanner = printBanner(environment);
			context = createApplicationContext();
			context.setApplicationStartup(this.applicationStartup);
			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
			refreshContext(context);
			afterRefresh(context, applicationArguments);
			startup.started();
			if (this.properties.isLogStartupInfo()) {
				new StartupInfoLogger(this.mainApplicationClass, environment).logStarted(getApplicationLog(), startup);
			}
			listeners.started(context, startup.timeTakenToStarted());
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
			throw handleRunFailure(context, ex, listeners);
		}
		try {
			if (context.isRunning()) {
				listeners.ready(context, startup.ready());
			}
		}
		catch (Throwable ex) {
			throw handleRunFailure(context, ex, null);
		}
		return context;
	}
	private DefaultBootstrapContext createBootstrapContext() {
		DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
		this.bootstrapRegistryInitializers.forEach((initializer) -> initializer.initialize(bootstrapContext));
		return bootstrapContext;
	}
	private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
			DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) {
		// Create and configure the environment
		ConfigurableEnvironment environment = getOrCreateEnvironment();
		configureEnvironment(environment, applicationArguments.getSourceArgs());
		ConfigurationPropertySources.attach(environment);
		listeners.environmentPrepared(bootstrapContext, environment);
		ApplicationInfoPropertySource.moveToEnd(environment);
		DefaultPropertiesPropertySource.moveToEnd(environment);
		Assert.state(!environment.containsProperty('spring.main.environment-prefix'),
				'Environment prefix cannot be set via properties.');
		bindToSpringApplication(environment);
		if (!this.isCustomEnvironment) {
			EnvironmentConverter environmentConverter = new EnvironmentConverter(getClassLoader());
			environment = environmentConverter.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());
		}
		ConfigurationPropertySources.attach(environment);
		return environment;
	}
	private Class<? extends ConfigurableEnvironment> deduceEnvironmentClass() {
		WebApplicationType webApplicationType = this.properties.getWebApplicationType();
		Class<? extends ConfigurableEnvironment> environmentType = this.applicationContextFactory
			.getEnvironmentType(webApplicationType);
		if (environmentType == null && this.applicationContextFactory != ApplicationContextFactory.DEFAULT) {
			environmentType = ApplicationContextFactory.DEFAULT.getEnvironmentType(webApplicationType);
		}
		return (environmentType != null) ? environmentType : ApplicationEnvironment.class;
	}
	private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,
			ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
			ApplicationArguments applicationArguments, Banner printedBanner) {
		context.setEnvironment(environment);
		postProcessApplicationContext(context);
		addAotGeneratedInitializerIfNecessary(this.initializers);
		applyInitializers(context);
		listeners.contextPrepared(context);
		bootstrapContext.close(context);
		if (this.properties.isLogStartupInfo()) {
			logStartupInfo(context.getParent() == null);
			logStartupInfo(context);
			logStartupProfileInfo(context);
		}
		// Add boot specific singleton beans
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		beanFactory.registerSingleton('springApplicationArguments', applicationArguments);
		if (printedBanner != null) {
			beanFactory.registerSingleton('springBootBanner', printedBanner);
		}
		if (beanFactory instanceof AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) {
			autowireCapableBeanFactory.setAllowCircularReferences(this.properties.isAllowCircularReferences());
			if (beanFactory instanceof DefaultListableBeanFactory listableBeanFactory) {
				listableBeanFactory.setAllowBeanDefinitionOverriding(this.properties.isAllowBeanDefinitionOverriding());
			}
		}
		if (this.properties.isLazyInitialization()) {
			context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
		}
		if (this.properties.isKeepAlive()) {
			context.addApplicationListener(new KeepAlive());
		}
		context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));
		if (!AotDetector.useGeneratedArtifacts()) {
			// Load the sources
			Set<Object> sources = getAllSources();
			Assert.notEmpty(sources, 'Sources must not be empty');
			load(context, sources.toArray(new Object[0]));
		}
		listeners.contextLoaded(context);
	}
	private void addAotGeneratedInitializerIfNecessary(List<ApplicationContextInitializer<?>> initializers) {
		if (AotDetector.useGeneratedArtifacts()) {
			List<ApplicationContextInitializer<?>> aotInitializers = new ArrayList<>(
					initializers.stream().filter(AotApplicationContextInitializer.class::isInstance).toList());
			if (aotInitializers.isEmpty()) {
				String initializerClassName = this.mainApplicationClass.getName() + '__ApplicationContextInitializer';
				if (!ClassUtils.isPresent(initializerClassName, getClassLoader())) {
					throw new AotInitializerNotFoundException(this.mainApplicationClass, initializerClassName);
				}
				aotInitializers.add(AotApplicationContextInitializer.forInitializerClasses(initializerClassName));
			}
			initializers.removeAll(aotInitializers);
			initializers.addAll(0, aotInitializers);
		}
	}
	private void refreshContext(ConfigurableApplicationContext context) {
		if (this.properties.isRegisterShutdownHook()) {
			shutdownHook.registerApplicationContext(context);
		}
		refresh(context);
	}
	private void configureHeadlessProperty() {
		System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,
				System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));
	}
	private SpringApplicationRunListeners getRunListeners(String[] args) {
		ArgumentResolver argumentResolver = ArgumentResolver.of(SpringApplication.class, this);
		argumentResolver = argumentResolver.and(String[].class, args);
		List<SpringApplicationRunListener> listeners = getSpringFactoriesInstances(SpringApplicationRunListener.class,
				argumentResolver);
		SpringApplicationHook hook = applicationHook.get();
		SpringApplicationRunListener hookListener = (hook != null) ? hook.getRunListener(this) : null;
		if (hookListener != null) {
			listeners = new ArrayList<>(listeners);
			listeners.add(hookListener);
		}
		return new SpringApplicationRunListeners(logger, listeners, this.applicationStartup);
	}
	private <T> List<T> getSpringFactoriesInstances(Class<T> type) {
		return getSpringFactoriesInstances(type, null);
	}
	private <T> List<T> getSpringFactoriesInstances(Class<T> type, ArgumentResolver argumentResolver) {
		return SpringFactoriesLoader.forDefaultResourceLocation(getClassLoader()).load(type, argumentResolver);
	}
	private ConfigurableEnvironment getOrCreateEnvironment() {
		if (this.environment != null) {
			return this.environment;
		}
		WebApplicationType webApplicationType = this.properties.getWebApplicationType();
		ConfigurableEnvironment environment = this.applicationContextFactory.createEnvironment(webApplicationType);
		if (environment == null && this.applicationContextFactory != ApplicationContextFactory.DEFAULT) {
			environment = ApplicationContextFactory.DEFAULT.createEnvironment(webApplicationType);
		}
		return (environment != null) ? environment : new ApplicationEnvironment();
	}
	/**
	 * Template method delegating to
	 * {@link #configurePropertySources(ConfigurableEnvironment, String[])} and
	 * {@link #configureProfiles(ConfigurableEnvironment, String[])} in that order.
	 * Override this method for complete control over Environment customization, or one of
	 * the above for fine-grained control over property sources or profiles, respectively.
	 * @param environment this application"s environment
	 * @param args arguments passed to the {@code run} method
	 * @see #configureProfiles(ConfigurableEnvironment, String[])
	 * @see #configurePropertySources(ConfigurableEnvironment, String[])
	 */
	protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) {
		if (this.addConversionService) {
			environment.setConversionService(new ApplicationConversionService());
		}
		configurePropertySources(environment, args);
		configureProfiles(environment, args);
	}
	/**
	 * Add, remove or re-order any {@link PropertySource}s in this application"s
	 * environment.
	 * @param environment this application"s environment
	 * @param args arguments passed to the {@code run} method
	 * @see #configureEnvironment(ConfigurableEnvironment, String[])
	 */
	protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) {
		MutablePropertySources sources = environment.getPropertySources();
		if (!CollectionUtils.isEmpty(this.defaultProperties)) {
			DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources);
		}
		if (this.addCommandLineProperties && args.length > 0) {
			String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;
			if (sources.contains(name)) {
				PropertySource<?> source = sources.get(name);
				CompositePropertySource composite = new CompositePropertySource(name);
				composite
					.addPropertySource(new SimpleCommandLinePropertySource('springApplicationCommandLineArgs', args));
				composite.addPropertySource(source);
				sources.replace(name, composite);
			}
			else {
				sources.addFirst(new SimpleCommandLinePropertySource(args));
			}
		}
		environment.getPropertySources().addLast(new ApplicationInfoPropertySource(this.mainApplicationClass));
	}
	/**
	 * Configure which profiles are active (or active by default) for this application
	 * environment. Additional profiles may be activated during configuration file
	 * processing through the {@code spring.profiles.active} property.
	 * @param environment this application"s environment
	 * @param args arguments passed to the {@code run} method
	 * @see #configureEnvironment(ConfigurableEnvironment, String[])
	 */
	protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {
	}
	/**
	 * Bind the environment to the {@link ApplicationProperties}.
	 * @param environment the environment to bind
	 */
	protected void bindToSpringApplication(ConfigurableEnvironment environment) {
		try {
			Binder.get(environment).bind('spring.main', Bindable.ofInstance(this.properties));
		}
		catch (Exception ex) {
			throw new IllegalStateException('Cannot bind to SpringApplication', ex);
		}
	}
	private Banner printBanner(ConfigurableEnvironment environment) {
		if (this.properties.getBannerMode(environment) == Banner.Mode.OFF) {
			return null;
		}
		ResourceLoader resourceLoader = (this.resourceLoader != null) ? this.resourceLoader
				: new DefaultResourceLoader(null);
		SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner);
		if (this.properties.getBannerMode(environment) == Mode.LOG) {
			return bannerPrinter.print(environment, this.mainApplicationClass, logger);
		}
		return bannerPrinter.print(environment, this.mainApplicationClass, System.out);
	}
	/**
	 * Strategy method used to create the {@link ApplicationContext}. By default this
	 * method will respect any explicitly set application context class or factory before
	 * falling back to a suitable default.
	 * @return the application context (not yet refreshed)
	 * @see #setApplicationContextFactory(ApplicationContextFactory)
	 */
	protected ConfigurableApplicationContext createApplicationContext() {
		return this.applicationContextFactory.create(this.properties.getWebApplicationType());
	}
	/**
	 * Apply any relevant post-processing to the {@link ApplicationContext}. Subclasses
	 * can apply additional processing as required.
	 * @param context the application context
	 */
	protected void postProcessApplicationContext(ConfigurableApplicationContext context) {
		if (this.beanNameGenerator != null) {
			context.getBeanFactory()
				.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, this.beanNameGenerator);
		}
		if (this.resourceLoader != null) {
			if (context instanceof GenericApplicationContext genericApplicationContext) {
				genericApplicationContext.setResourceLoader(this.resourceLoader);
			}
			if (context instanceof DefaultResourceLoader defaultResourceLoader) {
				defaultResourceLoader.setClassLoader(this.resourceLoader.getClassLoader());
			}
		}
		if (this.addConversionService) {
			context.getBeanFactory().setConversionService(context.getEnvironment().getConversionService());
		}
	}
	/**
	 * Apply any {@link ApplicationContextInitializer}s to the context before it is
	 * refreshed.
	 * @param context the configured ApplicationContext (not refreshed yet)
	 * @see ConfigurableApplicationContext#refresh()
	 */
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	protected void applyInitializers(ConfigurableApplicationContext context) {
		for (ApplicationContextInitializer initializer : getInitializers()) {
			Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),
					ApplicationContextInitializer.class);
			Assert.isInstanceOf(requiredType, context, 'Unable to call initializer.');
			initializer.initialize(context);
		}
	}
	/**
	 * Called to log startup information, subclasses may override to add additional
	 * logging.
	 * @param context the application context
	 * @since 3.4.0
	 */
	protected void logStartupInfo(ConfigurableApplicationContext context) {
		boolean isRoot = context.getParent() == null;
		if (isRoot) {
			new StartupInfoLogger(this.mainApplicationClass, context.getEnvironment()).logStarting(getApplicationLog());
		}
	}
	/**
	 * Called to log startup information, subclasses may override to add additional
	 * logging.
	 * @param isRoot true if this application is the root of a context hierarchy
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #logStartupInfo(ConfigurableApplicationContext)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	protected void logStartupInfo(boolean isRoot) {
	}
	/**
	 * Called to log active profile information.
	 * @param context the application context
	 */
	protected void logStartupProfileInfo(ConfigurableApplicationContext context) {
		Log log = getApplicationLog();
		if (log.isInfoEnabled()) {
			List<String> activeProfiles = quoteProfiles(context.getEnvironment().getActiveProfiles());
			if (ObjectUtils.isEmpty(activeProfiles)) {
				List<String> defaultProfiles = quoteProfiles(context.getEnvironment().getDefaultProfiles());
				String message = String.format('%s default %s: ', defaultProfiles.size(),
						(defaultProfiles.size() <= 1) ? 'profile' : 'profiles');
				log.info('No active profile set, falling back to ' + message
						+ StringUtils.collectionToDelimitedString(defaultProfiles, ', '));
			}
			else {
				String message = (activeProfiles.size() == 1) ? '1 profile is active: '
						: activeProfiles.size() + ' profiles are active: ';
				log.info('The following ' + message + StringUtils.collectionToDelimitedString(activeProfiles, ', '));
			}
		}
	}
	private List<String> quoteProfiles(String[] profiles) {
		return Arrays.stream(profiles).map((profile) -> '\'' + profile + '\'').toList();
	}
	/**
	 * Returns the {@link Log} for the application. By default will be deduced.
	 * @return the application log
	 */
	protected Log getApplicationLog() {
		if (this.mainApplicationClass == null) {
			return logger;
		}
		return LogFactory.getLog(this.mainApplicationClass);
	}
	/**
	 * Load beans into the application context.
	 * @param context the context to load beans into
	 * @param sources the sources to load
	 */
	protected void load(ApplicationContext context, Object[] sources) {
		if (logger.isDebugEnabled()) {
			logger.debug('Loading source ' + StringUtils.arrayToCommaDelimitedString(sources));
		}
		BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);
		if (this.beanNameGenerator != null) {
			loader.setBeanNameGenerator(this.beanNameGenerator);
		}
		if (this.resourceLoader != null) {
			loader.setResourceLoader(this.resourceLoader);
		}
		if (this.environment != null) {
			loader.setEnvironment(this.environment);
		}
		loader.load();
	}
	/**
	 * The ResourceLoader that will be used in the ApplicationContext.
	 * @return the resourceLoader the resource loader that will be used in the
	 * ApplicationContext (or null if the default)
	 */
	public ResourceLoader getResourceLoader() {
		return this.resourceLoader;
	}
	/**
	 * Either the ClassLoader that will be used in the ApplicationContext (if
	 * {@link #setResourceLoader(ResourceLoader) resourceLoader} is set), or the context
	 * class loader (if not null), or the loader of the Spring {@link ClassUtils} class.
	 * @return a ClassLoader (never null)
	 */
	public ClassLoader getClassLoader() {
		if (this.resourceLoader != null) {
			return this.resourceLoader.getClassLoader();
		}
		return ClassUtils.getDefaultClassLoader();
	}
	/**
	 * Get the bean definition registry.
	 * @param context the application context
	 * @return the BeanDefinitionRegistry if it can be determined
	 */
	private BeanDefinitionRegistry getBeanDefinitionRegistry(ApplicationContext context) {
		if (context instanceof BeanDefinitionRegistry registry) {
			return registry;
		}
		if (context instanceof AbstractApplicationContext abstractApplicationContext) {
			return (BeanDefinitionRegistry) abstractApplicationContext.getBeanFactory();
		}
		throw new IllegalStateException('Could not locate BeanDefinitionRegistry');
	}
	/**
	 * Factory method used to create the {@link BeanDefinitionLoader}.
	 * @param registry the bean definition registry
	 * @param sources the sources to load
	 * @return the {@link BeanDefinitionLoader} that will be used to load beans
	 */
	protected BeanDefinitionLoader createBeanDefinitionLoader(BeanDefinitionRegistry registry, Object[] sources) {
		return new BeanDefinitionLoader(registry, sources);
	}
	/**
	 * Refresh the underlying {@link ApplicationContext}.
	 * @param applicationContext the application context to refresh
	 */
	protected void refresh(ConfigurableApplicationContext applicationContext) {
		applicationContext.refresh();
	}
	/**
	 * Called after the context has been refreshed.
	 * @param context the application context
	 * @param args the application arguments
	 */
	protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) {
	}
	private void callRunners(ConfigurableApplicationContext context, ApplicationArguments args) {
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		String[] beanNames = beanFactory.getBeanNamesForType(Runner.class);
		Map<Runner, String> instancesToBeanNames = new IdentityHashMap<>();
		for (String beanName : beanNames) {
			instancesToBeanNames.put(beanFactory.getBean(beanName, Runner.class), beanName);
		}
		Comparator<Object> comparator = getOrderComparator(beanFactory)
			.withSourceProvider(new FactoryAwareOrderSourceProvider(beanFactory, instancesToBeanNames));
		instancesToBeanNames.keySet().stream().sorted(comparator).forEach((runner) -> callRunner(runner, args));
	}
	private OrderComparator getOrderComparator(ConfigurableListableBeanFactory beanFactory) {
		Comparator<?> dependencyComparator = (beanFactory instanceof DefaultListableBeanFactory defaultListableBeanFactory)
				? defaultListableBeanFactory.getDependencyComparator() : null;
		return (dependencyComparator instanceof OrderComparator orderComparator) ? orderComparator
				: AnnotationAwareOrderComparator.INSTANCE;
	}
	private void callRunner(Runner runner, ApplicationArguments args) {
		if (runner instanceof ApplicationRunner) {
			callRunner(ApplicationRunner.class, runner, (applicationRunner) -> applicationRunner.run(args));
		}
		if (runner instanceof CommandLineRunner) {
			callRunner(CommandLineRunner.class, runner,
					(commandLineRunner) -> commandLineRunner.run(args.getSourceArgs()));
		}
	}
	@SuppressWarnings('unchecked')
	private <R extends Runner> void callRunner(Class<R> type, Runner runner, ThrowingConsumer<R> call) {
		call.throwing(
				(message, ex) -> new IllegalStateException('Failed to execute ' + ClassUtils.getShortName(type), ex))
			.accept((R) runner);
	}
	private RuntimeException handleRunFailure(ConfigurableApplicationContext context, Throwable exception,
			SpringApplicationRunListeners listeners) {
		if (exception instanceof AbandonedRunException abandonedRunException) {
			return abandonedRunException;
		}
		try {
			try {
				handleExitCode(context, exception);
				if (listeners != null) {
					listeners.failed(context, exception);
				}
			}
			finally {
				reportFailure(getExceptionReporters(context), exception);
				if (context != null) {
					context.close();
					shutdownHook.deregisterFailedApplicationContext(context);
				}
			}
		}
		catch (Exception ex) {
			logger.warn('Unable to close ApplicationContext', ex);
		}
		return (exception instanceof RuntimeException runtimeException) ? runtimeException
				: new IllegalStateException(exception);
	}
	private Collection<SpringBootExceptionReporter> getExceptionReporters(ConfigurableApplicationContext context) {
		try {
			ArgumentResolver argumentResolver = ArgumentResolver.of(ConfigurableApplicationContext.class, context);
			return getSpringFactoriesInstances(SpringBootExceptionReporter.class, argumentResolver);
		}
		catch (Throwable ex) {
			return Collections.emptyList();
		}
	}
	private void reportFailure(Collection<SpringBootExceptionReporter> exceptionReporters, Throwable failure) {
		try {
			for (SpringBootExceptionReporter reporter : exceptionReporters) {
				if (reporter.reportException(failure)) {
					registerLoggedException(failure);
					return;
				}
			}
		}
		catch (Throwable ex) {
			// Continue with normal handling of the original failure
		}
		if (logger.isErrorEnabled()) {
			if (NativeDetector.inNativeImage()) {
				// Depending on how early the failure was, logging may not work in a
				// native image so we output the stack trace directly to System.out
				// instead.
				System.out.println('Application run failed');
				failure.printStackTrace(System.out);
			}
			else {
				logger.error('Application run failed', failure);
			}
			registerLoggedException(failure);
		}
	}
	/**
	 * Register that the given exception has been logged. By default, if the running in
	 * the main thread, this method will suppress additional printing of the stacktrace.
	 * @param exception the exception that was logged
	 */
	protected void registerLoggedException(Throwable exception) {
		SpringBootExceptionHandler handler = getSpringBootExceptionHandler();
		if (handler != null) {
			handler.registerLoggedException(exception);
		}
	}
	private void handleExitCode(ConfigurableApplicationContext context, Throwable exception) {
		int exitCode = getExitCodeFromException(context, exception);
		if (exitCode != 0) {
			if (context != null) {
				context.publishEvent(new ExitCodeEvent(context, exitCode));
			}
			SpringBootExceptionHandler handler = getSpringBootExceptionHandler();
			if (handler != null) {
				handler.registerExitCode(exitCode);
			}
		}
	}
	private int getExitCodeFromException(ConfigurableApplicationContext context, Throwable exception) {
		int exitCode = getExitCodeFromMappedException(context, exception);
		if (exitCode == 0) {
			exitCode = getExitCodeFromExitCodeGeneratorException(exception);
		}
		return exitCode;
	}
	private int getExitCodeFromMappedException(ConfigurableApplicationContext context, Throwable exception) {
		if (context == null || !context.isActive()) {
			return 0;
		}
		ExitCodeGenerators generators = new ExitCodeGenerators();
		Collection<ExitCodeExceptionMapper> beans = context.getBeansOfType(ExitCodeExceptionMapper.class).values();
		generators.addAll(exception, beans);
		return generators.getExitCode();
	}
	private int getExitCodeFromExitCodeGeneratorException(Throwable exception) {
		if (exception == null) {
			return 0;
		}
		if (exception instanceof ExitCodeGenerator generator) {
			return generator.getExitCode();
		}
		return getExitCodeFromExitCodeGeneratorException(exception.getCause());
	}
	SpringBootExceptionHandler getSpringBootExceptionHandler() {
		if (isMainThread(Thread.currentThread())) {
			return SpringBootExceptionHandler.forCurrentThread();
		}
		return null;
	}
	private boolean isMainThread(Thread currentThread) {
		return ('main'.equals(currentThread.getName()) || 'restartedMain'.equals(currentThread.getName()))
				&& 'main'.equals(currentThread.getThreadGroup().getName());
	}
	/**
	 * Returns the main application class that has been deduced or explicitly configured.
	 * @return the main application class or {@code null}
	 */
	public Class<?> getMainApplicationClass() {
		return this.mainApplicationClass;
	}
	/**
	 * Set a specific main application class that will be used as a log source and to
	 * obtain version information. By default the main application class will be deduced.
	 * Can be set to {@code null} if there is no explicit application class.
	 * @param mainApplicationClass the mainApplicationClass to set or {@code null}
	 */
	public void setMainApplicationClass(Class<?> mainApplicationClass) {
		this.mainApplicationClass = mainApplicationClass;
	}
	/**
	 * Returns the type of web application that is being run.
	 * @return the type of web application
	 * @since 2.0.0
	 */
	public WebApplicationType getWebApplicationType() {
		return this.properties.getWebApplicationType();
	}
	/**
	 * Sets the type of web application to be run. If not explicitly set the type of web
	 * application will be deduced based on the classpath.
	 * @param webApplicationType the web application type
	 * @since 2.0.0
	 */
	public void setWebApplicationType(WebApplicationType webApplicationType) {
		Assert.notNull(webApplicationType, 'WebApplicationType must not be null');
		this.properties.setWebApplicationType(webApplicationType);
	}
	/**
	 * Sets if bean definition overriding, by registering a definition with the same name
	 * as an existing definition, should be allowed. Defaults to {@code false}.
	 * @param allowBeanDefinitionOverriding if overriding is allowed
	 * @since 2.1.0
	 * @see DefaultListableBeanFactory#setAllowBeanDefinitionOverriding(boolean)
	 */
	public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
		this.properties.setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding);
	}
	/**
	 * Sets whether to allow circular references between beans and automatically try to
	 * resolve them. Defaults to {@code false}.
	 * @param allowCircularReferences if circular references are allowed
	 * @since 2.6.0
	 * @see AbstractAutowireCapableBeanFactory#setAllowCircularReferences(boolean)
	 */
	public void setAllowCircularReferences(boolean allowCircularReferences) {
		this.properties.setAllowCircularReferences(allowCircularReferences);
	}
	/**
	 * Sets if beans should be initialized lazily. Defaults to {@code false}.
	 * @param lazyInitialization if initialization should be lazy
	 * @since 2.2
	 * @see BeanDefinition#setLazyInit(boolean)
	 */
	public void setLazyInitialization(boolean lazyInitialization) {
		this.properties.setLazyInitialization(lazyInitialization);
	}
	/**
	 * Sets if the application is headless and should not instantiate AWT. Defaults to
	 * {@code true} to prevent java icons appearing.
	 * @param headless if the application is headless
	 */
	public void setHeadless(boolean headless) {
		this.headless = headless;
	}
	/**
	 * Sets if the created {@link ApplicationContext} should have a shutdown hook
	 * registered. Defaults to {@code true} to ensure that JVM shutdowns are handled
	 * gracefully.
	 * @param registerShutdownHook if the shutdown hook should be registered
	 * @see #getShutdownHandlers()
	 */
	public void setRegisterShutdownHook(boolean registerShutdownHook) {
		this.properties.setRegisterShutdownHook(registerShutdownHook);
	}
	/**
	 * Sets the {@link Banner} instance which will be used to print the banner when no
	 * static banner file is provided.
	 * @param banner the Banner instance to use
	 */
	public void setBanner(Banner banner) {
		this.banner = banner;
	}
	/**
	 * Sets the mode used to display the banner when the application runs. Defaults to
	 * {@code Banner.Mode.CONSOLE}.
	 * @param bannerMode the mode used to display the banner
	 */
	public void setBannerMode(Banner.Mode bannerMode) {
		this.properties.setBannerMode(bannerMode);
	}
	/**
	 * Sets if the application information should be logged when the application starts.
	 * Defaults to {@code true}.
	 * @param logStartupInfo if startup info should be logged.
	 */
	public void setLogStartupInfo(boolean logStartupInfo) {
		this.properties.setLogStartupInfo(logStartupInfo);
	}
	/**
	 * Sets if a {@link CommandLinePropertySource} should be added to the application
	 * context in order to expose arguments. Defaults to {@code true}.
	 * @param addCommandLineProperties if command line arguments should be exposed
	 */
	public void setAddCommandLineProperties(boolean addCommandLineProperties) {
		this.addCommandLineProperties = addCommandLineProperties;
	}
	/**
	 * Sets if the {@link ApplicationConversionService} should be added to the application
	 * context"s {@link Environment}.
	 * @param addConversionService if the application conversion service should be added
	 * @since 2.1.0
	 */
	public void setAddConversionService(boolean addConversionService) {
		this.addConversionService = addConversionService;
	}
	/**
	 * Adds {@link BootstrapRegistryInitializer} instances that can be used to initialize
	 * the {@link BootstrapRegistry}.
	 * @param bootstrapRegistryInitializer the bootstrap registry initializer to add
	 * @since 2.4.5
	 */
	public void addBootstrapRegistryInitializer(BootstrapRegistryInitializer bootstrapRegistryInitializer) {
		Assert.notNull(bootstrapRegistryInitializer, 'BootstrapRegistryInitializer must not be null');
		this.bootstrapRegistryInitializers.addAll(Arrays.asList(bootstrapRegistryInitializer));
	}
	/**
	 * Set default environment properties which will be used in addition to those in the
	 * existing {@link Environment}.
	 * @param defaultProperties the additional properties to set
	 */
	public void setDefaultProperties(Map<String, Object> defaultProperties) {
		this.defaultProperties = defaultProperties;
	}
	/**
	 * Convenient alternative to {@link #setDefaultProperties(Map)}.
	 * @param defaultProperties some {@link Properties}
	 */
	public void setDefaultProperties(Properties defaultProperties) {
		this.defaultProperties = new HashMap<>();
		for (Object key : Collections.list(defaultProperties.propertyNames())) {
			this.defaultProperties.put((String) key, defaultProperties.get(key));
		}
	}
	/**
	 * Set additional profile values to use (on top of those set in system or command line
	 * properties).
	 * @param profiles the additional profiles to set
	 */
	public void setAdditionalProfiles(String... profiles) {
		this.additionalProfiles = Collections.unmodifiableSet(new LinkedHashSet<>(Arrays.asList(profiles)));
	}
	/**
	 * Return an immutable set of any additional profiles in use.
	 * @return the additional profiles
	 */
	public Set<String> getAdditionalProfiles() {
		return this.additionalProfiles;
	}
	/**
	 * Sets the bean name generator that should be used when generating bean names.
	 * @param beanNameGenerator the bean name generator
	 */
	public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
		this.beanNameGenerator = beanNameGenerator;
	}
	/**
	 * Sets the underlying environment that should be used with the created application
	 * context.
	 * @param environment the environment
	 */
	public void setEnvironment(ConfigurableEnvironment environment) {
		this.isCustomEnvironment = true;
		this.environment = environment;
	}
	/**
	 * Add additional items to the primary sources that will be added to an
	 * ApplicationContext when {@link #run(String...)} is called.
	 * <p>
	 * The sources here are added to those that were set in the constructor. Most users
	 * should consider using {@link #getSources()}/{@link #setSources(Set)} rather than
	 * calling this method.
	 * @param additionalPrimarySources the additional primary sources to add
	 * @see #SpringApplication(Class...)
	 * @see #getSources()
	 * @see #setSources(Set)
	 * @see #getAllSources()
	 */
	public void addPrimarySources(Collection<Class<?>> additionalPrimarySources) {
		this.primarySources.addAll(additionalPrimarySources);
	}
	/**
	 * Returns a mutable set of the sources that will be added to an ApplicationContext
	 * when {@link #run(String...)} is called.
	 * <p>
	 * Sources set here will be used in addition to any primary sources set in the
	 * constructor.
	 * @return the application sources.
	 * @see #SpringApplication(Class...)
	 * @see #getAllSources()
	 */
	public Set<String> getSources() {
		return this.properties.getSources();
	}
	/**
	 * Set additional sources that will be used to create an ApplicationContext. A source
	 * can be: a class name, package name, or an XML resource location.
	 * <p>
	 * Sources set here will be used in addition to any primary sources set in the
	 * constructor.
	 * @param sources the application sources to set
	 * @see #SpringApplication(Class...)
	 * @see #getAllSources()
	 */
	public void setSources(Set<String> sources) {
		Assert.notNull(sources, 'Sources must not be null');
		this.properties.setSources(sources);
	}
	/**
	 * Return an immutable set of all the sources that will be added to an
	 * ApplicationContext when {@link #run(String...)} is called. This method combines any
	 * primary sources specified in the constructor with any additional ones that have
	 * been {@link #setSources(Set) explicitly set}.
	 * @return an immutable set of all sources
	 */
	public Set<Object> getAllSources() {
		Set<Object> allSources = new LinkedHashSet<>();
		if (!CollectionUtils.isEmpty(this.primarySources)) {
			allSources.addAll(this.primarySources);
		}
		if (!CollectionUtils.isEmpty(this.properties.getSources())) {
			allSources.addAll(this.properties.getSources());
		}
		return Collections.unmodifiableSet(allSources);
	}
	/**
	 * Sets the {@link ResourceLoader} that should be used when loading resources.
	 * @param resourceLoader the resource loader
	 */
	public void setResourceLoader(ResourceLoader resourceLoader) {
		Assert.notNull(resourceLoader, 'ResourceLoader must not be null');
		this.resourceLoader = resourceLoader;
	}
	/**
	 * Return a prefix that should be applied when obtaining configuration properties from
	 * the system environment.
	 * @return the environment property prefix
	 * @since 2.5.0
	 */
	public String getEnvironmentPrefix() {
		return this.environmentPrefix;
	}
	/**
	 * Set the prefix that should be applied when obtaining configuration properties from
	 * the system environment.
	 * @param environmentPrefix the environment property prefix to set
	 * @since 2.5.0
	 */
	public void setEnvironmentPrefix(String environmentPrefix) {
		this.environmentPrefix = environmentPrefix;
	}
	/**
	 * Sets the factory that will be called to create the application context. If not set,
	 * defaults to a factory that will create
	 * {@link AnnotationConfigServletWebServerApplicationContext} for servlet web
	 * applications, {@link AnnotationConfigReactiveWebServerApplicationContext} for
	 * reactive web applications, and {@link AnnotationConfigApplicationContext} for
	 * non-web applications.
	 * @param applicationContextFactory the factory for the context
	 * @since 2.4.0
	 */
	public void setApplicationContextFactory(ApplicationContextFactory applicationContextFactory) {
		this.applicationContextFactory = (applicationContextFactory != null) ? applicationContextFactory
				: ApplicationContextFactory.DEFAULT;
	}
	/**
	 * Sets the {@link ApplicationContextInitializer} that will be applied to the Spring
	 * {@link ApplicationContext}.
	 * @param initializers the initializers to set
	 */
	public void setInitializers(Collection<? extends ApplicationContextInitializer<?>> initializers) {
		this.initializers = new ArrayList<>(initializers);
	}
	/**
	 * Add {@link ApplicationContextInitializer}s to be applied to the Spring
	 * {@link ApplicationContext}.
	 * @param initializers the initializers to add
	 */
	public void addInitializers(ApplicationContextInitializer<?>... initializers) {
		this.initializers.addAll(Arrays.asList(initializers));
	}
	/**
	 * Returns read-only ordered Set of the {@link ApplicationContextInitializer}s that
	 * will be applied to the Spring {@link ApplicationContext}.
	 * @return the initializers
	 */
	public Set<ApplicationContextInitializer<?>> getInitializers() {
		return asUnmodifiableOrderedSet(this.initializers);
	}
	/**
	 * Sets the {@link ApplicationListener}s that will be applied to the SpringApplication
	 * and registered with the {@link ApplicationContext}.
	 * @param listeners the listeners to set
	 */
	public void setListeners(Collection<? extends ApplicationListener<?>> listeners) {
		this.listeners = new ArrayList<>(listeners);
	}
	/**
	 * Add {@link ApplicationListener}s to be applied to the SpringApplication and
	 * registered with the {@link ApplicationContext}.
	 * @param listeners the listeners to add
	 */
	public void addListeners(ApplicationListener<?>... listeners) {
		this.listeners.addAll(Arrays.asList(listeners));
	}
	/**
	 * Returns read-only ordered Set of the {@link ApplicationListener}s that will be
	 * applied to the SpringApplication and registered with the {@link ApplicationContext}
	 * .
	 * @return the listeners
	 */
	public Set<ApplicationListener<?>> getListeners() {
		return asUnmodifiableOrderedSet(this.listeners);
	}
	/**
	 * Set the {@link ApplicationStartup} to use for collecting startup metrics.
	 * @param applicationStartup the application startup to use
	 * @since 2.4.0
	 */
	public void setApplicationStartup(ApplicationStartup applicationStartup) {
		this.applicationStartup = (applicationStartup != null) ? applicationStartup : ApplicationStartup.DEFAULT;
	}
	/**
	 * Returns the {@link ApplicationStartup} used for collecting startup metrics.
	 * @return the application startup
	 * @since 2.4.0
	 */
	public ApplicationStartup getApplicationStartup() {
		return this.applicationStartup;
	}
	/**
	 * Whether to keep the application alive even if there are no more non-daemon threads.
	 * @return whether to keep the application alive even if there are no more non-daemon
	 * threads
	 * @since 3.2.0
	 */
	public boolean isKeepAlive() {
		return this.properties.isKeepAlive();
	}
	/**
	 * Set whether to keep the application alive even if there are no more non-daemon
	 * threads.
	 * @param keepAlive whether to keep the application alive even if there are no more
	 * non-daemon threads
	 * @since 3.2.0
	 */
	public void setKeepAlive(boolean keepAlive) {
		this.properties.setKeepAlive(keepAlive);
	}
	/**
	 * Return a {@link SpringApplicationShutdownHandlers} instance that can be used to add
	 * or remove handlers that perform actions before the JVM is shutdown.
	 * @return a {@link SpringApplicationShutdownHandlers} instance
	 * @since 2.5.1
	 */
	public static SpringApplicationShutdownHandlers getShutdownHandlers() {
		return shutdownHook.getHandlers();
	}
	/**
	 * Static helper that can be used to run a {@link SpringApplication} from the
	 * specified source using default settings.
	 * @param primarySource the primary source to load
	 * @param args the application arguments (usually passed from a Java main method)
	 * @return the running {@link ApplicationContext}
	 */
	public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
		return run(new Class<?>[] { primarySource }, args);
	}
	/**
	 * Static helper that can be used to run a {@link SpringApplication} from the
	 * specified sources using default settings and user supplied arguments.
	 * @param primarySources the primary sources to load
	 * @param args the application arguments (usually passed from a Java main method)
	 * @return the running {@link ApplicationContext}
	 */
	public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
		return new SpringApplication(primarySources).run(args);
	}
	/**
	 * A basic main that can be used to launch an application. This method is useful when
	 * application sources are defined through a {@literal --spring.main.sources} command
	 * line argument.
	 * <p>
	 * Most developers will want to define their own main method and call the
	 * {@link #run(Class, String...) run} method instead.
	 * @param args command line arguments
	 * @throws Exception if the application cannot be started
	 * @see SpringApplication#run(Class[], String[])
	 * @see SpringApplication#run(Class, String...)
	 */
	public static void main(String[] args) throws Exception {
		SpringApplication.run(new Class<?>[0], args);
	}
	/**
	 * Static helper that can be used to exit a {@link SpringApplication} and obtain a
	 * code indicating success (0) or otherwise. Does not throw exceptions but should
	 * print stack traces of any encountered. Applies the specified
	 * {@link ExitCodeGenerator ExitCodeGenerators} in addition to any Spring beans that
	 * implement {@link ExitCodeGenerator}. When multiple generators are available, the
	 * first non-zero exit code is used. Generators are ordered based on their
	 * {@link Ordered} implementation and {@link Order @Order} annotation.
	 * @param context the context to close if possible
	 * @param exitCodeGenerators exit code generators
	 * @return the outcome (0 if successful)
	 */
	public static int exit(ApplicationContext context, ExitCodeGenerator... exitCodeGenerators) {
		Assert.notNull(context, 'Context must not be null');
		int exitCode = 0;
		try {
			try {
				ExitCodeGenerators generators = new ExitCodeGenerators();
				Collection<ExitCodeGenerator> beans = context.getBeansOfType(ExitCodeGenerator.class).values();
				generators.addAll(exitCodeGenerators);
				generators.addAll(beans);
				exitCode = generators.getExitCode();
				if (exitCode != 0) {
					context.publishEvent(new ExitCodeEvent(context, exitCode));
				}
			}
			finally {
				close(context);
			}
		}
		catch (Exception ex) {
			ex.printStackTrace();
			exitCode = (exitCode != 0) ? exitCode : 1;
		}
		return exitCode;
	}
	/**
	 * Create an application from an existing {@code main} method that can run with
	 * additional {@code @Configuration} or bean classes. This method can be helpful when
	 * writing a test harness that needs to start an application with additional
	 * configuration.
	 * @param main the main method entry point that runs the {@link SpringApplication}
	 * @return a {@link SpringApplication.Augmented} instance that can be used to add
	 * configuration and run the application
	 * @since 3.1.0
	 * @see #withHook(SpringApplicationHook, Runnable)
	 */
	public static SpringApplication.Augmented from(ThrowingConsumer<String[]> main) {
		Assert.notNull(main, 'Main must not be null');
		return new Augmented(main, Collections.emptySet(), Collections.emptySet());
	}
	/**
	 * Perform the given action with the given {@link SpringApplicationHook} attached if
	 * the action triggers an {@link SpringApplication#run(String...) application run}.
	 * @param hook the hook to apply
	 * @param action the action to run
	 * @since 3.0.0
	 * @see #withHook(SpringApplicationHook, ThrowingSupplier)
	 */
	public static void withHook(SpringApplicationHook hook, Runnable action) {
		withHook(hook, () -> {
			action.run();
			return null;
		});
	}
	/**
	 * Perform the given action with the given {@link SpringApplicationHook} attached if
	 * the action triggers an {@link SpringApplication#run(String...) application run}.
	 * @param <T> the result type
	 * @param hook the hook to apply
	 * @param action the action to run
	 * @return the result of the action
	 * @since 3.0.0
	 * @see #withHook(SpringApplicationHook, Runnable)
	 */
	public static <T> T withHook(SpringApplicationHook hook, ThrowingSupplier<T> action) {
		applicationHook.set(hook);
		try {
			return action.get();
		}
		finally {
			applicationHook.remove();
		}
	}
	private static void close(ApplicationContext context) {
		if (context instanceof ConfigurableApplicationContext closable) {
			closable.close();
		}
	}
	private static <E> Set<E> asUnmodifiableOrderedSet(Collection<E> elements) {
		List<E> list = new ArrayList<>(elements);
		list.sort(AnnotationAwareOrderComparator.INSTANCE);
		return new LinkedHashSet<>(list);
	}
	/**
	 * Used to configure and run an augmented {@link SpringApplication} where additional
	 * configuration should be applied.
	 *
	 * @since 3.1.0
	 */
	public static class Augmented {
		private final ThrowingConsumer<String[]> main;
		private final Set<Class<?>> sources;
		private final Set<String> additionalProfiles;
		Augmented(ThrowingConsumer<String[]> main, Set<Class<?>> sources, Set<String> additionalProfiles) {
			this.main = main;
			this.sources = Set.copyOf(sources);
			this.additionalProfiles = additionalProfiles;
		}
		/**
		 * Return a new {@link SpringApplication.Augmented} instance with additional
		 * sources that should be applied when the application runs.
		 * @param sources the sources that should be applied
		 * @return a new {@link SpringApplication.Augmented} instance
		 */
		public Augmented with(Class<?>... sources) {
			LinkedHashSet<Class<?>> merged = new LinkedHashSet<>(this.sources);
			merged.addAll(Arrays.asList(sources));
			return new Augmented(this.main, merged, this.additionalProfiles);
		}
		/**
		 * Return a new {@link SpringApplication.Augmented} instance with additional
		 * profiles that should be applied when the application runs.
		 * @param profiles the profiles that should be applied
		 * @return a new {@link SpringApplication.Augmented} instance
		 * @since 3.4.0
		 */
		public Augmented withAdditionalProfiles(String... profiles) {
			Set<String> merged = new LinkedHashSet<>(this.additionalProfiles);
			merged.addAll(Arrays.asList(profiles));
			return new Augmented(this.main, this.sources, merged);
		}
		/**
		 * Run the application using the given args.
		 * @param args the main method args
		 * @return the running {@link ApplicationContext}
		 */
		public SpringApplication.Running run(String... args) {
			RunListener runListener = new RunListener();
			SpringApplicationHook hook = new SingleUseSpringApplicationHook((springApplication) -> {
				springApplication.addPrimarySources(this.sources);
				springApplication.setAdditionalProfiles(this.additionalProfiles.toArray(String[]::new));
				return runListener;
			});
			withHook(hook, () -> this.main.accept(args));
			return runListener;
		}
		/**
		 * {@link SpringApplicationRunListener} to capture {@link Running} application
		 * details.
		 */
		private static final class RunListener implements SpringApplicationRunListener, Running {
			private final List<ConfigurableApplicationContext> contexts = Collections
				.synchronizedList(new ArrayList<>());
			@Override
			public void contextLoaded(ConfigurableApplicationContext context) {
				this.contexts.add(context);
			}
			@Override
			public ConfigurableApplicationContext getApplicationContext() {
				List<ConfigurableApplicationContext> rootContexts = this.contexts.stream()
					.filter((context) -> context.getParent() == null)
					.toList();
				Assert.state(!rootContexts.isEmpty(), 'No root application context located');
				Assert.state(rootContexts.size() == 1, 'No unique root application context located');
				return rootContexts.get(0);
			}
		}
	}
	/**
	 * Provides access to details of a {@link SpringApplication} run using
	 * {@link Augmented#run(String...)}.
	 *
	 * @since 3.1.0
	 */
	public interface Running {
		/**
		 * Return the root {@link ConfigurableApplicationContext} of the running
		 * application.
		 * @return the root application context
		 */
		ConfigurableApplicationContext getApplicationContext();
	}
	/**
	 * {@link BeanFactoryPostProcessor} to re-order our property sources below any
	 * {@code @PropertySource} items added by the {@link ConfigurationClassPostProcessor}.
	 */
	private static class PropertySourceOrderingBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {
		private final ConfigurableApplicationContext context;
		PropertySourceOrderingBeanFactoryPostProcessor(ConfigurableApplicationContext context) {
			this.context = context;
		}
		@Override
		public int getOrder() {
			return Ordered.HIGHEST_PRECEDENCE;
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
			DefaultPropertiesPropertySource.moveToEnd(this.context.getEnvironment());
		}
	}
	/**
	 * Exception that can be thrown to silently exit a running {@link SpringApplication}
	 * without handling run failures.
	 *
	 * @since 3.0.0
	 */
	public static class AbandonedRunException extends RuntimeException {
		private final ConfigurableApplicationContext applicationContext;
		/**
		 * Create a new {@link AbandonedRunException} instance.
		 */
		public AbandonedRunException() {
			this(null);
		}
		/**
		 * Create a new {@link AbandonedRunException} instance with the given application
		 * context.
		 * @param applicationContext the application context that was available when the
		 * run was abandoned
		 */
		public AbandonedRunException(ConfigurableApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		/**
		 * Return the application context that was available when the run was abandoned or
		 * {@code null} if no context was available.
		 * @return the application context
		 */
		public ConfigurableApplicationContext getApplicationContext() {
			return this.applicationContext;
		}
	}
	/**
	 * {@link SpringApplicationHook} decorator that ensures the hook is only used once.
	 */
	private static final class SingleUseSpringApplicationHook implements SpringApplicationHook {
		private final AtomicBoolean used = new AtomicBoolean();
		private final SpringApplicationHook delegate;
		private SingleUseSpringApplicationHook(SpringApplicationHook delegate) {
			this.delegate = delegate;
		}
		@Override
		public SpringApplicationRunListener getRunListener(SpringApplication springApplication) {
			return this.used.compareAndSet(false, true) ? this.delegate.getRunListener(springApplication) : null;
		}
	}
	/**
	 * Starts a non-daemon thread to keep the JVM alive on {@link ContextRefreshedEvent}.
	 * Stops the thread on {@link ContextClosedEvent}.
	 */
	private static final class KeepAlive implements ApplicationListener<ApplicationContextEvent> {
		private final AtomicReference<Thread> thread = new AtomicReference<>();
		@Override
		public void onApplicationEvent(ApplicationContextEvent event) {
			if (event instanceof ContextRefreshedEvent) {
				startKeepAliveThread();
			}
			else if (event instanceof ContextClosedEvent) {
				stopKeepAliveThread();
			}
		}
		private void startKeepAliveThread() {
			Thread thread = new Thread(() -> {
				while (true) {
					try {
						Thread.sleep(Long.MAX_VALUE);
					}
					catch (InterruptedException ex) {
						break;
					}
				}
			});
			if (this.thread.compareAndSet(null, thread)) {
				thread.setDaemon(false);
				thread.setName('keep-alive');
				thread.start();
			}
		}
		private void stopKeepAliveThread() {
			Thread thread = this.thread.getAndSet(null);
			if (thread == null) {
				return;
			}
			thread.interrupt();
		}
	}
	/**
	 * Strategy used to handle startup concerns.
	 */
	abstract static class Startup {
		private Duration timeTakenToStarted;
		protected abstract long startTime();
		protected abstract Long processUptime();
		protected abstract String action();
		final Duration started() {
			long now = System.currentTimeMillis();
			this.timeTakenToStarted = Duration.ofMillis(now - startTime());
			return this.timeTakenToStarted;
		}
		Duration timeTakenToStarted() {
			return this.timeTakenToStarted;
		}
		private Duration ready() {
			long now = System.currentTimeMillis();
			return Duration.ofMillis(now - startTime());
		}
		static Startup create() {
			ClassLoader classLoader = Startup.class.getClassLoader();
			return (ClassUtils.isPresent('jdk.crac.management.CRaCMXBean', classLoader)
					&& ClassUtils.isPresent('org.crac.management.CRaCMXBean', classLoader))
							? new CoordinatedRestoreAtCheckpointStartup() : new StandardStartup();
		}
	}
	/**
	 * Standard {@link Startup} implementation.
	 */
	private static final class StandardStartup extends Startup {
		private final Long startTime = System.currentTimeMillis();
		@Override
		protected long startTime() {
			return this.startTime;
		}
		@Override
		protected Long processUptime() {
			try {
				return ManagementFactory.getRuntimeMXBean().getUptime();
			}
			catch (Throwable ex) {
				return null;
			}
		}
		@Override
		protected String action() {
			return 'Started';
		}
	}
	/**
	 * Coordinated-Restore-At-Checkpoint {@link Startup} implementation.
	 */
	private static final class CoordinatedRestoreAtCheckpointStartup extends Startup {
		private final StandardStartup fallback = new StandardStartup();
		@Override
		protected Long processUptime() {
			long uptime = CRaCMXBean.getCRaCMXBean().getUptimeSinceRestore();
			return (uptime >= 0) ? uptime : this.fallback.processUptime();
		}
		@Override
		protected String action() {
			return (restoreTime() >= 0) ? 'Restored' : this.fallback.action();
		}
		private long restoreTime() {
			return CRaCMXBean.getCRaCMXBean().getRestoreTime();
		}
		@Override
		protected long startTime() {
			long restoreTime = restoreTime();
			return (restoreTime >= 0) ? restoreTime : this.fallback.startTime();
		}
	}
	/**
	 * {@link OrderSourceProvider} used to obtain factory method and target type order
	 * sources. Based on internal {@link DefaultListableBeanFactory} code.
	 */
	private class FactoryAwareOrderSourceProvider implements OrderSourceProvider {
		private final ConfigurableBeanFactory beanFactory;
		private final Map<?, String> instancesToBeanNames;
		FactoryAwareOrderSourceProvider(ConfigurableBeanFactory beanFactory, Map<?, String> instancesToBeanNames) {
			this.beanFactory = beanFactory;
			this.instancesToBeanNames = instancesToBeanNames;
		}
		@Override
		public Object getOrderSource(Object obj) {
			String beanName = this.instancesToBeanNames.get(obj);
			return (beanName != null) ? getOrderSource(beanName, obj.getClass()) : null;
		}
		private Object getOrderSource(String beanName, Class<?> instanceType) {
			try {
				RootBeanDefinition beanDefinition = (RootBeanDefinition) this.beanFactory
					.getMergedBeanDefinition(beanName);
				Method factoryMethod = beanDefinition.getResolvedFactoryMethod();
				Class<?> targetType = beanDefinition.getTargetType();
				targetType = (targetType != instanceType) ? targetType : null;
				return Stream.of(factoryMethod, targetType).filter(Objects::nonNull).toArray();
			}
			catch (NoSuchBeanDefinitionException ex) {
				return null;
			}
		}
	}
}
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface CommandLineRunner extends Runner {
	/**
	 * Callback used to run the bean.
	 * @param args incoming main method arguments
	 * @throws Exception on error
	 */
	void run(String... args) throws Exception;
}
/*
package org.springframework.boot;
/**
public class SpringApplicationAotProcessor extends ContextAotProcessor {
	private final String[] applicationArgs;
	/**
	 * Create a new processor for the specified application and settings.
	 * @param application the application main class
	 * @param settings the general AOT processor settings
	 * @param applicationArgs the arguments to provide to the main method
	 */
	public SpringApplicationAotProcessor(Class<?> application, Settings settings, String[] applicationArgs) {
		super(application, settings);
		this.applicationArgs = applicationArgs;
	}
	@Override
	protected GenericApplicationContext prepareApplicationContext(Class<?> application) {
		return new AotProcessorHook(application).run(() -> {
			Method mainMethod = application.getMethod('main', String[].class);
			return ReflectionUtils.invokeMethod(mainMethod, null, new Object[] { this.applicationArgs });
		});
	}
	public static void main(String[] args) throws Exception {
		int requiredArgs = 6;
		Assert.isTrue(args.length >= requiredArgs, () -> 'Usage: ' + SpringApplicationAotProcessor.class.getName()
				+ ' <applicationName> <sourceOutput> <resourceOutput> <classOutput> <groupId> <artifactId> <originalArgs...>');
		Class<?> application = Class.forName(args[0]);
		Settings settings = Settings.builder()
			.sourceOutput(Paths.get(args[1]))
			.resourceOutput(Paths.get(args[2]))
			.classOutput(Paths.get(args[3]))
			.groupId((StringUtils.hasText(args[4])) ? args[4] : 'unspecified')
			.artifactId(args[5])
			.build();
		String[] applicationArgs = (args.length > requiredArgs) ? Arrays.copyOfRange(args, requiredArgs, args.length)
				: new String[0];
		new SpringApplicationAotProcessor(application, settings, applicationArgs).process();
	}
	/**
	 * {@link SpringApplicationHook} used to capture the {@link ApplicationContext} and
	 * trigger early exit of main method.
	 */
	private static final class AotProcessorHook implements SpringApplicationHook {
		private final Class<?> application;
		private AotProcessorHook(Class<?> application) {
			this.application = application;
		}
		@Override
		public SpringApplicationRunListener getRunListener(SpringApplication application) {
			return new SpringApplicationRunListener() {
				@Override
				public void contextLoaded(ConfigurableApplicationContext context) {
					throw new AbandonedRunException(context);
				}
			};
		}
		private <T> GenericApplicationContext run(ThrowingSupplier<T> action) {
			try {
				SpringApplication.withHook(this, action);
			}
			catch (AbandonedRunException ex) {
				ApplicationContext context = ex.getApplicationContext();
				Assert.isInstanceOf(GenericApplicationContext.class, context,
						() -> 'AOT processing requires a GenericApplicationContext but got a '
								+ context.getClass().getName());
				return (GenericApplicationContext) context;
			}
			throw new IllegalStateException(
					'No application context available after calling main method of "%s". Does it run a SpringApplication?'
						.formatted(this.application.getName()));
		}
	}
}
/*
package org.springframework.boot.web.context;
/**
@Order(0)
class MissingWebServerFactoryBeanFailureAnalyzer extends AbstractFailureAnalyzer<MissingWebServerFactoryBeanException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, MissingWebServerFactoryBeanException cause) {
		return new FailureAnalysis(
				'Web application could not be started as there was no ' + cause.getBeanType().getName()
						+ ' bean defined in the context.',
				'Check your application"s dependencies for a supported '
						+ cause.getWebApplicationType().name().toLowerCase(Locale.ENGLISH) + ' web server.\n'
						+ 'Check the configured web application type.',
				cause);
	}
}
/*
package org.springframework.boot.web.context;
/**
public interface WebServerApplicationContext extends ApplicationContext {
	/**
	 * Returns the {@link WebServer} that was created by the context or {@code null} if
	 * the server has not yet been created.
	 * @return the web server
	 */
	WebServer getWebServer();
	/**
	 * Returns the namespace of the web server application context or {@code null} if no
	 * namespace has been set. Used for disambiguation when multiple web servers are
	 * running in the same application (for example a management context running on a
	 * different port).
	 * @return the server namespace
	 */
	String getServerNamespace();
	/**
	 * Returns {@code true} if the specified context is a
	 * {@link WebServerApplicationContext} with a matching server namespace.
	 * @param context the context to check
	 * @param serverNamespace the server namespace to match against
	 * @return {@code true} if the server namespace of the context matches
	 * @since 2.1.8
	 */
	static boolean hasServerNamespace(ApplicationContext context, String serverNamespace) {
		return (context instanceof WebServerApplicationContext webServerApplicationContext)
				&& ObjectUtils.nullSafeEquals(webServerApplicationContext.getServerNamespace(), serverNamespace);
	}
	/**
	 * Returns the server namespace if the specified context is a
	 * {@link WebServerApplicationContext}.
	 * @param context the context
	 * @return the server namespace or {@code null} if the context is not a
	 * {@link WebServerApplicationContext}
	 * @since 2.6.0
	 */
	static String getServerNamespace(ApplicationContext context) {
		return (context instanceof WebServerApplicationContext configurableContext)
				? configurableContext.getServerNamespace() : null;
	}
}
/*
package org.springframework.boot.web.context;
/**
public class WebServerPortFileWriter implements ApplicationListener<WebServerInitializedEvent> {
	private static final String DEFAULT_FILE_NAME = 'application.port';
	private static final String[] PROPERTY_VARIABLES = { 'PORTFILE', 'portfile' };
	private static final Log logger = LogFactory.getLog(WebServerPortFileWriter.class);
	private final File file;
	/**
	 * Create a new {@link WebServerPortFileWriter} instance using the filename
	 * "application.port".
	 */
	public WebServerPortFileWriter() {
		this(new File(DEFAULT_FILE_NAME));
	}
	/**
	 * Create a new {@link WebServerPortFileWriter} instance with a specified filename.
	 * @param filename the name of file containing port
	 */
	public WebServerPortFileWriter(String filename) {
		this(new File(filename));
	}
	/**
	 * Create a new {@link WebServerPortFileWriter} instance with a specified file.
	 * @param file the file containing port
	 */
	public WebServerPortFileWriter(File file) {
		Assert.notNull(file, 'File must not be null');
		String override = SystemProperties.get(PROPERTY_VARIABLES);
		if (override != null) {
			this.file = new File(override);
		}
		else {
			this.file = file;
		}
	}
	@Override
	public void onApplicationEvent(WebServerInitializedEvent event) {
		File portFile = getPortFile(event.getApplicationContext());
		try {
			String port = String.valueOf(event.getWebServer().getPort());
			createParentDirectory(portFile);
			FileCopyUtils.copy(port.getBytes(), portFile);
			portFile.deleteOnExit();
		}
		catch (Exception ex) {
			logger.warn(LogMessage.format('Cannot create port file %s', this.file));
		}
	}
	/**
	 * Return the actual port file that should be written for the given application
	 * context. The default implementation builds a file from the source file and the
	 * application context namespace if available.
	 * @param applicationContext the source application context
	 * @return the file that should be written
	 */
	protected File getPortFile(ApplicationContext applicationContext) {
		String namespace = getServerNamespace(applicationContext);
		if (!StringUtils.hasLength(namespace)) {
			return this.file;
		}
		String filename = this.file.getName();
		String extension = StringUtils.getFilenameExtension(filename);
		String filenameWithoutExtension = filename.substring(0, filename.length() - extension.length() - 1);
		String suffix = (!isUpperCase(filename)) ? namespace.toLowerCase(Locale.ENGLISH)
				: namespace.toUpperCase(Locale.ENGLISH);
		return new File(this.file.getParentFile(),
				filenameWithoutExtension + '-' + suffix + ((!StringUtils.hasLength(extension)) ? '' : '.' + extension));
	}
	private String getServerNamespace(ApplicationContext applicationContext) {
		if (applicationContext instanceof WebServerApplicationContext webServerApplicationContext) {
			return webServerApplicationContext.getServerNamespace();
		}
		return null;
	}
	private boolean isUpperCase(String name) {
		for (int i = 0; i < name.length(); i++) {
			if (Character.isLetter(name.charAt(i)) && !Character.isUpperCase(name.charAt(i))) {
				return false;
			}
		}
		return true;
	}
	private void createParentDirectory(File file) {
		File parent = file.getParentFile();
		if (parent != null) {
			parent.mkdirs();
		}
	}
}
/*
package org.springframework.boot.web.context;
/**
public class MissingWebServerFactoryBeanException extends NoSuchBeanDefinitionException {
	private final WebApplicationType webApplicationType;
	/**
	 * Create a new {@code MissingWebServerFactoryBeanException}.
	 * @param webServerApplicationContextClass the class of the
	 * WebServerApplicationContext that required the WebServerFactory
	 * @param webServerFactoryClass the class of the WebServerFactory that was missing
	 * @param webApplicationType the type of the web application
	 */
	public MissingWebServerFactoryBeanException(
			Class<? extends WebServerApplicationContext> webServerApplicationContextClass,
			Class<? extends WebServerFactory> webServerFactoryClass, WebApplicationType webApplicationType) {
		super(webServerFactoryClass, String.format('Unable to start %s due to missing %s bean',
				webServerApplicationContextClass.getSimpleName(), webServerFactoryClass.getSimpleName()));
		this.webApplicationType = webApplicationType;
	}
	/**
	 * Returns the type of web application for which a {@link WebServerFactory} bean was
	 * missing.
	 * @return the type of web application
	 */
	public WebApplicationType getWebApplicationType() {
		return this.webApplicationType;
	}
}
/*
/**
package org.springframework.boot.web.context;
/*
package org.springframework.boot.web.context;
/**
public final class WebServerGracefulShutdownLifecycle implements SmartLifecycle {
	/**
	 * {@link SmartLifecycle#getPhase() SmartLifecycle phase} in which graceful shutdown
	 * of the web server is performed.
	 */
	public static final int SMART_LIFECYCLE_PHASE = SmartLifecycle.DEFAULT_PHASE - 1024;
	private final WebServer webServer;
	private volatile boolean running;
	/**
	 * Creates a new {@code WebServerGracefulShutdownLifecycle} that will gracefully shut
	 * down the given {@code webServer}.
	 * @param webServer web server to shut down gracefully
	 */
	public WebServerGracefulShutdownLifecycle(WebServer webServer) {
		this.webServer = webServer;
	}
	@Override
	public void start() {
		this.running = true;
	}
	@Override
	public void stop() {
		throw new UnsupportedOperationException('Stop must not be invoked directly');
	}
	@Override
	public void stop(Runnable callback) {
		this.running = false;
		this.webServer.shutDownGracefully((result) -> callback.run());
	}
	@Override
	public boolean isRunning() {
		return this.running;
	}
	@Override
	public int getPhase() {
		return SMART_LIFECYCLE_PHASE;
	}
}
/*
package org.springframework.boot.web.context;
/**
@SuppressWarnings('serial')
public abstract class WebServerInitializedEvent extends ApplicationEvent {
	protected WebServerInitializedEvent(WebServer webServer) {
		super(webServer);
	}
	/**
	 * Access the {@link WebServer}.
	 * @return the embedded web server
	 */
	public WebServer getWebServer() {
		return getSource();
	}
	/**
	 * Access the application context that the server was created in. Sometimes it is
	 * prudent to check that this matches expectations (like being equal to the current
	 * context) before acting on the server itself.
	 * @return the applicationContext that the server was created from
	 */
	public abstract WebServerApplicationContext getApplicationContext();
	/**
	 * Access the source of the event (an {@link WebServer}).
	 * @return the embedded web server
	 */
	@Override
	public WebServer getSource() {
		return (WebServer) super.getSource();
	}
}
/*
package org.springframework.boot.web.context;
/**
public class ServerPortInfoApplicationContextInitializer implements
		ApplicationContextInitializer<ConfigurableApplicationContext>, ApplicationListener<WebServerInitializedEvent> {
	private static final String PROPERTY_SOURCE_NAME = 'server.ports';
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		applicationContext.addApplicationListener(this);
	}
	@Override
	public void onApplicationEvent(WebServerInitializedEvent event) {
		String propertyName = 'local.' + getName(event.getApplicationContext()) + '.port';
		setPortProperty(event.getApplicationContext(), propertyName, event.getWebServer().getPort());
	}
	private String getName(WebServerApplicationContext context) {
		String name = context.getServerNamespace();
		return StringUtils.hasText(name) ? name : 'server';
	}
	private void setPortProperty(ApplicationContext context, String propertyName, int port) {
		if (context instanceof ConfigurableApplicationContext configurableContext) {
			setPortProperty(configurableContext.getEnvironment(), propertyName, port);
		}
		if (context.getParent() != null) {
			setPortProperty(context.getParent(), propertyName, port);
		}
	}
	@SuppressWarnings('unchecked')
	private void setPortProperty(ConfigurableEnvironment environment, String propertyName, int port) {
		MutablePropertySources sources = environment.getPropertySources();
		PropertySource<?> source = sources.get(PROPERTY_SOURCE_NAME);
		if (source == null) {
			source = new MapPropertySource(PROPERTY_SOURCE_NAME, new HashMap<>());
			sources.addFirst(source);
		}
		((Map<String, Object>) source.getSource()).put(propertyName, port);
	}
}
/*
package org.springframework.boot.web.context;
/**
public interface ConfigurableWebServerApplicationContext
		extends ConfigurableApplicationContext, WebServerApplicationContext {
	/**
	 * Set the server namespace of the context.
	 * @param serverNamespace the server namespace
	 * @see #getServerNamespace()
	 */
	void setServerNamespace(String serverNamespace);
}
/*
package org.springframework.boot.web.codec;
/**
@FunctionalInterface
public interface CodecCustomizer {
	/**
	 * Callback to customize a {@link CodecConfigurer} instance.
	 * @param configurer codec configurer to customize
	 */
	void customize(CodecConfigurer configurer);
}
/*
/**
package org.springframework.boot.web.codec;
/*
package org.springframework.boot.web.embedded.undertow;
/**
class CompositeResourceManager implements ResourceManager {
	private final List<ResourceManager> resourceManagers;
	CompositeResourceManager(ResourceManager... resourceManagers) {
		this.resourceManagers = Arrays.asList(resourceManagers);
	}
	@Override
	public void close() throws IOException {
		for (ResourceManager resourceManager : this.resourceManagers) {
			resourceManager.close();
		}
	}
	@Override
	public Resource getResource(String path) throws IOException {
		for (ResourceManager resourceManager : this.resourceManagers) {
			Resource resource = resourceManager.getResource(path);
			if (resource != null) {
				return resource;
			}
		}
		return null;
	}
	@Override
	public boolean isResourceChangeListenerSupported() {
		return false;
	}
	@Override
	public void registerResourceChangeListener(ResourceChangeListener listener) {
		throw UndertowMessages.MESSAGES.resourceChangeListenerNotSupported();
	}
	@Override
	public void removeResourceChangeListener(ResourceChangeListener listener) {
		throw UndertowMessages.MESSAGES.resourceChangeListenerNotSupported();
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class FileSessionPersistence implements SessionPersistenceManager {
	private final File dir;
	FileSessionPersistence(File dir) {
		this.dir = dir;
	}
	@Override
	public void persistSessions(String deploymentName, Map<String, PersistentSession> sessionData) {
		try {
			save(sessionData, getSessionFile(deploymentName));
		}
		catch (Exception ex) {
			UndertowServletLogger.ROOT_LOGGER.failedToPersistSessions(ex);
		}
	}
	private void save(Map<String, PersistentSession> sessionData, File file) throws IOException {
		try (ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(file))) {
			save(sessionData, stream);
		}
	}
	private void save(Map<String, PersistentSession> sessionData, ObjectOutputStream stream) throws IOException {
		Map<String, Serializable> session = new LinkedHashMap<>();
		sessionData.forEach((key, value) -> session.put(key, new SerializablePersistentSession(value)));
		stream.writeObject(session);
	}
	@Override
	public Map<String, PersistentSession> loadSessionAttributes(String deploymentName, final ClassLoader classLoader) {
		try {
			File file = getSessionFile(deploymentName);
			if (file.exists()) {
				return load(file, classLoader);
			}
		}
		catch (Exception ex) {
			UndertowServletLogger.ROOT_LOGGER.failedtoLoadPersistentSessions(ex);
		}
		return null;
	}
	private Map<String, PersistentSession> load(File file, ClassLoader classLoader)
			throws IOException, ClassNotFoundException {
		try (ObjectInputStream stream = new ConfigurableObjectInputStream(new FileInputStream(file), classLoader)) {
			return load(stream);
		}
	}
	private Map<String, PersistentSession> load(ObjectInputStream stream) throws ClassNotFoundException, IOException {
		Map<String, SerializablePersistentSession> session = readSession(stream);
		long time = System.currentTimeMillis();
		Map<String, PersistentSession> result = new LinkedHashMap<>();
		session.forEach((key, value) -> {
			PersistentSession entrySession = value.getPersistentSession();
			if (entrySession.getExpiration().getTime() > time) {
				result.put(key, entrySession);
			}
		});
		return result;
	}
	@SuppressWarnings('unchecked')
	private Map<String, SerializablePersistentSession> readSession(ObjectInputStream stream)
			throws ClassNotFoundException, IOException {
		return ((Map<String, SerializablePersistentSession>) stream.readObject());
	}
	private File getSessionFile(String deploymentName) {
		if (!this.dir.exists()) {
			this.dir.mkdirs();
		}
		return new File(this.dir, deploymentName + '.session');
	}
	@Override
	public void clear(String deploymentName) {
		getSessionFile(deploymentName).delete();
	}
	/**
	 * Session data in a serializable form.
	 */
	static class SerializablePersistentSession implements Serializable {
		private static final long serialVersionUID = 0L;
		private final Date expiration;
		private final Map<String, Object> sessionData;
		SerializablePersistentSession(PersistentSession session) {
			this.expiration = session.getExpiration();
			this.sessionData = new LinkedHashMap<>(session.getSessionData());
		}
		PersistentSession getPersistentSession() {
			return new PersistentSession(this.expiration, this.sessionData);
		}
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
@FunctionalInterface
public interface UndertowBuilderCustomizer {
	/**
	 * Customize the builder.
	 * @param builder the {@code Builder} to customize
	 */
	void customize(Builder builder);
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
public interface ConfigurableUndertowWebServerFactory extends ConfigurableWebServerFactory {
	/**
	 * Set {@link UndertowBuilderCustomizer}s that should be applied to the Undertow
	 * {@link Builder}. Calling this method will replace any existing customizers.
	 * @param customizers the customizers to set
	 * @since 2.3.0
	 */
	void setBuilderCustomizers(Collection<? extends UndertowBuilderCustomizer> customizers);
	/**
	 * Add {@link UndertowBuilderCustomizer}s that should be used to customize the
	 * Undertow {@link Builder}.
	 * @param customizers the customizers to add
	 */
	void addBuilderCustomizers(UndertowBuilderCustomizer... customizers);
	/**
	 * Set the buffer size.
	 * @param bufferSize buffer size
	 */
	void setBufferSize(Integer bufferSize);
	/**
	 * Set the number of IO Threads.
	 * @param ioThreads number of IO Threads
	 */
	void setIoThreads(Integer ioThreads);
	/**
	 * Set the number of Worker Threads.
	 * @param workerThreads number of Worker Threads
	 */
	void setWorkerThreads(Integer workerThreads);
	/**
	 * Set whether direct buffers should be used.
	 * @param useDirectBuffers whether direct buffers should be used
	 */
	void setUseDirectBuffers(Boolean useDirectBuffers);
	/**
	 * Set the access log directory.
	 * @param accessLogDirectory access log directory
	 */
	void setAccessLogDirectory(File accessLogDirectory);
	/**
	 * Set the access log pattern.
	 * @param accessLogPattern access log pattern
	 */
	void setAccessLogPattern(String accessLogPattern);
	/**
	 * Set the access log prefix.
	 * @param accessLogPrefix log prefix
	 */
	void setAccessLogPrefix(String accessLogPrefix);
	/**
	 * Set the access log suffix.
	 * @param accessLogSuffix access log suffix
	 */
	void setAccessLogSuffix(String accessLogSuffix);
	/**
	 * Set whether access logs are enabled.
	 * @param accessLogEnabled whether access logs are enabled
	 */
	void setAccessLogEnabled(boolean accessLogEnabled);
	/**
	 * Set whether access logs rotation is enabled.
	 * @param accessLogRotate whether access logs rotation is enabled
	 */
	void setAccessLogRotate(boolean accessLogRotate);
	/**
	 * Set if x-forward-* headers should be processed.
	 * @param useForwardHeaders if x-forward headers should be used
	 */
	void setUseForwardHeaders(boolean useForwardHeaders);
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class AccessLogHttpHandlerFactory implements HttpHandlerFactory {
	private final File directory;
	private final String pattern;
	private final String prefix;
	private final String suffix;
	private final boolean rotate;
	AccessLogHttpHandlerFactory(File directory, String pattern, String prefix, String suffix, boolean rotate) {
		this.directory = directory;
		this.pattern = pattern;
		this.prefix = prefix;
		this.suffix = suffix;
		this.rotate = rotate;
	}
	@Override
	public HttpHandler getHandler(HttpHandler next) {
		try {
			createAccessLogDirectoryIfNecessary();
			XnioWorker worker = createWorker();
			String baseName = (this.prefix != null) ? this.prefix : 'access_log.';
			String formatString = (this.pattern != null) ? this.pattern : 'common';
			return new ClosableAccessLogHandler(next, worker,
					new DefaultAccessLogReceiver(worker, this.directory, baseName, this.suffix, this.rotate),
					formatString);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to create AccessLogHandler', ex);
		}
	}
	private void createAccessLogDirectoryIfNecessary() {
		Assert.state(this.directory != null, 'Access log directory is not set');
		if (!this.directory.isDirectory() && !this.directory.mkdirs()) {
			throw new IllegalStateException('Failed to create access log directory "' + this.directory + '"');
		}
	}
	private XnioWorker createWorker() throws IOException {
		Xnio xnio = Xnio.getInstance(Undertow.class.getClassLoader());
		return xnio.createWorker(OptionMap.builder().set(Options.THREAD_DAEMON, true).getMap());
	}
	/**
	 * {@link Closeable} variant of {@link AccessLogHandler}.
	 */
	private static class ClosableAccessLogHandler extends AccessLogHandler implements Closeable {
		private final DefaultAccessLogReceiver accessLogReceiver;
		private final XnioWorker worker;
		ClosableAccessLogHandler(HttpHandler next, XnioWorker worker, DefaultAccessLogReceiver accessLogReceiver,
				String formatString) {
			super(next, accessLogReceiver, formatString, Undertow.class.getClassLoader());
			this.worker = worker;
			this.accessLogReceiver = accessLogReceiver;
		}
		@Override
		public void close() throws IOException {
			try {
				this.accessLogReceiver.close();
				this.worker.shutdown();
				this.worker.awaitTermination(30, TimeUnit.SECONDS);
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
public class UndertowReactiveWebServerFactory extends AbstractReactiveWebServerFactory
		implements ConfigurableUndertowWebServerFactory {
	private final UndertowWebServerFactoryDelegate delegate = new UndertowWebServerFactoryDelegate();
	/**
	 * Create a new {@link UndertowReactiveWebServerFactory} instance.
	 */
	public UndertowReactiveWebServerFactory() {
	}
	/**
	 * Create a new {@link UndertowReactiveWebServerFactory} that listens for requests
	 * using the specified port.
	 * @param port the port to listen on
	 */
	public UndertowReactiveWebServerFactory(int port) {
		super(port);
	}
	@Override
	public void setBuilderCustomizers(Collection<? extends UndertowBuilderCustomizer> customizers) {
		this.delegate.setBuilderCustomizers(customizers);
	}
	@Override
	public void addBuilderCustomizers(UndertowBuilderCustomizer... customizers) {
		this.delegate.addBuilderCustomizers(customizers);
	}
	/**
	 * Returns a mutable collection of the {@link UndertowBuilderCustomizer}s that will be
	 * applied to the Undertow {@link io.undertow.Undertow.Builder Builder}.
	 * @return the customizers that will be applied
	 */
	public Collection<UndertowBuilderCustomizer> getBuilderCustomizers() {
		return this.delegate.getBuilderCustomizers();
	}
	@Override
	public void setBufferSize(Integer bufferSize) {
		this.delegate.setBufferSize(bufferSize);
	}
	@Override
	public void setIoThreads(Integer ioThreads) {
		this.delegate.setIoThreads(ioThreads);
	}
	@Override
	public void setWorkerThreads(Integer workerThreads) {
		this.delegate.setWorkerThreads(workerThreads);
	}
	@Override
	public void setUseDirectBuffers(Boolean directBuffers) {
		this.delegate.setUseDirectBuffers(directBuffers);
	}
	@Override
	public void setUseForwardHeaders(boolean useForwardHeaders) {
		this.delegate.setUseForwardHeaders(useForwardHeaders);
	}
	protected final boolean isUseForwardHeaders() {
		return this.delegate.isUseForwardHeaders();
	}
	@Override
	public void setAccessLogDirectory(File accessLogDirectory) {
		this.delegate.setAccessLogDirectory(accessLogDirectory);
	}
	@Override
	public void setAccessLogPattern(String accessLogPattern) {
		this.delegate.setAccessLogPattern(accessLogPattern);
	}
	@Override
	public void setAccessLogPrefix(String accessLogPrefix) {
		this.delegate.setAccessLogPrefix(accessLogPrefix);
	}
	@Override
	public void setAccessLogSuffix(String accessLogSuffix) {
		this.delegate.setAccessLogSuffix(accessLogSuffix);
	}
	public boolean isAccessLogEnabled() {
		return this.delegate.isAccessLogEnabled();
	}
	@Override
	public void setAccessLogEnabled(boolean accessLogEnabled) {
		this.delegate.setAccessLogEnabled(accessLogEnabled);
	}
	@Override
	public void setAccessLogRotate(boolean accessLogRotate) {
		this.delegate.setAccessLogRotate(accessLogRotate);
	}
	@Override
	public WebServer getWebServer(org.springframework.http.server.reactive.HttpHandler httpHandler) {
		Undertow.Builder builder = this.delegate.createBuilder(this, this::getSslBundle, this::getServerNameSslBundles);
		List<HttpHandlerFactory> httpHandlerFactories = this.delegate.createHttpHandlerFactories(this,
				(next) -> new UndertowHttpHandlerAdapter(httpHandler));
		return new UndertowWebServer(builder, httpHandlerFactories, getPort() >= 0);
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
@FunctionalInterface
public interface UndertowDeploymentInfoCustomizer {
	/**
	 * Customize the deployment info.
	 * @param deploymentInfo the {@code DeploymentInfo} to customize
	 */
	void customize(DeploymentInfo deploymentInfo);
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class DeploymentManagerHttpHandlerFactory implements HttpHandlerFactory {
	private final DeploymentManager deploymentManager;
	DeploymentManagerHttpHandlerFactory(DeploymentManager deploymentManager) {
		this.deploymentManager = deploymentManager;
	}
	@Override
	public HttpHandler getHandler(HttpHandler next) {
		Assert.state(next == null, 'DeploymentManagerHttpHandlerFactory must be first');
		return new DeploymentManagerHandler(this.deploymentManager);
	}
	DeploymentManager getDeploymentManager() {
		return this.deploymentManager;
	}
	/**
	 * {@link HttpHandler} that delegates to a {@link DeploymentManager}.
	 */
	static class DeploymentManagerHandler implements HttpHandler, Closeable {
		private final DeploymentManager deploymentManager;
		private final HttpHandler handler;
		DeploymentManagerHandler(DeploymentManager deploymentManager) {
			this.deploymentManager = deploymentManager;
			try {
				this.handler = deploymentManager.start();
			}
			catch (ServletException ex) {
				throw new RuntimeException(ex);
			}
		}
		@Override
		public void handleRequest(HttpServerExchange exchange) throws Exception {
			this.handler.handleRequest(exchange);
		}
		@Override
		public void close() throws IOException {
			try {
				this.deploymentManager.stop();
				this.deploymentManager.undeploy();
			}
			catch (ServletException ex) {
				throw new RuntimeException(ex);
			}
		}
		DeploymentManager getDeploymentManager() {
			return this.deploymentManager;
		}
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class SslBuilderCustomizer implements UndertowBuilderCustomizer {
	private final int port;
	private final InetAddress address;
	private final ClientAuth clientAuth;
	private final SslBundle sslBundle;
	private final Map<String, SslBundle> serverNameSslBundles;
	SslBuilderCustomizer(int port, InetAddress address, ClientAuth clientAuth, SslBundle sslBundle,
			Map<String, SslBundle> serverNameSslBundles) {
		this.port = port;
		this.address = address;
		this.clientAuth = clientAuth;
		this.sslBundle = sslBundle;
		this.serverNameSslBundles = serverNameSslBundles;
	}
	@Override
	public void customize(Undertow.Builder builder) {
		SslOptions options = this.sslBundle.getOptions();
		builder.addHttpsListener(this.port, getListenAddress(), createSslContext());
		builder.setSocketOption(Options.SSL_CLIENT_AUTH_MODE, ClientAuth.map(this.clientAuth,
				SslClientAuthMode.NOT_REQUESTED, SslClientAuthMode.REQUESTED, SslClientAuthMode.REQUIRED));
		if (options.getEnabledProtocols() != null) {
			builder.setSocketOption(Options.SSL_ENABLED_PROTOCOLS, Sequence.of(options.getEnabledProtocols()));
		}
		if (options.getCiphers() != null) {
			builder.setSocketOption(Options.SSL_ENABLED_CIPHER_SUITES, Sequence.of(options.getCiphers()));
		}
	}
	private SSLContext createSslContext() {
		SNIContextMatcher.Builder builder = new SNIContextMatcher.Builder();
		builder.setDefaultContext(this.sslBundle.createSslContext());
		this.serverNameSslBundles
			.forEach((serverName, sslBundle) -> builder.addMatch(serverName, sslBundle.createSslContext()));
		return new SNISSLContext(builder.build());
	}
	private String getListenAddress() {
		if (this.address == null) {
			return '0.0.0.0';
		}
		return this.address.getHostAddress();
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
public class UndertowServletWebServerFactory extends AbstractServletWebServerFactory
		implements ConfigurableUndertowWebServerFactory, ResourceLoaderAware {
	private static final Pattern ENCODED_SLASH = Pattern.compile('%2F', Pattern.LITERAL);
	private static final Set<Class<?>> NO_CLASSES = Collections.emptySet();
	private final UndertowWebServerFactoryDelegate delegate = new UndertowWebServerFactoryDelegate();
	private Set<UndertowDeploymentInfoCustomizer> deploymentInfoCustomizers = new LinkedHashSet<>();
	private ResourceLoader resourceLoader;
	private boolean eagerFilterInit = true;
	private boolean preservePathOnForward = false;
	/**
	 * Create a new {@link UndertowServletWebServerFactory} instance.
	 */
	public UndertowServletWebServerFactory() {
		getJsp().setRegistered(false);
	}
	/**
	 * Create a new {@link UndertowServletWebServerFactory} that listens for requests
	 * using the specified port.
	 * @param port the port to listen on
	 */
	public UndertowServletWebServerFactory(int port) {
		super(port);
		getJsp().setRegistered(false);
	}
	/**
	 * Create a new {@link UndertowServletWebServerFactory} with the specified context
	 * path and port.
	 * @param contextPath the root context path
	 * @param port the port to listen on
	 */
	public UndertowServletWebServerFactory(String contextPath, int port) {
		super(contextPath, port);
		getJsp().setRegistered(false);
	}
	@Override
	public void setBuilderCustomizers(Collection<? extends UndertowBuilderCustomizer> customizers) {
		this.delegate.setBuilderCustomizers(customizers);
	}
	@Override
	public void addBuilderCustomizers(UndertowBuilderCustomizer... customizers) {
		this.delegate.addBuilderCustomizers(customizers);
	}
	/**
	 * Returns a mutable collection of the {@link UndertowBuilderCustomizer}s that will be
	 * applied to the Undertow {@link Builder}.
	 * @return the customizers that will be applied
	 */
	public Collection<UndertowBuilderCustomizer> getBuilderCustomizers() {
		return this.delegate.getBuilderCustomizers();
	}
	@Override
	public void setBufferSize(Integer bufferSize) {
		this.delegate.setBufferSize(bufferSize);
	}
	@Override
	public void setIoThreads(Integer ioThreads) {
		this.delegate.setIoThreads(ioThreads);
	}
	@Override
	public void setWorkerThreads(Integer workerThreads) {
		this.delegate.setWorkerThreads(workerThreads);
	}
	@Override
	public void setUseDirectBuffers(Boolean directBuffers) {
		this.delegate.setUseDirectBuffers(directBuffers);
	}
	@Override
	public void setAccessLogDirectory(File accessLogDirectory) {
		this.delegate.setAccessLogDirectory(accessLogDirectory);
	}
	@Override
	public void setAccessLogPattern(String accessLogPattern) {
		this.delegate.setAccessLogPattern(accessLogPattern);
	}
	@Override
	public void setAccessLogPrefix(String accessLogPrefix) {
		this.delegate.setAccessLogPrefix(accessLogPrefix);
	}
	public String getAccessLogPrefix() {
		return this.delegate.getAccessLogPrefix();
	}
	@Override
	public void setAccessLogSuffix(String accessLogSuffix) {
		this.delegate.setAccessLogSuffix(accessLogSuffix);
	}
	@Override
	public void setAccessLogEnabled(boolean accessLogEnabled) {
		this.delegate.setAccessLogEnabled(accessLogEnabled);
	}
	public boolean isAccessLogEnabled() {
		return this.delegate.isAccessLogEnabled();
	}
	@Override
	public void setAccessLogRotate(boolean accessLogRotate) {
		this.delegate.setAccessLogRotate(accessLogRotate);
	}
	@Override
	public void setUseForwardHeaders(boolean useForwardHeaders) {
		this.delegate.setUseForwardHeaders(useForwardHeaders);
	}
	protected final boolean isUseForwardHeaders() {
		return this.delegate.isUseForwardHeaders();
	}
	/**
	 * Set {@link UndertowDeploymentInfoCustomizer}s that should be applied to the
	 * Undertow {@link DeploymentInfo}. Calling this method will replace any existing
	 * customizers.
	 * @param customizers the customizers to set
	 */
	public void setDeploymentInfoCustomizers(Collection<? extends UndertowDeploymentInfoCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.deploymentInfoCustomizers = new LinkedHashSet<>(customizers);
	}
	/**
	 * Add {@link UndertowDeploymentInfoCustomizer}s that should be used to customize the
	 * Undertow {@link DeploymentInfo}.
	 * @param customizers the customizers to add
	 */
	public void addDeploymentInfoCustomizers(UndertowDeploymentInfoCustomizer... customizers) {
		Assert.notNull(customizers, 'UndertowDeploymentInfoCustomizers must not be null');
		this.deploymentInfoCustomizers.addAll(Arrays.asList(customizers));
	}
	/**
	 * Returns a mutable collection of the {@link UndertowDeploymentInfoCustomizer}s that
	 * will be applied to the Undertow {@link DeploymentInfo}.
	 * @return the customizers that will be applied
	 */
	public Collection<UndertowDeploymentInfoCustomizer> getDeploymentInfoCustomizers() {
		return this.deploymentInfoCustomizers;
	}
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	/**
	 * Return if filters should be eagerly initialized.
	 * @return {@code true} if filters are eagerly initialized, otherwise {@code false}.
	 * @since 2.4.0
	 */
	public boolean isEagerFilterInit() {
		return this.eagerFilterInit;
	}
	/**
	 * Set whether filters should be eagerly initialized.
	 * @param eagerFilterInit {@code true} if filters are eagerly initialized, otherwise
	 * {@code false}.
	 * @since 2.4.0
	 */
	public void setEagerFilterInit(boolean eagerFilterInit) {
		this.eagerFilterInit = eagerFilterInit;
	}
	/**
	 * Return whether the request path should be preserved on forward.
	 * @return {@code true} if the path should be preserved when a request is forwarded,
	 * otherwise {@code false}.
	 * @since 2.4.0
	 */
	public boolean isPreservePathOnForward() {
		return this.preservePathOnForward;
	}
	/**
	 * Set whether the request path should be preserved on forward.
	 * @param preservePathOnForward {@code true} if the path should be preserved when a
	 * request is forwarded, otherwise {@code false}.
	 * @since 2.4.0
	 */
	public void setPreservePathOnForward(boolean preservePathOnForward) {
		this.preservePathOnForward = preservePathOnForward;
	}
	@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		Builder builder = this.delegate.createBuilder(this, this::getSslBundle, this::getServerNameSslBundles);
		DeploymentManager manager = createManager(initializers);
		return getUndertowWebServer(builder, manager, getPort());
	}
	private DeploymentManager createManager(ServletContextInitializer... initializers) {
		DeploymentInfo deployment = Servlets.deployment();
		registerServletContainerInitializerToDriveServletContextInitializers(deployment, initializers);
		deployment.setClassLoader(getServletClassLoader());
		deployment.setContextPath(getContextPath());
		deployment.setDisplayName(getDisplayName());
		deployment.setDeploymentName('spring-boot');
		if (isRegisterDefaultServlet()) {
			deployment.addServlet(Servlets.servlet('default', DefaultServlet.class));
		}
		configureErrorPages(deployment);
		deployment.setServletStackTraces(ServletStackTraces.NONE);
		deployment.setResourceManager(getDocumentRootResourceManager());
		deployment.setTempDir(createTempDir('undertow'));
		deployment.setEagerFilterInit(this.eagerFilterInit);
		deployment.setPreservePathOnForward(this.preservePathOnForward);
		configureMimeMappings(deployment);
		configureWebListeners(deployment);
		for (UndertowDeploymentInfoCustomizer customizer : this.deploymentInfoCustomizers) {
			customizer.customize(deployment);
		}
		if (getSession().isPersistent()) {
			File dir = getValidSessionStoreDir();
			deployment.setSessionPersistenceManager(new FileSessionPersistence(dir));
		}
		addLocaleMappings(deployment);
		DeploymentManager manager = Servlets.newContainer().addDeployment(deployment);
		manager.deploy();
		if (manager.getDeployment() instanceof DeploymentImpl managerDeployment) {
			removeSuperfluousMimeMappings(managerDeployment, deployment);
		}
		SessionManager sessionManager = manager.getDeployment().getSessionManager();
		Duration timeoutDuration = getSession().getTimeout();
		int sessionTimeout = (isZeroOrLess(timeoutDuration) ? -1 : (int) timeoutDuration.getSeconds());
		sessionManager.setDefaultSessionTimeout(sessionTimeout);
		return manager;
	}
	private void configureWebListeners(DeploymentInfo deployment) {
		for (String className : getWebListenerClassNames()) {
			try {
				deployment.addListener(new ListenerInfo(loadWebListenerClass(className)));
			}
			catch (ClassNotFoundException ex) {
				throw new IllegalStateException('Failed to load web listener class "' + className + '"', ex);
			}
		}
	}
	@SuppressWarnings('unchecked')
	private Class<? extends EventListener> loadWebListenerClass(String className) throws ClassNotFoundException {
		return (Class<? extends EventListener>) getServletClassLoader().loadClass(className);
	}
	private boolean isZeroOrLess(Duration timeoutDuration) {
		return timeoutDuration == null || timeoutDuration.isZero() || timeoutDuration.isNegative();
	}
	private void addLocaleMappings(DeploymentInfo deployment) {
		getLocaleCharsetMappings()
			.forEach((locale, charset) -> deployment.addLocaleCharsetMapping(locale.toString(), charset.toString()));
	}
	private void registerServletContainerInitializerToDriveServletContextInitializers(DeploymentInfo deployment,
			ServletContextInitializer... initializers) {
		ServletContextInitializer[] mergedInitializers = mergeInitializers(initializers);
		Initializer initializer = new Initializer(mergedInitializers);
		deployment.addServletContainerInitializer(new ServletContainerInitializerInfo(Initializer.class,
				new ImmediateInstanceFactory<ServletContainerInitializer>(initializer), NO_CLASSES));
	}
	private ClassLoader getServletClassLoader() {
		if (this.resourceLoader != null) {
			return this.resourceLoader.getClassLoader();
		}
		return getClass().getClassLoader();
	}
	private ResourceManager getDocumentRootResourceManager() {
		File root = getValidDocumentRoot();
		File docBase = getCanonicalDocumentRoot(root);
		List<URL> metaInfResourceUrls = getUrlsOfJarsWithMetaInfResources();
		List<URL> resourceJarUrls = new ArrayList<>();
		List<ResourceManager> managers = new ArrayList<>();
		ResourceManager rootManager = (docBase.isDirectory() ? new FileResourceManager(docBase, 0)
				: new JarResourceManager(docBase));
		if (root != null) {
			rootManager = new LoaderHidingResourceManager(rootManager);
		}
		managers.add(rootManager);
		for (URL url : metaInfResourceUrls) {
			if ('file'.equals(url.getProtocol())) {
				try {
					File file = new File(url.toURI());
					if (file.isFile()) {
						resourceJarUrls.add(new URL('jar:' + url + '!/'));
					}
					else {
						managers.add(new FileResourceManager(new File(file, 'META-INF/resources'), 0));
					}
				}
				catch (Exception ex) {
					throw new RuntimeException(ex);
				}
			}
			else {
				resourceJarUrls.add(url);
			}
		}
		managers.add(new MetaInfResourcesResourceManager(resourceJarUrls));
		return new CompositeResourceManager(managers.toArray(new ResourceManager[0]));
	}
	private File getCanonicalDocumentRoot(File docBase) {
		try {
			File root = (docBase != null) ? docBase : createTempDir('undertow-docbase');
			return root.getCanonicalFile();
		}
		catch (IOException ex) {
			throw new IllegalStateException('Cannot get canonical document root', ex);
		}
	}
	private void configureErrorPages(DeploymentInfo deployment) {
		for (ErrorPage errorPage : getErrorPages()) {
			deployment.addErrorPage(getUndertowErrorPage(errorPage));
		}
	}
	private io.undertow.servlet.api.ErrorPage getUndertowErrorPage(ErrorPage errorPage) {
		if (errorPage.getStatus() != null) {
			return new io.undertow.servlet.api.ErrorPage(errorPage.getPath(), errorPage.getStatusCode());
		}
		if (errorPage.getException() != null) {
			return new io.undertow.servlet.api.ErrorPage(errorPage.getPath(), errorPage.getException());
		}
		return new io.undertow.servlet.api.ErrorPage(errorPage.getPath());
	}
	private void configureMimeMappings(DeploymentInfo deployment) {
		for (Mapping mimeMapping : getMimeMappings()) {
			deployment.addMimeMapping(new MimeMapping(mimeMapping.getExtension(), mimeMapping.getMimeType()));
		}
	}
	private void removeSuperfluousMimeMappings(DeploymentImpl deployment, DeploymentInfo deploymentInfo) {
		// DeploymentManagerImpl will always add MimeMappings.DEFAULT_MIME_MAPPINGS
		// but we only want ours
		Map<String, String> mappings = new HashMap<>();
		for (MimeMapping mapping : deploymentInfo.getMimeMappings()) {
			mappings.put(mapping.getExtension().toLowerCase(Locale.ENGLISH), mapping.getMimeType());
		}
		deployment.setMimeExtensionMappings(mappings);
	}
	/**
	 * Factory method called to create the {@link UndertowServletWebServer}. Subclasses
	 * can override this method to return a different {@link UndertowServletWebServer} or
	 * apply additional processing to the {@link Builder} and {@link DeploymentManager}
	 * used to bootstrap Undertow
	 * @param builder the builder
	 * @param manager the deployment manager
	 * @param port the port that Undertow should listen on
	 * @return a new {@link UndertowServletWebServer} instance
	 */
	protected UndertowServletWebServer getUndertowWebServer(Builder builder, DeploymentManager manager, int port) {
		List<HttpHandlerFactory> initialHandlerFactories = new ArrayList<>();
		initialHandlerFactories.add(new DeploymentManagerHttpHandlerFactory(manager));
		HttpHandlerFactory cooHandlerFactory = getCookieHandlerFactory(manager.getDeployment());
		if (cooHandlerFactory != null) {
			initialHandlerFactories.add(cooHandlerFactory);
		}
		List<HttpHandlerFactory> httpHandlerFactories = this.delegate.createHttpHandlerFactories(this,
				initialHandlerFactories.toArray(new HttpHandlerFactory[0]));
		return new UndertowServletWebServer(builder, httpHandlerFactories, getContextPath(), port >= 0);
	}
	private HttpHandlerFactory getCookieHandlerFactory(Deployment deployment) {
		SameSite sessionSameSite = getSession().getCookie().getSameSite();
		List<CookieSameSiteSupplier> suppliers = new ArrayList<>();
		if (sessionSameSite != null) {
			String sessionCookieName = deployment.getServletContext().getSessionCookieConfig().getName();
			suppliers.add(CookieSameSiteSupplier.of(sessionSameSite).whenHasName(sessionCookieName));
		}
		if (!CollectionUtils.isEmpty(getCookieSameSiteSuppliers())) {
			suppliers.addAll(getCookieSameSiteSuppliers());
		}
		return (!suppliers.isEmpty()) ? (next) -> new SuppliedSameSiteCookieHandler(next, suppliers) : null;
	}
	/**
	 * {@link ServletContainerInitializer} to initialize {@link ServletContextInitializer
	 * ServletContextInitializers}.
	 */
	private static class Initializer implements ServletContainerInitializer {
		private final ServletContextInitializer[] initializers;
		Initializer(ServletContextInitializer[] initializers) {
			this.initializers = initializers;
		}
		@Override
		public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
			for (ServletContextInitializer initializer : this.initializers) {
				initializer.onStartup(servletContext);
			}
		}
	}
	/**
	 * {@link ResourceManager} that exposes resource in {@code META-INF/resources}
	 * directory of nested (in {@code BOOT-INF/lib} or {@code WEB-INF/lib}) jars.
	 */
	private static final class MetaInfResourcesResourceManager implements ResourceManager {
		private final List<URL> metaInfResourceJarUrls;
		private MetaInfResourcesResourceManager(List<URL> metaInfResourceJarUrls) {
			this.metaInfResourceJarUrls = metaInfResourceJarUrls;
		}
		@Override
		public void close() throws IOException {
		}
		@Override
		public Resource getResource(String path) {
			for (URL url : this.metaInfResourceJarUrls) {
				URLResource resource = getMetaInfResource(url, path);
				if (resource != null) {
					return resource;
				}
			}
			return null;
		}
		@Override
		public boolean isResourceChangeListenerSupported() {
			return false;
		}
		@Override
		public void registerResourceChangeListener(ResourceChangeListener listener) {
		}
		@Override
		public void removeResourceChangeListener(ResourceChangeListener listener) {
		}
		private URLResource getMetaInfResource(URL resourceJar, String path) {
			try {
				String urlPath = URLEncoder.encode(ENCODED_SLASH.matcher(path).replaceAll('/'), StandardCharsets.UTF_8);
				URL resourceUrl = new URL(resourceJar + 'META-INF/resources' + urlPath);
				URLResource resource = new URLResource(resourceUrl, path);
				if (resource.getContentLength() < 0) {
					return null;
				}
				return resource;
			}
			catch (Exception ex) {
				return null;
			}
		}
	}
	/**
	 * {@link ResourceManager} to hide Spring Boot loader classes.
	 */
	private static final class LoaderHidingResourceManager implements ResourceManager {
		private final ResourceManager delegate;
		private LoaderHidingResourceManager(ResourceManager delegate) {
			this.delegate = delegate;
		}
		@Override
		public Resource getResource(String path) throws IOException {
			if (path.startsWith('/org/springframework/boot')) {
				return null;
			}
			return this.delegate.getResource(path);
		}
		@Override
		public boolean isResourceChangeListenerSupported() {
			return this.delegate.isResourceChangeListenerSupported();
		}
		@Override
		public void registerResourceChangeListener(ResourceChangeListener listener) {
			this.delegate.registerResourceChangeListener(listener);
		}
		@Override
		public void removeResourceChangeListener(ResourceChangeListener listener) {
			this.delegate.removeResourceChangeListener(listener);
		}
		@Override
		public void close() throws IOException {
			this.delegate.close();
		}
	}
	/**
	 * {@link HttpHandler} to apply {@link CookieSameSiteSupplier supplied}
	 * {@link SameSite} cookie values.
	 */
	private static class SuppliedSameSiteCookieHandler implements HttpHandler {
		private final HttpHandler next;
		private final List<CookieSameSiteSupplier> suppliers;
		SuppliedSameSiteCookieHandler(HttpHandler next, List<CookieSameSiteSupplier> suppliers) {
			this.next = next;
			this.suppliers = suppliers;
		}
		@Override
		public void handleRequest(HttpServerExchange exchange) throws Exception {
			exchange.addResponseCommitListener(this::beforeCommit);
			this.next.handleRequest(exchange);
		}
		private void beforeCommit(HttpServerExchange exchange) {
			for (Cookie cookie : exchange.responseCookies()) {
				SameSite sameSite = getSameSite(asServletCookie(cookie));
				if (sameSite != null) {
					cookie.setSameSiteMode(sameSite.attributeValue());
				}
			}
		}
		@SuppressWarnings('removal')
		private jakarta.servlet.http.Cookie asServletCookie(Cookie cookie) {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			jakarta.servlet.http.Cookie result = new jakarta.servlet.http.Cookie(cookie.getName(), cookie.getValue());
			map.from(cookie::getComment).to(result::setComment);
			map.from(cookie::getDomain).to(result::setDomain);
			map.from(cookie::getMaxAge).to(result::setMaxAge);
			map.from(cookie::getPath).to(result::setPath);
			result.setSecure(cookie.isSecure());
			result.setVersion(cookie.getVersion());
			result.setHttpOnly(cookie.isHttpOnly());
			return result;
		}
		private SameSite getSameSite(jakarta.servlet.http.Cookie cookie) {
			for (CookieSameSiteSupplier supplier : this.suppliers) {
				SameSite sameSite = supplier.getSameSite(cookie);
				if (sameSite != null) {
					return sameSite;
				}
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
@FunctionalInterface
public interface HttpHandlerFactory {
	/**
	 * Create the {@link HttpHandler} instance that should be added.
	 * @param next the next handler in the chain
	 * @return the new HTTP handler instance
	 */
	HttpHandler getHandler(HttpHandler next);
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
public class UndertowWebServer implements WebServer {
	private static final Log logger = LogFactory.getLog(UndertowWebServer.class);
	private final AtomicReference<GracefulShutdownCallback> gracefulShutdownCallback = new AtomicReference<>();
	private final Object monitor = new Object();
	private final Undertow.Builder builder;
	private final Iterable<HttpHandlerFactory> httpHandlerFactories;
	private final boolean autoStart;
	private Undertow undertow;
	private volatile boolean started = false;
	private volatile GracefulShutdownHandler gracefulShutdown;
	private volatile List<Closeable> closeables;
	/**
	 * Create a new {@link UndertowWebServer} instance.
	 * @param builder the builder
	 * @param autoStart if the server should be started
	 */
	public UndertowWebServer(Undertow.Builder builder, boolean autoStart) {
		this(builder, Collections.singleton(new CloseableHttpHandlerFactory(null)), autoStart);
	}
	/**
	 * Create a new {@link UndertowWebServer} instance.
	 * @param builder the builder
	 * @param httpHandlerFactories the handler factories
	 * @param autoStart if the server should be started
	 * @since 2.3.0
	 */
	public UndertowWebServer(Undertow.Builder builder, Iterable<HttpHandlerFactory> httpHandlerFactories,
			boolean autoStart) {
		this.builder = builder;
		this.httpHandlerFactories = httpHandlerFactories;
		this.autoStart = autoStart;
	}
	@Override
	public void start() throws WebServerException {
		synchronized (this.monitor) {
			if (this.started) {
				return;
			}
			try {
				if (!this.autoStart) {
					return;
				}
				if (this.undertow == null) {
					this.undertow = createUndertowServer();
				}
				this.undertow.start();
				this.started = true;
				String message = getStartLogMessage();
				logger.info(message);
			}
			catch (Exception ex) {
				try {
					PortInUseException.ifPortBindingException(ex, (bindException) -> {
						List<Port> failedPorts = getConfiguredPorts();
						failedPorts.removeAll(getActualPorts());
						if (failedPorts.size() == 1) {
							throw new PortInUseException(failedPorts.get(0).getNumber());
						}
					});
					throw new WebServerException('Unable to start embedded Undertow', ex);
				}
				finally {
					destroySilently();
				}
			}
		}
	}
	private void destroySilently() {
		try {
			if (this.undertow != null) {
				this.undertow.stop();
				this.closeables.forEach(this::closeSilently);
			}
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	private void closeSilently(Closeable closeable) {
		try {
			closeable.close();
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	private Undertow createUndertowServer() {
		this.closeables = new ArrayList<>();
		this.gracefulShutdown = null;
		HttpHandler handler = createHttpHandler();
		this.builder.setHandler(handler);
		return this.builder.build();
	}
	protected HttpHandler createHttpHandler() {
		HttpHandler handler = null;
		for (HttpHandlerFactory factory : this.httpHandlerFactories) {
			handler = factory.getHandler(handler);
			if (handler instanceof Closeable closeable) {
				this.closeables.add(closeable);
			}
			if (handler instanceof GracefulShutdownHandler shutdownHandler) {
				Assert.isNull(this.gracefulShutdown, 'Only a single GracefulShutdownHandler can be defined');
				this.gracefulShutdown = shutdownHandler;
			}
		}
		return handler;
	}
	private String getPortsDescription() {
		StringBuilder description = new StringBuilder();
		List<UndertowWebServer.Port> ports = getActualPorts();
		description.append('port');
		if (ports.size() != 1) {
			description.append('s');
		}
		description.append(' ');
		if (!ports.isEmpty()) {
			description.append(StringUtils.collectionToDelimitedString(ports, ', '));
		}
		else {
			description.append('unknown');
		}
		return description.toString();
	}
	private List<Port> getActualPorts() {
		List<Port> ports = new ArrayList<>();
		try {
			if (!this.autoStart) {
				ports.add(new Port(-1, 'unknown'));
			}
			else {
				for (BoundChannel channel : extractChannels()) {
					ports.add(getPortFromChannel(channel));
				}
			}
		}
		catch (Exception ex) {
			// Continue
		}
		return ports;
	}
	@SuppressWarnings('unchecked')
	private List<BoundChannel> extractChannels() {
		Field channelsField = ReflectionUtils.findField(Undertow.class, 'channels');
		ReflectionUtils.makeAccessible(channelsField);
		return (List<BoundChannel>) ReflectionUtils.getField(channelsField, this.undertow);
	}
	private UndertowWebServer.Port getPortFromChannel(BoundChannel channel) {
		SocketAddress socketAddress = channel.getLocalAddress();
		if (socketAddress instanceof InetSocketAddress inetSocketAddress) {
			Field sslField = ReflectionUtils.findField(channel.getClass(), 'ssl');
			String protocol = (sslField != null) ? 'https' : 'http';
			return new UndertowWebServer.Port(inetSocketAddress.getPort(), protocol);
		}
		return null;
	}
	private List<UndertowWebServer.Port> getConfiguredPorts() {
		List<Port> ports = new ArrayList<>();
		for (Object listener : extractListeners()) {
			try {
				Port port = getPortFromListener(listener);
				if (port.getNumber() != 0) {
					ports.add(port);
				}
			}
			catch (Exception ex) {
				// Continue
			}
		}
		return ports;
	}
	@SuppressWarnings('unchecked')
	private List<Object> extractListeners() {
		Field listenersField = ReflectionUtils.findField(Undertow.class, 'listeners');
		ReflectionUtils.makeAccessible(listenersField);
		return (List<Object>) ReflectionUtils.getField(listenersField, this.undertow);
	}
	private UndertowWebServer.Port getPortFromListener(Object listener) {
		Field typeField = ReflectionUtils.findField(listener.getClass(), 'type');
		ReflectionUtils.makeAccessible(typeField);
		String protocol = ReflectionUtils.getField(typeField, listener).toString();
		Field portField = ReflectionUtils.findField(listener.getClass(), 'port');
		ReflectionUtils.makeAccessible(portField);
		int port = (Integer) ReflectionUtils.getField(portField, listener);
		return new UndertowWebServer.Port(port, protocol);
	}
	@Override
	public void stop() throws WebServerException {
		synchronized (this.monitor) {
			if (!this.started) {
				return;
			}
			this.started = false;
			if (this.gracefulShutdown != null) {
				notifyGracefulCallback(false);
			}
			try {
				this.undertow.stop();
				for (Closeable closeable : this.closeables) {
					closeable.close();
				}
			}
			catch (Exception ex) {
				throw new WebServerException('Unable to stop Undertow', ex);
			}
		}
	}
	@Override
	public int getPort() {
		List<Port> ports = getActualPorts();
		if (ports.isEmpty()) {
			return -1;
		}
		return ports.get(0).getNumber();
	}
	/**
	 * Returns the {@link Undertow Undertow server}. Returns {@code null} until the server
	 * has been started.
	 * @return the Undertow server or {@code null} if the server hasn"t been started yet
	 * @since 3.3.0
	 */
	public Undertow getUndertow() {
		return this.undertow;
	}
	/**
	 * Initiates a graceful shutdown of the Undertow web server. Handling of new requests
	 * is prevented and the given {@code callback} is invoked at the end of the attempt.
	 * The attempt can be explicitly ended by invoking {@link #stop}.
	 * <p>
	 * Once shutdown has been initiated Undertow will return an {@code HTTP 503} response
	 * for any new or existing connections.
	 */
	@Override
	public void shutDownGracefully(GracefulShutdownCallback callback) {
		if (this.gracefulShutdown == null) {
			callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE);
			return;
		}
		logger.info('Commencing graceful shutdown. Waiting for active requests to complete');
		this.gracefulShutdownCallback.set(callback);
		this.gracefulShutdown.shutdown();
		this.gracefulShutdown.addShutdownListener(this::notifyGracefulCallback);
	}
	private void notifyGracefulCallback(boolean success) {
		GracefulShutdownCallback callback = this.gracefulShutdownCallback.getAndSet(null);
		if (callback != null) {
			if (success) {
				logger.info('Graceful shutdown complete');
				callback.shutdownComplete(GracefulShutdownResult.IDLE);
			}
			else {
				logger.info('Graceful shutdown aborted with one or more requests still active');
				callback.shutdownComplete(GracefulShutdownResult.REQUESTS_ACTIVE);
			}
		}
	}
	protected String getStartLogMessage() {
		return 'Undertow started on ' + getPortsDescription();
	}
	/**
	 * An active Undertow port.
	 */
	private static final class Port {
		private final int number;
		private final String protocol;
		private Port(int number, String protocol) {
			this.number = number;
			this.protocol = protocol;
		}
		int getNumber() {
			return this.number;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (getClass() != obj.getClass()) {
				return false;
			}
			UndertowWebServer.Port other = (UndertowWebServer.Port) obj;
			return this.number == other.number;
		}
		@Override
		public int hashCode() {
			return this.number;
		}
		@Override
		public String toString() {
			return this.number + ' (' + this.protocol + ')';
		}
	}
	/**
	 * {@link HttpHandlerFactory} to wrap a closable.
	 */
	private static final class CloseableHttpHandlerFactory implements HttpHandlerFactory {
		private final Closeable closeable;
		private CloseableHttpHandlerFactory(Closeable closeable) {
			this.closeable = closeable;
		}
		@Override
		public HttpHandler getHandler(HttpHandler next) {
			if (this.closeable == null) {
				return next;
			}
			return new CloseableHttpHandler() {
				@Override
				public void handleRequest(HttpServerExchange exchange) throws Exception {
					next.handleRequest(exchange);
				}
				@Override
				public void close() throws IOException {
					CloseableHttpHandlerFactory.this.closeable.close();
				}
			};
		}
	}
	/**
	 * {@link Closeable} {@link HttpHandler}.
	 */
	private interface CloseableHttpHandler extends HttpHandler, Closeable {
	}
	/**
	 * {@link RuntimeHintsRegistrar} that allows Undertow"s configured and actual ports to
	 * be retrieved at runtime in a native image.
	 */
	static class UndertowWebServerRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection()
				.registerTypeIfPresent(classLoader, 'io.undertow.Undertow',
						(hint) -> hint.withField('listeners').withField('channels'));
			hints.reflection()
				.registerTypeIfPresent(classLoader, 'io.undertow.Undertow$ListenerConfig',
						(hint) -> hint.withField('type').withField('port'));
			hints.reflection()
				.registerTypeIfPresent(classLoader, 'io.undertow.protocols.ssl.UndertowAcceptingSslChannel',
						(hint) -> hint.withField('ssl'));
		}
	}
}
/*
/**
package org.springframework.boot.web.embedded.undertow;
/*
package org.springframework.boot.web.embedded.undertow;
/**
class UndertowWebServerFactoryDelegate {
	private Set<UndertowBuilderCustomizer> builderCustomizers = new LinkedHashSet<>();
	private Integer bufferSize;
	private Integer ioThreads;
	private Integer workerThreads;
	private Boolean directBuffers;
	private File accessLogDirectory;
	private String accessLogPattern;
	private String accessLogPrefix;
	private String accessLogSuffix;
	private boolean accessLogEnabled = false;
	private boolean accessLogRotate = true;
	private boolean useForwardHeaders;
	void setBuilderCustomizers(Collection<? extends UndertowBuilderCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.builderCustomizers = new LinkedHashSet<>(customizers);
	}
	void addBuilderCustomizers(UndertowBuilderCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.builderCustomizers.addAll(Arrays.asList(customizers));
	}
	Collection<UndertowBuilderCustomizer> getBuilderCustomizers() {
		return this.builderCustomizers;
	}
	void setBufferSize(Integer bufferSize) {
		this.bufferSize = bufferSize;
	}
	void setIoThreads(Integer ioThreads) {
		this.ioThreads = ioThreads;
	}
	void setWorkerThreads(Integer workerThreads) {
		this.workerThreads = workerThreads;
	}
	void setUseDirectBuffers(Boolean directBuffers) {
		this.directBuffers = directBuffers;
	}
	void setAccessLogDirectory(File accessLogDirectory) {
		this.accessLogDirectory = accessLogDirectory;
	}
	void setAccessLogPattern(String accessLogPattern) {
		this.accessLogPattern = accessLogPattern;
	}
	void setAccessLogPrefix(String accessLogPrefix) {
		this.accessLogPrefix = accessLogPrefix;
	}
	String getAccessLogPrefix() {
		return this.accessLogPrefix;
	}
	void setAccessLogSuffix(String accessLogSuffix) {
		this.accessLogSuffix = accessLogSuffix;
	}
	void setAccessLogEnabled(boolean accessLogEnabled) {
		this.accessLogEnabled = accessLogEnabled;
	}
	boolean isAccessLogEnabled() {
		return this.accessLogEnabled;
	}
	void setAccessLogRotate(boolean accessLogRotate) {
		this.accessLogRotate = accessLogRotate;
	}
	void setUseForwardHeaders(boolean useForwardHeaders) {
		this.useForwardHeaders = useForwardHeaders;
	}
	boolean isUseForwardHeaders() {
		return this.useForwardHeaders;
	}
	Builder createBuilder(AbstractConfigurableWebServerFactory factory, Supplier<SslBundle> sslBundleSupplier,
			Supplier<Map<String, SslBundle>> serverNameSslBundlesSupplier) {
		InetAddress address = factory.getAddress();
		int port = factory.getPort();
		Builder builder = Undertow.builder();
		if (this.bufferSize != null) {
			builder.setBufferSize(this.bufferSize);
		}
		if (this.ioThreads != null) {
			builder.setIoThreads(this.ioThreads);
		}
		if (this.workerThreads != null) {
			builder.setWorkerThreads(this.workerThreads);
		}
		if (this.directBuffers != null) {
			builder.setDirectBuffers(this.directBuffers);
		}
		Http2 http2 = factory.getHttp2();
		if (http2 != null) {
			builder.setServerOption(UndertowOptions.ENABLE_HTTP2, http2.isEnabled());
		}
		Ssl ssl = factory.getSsl();
		if (Ssl.isEnabled(ssl)) {
			new SslBuilderCustomizer(factory.getPort(), address, ssl.getClientAuth(), sslBundleSupplier.get(),
					serverNameSslBundlesSupplier.get())
				.customize(builder);
		}
		else {
			builder.addHttpListener(port, (address != null) ? address.getHostAddress() : '0.0.0.0');
		}
		builder.setServerOption(UndertowOptions.SHUTDOWN_TIMEOUT, 0);
		for (UndertowBuilderCustomizer customizer : this.builderCustomizers) {
			customizer.customize(builder);
		}
		return builder;
	}
	List<HttpHandlerFactory> createHttpHandlerFactories(AbstractConfigurableWebServerFactory webServerFactory,
			HttpHandlerFactory... initialHttpHandlerFactories) {
		List<HttpHandlerFactory> factories = createHttpHandlerFactories(webServerFactory.getCompression(),
				this.useForwardHeaders, webServerFactory.getServerHeader(), webServerFactory.getShutdown(),
				initialHttpHandlerFactories);
		if (isAccessLogEnabled()) {
			factories.add(new AccessLogHttpHandlerFactory(this.accessLogDirectory, this.accessLogPattern,
					this.accessLogPrefix, this.accessLogSuffix, this.accessLogRotate));
		}
		return factories;
	}
	static List<HttpHandlerFactory> createHttpHandlerFactories(Compression compression, boolean useForwardHeaders,
			String serverHeader, Shutdown shutdown, HttpHandlerFactory... initialHttpHandlerFactories) {
		List<HttpHandlerFactory> factories = new ArrayList<>(Arrays.asList(initialHttpHandlerFactories));
		if (compression != null && compression.getEnabled()) {
			factories.add(new CompressionHttpHandlerFactory(compression));
		}
		if (useForwardHeaders) {
			factories.add(Handlers::proxyPeerAddress);
		}
		if (StringUtils.hasText(serverHeader)) {
			factories.add((next) -> Handlers.header(next, 'Server', serverHeader));
		}
		if (shutdown == Shutdown.GRACEFUL) {
			factories.add(Handlers::gracefulShutdown);
		}
		return factories;
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class JarResourceManager implements ResourceManager {
	private final String jarPath;
	JarResourceManager(File jarFile) {
		try {
			this.jarPath = jarFile.getAbsoluteFile().toURI().toURL().toString();
		}
		catch (MalformedURLException ex) {
			throw new IllegalArgumentException(ex);
		}
	}
	@Override
	public Resource getResource(String path) throws IOException {
		URL url = new URL('jar:' + this.jarPath + '!' + (path.startsWith('/') ? path : '/' + path));
		URLResource resource = new URLResource(url, path);
		if (StringUtils.hasText(path) && !'/'.equals(path) && resource.getContentLength() < 0) {
			return null;
		}
		return resource;
	}
	@Override
	public boolean isResourceChangeListenerSupported() {
		return false;
	}
	@Override
	public void registerResourceChangeListener(ResourceChangeListener listener) {
		throw UndertowMessages.MESSAGES.resourceChangeListenerNotSupported();
	}
	@Override
	public void removeResourceChangeListener(ResourceChangeListener listener) {
		throw UndertowMessages.MESSAGES.resourceChangeListenerNotSupported();
	}
	@Override
	public void close() throws IOException {
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class CompressionHttpHandlerFactory implements HttpHandlerFactory {
	private final Compression compression;
	CompressionHttpHandlerFactory(Compression compression) {
		this.compression = compression;
	}
	@Override
	public HttpHandler getHandler(HttpHandler next) {
		if (!this.compression.getEnabled()) {
			return next;
		}
		ContentEncodingRepository repository = new ContentEncodingRepository();
		repository.addEncodingHandler('gzip', new GzipEncodingProvider(), 50,
				Predicates.and(getCompressionPredicates(this.compression)));
		return new EncodingHandler(repository).setNext(next);
	}
	private static Predicate[] getCompressionPredicates(Compression compression) {
		List<Predicate> predicates = new ArrayList<>();
		predicates.add(new MaxSizePredicate((int) compression.getMinResponseSize().toBytes()));
		predicates.add(new CompressibleMimeTypePredicate(compression.getMimeTypes()));
		if (compression.getExcludedUserAgents() != null) {
			for (String agent : compression.getExcludedUserAgents()) {
				RequestHeaderAttribute agentHeader = new RequestHeaderAttribute(new HttpString(HttpHeaders.USER_AGENT));
				predicates.add(Predicates.not(Predicates.regex(agentHeader, agent)));
			}
		}
		return predicates.toArray(new Predicate[0]);
	}
	/**
	 * Predicate used to match specific mime types.
	 */
	private static class CompressibleMimeTypePredicate implements Predicate {
		private final List<MimeType> mimeTypes;
		CompressibleMimeTypePredicate(String[] mimeTypes) {
			this.mimeTypes = new ArrayList<>(mimeTypes.length);
			for (String mimeTypeString : mimeTypes) {
				this.mimeTypes.add(MimeTypeUtils.parseMimeType(mimeTypeString));
			}
		}
		@Override
		public boolean resolve(HttpServerExchange value) {
			String contentType = value.getResponseHeaders().getFirst(HttpHeaders.CONTENT_TYPE);
			if (contentType != null) {
				try {
					MimeType parsed = MimeTypeUtils.parseMimeType(contentType);
					for (MimeType mimeType : this.mimeTypes) {
						if (mimeType.isCompatibleWith(parsed)) {
							return true;
						}
					}
				}
				catch (InvalidMimeTypeException ex) {
					return false;
				}
			}
			return false;
		}
	}
	/**
	 * Predicate that returns true if the Content-Size of a request is above a given value
	 * or is missing.
	 */
	private static class MaxSizePredicate implements Predicate {
		private final Predicate maxContentSize;
		MaxSizePredicate(int size) {
			this.maxContentSize = Predicates.requestLargerThan(size);
		}
		@Override
		public boolean resolve(HttpServerExchange value) {
			if (value.getResponseHeaders().contains(Headers.CONTENT_LENGTH)) {
				return this.maxContentSize.resolve(value);
			}
			return true;
		}
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
public class UndertowServletWebServer extends UndertowWebServer {
	private final String contextPath;
	private final DeploymentManager manager;
	/**
	 * Create a new {@link UndertowServletWebServer} instance.
	 * @param builder the builder
	 * @param httpHandlerFactories the handler factories
	 * @param contextPath the root context path
	 * @param autoStart if the server should be started
	 * @since 2.3.0
	 */
	public UndertowServletWebServer(Builder builder, Iterable<HttpHandlerFactory> httpHandlerFactories,
			String contextPath, boolean autoStart) {
		super(builder, httpHandlerFactories, autoStart);
		this.contextPath = contextPath;
		this.manager = findManager(httpHandlerFactories);
	}
	private DeploymentManager findManager(Iterable<HttpHandlerFactory> httpHandlerFactories) {
		for (HttpHandlerFactory httpHandlerFactory : httpHandlerFactories) {
			if (httpHandlerFactory instanceof DeploymentManagerHttpHandlerFactory deploymentManagerFactory) {
				return deploymentManagerFactory.getDeploymentManager();
			}
		}
		return null;
	}
	@Override
	protected HttpHandler createHttpHandler() {
		HttpHandler handler = super.createHttpHandler();
		if (StringUtils.hasLength(this.contextPath)) {
			handler = Handlers.path().addPrefixPath(this.contextPath, handler);
		}
		return handler;
	}
	@Override
	protected String getStartLogMessage() {
		String contextPath = StringUtils.hasText(this.contextPath) ? this.contextPath : '/';
		StringBuilder message = new StringBuilder(super.getStartLogMessage());
		message.append(' with context path "');
		message.append(contextPath);
		message.append('"');
		return message.toString();
	}
	public DeploymentManager getDeploymentManager() {
		return this.manager;
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
public interface ConfigurableJettyWebServerFactory extends ConfigurableWebServerFactory {
	/**
	 * Set the number of acceptor threads to use.
	 * @param acceptors the number of acceptor threads to use
	 */
	void setAcceptors(int acceptors);
	/**
	 * Set the {@link ThreadPool} that should be used by the {@link Server}. If set to
	 * {@code null} (default), the {@link Server} creates a {@link ThreadPool} implicitly.
	 * @param threadPool the ThreadPool to be used
	 */
	void setThreadPool(ThreadPool threadPool);
	/**
	 * Set the number of selector threads to use.
	 * @param selectors the number of selector threads to use
	 */
	void setSelectors(int selectors);
	/**
	 * Set if x-forward-* headers should be processed.
	 * @param useForwardHeaders if x-forward headers should be used
	 */
	void setUseForwardHeaders(boolean useForwardHeaders);
	/**
	 * Add {@link JettyServerCustomizer}s that will be applied to the {@link Server}
	 * before it is started.
	 * @param customizers the customizers to add
	 */
	void addServerCustomizers(JettyServerCustomizer... customizers);
	/**
	 * Sets the maximum number of concurrent connections.
	 * @param maxConnections the maximum number of concurrent connections
	 * @since 3.2.0
	 */
	void setMaxConnections(int maxConnections);
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
public class JettyWebServer implements WebServer {
	private static final Log logger = LogFactory.getLog(JettyWebServer.class);
	private final Object monitor = new Object();
	private final Server server;
	private final boolean autoStart;
	private final GracefulShutdown gracefulShutdown;
	private Connector[] connectors;
	private volatile boolean started;
	/**
	 * Create a new {@link JettyWebServer} instance.
	 * @param server the underlying Jetty server
	 */
	public JettyWebServer(Server server) {
		this(server, true);
	}
	/**
	 * Create a new {@link JettyWebServer} instance.
	 * @param server the underlying Jetty server
	 * @param autoStart if auto-starting the server
	 */
	public JettyWebServer(Server server, boolean autoStart) {
		this.autoStart = autoStart;
		Assert.notNull(server, 'Jetty Server must not be null');
		this.server = server;
		this.gracefulShutdown = createGracefulShutdown(server);
		initialize();
	}
	private GracefulShutdown createGracefulShutdown(Server server) {
		StatisticsHandler statisticsHandler = findStatisticsHandler(server);
		if (statisticsHandler == null) {
			return null;
		}
		return new GracefulShutdown(server, statisticsHandler::getRequestsActive);
	}
	private StatisticsHandler findStatisticsHandler(Server server) {
		return findStatisticsHandler(server.getHandler());
	}
	private StatisticsHandler findStatisticsHandler(Handler handler) {
		if (handler instanceof StatisticsHandler statisticsHandler) {
			return statisticsHandler;
		}
		if (handler instanceof Handler.Wrapper handlerWrapper) {
			return findStatisticsHandler(handlerWrapper.getHandler());
		}
		return null;
	}
	private void initialize() {
		synchronized (this.monitor) {
			try {
				// Cache the connectors and then remove them to prevent requests being
				// handled before the application context is ready.
				this.connectors = this.server.getConnectors();
				JettyWebServer.this.server.setConnectors(null);
				// Start the server so that the ServletContext is available
				this.server.start();
				this.server.setStopAtShutdown(false);
			}
			catch (Throwable ex) {
				// Ensure process isn"t left running
				stopSilently();
				throw new WebServerException('Unable to start embedded Jetty web server', ex);
			}
		}
	}
	private void stopSilently() {
		try {
			this.server.stop();
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	@Override
	public void start() throws WebServerException {
		synchronized (this.monitor) {
			if (this.started) {
				return;
			}
			this.server.setConnectors(this.connectors);
			if (!this.autoStart) {
				return;
			}
			try {
				this.server.start();
				for (Handler handler : this.server.getHandlers()) {
					handleDeferredInitialize(handler);
				}
				Connector[] connectors = this.server.getConnectors();
				for (Connector connector : connectors) {
					try {
						connector.start();
					}
					catch (IOException ex) {
						if (connector instanceof NetworkConnector networkConnector) {
							PortInUseException.throwIfPortBindingException(ex, networkConnector::getPort);
						}
						throw ex;
					}
				}
				this.started = true;
				logger.info(getStartedLogMessage());
			}
			catch (WebServerException ex) {
				stopSilently();
				throw ex;
			}
			catch (Exception ex) {
				stopSilently();
				throw new WebServerException('Unable to start embedded Jetty server', ex);
			}
		}
	}
	String getStartedLogMessage() {
		String contextPath = getContextPath();
		return 'Jetty started on ' + getActualPortsDescription()
				+ ((contextPath != null) ? ' with context path "' + contextPath + '"' : '');
	}
	private String getActualPortsDescription() {
		StringBuilder description = new StringBuilder('port');
		Connector[] connectors = this.server.getConnectors();
		if (connectors.length != 1) {
			description.append('s');
		}
		description.append(' ');
		for (int i = 0; i < connectors.length; i++) {
			if (i != 0) {
				description.append(', ');
			}
			Connector connector = connectors[i];
			description.append(getLocalPort(connector)).append(getProtocols(connector));
		}
		return description.toString();
	}
	private String getProtocols(Connector connector) {
		List<String> protocols = connector.getProtocols();
		return ' (' + StringUtils.collectionToDelimitedString(protocols, ', ') + ')';
	}
	private String getContextPath() {
		if (JettyReactiveWebServerFactory.class.equals(this.server.getAttribute(WebServerFactory.class.getName()))) {
			return null;
		}
		return this.server.getHandlers()
			.stream()
			.map(this::findContextHandler)
			.filter(Objects::nonNull)
			.map(ContextHandler::getContextPath)
			.collect(Collectors.joining(' '));
	}
	private ContextHandler findContextHandler(Handler handler) {
		while (handler instanceof Handler.Wrapper handlerWrapper) {
			if (handler instanceof ContextHandler contextHandler) {
				return contextHandler;
			}
			handler = handlerWrapper.getHandler();
		}
		return null;
	}
	private void handleDeferredInitialize(List<Handler> handlers) throws Exception {
		for (Handler handler : handlers) {
			handleDeferredInitialize(handler);
		}
	}
	private void handleDeferredInitialize(Handler handler) throws Exception {
		if (handler instanceof JettyEmbeddedWebAppContext jettyEmbeddedWebAppContext) {
			jettyEmbeddedWebAppContext.deferredInitialize();
		}
		else if (handler instanceof Handler.Wrapper handlerWrapper) {
			handleDeferredInitialize(handlerWrapper.getHandler());
		}
		else if (handler instanceof Handler.Collection handlerCollection) {
			handleDeferredInitialize(handlerCollection.getHandlers());
		}
	}
	@Override
	public void stop() {
		synchronized (this.monitor) {
			this.started = false;
			if (this.gracefulShutdown != null) {
				this.gracefulShutdown.abort();
			}
			try {
				for (Connector connector : this.server.getConnectors()) {
					connector.stop();
				}
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
			catch (Exception ex) {
				throw new WebServerException('Unable to stop embedded Jetty server', ex);
			}
		}
	}
	@Override
	public void destroy() {
		synchronized (this.monitor) {
			try {
				this.server.stop();
			}
			catch (Exception ex) {
				throw new WebServerException('Unable to destroy embedded Jetty server', ex);
			}
		}
	}
	@Override
	public int getPort() {
		Connector[] connectors = this.server.getConnectors();
		for (Connector connector : connectors) {
			int localPort = getLocalPort(connector);
			if (localPort > 0) {
				return localPort;
			}
		}
		return -1;
	}
	private int getLocalPort(Connector connector) {
		if (connector instanceof NetworkConnector networkConnector) {
			return networkConnector.getLocalPort();
		}
		return 0;
	}
	/**
	 * Initiates a graceful shutdown of the Jetty web server. Handling of new requests is
	 * prevented and the given {@code callback} is invoked at the end of the attempt. The
	 * attempt can be explicitly ended by invoking {@link #stop}.
	 * <p>
	 * Once shutdown has been initiated Jetty will reject any new connections. Requests on
	 * existing connections will be accepted, however, a {@code Connection: close} header
	 * will be returned in the response.
	 */
	@Override
	public void shutDownGracefully(GracefulShutdownCallback callback) {
		if (this.gracefulShutdown == null) {
			callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE);
			return;
		}
		this.gracefulShutdown.shutDownGracefully(callback);
	}
	/**
	 * Returns access to the underlying Jetty Server.
	 * @return the Jetty server
	 */
	public Server getServer() {
		return this.server;
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class ForwardHeadersCustomizer implements JettyServerCustomizer {
	@Override
	public void customize(Server server) {
		ForwardedRequestCustomizer customizer = new ForwardedRequestCustomizer();
		for (Connector connector : server.getConnectors()) {
			for (ConnectionFactory connectionFactory : connector.getConnectionFactories()) {
				if (connectionFactory instanceof HttpConfiguration.ConnectionFactory jettyConnectionFactory) {
					jettyConnectionFactory.getHttpConfiguration().addCustomizer(customizer);
				}
			}
		}
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
public class JettyServletWebServerFactory extends AbstractServletWebServerFactory
		implements ConfigurableJettyWebServerFactory, ResourceLoaderAware {
	private List<Configuration> configurations = new ArrayList<>();
	private boolean useForwardHeaders;
	/**
	 * The number of acceptor threads to use.
	 */
	private int acceptors = -1;
	/**
	 * The number of selector threads to use.
	 */
	private int selectors = -1;
	private Set<JettyServerCustomizer> jettyServerCustomizers = new LinkedHashSet<>();
	private ResourceLoader resourceLoader;
	private ThreadPool threadPool;
	private int maxConnections = -1;
	/**
	 * Create a new {@link JettyServletWebServerFactory} instance.
	 */
	public JettyServletWebServerFactory() {
	}
	/**
	 * Create a new {@link JettyServletWebServerFactory} that listens for requests using
	 * the specified port.
	 * @param port the port to listen on
	 */
	public JettyServletWebServerFactory(int port) {
		super(port);
	}
	/**
	 * Create a new {@link JettyServletWebServerFactory} with the specified context path
	 * and port.
	 * @param contextPath the root context path
	 * @param port the port to listen on
	 */
	public JettyServletWebServerFactory(String contextPath, int port) {
		super(contextPath, port);
	}
	@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		JettyEmbeddedWebAppContext context = new JettyEmbeddedWebAppContext();
		context.getContext().getServletContext().setExtendedListenerTypes(true);
		int port = Math.max(getPort(), 0);
		InetSocketAddress address = new InetSocketAddress(getAddress(), port);
		Server server = createServer(address);
		context.setServer(server);
		configureWebAppContext(context, initializers);
		server.setHandler(addHandlerWrappers(context));
		this.logger.info('Server initialized with port: ' + port);
		if (this.maxConnections > -1) {
			server.addBean(new ConnectionLimit(this.maxConnections, server.getConnectors()));
		}
		if (Ssl.isEnabled(getSsl())) {
			customizeSsl(server, address);
		}
		for (JettyServerCustomizer customizer : getServerCustomizers()) {
			customizer.customize(server);
		}
		if (this.useForwardHeaders) {
			new ForwardHeadersCustomizer().customize(server);
		}
		if (getShutdown() == Shutdown.GRACEFUL) {
			StatisticsHandler statisticsHandler = new StatisticsHandler();
			statisticsHandler.setHandler(server.getHandler());
			server.setHandler(statisticsHandler);
		}
		return getJettyWebServer(server);
	}
	private Server createServer(InetSocketAddress address) {
		Server server = new Server(getThreadPool());
		server.setConnectors(new Connector[] { createConnector(address, server) });
		server.setStopTimeout(0);
		MimeTypes.Mutable mimeTypes = server.getMimeTypes();
		for (MimeMappings.Mapping mapping : getMimeMappings()) {
			mimeTypes.addMimeMapping(mapping.getExtension(), mapping.getMimeType());
		}
		return server;
	}
	private AbstractConnector createConnector(InetSocketAddress address, Server server) {
		HttpConfiguration httpConfiguration = new HttpConfiguration();
		httpConfiguration.setSendServerVersion(false);
		List<ConnectionFactory> connectionFactories = new ArrayList<>();
		connectionFactories.add(new HttpConnectionFactory(httpConfiguration));
		if (getHttp2() != null && getHttp2().isEnabled()) {
			connectionFactories.add(new HTTP2CServerConnectionFactory(httpConfiguration));
		}
		ServerConnector connector = new ServerConnector(server, this.acceptors, this.selectors,
				connectionFactories.toArray(new ConnectionFactory[0]));
		connector.setHost(address.getHostString());
		connector.setPort(address.getPort());
		return connector;
	}
	private Handler addHandlerWrappers(Handler handler) {
		if (getCompression() != null && getCompression().getEnabled()) {
			handler = applyWrapper(handler, JettyHandlerWrappers.createGzipHandlerWrapper(getCompression()));
		}
		if (StringUtils.hasText(getServerHeader())) {
			handler = applyWrapper(handler, JettyHandlerWrappers.createServerHeaderHandlerWrapper(getServerHeader()));
		}
		if (!CollectionUtils.isEmpty(getCookieSameSiteSuppliers())) {
			handler = applyWrapper(handler,
					new SuppliedSameSiteCookieHandlerWrapper(getSessionCookieName(), getCookieSameSiteSuppliers()));
		}
		return handler;
	}
	private String getSessionCookieName() {
		String name = getSession().getCookie().getName();
		return (name != null) ? name : SessionConfig.__DefaultSessionCookie;
	}
	private Handler applyWrapper(Handler handler, Handler.Wrapper wrapper) {
		wrapper.setHandler(handler);
		return wrapper;
	}
	private void customizeSsl(Server server, InetSocketAddress address) {
		Assert.state(getSsl().getServerNameBundles().isEmpty(), 'Server name SSL bundles are not supported with Jetty');
		new SslServerCustomizer(getHttp2(), address, getSsl().getClientAuth(), getSslBundle()).customize(server);
	}
	/**
	 * Configure the given Jetty {@link WebAppContext} for use.
	 * @param context the context to configure
	 * @param initializers the set of initializers to apply
	 */
	protected final void configureWebAppContext(WebAppContext context, ServletContextInitializer... initializers) {
		Assert.notNull(context, 'Context must not be null');
		context.clearAliasChecks();
		if (this.resourceLoader != null) {
			context.setClassLoader(this.resourceLoader.getClassLoader());
		}
		String contextPath = getContextPath();
		context.setContextPath(StringUtils.hasLength(contextPath) ? contextPath : '/');
		context.setDisplayName(getDisplayName());
		configureDocumentRoot(context);
		if (isRegisterDefaultServlet()) {
			addDefaultServlet(context);
		}
		if (shouldRegisterJspServlet()) {
			addJspServlet(context);
			context.addBean(new JasperInitializer(context), true);
		}
		addLocaleMappings(context);
		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
		Configuration[] configurations = getWebAppContextConfigurations(context, initializersToUse);
		context.setConfigurations(configurations);
		context.setThrowUnavailableOnStartupException(true);
		configureSession(context);
		context.setTempDirectory(getTempDirectory(context));
		postProcessWebAppContext(context);
	}
	private void configureSession(WebAppContext context) {
		SessionHandler handler = context.getSessionHandler();
		SameSite sessionSameSite = getSession().getCookie().getSameSite();
		if (sessionSameSite != null) {
			handler.setSameSite(HttpCookie.SameSite.valueOf(sessionSameSite.name()));
		}
		Duration sessionTimeout = getSession().getTimeout();
		handler.setMaxInactiveInterval(isNegative(sessionTimeout) ? -1 : (int) sessionTimeout.getSeconds());
		if (getSession().isPersistent()) {
			DefaultSessionCache cache = new DefaultSessionCache(handler);
			FileSessionDataStore store = new FileSessionDataStore();
			store.setStoreDir(getValidSessionStoreDir());
			cache.setSessionDataStore(store);
			handler.setSessionCache(cache);
		}
	}
	private boolean isNegative(Duration sessionTimeout) {
		return sessionTimeout == null || sessionTimeout.isNegative();
	}
	private void addLocaleMappings(WebAppContext context) {
		getLocaleCharsetMappings()
			.forEach((locale, charset) -> context.addLocaleEncoding(locale.toString(), charset.toString()));
	}
	private File getTempDirectory(WebAppContext context) {
		String temp = System.getProperty('java.io.tmpdir');
		return (temp != null) ? new File(temp, getTempDirectoryPrefix(context) + UUID.randomUUID()) : null;
	}
	@SuppressWarnings('removal')
	private String getTempDirectoryPrefix(WebAppContext context) {
		try {
			return ((JettyEmbeddedWebAppContext) context).getCanonicalNameForTmpDir();
		}
		catch (Throwable ex) {
			return WebInfConfiguration.getCanonicalNameForWebAppTmpDir(context);
		}
	}
	private void configureDocumentRoot(WebAppContext handler) {
		File root = getValidDocumentRoot();
		File docBase = (root != null) ? root : createTempDir('jetty-docbase');
		try {
			ResourceFactory resourceFactory = handler.getResourceFactory();
			List<Resource> resources = new ArrayList<>();
			Resource rootResource = (docBase.isDirectory()
					? resourceFactory.newResource(docBase.getCanonicalFile().toURI())
					: resourceFactory.newJarFileResource(docBase.toURI()));
			resources.add((root != null) ? new LoaderHidingResource(rootResource, rootResource) : rootResource);
			URLResourceFactory urlResourceFactory = new URLResourceFactory();
			for (URL resourceJarUrl : getUrlsOfJarsWithMetaInfResources()) {
				Resource resource = createResource(resourceJarUrl, resourceFactory, urlResourceFactory);
				if (resource != null) {
					resources.add(resource);
				}
			}
			handler.setBaseResource(ResourceFactory.combine(resources));
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	private Resource createResource(URL url, ResourceFactory resourceFactory, URLResourceFactory urlResourceFactory)
			throws Exception {
		if ('file'.equals(url.getProtocol())) {
			File file = new File(url.toURI());
			if (file.isFile()) {
				return resourceFactory.newResource('jar:' + url + '!/META-INF/resources/');
			}
			if (file.isDirectory()) {
				return resourceFactory.newResource(url).resolve('META-INF/resources/');
			}
		}
		return urlResourceFactory.newResource(url + 'META-INF/resources/');
	}
	/**
	 * Add Jetty"s {@code DefaultServlet} to the given {@link WebAppContext}.
	 * @param context the jetty {@link WebAppContext}
	 */
	protected final void addDefaultServlet(WebAppContext context) {
		Assert.notNull(context, 'Context must not be null');
		ServletHolder holder = new ServletHolder();
		holder.setName('default');
		holder.setClassName('org.eclipse.jetty.ee10.servlet.DefaultServlet');
		holder.setInitParameter('dirAllowed', 'false');
		holder.setInitOrder(1);
		context.getServletHandler().addServletWithMapping(holder, '/');
		ServletMapping servletMapping = context.getServletHandler().getServletMapping('/');
		servletMapping.setFromDefaultDescriptor(true);
	}
	/**
	 * Add Jetty"s {@code JspServlet} to the given {@link WebAppContext}.
	 * @param context the jetty {@link WebAppContext}
	 */
	protected final void addJspServlet(WebAppContext context) {
		Assert.notNull(context, 'Context must not be null');
		ServletHolder holder = new ServletHolder();
		holder.setName('jsp');
		holder.setClassName(getJsp().getClassName());
		holder.setInitParameter('fork', 'false');
		holder.setInitParameters(getJsp().getInitParameters());
		holder.setInitOrder(3);
		context.getServletHandler().addServlet(holder);
		ServletMapping mapping = new ServletMapping();
		mapping.setServletName('jsp');
		mapping.setPathSpecs(new String[] { '*.jsp', '*.jspx' });
		context.getServletHandler().addServletMapping(mapping);
	}
	/**
	 * Return the Jetty {@link Configuration}s that should be applied to the server.
	 * @param webAppContext the Jetty {@link WebAppContext}
	 * @param initializers the {@link ServletContextInitializer}s to apply
	 * @return configurations to apply
	 */
	protected Configuration[] getWebAppContextConfigurations(WebAppContext webAppContext,
			ServletContextInitializer... initializers) {
		List<Configuration> configurations = new ArrayList<>();
		configurations.add(getServletContextInitializerConfiguration(webAppContext, initializers));
		configurations.add(getErrorPageConfiguration());
		configurations.add(getMimeTypeConfiguration());
		configurations.add(new WebListenersConfiguration(getWebListenerClassNames()));
		configurations.addAll(getConfigurations());
		return configurations.toArray(new Configuration[0]);
	}
	/**
	 * Create a configuration object that adds error handlers.
	 * @return a configuration object for adding error pages
	 */
	private Configuration getErrorPageConfiguration() {
		return new AbstractConfiguration(new AbstractConfiguration.Builder()) {
			@Override
			public void configure(WebAppContext context) throws Exception {
				JettyEmbeddedErrorHandler errorHandler = new JettyEmbeddedErrorHandler();
				context.setErrorHandler(errorHandler);
				addJettyErrorPages(errorHandler, getErrorPages());
			}
		};
	}
	/**
	 * Create a configuration object that adds mime type mappings.
	 * @return a configuration object for adding mime type mappings
	 */
	private Configuration getMimeTypeConfiguration() {
		return new AbstractConfiguration(new AbstractConfiguration.Builder()) {
			@Override
			public void configure(WebAppContext context) throws Exception {
				MimeTypes.Wrapper mimeTypes = (Wrapper) context.getMimeTypes();
				mimeTypes.setWrapped(new MimeTypes(null));
				for (MimeMappings.Mapping mapping : getMimeMappings()) {
					mimeTypes.addMimeMapping(mapping.getExtension(), mapping.getMimeType());
				}
			}
		};
	}
	/**
	 * Return a Jetty {@link Configuration} that will invoke the specified
	 * {@link ServletContextInitializer}s. By default this method will return a
	 * {@link ServletContextInitializerConfiguration}.
	 * @param webAppContext the Jetty {@link WebAppContext}
	 * @param initializers the {@link ServletContextInitializer}s to apply
	 * @return the {@link Configuration} instance
	 */
	protected Configuration getServletContextInitializerConfiguration(WebAppContext webAppContext,
			ServletContextInitializer... initializers) {
		return new ServletContextInitializerConfiguration(initializers);
	}
	/**
	 * Post process the Jetty {@link WebAppContext} before it"s used with the Jetty
	 * Server. Subclasses can override this method to apply additional processing to the
	 * {@link WebAppContext}.
	 * @param webAppContext the Jetty {@link WebAppContext}
	 */
	protected void postProcessWebAppContext(WebAppContext webAppContext) {
	}
	/**
	 * Factory method called to create the {@link JettyWebServer}. Subclasses can override
	 * this method to return a different {@link JettyWebServer} or apply additional
	 * processing to the Jetty server.
	 * @param server the Jetty server.
	 * @return a new {@link JettyWebServer} instance
	 */
	protected JettyWebServer getJettyWebServer(Server server) {
		return new JettyWebServer(server, getPort() >= 0);
	}
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	@Override
	public void setUseForwardHeaders(boolean useForwardHeaders) {
		this.useForwardHeaders = useForwardHeaders;
	}
	@Override
	public void setAcceptors(int acceptors) {
		this.acceptors = acceptors;
	}
	@Override
	public void setSelectors(int selectors) {
		this.selectors = selectors;
	}
	@Override
	public void setMaxConnections(int maxConnections) {
		this.maxConnections = maxConnections;
	}
	/**
	 * Sets {@link JettyServerCustomizer}s that will be applied to the {@link Server}
	 * before it is started. Calling this method will replace any existing customizers.
	 * @param customizers the Jetty customizers to apply
	 */
	public void setServerCustomizers(Collection<? extends JettyServerCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.jettyServerCustomizers = new LinkedHashSet<>(customizers);
	}
	/**
	 * Returns a mutable collection of Jetty {@link JettyServerCustomizer}s that will be
	 * applied to the {@link Server} before it is created.
	 * @return the {@link JettyServerCustomizer}s
	 */
	public Collection<JettyServerCustomizer> getServerCustomizers() {
		return this.jettyServerCustomizers;
	}
	@Override
	public void addServerCustomizers(JettyServerCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.jettyServerCustomizers.addAll(Arrays.asList(customizers));
	}
	/**
	 * Sets Jetty {@link Configuration}s that will be applied to the {@link WebAppContext}
	 * before the server is created. Calling this method will replace any existing
	 * configurations.
	 * @param configurations the Jetty configurations to apply
	 */
	public void setConfigurations(Collection<? extends Configuration> configurations) {
		Assert.notNull(configurations, 'Configurations must not be null');
		this.configurations = new ArrayList<>(configurations);
	}
	/**
	 * Returns a mutable collection of Jetty {@link Configuration}s that will be applied
	 * to the {@link WebAppContext} before the server is created.
	 * @return the Jetty {@link Configuration}s
	 */
	public Collection<Configuration> getConfigurations() {
		return this.configurations;
	}
	/**
	 * Add {@link Configuration}s that will be applied to the {@link WebAppContext} before
	 * the server is started.
	 * @param configurations the configurations to add
	 */
	public void addConfigurations(Configuration... configurations) {
		Assert.notNull(configurations, 'Configurations must not be null');
		this.configurations.addAll(Arrays.asList(configurations));
	}
	/**
	 * Returns a Jetty {@link ThreadPool} that should be used by the {@link Server}.
	 * @return a Jetty {@link ThreadPool} or {@code null}
	 */
	public ThreadPool getThreadPool() {
		return this.threadPool;
	}
	@Override
	public void setThreadPool(ThreadPool threadPool) {
		this.threadPool = threadPool;
	}
	private void addJettyErrorPages(ErrorHandler errorHandler, Collection<ErrorPage> errorPages) {
		if (errorHandler instanceof ErrorPageErrorHandler handler) {
			for (ErrorPage errorPage : errorPages) {
				if (errorPage.isGlobal()) {
					handler.addErrorPage(ErrorPageErrorHandler.GLOBAL_ERROR_PAGE, errorPage.getPath());
				}
				else {
					if (errorPage.getExceptionName() != null) {
						handler.addErrorPage(errorPage.getExceptionName(), errorPage.getPath());
					}
					else {
						handler.addErrorPage(errorPage.getStatusCode(), errorPage.getPath());
					}
				}
			}
		}
	}
	/**
	 * {@link AbstractConfiguration} to apply {@code @WebListener} classes.
	 */
	private static class WebListenersConfiguration extends AbstractConfiguration {
		private final Set<String> classNames;
		WebListenersConfiguration(Set<String> webListenerClassNames) {
			super(new AbstractConfiguration.Builder());
			this.classNames = webListenerClassNames;
		}
		@Override
		public void configure(WebAppContext context) throws Exception {
			ServletHandler servletHandler = context.getServletHandler();
			for (String className : this.classNames) {
				configure(context, servletHandler, className);
			}
		}
		private void configure(WebAppContext context, ServletHandler servletHandler, String className)
				throws ClassNotFoundException {
			ListenerHolder holder = servletHandler.newListenerHolder(new Source(Source.Origin.ANNOTATION, className));
			holder.setHeldClass(loadClass(context, className));
			servletHandler.addListener(holder);
		}
		@SuppressWarnings('unchecked')
		private Class<? extends EventListener> loadClass(WebAppContext context, String className)
				throws ClassNotFoundException {
			ClassLoader classLoader = context.getClassLoader();
			classLoader = (classLoader != null) ? classLoader : getClass().getClassLoader();
			return (Class<? extends EventListener>) classLoader.loadClass(className);
		}
	}
	/**
	 * {@link Handler.Wrapper} to apply {@link CookieSameSiteSupplier supplied}
	 * {@link SameSite} cookie values.
	 */
	private static class SuppliedSameSiteCookieHandlerWrapper extends Handler.Wrapper {
		private static final SetCookieParser setCookieParser = SetCookieParser.newInstance();
		private final String sessionCookieName;
		private final List<CookieSameSiteSupplier> suppliers;
		SuppliedSameSiteCookieHandlerWrapper(String sessionCookieName, List<CookieSameSiteSupplier> suppliers) {
			this.sessionCookieName = sessionCookieName;
			this.suppliers = suppliers;
		}
		@Override
		public boolean handle(Request request, Response response, Callback callback) throws Exception {
			SuppliedSameSiteCookieResponse wrappedResponse = new SuppliedSameSiteCookieResponse(request, response);
			return super.handle(request, wrappedResponse, callback);
		}
		private class SuppliedSameSiteCookieResponse extends Response.Wrapper {
			private final HttpFields.Mutable wrappedHeaders;
			SuppliedSameSiteCookieResponse(Request request, Response wrapped) {
				super(request, wrapped);
				this.wrappedHeaders = new SuppliedSameSiteCookieHeaders(
						request.getConnectionMetaData().getHttpConfiguration().getResponseCookieCompliance(),
						wrapped.getHeaders());
			}
			@Override
			public Mutable getHeaders() {
				return this.wrappedHeaders;
			}
		}
		private class SuppliedSameSiteCookieHeaders extends HttpFields.Mutable.Wrapper {
			private final CookieCompliance compliance;
			SuppliedSameSiteCookieHeaders(CookieCompliance compliance, HttpFields.Mutable fields) {
				super(fields);
				this.compliance = compliance;
			}
			@Override
			public HttpField onAddField(HttpField field) {
				return (field.getHeader() != HttpHeader.SET_COOKIE) ? field : onAddSetCookieField(field);
			}
			private HttpField onAddSetCookieField(HttpField field) {
				HttpCookie cookie = setCookieParser.parse(field.getValue());
				if (cookie == null || isSessionCookie(cookie)) {
					return field;
				}
				SameSite sameSite = getSameSite(cookie);
				if (sameSite == null) {
					return field;
				}
				HttpCookie updatedCookie = buildCookieWithUpdatedSameSite(cookie, sameSite);
				return new HttpCookieUtils.SetCookieHttpField(updatedCookie, this.compliance);
			}
			private boolean isSessionCookie(HttpCookie cookie) {
				return SuppliedSameSiteCookieHandlerWrapper.this.sessionCookieName.equals(cookie.getName());
			}
			private HttpCookie buildCookieWithUpdatedSameSite(HttpCookie cookie, SameSite sameSite) {
				return HttpCookie.build(cookie)
					.sameSite(org.eclipse.jetty.http.HttpCookie.SameSite.from(sameSite.name()))
					.build();
			}
			private SameSite getSameSite(HttpCookie cookie) {
				return getSameSite(asServletCookie(cookie));
			}
			private SameSite getSameSite(Cookie cookie) {
				return SuppliedSameSiteCookieHandlerWrapper.this.suppliers.stream()
					.map((supplier) -> supplier.getSameSite(cookie))
					.filter(Objects::nonNull)
					.findFirst()
					.orElse(null);
			}
			private Cookie asServletCookie(HttpCookie cookie) {
				Cookie servletCookie = new Cookie(cookie.getName(), cookie.getValue());
				cookie.getAttributes().forEach(servletCookie::setAttribute);
				return servletCookie;
			}
		}
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class JasperInitializer extends AbstractLifeCycle {
	private static final String[] INITIALIZER_CLASSES = { 'org.eclipse.jetty.apache.jsp.JettyJasperInitializer',
			'org.apache.jasper.servlet.JasperInitializer' };
	private final WebAppContext context;
	private final ServletContainerInitializer initializer;
	JasperInitializer(WebAppContext context) {
		this.context = context;
		this.initializer = newInitializer();
	}
	private ServletContainerInitializer newInitializer() {
		for (String className : INITIALIZER_CLASSES) {
			try {
				Class<?> initializerClass = ClassUtils.forName(className, null);
				return (ServletContainerInitializer) initializerClass.getDeclaredConstructor().newInstance();
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return null;
	}
	@Override
	protected void doStart() throws Exception {
		if (this.initializer == null) {
			return;
		}
		if (ClassUtils.isPresent('org.apache.catalina.webresources.TomcatURLStreamHandlerFactory',
				getClass().getClassLoader())) {
			org.apache.catalina.webresources.TomcatURLStreamHandlerFactory.register();
		}
		else {
			try {
				URL.setURLStreamHandlerFactory(new WarUrlStreamHandlerFactory());
			}
			catch (Error ex) {
				// Ignore
			}
		}
		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
		try {
			Thread.currentThread().setContextClassLoader(this.context.getClassLoader());
			try {
				this.context.getContext().setExtendedListenerTypes(true);
				this.initializer.onStartup(null, this.context.getServletContext());
			}
			finally {
				this.context.getContext().setExtendedListenerTypes(false);
			}
		}
		finally {
			Thread.currentThread().setContextClassLoader(classLoader);
		}
	}
	/**
	 * {@link URLStreamHandlerFactory} to support {@literal war} protocol.
	 */
	private static final class WarUrlStreamHandlerFactory implements URLStreamHandlerFactory {
		@Override
		public URLStreamHandler createURLStreamHandler(String protocol) {
			if ('war'.equals(protocol)) {
				return new WarUrlStreamHandler();
			}
			return null;
		}
	}
	/**
	 * {@link URLStreamHandler} for {@literal war} protocol compatible with jasper"s
	 * {@link URL urls} produced by
	 * {@link org.apache.tomcat.util.scan.JarFactory#getJarEntryURL(URL, String)}.
	 */
	private static final class WarUrlStreamHandler extends URLStreamHandler {
		@Override
		protected void parseURL(URL u, String spec, int start, int limit) {
			String path = 'jar:' + spec.substring('war:'.length());
			int separator = path.indexOf('*/');
			if (separator >= 0) {
				path = path.substring(0, separator) + '!/' + path.substring(separator + 2);
			}
			setURL(u, u.getProtocol(), '', -1, null, null, path, null, null);
		}
		@Override
		protected URLConnection openConnection(URL u) throws IOException {
			return new WarURLConnection(u);
		}
	}
	/**
	 * {@link URLConnection} to support {@literal war} protocol.
	 */
	private static class WarURLConnection extends URLConnection {
		private final URLConnection connection;
		protected WarURLConnection(URL url) throws IOException {
			super(url);
			this.connection = new URL(url.getFile()).openConnection();
		}
		@Override
		public void connect() throws IOException {
			if (!this.connected) {
				this.connection.connect();
				this.connected = true;
			}
		}
		@Override
		public InputStream getInputStream() throws IOException {
			connect();
			return this.connection.getInputStream();
		}
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
final class LoaderHidingResource extends Resource {
	private static final String LOADER_RESOURCE_PATH_PREFIX = '/org/springframework/boot/';
	private final Path loaderBasePath;
	private final Resource base;
	private final Resource delegate;
	LoaderHidingResource(Resource base, Resource delegate) {
		this.base = base;
		this.delegate = delegate;
		this.loaderBasePath = base.getPath().getFileSystem().getPath('/', 'org', 'springframework', 'boot');
	}
	@Override
	public void forEach(Consumer<? super Resource> action) {
		this.delegate.forEach(action);
	}
	@Override
	public Path getPath() {
		return this.delegate.getPath();
	}
	@Override
	public boolean isContainedIn(Resource r) {
		return this.delegate.isContainedIn(r);
	}
	@Override
	public Iterator<Resource> iterator() {
		if (this.delegate instanceof CombinedResource) {
			return list().iterator();
		}
		return List.<Resource>of(this).iterator();
	}
	@Override
	public boolean equals(Object obj) {
		return this.delegate.equals(obj);
	}
	@Override
	public int hashCode() {
		return this.delegate.hashCode();
	}
	@Override
	public boolean exists() {
		return this.delegate.exists();
	}
	@Override
	public Spliterator<Resource> spliterator() {
		return this.delegate.spliterator();
	}
	@Override
	public boolean isDirectory() {
		return this.delegate.isDirectory();
	}
	@Override
	public boolean isReadable() {
		return this.delegate.isReadable();
	}
	@Override
	public Instant lastModified() {
		return this.delegate.lastModified();
	}
	@Override
	public long length() {
		return this.delegate.length();
	}
	@Override
	public URI getURI() {
		return this.delegate.getURI();
	}
	@Override
	public String getName() {
		return this.delegate.getName();
	}
	@Override
	public String getFileName() {
		return this.delegate.getFileName();
	}
	@Override
	public InputStream newInputStream() throws IOException {
		return this.delegate.newInputStream();
	}
	@Override
	@SuppressWarnings({ 'deprecation', 'removal' })
	public ReadableByteChannel newReadableByteChannel() throws IOException {
		return this.delegate.newReadableByteChannel();
	}
	@Override
	public List<Resource> list() {
		return asLoaderHidingResources(this.delegate.list());
	}
	private boolean nonLoaderResource(Resource resource) {
		return !resource.getPath().startsWith(this.loaderBasePath);
	}
	private List<Resource> asLoaderHidingResources(Collection<Resource> resources) {
		return resources.stream().filter(this::nonLoaderResource).map(this::asLoaderHidingResource).toList();
	}
	private Resource asLoaderHidingResource(Resource resource) {
		return (resource instanceof LoaderHidingResource) ? resource : new LoaderHidingResource(this.base, resource);
	}
	@Override
	public Resource resolve(String subUriPath) {
		if (subUriPath.startsWith(LOADER_RESOURCE_PATH_PREFIX)) {
			return null;
		}
		Resource resolved = this.delegate.resolve(subUriPath);
		return (resolved != null) ? new LoaderHidingResource(this.base, resolved) : null;
	}
	@Override
	public boolean isAlias() {
		return this.delegate.isAlias();
	}
	@Override
	public URI getRealURI() {
		return this.delegate.getRealURI();
	}
	@Override
	public void copyTo(Path destination) throws IOException {
		this.delegate.copyTo(destination);
	}
	@Override
	public Collection<Resource> getAllResources() {
		return asLoaderHidingResources(this.delegate.getAllResources());
	}
	@Override
	public String toString() {
		return this.delegate.toString();
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
final class JettyHandlerWrappers {
	private JettyHandlerWrappers() {
	}
	static Handler.Wrapper createGzipHandlerWrapper(Compression compression) {
		GzipHandler handler = new GzipHandler();
		handler.setMinGzipSize((int) compression.getMinResponseSize().toBytes());
		handler.setIncludedMimeTypes(compression.getMimeTypes());
		for (HttpMethod httpMethod : HttpMethod.values()) {
			handler.addIncludedMethods(httpMethod.name());
		}
		return handler;
	}
	static Handler.Wrapper createServerHeaderHandlerWrapper(String header) {
		return new ServerHeaderHandler(header);
	}
	/**
	 * {@link Handler.Wrapper} to add a custom {@code server} header.
	 */
	private static class ServerHeaderHandler extends Handler.Wrapper {
		private static final String SERVER_HEADER = 'server';
		private final String value;
		ServerHeaderHandler(String value) {
			this.value = value;
		}
		@Override
		public boolean handle(Request request, Response response, Callback callback) throws Exception {
			Mutable headers = response.getHeaders();
			if (!headers.contains(SERVER_HEADER)) {
				headers.add(SERVER_HEADER, this.value);
			}
			return super.handle(request, response, callback);
		}
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
final class GracefulShutdown {
	private static final Log logger = LogFactory.getLog(GracefulShutdown.class);
	private final Server server;
	private final Supplier<Integer> activeRequests;
	private volatile boolean aborted = false;
	GracefulShutdown(Server server, Supplier<Integer> activeRequests) {
		this.server = server;
		this.activeRequests = activeRequests;
	}
	void shutDownGracefully(GracefulShutdownCallback callback) {
		logger.info('Commencing graceful shutdown. Waiting for active requests to complete');
		new Thread(() -> awaitShutdown(callback), 'jetty-shutdown').start();
		boolean jetty10 = isJetty10();
		for (Connector connector : this.server.getConnectors()) {
			shutdown(connector, !jetty10);
		}
	}
	@SuppressWarnings('unchecked')
	private void shutdown(Connector connector, boolean getResult) {
		Future<Void> result;
		try {
			result = connector.shutdown();
		}
		catch (NoSuchMethodError ex) {
			Method shutdown = ReflectionUtils.findMethod(connector.getClass(), 'shutdown');
			result = (Future<Void>) ReflectionUtils.invokeMethod(shutdown, connector);
		}
		if (getResult) {
			try {
				result.get();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
			catch (ExecutionException ex) {
				// Continue
			}
		}
	}
	private boolean isJetty10() {
		try {
			return CompletableFuture.class.equals(Connector.class.getMethod('shutdown').getReturnType());
		}
		catch (Exception ex) {
			return false;
		}
	}
	private void awaitShutdown(GracefulShutdownCallback callback) {
		while (!this.aborted && this.activeRequests.get() > 0) {
			sleep(100);
		}
		if (this.aborted) {
			logger.info('Graceful shutdown aborted with one or more requests still active');
			callback.shutdownComplete(GracefulShutdownResult.REQUESTS_ACTIVE);
		}
		else {
			logger.info('Graceful shutdown complete');
			callback.shutdownComplete(GracefulShutdownResult.IDLE);
		}
	}
	private void sleep(long millis) {
		try {
			Thread.sleep(millis);
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
	void abort() {
		this.aborted = true;
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
public class JettyReactiveWebServerFactory extends AbstractReactiveWebServerFactory
		implements ConfigurableJettyWebServerFactory {
	private static final Log logger = LogFactory.getLog(JettyReactiveWebServerFactory.class);
	/**
	 * The number of acceptor threads to use.
	 */
	private int acceptors = -1;
	/**
	 * The number of selector threads to use.
	 */
	private int selectors = -1;
	private boolean useForwardHeaders;
	private Set<JettyServerCustomizer> jettyServerCustomizers = new LinkedHashSet<>();
	private JettyResourceFactory resourceFactory;
	private ThreadPool threadPool;
	private int maxConnections = -1;
	/**
	 * Create a new {@link JettyServletWebServerFactory} instance.
	 */
	public JettyReactiveWebServerFactory() {
	}
	/**
	 * Create a new {@link JettyServletWebServerFactory} that listens for requests using
	 * the specified port.
	 * @param port the port to listen on
	 */
	public JettyReactiveWebServerFactory(int port) {
		super(port);
	}
	@Override
	public void setUseForwardHeaders(boolean useForwardHeaders) {
		this.useForwardHeaders = useForwardHeaders;
	}
	@Override
	public void setAcceptors(int acceptors) {
		this.acceptors = acceptors;
	}
	@Override
	public WebServer getWebServer(HttpHandler httpHandler) {
		JettyHttpHandlerAdapter servlet = new JettyHttpHandlerAdapter(httpHandler);
		Server server = createJettyServer(servlet);
		return new JettyWebServer(server, getPort() >= 0);
	}
	@Override
	public void addServerCustomizers(JettyServerCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.jettyServerCustomizers.addAll(Arrays.asList(customizers));
	}
	@Override
	public void setMaxConnections(int maxConnections) {
		this.maxConnections = maxConnections;
	}
	/**
	 * Sets {@link JettyServerCustomizer}s that will be applied to the {@link Server}
	 * before it is started. Calling this method will replace any existing customizers.
	 * @param customizers the Jetty customizers to apply
	 */
	public void setServerCustomizers(Collection<? extends JettyServerCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.jettyServerCustomizers = new LinkedHashSet<>(customizers);
	}
	/**
	 * Returns a mutable collection of Jetty {@link JettyServerCustomizer}s that will be
	 * applied to the {@link Server} before it is created.
	 * @return the Jetty customizers
	 */
	public Collection<JettyServerCustomizer> getServerCustomizers() {
		return this.jettyServerCustomizers;
	}
	/**
	 * Returns a Jetty {@link ThreadPool} that should be used by the {@link Server}.
	 * @return a Jetty {@link ThreadPool} or {@code null}
	 */
	public ThreadPool getThreadPool() {
		return this.threadPool;
	}
	@Override
	public void setThreadPool(ThreadPool threadPool) {
		this.threadPool = threadPool;
	}
	@Override
	public void setSelectors(int selectors) {
		this.selectors = selectors;
	}
	/**
	 * Set the {@link JettyResourceFactory} to get the shared resources from.
	 * @param resourceFactory the server resources
	 * @since 2.1.0
	 */
	public void setResourceFactory(JettyResourceFactory resourceFactory) {
		this.resourceFactory = resourceFactory;
	}
	protected JettyResourceFactory getResourceFactory() {
		return this.resourceFactory;
	}
	protected Server createJettyServer(JettyHttpHandlerAdapter servlet) {
		int port = Math.max(getPort(), 0);
		InetSocketAddress address = new InetSocketAddress(getAddress(), port);
		Server server = new Server(getThreadPool());
		server.addConnector(createConnector(address, server));
		server.setStopTimeout(0);
		ServletHolder servletHolder = new ServletHolder(servlet);
		servletHolder.setAsyncSupported(true);
		ServletContextHandler contextHandler = new ServletContextHandler('/', false, false);
		contextHandler.addServlet(servletHolder, '/');
		server.setHandler(addHandlerWrappers(contextHandler));
		JettyReactiveWebServerFactory.logger.info('Server initialized with port: ' + port);
		if (this.maxConnections > -1) {
			server.addBean(new ConnectionLimit(this.maxConnections, server));
		}
		if (Ssl.isEnabled(getSsl())) {
			customizeSsl(server, address);
		}
		for (JettyServerCustomizer customizer : getServerCustomizers()) {
			customizer.customize(server);
		}
		if (this.useForwardHeaders) {
			new ForwardHeadersCustomizer().customize(server);
		}
		if (getShutdown() == Shutdown.GRACEFUL) {
			StatisticsHandler statisticsHandler = new StatisticsHandler();
			statisticsHandler.setHandler(server.getHandler());
			server.setHandler(statisticsHandler);
		}
		server.setAttribute(org.springframework.boot.web.server.WebServerFactory.class.getName(), getClass());
		return server;
	}
	private AbstractConnector createConnector(InetSocketAddress address, Server server) {
		HttpConfiguration httpConfiguration = new HttpConfiguration();
		httpConfiguration.setSendServerVersion(false);
		List<ConnectionFactory> connectionFactories = new ArrayList<>();
		connectionFactories.add(new HttpConnectionFactory(httpConfiguration));
		if (getHttp2() != null && getHttp2().isEnabled()) {
			connectionFactories.add(new HTTP2CServerConnectionFactory(httpConfiguration));
		}
		JettyResourceFactory resourceFactory = getResourceFactory();
		ServerConnector connector;
		if (resourceFactory != null) {
			connector = new ServerConnector(server, resourceFactory.getExecutor(), resourceFactory.getScheduler(),
					resourceFactory.getByteBufferPool(), this.acceptors, this.selectors,
					connectionFactories.toArray(new ConnectionFactory[0]));
		}
		else {
			connector = new ServerConnector(server, this.acceptors, this.selectors,
					connectionFactories.toArray(new ConnectionFactory[0]));
		}
		connector.setHost(address.getHostString());
		connector.setPort(address.getPort());
		return connector;
	}
	private Handler addHandlerWrappers(Handler handler) {
		if (getCompression() != null && getCompression().getEnabled()) {
			handler = applyWrapper(handler, JettyHandlerWrappers.createGzipHandlerWrapper(getCompression()));
		}
		if (StringUtils.hasText(getServerHeader())) {
			handler = applyWrapper(handler, JettyHandlerWrappers.createServerHeaderHandlerWrapper(getServerHeader()));
		}
		return handler;
	}
	private Handler applyWrapper(Handler handler, Handler.Wrapper wrapper) {
		wrapper.setHandler(handler);
		return wrapper;
	}
	private void customizeSsl(Server server, InetSocketAddress address) {
		new SslServerCustomizer(getHttp2(), address, getSsl().getClientAuth(), getSslBundle()).customize(server);
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
@FunctionalInterface
public interface JettyServerCustomizer {
	/**
	 * Customize the server.
	 * @param server the server to customize
	 */
	void customize(Server server);
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class JettyEmbeddedErrorHandler extends ErrorPageErrorHandler {
	@Override
	public boolean errorPageForMethod(String method) {
		return true;
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class JettyEmbeddedWebAppContext extends WebAppContext {
	JettyEmbeddedWebAppContext() {
		setHiddenClassMatcher(new ClassMatcher('org.springframework.boot.loader.'));
	}
	@Override
	protected ServletHandler newServletHandler() {
		return new JettyEmbeddedServletHandler();
	}
	void deferredInitialize() throws Exception {
		JettyEmbeddedServletHandler handler = (JettyEmbeddedServletHandler) getServletHandler();
		getContext().call(handler::deferredInitialize, null);
	}
	@Override
	public String getCanonicalNameForTmpDir() {
		return super.getCanonicalNameForTmpDir();
	}
	private static final class JettyEmbeddedServletHandler extends ServletHandler {
		@Override
		public void initialize() throws Exception {
		}
		void deferredInitialize() throws Exception {
			super.initialize();
		}
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class SslServerCustomizer implements JettyServerCustomizer {
	private final Http2 http2;
	private final InetSocketAddress address;
	private final ClientAuth clientAuth;
	private final SslBundle sslBundle;
	SslServerCustomizer(Http2 http2, InetSocketAddress address, ClientAuth clientAuth, SslBundle sslBundle) {
		this.address = address;
		this.clientAuth = clientAuth;
		this.sslBundle = sslBundle;
		this.http2 = http2;
	}
	@Override
	public void customize(Server server) {
		SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
		sslContextFactory.setEndpointIdentificationAlgorithm(null);
		configureSsl(sslContextFactory, this.clientAuth);
		ServerConnector connector = createConnector(server, sslContextFactory);
		server.setConnectors(new Connector[] { connector });
	}
	private ServerConnector createConnector(Server server, SslContextFactory.Server sslContextFactory) {
		HttpConfiguration config = new HttpConfiguration();
		config.setSendServerVersion(false);
		config.setSecureScheme('https');
		config.setSecurePort(this.address.getPort());
		config.addCustomizer(new SecureRequestCustomizer());
		ServerConnector connector = createServerConnector(server, sslContextFactory, config);
		connector.setPort(this.address.getPort());
		connector.setHost(this.address.getHostString());
		return connector;
	}
	private ServerConnector createServerConnector(Server server, SslContextFactory.Server sslContextFactory,
			HttpConfiguration config) {
		if (this.http2 == null || !this.http2.isEnabled()) {
			return createHttp11ServerConnector(config, sslContextFactory, server);
		}
		Assert.state(isJettyAlpnPresent(),
				() -> 'An "org.eclipse.jetty:jetty-alpn-*-server" dependency is required for HTTP/2 support.');
		Assert.state(isJettyHttp2Present(),
				() -> 'The "org.eclipse.jetty.http2:jetty-http2-server" dependency is required for HTTP/2 support.');
		return createHttp2ServerConnector(config, sslContextFactory, server);
	}
	private ServerConnector createHttp11ServerConnector(HttpConfiguration config,
			SslContextFactory.Server sslContextFactory, Server server) {
		SslConnectionFactory sslConnectionFactory = createSslConnectionFactory(sslContextFactory,
				HttpVersion.HTTP_1_1.asString());
		HttpConnectionFactory connectionFactory = new HttpConnectionFactory(config);
		return new SslValidatingServerConnector(this.sslBundle.getKey(), sslContextFactory, server,
				sslConnectionFactory, connectionFactory);
	}
	private SslConnectionFactory createSslConnectionFactory(SslContextFactory.Server sslContextFactory,
			String protocol) {
		return new SslConnectionFactory(sslContextFactory, protocol);
	}
	private boolean isJettyAlpnPresent() {
		return ClassUtils.isPresent('org.eclipse.jetty.alpn.server.ALPNServerConnectionFactory', null);
	}
	private boolean isJettyHttp2Present() {
		return ClassUtils.isPresent('org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory', null);
	}
	private ServerConnector createHttp2ServerConnector(HttpConfiguration config,
			SslContextFactory.Server sslContextFactory, Server server) {
		HttpConnectionFactory http = new HttpConnectionFactory(config);
		HTTP2ServerConnectionFactory h2 = new HTTP2ServerConnectionFactory(config);
		ALPNServerConnectionFactory alpn = createAlpnServerConnectionFactory();
		sslContextFactory.setCipherComparator(HTTP2Cipher.COMPARATOR);
		if (isConscryptPresent()) {
			sslContextFactory.setProvider('Conscrypt');
		}
		SslConnectionFactory sslConnectionFactory = createSslConnectionFactory(sslContextFactory, alpn.getProtocol());
		return new SslValidatingServerConnector(this.sslBundle.getKey(), sslContextFactory, server,
				sslConnectionFactory, alpn, h2, http);
	}
	private ALPNServerConnectionFactory createAlpnServerConnectionFactory() {
		try {
			return new ALPNServerConnectionFactory();
		}
		catch (IllegalStateException ex) {
			throw new IllegalStateException(
					'An "org.eclipse.jetty:jetty-alpn-*-server" dependency is required for HTTP/2 support.', ex);
		}
	}
	private boolean isConscryptPresent() {
		return ClassUtils.isPresent('org.conscrypt.Conscrypt', null)
				&& ClassUtils.isPresent('org.eclipse.jetty.alpn.conscrypt.server.ConscryptServerALPNProcessor', null);
	}
	/**
	 * Configure the SSL connection.
	 * @param factory the Jetty {@link Server SslContextFactory.Server}.
	 * @param clientAuth the client authentication mode
	 */
	protected void configureSsl(SslContextFactory.Server factory, ClientAuth clientAuth) {
		SslBundleKey key = this.sslBundle.getKey();
		SslOptions options = this.sslBundle.getOptions();
		SslStoreBundle stores = this.sslBundle.getStores();
		factory.setProtocol(this.sslBundle.getProtocol());
		configureSslClientAuth(factory, clientAuth);
		if (stores.getKeyStorePassword() != null) {
			factory.setKeyStorePassword(stores.getKeyStorePassword());
		}
		factory.setCertAlias(key.getAlias());
		if (options.getCiphers() != null) {
			factory.setIncludeCipherSuites(options.getCiphers());
			factory.setExcludeCipherSuites();
		}
		if (options.getEnabledProtocols() != null) {
			factory.setIncludeProtocols(options.getEnabledProtocols());
			factory.setExcludeProtocols();
		}
		try {
			if (key.getPassword() != null) {
				factory.setKeyManagerPassword(key.getPassword());
			}
			factory.setKeyStore(stores.getKeyStore());
			factory.setTrustStore(stores.getTrustStore());
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to set SSL store: ' + ex.getMessage(), ex);
		}
	}
	private void configureSslClientAuth(SslContextFactory.Server factory, ClientAuth clientAuth) {
		factory.setWantClientAuth(clientAuth == ClientAuth.WANT || clientAuth == ClientAuth.NEED);
		factory.setNeedClientAuth(clientAuth == ClientAuth.NEED);
	}
	/**
	 * A {@link ServerConnector} that validates the ssl key alias on server startup.
	 */
	static class SslValidatingServerConnector extends ServerConnector {
		private final SslBundleKey key;
		private final SslContextFactory sslContextFactory;
		SslValidatingServerConnector(SslBundleKey key, SslContextFactory sslContextFactory, Server server,
				SslConnectionFactory sslConnectionFactory, HttpConnectionFactory connectionFactory) {
			super(server, sslConnectionFactory, connectionFactory);
			this.key = key;
			this.sslContextFactory = sslContextFactory;
		}
		SslValidatingServerConnector(SslBundleKey keyAlias, SslContextFactory sslContextFactory, Server server,
				ConnectionFactory... factories) {
			super(server, factories);
			this.key = keyAlias;
			this.sslContextFactory = sslContextFactory;
		}
		@Override
		protected void doStart() throws Exception {
			super.doStart();
			this.key.assertContainsAlias(this.sslContextFactory.getKeyStore());
		}
	}
}
/*
/**
package org.springframework.boot.web.embedded.jetty;
/*
package org.springframework.boot.web.embedded.jetty;
/**
public class ServletContextInitializerConfiguration extends AbstractConfiguration {
	private final ServletContextInitializer[] initializers;
	/**
	 * Create a new {@link ServletContextInitializerConfiguration}.
	 * @param initializers the initializers that should be invoked
	 * @since 1.2.1
	 */
	public ServletContextInitializerConfiguration(ServletContextInitializer... initializers) {
		super(new AbstractConfiguration.Builder());
		Assert.notNull(initializers, 'Initializers must not be null');
		this.initializers = initializers;
	}
	@Override
	public void configure(WebAppContext context) throws Exception {
		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(context.getClassLoader());
		try {
			callInitializers(context);
		}
		finally {
			Thread.currentThread().setContextClassLoader(classLoader);
		}
	}
	private void callInitializers(WebAppContext context) throws ServletException {
		try {
			context.getContext().setExtendedListenerTypes(true);
			for (ServletContextInitializer initializer : this.initializers) {
				initializer.onStartup(context.getServletContext());
			}
		}
		finally {
			context.getContext().setExtendedListenerTypes(false);
		}
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
@FunctionalInterface
public interface TomcatContextCustomizer {
	/**
	 * Customize the context.
	 * @param context the context to customize
	 */
	void customize(Context context);
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
final class TldPatterns {
	static final Set<String> TOMCAT_SKIP;
	static {
		// Same as Tomcat
		Set<String> skipPatterns = new LinkedHashSet<>();
		skipPatterns.add('annotations-api.jar');
		skipPatterns.add('ant-junit*.jar');
		skipPatterns.add('ant-launcher*.jar');
		skipPatterns.add('ant*.jar');
		skipPatterns.add('asm-*.jar');
		skipPatterns.add('aspectj*.jar');
		skipPatterns.add('bcel*.jar');
		skipPatterns.add('biz.aQute.bnd*.jar');
		skipPatterns.add('bootstrap.jar');
		skipPatterns.add('catalina-ant.jar');
		skipPatterns.add('catalina-ha.jar');
		skipPatterns.add('catalina-ssi.jar');
		skipPatterns.add('catalina-storeconfig.jar');
		skipPatterns.add('catalina-tribes.jar');
		skipPatterns.add('catalina.jar');
		skipPatterns.add('cglib-*.jar');
		skipPatterns.add('cobertura-*.jar');
		skipPatterns.add('commons-beanutils*.jar');
		skipPatterns.add('commons-codec*.jar');
		skipPatterns.add('commons-collections*.jar');
		skipPatterns.add('commons-compress*.jar');
		skipPatterns.add('commons-daemon.jar');
		skipPatterns.add('commons-dbcp*.jar');
		skipPatterns.add('commons-digester*.jar');
		skipPatterns.add('commons-fileupload*.jar');
		skipPatterns.add('commons-httpclient*.jar');
		skipPatterns.add('commons-io*.jar');
		skipPatterns.add('commons-lang*.jar');
		skipPatterns.add('commons-logging*.jar');
		skipPatterns.add('commons-math*.jar');
		skipPatterns.add('commons-pool*.jar');
		skipPatterns.add('derby-*.jar');
		skipPatterns.add('dom4j-*.jar');
		skipPatterns.add('easymock-*.jar');
		skipPatterns.add('ecj-*.jar');
		skipPatterns.add('el-api.jar');
		skipPatterns.add('geronimo-spec-jaxrpc*.jar');
		skipPatterns.add('h2*.jar');
		skipPatterns.add('ha-api-*.jar');
		skipPatterns.add('hamcrest-*.jar');
		skipPatterns.add('hibernate*.jar');
		skipPatterns.add('httpclient*.jar');
		skipPatterns.add('icu4j-*.jar');
		skipPatterns.add('jakartaee-migration-*.jar');
		skipPatterns.add('jasper-el.jar');
		skipPatterns.add('jasper.jar');
		skipPatterns.add('jaspic-api.jar');
		skipPatterns.add('jaxb-*.jar');
		skipPatterns.add('jaxen-*.jar');
		skipPatterns.add('jaxws-rt-*.jar');
		skipPatterns.add('jdom-*.jar');
		skipPatterns.add('jetty-*.jar');
		skipPatterns.add('jmx-tools.jar');
		skipPatterns.add('jmx.jar');
		skipPatterns.add('jsp-api.jar');
		skipPatterns.add('jstl.jar');
		skipPatterns.add('jta*.jar');
		skipPatterns.add('junit-*.jar');
		skipPatterns.add('junit.jar');
		skipPatterns.add('log4j*.jar');
		skipPatterns.add('mail*.jar');
		skipPatterns.add('objenesis-*.jar');
		skipPatterns.add('oraclepki.jar');
		skipPatterns.add('org.hamcrest.core_*.jar');
		skipPatterns.add('org.junit_*.jar');
		skipPatterns.add('oro-*.jar');
		skipPatterns.add('servlet-api-*.jar');
		skipPatterns.add('servlet-api.jar');
		skipPatterns.add('slf4j*.jar');
		skipPatterns.add('taglibs-standard-spec-*.jar');
		skipPatterns.add('tagsoup-*.jar');
		skipPatterns.add('tomcat-api.jar');
		skipPatterns.add('tomcat-coyote.jar');
		skipPatterns.add('tomcat-coyote-ffm.jar');
		skipPatterns.add('tomcat-dbcp.jar');
		skipPatterns.add('tomcat-i18n-*.jar');
		skipPatterns.add('tomcat-jdbc.jar');
		skipPatterns.add('tomcat-jni.jar');
		skipPatterns.add('tomcat-juli-adapters.jar');
		skipPatterns.add('tomcat-juli.jar');
		skipPatterns.add('tomcat-util-scan.jar');
		skipPatterns.add('tomcat-util.jar');
		skipPatterns.add('tomcat-websocket.jar');
		skipPatterns.add('tools.jar');
		skipPatterns.add('unboundid-ldapsdk-*.jar');
		skipPatterns.add('websocket-api.jar');
		skipPatterns.add('websocket-client-api.jar');
		skipPatterns.add('wsdl4j*.jar');
		skipPatterns.add('xercesImpl.jar');
		skipPatterns.add('xml-apis.jar');
		skipPatterns.add('xmlParserAPIs-*.jar');
		skipPatterns.add('xmlParserAPIs.jar');
		skipPatterns.add('xom-*.jar');
		TOMCAT_SKIP = Collections.unmodifiableSet(skipPatterns);
	}
	private static final Set<String> ADDITIONAL_SKIP;
	static {
		// Additional typical for Spring Boot applications
		Set<String> skipPatterns = new LinkedHashSet<>();
		skipPatterns.add('antlr-*.jar');
		skipPatterns.add('aopalliance-*.jar');
		skipPatterns.add('aspectjweaver-*.jar');
		skipPatterns.add('classmate-*.jar');
		skipPatterns.add('ehcache-core-*.jar');
		skipPatterns.add('hsqldb-*.jar');
		skipPatterns.add('jackson-annotations-*.jar');
		skipPatterns.add('jackson-core-*.jar');
		skipPatterns.add('jackson-databind-*.jar');
		skipPatterns.add('jandex-*.jar');
		skipPatterns.add('javassist-*.jar');
		skipPatterns.add('jboss-logging-*.jar');
		skipPatterns.add('jboss-transaction-api_*.jar');
		skipPatterns.add('jcl-over-slf4j-*.jar');
		skipPatterns.add('jdom-*.jar');
		skipPatterns.add('jul-to-slf4j-*.jar');
		skipPatterns.add('logback-classic-*.jar');
		skipPatterns.add('logback-core-*.jar');
		skipPatterns.add('rome-*.jar');
		skipPatterns.add('spring-aop-*.jar');
		skipPatterns.add('spring-aspects-*.jar');
		skipPatterns.add('spring-beans-*.jar');
		skipPatterns.add('spring-boot-*.jar');
		skipPatterns.add('spring-core-*.jar');
		skipPatterns.add('spring-context-*.jar');
		skipPatterns.add('spring-data-*.jar');
		skipPatterns.add('spring-expression-*.jar');
		skipPatterns.add('spring-jdbc-*.jar,');
		skipPatterns.add('spring-orm-*.jar');
		skipPatterns.add('spring-oxm-*.jar');
		skipPatterns.add('spring-tx-*.jar');
		skipPatterns.add('snakeyaml-*.jar');
		skipPatterns.add('tomcat-embed-core-*.jar');
		skipPatterns.add('tomcat-embed-logging-*.jar');
		skipPatterns.add('tomcat-embed-el-*.jar');
		skipPatterns.add('validation-api-*.jar');
		ADDITIONAL_SKIP = Collections.unmodifiableSet(skipPatterns);
	}
	static final Set<String> DEFAULT_SKIP;
	static {
		Set<String> skipPatterns = new LinkedHashSet<>();
		skipPatterns.addAll(TOMCAT_SKIP);
		skipPatterns.addAll(ADDITIONAL_SKIP);
		DEFAULT_SKIP = Collections.unmodifiableSet(skipPatterns);
	}
	static final Set<String> TOMCAT_SCAN;
	static {
		Set<String> scanPatterns = new LinkedHashSet<>();
		scanPatterns.add('log4j-taglib*.jar');
		scanPatterns.add('log4j-jakarta-web*.jar');
		scanPatterns.add('log4javascript*.jar');
		scanPatterns.add('slf4j-taglib*.jar');
		TOMCAT_SCAN = Collections.unmodifiableSet(scanPatterns);
	}
	static final Set<String> DEFAULT_SCAN;
	static {
		Set<String> scanPatterns = new LinkedHashSet<>(TOMCAT_SCAN);
		DEFAULT_SCAN = Collections.unmodifiableSet(scanPatterns);
	}
	private TldPatterns() {
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
public class TomcatWebServer implements WebServer {
	private static final Log logger = LogFactory.getLog(TomcatWebServer.class);
	private static final AtomicInteger containerCounter = new AtomicInteger(-1);
	private final Object monitor = new Object();
	private final Map<Service, Connector[]> serviceConnectors = new HashMap<>();
	private final Tomcat tomcat;
	private final boolean autoStart;
	private final GracefulShutdown gracefulShutdown;
	private volatile boolean started;
	/**
	 * Create a new {@link TomcatWebServer} instance.
	 * @param tomcat the underlying Tomcat server
	 */
	public TomcatWebServer(Tomcat tomcat) {
		this(tomcat, true);
	}
	/**
	 * Create a new {@link TomcatWebServer} instance.
	 * @param tomcat the underlying Tomcat server
	 * @param autoStart if the server should be started
	 */
	public TomcatWebServer(Tomcat tomcat, boolean autoStart) {
		this(tomcat, autoStart, Shutdown.IMMEDIATE);
	}
	/**
	 * Create a new {@link TomcatWebServer} instance.
	 * @param tomcat the underlying Tomcat server
	 * @param autoStart if the server should be started
	 * @param shutdown type of shutdown supported by the server
	 * @since 2.3.0
	 */
	public TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) {
		Assert.notNull(tomcat, 'Tomcat Server must not be null');
		this.tomcat = tomcat;
		this.autoStart = autoStart;
		this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(tomcat) : null;
		initialize();
	}
	private void initialize() throws WebServerException {
		logger.info('Tomcat initialized with ' + getPortsDescription(false));
		synchronized (this.monitor) {
			try {
				addInstanceIdToEngineName();
				Context context = findContext();
				context.addLifecycleListener((event) -> {
					if (context.equals(event.getSource()) && Lifecycle.START_EVENT.equals(event.getType())) {
						// Remove service connectors so that protocol binding doesn"t
						// happen when the service is started.
						removeServiceConnectors();
					}
				});
				disableBindOnInit();
				// Start the server to trigger initialization listeners
				this.tomcat.start();
				// We can re-throw failure exception directly in the main thread
				rethrowDeferredStartupExceptions();
				try {
					ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
				}
				catch (NamingException ex) {
					// Naming is not enabled. Continue
				}
				// Unlike Jetty, all Tomcat threads are daemon threads. We create a
				// blocking non-daemon to stop immediate shutdown
				startNonDaemonAwaitThread();
			}
			catch (Exception ex) {
				stopSilently();
				destroySilently();
				throw new WebServerException('Unable to start embedded Tomcat', ex);
			}
		}
	}
	private Context findContext() {
		for (Container child : this.tomcat.getHost().findChildren()) {
			if (child instanceof Context context) {
				return context;
			}
		}
		throw new IllegalStateException('The host does not contain a Context');
	}
	private void addInstanceIdToEngineName() {
		int instanceId = containerCounter.incrementAndGet();
		if (instanceId > 0) {
			Engine engine = this.tomcat.getEngine();
			engine.setName(engine.getName() + '-' + instanceId);
		}
	}
	private void removeServiceConnectors() {
		doWithConnectors((service, connectors) -> {
			this.serviceConnectors.put(service, connectors);
			for (Connector connector : connectors) {
				service.removeConnector(connector);
			}
		});
	}
	private void disableBindOnInit() {
		doWithConnectors((service, connectors) -> {
			for (Connector connector : connectors) {
				Object bindOnInit = connector.getProperty('bindOnInit');
				if (bindOnInit == null) {
					connector.setProperty('bindOnInit', 'false');
				}
			}
		});
	}
	private void doWithConnectors(BiConsumer<Service, Connector[]> consumer) {
		for (Service service : this.tomcat.getServer().findServices()) {
			Connector[] connectors = service.findConnectors().clone();
			consumer.accept(service, connectors);
		}
	}
	private void rethrowDeferredStartupExceptions() throws Exception {
		Container[] children = this.tomcat.getHost().findChildren();
		for (Container container : children) {
			if (container instanceof TomcatEmbeddedContext embeddedContext) {
				TomcatStarter tomcatStarter = embeddedContext.getStarter();
				if (tomcatStarter != null) {
					Exception exception = tomcatStarter.getStartUpException();
					if (exception != null) {
						throw exception;
					}
				}
			}
			if (!LifecycleState.STARTED.equals(container.getState())) {
				throw new IllegalStateException(container + ' failed to start');
			}
		}
	}
	private void startNonDaemonAwaitThread() {
		Thread awaitThread = new Thread('container-' + (containerCounter.get())) {
			@Override
			public void run() {
				TomcatWebServer.this.tomcat.getServer().await();
			}
		};
		awaitThread.setContextClassLoader(getClass().getClassLoader());
		awaitThread.setDaemon(false);
		awaitThread.start();
	}
	@Override
	public void start() throws WebServerException {
		synchronized (this.monitor) {
			if (this.started) {
				return;
			}
			try {
				addPreviouslyRemovedConnectors();
				Connector connector = this.tomcat.getConnector();
				if (connector != null && this.autoStart) {
					performDeferredLoadOnStartup();
				}
				checkThatConnectorsHaveStarted();
				this.started = true;
				logger.info(getStartedLogMessage());
			}
			catch (ConnectorStartFailedException ex) {
				stopSilently();
				throw ex;
			}
			catch (Exception ex) {
				PortInUseException.throwIfPortBindingException(ex, () -> this.tomcat.getConnector().getPort());
				throw new WebServerException('Unable to start embedded Tomcat server', ex);
			}
			finally {
				Context context = findContext();
				ContextBindings.unbindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
			}
		}
	}
	String getStartedLogMessage() {
		String contextPath = getContextPath();
		return 'Tomcat started on ' + getPortsDescription(true)
				+ ((contextPath != null) ? ' with context path "' + contextPath + '"' : '');
	}
	private void checkThatConnectorsHaveStarted() {
		checkConnectorHasStarted(this.tomcat.getConnector());
		for (Connector connector : this.tomcat.getService().findConnectors()) {
			checkConnectorHasStarted(connector);
		}
	}
	private void checkConnectorHasStarted(Connector connector) {
		if (LifecycleState.FAILED.equals(connector.getState())) {
			throw new ConnectorStartFailedException(connector.getPort());
		}
	}
	private void stopSilently() {
		try {
			stopTomcat();
		}
		catch (LifecycleException ex) {
			// Ignore
		}
	}
	private void destroySilently() {
		try {
			this.tomcat.destroy();
		}
		catch (LifecycleException ex) {
			// Ignore
		}
	}
	private void stopTomcat() throws LifecycleException {
		if (Thread.currentThread().getContextClassLoader() instanceof TomcatEmbeddedWebappClassLoader) {
			Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
		}
		this.tomcat.stop();
	}
	private void addPreviouslyRemovedConnectors() {
		Service[] services = this.tomcat.getServer().findServices();
		for (Service service : services) {
			Connector[] connectors = this.serviceConnectors.get(service);
			if (connectors != null) {
				for (Connector connector : connectors) {
					service.addConnector(connector);
					if (!this.autoStart) {
						stopProtocolHandler(connector);
					}
				}
				this.serviceConnectors.remove(service);
			}
		}
	}
	private void stopProtocolHandler(Connector connector) {
		try {
			connector.getProtocolHandler().stop();
		}
		catch (Exception ex) {
			logger.error('Cannot pause connector: ', ex);
		}
	}
	private void performDeferredLoadOnStartup() {
		try {
			for (Container child : this.tomcat.getHost().findChildren()) {
				if (child instanceof TomcatEmbeddedContext embeddedContext) {
					embeddedContext.deferredLoadOnStartup();
				}
			}
		}
		catch (Exception ex) {
			if (ex instanceof WebServerException webServerException) {
				throw webServerException;
			}
			throw new WebServerException('Unable to start embedded Tomcat connectors', ex);
		}
	}
	Map<Service, Connector[]> getServiceConnectors() {
		return this.serviceConnectors;
	}
	@Override
	public void stop() throws WebServerException {
		synchronized (this.monitor) {
			boolean wasStarted = this.started;
			try {
				this.started = false;
				if (this.gracefulShutdown != null) {
					this.gracefulShutdown.abort();
				}
				removeServiceConnectors();
			}
			catch (Exception ex) {
				throw new WebServerException('Unable to stop embedded Tomcat', ex);
			}
			finally {
				if (wasStarted) {
					containerCounter.decrementAndGet();
				}
			}
		}
	}
	@Override
	public void destroy() throws WebServerException {
		try {
			stopTomcat();
			this.tomcat.destroy();
		}
		catch (LifecycleException ex) {
			// Swallow and continue
		}
		catch (Exception ex) {
			throw new WebServerException('Unable to destroy embedded Tomcat', ex);
		}
	}
	private String getPortsDescription(boolean localPort) {
		StringBuilder description = new StringBuilder();
		Connector[] connectors = this.tomcat.getService().findConnectors();
		description.append('port');
		if (connectors.length != 1) {
			description.append('s');
		}
		description.append(' ');
		for (int i = 0; i < connectors.length; i++) {
			if (i != 0) {
				description.append(', ');
			}
			Connector connector = connectors[i];
			int port = localPort ? connector.getLocalPort() : connector.getPort();
			description.append(port).append(' (').append(connector.getScheme()).append(")");
		}
		return description.toString();
	}
	@Override
	public int getPort() {
		Connector connector = this.tomcat.getConnector();
		if (connector != null) {
			return connector.getLocalPort();
		}
		return -1;
	}
	private String getContextPath() {
		String contextPath = Arrays.stream(this.tomcat.getHost().findChildren())
			.filter(TomcatEmbeddedContext.class::isInstance)
			.map(TomcatEmbeddedContext.class::cast)
			.filter(this::imperative)
			.map(TomcatEmbeddedContext::getPath)
			.map((path) -> path.isEmpty() ? '/' : path)
			.collect(Collectors.joining(' '));
		return StringUtils.hasText(contextPath) ? contextPath : null;
	}
	private boolean imperative(TomcatEmbeddedContext context) {
		for (Container container : context.findChildren()) {
			if (container instanceof Wrapper wrapper) {
				if (wrapper.getServletClass()
					.equals('org.springframework.http.server.reactive.TomcatHttpHandlerAdapter')) {
					return false;
				}
			}
		}
		return true;
	}
	/**
	 * Returns access to the underlying Tomcat server.
	 * @return the Tomcat server
	 */
	public Tomcat getTomcat() {
		return this.tomcat;
	}
	/**
	 * Initiates a graceful shutdown of the Tomcat web server. Handling of new requests is
	 * prevented and the given {@code callback} is invoked at the end of the attempt. The
	 * attempt can be explicitly ended by invoking {@link #stop}.
	 * <p>
	 * Once shutdown has been initiated Tomcat will reject any new connections. Requests
	 * on existing idle connections will also be rejected.
	 */
	@Override
	public void shutDownGracefully(GracefulShutdownCallback callback) {
		if (this.gracefulShutdown == null) {
			callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE);
			return;
		}
		this.gracefulShutdown.shutDownGracefully(callback);
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class CompressionConnectorCustomizer implements TomcatConnectorCustomizer {
	private final Compression compression;
	CompressionConnectorCustomizer(Compression compression) {
		this.compression = compression;
	}
	@Override
	public void customize(Connector connector) {
		if (this.compression != null && this.compression.getEnabled()) {
			ProtocolHandler handler = connector.getProtocolHandler();
			if (handler instanceof AbstractHttp11Protocol<?> abstractHttp11Protocol) {
				customize(abstractHttp11Protocol);
			}
		}
	}
	private void customize(AbstractHttp11Protocol<?> protocol) {
		Compression compression = this.compression;
		protocol.setCompression('on');
		protocol.setCompressionMinSize(getMinResponseSize(compression));
		protocol.setCompressibleMimeType(getMimeTypes(compression));
		if (this.compression.getExcludedUserAgents() != null) {
			protocol.setNoCompressionUserAgents(getExcludedUserAgents());
		}
	}
	private int getMinResponseSize(Compression compression) {
		return (int) compression.getMinResponseSize().toBytes();
	}
	private String getMimeTypes(Compression compression) {
		return StringUtils.arrayToCommaDelimitedString(compression.getMimeTypes());
	}
	private String getExcludedUserAgents() {
		return StringUtils.arrayToCommaDelimitedString(this.compression.getExcludedUserAgents());
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class DisableReferenceClearingContextCustomizer implements TomcatContextCustomizer {
	@Override
	public void customize(Context context) {
		if (!(context instanceof StandardContext standardContext)) {
			return;
		}
		try {
			standardContext.setClearReferencesObjectStreamClassCaches(false);
			standardContext.setClearReferencesRmiTargets(false);
			standardContext.setClearReferencesThreadLocals(false);
		}
		catch (NoSuchMethodError ex) {
			// Earlier version of Tomcat (probably without
			// setClearReferencesThreadLocals). Continue.
		}
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class TomcatStarter implements ServletContainerInitializer {
	private static final Log logger = LogFactory.getLog(TomcatStarter.class);
	private final ServletContextInitializer[] initializers;
	private volatile Exception startUpException;
	TomcatStarter(ServletContextInitializer[] initializers) {
		this.initializers = initializers;
	}
	@Override
	public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
		try {
			for (ServletContextInitializer initializer : this.initializers) {
				initializer.onStartup(servletContext);
			}
		}
		catch (Exception ex) {
			this.startUpException = ex;
			// Prevent Tomcat from logging and re-throwing when we know we can
			// deal with it in the main thread, but log for information here.
			if (logger.isErrorEnabled()) {
				logger.error('Error starting Tomcat context. Exception: ' + ex.getClass().getName() + '. Message: '
						+ ex.getMessage());
			}
		}
	}
	Exception getStartUpException() {
		return this.startUpException;
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
@FunctionalInterface
public interface TomcatConnectorCustomizer {
	/**
	 * Customize the connector.
	 * @param connector the connector to customize
	 */
	void customize(Connector connector);
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
public class TomcatEmbeddedWebappClassLoader extends ParallelWebappClassLoader {
	private static final Log logger = LogFactory.getLog(TomcatEmbeddedWebappClassLoader.class);
	static {
		if (!JreCompat.isGraalAvailable()) {
			ClassLoader.registerAsParallelCapable();
		}
	}
	public TomcatEmbeddedWebappClassLoader() {
	}
	public TomcatEmbeddedWebappClassLoader(ClassLoader parent) {
		super(parent);
	}
	@Override
	public URL findResource(String name) {
		return null;
	}
	@Override
	public Enumeration<URL> findResources(String name) throws IOException {
		return Collections.emptyEnumeration();
	}
	@Override
	public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		synchronized (JreCompat.isGraalAvailable() ? this : getClassLoadingLock(name)) {
			Class<?> result = findExistingLoadedClass(name);
			result = (result != null) ? result : doLoadClass(name);
			if (result == null) {
				throw new ClassNotFoundException(name);
			}
			return resolveIfNecessary(result, resolve);
		}
	}
	private Class<?> findExistingLoadedClass(String name) {
		Class<?> resultClass = findLoadedClass0(name);
		resultClass = (resultClass != null || JreCompat.isGraalAvailable()) ? resultClass : findLoadedClass(name);
		return resultClass;
	}
	private Class<?> doLoadClass(String name) {
		if ((this.delegate || filter(name, true))) {
			Class<?> result = loadFromParent(name);
			return (result != null) ? result : findClassIgnoringNotFound(name);
		}
		Class<?> result = findClassIgnoringNotFound(name);
		return (result != null) ? result : loadFromParent(name);
	}
	private Class<?> resolveIfNecessary(Class<?> resultClass, boolean resolve) {
		if (resolve) {
			resolveClass(resultClass);
		}
		return (resultClass);
	}
	@Override
	protected void addURL(URL url) {
		// Ignore URLs added by the Tomcat 8 implementation (see gh-919)
		if (logger.isTraceEnabled()) {
			logger.trace('Ignoring request to add ' + url + ' to the tomcat classloader');
		}
	}
	private Class<?> loadFromParent(String name) {
		if (this.parent == null) {
			return null;
		}
		try {
			return Class.forName(name, false, this.parent);
		}
		catch (ClassNotFoundException ex) {
			return null;
		}
	}
	private Class<?> findClassIgnoringNotFound(String name) {
		try {
			return findClass(name);
		}
		catch (ClassNotFoundException ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
final class GracefulShutdown {
	private static final Log logger = LogFactory.getLog(GracefulShutdown.class);
	private final Tomcat tomcat;
	private volatile boolean aborted = false;
	GracefulShutdown(Tomcat tomcat) {
		this.tomcat = tomcat;
	}
	void shutDownGracefully(GracefulShutdownCallback callback) {
		logger.info('Commencing graceful shutdown. Waiting for active requests to complete');
		CountDownLatch shutdownUnderway = new CountDownLatch(1);
		new Thread(() -> doShutdown(callback, shutdownUnderway), 'tomcat-shutdown').start();
		try {
			shutdownUnderway.await();
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
	private void doShutdown(GracefulShutdownCallback callback, CountDownLatch shutdownUnderway) {
		try {
			List<Connector> connectors = getConnectors();
			connectors.forEach(this::close);
			shutdownUnderway.countDown();
			awaitInactiveOrAborted();
			if (this.aborted) {
				logger.info('Graceful shutdown aborted with one or more requests still active');
				callback.shutdownComplete(GracefulShutdownResult.REQUESTS_ACTIVE);
			}
			else {
				logger.info('Graceful shutdown complete');
				callback.shutdownComplete(GracefulShutdownResult.IDLE);
			}
		}
		finally {
			shutdownUnderway.countDown();
		}
	}
	private List<Connector> getConnectors() {
		List<Connector> connectors = new ArrayList<>();
		for (Service service : this.tomcat.getServer().findServices()) {
			Collections.addAll(connectors, service.findConnectors());
		}
		return connectors;
	}
	private void close(Connector connector) {
		connector.pause();
		connector.getProtocolHandler().closeServerSocketGraceful();
	}
	private void awaitInactiveOrAborted() {
		try {
			for (Container host : this.tomcat.getEngine().findChildren()) {
				for (Container context : host.findChildren()) {
					while (!this.aborted && isActive(context)) {
						Thread.sleep(50);
					}
				}
			}
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
	private boolean isActive(Container context) {
		try {
			if (((StandardContext) context).getInProgressAsyncCount() > 0) {
				return true;
			}
			for (Container wrapper : context.findChildren()) {
				if (((StandardWrapper) wrapper).getCountAllocated() > 0) {
					return true;
				}
			}
			return false;
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	void abort() {
		this.aborted = true;
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
public class TomcatReactiveWebServerFactory extends AbstractReactiveWebServerFactory
		implements ConfigurableTomcatWebServerFactory {
	private static final Log logger = LogFactory.getLog(TomcatReactiveWebServerFactory.class);
	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	/**
	 * The class name of default protocol used.
	 */
	public static final String DEFAULT_PROTOCOL = 'org.apache.coyote.http11.Http11NioProtocol';
	private File baseDirectory;
	private final List<Valve> engineValves = new ArrayList<>();
	private List<LifecycleListener> contextLifecycleListeners = new ArrayList<>();
	private final List<LifecycleListener> serverLifecycleListeners = getDefaultServerLifecycleListeners();
	private Set<TomcatContextCustomizer> tomcatContextCustomizers = new LinkedHashSet<>();
	private Set<TomcatConnectorCustomizer> tomcatConnectorCustomizers = new LinkedHashSet<>();
	private Set<TomcatProtocolHandlerCustomizer<?>> tomcatProtocolHandlerCustomizers = new LinkedHashSet<>();
	private final List<Connector> additionalTomcatConnectors = new ArrayList<>();
	private String protocol = DEFAULT_PROTOCOL;
	private Charset uriEncoding = DEFAULT_CHARSET;
	private int backgroundProcessorDelay;
	private boolean disableMBeanRegistry = true;
	/**
	 * Create a new {@link TomcatReactiveWebServerFactory} instance.
	 */
	public TomcatReactiveWebServerFactory() {
	}
	/**
	 * Create a new {@link TomcatReactiveWebServerFactory} that listens for requests using
	 * the specified port.
	 * @param port the port to listen on
	 */
	public TomcatReactiveWebServerFactory(int port) {
		super(port);
	}
	private static List<LifecycleListener> getDefaultServerLifecycleListeners() {
		AprLifecycleListener aprLifecycleListener = new AprLifecycleListener();
		return AprLifecycleListener.isAprAvailable() ? new ArrayList<>(Arrays.asList(aprLifecycleListener))
				: new ArrayList<>();
	}
	@Override
	public WebServer getWebServer(HttpHandler httpHandler) {
		if (this.disableMBeanRegistry) {
			Registry.disableRegistry();
		}
		Tomcat tomcat = new Tomcat();
		File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir('tomcat');
		tomcat.setBaseDir(baseDir.getAbsolutePath());
		for (LifecycleListener listener : this.serverLifecycleListeners) {
			tomcat.getServer().addLifecycleListener(listener);
		}
		Connector connector = new Connector(this.protocol);
		connector.setThrowOnFailure(true);
		tomcat.getService().addConnector(connector);
		customizeConnector(connector);
		tomcat.setConnector(connector);
		registerConnectorExecutor(tomcat, connector);
		tomcat.getHost().setAutoDeploy(false);
		configureEngine(tomcat.getEngine());
		for (Connector additionalConnector : this.additionalTomcatConnectors) {
			tomcat.getService().addConnector(additionalConnector);
			registerConnectorExecutor(tomcat, additionalConnector);
		}
		TomcatHttpHandlerAdapter servlet = new TomcatHttpHandlerAdapter(httpHandler);
		prepareContext(tomcat.getHost(), servlet);
		return getTomcatWebServer(tomcat);
	}
	private void registerConnectorExecutor(Tomcat tomcat, Connector connector) {
		if (connector.getProtocolHandler().getExecutor() instanceof Executor executor) {
			tomcat.getService().addExecutor(executor);
		}
	}
	private void configureEngine(Engine engine) {
		engine.setBackgroundProcessorDelay(this.backgroundProcessorDelay);
		for (Valve valve : this.engineValves) {
			engine.getPipeline().addValve(valve);
		}
	}
	protected void prepareContext(Host host, TomcatHttpHandlerAdapter servlet) {
		File docBase = createTempDir('tomcat-docbase');
		TomcatEmbeddedContext context = new TomcatEmbeddedContext();
		context.setPath('');
		context.setDocBase(docBase.getAbsolutePath());
		context.addLifecycleListener(new Tomcat.FixContextListener());
		ClassLoader parentClassLoader = ClassUtils.getDefaultClassLoader();
		context.setParentClassLoader(parentClassLoader);
		skipAllTldScanning(context);
		WebappLoader loader = new WebappLoader();
		loader.setLoaderInstance(new TomcatEmbeddedWebappClassLoader(parentClassLoader));
		loader.setDelegate(true);
		context.setLoader(loader);
		Tomcat.addServlet(context, 'httpHandlerServlet', servlet).setAsyncSupported(true);
		context.addServletMappingDecoded('/', 'httpHandlerServlet');
		host.addChild(context);
		configureContext(context);
	}
	private void skipAllTldScanning(TomcatEmbeddedContext context) {
		StandardJarScanFilter filter = new StandardJarScanFilter();
		filter.setTldSkip('*.jar');
		context.getJarScanner().setJarScanFilter(filter);
	}
	/**
	 * Configure the Tomcat {@link Context}.
	 * @param context the Tomcat context
	 */
	protected void configureContext(Context context) {
		this.contextLifecycleListeners.forEach(context::addLifecycleListener);
		new DisableReferenceClearingContextCustomizer().customize(context);
		this.tomcatContextCustomizers.forEach((customizer) -> customizer.customize(context));
	}
	protected void customizeConnector(Connector connector) {
		int port = Math.max(getPort(), 0);
		connector.setPort(port);
		if (StringUtils.hasText(getServerHeader())) {
			connector.setProperty('server', getServerHeader());
		}
		if (connector.getProtocolHandler() instanceof AbstractProtocol<?> abstractProtocol) {
			customizeProtocol(abstractProtocol);
		}
		invokeProtocolHandlerCustomizers(connector.getProtocolHandler());
		if (getUriEncoding() != null) {
			connector.setURIEncoding(getUriEncoding().name());
		}
		if (getHttp2() != null && getHttp2().isEnabled()) {
			connector.addUpgradeProtocol(new Http2Protocol());
		}
		if (Ssl.isEnabled(getSsl())) {
			customizeSsl(connector);
		}
		TomcatConnectorCustomizer compression = new CompressionConnectorCustomizer(getCompression());
		compression.customize(connector);
		for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) {
			customizer.customize(connector);
		}
	}
	@SuppressWarnings('unchecked')
	private void invokeProtocolHandlerCustomizers(ProtocolHandler protocolHandler) {
		LambdaSafe
			.callbacks(TomcatProtocolHandlerCustomizer.class, this.tomcatProtocolHandlerCustomizers, protocolHandler)
			.invoke((customizer) -> customizer.customize(protocolHandler));
	}
	private void customizeProtocol(AbstractProtocol<?> protocol) {
		if (getAddress() != null) {
			protocol.setAddress(getAddress());
		}
	}
	private void customizeSsl(Connector connector) {
		SslConnectorCustomizer customizer = new SslConnectorCustomizer(logger, connector, getSsl().getClientAuth());
		customizer.customize(getSslBundle(), getServerNameSslBundles());
		addBundleUpdateHandler(null, getSsl().getBundle(), customizer);
		getSsl().getServerNameBundles()
			.forEach((serverNameSslBundle) -> addBundleUpdateHandler(serverNameSslBundle.serverName(),
					serverNameSslBundle.bundle(), customizer));
	}
	private void addBundleUpdateHandler(String serverName, String sslBundleName, SslConnectorCustomizer customizer) {
		if (StringUtils.hasText(sslBundleName)) {
			getSslBundles().addBundleUpdateHandler(sslBundleName,
					(sslBundle) -> customizer.update(serverName, sslBundle));
		}
	}
	@Override
	public void setBaseDirectory(File baseDirectory) {
		this.baseDirectory = baseDirectory;
	}
	@Override
	public void setBackgroundProcessorDelay(int delay) {
		this.backgroundProcessorDelay = delay;
	}
	/**
	 * Set {@link TomcatContextCustomizer}s that should be applied to the Tomcat
	 * {@link Context}. Calling this method will replace any existing customizers.
	 * @param tomcatContextCustomizers the customizers to set
	 */
	public void setTomcatContextCustomizers(Collection<? extends TomcatContextCustomizer> tomcatContextCustomizers) {
		Assert.notNull(tomcatContextCustomizers, 'TomcatContextCustomizers must not be null');
		this.tomcatContextCustomizers = new LinkedHashSet<>(tomcatContextCustomizers);
	}
	/**
	 * Returns a mutable collection of the {@link TomcatContextCustomizer}s that will be
	 * applied to the Tomcat {@link Context}.
	 * @return the listeners that will be applied
	 */
	public Collection<TomcatContextCustomizer> getTomcatContextCustomizers() {
		return this.tomcatContextCustomizers;
	}
	/**
	 * Add {@link TomcatContextCustomizer}s that should be added to the Tomcat
	 * {@link Context}.
	 * @param tomcatContextCustomizers the customizers to add
	 */
	@Override
	public void addContextCustomizers(TomcatContextCustomizer... tomcatContextCustomizers) {
		Assert.notNull(tomcatContextCustomizers, 'TomcatContextCustomizers must not be null');
		this.tomcatContextCustomizers.addAll(Arrays.asList(tomcatContextCustomizers));
	}
	/**
	 * Set {@link TomcatConnectorCustomizer}s that should be applied to the Tomcat
	 * {@link Connector}. Calling this method will replace any existing customizers.
	 * @param tomcatConnectorCustomizers the customizers to set
	 */
	public void setTomcatConnectorCustomizers(
			Collection<? extends TomcatConnectorCustomizer> tomcatConnectorCustomizers) {
		Assert.notNull(tomcatConnectorCustomizers, 'TomcatConnectorCustomizers must not be null');
		this.tomcatConnectorCustomizers = new LinkedHashSet<>(tomcatConnectorCustomizers);
	}
	/**
	 * Add {@link TomcatConnectorCustomizer}s that should be added to the Tomcat
	 * {@link Connector}.
	 * @param tomcatConnectorCustomizers the customizers to add
	 */
	@Override
	public void addConnectorCustomizers(TomcatConnectorCustomizer... tomcatConnectorCustomizers) {
		Assert.notNull(tomcatConnectorCustomizers, 'TomcatConnectorCustomizers must not be null');
		this.tomcatConnectorCustomizers.addAll(Arrays.asList(tomcatConnectorCustomizers));
	}
	/**
	 * Returns a mutable collection of the {@link TomcatConnectorCustomizer}s that will be
	 * applied to the Tomcat {@link Connector}.
	 * @return the customizers that will be applied
	 */
	public Collection<TomcatConnectorCustomizer> getTomcatConnectorCustomizers() {
		return this.tomcatConnectorCustomizers;
	}
	/**
	 * Set {@link TomcatProtocolHandlerCustomizer}s that should be applied to the Tomcat
	 * {@link Connector}. Calling this method will replace any existing customizers.
	 * @param tomcatProtocolHandlerCustomizers the customizers to set
	 * @since 2.2.0
	 */
	public void setTomcatProtocolHandlerCustomizers(
			Collection<? extends TomcatProtocolHandlerCustomizer<?>> tomcatProtocolHandlerCustomizers) {
		Assert.notNull(tomcatProtocolHandlerCustomizers, 'TomcatProtocolHandlerCustomizers must not be null');
		this.tomcatProtocolHandlerCustomizers = new LinkedHashSet<>(tomcatProtocolHandlerCustomizers);
	}
	/**
	 * Add {@link TomcatProtocolHandlerCustomizer}s that should be added to the Tomcat
	 * {@link Connector}.
	 * @param tomcatProtocolHandlerCustomizers the customizers to add
	 * @since 2.2.0
	 */
	@Override
	public void addProtocolHandlerCustomizers(TomcatProtocolHandlerCustomizer<?>... tomcatProtocolHandlerCustomizers) {
		Assert.notNull(tomcatProtocolHandlerCustomizers, 'TomcatProtocolHandlerCustomizers must not be null');
		this.tomcatProtocolHandlerCustomizers.addAll(Arrays.asList(tomcatProtocolHandlerCustomizers));
	}
	/**
	 * Returns a mutable collection of the {@link TomcatProtocolHandlerCustomizer}s that
	 * will be applied to the Tomcat {@link Connector}.
	 * @return the customizers that will be applied
	 * @since 2.2.0
	 */
	public Collection<TomcatProtocolHandlerCustomizer<?>> getTomcatProtocolHandlerCustomizers() {
		return this.tomcatProtocolHandlerCustomizers;
	}
	/**
	 * Add {@link Connector}s in addition to the default connector, e.g. for SSL or AJP.
	 * <p>
	 * {@link #getTomcatConnectorCustomizers Connector customizers} are not applied to
	 * connectors added this way.
	 * @param connectors the connectors to add
	 * @since 2.2.0
	 */
	public void addAdditionalTomcatConnectors(Connector... connectors) {
		Assert.notNull(connectors, 'Connectors must not be null');
		this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));
	}
	/**
	 * Returns a mutable collection of the {@link Connector}s that will be added to the
	 * Tomcat.
	 * @return the additionalTomcatConnectors
	 * @since 2.2.0
	 */
	public List<Connector> getAdditionalTomcatConnectors() {
		return this.additionalTomcatConnectors;
	}
	@Override
	public void addEngineValves(Valve... engineValves) {
		Assert.notNull(engineValves, 'Valves must not be null');
		this.engineValves.addAll(Arrays.asList(engineValves));
	}
	/**
	 * Returns a mutable collection of the {@link Valve}s that will be applied to the
	 * Tomcat {@link Engine}.
	 * @return the engine valves that will be applied
	 */
	public List<Valve> getEngineValves() {
		return this.engineValves;
	}
	/**
	 * Set the character encoding to use for URL decoding. If not specified "UTF-8" will
	 * be used.
	 * @param uriEncoding the uri encoding to set
	 */
	@Override
	public void setUriEncoding(Charset uriEncoding) {
		this.uriEncoding = uriEncoding;
	}
	/**
	 * Returns the character encoding to use for URL decoding.
	 * @return the URI encoding
	 */
	public Charset getUriEncoding() {
		return this.uriEncoding;
	}
	/**
	 * Set {@link LifecycleListener}s that should be applied to the Tomcat
	 * {@link Context}. Calling this method will replace any existing listeners.
	 * @param contextLifecycleListeners the listeners to set
	 */
	public void setContextLifecycleListeners(Collection<? extends LifecycleListener> contextLifecycleListeners) {
		Assert.notNull(contextLifecycleListeners, 'ContextLifecycleListeners must not be null');
		this.contextLifecycleListeners = new ArrayList<>(contextLifecycleListeners);
	}
	/**
	 * Returns a mutable collection of the {@link LifecycleListener}s that will be applied
	 * to the Tomcat {@link Context}.
	 * @return the context lifecycle listeners that will be applied
	 */
	public Collection<LifecycleListener> getContextLifecycleListeners() {
		return this.contextLifecycleListeners;
	}
	/**
	 * Add {@link LifecycleListener}s that should be added to the Tomcat {@link Context}.
	 * @param contextLifecycleListeners the listeners to add
	 */
	public void addContextLifecycleListeners(LifecycleListener... contextLifecycleListeners) {
		Assert.notNull(contextLifecycleListeners, 'ContextLifecycleListeners must not be null');
		this.contextLifecycleListeners.addAll(Arrays.asList(contextLifecycleListeners));
	}
	/**
	 * Factory method called to create the {@link TomcatWebServer}. Subclasses can
	 * override this method to return a different {@link TomcatWebServer} or apply
	 * additional processing to the Tomcat server.
	 * @param tomcat the Tomcat server.
	 * @return a new {@link TomcatWebServer} instance
	 */
	protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {
		return new TomcatWebServer(tomcat, getPort() >= 0, getShutdown());
	}
	/**
	 * The Tomcat protocol to use when create the {@link Connector}.
	 * @param protocol the protocol
	 * @see Connector#Connector(String)
	 */
	public void setProtocol(String protocol) {
		Assert.hasLength(protocol, 'Protocol must not be empty');
		this.protocol = protocol;
	}
	/**
	 * Set whether the factory should disable Tomcat"s MBean registry prior to creating
	 * the server.
	 * @param disableMBeanRegistry whether to disable the MBean registry
	 * @since 2.2.0
	 */
	public void setDisableMBeanRegistry(boolean disableMBeanRegistry) {
		this.disableMBeanRegistry = disableMBeanRegistry;
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class LazySessionIdGenerator extends StandardSessionIdGenerator {
	@Override
	protected void startInternal() throws LifecycleException {
		setState(LifecycleState.STARTING);
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class SslConnectorCustomizer {
	private final Log logger;
	private final ClientAuth clientAuth;
	private final Connector connector;
	SslConnectorCustomizer(Log logger, Connector connector, ClientAuth clientAuth) {
		this.logger = logger;
		this.clientAuth = clientAuth;
		this.connector = connector;
	}
	void update(String serverName, SslBundle updatedSslBundle) {
		AbstractHttp11JsseProtocol<?> protocol = (AbstractHttp11JsseProtocol<?>) this.connector.getProtocolHandler();
		String host = (serverName != null) ? serverName : protocol.getDefaultSSLHostConfigName();
		this.logger.debug('SSL Bundle for host ' + host + ' has been updated, reloading SSL configuration');
		addSslHostConfig(protocol, host, updatedSslBundle);
	}
	void customize(SslBundle sslBundle, Map<String, SslBundle> serverNameSslBundles) {
		ProtocolHandler handler = this.connector.getProtocolHandler();
		Assert.state(handler instanceof AbstractHttp11JsseProtocol,
				'To use SSL, the connector"s protocol handler must be an AbstractHttp11JsseProtocol subclass');
		configureSsl((AbstractHttp11JsseProtocol<?>) handler, sslBundle, serverNameSslBundles);
		this.connector.setScheme('https');
		this.connector.setSecure(true);
	}
	/**
	 * Configure Tomcat"s {@link AbstractHttp11JsseProtocol} for SSL.
	 * @param protocol the protocol
	 * @param sslBundle the SSL bundle
	 * @param serverNameSslBundles the SSL bundles for specific SNI host names
	 */
	private void configureSsl(AbstractHttp11JsseProtocol<?> protocol, SslBundle sslBundle,
			Map<String, SslBundle> serverNameSslBundles) {
		protocol.setSSLEnabled(true);
		if (sslBundle != null) {
			addSslHostConfig(protocol, protocol.getDefaultSSLHostConfigName(), sslBundle);
		}
		serverNameSslBundles.forEach((serverName, bundle) -> addSslHostConfig(protocol, serverName, bundle));
	}
	private void addSslHostConfig(AbstractHttp11JsseProtocol<?> protocol, String serverName, SslBundle sslBundle) {
		SSLHostConfig sslHostConfig = new SSLHostConfig();
		sslHostConfig.setHostName(serverName);
		configureSslClientAuth(sslHostConfig);
		applySslBundle(protocol, sslHostConfig, sslBundle);
		protocol.addSslHostConfig(sslHostConfig, true);
	}
	private void applySslBundle(AbstractHttp11JsseProtocol<?> protocol, SSLHostConfig sslHostConfig,
			SslBundle sslBundle) {
		SslBundleKey key = sslBundle.getKey();
		SslStoreBundle stores = sslBundle.getStores();
		SslOptions options = sslBundle.getOptions();
		sslHostConfig.setSslProtocol(sslBundle.getProtocol());
		SSLHostConfigCertificate certificate = new SSLHostConfigCertificate(sslHostConfig, Type.UNDEFINED);
		String keystorePassword = (stores.getKeyStorePassword() != null) ? stores.getKeyStorePassword() : '';
		certificate.setCertificateKeystorePassword(keystorePassword);
		if (key.getPassword() != null) {
			certificate.setCertificateKeyPassword(key.getPassword());
		}
		if (key.getAlias() != null) {
			certificate.setCertificateKeyAlias(key.getAlias());
		}
		sslHostConfig.addCertificate(certificate);
		if (options.getCiphers() != null) {
			String ciphers = StringUtils.arrayToCommaDelimitedString(options.getCiphers());
			sslHostConfig.setCiphers(ciphers);
		}
		configureSslStores(sslHostConfig, certificate, stores);
		configureEnabledProtocols(sslHostConfig, options);
	}
	private void configureEnabledProtocols(SSLHostConfig sslHostConfig, SslOptions options) {
		if (options.getEnabledProtocols() != null) {
			String enabledProtocols = StringUtils.arrayToDelimitedString(options.getEnabledProtocols(), '+');
			sslHostConfig.setProtocols(enabledProtocols);
		}
	}
	private void configureSslClientAuth(SSLHostConfig config) {
		config.setCertificateVerification(ClientAuth.map(this.clientAuth, 'none', 'optional', 'required'));
	}
	private void configureSslStores(SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate,
			SslStoreBundle stores) {
		try {
			if (stores.getKeyStore() != null) {
				certificate.setCertificateKeystore(stores.getKeyStore());
			}
			if (stores.getTrustStore() != null) {
				sslHostConfig.setTrustStore(stores.getTrustStore());
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Could not load store: ' + ex.getMessage(), ex);
		}
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class ConnectorStartFailureAnalyzer extends AbstractFailureAnalyzer<ConnectorStartFailedException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, ConnectorStartFailedException cause) {
		return new FailureAnalysis(
				'The Tomcat connector configured to listen on port ' + cause.getPort()
						+ ' failed to start. The port may already be in use or the connector may be misconfigured.',
				'Verify the connector"s configuration, identify and stop any process that"s listening on port '
						+ cause.getPort() + ', or configure this application to listen on another port.',
				cause);
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class NestedJarResourceSet extends AbstractSingleArchiveResourceSet {
	private static final Name MULTI_RELEASE = new Name('Multi-Release');
	private final URL url;
	private JarFile archive = null;
	private long archiveUseCount = 0;
	private boolean useCaches;
	private volatile Boolean multiRelease;
	NestedJarResourceSet(URL url, WebResourceRoot root, String webAppMount, String internalPath)
			throws IllegalArgumentException {
		this.url = url;
		setRoot(root);
		setWebAppMount(webAppMount);
		setInternalPath(internalPath);
		setStaticOnly(true);
		if (getRoot().getState().isAvailable()) {
			try {
				start();
			}
			catch (LifecycleException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
	@Override
	protected WebResource createArchiveResource(JarEntry jarEntry, String webAppPath, Manifest manifest) {
		return new JarResource(this, webAppPath, getBaseUrlString(), jarEntry);
	}
	@Override
	protected void initInternal() throws LifecycleException {
		try {
			JarURLConnection connection = connect();
			try {
				setManifest(connection.getManifest());
				setBaseUrl(connection.getJarFileURL());
			}
			finally {
				if (!connection.getUseCaches()) {
					connection.getJarFile().close();
				}
			}
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	@Override
	protected JarFile openJarFile() throws IOException {
		synchronized (this.archiveLock) {
			if (this.archive == null) {
				JarURLConnection connection = connect();
				this.useCaches = connection.getUseCaches();
				this.archive = connection.getJarFile();
			}
			this.archiveUseCount++;
			return this.archive;
		}
	}
	@Override
	protected void closeJarFile() {
		synchronized (this.archiveLock) {
			this.archiveUseCount--;
		}
	}
	@Override
	protected boolean isMultiRelease() {
		if (this.multiRelease == null) {
			synchronized (this.archiveLock) {
				if (this.multiRelease == null) {
					// JarFile.isMultiRelease() is final so we must go to the manifest
					Manifest manifest = getManifest();
					Attributes attributes = (manifest != null) ? manifest.getMainAttributes() : null;
					this.multiRelease = (attributes != null) && attributes.containsKey(MULTI_RELEASE);
				}
			}
		}
		return this.multiRelease;
	}
	@Override
	public void gc() {
		synchronized (this.archiveLock) {
			if (this.archive != null && this.archiveUseCount == 0) {
				try {
					if (!this.useCaches) {
						this.archive.close();
					}
				}
				catch (IOException ex) {
					// Ignore
				}
				this.archive = null;
				this.archiveEntries = null;
			}
		}
	}
	private JarURLConnection connect() throws IOException {
		URLConnection connection = this.url.openConnection();
		ResourceUtils.useCachesIfNecessary(connection);
		Assert.state(connection instanceof JarURLConnection,
				() -> 'URL "%s" did not return a JAR connection'.formatted(this.url));
		connection.connect();
		return (JarURLConnection) connection;
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
@FunctionalInterface
public interface TomcatProtocolHandlerCustomizer<T extends ProtocolHandler> {
	/**
	 * Customize the protocol handler.
	 * @param protocolHandler the protocol handler to customize
	 */
	void customize(T protocolHandler);
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
public interface ConfigurableTomcatWebServerFactory extends ConfigurableWebServerFactory {
	/**
	 * Set the Tomcat base directory. If not specified a temporary directory will be used.
	 * @param baseDirectory the tomcat base directory
	 */
	void setBaseDirectory(File baseDirectory);
	/**
	 * Sets the background processor delay in seconds.
	 * @param delay the delay in seconds
	 */
	void setBackgroundProcessorDelay(int delay);
	/**
	 * Add {@link Valve}s that should be applied to the Tomcat {@link Engine}.
	 * @param engineValves the valves to add
	 */
	void addEngineValves(Valve... engineValves);
	/**
	 * Add {@link TomcatConnectorCustomizer}s that should be added to the Tomcat
	 * {@link Connector}.
	 * @param tomcatConnectorCustomizers the customizers to add
	 */
	void addConnectorCustomizers(TomcatConnectorCustomizer... tomcatConnectorCustomizers);
	/**
	 * Add {@link TomcatContextCustomizer}s that should be added to the Tomcat
	 * {@link Context}.
	 * @param tomcatContextCustomizers the customizers to add
	 */
	void addContextCustomizers(TomcatContextCustomizer... tomcatContextCustomizers);
	/**
	 * Add {@link TomcatProtocolHandlerCustomizer}s that should be added to the Tomcat
	 * {@link Connector}.
	 * @param tomcatProtocolHandlerCustomizers the customizers to add
	 * @since 2.2.0
	 */
	void addProtocolHandlerCustomizers(TomcatProtocolHandlerCustomizer<?>... tomcatProtocolHandlerCustomizers);
	/**
	 * Set the character encoding to use for URL decoding. If not specified "UTF-8" will
	 * be used.
	 * @param uriEncoding the uri encoding to set
	 */
	void setUriEncoding(Charset uriEncoding);
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class TomcatEmbeddedContext extends StandardContext {
	private TomcatStarter starter;
	private MimeMappings mimeMappings;
	@Override
	public boolean loadOnStartup(Container[] children) {
		// deferred until later (see deferredLoadOnStartup)
		return true;
	}
	@Override
	public void setManager(Manager manager) {
		if (manager instanceof ManagerBase) {
			manager.setSessionIdGenerator(new LazySessionIdGenerator());
		}
		super.setManager(manager);
	}
	void deferredLoadOnStartup() {
		doWithThreadContextClassLoader(getLoader().getClassLoader(),
				() -> getLoadOnStartupWrappers(findChildren()).forEach(this::load));
	}
	private Stream<Wrapper> getLoadOnStartupWrappers(Container[] children) {
		Map<Integer, List<Wrapper>> grouped = new TreeMap<>();
		for (Container child : children) {
			Wrapper wrapper = (Wrapper) child;
			int order = wrapper.getLoadOnStartup();
			if (order >= 0) {
				grouped.computeIfAbsent(order, (o) -> new ArrayList<>()).add(wrapper);
			}
		}
		return grouped.values().stream().flatMap(List::stream);
	}
	private void load(Wrapper wrapper) {
		try {
			wrapper.load();
		}
		catch (ServletException ex) {
			String message = sm.getString('standardContext.loadOnStartup.loadException', getName(), wrapper.getName());
			if (getComputedFailCtxIfServletStartFails()) {
				throw new WebServerException(message, ex);
			}
			getLogger().error(message, StandardWrapper.getRootCause(ex));
		}
	}
	/**
	 * Some older Servlet frameworks (e.g. Struts, BIRT) use the Thread context class
	 * loader to create servlet instances in this phase. If they do that and then try to
	 * initialize them later the class loader may have changed, so wrap the call to
	 * loadOnStartup in what we think is going to be the main webapp classloader at
	 * runtime.
	 * @param classLoader the class loader to use
	 * @param code the code to run
	 */
	private void doWithThreadContextClassLoader(ClassLoader classLoader, Runnable code) {
		ClassLoader existingLoader = (classLoader != null) ? ClassUtils.overrideThreadContextClassLoader(classLoader)
				: null;
		try {
			code.run();
		}
		finally {
			if (existingLoader != null) {
				ClassUtils.overrideThreadContextClassLoader(existingLoader);
			}
		}
	}
	void setStarter(TomcatStarter starter) {
		this.starter = starter;
	}
	TomcatStarter getStarter() {
		return this.starter;
	}
	void setMimeMappings(MimeMappings mimeMappings) {
		this.mimeMappings = mimeMappings;
	}
	@Override
	public String[] findMimeMappings() {
		List<String> mappings = new ArrayList<>(Arrays.asList(super.findMimeMappings()));
		if (this.mimeMappings != null) {
			this.mimeMappings.forEach((mapping) -> mappings.add(mapping.getExtension()));
		}
		return mappings.toArray(String[]::new);
	}
	@Override
	public String findMimeMapping(String extension) {
		String mimeMapping = super.findMimeMapping(extension);
		if (mimeMapping != null) {
			return mimeMapping;
		}
		return (this.mimeMappings != null) ? this.mimeMappings.get(extension) : null;
	}
}
/*
/**
package org.springframework.boot.web.embedded.tomcat;
/*
package org.springframework.boot.web.embedded.tomcat;
/**
public class ConnectorStartFailedException extends WebServerException {
	private final int port;
	/**
	 * Creates a new {@code ConnectorStartFailedException} for a connector that"s
	 * configured to listen on the given {@code port}.
	 * @param port the port
	 */
	public ConnectorStartFailedException(int port) {
		super('Connector configured to listen on port ' + port + ' failed to start', null);
		this.port = port;
	}
	public int getPort() {
		return this.port;
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
public class TomcatServletWebServerFactory extends AbstractServletWebServerFactory
		implements ConfigurableTomcatWebServerFactory, ResourceLoaderAware {
	private static final Log logger = LogFactory.getLog(TomcatServletWebServerFactory.class);
	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	private static final Set<Class<?>> NO_CLASSES = Collections.emptySet();
	/**
	 * The class name of default protocol used.
	 */
	public static final String DEFAULT_PROTOCOL = 'org.apache.coyote.http11.Http11NioProtocol';
	private File baseDirectory;
	private List<Valve> engineValves = new ArrayList<>();
	private List<Valve> contextValves = new ArrayList<>();
	private List<LifecycleListener> contextLifecycleListeners = new ArrayList<>();
	private final List<LifecycleListener> serverLifecycleListeners = getDefaultServerLifecycleListeners();
	private Set<TomcatContextCustomizer> tomcatContextCustomizers = new LinkedHashSet<>();
	private Set<TomcatConnectorCustomizer> tomcatConnectorCustomizers = new LinkedHashSet<>();
	private Set<TomcatProtocolHandlerCustomizer<?>> tomcatProtocolHandlerCustomizers = new LinkedHashSet<>();
	private final List<Connector> additionalTomcatConnectors = new ArrayList<>();
	private ResourceLoader resourceLoader;
	private String protocol = DEFAULT_PROTOCOL;
	private Set<String> tldSkipPatterns = new LinkedHashSet<>(TldPatterns.DEFAULT_SKIP);
	private final Set<String> tldScanPatterns = new LinkedHashSet<>(TldPatterns.DEFAULT_SCAN);
	private Charset uriEncoding = DEFAULT_CHARSET;
	private int backgroundProcessorDelay;
	private boolean disableMBeanRegistry = true;
	/**
	 * Create a new {@link TomcatServletWebServerFactory} instance.
	 */
	public TomcatServletWebServerFactory() {
	}
	/**
	 * Create a new {@link TomcatServletWebServerFactory} that listens for requests using
	 * the specified port.
	 * @param port the port to listen on
	 */
	public TomcatServletWebServerFactory(int port) {
		super(port);
	}
	/**
	 * Create a new {@link TomcatServletWebServerFactory} with the specified context path
	 * and port.
	 * @param contextPath the root context path
	 * @param port the port to listen on
	 */
	public TomcatServletWebServerFactory(String contextPath, int port) {
		super(contextPath, port);
	}
	private static List<LifecycleListener> getDefaultServerLifecycleListeners() {
		ArrayList<LifecycleListener> lifecycleListeners = new ArrayList<>();
		if (!NativeDetector.inNativeImage()) {
			AprLifecycleListener aprLifecycleListener = new AprLifecycleListener();
			if (AprLifecycleListener.isAprAvailable()) {
				lifecycleListeners.add(aprLifecycleListener);
			}
		}
		return lifecycleListeners;
	}
	@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		if (this.disableMBeanRegistry) {
			Registry.disableRegistry();
		}
		Tomcat tomcat = new Tomcat();
		File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir('tomcat');
		tomcat.setBaseDir(baseDir.getAbsolutePath());
		for (LifecycleListener listener : this.serverLifecycleListeners) {
			tomcat.getServer().addLifecycleListener(listener);
		}
		Connector connector = new Connector(this.protocol);
		connector.setThrowOnFailure(true);
		tomcat.getService().addConnector(connector);
		customizeConnector(connector);
		tomcat.setConnector(connector);
		registerConnectorExecutor(tomcat, connector);
		tomcat.getHost().setAutoDeploy(false);
		configureEngine(tomcat.getEngine());
		for (Connector additionalConnector : this.additionalTomcatConnectors) {
			tomcat.getService().addConnector(additionalConnector);
			registerConnectorExecutor(tomcat, additionalConnector);
		}
		prepareContext(tomcat.getHost(), initializers);
		return getTomcatWebServer(tomcat);
	}
	private void registerConnectorExecutor(Tomcat tomcat, Connector connector) {
		if (connector.getProtocolHandler().getExecutor() instanceof Executor executor) {
			tomcat.getService().addExecutor(executor);
		}
	}
	private void configureEngine(Engine engine) {
		engine.setBackgroundProcessorDelay(this.backgroundProcessorDelay);
		for (Valve valve : this.engineValves) {
			engine.getPipeline().addValve(valve);
		}
	}
	protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
		File documentRoot = getValidDocumentRoot();
		TomcatEmbeddedContext context = new TomcatEmbeddedContext();
		if (documentRoot != null) {
			context.setResources(new LoaderHidingResourceRoot(context));
		}
		context.setName(getContextPath());
		context.setDisplayName(getDisplayName());
		context.setPath(getContextPath());
		File docBase = (documentRoot != null) ? documentRoot : createTempDir('tomcat-docbase');
		context.setDocBase(docBase.getAbsolutePath());
		context.addLifecycleListener(new FixContextListener());
		ClassLoader parentClassLoader = (this.resourceLoader != null) ? this.resourceLoader.getClassLoader()
				: ClassUtils.getDefaultClassLoader();
		context.setParentClassLoader(parentClassLoader);
		resetDefaultLocaleMapping(context);
		addLocaleMappings(context);
		try {
			context.setCreateUploadTargets(true);
		}
		catch (NoSuchMethodError ex) {
			// Tomcat is < 8.5.39. Continue.
		}
		configureTldPatterns(context);
		WebappLoader loader = new WebappLoader();
		loader.setLoaderInstance(new TomcatEmbeddedWebappClassLoader(parentClassLoader));
		loader.setDelegate(true);
		context.setLoader(loader);
		if (isRegisterDefaultServlet()) {
			addDefaultServlet(context);
		}
		if (shouldRegisterJspServlet()) {
			addJspServlet(context);
			addJasperInitializer(context);
		}
		context.addLifecycleListener(new StaticResourceConfigurer(context));
		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
		host.addChild(context);
		configureContext(context, initializersToUse);
		postProcessContext(context);
	}
	/**
	 * Override Tomcat"s default locale mappings to align with other servers. See
	 * {@code org.apache.catalina.util.CharsetMapperDefault.properties}.
	 * @param context the context to reset
	 */
	private void resetDefaultLocaleMapping(TomcatEmbeddedContext context) {
		context.addLocaleEncodingMappingParameter(Locale.ENGLISH.toString(), DEFAULT_CHARSET.displayName());
		context.addLocaleEncodingMappingParameter(Locale.FRENCH.toString(), DEFAULT_CHARSET.displayName());
		context.addLocaleEncodingMappingParameter(Locale.JAPANESE.toString(), DEFAULT_CHARSET.displayName());
	}
	private void addLocaleMappings(TomcatEmbeddedContext context) {
		getLocaleCharsetMappings().forEach(
				(locale, charset) -> context.addLocaleEncodingMappingParameter(locale.toString(), charset.toString()));
	}
	private void configureTldPatterns(TomcatEmbeddedContext context) {
		StandardJarScanFilter filter = new StandardJarScanFilter();
		filter.setTldSkip(StringUtils.collectionToCommaDelimitedString(this.tldSkipPatterns));
		filter.setTldScan(StringUtils.collectionToCommaDelimitedString(this.tldScanPatterns));
		context.getJarScanner().setJarScanFilter(filter);
	}
	private void addDefaultServlet(Context context) {
		Wrapper defaultServlet = context.createWrapper();
		defaultServlet.setName('default');
		defaultServlet.setServletClass('org.apache.catalina.servlets.DefaultServlet');
		defaultServlet.addInitParameter('debug', '0');
		defaultServlet.addInitParameter('listings', 'false');
		defaultServlet.setLoadOnStartup(1);
		// Otherwise the default location of a Spring DispatcherServlet cannot be set
		defaultServlet.setOverridable(true);
		context.addChild(defaultServlet);
		context.addServletMappingDecoded('/', 'default');
	}
	private void addJspServlet(Context context) {
		Wrapper jspServlet = context.createWrapper();
		jspServlet.setName('jsp');
		jspServlet.setServletClass(getJsp().getClassName());
		jspServlet.addInitParameter('fork', 'false');
		getJsp().getInitParameters().forEach(jspServlet::addInitParameter);
		jspServlet.setLoadOnStartup(3);
		context.addChild(jspServlet);
		context.addServletMappingDecoded('*.jsp', 'jsp');
		context.addServletMappingDecoded('*.jspx', 'jsp');
	}
	private void addJasperInitializer(TomcatEmbeddedContext context) {
		try {
			ServletContainerInitializer initializer = (ServletContainerInitializer) ClassUtils
				.forName('org.apache.jasper.servlet.JasperInitializer', null)
				.getDeclaredConstructor()
				.newInstance();
			context.addServletContainerInitializer(initializer, null);
		}
		catch (Exception ex) {
			// Probably not Tomcat 8
		}
	}
	// Needs to be protected so it can be used by subclasses
	protected void customizeConnector(Connector connector) {
		int port = Math.max(getPort(), 0);
		connector.setPort(port);
		if (StringUtils.hasText(getServerHeader())) {
			connector.setProperty('server', getServerHeader());
		}
		if (connector.getProtocolHandler() instanceof AbstractProtocol<?> abstractProtocol) {
			customizeProtocol(abstractProtocol);
		}
		invokeProtocolHandlerCustomizers(connector.getProtocolHandler());
		if (getUriEncoding() != null) {
			connector.setURIEncoding(getUriEncoding().name());
		}
		if (getHttp2() != null && getHttp2().isEnabled()) {
			connector.addUpgradeProtocol(new Http2Protocol());
		}
		if (Ssl.isEnabled(getSsl())) {
			customizeSsl(connector);
		}
		TomcatConnectorCustomizer compression = new CompressionConnectorCustomizer(getCompression());
		compression.customize(connector);
		for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) {
			customizer.customize(connector);
		}
	}
	private void customizeProtocol(AbstractProtocol<?> protocol) {
		if (getAddress() != null) {
			protocol.setAddress(getAddress());
		}
	}
	@SuppressWarnings('unchecked')
	private void invokeProtocolHandlerCustomizers(ProtocolHandler protocolHandler) {
		LambdaSafe
			.callbacks(TomcatProtocolHandlerCustomizer.class, this.tomcatProtocolHandlerCustomizers, protocolHandler)
			.invoke((customizer) -> customizer.customize(protocolHandler));
	}
	private void customizeSsl(Connector connector) {
		SslConnectorCustomizer customizer = new SslConnectorCustomizer(logger, connector, getSsl().getClientAuth());
		customizer.customize(getSslBundle(), getServerNameSslBundles());
		addBundleUpdateHandler(null, getSsl().getBundle(), customizer);
		getSsl().getServerNameBundles()
			.forEach((serverNameSslBundle) -> addBundleUpdateHandler(serverNameSslBundle.serverName(),
					serverNameSslBundle.bundle(), customizer));
	}
	private void addBundleUpdateHandler(String serverName, String sslBundleName, SslConnectorCustomizer customizer) {
		if (StringUtils.hasText(sslBundleName)) {
			getSslBundles().addBundleUpdateHandler(sslBundleName,
					(sslBundle) -> customizer.update(serverName, sslBundle));
		}
	}
	/**
	 * Configure the Tomcat {@link Context}.
	 * @param context the Tomcat context
	 * @param initializers initializers to apply
	 */
	protected void configureContext(Context context, ServletContextInitializer[] initializers) {
		TomcatStarter starter = new TomcatStarter(initializers);
		if (context instanceof TomcatEmbeddedContext embeddedContext) {
			embeddedContext.setStarter(starter);
			embeddedContext.setFailCtxIfServletStartFails(true);
		}
		context.addServletContainerInitializer(starter, NO_CLASSES);
		for (LifecycleListener lifecycleListener : this.contextLifecycleListeners) {
			context.addLifecycleListener(lifecycleListener);
		}
		for (Valve valve : this.contextValves) {
			context.getPipeline().addValve(valve);
		}
		for (ErrorPage errorPage : getErrorPages()) {
			org.apache.tomcat.util.descriptor.web.ErrorPage tomcatErrorPage = new org.apache.tomcat.util.descriptor.web.ErrorPage();
			tomcatErrorPage.setLocation(errorPage.getPath());
			tomcatErrorPage.setErrorCode(errorPage.getStatusCode());
			tomcatErrorPage.setExceptionType(errorPage.getExceptionName());
			context.addErrorPage(tomcatErrorPage);
		}
		setMimeMappings(context);
		configureSession(context);
		configureCookieProcessor(context);
		new DisableReferenceClearingContextCustomizer().customize(context);
		for (String webListenerClassName : getWebListenerClassNames()) {
			context.addApplicationListener(webListenerClassName);
		}
		for (TomcatContextCustomizer customizer : this.tomcatContextCustomizers) {
			customizer.customize(context);
		}
	}
	private void configureSession(Context context) {
		long sessionTimeout = getSessionTimeoutInMinutes();
		context.setSessionTimeout((int) sessionTimeout);
		Boolean httpOnly = getSession().getCookie().getHttpOnly();
		if (httpOnly != null) {
			context.setUseHttpOnly(httpOnly);
		}
		if (getSession().isPersistent()) {
			Manager manager = context.getManager();
			if (manager == null) {
				manager = new StandardManager();
				context.setManager(manager);
			}
			configurePersistSession(manager);
		}
		else {
			context.addLifecycleListener(new DisablePersistSessionListener());
		}
	}
	private void setMimeMappings(Context context) {
		if (context instanceof TomcatEmbeddedContext embeddedContext) {
			embeddedContext.setMimeMappings(getMimeMappings());
			return;
		}
		for (MimeMappings.Mapping mapping : getMimeMappings()) {
			context.addMimeMapping(mapping.getExtension(), mapping.getMimeType());
		}
	}
	private void configureCookieProcessor(Context context) {
		SameSite sessionSameSite = getSession().getCookie().getSameSite();
		List<CookieSameSiteSupplier> suppliers = new ArrayList<>();
		if (sessionSameSite != null) {
			suppliers.add(CookieSameSiteSupplier.of(sessionSameSite)
				.whenHasName(() -> SessionConfig.getSessionCookieName(context)));
		}
		if (!CollectionUtils.isEmpty(getCookieSameSiteSuppliers())) {
			suppliers.addAll(getCookieSameSiteSuppliers());
		}
		if (!suppliers.isEmpty()) {
			context.setCookieProcessor(new SuppliedSameSiteCookieProcessor(suppliers));
		}
	}
	private void configurePersistSession(Manager manager) {
		Assert.state(manager instanceof StandardManager,
				() -> 'Unable to persist HTTP session state using manager type ' + manager.getClass().getName());
		File dir = getValidSessionStoreDir();
		File file = new File(dir, 'SESSIONS.ser');
		((StandardManager) manager).setPathname(file.getAbsolutePath());
	}
	private long getSessionTimeoutInMinutes() {
		Duration sessionTimeout = getSession().getTimeout();
		if (isZeroOrLess(sessionTimeout)) {
			return 0;
		}
		return Math.max(sessionTimeout.toMinutes(), 1);
	}
	private boolean isZeroOrLess(Duration sessionTimeout) {
		return sessionTimeout == null || sessionTimeout.isNegative() || sessionTimeout.isZero();
	}
	/**
	 * Post process the Tomcat {@link Context} before it"s used with the Tomcat Server.
	 * Subclasses can override this method to apply additional processing to the
	 * {@link Context}.
	 * @param context the Tomcat {@link Context}
	 */
	protected void postProcessContext(Context context) {
	}
	/**
	 * Factory method called to create the {@link TomcatWebServer}. Subclasses can
	 * override this method to return a different {@link TomcatWebServer} or apply
	 * additional processing to the Tomcat server.
	 * @param tomcat the Tomcat server.
	 * @return a new {@link TomcatWebServer} instance
	 */
	protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {
		return new TomcatWebServer(tomcat, getPort() >= 0, getShutdown());
	}
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	@Override
	public void setBaseDirectory(File baseDirectory) {
		this.baseDirectory = baseDirectory;
	}
	/**
	 * Returns a mutable set of the patterns that match jars to ignore for TLD scanning.
	 * @return the list of jars to ignore for TLD scanning
	 */
	public Set<String> getTldSkipPatterns() {
		return this.tldSkipPatterns;
	}
	/**
	 * Set the patterns that match jars to ignore for TLD scanning. See Tomcat"s
	 * catalina.properties for typical values. Defaults to a list drawn from that source.
	 * @param patterns the jar patterns to skip when scanning for TLDs etc
	 */
	public void setTldSkipPatterns(Collection<String> patterns) {
		Assert.notNull(patterns, 'Patterns must not be null');
		this.tldSkipPatterns = new LinkedHashSet<>(patterns);
	}
	/**
	 * Add patterns that match jars to ignore for TLD scanning. See Tomcat"s
	 * catalina.properties for typical values.
	 * @param patterns the additional jar patterns to skip when scanning for TLDs etc
	 */
	public void addTldSkipPatterns(String... patterns) {
		Assert.notNull(patterns, 'Patterns must not be null');
		this.tldSkipPatterns.addAll(Arrays.asList(patterns));
	}
	/**
	 * The Tomcat protocol to use when create the {@link Connector}.
	 * @param protocol the protocol
	 * @see Connector#Connector(String)
	 */
	public void setProtocol(String protocol) {
		Assert.hasLength(protocol, 'Protocol must not be empty');
		this.protocol = protocol;
	}
	/**
	 * Set {@link Valve}s that should be applied to the Tomcat {@link Engine}. Calling
	 * this method will replace any existing valves.
	 * @param engineValves the valves to set
	 */
	public void setEngineValves(Collection<? extends Valve> engineValves) {
		Assert.notNull(engineValves, 'Valves must not be null');
		this.engineValves = new ArrayList<>(engineValves);
	}
	/**
	 * Returns a mutable collection of the {@link Valve}s that will be applied to the
	 * Tomcat {@link Engine}.
	 * @return the engine valves that will be applied
	 */
	public Collection<Valve> getEngineValves() {
		return this.engineValves;
	}
	@Override
	public void addEngineValves(Valve... engineValves) {
		Assert.notNull(engineValves, 'Valves must not be null');
		this.engineValves.addAll(Arrays.asList(engineValves));
	}
	/**
	 * Set {@link Valve}s that should be applied to the Tomcat {@link Context}. Calling
	 * this method will replace any existing valves.
	 * @param contextValves the valves to set
	 */
	public void setContextValves(Collection<? extends Valve> contextValves) {
		Assert.notNull(contextValves, 'Valves must not be null');
		this.contextValves = new ArrayList<>(contextValves);
	}
	/**
	 * Returns a mutable collection of the {@link Valve}s that will be applied to the
	 * Tomcat {@link Context}.
	 * @return the context valves that will be applied
	 * @see #getEngineValves()
	 */
	public Collection<Valve> getContextValves() {
		return this.contextValves;
	}
	/**
	 * Add {@link Valve}s that should be applied to the Tomcat {@link Context}.
	 * @param contextValves the valves to add
	 */
	public void addContextValves(Valve... contextValves) {
		Assert.notNull(contextValves, 'Valves must not be null');
		this.contextValves.addAll(Arrays.asList(contextValves));
	}
	/**
	 * Set {@link LifecycleListener}s that should be applied to the Tomcat
	 * {@link Context}. Calling this method will replace any existing listeners.
	 * @param contextLifecycleListeners the listeners to set
	 */
	public void setContextLifecycleListeners(Collection<? extends LifecycleListener> contextLifecycleListeners) {
		Assert.notNull(contextLifecycleListeners, 'ContextLifecycleListeners must not be null');
		this.contextLifecycleListeners = new ArrayList<>(contextLifecycleListeners);
	}
	/**
	 * Returns a mutable collection of the {@link LifecycleListener}s that will be applied
	 * to the Tomcat {@link Context}.
	 * @return the context lifecycle listeners that will be applied
	 */
	public Collection<LifecycleListener> getContextLifecycleListeners() {
		return this.contextLifecycleListeners;
	}
	/**
	 * Add {@link LifecycleListener}s that should be added to the Tomcat {@link Context}.
	 * @param contextLifecycleListeners the listeners to add
	 */
	public void addContextLifecycleListeners(LifecycleListener... contextLifecycleListeners) {
		Assert.notNull(contextLifecycleListeners, 'ContextLifecycleListeners must not be null');
		this.contextLifecycleListeners.addAll(Arrays.asList(contextLifecycleListeners));
	}
	/**
	 * Set {@link TomcatContextCustomizer}s that should be applied to the Tomcat
	 * {@link Context}. Calling this method will replace any existing customizers.
	 * @param tomcatContextCustomizers the customizers to set
	 */
	public void setTomcatContextCustomizers(Collection<? extends TomcatContextCustomizer> tomcatContextCustomizers) {
		Assert.notNull(tomcatContextCustomizers, 'TomcatContextCustomizers must not be null');
		this.tomcatContextCustomizers = new LinkedHashSet<>(tomcatContextCustomizers);
	}
	/**
	 * Returns a mutable collection of the {@link TomcatContextCustomizer}s that will be
	 * applied to the Tomcat {@link Context}.
	 * @return the listeners that will be applied
	 */
	public Collection<TomcatContextCustomizer> getTomcatContextCustomizers() {
		return this.tomcatContextCustomizers;
	}
	@Override
	public void addContextCustomizers(TomcatContextCustomizer... tomcatContextCustomizers) {
		Assert.notNull(tomcatContextCustomizers, 'TomcatContextCustomizers must not be null');
		this.tomcatContextCustomizers.addAll(Arrays.asList(tomcatContextCustomizers));
	}
	/**
	 * Set {@link TomcatConnectorCustomizer}s that should be applied to the Tomcat
	 * {@link Connector}. Calling this method will replace any existing customizers.
	 * @param tomcatConnectorCustomizers the customizers to set
	 */
	public void setTomcatConnectorCustomizers(
			Collection<? extends TomcatConnectorCustomizer> tomcatConnectorCustomizers) {
		Assert.notNull(tomcatConnectorCustomizers, 'TomcatConnectorCustomizers must not be null');
		this.tomcatConnectorCustomizers = new LinkedHashSet<>(tomcatConnectorCustomizers);
	}
	@Override
	public void addConnectorCustomizers(TomcatConnectorCustomizer... tomcatConnectorCustomizers) {
		Assert.notNull(tomcatConnectorCustomizers, 'TomcatConnectorCustomizers must not be null');
		this.tomcatConnectorCustomizers.addAll(Arrays.asList(tomcatConnectorCustomizers));
	}
	/**
	 * Returns a mutable collection of the {@link TomcatConnectorCustomizer}s that will be
	 * applied to the Tomcat {@link Connector}.
	 * @return the customizers that will be applied
	 */
	public Collection<TomcatConnectorCustomizer> getTomcatConnectorCustomizers() {
		return this.tomcatConnectorCustomizers;
	}
	/**
	 * Set {@link TomcatProtocolHandlerCustomizer}s that should be applied to the Tomcat
	 * {@link Connector}. Calling this method will replace any existing customizers.
	 * @param tomcatProtocolHandlerCustomizer the customizers to set
	 * @since 2.2.0
	 */
	public void setTomcatProtocolHandlerCustomizers(
			Collection<? extends TomcatProtocolHandlerCustomizer<?>> tomcatProtocolHandlerCustomizer) {
		Assert.notNull(tomcatProtocolHandlerCustomizer, 'TomcatProtocolHandlerCustomizers must not be null');
		this.tomcatProtocolHandlerCustomizers = new LinkedHashSet<>(tomcatProtocolHandlerCustomizer);
	}
	/**
	 * Add {@link TomcatProtocolHandlerCustomizer}s that should be added to the Tomcat
	 * {@link Connector}.
	 * @param tomcatProtocolHandlerCustomizers the customizers to add
	 * @since 2.2.0
	 */
	@Override
	public void addProtocolHandlerCustomizers(TomcatProtocolHandlerCustomizer<?>... tomcatProtocolHandlerCustomizers) {
		Assert.notNull(tomcatProtocolHandlerCustomizers, 'TomcatProtocolHandlerCustomizers must not be null');
		this.tomcatProtocolHandlerCustomizers.addAll(Arrays.asList(tomcatProtocolHandlerCustomizers));
	}
	/**
	 * Returns a mutable collection of the {@link TomcatProtocolHandlerCustomizer}s that
	 * will be applied to the Tomcat {@link Connector}.
	 * @return the customizers that will be applied
	 * @since 2.2.0
	 */
	public Collection<TomcatProtocolHandlerCustomizer<?>> getTomcatProtocolHandlerCustomizers() {
		return this.tomcatProtocolHandlerCustomizers;
	}
	/**
	 * Add {@link Connector}s in addition to the default connector, e.g. for SSL or AJP.
	 * <p>
	 * {@link #getTomcatConnectorCustomizers Connector customizers} are not applied to
	 * connectors added this way.
	 * @param connectors the connectors to add
	 */
	public void addAdditionalTomcatConnectors(Connector... connectors) {
		Assert.notNull(connectors, 'Connectors must not be null');
		this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));
	}
	/**
	 * Returns a mutable collection of the {@link Connector}s that will be added to the
	 * Tomcat.
	 * @return the additionalTomcatConnectors
	 */
	public List<Connector> getAdditionalTomcatConnectors() {
		return this.additionalTomcatConnectors;
	}
	@Override
	public void setUriEncoding(Charset uriEncoding) {
		this.uriEncoding = uriEncoding;
	}
	/**
	 * Returns the character encoding to use for URL decoding.
	 * @return the URI encoding
	 */
	public Charset getUriEncoding() {
		return this.uriEncoding;
	}
	@Override
	public void setBackgroundProcessorDelay(int delay) {
		this.backgroundProcessorDelay = delay;
	}
	/**
	 * Set whether the factory should disable Tomcat"s MBean registry prior to creating
	 * the server.
	 * @param disableMBeanRegistry whether to disable the MBean registry
	 * @since 2.2.0
	 */
	public void setDisableMBeanRegistry(boolean disableMBeanRegistry) {
		this.disableMBeanRegistry = disableMBeanRegistry;
	}
	/**
	 * {@link LifecycleListener} to disable persistence in the {@link StandardManager}. A
	 * {@link LifecycleListener} is used so not to interfere with Tomcat"s default manager
	 * creation logic.
	 */
	private static final class DisablePersistSessionListener implements LifecycleListener {
		@Override
		public void lifecycleEvent(LifecycleEvent event) {
			if (event.getType().equals(Lifecycle.START_EVENT)) {
				Context context = (Context) event.getLifecycle();
				Manager manager = context.getManager();
				if (manager instanceof StandardManager standardManager) {
					standardManager.setPathname(null);
				}
			}
		}
	}
	private final class StaticResourceConfigurer implements LifecycleListener {
		private static final String WEB_APP_MOUNT = '/';
		private static final String INTERNAL_PATH = '/META-INF/resources';
		private final Context context;
		private StaticResourceConfigurer(Context context) {
			this.context = context;
		}
		@Override
		public void lifecycleEvent(LifecycleEvent event) {
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				addResourceJars(getUrlsOfJarsWithMetaInfResources());
			}
		}
		private void addResourceJars(List<URL> resourceJarUrls) {
			for (URL url : resourceJarUrls) {
				String path = url.getPath();
				if (path.endsWith('.jar') || path.endsWith('.jar!/')) {
					String jar = url.toString();
					if (!jar.startsWith('jar:')) {
						// A jar file in the file system. Convert to Jar URL.
						jar = 'jar:' + jar + '!/';
					}
					addResourceSet(jar);
				}
				else {
					addResourceSet(url.toString());
				}
			}
		}
		private void addResourceSet(String resource) {
			try {
				if (isInsideClassicNestedJar(resource)) {
					addClassicNestedResourceSet(resource);
					return;
				}
				WebResourceRoot root = this.context.getResources();
				URL url = new URL(resource);
				if (isInsideNestedJar(resource)) {
					root.addJarResources(new NestedJarResourceSet(url, root, WEB_APP_MOUNT, INTERNAL_PATH));
				}
				else {
					root.createWebResourceSet(ResourceSetType.RESOURCE_JAR, WEB_APP_MOUNT, url, INTERNAL_PATH);
				}
			}
			catch (Exception ex) {
				// Ignore (probably not a directory)
			}
		}
		private void addClassicNestedResourceSet(String resource) throws MalformedURLException {
			// It"s a nested jar but we now don"t want the suffix because Tomcat
			// is going to try and locate it as a root URL (not the resource
			// inside it)
			URL url = new URL(resource.substring(0, resource.length() - 2));
			this.context.getResources()
				.createWebResourceSet(ResourceSetType.RESOURCE_JAR, WEB_APP_MOUNT, url, INTERNAL_PATH);
		}
		private boolean isInsideClassicNestedJar(String resource) {
			return !isInsideNestedJar(resource) && resource.indexOf('!/') < resource.lastIndexOf('!/');
		}
		private boolean isInsideNestedJar(String resource) {
			return resource.startsWith('jar:nested:');
		}
	}
	private static final class LoaderHidingResourceRoot extends StandardRoot {
		private LoaderHidingResourceRoot(TomcatEmbeddedContext context) {
			super(context);
		}
		@Override
		protected WebResourceSet createMainResourceSet() {
			return new LoaderHidingWebResourceSet(super.createMainResourceSet());
		}
	}
	private static final class LoaderHidingWebResourceSet extends AbstractResourceSet {
		private final WebResourceSet delegate;
		private final Method initInternal;
		private LoaderHidingWebResourceSet(WebResourceSet delegate) {
			this.delegate = delegate;
			try {
				this.initInternal = LifecycleBase.class.getDeclaredMethod('initInternal');
				this.initInternal.setAccessible(true);
			}
			catch (Exception ex) {
				throw new IllegalStateException(ex);
			}
		}
		@Override
		public WebResource getResource(String path) {
			if (path.startsWith('/org/springframework/boot')) {
				return new EmptyResource(getRoot(), path);
			}
			return this.delegate.getResource(path);
		}
		@Override
		public String[] list(String path) {
			return this.delegate.list(path);
		}
		@Override
		public Set<String> listWebAppPaths(String path) {
			return this.delegate.listWebAppPaths(path)
				.stream()
				.filter((webAppPath) -> !webAppPath.startsWith('/org/springframework/boot'))
				.collect(Collectors.toSet());
		}
		@Override
		public boolean mkdir(String path) {
			return this.delegate.mkdir(path);
		}
		@Override
		public boolean write(String path, InputStream is, boolean overwrite) {
			return this.delegate.write(path, is, overwrite);
		}
		@Override
		public URL getBaseUrl() {
			return this.delegate.getBaseUrl();
		}
		@Override
		public void setReadOnly(boolean readOnly) {
			this.delegate.setReadOnly(readOnly);
		}
		@Override
		public boolean isReadOnly() {
			return this.delegate.isReadOnly();
		}
		@Override
		public void gc() {
			this.delegate.gc();
		}
		@Override
		protected void initInternal() throws LifecycleException {
			if (this.delegate instanceof LifecycleBase) {
				try {
					ReflectionUtils.invokeMethod(this.initInternal, this.delegate);
				}
				catch (Exception ex) {
					throw new LifecycleException(ex);
				}
			}
		}
	}
	/**
	 * {@link Rfc6265CookieProcessor} that supports {@link CookieSameSiteSupplier
	 * supplied} {@link SameSite} values.
	 */
	private static class SuppliedSameSiteCookieProcessor extends Rfc6265CookieProcessor {
		private final List<CookieSameSiteSupplier> suppliers;
		SuppliedSameSiteCookieProcessor(List<CookieSameSiteSupplier> suppliers) {
			this.suppliers = suppliers;
		}
		@Override
		public String generateHeader(Cookie cookie, HttpServletRequest request) {
			SameSite sameSite = getSameSite(cookie);
			if (sameSite == null) {
				return super.generateHeader(cookie, request);
			}
			Rfc6265CookieProcessor delegate = new Rfc6265CookieProcessor();
			delegate.setSameSiteCookies(sameSite.attributeValue());
			return delegate.generateHeader(cookie, request);
		}
		private SameSite getSameSite(Cookie cookie) {
			for (CookieSameSiteSupplier supplier : this.suppliers) {
				SameSite sameSite = supplier.getSameSite(cookie);
				if (sameSite != null) {
					return sameSite;
				}
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.web.embedded.netty;
/**
final class CompressionCustomizer implements NettyServerCustomizer {
	private static final CompressionPredicate ALWAYS_COMPRESS = (request, response) -> true;
	private final Compression compression;
	CompressionCustomizer(Compression compression) {
		this.compression = compression;
	}
	@Override
	public HttpServer apply(HttpServer server) {
		if (!this.compression.getMinResponseSize().isNegative()) {
			server = server.compress((int) this.compression.getMinResponseSize().toBytes());
		}
		CompressionPredicate mimeTypes = getMimeTypesPredicate(this.compression.getMimeTypes());
		CompressionPredicate excludedUserAgents = getExcludedUserAgentsPredicate(
				this.compression.getExcludedUserAgents());
		server = server.compress(mimeTypes.and(excludedUserAgents));
		return server;
	}
	private CompressionPredicate getMimeTypesPredicate(String[] mimeTypeValues) {
		if (ObjectUtils.isEmpty(mimeTypeValues)) {
			return ALWAYS_COMPRESS;
		}
		List<MimeType> mimeTypes = Arrays.stream(mimeTypeValues).map(MimeTypeUtils::parseMimeType).toList();
		return (request, response) -> {
			String contentType = response.responseHeaders().get(HttpHeaderNames.CONTENT_TYPE);
			if (!StringUtils.hasLength(contentType)) {
				return false;
			}
			try {
				MimeType contentMimeType = MimeTypeUtils.parseMimeType(contentType);
				return mimeTypes.stream().anyMatch((candidate) -> candidate.isCompatibleWith(contentMimeType));
			}
			catch (InvalidMimeTypeException ex) {
				return false;
			}
		};
	}
	private CompressionPredicate getExcludedUserAgentsPredicate(String[] excludedUserAgents) {
		if (ObjectUtils.isEmpty(excludedUserAgents)) {
			return ALWAYS_COMPRESS;
		}
		return (request, response) -> {
			HttpHeaders headers = request.requestHeaders();
			return Arrays.stream(excludedUserAgents)
				.noneMatch((candidate) -> headers.contains(HttpHeaderNames.USER_AGENT, candidate, true));
		};
	}
	private interface CompressionPredicate extends BiPredicate<HttpServerRequest, HttpServerResponse> {
	}
}
/*
package org.springframework.boot.web.embedded.netty;
/**
@FunctionalInterface
public interface NettyRouteProvider extends Function<HttpServerRoutes, HttpServerRoutes> {
}
/*
package org.springframework.boot.web.embedded.netty;
/**
public class NettyWebServer implements WebServer {
	/**
	 * Permission denied error code from {@code errno.h}.
	 */
	private static final int ERROR_NO_EACCES = -13;
	private static final Predicate<HttpServerRequest> ALWAYS = (request) -> true;
	private static final Log logger = LogFactory.getLog(NettyWebServer.class);
	private final HttpServer httpServer;
	private final BiFunction<? super HttpServerRequest, ? super HttpServerResponse, ? extends Publisher<Void>> handler;
	private final Duration lifecycleTimeout;
	private final GracefulShutdown gracefulShutdown;
	private final ReactorResourceFactory resourceFactory;
	private List<NettyRouteProvider> routeProviders = Collections.emptyList();
	private volatile DisposableServer disposableServer;
	/**
	 * Creates a new {@code NettyWebServer} instance.
	 * @param httpServer the HTTP server
	 * @param handlerAdapter the handler adapter
	 * @param lifecycleTimeout the lifecycle timeout, may be {@code null}
	 * @param shutdown the shutdown, may be {@code null}
	 * @param resourceFactory the factory for the server"s {@link LoopResources loop
	 * resources}, may be {@code null}
	 * @since 3.2.0
	 */
	public NettyWebServer(HttpServer httpServer, ReactorHttpHandlerAdapter handlerAdapter, Duration lifecycleTimeout,
			Shutdown shutdown, ReactorResourceFactory resourceFactory) {
		Assert.notNull(httpServer, 'HttpServer must not be null');
		Assert.notNull(handlerAdapter, 'HandlerAdapter must not be null');
		this.lifecycleTimeout = lifecycleTimeout;
		this.handler = handlerAdapter;
		this.httpServer = httpServer.channelGroup(new DefaultChannelGroup(new DefaultEventExecutor()));
		this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(() -> this.disposableServer)
				: null;
		this.resourceFactory = resourceFactory;
	}
	public void setRouteProviders(List<NettyRouteProvider> routeProviders) {
		this.routeProviders = routeProviders;
	}
	@Override
	public void start() throws WebServerException {
		if (this.disposableServer == null) {
			try {
				this.disposableServer = startHttpServer();
			}
			catch (Exception ex) {
				PortInUseException.ifCausedBy(ex, ChannelBindException.class, (bindException) -> {
					if (bindException.localPort() > 0 && !isPermissionDenied(bindException.getCause())) {
						throw new PortInUseException(bindException.localPort(), ex);
					}
				});
				throw new WebServerException('Unable to start Netty', ex);
			}
			if (this.disposableServer != null) {
				logger.info(getStartedOnMessage(this.disposableServer));
			}
			startDaemonAwaitThread(this.disposableServer);
		}
	}
	private String getStartedOnMessage(DisposableServer server) {
		StringBuilder message = new StringBuilder();
		tryAppend(message, 'port %s', () -> server.port()
				+ ((this.httpServer.configuration().sslProvider() != null) ? ' (https)' : ' (http)'));
		tryAppend(message, 'path %s', server::path);
		return (!message.isEmpty()) ? 'Netty started on ' + message : 'Netty started';
	}
	protected String getStartedLogMessage() {
		return getStartedOnMessage(this.disposableServer);
	}
	private void tryAppend(StringBuilder message, String format, Supplier<Object> supplier) {
		try {
			Object value = supplier.get();
			message.append((!message.isEmpty()) ? ' ' : '');
			message.append(String.format(format, value));
		}
		catch (UnsupportedOperationException ex) {
			// Ignore
		}
	}
	DisposableServer startHttpServer() {
		HttpServer server = this.httpServer;
		if (this.routeProviders.isEmpty()) {
			server = server.handle(this.handler);
		}
		else {
			server = server.route(this::applyRouteProviders);
		}
		if (this.resourceFactory != null) {
			LoopResources resources = this.resourceFactory.getLoopResources();
			Assert.notNull(resources, 'No LoopResources: is ReactorResourceFactory not initialized yet?');
			server = server.runOn(resources);
		}
		if (this.lifecycleTimeout != null) {
			return server.bindNow(this.lifecycleTimeout);
		}
		return server.bindNow();
	}
	private boolean isPermissionDenied(Throwable bindExceptionCause) {
		try {
			if (bindExceptionCause instanceof NativeIoException nativeException) {
				return nativeException.expectedErr() == ERROR_NO_EACCES;
			}
		}
		catch (Throwable ignore) {
		}
		return false;
	}
	/**
	 * Initiates a graceful shutdown of the Netty web server. Handling of new requests is
	 * prevented and the given {@code callback} is invoked at the end of the attempt. The
	 * attempt can be explicitly ended by invoking {@link #stop}.
	 * <p>
	 * Once shutdown has been initiated Netty will reject any new connections. Requests +
	 * on existing idle connections will also be rejected.
	 */
	@Override
	public void shutDownGracefully(GracefulShutdownCallback callback) {
		if (this.gracefulShutdown == null) {
			callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE);
			return;
		}
		this.gracefulShutdown.shutDownGracefully(callback);
	}
	private void applyRouteProviders(HttpServerRoutes routes) {
		for (NettyRouteProvider provider : this.routeProviders) {
			routes = provider.apply(routes);
		}
		routes.route(ALWAYS, this.handler);
	}
	private void startDaemonAwaitThread(DisposableServer disposableServer) {
		Thread awaitThread = new Thread('server') {
			@Override
			public void run() {
				disposableServer.onDispose().block();
			}
		};
		awaitThread.setContextClassLoader(getClass().getClassLoader());
		awaitThread.setDaemon(false);
		awaitThread.start();
	}
	@Override
	public void stop() throws WebServerException {
		if (this.disposableServer != null) {
			if (this.gracefulShutdown != null) {
				this.gracefulShutdown.abort();
			}
			try {
				if (this.lifecycleTimeout != null) {
					this.disposableServer.disposeNow(this.lifecycleTimeout);
				}
				else {
					this.disposableServer.disposeNow();
				}
			}
			catch (IllegalStateException ex) {
				// Continue
			}
			this.disposableServer = null;
		}
	}
	@Override
	public int getPort() {
		if (this.disposableServer != null) {
			try {
				return this.disposableServer.port();
			}
			catch (UnsupportedOperationException ex) {
				return -1;
			}
		}
		return -1;
	}
}
/*
package org.springframework.boot.web.embedded.netty;
/**
final class GracefulShutdown {
	private static final Log logger = LogFactory.getLog(GracefulShutdown.class);
	private final Supplier<DisposableServer> disposableServer;
	private volatile Thread shutdownThread;
	private volatile boolean shuttingDown;
	GracefulShutdown(Supplier<DisposableServer> disposableServer) {
		this.disposableServer = disposableServer;
	}
	void shutDownGracefully(GracefulShutdownCallback callback) {
		DisposableServer server = this.disposableServer.get();
		if (server == null) {
			return;
		}
		logger.info('Commencing graceful shutdown. Waiting for active requests to complete');
		this.shutdownThread = new Thread(() -> doShutdown(callback, server), 'netty-shutdown');
		this.shutdownThread.start();
	}
	private void doShutdown(GracefulShutdownCallback callback, DisposableServer server) {
		this.shuttingDown = true;
		try {
			server.disposeNow(Duration.ofNanos(Long.MAX_VALUE));
			logger.info('Graceful shutdown complete');
			callback.shutdownComplete(GracefulShutdownResult.IDLE);
		}
		catch (Exception ex) {
			logger.info('Graceful shutdown aborted with one or more requests still active');
			callback.shutdownComplete(GracefulShutdownResult.REQUESTS_ACTIVE);
		}
		finally {
			this.shutdownThread = null;
			this.shuttingDown = false;
		}
	}
	void abort() {
		Thread shutdownThread = this.shutdownThread;
		if (shutdownThread != null) {
			while (!this.shuttingDown) {
				sleep(50);
			}
			shutdownThread.interrupt();
		}
	}
	private void sleep(long millis) {
		try {
			Thread.sleep(millis);
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
}
/*
package org.springframework.boot.web.embedded.netty;
/**
public class SslServerCustomizer implements NettyServerCustomizer {
	private static final Log logger = LogFactory.getLog(SslServerCustomizer.class);
	private final Http2 http2;
	private final ClientAuth clientAuth;
	private volatile SslProvider sslProvider;
	private final Map<String, SslProvider> serverNameSslProviders;
	public SslServerCustomizer(Http2 http2, Ssl.ClientAuth clientAuth, SslBundle sslBundle,
			Map<String, SslBundle> serverNameSslBundles) {
		this.http2 = http2;
		this.clientAuth = Ssl.ClientAuth.map(clientAuth, ClientAuth.NONE, ClientAuth.OPTIONAL, ClientAuth.REQUIRE);
		this.sslProvider = createSslProvider(sslBundle);
		this.serverNameSslProviders = createServerNameSslProviders(serverNameSslBundles);
		updateSslBundle(null, sslBundle);
	}
	@Override
	public HttpServer apply(HttpServer server) {
		return server.secure(this::applySecurity);
	}
	private void applySecurity(SslContextSpec spec) {
		spec.sslContext(this.sslProvider.getSslContext()).setSniAsyncMappings((serverName, promise) -> {
			SslProvider provider = (serverName != null) ? this.serverNameSslProviders.get(serverName)
					: this.sslProvider;
			return promise.setSuccess(provider);
		});
	}
	void updateSslBundle(String serverName, SslBundle sslBundle) {
		logger.debug('SSL Bundle has been updated, reloading SSL configuration');
		if (serverName == null) {
			this.sslProvider = createSslProvider(sslBundle);
		}
		else {
			this.serverNameSslProviders.put(serverName, createSslProvider(sslBundle));
		}
	}
	private Map<String, SslProvider> createServerNameSslProviders(Map<String, SslBundle> serverNameSslBundles) {
		Map<String, SslProvider> serverNameSslProviders = new HashMap<>();
		serverNameSslBundles
			.forEach((serverName, sslBundle) -> serverNameSslProviders.put(serverName, createSslProvider(sslBundle)));
		return serverNameSslProviders;
	}
	private SslProvider createSslProvider(SslBundle sslBundle) {
		return SslProvider.builder().sslContext((GenericSslContextSpec<?>) createSslContextSpec(sslBundle)).build();
	}
	/**
	 * Create an {@link AbstractProtocolSslContextSpec} for a given {@link SslBundle}.
	 * @param sslBundle the {@link SslBundle} to use
	 * @return an {@link AbstractProtocolSslContextSpec} instance
	 * @since 3.2.0
	 */
	protected final AbstractProtocolSslContextSpec<?> createSslContextSpec(SslBundle sslBundle) {
		AbstractProtocolSslContextSpec<?> sslContextSpec = (this.http2 != null && this.http2.isEnabled())
				? Http2SslContextSpec.forServer(sslBundle.getManagers().getKeyManagerFactory())
				: Http11SslContextSpec.forServer(sslBundle.getManagers().getKeyManagerFactory());
		return sslContextSpec.configure((builder) -> {
			builder.trustManager(sslBundle.getManagers().getTrustManagerFactory());
			SslOptions options = sslBundle.getOptions();
			builder.protocols(options.getEnabledProtocols());
			builder.ciphers(SslOptions.asSet(options.getCiphers()));
			builder.clientAuth(this.clientAuth);
		});
	}
}
/*
package org.springframework.boot.web.embedded.netty;
/**
public class NettyReactiveWebServerFactory extends AbstractReactiveWebServerFactory {
	private Set<NettyServerCustomizer> serverCustomizers = new LinkedHashSet<>();
	private final List<NettyRouteProvider> routeProviders = new ArrayList<>();
	private Duration lifecycleTimeout;
	private boolean useForwardHeaders;
	private ReactorResourceFactory resourceFactory;
	private Shutdown shutdown;
	public NettyReactiveWebServerFactory() {
	}
	public NettyReactiveWebServerFactory(int port) {
		super(port);
	}
	@Override
	public WebServer getWebServer(HttpHandler httpHandler) {
		HttpServer httpServer = createHttpServer();
		ReactorHttpHandlerAdapter handlerAdapter = new ReactorHttpHandlerAdapter(httpHandler);
		NettyWebServer webServer = createNettyWebServer(httpServer, handlerAdapter, this.lifecycleTimeout,
				getShutdown());
		webServer.setRouteProviders(this.routeProviders);
		return webServer;
	}
	NettyWebServer createNettyWebServer(HttpServer httpServer, ReactorHttpHandlerAdapter handlerAdapter,
			Duration lifecycleTimeout, Shutdown shutdown) {
		return new NettyWebServer(httpServer, handlerAdapter, lifecycleTimeout, shutdown, this.resourceFactory);
	}
	/**
	 * Returns a mutable collection of the {@link NettyServerCustomizer}s that will be
	 * applied to the Netty server builder.
	 * @return the customizers that will be applied
	 */
	public Collection<NettyServerCustomizer> getServerCustomizers() {
		return this.serverCustomizers;
	}
	/**
	 * Set {@link NettyServerCustomizer}s that should be applied to the Netty server
	 * builder. Calling this method will replace any existing customizers.
	 * @param serverCustomizers the customizers to set
	 */
	public void setServerCustomizers(Collection<? extends NettyServerCustomizer> serverCustomizers) {
		Assert.notNull(serverCustomizers, 'ServerCustomizers must not be null');
		this.serverCustomizers = new LinkedHashSet<>(serverCustomizers);
	}
	/**
	 * Add {@link NettyServerCustomizer}s that should be applied while building the
	 * server.
	 * @param serverCustomizers the customizers to add
	 */
	public void addServerCustomizers(NettyServerCustomizer... serverCustomizers) {
		Assert.notNull(serverCustomizers, 'ServerCustomizer must not be null');
		this.serverCustomizers.addAll(Arrays.asList(serverCustomizers));
	}
	/**
	 * Add {@link NettyRouteProvider}s that should be applied, in order, before the
	 * handler for the Spring application.
	 * @param routeProviders the route providers to add
	 */
	public void addRouteProviders(NettyRouteProvider... routeProviders) {
		Assert.notNull(routeProviders, 'NettyRouteProvider must not be null');
		this.routeProviders.addAll(Arrays.asList(routeProviders));
	}
	/**
	 * Set the maximum amount of time that should be waited when starting or stopping the
	 * server.
	 * @param lifecycleTimeout the lifecycle timeout
	 */
	public void setLifecycleTimeout(Duration lifecycleTimeout) {
		this.lifecycleTimeout = lifecycleTimeout;
	}
	/**
	 * Set if x-forward-* headers should be processed.
	 * @param useForwardHeaders if x-forward headers should be used
	 * @since 2.1.0
	 */
	public void setUseForwardHeaders(boolean useForwardHeaders) {
		this.useForwardHeaders = useForwardHeaders;
	}
	/**
	 * Set the {@link ReactorResourceFactory} to get the shared resources from.
	 * @param resourceFactory the server resources
	 * @since 2.1.0
	 */
	public void setResourceFactory(ReactorResourceFactory resourceFactory) {
		this.resourceFactory = resourceFactory;
	}
	@Override
	public void setShutdown(Shutdown shutdown) {
		this.shutdown = shutdown;
	}
	@Override
	public Shutdown getShutdown() {
		return this.shutdown;
	}
	private HttpServer createHttpServer() {
		HttpServer server = HttpServer.create().bindAddress(this::getListenAddress);
		if (Ssl.isEnabled(getSsl())) {
			server = customizeSslConfiguration(server);
		}
		if (getCompression() != null && getCompression().getEnabled()) {
			CompressionCustomizer compressionCustomizer = new CompressionCustomizer(getCompression());
			server = compressionCustomizer.apply(server);
		}
		server = server.protocol(listProtocols()).forwarded(this.useForwardHeaders);
		return applyCustomizers(server);
	}
	private HttpServer customizeSslConfiguration(HttpServer httpServer) {
		SslServerCustomizer customizer = new SslServerCustomizer(getHttp2(), getSsl().getClientAuth(), getSslBundle(),
				getServerNameSslBundles());
		addBundleUpdateHandler(null, getSsl().getBundle(), customizer);
		getSsl().getServerNameBundles()
			.forEach((serverNameSslBundle) -> addBundleUpdateHandler(serverNameSslBundle.serverName(),
					serverNameSslBundle.bundle(), customizer));
		return customizer.apply(httpServer);
	}
	private void addBundleUpdateHandler(String serverName, String bundleName, SslServerCustomizer customizer) {
		if (StringUtils.hasText(bundleName)) {
			getSslBundles().addBundleUpdateHandler(bundleName,
					(sslBundle) -> customizer.updateSslBundle(serverName, sslBundle));
		}
	}
	private HttpProtocol[] listProtocols() {
		List<HttpProtocol> protocols = new ArrayList<>();
		protocols.add(HttpProtocol.HTTP11);
		if (getHttp2() != null && getHttp2().isEnabled()) {
			if (getSsl() != null && getSsl().isEnabled()) {
				protocols.add(HttpProtocol.H2);
			}
			else {
				protocols.add(HttpProtocol.H2C);
			}
		}
		return protocols.toArray(new HttpProtocol[0]);
	}
	private InetSocketAddress getListenAddress() {
		if (getAddress() != null) {
			return new InetSocketAddress(getAddress().getHostAddress(), getPort());
		}
		return new InetSocketAddress(getPort());
	}
	private HttpServer applyCustomizers(HttpServer server) {
		for (NettyServerCustomizer customizer : this.serverCustomizers) {
			server = customizer.apply(server);
		}
		return server;
	}
}
/*
/**
package org.springframework.boot.web.embedded.netty;
/*
package org.springframework.boot.web.embedded.netty;
/**
@FunctionalInterface
public interface NettyServerCustomizer extends Function<HttpServer, HttpServer> {
}
/*
package org.springframework.boot.web.server;
/**
@FunctionalInterface
public interface ErrorPageRegistry {
	/**
	 * Adds error pages that will be used when handling exceptions.
	 * @param errorPages the error pages
	 */
	void addErrorPages(ErrorPage... errorPages);
}
/*
package org.springframework.boot.web.server;
/**
public interface WebServer {
	/**
	 * Starts the web server. Calling this method on an already started server has no
	 * effect.
	 * @throws WebServerException if the server cannot be started
	 */
	void start() throws WebServerException;
	/**
	 * Stops the web server. Calling this method on an already stopped server has no
	 * effect.
	 * @throws WebServerException if the server cannot be stopped
	 */
	void stop() throws WebServerException;
	/**
	 * Return the port this server is listening on.
	 * @return the port (or -1 if none)
	 */
	int getPort();
	/**
	 * Initiates a graceful shutdown of the web server. Handling of new requests is
	 * prevented and the given {@code callback} is invoked at the end of the attempt. The
	 * attempt can be explicitly ended by invoking {@link #stop}. The default
	 * implementation invokes the callback immediately with
	 * {@link GracefulShutdownResult#IMMEDIATE}, i.e. no attempt is made at a graceful
	 * shutdown.
	 * @param callback the callback to invoke when the graceful shutdown completes
	 * @since 2.3.0
	 */
	default void shutDownGracefully(GracefulShutdownCallback callback) {
		callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE);
	}
	/**
	 * Destroys the web server such that it cannot be started again.
	 * @since 3.2.0
	 */
	default void destroy() {
		stop();
	}
}
/*
package org.springframework.boot.web.server;
/**
public class Ssl {
	private boolean enabled = true;
	private String bundle;
	private ClientAuth clientAuth;
	private String[] ciphers;
	private String[] enabledProtocols;
	private String keyAlias;
	private String keyPassword;
	private String keyStore;
	private String keyStorePassword;
	private String keyStoreType;
	private String keyStoreProvider;
	private String trustStore;
	private String trustStorePassword;
	private String trustStoreType;
	private String trustStoreProvider;
	private String certificate;
	private String certificatePrivateKey;
	private String trustCertificate;
	private String trustCertificatePrivateKey;
	private String protocol = 'TLS';
	private List<ServerNameSslBundle> serverNameBundles = new ArrayList<>();
	/**
	 * Return whether to enable SSL support.
	 * @return whether to enable SSL support
	 */
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	/**
	 * Return the name of the SSL bundle to use.
	 * @return the SSL bundle name
	 * @since 3.1.0
	 */
	public String getBundle() {
		return this.bundle;
	}
	/**
	 * Set the name of the SSL bundle to use.
	 * @param bundle the SSL bundle name
	 * @since 3.1.0
	 */
	public void setBundle(String bundle) {
		this.bundle = bundle;
	}
	/**
	 * Return Whether client authentication is not wanted ('none'), wanted ('want') or
	 * needed ('need'). Requires a trust store.
	 * @return the {@link ClientAuth} to use
	 */
	public ClientAuth getClientAuth() {
		return this.clientAuth;
	}
	public void setClientAuth(ClientAuth clientAuth) {
		this.clientAuth = clientAuth;
	}
	/**
	 * Return the supported SSL ciphers.
	 * @return the supported SSL ciphers
	 */
	public String[] getCiphers() {
		return this.ciphers;
	}
	public void setCiphers(String[] ciphers) {
		this.ciphers = ciphers;
	}
	/**
	 * Return the enabled SSL protocols.
	 * @return the enabled SSL protocols.
	 */
	public String[] getEnabledProtocols() {
		return this.enabledProtocols;
	}
	public void setEnabledProtocols(String[] enabledProtocols) {
		this.enabledProtocols = enabledProtocols;
	}
	/**
	 * Return the alias that identifies the key in the key store.
	 * @return the key alias
	 */
	public String getKeyAlias() {
		return this.keyAlias;
	}
	public void setKeyAlias(String keyAlias) {
		this.keyAlias = keyAlias;
	}
	/**
	 * Return the password used to access the key in the key store.
	 * @return the key password
	 */
	public String getKeyPassword() {
		return this.keyPassword;
	}
	public void setKeyPassword(String keyPassword) {
		this.keyPassword = keyPassword;
	}
	/**
	 * Return the path to the key store that holds the SSL certificate (typically a jks
	 * file).
	 * @return the path to the key store
	 */
	public String getKeyStore() {
		return this.keyStore;
	}
	public void setKeyStore(String keyStore) {
		this.keyStore = keyStore;
	}
	/**
	 * Return the password used to access the key store.
	 * @return the key store password
	 */
	public String getKeyStorePassword() {
		return this.keyStorePassword;
	}
	public void setKeyStorePassword(String keyStorePassword) {
		this.keyStorePassword = keyStorePassword;
	}
	/**
	 * Return the type of the key store.
	 * @return the key store type
	 */
	public String getKeyStoreType() {
		return this.keyStoreType;
	}
	public void setKeyStoreType(String keyStoreType) {
		this.keyStoreType = keyStoreType;
	}
	/**
	 * Return the provider for the key store.
	 * @return the key store provider
	 */
	public String getKeyStoreProvider() {
		return this.keyStoreProvider;
	}
	public void setKeyStoreProvider(String keyStoreProvider) {
		this.keyStoreProvider = keyStoreProvider;
	}
	/**
	 * Return the trust store that holds SSL certificates.
	 * @return the trust store
	 */
	public String getTrustStore() {
		return this.trustStore;
	}
	public void setTrustStore(String trustStore) {
		this.trustStore = trustStore;
	}
	/**
	 * Return the password used to access the trust store.
	 * @return the trust store password
	 */
	public String getTrustStorePassword() {
		return this.trustStorePassword;
	}
	public void setTrustStorePassword(String trustStorePassword) {
		this.trustStorePassword = trustStorePassword;
	}
	/**
	 * Return the type of the trust store.
	 * @return the trust store type
	 */
	public String getTrustStoreType() {
		return this.trustStoreType;
	}
	public void setTrustStoreType(String trustStoreType) {
		this.trustStoreType = trustStoreType;
	}
	/**
	 * Return the provider for the trust store.
	 * @return the trust store provider
	 */
	public String getTrustStoreProvider() {
		return this.trustStoreProvider;
	}
	public void setTrustStoreProvider(String trustStoreProvider) {
		this.trustStoreProvider = trustStoreProvider;
	}
	/**
	 * Return the location of the certificate in PEM format.
	 * @return the certificate location
	 */
	public String getCertificate() {
		return this.certificate;
	}
	public void setCertificate(String certificate) {
		this.certificate = certificate;
	}
	/**
	 * Return the location of the private key for the certificate in PEM format.
	 * @return the location of the certificate private key
	 */
	public String getCertificatePrivateKey() {
		return this.certificatePrivateKey;
	}
	public void setCertificatePrivateKey(String certificatePrivateKey) {
		this.certificatePrivateKey = certificatePrivateKey;
	}
	/**
	 * Return the location of the trust certificate authority chain in PEM format.
	 * @return the location of the trust certificate
	 */
	public String getTrustCertificate() {
		return this.trustCertificate;
	}
	public void setTrustCertificate(String trustCertificate) {
		this.trustCertificate = trustCertificate;
	}
	/**
	 * Return the location of the private key for the trust certificate in PEM format.
	 * @return the location of the trust certificate private key
	 */
	public String getTrustCertificatePrivateKey() {
		return this.trustCertificatePrivateKey;
	}
	public void setTrustCertificatePrivateKey(String trustCertificatePrivateKey) {
		this.trustCertificatePrivateKey = trustCertificatePrivateKey;
	}
	/**
	 * Return the SSL protocol to use.
	 * @return the SSL protocol
	 */
	public String getProtocol() {
		return this.protocol;
	}
	public void setProtocol(String protocol) {
		this.protocol = protocol;
	}
	/**
	 * Returns if SSL is enabled for the given instance.
	 * @param ssl the {@link Ssl SSL} instance or {@code null}
	 * @return {@code true} if SSL is enabled
	 * @since 3.1.0
	 */
	public static boolean isEnabled(Ssl ssl) {
		return (ssl != null) && ssl.isEnabled();
	}
	/**
	 * Return the mapping of host names to SSL bundles for SNI configuration.
	 * @return the host name to SSL bundle mapping
	 */
	public List<ServerNameSslBundle> getServerNameBundles() {
		return this.serverNameBundles;
	}
	public void setServerNameBundles(List<ServerNameSslBundle> serverNameBundles) {
		this.serverNameBundles = serverNameBundles;
	}
	/**
	 * Factory method to create an {@link Ssl} instance for a specific bundle name.
	 * @param bundle the name of the bundle
	 * @return a new {@link Ssl} instance with the bundle set
	 * @since 3.1.0
	 */
	public static Ssl forBundle(String bundle) {
		Ssl ssl = new Ssl();
		ssl.setBundle(bundle);
		return ssl;
	}
	public record ServerNameSslBundle(String serverName, String bundle) {
	}
	/**
	 * Client authentication types.
	 */
	public enum ClientAuth {
		/**
		 * Client authentication is not wanted.
		 */
		NONE,
		/**
		 * Client authentication is wanted but not mandatory.
		 */
		WANT,
		/**
		 * Client authentication is needed and mandatory.
		 */
		NEED;
		/**
		 * Map an optional {@link ClientAuth} value to a different type.
		 * @param <R> the result type
		 * @param clientAuth the client auth to map (may be {@code null})
		 * @param none the value for {@link ClientAuth#NONE} or {@code null}
		 * @param want the value for {@link ClientAuth#WANT}
		 * @param need the value for {@link ClientAuth#NEED}
		 * @return the mapped value
		 * @since 3.1.0
		 */
		public static <R> R map(ClientAuth clientAuth, R none, R want, R need) {
			return switch ((clientAuth != null) ? clientAuth : NONE) {
				case NONE -> none;
				case WANT -> want;
				case NEED -> need;
			};
		}
	}
}
/*
package org.springframework.boot.web.server;
/**
public class Cookie {
	/**
	 * Name for the cookie.
	 */
	private String name;
	/**
	 * Domain for the cookie.
	 */
	private String domain;
	/**
	 * Path of the cookie.
	 */
	private String path;
	/**
	 * Whether to use 'HttpOnly' cookies for the cookie.
	 */
	private Boolean httpOnly;
	/**
	 * Whether to always mark the cookie as secure.
	 */
	private Boolean secure;
	/**
	 * Whether the generated cookie carries the Partitioned attribute.
	 */
	private Boolean partitioned;
	/**
	 * Maximum age of the cookie. If a duration suffix is not specified, seconds will be
	 * used. A positive value indicates when the cookie expires relative to the current
	 * time. A value of 0 means the cookie should expire immediately. A negative value
	 * means no 'Max-Age'.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration maxAge;
	/**
	 * SameSite setting for the cookie.
	 */
	private SameSite sameSite;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDomain() {
		return this.domain;
	}
	public void setDomain(String domain) {
		this.domain = domain;
	}
	public String getPath() {
		return this.path;
	}
	public void setPath(String path) {
		this.path = path;
	}
	public Boolean getHttpOnly() {
		return this.httpOnly;
	}
	public void setHttpOnly(Boolean httpOnly) {
		this.httpOnly = httpOnly;
	}
	public Boolean getSecure() {
		return this.secure;
	}
	public void setSecure(Boolean secure) {
		this.secure = secure;
	}
	public Duration getMaxAge() {
		return this.maxAge;
	}
	public void setMaxAge(Duration maxAge) {
		this.maxAge = maxAge;
	}
	public SameSite getSameSite() {
		return this.sameSite;
	}
	public void setSameSite(SameSite sameSite) {
		this.sameSite = sameSite;
	}
	public Boolean getPartitioned() {
		return this.partitioned;
	}
	public void setPartitioned(Boolean partitioned) {
		this.partitioned = partitioned;
	}
	/**
	 * SameSite values.
	 */
	public enum SameSite {
		/**
		 * Cookies are sent in both first-party and cross-origin requests.
		 */
		NONE('None'),
		/**
		 * Cookies are sent in a first-party context, also when following a link to the
		 * origin site.
		 */
		LAX('Lax'),
		/**
		 * Cookies are only sent in a first-party context (i.e. not when following a link
		 * to the origin site).
		 */
		STRICT('Strict');
		private final String attributeValue;
		SameSite(String attributeValue) {
			this.attributeValue = attributeValue;
		}
		public String attributeValue() {
			return this.attributeValue;
		}
	}
}
/*
package org.springframework.boot.web.server;
/**
public class Compression {
	private boolean enabled = false;
	private String[] mimeTypes = new String[] { 'text/html', 'text/xml', 'text/plain', 'text/css', 'text/javascript',
			'application/javascript', 'application/json', 'application/xml' };
	private String[] excludedUserAgents = null;
	private DataSize minResponseSize = DataSize.ofKilobytes(2);
	/**
	 * Return whether response compression is enabled.
	 * @return {@code true} if response compression is enabled
	 */
	public boolean getEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	/**
	 * Return the MIME types that should be compressed.
	 * @return the MIME types that should be compressed
	 */
	public String[] getMimeTypes() {
		return this.mimeTypes;
	}
	public void setMimeTypes(String[] mimeTypes) {
		this.mimeTypes = mimeTypes;
	}
	public String[] getExcludedUserAgents() {
		return this.excludedUserAgents;
	}
	public void setExcludedUserAgents(String[] excludedUserAgents) {
		this.excludedUserAgents = excludedUserAgents;
	}
	/**
	 * Return the minimum 'Content-Length' value that is required for compression to be
	 * performed.
	 * @return the minimum content size in bytes that is required for compression
	 */
	public DataSize getMinResponseSize() {
		return this.minResponseSize;
	}
	public void setMinResponseSize(DataSize minSize) {
		this.minResponseSize = minSize;
	}
}
/*
package org.springframework.boot.web.server;
/**
public class WebServerFactoryCustomizerBeanPostProcessor implements BeanPostProcessor, BeanFactoryAware {
	private ListableBeanFactory beanFactory;
	private List<WebServerFactoryCustomizer<?>> customizers;
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		Assert.isInstanceOf(ListableBeanFactory.class, beanFactory,
				'WebServerCustomizerBeanPostProcessor can only be used with a ListableBeanFactory');
		this.beanFactory = (ListableBeanFactory) beanFactory;
	}
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof WebServerFactory webServerFactory) {
			postProcessBeforeInitialization(webServerFactory);
		}
		return bean;
	}
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
	@SuppressWarnings('unchecked')
	private void postProcessBeforeInitialization(WebServerFactory webServerFactory) {
		LambdaSafe.callbacks(WebServerFactoryCustomizer.class, getCustomizers(), webServerFactory)
			.withLogger(WebServerFactoryCustomizerBeanPostProcessor.class)
			.invoke((customizer) -> customizer.customize(webServerFactory));
	}
	private Collection<WebServerFactoryCustomizer<?>> getCustomizers() {
		if (this.customizers == null) {
			// Look up does not include the parent context
			this.customizers = new ArrayList<>(getWebServerFactoryCustomizerBeans());
			this.customizers.sort(AnnotationAwareOrderComparator.INSTANCE);
			this.customizers = Collections.unmodifiableList(this.customizers);
		}
		return this.customizers;
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private Collection<WebServerFactoryCustomizer<?>> getWebServerFactoryCustomizerBeans() {
		return (Collection) this.beanFactory.getBeansOfType(WebServerFactoryCustomizer.class, false, false).values();
	}
}
/*
package org.springframework.boot.web.server;
/**
public class ErrorPageRegistrarBeanPostProcessor implements BeanPostProcessor, BeanFactoryAware {
	private ListableBeanFactory beanFactory;
	private List<ErrorPageRegistrar> registrars;
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		Assert.isInstanceOf(ListableBeanFactory.class, beanFactory,
				'ErrorPageRegistrarBeanPostProcessor can only be used with a ListableBeanFactory');
		this.beanFactory = (ListableBeanFactory) beanFactory;
	}
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof ErrorPageRegistry errorPageRegistry) {
			postProcessBeforeInitialization(errorPageRegistry);
		}
		return bean;
	}
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
	private void postProcessBeforeInitialization(ErrorPageRegistry registry) {
		for (ErrorPageRegistrar registrar : getRegistrars()) {
			registrar.registerErrorPages(registry);
		}
	}
	private Collection<ErrorPageRegistrar> getRegistrars() {
		if (this.registrars == null) {
			// Look up does not include the parent context
			this.registrars = new ArrayList<>(
					this.beanFactory.getBeansOfType(ErrorPageRegistrar.class, false, false).values());
			this.registrars.sort(AnnotationAwareOrderComparator.INSTANCE);
			this.registrars = Collections.unmodifiableList(this.registrars);
		}
		return this.registrars;
	}
}
/*
package org.springframework.boot.web.server;
/**
public interface ConfigurableWebServerFactory extends WebServerFactory, ErrorPageRegistry {
	/**
	 * Sets the port that the web server should listen on. If not specified port "8080"
	 * will be used. Use port -1 to disable auto-start (i.e. start the web application
	 * context but not have it listen to any port).
	 * @param port the port to set
	 */
	void setPort(int port);
	/**
	 * Sets the specific network address that the server should bind to.
	 * @param address the address to set (defaults to {@code null})
	 */
	void setAddress(InetAddress address);
	/**
	 * Sets the error pages that will be used when handling exceptions.
	 * @param errorPages the error pages
	 */
	void setErrorPages(Set<? extends ErrorPage> errorPages);
	/**
	 * Sets the SSL configuration that will be applied to the server"s default connector.
	 * @param ssl the SSL configuration
	 */
	void setSsl(Ssl ssl);
	/**
	 * Sets the SSL bundles that can be used to configure SSL connections.
	 * @param sslBundles the SSL bundles
	 * @since 3.1.0
	 */
	void setSslBundles(SslBundles sslBundles);
	/**
	 * Sets the HTTP/2 configuration that will be applied to the server.
	 * @param http2 the HTTP/2 configuration
	 */
	void setHttp2(Http2 http2);
	/**
	 * Sets the compression configuration that will be applied to the server"s default
	 * connector.
	 * @param compression the compression configuration
	 */
	void setCompression(Compression compression);
	/**
	 * Sets the server header value.
	 * @param serverHeader the server header value
	 */
	void setServerHeader(String serverHeader);
	/**
	 * Sets the shutdown configuration that will be applied to the server.
	 * @param shutdown the shutdown configuration
	 * @since 2.3.0
	 */
	default void setShutdown(Shutdown shutdown) {
	}
}
/*
package org.springframework.boot.web.server;
/**
@SuppressWarnings('serial')
public class WebServerException extends RuntimeException {
	public WebServerException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.web.server;
/**
@FunctionalInterface
public interface GracefulShutdownCallback {
	/**
	 * Graceful shutdown has completed with the given {@code result}.
	 * @param result the result of the shutdown
	 */
	void shutdownComplete(GracefulShutdownResult result);
}
/*
package org.springframework.boot.web.server;
/**
public sealed class MimeMappings implements Iterable<MimeMappings.Mapping> {
	/**
	 * Default mime mapping commonly used.
	 */
	public static final MimeMappings DEFAULT = new DefaultMimeMappings();
	private final Map<String, Mapping> map;
	/**
	 * Create a new empty {@link MimeMappings} instance.
	 */
	public MimeMappings() {
		this.map = new LinkedHashMap<>();
	}
	/**
	 * Create a new {@link MimeMappings} instance from the specified mappings.
	 * @param mappings the source mappings
	 */
	public MimeMappings(MimeMappings mappings) {
		this(mappings, true);
	}
	/**
	 * Create a new {@link MimeMappings} from the specified mappings.
	 * @param mappings the source mappings with extension as the key and mime-type as the
	 * value
	 */
	public MimeMappings(Map<String, String> mappings) {
		Assert.notNull(mappings, 'Mappings must not be null');
		this.map = new LinkedHashMap<>();
		mappings.forEach(this::add);
	}
	/**
	 * Internal constructor.
	 * @param mappings source mappings
	 * @param mutable if the new object should be mutable.
	 */
	MimeMappings(MimeMappings mappings, boolean mutable) {
		Assert.notNull(mappings, 'Mappings must not be null');
		this.map = (mutable ? new LinkedHashMap<>(mappings.map) : Collections.unmodifiableMap(mappings.map));
	}
	/**
	 * Add a new mime mapping.
	 * @param extension the file extension (excluding ".")
	 * @param mimeType the mime type to map
	 * @return any previous mapping or {@code null}
	 */
	public String add(String extension, String mimeType) {
		Assert.notNull(extension, 'Extension must not be null');
		Assert.notNull(mimeType, 'MimeType must not be null');
		Mapping previous = this.map.put(extension.toLowerCase(Locale.ENGLISH), new Mapping(extension, mimeType));
		return (previous != null) ? previous.getMimeType() : null;
	}
	/**
	 * Remove an existing mapping.
	 * @param extension the file extension (excluding ".")
	 * @return the removed mime mapping or {@code null} if no item was removed
	 */
	public String remove(String extension) {
		Assert.notNull(extension, 'Extension must not be null');
		Mapping previous = this.map.remove(extension.toLowerCase(Locale.ENGLISH));
		return (previous != null) ? previous.getMimeType() : null;
	}
	/**
	 * Get a mime mapping for the given extension.
	 * @param extension the file extension (excluding ".")
	 * @return a mime mapping or {@code null}
	 */
	public String get(String extension) {
		Assert.notNull(extension, 'Extension must not be null');
		Mapping mapping = this.map.get(extension.toLowerCase(Locale.ENGLISH));
		return (mapping != null) ? mapping.getMimeType() : null;
	}
	/**
	 * Returns all defined mappings.
	 * @return the mappings.
	 */
	public Collection<Mapping> getAll() {
		return this.map.values();
	}
	@Override
	public final Iterator<Mapping> iterator() {
		return getAll().iterator();
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null) {
			return false;
		}
		if (obj == this) {
			return true;
		}
		if (obj instanceof MimeMappings other) {
			return getMap().equals(other.map);
		}
		return false;
	}
	@Override
	public int hashCode() {
		return getMap().hashCode();
	}
	Map<String, Mapping> getMap() {
		return this.map;
	}
	/**
	 * Create a new unmodifiable view of the specified mapping. Methods that attempt to
	 * modify the returned map will throw {@link UnsupportedOperationException}s.
	 * @param mappings the mappings
	 * @return an unmodifiable view of the specified mappings.
	 */
	public static MimeMappings unmodifiableMappings(MimeMappings mappings) {
		Assert.notNull(mappings, 'Mappings must not be null');
		return new MimeMappings(mappings, false);
	}
	/**
	 * Create a new lazy copy of the given mappings that will only copy entries if the
	 * mappings are mutated.
	 * @param mappings the source mappings
	 * @return a new mappings instance
	 * @since 3.0.0
	 */
	public static MimeMappings lazyCopy(MimeMappings mappings) {
		Assert.notNull(mappings, 'Mappings must not be null');
		return new LazyMimeMappingsCopy(mappings);
	}
	/**
	 * A single mime mapping.
	 */
	public static final class Mapping {
		private final String extension;
		private final String mimeType;
		public Mapping(String extension, String mimeType) {
			Assert.notNull(extension, 'Extension must not be null');
			Assert.notNull(mimeType, 'MimeType must not be null');
			this.extension = extension;
			this.mimeType = mimeType;
		}
		public String getExtension() {
			return this.extension;
		}
		public String getMimeType() {
			return this.mimeType;
		}
		@Override
		public boolean equals(Object obj) {
			if (obj == null) {
				return false;
			}
			if (obj == this) {
				return true;
			}
			if (obj instanceof Mapping other) {
				return this.extension.equals(other.extension) && this.mimeType.equals(other.mimeType);
			}
			return false;
		}
		@Override
		public int hashCode() {
			return this.extension.hashCode();
		}
		@Override
		public String toString() {
			return 'Mapping [extension=' + this.extension + ', mimeType=' + this.mimeType + ']';
		}
	}
	/**
	 * {@link MimeMappings} implementation used for {@link MimeMappings#DEFAULT}. Provides
	 * in-memory access for common mappings and lazily loads the complete set when
	 * necessary.
	 */
	static final class DefaultMimeMappings extends MimeMappings {
		static final String MIME_MAPPINGS_PROPERTIES = 'mime-mappings.properties';
		private static final MimeMappings COMMON;
		static {
			MimeMappings mappings = new MimeMappings();
			mappings.add('avi', 'video/x-msvideo');
			mappings.add('bin', 'application/octet-stream');
			mappings.add('body', 'text/html');
			mappings.add('class', 'application/java');
			mappings.add('css', 'text/css');
			mappings.add('dtd', 'application/xml-dtd');
			mappings.add('gif', 'image/gif');
			mappings.add('gtar', 'application/x-gtar');
			mappings.add('gz', 'application/x-gzip');
			mappings.add('htm', 'text/html');
			mappings.add('html', 'text/html');
			mappings.add('jar', 'application/java-archive');
			mappings.add('java', 'text/x-java-source');
			mappings.add('jnlp', 'application/x-java-jnlp-file');
			mappings.add('jpe', 'image/jpeg');
			mappings.add('jpeg', 'image/jpeg');
			mappings.add('jpg', 'image/jpeg');
			mappings.add('js', 'text/javascript');
			mappings.add('json', 'application/json');
			mappings.add('otf', 'font/otf');
			mappings.add('pdf', 'application/pdf');
			mappings.add('png', 'image/png');
			mappings.add('ps', 'application/postscript');
			mappings.add('tar', 'application/x-tar');
			mappings.add('tif', 'image/tiff');
			mappings.add('tiff', 'image/tiff');
			mappings.add('ttf', 'font/ttf');
			mappings.add('txt', 'text/plain');
			mappings.add('xht', 'application/xhtml+xml');
			mappings.add('xhtml', 'application/xhtml+xml');
			mappings.add('xls', 'application/vnd.ms-excel');
			mappings.add('xml', 'application/xml');
			mappings.add('xsl', 'application/xml');
			mappings.add('xslt', 'application/xslt+xml');
			mappings.add('wasm', 'application/wasm');
			mappings.add('zip', 'application/zip');
			COMMON = unmodifiableMappings(mappings);
		}
		private volatile Map<String, Mapping> loaded;
		DefaultMimeMappings() {
			super(new MimeMappings(), false);
		}
		@Override
		public Collection<Mapping> getAll() {
			return load().values();
		}
		@Override
		public String get(String extension) {
			Assert.notNull(extension, 'Extension must not be null');
			extension = extension.toLowerCase(Locale.ENGLISH);
			Map<String, Mapping> loaded = this.loaded;
			if (loaded != null) {
				return get(loaded, extension);
			}
			String commonMimeType = COMMON.get(extension);
			if (commonMimeType != null) {
				return commonMimeType;
			}
			loaded = load();
			return get(loaded, extension);
		}
		private String get(Map<String, Mapping> mappings, String extension) {
			Mapping mapping = mappings.get(extension);
			return (mapping != null) ? mapping.getMimeType() : null;
		}
		@Override
		Map<String, Mapping> getMap() {
			return load();
		}
		private Map<String, Mapping> load() {
			Map<String, Mapping> loaded = this.loaded;
			if (loaded != null) {
				return loaded;
			}
			try {
				loaded = new LinkedHashMap<>();
				for (Entry<?, ?> entry : PropertiesLoaderUtils
					.loadProperties(new ClassPathResource(MIME_MAPPINGS_PROPERTIES, getClass()))
					.entrySet()) {
					loaded.put((String) entry.getKey(),
							new Mapping((String) entry.getKey(), (String) entry.getValue()));
				}
				loaded = Collections.unmodifiableMap(loaded);
				this.loaded = loaded;
				return loaded;
			}
			catch (IOException ex) {
				throw new IllegalArgumentException('Unable to load the default MIME types', ex);
			}
		}
	}
	/**
	 * {@link MimeMappings} implementation used to create a lazy copy only when the
	 * mappings are mutated.
	 */
	static final class LazyMimeMappingsCopy extends MimeMappings {
		private final MimeMappings source;
		private final AtomicBoolean copied = new AtomicBoolean();
		LazyMimeMappingsCopy(MimeMappings source) {
			this.source = source;
		}
		@Override
		public String add(String extension, String mimeType) {
			copyIfNecessary();
			return super.add(extension, mimeType);
		}
		@Override
		public String remove(String extension) {
			copyIfNecessary();
			return super.remove(extension);
		}
		private void copyIfNecessary() {
			if (this.copied.compareAndSet(false, true)) {
				this.source.forEach((mapping) -> add(mapping.getExtension(), mapping.getMimeType()));
			}
		}
		@Override
		public String get(String extension) {
			return !this.copied.get() ? this.source.get(extension) : super.get(extension);
		}
		@Override
		public Collection<Mapping> getAll() {
			return !this.copied.get() ? this.source.getAll() : super.getAll();
		}
		@Override
		Map<String, Mapping> getMap() {
			return !this.copied.get() ? this.source.getMap() : super.getMap();
		}
	}
	static class MimeMappingsRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources()
				.registerPattern('org/springframework/boot/web/server/' + DefaultMimeMappings.MIME_MAPPINGS_PROPERTIES);
		}
	}
}
/*
package org.springframework.boot.web.server;
/**
public enum Shutdown {
	/**
	 * The {@link WebServer} should support graceful shutdown, allowing active requests
	 * time to complete.
	 */
	GRACEFUL,
	/**
	 * The {@link WebServer} should shut down immediately.
	 */
	IMMEDIATE
}
/*
package org.springframework.boot.web.server;
/**
public interface WebServerFactory {
}
/*
package org.springframework.boot.web.server;
/**
public class ErrorPage {
	private final HttpStatus status;
	private final Class<? extends Throwable> exception;
	private final String path;
	public ErrorPage(String path) {
		this.status = null;
		this.exception = null;
		this.path = path;
	}
	public ErrorPage(HttpStatus status, String path) {
		this.status = status;
		this.exception = null;
		this.path = path;
	}
	public ErrorPage(Class<? extends Throwable> exception, String path) {
		this.status = null;
		this.exception = exception;
		this.path = path;
	}
	/**
	 * The path to render (usually implemented as a forward), starting with '/'. A custom
	 * controller or servlet path can be used, or if the server supports it, a template
	 * path (e.g. '/error.jsp').
	 * @return the path that will be rendered for this error
	 */
	public String getPath() {
		return this.path;
	}
	/**
	 * Returns the exception type (or {@code null} for a page that matches by status).
	 * @return the exception type or {@code null}
	 */
	public Class<? extends Throwable> getException() {
		return this.exception;
	}
	/**
	 * The HTTP status value that this error page matches (or {@code null} for a page that
	 * matches by exception).
	 * @return the status or {@code null}
	 */
	public HttpStatus getStatus() {
		return this.status;
	}
	/**
	 * The HTTP status value that this error page matches.
	 * @return the status value (or 0 for a page that matches any status)
	 */
	public int getStatusCode() {
		return (this.status != null) ? this.status.value() : 0;
	}
	/**
	 * The exception type name.
	 * @return the exception type name (or {@code null} if there is none)
	 */
	public String getExceptionName() {
		return (this.exception != null) ? this.exception.getName() : null;
	}
	/**
	 * Return if this error page is a global one (matches all unmatched status and
	 * exception types).
	 * @return if this is a global error page
	 */
	public boolean isGlobal() {
		return (this.status == null && this.exception == null);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (obj instanceof ErrorPage other) {
			return ObjectUtils.nullSafeEquals(getExceptionName(), other.getExceptionName())
					&& ObjectUtils.nullSafeEquals(this.path, other.path) && this.status == other.status;
		}
		return false;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ObjectUtils.nullSafeHashCode(getExceptionName());
		result = prime * result + ObjectUtils.nullSafeHashCode(this.path);
		result = prime * result + getStatusCode();
		return result;
	}
}
/*
/**
package org.springframework.boot.web.server;
/*
package org.springframework.boot.web.server;
/**
public enum GracefulShutdownResult {
	/**
	 * Requests remained active at the end of the grace period.
	 */
	REQUESTS_ACTIVE,
	/**
	 * The server was idle with no active requests at the end of the grace period.
	 */
	IDLE,
	/**
	 * The server was shutdown immediately, ignoring any active requests.
	 */
	IMMEDIATE
}
/*
package org.springframework.boot.web.server;
/**
@FunctionalInterface
public interface WebServerFactoryCustomizer<T extends WebServerFactory> {
	/**
	 * Customize the specified {@link WebServerFactory}.
	 * @param factory the web server factory to customize
	 */
	void customize(T factory);
}
/*
package org.springframework.boot.web.server;
/**
public final class WebServerSslBundle implements SslBundle {
	private final SslStoreBundle stores;
	private final SslBundleKey key;
	private final SslOptions options;
	private final String protocol;
	private final SslManagerBundle managers;
	private WebServerSslBundle(SslStoreBundle stores, String keyPassword, Ssl ssl) {
		this.stores = stores;
		this.key = SslBundleKey.of(keyPassword, ssl.getKeyAlias());
		this.protocol = ssl.getProtocol();
		this.options = SslOptions.of(ssl.getCiphers(), ssl.getEnabledProtocols());
		this.managers = SslManagerBundle.from(this.stores, this.key);
	}
	private static SslStoreBundle createPemKeyStoreBundle(Ssl ssl) {
		PemSslStoreDetails keyStoreDetails = new PemSslStoreDetails(ssl.getKeyStoreType(), ssl.getCertificate(),
				ssl.getCertificatePrivateKey())
			.withAlias(ssl.getKeyAlias());
		return new PemSslStoreBundle(keyStoreDetails, null);
	}
	private static SslStoreBundle createPemTrustStoreBundle(Ssl ssl) {
		PemSslStoreDetails trustStoreDetails = new PemSslStoreDetails(ssl.getTrustStoreType(),
				ssl.getTrustCertificate(), ssl.getTrustCertificatePrivateKey())
			.withAlias(ssl.getKeyAlias());
		return new PemSslStoreBundle(null, trustStoreDetails);
	}
	private static SslStoreBundle createJksKeyStoreBundle(Ssl ssl) {
		JksSslStoreDetails keyStoreDetails = new JksSslStoreDetails(ssl.getKeyStoreType(), ssl.getKeyStoreProvider(),
				ssl.getKeyStore(), ssl.getKeyStorePassword());
		return new JksSslStoreBundle(keyStoreDetails, null);
	}
	private static SslStoreBundle createJksTrustStoreBundle(Ssl ssl) {
		JksSslStoreDetails trustStoreDetails = new JksSslStoreDetails(ssl.getTrustStoreType(),
				ssl.getTrustStoreProvider(), ssl.getTrustStore(), ssl.getTrustStorePassword());
		return new JksSslStoreBundle(null, trustStoreDetails);
	}
	@Override
	public SslStoreBundle getStores() {
		return this.stores;
	}
	@Override
	public SslBundleKey getKey() {
		return this.key;
	}
	@Override
	public SslOptions getOptions() {
		return this.options;
	}
	@Override
	public String getProtocol() {
		return this.protocol;
	}
	@Override
	public SslManagerBundle getManagers() {
		return this.managers;
	}
	/**
	 * Get the {@link SslBundle} that should be used for the given {@link Ssl} instance.
	 * @param ssl the source ssl instance
	 * @return a {@link SslBundle} instance
	 * @throws NoSuchSslBundleException if a bundle lookup fails
	 */
	public static SslBundle get(Ssl ssl) throws NoSuchSslBundleException {
		return get(ssl, null);
	}
	/**
	 * Get the {@link SslBundle} that should be used for the given {@link Ssl} instance.
	 * @param ssl the source ssl instance
	 * @param sslBundles the bundles that should be used when {@link Ssl#getBundle()} is
	 * set
	 * @return a {@link SslBundle} instance
	 * @throws NoSuchSslBundleException if a bundle lookup fails
	 */
	public static SslBundle get(Ssl ssl, SslBundles sslBundles) throws NoSuchSslBundleException {
		Assert.state(Ssl.isEnabled(ssl), 'SSL is not enabled');
		String keyPassword = ssl.getKeyPassword();
		String bundleName = ssl.getBundle();
		if (StringUtils.hasText(bundleName)) {
			Assert.state(sslBundles != null,
					() -> 'SSL bundle "%s" was requested but no SslBundles instance was provided'
						.formatted(bundleName));
			return sslBundles.getBundle(bundleName);
		}
		SslStoreBundle stores = createStoreBundle(ssl);
		return new WebServerSslBundle(stores, keyPassword, ssl);
	}
	private static SslStoreBundle createStoreBundle(Ssl ssl) {
		KeyStore keyStore = createKeyStore(ssl);
		KeyStore trustStore = createTrustStore(ssl);
		return new WebServerSslStoreBundle(keyStore, trustStore, ssl.getKeyStorePassword());
	}
	private static KeyStore createKeyStore(Ssl ssl) {
		if (hasPemKeyStoreProperties(ssl)) {
			return createPemKeyStoreBundle(ssl).getKeyStore();
		}
		else if (hasJksKeyStoreProperties(ssl)) {
			return createJksKeyStoreBundle(ssl).getKeyStore();
		}
		return null;
	}
	private static KeyStore createTrustStore(Ssl ssl) {
		if (hasPemTrustStoreProperties(ssl)) {
			return createPemTrustStoreBundle(ssl).getTrustStore();
		}
		else if (hasJksTrustStoreProperties(ssl)) {
			return createJksTrustStoreBundle(ssl).getTrustStore();
		}
		return null;
	}
	private static boolean hasPemKeyStoreProperties(Ssl ssl) {
		return Ssl.isEnabled(ssl) && ssl.getCertificate() != null && ssl.getCertificatePrivateKey() != null;
	}
	private static boolean hasPemTrustStoreProperties(Ssl ssl) {
		return Ssl.isEnabled(ssl) && ssl.getTrustCertificate() != null;
	}
	private static boolean hasJksKeyStoreProperties(Ssl ssl) {
		return Ssl.isEnabled(ssl) && (ssl.getKeyStore() != null
				|| (ssl.getKeyStoreType() != null && ssl.getKeyStoreType().equals('PKCS11')));
	}
	private static boolean hasJksTrustStoreProperties(Ssl ssl) {
		return Ssl.isEnabled(ssl) && (ssl.getTrustStore() != null
				|| (ssl.getTrustStoreType() != null && ssl.getTrustStoreType().equals('PKCS11')));
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this);
		creator.append('key', this.key);
		creator.append('protocol', this.protocol);
		creator.append('stores', this.stores);
		creator.append('options', this.options);
		return creator.toString();
	}
	private static final class WebServerSslStoreBundle implements SslStoreBundle {
		private final KeyStore keyStore;
		private final KeyStore trustStore;
		private final String keyStorePassword;
		private WebServerSslStoreBundle(KeyStore keyStore, KeyStore trustStore, String keyStorePassword) {
			Assert.state(keyStore != null || trustStore != null,
					'SSL is enabled but no trust material is configured for the default host');
			this.keyStore = keyStore;
			this.trustStore = trustStore;
			this.keyStorePassword = keyStorePassword;
		}
		@Override
		public KeyStore getKeyStore() {
			return this.keyStore;
		}
		@Override
		public KeyStore getTrustStore() {
			return this.trustStore;
		}
		@Override
		public String getKeyStorePassword() {
			return this.keyStorePassword;
		}
		@Override
		public String toString() {
			ToStringCreator creator = new ToStringCreator(this);
			creator.append('keyStore.type', (this.keyStore != null) ? this.keyStore.getType() : 'none');
			creator.append('keyStorePassword', (this.keyStorePassword != null) ? '******' : null);
			creator.append('trustStore.type', (this.trustStore != null) ? this.trustStore.getType() : 'none');
			return creator.toString();
		}
	}
}
/*
package org.springframework.boot.web.server;
/**
@FunctionalInterface
public interface ErrorPageRegistrar {
	/**
	 * Register pages as required with the given registry.
	 * @param registry the error page registry
	 */
	void registerErrorPages(ErrorPageRegistry registry);
}
/*
package org.springframework.boot.web.server;
/**
public class Http2 {
	private boolean enabled = false;
	/**
	 * Return whether to enable HTTP/2 support, if the current environment supports it.
	 * @return {@code true} to enable HTTP/2 support
	 */
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
}
/*
package org.springframework.boot.web.server;
/**
public abstract class AbstractConfigurableWebServerFactory implements ConfigurableWebServerFactory {
	private int port = 8080;
	private InetAddress address;
	private Set<ErrorPage> errorPages = new LinkedHashSet<>();
	private Ssl ssl;
	private SslBundles sslBundles;
	private Http2 http2;
	private Compression compression;
	private String serverHeader;
	private Shutdown shutdown = Shutdown.IMMEDIATE;
	/**
	 * Create a new {@link AbstractConfigurableWebServerFactory} instance.
	 */
	public AbstractConfigurableWebServerFactory() {
	}
	/**
	 * Create a new {@link AbstractConfigurableWebServerFactory} instance with the
	 * specified port.
	 * @param port the port number for the web server
	 */
	public AbstractConfigurableWebServerFactory(int port) {
		this.port = port;
	}
	/**
	 * The port that the web server listens on.
	 * @return the port
	 */
	public int getPort() {
		return this.port;
	}
	@Override
	public void setPort(int port) {
		this.port = port;
	}
	/**
	 * Return the address that the web server binds to.
	 * @return the address
	 */
	public InetAddress getAddress() {
		return this.address;
	}
	@Override
	public void setAddress(InetAddress address) {
		this.address = address;
	}
	/**
	 * Returns a mutable set of {@link ErrorPage ErrorPages} that will be used when
	 * handling exceptions.
	 * @return the error pages
	 */
	public Set<ErrorPage> getErrorPages() {
		return this.errorPages;
	}
	@Override
	public void setErrorPages(Set<? extends ErrorPage> errorPages) {
		Assert.notNull(errorPages, 'ErrorPages must not be null');
		this.errorPages = new LinkedHashSet<>(errorPages);
	}
	@Override
	public void addErrorPages(ErrorPage... errorPages) {
		Assert.notNull(errorPages, 'ErrorPages must not be null');
		this.errorPages.addAll(Arrays.asList(errorPages));
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	@Override
	public void setSsl(Ssl ssl) {
		this.ssl = ssl;
	}
	/**
	 * Return the configured {@link SslBundles}.
	 * @return the {@link SslBundles} or {@code null}
	 * @since 3.2.0
	 */
	public SslBundles getSslBundles() {
		return this.sslBundles;
	}
	@Override
	public void setSslBundles(SslBundles sslBundles) {
		this.sslBundles = sslBundles;
	}
	public Http2 getHttp2() {
		return this.http2;
	}
	@Override
	public void setHttp2(Http2 http2) {
		this.http2 = http2;
	}
	public Compression getCompression() {
		return this.compression;
	}
	@Override
	public void setCompression(Compression compression) {
		this.compression = compression;
	}
	public String getServerHeader() {
		return this.serverHeader;
	}
	@Override
	public void setServerHeader(String serverHeader) {
		this.serverHeader = serverHeader;
	}
	@Override
	public void setShutdown(Shutdown shutdown) {
		this.shutdown = shutdown;
	}
	/**
	 * Returns the shutdown configuration that will be applied to the server.
	 * @return the shutdown configuration
	 * @since 2.3.0
	 */
	public Shutdown getShutdown() {
		return this.shutdown;
	}
	/**
	 * Return the {@link SslBundle} that should be used with this server.
	 * @return the SSL bundle
	 */
	protected final SslBundle getSslBundle() {
		return WebServerSslBundle.get(this.ssl, this.sslBundles);
	}
	protected final Map<String, SslBundle> getServerNameSslBundles() {
		return this.ssl.getServerNameBundles()
			.stream()
			.collect(Collectors.toMap(ServerNameSslBundle::serverName,
					(serverNameSslBundle) -> this.sslBundles.getBundle(serverNameSslBundle.bundle())));
	}
	/**
	 * Return the absolute temp dir for given web server.
	 * @param prefix server name
	 * @return the temp dir for given server.
	 */
	protected final File createTempDir(String prefix) {
		try {
			File tempDir = Files.createTempDirectory(prefix + '.' + getPort() + '.').toFile();
			tempDir.deleteOnExit();
			return tempDir;
		}
		catch (IOException ex) {
			throw new WebServerException(
					'Unable to create tempDir. java.io.tmpdir is set to ' + System.getProperty('java.io.tmpdir'), ex);
		}
	}
}
/*
package org.springframework.boot.web.server;
/**
public class PortInUseException extends WebServerException {
	private final int port;
	/**
	 * Creates a new port in use exception for the given {@code port}.
	 * @param port the port that was in use
	 */
	public PortInUseException(int port) {
		this(port, null);
	}
	/**
	 * Creates a new port in use exception for the given {@code port}.
	 * @param port the port that was in use
	 * @param cause the cause of the exception
	 */
	public PortInUseException(int port, Throwable cause) {
		super('Port ' + port + ' is already in use', cause);
		this.port = port;
	}
	/**
	 * Returns the port that was in use.
	 * @return the port
	 */
	public int getPort() {
		return this.port;
	}
	/**
	 * Throw a {@link PortInUseException} if the given exception was caused by a 'port in
	 * use' {@link BindException}.
	 * @param ex the source exception
	 * @param port a suppler used to provide the port
	 * @since 2.2.7
	 */
	public static void throwIfPortBindingException(Exception ex, IntSupplier port) {
		ifPortBindingException(ex, (bindException) -> {
			throw new PortInUseException(port.getAsInt(), ex);
		});
	}
	/**
	 * Perform an action if the given exception was caused by a 'port in use'
	 * {@link BindException}.
	 * @param ex the source exception
	 * @param action the action to perform
	 * @since 2.2.7
	 */
	public static void ifPortBindingException(Exception ex, Consumer<BindException> action) {
		ifCausedBy(ex, BindException.class, (bindException) -> {
			// bind exception can be also thrown because an address can"t be assigned
			if (bindException.getMessage().toLowerCase(Locale.ROOT).contains('in use')) {
				action.accept(bindException);
			}
		});
	}
	/**
	 * Perform an action if the given exception was caused by a specific exception type.
	 * @param <E> the cause exception type
	 * @param ex the source exception
	 * @param causedBy the required cause type
	 * @param action the action to perform
	 * @since 2.2.7
	 */
	@SuppressWarnings('unchecked')
	public static <E extends Exception> void ifCausedBy(Exception ex, Class<E> causedBy, Consumer<E> action) {
		Throwable candidate = ex;
		while (candidate != null) {
			if (causedBy.isInstance(candidate)) {
				action.accept((E) candidate);
				return;
			}
			candidate = candidate.getCause();
		}
	}
}
/*
package org.springframework.boot.web.error;
/**
public final class ErrorAttributeOptions {
	private final Set<Include> includes;
	private ErrorAttributeOptions(Set<Include> includes) {
		this.includes = includes;
	}
	/**
	 * Get the option for including the specified attribute in the error response.
	 * @param include error attribute to get
	 * @return {@code true} if the {@code Include} attribute is included in the error
	 * response, {@code false} otherwise
	 */
	public boolean isIncluded(Include include) {
		return this.includes.contains(include);
	}
	/**
	 * Get all options for including attributes in the error response.
	 * @return the options
	 */
	public Set<Include> getIncludes() {
		return this.includes;
	}
	/**
	 * Return an {@code ErrorAttributeOptions} that includes the specified attribute
	 * {@link Include} options.
	 * @param includes error attributes to include
	 * @return an {@code ErrorAttributeOptions}
	 */
	public ErrorAttributeOptions including(Include... includes) {
		EnumSet<Include> updated = copyIncludes();
		updated.addAll(Arrays.asList(includes));
		return new ErrorAttributeOptions(Collections.unmodifiableSet(updated));
	}
	/**
	 * Return an {@code ErrorAttributeOptions} that excludes the specified attribute
	 * {@link Include} options.
	 * @param excludes error attributes to exclude
	 * @return an {@code ErrorAttributeOptions}
	 */
	public ErrorAttributeOptions excluding(Include... excludes) {
		EnumSet<Include> updated = copyIncludes();
		Arrays.stream(excludes).forEach(updated::remove);
		return new ErrorAttributeOptions(Collections.unmodifiableSet(updated));
	}
	/**
	 * Remove elements from the given map if they are not included in this set of options.
	 * @param map the map to update
	 * @since 3.2.7
	 */
	public void retainIncluded(Map<String, Object> map) {
		for (Include candidate : Include.values()) {
			if (!this.includes.contains(candidate)) {
				map.remove(candidate.key);
			}
		}
	}
	private EnumSet<Include> copyIncludes() {
		return (this.includes.isEmpty()) ? EnumSet.noneOf(Include.class) : EnumSet.copyOf(this.includes);
	}
	/**
	 * Create an {@code ErrorAttributeOptions} with defaults.
	 * @return an {@code ErrorAttributeOptions}
	 */
	public static ErrorAttributeOptions defaults() {
		return of(Include.PATH, Include.STATUS, Include.ERROR);
	}
	/**
	 * Create an {@code ErrorAttributeOptions} that includes the specified attribute
	 * {@link Include} options.
	 * @param includes error attributes to include
	 * @return an {@code ErrorAttributeOptions}
	 */
	public static ErrorAttributeOptions of(Include... includes) {
		return of(Arrays.asList(includes));
	}
	/**
	 * Create an {@code ErrorAttributeOptions} that includes the specified attribute
	 * {@link Include} options.
	 * @param includes error attributes to include
	 * @return an {@code ErrorAttributeOptions}
	 */
	public static ErrorAttributeOptions of(Collection<Include> includes) {
		return new ErrorAttributeOptions(
				(includes.isEmpty()) ? Collections.emptySet() : Collections.unmodifiableSet(EnumSet.copyOf(includes)));
	}
	/**
	 * Error attributes that can be included in an error response.
	 */
	public enum Include {
		/**
		 * Include the exception class name attribute.
		 */
		EXCEPTION('exception'),
		/**
		 * Include the stack trace attribute.
		 */
		STACK_TRACE('trace'),
		/**
		 * Include the message attribute.
		 */
		MESSAGE('message'),
		/**
		 * Include the binding errors attribute.
		 */
		BINDING_ERRORS('errors'),
		/**
		 * Include the HTTP status code.
		 * @since 3.2.7
		 */
		STATUS('status'),
		/**
		 * Include the HTTP status code.
		 * @since 3.2.7
		 */
		ERROR('error'),
		/**
		 * Include the request path.
		 * @since 3.3.0
		 */
		PATH('path');
		private final String key;
		Include(String key) {
			this.key = key;
		}
	}
}
/*
/**
package org.springframework.boot.web.error;
/*
package org.springframework.boot.web.client;
/**
@FunctionalInterface
public interface RestClientCustomizer {
	/**
	 * Callback to customize a {@link org.springframework.web.client.RestClient.Builder
	 * RestClient.Builder} instance.
	 * @param restClientBuilder the client builder to customize
	 */
	void customize(RestClient.Builder restClientBuilder);
}
/*
package org.springframework.boot.web.client;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public record ClientHttpRequestFactorySettings(Duration connectTimeout, Duration readTimeout, SslBundle sslBundle) {
	/**
	 * Use defaults for the {@link ClientHttpRequestFactory} which can differ depending on
	 * the implementation.
	 */
	public static final ClientHttpRequestFactorySettings DEFAULTS = new ClientHttpRequestFactorySettings(null, null,
			null);
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} instance with an updated
	 * connect timeout setting.
	 * @param connectTimeout the new connect timeout setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 */
	public ClientHttpRequestFactorySettings withConnectTimeout(Duration connectTimeout) {
		return new ClientHttpRequestFactorySettings(connectTimeout, this.readTimeout, this.sslBundle);
	}
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} instance with an updated read
	 * timeout setting.
	 * @param readTimeout the new read timeout setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 */
	public ClientHttpRequestFactorySettings withReadTimeout(Duration readTimeout) {
		return new ClientHttpRequestFactorySettings(this.connectTimeout, readTimeout, this.sslBundle);
	}
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} instance with an updated SSL
	 * bundle setting.
	 * @param sslBundle the new SSL bundle setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 * @since 3.1.0
	 */
	public ClientHttpRequestFactorySettings withSslBundle(SslBundle sslBundle) {
		return new ClientHttpRequestFactorySettings(this.connectTimeout, this.readTimeout, sslBundle);
	}
	org.springframework.boot.http.client.ClientHttpRequestFactorySettings adapt() {
		return new org.springframework.boot.http.client.ClientHttpRequestFactorySettings(null, connectTimeout(),
				readTimeout(), sslBundle());
	}
	static ClientHttpRequestFactorySettings of(
			org.springframework.boot.http.client.ClientHttpRequestFactorySettings settings) {
		return new ClientHttpRequestFactorySettings(settings.connectTimeout(), settings.readTimeout(),
				settings.sslBundle());
	}
}
/*
package org.springframework.boot.web.client;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public final class ClientHttpRequestFactories {
	private ClientHttpRequestFactories() {
	}
	/**
	 * Return a {@link ClientHttpRequestFactory} implementation with the given
	 * {@code settings} applied. The first of the following implementations whose
	 * dependencies {@link ClassUtils#isPresent are available} is returned:
	 * <ol>
	 * <li>{@link HttpComponentsClientHttpRequestFactory}</li>
	 * <li>{@link JettyClientHttpRequestFactory}</li>
	 * <li>{@link ReactorClientHttpRequestFactory}</li>
	 * <li>{@link SimpleClientHttpRequestFactory}</li>
	 * </ol>
	 * @param settings the settings to apply
	 * @return a new {@link ClientHttpRequestFactory}
	 */
	@SuppressWarnings('removal')
	public static ClientHttpRequestFactory get(ClientHttpRequestFactorySettings settings) {
		Assert.notNull(settings, 'Settings must not be null');
		return detectBuilder().build(settings.adapt());
	}
	/**
	 * Return a new {@link ClientHttpRequestFactory} of the given
	 * {@code requestFactoryType}, applying {@link ClientHttpRequestFactorySettings} using
	 * reflection if necessary. The following implementations are supported without the
	 * use of reflection:
	 * <ul>
	 * <li>{@link HttpComponentsClientHttpRequestFactory}</li>
	 * <li>{@link JdkClientHttpRequestFactory}</li>
	 * <li>{@link JettyClientHttpRequestFactory}</li>
	 * <li>{@link ReactorClientHttpRequestFactory}</li>
	 * <li>{@link SimpleClientHttpRequestFactory}</li>
	 * </ul>
	 * A {@code requestFactoryType} of {@link ClientHttpRequestFactory} is equivalent to
	 * calling {@link #get(ClientHttpRequestFactorySettings)}.
	 * @param <T> the {@link ClientHttpRequestFactory} type
	 * @param requestFactoryType the {@link ClientHttpRequestFactory} type
	 * @param settings the settings to apply
	 * @return a new {@link ClientHttpRequestFactory} instance
	 */
	@SuppressWarnings('removal')
	public static <T extends ClientHttpRequestFactory> T get(Class<T> requestFactoryType,
			ClientHttpRequestFactorySettings settings) {
		Assert.notNull(settings, 'Settings must not be null');
		return getBuilder(requestFactoryType).build(settings.adapt());
	}
	/**
	 * Return a new {@link ClientHttpRequestFactory} from the given supplier, applying
	 * {@link ClientHttpRequestFactorySettings} using reflection.
	 * @param <T> the {@link ClientHttpRequestFactory} type
	 * @param requestFactorySupplier the {@link ClientHttpRequestFactory} supplier
	 * @param settings the settings to apply
	 * @return a new {@link ClientHttpRequestFactory} instance
	 */
	@SuppressWarnings('removal')
	public static <T extends ClientHttpRequestFactory> T get(Supplier<T> requestFactorySupplier,
			ClientHttpRequestFactorySettings settings) {
		return ClientHttpRequestFactoryBuilder.of(requestFactorySupplier).build(settings.adapt());
	}
	@SuppressWarnings('unchecked')
	private static <T extends ClientHttpRequestFactory> ClientHttpRequestFactoryBuilder<T> getBuilder(
			Class<T> requestFactoryType) {
		if (requestFactoryType == ClientHttpRequestFactory.class) {
			return (ClientHttpRequestFactoryBuilder<T>) detectBuilder();
		}
		return ClientHttpRequestFactoryBuilder.of(requestFactoryType);
	}
	private static ClientHttpRequestFactoryBuilder<?> detectBuilder() {
		ClientHttpRequestFactoryBuilder<?> builder = ClientHttpRequestFactoryBuilder.detect();
		if (builder instanceof JdkClientHttpRequestFactoryBuilder) {
			// Same logic as earlier versions which did not support JDK client factories
			return ClientHttpRequestFactoryBuilder.simple();
		}
		return builder;
	}
}
/*
package org.springframework.boot.web.client;
/**
class RestTemplateBuilderClientHttpRequestInitializer implements ClientHttpRequestInitializer {
	private final BasicAuthentication basicAuthentication;
	private final Map<String, List<String>> defaultHeaders;
	private final Set<RestTemplateRequestCustomizer<?>> requestCustomizers;
	RestTemplateBuilderClientHttpRequestInitializer(BasicAuthentication basicAuthentication,
			Map<String, List<String>> defaultHeaders, Set<RestTemplateRequestCustomizer<?>> requestCustomizers) {
		this.basicAuthentication = basicAuthentication;
		this.defaultHeaders = defaultHeaders;
		this.requestCustomizers = requestCustomizers;
	}
	@Override
	@SuppressWarnings('unchecked')
	public void initialize(ClientHttpRequest request) {
		HttpHeaders headers = request.getHeaders();
		if (this.basicAuthentication != null) {
			this.basicAuthentication.applyTo(headers);
		}
		this.defaultHeaders.forEach(headers::putIfAbsent);
		LambdaSafe.callbacks(RestTemplateRequestCustomizer.class, this.requestCustomizers, request)
			.invoke((customizer) -> customizer.customize(request));
	}
}
/*
package org.springframework.boot.web.client;
/**
@FunctionalInterface
public interface RestTemplateRequestCustomizer<T extends ClientHttpRequest> {
	/**
	 * Customize the specified {@link ClientHttpRequest}.
	 * @param request the request to customize
	 */
	void customize(T request);
}
/*
package org.springframework.boot.web.client;
/**
class BasicAuthentication {
	private final String username;
	private final String password;
	private final Charset charset;
	BasicAuthentication(String username, String password, Charset charset) {
		Assert.notNull(username, 'Username must not be null');
		Assert.notNull(password, 'Password must not be null');
		this.username = username;
		this.password = password;
		this.charset = charset;
	}
	void applyTo(HttpHeaders headers) {
		if (!headers.containsKey(HttpHeaders.AUTHORIZATION)) {
			headers.setBasicAuth(this.username, this.password, this.charset);
		}
	}
}
/*
package org.springframework.boot.web.client;
/**
@FunctionalInterface
public interface RestTemplateCustomizer {
	/**
	 * Callback to customize a {@link RestTemplate} instance.
	 * @param restTemplate the template to customize
	 */
	void customize(RestTemplate restTemplate);
}
/*
/**
package org.springframework.boot.web.client;
/*
package org.springframework.boot.web.client;
/**
public class RootUriTemplateHandler implements UriTemplateHandler {
	private final String rootUri;
	private final UriTemplateHandler handler;
	protected RootUriTemplateHandler(UriTemplateHandler handler) {
		Assert.notNull(handler, 'Handler must not be null');
		this.rootUri = null;
		this.handler = handler;
	}
	RootUriTemplateHandler(String rootUri, UriTemplateHandler handler) {
		Assert.notNull(rootUri, 'RootUri must not be null');
		Assert.notNull(handler, 'Handler must not be null');
		this.rootUri = rootUri;
		this.handler = handler;
	}
	@Override
	public URI expand(String uriTemplate, Map<String, ?> uriVariables) {
		return this.handler.expand(apply(uriTemplate), uriVariables);
	}
	@Override
	public URI expand(String uriTemplate, Object... uriVariables) {
		return this.handler.expand(apply(uriTemplate), uriVariables);
	}
	String apply(String uriTemplate) {
		if (StringUtils.startsWithIgnoreCase(uriTemplate, '/')) {
			return getRootUri() + uriTemplate;
		}
		return uriTemplate;
	}
	public String getRootUri() {
		return this.rootUri;
	}
}
/*
package org.springframework.boot.web.client;
/**
public class RestTemplateBuilder {
	private final ClientHttpRequestFactorySettings requestFactorySettings;
	private final boolean detectRequestFactory;
	private final String rootUri;
	private final Set<HttpMessageConverter<?>> messageConverters;
	private final Set<ClientHttpRequestInterceptor> interceptors;
	private final ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder;
	private final UriTemplateHandler uriTemplateHandler;
	private final ResponseErrorHandler errorHandler;
	private final BasicAuthentication basicAuthentication;
	private final Map<String, List<String>> defaultHeaders;
	private final Set<RestTemplateCustomizer> customizers;
	private final Set<RestTemplateRequestCustomizer<?>> requestCustomizers;
	/**
	 * Create a new {@link RestTemplateBuilder} instance.
	 * @param customizers any {@link RestTemplateCustomizer RestTemplateCustomizers} that
	 * should be applied when the {@link RestTemplate} is built
	 */
	public RestTemplateBuilder(RestTemplateCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		this.requestFactorySettings = ClientHttpRequestFactorySettings.defaults();
		this.detectRequestFactory = true;
		this.rootUri = null;
		this.messageConverters = null;
		this.interceptors = Collections.emptySet();
		this.requestFactoryBuilder = null;
		this.uriTemplateHandler = null;
		this.errorHandler = null;
		this.basicAuthentication = null;
		this.defaultHeaders = Collections.emptyMap();
		this.customizers = copiedSetOf(customizers);
		this.requestCustomizers = Collections.emptySet();
	}
	private RestTemplateBuilder(ClientHttpRequestFactorySettings requestFactorySettings, boolean detectRequestFactory,
			String rootUri, Set<HttpMessageConverter<?>> messageConverters,
			Set<ClientHttpRequestInterceptor> interceptors, ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder,
			UriTemplateHandler uriTemplateHandler, ResponseErrorHandler errorHandler,
			BasicAuthentication basicAuthentication, Map<String, List<String>> defaultHeaders,
			Set<RestTemplateCustomizer> customizers, Set<RestTemplateRequestCustomizer<?>> requestCustomizers) {
		this.requestFactorySettings = requestFactorySettings;
		this.detectRequestFactory = detectRequestFactory;
		this.rootUri = rootUri;
		this.messageConverters = messageConverters;
		this.interceptors = interceptors;
		this.requestFactoryBuilder = requestFactoryBuilder;
		this.uriTemplateHandler = uriTemplateHandler;
		this.errorHandler = errorHandler;
		this.basicAuthentication = basicAuthentication;
		this.defaultHeaders = defaultHeaders;
		this.customizers = customizers;
		this.requestCustomizers = requestCustomizers;
	}
	/**
	 * Set if the {@link ClientHttpRequestFactory} should be detected based on the
	 * classpath. Default if {@code true}.
	 * @param detectRequestFactory if the {@link ClientHttpRequestFactory} should be
	 * detected
	 * @return a new builder instance
	 */
	public RestTemplateBuilder detectRequestFactory(boolean detectRequestFactory) {
		return new RestTemplateBuilder(this.requestFactorySettings, detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				this.requestCustomizers);
	}
	/**
	 * Set a root URL that should be applied to each request that starts with {@code "/"}.
	 * The root URL will only apply when {@code String} variants of the
	 * {@link RestTemplate} methods are used for specifying the request URL.
	 * @param rootUri the root URI or {@code null}
	 * @return a new builder instance
	 */
	public RestTemplateBuilder rootUri(String rootUri) {
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				this.requestCustomizers);
	}
	/**
	 * Set the {@link HttpMessageConverter HttpMessageConverters} that should be used with
	 * the {@link RestTemplate}. Setting this value will replace any previously configured
	 * converters and any converters configured on the builder will replace RestTemplate"s
	 * default converters.
	 * @param messageConverters the converters to set
	 * @return a new builder instance
	 * @see #additionalMessageConverters(HttpMessageConverter...)
	 */
	public RestTemplateBuilder messageConverters(HttpMessageConverter<?>... messageConverters) {
		Assert.notNull(messageConverters, 'MessageConverters must not be null');
		return messageConverters(Arrays.asList(messageConverters));
	}
	/**
	 * Set the {@link HttpMessageConverter HttpMessageConverters} that should be used with
	 * the {@link RestTemplate}. Setting this value will replace any previously configured
	 * converters and any converters configured on the builder will replace RestTemplate"s
	 * default converters.
	 * @param messageConverters the converters to set
	 * @return a new builder instance
	 * @see #additionalMessageConverters(HttpMessageConverter...)
	 */
	public RestTemplateBuilder messageConverters(Collection<? extends HttpMessageConverter<?>> messageConverters) {
		Assert.notNull(messageConverters, 'MessageConverters must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				copiedSetOf(messageConverters), this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				this.requestCustomizers);
	}
	/**
	 * Add additional {@link HttpMessageConverter HttpMessageConverters} that should be
	 * used with the {@link RestTemplate}. Any converters configured on the builder will
	 * replace RestTemplate"s default converters.
	 * @param messageConverters the converters to add
	 * @return a new builder instance
	 * @see #messageConverters(HttpMessageConverter...)
	 */
	public RestTemplateBuilder additionalMessageConverters(HttpMessageConverter<?>... messageConverters) {
		Assert.notNull(messageConverters, 'MessageConverters must not be null');
		return additionalMessageConverters(Arrays.asList(messageConverters));
	}
	/**
	 * Add additional {@link HttpMessageConverter HttpMessageConverters} that should be
	 * used with the {@link RestTemplate}. Any converters configured on the builder will
	 * replace RestTemplate"s default converters.
	 * @param messageConverters the converters to add
	 * @return a new builder instance
	 * @see #messageConverters(HttpMessageConverter...)
	 */
	public RestTemplateBuilder additionalMessageConverters(
			Collection<? extends HttpMessageConverter<?>> messageConverters) {
		Assert.notNull(messageConverters, 'MessageConverters must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				append(this.messageConverters, messageConverters), this.interceptors, this.requestFactoryBuilder,
				this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders,
				this.customizers, this.requestCustomizers);
	}
	/**
	 * Set the {@link HttpMessageConverter HttpMessageConverters} that should be used with
	 * the {@link RestTemplate} to the default set. Calling this method will replace any
	 * previously defined converters.
	 * @return a new builder instance
	 * @see #messageConverters(HttpMessageConverter...)
	 */
	public RestTemplateBuilder defaultMessageConverters() {
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				copiedSetOf(new RestTemplate().getMessageConverters()), this.interceptors, this.requestFactoryBuilder,
				this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders,
				this.customizers, this.requestCustomizers);
	}
	/**
	 * Set the {@link ClientHttpRequestInterceptor ClientHttpRequestInterceptors} that
	 * should be used with the {@link RestTemplate}. Setting this value will replace any
	 * previously defined interceptors.
	 * @param interceptors the interceptors to set
	 * @return a new builder instance
	 * @since 1.4.1
	 * @see #additionalInterceptors(ClientHttpRequestInterceptor...)
	 */
	public RestTemplateBuilder interceptors(ClientHttpRequestInterceptor... interceptors) {
		Assert.notNull(interceptors, 'interceptors must not be null');
		return interceptors(Arrays.asList(interceptors));
	}
	/**
	 * Set the {@link ClientHttpRequestInterceptor ClientHttpRequestInterceptors} that
	 * should be used with the {@link RestTemplate}. Setting this value will replace any
	 * previously defined interceptors.
	 * @param interceptors the interceptors to set
	 * @return a new builder instance
	 * @since 1.4.1
	 * @see #additionalInterceptors(ClientHttpRequestInterceptor...)
	 */
	public RestTemplateBuilder interceptors(Collection<ClientHttpRequestInterceptor> interceptors) {
		Assert.notNull(interceptors, 'interceptors must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, copiedSetOf(interceptors), this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				this.requestCustomizers);
	}
	/**
	 * Add additional {@link ClientHttpRequestInterceptor ClientHttpRequestInterceptors}
	 * that should be used with the {@link RestTemplate}.
	 * @param interceptors the interceptors to add
	 * @return a new builder instance
	 * @since 1.4.1
	 * @see #interceptors(ClientHttpRequestInterceptor...)
	 */
	public RestTemplateBuilder additionalInterceptors(ClientHttpRequestInterceptor... interceptors) {
		Assert.notNull(interceptors, 'interceptors must not be null');
		return additionalInterceptors(Arrays.asList(interceptors));
	}
	/**
	 * Add additional {@link ClientHttpRequestInterceptor ClientHttpRequestInterceptors}
	 * that should be used with the {@link RestTemplate}.
	 * @param interceptors the interceptors to add
	 * @return a new builder instance
	 * @since 1.4.1
	 * @see #interceptors(ClientHttpRequestInterceptor...)
	 */
	public RestTemplateBuilder additionalInterceptors(Collection<? extends ClientHttpRequestInterceptor> interceptors) {
		Assert.notNull(interceptors, 'interceptors must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, append(this.interceptors, interceptors), this.requestFactoryBuilder,
				this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders,
				this.customizers, this.requestCustomizers);
	}
	/**
	 * Set the {@link ClientHttpRequestFactory} class that should be used with the
	 * {@link RestTemplate}.
	 * @param requestFactoryType the request factory type to use
	 * @return a new builder instance
	 * @see ClientHttpRequestFactoryBuilder#of(Class)
	 * @see #requestFactoryBuilder(ClientHttpRequestFactoryBuilder)
	 */
	public RestTemplateBuilder requestFactory(Class<? extends ClientHttpRequestFactory> requestFactoryType) {
		Assert.notNull(requestFactoryType, 'RequestFactoryType must not be null');
		return requestFactoryBuilder(ClientHttpRequestFactoryBuilder.of(requestFactoryType));
	}
	/**
	 * Set the {@code Supplier} of {@link ClientHttpRequestFactory} that should be called
	 * each time we {@link #build()} a new {@link RestTemplate} instance.
	 * @param requestFactorySupplier the supplier for the request factory
	 * @return a new builder instance
	 * @since 2.0.0
	 * @see ClientHttpRequestFactoryBuilder#of(Supplier)
	 * @see #requestFactoryBuilder(ClientHttpRequestFactoryBuilder)
	 */
	public RestTemplateBuilder requestFactory(Supplier<ClientHttpRequestFactory> requestFactorySupplier) {
		Assert.notNull(requestFactorySupplier, 'RequestFactorySupplier must not be null');
		return requestFactoryBuilder(ClientHttpRequestFactoryBuilder.of(requestFactorySupplier));
	}
	/**
	 * Set the request factory function that should be called to provide a
	 * {@link ClientHttpRequestFactory} each time we {@link #build()} a new
	 * {@link RestTemplate} instance.
	 * @param requestFactoryFunction the settings to request factory function
	 * @return a new builder instance
	 * @since 3.0.0
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #requestFactoryBuilder(ClientHttpRequestFactoryBuilder)}
	 * @see ClientHttpRequestFactoryBuilder
	 * @see #requestFactoryBuilder(ClientHttpRequestFactoryBuilder)
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	@SuppressWarnings('removal')
	public RestTemplateBuilder requestFactory(
			Function<org.springframework.boot.web.client.ClientHttpRequestFactorySettings, ClientHttpRequestFactory> requestFactoryFunction) {
		Assert.notNull(requestFactoryFunction, 'RequestFactoryFunction must not be null');
		return requestFactoryBuilder((settings) -> requestFactoryFunction
			.apply(org.springframework.boot.web.client.ClientHttpRequestFactorySettings.of(settings)));
	}
	/**
	 * Set the {@link ClientHttpRequestFactoryBuilder} that should be used each time we
	 * {@link #build()} a new {@link RestTemplate} instance.
	 * @param requestFactoryBuilder the {@link ClientHttpRequestFactoryBuilder} to use
	 * @return a new builder instance
	 * @since 3.4.0
	 * @see ClientHttpRequestFactoryBuilder
	 */
	public RestTemplateBuilder requestFactoryBuilder(ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder) {
		Assert.notNull(requestFactoryBuilder, 'ClientHttpRequestFactoryBuilder must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				this.requestCustomizers);
	}
	/**
	 * Set the {@link UriTemplateHandler} that should be used with the
	 * {@link RestTemplate}.
	 * @param uriTemplateHandler the URI template handler to use
	 * @return a new builder instance
	 */
	public RestTemplateBuilder uriTemplateHandler(UriTemplateHandler uriTemplateHandler) {
		Assert.notNull(uriTemplateHandler, 'UriTemplateHandler must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				this.requestCustomizers);
	}
	/**
	 * Set the {@link ResponseErrorHandler} that should be used with the
	 * {@link RestTemplate}.
	 * @param errorHandler the error handler to use
	 * @return a new builder instance
	 */
	public RestTemplateBuilder errorHandler(ResponseErrorHandler errorHandler) {
		Assert.notNull(errorHandler, 'ErrorHandler must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);
	}
	/**
	 * Add HTTP Basic Authentication to requests with the given username/password pair,
	 * unless a custom Authorization header has been set before.
	 * @param username the user name
	 * @param password the password
	 * @return a new builder instance
	 * @since 2.1.0
	 * @see #basicAuthentication(String, String, Charset)
	 */
	public RestTemplateBuilder basicAuthentication(String username, String password) {
		return basicAuthentication(username, password, null);
	}
	/**
	 * Add HTTP Basic Authentication to requests with the given username/password pair,
	 * unless a custom Authorization header has been set before.
	 * @param username the user name
	 * @param password the password
	 * @param charset the charset to use
	 * @return a new builder instance
	 * @since 2.2.0
	 */
	public RestTemplateBuilder basicAuthentication(String username, String password, Charset charset) {
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, new BasicAuthentication(username, password, charset), this.defaultHeaders,
				this.customizers, this.requestCustomizers);
	}
	/**
	 * Add a default header that will be set if not already present on the outgoing
	 * {@link ClientHttpRequest}.
	 * @param name the name of the header
	 * @param values the header values
	 * @return a new builder instance
	 * @since 2.2.0
	 */
	public RestTemplateBuilder defaultHeader(String name, String... values) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(values, 'Values must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, append(this.defaultHeaders, name, values),
				this.customizers, this.requestCustomizers);
	}
	/**
	 * Sets the {@link ClientHttpRequestFactorySettings}. This will replace any previously
	 * set {@link #connectTimeout(Duration) connectTimeout} ,{@link #readTimeout(Duration)
	 * readTimeout} and {@link #sslBundle(SslBundle) sslBundle} values.
	 * @param requestFactorySettings the request factory settings
	 * @return a new builder instance
	 * @since 3.4.0
	 */
	public RestTemplateBuilder requestFactorySettings(ClientHttpRequestFactorySettings requestFactorySettings) {
		Assert.notNull(requestFactorySettings, 'ClientHttpRequestFactorySettings must not be null');
		return new RestTemplateBuilder(requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				this.requestCustomizers);
	}
	/**
	 * Sets the connection timeout on the underlying {@link ClientHttpRequestFactory}.
	 * @param connectTimeout the connection timeout
	 * @return a new builder instance.
	 * @since 2.1.0
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #connectTimeout(Duration)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public RestTemplateBuilder setConnectTimeout(Duration connectTimeout) {
		return connectTimeout(connectTimeout);
	}
	/**
	 * Sets the connection timeout on the underlying {@link ClientHttpRequestFactory}.
	 * @param connectTimeout the connection timeout
	 * @return a new builder instance.
	 * @since 3.4.0
	 */
	public RestTemplateBuilder connectTimeout(Duration connectTimeout) {
		return new RestTemplateBuilder(this.requestFactorySettings.withConnectTimeout(connectTimeout),
				this.detectRequestFactory, this.rootUri, this.messageConverters, this.interceptors,
				this.requestFactoryBuilder, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication,
				this.defaultHeaders, this.customizers, this.requestCustomizers);
	}
	/**
	 * Sets the read timeout on the underlying {@link ClientHttpRequestFactory}.
	 * @param readTimeout the read timeout
	 * @return a new builder instance.
	 * @since 2.1.0
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #readTimeout(Duration)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public RestTemplateBuilder setReadTimeout(Duration readTimeout) {
		return readTimeout(readTimeout);
	}
	/**
	 * Sets the read timeout on the underlying {@link ClientHttpRequestFactory}.
	 * @param readTimeout the read timeout
	 * @return a new builder instance.
	 * @since 3.4.0
	 */
	public RestTemplateBuilder readTimeout(Duration readTimeout) {
		return new RestTemplateBuilder(this.requestFactorySettings.withReadTimeout(readTimeout),
				this.detectRequestFactory, this.rootUri, this.messageConverters, this.interceptors,
				this.requestFactoryBuilder, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication,
				this.defaultHeaders, this.customizers, this.requestCustomizers);
	}
	/**
	 * Sets the SSL bundle on the underlying {@link ClientHttpRequestFactory}.
	 * @param sslBundle the SSL bundle
	 * @return a new builder instance
	 * @since 3.1.0
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #sslBundle(SslBundle)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public RestTemplateBuilder setSslBundle(SslBundle sslBundle) {
		return sslBundle(sslBundle);
	}
	/**
	 * Sets the SSL bundle on the underlying {@link ClientHttpRequestFactory}.
	 * @param sslBundle the SSL bundle
	 * @return a new builder instance
	 * @since 3.4.0
	 */
	public RestTemplateBuilder sslBundle(SslBundle sslBundle) {
		return new RestTemplateBuilder(this.requestFactorySettings.withSslBundle(sslBundle), this.detectRequestFactory,
				this.rootUri, this.messageConverters, this.interceptors, this.requestFactoryBuilder,
				this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders,
				this.customizers, this.requestCustomizers);
	}
	/**
	 * Set the {@link RestTemplateCustomizer RestTemplateCustomizers} that should be
	 * applied to the {@link RestTemplate}. Customizers are applied in the order that they
	 * were added after builder configuration has been applied. Setting this value will
	 * replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(RestTemplateCustomizer...)
	 */
	public RestTemplateBuilder customizers(RestTemplateCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return customizers(Arrays.asList(customizers));
	}
	/**
	 * Set the {@link RestTemplateCustomizer RestTemplateCustomizers} that should be
	 * applied to the {@link RestTemplate}. Customizers are applied in the order that they
	 * were added after builder configuration has been applied. Setting this value will
	 * replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(RestTemplateCustomizer...)
	 */
	public RestTemplateBuilder customizers(Collection<? extends RestTemplateCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, copiedSetOf(customizers),
				this.requestCustomizers);
	}
	/**
	 * Add {@link RestTemplateCustomizer RestTemplateCustomizers} that should be applied
	 * to the {@link RestTemplate}. Customizers are applied in the order that they were
	 * added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(RestTemplateCustomizer...)
	 */
	public RestTemplateBuilder additionalCustomizers(RestTemplateCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return additionalCustomizers(Arrays.asList(customizers));
	}
	/**
	 * Add {@link RestTemplateCustomizer RestTemplateCustomizers} that should be applied
	 * to the {@link RestTemplate}. Customizers are applied in the order that they were
	 * added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(RestTemplateCustomizer...)
	 */
	public RestTemplateBuilder additionalCustomizers(Collection<? extends RestTemplateCustomizer> customizers) {
		Assert.notNull(customizers, 'RestTemplateCustomizers must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, append(this.customizers, customizers),
				this.requestCustomizers);
	}
	/**
	 * Set the {@link RestTemplateRequestCustomizer RestTemplateRequestCustomizers} that
	 * should be applied to the {@link ClientHttpRequest}. Customizers are applied in the
	 * order that they were added. Setting this value will replace any previously
	 * configured request customizers.
	 * @param requestCustomizers the request customizers to set
	 * @return a new builder instance
	 * @since 2.2.0
	 * @see #additionalRequestCustomizers(RestTemplateRequestCustomizer...)
	 */
	public RestTemplateBuilder requestCustomizers(RestTemplateRequestCustomizer<?>... requestCustomizers) {
		Assert.notNull(requestCustomizers, 'RequestCustomizers must not be null');
		return requestCustomizers(Arrays.asList(requestCustomizers));
	}
	/**
	 * Set the {@link RestTemplateRequestCustomizer RestTemplateRequestCustomizers} that
	 * should be applied to the {@link ClientHttpRequest}. Customizers are applied in the
	 * order that they were added. Setting this value will replace any previously
	 * configured request customizers.
	 * @param requestCustomizers the request customizers to set
	 * @return a new builder instance
	 * @since 2.2.0
	 * @see #additionalRequestCustomizers(RestTemplateRequestCustomizer...)
	 */
	public RestTemplateBuilder requestCustomizers(
			Collection<? extends RestTemplateRequestCustomizer<?>> requestCustomizers) {
		Assert.notNull(requestCustomizers, 'RequestCustomizers must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				copiedSetOf(requestCustomizers));
	}
	/**
	 * Add the {@link RestTemplateRequestCustomizer RestTemplateRequestCustomizers} that
	 * should be applied to the {@link ClientHttpRequest}. Customizers are applied in the
	 * order that they were added.
	 * @param requestCustomizers the request customizers to add
	 * @return a new builder instance
	 * @since 2.2.0
	 * @see #requestCustomizers(RestTemplateRequestCustomizer...)
	 */
	public RestTemplateBuilder additionalRequestCustomizers(RestTemplateRequestCustomizer<?>... requestCustomizers) {
		Assert.notNull(requestCustomizers, 'RequestCustomizers must not be null');
		return additionalRequestCustomizers(Arrays.asList(requestCustomizers));
	}
	/**
	 * Add the {@link RestTemplateRequestCustomizer RestTemplateRequestCustomizers} that
	 * should be applied to the {@link ClientHttpRequest}. Customizers are applied in the
	 * order that they were added.
	 * @param requestCustomizers the request customizers to add
	 * @return a new builder instance
	 * @since 2.2.0
	 * @see #requestCustomizers(Collection)
	 */
	public RestTemplateBuilder additionalRequestCustomizers(
			Collection<? extends RestTemplateRequestCustomizer<?>> requestCustomizers) {
		Assert.notNull(requestCustomizers, 'RequestCustomizers must not be null');
		return new RestTemplateBuilder(this.requestFactorySettings, this.detectRequestFactory, this.rootUri,
				this.messageConverters, this.interceptors, this.requestFactoryBuilder, this.uriTemplateHandler,
				this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers,
				append(this.requestCustomizers, requestCustomizers));
	}
	/**
	 * Build a new {@link RestTemplate} instance and configure it using this builder.
	 * @return a configured {@link RestTemplate} instance.
	 * @see #build(Class)
	 * @see #configure(RestTemplate)
	 */
	public RestTemplate build() {
		return configure(new RestTemplate());
	}
	/**
	 * Build a new {@link RestTemplate} instance of the specified type and configure it
	 * using this builder.
	 * @param <T> the type of rest template
	 * @param restTemplateClass the template type to create
	 * @return a configured {@link RestTemplate} instance.
	 * @see RestTemplateBuilder#build()
	 * @see #configure(RestTemplate)
	 */
	public <T extends RestTemplate> T build(Class<T> restTemplateClass) {
		return configure(BeanUtils.instantiateClass(restTemplateClass));
	}
	/**
	 * Configure the provided {@link RestTemplate} instance using this builder.
	 * @param <T> the type of rest template
	 * @param restTemplate the {@link RestTemplate} to configure
	 * @return the rest template instance
	 * @see RestTemplateBuilder#build()
	 * @see RestTemplateBuilder#build(Class)
	 */
	public <T extends RestTemplate> T configure(T restTemplate) {
		ClientHttpRequestFactory requestFactory = buildRequestFactory();
		if (requestFactory != null) {
			restTemplate.setRequestFactory(requestFactory);
		}
		addClientHttpRequestInitializer(restTemplate);
		if (!CollectionUtils.isEmpty(this.messageConverters)) {
			restTemplate.setMessageConverters(new ArrayList<>(this.messageConverters));
		}
		if (this.uriTemplateHandler != null) {
			restTemplate.setUriTemplateHandler(this.uriTemplateHandler);
		}
		if (this.errorHandler != null) {
			restTemplate.setErrorHandler(this.errorHandler);
		}
		if (this.rootUri != null) {
			RootUriBuilderFactory.applyTo(restTemplate, this.rootUri);
		}
		restTemplate.getInterceptors().addAll(this.interceptors);
		if (!CollectionUtils.isEmpty(this.customizers)) {
			for (RestTemplateCustomizer customizer : this.customizers) {
				customizer.customize(restTemplate);
			}
		}
		return restTemplate;
	}
	/**
	 * Build a new {@link ClientHttpRequestFactory} instance using the settings of this
	 * builder.
	 * @return a {@link ClientHttpRequestFactory} or {@code null}
	 * @since 2.2.0
	 */
	public ClientHttpRequestFactory buildRequestFactory() {
		if (this.requestFactoryBuilder != null) {
			return this.requestFactoryBuilder.build(this.requestFactorySettings);
		}
		if (this.detectRequestFactory) {
			return ClientHttpRequestFactoryBuilder.detect().build(this.requestFactorySettings);
		}
		return null;
	}
	private void addClientHttpRequestInitializer(RestTemplate restTemplate) {
		if (this.basicAuthentication == null && this.defaultHeaders.isEmpty() && this.requestCustomizers.isEmpty()) {
			return;
		}
		restTemplate.getClientHttpRequestInitializers()
			.add(new RestTemplateBuilderClientHttpRequestInitializer(this.basicAuthentication, this.defaultHeaders,
					this.requestCustomizers));
	}
	@SuppressWarnings('unchecked')
	private <T> Set<T> copiedSetOf(T... items) {
		return copiedSetOf(Arrays.asList(items));
	}
	private <T> Set<T> copiedSetOf(Collection<? extends T> collection) {
		return Collections.unmodifiableSet(new LinkedHashSet<>(collection));
	}
	private static <T> List<T> copiedListOf(T[] items) {
		return Collections.unmodifiableList(Arrays.asList(Arrays.copyOf(items, items.length)));
	}
	private static <T> Set<T> append(Collection<? extends T> collection, Collection<? extends T> additions) {
		Set<T> result = new LinkedHashSet<>((collection != null) ? collection : Collections.emptySet());
		if (additions != null) {
			result.addAll(additions);
		}
		return Collections.unmodifiableSet(result);
	}
	private static <K, V> Map<K, List<V>> append(Map<K, List<V>> map, K key, V[] values) {
		Map<K, List<V>> result = new LinkedHashMap<>((map != null) ? map : Collections.emptyMap());
		if (values != null) {
			result.put(key, copiedListOf(values));
		}
		return Collections.unmodifiableMap(result);
	}
}
/*
package org.springframework.boot.web.client;
/**
public class RootUriBuilderFactory extends RootUriTemplateHandler implements UriBuilderFactory {
	RootUriBuilderFactory(String rootUri, UriTemplateHandler delegate) {
		super(rootUri, delegate);
	}
	@Override
	public UriBuilder uriString(String uriTemplate) {
		return UriComponentsBuilder.fromUriString(apply(uriTemplate));
	}
	@Override
	public UriBuilder builder() {
		return UriComponentsBuilder.newInstance();
	}
	/**
	 * Apply a {@link RootUriBuilderFactory} instance to the given {@link RestTemplate}.
	 * @param restTemplate the {@link RestTemplate} to add the builder factory to
	 * @param rootUri the root URI
	 */
	static void applyTo(RestTemplate restTemplate, String rootUri) {
		Assert.notNull(restTemplate, 'RestTemplate must not be null');
		RootUriBuilderFactory handler = new RootUriBuilderFactory(rootUri, restTemplate.getUriTemplateHandler());
		restTemplate.setUriTemplateHandler(handler);
	}
}
/*
package org.springframework.boot.web.servlet;
/**
public class ServletListenerRegistrationBean<T extends EventListener> extends RegistrationBean {
	private static final Set<Class<?>> SUPPORTED_TYPES;
	static {
		Set<Class<?>> types = new HashSet<>();
		types.add(ServletContextAttributeListener.class);
		types.add(ServletRequestListener.class);
		types.add(ServletRequestAttributeListener.class);
		types.add(HttpSessionAttributeListener.class);
		types.add(HttpSessionIdListener.class);
		types.add(HttpSessionListener.class);
		types.add(ServletContextListener.class);
		SUPPORTED_TYPES = Collections.unmodifiableSet(types);
	}
	private T listener;
	/**
	 * Create a new {@link ServletListenerRegistrationBean} instance.
	 */
	public ServletListenerRegistrationBean() {
	}
	/**
	 * Create a new {@link ServletListenerRegistrationBean} instance.
	 * @param listener the listener to register
	 */
	public ServletListenerRegistrationBean(T listener) {
		Assert.notNull(listener, 'Listener must not be null');
		Assert.isTrue(isSupportedType(listener), 'Listener is not of a supported type');
		this.listener = listener;
	}
	/**
	 * Set the listener that will be registered.
	 * @param listener the listener to register
	 */
	public void setListener(T listener) {
		Assert.notNull(listener, 'Listener must not be null');
		Assert.isTrue(isSupportedType(listener), 'Listener is not of a supported type');
		this.listener = listener;
	}
	/**
	 * Return the listener to be registered.
	 * @return the listener to be registered
	 */
	public T getListener() {
		return this.listener;
	}
	@Override
	protected String getDescription() {
		Assert.notNull(this.listener, 'Listener must not be null');
		return 'listener ' + this.listener;
	}
	@Override
	protected void register(String description, ServletContext servletContext) {
		try {
			servletContext.addListener(this.listener);
		}
		catch (RuntimeException ex) {
			throw new IllegalStateException('Failed to add listener "' + this.listener + '" to servlet context', ex);
		}
	}
	/**
	 * Returns {@code true} if the specified listener is one of the supported types.
	 * @param listener the listener to test
	 * @return if the listener is of a supported type
	 */
	public static boolean isSupportedType(EventListener listener) {
		for (Class<?> type : SUPPORTED_TYPES) {
			if (ClassUtils.isAssignableValue(type, listener)) {
				return true;
			}
		}
		return false;
	}
	/**
	 * Return the supported types for this registration.
	 * @return the supported types
	 */
	public static Set<Class<?>> getSupportedTypes() {
		return SUPPORTED_TYPES;
	}
}
/*
package org.springframework.boot.web.servlet;
/**
public abstract class RegistrationBean implements ServletContextInitializer, Ordered {
	private static final Log logger = LogFactory.getLog(RegistrationBean.class);
	private int order = Ordered.LOWEST_PRECEDENCE;
	private boolean enabled = true;
	@Override
	public final void onStartup(ServletContext servletContext) throws ServletException {
		String description = getDescription();
		if (!isEnabled()) {
			logger.info(StringUtils.capitalize(description) + ' was not registered (disabled)');
			return;
		}
		register(description, servletContext);
	}
	/**
	 * Return a description of the registration. For example 'Servlet resourceServlet'
	 * @return a description of the registration
	 */
	protected abstract String getDescription();
	/**
	 * Register this bean with the servlet context.
	 * @param description a description of the item being registered
	 * @param servletContext the servlet context
	 */
	protected abstract void register(String description, ServletContext servletContext);
	/**
	 * Flag to indicate that the registration is enabled.
	 * @param enabled the enabled to set
	 */
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	/**
	 * Return if the registration is enabled.
	 * @return if enabled (default {@code true})
	 */
	public boolean isEnabled() {
		return this.enabled;
	}
	/**
	 * Set the order of the registration bean.
	 * @param order the order
	 */
	public void setOrder(int order) {
		this.order = order;
	}
	/**
	 * Get the order of the registration bean.
	 * @return the order
	 */
	@Override
	public int getOrder() {
		return this.order;
	}
}
/*
package org.springframework.boot.web.servlet.filter;
/**
public interface OrderedFilter extends Filter, Ordered {
	/**
	 * Filters that wrap the servlet request should be ordered less than or equal to this.
	 */
	int REQUEST_WRAPPER_FILTER_MAX_ORDER = 0;
}
/*
package org.springframework.boot.web.servlet.filter;
/**
public class OrderedFormContentFilter extends FormContentFilter implements OrderedFilter {
	/**
	 * Higher order to ensure the filter is applied before Spring Security.
	 */
	public static final int DEFAULT_ORDER = REQUEST_WRAPPER_FILTER_MAX_ORDER - 9900;
	private int order = DEFAULT_ORDER;
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Set the order for this filter.
	 * @param order the order to set
	 */
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
package org.springframework.boot.web.servlet.filter;
/**
public class OrderedRequestContextFilter extends RequestContextFilter implements OrderedFilter {
	// Order defaults to after Spring Session filter
	private int order = REQUEST_WRAPPER_FILTER_MAX_ORDER - 105;
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Set the order for this filter.
	 * @param order the order to set
	 */
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
package org.springframework.boot.web.servlet.filter;
/**
public class OrderedCharacterEncodingFilter extends CharacterEncodingFilter implements OrderedFilter {
	private int order = Ordered.HIGHEST_PRECEDENCE;
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Set the order for this filter.
	 * @param order the order to set
	 */
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
package org.springframework.boot.web.servlet.filter;
/**
public class ApplicationContextHeaderFilter extends OncePerRequestFilter {
	/**
	 * Public constant for {@literal X-Application-Context}.
	 */
	public static final String HEADER_NAME = 'X-Application-Context';
	private final ApplicationContext applicationContext;
	public ApplicationContextHeaderFilter(ApplicationContext context) {
		this.applicationContext = context;
	}
	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {
		response.addHeader(HEADER_NAME, this.applicationContext.getId());
		filterChain.doFilter(request, response);
	}
}
/*
package org.springframework.boot.web.servlet.filter;
/**
public class OrderedHiddenHttpMethodFilter extends HiddenHttpMethodFilter implements OrderedFilter {
	/**
	 * The default order is high to ensure the filter is applied before Spring Security.
	 */
	public static final int DEFAULT_ORDER = REQUEST_WRAPPER_FILTER_MAX_ORDER - 10000;
	private int order = DEFAULT_ORDER;
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Set the order for this filter.
	 * @param order the order to set
	 */
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
/**
package org.springframework.boot.web.servlet.filter;
/*
package org.springframework.boot.web.servlet.context;
/**
public class WebApplicationContextServletContextAwareProcessor extends ServletContextAwareProcessor {
	private final ConfigurableWebApplicationContext webApplicationContext;
	public WebApplicationContextServletContextAwareProcessor(ConfigurableWebApplicationContext webApplicationContext) {
		Assert.notNull(webApplicationContext, 'WebApplicationContext must not be null');
		this.webApplicationContext = webApplicationContext;
	}
	@Override
	protected ServletContext getServletContext() {
		ServletContext servletContext = this.webApplicationContext.getServletContext();
		return (servletContext != null) ? servletContext : super.getServletContext();
	}
	@Override
	protected ServletConfig getServletConfig() {
		ServletConfig servletConfig = this.webApplicationContext.getServletConfig();
		return (servletConfig != null) ? servletConfig : super.getServletConfig();
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
@SuppressWarnings('serial')
public class ServletWebServerInitializedEvent extends WebServerInitializedEvent {
	private final ServletWebServerApplicationContext applicationContext;
	public ServletWebServerInitializedEvent(WebServer webServer,
			ServletWebServerApplicationContext applicationContext) {
		super(webServer);
		this.applicationContext = applicationContext;
	}
	/**
	 * Access the application context that the server was created in. Sometimes it is
	 * prudent to check that this matches expectations (like being equal to the current
	 * context) before acting on the server itself.
	 * @return the applicationContext that the server was created from
	 */
	@Override
	public ServletWebServerApplicationContext getApplicationContext() {
		return this.applicationContext;
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
class WebServerStartStopLifecycle implements SmartLifecycle {
	private final ServletWebServerApplicationContext applicationContext;
	private final WebServer webServer;
	private volatile boolean running;
	WebServerStartStopLifecycle(ServletWebServerApplicationContext applicationContext, WebServer webServer) {
		this.applicationContext = applicationContext;
		this.webServer = webServer;
	}
	@Override
	public void start() {
		this.webServer.start();
		this.running = true;
		this.applicationContext
			.publishEvent(new ServletWebServerInitializedEvent(this.webServer, this.applicationContext));
	}
	@Override
	public void stop() {
		this.running = false;
		this.webServer.stop();
	}
	@Override
	public boolean isRunning() {
		return this.running;
	}
	@Override
	public int getPhase() {
		return WebServerGracefulShutdownLifecycle.SMART_LIFECYCLE_PHASE - 1024;
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
class ApplicationServletEnvironment extends StandardServletEnvironment {
	@Override
	protected String doGetActiveProfilesProperty() {
		return null;
	}
	@Override
	protected String doGetDefaultProfilesProperty() {
		return null;
	}
	@Override
	protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {
		return ConfigurationPropertySources.createPropertyResolver(propertySources);
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
public class XmlServletWebServerApplicationContext extends ServletWebServerApplicationContext {
	private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);
	/**
	 * Create a new {@link XmlServletWebServerApplicationContext} that needs to be
	 * {@linkplain #load loaded} and then manually {@link #refresh refreshed}.
	 */
	public XmlServletWebServerApplicationContext() {
		this.reader.setEnvironment(getEnvironment());
	}
	/**
	 * Create a new {@link XmlServletWebServerApplicationContext}, loading bean
	 * definitions from the given resources and automatically refreshing the context.
	 * @param resources the resources to load from
	 */
	public XmlServletWebServerApplicationContext(Resource... resources) {
		load(resources);
		refresh();
	}
	/**
	 * Create a new {@link XmlServletWebServerApplicationContext}, loading bean
	 * definitions from the given resource locations and automatically refreshing the
	 * context.
	 * @param resourceLocations the resources to load from
	 */
	public XmlServletWebServerApplicationContext(String... resourceLocations) {
		load(resourceLocations);
		refresh();
	}
	/**
	 * Create a new {@link XmlServletWebServerApplicationContext}, loading bean
	 * definitions from the given resource locations and automatically refreshing the
	 * context.
	 * @param relativeClass class whose package will be used as a prefix when loading each
	 * specified resource name
	 * @param resourceNames relatively-qualified names of resources to load
	 */
	public XmlServletWebServerApplicationContext(Class<?> relativeClass, String... resourceNames) {
		load(relativeClass, resourceNames);
		refresh();
	}
	/**
	 * Set whether to use XML validation. Default is {@code true}.
	 * @param validating if validating the XML
	 */
	public void setValidating(boolean validating) {
		this.reader.setValidating(validating);
	}
	/**
	 * {@inheritDoc}
	 * <p>
	 * Delegates the given environment to underlying {@link XmlBeanDefinitionReader}.
	 * Should be called before any call to {@link #load}.
	 */
	@Override
	public void setEnvironment(ConfigurableEnvironment environment) {
		super.setEnvironment(environment);
		this.reader.setEnvironment(getEnvironment());
	}
	/**
	 * Load bean definitions from the given XML resources.
	 * @param resources one or more resources to load from
	 */
	public final void load(Resource... resources) {
		this.reader.loadBeanDefinitions(resources);
	}
	/**
	 * Load bean definitions from the given XML resources.
	 * @param resourceLocations one or more resource locations to load from
	 */
	public final void load(String... resourceLocations) {
		this.reader.loadBeanDefinitions(resourceLocations);
	}
	/**
	 * Load bean definitions from the given XML resources.
	 * @param relativeClass class whose package will be used as a prefix when loading each
	 * specified resource name
	 * @param resourceNames relatively-qualified names of resources to load
	 */
	public final void load(Class<?> relativeClass, String... resourceNames) {
		Resource[] resources = new Resource[resourceNames.length];
		for (int i = 0; i < resourceNames.length; i++) {
			resources[i] = new ClassPathResource(resourceNames[i], relativeClass);
		}
		this.reader.loadBeanDefinitions(resources);
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
public class AnnotationConfigServletWebApplicationContext extends GenericWebApplicationContext
		implements AnnotationConfigRegistry {
	private final AnnotatedBeanDefinitionReader reader;
	private final ClassPathBeanDefinitionScanner scanner;
	private final Set<Class<?>> annotatedClasses = new LinkedHashSet<>();
	private String[] basePackages;
	/**
	 * Create a new {@link AnnotationConfigServletWebApplicationContext} that needs to be
	 * populated through {@link #register} calls and then manually {@linkplain #refresh
	 * refreshed}.
	 */
	public AnnotationConfigServletWebApplicationContext() {
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
	/**
	 * Create a new {@link AnnotationConfigServletWebApplicationContext} with the given
	 * {@code DefaultListableBeanFactory}. The context needs to be populated through
	 * {@link #register} calls and then manually {@linkplain #refresh refreshed}.
	 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
	 */
	public AnnotationConfigServletWebApplicationContext(DefaultListableBeanFactory beanFactory) {
		super(beanFactory);
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
	/**
	 * Create a new {@link AnnotationConfigServletWebApplicationContext}, deriving bean
	 * definitions from the given annotated classes and automatically refreshing the
	 * context.
	 * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}
	 * classes
	 */
	public AnnotationConfigServletWebApplicationContext(Class<?>... annotatedClasses) {
		this();
		register(annotatedClasses);
		refresh();
	}
	/**
	 * Create a new {@link AnnotationConfigServletWebApplicationContext}, scanning for
	 * bean definitions in the given packages and automatically refreshing the context.
	 * @param basePackages the packages to check for annotated classes
	 */
	public AnnotationConfigServletWebApplicationContext(String... basePackages) {
		this();
		scan(basePackages);
		refresh();
	}
	/**
	 * {@inheritDoc}
	 * <p>
	 * Delegates given environment to underlying {@link AnnotatedBeanDefinitionReader} and
	 * {@link ClassPathBeanDefinitionScanner} members.
	 */
	@Override
	public void setEnvironment(ConfigurableEnvironment environment) {
		super.setEnvironment(environment);
		this.reader.setEnvironment(environment);
		this.scanner.setEnvironment(environment);
	}
	/**
	 * Provide a custom {@link BeanNameGenerator} for use with
	 * {@link AnnotatedBeanDefinitionReader} and/or
	 * {@link ClassPathBeanDefinitionScanner}, if any.
	 * <p>
	 * Default is
	 * {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.
	 * <p>
	 * Any call to this method must occur prior to calls to {@link #register(Class...)}
	 * and/or {@link #scan(String...)}.
	 * @param beanNameGenerator the bean name generator
	 * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator
	 * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator
	 */
	public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
		this.reader.setBeanNameGenerator(beanNameGenerator);
		this.scanner.setBeanNameGenerator(beanNameGenerator);
		getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
	}
	/**
	 * Set the {@link ScopeMetadataResolver} to use for detected bean classes.
	 * <p>
	 * The default is an {@link AnnotationScopeMetadataResolver}.
	 * <p>
	 * Any call to this method must occur prior to calls to {@link #register(Class...)}
	 * and/or {@link #scan(String...)}.
	 * @param scopeMetadataResolver the scope metadata resolver
	 */
	public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {
		this.reader.setScopeMetadataResolver(scopeMetadataResolver);
		this.scanner.setScopeMetadataResolver(scopeMetadataResolver);
	}
	/**
	 * Register one or more annotated classes to be processed. Note that
	 * {@link #refresh()} must be called in order for the context to fully process the new
	 * class.
	 * <p>
	 * Calls to {@code #register} are idempotent; adding the same annotated class more
	 * than once has no additional effect.
	 * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}
	 * classes
	 * @see #scan(String...)
	 * @see #refresh()
	 */
	@Override
	public final void register(Class<?>... annotatedClasses) {
		Assert.notEmpty(annotatedClasses, 'At least one annotated class must be specified');
		this.annotatedClasses.addAll(Arrays.asList(annotatedClasses));
	}
	/**
	 * Perform a scan within the specified base packages. Note that {@link #refresh()}
	 * must be called in order for the context to fully process the new class.
	 * @param basePackages the packages to check for annotated classes
	 * @see #register(Class...)
	 * @see #refresh()
	 */
	@Override
	public final void scan(String... basePackages) {
		Assert.notEmpty(basePackages, 'At least one base package must be specified');
		this.basePackages = basePackages;
	}
	@Override
	protected void prepareRefresh() {
		this.scanner.clearCache();
		super.prepareRefresh();
	}
	@Override
	protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		super.postProcessBeanFactory(beanFactory);
		if (!ObjectUtils.isEmpty(this.basePackages)) {
			this.scanner.scan(this.basePackages);
		}
		if (!this.annotatedClasses.isEmpty()) {
			this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));
		}
	}
	@Override
	public <T> void registerBean(String beanName, Class<T> beanClass, Supplier<T> supplier,
			BeanDefinitionCustomizer... customizers) {
		this.reader.registerBean(beanClass, beanName, supplier, customizers);
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
class ServletWebServerApplicationContextFactory implements ApplicationContextFactory {
	@Override
	public Class<? extends ConfigurableEnvironment> getEnvironmentType(WebApplicationType webApplicationType) {
		return (webApplicationType != WebApplicationType.SERVLET) ? null : ApplicationServletEnvironment.class;
	}
	@Override
	public ConfigurableEnvironment createEnvironment(WebApplicationType webApplicationType) {
		return (webApplicationType != WebApplicationType.SERVLET) ? null : new ApplicationServletEnvironment();
	}
	@Override
	public ConfigurableApplicationContext create(WebApplicationType webApplicationType) {
		return (webApplicationType != WebApplicationType.SERVLET) ? null : createContext();
	}
	private ConfigurableApplicationContext createContext() {
		if (!AotDetector.useGeneratedArtifacts()) {
			return new AnnotationConfigServletWebServerApplicationContext();
		}
		return new ServletWebServerApplicationContext();
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
public class ServletWebServerApplicationContext extends GenericWebApplicationContext
		implements ConfigurableWebServerApplicationContext {
	private static final Log logger = LogFactory.getLog(ServletWebServerApplicationContext.class);
	/**
	 * Constant value for the DispatcherServlet bean name. A Servlet bean with this name
	 * is deemed to be the 'main' servlet and is automatically given a mapping of '/' by
	 * default. To change the default behavior you can use a
	 * {@link ServletRegistrationBean} or a different bean name.
	 */
	public static final String DISPATCHER_SERVLET_NAME = 'dispatcherServlet';
	private volatile WebServer webServer;
	private ServletConfig servletConfig;
	private String serverNamespace;
	/**
	 * Create a new {@link ServletWebServerApplicationContext}.
	 */
	public ServletWebServerApplicationContext() {
	}
	/**
	 * Create a new {@link ServletWebServerApplicationContext} with the given
	 * {@code DefaultListableBeanFactory}.
	 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
	 */
	public ServletWebServerApplicationContext(DefaultListableBeanFactory beanFactory) {
		super(beanFactory);
	}
	/**
	 * Register ServletContextAwareProcessor.
	 * @see ServletContextAwareProcessor
	 */
	@Override
	protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));
		beanFactory.ignoreDependencyInterface(ServletContextAware.class);
		registerWebApplicationScopes();
	}
	@Override
	public final void refresh() throws BeansException, IllegalStateException {
		try {
			super.refresh();
		}
		catch (RuntimeException ex) {
			WebServer webServer = this.webServer;
			if (webServer != null) {
				webServer.stop();
				webServer.destroy();
			}
			throw ex;
		}
	}
	@Override
	protected void onRefresh() {
		super.onRefresh();
		try {
			createWebServer();
		}
		catch (Throwable ex) {
			throw new ApplicationContextException('Unable to start web server', ex);
		}
	}
	@Override
	protected void doClose() {
		if (isActive()) {
			AvailabilityChangeEvent.publish(this, ReadinessState.REFUSING_TRAFFIC);
		}
		super.doClose();
		WebServer webServer = this.webServer;
		if (webServer != null) {
			webServer.destroy();
		}
	}
	private void createWebServer() {
		WebServer webServer = this.webServer;
		ServletContext servletContext = getServletContext();
		if (webServer == null && servletContext == null) {
			StartupStep createWebServer = getApplicationStartup().start('spring.boot.webserver.create');
			ServletWebServerFactory factory = getWebServerFactory();
			createWebServer.tag('factory', factory.getClass().toString());
			this.webServer = factory.getWebServer(getSelfInitializer());
			createWebServer.end();
			getBeanFactory().registerSingleton('webServerGracefulShutdown',
					new WebServerGracefulShutdownLifecycle(this.webServer));
			getBeanFactory().registerSingleton('webServerStartStop',
					new WebServerStartStopLifecycle(this, this.webServer));
		}
		else if (servletContext != null) {
			try {
				getSelfInitializer().onStartup(servletContext);
			}
			catch (ServletException ex) {
				throw new ApplicationContextException('Cannot initialize servlet context', ex);
			}
		}
		initPropertySources();
	}
	/**
	 * Returns the {@link ServletWebServerFactory} that should be used to create the
	 * embedded {@link WebServer}. By default this method searches for a suitable bean in
	 * the context itself.
	 * @return a {@link ServletWebServerFactory} (never {@code null})
	 */
	protected ServletWebServerFactory getWebServerFactory() {
		// Use bean names so that we don"t consider the hierarchy
		String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);
		if (beanNames.length == 0) {
			throw new MissingWebServerFactoryBeanException(getClass(), ServletWebServerFactory.class,
					WebApplicationType.SERVLET);
		}
		if (beanNames.length > 1) {
			throw new ApplicationContextException('Unable to start ServletWebServerApplicationContext due to multiple '
					+ 'ServletWebServerFactory beans : ' + StringUtils.arrayToCommaDelimitedString(beanNames));
		}
		return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);
	}
	/**
	 * Returns the {@link ServletContextInitializer} that will be used to complete the
	 * setup of this {@link WebApplicationContext}.
	 * @return the self initializer
	 * @see #prepareWebApplicationContext(ServletContext)
	 */
	private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {
		return this::selfInitialize;
	}
	private void selfInitialize(ServletContext servletContext) throws ServletException {
		prepareWebApplicationContext(servletContext);
		registerApplicationScope(servletContext);
		WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);
		for (ServletContextInitializer beans : getServletContextInitializerBeans()) {
			beans.onStartup(servletContext);
		}
	}
	private void registerApplicationScope(ServletContext servletContext) {
		ServletContextScope appScope = new ServletContextScope(servletContext);
		getBeanFactory().registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);
		// Register as ServletContext attribute, for ContextCleanupListener to detect it.
		servletContext.setAttribute(ServletContextScope.class.getName(), appScope);
	}
	private void registerWebApplicationScopes() {
		ExistingWebApplicationScopes existingScopes = new ExistingWebApplicationScopes(getBeanFactory());
		WebApplicationContextUtils.registerWebApplicationScopes(getBeanFactory());
		existingScopes.restore();
	}
	/**
	 * Returns {@link ServletContextInitializer}s that should be used with the embedded
	 * web server. By default this method will first attempt to find
	 * {@link ServletContextInitializer}, {@link Servlet}, {@link Filter} and certain
	 * {@link EventListener} beans.
	 * @return the servlet initializer beans
	 */
	protected Collection<ServletContextInitializer> getServletContextInitializerBeans() {
		return new ServletContextInitializerBeans(getBeanFactory());
	}
	/**
	 * Prepare the {@link WebApplicationContext} with the given fully loaded
	 * {@link ServletContext}. This method is usually called from
	 * {@link ServletContextInitializer#onStartup(ServletContext)} and is similar to the
	 * functionality usually provided by a {@link ContextLoaderListener}.
	 * @param servletContext the operational servlet context
	 */
	protected void prepareWebApplicationContext(ServletContext servletContext) {
		Object rootContext = servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
		if (rootContext != null) {
			if (rootContext == this) {
				throw new IllegalStateException(
						'Cannot initialize context because there is already a root application context present - '
								+ 'check whether you have multiple ServletContextInitializers!');
			}
			return;
		}
		servletContext.log('Initializing Spring embedded WebApplicationContext');
		try {
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this);
			if (logger.isDebugEnabled()) {
				logger.debug('Published root WebApplicationContext as ServletContext attribute with name ['
						+ WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + ']');
			}
			setServletContext(servletContext);
			if (logger.isInfoEnabled()) {
				long elapsedTime = System.currentTimeMillis() - getStartupDate();
				logger.info('Root WebApplicationContext: initialization completed in ' + elapsedTime + ' ms');
			}
		}
		catch (RuntimeException | Error ex) {
			logger.error('Context initialization failed', ex);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
			throw ex;
		}
	}
	@Override
	protected Resource getResourceByPath(String path) {
		if (getServletContext() == null) {
			return new ClassPathContextResource(path, getClassLoader());
		}
		return new ServletContextResource(getServletContext(), path);
	}
	@Override
	public String getServerNamespace() {
		return this.serverNamespace;
	}
	@Override
	public void setServerNamespace(String serverNamespace) {
		this.serverNamespace = serverNamespace;
	}
	@Override
	public void setServletConfig(ServletConfig servletConfig) {
		this.servletConfig = servletConfig;
	}
	@Override
	public ServletConfig getServletConfig() {
		return this.servletConfig;
	}
	/**
	 * Returns the {@link WebServer} that was created by the context or {@code null} if
	 * the server has not yet been created.
	 * @return the embedded web server
	 */
	@Override
	public WebServer getWebServer() {
		return this.webServer;
	}
	/**
	 * Utility class to store and restore any user defined scopes. This allows scopes to
	 * be registered in an ApplicationContextInitializer in the same way as they would in
	 * a classic non-embedded web application context.
	 */
	public static class ExistingWebApplicationScopes {
		private static final Set<String> SCOPES;
		static {
			Set<String> scopes = new LinkedHashSet<>();
			scopes.add(WebApplicationContext.SCOPE_REQUEST);
			scopes.add(WebApplicationContext.SCOPE_SESSION);
			SCOPES = Collections.unmodifiableSet(scopes);
		}
		private final ConfigurableListableBeanFactory beanFactory;
		private final Map<String, Scope> scopes = new HashMap<>();
		public ExistingWebApplicationScopes(ConfigurableListableBeanFactory beanFactory) {
			this.beanFactory = beanFactory;
			for (String scopeName : SCOPES) {
				Scope scope = beanFactory.getRegisteredScope(scopeName);
				if (scope != null) {
					this.scopes.put(scopeName, scope);
				}
			}
		}
		public void restore() {
			this.scopes.forEach((key, value) -> {
				if (logger.isInfoEnabled()) {
					logger.info('Restoring user defined scope ' + key);
				}
				this.beanFactory.registerScope(key, value);
			});
		}
	}
}
/*
/**
package org.springframework.boot.web.servlet.context;
/*
package org.springframework.boot.web.servlet.context;
/**
public class AnnotationConfigServletWebServerApplicationContext extends ServletWebServerApplicationContext
		implements AnnotationConfigRegistry {
	private final AnnotatedBeanDefinitionReader reader;
	private final ClassPathBeanDefinitionScanner scanner;
	private final Set<Class<?>> annotatedClasses = new LinkedHashSet<>();
	private String[] basePackages;
	/**
	 * Create a new {@link AnnotationConfigServletWebServerApplicationContext} that needs
	 * to be populated through {@link #register} calls and then manually
	 * {@linkplain #refresh refreshed}.
	 */
	public AnnotationConfigServletWebServerApplicationContext() {
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
	/**
	 * Create a new {@link AnnotationConfigServletWebServerApplicationContext} with the
	 * given {@code DefaultListableBeanFactory}. The context needs to be populated through
	 * {@link #register} calls and then manually {@linkplain #refresh refreshed}.
	 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
	 */
	public AnnotationConfigServletWebServerApplicationContext(DefaultListableBeanFactory beanFactory) {
		super(beanFactory);
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
	/**
	 * Create a new {@link AnnotationConfigServletWebServerApplicationContext}, deriving
	 * bean definitions from the given annotated classes and automatically refreshing the
	 * context.
	 * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}
	 * classes
	 */
	public AnnotationConfigServletWebServerApplicationContext(Class<?>... annotatedClasses) {
		this();
		register(annotatedClasses);
		refresh();
	}
	/**
	 * Create a new {@link AnnotationConfigServletWebServerApplicationContext}, scanning
	 * for bean definitions in the given packages and automatically refreshing the
	 * context.
	 * @param basePackages the packages to check for annotated classes
	 */
	public AnnotationConfigServletWebServerApplicationContext(String... basePackages) {
		this();
		scan(basePackages);
		refresh();
	}
	/**
	 * {@inheritDoc}
	 * <p>
	 * Delegates given environment to underlying {@link AnnotatedBeanDefinitionReader} and
	 * {@link ClassPathBeanDefinitionScanner} members.
	 */
	@Override
	public void setEnvironment(ConfigurableEnvironment environment) {
		super.setEnvironment(environment);
		this.reader.setEnvironment(environment);
		this.scanner.setEnvironment(environment);
	}
	/**
	 * Provide a custom {@link BeanNameGenerator} for use with
	 * {@link AnnotatedBeanDefinitionReader} and/or
	 * {@link ClassPathBeanDefinitionScanner}, if any.
	 * <p>
	 * Default is
	 * {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.
	 * <p>
	 * Any call to this method must occur prior to calls to {@link #register(Class...)}
	 * and/or {@link #scan(String...)}.
	 * @param beanNameGenerator the bean name generator
	 * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator
	 * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator
	 */
	public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
		this.reader.setBeanNameGenerator(beanNameGenerator);
		this.scanner.setBeanNameGenerator(beanNameGenerator);
		getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
	}
	/**
	 * Set the {@link ScopeMetadataResolver} to use for detected bean classes.
	 * <p>
	 * The default is an {@link AnnotationScopeMetadataResolver}.
	 * <p>
	 * Any call to this method must occur prior to calls to {@link #register(Class...)}
	 * and/or {@link #scan(String...)}.
	 * @param scopeMetadataResolver the scope metadata resolver
	 */
	public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {
		this.reader.setScopeMetadataResolver(scopeMetadataResolver);
		this.scanner.setScopeMetadataResolver(scopeMetadataResolver);
	}
	/**
	 * Register one or more annotated classes to be processed. Note that
	 * {@link #refresh()} must be called in order for the context to fully process the new
	 * class.
	 * <p>
	 * Calls to {@code #register} are idempotent; adding the same annotated class more
	 * than once has no additional effect.
	 * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}
	 * classes
	 * @see #scan(String...)
	 * @see #refresh()
	 */
	@Override
	public final void register(Class<?>... annotatedClasses) {
		Assert.notEmpty(annotatedClasses, 'At least one annotated class must be specified');
		this.annotatedClasses.addAll(Arrays.asList(annotatedClasses));
	}
	/**
	 * Perform a scan within the specified base packages. Note that {@link #refresh()}
	 * must be called in order for the context to fully process the new class.
	 * @param basePackages the packages to check for annotated classes
	 * @see #register(Class...)
	 * @see #refresh()
	 */
	@Override
	public final void scan(String... basePackages) {
		Assert.notEmpty(basePackages, 'At least one base package must be specified');
		this.basePackages = basePackages;
	}
	@Override
	protected void prepareRefresh() {
		this.scanner.clearCache();
		super.prepareRefresh();
	}
	@Override
	protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		super.postProcessBeanFactory(beanFactory);
		if (this.basePackages != null && this.basePackages.length > 0) {
			this.scanner.scan(this.basePackages);
		}
		if (!this.annotatedClasses.isEmpty()) {
			this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
public class ServletContextInitializerBeans extends AbstractCollection<ServletContextInitializer> {
	private static final String DISPATCHER_SERVLET_NAME = 'dispatcherServlet';
	private static final Log logger = LogFactory.getLog(ServletContextInitializerBeans.class);
	/**
	 * Seen bean instances or bean names.
	 */
	private final Seen seen = new Seen();
	private final MultiValueMap<Class<?>, ServletContextInitializer> initializers;
	private final List<Class<? extends ServletContextInitializer>> initializerTypes;
	private final List<ServletContextInitializer> sortedList;
	@SafeVarargs
	@SuppressWarnings('varargs')
	public ServletContextInitializerBeans(ListableBeanFactory beanFactory,
			Class<? extends ServletContextInitializer>... initializerTypes) {
		this.initializers = new LinkedMultiValueMap<>();
		this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes)
				: Collections.singletonList(ServletContextInitializer.class);
		addServletContextInitializerBeans(beanFactory);
		addAdaptableBeans(beanFactory);
		this.sortedList = this.initializers.values()
			.stream()
			.flatMap((value) -> value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))
			.toList();
		logMappings(this.initializers);
	}
	private void addServletContextInitializerBeans(ListableBeanFactory beanFactory) {
		for (Class<? extends ServletContextInitializer> initializerType : this.initializerTypes) {
			for (Entry<String, ? extends ServletContextInitializer> initializerBean : getOrderedBeansOfType(beanFactory,
					initializerType)) {
				addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);
			}
		}
	}
	private void addServletContextInitializerBean(String beanName, ServletContextInitializer initializer,
			ListableBeanFactory beanFactory) {
		if (initializer instanceof ServletRegistrationBean<?> servletRegistrationBean) {
			Servlet source = servletRegistrationBean.getServlet();
			addServletContextInitializerBean(Servlet.class, beanName, servletRegistrationBean, beanFactory, source);
		}
		else if (initializer instanceof FilterRegistrationBean<?> filterRegistrationBean) {
			Filter source = filterRegistrationBean.getFilter();
			addServletContextInitializerBean(Filter.class, beanName, filterRegistrationBean, beanFactory, source);
		}
		else if (initializer instanceof DelegatingFilterProxyRegistrationBean registrationBean) {
			String source = registrationBean.getTargetBeanName();
			addServletContextInitializerBean(Filter.class, beanName, registrationBean, beanFactory, source);
		}
		else if (initializer instanceof ServletListenerRegistrationBean<?> registrationBean) {
			EventListener source = registrationBean.getListener();
			addServletContextInitializerBean(EventListener.class, beanName, registrationBean, beanFactory, source);
		}
		else {
			addServletContextInitializerBean(ServletContextInitializer.class, beanName, initializer, beanFactory,
					initializer);
		}
	}
	private void addServletContextInitializerBean(Class<?> type, String beanName, ServletContextInitializer initializer,
			ListableBeanFactory beanFactory, Object source) {
		this.initializers.add(type, initializer);
		if (source != null) {
			// Mark the underlying source as seen in case it wraps an existing bean
			this.seen.add(type, source);
		}
		if (logger.isTraceEnabled()) {
			String resourceDescription = getResourceDescription(beanName, beanFactory);
			int order = getOrder(initializer);
			logger.trace('Added existing ' + type.getSimpleName() + ' initializer bean "' + beanName + '"; order='
					+ order + ', resource=' + resourceDescription);
		}
	}
	private String getResourceDescription(String beanName, ListableBeanFactory beanFactory) {
		if (beanFactory instanceof BeanDefinitionRegistry registry) {
			return registry.getBeanDefinition(beanName).getResourceDescription();
		}
		return 'unknown';
	}
	@SuppressWarnings('unchecked')
	protected void addAdaptableBeans(ListableBeanFactory beanFactory) {
		MultipartConfigElement multipartConfig = getMultipartConfig(beanFactory);
		addAsRegistrationBean(beanFactory, Servlet.class, new ServletRegistrationBeanAdapter(multipartConfig));
		addAsRegistrationBean(beanFactory, Filter.class, new FilterRegistrationBeanAdapter());
		for (Class<?> listenerType : ServletListenerRegistrationBean.getSupportedTypes()) {
			addAsRegistrationBean(beanFactory, EventListener.class, (Class<EventListener>) listenerType,
					new ServletListenerRegistrationBeanAdapter());
		}
	}
	private MultipartConfigElement getMultipartConfig(ListableBeanFactory beanFactory) {
		List<Entry<String, MultipartConfigElement>> beans = getOrderedBeansOfType(beanFactory,
				MultipartConfigElement.class);
		return beans.isEmpty() ? null : beans.get(0).getValue();
	}
	protected <T> void addAsRegistrationBean(ListableBeanFactory beanFactory, Class<T> type,
			RegistrationBeanAdapter<T> adapter) {
		addAsRegistrationBean(beanFactory, type, type, adapter);
	}
	private <T, B extends T> void addAsRegistrationBean(ListableBeanFactory beanFactory, Class<T> type,
			Class<B> beanType, RegistrationBeanAdapter<T> adapter) {
		List<Map.Entry<String, B>> entries = getOrderedBeansOfType(beanFactory, beanType, this.seen);
		for (Entry<String, B> entry : entries) {
			String beanName = entry.getKey();
			B bean = entry.getValue();
			if (this.seen.add(type, bean)) {
				// One that we haven"t already seen
				RegistrationBean registration = adapter.createRegistrationBean(beanName, bean, entries.size());
				int order = getOrder(bean);
				registration.setOrder(order);
				this.initializers.add(type, registration);
				if (logger.isTraceEnabled()) {
					logger.trace('Created ' + type.getSimpleName() + ' initializer for bean "' + beanName + '"; order='
							+ order + ', resource=' + getResourceDescription(beanName, beanFactory));
				}
			}
		}
	}
	private int getOrder(Object value) {
		return new AnnotationAwareOrderComparator() {
			@Override
			public int getOrder(Object obj) {
				return super.getOrder(obj);
			}
		}.getOrder(value);
	}
	private <T> List<Entry<String, T>> getOrderedBeansOfType(ListableBeanFactory beanFactory, Class<T> type) {
		return getOrderedBeansOfType(beanFactory, type, Seen.empty());
	}
	private <T> List<Entry<String, T>> getOrderedBeansOfType(ListableBeanFactory beanFactory, Class<T> type,
			Seen seen) {
		String[] names = beanFactory.getBeanNamesForType(type, true, false);
		Map<String, T> map = new LinkedHashMap<>();
		for (String name : names) {
			if (!seen.contains(type, name) && !ScopedProxyUtils.isScopedTarget(name)) {
				T bean = beanFactory.getBean(name, type);
				if (!seen.contains(type, bean)) {
					map.put(name, bean);
				}
			}
		}
		List<Entry<String, T>> beans = new ArrayList<>(map.entrySet());
		beans.sort((o1, o2) -> AnnotationAwareOrderComparator.INSTANCE.compare(o1.getValue(), o2.getValue()));
		return beans;
	}
	private void logMappings(MultiValueMap<Class<?>, ServletContextInitializer> initializers) {
		if (logger.isDebugEnabled()) {
			logMappings('filters', initializers, Filter.class, FilterRegistrationBean.class);
			logMappings('servlets', initializers, Servlet.class, ServletRegistrationBean.class);
		}
	}
	private void logMappings(String name, MultiValueMap<Class<?>, ServletContextInitializer> initializers,
			Class<?> type, Class<? extends RegistrationBean> registrationType) {
		List<ServletContextInitializer> registrations = new ArrayList<>();
		registrations.addAll(initializers.getOrDefault(registrationType, Collections.emptyList()));
		registrations.addAll(initializers.getOrDefault(type, Collections.emptyList()));
		String info = registrations.stream().map(Object::toString).collect(Collectors.joining(', '));
		logger.debug('Mapping ' + name + ': ' + info);
	}
	@Override
	public Iterator<ServletContextInitializer> iterator() {
		return this.sortedList.iterator();
	}
	@Override
	public int size() {
		return this.sortedList.size();
	}
	/**
	 * Adapter to convert a given Bean type into a {@link RegistrationBean} (and hence a
	 * {@link ServletContextInitializer}).
	 *
	 * @param <T> the type of the Bean to adapt
	 */
	@FunctionalInterface
	protected interface RegistrationBeanAdapter<T> {
		RegistrationBean createRegistrationBean(String name, T source, int totalNumberOfSourceBeans);
	}
	/**
	 * {@link RegistrationBeanAdapter} for {@link Servlet} beans.
	 */
	private static class ServletRegistrationBeanAdapter implements RegistrationBeanAdapter<Servlet> {
		private final MultipartConfigElement multipartConfig;
		ServletRegistrationBeanAdapter(MultipartConfigElement multipartConfig) {
			this.multipartConfig = multipartConfig;
		}
		@Override
		public RegistrationBean createRegistrationBean(String name, Servlet source, int totalNumberOfSourceBeans) {
			String url = (totalNumberOfSourceBeans != 1) ? '/' + name + '/' : '/';
			if (name.equals(DISPATCHER_SERVLET_NAME)) {
				url = '/'; // always map the main dispatcherServlet to '/'
			}
			ServletRegistrationBean<Servlet> bean = new ServletRegistrationBean<>(source, url);
			bean.setName(name);
			bean.setMultipartConfig(this.multipartConfig);
			return bean;
		}
	}
	/**
	 * {@link RegistrationBeanAdapter} for {@link Filter} beans.
	 */
	private static final class FilterRegistrationBeanAdapter implements RegistrationBeanAdapter<Filter> {
		@Override
		public RegistrationBean createRegistrationBean(String name, Filter source, int totalNumberOfSourceBeans) {
			FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>(source);
			bean.setName(name);
			return bean;
		}
	}
	/**
	 * {@link RegistrationBeanAdapter} for certain {@link EventListener} beans.
	 */
	private static final class ServletListenerRegistrationBeanAdapter
			implements RegistrationBeanAdapter<EventListener> {
		@Override
		public RegistrationBean createRegistrationBean(String name, EventListener source,
				int totalNumberOfSourceBeans) {
			return new ServletListenerRegistrationBean<>(source);
		}
	}
	private static final class Seen {
		private final Map<Class<?>, Set<Object>> seen = new HashMap<>();
		boolean add(Class<?> type, Object object) {
			if (contains(type, object)) {
				return false;
			}
			return this.seen.computeIfAbsent(type, (ignore) -> new HashSet<>()).add(object);
		}
		boolean contains(Class<?> type, Object object) {
			if (this.seen.isEmpty()) {
				return false;
			}
			// If it has been directly seen, or the implemented ServletContextInitializer
			// has been seen already
			if (type != ServletContextInitializer.class
					&& this.seen.getOrDefault(type, Collections.emptySet()).contains(object)) {
				return true;
			}
			return this.seen.getOrDefault(ServletContextInitializer.class, Collections.emptySet()).contains(object);
		}
		static Seen empty() {
			return new Seen();
		}
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
public abstract class AbstractServletWebServerFactory extends AbstractConfigurableWebServerFactory
		implements ConfigurableServletWebServerFactory {
	protected final Log logger = LogFactory.getLog(getClass());
	private String contextPath = '';
	private String displayName;
	private Session session = new Session();
	private boolean registerDefaultServlet = false;
	private MimeMappings mimeMappings = MimeMappings.lazyCopy(MimeMappings.DEFAULT);
	private List<ServletContextInitializer> initializers = new ArrayList<>();
	private Jsp jsp = new Jsp();
	private Map<Locale, Charset> localeCharsetMappings = new HashMap<>();
	private Map<String, String> initParameters = Collections.emptyMap();
	private List<CookieSameSiteSupplier> cookieSameSiteSuppliers = new ArrayList<>();
	private final DocumentRoot documentRoot = new DocumentRoot(this.logger);
	private final StaticResourceJars staticResourceJars = new StaticResourceJars();
	private final Set<String> webListenerClassNames = new HashSet<>();
	/**
	 * Create a new {@link AbstractServletWebServerFactory} instance.
	 */
	public AbstractServletWebServerFactory() {
	}
	/**
	 * Create a new {@link AbstractServletWebServerFactory} instance with the specified
	 * port.
	 * @param port the port number for the web server
	 */
	public AbstractServletWebServerFactory(int port) {
		super(port);
	}
	/**
	 * Create a new {@link AbstractServletWebServerFactory} instance with the specified
	 * context path and port.
	 * @param contextPath the context path for the web server
	 * @param port the port number for the web server
	 */
	public AbstractServletWebServerFactory(String contextPath, int port) {
		super(port);
		checkContextPath(contextPath);
		this.contextPath = contextPath;
	}
	/**
	 * Returns the context path for the web server. The path will start with '/' and not
	 * end with '/'. The root context is represented by an empty string.
	 * @return the context path
	 */
	public String getContextPath() {
		return this.contextPath;
	}
	@Override
	public void setContextPath(String contextPath) {
		checkContextPath(contextPath);
		this.contextPath = contextPath;
	}
	private void checkContextPath(String contextPath) {
		Assert.notNull(contextPath, 'ContextPath must not be null');
		if (!contextPath.isEmpty()) {
			if ('/'.equals(contextPath)) {
				throw new IllegalArgumentException('Root ContextPath must be specified using an empty string');
			}
			if (!contextPath.startsWith('/') || contextPath.endsWith('/')) {
				throw new IllegalArgumentException('ContextPath must start with "/" and not end with "/"');
			}
		}
	}
	public String getDisplayName() {
		return this.displayName;
	}
	@Override
	public void setDisplayName(String displayName) {
		this.displayName = displayName;
	}
	/**
	 * Flag to indicate that the default servlet should be registered.
	 * @return true if the default servlet is to be registered
	 */
	public boolean isRegisterDefaultServlet() {
		return this.registerDefaultServlet;
	}
	@Override
	public void setRegisterDefaultServlet(boolean registerDefaultServlet) {
		this.registerDefaultServlet = registerDefaultServlet;
	}
	/**
	 * Returns the mime-type mappings.
	 * @return the mimeMappings the mime-type mappings.
	 */
	public MimeMappings getMimeMappings() {
		return this.mimeMappings;
	}
	@Override
	public void setMimeMappings(MimeMappings mimeMappings) {
		Assert.notNull(mimeMappings, 'MimeMappings must not be null');
		this.mimeMappings = new MimeMappings(mimeMappings);
	}
	@Override
	public void addMimeMappings(MimeMappings mimeMappings) {
		mimeMappings.forEach((mapping) -> this.mimeMappings.add(mapping.getExtension(), mapping.getMimeType()));
	}
	/**
	 * Returns the document root which will be used by the web context to serve static
	 * files.
	 * @return the document root
	 */
	public File getDocumentRoot() {
		return this.documentRoot.getDirectory();
	}
	@Override
	public void setDocumentRoot(File documentRoot) {
		this.documentRoot.setDirectory(documentRoot);
	}
	@Override
	public void setInitializers(List<? extends ServletContextInitializer> initializers) {
		Assert.notNull(initializers, 'Initializers must not be null');
		this.initializers = new ArrayList<>(initializers);
	}
	@Override
	public void addInitializers(ServletContextInitializer... initializers) {
		Assert.notNull(initializers, 'Initializers must not be null');
		this.initializers.addAll(Arrays.asList(initializers));
	}
	public Jsp getJsp() {
		return this.jsp;
	}
	@Override
	public void setJsp(Jsp jsp) {
		this.jsp = jsp;
	}
	public Session getSession() {
		return this.session;
	}
	@Override
	public void setSession(Session session) {
		this.session = session;
	}
	/**
	 * Return the Locale to Charset mappings.
	 * @return the charset mappings
	 */
	public Map<Locale, Charset> getLocaleCharsetMappings() {
		return this.localeCharsetMappings;
	}
	@Override
	public void setLocaleCharsetMappings(Map<Locale, Charset> localeCharsetMappings) {
		Assert.notNull(localeCharsetMappings, 'localeCharsetMappings must not be null');
		this.localeCharsetMappings = localeCharsetMappings;
	}
	@Override
	public void setInitParameters(Map<String, String> initParameters) {
		this.initParameters = initParameters;
	}
	public Map<String, String> getInitParameters() {
		return this.initParameters;
	}
	@Override
	public void setCookieSameSiteSuppliers(List<? extends CookieSameSiteSupplier> cookieSameSiteSuppliers) {
		Assert.notNull(cookieSameSiteSuppliers, 'CookieSameSiteSuppliers must not be null');
		this.cookieSameSiteSuppliers = new ArrayList<>(cookieSameSiteSuppliers);
	}
	@Override
	public void addCookieSameSiteSuppliers(CookieSameSiteSupplier... cookieSameSiteSuppliers) {
		Assert.notNull(cookieSameSiteSuppliers, 'CookieSameSiteSuppliers must not be null');
		this.cookieSameSiteSuppliers.addAll(Arrays.asList(cookieSameSiteSuppliers));
	}
	public List<CookieSameSiteSupplier> getCookieSameSiteSuppliers() {
		return this.cookieSameSiteSuppliers;
	}
	/**
	 * Utility method that can be used by subclasses wishing to combine the specified
	 * {@link ServletContextInitializer} parameters with those defined in this instance.
	 * @param initializers the initializers to merge
	 * @return a complete set of merged initializers (with the specified parameters
	 * appearing first)
	 */
	protected final ServletContextInitializer[] mergeInitializers(ServletContextInitializer... initializers) {
		List<ServletContextInitializer> mergedInitializers = new ArrayList<>();
		mergedInitializers.add((servletContext) -> this.initParameters.forEach(servletContext::setInitParameter));
		mergedInitializers.add(new SessionConfiguringInitializer(this.session));
		mergedInitializers.addAll(Arrays.asList(initializers));
		mergedInitializers.addAll(this.initializers);
		return mergedInitializers.toArray(new ServletContextInitializer[0]);
	}
	/**
	 * Returns whether the JSP servlet should be registered with the web server.
	 * @return {@code true} if the servlet should be registered, otherwise {@code false}
	 */
	protected boolean shouldRegisterJspServlet() {
		return this.jsp != null && this.jsp.getRegistered()
				&& ClassUtils.isPresent(this.jsp.getClassName(), getClass().getClassLoader());
	}
	/**
	 * Returns the absolute document root when it points to a valid directory, logging a
	 * warning and returning {@code null} otherwise.
	 * @return the valid document root
	 */
	protected final File getValidDocumentRoot() {
		return this.documentRoot.getValidDirectory();
	}
	protected final List<URL> getUrlsOfJarsWithMetaInfResources() {
		return this.staticResourceJars.getUrls();
	}
	protected final File getValidSessionStoreDir() {
		return getValidSessionStoreDir(true);
	}
	protected final File getValidSessionStoreDir(boolean mkdirs) {
		return this.session.getSessionStoreDirectory().getValidDirectory(mkdirs);
	}
	@Override
	public void addWebListeners(String... webListenerClassNames) {
		this.webListenerClassNames.addAll(Arrays.asList(webListenerClassNames));
	}
	protected final Set<String> getWebListenerClassNames() {
		return this.webListenerClassNames;
	}
	/**
	 * {@link ServletContextInitializer} to apply appropriate parts of the {@link Session}
	 * configuration.
	 */
	private static class SessionConfiguringInitializer implements ServletContextInitializer {
		private final Session session;
		SessionConfiguringInitializer(Session session) {
			this.session = session;
		}
		@Override
		public void onStartup(ServletContext servletContext) throws ServletException {
			if (this.session.getTrackingModes() != null) {
				servletContext.setSessionTrackingModes(unwrap(this.session.getTrackingModes()));
			}
			configureSessionCookie(servletContext.getSessionCookieConfig());
		}
		private void configureSessionCookie(SessionCookieConfig config) {
			Cookie cookie = this.session.getCookie();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(cookie::getName).to(config::setName);
			map.from(cookie::getDomain).to(config::setDomain);
			map.from(cookie::getPath).to(config::setPath);
			map.from(cookie::getHttpOnly).to(config::setHttpOnly);
			map.from(cookie::getSecure).to(config::setSecure);
			map.from(cookie::getMaxAge).asInt(Duration::getSeconds).to(config::setMaxAge);
			map.from(cookie::getPartitioned)
				.as(Object::toString)
				.to((partitioned) -> config.setAttribute('Partitioned', partitioned));
		}
		private Set<jakarta.servlet.SessionTrackingMode> unwrap(Set<Session.SessionTrackingMode> modes) {
			if (modes == null) {
				return null;
			}
			Set<jakarta.servlet.SessionTrackingMode> result = new LinkedHashSet<>();
			for (Session.SessionTrackingMode mode : modes) {
				result.add(jakarta.servlet.SessionTrackingMode.valueOf(mode.name()));
			}
			return result;
		}
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
class SessionStoreDirectory {
	private File directory;
	File getDirectory() {
		return this.directory;
	}
	void setDirectory(File directory) {
		this.directory = directory;
	}
	File getValidDirectory(boolean mkdirs) {
		File dir = getDirectory();
		if (dir == null) {
			return new ApplicationTemp().getDir('servlet-sessions');
		}
		if (!dir.isAbsolute()) {
			dir = new File(new ApplicationHome().getDir(), dir.getPath());
		}
		if (!dir.exists() && mkdirs) {
			dir.mkdirs();
		}
		assertDirectory(mkdirs, dir);
		return dir;
	}
	private void assertDirectory(boolean mkdirs, File dir) {
		Assert.state(!mkdirs || dir.exists(), () -> 'Session dir ' + dir + ' does not exist');
		Assert.state(!dir.isFile(), () -> 'Session dir ' + dir + ' points to a file');
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
@FunctionalInterface
public interface CookieSameSiteSupplier {
	/**
	 * Get the {@link SameSite} values that should be used for the given {@link Cookie}.
	 * @param cookie the cookie to check
	 * @return the {@link SameSite} value to use or {@code null} if the next supplier
	 * should be checked
	 */
	SameSite getSameSite(Cookie cookie);
	/**
	 * Limit this supplier so that it"s only called if the Cookie has the given name.
	 * @param name the name to check
	 * @return a new {@link CookieSameSiteSupplier} that only calls this supplier when the
	 * name matches
	 */
	default CookieSameSiteSupplier whenHasName(String name) {
		Assert.hasText(name, 'Name must not be empty');
		return when((cookie) -> ObjectUtils.nullSafeEquals(cookie.getName(), name));
	}
	/**
	 * Limit this supplier so that it"s only called if the Cookie has the given name.
	 * @param nameSupplier a supplier providing the name to check
	 * @return a new {@link CookieSameSiteSupplier} that only calls this supplier when the
	 * name matches
	 */
	default CookieSameSiteSupplier whenHasName(Supplier<String> nameSupplier) {
		Assert.notNull(nameSupplier, 'NameSupplier must not be empty');
		return when((cookie) -> ObjectUtils.nullSafeEquals(cookie.getName(), nameSupplier.get()));
	}
	/**
	 * Limit this supplier so that it"s only called if the Cookie name matches the given
	 * regex.
	 * @param regex the regex pattern that must match
	 * @return a new {@link CookieSameSiteSupplier} that only calls this supplier when the
	 * name matches the regex
	 */
	default CookieSameSiteSupplier whenHasNameMatching(String regex) {
		Assert.hasText(regex, 'Regex must not be empty');
		return whenHasNameMatching(Pattern.compile(regex));
	}
	/**
	 * Limit this supplier so that it"s only called if the Cookie name matches the given
	 * {@link Pattern}.
	 * @param pattern the regex pattern that must match
	 * @return a new {@link CookieSameSiteSupplier} that only calls this supplier when the
	 * name matches the pattern
	 */
	default CookieSameSiteSupplier whenHasNameMatching(Pattern pattern) {
		Assert.notNull(pattern, 'Pattern must not be null');
		return when((cookie) -> pattern.matcher(cookie.getName()).matches());
	}
	/**
	 * Limit this supplier so that it"s only called if the predicate accepts the Cookie.
	 * @param predicate the predicate used to match the cookie
	 * @return a new {@link CookieSameSiteSupplier} that only calls this supplier when the
	 * cookie matches the predicate
	 */
	default CookieSameSiteSupplier when(Predicate<Cookie> predicate) {
		Assert.notNull(predicate, 'Predicate must not be null');
		return (cookie) -> predicate.test(cookie) ? getSameSite(cookie) : null;
	}
	/**
	 * Return a new {@link CookieSameSiteSupplier} that always returns
	 * {@link SameSite#NONE}.
	 * @return the supplier instance
	 */
	static CookieSameSiteSupplier ofNone() {
		return of(SameSite.NONE);
	}
	/**
	 * Return a new {@link CookieSameSiteSupplier} that always returns
	 * {@link SameSite#LAX}.
	 * @return the supplier instance
	 */
	static CookieSameSiteSupplier ofLax() {
		return of(SameSite.LAX);
	}
	/**
	 * Return a new {@link CookieSameSiteSupplier} that always returns
	 * {@link SameSite#STRICT}.
	 * @return the supplier instance
	 */
	static CookieSameSiteSupplier ofStrict() {
		return of(SameSite.STRICT);
	}
	/**
	 * Return a new {@link CookieSameSiteSupplier} that always returns the given
	 * {@link SameSite} value.
	 * @param sameSite the value to return
	 * @return the supplier instance
	 */
	static CookieSameSiteSupplier of(SameSite sameSite) {
		Assert.notNull(sameSite, 'SameSite must not be null');
		return (cookie) -> sameSite;
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
public class Jsp {
	/**
	 * Class name of the servlet to use for JSPs. If registered is true and this class is
	 * on the classpath then it will be registered.
	 */
	private String className = 'org.apache.jasper.servlet.JspServlet';
	private Map<String, String> initParameters = new HashMap<>();
	/**
	 * Whether the JSP servlet is registered.
	 */
	private boolean registered = true;
	public Jsp() {
		this.initParameters.put('development', 'false');
	}
	/**
	 * Return the class name of the servlet to use for JSPs. If {@link #getRegistered()
	 * registered} is {@code true} and this class is on the classpath then it will be
	 * registered.
	 * @return the class name of the servlet to use for JSPs
	 */
	public String getClassName() {
		return this.className;
	}
	public void setClassName(String className) {
		this.className = className;
	}
	/**
	 * Return the init parameters used to configure the JSP servlet.
	 * @return the init parameters
	 */
	public Map<String, String> getInitParameters() {
		return this.initParameters;
	}
	public void setInitParameters(Map<String, String> initParameters) {
		this.initParameters = initParameters;
	}
	/**
	 * Return whether the JSP servlet is registered.
	 * @return {@code true} to register the JSP servlet
	 */
	public boolean getRegistered() {
		return this.registered;
	}
	public void setRegistered(boolean registered) {
		this.registered = registered;
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
@FunctionalInterface
public interface ServletWebServerFactory extends WebServerFactory {
	/**
	 * Gets a new fully configured but paused {@link WebServer} instance. Clients should
	 * not be able to connect to the returned server until {@link WebServer#start()} is
	 * called (which happens when the {@code ApplicationContext} has been fully
	 * refreshed).
	 * @param initializers {@link ServletContextInitializer}s that should be applied as
	 * the server starts
	 * @return a fully configured and started {@link WebServer}
	 * @see WebServer#stop()
	 */
	WebServer getWebServer(ServletContextInitializer... initializers);
}
/*
package org.springframework.boot.web.servlet.server;
/**
class StaticResourceJars {
	List<URL> getUrls() {
		ClassLoader classLoader = getClass().getClassLoader();
		if (classLoader instanceof URLClassLoader urlClassLoader) {
			return getUrlsFrom(urlClassLoader.getURLs());
		}
		else {
			return getUrlsFrom(Stream.of(ManagementFactory.getRuntimeMXBean().getClassPath().split(File.pathSeparator))
				.map(this::toUrl)
				.toArray(URL[]::new));
		}
	}
	List<URL> getUrlsFrom(URL... urls) {
		List<URL> resourceJarUrls = new ArrayList<>();
		for (URL url : urls) {
			addUrl(resourceJarUrls, url);
		}
		return resourceJarUrls;
	}
	private URL toUrl(String classPathEntry) {
		try {
			return new File(classPathEntry).toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalArgumentException('URL could not be created from "' + classPathEntry + '"', ex);
		}
	}
	private File toFile(URL url) {
		try {
			return new File(url.toURI());
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException('Failed to create File from URL "' + url + '"');
		}
		catch (IllegalArgumentException ex) {
			return null;
		}
	}
	private void addUrl(List<URL> urls, URL url) {
		try {
			if (!'file'.equals(url.getProtocol())) {
				addUrlConnection(urls, url, url.openConnection());
			}
			else {
				File file = toFile(url);
				if (file != null) {
					addUrlFile(urls, url, file);
				}
				else {
					addUrlConnection(urls, url, url.openConnection());
				}
			}
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private void addUrlFile(List<URL> urls, URL url, File file) {
		if ((file.isDirectory() && new File(file, 'META-INF/resources').isDirectory()) || isResourcesJar(file)) {
			urls.add(url);
		}
	}
	private void addUrlConnection(List<URL> urls, URL url, URLConnection connection) {
		if (connection instanceof JarURLConnection jarURLConnection && isResourcesJar(jarURLConnection)) {
			urls.add(url);
		}
	}
	private boolean isResourcesJar(JarURLConnection connection) {
		try {
			return isResourcesJar(connection.getJarFile(), !connection.getUseCaches());
		}
		catch (IOException ex) {
			return false;
		}
	}
	private boolean isResourcesJar(File file) {
		try {
			return isResourcesJar(new JarFile(file), true);
		}
		catch (IOException | InvalidPathException ex) {
			return false;
		}
	}
	private boolean isResourcesJar(JarFile jarFile, boolean closeJarFile) throws IOException {
		try {
			return jarFile.getName().endsWith('.jar') && (jarFile.getJarEntry('META-INF/resources') != null);
		}
		finally {
			if (closeJarFile) {
				jarFile.close();
			}
		}
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
public interface ConfigurableServletWebServerFactory
		extends ConfigurableWebServerFactory, ServletWebServerFactory, WebListenerRegistry {
	/**
	 * Sets the context path for the web server. The context should start with a '/'
	 * character but not end with a '/' character. The default context path can be
	 * specified using an empty string.
	 * @param contextPath the contextPath to set
	 */
	void setContextPath(String contextPath);
	/**
	 * Sets the display name of the application deployed in the web server.
	 * @param displayName the displayName to set
	 * @since 1.3.0
	 */
	void setDisplayName(String displayName);
	/**
	 * Sets the configuration that will be applied to the container"s HTTP session
	 * support.
	 * @param session the session configuration
	 */
	void setSession(Session session);
	/**
	 * Set if the DefaultServlet should be registered. Defaults to {@code false} since
	 * 2.4.
	 * @param registerDefaultServlet if the default servlet should be registered
	 */
	void setRegisterDefaultServlet(boolean registerDefaultServlet);
	/**
	 * Sets the mime-type mappings.
	 * @param mimeMappings the mime type mappings (defaults to
	 * {@link MimeMappings#DEFAULT})
	 */
	void setMimeMappings(MimeMappings mimeMappings);
	/**
	 * Adds mime-type mappings.
	 * @param mimeMappings the mime type mappings to add
	 * @since 3.3.0
	 */
	void addMimeMappings(MimeMappings mimeMappings);
	/**
	 * Sets the document root directory which will be used by the web context to serve
	 * static files.
	 * @param documentRoot the document root or {@code null} if not required
	 */
	void setDocumentRoot(File documentRoot);
	/**
	 * Sets {@link ServletContextInitializer} that should be applied in addition to
	 * {@link ServletWebServerFactory#getWebServer(ServletContextInitializer...)}
	 * parameters. This method will replace any previously set or added initializers.
	 * @param initializers the initializers to set
	 * @see #addInitializers
	 */
	void setInitializers(List<? extends ServletContextInitializer> initializers);
	/**
	 * Add {@link ServletContextInitializer}s to those that should be applied in addition
	 * to {@link ServletWebServerFactory#getWebServer(ServletContextInitializer...)}
	 * parameters.
	 * @param initializers the initializers to add
	 * @see #setInitializers
	 */
	void addInitializers(ServletContextInitializer... initializers);
	/**
	 * Sets the configuration that will be applied to the server"s JSP servlet.
	 * @param jsp the JSP servlet configuration
	 */
	void setJsp(Jsp jsp);
	/**
	 * Sets the Locale to Charset mappings.
	 * @param localeCharsetMappings the Locale to Charset mappings
	 */
	void setLocaleCharsetMappings(Map<Locale, Charset> localeCharsetMappings);
	/**
	 * Sets the init parameters that are applied to the container"s
	 * {@link ServletContext}.
	 * @param initParameters the init parameters
	 */
	void setInitParameters(Map<String, String> initParameters);
	/**
	 * Sets {@link CookieSameSiteSupplier CookieSameSiteSuppliers} that should be used to
	 * obtain the {@link SameSite} attribute of any added cookie. This method will replace
	 * any previously set or added suppliers.
	 * @param cookieSameSiteSuppliers the suppliers to add
	 * @see #addCookieSameSiteSuppliers
	 */
	void setCookieSameSiteSuppliers(List<? extends CookieSameSiteSupplier> cookieSameSiteSuppliers);
	/**
	 * Add {@link CookieSameSiteSupplier CookieSameSiteSuppliers} to those that should be
	 * used to obtain the {@link SameSite} attribute of any added cookie.
	 * @param cookieSameSiteSuppliers the suppliers to add
	 * @see #setCookieSameSiteSuppliers
	 */
	void addCookieSameSiteSuppliers(CookieSameSiteSupplier... cookieSameSiteSuppliers);
}
/*
/**
package org.springframework.boot.web.servlet.server;
/*
package org.springframework.boot.web.servlet.server;
/**
class DocumentRoot {
	private static final String[] COMMON_DOC_ROOTS = { 'src/main/webapp', 'public', 'static' };
	private final Log logger;
	private File directory;
	DocumentRoot(Log logger) {
		this.logger = logger;
	}
	File getDirectory() {
		return this.directory;
	}
	void setDirectory(File directory) {
		this.directory = directory;
	}
	/**
	 * Returns the absolute document root when it points to a valid directory, logging a
	 * warning and returning {@code null} otherwise.
	 * @return the valid document root
	 */
	final File getValidDirectory() {
		File file = this.directory;
		file = (file != null) ? file : getWarFileDocumentRoot();
		file = (file != null) ? file : getExplodedWarFileDocumentRoot();
		file = (file != null) ? file : getCommonDocumentRoot();
		if (file == null && this.logger.isDebugEnabled()) {
			logNoDocumentRoots();
		}
		else if (this.logger.isDebugEnabled()) {
			this.logger.debug('Document root: ' + file);
		}
		return file;
	}
	private File getWarFileDocumentRoot() {
		return getArchiveFileDocumentRoot('.war');
	}
	private File getArchiveFileDocumentRoot(String extension) {
		File file = getCodeSourceArchive();
		if (this.logger.isDebugEnabled()) {
			this.logger.debug('Code archive: ' + file);
		}
		if (file != null && file.exists() && !file.isDirectory()
				&& file.getName().toLowerCase(Locale.ENGLISH).endsWith(extension)) {
			return file.getAbsoluteFile();
		}
		return null;
	}
	private File getExplodedWarFileDocumentRoot() {
		return getExplodedWarFileDocumentRoot(getCodeSourceArchive());
	}
	private File getCodeSourceArchive() {
		return getCodeSourceArchive(getClass().getProtectionDomain().getCodeSource());
	}
	File getCodeSourceArchive(CodeSource codeSource) {
		try {
			URL location = (codeSource != null) ? codeSource.getLocation() : null;
			if (location == null) {
				return null;
			}
			String path;
			URLConnection connection = location.openConnection();
			if (connection instanceof JarURLConnection jarURLConnection) {
				path = jarURLConnection.getJarFile().getName();
			}
			else {
				path = location.toURI().getPath();
			}
			int index = path.indexOf('!/');
			if (index != -1) {
				path = path.substring(0, index);
			}
			return new File(path);
		}
		catch (Exception ex) {
			return null;
		}
	}
	final File getExplodedWarFileDocumentRoot(File codeSourceFile) {
		if (this.logger.isDebugEnabled()) {
			this.logger.debug('Code archive: ' + codeSourceFile);
		}
		if (codeSourceFile != null && codeSourceFile.exists()) {
			String path = codeSourceFile.getAbsolutePath();
			int webInfPathIndex = path.indexOf(File.separatorChar + 'WEB-INF' + File.separatorChar);
			if (webInfPathIndex >= 0) {
				path = path.substring(0, webInfPathIndex);
				return new File(path);
			}
		}
		return null;
	}
	private File getCommonDocumentRoot() {
		for (String commonDocRoot : COMMON_DOC_ROOTS) {
			File root = new File(commonDocRoot);
			if (root.exists() && root.isDirectory()) {
				return root.getAbsoluteFile();
			}
		}
		return null;
	}
	private void logNoDocumentRoots() {
		this.logger.debug('None of the document roots ' + Arrays.asList(COMMON_DOC_ROOTS)
				+ ' point to a directory and will be ignored.');
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
public class Encoding {
	/**
	 * Default HTTP encoding for Servlet applications.
	 */
	public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	/**
	 * Charset of HTTP requests and responses. Added to the 'Content-Type' header if not
	 * set explicitly.
	 */
	private Charset charset = DEFAULT_CHARSET;
	/**
	 * Whether to force the encoding to the configured charset on HTTP requests and
	 * responses.
	 */
	private Boolean force;
	/**
	 * Whether to force the encoding to the configured charset on HTTP requests. Defaults
	 * to true when 'force' has not been specified.
	 */
	private Boolean forceRequest;
	/**
	 * Whether to force the encoding to the configured charset on HTTP responses.
	 */
	private Boolean forceResponse;
	/**
	 * Mapping of locale to charset for response encoding.
	 */
	private Map<Locale, Charset> mapping;
	public Charset getCharset() {
		return this.charset;
	}
	public void setCharset(Charset charset) {
		this.charset = charset;
	}
	public boolean isForce() {
		return Boolean.TRUE.equals(this.force);
	}
	public void setForce(boolean force) {
		this.force = force;
	}
	public boolean isForceRequest() {
		return Boolean.TRUE.equals(this.forceRequest);
	}
	public void setForceRequest(boolean forceRequest) {
		this.forceRequest = forceRequest;
	}
	public boolean isForceResponse() {
		return Boolean.TRUE.equals(this.forceResponse);
	}
	public void setForceResponse(boolean forceResponse) {
		this.forceResponse = forceResponse;
	}
	public Map<Locale, Charset> getMapping() {
		return this.mapping;
	}
	public void setMapping(Map<Locale, Charset> mapping) {
		this.mapping = mapping;
	}
	public boolean shouldForce(Type type) {
		Boolean force = (type != Type.REQUEST) ? this.forceResponse : this.forceRequest;
		if (force == null) {
			force = this.force;
		}
		if (force == null) {
			force = (type == Type.REQUEST);
		}
		return force;
	}
	/**
	 * Type of HTTP message to consider for encoding configuration.
	 */
	public enum Type {
		/**
		 * HTTP request message.
		 */
		REQUEST,
		/**
		 * HTTP response message.
		 */
		RESPONSE
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
public class Session {
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration timeout = Duration.ofMinutes(30);
	private Set<Session.SessionTrackingMode> trackingModes;
	private boolean persistent;
	/**
	 * Directory used to store session data.
	 */
	private File storeDir;
	@NestedConfigurationProperty
	private final Cookie cookie = new Cookie();
	private final SessionStoreDirectory sessionStoreDirectory = new SessionStoreDirectory();
	public Duration getTimeout() {
		return this.timeout;
	}
	public void setTimeout(Duration timeout) {
		this.timeout = timeout;
	}
	/**
	 * Return the {@link SessionTrackingMode session tracking modes}.
	 * @return the session tracking modes
	 */
	public Set<Session.SessionTrackingMode> getTrackingModes() {
		return this.trackingModes;
	}
	public void setTrackingModes(Set<Session.SessionTrackingMode> trackingModes) {
		this.trackingModes = trackingModes;
	}
	/**
	 * Return whether to persist session data between restarts.
	 * @return {@code true} to persist session data between restarts.
	 */
	public boolean isPersistent() {
		return this.persistent;
	}
	public void setPersistent(boolean persistent) {
		this.persistent = persistent;
	}
	/**
	 * Return the directory used to store session data.
	 * @return the session data store directory
	 */
	public File getStoreDir() {
		return this.storeDir;
	}
	public void setStoreDir(File storeDir) {
		this.sessionStoreDirectory.setDirectory(storeDir);
		this.storeDir = storeDir;
	}
	public Cookie getCookie() {
		return this.cookie;
	}
	SessionStoreDirectory getSessionStoreDirectory() {
		return this.sessionStoreDirectory;
	}
	/**
	 * Session cookie properties. This class is provided only for back-compatibility
	 * reasons, consider using {@link org.springframework.boot.web.server.Cookie} whenever
	 * possible.
	 */
	public static class Cookie extends org.springframework.boot.web.server.Cookie {
	}
	/**
	 * Available session tracking modes (mirrors
	 * {@link jakarta.servlet.SessionTrackingMode}).
	 */
	public enum SessionTrackingMode {
		/**
		 * Send a cookie in response to the client"s first request.
		 */
		COOKIE,
		/**
		 * Rewrite the URL to append a session ID.
		 */
		URL,
		/**
		 * Use SSL build-in mechanism to track the session.
		 */
		SSL
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class ServletComponentScanRegistrar implements ImportBeanDefinitionRegistrar {
	private static final String BEAN_NAME = 'servletComponentRegisteringPostProcessor';
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		Set<String> packagesToScan = getPackagesToScan(importingClassMetadata);
		if (registry.containsBeanDefinition(BEAN_NAME)) {
			updatePostProcessor(registry, packagesToScan);
		}
		else {
			addPostProcessor(registry, packagesToScan);
		}
	}
	private void updatePostProcessor(BeanDefinitionRegistry registry, Set<String> packagesToScan) {
		ServletComponentRegisteringPostProcessorBeanDefinition definition = (ServletComponentRegisteringPostProcessorBeanDefinition) registry
			.getBeanDefinition(BEAN_NAME);
		definition.addPackageNames(packagesToScan);
	}
	private void addPostProcessor(BeanDefinitionRegistry registry, Set<String> packagesToScan) {
		ServletComponentRegisteringPostProcessorBeanDefinition definition = new ServletComponentRegisteringPostProcessorBeanDefinition(
				packagesToScan);
		registry.registerBeanDefinition(BEAN_NAME, definition);
	}
	private Set<String> getPackagesToScan(AnnotationMetadata metadata) {
		AnnotationAttributes attributes = AnnotationAttributes
			.fromMap(metadata.getAnnotationAttributes(ServletComponentScan.class.getName()));
		String[] basePackages = attributes.getStringArray('basePackages');
		Class<?>[] basePackageClasses = attributes.getClassArray('basePackageClasses');
		Set<String> packagesToScan = new LinkedHashSet<>(Arrays.asList(basePackages));
		for (Class<?> basePackageClass : basePackageClasses) {
			packagesToScan.add(ClassUtils.getPackageName(basePackageClass));
		}
		if (packagesToScan.isEmpty()) {
			packagesToScan.add(ClassUtils.getPackageName(metadata.getClassName()));
		}
		return packagesToScan;
	}
	static final class ServletComponentRegisteringPostProcessorBeanDefinition extends RootBeanDefinition {
		private final Set<String> packageNames = new LinkedHashSet<>();
		ServletComponentRegisteringPostProcessorBeanDefinition(Collection<String> packageNames) {
			setBeanClass(ServletComponentRegisteringPostProcessor.class);
			setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
			addPackageNames(packageNames);
		}
		@Override
		public Supplier<?> getInstanceSupplier() {
			return () -> new ServletComponentRegisteringPostProcessor(this.packageNames);
		}
		private void addPackageNames(Collection<String> additionalPackageNames) {
			this.packageNames.addAll(additionalPackageNames);
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
public abstract class DynamicRegistrationBean<D extends Registration.Dynamic> extends RegistrationBean
		implements BeanNameAware {
	private static final Log logger = LogFactory.getLog(RegistrationBean.class);
	private String name;
	private boolean asyncSupported = true;
	private Map<String, String> initParameters = new LinkedHashMap<>();
	private String beanName;
	private boolean ignoreRegistrationFailure;
	/**
	 * Set the name of this registration. If not specified the bean name will be used.
	 * @param name the name of the registration
	 */
	public void setName(String name) {
		Assert.hasLength(name, 'Name must not be empty');
		this.name = name;
	}
	/**
	 * Sets if asynchronous operations are supported for this registration. If not
	 * specified defaults to {@code true}.
	 * @param asyncSupported if async is supported
	 */
	public void setAsyncSupported(boolean asyncSupported) {
		this.asyncSupported = asyncSupported;
	}
	/**
	 * Returns if asynchronous operations are supported for this registration.
	 * @return if async is supported
	 */
	public boolean isAsyncSupported() {
		return this.asyncSupported;
	}
	/**
	 * Set init-parameters for this registration. Calling this method will replace any
	 * existing init-parameters.
	 * @param initParameters the init parameters
	 * @see #getInitParameters
	 * @see #addInitParameter
	 */
	public void setInitParameters(Map<String, String> initParameters) {
		Assert.notNull(initParameters, 'InitParameters must not be null');
		this.initParameters = new LinkedHashMap<>(initParameters);
	}
	/**
	 * Returns a mutable Map of the registration init-parameters.
	 * @return the init parameters
	 */
	public Map<String, String> getInitParameters() {
		return this.initParameters;
	}
	/**
	 * Add a single init-parameter, replacing any existing parameter with the same name.
	 * @param name the init-parameter name
	 * @param value the init-parameter value
	 */
	public void addInitParameter(String name, String value) {
		Assert.notNull(name, 'Name must not be null');
		this.initParameters.put(name, value);
	}
	@Override
	protected final void register(String description, ServletContext servletContext) {
		D registration = addRegistration(description, servletContext);
		if (registration == null) {
			if (this.ignoreRegistrationFailure) {
				logger.info(StringUtils.capitalize(description) + ' was not registered (possibly already registered?)');
				return;
			}
			throw new IllegalStateException(
					'Failed to register "%s" on the servlet context. Possibly already registered?'
						.formatted(description));
		}
		configure(registration);
	}
	/**
	 * Sets whether registration failures should be ignored. If set to true, a failure
	 * will be logged. If set to false, an {@link IllegalStateException} will be thrown.
	 * @param ignoreRegistrationFailure whether to ignore registration failures
	 * @since 3.1.0
	 */
	public void setIgnoreRegistrationFailure(boolean ignoreRegistrationFailure) {
		this.ignoreRegistrationFailure = ignoreRegistrationFailure;
	}
	@Override
	public void setBeanName(String name) {
		this.beanName = name;
	}
	protected abstract D addRegistration(String description, ServletContext servletContext);
	protected void configure(D registration) {
		registration.setAsyncSupported(this.asyncSupported);
		if (!this.initParameters.isEmpty()) {
			registration.setInitParameters(this.initParameters);
		}
	}
	/**
	 * Deduces the name for this registration. Will return user specified name or fallback
	 * to the bean name. If the bean name is not available, convention based naming is
	 * used.
	 * @param value the object used for convention based names
	 * @return the deduced name
	 */
	protected final String getOrDeduceName(Object value) {
		if (this.name != null) {
			return this.name;
		}
		if (this.beanName != null) {
			return this.beanName;
		}
		return Conventions.getVariableName(value);
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class ServletComponentRegisteringPostProcessor
		implements BeanFactoryPostProcessor, ApplicationContextAware, BeanFactoryInitializationAotProcessor {
	private static final boolean MOCK_SERVLET_CONTEXT_AVAILABLE = ClassUtils
		.isPresent('org.springframework.mock.web.MockServletContext', null);
	private static final List<ServletComponentHandler> HANDLERS;
	static {
		List<ServletComponentHandler> servletComponentHandlers = new ArrayList<>();
		servletComponentHandlers.add(new WebServletHandler());
		servletComponentHandlers.add(new WebFilterHandler());
		servletComponentHandlers.add(new WebListenerHandler());
		HANDLERS = Collections.unmodifiableList(servletComponentHandlers);
	}
	private final Set<String> packagesToScan;
	private ApplicationContext applicationContext;
	ServletComponentRegisteringPostProcessor(Set<String> packagesToScan) {
		this.packagesToScan = packagesToScan;
	}
	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		if (eligibleForServletComponentScanning()) {
			ClassPathScanningCandidateComponentProvider componentProvider = createComponentProvider();
			for (String packageToScan : this.packagesToScan) {
				scanPackage(componentProvider, packageToScan);
			}
		}
	}
	private void scanPackage(ClassPathScanningCandidateComponentProvider componentProvider, String packageToScan) {
		for (BeanDefinition candidate : componentProvider.findCandidateComponents(packageToScan)) {
			if (candidate instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {
				for (ServletComponentHandler handler : HANDLERS) {
					handler.handle(annotatedBeanDefinition, (BeanDefinitionRegistry) this.applicationContext);
				}
			}
		}
	}
	private boolean eligibleForServletComponentScanning() {
		return this.applicationContext instanceof WebApplicationContext webApplicationContext
				&& (webApplicationContext.getServletContext() == null || (MOCK_SERVLET_CONTEXT_AVAILABLE
						&& webApplicationContext.getServletContext() instanceof MockServletContext));
	}
	private ClassPathScanningCandidateComponentProvider createComponentProvider() {
		ClassPathScanningCandidateComponentProvider componentProvider = new ClassPathScanningCandidateComponentProvider(
				false);
		componentProvider.setEnvironment(this.applicationContext.getEnvironment());
		componentProvider.setResourceLoader(this.applicationContext);
		for (ServletComponentHandler handler : HANDLERS) {
			componentProvider.addIncludeFilter(handler.getTypeFilter());
		}
		return componentProvider;
	}
	Set<String> getPackagesToScan() {
		return Collections.unmodifiableSet(this.packagesToScan);
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}
	@Override
	public BeanFactoryInitializationAotContribution processAheadOfTime(ConfigurableListableBeanFactory beanFactory) {
		return (generationContext, beanFactoryInitializationCode) -> {
			for (String beanName : beanFactory.getBeanDefinitionNames()) {
				BeanDefinition definition = beanFactory.getBeanDefinition(beanName);
				if (Objects.equals(definition.getBeanClassName(),
						WebListenerHandler.ServletComponentWebListenerRegistrar.class.getName())) {
					String listenerClassName = (String) definition.getConstructorArgumentValues()
						.getArgumentValue(0, String.class)
						.getValue();
					generationContext.getRuntimeHints()
						.reflection()
						.registerType(TypeReference.of(listenerClassName), MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
				}
			}
		};
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class WebListenerHandler extends ServletComponentHandler {
	WebListenerHandler() {
		super(WebListener.class);
	}
	@Override
	protected void doHandle(Map<String, Object> attributes, AnnotatedBeanDefinition beanDefinition,
			BeanDefinitionRegistry registry) {
		BeanDefinitionBuilder builder = BeanDefinitionBuilder
			.rootBeanDefinition(ServletComponentWebListenerRegistrar.class);
		builder.addConstructorArgValue(beanDefinition.getBeanClassName());
		registry.registerBeanDefinition(beanDefinition.getBeanClassName() + 'Registrar', builder.getBeanDefinition());
	}
	static class ServletComponentWebListenerRegistrar implements WebListenerRegistrar {
		private final String listenerClassName;
		ServletComponentWebListenerRegistrar(String listenerClassName) {
			this.listenerClassName = listenerClassName;
		}
		@Override
		public void register(WebListenerRegistry registry) {
			registry.addWebListeners(this.listenerClassName);
		}
	}
}
/*
package org.springframework.boot.web.servlet.error;
/**
@Order(Ordered.HIGHEST_PRECEDENCE)
public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered {
	private static final String ERROR_INTERNAL_ATTRIBUTE = DefaultErrorAttributes.class.getName() + '.ERROR';
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE;
	}
	@Override
	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception ex) {
		storeErrorAttributes(request, ex);
		return null;
	}
	private void storeErrorAttributes(HttpServletRequest request, Exception ex) {
		request.setAttribute(ERROR_INTERNAL_ATTRIBUTE, ex);
	}
	@Override
	public Map<String, Object> getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
		Map<String, Object> errorAttributes = getErrorAttributes(webRequest, options.isIncluded(Include.STACK_TRACE));
		options.retainIncluded(errorAttributes);
		return errorAttributes;
	}
	private Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {
		Map<String, Object> errorAttributes = new LinkedHashMap<>();
		errorAttributes.put('timestamp', new Date());
		addStatus(errorAttributes, webRequest);
		addErrorDetails(errorAttributes, webRequest, includeStackTrace);
		addPath(errorAttributes, webRequest);
		return errorAttributes;
	}
	private void addStatus(Map<String, Object> errorAttributes, RequestAttributes requestAttributes) {
		Integer status = getAttribute(requestAttributes, RequestDispatcher.ERROR_STATUS_CODE);
		if (status == null) {
			errorAttributes.put('status', 999);
			errorAttributes.put('error', 'None');
			return;
		}
		errorAttributes.put('status', status);
		try {
			errorAttributes.put('error', HttpStatus.valueOf(status).getReasonPhrase());
		}
		catch (Exception ex) {
			// Unable to obtain a reason
			errorAttributes.put('error', 'Http Status ' + status);
		}
	}
	private void addErrorDetails(Map<String, Object> errorAttributes, WebRequest webRequest,
			boolean includeStackTrace) {
		Throwable error = getError(webRequest);
		if (error != null) {
			while (error instanceof ServletException && error.getCause() != null) {
				error = error.getCause();
			}
			errorAttributes.put('exception', error.getClass().getName());
			if (includeStackTrace) {
				addStackTrace(errorAttributes, error);
			}
		}
		addErrorMessage(errorAttributes, webRequest, error);
	}
	private void addErrorMessage(Map<String, Object> errorAttributes, WebRequest webRequest, Throwable error) {
		BindingResult bindingResult = extractBindingResult(error);
		if (bindingResult != null) {
			addMessageAndErrorsFromBindingResult(errorAttributes, bindingResult);
		}
		else {
			MethodValidationResult methodValidationResult = extractMethodValidationResult(error);
			if (methodValidationResult != null) {
				addMessageAndErrorsFromMethodValidationResult(errorAttributes, methodValidationResult);
			}
			else {
				addExceptionErrorMessage(errorAttributes, webRequest, error);
			}
		}
	}
	private void addExceptionErrorMessage(Map<String, Object> errorAttributes, WebRequest webRequest, Throwable error) {
		errorAttributes.put('message', getMessage(webRequest, error));
	}
	/**
	 * Returns the message to be included as the value of the {@code message} error
	 * attribute. By default the returned message is the first of the following that is
	 * not empty:
	 * <ol>
	 * <li>Value of the {@link RequestDispatcher#ERROR_MESSAGE} request attribute.
	 * <li>Message of the given {@code error}.
	 * <li>{@code No message available}.
	 * </ol>
	 * @param webRequest current request
	 * @param error current error, if any
	 * @return message to include in the error attributes
	 * @since 2.4.0
	 */
	protected String getMessage(WebRequest webRequest, Throwable error) {
		Object message = getAttribute(webRequest, RequestDispatcher.ERROR_MESSAGE);
		if (!ObjectUtils.isEmpty(message)) {
			return message.toString();
		}
		if (error != null && StringUtils.hasLength(error.getMessage())) {
			return error.getMessage();
		}
		return 'No message available';
	}
	private void addMessageAndErrorsFromBindingResult(Map<String, Object> errorAttributes, BindingResult result) {
		addMessageAndErrorsForValidationFailure(errorAttributes, 'object="' + result.getObjectName() + '"',
				result.getAllErrors());
	}
	private void addMessageAndErrorsFromMethodValidationResult(Map<String, Object> errorAttributes,
			MethodValidationResult result) {
		List<ObjectError> errors = result.getAllErrors()
			.stream()
			.filter(ObjectError.class::isInstance)
			.map(ObjectError.class::cast)
			.toList();
		addMessageAndErrorsForValidationFailure(errorAttributes, 'method="' + result.getMethod() + '"', errors);
	}
	private void addMessageAndErrorsForValidationFailure(Map<String, Object> errorAttributes, String validated,
			List<ObjectError> errors) {
		errorAttributes.put('message', 'Validation failed for ' + validated + '. Error count: ' + errors.size());
		errorAttributes.put('errors', errors);
	}
	private BindingResult extractBindingResult(Throwable error) {
		if (error instanceof BindingResult bindingResult) {
			return bindingResult;
		}
		return null;
	}
	private MethodValidationResult extractMethodValidationResult(Throwable error) {
		if (error instanceof MethodValidationResult methodValidationResult) {
			return methodValidationResult;
		}
		return null;
	}
	private void addStackTrace(Map<String, Object> errorAttributes, Throwable error) {
		StringWriter stackTrace = new StringWriter();
		error.printStackTrace(new PrintWriter(stackTrace));
		stackTrace.flush();
		errorAttributes.put('trace', stackTrace.toString());
	}
	private void addPath(Map<String, Object> errorAttributes, RequestAttributes requestAttributes) {
		String path = getAttribute(requestAttributes, RequestDispatcher.ERROR_REQUEST_URI);
		if (path != null) {
			errorAttributes.put('path', path);
		}
	}
	@Override
	public Throwable getError(WebRequest webRequest) {
		Throwable exception = getAttribute(webRequest, ERROR_INTERNAL_ATTRIBUTE);
		if (exception == null) {
			exception = getAttribute(webRequest, RequestDispatcher.ERROR_EXCEPTION);
		}
		return exception;
	}
	@SuppressWarnings('unchecked')
	private <T> T getAttribute(RequestAttributes requestAttributes, String name) {
		return (T) requestAttributes.getAttribute(name, RequestAttributes.SCOPE_REQUEST);
	}
}
/*
package org.springframework.boot.web.servlet.error;
/**
public interface ErrorAttributes {
	/**
	 * Returns a {@link Map} of the error attributes. The map can be used as the model of
	 * an error page {@link ModelAndView}, or returned as a
	 * {@link ResponseBody @ResponseBody}.
	 * @param webRequest the source request
	 * @param options options for error attribute contents
	 * @return a map of error attributes
	 * @since 2.3.0
	 */
	default Map<String, Object> getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
		return Collections.emptyMap();
	}
	/**
	 * Return the underlying cause of the error or {@code null} if the error cannot be
	 * extracted.
	 * @param webRequest the source request
	 * @return the {@link Exception} that caused the error or {@code null}
	 */
	Throwable getError(WebRequest webRequest);
}
/*
package org.springframework.boot.web.servlet.error;
/**
public interface ErrorController {
}
/*
/**
package org.springframework.boot.web.servlet.error;
/*
package org.springframework.boot.web.servlet;
/**
public interface WebListenerRegistry {
	/**
	 * Adds web listeners that will be registered with the servlet container.
	 * @param webListenerClassNames the class names of the web listeners
	 */
	void addWebListeners(String... webListenerClassNames);
}
/*
package org.springframework.boot.web.servlet.view;
/**
public class MustacheViewResolver extends AbstractTemplateViewResolver {
	private final Mustache.Compiler compiler;
	private String charset;
	/**
	 * Create a {@code MustacheViewResolver} backed by a default instance of a
	 * {@link Compiler}.
	 */
	public MustacheViewResolver() {
		this.compiler = Mustache.compiler();
		setViewClass(requiredViewClass());
	}
	/**
	 * Create a {@code MustacheViewResolver} backed by a custom instance of a
	 * {@link Compiler}.
	 * @param compiler the Mustache compiler used to compile templates
	 */
	public MustacheViewResolver(Compiler compiler) {
		this.compiler = compiler;
		setViewClass(requiredViewClass());
	}
	@Override
	protected Class<?> requiredViewClass() {
		return MustacheView.class;
	}
	/**
	 * Set the charset.
	 * @param charset the charset
	 */
	public void setCharset(String charset) {
		this.charset = charset;
	}
	@Override
	protected AbstractUrlBasedView buildView(String viewName) throws Exception {
		MustacheView view = (MustacheView) super.buildView(viewName);
		view.setCompiler(this.compiler);
		view.setCharset(this.charset);
		return view;
	}
	@Override
	protected AbstractUrlBasedView instantiateView() {
		return (getViewClass() == MustacheView.class) ? new MustacheView() : super.instantiateView();
	}
}
/*
package org.springframework.boot.web.servlet.view;
/**
public class MustacheView extends AbstractTemplateView {
	private Compiler compiler;
	private String charset;
	/**
	 * Set the Mustache compiler to be used by this view.
	 * <p>
	 * Typically this property is not set directly. Instead a single {@link Compiler} is
	 * expected in the Spring application context which is used to compile Mustache
	 * templates.
	 * @param compiler the Mustache compiler
	 */
	public void setCompiler(Compiler compiler) {
		this.compiler = compiler;
	}
	/**
	 * Set the charset used for reading Mustache template files.
	 * @param charset the charset to use for reading template files
	 */
	public void setCharset(String charset) {
		this.charset = charset;
	}
	@Override
	public boolean checkResource(Locale locale) throws Exception {
		Resource resource = getApplicationContext().getResource(getUrl());
		return (resource != null && resource.exists());
	}
	@Override
	protected void renderMergedTemplateModel(Map<String, Object> model, HttpServletRequest request,
			HttpServletResponse response) throws Exception {
		Template template = createTemplate(getApplicationContext().getResource(getUrl()));
		if (template != null) {
			template.execute(model, response.getWriter());
		}
	}
	private Template createTemplate(Resource resource) throws IOException {
		try (Reader reader = getReader(resource)) {
			return this.compiler.compile(reader);
		}
	}
	private Reader getReader(Resource resource) throws IOException {
		if (this.charset != null) {
			return new InputStreamReader(resource.getInputStream(), this.charset);
		}
		return new InputStreamReader(resource.getInputStream());
	}
}
/*
/**
package org.springframework.boot.web.servlet.view;
/*
package org.springframework.boot.web.servlet;
/**
public class FilterRegistrationBean<T extends Filter> extends AbstractFilterRegistrationBean<T> {
	private T filter;
	/**
	 * Create a new {@link FilterRegistrationBean} instance.
	 */
	public FilterRegistrationBean() {
	}
	/**
	 * Create a new {@link FilterRegistrationBean} instance to be registered with the
	 * specified {@link ServletRegistrationBean}s.
	 * @param filter the filter to register
	 * @param servletRegistrationBeans associate {@link ServletRegistrationBean}s
	 */
	public FilterRegistrationBean(T filter, ServletRegistrationBean<?>... servletRegistrationBeans) {
		super(servletRegistrationBeans);
		Assert.notNull(filter, 'Filter must not be null');
		this.filter = filter;
	}
	@Override
	public T getFilter() {
		return this.filter;
	}
	/**
	 * Set the filter to be registered.
	 * @param filter the filter
	 */
	public void setFilter(T filter) {
		Assert.notNull(filter, 'Filter must not be null');
		this.filter = filter;
	}
}
/*
package org.springframework.boot.web.servlet;
/**
@FunctionalInterface
public interface ServletContextInitializer {
	/**
	 * Configure the given {@link ServletContext} with any servlets, filters, listeners
	 * context-params and attributes necessary for initialization.
	 * @param servletContext the {@code ServletContext} to initialize
	 * @throws ServletException if any call against the given {@code ServletContext}
	 * throws a {@code ServletException}
	 */
	void onStartup(ServletContext servletContext) throws ServletException;
}
/*
package org.springframework.boot.web.servlet;
/**
public class DelegatingFilterProxyRegistrationBean extends AbstractFilterRegistrationBean<DelegatingFilterProxy>
		implements ApplicationContextAware {
	private ApplicationContext applicationContext;
	private final String targetBeanName;
	/**
	 * Create a new {@link DelegatingFilterProxyRegistrationBean} instance to be
	 * registered with the specified {@link ServletRegistrationBean}s.
	 * @param targetBeanName name of the target filter bean to look up in the Spring
	 * application context (must not be {@code null}).
	 * @param servletRegistrationBeans associate {@link ServletRegistrationBean}s
	 */
	public DelegatingFilterProxyRegistrationBean(String targetBeanName,
			ServletRegistrationBean<?>... servletRegistrationBeans) {
		super(servletRegistrationBeans);
		Assert.hasLength(targetBeanName, 'TargetBeanName must not be null or empty');
		this.targetBeanName = targetBeanName;
		setName(targetBeanName);
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}
	protected String getTargetBeanName() {
		return this.targetBeanName;
	}
	@Override
	public DelegatingFilterProxy getFilter() {
		return new DelegatingFilterProxy(this.targetBeanName, getWebApplicationContext()) {
			@Override
			protected void initFilterBean() throws ServletException {
				// Don"t initialize filter bean on init()
			}
		};
	}
	private WebApplicationContext getWebApplicationContext() {
		Assert.notNull(this.applicationContext, 'ApplicationContext be injected');
		Assert.isInstanceOf(WebApplicationContext.class, this.applicationContext);
		return (WebApplicationContext) this.applicationContext;
	}
}
/*
package org.springframework.boot.web.servlet;
/**
public class ServletRegistrationBean<T extends Servlet> extends DynamicRegistrationBean<ServletRegistration.Dynamic> {
	private static final String[] DEFAULT_MAPPINGS = { '/*' };
	private T servlet;
	private Set<String> urlMappings = new LinkedHashSet<>();
	private boolean alwaysMapUrl = true;
	private int loadOnStartup = -1;
	private MultipartConfigElement multipartConfig;
	/**
	 * Create a new {@link ServletRegistrationBean} instance.
	 */
	public ServletRegistrationBean() {
	}
	/**
	 * Create a new {@link ServletRegistrationBean} instance with the specified
	 * {@link Servlet} and URL mappings.
	 * @param servlet the servlet being mapped
	 * @param urlMappings the URLs being mapped
	 */
	public ServletRegistrationBean(T servlet, String... urlMappings) {
		this(servlet, true, urlMappings);
	}
	/**
	 * Create a new {@link ServletRegistrationBean} instance with the specified
	 * {@link Servlet} and URL mappings.
	 * @param servlet the servlet being mapped
	 * @param alwaysMapUrl if omitted URL mappings should be replaced with "/*"
	 * @param urlMappings the URLs being mapped
	 */
	public ServletRegistrationBean(T servlet, boolean alwaysMapUrl, String... urlMappings) {
		Assert.notNull(servlet, 'Servlet must not be null');
		Assert.notNull(urlMappings, 'UrlMappings must not be null');
		this.servlet = servlet;
		this.alwaysMapUrl = alwaysMapUrl;
		this.urlMappings.addAll(Arrays.asList(urlMappings));
	}
	/**
	 * Sets the servlet to be registered.
	 * @param servlet the servlet
	 */
	public void setServlet(T servlet) {
		Assert.notNull(servlet, 'Servlet must not be null');
		this.servlet = servlet;
	}
	/**
	 * Return the servlet being registered.
	 * @return the servlet
	 */
	public T getServlet() {
		return this.servlet;
	}
	/**
	 * Set the URL mappings for the servlet. If not specified the mapping will default to
	 * "/". This will replace any previously specified mappings.
	 * @param urlMappings the mappings to set
	 * @see #addUrlMappings(String...)
	 */
	public void setUrlMappings(Collection<String> urlMappings) {
		Assert.notNull(urlMappings, 'UrlMappings must not be null');
		this.urlMappings = new LinkedHashSet<>(urlMappings);
	}
	/**
	 * Return a mutable collection of the URL mappings, as defined in the Servlet
	 * specification, for the servlet.
	 * @return the urlMappings
	 */
	public Collection<String> getUrlMappings() {
		return this.urlMappings;
	}
	/**
	 * Add URL mappings, as defined in the Servlet specification, for the servlet.
	 * @param urlMappings the mappings to add
	 * @see #setUrlMappings(Collection)
	 */
	public void addUrlMappings(String... urlMappings) {
		Assert.notNull(urlMappings, 'UrlMappings must not be null');
		this.urlMappings.addAll(Arrays.asList(urlMappings));
	}
	/**
	 * Sets the {@code loadOnStartup} priority. See
	 * {@link ServletRegistration.Dynamic#setLoadOnStartup} for details.
	 * @param loadOnStartup if load on startup is enabled
	 */
	public void setLoadOnStartup(int loadOnStartup) {
		this.loadOnStartup = loadOnStartup;
	}
	/**
	 * Set the {@link MultipartConfigElement multi-part configuration}.
	 * @param multipartConfig the multipart configuration to set or {@code null}
	 */
	public void setMultipartConfig(MultipartConfigElement multipartConfig) {
		this.multipartConfig = multipartConfig;
	}
	/**
	 * Returns the {@link MultipartConfigElement multi-part configuration} to be applied
	 * or {@code null}.
	 * @return the multipart config
	 */
	public MultipartConfigElement getMultipartConfig() {
		return this.multipartConfig;
	}
	@Override
	protected String getDescription() {
		Assert.notNull(this.servlet, 'Servlet must not be null');
		return 'servlet ' + getServletName();
	}
	@Override
	protected ServletRegistration.Dynamic addRegistration(String description, ServletContext servletContext) {
		String name = getServletName();
		return servletContext.addServlet(name, this.servlet);
	}
	/**
	 * Configure registration settings. Subclasses can override this method to perform
	 * additional configuration if required.
	 * @param registration the registration
	 */
	@Override
	protected void configure(ServletRegistration.Dynamic registration) {
		super.configure(registration);
		String[] urlMapping = StringUtils.toStringArray(this.urlMappings);
		if (urlMapping.length == 0 && this.alwaysMapUrl) {
			urlMapping = DEFAULT_MAPPINGS;
		}
		if (!ObjectUtils.isEmpty(urlMapping)) {
			registration.addMapping(urlMapping);
		}
		registration.setLoadOnStartup(this.loadOnStartup);
		if (this.multipartConfig != null) {
			registration.setMultipartConfig(this.multipartConfig);
		}
	}
	/**
	 * Returns the servlet name that will be registered.
	 * @return the servlet name
	 */
	public String getServletName() {
		return getOrDeduceName(this.servlet);
	}
	@Override
	public String toString() {
		return getServletName() + ' urls=' + getUrlMappings();
	}
}
/*
package org.springframework.boot.web.servlet.support;
/**
public class ErrorPageFilter implements Filter, ErrorPageRegistry, Ordered {
	private static final Log logger = LogFactory.getLog(ErrorPageFilter.class);
	// From RequestDispatcher but not referenced to remain compatible with Servlet 2.5
	private static final String ERROR_EXCEPTION = 'jakarta.servlet.error.exception';
	private static final String ERROR_EXCEPTION_TYPE = 'jakarta.servlet.error.exception_type';
	private static final String ERROR_MESSAGE = 'jakarta.servlet.error.message';
	/**
	 * The name of the servlet attribute containing request URI.
	 */
	public static final String ERROR_REQUEST_URI = 'jakarta.servlet.error.request_uri';
	private static final String ERROR_STATUS_CODE = 'jakarta.servlet.error.status_code';
	private static final Set<Class<?>> CLIENT_ABORT_EXCEPTIONS;
	static {
		Set<Class<?>> clientAbortExceptions = new HashSet<>();
		addClassIfPresent(clientAbortExceptions, 'org.apache.catalina.connector.ClientAbortException');
		CLIENT_ABORT_EXCEPTIONS = Collections.unmodifiableSet(clientAbortExceptions);
	}
	private String global;
	private final Map<Integer, String> statuses = new HashMap<>();
	private final Map<Class<?>, String> exceptions = new HashMap<>();
	private final OncePerRequestFilter delegate = new OncePerRequestFilter() {
		@Override
		protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
				throws ServletException, IOException {
			ErrorPageFilter.this.doFilter(request, response, chain);
		}
		@Override
		protected boolean shouldNotFilterAsyncDispatch() {
			return false;
		}
	};
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		this.delegate.init(filterConfig);
	}
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		this.delegate.doFilter(request, response, chain);
	}
	private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		ErrorWrapperResponse wrapped = new ErrorWrapperResponse(response);
		try {
			chain.doFilter(request, wrapped);
			if (wrapped.hasErrorToSend()) {
				handleErrorStatus(request, response, wrapped.getStatus(), wrapped.getMessage());
				response.flushBuffer();
			}
			else if (!request.isAsyncStarted() && !response.isCommitted()) {
				response.flushBuffer();
			}
		}
		catch (Throwable ex) {
			Throwable exceptionToHandle = ex;
			if (ex instanceof ServletException servletException) {
				Throwable rootCause = servletException.getRootCause();
				if (rootCause != null) {
					exceptionToHandle = rootCause;
				}
			}
			handleException(request, response, wrapped, exceptionToHandle);
			response.flushBuffer();
		}
	}
	private void handleErrorStatus(HttpServletRequest request, HttpServletResponse response, int status, String message)
			throws ServletException, IOException {
		if (response.isCommitted()) {
			handleCommittedResponse(request, null);
			return;
		}
		String errorPath = getErrorPath(this.statuses, status);
		if (errorPath == null) {
			response.sendError(status, message);
			return;
		}
		response.setStatus(status);
		setErrorAttributes(request, status, message);
		request.getRequestDispatcher(errorPath).forward(request, response);
	}
	private void handleException(HttpServletRequest request, HttpServletResponse response, ErrorWrapperResponse wrapped,
			Throwable ex) throws IOException, ServletException {
		Class<?> type = ex.getClass();
		String errorPath = getErrorPath(type);
		if (errorPath == null) {
			rethrow(ex);
			return;
		}
		if (response.isCommitted()) {
			handleCommittedResponse(request, ex);
			return;
		}
		forwardToErrorPage(errorPath, request, wrapped, ex);
	}
	private void forwardToErrorPage(String path, HttpServletRequest request, HttpServletResponse response, Throwable ex)
			throws ServletException, IOException {
		if (logger.isErrorEnabled()) {
			String message = 'Forwarding to error page from request ' + getDescription(request) + ' due to exception ['
					+ ex.getMessage() + ']';
			logger.error(message, ex);
		}
		setErrorAttributes(request, 500, ex.getMessage());
		request.setAttribute(ERROR_EXCEPTION, ex);
		request.setAttribute(ERROR_EXCEPTION_TYPE, ex.getClass());
		response.reset();
		response.setStatus(500);
		request.getRequestDispatcher(path).forward(request, response);
		request.removeAttribute(ERROR_EXCEPTION);
		request.removeAttribute(ERROR_EXCEPTION_TYPE);
	}
	/**
	 * Return the description for the given request. By default this method will return a
	 * description based on the request {@code servletPath} and {@code pathInfo}.
	 * @param request the source request
	 * @return the description
	 * @since 1.5.0
	 */
	protected String getDescription(HttpServletRequest request) {
		String pathInfo = (request.getPathInfo() != null) ? request.getPathInfo() : '';
		return '[' + request.getServletPath() + pathInfo + ']';
	}
	private void handleCommittedResponse(HttpServletRequest request, Throwable ex) {
		if (isClientAbortException(ex)) {
			return;
		}
		String message = 'Cannot forward to error page for request ' + getDescription(request)
				+ ' as the response has already been'
				+ ' committed. As a result, the response may have the wrong status'
				+ ' code. If your application is running on WebSphere Application'
				+ ' Server you may be able to resolve this problem by setting'
				+ ' com.ibm.ws.webcontainer.invokeFlushAfterService to false';
		if (ex == null) {
			logger.error(message);
		}
		else {
			// User might see the error page without all the data here but throwing the
			// exception isn"t going to help anyone (we"ll log it to be on the safe side)
			logger.error(message, ex);
		}
	}
	private boolean isClientAbortException(Throwable ex) {
		if (ex == null) {
			return false;
		}
		for (Class<?> candidate : CLIENT_ABORT_EXCEPTIONS) {
			if (candidate.isInstance(ex)) {
				return true;
			}
		}
		return isClientAbortException(ex.getCause());
	}
	private String getErrorPath(Map<Integer, String> map, Integer status) {
		if (map.containsKey(status)) {
			return map.get(status);
		}
		return this.global;
	}
	private String getErrorPath(Class<?> type) {
		while (type != Object.class) {
			String path = this.exceptions.get(type);
			if (path != null) {
				return path;
			}
			type = type.getSuperclass();
		}
		return this.global;
	}
	private void setErrorAttributes(HttpServletRequest request, int status, String message) {
		request.setAttribute(ERROR_STATUS_CODE, status);
		request.setAttribute(ERROR_MESSAGE, message);
		request.setAttribute(ERROR_REQUEST_URI, request.getRequestURI());
	}
	private void rethrow(Throwable ex) throws IOException, ServletException {
		if (ex instanceof RuntimeException runtimeException) {
			throw runtimeException;
		}
		if (ex instanceof Error error) {
			throw error;
		}
		if (ex instanceof IOException ioException) {
			throw ioException;
		}
		if (ex instanceof ServletException servletException) {
			throw servletException;
		}
		throw new IllegalStateException(ex);
	}
	@Override
	public void addErrorPages(ErrorPage... errorPages) {
		for (ErrorPage errorPage : errorPages) {
			if (errorPage.isGlobal()) {
				this.global = errorPage.getPath();
			}
			else if (errorPage.getStatus() != null) {
				this.statuses.put(errorPage.getStatus().value(), errorPage.getPath());
			}
			else {
				this.exceptions.put(errorPage.getException(), errorPage.getPath());
			}
		}
	}
	@Override
	public void destroy() {
	}
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE + 1;
	}
	private static void addClassIfPresent(Collection<Class<?>> collection, String className) {
		try {
			collection.add(ClassUtils.forName(className, null));
		}
		catch (Throwable ex) {
			// Ignore
		}
	}
	private static class ErrorWrapperResponse extends HttpServletResponseWrapper {
		private int status;
		private String message;
		private boolean hasErrorToSend = false;
		ErrorWrapperResponse(HttpServletResponse response) {
			super(response);
		}
		@Override
		public void sendError(int status) {
			sendError(status, null);
		}
		@Override
		public void sendError(int status, String message) {
			this.status = status;
			this.message = message;
			this.hasErrorToSend = true;
			// Do not call super because the container may prevent us from handling the
			// error ourselves
		}
		@Override
		public int getStatus() {
			if (this.hasErrorToSend) {
				return this.status;
			}
			// If there was no error we need to trust the wrapped response
			return super.getStatus();
		}
		@Override
		public void flushBuffer() throws IOException {
			sendErrorIfNecessary();
			super.flushBuffer();
		}
		private void sendErrorIfNecessary() throws IOException {
			if (this.hasErrorToSend && !isCommitted()) {
				((HttpServletResponse) getResponse()).sendError(this.status, this.message);
			}
		}
		String getMessage() {
			return this.message;
		}
		boolean hasErrorToSend() {
			return this.hasErrorToSend;
		}
		@Override
		public PrintWriter getWriter() throws IOException {
			sendErrorIfNecessary();
			return super.getWriter();
		}
		@Override
		public ServletOutputStream getOutputStream() throws IOException {
			sendErrorIfNecessary();
			return super.getOutputStream();
		}
	}
}
/*
package org.springframework.boot.web.servlet.support;
/**
@Configuration(proxyBeanMethods = false)
class ErrorPageFilterConfiguration {
	@Bean
	ErrorPageFilter errorPageFilter() {
		return new ErrorPageFilter();
	}
	@Bean
	FilterRegistrationBean<ErrorPageFilter> errorPageFilterRegistration(ErrorPageFilter filter) {
		FilterRegistrationBean<ErrorPageFilter> registration = new FilterRegistrationBean<>(filter);
		registration.setOrder(filter.getOrder());
		registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC);
		return registration;
	}
}
/*
package org.springframework.boot.web.servlet.support;
/**
public class ServletContextApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableWebApplicationContext>, Ordered {
	private int order = Ordered.HIGHEST_PRECEDENCE;
	private final ServletContext servletContext;
	private final boolean addApplicationContextAttribute;
	/**
	 * Create a new {@link ServletContextApplicationContextInitializer} instance.
	 * @param servletContext the servlet that should be ultimately set.
	 */
	public ServletContextApplicationContextInitializer(ServletContext servletContext) {
		this(servletContext, false);
	}
	/**
	 * Create a new {@link ServletContextApplicationContextInitializer} instance.
	 * @param servletContext the servlet that should be ultimately set.
	 * @param addApplicationContextAttribute if the {@link ApplicationContext} should be
	 * stored as an attribute in the {@link ServletContext}
	 * @since 1.3.4
	 */
	public ServletContextApplicationContextInitializer(ServletContext servletContext,
			boolean addApplicationContextAttribute) {
		this.servletContext = servletContext;
		this.addApplicationContextAttribute = addApplicationContextAttribute;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	@Override
	public void initialize(ConfigurableWebApplicationContext applicationContext) {
		applicationContext.setServletContext(this.servletContext);
		if (this.addApplicationContextAttribute) {
			this.servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,
					applicationContext);
		}
	}
}
/*
/**
package org.springframework.boot.web.servlet.support;
/*
package org.springframework.boot.web.servlet.support;
/**
public abstract class SpringBootServletInitializer implements WebApplicationInitializer {
	private static final boolean REACTOR_PRESENT = ClassUtils.isPresent('reactor.core.scheduler.Schedulers',
			SpringBootServletInitializer.class.getClassLoader());
	protected Log logger; // Don"t initialize early
	private boolean registerErrorPageFilter = true;
	/**
	 * Set if the {@link ErrorPageFilter} should be registered. Set to {@code false} if
	 * error page mappings should be handled through the server and not Spring Boot.
	 * @param registerErrorPageFilter if the {@link ErrorPageFilter} should be registered.
	 */
	protected final void setRegisterErrorPageFilter(boolean registerErrorPageFilter) {
		this.registerErrorPageFilter = registerErrorPageFilter;
	}
	@Override
	public void onStartup(ServletContext servletContext) throws ServletException {
		servletContext.setAttribute(LoggingApplicationListener.REGISTER_SHUTDOWN_HOOK_PROPERTY, false);
		// Logger initialization is deferred in case an ordered
		// LogServletContextInitializer is being used
		this.logger = LogFactory.getLog(getClass());
		WebApplicationContext rootApplicationContext = createRootApplicationContext(servletContext);
		if (rootApplicationContext != null) {
			servletContext.addListener(new SpringBootContextLoaderListener(rootApplicationContext, servletContext));
		}
		else {
			this.logger.debug('No ContextLoaderListener registered, as createRootApplicationContext() did not '
					+ 'return an application context');
		}
	}
	/**
	 * Deregisters the JDBC drivers that were registered by the application represented by
	 * the given {@code servletContext}. The default implementation
	 * {@link DriverManager#deregisterDriver(Driver) deregisters} every {@link Driver}
	 * that was loaded by the {@link ServletContext#getClassLoader web application"s class
	 * loader}.
	 * @param servletContext the web application"s servlet context
	 * @since 2.3.0
	 */
	protected void deregisterJdbcDrivers(ServletContext servletContext) {
		for (Driver driver : Collections.list(DriverManager.getDrivers())) {
			if (driver.getClass().getClassLoader() == servletContext.getClassLoader()) {
				try {
					DriverManager.deregisterDriver(driver);
				}
				catch (SQLException ex) {
					// Continue
				}
			}
		}
	}
	/**
	 * Shuts down the reactor {@link Schedulers} that were initialized by
	 * {@code Schedulers.boundedElastic()} (or similar). The default implementation
	 * {@link Schedulers#shutdownNow()} schedulers if they were initialized on this web
	 * application"s class loader.
	 * @param servletContext the web application"s servlet context
	 * @since 3.4.0
	 */
	protected void shutDownSharedReactorSchedulers(ServletContext servletContext) {
		if (Schedulers.class.getClassLoader() == servletContext.getClassLoader()) {
			Schedulers.shutdownNow();
		}
	}
	protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) {
		SpringApplicationBuilder builder = createSpringApplicationBuilder();
		builder.main(getClass());
		ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
		if (parent != null) {
			this.logger.info('Root context already created (using as parent).');
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
			builder.initializers(new ParentContextApplicationContextInitializer(parent));
		}
		builder.initializers(new ServletContextApplicationContextInitializer(servletContext));
		builder.contextFactory((webApplicationType) -> new AnnotationConfigServletWebServerApplicationContext());
		builder = configure(builder);
		builder.listeners(new WebEnvironmentPropertySourceInitializer(servletContext));
		SpringApplication application = builder.build();
		if (application.getAllSources().isEmpty()
				&& MergedAnnotations.from(getClass(), SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class)) {
			application.addPrimarySources(Collections.singleton(getClass()));
		}
		Assert.state(!application.getAllSources().isEmpty(),
				'No SpringApplication sources have been defined. Either override the '
						+ 'configure method or add an @Configuration annotation');
		// Ensure error pages are registered
		if (this.registerErrorPageFilter) {
			application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));
		}
		application.setRegisterShutdownHook(false);
		return run(application);
	}
	/**
	 * Returns the {@code SpringApplicationBuilder} that is used to configure and create
	 * the {@link SpringApplication}. The default implementation returns a new
	 * {@code SpringApplicationBuilder} in its default state.
	 * @return the {@code SpringApplicationBuilder}.
	 * @since 1.3.0
	 */
	protected SpringApplicationBuilder createSpringApplicationBuilder() {
		return new SpringApplicationBuilder();
	}
	/**
	 * Called to run a fully configured {@link SpringApplication}.
	 * @param application the application to run
	 * @return the {@link WebApplicationContext}
	 */
	protected WebApplicationContext run(SpringApplication application) {
		return (WebApplicationContext) application.run();
	}
	private ApplicationContext getExistingRootWebApplicationContext(ServletContext servletContext) {
		Object context = servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
		if (context instanceof ApplicationContext applicationContext) {
			return applicationContext;
		}
		return null;
	}
	/**
	 * Configure the application. Normally all you would need to do is to add sources
	 * (e.g. config classes) because other settings have sensible defaults. You might
	 * choose (for instance) to add default command line arguments, or set an active
	 * Spring profile.
	 * @param builder a builder for the application context
	 * @return the application builder
	 * @see SpringApplicationBuilder
	 */
	protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
		return builder;
	}
	/**
	 * {@link ApplicationListener} to trigger
	 * {@link ConfigurableWebEnvironment#initPropertySources(ServletContext, jakarta.servlet.ServletConfig)}.
	 */
	private static final class WebEnvironmentPropertySourceInitializer
			implements ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
		private final ServletContext servletContext;
		private WebEnvironmentPropertySourceInitializer(ServletContext servletContext) {
			this.servletContext = servletContext;
		}
		@Override
		public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
			ConfigurableEnvironment environment = event.getEnvironment();
			if (environment instanceof ConfigurableWebEnvironment configurableWebEnvironment) {
				configurableWebEnvironment.initPropertySources(this.servletContext, null);
			}
		}
		@Override
		public int getOrder() {
			return Ordered.HIGHEST_PRECEDENCE;
		}
	}
	/**
	 * {@link ContextLoaderListener} for the initialized context.
	 */
	private class SpringBootContextLoaderListener extends ContextLoaderListener {
		private final ServletContext servletContext;
		SpringBootContextLoaderListener(WebApplicationContext applicationContext, ServletContext servletContext) {
			super(applicationContext);
			this.servletContext = servletContext;
		}
		@Override
		public void contextInitialized(ServletContextEvent event) {
			// no-op because the application context is already initialized
		}
		@Override
		public void contextDestroyed(ServletContextEvent event) {
			try {
				super.contextDestroyed(event);
			}
			finally {
				// Use original context so that the classloader can be accessed
				deregisterJdbcDrivers(this.servletContext);
				// Shut down shared reactor schedulers tied to this classloader
				if (REACTOR_PRESENT) {
					shutDownSharedReactorSchedulers(this.servletContext);
				}
			}
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class WebFilterHandler extends ServletComponentHandler {
	WebFilterHandler() {
		super(WebFilter.class);
	}
	@Override
	public void doHandle(Map<String, Object> attributes, AnnotatedBeanDefinition beanDefinition,
			BeanDefinitionRegistry registry) {
		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(FilterRegistrationBean.class);
		builder.addPropertyValue('asyncSupported', attributes.get('asyncSupported'));
		builder.addPropertyValue('dispatcherTypes', extractDispatcherTypes(attributes));
		builder.addPropertyValue('filter', beanDefinition);
		builder.addPropertyValue('initParameters', extractInitParameters(attributes));
		String name = determineName(attributes, beanDefinition);
		builder.addPropertyValue('name', name);
		builder.addPropertyValue('servletNames', attributes.get('servletNames'));
		builder.addPropertyValue('urlPatterns', extractUrlPatterns(attributes));
		registry.registerBeanDefinition(name, builder.getBeanDefinition());
	}
	private EnumSet<DispatcherType> extractDispatcherTypes(Map<String, Object> attributes) {
		DispatcherType[] dispatcherTypes = (DispatcherType[]) attributes.get('dispatcherTypes');
		if (dispatcherTypes.length == 0) {
			return EnumSet.noneOf(DispatcherType.class);
		}
		if (dispatcherTypes.length == 1) {
			return EnumSet.of(dispatcherTypes[0]);
		}
		return EnumSet.of(dispatcherTypes[0], Arrays.copyOfRange(dispatcherTypes, 1, dispatcherTypes.length));
	}
	private String determineName(Map<String, Object> attributes, BeanDefinition beanDefinition) {
		return (String) (StringUtils.hasText((String) attributes.get('filterName')) ? attributes.get('filterName')
				: beanDefinition.getBeanClassName());
	}
}
/*
package org.springframework.boot.web.servlet;
/**
abstract class ServletComponentHandler {
	private final Class<? extends Annotation> annotationType;
	private final TypeFilter typeFilter;
	protected ServletComponentHandler(Class<? extends Annotation> annotationType) {
		this.typeFilter = new AnnotationTypeFilter(annotationType);
		this.annotationType = annotationType;
	}
	TypeFilter getTypeFilter() {
		return this.typeFilter;
	}
	protected String[] extractUrlPatterns(Map<String, Object> attributes) {
		String[] value = (String[]) attributes.get('value');
		String[] urlPatterns = (String[]) attributes.get('urlPatterns');
		if (urlPatterns.length > 0) {
			Assert.state(value.length == 0, 'The urlPatterns and value attributes are mutually exclusive.');
			return urlPatterns;
		}
		return value;
	}
	protected final Map<String, String> extractInitParameters(Map<String, Object> attributes) {
		Map<String, String> initParameters = new HashMap<>();
		for (AnnotationAttributes initParam : (AnnotationAttributes[]) attributes.get('initParams')) {
			String name = (String) initParam.get('name');
			String value = (String) initParam.get('value');
			initParameters.put(name, value);
		}
		return initParameters;
	}
	void handle(AnnotatedBeanDefinition beanDefinition, BeanDefinitionRegistry registry) {
		Map<String, Object> attributes = beanDefinition.getMetadata()
			.getAnnotationAttributes(this.annotationType.getName());
		if (attributes != null) {
			doHandle(attributes, beanDefinition, registry);
		}
	}
	protected abstract void doHandle(Map<String, Object> attributes, AnnotatedBeanDefinition beanDefinition,
			BeanDefinitionRegistry registry);
}
/*
package org.springframework.boot.web.servlet;
/**
public enum DispatcherType {
	/**
	 * Apply the filter on 'RequestDispatcher.forward()' calls.
	 */
	FORWARD,
	/**
	 * Apply the filter on 'RequestDispatcher.include()' calls.
	 */
	INCLUDE,
	/**
	 * Apply the filter on ordinary client calls.
	 */
	REQUEST,
	/**
	 * Apply the filter under calls dispatched from an AsyncContext.
	 */
	ASYNC,
	/**
	 * Apply the filter when an error is handled.
	 */
	ERROR
}
/*
package org.springframework.boot.web.servlet;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(ServletComponentScanRegistrar.class)
public @interface ServletComponentScan {
	/**
	 * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation
	 * declarations e.g.: {@code @ServletComponentScan('org.my.pkg')} instead of
	 * {@code @ServletComponentScan(basePackages='org.my.pkg')}.
	 * @return the base packages to scan
	 */
	@AliasFor('basePackages')
	String[] value() default {};
	/**
	 * Base packages to scan for annotated servlet components. {@link #value()} is an
	 * alias for (and mutually exclusive with) this attribute.
	 * <p>
	 * Use {@link #basePackageClasses()} for a type-safe alternative to String-based
	 * package names.
	 * @return the base packages to scan
	 */
	@AliasFor('value')
	String[] basePackages() default {};
	/**
	 * Type-safe alternative to {@link #basePackages()} for specifying the packages to
	 * scan for annotated servlet components. The package of each class specified will be
	 * scanned.
	 * @return classes from the base packages to scan
	 */
	Class<?>[] basePackageClasses() default {};
}
/*
/**
package org.springframework.boot.web.servlet;
/*
package org.springframework.boot.web.servlet;
/**
public class MultipartConfigFactory {
	private String location;
	private DataSize maxFileSize;
	private DataSize maxRequestSize;
	private DataSize fileSizeThreshold;
	/**
	 * Sets the directory location where files will be stored.
	 * @param location the location
	 */
	public void setLocation(String location) {
		this.location = location;
	}
	/**
	 * Sets the maximum {@link DataSize size} allowed for uploaded files.
	 * @param maxFileSize the maximum file size
	 */
	public void setMaxFileSize(DataSize maxFileSize) {
		this.maxFileSize = maxFileSize;
	}
	/**
	 * Sets the maximum {@link DataSize} allowed for multipart/form-data requests.
	 * @param maxRequestSize the maximum request size
	 */
	public void setMaxRequestSize(DataSize maxRequestSize) {
		this.maxRequestSize = maxRequestSize;
	}
	/**
	 * Sets the {@link DataSize size} threshold after which files will be written to disk.
	 * @param fileSizeThreshold the file size threshold
	 */
	public void setFileSizeThreshold(DataSize fileSizeThreshold) {
		this.fileSizeThreshold = fileSizeThreshold;
	}
	/**
	 * Create a new {@link MultipartConfigElement} instance.
	 * @return the multipart config element
	 */
	public MultipartConfigElement createMultipartConfig() {
		long maxFileSizeBytes = convertToBytes(this.maxFileSize, -1);
		long maxRequestSizeBytes = convertToBytes(this.maxRequestSize, -1);
		long fileSizeThresholdBytes = convertToBytes(this.fileSizeThreshold, 0);
		return new MultipartConfigElement(this.location, maxFileSizeBytes, maxRequestSizeBytes,
				(int) fileSizeThresholdBytes);
	}
	/**
	 * Return the amount of bytes from the specified {@link DataSize size}. If the size is
	 * {@code null} or negative, returns {@code defaultValue}.
	 * @param size the data size to handle
	 * @param defaultValue the default value if the size is {@code null} or negative
	 * @return the amount of bytes to use
	 */
	private long convertToBytes(DataSize size, int defaultValue) {
		if (size != null && !size.isNegative()) {
			return size.toBytes();
		}
		return defaultValue;
	}
}
/*
package org.springframework.boot.web.servlet;
/**
public interface WebListenerRegistrar {
	/**
	 * Register web listeners with the given registry.
	 * @param registry the web listener registry
	 */
	void register(WebListenerRegistry registry);
}
/*
package org.springframework.boot.web.servlet;
/**
class WebServletHandler extends ServletComponentHandler {
	WebServletHandler() {
		super(WebServlet.class);
	}
	@Override
	public void doHandle(Map<String, Object> attributes, AnnotatedBeanDefinition beanDefinition,
			BeanDefinitionRegistry registry) {
		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServletRegistrationBean.class);
		builder.addPropertyValue('asyncSupported', attributes.get('asyncSupported'));
		builder.addPropertyValue('initParameters', extractInitParameters(attributes));
		builder.addPropertyValue('loadOnStartup', attributes.get('loadOnStartup'));
		String name = determineName(attributes, beanDefinition);
		builder.addPropertyValue('name', name);
		builder.addPropertyValue('servlet', beanDefinition);
		builder.addPropertyValue('urlMappings', extractUrlPatterns(attributes));
		builder.addPropertyValue('multipartConfig', determineMultipartConfig(beanDefinition));
		registry.registerBeanDefinition(name, builder.getBeanDefinition());
	}
	private String determineName(Map<String, Object> attributes, BeanDefinition beanDefinition) {
		return (String) (StringUtils.hasText((String) attributes.get('name')) ? attributes.get('name')
				: beanDefinition.getBeanClassName());
	}
	private BeanDefinition determineMultipartConfig(AnnotatedBeanDefinition beanDefinition) {
		Map<String, Object> attributes = beanDefinition.getMetadata()
			.getAnnotationAttributes(MultipartConfig.class.getName());
		if (attributes == null) {
			return null;
		}
		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(MultipartConfigElement.class);
		builder.addConstructorArgValue(attributes.get('location'));
		builder.addConstructorArgValue(attributes.get('maxFileSize'));
		builder.addConstructorArgValue(attributes.get('maxRequestSize'));
		builder.addConstructorArgValue(attributes.get('fileSizeThreshold'));
		return builder.getBeanDefinition();
	}
}
/*
package org.springframework.boot.web.servlet;
/**
public abstract class AbstractFilterRegistrationBean<T extends Filter> extends DynamicRegistrationBean<Dynamic> {
	private static final String[] DEFAULT_URL_MAPPINGS = { '/*' };
	private Set<ServletRegistrationBean<?>> servletRegistrationBeans = new LinkedHashSet<>();
	private Set<String> servletNames = new LinkedHashSet<>();
	private Set<String> urlPatterns = new LinkedHashSet<>();
	private EnumSet<DispatcherType> dispatcherTypes;
	private boolean matchAfter = false;
	/**
	 * Create a new instance to be registered with the specified
	 * {@link ServletRegistrationBean}s.
	 * @param servletRegistrationBeans associate {@link ServletRegistrationBean}s
	 */
	AbstractFilterRegistrationBean(ServletRegistrationBean<?>... servletRegistrationBeans) {
		Assert.notNull(servletRegistrationBeans, 'ServletRegistrationBeans must not be null');
		Collections.addAll(this.servletRegistrationBeans, servletRegistrationBeans);
	}
	/**
	 * Set {@link ServletRegistrationBean}s that the filter will be registered against.
	 * @param servletRegistrationBeans the Servlet registration beans
	 */
	public void setServletRegistrationBeans(Collection<? extends ServletRegistrationBean<?>> servletRegistrationBeans) {
		Assert.notNull(servletRegistrationBeans, 'ServletRegistrationBeans must not be null');
		this.servletRegistrationBeans = new LinkedHashSet<>(servletRegistrationBeans);
	}
	/**
	 * Return a mutable collection of the {@link ServletRegistrationBean} that the filter
	 * will be registered against. {@link ServletRegistrationBean}s.
	 * @return the Servlet registration beans
	 * @see #setServletNames
	 * @see #setUrlPatterns
	 */
	public Collection<ServletRegistrationBean<?>> getServletRegistrationBeans() {
		return this.servletRegistrationBeans;
	}
	/**
	 * Add {@link ServletRegistrationBean}s for the filter.
	 * @param servletRegistrationBeans the servlet registration beans to add
	 * @see #setServletRegistrationBeans
	 */
	public void addServletRegistrationBeans(ServletRegistrationBean<?>... servletRegistrationBeans) {
		Assert.notNull(servletRegistrationBeans, 'ServletRegistrationBeans must not be null');
		Collections.addAll(this.servletRegistrationBeans, servletRegistrationBeans);
	}
	/**
	 * Set servlet names that the filter will be registered against. This will replace any
	 * previously specified servlet names.
	 * @param servletNames the servlet names
	 * @see #setServletRegistrationBeans
	 * @see #setUrlPatterns
	 */
	public void setServletNames(Collection<String> servletNames) {
		Assert.notNull(servletNames, 'ServletNames must not be null');
		this.servletNames = new LinkedHashSet<>(servletNames);
	}
	/**
	 * Return a mutable collection of servlet names that the filter will be registered
	 * against.
	 * @return the servlet names
	 */
	public Collection<String> getServletNames() {
		return this.servletNames;
	}
	/**
	 * Add servlet names for the filter.
	 * @param servletNames the servlet names to add
	 */
	public void addServletNames(String... servletNames) {
		Assert.notNull(servletNames, 'ServletNames must not be null');
		this.servletNames.addAll(Arrays.asList(servletNames));
	}
	/**
	 * Set the URL patterns that the filter will be registered against. This will replace
	 * any previously specified URL patterns.
	 * @param urlPatterns the URL patterns
	 * @see #setServletRegistrationBeans
	 * @see #setServletNames
	 */
	public void setUrlPatterns(Collection<String> urlPatterns) {
		Assert.notNull(urlPatterns, 'UrlPatterns must not be null');
		this.urlPatterns = new LinkedHashSet<>(urlPatterns);
	}
	/**
	 * Return a mutable collection of URL patterns, as defined in the Servlet
	 * specification, that the filter will be registered against.
	 * @return the URL patterns
	 */
	public Collection<String> getUrlPatterns() {
		return this.urlPatterns;
	}
	/**
	 * Add URL patterns, as defined in the Servlet specification, that the filter will be
	 * registered against.
	 * @param urlPatterns the URL patterns
	 */
	public void addUrlPatterns(String... urlPatterns) {
		Assert.notNull(urlPatterns, 'UrlPatterns must not be null');
		Collections.addAll(this.urlPatterns, urlPatterns);
	}
	/**
	 * Determines the {@link DispatcherType dispatcher types} for which the filter should
	 * be registered. Applies defaults based on the type of filter being registered if
	 * none have been configured. Modifications to the returned {@link EnumSet} will have
	 * no effect on the registration.
	 * @return the dispatcher types, never {@code null}
	 * @since 3.2.0
	 */
	public EnumSet<DispatcherType> determineDispatcherTypes() {
		if (this.dispatcherTypes == null) {
			T filter = getFilter();
			if (ClassUtils.isPresent('org.springframework.web.filter.OncePerRequestFilter',
					filter.getClass().getClassLoader()) && filter instanceof OncePerRequestFilter) {
				return EnumSet.allOf(DispatcherType.class);
			}
			else {
				return EnumSet.of(DispatcherType.REQUEST);
			}
		}
		return EnumSet.copyOf(this.dispatcherTypes);
	}
	/**
	 * Convenience method to {@link #setDispatcherTypes(EnumSet) set dispatcher types}
	 * using the specified elements.
	 * @param first the first dispatcher type
	 * @param rest additional dispatcher types
	 */
	public void setDispatcherTypes(DispatcherType first, DispatcherType... rest) {
		this.dispatcherTypes = EnumSet.of(first, rest);
	}
	/**
	 * Sets the dispatcher types that should be used with the registration.
	 * @param dispatcherTypes the dispatcher types
	 */
	public void setDispatcherTypes(EnumSet<DispatcherType> dispatcherTypes) {
		this.dispatcherTypes = dispatcherTypes;
	}
	/**
	 * Set if the filter mappings should be matched after any declared filter mappings of
	 * the ServletContext. Defaults to {@code false} indicating the filters are supposed
	 * to be matched before any declared filter mappings of the ServletContext.
	 * @param matchAfter if filter mappings are matched after
	 */
	public void setMatchAfter(boolean matchAfter) {
		this.matchAfter = matchAfter;
	}
	/**
	 * Return if filter mappings should be matched after any declared Filter mappings of
	 * the ServletContext.
	 * @return if filter mappings are matched after
	 */
	public boolean isMatchAfter() {
		return this.matchAfter;
	}
	@Override
	protected String getDescription() {
		Filter filter = getFilter();
		Assert.notNull(filter, 'Filter must not be null');
		return 'filter ' + getOrDeduceName(filter);
	}
	@Override
	protected Dynamic addRegistration(String description, ServletContext servletContext) {
		Filter filter = getFilter();
		return servletContext.addFilter(getOrDeduceName(filter), filter);
	}
	/**
	 * Configure registration settings. Subclasses can override this method to perform
	 * additional configuration if required.
	 * @param registration the registration
	 */
	@Override
	protected void configure(FilterRegistration.Dynamic registration) {
		super.configure(registration);
		EnumSet<DispatcherType> dispatcherTypes = determineDispatcherTypes();
		Set<String> servletNames = new LinkedHashSet<>();
		for (ServletRegistrationBean<?> servletRegistrationBean : this.servletRegistrationBeans) {
			servletNames.add(servletRegistrationBean.getServletName());
		}
		servletNames.addAll(this.servletNames);
		if (servletNames.isEmpty() && this.urlPatterns.isEmpty()) {
			registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, DEFAULT_URL_MAPPINGS);
		}
		else {
			if (!servletNames.isEmpty()) {
				registration.addMappingForServletNames(dispatcherTypes, this.matchAfter,
						StringUtils.toStringArray(servletNames));
			}
			if (!this.urlPatterns.isEmpty()) {
				registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter,
						StringUtils.toStringArray(this.urlPatterns));
			}
		}
	}
	/**
	 * Return the {@link Filter} to be registered.
	 * @return the filter
	 */
	public abstract T getFilter();
	/**
	 * Returns the filter name that will be registered.
	 * @return the filter name
	 * @since 3.2.0
	 */
	public String getFilterName() {
		return getOrDeduceName(getFilter());
	}
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder(getOrDeduceName(this));
		if (this.servletNames.isEmpty() && this.urlPatterns.isEmpty()) {
			builder.append(' urls=').append(Arrays.toString(DEFAULT_URL_MAPPINGS));
		}
		else {
			if (!this.servletNames.isEmpty()) {
				builder.append(' servlets=').append(this.servletNames);
			}
			if (!this.urlPatterns.isEmpty()) {
				builder.append(' urls=').append(this.urlPatterns);
			}
		}
		builder.append(' order=').append(getOrder());
		return builder.toString();
	}
}
/*
package org.springframework.boot.web.reactive.result.view;
/**
public class MustacheViewResolver extends UrlBasedViewResolver {
	private final Compiler compiler;
	private String charset;
	/**
	 * Create a {@code MustacheViewResolver} backed by a default instance of a
	 * {@link Compiler}.
	 */
	public MustacheViewResolver() {
		this.compiler = Mustache.compiler();
		setViewClass(requiredViewClass());
	}
	/**
	 * Create a {@code MustacheViewResolver} backed by a custom instance of a
	 * {@link Compiler}.
	 * @param compiler the Mustache compiler used to compile templates
	 */
	public MustacheViewResolver(Compiler compiler) {
		this.compiler = compiler;
		setViewClass(requiredViewClass());
	}
	/**
	 * Set the charset.
	 * @param charset the charset
	 */
	public void setCharset(String charset) {
		this.charset = charset;
	}
	@Override
	protected Class<?> requiredViewClass() {
		return MustacheView.class;
	}
	@Override
	protected AbstractUrlBasedView createView(String viewName) {
		MustacheView view = (MustacheView) super.createView(viewName);
		view.setCompiler(this.compiler);
		view.setCharset(this.charset);
		return view;
	}
	@Override
	protected AbstractUrlBasedView instantiateView() {
		return (getViewClass() == MustacheView.class) ? new MustacheView() : super.instantiateView();
	}
}
/*
package org.springframework.boot.web.reactive.result.view;
/**
public class MustacheView extends AbstractUrlBasedView {
	private Compiler compiler;
	private String charset;
	/**
	 * Set the JMustache compiler to be used by this view. Typically this property is not
	 * set directly. Instead a single {@link Compiler} is expected in the Spring
	 * application context which is used to compile Mustache templates.
	 * @param compiler the Mustache compiler
	 */
	public void setCompiler(Compiler compiler) {
		this.compiler = compiler;
	}
	/**
	 * Set the charset used for reading Mustache template files.
	 * @param charset the charset to use for reading template files
	 */
	public void setCharset(String charset) {
		this.charset = charset;
	}
	@Override
	public boolean checkResourceExists(Locale locale) throws Exception {
		return resolveResource() != null;
	}
	@Override
	protected Mono<Void> renderInternal(Map<String, Object> model, MediaType contentType, ServerWebExchange exchange) {
		Resource resource = resolveResource();
		if (resource == null) {
			return Mono
				.error(new IllegalStateException('Could not find Mustache template with URL [' + getUrl() + ']'));
		}
		DataBuffer dataBuffer = exchange.getResponse()
			.bufferFactory()
			.allocateBuffer(DefaultDataBufferFactory.DEFAULT_INITIAL_CAPACITY);
		try (Reader reader = getReader(resource)) {
			Template template = this.compiler.compile(reader);
			Charset charset = getCharset(contentType).orElseGet(this::getDefaultCharset);
			try (Writer writer = new OutputStreamWriter(dataBuffer.asOutputStream(), charset)) {
				template.execute(model, writer);
				writer.flush();
			}
		}
		catch (Exception ex) {
			DataBufferUtils.release(dataBuffer);
			return Mono.error(ex);
		}
		return exchange.getResponse().writeWith(Flux.just(dataBuffer));
	}
	private Resource resolveResource() {
		Resource resource = getApplicationContext().getResource(getUrl());
		if (resource == null || !resource.exists()) {
			return null;
		}
		return resource;
	}
	private Reader getReader(Resource resource) throws IOException {
		if (this.charset != null) {
			return new InputStreamReader(resource.getInputStream(), this.charset);
		}
		return new InputStreamReader(resource.getInputStream());
	}
	private Optional<Charset> getCharset(MediaType mediaType) {
		return Optional.ofNullable((mediaType != null) ? mediaType.getCharset() : null);
	}
}
/*
/**
package org.springframework.boot.web.reactive.result.view;
/*
package org.springframework.boot.web.reactive.filter;
/**
public interface OrderedWebFilter extends WebFilter, Ordered {
	/**
	 * Filters that wrap the request should be ordered less than or equal to this.
	 */
	int REQUEST_WRAPPER_FILTER_MAX_ORDER = 0;
}
/*
package org.springframework.boot.web.reactive.filter;
/**
public class OrderedHiddenHttpMethodFilter extends HiddenHttpMethodFilter implements OrderedWebFilter {
	/**
	 * The default order is high to ensure the filter is applied before Spring Security.
	 */
	public static final int DEFAULT_ORDER = REQUEST_WRAPPER_FILTER_MAX_ORDER - 10000;
	private int order = DEFAULT_ORDER;
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Set the order for this filter.
	 * @param order the order to set
	 */
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
/**
package org.springframework.boot.web.reactive.filter;
/*
package org.springframework.boot.web.reactive.context;
/**
class ApplicationReactiveWebEnvironment extends StandardReactiveWebEnvironment {
	@Override
	protected String doGetActiveProfilesProperty() {
		return null;
	}
	@Override
	protected String doGetDefaultProfilesProperty() {
		return null;
	}
	@Override
	protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {
		return ConfigurationPropertySources.createPropertyResolver(propertySources);
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
public class ReactiveWebServerInitializedEvent extends WebServerInitializedEvent {
	private final ReactiveWebServerApplicationContext applicationContext;
	public ReactiveWebServerInitializedEvent(WebServer webServer,
			ReactiveWebServerApplicationContext applicationContext) {
		super(webServer);
		this.applicationContext = applicationContext;
	}
	@Override
	public ReactiveWebServerApplicationContext getApplicationContext() {
		return this.applicationContext;
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
class ReactiveWebServerApplicationContextFactory implements ApplicationContextFactory {
	@Override
	public Class<? extends ConfigurableEnvironment> getEnvironmentType(WebApplicationType webApplicationType) {
		return (webApplicationType != WebApplicationType.REACTIVE) ? null : ApplicationReactiveWebEnvironment.class;
	}
	@Override
	public ConfigurableEnvironment createEnvironment(WebApplicationType webApplicationType) {
		return (webApplicationType != WebApplicationType.REACTIVE) ? null : new ApplicationReactiveWebEnvironment();
	}
	@Override
	public ConfigurableApplicationContext create(WebApplicationType webApplicationType) {
		return (webApplicationType != WebApplicationType.REACTIVE) ? null : createContext();
	}
	private ConfigurableApplicationContext createContext() {
		if (!AotDetector.useGeneratedArtifacts()) {
			return new AnnotationConfigReactiveWebServerApplicationContext();
		}
		return new ReactiveWebServerApplicationContext();
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
public class ReactiveWebServerApplicationContext extends GenericReactiveWebApplicationContext
		implements ConfigurableWebServerApplicationContext {
	private volatile WebServerManager serverManager;
	private String serverNamespace;
	/**
	 * Create a new {@link ReactiveWebServerApplicationContext}.
	 */
	public ReactiveWebServerApplicationContext() {
	}
	/**
	 * Create a new {@link ReactiveWebServerApplicationContext} with the given
	 * {@code DefaultListableBeanFactory}.
	 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
	 */
	public ReactiveWebServerApplicationContext(DefaultListableBeanFactory beanFactory) {
		super(beanFactory);
	}
	@Override
	public final void refresh() throws BeansException, IllegalStateException {
		try {
			super.refresh();
		}
		catch (RuntimeException ex) {
			WebServerManager serverManager = this.serverManager;
			if (serverManager != null) {
				serverManager.getWebServer().stop();
			}
			throw ex;
		}
	}
	@Override
	protected void onRefresh() {
		super.onRefresh();
		try {
			createWebServer();
		}
		catch (Throwable ex) {
			throw new ApplicationContextException('Unable to start reactive web server', ex);
		}
	}
	private void createWebServer() {
		WebServerManager serverManager = this.serverManager;
		if (serverManager == null) {
			StartupStep createWebServer = getApplicationStartup().start('spring.boot.webserver.create');
			String webServerFactoryBeanName = getWebServerFactoryBeanName();
			ReactiveWebServerFactory webServerFactory = getWebServerFactory(webServerFactoryBeanName);
			createWebServer.tag('factory', webServerFactory.getClass().toString());
			boolean lazyInit = getBeanFactory().getBeanDefinition(webServerFactoryBeanName).isLazyInit();
			this.serverManager = new WebServerManager(this, webServerFactory, this::getHttpHandler, lazyInit);
			getBeanFactory().registerSingleton('webServerGracefulShutdown',
					new WebServerGracefulShutdownLifecycle(this.serverManager.getWebServer()));
			getBeanFactory().registerSingleton('webServerStartStop',
					new WebServerStartStopLifecycle(this.serverManager));
			createWebServer.end();
		}
		initPropertySources();
	}
	protected String getWebServerFactoryBeanName() {
		// Use bean names so that we don"t consider the hierarchy
		String[] beanNames = getBeanFactory().getBeanNamesForType(ReactiveWebServerFactory.class);
		if (beanNames.length == 0) {
			throw new MissingWebServerFactoryBeanException(getClass(), ReactiveWebServerFactory.class,
					WebApplicationType.REACTIVE);
		}
		if (beanNames.length > 1) {
			throw new ApplicationContextException('Unable to start ReactiveWebApplicationContext due to multiple '
					+ 'ReactiveWebServerFactory beans : ' + StringUtils.arrayToCommaDelimitedString(beanNames));
		}
		return beanNames[0];
	}
	protected ReactiveWebServerFactory getWebServerFactory(String factoryBeanName) {
		return getBeanFactory().getBean(factoryBeanName, ReactiveWebServerFactory.class);
	}
	/**
	 * Return the {@link HttpHandler} that should be used to process the reactive web
	 * server. By default this method searches for a suitable bean in the context itself.
	 * @return a {@link HttpHandler} (never {@code null}
	 */
	protected HttpHandler getHttpHandler() {
		// Use bean names so that we don"t consider the hierarchy
		String[] beanNames = getBeanFactory().getBeanNamesForType(HttpHandler.class);
		if (beanNames.length == 0) {
			throw new ApplicationContextException(
					'Unable to start ReactiveWebApplicationContext due to missing HttpHandler bean.');
		}
		if (beanNames.length > 1) {
			throw new ApplicationContextException(
					'Unable to start ReactiveWebApplicationContext due to multiple HttpHandler beans : '
							+ StringUtils.arrayToCommaDelimitedString(beanNames));
		}
		return getBeanFactory().getBean(beanNames[0], HttpHandler.class);
	}
	@Override
	protected void doClose() {
		if (isActive()) {
			AvailabilityChangeEvent.publish(this, ReadinessState.REFUSING_TRAFFIC);
		}
		super.doClose();
	}
	/**
	 * Returns the {@link WebServer} that was created by the context or {@code null} if
	 * the server has not yet been created.
	 * @return the web server
	 */
	@Override
	public WebServer getWebServer() {
		WebServerManager serverManager = this.serverManager;
		return (serverManager != null) ? serverManager.getWebServer() : null;
	}
	@Override
	public String getServerNamespace() {
		return this.serverNamespace;
	}
	@Override
	public void setServerNamespace(String serverNamespace) {
		this.serverNamespace = serverNamespace;
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
public interface ConfigurableReactiveWebEnvironment extends ConfigurableEnvironment {
}
/*
package org.springframework.boot.web.reactive.context;
/**
class WebServerStartStopLifecycle implements SmartLifecycle {
	private final WebServerManager weServerManager;
	private volatile boolean running;
	WebServerStartStopLifecycle(WebServerManager weServerManager) {
		this.weServerManager = weServerManager;
	}
	@Override
	public void start() {
		this.weServerManager.start();
		this.running = true;
	}
	@Override
	public void stop() {
		this.running = false;
		this.weServerManager.stop();
	}
	@Override
	public boolean isRunning() {
		return this.running;
	}
	@Override
	public int getPhase() {
		return WebServerGracefulShutdownLifecycle.SMART_LIFECYCLE_PHASE - 1024;
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
public interface ConfigurableReactiveWebApplicationContext
		extends ConfigurableApplicationContext, ReactiveWebApplicationContext {
}
/*
package org.springframework.boot.web.reactive.context;
/**
class FilteredReactiveWebContextResource extends AbstractResource {
	private final String path;
	FilteredReactiveWebContextResource(String path) {
		this.path = path;
	}
	@Override
	public boolean exists() {
		return false;
	}
	@Override
	public Resource createRelative(String relativePath) throws IOException {
		String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);
		return new FilteredReactiveWebContextResource(pathToUse);
	}
	@Override
	public String getDescription() {
		return 'ReactiveWebContext resource [' + this.path + ']';
	}
	@Override
	public InputStream getInputStream() throws IOException {
		throw new FileNotFoundException(getDescription() + ' cannot be opened because it does not exist');
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
class WebServerManager {
	private final ReactiveWebServerApplicationContext applicationContext;
	private final DelayedInitializationHttpHandler handler;
	private final WebServer webServer;
	WebServerManager(ReactiveWebServerApplicationContext applicationContext, ReactiveWebServerFactory factory,
			Supplier<HttpHandler> handlerSupplier, boolean lazyInit) {
		this.applicationContext = applicationContext;
		Assert.notNull(factory, 'Factory must not be null');
		this.handler = new DelayedInitializationHttpHandler(handlerSupplier, lazyInit);
		this.webServer = factory.getWebServer(this.handler);
	}
	void start() {
		this.handler.initializeHandler();
		this.webServer.start();
		this.applicationContext
			.publishEvent(new ReactiveWebServerInitializedEvent(this.webServer, this.applicationContext));
	}
	void shutDownGracefully(GracefulShutdownCallback callback) {
		this.webServer.shutDownGracefully(callback);
	}
	void stop() {
		this.webServer.stop();
	}
	WebServer getWebServer() {
		return this.webServer;
	}
	HttpHandler getHandler() {
		return this.handler;
	}
	/**
	 * A delayed {@link HttpHandler} that doesn"t initialize things too early.
	 */
	static final class DelayedInitializationHttpHandler implements HttpHandler {
		private final Supplier<HttpHandler> handlerSupplier;
		private final boolean lazyInit;
		private volatile HttpHandler delegate = this::handleUninitialized;
		private DelayedInitializationHttpHandler(Supplier<HttpHandler> handlerSupplier, boolean lazyInit) {
			this.handlerSupplier = handlerSupplier;
			this.lazyInit = lazyInit;
		}
		private Mono<Void> handleUninitialized(ServerHttpRequest request, ServerHttpResponse response) {
			throw new IllegalStateException('The HttpHandler has not yet been initialized');
		}
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			return this.delegate.handle(request, response);
		}
		void initializeHandler() {
			this.delegate = this.lazyInit ? new LazyHttpHandler(this.handlerSupplier) : this.handlerSupplier.get();
		}
		HttpHandler getHandler() {
			return this.delegate;
		}
	}
	/**
	 * {@link HttpHandler} that initializes its delegate on first request.
	 */
	private static final class LazyHttpHandler implements HttpHandler {
		private final Mono<HttpHandler> delegate;
		private LazyHttpHandler(Supplier<HttpHandler> handlerSupplier) {
			this.delegate = Mono.fromSupplier(handlerSupplier);
		}
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			return this.delegate.flatMap((handler) -> handler.handle(request, response));
		}
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
public interface ReactiveWebApplicationContext extends ApplicationContext {
}
/*
package org.springframework.boot.web.reactive.context;
/**
public class AnnotationConfigReactiveWebServerApplicationContext extends ReactiveWebServerApplicationContext
		implements AnnotationConfigRegistry {
	private final AnnotatedBeanDefinitionReader reader;
	private final ClassPathBeanDefinitionScanner scanner;
	private final Set<Class<?>> annotatedClasses = new LinkedHashSet<>();
	private String[] basePackages;
	/**
	 * Create a new {@link AnnotationConfigReactiveWebServerApplicationContext} that needs
	 * to be populated through {@link #register} calls and then manually
	 * {@linkplain #refresh refreshed}.
	 */
	public AnnotationConfigReactiveWebServerApplicationContext() {
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
	/**
	 * Create a new {@link AnnotationConfigReactiveWebServerApplicationContext} with the
	 * given {@code DefaultListableBeanFactory}. The context needs to be populated through
	 * {@link #register} calls and then manually {@linkplain #refresh refreshed}.
	 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
	 */
	public AnnotationConfigReactiveWebServerApplicationContext(DefaultListableBeanFactory beanFactory) {
		super(beanFactory);
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
	/**
	 * Create a new {@link AnnotationConfigReactiveWebServerApplicationContext}, deriving
	 * bean definitions from the given annotated classes and automatically refreshing the
	 * context.
	 * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}
	 * classes
	 */
	public AnnotationConfigReactiveWebServerApplicationContext(Class<?>... annotatedClasses) {
		this();
		register(annotatedClasses);
		refresh();
	}
	/**
	 * Create a new {@link AnnotationConfigReactiveWebServerApplicationContext}, scanning
	 * for bean definitions in the given packages and automatically refreshing the
	 * context.
	 * @param basePackages the packages to check for annotated classes
	 */
	public AnnotationConfigReactiveWebServerApplicationContext(String... basePackages) {
		this();
		scan(basePackages);
		refresh();
	}
	/**
	 * {@inheritDoc}
	 * <p>
	 * Delegates given environment to underlying {@link AnnotatedBeanDefinitionReader} and
	 * {@link ClassPathBeanDefinitionScanner} members.
	 */
	@Override
	public void setEnvironment(ConfigurableEnvironment environment) {
		super.setEnvironment(environment);
		this.reader.setEnvironment(environment);
		this.scanner.setEnvironment(environment);
	}
	/**
	 * Provide a custom {@link BeanNameGenerator} for use with
	 * {@link AnnotatedBeanDefinitionReader} and/or
	 * {@link ClassPathBeanDefinitionScanner}, if any.
	 * <p>
	 * Default is
	 * {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.
	 * <p>
	 * Any call to this method must occur prior to calls to {@link #register(Class...)}
	 * and/or {@link #scan(String...)}.
	 * @param beanNameGenerator the bean name generator
	 * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator
	 * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator
	 */
	public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
		this.reader.setBeanNameGenerator(beanNameGenerator);
		this.scanner.setBeanNameGenerator(beanNameGenerator);
		getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
	}
	/**
	 * Set the {@link ScopeMetadataResolver} to use for detected bean classes.
	 * <p>
	 * The default is an {@link AnnotationScopeMetadataResolver}.
	 * <p>
	 * Any call to this method must occur prior to calls to {@link #register(Class...)}
	 * and/or {@link #scan(String...)}.
	 * @param scopeMetadataResolver the scope metadata resolver
	 */
	public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {
		this.reader.setScopeMetadataResolver(scopeMetadataResolver);
		this.scanner.setScopeMetadataResolver(scopeMetadataResolver);
	}
	/**
	 * Register one or more annotated classes to be processed. Note that
	 * {@link #refresh()} must be called in order for the context to fully process the new
	 * class.
	 * <p>
	 * Calls to {@code #register} are idempotent; adding the same annotated class more
	 * than once has no additional effect.
	 * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}
	 * classes
	 * @see #scan(String...)
	 * @see #refresh()
	 */
	@Override
	public final void register(Class<?>... annotatedClasses) {
		Assert.notEmpty(annotatedClasses, 'At least one annotated class must be specified');
		this.annotatedClasses.addAll(Arrays.asList(annotatedClasses));
	}
	/**
	 * Perform a scan within the specified base packages. Note that {@link #refresh()}
	 * must be called in order for the context to fully process the new class.
	 * @param basePackages the packages to check for annotated classes
	 * @see #register(Class...)
	 * @see #refresh()
	 */
	@Override
	public final void scan(String... basePackages) {
		Assert.notEmpty(basePackages, 'At least one base package must be specified');
		this.basePackages = basePackages;
	}
	@Override
	protected void prepareRefresh() {
		this.scanner.clearCache();
		super.prepareRefresh();
	}
	@Override
	protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		super.postProcessBeanFactory(beanFactory);
		if (!ObjectUtils.isEmpty(this.basePackages)) {
			this.scanner.scan(this.basePackages);
		}
		if (!this.annotatedClasses.isEmpty()) {
			this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));
		}
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
public class StandardReactiveWebEnvironment extends StandardEnvironment implements ConfigurableReactiveWebEnvironment {
	public StandardReactiveWebEnvironment() {
		super();
	}
	protected StandardReactiveWebEnvironment(MutablePropertySources propertySources) {
		super(propertySources);
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
public class AnnotationConfigReactiveWebApplicationContext extends AnnotationConfigApplicationContext
		implements ConfigurableReactiveWebApplicationContext {
	/**
	 * Create a new AnnotationConfigReactiveWebApplicationContext that needs to be
	 * populated through {@link #register} calls and then manually {@linkplain #refresh
	 * refreshed}.
	 */
	public AnnotationConfigReactiveWebApplicationContext() {
	}
	/**
	 * Create a new AnnotationConfigApplicationContext with the given
	 * DefaultListableBeanFactory.
	 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
	 * @since 2.2.0
	 */
	public AnnotationConfigReactiveWebApplicationContext(DefaultListableBeanFactory beanFactory) {
		super(beanFactory);
	}
	/**
	 * Create a new AnnotationConfigApplicationContext, deriving bean definitions from the
	 * given annotated classes and automatically refreshing the context.
	 * @param annotatedClasses one or more annotated classes, e.g.
	 * {@link Configuration @Configuration} classes
	 * @since 2.2.0
	 */
	public AnnotationConfigReactiveWebApplicationContext(Class<?>... annotatedClasses) {
		super(annotatedClasses);
	}
	/**
	 * Create a new AnnotationConfigApplicationContext, scanning for bean definitions in
	 * the given packages and automatically refreshing the context.
	 * @param basePackages the packages to check for annotated classes
	 * @since 2.2.0
	 */
	public AnnotationConfigReactiveWebApplicationContext(String... basePackages) {
		super(basePackages);
	}
	@Override
	protected ConfigurableEnvironment createEnvironment() {
		return new StandardReactiveWebEnvironment();
	}
	@Override
	protected Resource getResourceByPath(String path) {
		// We must be careful not to expose classpath resources
		return new FilteredReactiveWebContextResource(path);
	}
}
/*
/**
package org.springframework.boot.web.reactive.context;
/*
package org.springframework.boot.web.reactive.context;
/**
public class GenericReactiveWebApplicationContext extends GenericApplicationContext
		implements ConfigurableReactiveWebApplicationContext {
	/**
	 * Create a new {@link GenericReactiveWebApplicationContext}.
	 * @see #registerBeanDefinition
	 * @see #refresh
	 */
	public GenericReactiveWebApplicationContext() {
	}
	/**
	 * Create a new {@link GenericReactiveWebApplicationContext} with the given
	 * DefaultListableBeanFactory.
	 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
	 * @see #registerBeanDefinition
	 * @see #refresh
	 */
	public GenericReactiveWebApplicationContext(DefaultListableBeanFactory beanFactory) {
		super(beanFactory);
	}
	@Override
	protected ConfigurableEnvironment createEnvironment() {
		return new StandardReactiveWebEnvironment();
	}
	@Override
	protected Resource getResourceByPath(String path) {
		// We must be careful not to expose classpath resources
		return new FilteredReactiveWebContextResource(path);
	}
}
/*
package org.springframework.boot.web.reactive.server;
/**
public interface ConfigurableReactiveWebServerFactory extends ConfigurableWebServerFactory, ReactiveWebServerFactory {
}
/*
package org.springframework.boot.web.reactive.server;
/**
@FunctionalInterface
public interface ReactiveWebServerFactory extends WebServerFactory {
	/**
	 * Gets a new fully configured but paused {@link WebServer} instance. Clients should
	 * not be able to connect to the returned server until {@link WebServer#start()} is
	 * called (which happens when the {@code ApplicationContext} has been fully
	 * refreshed).
	 * @param httpHandler the HTTP handler in charge of processing requests
	 * @return a fully configured and started {@link WebServer}
	 * @see WebServer#stop()
	 */
	WebServer getWebServer(HttpHandler httpHandler);
}
/*
package org.springframework.boot.web.reactive.server;
/**
public abstract class AbstractReactiveWebServerFactory extends AbstractConfigurableWebServerFactory
		implements ConfigurableReactiveWebServerFactory {
	public AbstractReactiveWebServerFactory() {
	}
	public AbstractReactiveWebServerFactory(int port) {
		super(port);
	}
}
/*
/**
package org.springframework.boot.web.reactive.server;
/*
package org.springframework.boot.web.reactive.error;
/**
public class DefaultErrorAttributes implements ErrorAttributes {
	private static final String ERROR_INTERNAL_ATTRIBUTE = DefaultErrorAttributes.class.getName() + '.ERROR';
	@Override
	public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
		Map<String, Object> errorAttributes = getErrorAttributes(request, options.isIncluded(Include.STACK_TRACE));
		options.retainIncluded(errorAttributes);
		return errorAttributes;
	}
	private Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) {
		Map<String, Object> errorAttributes = new LinkedHashMap<>();
		errorAttributes.put('timestamp', new Date());
		errorAttributes.put('path', request.requestPath().value());
		Throwable error = getError(request);
		MergedAnnotation<ResponseStatus> responseStatusAnnotation = MergedAnnotations
			.from(error.getClass(), SearchStrategy.TYPE_HIERARCHY)
			.get(ResponseStatus.class);
		HttpStatus errorStatus = determineHttpStatus(error, responseStatusAnnotation);
		errorAttributes.put('status', errorStatus.value());
		errorAttributes.put('error', errorStatus.getReasonPhrase());
		errorAttributes.put('requestId', request.exchange().getRequest().getId());
		handleException(errorAttributes, error, responseStatusAnnotation, includeStackTrace);
		return errorAttributes;
	}
	private HttpStatus determineHttpStatus(Throwable error, MergedAnnotation<ResponseStatus> responseStatusAnnotation) {
		if (error instanceof ResponseStatusException responseStatusException) {
			HttpStatus httpStatus = HttpStatus.resolve(responseStatusException.getStatusCode().value());
			if (httpStatus != null) {
				return httpStatus;
			}
		}
		return responseStatusAnnotation.getValue('code', HttpStatus.class).orElse(HttpStatus.INTERNAL_SERVER_ERROR);
	}
	private void addStackTrace(Map<String, Object> errorAttributes, Throwable error) {
		StringWriter stackTrace = new StringWriter();
		error.printStackTrace(new PrintWriter(stackTrace));
		stackTrace.flush();
		errorAttributes.put('trace', stackTrace.toString());
	}
	private void handleException(Map<String, Object> errorAttributes, Throwable error,
			MergedAnnotation<ResponseStatus> responseStatusAnnotation, boolean includeStackTrace) {
		Throwable exception;
		if (error instanceof BindingResult bindingResult) {
			errorAttributes.put('message', error.getMessage());
			errorAttributes.put('errors', bindingResult.getAllErrors());
			exception = error;
		}
		else if (error instanceof MethodValidationResult methodValidationResult) {
			addMessageAndErrorsFromMethodValidationResult(errorAttributes, methodValidationResult);
			exception = error;
		}
		else if (error instanceof ResponseStatusException responseStatusException) {
			errorAttributes.put('message', responseStatusException.getReason());
			exception = (responseStatusException.getCause() != null) ? responseStatusException.getCause() : error;
			if (exception instanceof BindingResult bindingResult) {
				errorAttributes.put('errors', bindingResult.getAllErrors());
			}
		}
		else {
			exception = error;
			String reason = responseStatusAnnotation.getValue('reason', String.class).orElse('');
			String message = StringUtils.hasText(reason) ? reason : error.getMessage();
			errorAttributes.put('message', (message != null) ? message : '');
		}
		errorAttributes.put('exception', exception.getClass().getName());
		if (includeStackTrace) {
			addStackTrace(errorAttributes, exception);
		}
	}
	private void addMessageAndErrorsFromMethodValidationResult(Map<String, Object> errorAttributes,
			MethodValidationResult result) {
		List<ObjectError> errors = result.getAllErrors()
			.stream()
			.filter(ObjectError.class::isInstance)
			.map(ObjectError.class::cast)
			.toList();
		errorAttributes.put('message',
				'Validation failed for method="' + result.getMethod() + '". Error count: ' + errors.size());
		errorAttributes.put('errors', errors);
	}
	@Override
	public Throwable getError(ServerRequest request) {
		Optional<Object> error = request.attribute(ERROR_INTERNAL_ATTRIBUTE);
		return (Throwable) error
			.orElseThrow(() -> new IllegalStateException('Missing exception attribute in ServerWebExchange'));
	}
	@Override
	public void storeErrorInformation(Throwable error, ServerWebExchange exchange) {
		exchange.getAttributes().putIfAbsent(ERROR_INTERNAL_ATTRIBUTE, error);
	}
}
/*
package org.springframework.boot.web.reactive.error;
/**
public interface ErrorAttributes {
	/**
	 * Return a {@link Map} of the error attributes. The map can be used as the model of
	 * an error page, or returned as a {@link ServerResponse} body.
	 * @param request the source request
	 * @param options options for error attribute contents
	 * @return a map of error attributes
	 */
	default Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
		return Collections.emptyMap();
	}
	/**
	 * Return the underlying cause of the error or {@code null} if the error cannot be
	 * extracted.
	 * @param request the source ServerRequest
	 * @return the {@link Exception} that caused the error or {@code null}
	 */
	Throwable getError(ServerRequest request);
	/**
	 * Store the given error information in the current {@link ServerWebExchange}.
	 * @param error the {@link Exception} that caused the error
	 * @param exchange the source exchange
	 */
	void storeErrorInformation(Throwable error, ServerWebExchange exchange);
}
/*
/**
package org.springframework.boot.web.reactive.error;
/*
package org.springframework.boot.web.reactive.error;
/**
@FunctionalInterface
public interface ErrorWebExceptionHandler extends WebExceptionHandler {
}
/*
package org.springframework.boot.web.reactive.function.client;
/**
@FunctionalInterface
public interface WebClientCustomizer {
	/**
	 * Callback to customize a
	 * {@link org.springframework.web.reactive.function.client.WebClient.Builder
	 * WebClient.Builder} instance.
	 * @param webClientBuilder the client builder to customize
	 */
	void customize(WebClient.Builder webClientBuilder);
}
/*
/**
package org.springframework.boot.web.reactive.function.client;
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface ExitCodeExceptionMapper {
	/**
	 * Returns the exit code that should be returned from the application.
	 * @param exception the exception causing the application to exit
	 * @return the exit code or {@code 0}.
	 */
	int getExitCode(Throwable exception);
}
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface ExitCodeGenerator {
	/**
	 * Returns the exit code that should be returned from the application.
	 * @return the exit code.
	 */
	int getExitCode();
}
/*
package org.springframework.boot;
/**
class SpringBootExceptionHandler implements UncaughtExceptionHandler {
	private static final Set<String> LOG_CONFIGURATION_MESSAGES;
	static {
		Set<String> messages = new HashSet<>();
		messages.add('Logback configuration error detected');
		LOG_CONFIGURATION_MESSAGES = Collections.unmodifiableSet(messages);
	}
	private static final LoggedExceptionHandlerThreadLocal handler = new LoggedExceptionHandlerThreadLocal();
	private final UncaughtExceptionHandler parent;
	private final List<Throwable> loggedExceptions = new ArrayList<>();
	private int exitCode = 0;
	SpringBootExceptionHandler(UncaughtExceptionHandler parent) {
		this.parent = parent;
	}
	void registerLoggedException(Throwable exception) {
		this.loggedExceptions.add(exception);
	}
	void registerExitCode(int exitCode) {
		this.exitCode = exitCode;
	}
	@Override
	public void uncaughtException(Thread thread, Throwable ex) {
		try {
			if (isPassedToParent(ex) && this.parent != null) {
				this.parent.uncaughtException(thread, ex);
			}
		}
		finally {
			this.loggedExceptions.clear();
			if (this.exitCode != 0) {
				System.exit(this.exitCode);
			}
		}
	}
	private boolean isPassedToParent(Throwable ex) {
		return isLogConfigurationMessage(ex) || !isRegistered(ex);
	}
	/**
	 * Check if the exception is a log configuration message, i.e. the log call might not
	 * have actually output anything.
	 * @param ex the source exception
	 * @return {@code true} if the exception contains a log configuration message
	 */
	private boolean isLogConfigurationMessage(Throwable ex) {
		if (ex instanceof InvocationTargetException) {
			return isLogConfigurationMessage(ex.getCause());
		}
		String message = ex.getMessage();
		if (message != null) {
			for (String candidate : LOG_CONFIGURATION_MESSAGES) {
				if (message.contains(candidate)) {
					return true;
				}
			}
		}
		return false;
	}
	private boolean isRegistered(Throwable ex) {
		if (this.loggedExceptions.contains(ex)) {
			return true;
		}
		if (ex instanceof InvocationTargetException) {
			return isRegistered(ex.getCause());
		}
		return false;
	}
	static SpringBootExceptionHandler forCurrentThread() {
		return handler.get();
	}
	/**
	 * Thread local used to attach and track handlers.
	 */
	private static final class LoggedExceptionHandlerThreadLocal extends ThreadLocal<SpringBootExceptionHandler> {
		@Override
		protected SpringBootExceptionHandler initialValue() {
			SpringBootExceptionHandler handler = new SpringBootExceptionHandler(
					Thread.currentThread().getUncaughtExceptionHandler());
			Thread.currentThread().setUncaughtExceptionHandler(handler);
			return handler;
		}
	}
}
/*
package org.springframework.boot;
/**
public interface SpringApplicationShutdownHandlers {
	/**
	 * Add an action to the handlers that will be run when the JVM exits.
	 * @param action the action to add
	 */
	void add(Runnable action);
	/**
	 * Remove a previously added an action so that it no longer runs when the JVM exits.
	 * @param action the action to remove
	 */
	void remove(Runnable action);
}
/*
package org.springframework.boot.validation;
/**
class MessageSourceMessageInterpolator implements MessageInterpolator {
	private static final char PREFIX = "{";
	private static final char SUFFIX = "}";
	private static final char ESCAPE = "\\";
	private final MessageSource messageSource;
	private final MessageInterpolator messageInterpolator;
	MessageSourceMessageInterpolator(MessageSource messageSource, MessageInterpolator messageInterpolator) {
		this.messageSource = messageSource;
		this.messageInterpolator = messageInterpolator;
	}
	@Override
	public String interpolate(String messageTemplate, Context context) {
		return interpolate(messageTemplate, context, LocaleContextHolder.getLocale());
	}
	@Override
	public String interpolate(String messageTemplate, Context context, Locale locale) {
		String message = replaceParameters(messageTemplate, locale);
		return this.messageInterpolator.interpolate(message, context, locale);
	}
	/**
	 * Recursively replaces all message parameters.
	 * <p>
	 * The message parameter prefix <code>&#123;</code> and suffix <code>&#125;</code> can
	 * be escaped using {@code \}, e.g. <code>\&#123;escaped\&#125;</code>.
	 * @param message the message containing the parameters to be replaced
	 * @param locale the locale to use when resolving replacements
	 * @return the message with parameters replaced
	 */
	private String replaceParameters(String message, Locale locale) {
		return replaceParameters(message, locale, new LinkedHashSet<>(4));
	}
	private String replaceParameters(String message, Locale locale, Set<String> visitedParameters) {
		StringBuilder buf = new StringBuilder(message);
		int parentheses = 0;
		int startIndex = -1;
		int endIndex = -1;
		for (int i = 0; i < buf.length(); i++) {
			if (buf.charAt(i) == ESCAPE) {
				i++;
			}
			else if (buf.charAt(i) == PREFIX) {
				if (startIndex == -1) {
					startIndex = i;
				}
				parentheses++;
			}
			else if (buf.charAt(i) == SUFFIX) {
				if (parentheses > 0) {
					parentheses--;
				}
				endIndex = i;
			}
			if (parentheses == 0 && startIndex < endIndex) {
				String parameter = buf.substring(startIndex + 1, endIndex);
				if (!visitedParameters.add(parameter)) {
					throw new IllegalArgumentException('Circular reference "{' + String.join(' -> ', visitedParameters)
							+ ' -> ' + parameter + '}"');
				}
				String value = replaceParameter(parameter, locale, visitedParameters);
				if (value != null) {
					buf.replace(startIndex, endIndex + 1, value);
					i = startIndex + value.length() - 1;
				}
				visitedParameters.remove(parameter);
				startIndex = -1;
				endIndex = -1;
			}
		}
		return buf.toString();
	}
	private String replaceParameter(String parameter, Locale locale, Set<String> visitedParameters) {
		parameter = replaceParameters(parameter, locale, visitedParameters);
		String value = this.messageSource.getMessage(parameter, null, null, locale);
		return (value != null && !isUsingCodeAsDefaultMessage(value, parameter))
				? replaceParameters(value, locale, visitedParameters) : null;
	}
	private boolean isUsingCodeAsDefaultMessage(String value, String parameter) {
		return value.equals(parameter);
	}
}
/*
package org.springframework.boot.validation.beanvalidation;
/**
public class FilteredMethodValidationPostProcessor extends MethodValidationPostProcessor {
	private final Collection<MethodValidationExcludeFilter> excludeFilters;
	/**
	 * Creates a new {@code FilteredMethodValidationPostProcessor} that will apply the
	 * given {@code excludeFilters} when identifying beans that are eligible for method
	 * validation post-processing.
	 * @param excludeFilters filters to apply
	 */
	public FilteredMethodValidationPostProcessor(Stream<? extends MethodValidationExcludeFilter> excludeFilters) {
		this.excludeFilters = excludeFilters.map(MethodValidationExcludeFilter.class::cast).toList();
	}
	/**
	 * Creates a new {@code FilteredMethodValidationPostProcessor} that will apply the
	 * given {@code excludeFilters} when identifying beans that are eligible for method
	 * validation post-processing.
	 * @param excludeFilters filters to apply
	 */
	public FilteredMethodValidationPostProcessor(Collection<? extends MethodValidationExcludeFilter> excludeFilters) {
		this.excludeFilters = new ArrayList<>(excludeFilters);
	}
	@Override
	public void afterPropertiesSet() {
		super.afterPropertiesSet();
		DefaultPointcutAdvisor advisor = (DefaultPointcutAdvisor) this.advisor;
		ClassFilter classFilter = advisor.getPointcut().getClassFilter();
		MethodMatcher methodMatcher = advisor.getPointcut().getMethodMatcher();
		advisor.setPointcut(new ComposablePointcut(classFilter, methodMatcher).intersection(this::isIncluded));
	}
	private boolean isIncluded(Class<?> candidate) {
		for (MethodValidationExcludeFilter exclusionFilter : this.excludeFilters) {
			if (exclusionFilter.isExcluded(candidate)) {
				return false;
			}
		}
		return true;
	}
}
/*
package org.springframework.boot.validation.beanvalidation;
/**
public interface MethodValidationExcludeFilter {
	/**
	 * Evaluate whether to exclude the given {@code type} from method validation.
	 * @param type the type to evaluate
	 * @return {@code true} to exclude the type from method validation, otherwise
	 * {@code false}.
	 */
	boolean isExcluded(Class<?> type);
	/**
	 * Factory method to create a {@link MethodValidationExcludeFilter} that excludes
	 * classes by annotation found using an {@link SearchStrategy#INHERITED_ANNOTATIONS
	 * inherited annotations search strategy}.
	 * @param annotationType the annotation to check
	 * @return a {@link MethodValidationExcludeFilter} instance
	 */
	static MethodValidationExcludeFilter byAnnotation(Class<? extends Annotation> annotationType) {
		return byAnnotation(annotationType, SearchStrategy.INHERITED_ANNOTATIONS);
	}
	/**
	 * Factory method to create a {@link MethodValidationExcludeFilter} that excludes
	 * classes by annotation found using the given search strategy.
	 * @param annotationType the annotation to check
	 * @param searchStrategy the annotation search strategy
	 * @return a {@link MethodValidationExcludeFilter} instance
	 */
	static MethodValidationExcludeFilter byAnnotation(Class<? extends Annotation> annotationType,
			SearchStrategy searchStrategy) {
		return (type) -> MergedAnnotations.from(type, searchStrategy).isPresent(annotationType);
	}
}
/*
/**
package org.springframework.boot.validation.beanvalidation;
/*
package org.springframework.boot.validation;
/**
public class MessageInterpolatorFactory implements ObjectFactory<MessageInterpolator> {
	private static final Set<String> FALLBACKS;
	static {
		Set<String> fallbacks = new LinkedHashSet<>();
		fallbacks.add('org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator');
		FALLBACKS = Collections.unmodifiableSet(fallbacks);
	}
	private final MessageSource messageSource;
	public MessageInterpolatorFactory() {
		this(null);
	}
	/**
	 * Creates a new {@link MessageInterpolatorFactory} that will produce a
	 * {@link MessageInterpolator} that uses the given {@code messageSource} to resolve
	 * any message parameters before final interpolation.
	 * @param messageSource message source to be used by the interpolator
	 * @since 2.6.0
	 */
	public MessageInterpolatorFactory(MessageSource messageSource) {
		this.messageSource = messageSource;
	}
	@Override
	public MessageInterpolator getObject() throws BeansException {
		MessageInterpolator messageInterpolator = getMessageInterpolator();
		if (this.messageSource != null) {
			return new MessageSourceMessageInterpolator(this.messageSource, messageInterpolator);
		}
		return messageInterpolator;
	}
	private MessageInterpolator getMessageInterpolator() {
		try {
			return Validation.byDefaultProvider().configure().getDefaultMessageInterpolator();
		}
		catch (ValidationException ex) {
			MessageInterpolator fallback = getFallback();
			if (fallback != null) {
				return fallback;
			}
			throw ex;
		}
	}
	private MessageInterpolator getFallback() {
		for (String fallback : FALLBACKS) {
			try {
				return getFallback(fallback);
			}
			catch (Exception ex) {
				// Swallow and continue
			}
		}
		return null;
	}
	private MessageInterpolator getFallback(String fallback) {
		Class<?> interpolatorClass = ClassUtils.resolveClassName(fallback, null);
		Object interpolator = BeanUtils.instantiateClass(interpolatorClass);
		return (MessageInterpolator) interpolator;
	}
}
/*
/**
package org.springframework.boot.validation;
/*
package org.springframework.boot.availability;
/**
public class AvailabilityChangeEvent<S extends AvailabilityState> extends PayloadApplicationEvent<S> {
	/**
	 * Create a new {@link AvailabilityChangeEvent} instance.
	 * @param source the source of the event
	 * @param state the availability state (never {@code null})
	 */
	public AvailabilityChangeEvent(Object source, S state) {
		super(source, state);
	}
	/**
	 * Return the changed availability state.
	 * @return the availability state
	 */
	public S getState() {
		return getPayload();
	}
	@Override
	public ResolvableType getResolvableType() {
		return ResolvableType.forClassWithGenerics(getClass(), getStateType());
	}
	private Class<?> getStateType() {
		S state = getState();
		if (state instanceof Enum<?> enumState) {
			return enumState.getDeclaringClass();
		}
		return state.getClass();
	}
	/**
	 * Convenience method that can be used to publish an {@link AvailabilityChangeEvent}
	 * to the given application context.
	 * @param <S> the availability state type
	 * @param context the context used to publish the event
	 * @param state the changed availability state
	 */
	public static <S extends AvailabilityState> void publish(ApplicationContext context, S state) {
		Assert.notNull(context, 'Context must not be null');
		publish(context, context, state);
	}
	/**
	 * Convenience method that can be used to publish an {@link AvailabilityChangeEvent}
	 * to the given application context.
	 * @param <S> the availability state type
	 * @param publisher the publisher used to publish the event
	 * @param source the source of the event
	 * @param state the changed availability state
	 */
	public static <S extends AvailabilityState> void publish(ApplicationEventPublisher publisher, Object source,
			S state) {
		Assert.notNull(publisher, 'Publisher must not be null');
		publisher.publishEvent(new AvailabilityChangeEvent<>(source, state));
	}
}
/*
package org.springframework.boot.availability;
/**
public enum ReadinessState implements AvailabilityState {
	/**
	 * The application is ready to receive traffic.
	 */
	ACCEPTING_TRAFFIC,
	/**
	 * The application is not willing to receive traffic.
	 */
	REFUSING_TRAFFIC
}
/*
package org.springframework.boot.availability;
/**
public interface ApplicationAvailability {
	/**
	 * Return the {@link LivenessState} of the application.
	 * @return the liveness state
	 */
	default LivenessState getLivenessState() {
		return getState(LivenessState.class, LivenessState.BROKEN);
	}
	/**
	 * Return the {@link ReadinessState} of the application.
	 * @return the readiness state
	 */
	default ReadinessState getReadinessState() {
		return getState(ReadinessState.class, ReadinessState.REFUSING_TRAFFIC);
	}
	/**
	 * Return {@link AvailabilityState} information for the application.
	 * @param <S> the state type
	 * @param stateType the state type
	 * @param defaultState the default state to return if no event of the given type has
	 * been published yet (must not be {@code null}).
	 * @return the readiness state
	 * @see #getState(Class)
	 */
	<S extends AvailabilityState> S getState(Class<S> stateType, S defaultState);
	/**
	 * Return {@link AvailabilityState} information for the application.
	 * @param <S> the state type
	 * @param stateType the state type
	 * @return the readiness state or {@code null} if no event of the given type has been
	 * published yet
	 * @see #getState(Class, AvailabilityState)
	 */
	<S extends AvailabilityState> S getState(Class<S> stateType);
	/**
	 * Return the last {@link AvailabilityChangeEvent} received for a given state type.
	 * @param <S> the state type
	 * @param stateType the state type
	 * @return the readiness state or {@code null} if no event of the given type has been
	 * published yet
	 */
	<S extends AvailabilityState> AvailabilityChangeEvent<S> getLastChangeEvent(Class<S> stateType);
}
/*
package org.springframework.boot.availability;
/**
public interface AvailabilityState {
}
/*
package org.springframework.boot.availability;
/**
public class ApplicationAvailabilityBean
		implements ApplicationAvailability, ApplicationListener<AvailabilityChangeEvent<?>> {
	private final Map<Class<? extends AvailabilityState>, AvailabilityChangeEvent<?>> events = new ConcurrentHashMap<>();
	private final Log logger;
	public ApplicationAvailabilityBean() {
		this(LogFactory.getLog(ApplicationAvailabilityBean.class));
	}
	ApplicationAvailabilityBean(Log logger) {
		this.logger = logger;
	}
	@Override
	public <S extends AvailabilityState> S getState(Class<S> stateType, S defaultState) {
		Assert.notNull(stateType, 'StateType must not be null');
		Assert.notNull(defaultState, 'DefaultState must not be null');
		S state = getState(stateType);
		return (state != null) ? state : defaultState;
	}
	@Override
	public <S extends AvailabilityState> S getState(Class<S> stateType) {
		AvailabilityChangeEvent<S> event = getLastChangeEvent(stateType);
		return (event != null) ? event.getState() : null;
	}
	@Override
	@SuppressWarnings('unchecked')
	public <S extends AvailabilityState> AvailabilityChangeEvent<S> getLastChangeEvent(Class<S> stateType) {
		return (AvailabilityChangeEvent<S>) this.events.get(stateType);
	}
	@Override
	public void onApplicationEvent(AvailabilityChangeEvent<?> event) {
		Class<? extends AvailabilityState> type = getStateType(event.getState());
		if (this.logger.isDebugEnabled()) {
			this.logger.debug(getLogMessage(type, event));
		}
		this.events.put(type, event);
	}
	private <S extends AvailabilityState> Object getLogMessage(Class<S> type, AvailabilityChangeEvent<?> event) {
		AvailabilityChangeEvent<S> lastChangeEvent = getLastChangeEvent(type);
		StringBuilder message = new StringBuilder(
				'Application availability state ' + type.getSimpleName() + ' changed');
		message.append((lastChangeEvent != null) ? ' from ' + lastChangeEvent.getState() : '');
		message.append(' to ' + event.getState());
		message.append(getSourceDescription(event.getSource()));
		return message;
	}
	private String getSourceDescription(Object source) {
		if (source == null || source instanceof ApplicationEventPublisher) {
			return '';
		}
		return ': ' + ((source instanceof Throwable) ? source : source.getClass().getName());
	}
	@SuppressWarnings('unchecked')
	private Class<? extends AvailabilityState> getStateType(AvailabilityState state) {
		Class<?> type = (state instanceof Enum<?> enumState) ? enumState.getDeclaringClass() : state.getClass();
		return (Class<? extends AvailabilityState>) type;
	}
}
/*
/**
package org.springframework.boot.availability;
/*
package org.springframework.boot.availability;
/**
public enum LivenessState implements AvailabilityState {
	/**
	 * The application is running and its internal state is correct.
	 */
	CORRECT,
	/**
	 * The application is running but its internal state is broken.
	 */
	BROKEN
}
/*
package org.springframework.boot.sql.init;
/**
public class DatabaseInitializationSettings {
	private List<String> schemaLocations;
	private List<String> dataLocations;
	private boolean continueOnError = false;
	private String separator = ';';
	private Charset encoding;
	private DatabaseInitializationMode mode = DatabaseInitializationMode.EMBEDDED;
	/**
	 * Returns the locations of the schema (DDL) scripts to apply to the database.
	 * @return the locations of the schema scripts
	 */
	public List<String> getSchemaLocations() {
		return this.schemaLocations;
	}
	/**
	 * Sets the locations of schema (DDL) scripts to apply to the database. By default,
	 * initialization will fail if a location does not exist. To prevent a failure, a
	 * location can be made optional by prefixing it with {@code optional:}.
	 * @param schemaLocations locations of the schema scripts
	 */
	public void setSchemaLocations(List<String> schemaLocations) {
		this.schemaLocations = schemaLocations;
	}
	/**
	 * Returns the locations of data (DML) scripts to apply to the database.
	 * @return the locations of the data scripts
	 */
	public List<String> getDataLocations() {
		return this.dataLocations;
	}
	/**
	 * Sets the locations of data (DML) scripts to apply to the database. By default,
	 * initialization will fail if a location does not exist. To prevent a failure, a
	 * location can be made optional by prefixing it with {@code optional:}.
	 * @param dataLocations locations of the data scripts
	 */
	public void setDataLocations(List<String> dataLocations) {
		this.dataLocations = dataLocations;
	}
	/**
	 * Returns whether to continue when an error occurs while applying a schema or data
	 * script.
	 * @return whether to continue on error
	 */
	public boolean isContinueOnError() {
		return this.continueOnError;
	}
	/**
	 * Sets whether initialization should continue when an error occurs when applying a
	 * schema or data script.
	 * @param continueOnError whether to continue when an error occurs.
	 */
	public void setContinueOnError(boolean continueOnError) {
		this.continueOnError = continueOnError;
	}
	/**
	 * Returns the statement separator used in the schema and data scripts.
	 * @return the statement separator
	 */
	public String getSeparator() {
		return this.separator;
	}
	/**
	 * Sets the statement separator to use when reading the schema and data scripts.
	 * @param separator statement separator used in the schema and data scripts
	 */
	public void setSeparator(String separator) {
		this.separator = separator;
	}
	/**
	 * Returns the encoding to use when reading the schema and data scripts.
	 * @return the script encoding
	 */
	public Charset getEncoding() {
		return this.encoding;
	}
	/**
	 * Sets the encoding to use when reading the schema and data scripts.
	 * @param encoding encoding to use when reading the schema and data scripts
	 */
	public void setEncoding(Charset encoding) {
		this.encoding = encoding;
	}
	/**
	 * Gets the mode to use when determining whether database initialization should be
	 * performed.
	 * @return the initialization mode
	 * @since 2.5.1
	 */
	public DatabaseInitializationMode getMode() {
		return this.mode;
	}
	/**
	 * Sets the mode the use when determining whether database initialization should be
	 * performed.
	 * @param mode the initialization mode
	 * @since 2.5.1
	 */
	public void setMode(DatabaseInitializationMode mode) {
		this.mode = mode;
	}
}
/*
package org.springframework.boot.sql.init;
/**
public enum DatabaseInitializationMode {
	/**
	 * Always initialize the database.
	 */
	ALWAYS,
	/**
	 * Only initialize an embedded database.
	 */
	EMBEDDED,
	/**
	 * Never initialize the database.
	 */
	NEVER
}
/*
package org.springframework.boot.sql.init;
/**
public abstract class AbstractScriptDatabaseInitializer implements ResourceLoaderAware, InitializingBean {
	private static final String OPTIONAL_LOCATION_PREFIX = 'optional:';
	private final DatabaseInitializationSettings settings;
	private volatile ResourceLoader resourceLoader;
	/**
	 * Creates a new {@link AbstractScriptDatabaseInitializer} that will initialize the
	 * database using the given settings.
	 * @param settings initialization settings
	 */
	protected AbstractScriptDatabaseInitializer(DatabaseInitializationSettings settings) {
		this.settings = settings;
	}
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		initializeDatabase();
	}
	/**
	 * Initializes the database by applying schema and data scripts.
	 * @return {@code true} if one or more scripts were applied to the database, otherwise
	 * {@code false}
	 */
	public boolean initializeDatabase() {
		ScriptLocationResolver locationResolver = new ScriptLocationResolver(this.resourceLoader);
		boolean initialized = applySchemaScripts(locationResolver);
		return applyDataScripts(locationResolver) || initialized;
	}
	private boolean isEnabled() {
		if (this.settings.getMode() == DatabaseInitializationMode.NEVER) {
			return false;
		}
		return this.settings.getMode() == DatabaseInitializationMode.ALWAYS || isEmbeddedDatabase();
	}
	/**
	 * Returns whether the database that is to be initialized is embedded.
	 * @return {@code true} if the database is embedded, otherwise {@code false}
	 * @since 2.5.1
	 */
	protected boolean isEmbeddedDatabase() {
		throw new IllegalStateException(
				'Database initialization mode is "' + this.settings.getMode() + '" and database type is unknown');
	}
	private boolean applySchemaScripts(ScriptLocationResolver locationResolver) {
		return applyScripts(this.settings.getSchemaLocations(), 'schema', locationResolver);
	}
	private boolean applyDataScripts(ScriptLocationResolver locationResolver) {
		return applyScripts(this.settings.getDataLocations(), 'data', locationResolver);
	}
	private boolean applyScripts(List<String> locations, String type, ScriptLocationResolver locationResolver) {
		List<Resource> scripts = getScripts(locations, type, locationResolver);
		if (!scripts.isEmpty() && isEnabled()) {
			runScripts(scripts);
			return true;
		}
		return false;
	}
	private List<Resource> getScripts(List<String> locations, String type, ScriptLocationResolver locationResolver) {
		if (CollectionUtils.isEmpty(locations)) {
			return Collections.emptyList();
		}
		List<Resource> resources = new ArrayList<>();
		for (String location : locations) {
			boolean optional = location.startsWith(OPTIONAL_LOCATION_PREFIX);
			if (optional) {
				location = location.substring(OPTIONAL_LOCATION_PREFIX.length());
			}
			for (Resource resource : doGetResources(location, locationResolver)) {
				if (resource.isReadable()) {
					resources.add(resource);
				}
				else if (!optional) {
					throw new IllegalStateException('No ' + type + ' scripts found at location "' + location + '"');
				}
			}
		}
		return resources;
	}
	private List<Resource> doGetResources(String location, ScriptLocationResolver locationResolver) {
		try {
			return locationResolver.resolve(location);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to load resources from ' + location, ex);
		}
	}
	private void runScripts(List<Resource> resources) {
		runScripts(new Scripts(resources).continueOnError(this.settings.isContinueOnError())
			.separator(this.settings.getSeparator())
			.encoding(this.settings.getEncoding()));
	}
	/**
	 * Initialize the database by running the given {@code scripts}.
	 * @param scripts the scripts to run
	 * @since 3.0.0
	 */
	protected abstract void runScripts(Scripts scripts);
	private static class ScriptLocationResolver {
		private final ResourcePatternResolver resourcePatternResolver;
		ScriptLocationResolver(ResourceLoader resourceLoader) {
			this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);
		}
		private List<Resource> resolve(String location) throws IOException {
			List<Resource> resources = new ArrayList<>(
					Arrays.asList(this.resourcePatternResolver.getResources(location)));
			resources.sort((r1, r2) -> {
				try {
					return r1.getURL().toString().compareTo(r2.getURL().toString());
				}
				catch (IOException ex) {
					return 0;
				}
			});
			return resources;
		}
	}
	/**
	 * Scripts to be used to initialize the database.
	 *
	 * @since 3.0.0
	 */
	public static class Scripts implements Iterable<Resource> {
		private final List<Resource> resources;
		private boolean continueOnError = false;
		private String separator = ';';
		private Charset encoding;
		public Scripts(List<Resource> resources) {
			this.resources = resources;
		}
		@Override
		public Iterator<Resource> iterator() {
			return this.resources.iterator();
		}
		public Scripts continueOnError(boolean continueOnError) {
			this.continueOnError = continueOnError;
			return this;
		}
		public boolean isContinueOnError() {
			return this.continueOnError;
		}
		public Scripts separator(String separator) {
			this.separator = separator;
			return this;
		}
		public String getSeparator() {
			return this.separator;
		}
		public Scripts encoding(Charset encoding) {
			this.encoding = encoding;
			return this;
		}
		public Charset getEncoding() {
			return this.encoding;
		}
	}
}
/*
/**
package org.springframework.boot.sql.init;
/*
package org.springframework.boot.sql.init.dependency;
/**
class AnnotationDependsOnDatabaseInitializationDetector implements DependsOnDatabaseInitializationDetector {
	@Override
	public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
		Set<String> dependentBeans = new HashSet<>();
		for (String beanName : beanFactory.getBeanDefinitionNames()) {
			if (beanFactory.findAnnotationOnBean(beanName, DependsOnDatabaseInitialization.class, false) != null) {
				dependentBeans.add(beanName);
			}
		}
		return dependentBeans;
	}
}
/*
package org.springframework.boot.sql.init.dependency;
/**
public class DatabaseInitializationDependencyConfigurer implements ImportBeanDefinitionRegistrar {
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		String name = DependsOnDatabaseInitializationPostProcessor.class.getName();
		if (!registry.containsBeanDefinition(name)) {
			BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(DependsOnDatabaseInitializationPostProcessor.class);
			registry.registerBeanDefinition(name, builder.getBeanDefinition());
		}
	}
	/**
	 * {@link BeanFactoryPostProcessor} used to configure database initialization
	 * dependency relationships.
	 */
	static class DependsOnDatabaseInitializationPostProcessor
			implements BeanFactoryPostProcessor, EnvironmentAware, Ordered {
		private Environment environment;
		@Override
		public void setEnvironment(Environment environment) {
			this.environment = environment;
		}
		@Override
		public int getOrder() {
			return 0;
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
			if (AotDetector.useGeneratedArtifacts()) {
				return;
			}
			InitializerBeanNames initializerBeanNames = detectInitializerBeanNames(beanFactory);
			if (initializerBeanNames.isEmpty()) {
				return;
			}
			Set<String> previousInitializerBeanNamesBatch = null;
			for (Set<String> initializerBeanNamesBatch : initializerBeanNames.batchedBeanNames()) {
				for (String initializerBeanName : initializerBeanNamesBatch) {
					BeanDefinition beanDefinition = getBeanDefinition(initializerBeanName, beanFactory);
					beanDefinition
						.setDependsOn(merge(beanDefinition.getDependsOn(), previousInitializerBeanNamesBatch));
				}
				previousInitializerBeanNamesBatch = initializerBeanNamesBatch;
			}
			for (String dependsOnInitializationBeanNames : detectDependsOnInitializationBeanNames(beanFactory)) {
				BeanDefinition beanDefinition = getBeanDefinition(dependsOnInitializationBeanNames, beanFactory);
				beanDefinition.setDependsOn(merge(beanDefinition.getDependsOn(), initializerBeanNames.beanNames()));
			}
		}
		private String[] merge(String[] source, Set<String> additional) {
			if (CollectionUtils.isEmpty(additional)) {
				return source;
			}
			Set<String> result = new LinkedHashSet<>((source != null) ? Arrays.asList(source) : Collections.emptySet());
			result.addAll(additional);
			return StringUtils.toStringArray(result);
		}
		private InitializerBeanNames detectInitializerBeanNames(ConfigurableListableBeanFactory beanFactory) {
			List<DatabaseInitializerDetector> detectors = getDetectors(beanFactory, DatabaseInitializerDetector.class);
			InitializerBeanNames initializerBeanNames = new InitializerBeanNames();
			for (DatabaseInitializerDetector detector : detectors) {
				for (String beanName : detector.detect(beanFactory)) {
					BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
					beanDefinition.setAttribute(DatabaseInitializerDetector.class.getName(),
							detector.getClass().getName());
					initializerBeanNames.detected(detector, beanName);
				}
			}
			for (DatabaseInitializerDetector detector : detectors) {
				detector.detectionComplete(beanFactory, initializerBeanNames.beanNames());
			}
			return initializerBeanNames;
		}
		private Collection<String> detectDependsOnInitializationBeanNames(ConfigurableListableBeanFactory beanFactory) {
			List<DependsOnDatabaseInitializationDetector> detectors = getDetectors(beanFactory,
					DependsOnDatabaseInitializationDetector.class);
			Set<String> beanNames = new HashSet<>();
			for (DependsOnDatabaseInitializationDetector detector : detectors) {
				beanNames.addAll(detector.detect(beanFactory));
			}
			return beanNames;
		}
		private <T> List<T> getDetectors(ConfigurableListableBeanFactory beanFactory, Class<T> type) {
			ArgumentResolver argumentResolver = ArgumentResolver.of(Environment.class, this.environment);
			return SpringFactoriesLoader.forDefaultResourceLocation(beanFactory.getBeanClassLoader())
				.load(type, argumentResolver);
		}
		private static BeanDefinition getBeanDefinition(String beanName, ConfigurableListableBeanFactory beanFactory) {
			try {
				return beanFactory.getBeanDefinition(beanName);
			}
			catch (NoSuchBeanDefinitionException ex) {
				BeanFactory parentBeanFactory = beanFactory.getParentBeanFactory();
				if (parentBeanFactory instanceof ConfigurableListableBeanFactory configurableBeanFactory) {
					return getBeanDefinition(beanName, configurableBeanFactory);
				}
				throw ex;
			}
		}
		static class InitializerBeanNames {
			private final Map<DatabaseInitializerDetector, Set<String>> byDetectorBeanNames = new LinkedHashMap<>();
			private final Set<String> beanNames = new LinkedHashSet<>();
			private void detected(DatabaseInitializerDetector detector, String beanName) {
				this.byDetectorBeanNames.computeIfAbsent(detector, (key) -> new LinkedHashSet<>()).add(beanName);
				this.beanNames.add(beanName);
			}
			private boolean isEmpty() {
				return this.beanNames.isEmpty();
			}
			private Iterable<Set<String>> batchedBeanNames() {
				return this.byDetectorBeanNames.values();
			}
			private Set<String> beanNames() {
				return Collections.unmodifiableSet(this.beanNames);
			}
		}
	}
}
/*
package org.springframework.boot.sql.init.dependency;
/**
public interface DatabaseInitializerDetector extends Ordered {
	/**
	 * Detect beans defined in the given {@code beanFactory} that initialize a
	 * {@link DataSource}.
	 * @param beanFactory bean factory to examine
	 * @return names of the detected {@code DataSource} initializer beans, or an empty set
	 * if none were detected.
	 */
	Set<String> detect(ConfigurableListableBeanFactory beanFactory);
	/**
	 * Callback indicating that all known {@code DataSourceInitializerDetectors} have been
	 * called and detection of beans that initialize a {@link DataSource} is complete.
	 * @param beanFactory bean factory that was examined
	 * @param dataSourceInitializerNames names of the {@code DataSource} initializer beans
	 * detected by all known detectors
	 */
	default void detectionComplete(ConfigurableListableBeanFactory beanFactory,
			Set<String> dataSourceInitializerNames) {
	}
	@Override
	default int getOrder() {
		return 0;
	}
}
/*
package org.springframework.boot.sql.init.dependency;
/**
class BeansOfTypeDetector {
	private final Set<Class<?>> types;
	BeansOfTypeDetector(Set<Class<?>> types) {
		this.types = types;
	}
	Set<String> detect(ListableBeanFactory beanFactory) {
		Set<String> beanNames = new HashSet<>();
		for (Class<?> type : this.types) {
			try {
				String[] names = beanFactory.getBeanNamesForType(type, true, false);
				Arrays.stream(names).map(BeanFactoryUtils::transformedBeanName).forEach(beanNames::add);
			}
			catch (Throwable ex) {
				// Continue
			}
		}
		return beanNames;
	}
}
/*
package org.springframework.boot.sql.init.dependency;
/**
public interface DependsOnDatabaseInitializationDetector {
	/**
	 * Detect beans defined in the given {@code beanFactory} that depend on database
	 * initialization. If no beans are detected, an empty set is returned.
	 * @param beanFactory bean factory to examine
	 * @return names of any beans that depend upon database initialization
	 */
	Set<String> detect(ConfigurableListableBeanFactory beanFactory);
}
/*
package org.springframework.boot.sql.init.dependency;
/**
public abstract class AbstractBeansOfTypeDatabaseInitializerDetector implements DatabaseInitializerDetector {
	@Override
	public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
		try {
			Set<Class<?>> types = getDatabaseInitializerBeanTypes();
			return new BeansOfTypeDetector(types).detect(beanFactory);
		}
		catch (Throwable ex) {
			return Collections.emptySet();
		}
	}
	/**
	 * Returns the bean types that should be detected as being database initializers.
	 * @return the database initializer bean types
	 */
	protected abstract Set<Class<?>> getDatabaseInitializerBeanTypes();
}
/*
package org.springframework.boot.sql.init.dependency;
/**
public abstract class AbstractBeansOfTypeDependsOnDatabaseInitializationDetector
		implements DependsOnDatabaseInitializationDetector {
	@Override
	public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
		try {
			Set<Class<?>> types = getDependsOnDatabaseInitializationBeanTypes();
			return new BeansOfTypeDetector(types).detect(beanFactory);
		}
		catch (Throwable ex) {
			return Collections.emptySet();
		}
	}
	/**
	 * Returns the bean types that should be detected as depending on database
	 * initialization.
	 * @return the database initialization dependent bean types
	 */
	protected abstract Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes();
}
/*
/**
package org.springframework.boot.sql.init.dependency;
/*
package org.springframework.boot.sql.init.dependency;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DependsOnDatabaseInitialization {
}
/*
package org.springframework.boot;
/**
public class DefaultPropertiesPropertySource extends MapPropertySource {
	/**
	 * The name of the "default properties" property source.
	 */
	public static final String NAME = 'defaultProperties';
	/**
	 * Create a new {@link DefaultPropertiesPropertySource} with the given {@code Map}
	 * source.
	 * @param source the source map
	 */
	public DefaultPropertiesPropertySource(Map<String, Object> source) {
		super(NAME, source);
	}
	/**
	 * Return {@code true} if the given source is named "defaultProperties".
	 * @param propertySource the property source to check
	 * @return {@code true} if the name matches
	 */
	public static boolean hasMatchingName(PropertySource<?> propertySource) {
		return (propertySource != null) && propertySource.getName().equals(NAME);
	}
	/**
	 * Create a new {@link DefaultPropertiesPropertySource} instance if the provided
	 * source is not empty.
	 * @param source the {@code Map} source
	 * @param action the action used to consume the
	 * {@link DefaultPropertiesPropertySource}
	 */
	public static void ifNotEmpty(Map<String, Object> source, Consumer<DefaultPropertiesPropertySource> action) {
		if (!CollectionUtils.isEmpty(source) && action != null) {
			action.accept(new DefaultPropertiesPropertySource(source));
		}
	}
	/**
	 * Add a new {@link DefaultPropertiesPropertySource} or merge with an existing one.
	 * @param source the {@code Map} source
	 * @param sources the existing sources
	 * @since 2.4.4
	 */
	public static void addOrMerge(Map<String, Object> source, MutablePropertySources sources) {
		if (!CollectionUtils.isEmpty(source)) {
			Map<String, Object> resultingSource = new HashMap<>();
			DefaultPropertiesPropertySource propertySource = new DefaultPropertiesPropertySource(resultingSource);
			if (sources.contains(NAME)) {
				mergeIfPossible(source, sources, resultingSource);
				sources.replace(NAME, propertySource);
			}
			else {
				resultingSource.putAll(source);
				sources.addLast(propertySource);
			}
		}
	}
	@SuppressWarnings('unchecked')
	private static void mergeIfPossible(Map<String, Object> source, MutablePropertySources sources,
			Map<String, Object> resultingSource) {
		PropertySource<?> existingSource = sources.get(NAME);
		if (existingSource != null) {
			Object underlyingSource = existingSource.getSource();
			if (underlyingSource instanceof Map) {
				resultingSource.putAll((Map<String, Object>) underlyingSource);
			}
			resultingSource.putAll(source);
		}
	}
	/**
	 * Move the "defaultProperties" property source so that it"s the last source in the
	 * given {@link ConfigurableEnvironment}.
	 * @param environment the environment to update
	 */
	public static void moveToEnd(ConfigurableEnvironment environment) {
		moveToEnd(environment.getPropertySources());
	}
	/**
	 * Move the "defaultProperties" property source so that it"s the last source in the
	 * given {@link MutablePropertySources}.
	 * @param propertySources the property sources to update
	 */
	public static void moveToEnd(MutablePropertySources propertySources) {
		PropertySource<?> propertySource = propertySources.remove(NAME);
		if (propertySource != null) {
			propertySources.addLast(propertySource);
		}
	}
}
/*
package org.springframework.boot;
/**
class ApplicationInfoPropertySource extends MapPropertySource {
	static final String NAME = 'applicationInfo';
	ApplicationInfoPropertySource(Class<?> mainClass) {
		super(NAME, getProperties(readVersion(mainClass)));
	}
	ApplicationInfoPropertySource(String applicationVersion) {
		super(NAME, getProperties(applicationVersion));
	}
	private static Map<String, Object> getProperties(String applicationVersion) {
		Map<String, Object> result = new HashMap<>();
		if (StringUtils.hasText(applicationVersion)) {
			result.put('spring.application.version', applicationVersion);
		}
		ApplicationPid applicationPid = new ApplicationPid();
		if (applicationPid.isAvailable()) {
			result.put('spring.application.pid', applicationPid.toLong());
		}
		return result;
	}
	private static String readVersion(Class<?> applicationClass) {
		Package sourcePackage = (applicationClass != null) ? applicationClass.getPackage() : null;
		return (sourcePackage != null) ? sourcePackage.getImplementationVersion() : null;
	}
	/**
	 * Moves the {@link ApplicationInfoPropertySource} to the end of the environment"s
	 * property sources.
	 * @param environment the environment
	 */
	static void moveToEnd(ConfigurableEnvironment environment) {
		MutablePropertySources propertySources = environment.getPropertySources();
		PropertySource<?> propertySource = propertySources.remove(NAME);
		if (propertySource != null) {
			propertySources.addLast(propertySource);
		}
	}
}
/*
package org.springframework.boot.security.servlet;
/**
public abstract class ApplicationContextRequestMatcher<C> implements RequestMatcher {
	private final Class<? extends C> contextClass;
	private volatile boolean initialized;
	private final Object initializeLock = new Object();
	public ApplicationContextRequestMatcher(Class<? extends C> contextClass) {
		Assert.notNull(contextClass, 'Context class must not be null');
		this.contextClass = contextClass;
	}
	@Override
	public final boolean matches(HttpServletRequest request) {
		WebApplicationContext webApplicationContext = WebApplicationContextUtils
			.getRequiredWebApplicationContext(request.getServletContext());
		if (ignoreApplicationContext(webApplicationContext)) {
			return false;
		}
		Supplier<C> context = () -> getContext(webApplicationContext);
		if (!this.initialized) {
			synchronized (this.initializeLock) {
				if (!this.initialized) {
					initialized(context);
					this.initialized = true;
				}
			}
		}
		return matches(request, context);
	}
	@SuppressWarnings('unchecked')
	private C getContext(WebApplicationContext webApplicationContext) {
		if (this.contextClass.isInstance(webApplicationContext)) {
			return (C) webApplicationContext;
		}
		return webApplicationContext.getBean(this.contextClass);
	}
	/**
	 * Returns if the {@link WebApplicationContext} should be ignored and not used for
	 * matching. If this method returns {@code true} then the context will not be used and
	 * the {@link #matches(HttpServletRequest) matches} method will return {@code false}.
	 * @param webApplicationContext the candidate web application context
	 * @return if the application context should be ignored
	 * @since 2.1.8
	 */
	protected boolean ignoreApplicationContext(WebApplicationContext webApplicationContext) {
		return false;
	}
	/**
	 * Method that can be implemented by subclasses that wish to initialize items the
	 * first time that the matcher is called. This method will be called only once and
	 * only if {@link #ignoreApplicationContext(WebApplicationContext)} returns
	 * {@code false}. Note that the supplied context will be based on the
	 * <strong>first</strong> request sent to the matcher.
	 * @param context a supplier for the initialized context (may throw an exception)
	 * @see #ignoreApplicationContext(WebApplicationContext)
	 */
	protected void initialized(Supplier<C> context) {
	}
	/**
	 * Decides whether the rule implemented by the strategy matches the supplied request.
	 * @param request the source request
	 * @param context a supplier for the initialized context (may throw an exception)
	 * @return if the request matches
	 */
	protected abstract boolean matches(HttpServletRequest request, Supplier<C> context);
}
/*
/**
package org.springframework.boot.security.servlet;
/*
/**
package org.springframework.boot.security;
/*
package org.springframework.boot.security.reactive;
/**
public abstract class ApplicationContextServerWebExchangeMatcher<C> implements ServerWebExchangeMatcher {
	private final Class<? extends C> contextClass;
	private volatile Supplier<C> context;
	private final Object contextLock = new Object();
	public ApplicationContextServerWebExchangeMatcher(Class<? extends C> contextClass) {
		Assert.notNull(contextClass, 'Context class must not be null');
		this.contextClass = contextClass;
	}
	@Override
	public final Mono<MatchResult> matches(ServerWebExchange exchange) {
		if (ignoreApplicationContext(exchange.getApplicationContext())) {
			return MatchResult.notMatch();
		}
		return matches(exchange, getContext(exchange));
	}
	/**
	 * Decides whether the rule implemented by the strategy matches the supplied exchange.
	 * @param exchange the source exchange
	 * @param context a supplier for the initialized context (may throw an exception)
	 * @return if the exchange matches
	 */
	protected abstract Mono<MatchResult> matches(ServerWebExchange exchange, Supplier<C> context);
	/**
	 * Returns if the {@link ApplicationContext} should be ignored and not used for
	 * matching. If this method returns {@code true} then the context will not be used and
	 * the {@link #matches(ServerWebExchange) matches} method will return {@code false}.
	 * @param applicationContext the candidate application context
	 * @return if the application context should be ignored
	 * @since 2.2.5
	 */
	protected boolean ignoreApplicationContext(ApplicationContext applicationContext) {
		return false;
	}
	protected Supplier<C> getContext(ServerWebExchange exchange) {
		if (this.context == null) {
			synchronized (this.contextLock) {
				if (this.context == null) {
					Supplier<C> createdContext = createContext(exchange);
					initialized(createdContext);
					this.context = createdContext;
				}
			}
		}
		return this.context;
	}
	/**
	 * Called once the context has been initialized.
	 * @param context a supplier for the initialized context (may throw an exception)
	 */
	protected void initialized(Supplier<C> context) {
	}
	@SuppressWarnings('unchecked')
	private Supplier<C> createContext(ServerWebExchange exchange) {
		ApplicationContext context = exchange.getApplicationContext();
		Assert.state(context != null, 'No ApplicationContext found on ServerWebExchange.');
		if (this.contextClass.isInstance(context)) {
			return () -> (C) context;
		}
		return () -> context.getBean(this.contextClass);
	}
}
/*
/**
package org.springframework.boot.security.reactive;
/*
package org.springframework.boot;
/**
public class DefaultApplicationArguments implements ApplicationArguments {
	private final Source source;
	private final String[] args;
	public DefaultApplicationArguments(String... args) {
		Assert.notNull(args, 'Args must not be null');
		this.source = new Source(args);
		this.args = args;
	}
	@Override
	public String[] getSourceArgs() {
		return this.args;
	}
	@Override
	public Set<String> getOptionNames() {
		String[] names = this.source.getPropertyNames();
		return Collections.unmodifiableSet(new HashSet<>(Arrays.asList(names)));
	}
	@Override
	public boolean containsOption(String name) {
		return this.source.containsProperty(name);
	}
	@Override
	public List<String> getOptionValues(String name) {
		List<String> values = this.source.getOptionValues(name);
		return (values != null) ? Collections.unmodifiableList(values) : null;
	}
	@Override
	public List<String> getNonOptionArgs() {
		return this.source.getNonOptionArgs();
	}
	private static class Source extends SimpleCommandLinePropertySource {
		Source(String[] args) {
			super(args);
		}
		@Override
		public List<String> getNonOptionArgs() {
			return super.getNonOptionArgs();
		}
		@Override
		public List<String> getOptionValues(String name) {
			return super.getOptionValues(name);
		}
	}
}
/*
package org.springframework.boot;
/**
class SpringApplicationBannerPrinter {
	static final String BANNER_LOCATION_PROPERTY = 'spring.banner.location';
	static final String DEFAULT_BANNER_LOCATION = 'banner.txt';
	private static final Banner DEFAULT_BANNER = new SpringBootBanner();
	private final ResourceLoader resourceLoader;
	private final Banner fallbackBanner;
	SpringApplicationBannerPrinter(ResourceLoader resourceLoader, Banner fallbackBanner) {
		this.resourceLoader = resourceLoader;
		this.fallbackBanner = fallbackBanner;
	}
	Banner print(Environment environment, Class<?> sourceClass, Log logger) {
		Banner banner = getBanner(environment);
		try {
			logger.info(createStringFromBanner(banner, environment, sourceClass));
		}
		catch (UnsupportedEncodingException ex) {
			logger.warn('Failed to create String for banner', ex);
		}
		return new PrintedBanner(banner, sourceClass);
	}
	Banner print(Environment environment, Class<?> sourceClass, PrintStream out) {
		Banner banner = getBanner(environment);
		banner.printBanner(environment, sourceClass, out);
		return new PrintedBanner(banner, sourceClass);
	}
	private Banner getBanner(Environment environment) {
		Banner textBanner = getTextBanner(environment);
		if (textBanner != null) {
			return textBanner;
		}
		if (this.fallbackBanner != null) {
			return this.fallbackBanner;
		}
		return DEFAULT_BANNER;
	}
	private Banner getTextBanner(Environment environment) {
		String location = environment.getProperty(BANNER_LOCATION_PROPERTY, DEFAULT_BANNER_LOCATION);
		Resource resource = this.resourceLoader.getResource(location);
		try {
			if (resource.exists() && !resource.getURL().toExternalForm().contains('liquibase-core')) {
				return new ResourceBanner(resource);
			}
		}
		catch (IOException ex) {
			// Ignore
		}
		return null;
	}
	private String createStringFromBanner(Banner banner, Environment environment, Class<?> mainApplicationClass)
			throws UnsupportedEncodingException {
		String charset = environment.getProperty('spring.banner.charset', StandardCharsets.UTF_8.name());
		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
		try (PrintStream out = new PrintStream(byteArrayOutputStream, false, charset)) {
			banner.printBanner(environment, mainApplicationClass, out);
		}
		return byteArrayOutputStream.toString(charset);
	}
	/**
	 * Decorator that allows a {@link Banner} to be printed again without needing to
	 * specify the source class.
	 */
	private static class PrintedBanner implements Banner {
		private final Banner banner;
		private final Class<?> sourceClass;
		PrintedBanner(Banner banner, Class<?> sourceClass) {
			this.banner = banner;
			this.sourceClass = sourceClass;
		}
		@Override
		public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
			sourceClass = (sourceClass != null) ? sourceClass : this.sourceClass;
			this.banner.printBanner(environment, sourceClass, out);
		}
	}
	static class SpringApplicationBannerPrinterRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern(DEFAULT_BANNER_LOCATION);
		}
	}
}
/*
package org.springframework.boot.type.classreading;
/**
public class ConcurrentReferenceCachingMetadataReaderFactory extends SimpleMetadataReaderFactory {
	private final Map<Resource, MetadataReader> cache = new ConcurrentReferenceHashMap<>();
	/**
	 * Create a new {@link ConcurrentReferenceCachingMetadataReaderFactory} instance for
	 * the default class loader.
	 */
	public ConcurrentReferenceCachingMetadataReaderFactory() {
	}
	/**
	 * Create a new {@link ConcurrentReferenceCachingMetadataReaderFactory} instance for
	 * the given resource loader.
	 * @param resourceLoader the Spring ResourceLoader to use (also determines the
	 * ClassLoader to use)
	 */
	public ConcurrentReferenceCachingMetadataReaderFactory(ResourceLoader resourceLoader) {
		super(resourceLoader);
	}
	/**
	 * Create a new {@link ConcurrentReferenceCachingMetadataReaderFactory} instance for
	 * the given class loader.
	 * @param classLoader the ClassLoader to use
	 */
	public ConcurrentReferenceCachingMetadataReaderFactory(ClassLoader classLoader) {
		super(classLoader);
	}
	@Override
	public MetadataReader getMetadataReader(Resource resource) throws IOException {
		MetadataReader metadataReader = this.cache.get(resource);
		if (metadataReader == null) {
			metadataReader = createMetadataReader(resource);
			this.cache.put(resource, metadataReader);
		}
		return metadataReader;
	}
	/**
	 * Create the meta-data reader.
	 * @param resource the source resource.
	 * @return the meta-data reader
	 * @throws IOException on error
	 */
	protected MetadataReader createMetadataReader(Resource resource) throws IOException {
		return super.getMetadataReader(resource);
	}
	/**
	 * Clear the entire MetadataReader cache, removing all cached class metadata.
	 */
	public void clearCache() {
		this.cache.clear();
	}
}
/*
/**
package org.springframework.boot.type.classreading;
/*
package org.springframework.boot.ansi;
/**
public final class Ansi8BitColor implements AnsiElement {
	private final String prefix;
	private final int code;
	/**
	 * Create a new {@link Ansi8BitColor} instance.
	 * @param prefix the prefix escape chars
	 * @param code color code (must be 0-255)
	 * @throws IllegalArgumentException if color code is not between 0 and 255.
	 */
	private Ansi8BitColor(String prefix, int code) {
		Assert.isTrue(code >= 0 && code <= 255, 'Code must be between 0 and 255');
		this.prefix = prefix;
		this.code = code;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		Ansi8BitColor other = (Ansi8BitColor) obj;
		return this.prefix.equals(other.prefix) && this.code == other.code;
	}
	@Override
	public int hashCode() {
		return this.prefix.hashCode() * 31 + this.code;
	}
	@Override
	public String toString() {
		return this.prefix + this.code;
	}
	/**
	 * Return a foreground ANSI color code instance for the given code.
	 * @param code the color code
	 * @return an ANSI color code instance
	 */
	public static Ansi8BitColor foreground(int code) {
		return new Ansi8BitColor('38;5;', code);
	}
	/**
	 * Return a background ANSI color code instance for the given code.
	 * @param code the color code
	 * @return an ANSI color code instance
	 */
	public static Ansi8BitColor background(int code) {
		return new Ansi8BitColor('48;5;', code);
	}
}
/*
package org.springframework.boot.ansi;
/**
public enum AnsiStyle implements AnsiElement {
	NORMAL('0'),
	BOLD('1'),
	FAINT('2'),
	ITALIC('3'),
	UNDERLINE('4');
	private final String code;
	AnsiStyle(String code) {
		this.code = code;
	}
	@Override
	public String toString() {
		return this.code;
	}
}
/*
package org.springframework.boot.ansi;
/**
public class AnsiPropertySource extends PropertySource<AnsiElement> {
	private static final Iterable<Mapping> MAPPINGS;
	static {
		List<Mapping> mappings = new ArrayList<>();
		mappings.add(new EnumMapping<>('AnsiStyle.', AnsiStyle.class));
		mappings.add(new EnumMapping<>('AnsiColor.', AnsiColor.class));
		mappings.add(new Ansi8BitColorMapping('AnsiColor.', Ansi8BitColor::foreground));
		mappings.add(new EnumMapping<>('AnsiBackground.', AnsiBackground.class));
		mappings.add(new Ansi8BitColorMapping('AnsiBackground.', Ansi8BitColor::background));
		mappings.add(new EnumMapping<>('Ansi.', AnsiStyle.class));
		mappings.add(new EnumMapping<>('Ansi.', AnsiColor.class));
		mappings.add(new EnumMapping<>('Ansi.BG_', AnsiBackground.class));
		MAPPINGS = Collections.unmodifiableList(mappings);
	}
	private final boolean encode;
	/**
	 * Create a new {@link AnsiPropertySource} instance.
	 * @param name the name of the property source
	 * @param encode if the output should be encoded
	 */
	public AnsiPropertySource(String name, boolean encode) {
		super(name);
		this.encode = encode;
	}
	@Override
	public Object getProperty(String name) {
		if (StringUtils.hasLength(name)) {
			for (Mapping mapping : MAPPINGS) {
				String prefix = mapping.getPrefix();
				if (name.startsWith(prefix)) {
					String postfix = name.substring(prefix.length());
					AnsiElement element = mapping.getElement(postfix);
					if (element != null) {
						return (this.encode) ? AnsiOutput.encode(element) : element;
					}
				}
			}
		}
		return null;
	}
	/**
	 * Mapping between a name and the pseudo property source.
	 */
	private abstract static class Mapping {
		private final String prefix;
		Mapping(String prefix) {
			this.prefix = prefix;
		}
		String getPrefix() {
			return this.prefix;
		}
		abstract AnsiElement getElement(String postfix);
	}
	/**
	 * {@link Mapping} for {@link AnsiElement} enums.
	 */
	private static class EnumMapping<E extends Enum<E> & AnsiElement> extends Mapping {
		private final Set<E> enums;
		EnumMapping(String prefix, Class<E> enumType) {
			super(prefix);
			this.enums = EnumSet.allOf(enumType);
		}
		@Override
		AnsiElement getElement(String postfix) {
			for (Enum<?> candidate : this.enums) {
				if (candidate.name().equals(postfix)) {
					return (AnsiElement) candidate;
				}
			}
			return null;
		}
	}
	/**
	 * {@link Mapping} for {@link Ansi8BitColor}.
	 */
	private static class Ansi8BitColorMapping extends Mapping {
		private final IntFunction<Ansi8BitColor> factory;
		Ansi8BitColorMapping(String prefix, IntFunction<Ansi8BitColor> factory) {
			super(prefix);
			this.factory = factory;
		}
		@Override
		AnsiElement getElement(String postfix) {
			if (containsOnlyDigits(postfix)) {
				try {
					return this.factory.apply(Integer.parseInt(postfix));
				}
				catch (IllegalArgumentException ex) {
					// Ignore
				}
			}
			return null;
		}
		private boolean containsOnlyDigits(String postfix) {
			for (int i = 0; i < postfix.length(); i++) {
				if (!Character.isDigit(postfix.charAt(i))) {
					return false;
				}
			}
			return !postfix.isEmpty();
		}
	}
}
/*
package org.springframework.boot.ansi;
/**
public abstract class AnsiOutput {
	private static final String ENCODE_JOIN = ';';
	private static Enabled enabled = Enabled.DETECT;
	private static Boolean consoleAvailable;
	private static Boolean ansiCapable;
	private static final String OPERATING_SYSTEM_NAME = System.getProperty('os.name').toLowerCase(Locale.ENGLISH);
	private static final String ENCODE_START = '\033[';
	private static final String ENCODE_END = 'm';
	private static final String RESET = '0;' + AnsiColor.DEFAULT;
	/**
	 * Sets if ANSI output is enabled.
	 * @param enabled if ANSI is enabled, disabled or detected
	 */
	public static void setEnabled(Enabled enabled) {
		Assert.notNull(enabled, 'Enabled must not be null');
		AnsiOutput.enabled = enabled;
	}
	/**
	 * Returns if ANSI output is enabled
	 * @return if ANSI enabled, disabled or detected
	 */
	public static Enabled getEnabled() {
		return AnsiOutput.enabled;
	}
	/**
	 * Sets if the System.console() is known to be available.
	 * @param consoleAvailable if the console is known to be available or {@code null} to
	 * use standard detection logic.
	 */
	public static void setConsoleAvailable(Boolean consoleAvailable) {
		AnsiOutput.consoleAvailable = consoleAvailable;
	}
	/**
	 * Encode a single {@link AnsiElement} if output is enabled.
	 * @param element the element to encode
	 * @return the encoded element or an empty string
	 */
	public static String encode(AnsiElement element) {
		if (isEnabled()) {
			return ENCODE_START + element + ENCODE_END;
		}
		return '';
	}
	/**
	 * Create a new ANSI string from the specified elements. Any {@link AnsiElement}s will
	 * be encoded as required.
	 * @param elements the elements to encode
	 * @return a string of the encoded elements
	 */
	public static String toString(Object... elements) {
		StringBuilder sb = new StringBuilder();
		if (isEnabled()) {
			buildEnabled(sb, elements);
		}
		else {
			buildDisabled(sb, elements);
		}
		return sb.toString();
	}
	private static void buildEnabled(StringBuilder sb, Object[] elements) {
		boolean writingAnsi = false;
		boolean containsEncoding = false;
		for (Object element : elements) {
			if (element instanceof AnsiElement) {
				containsEncoding = true;
				if (!writingAnsi) {
					sb.append(ENCODE_START);
					writingAnsi = true;
				}
				else {
					sb.append(ENCODE_JOIN);
				}
			}
			else {
				if (writingAnsi) {
					sb.append(ENCODE_END);
					writingAnsi = false;
				}
			}
			sb.append(element);
		}
		if (containsEncoding) {
			sb.append(writingAnsi ? ENCODE_JOIN : ENCODE_START);
			sb.append(RESET);
			sb.append(ENCODE_END);
		}
	}
	private static void buildDisabled(StringBuilder sb, Object[] elements) {
		for (Object element : elements) {
			if (!(element instanceof AnsiElement) && element != null) {
				sb.append(element);
			}
		}
	}
	private static boolean isEnabled() {
		if (enabled == Enabled.DETECT) {
			if (ansiCapable == null) {
				ansiCapable = detectIfAnsiCapable();
			}
			return ansiCapable;
		}
		return enabled == Enabled.ALWAYS;
	}
	private static boolean detectIfAnsiCapable() {
		try {
			if (Boolean.FALSE.equals(consoleAvailable)) {
				return false;
			}
			if (consoleAvailable == null) {
				Console console = System.console();
				if (console == null) {
					return false;
				}
				Method isTerminalMethod = ClassUtils.getMethodIfAvailable(Console.class, 'isTerminal');
				if (isTerminalMethod != null) {
					Boolean isTerminal = (Boolean) isTerminalMethod.invoke(console);
					if (Boolean.FALSE.equals(isTerminal)) {
						return false;
					}
				}
			}
			return !(OPERATING_SYSTEM_NAME.contains('win'));
		}
		catch (Throwable ex) {
			return false;
		}
	}
	/**
	 * Possible values to pass to {@link AnsiOutput#setEnabled}. Determines when to output
	 * ANSI escape sequences for coloring application output.
	 */
	public enum Enabled {
		/**
		 * Try to detect whether ANSI coloring capabilities are available. The default
		 * value for {@link AnsiOutput}.
		 */
		DETECT,
		/**
		 * Enable ANSI-colored output.
		 */
		ALWAYS,
		/**
		 * Disable ANSI-colored output.
		 */
		NEVER
	}
}
/*
package org.springframework.boot.ansi;
/**
public enum AnsiBackground implements AnsiElement {
	DEFAULT('49'),
	BLACK('40'),
	RED('41'),
	GREEN('42'),
	YELLOW('43'),
	BLUE('44'),
	MAGENTA('45'),
	CYAN('46'),
	WHITE('47'),
	BRIGHT_BLACK('100'),
	BRIGHT_RED('101'),
	BRIGHT_GREEN('102'),
	BRIGHT_YELLOW('103'),
	BRIGHT_BLUE('104'),
	BRIGHT_MAGENTA('105'),
	BRIGHT_CYAN('106'),
	BRIGHT_WHITE('107');
	private final String code;
	AnsiBackground(String code) {
		this.code = code;
	}
	@Override
	public String toString() {
		return this.code;
	}
}
/*
package org.springframework.boot.ansi;
/**
public interface AnsiElement {
	/**
	 * @return the ANSI escape code
	 */
	@Override
	String toString();
}
/*
/**
package org.springframework.boot.ansi;
/*
package org.springframework.boot.ansi;
/**
public enum AnsiColor implements AnsiElement {
	DEFAULT('39'),
	BLACK('30'),
	RED('31'),
	GREEN('32'),
	YELLOW('33'),
	BLUE('34'),
	MAGENTA('35'),
	CYAN('36'),
	WHITE('37'),
	BRIGHT_BLACK('90'),
	BRIGHT_RED('91'),
	BRIGHT_GREEN('92'),
	BRIGHT_YELLOW('93'),
	BRIGHT_BLUE('94'),
	BRIGHT_MAGENTA('95'),
	BRIGHT_CYAN('96'),
	BRIGHT_WHITE('97');
	private final String code;
	AnsiColor(String code) {
		this.code = code;
	}
	@Override
	public String toString() {
		return this.code;
	}
}
/*
package org.springframework.boot.reactor;
/**
public class ReactorEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
	private static final String REACTOR_DEBUGAGENT_CLASS = 'reactor.tools.agent.ReactorDebugAgent';
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		if (ClassUtils.isPresent(REACTOR_DEBUGAGENT_CLASS, null)) {
			Boolean agentEnabled = environment.getProperty('spring.reactor.debug-agent.enabled', Boolean.class);
			if (agentEnabled != Boolean.FALSE) {
				try {
					Class<?> debugAgent = Class.forName(REACTOR_DEBUGAGENT_CLASS);
					debugAgent.getMethod('init').invoke(null);
				}
				catch (Exception ex) {
					throw new RuntimeException('Failed to init Reactor"s debug agent', ex);
				}
			}
		}
		if (environment.getProperty('spring.threads.virtual.enabled', boolean.class, false)
				&& JavaVersion.getJavaVersion().isEqualOrNewerThan(JavaVersion.TWENTY_ONE)) {
			System.setProperty('reactor.schedulers.defaultBoundedElasticOnVirtualThreads', 'true');
		}
	}
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE;
	}
}
/*
/**
package org.springframework.boot.reactor;
/*
package org.springframework.boot.logging;
/**
public final class CorrelationIdFormatter {
	/**
	 * Default {@link CorrelationIdFormatter}.
	 */
	public static final CorrelationIdFormatter DEFAULT = CorrelationIdFormatter.of('traceId(32),spanId(16)');
	private final List<Part> parts;
	private final String blank;
	private CorrelationIdFormatter(List<Part> parts) {
		this.parts = parts;
		this.blank = String.format('[%s] ', parts.stream().map(Part::blank).collect(Collectors.joining(' ')));
	}
	/**
	 * Format a correlation from the values in the given resolver.
	 * @param resolver the resolver used to resolve named values
	 * @return a formatted correlation id
	 */
	public String format(UnaryOperator<String> resolver) {
		StringBuilder result = new StringBuilder();
		formatTo(resolver, result);
		return result.toString();
	}
	/**
	 * Format a correlation from the values in the given resolver and append it to the
	 * given {@link Appendable}.
	 * @param resolver the resolver used to resolve named values
	 * @param appendable the appendable for the formatted correlation id
	 */
	public void formatTo(UnaryOperator<String> resolver, Appendable appendable) {
		Predicate<Part> canResolve = (part) -> StringUtils.hasLength(resolver.apply(part.name()));
		try {
			if (this.parts.stream().anyMatch(canResolve)) {
				appendable.append("[");
				for (Iterator<Part> iterator = this.parts.iterator(); iterator.hasNext();) {
					appendable.append(iterator.next().resolve(resolver));
					if (iterator.hasNext()) {
						appendable.append("-");
					}
				}
				appendable.append('] ');
			}
			else {
				appendable.append(this.blank);
			}
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	@Override
	public String toString() {
		return this.parts.stream().map(Part::toString).collect(Collectors.joining(','));
	}
	/**
	 * Create a new {@link CorrelationIdFormatter} instance from the given specification.
	 * @param spec a comma-separated specification
	 * @return a new {@link CorrelationIdFormatter} instance
	 */
	public static CorrelationIdFormatter of(String spec) {
		try {
			return (!StringUtils.hasText(spec)) ? DEFAULT : of(List.of(spec.split(',')));
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to parse correlation formatter spec "%s"'.formatted(spec), ex);
		}
	}
	/**
	 * Create a new {@link CorrelationIdFormatter} instance from the given specification.
	 * @param spec a pre-separated specification
	 * @return a new {@link CorrelationIdFormatter} instance
	 */
	public static CorrelationIdFormatter of(String[] spec) {
		return of((spec != null) ? List.of(spec) : Collections.emptyList());
	}
	/**
	 * Create a new {@link CorrelationIdFormatter} instance from the given specification.
	 * @param spec a pre-separated specification
	 * @return a new {@link CorrelationIdFormatter} instance
	 */
	public static CorrelationIdFormatter of(Collection<String> spec) {
		if (CollectionUtils.isEmpty(spec)) {
			return DEFAULT;
		}
		List<Part> parts = spec.stream().map(Part::of).toList();
		return new CorrelationIdFormatter(parts);
	}
	/**
	 * A part of the correlation id.
	 *
	 * @param name the name of the correlation part
	 * @param length the expected length of the correlation part
	 */
	record Part(String name, int length) {
		private static final Pattern pattern = Pattern.compile('^(.+?)\\((\\d+)\\)$');
		String resolve(UnaryOperator<String> resolver) {
			String resolved = resolver.apply(name());
			if (resolved == null) {
				return blank();
			}
			int padding = length() - resolved.length();
			return (padding <= 0) ? resolved : resolved + ' '.repeat(padding);
		}
		String blank() {
			return ' '.repeat(this.length);
		}
		@Override
		public String toString() {
			return '%s(%s)'.formatted(name(), length());
		}
		static Part of(String part) {
			Matcher matcher = pattern.matcher(part.trim());
			Assert.state(matcher.matches(), () -> 'Invalid specification part "%s"'.formatted(part));
			String name = matcher.group(1);
			int length = Integer.parseInt(matcher.group(2));
			return new Part(name, length);
		}
	}
}
/*
package org.springframework.boot.logging;
/**
public class LoggingSystemProperties {
	private static final BiConsumer<String, String> systemPropertySetter = (name, value) -> {
		if (System.getProperty(name) == null && value != null) {
			System.setProperty(name, value);
		}
	};
	private final Environment environment;
	private final Function<String, String> defaultValueResolver;
	private final BiConsumer<String, String> setter;
	/**
	 * Create a new {@link LoggingSystemProperties} instance.
	 * @param environment the source environment
	 */
	public LoggingSystemProperties(Environment environment) {
		this(environment, null);
	}
	/**
	 * Create a new {@link LoggingSystemProperties} instance.
	 * @param environment the source environment
	 * @param setter setter used to apply the property or {@code null} for system
	 * properties
	 * @since 2.4.2
	 */
	public LoggingSystemProperties(Environment environment, BiConsumer<String, String> setter) {
		this(environment, null, setter);
	}
	/**
	 * Create a new {@link LoggingSystemProperties} instance.
	 * @param environment the source environment
	 * @param defaultValueResolver function used to resolve default values or {@code null}
	 * @param setter setter used to apply the property or {@code null} for system
	 * properties
	 * @since 3.2.0
	 */
	public LoggingSystemProperties(Environment environment, Function<String, String> defaultValueResolver,
			BiConsumer<String, String> setter) {
		Assert.notNull(environment, 'Environment must not be null');
		this.environment = environment;
		this.defaultValueResolver = (defaultValueResolver != null) ? defaultValueResolver : (name) -> null;
		this.setter = (setter != null) ? setter : systemPropertySetter;
	}
	protected Charset getDefaultCharset() {
		return StandardCharsets.UTF_8;
	}
	public final void apply() {
		apply(null);
	}
	public final void apply(LogFile logFile) {
		PropertyResolver resolver = getPropertyResolver();
		apply(logFile, resolver);
	}
	private PropertyResolver getPropertyResolver() {
		if (this.environment instanceof ConfigurableEnvironment configurableEnvironment) {
			PropertySourcesPropertyResolver resolver = new PropertySourcesPropertyResolver(
					configurableEnvironment.getPropertySources());
			resolver.setConversionService(configurableEnvironment.getConversionService());
			resolver.setIgnoreUnresolvableNestedPlaceholders(true);
			return resolver;
		}
		return this.environment;
	}
	protected void apply(LogFile logFile, PropertyResolver resolver) {
		String defaultCharsetName = getDefaultCharset().name();
		setSystemProperty(LoggingSystemProperty.APPLICATION_NAME, resolver);
		setSystemProperty(LoggingSystemProperty.APPLICATION_GROUP, resolver);
		setSystemProperty(LoggingSystemProperty.PID, new ApplicationPid().toString());
		setSystemProperty(LoggingSystemProperty.CONSOLE_CHARSET, resolver, defaultCharsetName);
		setSystemProperty(LoggingSystemProperty.FILE_CHARSET, resolver, defaultCharsetName);
		setSystemProperty(LoggingSystemProperty.CONSOLE_THRESHOLD, resolver, this::thresholdMapper);
		setSystemProperty(LoggingSystemProperty.FILE_THRESHOLD, resolver, this::thresholdMapper);
		setSystemProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD, resolver);
		setSystemProperty(LoggingSystemProperty.CONSOLE_PATTERN, resolver);
		setSystemProperty(LoggingSystemProperty.FILE_PATTERN, resolver);
		setSystemProperty(LoggingSystemProperty.CONSOLE_STRUCTURED_FORMAT, resolver);
		setSystemProperty(LoggingSystemProperty.FILE_STRUCTURED_FORMAT, resolver);
		setSystemProperty(LoggingSystemProperty.LEVEL_PATTERN, resolver);
		setSystemProperty(LoggingSystemProperty.DATEFORMAT_PATTERN, resolver);
		setSystemProperty(LoggingSystemProperty.CORRELATION_PATTERN, resolver);
		if (logFile != null) {
			logFile.applyToSystemProperties();
		}
	}
	private void setSystemProperty(LoggingSystemProperty property, PropertyResolver resolver) {
		setSystemProperty(property, resolver, Function.identity());
	}
	private void setSystemProperty(LoggingSystemProperty property, PropertyResolver resolver,
			Function<String, String> mapper) {
		setSystemProperty(property, resolver, null, mapper);
	}
	private void setSystemProperty(LoggingSystemProperty property, PropertyResolver resolver, String defaultValue) {
		setSystemProperty(property, resolver, defaultValue, Function.identity());
	}
	private void setSystemProperty(LoggingSystemProperty property, PropertyResolver resolver, String defaultValue,
			Function<String, String> mapper) {
		if (property.getIncludePropertyName() != null) {
			if (!resolver.getProperty(property.getIncludePropertyName(), Boolean.class, Boolean.TRUE)) {
				return;
			}
		}
		String value = (property.getApplicationPropertyName() != null)
				? resolver.getProperty(property.getApplicationPropertyName()) : null;
		value = (value != null) ? value : this.defaultValueResolver.apply(property.getApplicationPropertyName());
		value = (value != null) ? value : defaultValue;
		value = mapper.apply(value);
		setSystemProperty(property.getEnvironmentVariableName(), value);
		if (property == LoggingSystemProperty.APPLICATION_NAME && StringUtils.hasText(value)) {
			// LOGGED_APPLICATION_NAME is deprecated for removal in 3.6.0
			setSystemProperty('LOGGED_APPLICATION_NAME', '[%s] '.formatted(value));
		}
	}
	private void setSystemProperty(LoggingSystemProperty property, String value) {
		setSystemProperty(property.getEnvironmentVariableName(), value);
	}
	private String thresholdMapper(String input) {
		// YAML converts an unquoted OFF to false
		if ('false'.equals(input)) {
			return 'OFF';
		}
		return input;
	}
	/**
	 * Set a system property.
	 * @param name the property name
	 * @param value the value
	 */
	protected final void setSystemProperty(String name, String value) {
		this.setter.accept(name, value);
	}
}
/*
package org.springframework.boot.logging;
/**
class LoggerConfigurationComparator implements Comparator<LoggerConfiguration> {
	private final String rootLoggerName;
	/**
	 * Create a new {@link LoggerConfigurationComparator} instance.
	 * @param rootLoggerName the name of the 'root' logger
	 */
	LoggerConfigurationComparator(String rootLoggerName) {
		Assert.notNull(rootLoggerName, 'RootLoggerName must not be null');
		this.rootLoggerName = rootLoggerName;
	}
	@Override
	public int compare(LoggerConfiguration o1, LoggerConfiguration o2) {
		if (this.rootLoggerName.equals(o1.getName())) {
			return -1;
		}
		if (this.rootLoggerName.equals(o2.getName())) {
			return 1;
		}
		return o1.getName().compareTo(o2.getName());
	}
}
/*
package org.springframework.boot.logging;
/**
@FunctionalInterface
public interface DeferredLogFactory {
	/**
	 * Create a new {@link DeferredLog} for the given destination.
	 * @param destination the ultimate log destination
	 * @return a deferred log instance that will switch to the destination when
	 * appropriate.
	 */
	default Log getLog(Class<?> destination) {
		return getLog(() -> LogFactory.getLog(destination));
	}
	/**
	 * Create a new {@link DeferredLog} for the given destination.
	 * @param destination the ultimate log destination
	 * @return a deferred log instance that will switch to the destination when
	 * appropriate.
	 */
	default Log getLog(Log destination) {
		return getLog(() -> destination);
	}
	/**
	 * Create a new {@link DeferredLog} for the given destination.
	 * @param destination the ultimate log destination
	 * @return a deferred log instance that will switch to the destination when
	 * appropriate.
	 */
	Log getLog(Supplier<Log> destination);
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'StructuredLogLayout', category = Node.CATEGORY, elementType = Layout.ELEMENT_TYPE)
final class StructuredLogLayout extends AbstractStringLayout {
	private final StructuredLogFormatter<LogEvent> formatter;
	private StructuredLogLayout(Charset charset, StructuredLogFormatter<LogEvent> formatter) {
		super(charset);
		Assert.notNull(formatter, 'Formatter must not be null');
		this.formatter = formatter;
	}
	@Override
	public String toSerializable(LogEvent event) {
		return this.formatter.format(event);
	}
	@Override
	public byte[] toByteArray(LogEvent event) {
		return this.formatter.formatAsBytes(event, (getCharset() != null) ? getCharset() : StandardCharsets.UTF_8);
	}
	@PluginBuilderFactory
	static StructuredLogLayout.Builder newBuilder() {
		return new StructuredLogLayout.Builder();
	}
	static final class Builder implements org.apache.logging.log4j.core.util.Builder<StructuredLogLayout> {
		@PluginLoggerContext
		private LoggerContext loggerContext;
		@PluginBuilderAttribute
		private String format;
		@PluginBuilderAttribute
		private String charset = StandardCharsets.UTF_8.name();
		Builder setFormat(String format) {
			this.format = format;
			return this;
		}
		Builder setCharset(String charset) {
			this.charset = charset;
			return this;
		}
		@Override
		public StructuredLogLayout build() {
			Charset charset = Charset.forName(this.charset);
			Environment environment = Log4J2LoggingSystem.getEnvironment(this.loggerContext);
			Assert.state(environment != null, 'Unable to find Spring Environment in logger context');
			StructuredLogFormatter<LogEvent> formatter = new StructuredLogFormatterFactory<>(LogEvent.class,
					environment, null, this::addCommonFormatters)
				.get(this.format);
			return new StructuredLogLayout(charset, formatter);
		}
		private void addCommonFormatters(CommonFormatters<LogEvent> commonFormatters) {
			commonFormatters.add(CommonStructuredLogFormat.ELASTIC_COMMON_SCHEMA, this::createEcsFormatter);
			commonFormatters.add(CommonStructuredLogFormat.GRAYLOG_EXTENDED_LOG_FORMAT, this::createGraylogFormatter);
			commonFormatters.add(CommonStructuredLogFormat.LOGSTASH, this::createLogstashFormatter);
		}
		private ElasticCommonSchemaStructuredLogFormatter createEcsFormatter(Instantiator<?> instantiator) {
			Environment environment = instantiator.getArg(Environment.class);
			StructureLoggingJsonMembersCustomizer<?> jsonMembersCustomizer = instantiator
				.getArg(StructureLoggingJsonMembersCustomizer.class);
			return new ElasticCommonSchemaStructuredLogFormatter(environment, jsonMembersCustomizer);
		}
		private GraylogExtendedLogFormatStructuredLogFormatter createGraylogFormatter(Instantiator<?> instantiator) {
			Environment environment = instantiator.getArg(Environment.class);
			StructureLoggingJsonMembersCustomizer<?> jsonMembersCustomizer = instantiator
				.getArg(StructureLoggingJsonMembersCustomizer.class);
			return new GraylogExtendedLogFormatStructuredLogFormatter(environment, jsonMembersCustomizer);
		}
		private LogstashStructuredLogFormatter createLogstashFormatter(Instantiator<?> instantiator) {
			StructureLoggingJsonMembersCustomizer<?> jsonMembersCustomizer = instantiator
				.getArg(StructureLoggingJsonMembersCustomizer.class);
			return new LogstashStructuredLogFormatter(jsonMembersCustomizer);
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'WhitespaceThrowablePatternConverter', category = PatternConverter.CATEGORY)
@ConverterKeys({ 'wEx', 'wThrowable', 'wException' })
public final class WhitespaceThrowablePatternConverter extends ThrowablePatternConverter {
	private WhitespaceThrowablePatternConverter(Configuration configuration, String[] options) {
		super('WhitespaceThrowable', 'throwable', options, configuration);
	}
	@Override
	public void format(LogEvent event, StringBuilder buffer) {
		if (event.getThrown() != null) {
			buffer.append(this.options.getSeparator());
			super.format(event, buffer);
			buffer.append(this.options.getSeparator());
		}
	}
	/**
	 * Creates a new instance of the class. Required by Log4J2.
	 * @param configuration current configuration
	 * @param options pattern options, may be null. If first element is 'short', only the
	 * first line of the throwable will be formatted.
	 * @return a new {@code WhitespaceThrowablePatternConverter}
	 */
	public static WhitespaceThrowablePatternConverter newInstance(Configuration configuration, String[] options) {
		return new WhitespaceThrowablePatternConverter(configuration, options);
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
public class Log4J2LoggingSystem extends AbstractLoggingSystem {
	private static final String LOG4J_BRIDGE_HANDLER = 'org.apache.logging.log4j.jul.Log4jBridgeHandler';
	private static final String LOG4J_LOG_MANAGER = 'org.apache.logging.log4j.jul.LogManager';
	private static final SpringEnvironmentPropertySource propertySource = new SpringEnvironmentPropertySource();
	static final String ENVIRONMENT_KEY = Conventions.getQualifiedAttributeName(Log4J2LoggingSystem.class,
			'environment');
	private static final LogLevels<Level> LEVELS = new LogLevels<>();
	static {
		LEVELS.map(LogLevel.TRACE, Level.TRACE);
		LEVELS.map(LogLevel.DEBUG, Level.DEBUG);
		LEVELS.map(LogLevel.INFO, Level.INFO);
		LEVELS.map(LogLevel.WARN, Level.WARN);
		LEVELS.map(LogLevel.ERROR, Level.ERROR);
		LEVELS.map(LogLevel.FATAL, Level.FATAL);
		LEVELS.map(LogLevel.OFF, Level.OFF);
	}
	private static final Filter FILTER = DenyAllFilter.newBuilder().build();
	public Log4J2LoggingSystem(ClassLoader classLoader) {
		super(classLoader);
	}
	@Override
	protected String[] getStandardConfigLocations() {
		List<String> locations = new ArrayList<>();
		locations.add('log4j2-test.properties');
		if (isClassAvailable('com.fasterxml.jackson.dataformat.yaml.YAMLParser')) {
			Collections.addAll(locations, 'log4j2-test.yaml', 'log4j2-test.yml');
		}
		if (isClassAvailable('com.fasterxml.jackson.databind.ObjectMapper')) {
			Collections.addAll(locations, 'log4j2-test.json', 'log4j2-test.jsn');
		}
		locations.add('log4j2-test.xml');
		locations.add('log4j2.properties');
		if (isClassAvailable('com.fasterxml.jackson.dataformat.yaml.YAMLParser')) {
			Collections.addAll(locations, 'log4j2.yaml', 'log4j2.yml');
		}
		if (isClassAvailable('com.fasterxml.jackson.databind.ObjectMapper')) {
			Collections.addAll(locations, 'log4j2.json', 'log4j2.jsn');
		}
		locations.add('log4j2.xml');
		String propertyDefinedLocation = new PropertiesUtil(new Properties())
			.getStringProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY);
		if (propertyDefinedLocation != null) {
			locations.add(propertyDefinedLocation);
		}
		return StringUtils.toStringArray(locations);
	}
	protected boolean isClassAvailable(String className) {
		return ClassUtils.isPresent(className, getClassLoader());
	}
	@Override
	public void beforeInitialize() {
		LoggerContext loggerContext = getLoggerContext();
		if (isAlreadyInitialized(loggerContext)) {
			return;
		}
		if (!configureJdkLoggingBridgeHandler()) {
			super.beforeInitialize();
		}
		loggerContext.getConfiguration().addFilter(FILTER);
	}
	private boolean configureJdkLoggingBridgeHandler() {
		try {
			if (isJulUsingASingleConsoleHandlerAtMost() && !isLog4jLogManagerInstalled()
					&& isLog4jBridgeHandlerAvailable()) {
				removeDefaultRootHandler();
				Log4jBridgeHandler.install(false, null, true);
				return true;
			}
		}
		catch (Throwable ex) {
			// Ignore. No java.util.logging bridge is installed.
		}
		return false;
	}
	private boolean isJulUsingASingleConsoleHandlerAtMost() {
		java.util.logging.Logger rootLogger = java.util.logging.LogManager.getLogManager().getLogger('');
		Handler[] handlers = rootLogger.getHandlers();
		return handlers.length == 0 || (handlers.length == 1 && handlers[0] instanceof ConsoleHandler);
	}
	private boolean isLog4jLogManagerInstalled() {
		final String logManagerClassName = java.util.logging.LogManager.getLogManager().getClass().getName();
		return LOG4J_LOG_MANAGER.equals(logManagerClassName);
	}
	private boolean isLog4jBridgeHandlerAvailable() {
		return ClassUtils.isPresent(LOG4J_BRIDGE_HANDLER, getClassLoader());
	}
	private void removeLog4jBridgeHandler() {
		removeDefaultRootHandler();
		java.util.logging.Logger rootLogger = java.util.logging.LogManager.getLogManager().getLogger('');
		for (final Handler handler : rootLogger.getHandlers()) {
			if (handler instanceof Log4jBridgeHandler) {
				handler.close();
				rootLogger.removeHandler(handler);
			}
		}
	}
	private void removeDefaultRootHandler() {
		try {
			java.util.logging.Logger rootLogger = java.util.logging.LogManager.getLogManager().getLogger('');
			Handler[] handlers = rootLogger.getHandlers();
			if (handlers.length == 1 && handlers[0] instanceof ConsoleHandler) {
				rootLogger.removeHandler(handlers[0]);
			}
		}
		catch (Throwable ex) {
			// Ignore and continue
		}
	}
	@Override
	public void initialize(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile) {
		LoggerContext loggerContext = getLoggerContext();
		if (isAlreadyInitialized(loggerContext)) {
			return;
		}
		Environment environment = initializationContext.getEnvironment();
		if (environment != null) {
			getLoggerContext().putObject(ENVIRONMENT_KEY, environment);
			Log4J2LoggingSystem.propertySource.setEnvironment(environment);
			PropertiesUtil.getProperties().addPropertySource(Log4J2LoggingSystem.propertySource);
		}
		loggerContext.getConfiguration().removeFilter(FILTER);
		super.initialize(initializationContext, configLocation, logFile);
		markAsInitialized(loggerContext);
	}
	@Override
	protected void loadDefaults(LoggingInitializationContext initializationContext, LogFile logFile) {
		String location = getPackagedConfigFile((logFile != null) ? 'log4j2-file.xml' : 'log4j2.xml');
		load(initializationContext, location, logFile);
	}
	@Override
	protected void loadConfiguration(LoggingInitializationContext initializationContext, String location,
			LogFile logFile) {
		load(initializationContext, location, logFile);
	}
	private void load(LoggingInitializationContext initializationContext, String location, LogFile logFile) {
		List<String> overrides = getOverrides(initializationContext);
		applySystemProperties(initializationContext.getEnvironment(), logFile);
		loadConfiguration(location, logFile, overrides);
	}
	private List<String> getOverrides(LoggingInitializationContext initializationContext) {
		BindResult<List<String>> overrides = Binder.get(initializationContext.getEnvironment())
			.bind('logging.log4j2.config.override', Bindable.listOf(String.class));
		return overrides.orElse(Collections.emptyList());
	}
	/**
	 * Load the configuration from the given {@code location}, creating a composite using
	 * the configuration from the given {@code overrides}.
	 * @param location the location
	 * @param logFile log file configuration
	 * @param overrides the overriding locations
	 * @since 2.6.0
	 */
	protected void loadConfiguration(String location, LogFile logFile, List<String> overrides) {
		Assert.notNull(location, 'Location must not be null');
		try {
			List<Configuration> configurations = new ArrayList<>();
			LoggerContext context = getLoggerContext();
			configurations.add(load(location, context));
			for (String override : overrides) {
				configurations.add(load(override, context));
			}
			Configuration configuration = (configurations.size() > 1) ? createComposite(configurations)
					: configurations.iterator().next();
			context.start(configuration);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Could not initialize Log4J2 logging from ' + location, ex);
		}
	}
	private Configuration load(String location, LoggerContext context) throws IOException {
		Resource resource = ApplicationResourceLoader.get().getResource(location);
		ConfigurationSource source = getConfigurationSource(resource);
		return ConfigurationFactory.getInstance().getConfiguration(context, source);
	}
	private ConfigurationSource getConfigurationSource(Resource resource) throws IOException {
		if (resource.isFile()) {
			return new ConfigurationSource(resource.getInputStream(), resource.getFile());
		}
		URL url = resource.getURL();
		AuthorizationProvider authorizationProvider = ConfigurationFactory
			.authorizationProvider(PropertiesUtil.getProperties());
		SslConfiguration sslConfiguration = url.getProtocol().equals('https')
				? SslConfigurationFactory.getSslConfiguration() : null;
		URLConnection connection = UrlConnectionFactory.createConnection(url, 0, sslConfiguration,
				authorizationProvider);
		return new ConfigurationSource(connection.getInputStream(), url, connection.getLastModified());
	}
	private CompositeConfiguration createComposite(List<Configuration> configurations) {
		return new CompositeConfiguration(configurations.stream().map(AbstractConfiguration.class::cast).toList());
	}
	@Override
	protected void reinitialize(LoggingInitializationContext initializationContext) {
		List<String> overrides = getOverrides(initializationContext);
		if (!CollectionUtils.isEmpty(overrides)) {
			reinitializeWithOverrides(overrides);
		}
		else {
			LoggerContext context = getLoggerContext();
			context.reconfigure();
		}
	}
	private void reinitializeWithOverrides(List<String> overrides) {
		LoggerContext context = getLoggerContext();
		Configuration base = context.getConfiguration();
		List<AbstractConfiguration> configurations = new ArrayList<>();
		configurations.add((AbstractConfiguration) base);
		for (String override : overrides) {
			try {
				configurations.add((AbstractConfiguration) load(override, context));
			}
			catch (IOException ex) {
				throw new RuntimeException('Failed to load overriding configuration from "' + override + '"', ex);
			}
		}
		CompositeConfiguration composite = new CompositeConfiguration(configurations);
		context.reconfigure(composite);
	}
	@Override
	public Set<LogLevel> getSupportedLogLevels() {
		return LEVELS.getSupported();
	}
	@Override
	public void setLogLevel(String loggerName, LogLevel logLevel) {
		setLogLevel(loggerName, LEVELS.convertSystemToNative(logLevel));
	}
	private void setLogLevel(String loggerName, Level level) {
		LoggerConfig logger = getLogger(loggerName);
		if (level == null) {
			clearLogLevel(loggerName, logger);
		}
		else {
			setLogLevel(loggerName, logger, level);
		}
		getLoggerContext().updateLoggers();
	}
	private void clearLogLevel(String loggerName, LoggerConfig logger) {
		if (logger instanceof LevelSetLoggerConfig) {
			getLoggerContext().getConfiguration().removeLogger(loggerName);
		}
		else {
			logger.setLevel(null);
		}
	}
	private void setLogLevel(String loggerName, LoggerConfig logger, Level level) {
		if (logger == null) {
			getLoggerContext().getConfiguration()
				.addLogger(loggerName, new LevelSetLoggerConfig(loggerName, level, true));
		}
		else {
			logger.setLevel(level);
		}
	}
	@Override
	public List<LoggerConfiguration> getLoggerConfigurations() {
		List<LoggerConfiguration> result = new ArrayList<>();
		getAllLoggers().forEach((name, loggerConfig) -> result.add(convertLoggerConfig(name, loggerConfig)));
		result.sort(CONFIGURATION_COMPARATOR);
		return result;
	}
	@Override
	public LoggerConfiguration getLoggerConfiguration(String loggerName) {
		LoggerConfig loggerConfig = getAllLoggers().get(loggerName);
		return (loggerConfig != null) ? convertLoggerConfig(loggerName, loggerConfig) : null;
	}
	private Map<String, LoggerConfig> getAllLoggers() {
		Map<String, LoggerConfig> loggers = new LinkedHashMap<>();
		for (Logger logger : getLoggerContext().getLoggers()) {
			addLogger(loggers, logger.getName());
		}
		getLoggerContext().getConfiguration().getLoggers().keySet().forEach((name) -> addLogger(loggers, name));
		return loggers;
	}
	private void addLogger(Map<String, LoggerConfig> loggers, String name) {
		Configuration configuration = getLoggerContext().getConfiguration();
		while (name != null) {
			loggers.computeIfAbsent(name, configuration::getLoggerConfig);
			name = getSubName(name);
		}
	}
	private String getSubName(String name) {
		if (!StringUtils.hasLength(name)) {
			return null;
		}
		int nested = name.lastIndexOf("$");
		return (nested != -1) ? name.substring(0, nested) : NameUtil.getSubName(name);
	}
	private LoggerConfiguration convertLoggerConfig(String name, LoggerConfig loggerConfig) {
		if (loggerConfig == null) {
			return null;
		}
		LevelConfiguration effectiveLevelConfiguration = getLevelConfiguration(loggerConfig.getLevel());
		if (!StringUtils.hasLength(name) || LogManager.ROOT_LOGGER_NAME.equals(name)) {
			name = ROOT_LOGGER_NAME;
		}
		boolean isAssigned = loggerConfig.getName().equals(name);
		LevelConfiguration assignedLevelConfiguration = (!isAssigned) ? null : effectiveLevelConfiguration;
		return new LoggerConfiguration(name, assignedLevelConfiguration, effectiveLevelConfiguration);
	}
	private LevelConfiguration getLevelConfiguration(Level level) {
		LogLevel logLevel = LEVELS.convertNativeToSystem(level);
		return (logLevel != null) ? LevelConfiguration.of(logLevel) : LevelConfiguration.ofCustom(level.name());
	}
	@Override
	public Runnable getShutdownHandler() {
		return () -> getLoggerContext().stop();
	}
	@Override
	public void cleanUp() {
		if (isLog4jBridgeHandlerAvailable()) {
			removeLog4jBridgeHandler();
		}
		super.cleanUp();
		LoggerContext loggerContext = getLoggerContext();
		markAsUninitialized(loggerContext);
		loggerContext.getConfiguration().removeFilter(FILTER);
		Log4J2LoggingSystem.propertySource.setEnvironment(null);
		getLoggerContext().removeObject(ENVIRONMENT_KEY);
	}
	private LoggerConfig getLogger(String name) {
		boolean isRootLogger = !StringUtils.hasLength(name) || ROOT_LOGGER_NAME.equals(name);
		return findLogger(isRootLogger ? LogManager.ROOT_LOGGER_NAME : name);
	}
	private LoggerConfig findLogger(String name) {
		Configuration configuration = getLoggerContext().getConfiguration();
		if (configuration instanceof AbstractConfiguration abstractConfiguration) {
			return abstractConfiguration.getLogger(name);
		}
		return configuration.getLoggers().get(name);
	}
	private LoggerContext getLoggerContext() {
		return (LoggerContext) LogManager.getContext(false);
	}
	private boolean isAlreadyInitialized(LoggerContext loggerContext) {
		return LoggingSystem.class.getName().equals(loggerContext.getExternalContext());
	}
	private void markAsInitialized(LoggerContext loggerContext) {
		loggerContext.setExternalContext(LoggingSystem.class.getName());
	}
	private void markAsUninitialized(LoggerContext loggerContext) {
		loggerContext.setExternalContext(null);
	}
	@Override
	protected String getDefaultLogCorrelationPattern() {
		return '%correlationId';
	}
	/**
	 * Get the Spring {@link Environment} attached to the given {@link LoggerContext} or
	 * {@code null} if no environment is available.
	 * @param loggerContext the logger context
	 * @return the Spring {@link Environment} or {@code null}
	 * @since 3.0.0
	 */
	public static Environment getEnvironment(LoggerContext loggerContext) {
		return (Environment) ((loggerContext != null) ? loggerContext.getObject(ENVIRONMENT_KEY) : null);
	}
	/**
	 * {@link LoggingSystemFactory} that returns {@link Log4J2LoggingSystem} if possible.
	 */
	@Order(Ordered.LOWEST_PRECEDENCE)
	public static class Factory implements LoggingSystemFactory {
		private static final boolean PRESENT = ClassUtils
			.isPresent('org.apache.logging.log4j.core.impl.Log4jContextFactory', Factory.class.getClassLoader());
		@Override
		public LoggingSystem getLoggingSystem(ClassLoader classLoader) {
			if (PRESENT) {
				return new Log4J2LoggingSystem(classLoader);
			}
			return null;
		}
	}
	/**
	 * {@link LoggerConfig} used when the user has set a specific {@link Level}.
	 */
	private static class LevelSetLoggerConfig extends LoggerConfig {
		LevelSetLoggerConfig(String name, Level level, boolean additive) {
			super(name, level, additive);
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
public class SpringBootPropertySource implements PropertySource {
	private static final String PREFIX = 'log4j.';
	private final Map<String, String> properties = Collections
		.singletonMap(ShutdownCallbackRegistry.SHUTDOWN_HOOK_ENABLED, 'false');
	@Override
	public void forEach(BiConsumer<String, String> action) {
		this.properties.forEach(action::accept);
	}
	@Override
	public CharSequence getNormalForm(Iterable<? extends CharSequence> tokens) {
		return PREFIX + Util.joinAsCamelCase(tokens);
	}
	@Override
	public int getPriority() {
		return -200;
	}
	@Override
	public String getProperty(String key) {
		return this.properties.get(key);
	}
	@Override
	public boolean containsProperty(String key) {
		return this.properties.containsKey(key);
	}
	@Override
	public Collection<String> getPropertyNames() {
		return this.properties.keySet();
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'ExtendedWhitespaceThrowablePatternConverter', category = PatternConverter.CATEGORY)
@ConverterKeys({ 'xwEx', 'xwThrowable', 'xwException' })
public final class ExtendedWhitespaceThrowablePatternConverter extends ThrowablePatternConverter {
	private final ExtendedThrowablePatternConverter delegate;
	private ExtendedWhitespaceThrowablePatternConverter(Configuration configuration, String[] options) {
		super('WhitespaceExtendedThrowable', 'throwable', options, configuration);
		this.delegate = ExtendedThrowablePatternConverter.newInstance(configuration, options);
	}
	@Override
	public void format(LogEvent event, StringBuilder buffer) {
		if (event.getThrown() != null) {
			buffer.append(this.options.getSeparator());
			this.delegate.format(event, buffer);
			buffer.append(this.options.getSeparator());
		}
	}
	/**
	 * Creates a new instance of the class. Required by Log4J2.
	 * @param configuration current configuration
	 * @param options pattern options, may be null. If first element is 'short', only the
	 * first line of the throwable will be formatted.
	 * @return a new {@code WhitespaceThrowablePatternConverter}
	 */
	public static ExtendedWhitespaceThrowablePatternConverter newInstance(Configuration configuration,
			String[] options) {
		return new ExtendedWhitespaceThrowablePatternConverter(configuration, options);
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class SpringEnvironmentPropertySource implements PropertySource {
	/**
	 * System properties take precedence followed by properties in Log4j properties files.
	 */
	private static final int PRIORITY = -100;
	private volatile Environment environment;
	@Override
	public int getPriority() {
		return PRIORITY;
	}
	@Override
	public String getProperty(String key) {
		Environment environment = this.environment;
		return (environment != null) ? environment.getProperty(key) : null;
	}
	@Override
	public boolean containsProperty(String key) {
		Environment environment = this.environment;
		return environment != null && environment.containsProperty(key);
	}
	void setEnvironment(Environment environment) {
		this.environment = environment;
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class ElasticCommonSchemaStructuredLogFormatter extends JsonWriterStructuredLogFormatter<LogEvent> {
	ElasticCommonSchemaStructuredLogFormatter(Environment environment,
			StructureLoggingJsonMembersCustomizer<?> customizer) {
		super((members) -> jsonMembers(environment, members), customizer);
	}
	private static void jsonMembers(Environment environment, JsonWriter.Members<LogEvent> members) {
		members.add('@timestamp', LogEvent::getInstant).as(ElasticCommonSchemaStructuredLogFormatter::asTimestamp);
		members.add('log.level', LogEvent::getLevel).as(Level::name);
		members.add('process.pid', environment.getProperty('spring.application.pid', Long.class))
			.when(Objects::nonNull);
		members.add('process.thread.name', LogEvent::getThreadName);
		ElasticCommonSchemaProperties.get(environment).jsonMembers(members);
		members.add('log.logger', LogEvent::getLoggerName);
		members.add('message', LogEvent::getMessage).as(StructuredMessage::get);
		members.from(LogEvent::getContextData)
			.whenNot(ReadOnlyStringMap::isEmpty)
			.usingPairs((contextData, pairs) -> contextData.forEach(pairs::accept));
		members.from(LogEvent::getThrownProxy).whenNotNull().usingMembers((thrownProxyMembers) -> {
			thrownProxyMembers.add('error.type', ThrowableProxy::getThrowable)
				.whenNotNull()
				.as(ObjectUtils::nullSafeClassName);
			thrownProxyMembers.add('error.message', ThrowableProxy::getMessage);
			thrownProxyMembers.add('error.stack_trace', ThrowableProxy::getExtendedStackTraceAsString);
		});
		members.add('ecs.version', '8.11');
	}
	private static java.time.Instant asTimestamp(Instant instant) {
		return java.time.Instant.ofEpochMilli(instant.getEpochMillisecond()).plusNanos(instant.getNanoOfMillisecond());
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class LogstashStructuredLogFormatter extends JsonWriterStructuredLogFormatter<LogEvent> {
	LogstashStructuredLogFormatter(StructureLoggingJsonMembersCustomizer<?> customizer) {
		super(LogstashStructuredLogFormatter::jsonMembers, customizer);
	}
	private static void jsonMembers(JsonWriter.Members<LogEvent> members) {
		members.add('@timestamp', LogEvent::getInstant).as(LogstashStructuredLogFormatter::asTimestamp);
		members.add('@version', '1');
		members.add('message', LogEvent::getMessage).as(StructuredMessage::get);
		members.add('logger_name', LogEvent::getLoggerName);
		members.add('thread_name', LogEvent::getThreadName);
		members.add('level', LogEvent::getLevel).as(Level::name);
		members.add('level_value', LogEvent::getLevel).as(Level::intLevel);
		members.from(LogEvent::getContextData)
			.whenNot(ReadOnlyStringMap::isEmpty)
			.usingPairs((contextData, pairs) -> contextData.forEach(pairs::accept));
		members.add('tags', LogEvent::getMarker)
			.whenNotNull()
			.as(LogstashStructuredLogFormatter::getMarkers)
			.whenNot(CollectionUtils::isEmpty);
		members.add('stack_trace', LogEvent::getThrownProxy)
			.whenNotNull()
			.as(ThrowableProxy::getExtendedStackTraceAsString);
	}
	private static String asTimestamp(Instant instant) {
		java.time.Instant javaInstant = java.time.Instant.ofEpochMilli(instant.getEpochMillisecond())
			.plusNanos(instant.getNanoOfMillisecond());
		OffsetDateTime offsetDateTime = OffsetDateTime.ofInstant(javaInstant, ZoneId.systemDefault());
		return DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(offsetDateTime);
	}
	private static Set<String> getMarkers(Marker marker) {
		Set<String> result = new TreeSet<>();
		addMarkers(result, marker);
		return result;
	}
	private static void addMarkers(Set<String> result, Marker marker) {
		result.add(marker.getName());
		if (marker.hasParents()) {
			for (Marker parent : marker.getParents()) {
				addMarkers(result, parent);
			}
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'enclosedInSquareBrackets', category = PatternConverter.CATEGORY)
@ConverterKeys('esb')
public final class EnclosedInSquareBracketsConverter extends LogEventPatternConverter {
	private final List<PatternFormatter> formatters;
	private EnclosedInSquareBracketsConverter(List<PatternFormatter> formatters) {
		super('enclosedInSquareBrackets', null);
		this.formatters = formatters;
	}
	@Override
	public void format(LogEvent event, StringBuilder toAppendTo) {
		StringBuilder buf = new StringBuilder();
		for (PatternFormatter formatter : this.formatters) {
			formatter.format(event, buf);
		}
		if (buf.isEmpty()) {
			return;
		}
		toAppendTo.append('[');
		toAppendTo.append(buf);
		toAppendTo.append('] ');
	}
	/**
	 * Creates a new instance of the class. Required by Log4J2.
	 * @param config the configuration
	 * @param options the options
	 * @return a new instance, or {@code null} if the options are invalid
	 */
	public static EnclosedInSquareBracketsConverter newInstance(Configuration config, String[] options) {
		if (options.length < 1) {
			LOGGER.error('Incorrect number of options on style. Expected at least 1, received {}', options.length);
			return null;
		}
		PatternParser parser = PatternLayout.createPatternParser(config);
		List<PatternFormatter> formatters = parser.parse(options[0]);
		return new EnclosedInSquareBracketsConverter(formatters);
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'spring', category = StrLookup.CATEGORY)
class SpringEnvironmentLookup implements LoggerContextAware, StrLookup {
	private volatile Environment environment;
	@Override
	public String lookup(LogEvent event, String key) {
		return lookup(key);
	}
	@Override
	public String lookup(String key) {
		Assert.state(this.environment != null,
				'Unable to obtain Spring Environment from LoggerContext. '
						+ 'This can happen if your log4j2 configuration filename does not end with "-spring" '
						+ '(for example using "log4j2.xml" instead of "log4j2-spring.xml")');
		return this.environment.getProperty(key);
	}
	@Override
	public void setLoggerContext(LoggerContext loggerContext) {
		this.environment = Log4J2LoggingSystem.getEnvironment(loggerContext);
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'color', category = PatternConverter.CATEGORY)
@ConverterKeys({ 'clr', 'color' })
public final class ColorConverter extends LogEventPatternConverter {
	private static final Map<String, AnsiElement> ELEMENTS;
	static {
		Map<String, AnsiElement> ansiElements = new HashMap<>();
		Arrays.stream(AnsiColor.values())
			.filter((color) -> color != AnsiColor.DEFAULT)
			.forEach((color) -> ansiElements.put(color.name().toLowerCase(Locale.ROOT), color));
		ansiElements.put('faint', AnsiStyle.FAINT);
		ELEMENTS = Collections.unmodifiableMap(ansiElements);
	}
	private static final Map<Integer, AnsiElement> LEVELS;
	static {
		Map<Integer, AnsiElement> ansiLevels = new HashMap<>();
		ansiLevels.put(Level.FATAL.intLevel(), AnsiColor.RED);
		ansiLevels.put(Level.ERROR.intLevel(), AnsiColor.RED);
		ansiLevels.put(Level.WARN.intLevel(), AnsiColor.YELLOW);
		LEVELS = Collections.unmodifiableMap(ansiLevels);
	}
	private final List<PatternFormatter> formatters;
	private final AnsiElement styling;
	private ColorConverter(List<PatternFormatter> formatters, AnsiElement styling) {
		super('style', 'style');
		this.formatters = formatters;
		this.styling = styling;
	}
	@Override
	public boolean handlesThrowable() {
		for (PatternFormatter formatter : this.formatters) {
			if (formatter.handlesThrowable()) {
				return true;
			}
		}
		return super.handlesThrowable();
	}
	@Override
	public void format(LogEvent event, StringBuilder toAppendTo) {
		StringBuilder buf = new StringBuilder();
		for (PatternFormatter formatter : this.formatters) {
			formatter.format(event, buf);
		}
		if (!buf.isEmpty()) {
			AnsiElement element = this.styling;
			if (element == null) {
				// Assume highlighting
				element = LEVELS.get(event.getLevel().intLevel());
				element = (element != null) ? element : AnsiColor.GREEN;
			}
			appendAnsiString(toAppendTo, buf.toString(), element);
		}
	}
	protected void appendAnsiString(StringBuilder toAppendTo, String in, AnsiElement element) {
		toAppendTo.append(AnsiOutput.toString(element, in));
	}
	/**
	 * Creates a new instance of the class. Required by Log4J2.
	 * @param config the configuration
	 * @param options the options
	 * @return a new instance, or {@code null} if the options are invalid
	 */
	public static ColorConverter newInstance(Configuration config, String[] options) {
		if (options.length < 1) {
			LOGGER.error('Incorrect number of options on style. Expected at least 1, received {}', options.length);
			return null;
		}
		if (options[0] == null) {
			LOGGER.error('No pattern supplied on style');
			return null;
		}
		PatternParser parser = PatternLayout.createPatternParser(config);
		List<PatternFormatter> formatters = parser.parse(options[0]);
		AnsiElement element = (options.length != 1) ? ELEMENTS.get(options[1]) : null;
		return new ColorConverter(formatters, element);
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class GraylogExtendedLogFormatStructuredLogFormatter extends JsonWriterStructuredLogFormatter<LogEvent> {
	private static final Log logger = LogFactory.getLog(GraylogExtendedLogFormatStructuredLogFormatter.class);
	/**
	 * Allowed characters in field names are any word character (letter, number,
	 * underscore), dashes and dots.
	 */
	private static final Pattern FIELD_NAME_VALID_PATTERN = Pattern.compile('^[\\w.\\-]*$');
	/**
	 * Libraries SHOULD not allow to send id as additional field ('_id'). Graylog server
	 * nodes omit this field automatically.
	 */
	private static final Set<String> ADDITIONAL_FIELD_ILLEGAL_KEYS = Set.of('id', '_id');
	GraylogExtendedLogFormatStructuredLogFormatter(Environment environment,
			StructureLoggingJsonMembersCustomizer<?> customizer) {
		super((members) -> jsonMembers(environment, members), customizer);
	}
	private static void jsonMembers(Environment environment, JsonWriter.Members<LogEvent> members) {
		members.add('version', '1.1');
		members.add('short_message', LogEvent::getMessage)
			.as(GraylogExtendedLogFormatStructuredLogFormatter::getMessageText);
		members.add('timestamp', LogEvent::getInstant)
			.as(GraylogExtendedLogFormatStructuredLogFormatter::formatTimeStamp);
		members.add('level', GraylogExtendedLogFormatStructuredLogFormatter::convertLevel);
		members.add('_level_name', LogEvent::getLevel).as(Level::name);
		members.add('_process_pid', environment.getProperty('spring.application.pid', Long.class))
			.when(Objects::nonNull);
		members.add('_process_thread_name', LogEvent::getThreadName);
		GraylogExtendedLogFormatProperties.get(environment).jsonMembers(members);
		members.add('_log_logger', LogEvent::getLoggerName);
		members.from(LogEvent::getContextData)
			.whenNot(ReadOnlyStringMap::isEmpty)
			.usingPairs(GraylogExtendedLogFormatStructuredLogFormatter::createAdditionalFields);
		members.add()
			.whenNotNull(LogEvent::getThrownProxy)
			.usingMembers(GraylogExtendedLogFormatStructuredLogFormatter::throwableMembers);
	}
	private static String getMessageText(Message message) {
		// Always return text as a blank message will lead to a error as of Graylog v6
		String formattedMessage = message.getFormattedMessage();
		return (!StringUtils.hasText(formattedMessage)) ? '(blank)' : formattedMessage;
	}
	/**
	 * GELF requires 'seconds since UNIX epoch with optional <b>decimal places for
	 * milliseconds</b>'. To comply with this requirement, we format a POSIX timestamp
	 * with millisecond precision as e.g. '1725459730385' -> '1725459730.385'
	 * @param timeStamp the timestamp of the log message.
	 * @return the timestamp formatted as string with millisecond precision
	 */
	private static WritableJson formatTimeStamp(Instant timeStamp) {
		return (out) -> out.append(new BigDecimal(timeStamp.getEpochMillisecond()).movePointLeft(3).toPlainString());
	}
	/**
	 * Converts the log4j2 event level to the Syslog event level code.
	 * @param event the log event
	 * @return an integer representing the syslog log level code
	 * @see Severity class from Log4j2 which contains the conversion logic
	 */
	private static int convertLevel(LogEvent event) {
		return Severity.getSeverity(event.getLevel()).getCode();
	}
	private static void throwableMembers(Members<LogEvent> members) {
		members.add('full_message', GraylogExtendedLogFormatStructuredLogFormatter::formatFullMessageWithThrowable);
		members.add('_error_type', (event) -> event.getThrownProxy().getThrowable())
			.whenNotNull()
			.as(ObjectUtils::nullSafeClassName);
		members.add('_error_stack_trace', (event) -> event.getThrownProxy().getExtendedStackTraceAsString());
		members.add('_error_message', (event) -> event.getThrownProxy().getMessage());
	}
	private static String formatFullMessageWithThrowable(LogEvent event) {
		return event.getMessage().getFormattedMessage() + '\n\n'
				+ event.getThrownProxy().getExtendedStackTraceAsString();
	}
	private static void createAdditionalFields(ReadOnlyStringMap contextData, BiConsumer<Object, Object> pairs) {
		contextData.forEach((name, value) -> createAdditionalField(name, value, pairs));
	}
	private static void createAdditionalField(String name, Object value, BiConsumer<Object, Object> pairs) {
		Assert.notNull(name, 'fieldName must not be null');
		if (!FIELD_NAME_VALID_PATTERN.matcher(name).matches()) {
			logger.warn(LogMessage.format('"%s" is not a valid field name according to GELF standard', name));
			return;
		}
		if (ADDITIONAL_FIELD_ILLEGAL_KEYS.contains(name)) {
			logger.warn(LogMessage.format('"%s" is an illegal field name according to GELF standard', name));
			return;
		}
		pairs.accept(asAdditionalFieldName(name), value);
	}
	private static Object asAdditionalFieldName(String name) {
		return (!name.startsWith('_')) ? '_' + name : name;
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'SpringBootConfigurationFactory', category = ConfigurationFactory.CATEGORY)
@Order(0)
public class SpringBootConfigurationFactory extends ConfigurationFactory {
	private static final String[] TYPES = { '.springboot' };
	@Override
	protected String[] getSupportedTypes() {
		return TYPES;
	}
	@Override
	public Configuration getConfiguration(LoggerContext loggerContext, ConfigurationSource source) {
		if (source == null || source == ConfigurationSource.NULL_SOURCE) {
			return null;
		}
		return new DefaultConfiguration();
	}
}
/*
/**
package org.springframework.boot.logging.log4j2;
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'SpringProfile', category = Node.CATEGORY, elementType = Arbiter.ELEMENT_TYPE, deferChildren = true,
		printObject = true)
final class SpringProfileArbiter implements Arbiter {
	private final Environment environment;
	private final Profiles profiles;
	private SpringProfileArbiter(Environment environment, String[] profiles) {
		this.environment = environment;
		this.profiles = Profiles.of(profiles);
	}
	@Override
	public boolean isCondition() {
		return (this.environment != null) && this.environment.acceptsProfiles(this.profiles);
	}
	@PluginBuilderFactory
	static Builder newBuilder() {
		return new Builder();
	}
	/**
	 * Standard Builder to create the Arbiter.
	 */
	static final class Builder implements org.apache.logging.log4j.core.util.Builder<SpringProfileArbiter> {
		private static final Logger statusLogger = StatusLogger.getLogger();
		@PluginBuilderAttribute
		private String name;
		@PluginConfiguration
		private Configuration configuration;
		@PluginLoggerContext
		private LoggerContext loggerContext;
		private Builder() {
		}
		/**
		 * Sets the profile name or expression.
		 * @param name the profile name or expression
		 * @return this
		 * @see Profiles#of(String...)
		 */
		Builder setName(String name) {
			this.name = name;
			return this;
		}
		@Override
		public SpringProfileArbiter build() {
			Environment environment = Log4J2LoggingSystem.getEnvironment(this.loggerContext);
			if (environment == null) {
				statusLogger.debug('Creating Arbiter without a Spring Environment');
			}
			String name = this.configuration.getStrSubstitutor().replace(this.name);
			String[] profiles = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));
			return new SpringProfileArbiter(environment, profiles);
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@Plugin(name = 'CorrelationIdConverter', category = PatternConverter.CATEGORY)
@ConverterKeys('correlationId')
@PerformanceSensitive('allocation')
public final class CorrelationIdConverter extends LogEventPatternConverter {
	private final CorrelationIdFormatter formatter;
	private CorrelationIdConverter(CorrelationIdFormatter formatter) {
		super('correlationId{%s}'.formatted(formatter), 'mdc');
		this.formatter = formatter;
	}
	@Override
	public void format(LogEvent event, StringBuilder toAppendTo) {
		ReadOnlyStringMap contextData = event.getContextData();
		this.formatter.formatTo(contextData::getValue, toAppendTo);
	}
	/**
	 * Factory method to create a new {@link CorrelationIdConverter}.
	 * @param options options, may be null or first element contains name of property to
	 * format.
	 * @return instance of PropertiesPatternConverter.
	 */
	public static CorrelationIdConverter newInstance(String[] options) {
		String pattern = (!ObjectUtils.isEmpty(options)) ? options[0] : null;
		return new CorrelationIdConverter(CorrelationIdFormatter.of(pattern));
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
final class StructuredMessage {
	private static final String JSON2 = 'JSON';
	private static final String[] JSON = { JSON2 };
	private StructuredMessage() {
	}
	static Object get(Message message) {
		if (message instanceof MultiFormatStringBuilderFormattable multiFormatMessage
				&& hasJsonFormat(multiFormatMessage)) {
			return WritableJson.of((out) -> formatTo(multiFormatMessage, out));
		}
		return message.getFormattedMessage();
	}
	private static boolean hasJsonFormat(MultiFormatStringBuilderFormattable message) {
		for (String format : message.getFormats()) {
			if (JSON2.equalsIgnoreCase(format)) {
				return true;
			}
		}
		return false;
	}
	private static void formatTo(MultiFormatStringBuilderFormattable message, Appendable out) throws IOException {
		if (out instanceof StringBuilder stringBuilder) {
			message.formatTo(JSON, stringBuilder);
		}
		else {
			out.append(message.getFormattedMessage(JSON));
		}
	}
}
/*
package org.springframework.boot.logging;
/**
public final class LoggerConfiguration {
	private final String name;
	private final LevelConfiguration levelConfiguration;
	private final LevelConfiguration inheritedLevelConfiguration;
	/**
	 * Create a new {@link LoggerConfiguration instance}.
	 * @param name the name of the logger
	 * @param configuredLevel the configured level of the logger
	 * @param effectiveLevel the effective level of the logger
	 */
	public LoggerConfiguration(String name, LogLevel configuredLevel, LogLevel effectiveLevel) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(effectiveLevel, 'EffectiveLevel must not be null');
		this.name = name;
		this.levelConfiguration = (configuredLevel != null) ? LevelConfiguration.of(configuredLevel) : null;
		this.inheritedLevelConfiguration = LevelConfiguration.of(effectiveLevel);
	}
	/**
	 * Create a new {@link LoggerConfiguration instance}.
	 * @param name the name of the logger
	 * @param levelConfiguration the level configuration
	 * @param inheritedLevelConfiguration the inherited level configuration
	 * @since 2.7.13
	 */
	public LoggerConfiguration(String name, LevelConfiguration levelConfiguration,
			LevelConfiguration inheritedLevelConfiguration) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(inheritedLevelConfiguration, 'InheritedLevelConfiguration must not be null');
		this.name = name;
		this.levelConfiguration = levelConfiguration;
		this.inheritedLevelConfiguration = inheritedLevelConfiguration;
	}
	/**
	 * Returns the name of the logger.
	 * @return the name of the logger
	 */
	public String getName() {
		return this.name;
	}
	/**
	 * Returns the configured level of the logger.
	 * @return the configured level of the logger
	 * @see #getLevelConfiguration(ConfigurationScope)
	 */
	public LogLevel getConfiguredLevel() {
		LevelConfiguration configuration = getLevelConfiguration(ConfigurationScope.DIRECT);
		return (configuration != null) ? configuration.getLevel() : null;
	}
	/**
	 * Returns the effective level of the logger.
	 * @return the effective level of the logger
	 * @see #getLevelConfiguration(ConfigurationScope)
	 */
	public LogLevel getEffectiveLevel() {
		return getLevelConfiguration().getLevel();
	}
	/**
	 * Return the level configuration, considering inherited loggers.
	 * @return the level configuration
	 * @since 2.7.13
	 */
	public LevelConfiguration getLevelConfiguration() {
		return getLevelConfiguration(ConfigurationScope.INHERITED);
	}
	/**
	 * Return the level configuration for the given scope.
	 * @param scope the configuration scope
	 * @return the level configuration or {@code null} for
	 * {@link ConfigurationScope#DIRECT direct scope} results without applied
	 * configuration
	 * @since 2.7.13
	 */
	public LevelConfiguration getLevelConfiguration(ConfigurationScope scope) {
		return (scope != ConfigurationScope.DIRECT) ? this.inheritedLevelConfiguration : this.levelConfiguration;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		LoggerConfiguration other = (LoggerConfiguration) obj;
		return ObjectUtils.nullSafeEquals(this.name, other.name)
				&& ObjectUtils.nullSafeEquals(this.levelConfiguration, other.levelConfiguration)
				&& ObjectUtils.nullSafeEquals(this.inheritedLevelConfiguration, other.inheritedLevelConfiguration);
	}
	@Override
	public int hashCode() {
		return Objects.hash(this.name, this.levelConfiguration, this.inheritedLevelConfiguration);
	}
	@Override
	public String toString() {
		return 'LoggerConfiguration [name=' + this.name + ', levelConfiguration=' + this.levelConfiguration
				+ ', inheritedLevelConfiguration=' + this.inheritedLevelConfiguration + ']';
	}
	/**
	 * Supported logger configuration scopes.
	 *
	 * @since 2.7.13
	 */
	public enum ConfigurationScope {
		/**
		 * Only return configuration that has been applied directly. Often referred to as
		 * "configured" or "assigned" configuration.
		 */
		DIRECT,
		/**
		 * May return configuration that has been applied to a parent logger. Often
		 * referred to as "effective" configuration.
		 */
		INHERITED
	}
	/**
	 * Logger level configuration.
	 *
	 * @since 2.7.13
	 */
	public static final class LevelConfiguration {
		private final String name;
		private final LogLevel logLevel;
		private LevelConfiguration(String name, LogLevel logLevel) {
			this.name = name;
			this.logLevel = logLevel;
		}
		/**
		 * Return the name of the level.
		 * @return the level name
		 */
		public String getName() {
			return this.name;
		}
		/**
		 * Return the actual level value if possible.
		 * @return the level value
		 * @throws IllegalStateException if this is a {@link #isCustom() custom} level
		 */
		public LogLevel getLevel() {
			Assert.state(this.logLevel != null, 'Unable to provide LogLevel for "' + this.name + '"');
			return this.logLevel;
		}
		/**
		 * Return if this is a custom level and cannot be represented by {@link LogLevel}.
		 * @return if this is a custom level
		 */
		public boolean isCustom() {
			return this.logLevel == null;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			LevelConfiguration other = (LevelConfiguration) obj;
			return this.logLevel == other.logLevel && ObjectUtils.nullSafeEquals(this.name, other.name);
		}
		@Override
		public int hashCode() {
			return Objects.hash(this.logLevel, this.name);
		}
		@Override
		public String toString() {
			return 'LevelConfiguration [name=' + this.name + ', logLevel=' + this.logLevel + ']';
		}
		/**
		 * Create a new {@link LevelConfiguration} instance of the given {@link LogLevel}.
		 * @param logLevel the log level
		 * @return a new {@link LevelConfiguration} instance
		 */
		public static LevelConfiguration of(LogLevel logLevel) {
			Assert.notNull(logLevel, 'LogLevel must not be null');
			return new LevelConfiguration(logLevel.name(), logLevel);
		}
		/**
		 * Create a new {@link LevelConfiguration} instance for a custom level name.
		 * @param name the log level name
		 * @return a new {@link LevelConfiguration} instance
		 */
		public static LevelConfiguration ofCustom(String name) {
			Assert.hasText(name, 'Name must not be empty');
			return new LevelConfiguration(name, null);
		}
	}
}
/*
package org.springframework.boot.logging;
/**
public enum LoggingSystemProperty {
	/**
	 * Logging system property for the application name that should be logged.
	 */
	APPLICATION_NAME('APPLICATION_NAME', 'spring.application.name', 'logging.include-application-name'),
	/**
	 * Logging system property for the application group that should be logged.
	 * @since 3.4.0
	 */
	APPLICATION_GROUP('APPLICATION_GROUP', 'spring.application.group', 'logging.include-application-group'),
	/**
	 * Logging system property for the process ID.
	 */
	PID('PID'),
	/**
	 * Logging system property for the log file.
	 */
	LOG_FILE('LOG_FILE'),
	/**
	 * Logging system property for the log path.
	 */
	LOG_PATH('LOG_PATH'),
	/**
	 * Logging system property for the console log charset.
	 */
	CONSOLE_CHARSET('CONSOLE_LOG_CHARSET', 'logging.charset.console'),
	/**
	 * Logging system property for the file log charset.
	 */
	FILE_CHARSET('FILE_LOG_CHARSET', 'logging.charset.file'),
	/**
	 * Logging system property for the console log.
	 */
	CONSOLE_THRESHOLD('CONSOLE_LOG_THRESHOLD', 'logging.threshold.console'),
	/**
	 * Logging system property for the file log.
	 */
	FILE_THRESHOLD('FILE_LOG_THRESHOLD', 'logging.threshold.file'),
	/**
	 * Logging system property for the exception conversion word.
	 */
	EXCEPTION_CONVERSION_WORD('LOG_EXCEPTION_CONVERSION_WORD', 'logging.exception-conversion-word'),
	/**
	 * Logging system property for the console log pattern.
	 */
	CONSOLE_PATTERN('CONSOLE_LOG_PATTERN', 'logging.pattern.console'),
	/**
	 * Logging system property for the file log pattern.
	 */
	FILE_PATTERN('FILE_LOG_PATTERN', 'logging.pattern.file'),
	/**
	 * Logging system property for the console structured logging format.
	 * @since 3.4.0
	 */
	CONSOLE_STRUCTURED_FORMAT('CONSOLE_LOG_STRUCTURED_FORMAT', 'logging.structured.format.console'),
	/**
	 * Logging system property for the file structured logging format.
	 * @since 3.4.0
	 */
	FILE_STRUCTURED_FORMAT('FILE_LOG_STRUCTURED_FORMAT', 'logging.structured.format.file'),
	/**
	 * Logging system property for the log level pattern.
	 */
	LEVEL_PATTERN('LOG_LEVEL_PATTERN', 'logging.pattern.level'),
	/**
	 * Logging system property for the date-format pattern.
	 */
	DATEFORMAT_PATTERN('LOG_DATEFORMAT_PATTERN', 'logging.pattern.dateformat'),
	/**
	 * Logging system property for the correlation pattern.
	 */
	CORRELATION_PATTERN('LOG_CORRELATION_PATTERN', 'logging.pattern.correlation');
	private final String environmentVariableName;
	private final String applicationPropertyName;
	private final String includePropertyName;
	LoggingSystemProperty(String environmentVariableName) {
		this(environmentVariableName, null);
	}
	LoggingSystemProperty(String environmentVariableName, String applicationPropertyName) {
		this(environmentVariableName, applicationPropertyName, null);
	}
	LoggingSystemProperty(String environmentVariableName, String applicationPropertyName, String includePropertyName) {
		this.environmentVariableName = environmentVariableName;
		this.applicationPropertyName = applicationPropertyName;
		this.includePropertyName = includePropertyName;
	}
	/**
	 * Return the name of environment variable that can be used to access this property.
	 * @return the environment variable name
	 */
	public String getEnvironmentVariableName() {
		return this.environmentVariableName;
	}
	/**
	 * Return the name of the application property name that can be used to set this
	 * property.
	 * @return the application property name
	 * @since 3.4.0
	 */
	public String getApplicationPropertyName() {
		return this.applicationPropertyName;
	}
	String getIncludePropertyName() {
		return this.includePropertyName;
	}
}
/*
package org.springframework.boot.logging;
/**
public class DeferredLog implements Log {
	private Log destination;
	private final Supplier<Log> destinationSupplier;
	private final Lines lines;
	/**
	 * Create a new {@link DeferredLog} instance.
	 */
	public DeferredLog() {
		this.destinationSupplier = null;
		this.lines = new Lines();
	}
	/**
	 * Create a new {@link DeferredLog} instance managed by a {@link DeferredLogFactory}.
	 * @param destination the switch-over destination
	 * @param lines the lines backing all related deferred logs
	 * @since 2.4.0
	 */
	DeferredLog(Supplier<Log> destination, Lines lines) {
		Assert.notNull(destination, 'Destination must not be null');
		this.destinationSupplier = destination;
		this.lines = lines;
	}
	@Override
	public boolean isTraceEnabled() {
		synchronized (this.lines) {
			return (this.destination == null) || this.destination.isTraceEnabled();
		}
	}
	@Override
	public boolean isDebugEnabled() {
		synchronized (this.lines) {
			return (this.destination == null) || this.destination.isDebugEnabled();
		}
	}
	@Override
	public boolean isInfoEnabled() {
		synchronized (this.lines) {
			return (this.destination == null) || this.destination.isInfoEnabled();
		}
	}
	@Override
	public boolean isWarnEnabled() {
		synchronized (this.lines) {
			return (this.destination == null) || this.destination.isWarnEnabled();
		}
	}
	@Override
	public boolean isErrorEnabled() {
		synchronized (this.lines) {
			return (this.destination == null) || this.destination.isErrorEnabled();
		}
	}
	@Override
	public boolean isFatalEnabled() {
		synchronized (this.lines) {
			return (this.destination == null) || this.destination.isFatalEnabled();
		}
	}
	@Override
	public void trace(Object message) {
		log(LogLevel.TRACE, message, null);
	}
	@Override
	public void trace(Object message, Throwable t) {
		log(LogLevel.TRACE, message, t);
	}
	@Override
	public void debug(Object message) {
		log(LogLevel.DEBUG, message, null);
	}
	@Override
	public void debug(Object message, Throwable t) {
		log(LogLevel.DEBUG, message, t);
	}
	@Override
	public void info(Object message) {
		log(LogLevel.INFO, message, null);
	}
	@Override
	public void info(Object message, Throwable t) {
		log(LogLevel.INFO, message, t);
	}
	@Override
	public void warn(Object message) {
		log(LogLevel.WARN, message, null);
	}
	@Override
	public void warn(Object message, Throwable t) {
		log(LogLevel.WARN, message, t);
	}
	@Override
	public void error(Object message) {
		log(LogLevel.ERROR, message, null);
	}
	@Override
	public void error(Object message, Throwable t) {
		log(LogLevel.ERROR, message, t);
	}
	@Override
	public void fatal(Object message) {
		log(LogLevel.FATAL, message, null);
	}
	@Override
	public void fatal(Object message, Throwable t) {
		log(LogLevel.FATAL, message, t);
	}
	private void log(LogLevel level, Object message, Throwable t) {
		synchronized (this.lines) {
			if (this.destination != null) {
				logTo(this.destination, level, message, t);
			}
			else {
				this.lines.add(this.destinationSupplier, level, message, t);
			}
		}
	}
	void switchOver() {
		synchronized (this.lines) {
			this.destination = this.destinationSupplier.get();
		}
	}
	/**
	 * Switch from deferred logging to immediate logging to the specified destination.
	 * @param destination the new log destination
	 * @since 2.1.0
	 */
	public void switchTo(Class<?> destination) {
		switchTo(LogFactory.getLog(destination));
	}
	/**
	 * Switch from deferred logging to immediate logging to the specified destination.
	 * @param destination the new log destination
	 * @since 2.1.0
	 */
	public void switchTo(Log destination) {
		synchronized (this.lines) {
			replayTo(destination);
			this.destination = destination;
		}
	}
	/**
	 * Replay deferred logging to the specified destination.
	 * @param destination the destination for the deferred log messages
	 */
	public void replayTo(Class<?> destination) {
		replayTo(LogFactory.getLog(destination));
	}
	/**
	 * Replay deferred logging to the specified destination.
	 * @param destination the destination for the deferred log messages
	 */
	public void replayTo(Log destination) {
		synchronized (this.lines) {
			for (Line line : this.lines) {
				logTo(destination, line.getLevel(), line.getMessage(), line.getThrowable());
			}
			this.lines.clear();
		}
	}
	/**
	 * Replay from a source log to a destination log when the source is deferred.
	 * @param source the source logger
	 * @param destination the destination logger class
	 * @return the destination
	 */
	public static Log replay(Log source, Class<?> destination) {
		return replay(source, LogFactory.getLog(destination));
	}
	/**
	 * Replay from a source log to a destination log when the source is deferred.
	 * @param source the source logger
	 * @param destination the destination logger
	 * @return the destination
	 */
	public static Log replay(Log source, Log destination) {
		if (source instanceof DeferredLog deferredLog) {
			deferredLog.replayTo(destination);
		}
		return destination;
	}
	static void logTo(Log log, LogLevel level, Object message, Throwable throwable) {
		switch (level) {
			case TRACE -> log.trace(message, throwable);
			case DEBUG -> log.debug(message, throwable);
			case INFO -> log.info(message, throwable);
			case WARN -> log.warn(message, throwable);
			case ERROR -> log.error(message, throwable);
			case FATAL -> log.fatal(message, throwable);
		}
	}
	static class Lines implements Iterable<Line> {
		private final List<Line> lines = new ArrayList<>();
		void add(Supplier<Log> destinationSupplier, LogLevel level, Object message, Throwable throwable) {
			this.lines.add(new Line(destinationSupplier, level, message, throwable));
		}
		void clear() {
			this.lines.clear();
		}
		@Override
		public Iterator<Line> iterator() {
			return this.lines.iterator();
		}
	}
	static class Line {
		private final Supplier<Log> destinationSupplier;
		private final LogLevel level;
		private final Object message;
		private final Throwable throwable;
		Line(Supplier<Log> destinationSupplier, LogLevel level, Object message, Throwable throwable) {
			this.destinationSupplier = destinationSupplier;
			this.level = level;
			this.message = message;
			this.throwable = throwable;
		}
		Log getDestination() {
			return this.destinationSupplier.get();
		}
		LogLevel getLevel() {
			return this.level;
		}
		Object getMessage() {
			return this.message;
		}
		Throwable getThrowable() {
			return this.throwable;
		}
	}
}
/*
package org.springframework.boot.logging;
/**
public interface LoggingSystemFactory {
	/**
	 * Return a logging system implementation or {@code null} if no logging system is
	 * available.
	 * @param classLoader the class loader to use
	 * @return a logging system
	 */
	LoggingSystem getLoggingSystem(ClassLoader classLoader);
	/**
	 * Return a {@link LoggingSystemFactory} backed by {@code spring.factories}.
	 * @return a {@link LoggingSystemFactory} instance
	 */
	static LoggingSystemFactory fromSpringFactories() {
		return new DelegatingLoggingSystemFactory(
				(classLoader) -> SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader));
	}
}
/*
package org.springframework.boot.logging;
/**
public abstract class AbstractLoggingSystem extends LoggingSystem {
	protected static final Comparator<LoggerConfiguration> CONFIGURATION_COMPARATOR = new LoggerConfigurationComparator(
			ROOT_LOGGER_NAME);
	private final ClassLoader classLoader;
	public AbstractLoggingSystem(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	@Override
	public void beforeInitialize() {
	}
	@Override
	public void initialize(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile) {
		if (StringUtils.hasLength(configLocation)) {
			initializeWithSpecificConfig(initializationContext, configLocation, logFile);
			return;
		}
		initializeWithConventions(initializationContext, logFile);
	}
	private void initializeWithSpecificConfig(LoggingInitializationContext initializationContext, String configLocation,
			LogFile logFile) {
		configLocation = SystemPropertyUtils.resolvePlaceholders(configLocation);
		loadConfiguration(initializationContext, configLocation, logFile);
	}
	private void initializeWithConventions(LoggingInitializationContext initializationContext, LogFile logFile) {
		String config = getSelfInitializationConfig();
		if (config != null && logFile == null) {
			// self initialization has occurred, reinitialize in case of property changes
			reinitialize(initializationContext);
			return;
		}
		if (config == null) {
			config = getSpringInitializationConfig();
		}
		if (config != null) {
			loadConfiguration(initializationContext, config, logFile);
			return;
		}
		loadDefaults(initializationContext, logFile);
	}
	/**
	 * Return any self initialization config that has been applied. By default this method
	 * checks {@link #getStandardConfigLocations()} and assumes that any file that exists
	 * will have been applied.
	 * @return the self initialization config or {@code null}
	 */
	protected String getSelfInitializationConfig() {
		return findConfig(getStandardConfigLocations());
	}
	/**
	 * Return any spring specific initialization config that should be applied. By default
	 * this method checks {@link #getSpringConfigLocations()}.
	 * @return the spring initialization config or {@code null}
	 */
	protected String getSpringInitializationConfig() {
		return findConfig(getSpringConfigLocations());
	}
	private String findConfig(String[] locations) {
		for (String location : locations) {
			ClassPathResource resource = new ClassPathResource(location, this.classLoader);
			if (resource.exists()) {
				return 'classpath:' + location;
			}
		}
		return null;
	}
	/**
	 * Return the standard config locations for this system.
	 * @return the standard config locations
	 * @see #getSelfInitializationConfig()
	 */
	protected abstract String[] getStandardConfigLocations();
	/**
	 * Return the spring config locations for this system. By default this method returns
	 * a set of locations based on {@link #getStandardConfigLocations()}.
	 * @return the spring config locations
	 * @see #getSpringInitializationConfig()
	 */
	protected String[] getSpringConfigLocations() {
		String[] locations = getStandardConfigLocations();
		for (int i = 0; i < locations.length; i++) {
			String extension = StringUtils.getFilenameExtension(locations[i]);
			locations[i] = locations[i].substring(0, locations[i].length() - extension.length() - 1) + '-spring.'
					+ extension;
		}
		return locations;
	}
	/**
	 * Load sensible defaults for the logging system.
	 * @param initializationContext the logging initialization context
	 * @param logFile the file to load or {@code null} if no log file is to be written
	 */
	protected abstract void loadDefaults(LoggingInitializationContext initializationContext, LogFile logFile);
	/**
	 * Load a specific configuration.
	 * @param initializationContext the logging initialization context
	 * @param location the location of the configuration to load (never {@code null})
	 * @param logFile the file to load or {@code null} if no log file is to be written
	 */
	protected abstract void loadConfiguration(LoggingInitializationContext initializationContext, String location,
			LogFile logFile);
	/**
	 * Reinitialize the logging system if required. Called when
	 * {@link #getSelfInitializationConfig()} is used and the log file hasn"t changed. May
	 * be used to reload configuration (for example to pick up additional System
	 * properties).
	 * @param initializationContext the logging initialization context
	 */
	protected void reinitialize(LoggingInitializationContext initializationContext) {
	}
	protected final ClassLoader getClassLoader() {
		return this.classLoader;
	}
	protected final String getPackagedConfigFile(String fileName) {
		String defaultPath = ClassUtils.getPackageName(getClass());
		defaultPath = defaultPath.replace(".", "/");
		defaultPath = defaultPath + '/' + fileName;
		defaultPath = 'classpath:' + defaultPath;
		return defaultPath;
	}
	protected final void applySystemProperties(Environment environment, LogFile logFile) {
		new LoggingSystemProperties(environment, getDefaultValueResolver(environment), null).apply(logFile);
	}
	/**
	 * Return the default value resolver to use when resolving system properties.
	 * @param environment the environment
	 * @return the default value resolver
	 * @since 3.2.0
	 */
	protected Function<String, String> getDefaultValueResolver(Environment environment) {
		String defaultLogCorrelationPattern = getDefaultLogCorrelationPattern();
		return (name) -> {
			if (StringUtils.hasLength(defaultLogCorrelationPattern)
					&& LoggingSystemProperty.CORRELATION_PATTERN.getApplicationPropertyName().equals(name)
					&& environment.getProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, Boolean.class, false)) {
				return defaultLogCorrelationPattern;
			}
			return null;
		};
	}
	/**
	 * Return the default log correlation pattern or {@code null} if log correlation
	 * patterns are not supported.
	 * @return the default log correlation pattern
	 * @since 3.2.0
	 */
	protected String getDefaultLogCorrelationPattern() {
		return null;
	}
	/**
	 * Maintains a mapping between native levels and {@link LogLevel}.
	 *
	 * @param <T> the native level type
	 */
	protected static class LogLevels<T> {
		private final Map<LogLevel, T> systemToNative;
		private final Map<T, LogLevel> nativeToSystem;
		public LogLevels() {
			this.systemToNative = new EnumMap<>(LogLevel.class);
			this.nativeToSystem = new HashMap<>();
		}
		public void map(LogLevel system, T nativeLevel) {
			this.systemToNative.putIfAbsent(system, nativeLevel);
			this.nativeToSystem.putIfAbsent(nativeLevel, system);
		}
		public LogLevel convertNativeToSystem(T level) {
			return this.nativeToSystem.get(level);
		}
		public T convertSystemToNative(LogLevel level) {
			return this.systemToNative.get(level);
		}
		public Set<LogLevel> getSupported() {
			return new LinkedHashSet<>(this.nativeToSystem.values());
		}
	}
}
/*
package org.springframework.boot.logging;
/**
public final class LoggerGroup {
	private final String name;
	private final List<String> members;
	private LogLevel configuredLevel;
	LoggerGroup(String name, List<String> members) {
		this.name = name;
		this.members = Collections.unmodifiableList(new ArrayList<>(members));
	}
	public String getName() {
		return this.name;
	}
	public List<String> getMembers() {
		return this.members;
	}
	public boolean hasMembers() {
		return !this.members.isEmpty();
	}
	public LogLevel getConfiguredLevel() {
		return this.configuredLevel;
	}
	public void configureLogLevel(LogLevel level, BiConsumer<String, LogLevel> configurer) {
		this.configuredLevel = level;
		this.members.forEach((name) -> configurer.accept(name, level));
	}
}
/*
package org.springframework.boot.logging;
/**
public class DeferredLogs implements DeferredLogFactory {
	private final Lines lines = new Lines();
	private final List<DeferredLog> loggers = new ArrayList<>();
	/**
	 * Create a new {@link DeferredLog} for the given destination.
	 * @param destination the ultimate log destination
	 * @return a deferred log instance that will switch to the destination when
	 * appropriate.
	 */
	@Override
	public Log getLog(Class<?> destination) {
		return getLog(() -> LogFactory.getLog(destination));
	}
	/**
	 * Create a new {@link DeferredLog} for the given destination.
	 * @param destination the ultimate log destination
	 * @return a deferred log instance that will switch to the destination when
	 * appropriate.
	 */
	@Override
	public Log getLog(Log destination) {
		return getLog(() -> destination);
	}
	/**
	 * Create a new {@link DeferredLog} for the given destination.
	 * @param destination the ultimate log destination
	 * @return a deferred log instance that will switch to the destination when
	 * appropriate.
	 */
	@Override
	public Log getLog(Supplier<Log> destination) {
		synchronized (this.lines) {
			DeferredLog logger = new DeferredLog(destination, this.lines);
			this.loggers.add(logger);
			return logger;
		}
	}
	/**
	 * Switch over all deferred logs to their supplied destination.
	 */
	public void switchOverAll() {
		synchronized (this.lines) {
			for (Line line : this.lines) {
				DeferredLog.logTo(line.getDestination(), line.getLevel(), line.getMessage(), line.getThrowable());
			}
			for (DeferredLog logger : this.loggers) {
				logger.switchOver();
			}
			this.lines.clear();
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringProfileIfNestedWithinSecondPhaseElementSanityChecker extends ContextAwareBase implements SanityChecker {
	private static final List<Class<? extends Model>> SECOND_PHASE_TYPES = List.of(AppenderModel.class,
			LoggerModel.class, RootLoggerModel.class);
	@Override
	public void check(Model model) {
		if (model == null) {
			return;
		}
		List<Model> models = new ArrayList<>();
		SECOND_PHASE_TYPES.forEach((type) -> deepFindAllModelsOfType(type, models, model));
		List<Pair<Model, Model>> nestedPairs = deepFindNestedSubModelsOfType(SpringProfileModel.class, models);
		if (!nestedPairs.isEmpty()) {
			addWarn('<springProfile> elements cannot be nested within an <appender>, <logger> or <root> element');
			nestedPairs.forEach((nested) -> {
				Model first = nested.first;
				Model second = nested.second;
				addWarn('Element <%s> at line %s contains a nested <%s> element at line %s'.formatted(first.getTag(),
						first.getLineNumber(), second.getTag(), second.getLineNumber()));
			});
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class LogbackLoggingSystem extends AbstractLoggingSystem implements BeanFactoryInitializationAotProcessor {
	private static final String BRIDGE_HANDLER = 'org.slf4j.bridge.SLF4JBridgeHandler';
	private static final String CONFIGURATION_FILE_PROPERTY = 'logback.configurationFile';
	private static final LogLevels<Level> LEVELS = createLogLevels();
	@SuppressWarnings('deprecation')
	private static LogLevels<Level> createLogLevels() {
		LogLevels<Level> levels = new LogLevels<>();
		levels.map(LogLevel.TRACE, Level.TRACE);
		levels.map(LogLevel.TRACE, Level.ALL);
		levels.map(LogLevel.DEBUG, Level.DEBUG);
		levels.map(LogLevel.INFO, Level.INFO);
		levels.map(LogLevel.WARN, Level.WARN);
		levels.map(LogLevel.ERROR, Level.ERROR);
		levels.map(LogLevel.FATAL, Level.ERROR);
		levels.map(LogLevel.OFF, Level.OFF);
		return levels;
	}
	private static final TurboFilter SUPPRESS_ALL_FILTER = new TurboFilter() {
		@Override
		public FilterReply decide(Marker marker, ch.qos.logback.classic.Logger logger, Level level, String format,
				Object[] params, Throwable t) {
			return FilterReply.DENY;
		}
	};
	private final StatusPrinter2 statusPrinter = new StatusPrinter2();
	public LogbackLoggingSystem(ClassLoader classLoader) {
		super(classLoader);
	}
	@Override
	public LoggingSystemProperties getSystemProperties(ConfigurableEnvironment environment) {
		return new LogbackLoggingSystemProperties(environment, getDefaultValueResolver(environment), null);
	}
	@Override
	protected String[] getStandardConfigLocations() {
		return new String[] { 'logback-test.groovy', 'logback-test.xml', 'logback.groovy', 'logback.xml' };
	}
	@Override
	public void beforeInitialize() {
		LoggerContext loggerContext = getLoggerContext();
		if (isAlreadyInitialized(loggerContext)) {
			return;
		}
		super.beforeInitialize();
		configureJdkLoggingBridgeHandler();
		loggerContext.getTurboFilterList().add(SUPPRESS_ALL_FILTER);
	}
	private void configureJdkLoggingBridgeHandler() {
		try {
			if (isBridgeJulIntoSlf4j()) {
				removeJdkLoggingBridgeHandler();
				SLF4JBridgeHandler.install();
			}
		}
		catch (Throwable ex) {
			// Ignore. No java.util.logging bridge is installed.
		}
	}
	private boolean isBridgeJulIntoSlf4j() {
		return isBridgeHandlerAvailable() && isJulUsingASingleConsoleHandlerAtMost();
	}
	private boolean isBridgeHandlerAvailable() {
		return ClassUtils.isPresent(BRIDGE_HANDLER, getClassLoader());
	}
	private boolean isJulUsingASingleConsoleHandlerAtMost() {
		java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger('');
		Handler[] handlers = rootLogger.getHandlers();
		return handlers.length == 0 || (handlers.length == 1 && handlers[0] instanceof ConsoleHandler);
	}
	private void removeJdkLoggingBridgeHandler() {
		try {
			removeDefaultRootHandler();
			SLF4JBridgeHandler.uninstall();
		}
		catch (Throwable ex) {
			// Ignore and continue
		}
	}
	private void removeDefaultRootHandler() {
		try {
			java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger('');
			Handler[] handlers = rootLogger.getHandlers();
			if (handlers.length == 1 && handlers[0] instanceof ConsoleHandler) {
				rootLogger.removeHandler(handlers[0]);
			}
		}
		catch (Throwable ex) {
			// Ignore and continue
		}
	}
	@Override
	public void initialize(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile) {
		LoggerContext loggerContext = getLoggerContext();
		putInitializationContextObjects(loggerContext, initializationContext);
		if (isAlreadyInitialized(loggerContext)) {
			return;
		}
		if (!initializeFromAotGeneratedArtifactsIfPossible(initializationContext, logFile)) {
			super.initialize(initializationContext, configLocation, logFile);
		}
		loggerContext.getTurboFilterList().remove(SUPPRESS_ALL_FILTER);
		markAsInitialized(loggerContext);
		if (StringUtils.hasText(System.getProperty(CONFIGURATION_FILE_PROPERTY))) {
			getLogger(LogbackLoggingSystem.class.getName()).warn('Ignoring "' + CONFIGURATION_FILE_PROPERTY
					+ '" system property. Please use "logging.config" instead.');
		}
	}
	private boolean initializeFromAotGeneratedArtifactsIfPossible(LoggingInitializationContext initializationContext,
			LogFile logFile) {
		if (!AotDetector.useGeneratedArtifacts()) {
			return false;
		}
		if (initializationContext != null) {
			applySystemProperties(initializationContext.getEnvironment(), logFile);
		}
		LoggerContext loggerContext = getLoggerContext();
		stopAndReset(loggerContext);
		withLoggingSuppressed(() -> putInitializationContextObjects(loggerContext, initializationContext));
		SpringBootJoranConfigurator configurator = new SpringBootJoranConfigurator(initializationContext);
		configurator.setContext(loggerContext);
		boolean configuredUsingAotGeneratedArtifacts = configurator.configureUsingAotGeneratedArtifacts();
		if (configuredUsingAotGeneratedArtifacts) {
			reportConfigurationErrorsIfNecessary(loggerContext);
		}
		return configuredUsingAotGeneratedArtifacts;
	}
	@Override
	protected void loadDefaults(LoggingInitializationContext initializationContext, LogFile logFile) {
		LoggerContext loggerContext = getLoggerContext();
		stopAndReset(loggerContext);
		withLoggingSuppressed(() -> {
			putInitializationContextObjects(loggerContext, initializationContext);
			boolean debug = Boolean.getBoolean('logback.debug');
			if (debug) {
				StatusListenerConfigHelper.addOnConsoleListenerInstance(loggerContext, new OnConsoleStatusListener());
			}
			Environment environment = initializationContext.getEnvironment();
			// Apply system properties directly in case the same JVM runs multiple apps
			new LogbackLoggingSystemProperties(environment, getDefaultValueResolver(environment),
					loggerContext::putProperty)
				.apply(logFile);
			LogbackConfigurator configurator = debug ? new DebugLogbackConfigurator(loggerContext)
					: new LogbackConfigurator(loggerContext);
			new DefaultLogbackConfiguration(logFile).apply(configurator);
			loggerContext.setPackagingDataEnabled(true);
			loggerContext.start();
		});
	}
	@Override
	protected void loadConfiguration(LoggingInitializationContext initializationContext, String location,
			LogFile logFile) {
		LoggerContext loggerContext = getLoggerContext();
		stopAndReset(loggerContext);
		withLoggingSuppressed(() -> {
			putInitializationContextObjects(loggerContext, initializationContext);
			if (initializationContext != null) {
				applySystemProperties(initializationContext.getEnvironment(), logFile);
			}
			try {
				Resource resource = ApplicationResourceLoader.get().getResource(location);
				configureByResourceUrl(initializationContext, loggerContext, resource.getURL());
			}
			catch (Exception ex) {
				throw new IllegalStateException('Could not initialize Logback logging from ' + location, ex);
			}
			loggerContext.start();
		});
		reportConfigurationErrorsIfNecessary(loggerContext);
	}
	private void reportConfigurationErrorsIfNecessary(LoggerContext loggerContext) {
		StringBuilder errors = new StringBuilder();
		List<Throwable> suppressedExceptions = new ArrayList<>();
		for (Status status : loggerContext.getStatusManager().getCopyOfStatusList()) {
			if (status.getLevel() == Status.ERROR) {
				errors.append((!errors.isEmpty()) ? String.format('%n') : '');
				errors.append(status);
				if (status.getThrowable() != null) {
					suppressedExceptions.add(status.getThrowable());
				}
			}
		}
		if (errors.isEmpty()) {
			if (!StatusUtil.contextHasStatusListener(loggerContext)) {
				this.statusPrinter.printInCaseOfErrorsOrWarnings(loggerContext);
			}
			return;
		}
		IllegalStateException ex = new IllegalStateException(
				String.format('Logback configuration error detected: %n%s', errors));
		suppressedExceptions.forEach(ex::addSuppressed);
		throw ex;
	}
	private void configureByResourceUrl(LoggingInitializationContext initializationContext, LoggerContext loggerContext,
			URL url) throws JoranException {
		if (url.getPath().endsWith('.xml')) {
			JoranConfigurator configurator = new SpringBootJoranConfigurator(initializationContext);
			configurator.setContext(loggerContext);
			configurator.doConfigure(url);
		}
		else {
			throw new IllegalArgumentException('Unsupported file extension in "' + url + '". Only .xml is supported');
		}
	}
	private void stopAndReset(LoggerContext loggerContext) {
		loggerContext.stop();
		loggerContext.reset();
		if (isBridgeHandlerInstalled()) {
			addLevelChangePropagator(loggerContext);
		}
	}
	private boolean isBridgeHandlerInstalled() {
		if (!isBridgeHandlerAvailable()) {
			return false;
		}
		java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger('');
		Handler[] handlers = rootLogger.getHandlers();
		return handlers.length == 1 && handlers[0] instanceof SLF4JBridgeHandler;
	}
	private void addLevelChangePropagator(LoggerContext loggerContext) {
		LevelChangePropagator levelChangePropagator = new LevelChangePropagator();
		levelChangePropagator.setResetJUL(true);
		levelChangePropagator.setContext(loggerContext);
		loggerContext.addListener(levelChangePropagator);
	}
	@Override
	public void cleanUp() {
		LoggerContext context = getLoggerContext();
		markAsUninitialized(context);
		super.cleanUp();
		if (isBridgeHandlerAvailable()) {
			removeJdkLoggingBridgeHandler();
		}
		context.getStatusManager().clear();
		context.getTurboFilterList().remove(SUPPRESS_ALL_FILTER);
	}
	@Override
	protected void reinitialize(LoggingInitializationContext initializationContext) {
		LoggerContext loggerContext = getLoggerContext();
		loggerContext.reset();
		loggerContext.getStatusManager().clear();
		loadConfiguration(initializationContext, getSelfInitializationConfig(), null);
	}
	private void putInitializationContextObjects(LoggerContext loggerContext,
			LoggingInitializationContext initializationContext) {
		withLoggingSuppressed(
				() -> loggerContext.putObject(Environment.class.getName(), initializationContext.getEnvironment()));
	}
	@Override
	public List<LoggerConfiguration> getLoggerConfigurations() {
		List<LoggerConfiguration> result = new ArrayList<>();
		for (ch.qos.logback.classic.Logger logger : getLoggerContext().getLoggerList()) {
			result.add(getLoggerConfiguration(logger));
		}
		result.sort(CONFIGURATION_COMPARATOR);
		return result;
	}
	@Override
	public LoggerConfiguration getLoggerConfiguration(String loggerName) {
		String name = getLoggerName(loggerName);
		LoggerContext loggerContext = getLoggerContext();
		return getLoggerConfiguration(loggerContext.exists(name));
	}
	private String getLoggerName(String name) {
		if (!StringUtils.hasLength(name) || Logger.ROOT_LOGGER_NAME.equals(name)) {
			return ROOT_LOGGER_NAME;
		}
		return name;
	}
	private LoggerConfiguration getLoggerConfiguration(ch.qos.logback.classic.Logger logger) {
		if (logger == null) {
			return null;
		}
		LogLevel level = LEVELS.convertNativeToSystem(logger.getLevel());
		LogLevel effectiveLevel = LEVELS.convertNativeToSystem(logger.getEffectiveLevel());
		String name = getLoggerName(logger.getName());
		return new LoggerConfiguration(name, level, effectiveLevel);
	}
	@Override
	public Set<LogLevel> getSupportedLogLevels() {
		return LEVELS.getSupported();
	}
	@Override
	public void setLogLevel(String loggerName, LogLevel level) {
		ch.qos.logback.classic.Logger logger = getLogger(loggerName);
		if (logger != null) {
			logger.setLevel(LEVELS.convertSystemToNative(level));
		}
	}
	@Override
	public Runnable getShutdownHandler() {
		return () -> getLoggerContext().stop();
	}
	private ch.qos.logback.classic.Logger getLogger(String name) {
		LoggerContext factory = getLoggerContext();
		return factory.getLogger(getLoggerName(name));
	}
	private LoggerContext getLoggerContext() {
		ILoggerFactory factory = getLoggerFactory();
		Assert.isInstanceOf(LoggerContext.class, factory,
				() -> String.format(
						'LoggerFactory is not a Logback LoggerContext but Logback is on '
								+ 'the classpath. Either remove Logback or the competing '
								+ 'implementation (%s loaded from %s). If you are using '
								+ 'WebLogic you will need to add "org.slf4j" to '
								+ 'prefer-application-packages in WEB-INF/weblogic.xml',
						factory.getClass(), getLocation(factory)));
		return (LoggerContext) factory;
	}
	private ILoggerFactory getLoggerFactory() {
		ILoggerFactory factory = LoggerFactory.getILoggerFactory();
		while (factory instanceof SubstituteLoggerFactory) {
			try {
				Thread.sleep(50);
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
				throw new IllegalStateException('Interrupted while waiting for non-substitute logger factory', ex);
			}
			factory = LoggerFactory.getILoggerFactory();
		}
		return factory;
	}
	private Object getLocation(ILoggerFactory factory) {
		try {
			ProtectionDomain protectionDomain = factory.getClass().getProtectionDomain();
			CodeSource codeSource = protectionDomain.getCodeSource();
			if (codeSource != null) {
				return codeSource.getLocation();
			}
		}
		catch (SecurityException ex) {
			// Unable to determine location
		}
		return 'unknown location';
	}
	private boolean isAlreadyInitialized(LoggerContext loggerContext) {
		return loggerContext.getObject(LoggingSystem.class.getName()) != null;
	}
	private void markAsInitialized(LoggerContext loggerContext) {
		loggerContext.putObject(LoggingSystem.class.getName(), new Object());
	}
	private void markAsUninitialized(LoggerContext loggerContext) {
		loggerContext.removeObject(LoggingSystem.class.getName());
	}
	@Override
	protected String getDefaultLogCorrelationPattern() {
		return '%correlationId';
	}
	@Override
	public BeanFactoryInitializationAotContribution processAheadOfTime(ConfigurableListableBeanFactory beanFactory) {
		String key = BeanFactoryInitializationAotContribution.class.getName();
		LoggerContext context = getLoggerContext();
		BeanFactoryInitializationAotContribution contribution = (BeanFactoryInitializationAotContribution) context
			.getObject(key);
		context.removeObject(key);
		return contribution;
	}
	private void withLoggingSuppressed(Runnable action) {
		TurboFilterList turboFilters = getLoggerContext().getTurboFilterList();
		turboFilters.add(SUPPRESS_ALL_FILTER);
		try {
			action.run();
		}
		finally {
			turboFilters.remove(SUPPRESS_ALL_FILTER);
		}
	}
	void setStatusPrinterStream(PrintStream stream) {
		this.statusPrinter.setPrintStream(stream);
	}
	/**
	 * {@link LoggingSystemFactory} that returns {@link LogbackLoggingSystem} if possible.
	 */
	@Order(Ordered.LOWEST_PRECEDENCE)
	public static class Factory implements LoggingSystemFactory {
		private static final boolean PRESENT = ClassUtils.isPresent('ch.qos.logback.classic.LoggerContext',
				Factory.class.getClassLoader());
		@Override
		public LoggingSystem getLoggingSystem(ClassLoader classLoader) {
			if (PRESENT) {
				return new LogbackLoggingSystem(classLoader);
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringProfileModel extends NamedModel {
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringProfileAction extends BaseModelAction {
	@Override
	protected Model buildCurrentModel(SaxEventInterpretationContext interpretationContext, String name,
			Attributes attributes) {
		SpringProfileModel model = new SpringProfileModel();
		model.setName(attributes.getValue(NAME_ATTRIBUTE));
		return model;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class LogbackLoggingSystemProperties extends LoggingSystemProperties {
	private static final boolean JBOSS_LOGGING_PRESENT = ClassUtils.isPresent('org.jboss.logging.Logger',
			LogbackLoggingSystemProperties.class.getClassLoader());
	public LogbackLoggingSystemProperties(Environment environment) {
		super(environment);
	}
	/**
	 * Create a new {@link LogbackLoggingSystemProperties} instance.
	 * @param environment the source environment
	 * @param setter setter used to apply the property
	 * @since 2.4.3
	 */
	public LogbackLoggingSystemProperties(Environment environment, BiConsumer<String, String> setter) {
		super(environment, setter);
	}
	/**
	 * Create a new {@link LoggingSystemProperties} instance.
	 * @param environment the source environment
	 * @param defaultValueResolver function used to resolve default values or {@code null}
	 * @param setter setter used to apply the property or {@code null} for system
	 * properties
	 * @since 3.2.0
	 */
	public LogbackLoggingSystemProperties(Environment environment, Function<String, String> defaultValueResolver,
			BiConsumer<String, String> setter) {
		super(environment, defaultValueResolver, setter);
	}
	@Override
	protected Charset getDefaultCharset() {
		return Charset.defaultCharset();
	}
	@Override
	protected void apply(LogFile logFile, PropertyResolver resolver) {
		super.apply(logFile, resolver);
		applyJBossLoggingProperties();
		applyRollingPolicyProperties(resolver);
	}
	private void applyJBossLoggingProperties() {
		if (JBOSS_LOGGING_PRESENT) {
			setSystemProperty('org.jboss.logging.provider', 'slf4j');
		}
	}
	private void applyRollingPolicyProperties(PropertyResolver resolver) {
		applyRollingPolicy(RollingPolicySystemProperty.FILE_NAME_PATTERN, resolver);
		applyRollingPolicy(RollingPolicySystemProperty.CLEAN_HISTORY_ON_START, resolver);
		applyRollingPolicy(RollingPolicySystemProperty.MAX_FILE_SIZE, resolver, DataSize.class);
		applyRollingPolicy(RollingPolicySystemProperty.TOTAL_SIZE_CAP, resolver, DataSize.class);
		applyRollingPolicy(RollingPolicySystemProperty.MAX_HISTORY, resolver);
	}
	private void applyRollingPolicy(RollingPolicySystemProperty property, PropertyResolver resolver) {
		applyRollingPolicy(property, resolver, String.class);
	}
	private <T> void applyRollingPolicy(RollingPolicySystemProperty property, PropertyResolver resolver,
			Class<T> type) {
		T value = getProperty(resolver, property.getApplicationPropertyName(), type);
		value = (value != null) ? value : getProperty(resolver, property.getDeprecatedApplicationPropertyName(), type);
		if (value != null) {
			String stringValue = String.valueOf((value instanceof DataSize dataSize) ? dataSize.toBytes() : value);
			setSystemProperty(property.getEnvironmentVariableName(), stringValue);
		}
	}
	@SuppressWarnings('unchecked')
	private <T> T getProperty(PropertyResolver resolver, String key, Class<T> type) {
		try {
			return resolver.getProperty(key, type);
		}
		catch (ConversionFailedException | ConverterNotFoundException ex) {
			if (type != DataSize.class) {
				throw ex;
			}
			String value = resolver.getProperty(key);
			return (T) DataSize.ofBytes(FileSize.valueOf(value).getSize());
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogbackRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		if (!ClassUtils.isPresent('ch.qos.logback.classic.LoggerContext', classLoader)) {
			return;
		}
		ReflectionHints reflection = hints.reflection();
		registerHintsForLogbackLoggingSystemTypeChecks(reflection, classLoader);
		registerHintsForBuiltInLogbackConverters(reflection);
		registerHintsForSpringBootConverters(reflection);
		registerHintsForDeprecateSpringBootConverters(reflection);
	}
	private void registerHintsForLogbackLoggingSystemTypeChecks(ReflectionHints reflection, ClassLoader classLoader) {
		reflection.registerType(LoggerContext.class);
		reflection.registerTypeIfPresent(classLoader, 'org.slf4j.bridge.SLF4JBridgeHandler', (typeHint) -> {
		});
	}
	private void registerHintsForBuiltInLogbackConverters(ReflectionHints reflection) {
		registerForPublicConstructorInvocation(reflection, DateTokenConverter.class, IntegerTokenConverter.class,
				SyslogStartConverter.class);
	}
	private void registerHintsForSpringBootConverters(ReflectionHints reflection) {
		registerForPublicConstructorInvocation(reflection, ColorConverter.class,
				EnclosedInSquareBracketsConverter.class, ExtendedWhitespaceThrowableProxyConverter.class,
				WhitespaceThrowableProxyConverter.class, CorrelationIdConverter.class);
	}
	@SuppressWarnings('removal')
	private void registerHintsForDeprecateSpringBootConverters(ReflectionHints reflection) {
		registerForPublicConstructorInvocation(reflection, ApplicationNameConverter.class);
	}
	private void registerForPublicConstructorInvocation(ReflectionHints reflection, Class<?>... classes) {
		reflection.registerTypes(TypeReference.listOf(classes),
				(hint) -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public class ApplicationNameConverter extends ClassicConverter {
	private static final String ENVIRONMENT_VARIABLE_NAME = LoggingSystemProperty.APPLICATION_NAME
		.getEnvironmentVariableName();
	@Override
	public String convert(ILoggingEvent event) {
		String applicationName = event.getLoggerContextVO().getPropertyMap().get(ENVIRONMENT_VARIABLE_NAME);
		applicationName = (applicationName != null) ? applicationName : System.getProperty(ENVIRONMENT_VARIABLE_NAME);
		return (applicationName != null) ? applicationName : '';
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public enum RollingPolicySystemProperty {
	/**
	 * Logging system property for the rolled-over log file name pattern.
	 */
	FILE_NAME_PATTERN('file-name-pattern', 'logging.pattern.rolling-file-name'),
	/**
	 * Logging system property for the clean history on start flag.
	 */
	CLEAN_HISTORY_ON_START('clean-history-on-start', 'logging.file.clean-history-on-start'),
	/**
	 * Logging system property for the file log max size.
	 */
	MAX_FILE_SIZE('max-file-size', 'logging.file.max-size'),
	/**
	 * Logging system property for the file total size cap.
	 */
	TOTAL_SIZE_CAP('total-size-cap', 'logging.file.total-size-cap'),
	/**
	 * Logging system property for the file log max history.
	 */
	MAX_HISTORY('max-history', 'logging.file.max-history');
	private final String environmentVariableName;
	private final String applicationPropertyName;
	private final String deprecatedApplicationPropertyName;
	RollingPolicySystemProperty(String applicationPropertyName, String deprecatedApplicationPropertyName) {
		this.environmentVariableName = 'LOGBACK_ROLLINGPOLICY_' + name();
		this.applicationPropertyName = 'logging.logback.rollingpolicy.' + applicationPropertyName;
		this.deprecatedApplicationPropertyName = deprecatedApplicationPropertyName;
	}
	/**
	 * Return the name of environment variable that can be used to access this property.
	 * @return the environment variable name
	 */
	public String getEnvironmentVariableName() {
		return this.environmentVariableName;
	}
	String getApplicationPropertyName() {
		return this.applicationPropertyName;
	}
	String getDeprecatedApplicationPropertyName() {
		return this.deprecatedApplicationPropertyName;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class ElasticCommonSchemaStructuredLogFormatter extends JsonWriterStructuredLogFormatter<ILoggingEvent> {
	private static final PairExtractor<KeyValuePair> keyValuePairExtractor = PairExtractor.of((pair) -> pair.key,
			(pair) -> pair.value);
	ElasticCommonSchemaStructuredLogFormatter(Environment environment, ThrowableProxyConverter throwableProxyConverter,
			StructureLoggingJsonMembersCustomizer<?> customizer) {
		super((members) -> jsonMembers(environment, throwableProxyConverter, members), customizer);
	}
	private static void jsonMembers(Environment environment, ThrowableProxyConverter throwableProxyConverter,
			JsonWriter.Members<ILoggingEvent> members) {
		members.add('@timestamp', ILoggingEvent::getInstant);
		members.add('log.level', ILoggingEvent::getLevel);
		members.add('process.pid', environment.getProperty('spring.application.pid', Long.class))
			.when(Objects::nonNull);
		members.add('process.thread.name', ILoggingEvent::getThreadName);
		ElasticCommonSchemaProperties.get(environment).jsonMembers(members);
		members.add('log.logger', ILoggingEvent::getLoggerName);
		members.add('message', ILoggingEvent::getFormattedMessage);
		members.addMapEntries(ILoggingEvent::getMDCPropertyMap);
		members.from(ILoggingEvent::getKeyValuePairs)
			.whenNotEmpty()
			.usingExtractedPairs(Iterable::forEach, keyValuePairExtractor);
		members.add().whenNotNull(ILoggingEvent::getThrowableProxy).usingMembers((throwableMembers) -> {
			throwableMembers.add('error.type', ILoggingEvent::getThrowableProxy).as(IThrowableProxy::getClassName);
			throwableMembers.add('error.message', ILoggingEvent::getThrowableProxy).as(IThrowableProxy::getMessage);
			throwableMembers.add('error.stack_trace', throwableProxyConverter::convert);
		});
		members.add('ecs.version', '8.11');
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringProfileModelHandler extends ModelHandlerBase {
	private final Environment environment;
	SpringProfileModelHandler(Context context, Environment environment) {
		super(context);
		this.environment = environment;
	}
	@Override
	public void handle(ModelInterpretationContext intercon, Model model) throws ModelHandlerException {
		SpringProfileModel profileModel = (SpringProfileModel) model;
		if (!acceptsProfiles(intercon, profileModel)) {
			model.deepMarkAsSkipped();
		}
	}
	private boolean acceptsProfiles(ModelInterpretationContext ic, SpringProfileModel model) {
		if (this.environment == null) {
			return false;
		}
		String[] profileNames = StringUtils
			.trimArrayElements(StringUtils.commaDelimitedListToStringArray(model.getName()));
		if (profileNames.length == 0) {
			return false;
		}
		for (int i = 0; i < profileNames.length; i++) {
			try {
				profileNames[i] = OptionHelper.substVars(profileNames[i], ic, this.context);
			}
			catch (ScanException ex) {
				throw new RuntimeException(ex);
			}
		}
		return this.environment.acceptsProfiles(Profiles.of(profileNames));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogstashStructuredLogFormatter extends JsonWriterStructuredLogFormatter<ILoggingEvent> {
	private static final PairExtractor<KeyValuePair> keyValuePairExtractor = PairExtractor.of((pair) -> pair.key,
			(pair) -> pair.value);
	LogstashStructuredLogFormatter(ThrowableProxyConverter throwableProxyConverter,
			StructureLoggingJsonMembersCustomizer<?> customizer) {
		super((members) -> jsonMembers(throwableProxyConverter, members), customizer);
	}
	private static void jsonMembers(ThrowableProxyConverter throwableProxyConverter,
			JsonWriter.Members<ILoggingEvent> members) {
		members.add('@timestamp', ILoggingEvent::getInstant).as(LogstashStructuredLogFormatter::asTimestamp);
		members.add('@version', '1');
		members.add('message', ILoggingEvent::getFormattedMessage);
		members.add('logger_name', ILoggingEvent::getLoggerName);
		members.add('thread_name', ILoggingEvent::getThreadName);
		members.add('level', ILoggingEvent::getLevel);
		members.add('level_value', ILoggingEvent::getLevel).as(Level::toInt);
		members.addMapEntries(ILoggingEvent::getMDCPropertyMap);
		members.from(ILoggingEvent::getKeyValuePairs)
			.whenNotEmpty()
			.usingExtractedPairs(Iterable::forEach, keyValuePairExtractor);
		members.add('tags', ILoggingEvent::getMarkerList)
			.whenNotNull()
			.as(LogstashStructuredLogFormatter::getMarkers)
			.whenNotEmpty();
		members.add('stack_trace', (event) -> event)
			.whenNotNull(ILoggingEvent::getThrowableProxy)
			.as(throwableProxyConverter::convert);
	}
	private static String asTimestamp(Instant instant) {
		OffsetDateTime offsetDateTime = OffsetDateTime.ofInstant(instant, ZoneId.systemDefault());
		return DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(offsetDateTime);
	}
	private static Set<String> getMarkers(List<Marker> markers) {
		Set<String> result = new LinkedHashSet<>();
		addMarkers(result, markers.iterator());
		return result;
	}
	private static void addMarkers(Set<String> result, Iterator<Marker> iterator) {
		while (iterator.hasNext()) {
			Marker marker = iterator.next();
			result.add(marker.getName());
			if (marker.hasReferences()) {
				addMarkers(result, marker.iterator());
			}
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringPropertyModelHandler extends ModelHandlerBase {
	private final Environment environment;
	SpringPropertyModelHandler(Context context, Environment environment) {
		super(context);
		this.environment = environment;
	}
	@Override
	public void handle(ModelInterpretationContext intercon, Model model) throws ModelHandlerException {
		SpringPropertyModel propertyModel = (SpringPropertyModel) model;
		Scope scope = ActionUtil.stringToScope(propertyModel.getScope());
		String defaultValue = propertyModel.getDefaultValue();
		String source = propertyModel.getSource();
		if (OptionHelper.isNullOrEmpty(propertyModel.getName()) || OptionHelper.isNullOrEmpty(source)) {
			addError('The \'name\' and \'source\' attributes of <springProperty> must be set');
		}
		PropertyModelHandlerHelper.setProperty(intercon, propertyModel.getName(), getValue(source, defaultValue),
				scope);
	}
	private String getValue(String source, String defaultValue) {
		if (this.environment == null) {
			addWarn('No Spring Environment available to resolve ' + source);
			return defaultValue;
		}
		return this.environment.getProperty(source, defaultValue);
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class EnclosedInSquareBracketsConverter extends CompositeConverter<ILoggingEvent> {
	@Override
	protected String transform(ILoggingEvent event, String in) {
		in = (!StringUtils.hasLength(in)) ? resolveFromFirstOption(event) : in;
		return (!StringUtils.hasLength(in)) ? '' : '[%s] '.formatted(in);
	}
	private String resolveFromFirstOption(ILoggingEvent event) {
		String name = getFirstOption();
		if (name == null) {
			return null;
		}
		String value = event.getLoggerContextVO().getPropertyMap().get(name);
		return (value != null) ? value : System.getProperty(name);
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringPropertyAction extends BaseModelAction {
	private static final String SOURCE_ATTRIBUTE = 'source';
	private static final String DEFAULT_VALUE_ATTRIBUTE = 'defaultValue';
	@Override
	protected Model buildCurrentModel(SaxEventInterpretationContext interpretationContext, String name,
			Attributes attributes) {
		SpringPropertyModel model = new SpringPropertyModel();
		model.setName(attributes.getValue(NAME_ATTRIBUTE));
		model.setSource(attributes.getValue(SOURCE_ATTRIBUTE));
		model.setScope(attributes.getValue(SCOPE_ATTRIBUTE));
		model.setDefaultValue(attributes.getValue(DEFAULT_VALUE_ATTRIBUTE));
		return model;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class ColorConverter extends CompositeConverter<ILoggingEvent> {
	private static final Map<String, AnsiElement> ELEMENTS;
	static {
		Map<String, AnsiElement> ansiElements = new HashMap<>();
		Arrays.stream(AnsiColor.values())
			.filter((color) -> color != AnsiColor.DEFAULT)
			.forEach((color) -> ansiElements.put(color.name().toLowerCase(Locale.ROOT), color));
		ansiElements.put('faint', AnsiStyle.FAINT);
		ELEMENTS = Collections.unmodifiableMap(ansiElements);
	}
	private static final Map<Integer, AnsiElement> LEVELS;
	static {
		Map<Integer, AnsiElement> ansiLevels = new HashMap<>();
		ansiLevels.put(Level.ERROR_INTEGER, AnsiColor.RED);
		ansiLevels.put(Level.WARN_INTEGER, AnsiColor.YELLOW);
		LEVELS = Collections.unmodifiableMap(ansiLevels);
	}
	@Override
	protected String transform(ILoggingEvent event, String in) {
		AnsiElement color = ELEMENTS.get(getFirstOption());
		if (color == null) {
			// Assume highlighting
			color = LEVELS.get(event.getLevel().toInteger());
			color = (color != null) ? color : AnsiColor.GREEN;
		}
		return toAnsiString(in, color);
	}
	protected String toAnsiString(String in, AnsiElement element) {
		return AnsiOutput.toString(element, in);
	}
	static String getName(AnsiElement element) {
		return ELEMENTS.entrySet()
			.stream()
			.filter((entry) -> entry.getValue().equals(element))
			.map(Map.Entry::getKey)
			.findFirst()
			.orElseThrow();
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringPropertyModel extends NamedModel {
	private String scope;
	private String defaultValue;
	private String source;
	String getScope() {
		return this.scope;
	}
	void setScope(String scope) {
		this.scope = scope;
	}
	String getDefaultValue() {
		return this.defaultValue;
	}
	void setDefaultValue(String defaultValue) {
		this.defaultValue = defaultValue;
	}
	String getSource() {
		return this.source;
	}
	void setSource(String source) {
		this.source = source;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class GraylogExtendedLogFormatStructuredLogFormatter extends JsonWriterStructuredLogFormatter<ILoggingEvent> {
	private static final Log logger = LogFactory.getLog(GraylogExtendedLogFormatStructuredLogFormatter.class);
	/**
	 * Allowed characters in field names are any word character (letter, number,
	 * underscore), dashes and dots.
	 */
	private static final Pattern FIELD_NAME_VALID_PATTERN = Pattern.compile('^[\\w.\\-]*$');
	/**
	 * Libraries SHOULD not allow to send id as additional field ('_id'). Graylog server
	 * nodes omit this field automatically.
	 */
	private static final Set<String> ADDITIONAL_FIELD_ILLEGAL_KEYS = Set.of('id', '_id');
	GraylogExtendedLogFormatStructuredLogFormatter(Environment environment,
			ThrowableProxyConverter throwableProxyConverter, StructureLoggingJsonMembersCustomizer<?> customizer) {
		super((members) -> jsonMembers(environment, throwableProxyConverter, members), customizer);
	}
	private static void jsonMembers(Environment environment, ThrowableProxyConverter throwableProxyConverter,
			JsonWriter.Members<ILoggingEvent> members) {
		members.add('version', '1.1');
		members.add('short_message', ILoggingEvent::getFormattedMessage)
			.as(GraylogExtendedLogFormatStructuredLogFormatter::getMessageText);
		members.add('timestamp', ILoggingEvent::getTimeStamp)
			.as(GraylogExtendedLogFormatStructuredLogFormatter::formatTimeStamp);
		members.add('level', LevelToSyslogSeverity::convert);
		members.add('_level_name', ILoggingEvent::getLevel);
		members.add('_process_pid', environment.getProperty('spring.application.pid', Long.class))
			.when(Objects::nonNull);
		members.add('_process_thread_name', ILoggingEvent::getThreadName);
		GraylogExtendedLogFormatProperties.get(environment).jsonMembers(members);
		members.add('_log_logger', ILoggingEvent::getLoggerName);
		members.from(ILoggingEvent::getMDCPropertyMap)
			.when((mdc) -> !CollectionUtils.isEmpty(mdc))
			.usingPairs((mdc, pairs) -> mdc.forEach((key, value) -> createAdditionalField(key, value, pairs)));
		members.from(ILoggingEvent::getKeyValuePairs)
			.when((keyValuePairs) -> !CollectionUtils.isEmpty(keyValuePairs))
			.usingPairs(GraylogExtendedLogFormatStructuredLogFormatter::createAdditionalField);
		members.add()
			.whenNotNull(ILoggingEvent::getThrowableProxy)
			.usingMembers((throwableMembers) -> throwableMembers(throwableMembers, throwableProxyConverter));
	}
	private static String getMessageText(String formattedMessage) {
		// Always return text as a blank message will lead to a error as of Graylog v6
		return (!StringUtils.hasText(formattedMessage)) ? '(blank)' : formattedMessage;
	}
	/**
	 * GELF requires 'seconds since UNIX epoch with optional <b>decimal places for
	 * milliseconds</b>'. To comply with this requirement, we format a POSIX timestamp
	 * with millisecond precision as e.g. '1725459730385' -> '1725459730.385'
	 * @param timeStamp the timestamp of the log message
	 * @return the timestamp formatted as string with millisecond precision
	 */
	private static WritableJson formatTimeStamp(long timeStamp) {
		return (out) -> out.append(new BigDecimal(timeStamp).movePointLeft(3).toPlainString());
	}
	private static void throwableMembers(Members<ILoggingEvent> members,
			ThrowableProxyConverter throwableProxyConverter) {
		members.add('full_message', (event) -> formatFullMessageWithThrowable(throwableProxyConverter, event));
		members.add('_error_type', ILoggingEvent::getThrowableProxy).as(IThrowableProxy::getClassName);
		members.add('_error_stack_trace', throwableProxyConverter::convert);
		members.add('_error_message', ILoggingEvent::getThrowableProxy).as(IThrowableProxy::getMessage);
	}
	private static String formatFullMessageWithThrowable(ThrowableProxyConverter throwableProxyConverter,
			ILoggingEvent event) {
		return event.getFormattedMessage() + '\n\n' + throwableProxyConverter.convert(event);
	}
	private static void createAdditionalField(List<KeyValuePair> keyValuePairs, BiConsumer<Object, Object> pairs) {
		keyValuePairs.forEach((keyValuePair) -> createAdditionalField(keyValuePair.key, keyValuePair.value, pairs));
	}
	private static void createAdditionalField(String name, Object value, BiConsumer<Object, Object> pairs) {
		Assert.notNull(name, 'fieldName must not be null');
		if (!FIELD_NAME_VALID_PATTERN.matcher(name).matches()) {
			logger.warn(LogMessage.format('"%s" is not a valid field name according to GELF standard', name));
			return;
		}
		if (ADDITIONAL_FIELD_ILLEGAL_KEYS.contains(name)) {
			logger.warn(LogMessage.format('"%s" is an illegal field name according to GELF standard', name));
			return;
		}
		pairs.accept(asAdditionalFieldName(name), value);
	}
	private static Object asAdditionalFieldName(String name) {
		return (!name.startsWith('_')) ? '_' + name : name;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class DebugLogbackConfigurator extends LogbackConfigurator {
	DebugLogbackConfigurator(LoggerContext context) {
		super(context);
	}
	@Override
	@SuppressWarnings('rawtypes')
	public void conversionRule(String conversionWord, Class<? extends Converter> converterClass) {
		info('Adding conversion rule of type "' + converterClass.getName() + '" for word "' + conversionWord + '"');
		super.conversionRule(conversionWord, converterClass);
	}
	@Override
	public void appender(String name, Appender<?> appender) {
		info('Adding appender "' + appender + '" named "' + name + '"');
		super.appender(name, appender);
	}
	@Override
	public void logger(String name, Level level, boolean additive, Appender<ILoggingEvent> appender) {
		info('Configuring logger "' + name + '" with level "' + level + '". Additive: ' + additive);
		if (appender != null) {
			info('Adding appender "' + appender + '" to logger "' + name + '"');
		}
		super.logger(name, level, additive, appender);
	}
	@Override
	public void start(LifeCycle lifeCycle) {
		info('Starting "' + lifeCycle + '"');
		super.start(lifeCycle);
	}
	private void info(String message) {
		getContext().getStatusManager().add(new InfoStatus(message, this));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class WhitespaceThrowableProxyConverter extends ThrowableProxyConverter {
	@Override
	protected String throwableProxyToString(IThrowableProxy tp) {
		return CoreConstants.LINE_SEPARATOR + super.throwableProxyToString(tp) + CoreConstants.LINE_SEPARATOR;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogbackConfigurator {
	private final LoggerContext context;
	LogbackConfigurator(LoggerContext context) {
		Assert.notNull(context, 'Context must not be null');
		this.context = context;
	}
	LoggerContext getContext() {
		return this.context;
	}
	ReentrantLock getConfigurationLock() {
		return this.context.getConfigurationLock();
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void conversionRule(String conversionWord, Class<? extends Converter> converterClass) {
		Assert.hasLength(conversionWord, 'Conversion word must not be empty');
		Assert.notNull(converterClass, 'Converter class must not be null');
		Map<String, String> registry = (Map<String, String>) this.context
			.getObject(CoreConstants.PATTERN_RULE_REGISTRY);
		if (registry == null) {
			registry = new HashMap<>();
			this.context.putObject(CoreConstants.PATTERN_RULE_REGISTRY, registry);
		}
		registry.put(conversionWord, converterClass.getName());
	}
	void appender(String name, Appender<?> appender) {
		appender.setName(name);
		start(appender);
	}
	void logger(String name, Level level) {
		logger(name, level, true);
	}
	void logger(String name, Level level, boolean additive) {
		logger(name, level, additive, null);
	}
	void logger(String name, Level level, boolean additive, Appender<ILoggingEvent> appender) {
		Logger logger = this.context.getLogger(name);
		if (level != null) {
			logger.setLevel(level);
		}
		logger.setAdditive(additive);
		if (appender != null) {
			logger.addAppender(appender);
		}
	}
	@SafeVarargs
	final void root(Level level, Appender<ILoggingEvent>... appenders) {
		Logger logger = this.context.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);
		if (level != null) {
			logger.setLevel(level);
		}
		for (Appender<ILoggingEvent> appender : appenders) {
			logger.addAppender(appender);
		}
	}
	void start(LifeCycle lifeCycle) {
		if (lifeCycle instanceof ContextAware contextAware) {
			contextAware.setContext(this.context);
		}
		lifeCycle.start();
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class RootLogLevelConfigurator extends ContextAwareBase implements Configurator {
	@Override
	public ExecutionStatus configure(LoggerContext loggerContext) {
		loggerContext.getLogger(Logger.ROOT_LOGGER_NAME).setLevel(Level.INFO);
		return ExecutionStatus.INVOKE_NEXT_IF_ANY;
	}
}
/*
/**
package org.springframework.boot.logging.logback;
/*
package org.springframework.boot.logging.logback;
/**
public class ExtendedWhitespaceThrowableProxyConverter extends ExtendedThrowableProxyConverter {
	@Override
	protected String throwableProxyToString(IThrowableProxy tp) {
		return CoreConstants.LINE_SEPARATOR + super.throwableProxyToString(tp) + CoreConstants.LINE_SEPARATOR;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class CorrelationIdConverter extends DynamicConverter<ILoggingEvent> {
	private CorrelationIdFormatter formatter;
	@Override
	public void start() {
		this.formatter = CorrelationIdFormatter.of(getOptionList());
		super.start();
	}
	@Override
	public void stop() {
		this.formatter = null;
		super.stop();
	}
	@Override
	public String convert(ILoggingEvent event) {
		if (this.formatter == null) {
			return '';
		}
		Map<String, String> mdc = event.getMDCPropertyMap();
		return this.formatter.format(mdc::get);
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringBootJoranConfigurator extends JoranConfigurator {
	private final LoggingInitializationContext initializationContext;
	SpringBootJoranConfigurator(LoggingInitializationContext initializationContext) {
		this.initializationContext = initializationContext;
	}
	@Override
	protected void sanityCheck(Model topModel) {
		super.sanityCheck(topModel);
		performCheck(new SpringProfileIfNestedWithinSecondPhaseElementSanityChecker(), topModel);
	}
	@Override
	protected void addModelHandlerAssociations(DefaultProcessor defaultProcessor) {
		defaultProcessor.addHandler(SpringPropertyModel.class,
				(handlerContext, handlerMic) -> new SpringPropertyModelHandler(this.context,
						this.initializationContext.getEnvironment()));
		defaultProcessor.addHandler(SpringProfileModel.class,
				(handlerContext, handlerMic) -> new SpringProfileModelHandler(this.context,
						this.initializationContext.getEnvironment()));
		super.addModelHandlerAssociations(defaultProcessor);
	}
	@Override
	public void addElementSelectorAndActionAssociations(RuleStore ruleStore) {
		super.addElementSelectorAndActionAssociations(ruleStore);
		ruleStore.addRule(new ElementSelector('configuration/springProperty'), SpringPropertyAction::new);
		ruleStore.addRule(new ElementSelector('*/springProfile'), SpringProfileAction::new);
		ruleStore.addTransparentPathPart('springProfile');
	}
	@Override
	public void buildModelInterpretationContext() {
		super.buildModelInterpretationContext();
		this.modelInterpretationContext.setConfiguratorSupplier(() -> {
			SpringBootJoranConfigurator configurator = new SpringBootJoranConfigurator(this.initializationContext);
			configurator.setContext(this.context);
			return configurator;
		});
	}
	boolean configureUsingAotGeneratedArtifacts() {
		if (!new PatternRules(getContext()).load()) {
			return false;
		}
		Model model = new ModelReader().read();
		processModel(model);
		registerSafeConfiguration(model);
		return true;
	}
	@Override
	public void processModel(Model model) {
		super.processModel(model);
		if (!NativeDetector.inNativeImage() && isAotProcessingInProgress()) {
			getContext().putObject(BeanFactoryInitializationAotContribution.class.getName(),
					new LogbackConfigurationAotContribution(model, getModelInterpretationContext(), getContext()));
		}
	}
	private boolean isAotProcessingInProgress() {
		return Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING);
	}
	static final class LogbackConfigurationAotContribution implements BeanFactoryInitializationAotContribution {
		private final ModelWriter modelWriter;
		private final PatternRules patternRules;
		private LogbackConfigurationAotContribution(Model model, ModelInterpretationContext interpretationContext,
				Context context) {
			this.modelWriter = new ModelWriter(model, interpretationContext);
			this.patternRules = new PatternRules(context);
		}
		@Override
		public void applyTo(GenerationContext generationContext,
				BeanFactoryInitializationCode beanFactoryInitializationCode) {
			this.modelWriter.writeTo(generationContext);
			this.patternRules.save(generationContext);
		}
	}
	private static final class ModelWriter {
		private static final String MODEL_RESOURCE_LOCATION = 'META-INF/spring/logback-model';
		private final Model model;
		private final ModelInterpretationContext modelInterpretationContext;
		private ModelWriter(Model model, ModelInterpretationContext modelInterpretationContext) {
			this.model = model;
			this.modelInterpretationContext = modelInterpretationContext;
		}
		private void writeTo(GenerationContext generationContext) {
			byte[] serializedModel = serializeModel();
			generationContext.getGeneratedFiles()
				.handleFile(Kind.RESOURCE, MODEL_RESOURCE_LOCATION,
						new RequireNewOrMatchingContentFileHandler(serializedModel));
			generationContext.getRuntimeHints().resources().registerPattern(MODEL_RESOURCE_LOCATION);
			SerializationHints serializationHints = generationContext.getRuntimeHints().serialization();
			serializationTypes(this.model).forEach(serializationHints::registerType);
			reflectionTypes(this.model).forEach((type) -> generationContext.getRuntimeHints()
				.reflection()
				.registerType(TypeReference.of(type), MemberCategory.INTROSPECT_PUBLIC_METHODS,
						MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
		}
		private byte[] serializeModel() {
			ByteArrayOutputStream bytes = new ByteArrayOutputStream();
			try (ObjectOutputStream output = new ObjectOutputStream(bytes)) {
				output.writeObject(this.model);
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
			return bytes.toByteArray();
		}
		@SuppressWarnings('unchecked')
		private Set<Class<? extends Serializable>> serializationTypes(Model model) {
			Set<Class<? extends Serializable>> modelClasses = new HashSet<>();
			Class<?> candidate = model.getClass();
			while (Model.class.isAssignableFrom(candidate)) {
				if (modelClasses.add((Class<? extends Model>) candidate)) {
					ReflectionUtils.doWithFields(candidate, (field) -> {
						if (Modifier.isStatic(field.getModifiers())) {
							return;
						}
						ReflectionUtils.makeAccessible(field);
						Object value = field.get(model);
						if (value != null) {
							Class<?> fieldType = value.getClass();
							if (Serializable.class.isAssignableFrom(fieldType)) {
								modelClasses.add((Class<? extends Serializable>) fieldType);
							}
						}
					});
					candidate = candidate.getSuperclass();
				}
			}
			for (Model submodel : model.getSubModels()) {
				modelClasses.addAll(serializationTypes(submodel));
			}
			return modelClasses;
		}
		private Set<String> reflectionTypes(Model model) {
			return reflectionTypes(model, () -> null);
		}
		private Set<String> reflectionTypes(Model model, Supplier<Object> parent) {
			Set<String> reflectionTypes = new HashSet<>();
			Class<?> componentType = determineType(model, parent);
			if (componentType != null) {
				processComponent(componentType, reflectionTypes);
			}
			Supplier<Object> componentSupplier = SingletonSupplier.ofNullable(() -> instantiate(componentType));
			for (Model submodel : model.getSubModels()) {
				reflectionTypes.addAll(reflectionTypes(submodel, componentSupplier));
			}
			return reflectionTypes;
		}
		private Class<?> determineType(Model model, Supplier<Object> parentSupplier) {
			String className = (model instanceof ComponentModel componentModel) ? componentModel.getClassName() : null;
			if (className != null) {
				return loadImportType(className);
			}
			String tag = model.getTag();
			if (tag != null) {
				className = this.modelInterpretationContext.getDefaultNestedComponentRegistry()
					.findDefaultComponentTypeByTag(tag);
				if (className != null) {
					return loadImportType(className);
				}
				return inferTypeFromParent(parentSupplier, tag);
			}
			return null;
		}
		private Class<?> loadImportType(String className) {
			return loadComponentType(this.modelInterpretationContext.getImport(className));
		}
		private Class<?> inferTypeFromParent(Supplier<Object> parentSupplier, String tag) {
			Object parent = parentSupplier.get();
			if (parent != null) {
				try {
					PropertySetter propertySetter = new PropertySetter(
							this.modelInterpretationContext.getBeanDescriptionCache(), parent);
					Class<?> typeFromPropertySetter = propertySetter.getClassNameViaImplicitRules(tag,
							AggregationType.AS_COMPLEX_PROPERTY,
							this.modelInterpretationContext.getDefaultNestedComponentRegistry());
					return typeFromPropertySetter;
				}
				catch (Exception ex) {
					return null;
				}
			}
			return null;
		}
		private Class<?> loadComponentType(String componentType) {
			try {
				return ClassUtils.forName(this.modelInterpretationContext.subst(componentType),
						getClass().getClassLoader());
			}
			catch (Throwable ex) {
				throw new RuntimeException('Failed to load component type "' + componentType + '"', ex);
			}
		}
		private Object instantiate(Class<?> type) {
			try {
				return type.getConstructor().newInstance();
			}
			catch (Exception ex) {
				return null;
			}
		}
		private void processComponent(Class<?> componentType, Set<String> reflectionTypes) {
			BeanDescription beanDescription = this.modelInterpretationContext.getBeanDescriptionCache()
				.getBeanDescription(componentType);
			reflectionTypes.addAll(parameterTypesNames(beanDescription.getPropertyNameToAdder().values()));
			reflectionTypes.addAll(parameterTypesNames(beanDescription.getPropertyNameToSetter().values()));
			reflectionTypes.add(componentType.getCanonicalName());
		}
		private Collection<String> parameterTypesNames(Collection<Method> methods) {
			return methods.stream()
				.filter((method) -> !method.getDeclaringClass().equals(ContextAware.class)
						&& !method.getDeclaringClass().equals(ContextAwareBase.class))
				.map(Method::getParameterTypes)
				.flatMap(Stream::of)
				.filter((type) -> !type.isPrimitive() && !type.equals(String.class))
				.map((type) -> type.isArray() ? type.getComponentType() : type)
				.map(Class::getName)
				.toList();
		}
	}
	private static final class ModelReader {
		private Model read() {
			try (InputStream modelInput = getClass().getClassLoader()
				.getResourceAsStream(ModelWriter.MODEL_RESOURCE_LOCATION)) {
				try (ObjectInputStream input = new ObjectInputStream(modelInput)) {
					Model model = (Model) input.readObject();
					ModelUtil.resetForReuse(model);
					markIncludesAsHandled(model);
					return model;
				}
			}
			catch (Exception ex) {
				throw new RuntimeException('Failed to load model from "' + ModelWriter.MODEL_RESOURCE_LOCATION + '"',
						ex);
			}
		}
		private void markIncludesAsHandled(Model model) {
			if (model instanceof IncludeModel) {
				model.markAsHandled();
			}
			for (Model submodel : model.getSubModels()) {
				markIncludesAsHandled(submodel);
			}
		}
	}
	private static final class PatternRules {
		private static final String RESOURCE_LOCATION = 'META-INF/spring/logback-pattern-rules';
		private final Context context;
		private PatternRules(Context context) {
			this.context = context;
		}
		private boolean load() {
			try {
				ClassPathResource resource = new ClassPathResource(RESOURCE_LOCATION);
				if (!resource.exists()) {
					return false;
				}
				Properties properties = PropertiesLoaderUtils.loadProperties(resource);
				Map<String, String> patternRuleRegistry = getRegistryMap();
				for (String word : properties.stringPropertyNames()) {
					patternRuleRegistry.put(word, properties.getProperty(word));
				}
				return true;
			}
			catch (Exception ex) {
				throw new RuntimeException(ex);
			}
		}
		@SuppressWarnings('unchecked')
		private Map<String, String> getRegistryMap() {
			Map<String, String> patternRuleRegistry = (Map<String, String>) this.context
				.getObject(CoreConstants.PATTERN_RULE_REGISTRY);
			if (patternRuleRegistry == null) {
				patternRuleRegistry = new HashMap<>();
				this.context.putObject(CoreConstants.PATTERN_RULE_REGISTRY, patternRuleRegistry);
			}
			return patternRuleRegistry;
		}
		private void save(GenerationContext generationContext) {
			Map<String, String> registryMap = getRegistryMap();
			byte[] rules = asBytes(registryMap);
			generationContext.getGeneratedFiles()
				.handleFile(Kind.RESOURCE, RESOURCE_LOCATION, new RequireNewOrMatchingContentFileHandler(rules));
			generationContext.getRuntimeHints().resources().registerPattern(RESOURCE_LOCATION);
			for (String ruleClassName : registryMap.values()) {
				generationContext.getRuntimeHints()
					.reflection()
					.registerType(TypeReference.of(ruleClassName), MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);
			}
		}
		private byte[] asBytes(Map<String, String> patternRuleRegistry) {
			Properties properties = CollectionFactory.createSortedProperties(true);
			patternRuleRegistry.forEach(properties::setProperty);
			ByteArrayOutputStream bytes = new ByteArrayOutputStream();
			try {
				properties.store(bytes, '');
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
			return bytes.toByteArray();
		}
	}
	private static final class RequireNewOrMatchingContentFileHandler implements ThrowingConsumer<FileHandler> {
		private final byte[] newContent;
		private RequireNewOrMatchingContentFileHandler(byte[] newContent) {
			this.newContent = newContent;
		}
		@Override
		public void acceptWithException(FileHandler file) throws Exception {
			if (file.exists()) {
				byte[] existingContent = file.getContent().getInputStream().readAllBytes();
				if (!Arrays.equals(this.newContent, existingContent)) {
					throw new IllegalStateException(
							'Logging configuration differs from the configuration that has already been written. '
									+ 'Update your logging configuration so that it is the same for each context');
				}
			}
			else {
				file.create(new ByteArrayResource(this.newContent));
			}
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class DefaultLogbackConfiguration {
	private static final String DEFAULT_CHARSET = Charset.defaultCharset().name();
	private static final String NAME_AND_GROUP = '%esb(){APPLICATION_NAME}%esb{APPLICATION_GROUP}';
	private static final String DATETIME = '%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd"T"HH:mm:ss.SSSXXX}}';
	private static final String DEFAULT_CONSOLE_LOG_PATTERN = faint(DATETIME) + ' '
			+ colorByLevel('${LOG_LEVEL_PATTERN:-%5p}') + ' ' + magenta('${PID:-}') + ' '
			+ faint('--- ' + NAME_AND_GROUP + '[%15.15t] ${LOG_CORRELATION_PATTERN:-}') + cyan('%-40.40logger{39}')
			+ ' ' + faint(':') + ' %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}';
	static final String CONSOLE_LOG_PATTERN = '${CONSOLE_LOG_PATTERN:-' + DEFAULT_CONSOLE_LOG_PATTERN;
	private static final String DEFAULT_FILE_LOG_PATTERN = DATETIME + ' ${LOG_LEVEL_PATTERN:-%5p} ${PID:-} --- '
			+ NAME_AND_GROUP + '[%t] ${LOG_CORRELATION_PATTERN:-}'
			+ '%-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}';
	static final String FILE_LOG_PATTERN = '${FILE_LOG_PATTERN:-' + DEFAULT_FILE_LOG_PATTERN;
	private final LogFile logFile;
	DefaultLogbackConfiguration(LogFile logFile) {
		this.logFile = logFile;
	}
	void apply(LogbackConfigurator config) {
		config.getConfigurationLock().lock();
		try {
			defaults(config);
			Appender<ILoggingEvent> consoleAppender = consoleAppender(config);
			if (this.logFile != null) {
				Appender<ILoggingEvent> fileAppender = fileAppender(config, this.logFile.toString());
				config.root(Level.INFO, consoleAppender, fileAppender);
			}
			else {
				config.root(Level.INFO, consoleAppender);
			}
		}
		finally {
			config.getConfigurationLock().unlock();
		}
	}
	private void defaults(LogbackConfigurator config) {
		deprecatedDefaults(config);
		config.conversionRule('clr', ColorConverter.class);
		config.conversionRule('correlationId', CorrelationIdConverter.class);
		config.conversionRule('esb', EnclosedInSquareBracketsConverter.class);
		config.conversionRule('wex', WhitespaceThrowableProxyConverter.class);
		config.conversionRule('wEx', ExtendedWhitespaceThrowableProxyConverter.class);
		putProperty(config, 'CONSOLE_LOG_PATTERN', CONSOLE_LOG_PATTERN);
		putProperty(config, 'CONSOLE_LOG_CHARSET', '${CONSOLE_LOG_CHARSET:-' + DEFAULT_CHARSET + '}');
		putProperty(config, 'CONSOLE_LOG_THRESHOLD', '${CONSOLE_LOG_THRESHOLD:-TRACE}');
		putProperty(config, 'CONSOLE_LOG_STRUCTURED_FORMAT', '${CONSOLE_LOG_STRUCTURED_FORMAT:-}');
		putProperty(config, 'FILE_LOG_PATTERN', FILE_LOG_PATTERN);
		putProperty(config, 'FILE_LOG_CHARSET', '${FILE_LOG_CHARSET:-' + DEFAULT_CHARSET + '}');
		putProperty(config, 'FILE_LOG_THRESHOLD', '${FILE_LOG_THRESHOLD:-TRACE}');
		putProperty(config, 'FILE_LOG_STRUCTURED_FORMAT', '${FILE_LOG_STRUCTURED_FORMAT:-}');
		config.logger('org.apache.catalina.startup.DigesterFactory', Level.ERROR);
		config.logger('org.apache.catalina.util.LifecycleBase', Level.ERROR);
		config.logger('org.apache.coyote.http11.Http11NioProtocol', Level.WARN);
		config.logger('org.apache.sshd.common.util.SecurityUtils', Level.WARN);
		config.logger('org.apache.tomcat.util.net.NioSelectorPool', Level.WARN);
		config.logger('org.eclipse.jetty.util.component.AbstractLifeCycle', Level.ERROR);
		config.logger('org.hibernate.validator.internal.util.Version', Level.WARN);
		config.logger('org.springframework.boot.actuate.endpoint.jmx', Level.WARN);
	}
	@SuppressWarnings('removal')
	private void deprecatedDefaults(LogbackConfigurator config) {
		config.conversionRule('applicationName', ApplicationNameConverter.class);
	}
	void putProperty(LogbackConfigurator config, String name, String val) {
		config.getContext().putProperty(name, resolve(config, val));
	}
	private Appender<ILoggingEvent> consoleAppender(LogbackConfigurator config) {
		ConsoleAppender<ILoggingEvent> appender = new ConsoleAppender<>();
		createAppender(config, appender, 'CONSOLE');
		config.appender('CONSOLE', appender);
		return appender;
	}
	private Appender<ILoggingEvent> fileAppender(LogbackConfigurator config, String logFile) {
		RollingFileAppender<ILoggingEvent> appender = new RollingFileAppender<>();
		createAppender(config, appender, 'FILE');
		appender.setFile(logFile);
		setRollingPolicy(appender, config);
		config.appender('FILE', appender);
		return appender;
	}
	private void createAppender(LogbackConfigurator config, OutputStreamAppender<ILoggingEvent> appender, String type) {
		appender.addFilter(createThresholdFilter(config, type));
		Encoder<ILoggingEvent> encoder = createEncoder(config, type);
		appender.setEncoder(encoder);
		config.start(encoder);
	}
	private ThresholdFilter createThresholdFilter(LogbackConfigurator config, String type) {
		ThresholdFilter filter = new ThresholdFilter();
		filter.setLevel(resolve(config, '${' + type + '_LOG_THRESHOLD}'));
		filter.start();
		return filter;
	}
	private Encoder<ILoggingEvent> createEncoder(LogbackConfigurator config, String type) {
		Charset charset = resolveCharset(config, '${' + type + '_LOG_CHARSET}');
		String structuredLogFormat = resolve(config, '${' + type + '_LOG_STRUCTURED_FORMAT}');
		if (StringUtils.hasLength(structuredLogFormat)) {
			StructuredLogEncoder encoder = createStructuredLogEncoder(structuredLogFormat);
			encoder.setCharset(charset);
			return encoder;
		}
		PatternLayoutEncoder encoder = new PatternLayoutEncoder();
		encoder.setCharset(charset);
		encoder.setPattern(resolve(config, '${' + type + '_LOG_PATTERN}'));
		return encoder;
	}
	private StructuredLogEncoder createStructuredLogEncoder(String format) {
		StructuredLogEncoder encoder = new StructuredLogEncoder();
		encoder.setFormat(format);
		return encoder;
	}
	private void setRollingPolicy(RollingFileAppender<ILoggingEvent> appender, LogbackConfigurator config) {
		SizeAndTimeBasedRollingPolicy<ILoggingEvent> rollingPolicy = new SizeAndTimeBasedRollingPolicy<>();
		rollingPolicy.setContext(config.getContext());
		rollingPolicy.setFileNamePattern(
				resolve(config, '${LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN:-${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz}'));
		rollingPolicy
			.setCleanHistoryOnStart(resolveBoolean(config, '${LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START:-false}'));
		rollingPolicy.setMaxFileSize(resolveFileSize(config, '${LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE:-10MB}'));
		rollingPolicy.setTotalSizeCap(resolveFileSize(config, '${LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP:-0}'));
		rollingPolicy.setMaxHistory(resolveInt(config, '${LOGBACK_ROLLINGPOLICY_MAX_HISTORY:-7}'));
		appender.setRollingPolicy(rollingPolicy);
		rollingPolicy.setParent(appender);
		config.start(rollingPolicy);
	}
	private boolean resolveBoolean(LogbackConfigurator config, String val) {
		return Boolean.parseBoolean(resolve(config, val));
	}
	private int resolveInt(LogbackConfigurator config, String val) {
		return Integer.parseInt(resolve(config, val));
	}
	private FileSize resolveFileSize(LogbackConfigurator config, String val) {
		return FileSize.valueOf(resolve(config, val));
	}
	private Charset resolveCharset(LogbackConfigurator config, String val) {
		return Charset.forName(resolve(config, val));
	}
	private String resolve(LogbackConfigurator config, String val) {
		try {
			return OptionHelper.substVars(val, config.getContext());
		}
		catch (ScanException ex) {
			throw new RuntimeException(ex);
		}
	}
	private static String faint(String value) {
		return color(value, AnsiStyle.FAINT);
	}
	private static String cyan(String value) {
		return color(value, AnsiColor.CYAN);
	}
	private static String magenta(String value) {
		return color(value, AnsiColor.MAGENTA);
	}
	private static String colorByLevel(String value) {
		return '%clr(' + value + '){}';
	}
	private static String color(String value, AnsiElement ansiElement) {
		return '%clr(' + value + '){' + ColorConverter.getName(ansiElement) + '}';
	}
}
/*
package org.springframework.boot.logging.logback;
/**
public class StructuredLogEncoder extends EncoderBase<ILoggingEvent> {
	private final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();
	private String format;
	private StructuredLogFormatter<ILoggingEvent> formatter;
	private Charset charset = StandardCharsets.UTF_8;
	public void setFormat(String format) {
		this.format = format;
	}
	public void setCharset(Charset charset) {
		this.charset = charset;
	}
	@Override
	public void start() {
		Assert.state(this.format != null, 'Format has not been set');
		this.formatter = createFormatter(this.format);
		super.start();
		this.throwableProxyConverter.start();
	}
	private StructuredLogFormatter<ILoggingEvent> createFormatter(String format) {
		Environment environment = (Environment) getContext().getObject(Environment.class.getName());
		Assert.state(environment != null, 'Unable to find Spring Environment in logger context');
		return new StructuredLogFormatterFactory<>(ILoggingEvent.class, environment, this::addAvailableParameters,
				this::addCommonFormatters)
			.get(format);
	}
	private void addAvailableParameters(AvailableParameters availableParameters) {
		availableParameters.add(ThrowableProxyConverter.class, this.throwableProxyConverter);
	}
	private void addCommonFormatters(CommonFormatters<ILoggingEvent> commonFormatters) {
		commonFormatters.add(CommonStructuredLogFormat.ELASTIC_COMMON_SCHEMA, this::createEcsFormatter);
		commonFormatters.add(CommonStructuredLogFormat.GRAYLOG_EXTENDED_LOG_FORMAT, this::createGraylogFormatter);
		commonFormatters.add(CommonStructuredLogFormat.LOGSTASH, this::createLogstashFormatter);
	}
	private StructuredLogFormatter<ILoggingEvent> createEcsFormatter(Instantiator<?> instantiator) {
		Environment environment = instantiator.getArg(Environment.class);
		ThrowableProxyConverter throwableProxyConverter = instantiator.getArg(ThrowableProxyConverter.class);
		StructureLoggingJsonMembersCustomizer<?> jsonMembersCustomizer = instantiator
			.getArg(StructureLoggingJsonMembersCustomizer.class);
		return new ElasticCommonSchemaStructuredLogFormatter(environment, throwableProxyConverter,
				jsonMembersCustomizer);
	}
	private StructuredLogFormatter<ILoggingEvent> createGraylogFormatter(Instantiator<?> instantiator) {
		Environment environment = instantiator.getArg(Environment.class);
		ThrowableProxyConverter throwableProxyConverter = instantiator.getArg(ThrowableProxyConverter.class);
		StructureLoggingJsonMembersCustomizer<?> jsonMembersCustomizer = instantiator
			.getArg(StructureLoggingJsonMembersCustomizer.class);
		return new GraylogExtendedLogFormatStructuredLogFormatter(environment, throwableProxyConverter,
				jsonMembersCustomizer);
	}
	private StructuredLogFormatter<ILoggingEvent> createLogstashFormatter(Instantiator<?> instantiator) {
		ThrowableProxyConverter throwableProxyConverter = instantiator.getArg(ThrowableProxyConverter.class);
		StructureLoggingJsonMembersCustomizer<?> jsonMembersCustomizer = instantiator
			.getArg(StructureLoggingJsonMembersCustomizer.class);
		return new LogstashStructuredLogFormatter(throwableProxyConverter, jsonMembersCustomizer);
	}
	@Override
	public void stop() {
		this.throwableProxyConverter.stop();
		super.stop();
	}
	@Override
	public byte[] headerBytes() {
		return null;
	}
	@Override
	public byte[] encode(ILoggingEvent event) {
		return this.formatter.formatAsBytes(event, (this.charset != null) ? this.charset : StandardCharsets.UTF_8);
	}
	@Override
	public byte[] footerBytes() {
		return null;
	}
}
/*
package org.springframework.boot.logging;
/**
public final class LoggerGroups implements Iterable<LoggerGroup> {
	private final Map<String, LoggerGroup> groups = new ConcurrentHashMap<>();
	public LoggerGroups() {
	}
	public LoggerGroups(Map<String, List<String>> namesAndMembers) {
		putAll(namesAndMembers);
	}
	public void putAll(Map<String, List<String>> namesAndMembers) {
		namesAndMembers.forEach(this::put);
	}
	private void put(String name, List<String> members) {
		put(new LoggerGroup(name, members));
	}
	private void put(LoggerGroup loggerGroup) {
		this.groups.put(loggerGroup.getName(), loggerGroup);
	}
	public LoggerGroup get(String name) {
		return this.groups.get(name);
	}
	@Override
	public Iterator<LoggerGroup> iterator() {
		return this.groups.values().iterator();
	}
}
/*
package org.springframework.boot.logging.structured;
/**
record StructuredLoggingJsonProperties(Set<String> include, Set<String> exclude, Map<String, String> rename,
		Map<String, String> add, String customizer) {
	static StructuredLoggingJsonProperties get(Environment environment) {
		return Binder.get(environment)
			.bind('logging.structured.json', StructuredLoggingJsonProperties.class)
			.orElse(null);
	}
}
/*
package org.springframework.boot.logging.structured;
/**
public class StructuredLogFormatterFactory<E> {
	private static final FailureHandler failureHandler = (type, implementationName, failure) -> {
		if (!(failure instanceof ClassNotFoundException)) {
			throw new IllegalArgumentException(
					'Unable to instantiate ' + implementationName + ' [' + type.getName() + ']', failure);
		}
	};
	private final SpringFactoriesLoader factoriesLoader;
	private final Class<E> logEventType;
	private final Instantiator<?> instantiator;
	private final CommonFormatters<E> commonFormatters;
	/**
	 * Create a new {@link StructuredLogFormatterFactory} instance.
	 * @param logEventType the log event type
	 * @param environment the Spring {@link Environment}
	 * @param availableParameters callback used to configure available parameters for the
	 * specific logging system
	 * @param commonFormatters callback used to define supported common formatters
	 */
	public StructuredLogFormatterFactory(Class<E> logEventType, Environment environment,
			Consumer<AvailableParameters> availableParameters, Consumer<CommonFormatters<E>> commonFormatters) {
		this(SpringFactoriesLoader.forDefaultResourceLocation(), logEventType, environment, availableParameters,
				commonFormatters);
	}
	StructuredLogFormatterFactory(SpringFactoriesLoader factoriesLoader, Class<E> logEventType, Environment environment,
			Consumer<AvailableParameters> availableParameters, Consumer<CommonFormatters<E>> commonFormatters) {
		this.factoriesLoader = factoriesLoader;
		this.logEventType = logEventType;
		this.instantiator = new Instantiator<>(Object.class, (allAvailableParameters) -> {
			allAvailableParameters.add(Environment.class, environment);
			allAvailableParameters.add(StructureLoggingJsonMembersCustomizer.class,
					(type) -> getStructureLoggingJsonMembersCustomizer(environment));
			if (availableParameters != null) {
				availableParameters.accept(allAvailableParameters);
			}
		}, failureHandler);
		this.commonFormatters = new CommonFormatters<>();
		commonFormatters.accept(this.commonFormatters);
	}
	StructureLoggingJsonMembersCustomizer<?> getStructureLoggingJsonMembersCustomizer(Environment environment) {
		List<StructureLoggingJsonMembersCustomizer<?>> customizers = new ArrayList<>();
		StructuredLoggingJsonProperties properties = StructuredLoggingJsonProperties.get(environment);
		if (properties != null) {
			customizers.add(new StructuredLoggingJsonPropertiesJsonMembersCustomizer(this.instantiator, properties));
		}
		customizers.addAll(loadStructureLoggingJsonMembersCustomizers());
		return (members) -> invokeCustomizers(customizers, members);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private List<StructureLoggingJsonMembersCustomizer<?>> loadStructureLoggingJsonMembersCustomizers() {
		return (List) this.factoriesLoader.load(StructureLoggingJsonMembersCustomizer.class,
				ArgumentResolver.from(this.instantiator::getArg));
	}
	@SuppressWarnings('unchecked')
	private void invokeCustomizers(List<StructureLoggingJsonMembersCustomizer<?>> customizers,
			Members<Object> members) {
		LambdaSafe.callbacks(StructureLoggingJsonMembersCustomizer.class, customizers, members)
			.invoke((customizer) -> customizer.customize(members));
	}
	/**
	 * Get a new {@link StructuredLogFormatter} instance for the specified format.
	 * @param format the format requested (either a {@link CommonStructuredLogFormat} ID
	 * or a fully-qualified class name)
	 * @return a new {@link StructuredLogFormatter} instance
	 * @throws IllegalArgumentException if the format is unknown
	 */
	public StructuredLogFormatter<E> get(String format) {
		StructuredLogFormatter<E> formatter = this.commonFormatters.get(this.instantiator, format);
		formatter = (formatter != null) ? formatter : getUsingClassName(format);
		if (formatter != null) {
			return formatter;
		}
		throw new IllegalArgumentException(
				'Unknown format "%s". Values can be a valid fully-qualified class name or one of the common formats: %s'
					.formatted(format, this.commonFormatters.getCommonNames()));
	}
	@SuppressWarnings('unchecked')
	private StructuredLogFormatter<E> getUsingClassName(String className) {
		Object formatter = this.instantiator.instantiate(className);
		if (formatter != null) {
			Assert.state(formatter instanceof StructuredLogFormatter,
					() -> '"%s" is not a StructuredLogFormatter'.formatted(className));
			checkTypeArgument(formatter);
		}
		return (StructuredLogFormatter<E>) formatter;
	}
	private void checkTypeArgument(Object formatter) {
		Class<?> typeArgument = GenericTypeResolver.resolveTypeArgument(formatter.getClass(),
				StructuredLogFormatter.class);
		Assert.isTrue(this.logEventType.equals(typeArgument),
				() -> 'Type argument of %s must be %s but was %s'.formatted(formatter.getClass().getName(),
						this.logEventType.getName(), (typeArgument != null) ? typeArgument.getName() : 'null'));
	}
	/**
	 * Callback used for configure the {@link CommonFormatterFactory} to use for a given
	 * {@link CommonStructuredLogFormat}.
	 *
	 * @param <E> the log event type
	 */
	public static class CommonFormatters<E> {
		private final Map<CommonStructuredLogFormat, CommonFormatterFactory<E>> factories = new TreeMap<>();
		/**
		 * Add the factory that should be used for the given
		 * {@link CommonStructuredLogFormat}.
		 * @param format the common structured log format
		 * @param factory the factory to use
		 */
		public void add(CommonStructuredLogFormat format, CommonFormatterFactory<E> factory) {
			this.factories.put(format, factory);
		}
		Collection<String> getCommonNames() {
			return this.factories.keySet().stream().map(CommonStructuredLogFormat::getId).toList();
		}
		StructuredLogFormatter<E> get(Instantiator<?> instantiator, String format) {
			CommonStructuredLogFormat commonFormat = CommonStructuredLogFormat.forId(format);
			CommonFormatterFactory<E> factory = (commonFormat != null) ? this.factories.get(commonFormat) : null;
			return (factory != null) ? factory.createFormatter(instantiator) : null;
		}
	}
	/**
	 * Factory used to create a {@link StructuredLogFormatter} for a given
	 * {@link CommonStructuredLogFormat}.
	 *
	 * @param <E> the log event type
	 */
	@FunctionalInterface
	public interface CommonFormatterFactory<E> {
		/**
		 * Create the {@link StructuredLogFormatter} instance.
		 * @param instantiator instantiator that can be used to obtain arguments
		 * @return a new {@link StructuredLogFormatter} instance
		 */
		StructuredLogFormatter<E> createFormatter(Instantiator<?> instantiator);
	}
}
/*
package org.springframework.boot.logging.structured;
/**
public abstract class JsonWriterStructuredLogFormatter<E> implements StructuredLogFormatter<E> {
	private final JsonWriter<E> jsonWriter;
	/**
	 * Create a new {@link JsonWriterStructuredLogFormatter} instance with the given
	 * members.
	 * @param members a consumer, which should configure the members
	 * @param customizer an optional customizer to apply
	 */
	protected JsonWriterStructuredLogFormatter(Consumer<Members<E>> members,
			StructureLoggingJsonMembersCustomizer<?> customizer) {
		this(JsonWriter.of(customized(members, customizer)).withNewLineAtEnd());
	}
	private static <E> Consumer<Members<E>> customized(Consumer<Members<E>> members,
			StructureLoggingJsonMembersCustomizer<?> customizer) {
		return (customizer != null) ? members.andThen(customizeWith(customizer)) : members;
	}
	@SuppressWarnings('unchecked')
	private static <E> Consumer<Members<E>> customizeWith(StructureLoggingJsonMembersCustomizer<?> customizer) {
		return (members) -> LambdaSafe.callback(StructureLoggingJsonMembersCustomizer.class, customizer, members)
			.invoke((instance) -> instance.customize(members));
	}
	/**
	 * Create a new {@link JsonWriterStructuredLogFormatter} instance with the given
	 * {@link JsonWriter}.
	 * @param jsonWriter the {@link JsonWriter}
	 */
	protected JsonWriterStructuredLogFormatter(JsonWriter<E> jsonWriter) {
		this.jsonWriter = jsonWriter;
	}
	@Override
	public String format(E event) {
		return this.jsonWriter.writeToString(event);
	}
	@Override
	public byte[] formatAsBytes(E event, Charset charset) {
		return this.jsonWriter.write(event).toByteArray(charset);
	}
}
/*
package org.springframework.boot.logging.structured;
/**
public record GraylogExtendedLogFormatProperties(String host, Service service) {
	static final GraylogExtendedLogFormatProperties NONE = new GraylogExtendedLogFormatProperties(null, Service.NONE);
	GraylogExtendedLogFormatProperties withDefaults(Environment environment) {
		String name = withFallbackProperty(environment, this.host, 'spring.application.name');
		Service service = this.service.withDefaults(environment);
		return new GraylogExtendedLogFormatProperties(name, service);
	}
	static String withFallbackProperty(Environment environment, String value, String property) {
		return (!StringUtils.hasLength(value)) ? environment.getProperty(property) : value;
	}
	/**
	 * Add {@link JsonWriter} members for the service.
	 * @param members the members to add to
	 */
	public void jsonMembers(JsonWriter.Members<?> members) {
		members.add('host', this::host).whenHasLength();
		this.service.jsonMembers(members);
	}
	/**
	 * Return a new {@link GraylogExtendedLogFormatProperties} from bound from properties
	 * in the given {@link Environment}.
	 * @param environment the source environment
	 * @return a new {@link GraylogExtendedLogFormatProperties} instance
	 */
	public static GraylogExtendedLogFormatProperties get(Environment environment) {
		return Binder.get(environment)
			.bind('logging.structured.gelf', GraylogExtendedLogFormatProperties.class)
			.orElse(NONE)
			.withDefaults(environment);
	}
	/**
	 * Service details.
	 *
	 * @param version the version of the application
	 */
	public record Service(String version) {
		static final Service NONE = new Service(null);
		Service withDefaults(Environment environment) {
			String version = withFallbackProperty(environment, this.version, 'spring.application.version');
			return new Service(version);
		}
		void jsonMembers(JsonWriter.Members<?> members) {
			members.add('_service_version', this::version).whenHasLength();
		}
	}
}
/*
package org.springframework.boot.logging.structured;
/**
public record ElasticCommonSchemaProperties(Service service) {
	static final ElasticCommonSchemaProperties NONE = new ElasticCommonSchemaProperties(Service.NONE);
	ElasticCommonSchemaProperties withDefaults(Environment environment) {
		Service service = this.service.withDefaults(environment);
		return new ElasticCommonSchemaProperties(service);
	}
	static String withFallbackProperty(Environment environment, String value, String property) {
		return (!StringUtils.hasLength(value)) ? environment.getProperty(property) : value;
	}
	/**
	 * Add {@link JsonWriter} members for the service.
	 * @param members the members to add to
	 */
	public void jsonMembers(JsonWriter.Members<?> members) {
		this.service.jsonMembers(members);
	}
	/**
	 * Return a new {@link ElasticCommonSchemaProperties} from bound from properties in
	 * the given {@link Environment}.
	 * @param environment the source environment
	 * @return a new {@link ElasticCommonSchemaProperties} instance
	 */
	public static ElasticCommonSchemaProperties get(Environment environment) {
		return Binder.get(environment)
			.bind('logging.structured.ecs', ElasticCommonSchemaProperties.class)
			.orElse(NONE)
			.withDefaults(environment);
	}
	/**
	 * Service details.
	 *
	 * @param name the application name
	 * @param version the version of the application
	 * @param environment the name of the environment the application is running in
	 * @param nodeName the name of the node the application is running on
	 */
	public record Service(String name, String version, String environment, String nodeName) {
		static final Service NONE = new Service(null, null, null, null);
		void jsonMembers(Members<?> members) {
			members.add('service.name', this::name).whenHasLength();
			members.add('service.version', this::version).whenHasLength();
			members.add('service.environment', this::environment).whenHasLength();
			members.add('service.node.name', this::nodeName).whenHasLength();
		}
		Service withDefaults(Environment environment) {
			String name = withFallbackProperty(environment, this.name, 'spring.application.name');
			String version = withFallbackProperty(environment, this.version, 'spring.application.version');
			return new Service(name, version, this.environment, this.nodeName);
		}
	}
}
/*
package org.springframework.boot.logging.structured;
/**
@FunctionalInterface
public interface StructuredLogFormatter<E> {
	/**
	 * Formats the given log event to a String.
	 * @param event the log event to write
	 * @return the formatted log event String
	 */
	String format(E event);
	/**
	 * Formats the given log event to a byte array.
	 * @param event the log event to write
	 * @param charset the charset
	 * @return the formatted log event bytes
	 */
	default byte[] formatAsBytes(E event, Charset charset) {
		return format(event).getBytes(charset);
	}
}
/*
package org.springframework.boot.logging.structured;
/**
class StructuredLoggingJsonPropertiesJsonMembersCustomizer implements StructureLoggingJsonMembersCustomizer<Object> {
	private final Instantiator<?> instantiator;
	private final StructuredLoggingJsonProperties properties;
	StructuredLoggingJsonPropertiesJsonMembersCustomizer(Instantiator<?> instantiator,
			StructuredLoggingJsonProperties properties) {
		this.instantiator = instantiator;
		this.properties = properties;
	}
	@Override
	public void customize(Members<Object> members) {
		members.applyingPathFilter(this::filterPath);
		members.applyingNameProcessor(this::renameJsonMembers);
		Map<String, String> add = this.properties.add();
		if (!CollectionUtils.isEmpty(add)) {
			add.forEach(members::add);
		}
		String customizer = this.properties.customizer();
		if (StringUtils.hasLength(customizer)) {
			createAndApplyCustomizer(members, customizer);
		}
	}
	String renameJsonMembers(MemberPath path, String existingName) {
		Map<String, String> rename = this.properties.rename();
		String key = path.toUnescapedString();
		return !CollectionUtils.isEmpty(rename) ? rename.getOrDefault(key, existingName) : existingName;
	}
	boolean filterPath(MemberPath path) {
		boolean included = CollectionUtils.isEmpty(this.properties.include())
				|| this.properties.include().contains(path.toUnescapedString());
		boolean excluded = !CollectionUtils.isEmpty(this.properties.exclude())
				&& this.properties.exclude().contains(path.toUnescapedString());
		return (!included || excluded);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private void createAndApplyCustomizer(Members<Object> members, String customizerClassName) {
		((StructureLoggingJsonMembersCustomizer) this.instantiator.instantiate(customizerClassName)).customize(members);
	}
}
/*
package org.springframework.boot.logging.structured;
/**
public enum CommonStructuredLogFormat {
	/**
	 * <a href='https://www.elastic.co/guide/en/ecs/current/ecs-log.html'>Elasic Common
	 * Schema</a> (ECS) log format.
	 */
	ELASTIC_COMMON_SCHEMA('ecs'),
	/**
	 * <a href='https://go2docs.graylog.org/current/getting_in_log_data/gelf.html'>Graylog
	 * Extended Log Format</a> (GELF) log format.
	 */
	GRAYLOG_EXTENDED_LOG_FORMAT('gelf'),
	/**
	 * The <a href=
	 * 'https://github.com/logfellow/logstash-logback-encoder?tab=readme-ov-file#standard-fields'>Logstash</a>
	 * log format.
	 */
	LOGSTASH('logstash');
	private final String id;
	CommonStructuredLogFormat(String id) {
		this.id = id;
	}
	/**
	 * Return the ID for this format.
	 * @return the format identifier
	 */
	String getId() {
		return this.id;
	}
	/**
	 * Find the {@link CommonStructuredLogFormat} for the given ID.
	 * @param id the format identifier
	 * @return the associated {@link CommonStructuredLogFormat} or {@code null}
	 */
	static CommonStructuredLogFormat forId(String id) {
		for (CommonStructuredLogFormat candidate : values()) {
			if (candidate.getId().equalsIgnoreCase(id)) {
				return candidate;
			}
		}
		return null;
	}
}
/*
/**
package org.springframework.boot.logging.structured;
/*
package org.springframework.boot.logging.structured;
/**
@FunctionalInterface
public interface StructureLoggingJsonMembersCustomizer<T> {
	/**
	 * Customize the given {@link Members} instance.
	 * @param members the members instance to customize
	 */
	void customize(JsonWriter.Members<T> members);
}
/*
package org.springframework.boot.logging;
/**
public enum LogLevel {
	TRACE(Log::trace),
	DEBUG(Log::debug),
	INFO(Log::info),
	WARN(Log::warn),
	ERROR(Log::error),
	FATAL(Log::fatal),
	OFF(null);
	private final LogMethod logMethod;
	LogLevel(LogMethod logMethod) {
		this.logMethod = logMethod;
	}
	/**
	 * Log a message to the given logger at this level.
	 * @param logger the logger
	 * @param message the message to log
	 * @since 3.1.0
	 */
	public void log(Log logger, Object message) {
		log(logger, message, null);
	}
	/**
	 * Log a message to the given logger at this level.
	 * @param logger the logger
	 * @param message the message to log
	 * @param cause the cause to log
	 * @since 3.1.0
	 */
	public void log(Log logger, Object message, Throwable cause) {
		if (logger != null && this.logMethod != null) {
			this.logMethod.log(logger, message, cause);
		}
	}
	@FunctionalInterface
	private interface LogMethod {
		void log(Log logger, Object message, Throwable cause);
	}
}
/*
/**
package org.springframework.boot.logging;
/*
package org.springframework.boot.logging;
/**
public class LogFile {
	/**
	 * The name of the Spring property that contains the name of the log file. Names can
	 * be an exact location or relative to the current directory.
	 * @since 2.2.0
	 */
	public static final String FILE_NAME_PROPERTY = 'logging.file.name';
	/**
	 * The name of the Spring property that contains the directory where log files are
	 * written.
	 * @since 2.2.0
	 */
	public static final String FILE_PATH_PROPERTY = 'logging.file.path';
	private final String file;
	private final String path;
	/**
	 * Create a new {@link LogFile} instance.
	 * @param file a reference to the file to write
	 */
	LogFile(String file) {
		this(file, null);
	}
	/**
	 * Create a new {@link LogFile} instance.
	 * @param file a reference to the file to write
	 * @param path a reference to the logging path to use if {@code file} is not specified
	 */
	LogFile(String file, String path) {
		Assert.isTrue(StringUtils.hasLength(file) || StringUtils.hasLength(path), 'File or Path must not be empty');
		this.file = file;
		this.path = path;
	}
	/**
	 * Apply log file details to {@code LOG_PATH} and {@code LOG_FILE} system properties.
	 */
	public void applyToSystemProperties() {
		applyTo(System.getProperties());
	}
	/**
	 * Apply log file details to {@code LOG_PATH} and {@code LOG_FILE} map entries.
	 * @param properties the properties to apply to
	 */
	public void applyTo(Properties properties) {
		put(properties, LoggingSystemProperty.LOG_PATH, this.path);
		put(properties, LoggingSystemProperty.LOG_FILE, toString());
	}
	private void put(Properties properties, LoggingSystemProperty property, String value) {
		if (StringUtils.hasLength(value)) {
			properties.put(property.getEnvironmentVariableName(), value);
		}
	}
	@Override
	public String toString() {
		if (StringUtils.hasLength(this.file)) {
			return this.file;
		}
		return new File(this.path, 'spring.log').getPath();
	}
	/**
	 * Get a {@link LogFile} from the given Spring {@link Environment}.
	 * @param propertyResolver the {@link PropertyResolver} used to obtain the logging
	 * properties
	 * @return a {@link LogFile} or {@code null} if the environment didn"t contain any
	 * suitable properties
	 */
	public static LogFile get(PropertyResolver propertyResolver) {
		String file = propertyResolver.getProperty(FILE_NAME_PROPERTY);
		String path = propertyResolver.getProperty(FILE_PATH_PROPERTY);
		if (StringUtils.hasLength(file) || StringUtils.hasLength(path)) {
			return new LogFile(file, path);
		}
		return null;
	}
}
/*
package org.springframework.boot.logging;
/**
class DelegatingLoggingSystemFactory implements LoggingSystemFactory {
	private final Function<ClassLoader, List<LoggingSystemFactory>> delegates;
	/**
	 * Create a new {@link DelegatingLoggingSystemFactory} instance.
	 * @param delegates a function that provides the delegates
	 */
	DelegatingLoggingSystemFactory(Function<ClassLoader, List<LoggingSystemFactory>> delegates) {
		this.delegates = delegates;
	}
	@Override
	public LoggingSystem getLoggingSystem(ClassLoader classLoader) {
		List<LoggingSystemFactory> delegates = (this.delegates != null) ? this.delegates.apply(classLoader) : null;
		if (delegates != null) {
			for (LoggingSystemFactory delegate : delegates) {
				LoggingSystem loggingSystem = delegate.getLoggingSystem(classLoader);
				if (loggingSystem != null) {
					return loggingSystem;
				}
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.logging;
/**
public abstract class LoggingSystem {
	/**
	 * A System property that can be used to indicate the {@link LoggingSystem} to use.
	 */
	public static final String SYSTEM_PROPERTY = LoggingSystem.class.getName();
	/**
	 * The value of the {@link #SYSTEM_PROPERTY} that can be used to indicate that no
	 * {@link LoggingSystem} should be used.
	 */
	public static final String NONE = 'none';
	/**
	 * The name used for the root logger. LoggingSystem implementations should ensure that
	 * this is the name used to represent the root logger, regardless of the underlying
	 * implementation.
	 */
	public static final String ROOT_LOGGER_NAME = 'ROOT';
	private static final LoggingSystemFactory SYSTEM_FACTORY = LoggingSystemFactory.fromSpringFactories();
	/**
	 * The name of an {@link Environment} property used to indicate that a correlation ID
	 * is expected to be logged at some point.
	 * @since 3.2.0
	 */
	public static final String EXPECT_CORRELATION_ID_PROPERTY = 'logging.expect-correlation-id';
	/**
	 * Return the {@link LoggingSystemProperties} that should be applied.
	 * @param environment the {@link ConfigurableEnvironment} used to obtain value
	 * @return the {@link LoggingSystemProperties} to apply
	 * @since 2.4.0
	 */
	public LoggingSystemProperties getSystemProperties(ConfigurableEnvironment environment) {
		return new LoggingSystemProperties(environment);
	}
	/**
	 * Reset the logging system to be limit output. This method may be called before
	 * {@link #initialize(LoggingInitializationContext, String, LogFile)} to reduce
	 * logging noise until the system has been fully initialized.
	 */
	public abstract void beforeInitialize();
	/**
	 * Fully initialize the logging system.
	 * @param initializationContext the logging initialization context
	 * @param configLocation a log configuration location or {@code null} if default
	 * initialization is required
	 * @param logFile the log output file that should be written or {@code null} for
	 * console only output
	 */
	public void initialize(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile) {
	}
	/**
	 * Clean up the logging system. The default implementation does nothing. Subclasses
	 * should override this method to perform any logging system-specific cleanup.
	 */
	public void cleanUp() {
	}
	/**
	 * Returns a {@link Runnable} that can handle shutdown of this logging system when the
	 * JVM exits. The default implementation returns {@code null}, indicating that no
	 * shutdown is required.
	 * @return the shutdown handler, or {@code null}
	 */
	public Runnable getShutdownHandler() {
		return null;
	}
	/**
	 * Returns a set of the {@link LogLevel LogLevels} that are actually supported by the
	 * logging system.
	 * @return the supported levels
	 */
	public Set<LogLevel> getSupportedLogLevels() {
		return EnumSet.allOf(LogLevel.class);
	}
	/**
	 * Sets the logging level for a given logger.
	 * @param loggerName the name of the logger to set ({@code null} can be used for the
	 * root logger).
	 * @param level the log level ({@code null} can be used to remove any custom level for
	 * the logger and use the default configuration instead)
	 */
	public void setLogLevel(String loggerName, LogLevel level) {
		throw new UnsupportedOperationException('Unable to set log level');
	}
	/**
	 * Returns a collection of the current configuration for all a {@link LoggingSystem}"s
	 * loggers.
	 * @return the current configurations
	 * @since 1.5.0
	 */
	public List<LoggerConfiguration> getLoggerConfigurations() {
		throw new UnsupportedOperationException('Unable to get logger configurations');
	}
	/**
	 * Returns the current configuration for a {@link LoggingSystem}"s logger.
	 * @param loggerName the name of the logger
	 * @return the current configuration
	 * @since 1.5.0
	 */
	public LoggerConfiguration getLoggerConfiguration(String loggerName) {
		throw new UnsupportedOperationException('Unable to get logger configuration');
	}
	/**
	 * Detect and return the logging system in use. Supports Logback and Java Logging.
	 * @param classLoader the classloader
	 * @return the logging system
	 */
	public static LoggingSystem get(ClassLoader classLoader) {
		String loggingSystemClassName = System.getProperty(SYSTEM_PROPERTY);
		if (StringUtils.hasLength(loggingSystemClassName)) {
			if (NONE.equals(loggingSystemClassName)) {
				return new NoOpLoggingSystem();
			}
			return get(classLoader, loggingSystemClassName);
		}
		LoggingSystem loggingSystem = SYSTEM_FACTORY.getLoggingSystem(classLoader);
		Assert.state(loggingSystem != null, 'No suitable logging system located');
		return loggingSystem;
	}
	private static LoggingSystem get(ClassLoader classLoader, String loggingSystemClassName) {
		try {
			Class<?> systemClass = ClassUtils.forName(loggingSystemClassName, classLoader);
			Constructor<?> constructor = systemClass.getDeclaredConstructor(ClassLoader.class);
			constructor.setAccessible(true);
			return (LoggingSystem) constructor.newInstance(classLoader);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	/**
	 * {@link LoggingSystem} that does nothing.
	 */
	static class NoOpLoggingSystem extends LoggingSystem {
		@Override
		public void beforeInitialize() {
		}
		@Override
		public void setLogLevel(String loggerName, LogLevel level) {
		}
		@Override
		public List<LoggerConfiguration> getLoggerConfigurations() {
			return Collections.emptyList();
		}
		@Override
		public LoggerConfiguration getLoggerConfiguration(String loggerName) {
			return null;
		}
	}
}
/*
package org.springframework.boot.logging.java;
/**
public class SimpleFormatter extends Formatter {
	private static final String DEFAULT_FORMAT = '[%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL] - %8$s %4$s [%7$s] --- %3$s: %5$s%6$s%n';
	private final String format = getOrUseDefault('LOG_FORMAT', DEFAULT_FORMAT);
	private final String pid = getOrUseDefault(LoggingSystemProperty.PID.getEnvironmentVariableName(), '????');
	@Override
	public String format(LogRecord record) {
		Date date = new Date(record.getMillis());
		String source = record.getLoggerName();
		String message = formatMessage(record);
		String throwable = getThrowable(record);
		String thread = getThreadName();
		return String.format(this.format, date, source, record.getLoggerName(), record.getLevel().getLocalizedName(),
				message, throwable, thread, this.pid);
	}
	private String getThrowable(LogRecord record) {
		if (record.getThrown() == null) {
			return '';
		}
		StringWriter stringWriter = new StringWriter();
		PrintWriter printWriter = new PrintWriter(stringWriter);
		printWriter.println();
		record.getThrown().printStackTrace(printWriter);
		printWriter.close();
		return stringWriter.toString();
	}
	private String getThreadName() {
		String name = Thread.currentThread().getName();
		return (name != null) ? name : '';
	}
	private static String getOrUseDefault(String key, String defaultValue) {
		String value = null;
		try {
			value = System.getenv(key);
		}
		catch (Exception ex) {
			// ignore
		}
		if (value == null) {
			value = defaultValue;
		}
		return System.getProperty(key, value);
	}
}
/*
/**
package org.springframework.boot.logging.java;
/*
package org.springframework.boot.logging.java;
/**
class JavaLoggingSystemRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		hints.resources().registerPattern('org/springframework/boot/logging/java/logging.properties');
		hints.resources().registerPattern('org/springframework/boot/logging/java/logging-file.properties');
	}
}
/*
package org.springframework.boot.logging.java;
/**
public class JavaLoggingSystem extends AbstractLoggingSystem {
	private static final LogLevels<Level> LEVELS = new LogLevels<>();
	static {
		LEVELS.map(LogLevel.TRACE, Level.FINEST);
		LEVELS.map(LogLevel.DEBUG, Level.FINE);
		LEVELS.map(LogLevel.INFO, Level.INFO);
		LEVELS.map(LogLevel.WARN, Level.WARNING);
		LEVELS.map(LogLevel.ERROR, Level.SEVERE);
		LEVELS.map(LogLevel.FATAL, Level.SEVERE);
		LEVELS.map(LogLevel.OFF, Level.OFF);
	}
	private final Set<Logger> configuredLoggers = Collections.synchronizedSet(new HashSet<>());
	public JavaLoggingSystem(ClassLoader classLoader) {
		super(classLoader);
	}
	@Override
	protected String[] getStandardConfigLocations() {
		return new String[] { 'logging.properties' };
	}
	@Override
	public void beforeInitialize() {
		super.beforeInitialize();
		Logger.getLogger('').setLevel(Level.SEVERE);
	}
	@Override
	protected void loadDefaults(LoggingInitializationContext initializationContext, LogFile logFile) {
		if (logFile != null) {
			loadConfiguration(getPackagedConfigFile('logging-file.properties'), logFile);
		}
		else {
			loadConfiguration(getPackagedConfigFile('logging.properties'), null);
		}
	}
	@Override
	protected void loadConfiguration(LoggingInitializationContext initializationContext, String location,
			LogFile logFile) {
		loadConfiguration(location, logFile);
	}
	protected void loadConfiguration(String location, LogFile logFile) {
		Assert.notNull(location, 'Location must not be null');
		try {
			Resource resource = ApplicationResourceLoader.get().getResource(location);
			String configuration = FileCopyUtils.copyToString(new InputStreamReader(resource.getInputStream()));
			if (logFile != null) {
				configuration = configuration.replace('${LOG_FILE}', StringUtils.cleanPath(logFile.toString()));
			}
			LogManager.getLogManager().readConfiguration(new ByteArrayInputStream(configuration.getBytes()));
		}
		catch (Exception ex) {
			throw new IllegalStateException('Could not initialize Java logging from ' + location, ex);
		}
	}
	@Override
	public Set<LogLevel> getSupportedLogLevels() {
		return LEVELS.getSupported();
	}
	@Override
	public void setLogLevel(String loggerName, LogLevel level) {
		if (loggerName == null || ROOT_LOGGER_NAME.equals(loggerName)) {
			loggerName = '';
		}
		Logger logger = Logger.getLogger(loggerName);
		if (logger != null) {
			this.configuredLoggers.add(logger);
			logger.setLevel(LEVELS.convertSystemToNative(level));
		}
	}
	@Override
	public List<LoggerConfiguration> getLoggerConfigurations() {
		List<LoggerConfiguration> result = new ArrayList<>();
		Enumeration<String> names = LogManager.getLogManager().getLoggerNames();
		while (names.hasMoreElements()) {
			result.add(getLoggerConfiguration(names.nextElement()));
		}
		result.sort(CONFIGURATION_COMPARATOR);
		return Collections.unmodifiableList(result);
	}
	@Override
	public LoggerConfiguration getLoggerConfiguration(String loggerName) {
		Logger logger = Logger.getLogger(loggerName);
		if (logger == null) {
			return null;
		}
		LogLevel level = LEVELS.convertNativeToSystem(logger.getLevel());
		LogLevel effectiveLevel = LEVELS.convertNativeToSystem(getEffectiveLevel(logger));
		String name = (StringUtils.hasLength(logger.getName()) ? logger.getName() : ROOT_LOGGER_NAME);
		return new LoggerConfiguration(name, level, effectiveLevel);
	}
	private Level getEffectiveLevel(Logger root) {
		Logger logger = root;
		while (logger.getLevel() == null) {
			logger = logger.getParent();
		}
		return logger.getLevel();
	}
	@Override
	public Runnable getShutdownHandler() {
		return () -> LogManager.getLogManager().reset();
	}
	@Override
	public void cleanUp() {
		this.configuredLoggers.clear();
	}
	/**
	 * {@link LoggingSystemFactory} that returns {@link JavaLoggingSystem} if possible.
	 */
	@Order(Ordered.LOWEST_PRECEDENCE)
	public static class Factory implements LoggingSystemFactory {
		private static final boolean PRESENT = ClassUtils.isPresent('java.util.logging.LogManager',
				Factory.class.getClassLoader());
		@Override
		public LoggingSystem getLoggingSystem(ClassLoader classLoader) {
			if (PRESENT) {
				return new JavaLoggingSystem(classLoader);
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.logging;
/**
public class LoggingInitializationContext {
	private final ConfigurableEnvironment environment;
	/**
	 * Create a new {@link LoggingInitializationContext} instance.
	 * @param environment the Spring environment.
	 */
	public LoggingInitializationContext(ConfigurableEnvironment environment) {
		this.environment = environment;
	}
	/**
	 * Return the Spring environment if available.
	 * @return the {@link Environment} or {@code null}
	 */
	public Environment getEnvironment() {
		return this.environment;
	}
}
/*
package org.springframework.boot.info;
/**
@ImportRuntimeHints(BuildPropertiesRuntimeHints.class)
public class BuildProperties extends InfoProperties {
	/**
	 * Create an instance with the specified entries.
	 * @param entries the information to expose
	 */
	public BuildProperties(Properties entries) {
		super(processEntries(entries));
	}
	/**
	 * Return the groupId of the project or {@code null}.
	 * @return the group
	 */
	public String getGroup() {
		return get('group');
	}
	/**
	 * Return the artifactId of the project or {@code null}.
	 * @return the artifact
	 */
	public String getArtifact() {
		return get('artifact');
	}
	/**
	 * Return the name of the project or {@code null}.
	 * @return the name
	 */
	public String getName() {
		return get('name');
	}
	/**
	 * Return the version of the project or {@code null}.
	 * @return the version
	 */
	public String getVersion() {
		return get('version');
	}
	/**
	 * Return the timestamp of the build or {@code null}.
	 * <p>
	 * If the original value could not be parsed properly, it is still available with the
	 * {@code time} key.
	 * @return the build time
	 * @see #get(String)
	 */
	public Instant getTime() {
		return getInstant('time');
	}
	private static Properties processEntries(Properties properties) {
		coerceDate(properties, 'time');
		return properties;
	}
	private static void coerceDate(Properties properties, String key) {
		String value = properties.getProperty(key);
		if (value != null) {
			try {
				String updatedValue = String
					.valueOf(DateTimeFormatter.ISO_INSTANT.parse(value, Instant::from).toEpochMilli());
				properties.setProperty(key, updatedValue);
			}
			catch (DateTimeException ex) {
				// Ignore and store the original value
			}
		}
	}
	static class BuildPropertiesRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('META-INF/build-info.properties');
		}
	}
}
/*
package org.springframework.boot.info;
/**
public class OsInfo {
	private final String name;
	private final String version;
	private final String arch;
	public OsInfo() {
		this.name = System.getProperty('os.name');
		this.version = System.getProperty('os.version');
		this.arch = System.getProperty('os.arch');
	}
	public String getName() {
		return this.name;
	}
	public String getVersion() {
		return this.version;
	}
	public String getArch() {
		return this.arch;
	}
}
/*
package org.springframework.boot.info;
/**
@ImportRuntimeHints(GitPropertiesRuntimeHints.class)
public class GitProperties extends InfoProperties {
	static final Set<Coercer> coercers = Set.of(Coercer.milliseconds(),
			Coercer.dateTimePattern('yyyy-MM-dd"T"HH:mm:ssXXX'), Coercer.dateTimePattern('yyyy-MM-dd"T"HH:mm:ssZ'));
	public GitProperties(Properties entries) {
		super(processEntries(entries));
	}
	/**
	 * Return the name of the branch or {@code null}.
	 * @return the branch
	 */
	public String getBranch() {
		return get('branch');
	}
	/**
	 * Return the full id of the commit or {@code null}.
	 * @return the full commit id
	 */
	public String getCommitId() {
		return get('commit.id');
	}
	/**
	 * Return the abbreviated id of the commit or {@code null}.
	 * @return the short commit id
	 */
	public String getShortCommitId() {
		String shortId = get('commit.id.abbrev');
		if (shortId != null) {
			return shortId;
		}
		String id = getCommitId();
		if (id == null) {
			return null;
		}
		return (id.length() > 7) ? id.substring(0, 7) : id;
	}
	/**
	 * Return the timestamp of the commit or {@code null}.
	 * <p>
	 * If the original value could not be parsed properly, it is still available with the
	 * {@code commit.time} key.
	 * @return the commit time
	 * @see #get(String)
	 */
	public Instant getCommitTime() {
		return getInstant('commit.time');
	}
	private static Properties processEntries(Properties properties) {
		coercePropertyToEpoch(properties, 'commit.time');
		coercePropertyToEpoch(properties, 'build.time');
		Object commitId = properties.get('commit.id');
		if (commitId != null) {
			// Can get converted into a map, so we copy the entry as a nested key
			properties.put('commit.id.full', commitId);
		}
		return properties;
	}
	private static void coercePropertyToEpoch(Properties properties, String key) {
		String value = properties.getProperty(key);
		if (value != null) {
			properties.setProperty(key,
					coercers.stream()
						.map((coercer) -> coercer.apply(value))
						.filter(Objects::nonNull)
						.findFirst()
						.orElse(value));
		}
	}
	/**
	 * {@link RuntimeHintsRegistrar} for git properties.
	 */
	static class GitPropertiesRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('git.properties');
		}
	}
	/**
	 * Coercer used to convert a source value to epoch time.
	 */
	private record Coercer(Function<String, Long> action, Predicate<RuntimeException> ignoredExceptions) {
		/**
		 * Attempt to convert the specified value to epoch time.
		 * @param value the value to coerce to
		 * @return the epoch time in milliseconds or {@code null}
		 */
		String apply(String value) {
			try {
				Long result = this.action.apply(value);
				return (result != null) ? String.valueOf(result) : null;
			}
			catch (RuntimeException ex) {
				if (this.ignoredExceptions.test(ex)) {
					return null;
				}
				throw ex;
			}
		}
		static Coercer milliseconds() {
			return new Coercer((value) -> Long.parseLong(value) * 1000, NumberFormatException.class::isInstance);
		}
		static Coercer dateTimePattern(String pattern) {
			return new Coercer(
					(value) -> DateTimeFormatter.ofPattern(pattern).parse(value, Instant::from).toEpochMilli(),
					DateTimeParseException.class::isInstance);
		}
	}
}
/*
package org.springframework.boot.info;
/**
public class SslInfo {
	private final SslBundles sslBundles;
	private final Duration certificateValidityWarningThreshold;
	public SslInfo(SslBundles sslBundles, Duration certificateValidityWarningThreshold) {
		this.sslBundles = sslBundles;
		this.certificateValidityWarningThreshold = certificateValidityWarningThreshold;
	}
	public List<BundleInfo> getBundles() {
		return this.sslBundles.getBundleNames()
			.stream()
			.map((name) -> new BundleInfo(name, this.sslBundles.getBundle(name)))
			.toList();
	}
	/**
	 * Info about a single {@link SslBundle}.
	 */
	public final class BundleInfo {
		private final String name;
		private final List<CertificateChainInfo> certificateChains;
		private BundleInfo(String name, SslBundle sslBundle) {
			this.name = name;
			this.certificateChains = extractCertificateChains(sslBundle.getStores().getKeyStore());
		}
		private List<CertificateChainInfo> extractCertificateChains(KeyStore keyStore) {
			try {
				return Collections.list(keyStore.aliases())
					.stream()
					.map((alias) -> new CertificateChainInfo(keyStore, alias))
					.toList();
			}
			catch (KeyStoreException ex) {
				return Collections.emptyList();
			}
		}
		public String getName() {
			return this.name;
		}
		public List<CertificateChainInfo> getCertificateChains() {
			return this.certificateChains;
		}
	}
	/**
	 * Info about a single certificate chain.
	 */
	public final class CertificateChainInfo {
		private final String alias;
		private final List<CertificateInfo> certificates;
		CertificateChainInfo(KeyStore keyStore, String alias) {
			this.alias = alias;
			this.certificates = extractCertificates(keyStore, alias);
		}
		private List<CertificateInfo> extractCertificates(KeyStore keyStore, String alias) {
			try {
				Certificate[] certificates = keyStore.getCertificateChain(alias);
				return (!ObjectUtils.isEmpty(certificates))
						? Arrays.stream(certificates).map(CertificateInfo::new).toList() : Collections.emptyList();
			}
			catch (KeyStoreException ex) {
				return Collections.emptyList();
			}
		}
		public String getAlias() {
			return this.alias;
		}
		public List<CertificateInfo> getCertificates() {
			return this.certificates;
		}
	}
	/**
	 * Info about a certificate.
	 */
	public final class CertificateInfo {
		private final X509Certificate certificate;
		private CertificateInfo(Certificate certificate) {
			this.certificate = (certificate instanceof X509Certificate x509Certificate) ? x509Certificate : null;
		}
		public String getSubject() {
			return extract(X509Certificate::getSubjectX500Principal, X500Principal::getName);
		}
		public String getIssuer() {
			return extract(X509Certificate::getIssuerX500Principal, X500Principal::getName);
		}
		public String getSerialNumber() {
			return extract(X509Certificate::getSerialNumber, (serial) -> serial.toString(16));
		}
		public String getVersion() {
			return extract((certificate) -> 'V' + certificate.getVersion());
		}
		public String getSignatureAlgorithmName() {
			return extract(X509Certificate::getSigAlgName);
		}
		public Instant getValidityStarts() {
			return extract(X509Certificate::getNotBefore, Date::toInstant);
		}
		public Instant getValidityEnds() {
			return extract(X509Certificate::getNotAfter, Date::toInstant);
		}
		public CertificateValidityInfo getValidity() {
			return extract((certificate) -> {
				Instant starts = getValidityStarts();
				Instant ends = getValidityEnds();
				Duration threshold = SslInfo.this.certificateValidityWarningThreshold;
				try {
					certificate.checkValidity();
					return (!isExpiringSoon(certificate, threshold)) ? CertificateValidityInfo.VALID
							: new CertificateValidityInfo(Status.WILL_EXPIRE_SOON,
									'Certificate will expire within threshold (%s) at %s', threshold, ends);
				}
				catch (CertificateNotYetValidException ex) {
					return new CertificateValidityInfo(Status.NOT_YET_VALID, 'Not valid before %s', starts);
				}
				catch (CertificateExpiredException ex) {
					return new CertificateValidityInfo(Status.EXPIRED, 'Not valid after %s', ends);
				}
			});
		}
		private boolean isExpiringSoon(X509Certificate certificate, Duration threshold) {
			Instant shouldBeValidAt = Instant.now().plus(threshold);
			Instant expiresAt = certificate.getNotAfter().toInstant();
			return shouldBeValidAt.isAfter(expiresAt);
		}
		private <V, R> R extract(Function<X509Certificate, V> valueExtractor, Function<V, R> resultExtractor) {
			return extract(valueExtractor.andThen(resultExtractor));
		}
		private <R> R extract(Function<X509Certificate, R> extractor) {
			return (this.certificate != null) ? extractor.apply(this.certificate) : null;
		}
	}
	/**
	 * Certificate validity info.
	 */
	public static class CertificateValidityInfo {
		static final CertificateValidityInfo VALID = new CertificateValidityInfo(Status.VALID, null);
		private final Status status;
		private final String message;
		CertificateValidityInfo(Status status, String message, Object... messageArgs) {
			this.status = status;
			this.message = (message != null) ? message.formatted(messageArgs) : null;
		}
		public Status getStatus() {
			return this.status;
		}
		public String getMessage() {
			return this.message;
		}
		/**
		 * Validity Status.
		 */
		public enum Status {
			/**
			 * The certificate is valid.
			 */
			VALID(true),
			/**
			 * The certificate"s validity date range is in the future.
			 */
			NOT_YET_VALID(false),
			/**
			 * The certificate"s validity date range is in the past.
			 */
			EXPIRED(false),
			/**
			 * The certificate is still valid, but the end of its validity date range is
			 * within the defined threshold.
			 */
			WILL_EXPIRE_SOON(true);
			private final boolean valid;
			Status(boolean valid) {
				this.valid = valid;
			}
			public boolean isValid() {
				return this.valid;
			}
		}
	}
}
/*
package org.springframework.boot.info;
/**
public class InfoProperties implements Iterable<InfoProperties.Entry> {
	private final Properties entries;
	/**
	 * Create an instance with the specified entries.
	 * @param entries the information to expose
	 */
	public InfoProperties(Properties entries) {
		Assert.notNull(entries, 'Entries must not be null');
		this.entries = copy(entries);
	}
	/**
	 * Return the value of the specified property or {@code null}.
	 * @param key the key of the property
	 * @return the property value
	 */
	public String get(String key) {
		return this.entries.getProperty(key);
	}
	/**
	 * Return the value of the specified property as an {@link Instant} or {@code null} if
	 * the value is not a valid {@link Long} representation of an epoch time.
	 * @param key the key of the property
	 * @return the property value
	 */
	public Instant getInstant(String key) {
		String s = get(key);
		if (s != null) {
			try {
				return Instant.ofEpochMilli(Long.parseLong(s));
			}
			catch (NumberFormatException ex) {
				// Not valid epoch time
			}
		}
		return null;
	}
	@Override
	public Iterator<Entry> iterator() {
		return new PropertiesIterator(this.entries);
	}
	/**
	 * Return a {@link PropertySource} of this instance.
	 * @return a {@link PropertySource}
	 */
	public PropertySource<?> toPropertySource() {
		return new PropertiesPropertySource(getClass().getSimpleName(), copy(this.entries));
	}
	private Properties copy(Properties properties) {
		Properties copy = new Properties();
		copy.putAll(properties);
		return copy;
	}
	private static final class PropertiesIterator implements Iterator<Entry> {
		private final Iterator<Map.Entry<Object, Object>> iterator;
		private PropertiesIterator(Properties properties) {
			this.iterator = properties.entrySet().iterator();
		}
		@Override
		public boolean hasNext() {
			return this.iterator.hasNext();
		}
		@Override
		public Entry next() {
			Map.Entry<Object, Object> entry = this.iterator.next();
			return new Entry((String) entry.getKey(), (String) entry.getValue());
		}
		@Override
		public void remove() {
			throw new UnsupportedOperationException('InfoProperties are immutable.');
		}
	}
	/**
	 * Property entry.
	 */
	public static final class Entry {
		private final String key;
		private final String value;
		private Entry(String key, String value) {
			this.key = key;
			this.value = value;
		}
		public String getKey() {
			return this.key;
		}
		public String getValue() {
			return this.value;
		}
	}
}
/*
package org.springframework.boot.info;
/**
public class JavaInfo {
	private final String version;
	private final JavaVendorInfo vendor;
	private final JavaRuntimeEnvironmentInfo runtime;
	private final JavaVirtualMachineInfo jvm;
	public JavaInfo() {
		this.version = System.getProperty('java.version');
		this.vendor = new JavaVendorInfo();
		this.runtime = new JavaRuntimeEnvironmentInfo();
		this.jvm = new JavaVirtualMachineInfo();
	}
	public String getVersion() {
		return this.version;
	}
	public JavaVendorInfo getVendor() {
		return this.vendor;
	}
	public JavaRuntimeEnvironmentInfo getRuntime() {
		return this.runtime;
	}
	public JavaVirtualMachineInfo getJvm() {
		return this.jvm;
	}
	/**
	 * Information about the Java Vendor of the Java Runtime the application is running
	 * in.
	 *
	 * @since 2.7.0
	 */
	public static class JavaVendorInfo {
		private final String name;
		private final String version;
		public JavaVendorInfo() {
			this.name = System.getProperty('java.vendor');
			this.version = System.getProperty('java.vendor.version');
		}
		public String getName() {
			return this.name;
		}
		public String getVersion() {
			return this.version;
		}
	}
	/**
	 * Information about the Java Runtime Environment the application is running in.
	 */
	public static class JavaRuntimeEnvironmentInfo {
		private final String name;
		private final String version;
		public JavaRuntimeEnvironmentInfo() {
			this.name = System.getProperty('java.runtime.name');
			this.version = System.getProperty('java.runtime.version');
		}
		public String getName() {
			return this.name;
		}
		public String getVersion() {
			return this.version;
		}
	}
	/**
	 * Information about the Java Virtual Machine the application is running in.
	 */
	public static class JavaVirtualMachineInfo {
		private final String name;
		private final String vendor;
		private final String version;
		public JavaVirtualMachineInfo() {
			this.name = System.getProperty('java.vm.name');
			this.vendor = System.getProperty('java.vm.vendor');
			this.version = System.getProperty('java.vm.version');
		}
		public String getName() {
			return this.name;
		}
		public String getVendor() {
			return this.vendor;
		}
		public String getVersion() {
			return this.version;
		}
	}
}
/*
package org.springframework.boot.info;
/**
public class ProcessInfo {
	private static final Runtime runtime = Runtime.getRuntime();
	private final long pid;
	private final long parentPid;
	private final String owner;
	public ProcessInfo() {
		ProcessHandle process = ProcessHandle.current();
		this.pid = process.pid();
		this.parentPid = process.parent().map(ProcessHandle::pid).orElse(-1L);
		this.owner = process.info().user().orElse(null);
	}
	/**
	 * Number of processors available to the process. This value may change between
	 * invocations especially in (containerized) environments where resource usage can be
	 * isolated (for example using control groups).
	 * @return result of {@link Runtime#availableProcessors()}
	 * @see Runtime#availableProcessors()
	 */
	public int getCpus() {
		return runtime.availableProcessors();
	}
	/**
	 * Memory information for the process. These values can provide details about the
	 * current memory usage and limits selected by the user or JVM ergonomics (init, max,
	 * committed, used for heap and non-heap). If limits not set explicitly, it might not
	 * be trivial to know what these values are runtime; especially in (containerized)
	 * environments where resource usage can be isolated (for example using control
	 * groups) or not necessarily trivial to discover. Other than that, these values can
	 * indicate if the JVM can resize the heap (stop-the-world).
	 * @return heap and non-heap memory information
	 * @since 3.4.0
	 * @see MemoryMXBean#getHeapMemoryUsage()
	 * @see MemoryMXBean#getNonHeapMemoryUsage()
	 * @see MemoryUsage
	 */
	public MemoryInfo getMemory() {
		return new MemoryInfo();
	}
	public long getPid() {
		return this.pid;
	}
	public long getParentPid() {
		return this.parentPid;
	}
	public String getOwner() {
		return this.owner;
	}
	/**
	 * Memory information.
	 *
	 * @since 3.4.0
	 */
	public static class MemoryInfo {
		private static final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
		private final MemoryUsageInfo heap;
		private final MemoryUsageInfo nonHeap;
		MemoryInfo() {
			this.heap = new MemoryUsageInfo(memoryMXBean.getHeapMemoryUsage());
			this.nonHeap = new MemoryUsageInfo(memoryMXBean.getNonHeapMemoryUsage());
		}
		public MemoryUsageInfo getHeap() {
			return this.heap;
		}
		public MemoryUsageInfo getNonHeap() {
			return this.nonHeap;
		}
		public static class MemoryUsageInfo {
			private final MemoryUsage memoryUsage;
			MemoryUsageInfo(MemoryUsage memoryUsage) {
				this.memoryUsage = memoryUsage;
			}
			public long getInit() {
				return this.memoryUsage.getInit();
			}
			public long getUsed() {
				return this.memoryUsage.getUsed();
			}
			public long getCommitted() {
				return this.memoryUsage.getCommitted();
			}
			public long getMax() {
				return this.memoryUsage.getMax();
			}
		}
	}
}
/*
/**
package org.springframework.boot.info;
/*
package org.springframework.boot;
/**
class ExitCodeGenerators implements Iterable<ExitCodeGenerator> {
	private final List<ExitCodeGenerator> generators = new ArrayList<>();
	void addAll(Throwable exception, ExitCodeExceptionMapper... mappers) {
		Assert.notNull(exception, 'Exception must not be null');
		Assert.notNull(mappers, 'Mappers must not be null');
		addAll(exception, Arrays.asList(mappers));
	}
	void addAll(Throwable exception, Iterable<? extends ExitCodeExceptionMapper> mappers) {
		Assert.notNull(exception, 'Exception must not be null');
		Assert.notNull(mappers, 'Mappers must not be null');
		for (ExitCodeExceptionMapper mapper : mappers) {
			add(exception, mapper);
		}
	}
	void add(Throwable exception, ExitCodeExceptionMapper mapper) {
		Assert.notNull(exception, 'Exception must not be null');
		Assert.notNull(mapper, 'Mapper must not be null');
		add(new MappedExitCodeGenerator(exception, mapper));
	}
	void addAll(ExitCodeGenerator... generators) {
		Assert.notNull(generators, 'Generators must not be null');
		addAll(Arrays.asList(generators));
	}
	void addAll(Iterable<? extends ExitCodeGenerator> generators) {
		Assert.notNull(generators, 'Generators must not be null');
		for (ExitCodeGenerator generator : generators) {
			add(generator);
		}
	}
	void add(ExitCodeGenerator generator) {
		Assert.notNull(generator, 'Generator must not be null');
		this.generators.add(generator);
		AnnotationAwareOrderComparator.sort(this.generators);
	}
	@Override
	public Iterator<ExitCodeGenerator> iterator() {
		return this.generators.iterator();
	}
	/**
	 * Get the final exit code that should be returned. The final exit code is the first
	 * non-zero exit code that is {@link ExitCodeGenerator#getExitCode generated}.
	 * @return the final exit code.
	 */
	int getExitCode() {
		int exitCode = 0;
		for (ExitCodeGenerator generator : this.generators) {
			try {
				int value = generator.getExitCode();
				if (value != 0) {
					exitCode = value;
					break;
				}
			}
			catch (Exception ex) {
				exitCode = 1;
				ex.printStackTrace();
			}
		}
		return exitCode;
	}
	/**
	 * Adapts an {@link ExitCodeExceptionMapper} to an {@link ExitCodeGenerator}.
	 */
	private static class MappedExitCodeGenerator implements ExitCodeGenerator {
		private final Throwable exception;
		private final ExitCodeExceptionMapper mapper;
		MappedExitCodeGenerator(Throwable exception, ExitCodeExceptionMapper mapper) {
			this.exception = exception;
			this.mapper = mapper;
		}
		@Override
		public int getExitCode() {
			return this.mapper.getExitCode(this.exception);
		}
	}
}
/*
package org.springframework.boot.system;
/**
public class ApplicationPid {
	private static final PosixFilePermission[] WRITE_PERMISSIONS = { PosixFilePermission.OWNER_WRITE,
			PosixFilePermission.GROUP_WRITE, PosixFilePermission.OTHERS_WRITE };
	private final Long pid;
	public ApplicationPid() {
		this.pid = currentProcessPid();
	}
	protected ApplicationPid(Long pid) {
		this.pid = pid;
	}
	private Long currentProcessPid() {
		try {
			return ProcessHandle.current().pid();
		}
		catch (Throwable ex) {
			return null;
		}
	}
	/**
	 * Return if the application PID is available.
	 * @return {@code true} if the PID is available
	 * @since 3.4.0
	 */
	public boolean isAvailable() {
		return this.pid != null;
	}
	/**
	 * Return the application PID as a {@link Long}.
	 * @return the application PID or {@code null}
	 * @since 3.4.0
	 */
	public Long toLong() {
		return this.pid;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj instanceof ApplicationPid other) {
			return ObjectUtils.nullSafeEquals(this.pid, other.pid);
		}
		return false;
	}
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHashCode(this.pid);
	}
	@Override
	public String toString() {
		return (this.pid != null) ? String.valueOf(this.pid) : '???';
	}
	/**
	 * Write the PID to the specified file.
	 * @param file the PID file
	 * @throws IllegalStateException if no PID is available.
	 * @throws IOException if the file cannot be written
	 */
	public void write(File file) throws IOException {
		Assert.state(this.pid != null, 'No PID available');
		createParentDirectory(file);
		if (file.exists()) {
			assertCanOverwrite(file);
		}
		try (FileWriter writer = new FileWriter(file)) {
			writer.append(String.valueOf(this.pid));
		}
	}
	private void createParentDirectory(File file) {
		File parent = file.getParentFile();
		if (parent != null) {
			parent.mkdirs();
		}
	}
	private void assertCanOverwrite(File file) throws IOException {
		if (!file.canWrite() || !canWritePosixFile(file)) {
			throw new FileNotFoundException(file + ' (permission denied)');
		}
	}
	private boolean canWritePosixFile(File file) throws IOException {
		try {
			Set<PosixFilePermission> permissions = Files.getPosixFilePermissions(file.toPath());
			for (PosixFilePermission permission : WRITE_PERMISSIONS) {
				if (permissions.contains(permission)) {
					return true;
				}
			}
			return false;
		}
		catch (UnsupportedOperationException ex) {
			// Assume that we can
			return true;
		}
	}
}
/*
package org.springframework.boot.system;
/**
public class ApplicationHome {
	private final File source;
	private final File dir;
	/**
	 * Create a new {@link ApplicationHome} instance.
	 */
	public ApplicationHome() {
		this(null);
	}
	/**
	 * Create a new {@link ApplicationHome} instance for the specified source class.
	 * @param sourceClass the source class or {@code null}
	 */
	public ApplicationHome(Class<?> sourceClass) {
		this.source = findSource((sourceClass != null) ? sourceClass : getStartClass());
		this.dir = findHomeDir(this.source);
	}
	private Class<?> getStartClass() {
		try {
			ClassLoader classLoader = getClass().getClassLoader();
			return getStartClass(classLoader.getResources('META-INF/MANIFEST.MF'));
		}
		catch (Exception ex) {
			return null;
		}
	}
	private Class<?> getStartClass(Enumeration<URL> manifestResources) {
		while (manifestResources.hasMoreElements()) {
			try (InputStream inputStream = manifestResources.nextElement().openStream()) {
				Manifest manifest = new Manifest(inputStream);
				String startClass = manifest.getMainAttributes().getValue('Start-Class');
				if (startClass != null) {
					return ClassUtils.forName(startClass, getClass().getClassLoader());
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return null;
	}
	private File findSource(Class<?> sourceClass) {
		try {
			ProtectionDomain domain = (sourceClass != null) ? sourceClass.getProtectionDomain() : null;
			CodeSource codeSource = (domain != null) ? domain.getCodeSource() : null;
			URL location = (codeSource != null) ? codeSource.getLocation() : null;
			File source = (location != null) ? findSource(location) : null;
			if (source != null && source.exists() && !isUnitTest()) {
				return source.getAbsoluteFile();
			}
		}
		catch (Exception ex) {
			// Ignore
		}
		return null;
	}
	private boolean isUnitTest() {
		try {
			StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
			for (int i = stackTrace.length - 1; i >= 0; i--) {
				if (stackTrace[i].getClassName().startsWith('org.junit.')) {
					return true;
				}
			}
		}
		catch (Exception ex) {
			// Ignore
		}
		return false;
	}
	private File findSource(URL location) throws IOException, URISyntaxException {
		URLConnection connection = location.openConnection();
		if (connection instanceof JarURLConnection jarURLConnection) {
			return getRootJarFile(jarURLConnection.getJarFile());
		}
		return new File(location.toURI());
	}
	private File getRootJarFile(JarFile jarFile) {
		String name = jarFile.getName();
		int separator = name.indexOf('!/');
		if (separator > 0) {
			name = name.substring(0, separator);
		}
		return new File(name);
	}
	private File findHomeDir(File source) {
		File homeDir = source;
		homeDir = (homeDir != null) ? homeDir : findDefaultHomeDir();
		if (homeDir.isFile()) {
			homeDir = homeDir.getParentFile();
		}
		homeDir = homeDir.exists() ? homeDir : new File('.');
		return homeDir.getAbsoluteFile();
	}
	private File findDefaultHomeDir() {
		String userDir = System.getProperty('user.dir');
		return new File(StringUtils.hasLength(userDir) ? userDir : '.');
	}
	/**
	 * Returns the underlying source used to find the home directory. This is usually the
	 * jar file or a directory. Can return {@code null} if the source cannot be
	 * determined.
	 * @return the underlying source or {@code null}
	 */
	public File getSource() {
		return this.source;
	}
	/**
	 * Returns the application home directory.
	 * @return the home directory (never {@code null})
	 */
	public File getDir() {
		return this.dir;
	}
	@Override
	public String toString() {
		return getDir().toString();
	}
}
/*
package org.springframework.boot.system;
/**
public final class SystemProperties {
	private SystemProperties() {
	}
	public static String get(String... properties) {
		for (String property : properties) {
			try {
				String override = System.getProperty(property);
				override = (override != null) ? override : System.getenv(property);
				if (override != null) {
					return override;
				}
			}
			catch (Throwable ex) {
				System.err.println('Could not resolve "' + property + '" as system property: ' + ex);
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.system;
/**
public class ApplicationTemp {
	private static final FileAttribute<?>[] NO_FILE_ATTRIBUTES = {};
	private static final EnumSet<PosixFilePermission> DIRECTORY_PERMISSIONS = EnumSet.of(PosixFilePermission.OWNER_READ,
			PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_EXECUTE);
	private final Class<?> sourceClass;
	private final Lock pathLock = new ReentrantLock();
	private volatile Path path;
	/**
	 * Create a new {@link ApplicationTemp} instance.
	 */
	public ApplicationTemp() {
		this(null);
	}
	/**
	 * Create a new {@link ApplicationTemp} instance for the specified source class.
	 * @param sourceClass the source class or {@code null}
	 */
	public ApplicationTemp(Class<?> sourceClass) {
		this.sourceClass = sourceClass;
	}
	@Override
	public String toString() {
		return getDir().getAbsolutePath();
	}
	/**
	 * Return the directory to be used for application specific temp files.
	 * @return the application temp directory
	 */
	public File getDir() {
		return getPath().toFile();
	}
	/**
	 * Return a subdirectory of the application temp.
	 * @param subDir the subdirectory name
	 * @return a subdirectory
	 */
	public File getDir(String subDir) {
		return createDirectory(getPath().resolve(subDir)).toFile();
	}
	private Path getPath() {
		if (this.path == null) {
			this.pathLock.lock();
			try {
				if (this.path == null) {
					String hash = HexFormat.of().withUpperCase().formatHex(generateHash(this.sourceClass));
					this.path = createDirectory(getTempDirectory().resolve(hash));
				}
			}
			finally {
				this.pathLock.unlock();
			}
		}
		return this.path;
	}
	private Path createDirectory(Path path) {
		try {
			if (!Files.exists(path)) {
				Files.createDirectory(path, getFileAttributes(path.getFileSystem(), DIRECTORY_PERMISSIONS));
			}
			return path;
		}
		catch (IOException ex) {
			throw new IllegalStateException('Unable to create application temp directory ' + path, ex);
		}
	}
	private FileAttribute<?>[] getFileAttributes(FileSystem fileSystem, EnumSet<PosixFilePermission> ownerReadWrite) {
		if (!fileSystem.supportedFileAttributeViews().contains('posix')) {
			return NO_FILE_ATTRIBUTES;
		}
		return new FileAttribute<?>[] { PosixFilePermissions.asFileAttribute(ownerReadWrite) };
	}
	private Path getTempDirectory() {
		String property = System.getProperty('java.io.tmpdir');
		Assert.state(StringUtils.hasLength(property), 'No "java.io.tmpdir" property set');
		Path tempDirectory = Paths.get(property);
		Assert.state(Files.exists(tempDirectory), () -> 'Temp directory "' + tempDirectory + '" does not exist');
		Assert.state(Files.isDirectory(tempDirectory),
				() -> 'Temp location "' + tempDirectory + '" is not a directory');
		return tempDirectory;
	}
	private byte[] generateHash(Class<?> sourceClass) {
		ApplicationHome home = new ApplicationHome(sourceClass);
		MessageDigest digest;
		try {
			digest = MessageDigest.getInstance('SHA-1');
			update(digest, home.getSource());
			update(digest, home.getDir());
			update(digest, System.getProperty('user.dir'));
			update(digest, System.getProperty('java.home'));
			update(digest, System.getProperty('java.class.path'));
			update(digest, System.getProperty('sun.java.command'));
			update(digest, System.getProperty('sun.boot.class.path'));
			return digest.digest();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	private void update(MessageDigest digest, Object source) {
		if (source != null) {
			digest.update(getUpdateSourceBytes(source));
		}
	}
	private byte[] getUpdateSourceBytes(Object source) {
		if (source instanceof File file) {
			return getUpdateSourceBytes(file.getAbsolutePath());
		}
		return source.toString().getBytes();
	}
}
/*
package org.springframework.boot.system;
/**
public enum JavaVersion {
	/**
	 * Java 17.
	 * @since 2.5.3
	 */
	SEVENTEEN('17', Console.class, 'charset'),
	/**
	 * Java 18.
	 * @since 2.5.11
	 */
	EIGHTEEN('18', Duration.class, 'isPositive'),
	/**
	 * Java 19.
	 * @since 2.6.12
	 */
	NINETEEN('19', Future.class, 'state'),
	/**
	 * Java 20.
	 * @since 2.7.13
	 */
	TWENTY('20', Class.class, 'accessFlags'),
	/**
	 * Java 21.
	 * @since 2.7.16
	 */
	TWENTY_ONE('21', SortedSet.class, 'getFirst'),
	/**
	 * Java 22.
	 * @since 3.2.4
	 */
	TWENTY_TWO('22', Console.class, 'isTerminal'),
	/**
	 * Java 23.
	 * @since 3.2.9
	 */
	TWENTY_THREE('23', NumberFormat.class, 'isStrict');
	private final String name;
	private final boolean available;
	JavaVersion(String name, Class<?> versionSpecificClass, String versionSpecificMethod) {
		this.name = name;
		this.available = ClassUtils.hasMethod(versionSpecificClass, versionSpecificMethod);
	}
	@Override
	public String toString() {
		return this.name;
	}
	/**
	 * Returns the {@link JavaVersion} of the current runtime.
	 * @return the {@link JavaVersion}
	 */
	public static JavaVersion getJavaVersion() {
		List<JavaVersion> candidates = Arrays.asList(JavaVersion.values());
		Collections.reverse(candidates);
		for (JavaVersion candidate : candidates) {
			if (candidate.available) {
				return candidate;
			}
		}
		return SEVENTEEN;
	}
	/**
	 * Return if this version is equal to or newer than a given version.
	 * @param version the version to compare
	 * @return {@code true} if this version is equal to or newer than {@code version}
	 */
	public boolean isEqualOrNewerThan(JavaVersion version) {
		return compareTo(version) >= 0;
	}
	/**
	 * Return if this version is older than a given version.
	 * @param version the version to compare
	 * @return {@code true} if this version is older than {@code version}
	 */
	public boolean isOlderThan(JavaVersion version) {
		return compareTo(version) < 0;
	}
}
/*
/**
package org.springframework.boot.system;
/*
package org.springframework.boot.admin;
/**
public interface SpringApplicationAdminMXBean {
	/**
	 * Specify if the application has fully started and is now ready.
	 * @return {@code true} if the application is ready
	 * @see org.springframework.boot.context.event.ApplicationReadyEvent
	 */
	boolean isReady();
	/**
	 * Specify if the application runs in an embedded web container. Return {@code false}
	 * on a web application that hasn"t fully started yet, so it is preferable to wait for
	 * the application to be {@link #isReady() ready}.
	 * @return {@code true} if the application runs in an embedded web container
	 * @see #isReady()
	 */
	boolean isEmbeddedWebApplication();
	/**
	 * Return the value of the specified key from the application
	 * {@link org.springframework.core.env.Environment Environment}.
	 * @param key the property key
	 * @return the property value or {@code null} if it does not exist
	 */
	String getProperty(String key);
	/**
	 * Shutdown the application.
	 * @see org.springframework.context.ConfigurableApplicationContext#close()
	 */
	void shutdown();
}
/*
package org.springframework.boot.admin;
/**
public class SpringApplicationAdminMXBeanRegistrar implements ApplicationContextAware, GenericApplicationListener,
		EnvironmentAware, InitializingBean, DisposableBean {
	private static final Log logger = LogFactory.getLog(SpringApplicationAdmin.class);
	private ConfigurableApplicationContext applicationContext;
	private Environment environment = new StandardEnvironment();
	private final ObjectName objectName;
	private boolean ready = false;
	private boolean embeddedWebApplication = false;
	public SpringApplicationAdminMXBeanRegistrar(String name) throws MalformedObjectNameException {
		this.objectName = new ObjectName(name);
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		Assert.state(applicationContext instanceof ConfigurableApplicationContext,
				'ApplicationContext does not implement ConfigurableApplicationContext');
		this.applicationContext = (ConfigurableApplicationContext) applicationContext;
	}
	@Override
	public void setEnvironment(Environment environment) {
		this.environment = environment;
	}
	@Override
	public boolean supportsEventType(ResolvableType eventType) {
		Class<?> type = eventType.getRawClass();
		if (type == null) {
			return false;
		}
		return ApplicationReadyEvent.class.isAssignableFrom(type)
				|| WebServerInitializedEvent.class.isAssignableFrom(type);
	}
	@Override
	public boolean supportsSourceType(Class<?> sourceType) {
		return true;
	}
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof ApplicationReadyEvent readyEvent) {
			onApplicationReadyEvent(readyEvent);
		}
		if (event instanceof WebServerInitializedEvent initializedEvent) {
			onWebServerInitializedEvent(initializedEvent);
		}
	}
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE;
	}
	void onApplicationReadyEvent(ApplicationReadyEvent event) {
		if (this.applicationContext.equals(event.getApplicationContext())) {
			this.ready = true;
		}
	}
	void onWebServerInitializedEvent(WebServerInitializedEvent event) {
		if (this.applicationContext.equals(event.getApplicationContext())) {
			this.embeddedWebApplication = true;
		}
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		MBeanServer server = ManagementFactory.getPlatformMBeanServer();
		server.registerMBean(new SpringApplicationAdmin(), this.objectName);
		if (logger.isDebugEnabled()) {
			logger.debug('Application Admin MBean registered with name "' + this.objectName + '"');
		}
	}
	@Override
	public void destroy() throws Exception {
		ManagementFactory.getPlatformMBeanServer().unregisterMBean(this.objectName);
	}
	private final class SpringApplicationAdmin implements SpringApplicationAdminMXBean {
		@Override
		public boolean isReady() {
			return SpringApplicationAdminMXBeanRegistrar.this.ready;
		}
		@Override
		public boolean isEmbeddedWebApplication() {
			return SpringApplicationAdminMXBeanRegistrar.this.embeddedWebApplication;
		}
		@Override
		public String getProperty(String key) {
			return SpringApplicationAdminMXBeanRegistrar.this.environment.getProperty(key);
		}
		@Override
		public void shutdown() {
			logger.info('Application shutdown requested.');
			SpringApplicationAdminMXBeanRegistrar.this.applicationContext.close();
		}
	}
}
/*
/**
package org.springframework.boot.admin;
/*
package org.springframework.boot.util;
/**
public final class LambdaSafe {
	private static final Method CLASS_GET_MODULE;
	private static final Method MODULE_GET_NAME;
	static {
		CLASS_GET_MODULE = ReflectionUtils.findMethod(Class.class, 'getModule');
		MODULE_GET_NAME = (CLASS_GET_MODULE != null)
				? ReflectionUtils.findMethod(CLASS_GET_MODULE.getReturnType(), 'getName') : null;
	}
	private LambdaSafe() {
	}
	/**
	 * Start a call to a single callback instance, dealing with common generic type
	 * concerns and exceptions.
	 * @param callbackType the callback type (a {@link FunctionalInterface functional
	 * interface})
	 * @param callbackInstance the callback instance (may be a lambda)
	 * @param argument the primary argument passed to the callback
	 * @param additionalArguments any additional arguments passed to the callback
	 * @param <C> the callback type
	 * @param <A> the primary argument type
	 * @return a {@link Callback} instance that can be invoked.
	 */
	public static <C, A> Callback<C, A> callback(Class<C> callbackType, C callbackInstance, A argument,
			Object... additionalArguments) {
		Assert.notNull(callbackType, 'CallbackType must not be null');
		Assert.notNull(callbackInstance, 'CallbackInstance must not be null');
		return new Callback<>(callbackType, callbackInstance, argument, additionalArguments);
	}
	/**
	 * Start a call to callback instances, dealing with common generic type concerns and
	 * exceptions.
	 * @param callbackType the callback type (a {@link FunctionalInterface functional
	 * interface})
	 * @param callbackInstances the callback instances (elements may be lambdas)
	 * @param argument the primary argument passed to the callbacks
	 * @param additionalArguments any additional arguments passed to the callbacks
	 * @param <C> the callback type
	 * @param <A> the primary argument type
	 * @return a {@link Callbacks} instance that can be invoked.
	 */
	public static <C, A> Callbacks<C, A> callbacks(Class<C> callbackType, Collection<? extends C> callbackInstances,
			A argument, Object... additionalArguments) {
		Assert.notNull(callbackType, 'CallbackType must not be null');
		Assert.notNull(callbackInstances, 'CallbackInstances must not be null');
		return new Callbacks<>(callbackType, callbackInstances, argument, additionalArguments);
	}
	/**
	 * Abstract base class for lambda safe callbacks.
	 *
	 * @param <C> the callback type
	 * @param <A> the primary argument type
	 * @param <SELF> the self class reference
	 */
	protected abstract static class LambdaSafeCallback<C, A, SELF extends LambdaSafeCallback<C, A, SELF>> {
		private final Class<C> callbackType;
		private final A argument;
		private final Object[] additionalArguments;
		private Log logger;
		private Filter<C, A> filter = new GenericTypeFilter<>();
		LambdaSafeCallback(Class<C> callbackType, A argument, Object[] additionalArguments) {
			this.callbackType = callbackType;
			this.argument = argument;
			this.additionalArguments = additionalArguments;
			this.logger = LogFactory.getLog(callbackType);
		}
		/**
		 * Use the specified logger source to report any lambda failures.
		 * @param loggerSource the logger source to use
		 * @return this instance
		 */
		public SELF withLogger(Class<?> loggerSource) {
			return withLogger(LogFactory.getLog(loggerSource));
		}
		/**
		 * Use the specified logger to report any lambda failures.
		 * @param logger the logger to use
		 * @return this instance
		 */
		public SELF withLogger(Log logger) {
			Assert.notNull(logger, 'Logger must not be null');
			this.logger = logger;
			return self();
		}
		/**
		 * Use a specific filter to determine when a callback should apply. If no explicit
		 * filter is set filter will be attempted using the generic type on the callback
		 * type.
		 * @param filter the filter to use
		 * @return this instance
		 */
		SELF withFilter(Filter<C, A> filter) {
			Assert.notNull(filter, 'Filter must not be null');
			this.filter = filter;
			return self();
		}
		protected final <R> InvocationResult<R> invoke(C callbackInstance, Supplier<R> supplier) {
			if (this.filter.match(this.callbackType, callbackInstance, this.argument, this.additionalArguments)) {
				try {
					return InvocationResult.of(supplier.get());
				}
				catch (ClassCastException ex) {
					if (!isLambdaGenericProblem(ex)) {
						throw ex;
					}
					logNonMatchingType(callbackInstance, ex);
				}
			}
			return InvocationResult.noResult();
		}
		private boolean isLambdaGenericProblem(ClassCastException ex) {
			return (ex.getMessage() == null || startsWithArgumentClassName(ex.getMessage()));
		}
		private boolean startsWithArgumentClassName(String message) {
			Predicate<Object> startsWith = (argument) -> startsWithArgumentClassName(message, argument);
			return startsWith.test(this.argument) || Stream.of(this.additionalArguments).anyMatch(startsWith);
		}
		private boolean startsWithArgumentClassName(String message, Object argument) {
			if (argument == null) {
				return false;
			}
			Class<?> argumentType = argument.getClass();
			// On Java 8, the message starts with the class name: 'java.lang.String cannot
			// be cast...'
			if (message.startsWith(argumentType.getName())) {
				return true;
			}
			// On Java 11, the message starts with 'class ...' a.k.a. Class.toString()
			if (message.startsWith(argumentType.toString())) {
				return true;
			}
			// On Java 9, the message used to contain the module name:
			// 'java.base/java.lang.String cannot be cast...'
			int moduleSeparatorIndex = message.indexOf("/");
			if (moduleSeparatorIndex != -1 && message.startsWith(argumentType.getName(), moduleSeparatorIndex + 1)) {
				return true;
			}
			if (CLASS_GET_MODULE != null) {
				Object module = ReflectionUtils.invokeMethod(CLASS_GET_MODULE, argumentType);
				Object moduleName = ReflectionUtils.invokeMethod(MODULE_GET_NAME, module);
				return message.startsWith(moduleName + '/' + argumentType.getName());
			}
			return false;
		}
		private void logNonMatchingType(C callback, ClassCastException ex) {
			if (this.logger.isDebugEnabled()) {
				Class<?> expectedType = ResolvableType.forClass(this.callbackType).resolveGeneric();
				String expectedTypeName = (expectedType != null) ? ClassUtils.getShortName(expectedType) + ' type'
						: 'type';
				String message = 'Non-matching ' + expectedTypeName + ' for callback '
						+ ClassUtils.getShortName(this.callbackType) + ': ' + callback;
				this.logger.debug(message, ex);
			}
		}
		@SuppressWarnings('unchecked')
		private SELF self() {
			return (SELF) this;
		}
	}
	/**
	 * Represents a single callback that can be invoked in a lambda safe way.
	 *
	 * @param <C> the callback type
	 * @param <A> the primary argument type
	 */
	public static final class Callback<C, A> extends LambdaSafeCallback<C, A, Callback<C, A>> {
		private final C callbackInstance;
		private Callback(Class<C> callbackType, C callbackInstance, A argument, Object[] additionalArguments) {
			super(callbackType, argument, additionalArguments);
			this.callbackInstance = callbackInstance;
		}
		/**
		 * Invoke the callback instance where the callback method returns void.
		 * @param invoker the invoker used to invoke the callback
		 */
		public void invoke(Consumer<C> invoker) {
			invoke(this.callbackInstance, () -> {
				invoker.accept(this.callbackInstance);
				return null;
			});
		}
		/**
		 * Invoke the callback instance where the callback method returns a result.
		 * @param invoker the invoker used to invoke the callback
		 * @param <R> the result type
		 * @return the result of the invocation (may be {@link InvocationResult#noResult}
		 * if the callback was not invoked)
		 */
		public <R> InvocationResult<R> invokeAnd(Function<C, R> invoker) {
			return invoke(this.callbackInstance, () -> invoker.apply(this.callbackInstance));
		}
	}
	/**
	 * Represents a collection of callbacks that can be invoked in a lambda safe way.
	 *
	 * @param <C> the callback type
	 * @param <A> the primary argument type
	 */
	public static final class Callbacks<C, A> extends LambdaSafeCallback<C, A, Callbacks<C, A>> {
		private final Collection<? extends C> callbackInstances;
		private Callbacks(Class<C> callbackType, Collection<? extends C> callbackInstances, A argument,
				Object[] additionalArguments) {
			super(callbackType, argument, additionalArguments);
			this.callbackInstances = callbackInstances;
		}
		/**
		 * Invoke the callback instances where the callback method returns void.
		 * @param invoker the invoker used to invoke the callback
		 */
		public void invoke(Consumer<C> invoker) {
			this.callbackInstances.forEach((callbackInstance) -> invoke(callbackInstance, () -> {
				invoker.accept(callbackInstance);
				return null;
			}));
		}
		/**
		 * Invoke the callback instances where the callback method returns a result.
		 * @param invoker the invoker used to invoke the callback
		 * @param <R> the result type
		 * @return the results of the invocation (may be an empty stream if no callbacks
		 * could be called)
		 */
		public <R> Stream<R> invokeAnd(Function<C, R> invoker) {
			Function<C, InvocationResult<R>> mapper = (callbackInstance) -> invoke(callbackInstance,
					() -> invoker.apply(callbackInstance));
			return this.callbackInstances.stream()
				.map(mapper)
				.filter(InvocationResult::hasResult)
				.map(InvocationResult::get);
		}
	}
	/**
	 * A filter that can be used to restrict when a callback is used.
	 *
	 * @param <C> the callback type
	 * @param <A> the primary argument type
	 */
	@FunctionalInterface
	interface Filter<C, A> {
		/**
		 * Determine if the given callback matches and should be invoked.
		 * @param callbackType the callback type (the functional interface)
		 * @param callbackInstance the callback instance (the implementation)
		 * @param argument the primary argument
		 * @param additionalArguments any additional arguments
		 * @return if the callback matches and should be invoked
		 */
		boolean match(Class<C> callbackType, C callbackInstance, A argument, Object[] additionalArguments);
		/**
		 * Return a {@link Filter} that allows all callbacks to be invoked.
		 * @param <C> the callback type
		 * @param <A> the primary argument type
		 * @return an 'allow all' filter
		 */
		static <C, A> Filter<C, A> allowAll() {
			return (callbackType, callbackInstance, argument, additionalArguments) -> true;
		}
	}
	/**
	 * {@link Filter} that matches when the callback has a single generic and primary
	 * argument is an instance of it.
	 */
	private static final class GenericTypeFilter<C, A> implements Filter<C, A> {
		@Override
		public boolean match(Class<C> callbackType, C callbackInstance, A argument, Object[] additionalArguments) {
			ResolvableType type = ResolvableType.forClass(callbackType, callbackInstance.getClass());
			if (type.getGenerics().length == 1 && type.resolveGeneric() != null) {
				return type.resolveGeneric().isInstance(argument);
			}
			return true;
		}
	}
	/**
	 * The result of a callback which may be a value, {@code null} or absent entirely if
	 * the callback wasn"t suitable. Similar in design to {@link Optional} but allows for
	 * {@code null} as a valid value.
	 *
	 * @param <R> the result type
	 */
	public static final class InvocationResult<R> {
		private static final InvocationResult<?> NONE = new InvocationResult<>(null);
		private final R value;
		private InvocationResult(R value) {
			this.value = value;
		}
		/**
		 * Return true if a result in present.
		 * @return if a result is present
		 */
		public boolean hasResult() {
			return this != NONE;
		}
		/**
		 * Return the result of the invocation or {@code null} if the callback wasn"t
		 * suitable.
		 * @return the result of the invocation or {@code null}
		 */
		public R get() {
			return this.value;
		}
		/**
		 * Return the result of the invocation or the given fallback if the callback
		 * wasn"t suitable.
		 * @param fallback the fallback to use when there is no result
		 * @return the result of the invocation or the fallback
		 */
		public R get(R fallback) {
			return (this != NONE) ? this.value : fallback;
		}
		/**
		 * Create a new {@link InvocationResult} instance with the specified value.
		 * @param value the value (may be {@code null})
		 * @param <R> the result type
		 * @return an {@link InvocationResult}
		 */
		public static <R> InvocationResult<R> of(R value) {
			return new InvocationResult<>(value);
		}
		/**
		 * Return an {@link InvocationResult} instance representing no result.
		 * @param <R> the result type
		 * @return an {@link InvocationResult}
		 */
		@SuppressWarnings('unchecked')
		public static <R> InvocationResult<R> noResult() {
			return (InvocationResult<R>) NONE;
		}
	}
}
/*
package org.springframework.boot.util;
/**
public class Instantiator<T> {
	private static final Comparator<Constructor<?>> CONSTRUCTOR_COMPARATOR = Comparator
		.<Constructor<?>>comparingInt(Constructor::getParameterCount)
		.reversed();
	private static final FailureHandler throwingFailureHandler = (type, implementationName, failure) -> {
		throw new IllegalArgumentException('Unable to instantiate ' + implementationName + ' [' + type.getName() + ']',
				failure);
	};
	private final Class<?> type;
	private final Map<Class<?>, Function<Class<?>, Object>> availableParameters;
	private final FailureHandler failureHandler;
	/**
	 * Create a new {@link Instantiator} instance for the given type.
	 * @param type the type to instantiate
	 * @param availableParameters consumer used to register available parameters
	 */
	public Instantiator(Class<?> type, Consumer<AvailableParameters> availableParameters) {
		this(type, availableParameters, throwingFailureHandler);
	}
	/**
	 * Create a new {@link Instantiator} instance for the given type.
	 * @param type the type to instantiate
	 * @param availableParameters consumer used to register available parameters
	 * @param failureHandler a {@link FailureHandler} that will be called in case of
	 * failure when instantiating objects
	 * @since 2.7.0
	 */
	public Instantiator(Class<?> type, Consumer<AvailableParameters> availableParameters,
			FailureHandler failureHandler) {
		this.type = type;
		this.availableParameters = getAvailableParameters(availableParameters);
		this.failureHandler = failureHandler;
	}
	private Map<Class<?>, Function<Class<?>, Object>> getAvailableParameters(
			Consumer<AvailableParameters> availableParameters) {
		Map<Class<?>, Function<Class<?>, Object>> result = new LinkedHashMap<>();
		availableParameters.accept(new AvailableParameters() {
			@Override
			public void add(Class<?> type, Object instance) {
				result.put(type, (factoryType) -> instance);
			}
			@Override
			public void add(Class<?> type, Function<Class<?>, Object> factory) {
				result.put(type, factory);
			}
		});
		return Collections.unmodifiableMap(result);
	}
	/**
	 * Instantiate the given set of class name, injecting constructor arguments as
	 * necessary.
	 * @param names the class names to instantiate
	 * @return a list of instantiated instances
	 */
	public List<T> instantiate(Collection<String> names) {
		return instantiate(null, names);
	}
	/**
	 * Instantiate the given set of class name, injecting constructor arguments as
	 * necessary.
	 * @param classLoader the source classloader
	 * @param names the class names to instantiate
	 * @return a list of instantiated instances
	 * @since 2.4.8
	 */
	public List<T> instantiate(ClassLoader classLoader, Collection<String> names) {
		Assert.notNull(names, 'Names must not be null');
		return instantiate(names.stream().map((name) -> TypeSupplier.forName(classLoader, name)));
	}
	/**
	 * Instantiate the given set of class name, injecting constructor arguments as
	 * necessary.
	 * @param name the class name to instantiate
	 * @return an instantiated instance
	 * @since 3.4.0
	 */
	public T instantiate(String name) {
		return instantiate(null, name);
	}
	/**
	 * Instantiate the given set of class name, injecting constructor arguments as
	 * necessary.
	 * @param classLoader the source classloader
	 * @param name the class name to instantiate
	 * @return an instantiated instance
	 * @since 3.4.0
	 */
	public T instantiate(ClassLoader classLoader, String name) {
		return instantiate(TypeSupplier.forName(classLoader, name));
	}
	/**
	 * Instantiate the given set of classes, injecting constructor arguments as necessary.
	 * @param types the types to instantiate
	 * @return a list of instantiated instances
	 * @since 2.4.8
	 */
	public List<T> instantiateTypes(Collection<Class<?>> types) {
		Assert.notNull(types, 'Types must not be null');
		return instantiate(types.stream().map(TypeSupplier::forType));
	}
	/**
	 * Get an injectable argument instance for the given type. This method can be used
	 * when manually instantiating an object without reflection.
	 * @param <A> the argument type
	 * @param type the argument type
	 * @return the argument to inject or {@code null}
	 * @since 3.4.0
	 */
	@SuppressWarnings('unchecked')
	public <A> A getArg(Class<A> type) {
		Assert.notNull(type, '"type" must not be null');
		Function<Class<?>, Object> parameter = getAvailableParameter(type);
		Assert.isTrue(parameter != null, 'Unknown argument type ' + type.getName());
		return (A) parameter.apply(this.type);
	}
	private List<T> instantiate(Stream<TypeSupplier> typeSuppliers) {
		return typeSuppliers.map(this::instantiate).sorted(AnnotationAwareOrderComparator.INSTANCE).toList();
	}
	private T instantiate(TypeSupplier typeSupplier) {
		try {
			Class<?> type = typeSupplier.get();
			Assert.isAssignable(this.type, type);
			return instantiate(type);
		}
		catch (Throwable ex) {
			this.failureHandler.handleFailure(this.type, typeSupplier.getName(), ex);
			return null;
		}
	}
	@SuppressWarnings('unchecked')
	private T instantiate(Class<?> type) throws Exception {
		Constructor<?>[] constructors = type.getDeclaredConstructors();
		Arrays.sort(constructors, CONSTRUCTOR_COMPARATOR);
		for (Constructor<?> constructor : constructors) {
			Object[] args = getArgs(constructor.getParameterTypes());
			if (args != null) {
				ReflectionUtils.makeAccessible(constructor);
				return (T) constructor.newInstance(args);
			}
		}
		throw new IllegalAccessException('Class [' + type.getName() + '] has no suitable constructor');
	}
	private Object[] getArgs(Class<?>[] parameterTypes) {
		Object[] args = new Object[parameterTypes.length];
		for (int i = 0; i < parameterTypes.length; i++) {
			Function<Class<?>, Object> parameter = getAvailableParameter(parameterTypes[i]);
			if (parameter == null) {
				return null;
			}
			args[i] = parameter.apply(this.type);
		}
		return args;
	}
	private Function<Class<?>, Object> getAvailableParameter(Class<?> parameterType) {
		for (Map.Entry<Class<?>, Function<Class<?>, Object>> entry : this.availableParameters.entrySet()) {
			if (entry.getKey().isAssignableFrom(parameterType)) {
				return entry.getValue();
			}
		}
		return null;
	}
	/**
	 * Callback used to register available parameters.
	 */
	public interface AvailableParameters {
		/**
		 * Add a parameter with an instance value.
		 * @param type the parameter type
		 * @param instance the instance that should be injected
		 */
		void add(Class<?> type, Object instance);
		/**
		 * Add a parameter with an instance factory.
		 * @param type the parameter type
		 * @param factory the factory used to create the instance that should be injected
		 */
		void add(Class<?> type, Function<Class<?>, Object> factory);
	}
	/**
	 * {@link Supplier} that provides a class type.
	 */
	private interface TypeSupplier {
		String getName();
		Class<?> get() throws ClassNotFoundException;
		static TypeSupplier forName(ClassLoader classLoader, String name) {
			return new TypeSupplier() {
				@Override
				public String getName() {
					return name;
				}
				@Override
				public Class<?> get() throws ClassNotFoundException {
					return ClassUtils.forName(name, classLoader);
				}
			};
		}
		static TypeSupplier forType(Class<?> type) {
			return new TypeSupplier() {
				@Override
				public String getName() {
					return type.getName();
				}
				@Override
				public Class<?> get() {
					return type;
				}
			};
		}
	}
	/**
	 * Strategy for handling a failure that occurs when instantiating a type.
	 *
	 * @since 2.7.0
	 */
	public interface FailureHandler {
		/**
		 * Handle the {@code failure} that occurred when instantiating the {@code type}
		 * that was expected to be of the given {@code typeSupplier}.
		 * @param type the type
		 * @param implementationName the name of the implementation type
		 * @param failure the failure that occurred
		 */
		void handleFailure(Class<?> type, String implementationName, Throwable failure);
	}
}
/*
/**
package org.springframework.boot.util;
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface SpringBootExceptionReporter {
	/**
	 * Report a startup failure to the user.
	 * @param failure the source failure
	 * @return {@code true} if the failure was reported or {@code false} if default
	 * reporting should occur.
	 */
	boolean reportException(Throwable failure);
}
/*
package org.springframework.boot;
/**
final class EnvironmentConverter {
	private static final String CONFIGURABLE_WEB_ENVIRONMENT_CLASS = 'org.springframework.web.context.ConfigurableWebEnvironment';
	private static final Set<String> SERVLET_ENVIRONMENT_SOURCE_NAMES;
	static {
		Set<String> names = new HashSet<>();
		names.add(StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME);
		names.add(StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME);
		names.add(StandardServletEnvironment.JNDI_PROPERTY_SOURCE_NAME);
		SERVLET_ENVIRONMENT_SOURCE_NAMES = Collections.unmodifiableSet(names);
	}
	private final ClassLoader classLoader;
	/**
	 * Creates a new {@link EnvironmentConverter} that will use the given
	 * {@code classLoader} during conversion.
	 * @param classLoader the class loader to use
	 */
	EnvironmentConverter(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	/**
	 * Converts the given {@code environment} to the given {@link StandardEnvironment}
	 * type. If the environment is already of the same type, no conversion is performed
	 * and it is returned unchanged.
	 * @param environment the Environment to convert
	 * @param type the type to convert the Environment to
	 * @return the converted Environment
	 */
	ConfigurableEnvironment convertEnvironmentIfNecessary(ConfigurableEnvironment environment,
			Class<? extends ConfigurableEnvironment> type) {
		if (type.equals(environment.getClass())) {
			return environment;
		}
		return convertEnvironment(environment, type);
	}
	private ConfigurableEnvironment convertEnvironment(ConfigurableEnvironment environment,
			Class<? extends ConfigurableEnvironment> type) {
		ConfigurableEnvironment result = createEnvironment(type);
		result.setActiveProfiles(environment.getActiveProfiles());
		result.setConversionService(environment.getConversionService());
		copyPropertySources(environment, result);
		return result;
	}
	private ConfigurableEnvironment createEnvironment(Class<? extends ConfigurableEnvironment> type) {
		try {
			Constructor<? extends ConfigurableEnvironment> constructor = type.getDeclaredConstructor();
			ReflectionUtils.makeAccessible(constructor);
			return constructor.newInstance();
		}
		catch (Exception ex) {
			return new ApplicationEnvironment();
		}
	}
	private void copyPropertySources(ConfigurableEnvironment source, ConfigurableEnvironment target) {
		removePropertySources(target.getPropertySources(), isServletEnvironment(target.getClass(), this.classLoader));
		for (PropertySource<?> propertySource : source.getPropertySources()) {
			if (!SERVLET_ENVIRONMENT_SOURCE_NAMES.contains(propertySource.getName())) {
				target.getPropertySources().addLast(propertySource);
			}
		}
	}
	private boolean isServletEnvironment(Class<?> conversionType, ClassLoader classLoader) {
		try {
			Class<?> webEnvironmentClass = ClassUtils.forName(CONFIGURABLE_WEB_ENVIRONMENT_CLASS, classLoader);
			return webEnvironmentClass.isAssignableFrom(conversionType);
		}
		catch (Throwable ex) {
			return false;
		}
	}
	private void removePropertySources(MutablePropertySources propertySources, boolean isServletEnvironment) {
		Set<String> names = new HashSet<>();
		for (PropertySource<?> propertySource : propertySources) {
			names.add(propertySource.getName());
		}
		for (String name : names) {
			if (!isServletEnvironment || !SERVLET_ENVIRONMENT_SOURCE_NAMES.contains(name)) {
				propertySources.remove(name);
			}
		}
	}
}
/*
package org.springframework.boot;
/**
public interface BootstrapRegistry {
	/**
	 * Register a specific type with the registry. If the specified type has already been
	 * registered and has not been obtained as a {@link Scope#SINGLETON singleton}, it
	 * will be replaced.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @param instanceSupplier the instance supplier
	 */
	<T> void register(Class<T> type, InstanceSupplier<T> instanceSupplier);
	/**
	 * Register a specific type with the registry if one is not already present.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @param instanceSupplier the instance supplier
	 */
	<T> void registerIfAbsent(Class<T> type, InstanceSupplier<T> instanceSupplier);
	/**
	 * Return if a registration exists for the given type.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @return {@code true} if the type has already been registered
	 */
	<T> boolean isRegistered(Class<T> type);
	/**
	 * Return any existing {@link InstanceSupplier} for the given type.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @return the registered {@link InstanceSupplier} or {@code null}
	 */
	<T> InstanceSupplier<T> getRegisteredInstanceSupplier(Class<T> type);
	/**
	 * Add an {@link ApplicationListener} that will be called with a
	 * {@link BootstrapContextClosedEvent} when the {@link BootstrapContext} is closed and
	 * the {@link ApplicationContext} has been prepared.
	 * @param listener the listener to add
	 */
	void addCloseListener(ApplicationListener<BootstrapContextClosedEvent> listener);
	/**
	 * Supplier used to provide the actual instance when needed.
	 *
	 * @param <T> the instance type
	 * @see Scope
	 */
	@FunctionalInterface
	interface InstanceSupplier<T> {
		/**
		 * Factory method used to create the instance when needed.
		 * @param context the {@link BootstrapContext} which may be used to obtain other
		 * bootstrap instances.
		 * @return the instance
		 */
		T get(BootstrapContext context);
		/**
		 * Return the scope of the supplied instance.
		 * @return the scope
		 * @since 2.4.2
		 */
		default Scope getScope() {
			return Scope.SINGLETON;
		}
		/**
		 * Return a new {@link InstanceSupplier} with an updated {@link Scope}.
		 * @param scope the new scope
		 * @return a new {@link InstanceSupplier} instance with the new scope
		 * @since 2.4.2
		 */
		default InstanceSupplier<T> withScope(Scope scope) {
			Assert.notNull(scope, 'Scope must not be null');
			InstanceSupplier<T> parent = this;
			return new InstanceSupplier<>() {
				@Override
				public T get(BootstrapContext context) {
					return parent.get(context);
				}
				@Override
				public Scope getScope() {
					return scope;
				}
			};
		}
		/**
		 * Factory method that can be used to create an {@link InstanceSupplier} for a
		 * given instance.
		 * @param <T> the instance type
		 * @param instance the instance
		 * @return a new {@link InstanceSupplier}
		 */
		static <T> InstanceSupplier<T> of(T instance) {
			return (registry) -> instance;
		}
		/**
		 * Factory method that can be used to create an {@link InstanceSupplier} from a
		 * {@link Supplier}.
		 * @param <T> the instance type
		 * @param supplier the supplier that will provide the instance
		 * @return a new {@link InstanceSupplier}
		 */
		static <T> InstanceSupplier<T> from(Supplier<T> supplier) {
			return (registry) -> (supplier != null) ? supplier.get() : null;
		}
	}
	/**
	 * The scope of an instance.
	 *
	 * @since 2.4.2
	 */
	enum Scope {
		/**
		 * A singleton instance. The {@link InstanceSupplier} will be called only once and
		 * the same instance will be returned each time.
		 */
		SINGLETON,
		/**
		 * A prototype instance. The {@link InstanceSupplier} will be called whenever an
		 * instance is needed.
		 */
		PROTOTYPE
	}
}
/*
/**
package org.springframework.boot.jooq;
/*
package org.springframework.boot.jooq;
/**
class JooqDependsOnDatabaseInitializationDetector extends AbstractBeansOfTypeDependsOnDatabaseInitializationDetector {
	@Override
	protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
		return Collections.singleton(DSLContext.class);
	}
}
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface SpringApplicationHook {
	/**
	 * Return the {@link SpringApplicationRunListener} that should be hooked into the
	 * given {@link SpringApplication}.
	 * @param springApplication the source {@link SpringApplication} instance
	 * @return the {@link SpringApplicationRunListener} to attach
	 */
	SpringApplicationRunListener getRunListener(SpringApplication springApplication);
}
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface ApplicationRunner extends Runner {
	/**
	 * Callback used to run the bean.
	 * @param args incoming application arguments
	 * @throws Exception on error
	 */
	void run(ApplicationArguments args) throws Exception;
}
/*
package org.springframework.boot;
/**
public class ExitCodeEvent extends ApplicationEvent {
	private final int exitCode;
	/**
	 * Create a new {@link ExitCodeEvent} instance.
	 * @param source the source of the event
	 * @param exitCode the exit code
	 */
	public ExitCodeEvent(Object source, int exitCode) {
		super(source);
		this.exitCode = exitCode;
	}
	/**
	 * Return the exit code that will be used to exit the JVM.
	 * @return the exit code
	 */
	public int getExitCode() {
		return this.exitCode;
	}
}
/*
package org.springframework.boot;
/**
public interface BootstrapContext {
	/**
	 * Return an instance from the context if the type has been registered. The instance
	 * will be created if it hasn"t been accessed previously.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @return the instance managed by the context
	 * @throws IllegalStateException if the type has not been registered
	 */
	<T> T get(Class<T> type) throws IllegalStateException;
	/**
	 * Return an instance from the context if the type has been registered. The instance
	 * will be created if it hasn"t been accessed previously.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @param other the instance to use if the type has not been registered
	 * @return the instance
	 */
	<T> T getOrElse(Class<T> type, T other);
	/**
	 * Return an instance from the context if the type has been registered. The instance
	 * will be created if it hasn"t been accessed previously.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @param other a supplier for the instance to use if the type has not been registered
	 * @return the instance
	 */
	<T> T getOrElseSupply(Class<T> type, Supplier<T> other);
	/**
	 * Return an instance from the context if the type has been registered. The instance
	 * will be created if it hasn"t been accessed previously.
	 * @param <T> the instance type
	 * @param <X> the exception to throw if the type is not registered
	 * @param type the instance type
	 * @param exceptionSupplier the supplier which will return the exception to be thrown
	 * @return the instance managed by the context
	 * @throws X if the type has not been registered
	 * @throws IllegalStateException if the type has not been registered
	 */
	<T, X extends Throwable> T getOrElseThrow(Class<T> type, Supplier<? extends X> exceptionSupplier) throws X;
	/**
	 * Return if a registration exists for the given type.
	 * @param <T> the instance type
	 * @param type the instance type
	 * @return {@code true} if the type has already been registered
	 */
	<T> boolean isRegistered(Class<T> type);
}
/*
package org.springframework.boot;
/**
public interface ApplicationArguments {
	/**
	 * Return the raw unprocessed arguments that were passed to the application.
	 * @return the arguments
	 */
	String[] getSourceArgs();
	/**
	 * Return the names of all option arguments. For example, if the arguments were
	 * '--foo=bar --debug' would return the values {@code ['foo', 'debug']}.
	 * @return the option names or an empty set
	 */
	Set<String> getOptionNames();
	/**
	 * Return whether the set of option arguments parsed from the arguments contains an
	 * option with the given name.
	 * @param name the name to check
	 * @return {@code true} if the arguments contain an option with the given name
	 */
	boolean containsOption(String name);
	/**
	 * Return the collection of values associated with the arguments option having the
	 * given name.
	 * <ul>
	 * <li>if the option is present and has no argument (e.g.: '--foo'), return an empty
	 * collection ({@code []})</li>
	 * <li>if the option is present and has a single value (e.g. '--foo=bar'), return a
	 * collection having one element ({@code ['bar']})</li>
	 * <li>if the option is present and has multiple values (e.g. '--foo=bar --foo=baz'),
	 * return a collection having elements for each value ({@code ['bar', 'baz']})</li>
	 * <li>if the option is not present, return {@code null}</li>
	 * </ul>
	 * @param name the name of the option
	 * @return a list of option values for the given name
	 */
	List<String> getOptionValues(String name);
	/**
	 * Return the collection of non-option arguments parsed.
	 * @return the non-option arguments or an empty list
	 */
	List<String> getNonOptionArgs();
}
/*
package org.springframework.boot.json;
/**
@FunctionalInterface
public interface JsonWriter<T> {
	/**
	 * Write the given instance to the provided {@link Appendable}.
	 * @param instance the instance to write (may be {@code null}
	 * @param out the output that should receive the JSON
	 * @throws IOException on IO error
	 */
	void write(T instance, Appendable out) throws IOException;
	/**
	 * Write the given instance to a JSON string.
	 * @param instance the instance to write (may be {@code null})
	 * @return the JSON string
	 */
	default String writeToString(T instance) {
		return write(instance).toJsonString();
	}
	/**
	 * Provide a {@link WritableJson} implementation that may be used to write the given
	 * instance to various outputs.
	 * @param instance the instance to write (may be {@code null})
	 * @return a {@link WritableJson} instance that may be used to write the JSON
	 */
	default WritableJson write(T instance) {
		return WritableJson.of((out) -> write(instance, out));
	}
	/**
	 * Return a new {@link JsonWriter} instance that appends a new line after the JSON has
	 * been written.
	 * @return a new {@link JsonWriter} instance that appends a new line after the JSON
	 */
	default JsonWriter<T> withNewLineAtEnd() {
		return withSuffix('\n');
	}
	/**
	 * Return a new {@link JsonWriter} instance that appends the given suffix after the
	 * JSON has been written.
	 * @param suffix the suffix to write, if any
	 * @return a new {@link JsonWriter} instance that appends a suffixafter the JSON
	 */
	default JsonWriter<T> withSuffix(String suffix) {
		if (!StringUtils.hasLength(suffix)) {
			return this;
		}
		return (instance, out) -> {
			write(instance, out);
			out.append(suffix);
		};
	}
	/**
	 * Factory method to return a {@link JsonWriter} for standard Java types. See
	 * {@link JsonValueWriter class-level javadoc} for details.
	 * @param <T> the type to write
	 * @return a {@link JsonWriter} instance
	 */
	static <T> JsonWriter<T> standard() {
		return of(Members::add);
	}
	/**
	 * Factory method to return a {@link JsonWriter} with specific {@link Members member
	 * mapping}. See {@link JsonValueWriter class-level javadoc} and {@link Members} for
	 * details.
	 * @param <T> the type to write
	 * @param members a consumer, which should configure the members
	 * @return a {@link JsonWriter} instance
	 * @see Members
	 */
	static <T> JsonWriter<T> of(Consumer<Members<T>> members) {
		// Don"t inline "new Members" (must be outside of lambda)
		Members<T> initializedMembers = new Members<>(members, false);
		return (instance, out) -> initializedMembers.write(instance, new JsonValueWriter(out));
	}
	/**
	 * Callback used to configure JSON members. Individual members can be declared using
	 * the various {@code add(...)} methods. Typically, members are declared with a
	 * {@code 'name'} and a {@link Function} that will extract the value from the
	 * instance. Members can also be declared using a static value or a {@link Supplier}.
	 * The {@link #add(String)} and {@link #add()} methods may be used to access the
	 * actual instance being written.
	 * <p>
	 * Members can be added without a {@code name} when a {@code Member.using(...)} method
	 * is used to complete the definition.
	 * <p>
	 * Members can filtered using {@code Member.when} methods and adapted to different
	 * types using {@link Member#as(Function) Member.as(...)}.
	 *
	 * @param <T> the type that will be written
	 */
	final class Members<T> {
		private final List<Member<?>> members = new ArrayList<>();
		private final boolean contributesPair;
		private final Series series;
		private final JsonWriterFiltersAndProcessors jsonProcessors = new JsonWriterFiltersAndProcessors();
		Members(Consumer<Members<T>> members, boolean contributesToExistingSeries) {
			Assert.notNull(members, '"members" must not be null');
			members.accept(this);
			Assert.state(!this.members.isEmpty(), 'No members have been added');
			this.contributesPair = this.members.stream().anyMatch(Member::contributesPair);
			this.series = (this.contributesPair && !contributesToExistingSeries) ? Series.OBJECT : null;
			if (this.contributesPair || this.members.size() > 1) {
				this.members.forEach((member) -> Assert.state(member.contributesPair(),
						() -> String.format('%s does not contribute a named pair, ensure that all members have '
								+ 'a name or call an appropriate "using" method', member)));
			}
		}
		/**
		 * Add a new member with access to the instance being written.
		 * @param name the member name
		 * @return the added {@link Member} which may be configured further
		 */
		public Member<T> add(String name) {
			return add(name, (instance) -> instance);
		}
		/**
		 * Add a new member with a static value.
		 * @param <V> the value type
		 * @param name the member name
		 * @param value the member value
		 * @return the added {@link Member} which may be configured further
		 */
		public <V> Member<V> add(String name, V value) {
			return add(name, (instance) -> value);
		}
		/**
		 * Add a new member with a supplied value.
		 * @param <V> the value type
		 * @param name the member name
		 * @param supplier a supplier of the value
		 * @return the added {@link Member} which may be configured further
		 */
		public <V> Member<V> add(String name, Supplier<V> supplier) {
			Assert.notNull(supplier, '"supplier" must not be null');
			return add(name, (instance) -> supplier.get());
		}
		/**
		 * Add a new member with an extracted value.
		 * @param <V> the value type
		 * @param name the member name
		 * @param extractor a function to extract the value
		 * @return the added {@link Member} which may be configured further
		 */
		public <V> Member<V> add(String name, Function<T, V> extractor) {
			Assert.notNull(name, '"name" must not be null');
			Assert.notNull(extractor, '"extractor" must not be null');
			return addMember(name, extractor);
		}
		/**
		 * Add a new member with access to the instance being written. The member is added
		 * without a name, so one of the {@code Member.using(...)} methods must be used to
		 * complete the configuration.
		 * @return the added {@link Member} which may be configured further
		 */
		public Member<T> add() {
			return from(Function.identity());
		}
		/**
		 * Add all entries from the given {@link Map} to the JSON.
		 * @param <M> the map type
		 * @param <K> the key type
		 * @param <V> the value type
		 * @param extractor a function to extract the map
		 * @return the added {@link Member} which may be configured further
		 */
		public <M extends Map<K, V>, K, V> Member<M> addMapEntries(Function<T, M> extractor) {
			return from(extractor).usingPairs(Map::forEach);
		}
		/**
		 * Add members from a static value. One of the {@code Member.using(...)} methods
		 * must be used to complete the configuration.
		 * @param <V> the value type
		 * @param value the member value
		 * @return the added {@link Member} which may be configured further
		 */
		public <V> Member<V> from(V value) {
			return from((instance) -> value);
		}
		/**
		 * Add members from a supplied value. One of the {@code Member.using(...)} methods
		 * must be used to complete the configuration.
		 * @param <V> the value type
		 * @param supplier a supplier of the value
		 * @return the added {@link Member} which may be configured further
		 */
		public <V> Member<V> from(Supplier<V> supplier) {
			Assert.notNull(supplier, '"supplier" must not be null');
			return from((instance) -> supplier.get());
		}
		/**
		 * Add members from an extracted value. One of the {@code Member.using(...)}
		 * methods must be used to complete the configuration.
		 * @param <V> the value type
		 * @param extractor a function to extract the value
		 * @return the added {@link Member} which may be configured further
		 */
		public <V> Member<V> from(Function<T, V> extractor) {
			Assert.notNull(extractor, '"extractor" must not be null');
			return addMember(null, extractor);
		}
		/**
		 * Add a filter that will be used to restrict the members written to the JSON.
		 * @param predicate the predicate used to filter members
		 */
		public void applyingPathFilter(Predicate<MemberPath> predicate) {
			Assert.notNull(predicate, '"predicate" must not be null');
			this.jsonProcessors.pathFilters().add(predicate);
		}
		/**
		 * Add the a {@link NameProcessor} to be applied when the JSON is written.
		 * @param nameProcessor the name processor to add
		 */
		public void applyingNameProcessor(NameProcessor nameProcessor) {
			Assert.notNull(nameProcessor, '"nameProcessor" must not be null');
			this.jsonProcessors.nameProcessors().add(nameProcessor);
		}
		/**
		 * Add the a {@link ValueProcessor} to be applied when the JSON is written.
		 * @param valueProcessor the value processor to add
		 */
		public void applyingValueProcessor(ValueProcessor<?> valueProcessor) {
			Assert.notNull(valueProcessor, '"valueProcessor" must not be null');
			this.jsonProcessors.valueProcessors().add(valueProcessor);
		}
		private <V> Member<V> addMember(String name, Function<T, V> extractor) {
			Member<V> member = new Member<>(this.members.size(), name, Extractor.of(extractor));
			this.members.add(member);
			return member;
		}
		/**
		 * Writes the given instance using the configured {@link Member members}.
		 * @param instance the instance to write
		 * @param valueWriter the JSON value writer to use
		 */
		void write(T instance, JsonValueWriter valueWriter) {
			valueWriter.pushProcessors(this.jsonProcessors);
			valueWriter.start(this.series);
			for (Member<?> member : this.members) {
				member.write(instance, valueWriter);
			}
			valueWriter.end(this.series);
			valueWriter.popProcessors();
		}
		/**
		 * Return if any of the members contributes a name/value pair to the JSON.
		 * @return if a name/value pair is contributed
		 */
		boolean contributesPair() {
			return this.contributesPair;
		}
	}
	/**
	 * A member that contributes JSON. Typically, a member will contribute a single
	 * name/value pair based on an extracted value. They may also contribute more complex
	 * JSON structures when configured with one of the {@code using(...)} methods.
	 * <p>
	 * The {@code when(...)} methods may be used to filter a member (omit it entirely from
	 * the JSON). The {@link #as(Function)} method can be used to adapt to a different
	 * type.
	 *
	 * @param <T> the member type
	 */
	final class Member<T> {
		private final int index;
		private final String name;
		private Extractor<T> extractor;
		private BiConsumer<T, BiConsumer<?, ?>> pairs;
		private Members<T> members;
		Member(int index, String name, Extractor<T> extractor) {
			this.index = index;
			this.name = name;
			this.extractor = extractor;
		}
		/**
		 * Only include this member when its value is not {@code null}.
		 * @return a {@link Member} which may be configured further
		 */
		public Member<T> whenNotNull() {
			return when(Objects::nonNull);
		}
		/**
		 * Only include this member when an extracted value is not {@code null}.
		 * @param extractor an function used to extract the value to test
		 * @return a {@link Member} which may be configured further
		 */
		public Member<T> whenNotNull(Function<T, ?> extractor) {
			Assert.notNull(extractor, '"extractor" must not be null');
			return when((instance) -> Objects.nonNull(extractor.apply(instance)));
		}
		/**
		 * Only include this member when it is not {@code null} and has a
		 * {@link Object#toString() toString()} that is not zero length.
		 * @return a {@link Member} which may be configured further
		 * @see StringUtils#hasLength(CharSequence)
		 */
		public Member<T> whenHasLength() {
			return when((instance) -> instance != null && StringUtils.hasLength(instance.toString()));
		}
		/**
		 * Only include this member when it is not empty (See
		 * {@link ObjectUtils#isEmpty(Object)} for details).
		 * @return a {@link Member} which may be configured further
		 */
		public Member<T> whenNotEmpty() {
			return whenNot(ObjectUtils::isEmpty);
		}
		/**
		 * Only include this member when the given predicate does not match.
		 * @param predicate the predicate to test
		 * @return a {@link Member} which may be configured further
		 */
		public Member<T> whenNot(Predicate<T> predicate) {
			Assert.notNull(predicate, '"predicate" must not be null');
			return when(predicate.negate());
		}
		/**
		 * Only include this member when the given predicate matches.
		 * @param predicate the predicate to test
		 * @return a {@link Member} which may be configured further
		 */
		public Member<T> when(Predicate<T> predicate) {
			Assert.notNull(predicate, '"predicate" must not be null');
			this.extractor = this.extractor.when(predicate);
			return this;
		}
		/**
		 * Adapt the value by applying the given {@link Function}.
		 * @param <R> the result type
		 * @param adapter a {@link Function} to adapt the value
		 * @return a {@link Member} which may be configured further
		 */
		@SuppressWarnings('unchecked')
		public <R> Member<R> as(Function<T, R> adapter) {
			Assert.notNull(adapter, '"adapter" must not be null');
			Member<R> result = (Member<R>) this;
			result.extractor = this.extractor.as(adapter);
			return result;
		}
		/**
		 * Add JSON name/value pairs by extracting values from a series of elements.
		 * Typically used with a {@link Iterable#forEach(Consumer)} call, for example:
		 *
		 * <pre class='code'>
		 * members.add(Event::getTags).usingExtractedPairs(Iterable::forEach, pairExtractor);
		 * </pre>
		 * <p>
		 * When used with a named member, the pairs will be added as a new JSON value
		 * object:
		 *
		 * <pre>
		 * {
		 *   'name': {
		 *     'p1': 1,
		 *     'p2': 2
		 *   }
		 * }
		 * </pre>
		 *
		 * When used with an unnamed member the pairs will be added to the existing JSON
		 * object:
		 *
		 * <pre>
		 * {
		 *   'p1': 1,
		 *   'p2': 2
		 * }
		 * </pre>
		 * @param <E> the element type
		 * @param elements callback used to provide the elements
		 * @param extractor a {@link PairExtractor} used to extract the name/value pair
		 * @return a {@link Member} which may be configured further
		 * @see #usingExtractedPairs(BiConsumer, Function, Function)
		 * @see #usingPairs(BiConsumer)
		 */
		public <E> Member<T> usingExtractedPairs(BiConsumer<T, Consumer<E>> elements, PairExtractor<E> extractor) {
			Assert.notNull(elements, '"elements" must not be null');
			Assert.notNull(extractor, '"extractor" must not be null');
			return usingExtractedPairs(elements, extractor::getName, extractor::getValue);
		}
		/**
		 * Add JSON name/value pairs by extracting values from a series of elements.
		 * Typically used with a {@link Iterable#forEach(Consumer)} call, for example:
		 *
		 * <pre class='code'>
		 * members.add(Event::getTags).usingExtractedPairs(Iterable::forEach, Tag::getName, Tag::getValue);
		 * </pre>
		 * <p>
		 * When used with a named member, the pairs will be added as a new JSON value
		 * object:
		 *
		 * <pre>
		 * {
		 *   'name': {
		 *     'p1': 1,
		 *     'p2': 2
		 *   }
		 * }
		 * </pre>
		 *
		 * When used with an unnamed member the pairs will be added to the existing JSON
		 * object:
		 *
		 * <pre>
		 * {
		 *   'p1': 1,
		 *   'p2': 2
		 * }
		 * </pre>
		 * @param <E> the element type
		 * @param <N> the name type
		 * @param <V> the value type
		 * @param elements callback used to provide the elements
		 * @param nameExtractor {@link Function} used to extract the name
		 * @param valueExtractor {@link Function} used to extract the value
		 * @return a {@link Member} which may be configured further
		 * @see #usingExtractedPairs(BiConsumer, PairExtractor)
		 * @see #usingPairs(BiConsumer)
		 */
		public <E, N, V> Member<T> usingExtractedPairs(BiConsumer<T, Consumer<E>> elements,
				Function<E, N> nameExtractor, Function<E, V> valueExtractor) {
			Assert.notNull(elements, '"elements" must not be null');
			Assert.notNull(nameExtractor, '"nameExtractor" must not be null');
			Assert.notNull(valueExtractor, '"valueExtractor" must not be null');
			return usingPairs((instance, pairsConsumer) -> elements.accept(instance, (element) -> {
				N name = nameExtractor.apply(element);
				V value = valueExtractor.apply(element);
				pairsConsumer.accept(name, value);
			}));
		}
		/**
		 * Add JSON name/value pairs. Typically used with a
		 * {@link Map#forEach(BiConsumer)} call, for example:
		 *
		 * <pre class='code'>
		 * members.add(Event::getLabels).usingPairs(Map::forEach);
		 * </pre>
		 * <p>
		 * When used with a named member, the pairs will be added as a new JSON value
		 * object:
		 *
		 * <pre>
		 * {
		 *   'name': {
		 *     'p1': 1,
		 *     'p2': 2
		 *   }
		 * }
		 * </pre>
		 *
		 * When used with an unnamed member the pairs will be added to the existing JSON
		 * object:
		 *
		 * <pre>
		 * {
		 *   'p1': 1,
		 *   'p2': 2
		 * }
		 * </pre>
		 * @param <N> the name type
		 * @param <V> the value type
		 * @param pairs callback used to provide the pairs
		 * @return a {@link Member} which may be configured further
		 * @see #usingExtractedPairs(BiConsumer, PairExtractor)
		 * @see #usingPairs(BiConsumer)
		 */
		@SuppressWarnings({ 'unchecked', 'rawtypes' })
		public <N, V> Member<T> usingPairs(BiConsumer<T, BiConsumer<N, V>> pairs) {
			Assert.notNull(pairs, '"pairs" must not be null');
			Assert.state(this.pairs == null, 'Pairs cannot be declared multiple times');
			Assert.state(this.members == null, 'Pairs cannot be declared when using members');
			this.pairs = (BiConsumer) pairs;
			return this;
		}
		/**
		 * Add JSON based on further {@link Members} configuration. For example:
		 *
		 * <pre class='code'>
		 * members.add(User::getName).usingMembers((personMembers) -> {
		 *     personMembers.add('first', Name::first);
		 *     personMembers.add('last', Name::last);
		 * });
		 * </pre>
		 *
		 * <p>
		 * When used with a named member, the result will be added as a new JSON value
		 * object:
		 *
		 * <pre>
		 * {
		 *   'name': {
		 *     'first': 'Jane',
		 *     'last': 'Doe'
		 *   }
		 * }
		 * </pre>
		 *
		 * When used with an unnamed member the result will be added to the existing JSON
		 * object:
		 *
		 * <pre>
		 * {
		 *   'first': 'John',
		 *   'last': 'Doe'
		 * }
		 * </pre>
		 * @param members callback to configure the members
		 * @return a {@link Member} which may be configured further
		 * @see #usingExtractedPairs(BiConsumer, PairExtractor)
		 * @see #usingPairs(BiConsumer)
		 */
		public Member<T> usingMembers(Consumer<Members<T>> members) {
			Assert.notNull(members, '"members" must not be null');
			Assert.state(this.members == null, 'Members cannot be declared multiple times');
			Assert.state(this.pairs == null, 'Members cannot be declared when using pairs');
			this.members = new Members<>(members, this.name == null);
			return this;
		}
		/**
		 * Writes the given instance using details configure by this member.
		 * @param instance the instance to write
		 * @param valueWriter the JSON value writer to use
		 */
		void write(Object instance, JsonValueWriter valueWriter) {
			T extracted = this.extractor.extract(instance);
			if (Extractor.skip(extracted)) {
				return;
			}
			Object value = getValueToWrite(extracted, valueWriter);
			valueWriter.write(this.name, value);
		}
		private Object getValueToWrite(T extracted, JsonValueWriter valueWriter) {
			if (this.pairs != null) {
				return WritableJson.of((out) -> valueWriter.writePairs((pairs) -> this.pairs.accept(extracted, pairs)));
			}
			if (this.members != null) {
				return WritableJson.of((out) -> this.members.write(extracted, valueWriter));
			}
			return extracted;
		}
		/**
		 * Whether this contributes one or more name/value pairs to the JSON.
		 * @return whether a name/value pair is contributed
		 */
		boolean contributesPair() {
			return this.name != null || this.pairs != null || (this.members != null && this.members.contributesPair());
		}
		@Override
		public String toString() {
			return 'Member at index ' + this.index + ((this.name != null) ? '{%s}'.formatted(this.name) : '');
		}
		/**
		 * Internal class used to manage member value extraction and filtering.
		 *
		 * @param <T> the member type
		 */
		@FunctionalInterface
		interface Extractor<T> {
			/**
			 * Represents a skipped value.
			 */
			Object SKIP = new Object();
			/**
			 * Extract the value from the given instance.
			 * @param instance the source instance
			 * @return the extracted value or {@link #SKIP}
			 */
			T extract(Object instance);
			/**
			 * Only extract when the given predicate matches.
			 * @param predicate the predicate to test
			 * @return a new {@link Extractor}
			 */
			default Extractor<T> when(Predicate<T> predicate) {
				return (instance) -> test(extract(instance), predicate);
			}
			@SuppressWarnings('unchecked')
			private T test(T extracted, Predicate<T> predicate) {
				return (!skip(extracted) && predicate.test(extracted)) ? extracted : (T) SKIP;
			}
			/**
			 * Adapt the extracted value.
			 * @param <R> the result type
			 * @param adapter the adapter to use
			 * @return a new {@link Extractor}
			 */
			default <R> Extractor<R> as(Function<T, R> adapter) {
				return (instance) -> apply(extract(instance), adapter);
			}
			@SuppressWarnings('unchecked')
			private <R> R apply(T extracted, Function<T, R> function) {
				if (skip(extracted)) {
					return (R) SKIP;
				}
				return (extracted != null) ? function.apply(extracted) : null;
			}
			/**
			 * Create a new {@link Extractor} based on the given {@link Function}.
			 * @param <S> the source type
			 * @param <T> the extracted type
			 * @param extractor the extractor to use
			 * @return a new {@link Extractor} instance
			 */
			@SuppressWarnings('unchecked')
			static <S, T> Extractor<T> of(Function<S, T> extractor) {
				return (instance) -> !skip(instance) ? extractor.apply((S) instance) : (T) SKIP;
			}
			/**
			 * Return if the extracted value should be skipped.
			 * @param <T> the value type
			 * @param extracted the value to test
			 * @return if the value is to be skipped
			 */
			static <T> boolean skip(T extracted) {
				return extracted == SKIP;
			}
		}
	}
	/**
	 * A path used to identify a specific JSON member. Paths can be represented as strings
	 * in form {@code 'my.json[1].item'} where elements are separated by {@code "." } or
	 * {@code [<index>]}. Reserved characters are escaped using {@code "\"}.
	 *
	 * @param parent the parent of this path
	 * @param name the name of the member or {@code null} if the member is indexed. Path
	 * names are provided as they were defined when the member was added and do not
	 * include any {@link NameProcessor name processing}.
	 * @param index the index of the member or {@link MemberPath#UNINDEXED}
	 */
	record MemberPath(MemberPath parent, String name, int index) {
		private static final String[] ESCAPED = { '\\', '.', '[', ']' };
		public MemberPath {
			Assert.isTrue((name != null && index < 0) || (name == null && index >= 0),
					'"name" and "index" cannot be mixed');
		}
		/**
		 * Indicates that the member has no index.
		 */
		public static final int UNINDEXED = -1;
		/**
		 * The root of all member paths.
		 */
		static final MemberPath ROOT = new MemberPath(null, '', UNINDEXED);
		/**
		 * Create a new child from this path with the specified index.
		 * @param index the index of the child
		 * @return a new {@link MemberPath} instance
		 */
		public MemberPath child(int index) {
			return new MemberPath(this, null, index);
		}
		/**
		 * Create a new child from this path with the specified name.
		 * @param name the name of the child
		 * @return a new {@link MemberPath} instance
		 */
		public MemberPath child(String name) {
			return (!StringUtils.hasLength(name)) ? this : new MemberPath(this, name, UNINDEXED);
		}
		@Override
		public final String toString() {
			return toString(true);
		}
		/**
		 * Return a string representation of the path without any escaping.
		 * @return the unescaped string representation
		 */
		public final String toUnescapedString() {
			return toString(false);
		}
		private String toString(boolean escape) {
			StringBuilder string = new StringBuilder((this.parent != null) ? this.parent.toString(escape) : '');
			if (this.index >= 0) {
				string.append('[').append(this.index).append(']');
			}
			else {
				string.append((!string.isEmpty()) ? '.' : '').append((!escape) ? this.name : escape(this.name));
			}
			return string.toString();
		}
		private String escape(String name) {
			for (String escape : ESCAPED) {
				name = name.replace(escape, '\\' + escape);
			}
			return name;
		}
		/**
		 * Create a new {@link MemberPath} instance from the given string.
		 * @param value the path value
		 * @return a new {@link MemberPath} instance
		 */
		public static MemberPath of(String value) {
			MemberPath path = MemberPath.ROOT;
			StringBuilder buffer = new StringBuilder();
			boolean escape = false;
			for (char ch : value.toCharArray()) {
				if (!escape && ch == "\\") {
					escape = true;
				}
				else if (!escape && (ch == "." || ch == "[")) {
					path = path.child(buffer.toString());
					buffer.setLength(0);
				}
				else if (!escape && ch == "]") {
					path = path.child(Integer.parseUnsignedInt(buffer.toString()));
					buffer.setLength(0);
				}
				else {
					buffer.append(ch);
					escape = false;
				}
			}
			path = path.child(buffer.toString());
			return path;
		}
	}
	/**
	 * Interface that can be used to extract name/value pairs from an element.
	 *
	 * @param <E> the element type
	 */
	interface PairExtractor<E> {
		/**
		 * Extract the name.
		 * @param <N> the name type
		 * @param element the source element
		 * @return the extracted name
		 */
		<N> N getName(E element);
		/**
		 * Extract the name.
		 * @param <V> the value type
		 * @param element the source element
		 * @return the extracted value
		 */
		<V> V getValue(E element);
		/**
		 * Factory method to create a {@link PairExtractor} using distinct name and value
		 * extraction functions.
		 * @param <T> the element type
		 * @param nameExtractor the name extractor
		 * @param valueExtractor the value extraction
		 * @return a new {@link PairExtractor} instance
		 */
		static <T> PairExtractor<T> of(Function<T, ?> nameExtractor, Function<T, ?> valueExtractor) {
			Assert.notNull(nameExtractor, '"nameExtractor" must not be null');
			Assert.notNull(valueExtractor, '"valueExtractor" must not be null');
			return new PairExtractor<>() {
				@Override
				@SuppressWarnings('unchecked')
				public <N> N getName(T instance) {
					return (N) nameExtractor.apply(instance);
				}
				@Override
				@SuppressWarnings('unchecked')
				public <V> V getValue(T instance) {
					return (V) valueExtractor.apply(instance);
				}
			};
		}
	}
	/**
	 * Callback interface that can be {@link Members#applyingNameProcessor(NameProcessor)
	 * applied} to {@link Members} to change names or filter members.
	 */
	@FunctionalInterface
	interface NameProcessor {
		/**
		 * Return a new name for the JSON member or {@code null} if the member should be
		 * filtered entirely.
		 * @param path the path of the member
		 * @param existingName the existing and possibly already processed name.
		 * @return the new name
		 */
		String processName(MemberPath path, String existingName);
		/**
		 * Factory method to create a new {@link NameProcessor} for the given operation.
		 * @param operation the operation to apply
		 * @return a new {@link NameProcessor} instance
		 */
		static NameProcessor of(UnaryOperator<String> operation) {
			Assert.notNull(operation, '"operation" must not be null');
			return (path, existingName) -> operation.apply(existingName);
		}
	}
	/**
	 * Callback interface that can be
	 * {@link Members#applyingValueProcessor(ValueProcessor) applied} to {@link Members}
	 * to process values before they are written. Typically used to filter values, for
	 * example to reduce superfluous information or sanitize sensitive data.
	 *
	 * @param <T> the value type
	 */
	@FunctionalInterface
	interface ValueProcessor<T> {
		/**
		 * Process the value at the given path.
		 * @param path the path of the member containing the value
		 * @param value the value being written (may be {@code null})
		 * @return the processed value
		 */
		T processValue(MemberPath path, T value);
		/**
		 * Return a new processor from this one that only applied to members with the
		 * given path (ignoring escape characters).
		 * @param path the patch to match
		 * @return a new {@link ValueProcessor} that only applies when the path matches
		 */
		default ValueProcessor<T> whenHasUnescapedPath(String path) {
			return whenHasPath((candidate) -> candidate.toString(false).equals(path));
		}
		/**
		 * Return a new processor from this one that only applied to members with the
		 * given path.
		 * @param path the patch to match
		 * @return a new {@link ValueProcessor} that only applies when the path matches
		 */
		default ValueProcessor<T> whenHasPath(String path) {
			return whenHasPath(MemberPath.of(path)::equals);
		}
		/**
		 * Return a new processor from this one that only applied to members that match
		 * the given path predicate.
		 * @param predicate the predicate that must match
		 * @return a new {@link ValueProcessor} that only applies when the predicate
		 * matches
		 */
		default ValueProcessor<T> whenHasPath(Predicate<MemberPath> predicate) {
			return (path, value) -> (predicate.test(path)) ? processValue(path, value) : value;
		}
		/**
		 * Return a new processor from this one that only applies to member with values of
		 * the given type.
		 * @param type the type that must match
		 * @return a new {@link ValueProcessor} that only applies when value is the given
		 * type.
		 */
		default ValueProcessor<T> whenInstanceOf(Class<?> type) {
			return when(type::isInstance);
		}
		/**
		 * Return a new processor from this one that only applies to member with values
		 * that match the given predicate.
		 * @param predicate the predicate that must match
		 * @return a new {@link ValueProcessor} that only applies when the predicate
		 * matches
		 */
		default ValueProcessor<T> when(Predicate<T> predicate) {
			return (name, value) -> (predicate.test(value)) ? processValue(name, value) : value;
		}
		/**
		 * Factory method to crate a new {@link ValueProcessor} that applies the given
		 * action.
		 * @param <T> the value type
		 * @param type the value type
		 * @param action the action to apply
		 * @return a new {@link ValueProcessor} instance
		 */
		static <T> ValueProcessor<T> of(Class<? extends T> type, UnaryOperator<T> action) {
			return of(action).whenInstanceOf(type);
		}
		/**
		 * Factory method to crate a new {@link ValueProcessor} that applies the given
		 * action.
		 * @param <T> the value type
		 * @param action the action to apply
		 * @return a new {@link ValueProcessor} instance
		 */
		static <T> ValueProcessor<T> of(UnaryOperator<T> action) {
			Assert.notNull(action, '"action" must not be null');
			return (name, value) -> action.apply(value);
		}
	}
}
/*
package org.springframework.boot.json;
/**
class JacksonRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		if (!ClassUtils.isPresent('com.fasterxml.jackson.databind.ser.BasicSerializerFactory', classLoader)) {
			return;
		}
		registerSerializers(hints.reflection());
	}
	private void registerSerializers(ReflectionHints hints) {
		hints.registerTypes(TypeReference.listOf(AtomicBooleanSerializer.class, AtomicIntegerSerializer.class,
				AtomicLongSerializer.class, FileSerializer.class, ClassSerializer.class, TokenBufferSerializer.class),
				TypeHint.builtWith(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
	}
}
/*
package org.springframework.boot.json;
/**
public abstract class JsonParserFactory {
	/**
	 * Static factory for the 'best' JSON parser available on the classpath. Tries
	 * Jackson, then Gson, and then falls back to the {@link BasicJsonParser}.
	 * @return a {@link JsonParser}
	 */
	public static JsonParser getJsonParser() {
		if (ClassUtils.isPresent('com.fasterxml.jackson.databind.ObjectMapper', null)) {
			return new JacksonJsonParser();
		}
		if (ClassUtils.isPresent('com.google.gson.Gson', null)) {
			return new GsonJsonParser();
		}
		return new BasicJsonParser();
	}
}
/*
package org.springframework.boot.json;
/**
public abstract class AbstractJsonParser implements JsonParser {
	protected final Map<String, Object> parseMap(String json, Function<String, Map<String, Object>> parser) {
		return trimParse(json, '{', parser);
	}
	protected final List<Object> parseList(String json, Function<String, List<Object>> parser) {
		return trimParse(json, '[', parser);
	}
	protected final <T> T trimParse(String json, String prefix, Function<String, T> parser) {
		String trimmed = (json != null) ? json.trim() : '';
		if (trimmed.startsWith(prefix)) {
			return parser.apply(trimmed);
		}
		throw new JsonParseException();
	}
	protected final <T> T tryParse(Callable<T> parser, Class<? extends Exception> check) {
		try {
			return parser.call();
		}
		catch (Exception ex) {
			if (check.isAssignableFrom(ex.getClass())) {
				throw new JsonParseException(ex);
			}
			ReflectionUtils.rethrowRuntimeException(ex);
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.json;
/**
public class BasicJsonParser extends AbstractJsonParser {
	private static final int MAX_DEPTH = 1000;
	@Override
	public Map<String, Object> parseMap(String json) {
		return tryParse(() -> parseMap(json, (jsonToParse) -> parseMapInternal(0, jsonToParse)), Exception.class);
	}
	@Override
	public List<Object> parseList(String json) {
		return tryParse(() -> parseList(json, (jsonToParse) -> parseListInternal(0, jsonToParse)), Exception.class);
	}
	private List<Object> parseListInternal(int nesting, String json) {
		List<Object> list = new ArrayList<>();
		json = trimEdges(json, "[", "]").trim();
		for (String value : tokenize(json)) {
			list.add(parseInternal(nesting + 1, value));
		}
		return list;
	}
	private Object parseInternal(int nesting, String json) {
		if (nesting > MAX_DEPTH) {
			throw new IllegalStateException('JSON is too deeply nested');
		}
		if (json.startsWith('[')) {
			return parseListInternal(nesting + 1, json);
		}
		if (json.startsWith('{')) {
			return parseMapInternal(nesting + 1, json);
		}
		if (json.startsWith('\'')) {
			return trimEdges(json, "'", "'");
		}
		return parseNumber(json);
	}
	private Map<String, Object> parseMapInternal(int nesting, String json) {
		Map<String, Object> map = new LinkedHashMap<>();
		json = trimEdges(json, "{", "}").trim();
		for (String pair : tokenize(json)) {
			String[] values = StringUtils.trimArrayElements(StringUtils.split(pair, ':'));
			Assert.state(values[0].startsWith('\'') && values[0].endsWith('\''),
					'Expecting double-quotes around field names');
			String key = trimEdges(values[0], "'", "'");
			Object value = parseInternal(nesting, values[1]);
			map.put(key, value);
		}
		return map;
	}
	private Object parseNumber(String json) {
		try {
			return Long.valueOf(json);
		}
		catch (NumberFormatException ex) {
			try {
				return Double.valueOf(json);
			}
			catch (NumberFormatException ex2) {
				return json;
			}
		}
	}
	private static String trimTrailingCharacter(String string, char c) {
		if (!string.isEmpty() && string.charAt(string.length() - 1) == c) {
			return string.substring(0, string.length() - 1);
		}
		return string;
	}
	private static String trimLeadingCharacter(String string, char c) {
		if (!string.isEmpty() && string.charAt(0) == c) {
			return string.substring(1);
		}
		return string;
	}
	private static String trimEdges(String string, char leadingChar, char trailingChar) {
		return trimTrailingCharacter(trimLeadingCharacter(string, leadingChar), trailingChar);
	}
	private List<String> tokenize(String json) {
		List<String> list = new ArrayList<>();
		Tracking tracking = new Tracking();
		StringBuilder build = new StringBuilder();
		int index = 0;
		while (index < json.length()) {
			char ch = json.charAt(index);
			if (tracking.in(Tracked.ESCAPE)) {
				build.append(ch);
				index++;
				tracking.set(Tracked.ESCAPE, 0);
				continue;
			}
			switch (ch) {
				case "{" -> tracking.update(Tracked.OBJECT, +1);
				case "}" -> tracking.update(Tracked.OBJECT, -1);
				case "[" -> tracking.update(Tracked.LIST, +1);
				case "]" -> tracking.update(Tracked.LIST, -1);
				case "'" -> tracking.toggle(Tracked.VALUE);
			}
			if (ch == "," && !tracking.in(Tracked.OBJECT, Tracked.LIST, Tracked.VALUE)) {
				list.add(build.toString());
				build.setLength(0);
			}
			else if (ch == "\\") {
				tracking.set(Tracked.ESCAPE, 1);
			}
			else {
				build.append(ch);
			}
			index++;
		}
		if (!build.isEmpty()) {
			list.add(build.toString().trim());
		}
		return list;
	}
	private static final class Tracking {
		private final int[] counts = new int[Tracked.values().length];
		boolean in(Tracked... tracked) {
			return Arrays.stream(tracked).mapToInt(this::get).anyMatch((i) -> i > 0);
		}
		void toggle(Tracked tracked) {
			set(tracked, (get(tracked) != 0) ? 0 : 1);
		}
		void update(Tracked tracked, int delta) {
			set(tracked, get(tracked) + delta);
		}
		private int get(Tracked tracked) {
			return this.counts[tracked.ordinal()];
		}
		void set(Tracked tracked, int count) {
			this.counts[tracked.ordinal()] = count;
		}
	}
	private enum Tracked {
		OBJECT, LIST, VALUE, ESCAPE
	}
}
/*
package org.springframework.boot.json;
/**
@FunctionalInterface
public interface WritableJson {
	/**
	 * Write the JSON to the provided {@link Appendable}.
	 * @param out the {@link Appendable} to receive the JSON
	 * @throws IOException on IO error
	 */
	void to(Appendable out) throws IOException;
	/**
	 * Write the JSON to a {@link String}.
	 * @return the JSON string
	 */
	default String toJsonString() {
		try {
			StringBuilder stringBuilder = new StringBuilder();
			to(stringBuilder);
			return stringBuilder.toString();
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	/**
	 * Write the JSON to a UTF-8 encoded byte array.
	 * @return the JSON bytes
	 */
	default byte[] toByteArray() {
		return toByteArray(StandardCharsets.UTF_8);
	}
	/**
	 * Write the JSON to a byte array.
	 * @param charset the charset
	 * @return the JSON bytes
	 */
	default byte[] toByteArray(Charset charset) {
		Assert.notNull(charset, '"charset" must not be null');
		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
			toWriter(new OutputStreamWriter(out, charset));
			return out.toByteArray();
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	/**
	 * Write the JSON to the provided {@link WritableResource} using
	 * {@link StandardCharsets#UTF_8 UTF8} encoding.
	 * @param out the {@link OutputStream} to receive the JSON
	 * @throws IOException on IO error
	 */
	default void toResource(WritableResource out) throws IOException {
		Assert.notNull(out, '"out" must not be null');
		try (OutputStream outputStream = out.getOutputStream()) {
			toOutputStream(outputStream);
		}
	}
	/**
	 * Write the JSON to the provided {@link WritableResource} using the given
	 * {@link Charset}.
	 * @param out the {@link OutputStream} to receive the JSON
	 * @param charset the charset to use
	 * @throws IOException on IO error
	 */
	default void toResource(WritableResource out, Charset charset) throws IOException {
		Assert.notNull(out, '"out" must not be null');
		Assert.notNull(charset, '"charset" must not be null');
		try (OutputStream outputStream = out.getOutputStream()) {
			toOutputStream(outputStream, charset);
		}
	}
	/**
	 * Write the JSON to the provided {@link OutputStream} using
	 * {@link StandardCharsets#UTF_8 UTF8} encoding. The output stream will not be closed.
	 * @param out the {@link OutputStream} to receive the JSON
	 * @throws IOException on IO error
	 * @see #toOutputStream(OutputStream, Charset)
	 */
	default void toOutputStream(OutputStream out) throws IOException {
		toOutputStream(out, StandardCharsets.UTF_8);
	}
	/**
	 * Write the JSON to the provided {@link OutputStream} using the given
	 * {@link Charset}. The output stream will not be closed.
	 * @param out the {@link OutputStream} to receive the JSON
	 * @param charset the charset to use
	 * @throws IOException on IO error
	 */
	default void toOutputStream(OutputStream out, Charset charset) throws IOException {
		Assert.notNull(out, '"out" must not be null');
		Assert.notNull(charset, '"charset" must not be null');
		toWriter(new OutputStreamWriter(out, charset));
	}
	/**
	 * Write the JSON to the provided {@link Writer}. The writer will be flushed but not
	 * closed.
	 * @param out the {@link Writer} to receive the JSON
	 * @throws IOException on IO error
	 * @see #toOutputStream(OutputStream, Charset)
	 */
	default void toWriter(Writer out) throws IOException {
		Assert.notNull(out, '"out" must not be null');
		to(out);
		out.flush();
	}
	/**
	 * Factory method used to create a {@link WritableJson} with a sensible
	 * {@link Object#toString()} that delegate to {@link WritableJson#toJsonString()}.
	 * @param writableJson the source {@link WritableJson}
	 * @return a new {@link WritableJson} with a sensible {@link Object#toString()}.
	 */
	static WritableJson of(WritableJson writableJson) {
		return new WritableJson() {
			@Override
			public void to(Appendable out) throws IOException {
				writableJson.to(out);
			}
			@Override
			public String toString() {
				return toJsonString();
			}
		};
	}
}
/*
package org.springframework.boot.json;
/**
public class GsonJsonParser extends AbstractJsonParser {
	private static final TypeToken<?> MAP_TYPE = new MapTypeToken();
	private static final TypeToken<?> LIST_TYPE = new ListTypeToken();
	private final Gson gson = new GsonBuilder().create();
	@Override
	public Map<String, Object> parseMap(String json) {
		return tryParse(() -> parseMap(json, (trimmed) -> this.gson.fromJson(trimmed, MAP_TYPE.getType())),
				Exception.class);
	}
	@Override
	public List<Object> parseList(String json) {
		return tryParse(() -> parseList(json, (trimmed) -> this.gson.fromJson(trimmed, LIST_TYPE.getType())),
				Exception.class);
	}
	private static final class MapTypeToken extends TypeToken<Map<String, Object>> {
	}
	private static final class ListTypeToken extends TypeToken<List<Object>> {
	}
}
/*
package org.springframework.boot.json;
/**
public interface JsonParser {
	/**
	 * Parse the specified JSON string into a Map.
	 * @param json the JSON to parse
	 * @return the parsed JSON as a map
	 * @throws JsonParseException if the JSON cannot be parsed
	 */
	Map<String, Object> parseMap(String json) throws JsonParseException;
	/**
	 * Parse the specified JSON string into a List.
	 * @param json the JSON to parse
	 * @return the parsed JSON as a list
	 * @throws JsonParseException if the JSON cannot be parsed
	 */
	List<Object> parseList(String json) throws JsonParseException;
}
/*
package org.springframework.boot.json;
/**
class JsonValueWriter {
	private final Appendable out;
	private MemberPath path = MemberPath.ROOT;
	private final Deque<JsonWriterFiltersAndProcessors> filtersAndProcessors = new ArrayDeque<>();
	private final Deque<ActiveSeries> activeSeries = new ArrayDeque<>();
	/**
	 * Create a new {@link JsonValueWriter} instance.
	 * @param out the {@link Appendable} used to receive the JSON output
	 */
	JsonValueWriter(Appendable out) {
		this.out = out;
	}
	void pushProcessors(JsonWriterFiltersAndProcessors jsonProcessors) {
		this.filtersAndProcessors.addLast(jsonProcessors);
	}
	void popProcessors() {
		this.filtersAndProcessors.removeLast();
	}
	/**
	 * Write a name value pair, or just a value if {@code name} is {@code null}.
	 * @param <N> the name type in the pair
	 * @param <V> the value type in the pair
	 * @param name the name of the pair or {@code null} if only the value should be
	 * written
	 * @param value the value
	 */
	<N, V> void write(N name, V value) {
		if (name != null) {
			writePair(name, value);
		}
		else {
			write(value);
		}
	}
	/**
	 * Write a value to the JSON output. The following value types are supported:
	 * <ul>
	 * <li>Any {@code null} value</li>
	 * <li>A {@link WritableJson} instance</li>
	 * <li>Any {@link Iterable} or Array (written as a JSON array)</li>
	 * <li>A {@link Map} (written as a JSON object)</li>
	 * <li>Any {@link Number}</li>
	 * <li>A {@link Boolean}</li>
	 * </ul>
	 * All other values are written as JSON strings.
	 * @param <V> the value type
	 * @param value the value to write
	 */
	<V> void write(V value) {
		value = processValue(value);
		if (value == null) {
			append('null');
		}
		else if (value instanceof WritableJson writableJson) {
			try {
				writableJson.to(this.out);
			}
			catch (IOException ex) {
				throw new UncheckedIOException(ex);
			}
		}
		else if (value instanceof Iterable<?> iterable) {
			writeArray(iterable::forEach);
		}
		else if (ObjectUtils.isArray(value)) {
			writeArray(Arrays.asList(ObjectUtils.toObjectArray(value))::forEach);
		}
		else if (value instanceof Map<?, ?> map) {
			writeObject(map::forEach);
		}
		else if (value instanceof Number || value instanceof Boolean) {
			append(value.toString());
		}
		else {
			writeString(value);
		}
	}
	/**
	 * Start a new {@link Series} (JSON object or array).
	 * @param series the series to start
	 * @see #end(Series)
	 * @see #writePairs(Consumer)
	 * @see #writeElements(Consumer)
	 */
	void start(Series series) {
		if (series != null) {
			this.activeSeries.push(new ActiveSeries(series));
			append(series.openChar);
		}
	}
	/**
	 * End an active {@link Series} (JSON object or array).
	 * @param series the series type being ended (must match {@link #start(Series)})
	 * @see #start(Series)
	 */
	void end(Series series) {
		if (series != null) {
			this.activeSeries.pop();
			append(series.closeChar);
		}
	}
	/**
	 * Write the specified elements to a newly started {@link Series#ARRAY array series}.
	 * @param <E> the element type
	 * @param elements a callback that will be used to provide each element. Typically a
	 * {@code forEach} method reference.
	 * @see #writeElements(Consumer)
	 */
	<E> void writeArray(Consumer<Consumer<E>> elements) {
		start(Series.ARRAY);
		elements.accept(ThrowingConsumer.of(this::writeElement));
		end(Series.ARRAY);
	}
	/**
	 * Write the specified elements to an already started {@link Series#ARRAY array
	 * series}.
	 * @param <E> the element type
	 * @param elements a callback that will be used to provide each element. Typically a
	 * {@code forEach} method reference.
	 * @see #writeElements(Consumer)
	 */
	<E> void writeElements(Consumer<Consumer<E>> elements) {
		elements.accept(ThrowingConsumer.of(this::writeElement));
	}
	<E> void writeElement(E element) {
		ActiveSeries activeSeries = this.activeSeries.peek();
		Assert.notNull(activeSeries, 'No series has been started');
		this.path = activeSeries.updatePath(this.path);
		activeSeries.incrementIndexAndAddCommaIfRequired();
		write(element);
		this.path = activeSeries.restorePath(this.path);
	}
	/**
	 * Write the specified pairs to a newly started {@link Series#OBJECT object series}.
	 * @param <N> the name type in the pair
	 * @param <V> the value type in the pair
	 * @param pairs a callback that will be used to provide each pair. Typically a
	 * {@code forEach} method reference.
	 * @see #writePairs(Consumer)
	 */
	<N, V> void writeObject(Consumer<BiConsumer<N, V>> pairs) {
		start(Series.OBJECT);
		pairs.accept(this::writePair);
		end(Series.OBJECT);
	}
	/**
	 * Write the specified pairs to an already started {@link Series#OBJECT object
	 * series}.
	 * @param <N> the name type in the pair
	 * @param <V> the value type in the pair
	 * @param pairs a callback that will be used to provide each pair. Typically a
	 * {@code forEach} method reference.
	 * @see #writePairs(Consumer)
	 */
	<N, V> void writePairs(Consumer<BiConsumer<N, V>> pairs) {
		pairs.accept(this::writePair);
	}
	private <N, V> void writePair(N name, V value) {
		this.path = this.path.child(name.toString());
		if (!isFilteredPath()) {
			String processedName = processName(name.toString());
			ActiveSeries activeSeries = this.activeSeries.peek();
			Assert.notNull(activeSeries, 'No series has been started');
			activeSeries.incrementIndexAndAddCommaIfRequired();
			writeString(processedName);
			append(':');
			write(value);
		}
		this.path = this.path.parent();
	}
	private void writeString(Object value) {
		try {
			this.out.append("'");
			String string = value.toString();
			for (int i = 0; i < string.length(); i++) {
				char ch = string.charAt(i);
				switch (ch) {
					case "'" -> this.out.append('\\\'');
					case "\\" -> this.out.append('\\\\');
					case "/" -> this.out.append('\\/');
					case "\b" -> this.out.append('\\b');
					case "\f" -> this.out.append('\\f');
					case "\n" -> this.out.append('\\n');
					case "\r" -> this.out.append('\\r');
					case "\t" -> this.out.append('\\t');
					default -> {
						if (Character.isISOControl(ch)) {
							this.out.append('\\u');
							this.out.append(String.format('%04X', (int) ch));
						}
						else {
							this.out.append(ch);
						}
					}
				}
			}
			this.out.append("'");
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private void append(String value) {
		try {
			this.out.append(value);
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private void append(char ch) {
		try {
			this.out.append(ch);
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private boolean isFilteredPath() {
		for (JsonWriterFiltersAndProcessors filtersAndProcessors : this.filtersAndProcessors) {
			for (Predicate<MemberPath> pathFilter : filtersAndProcessors.pathFilters()) {
				if (pathFilter.test(this.path)) {
					return true;
				}
			}
		}
		return false;
	}
	private String processName(String name) {
		for (JsonWriterFiltersAndProcessors filtersAndProcessors : this.filtersAndProcessors) {
			for (NameProcessor nameProcessor : filtersAndProcessors.nameProcessors()) {
				name = processName(name, nameProcessor);
			}
		}
		return name;
	}
	private String processName(String name, NameProcessor nameProcessor) {
		name = nameProcessor.processName(this.path, name);
		Assert.state(StringUtils.hasLength(name), 'NameProcessor ' + nameProcessor + ' returned an empty result');
		return name;
	}
	private <V> V processValue(V value) {
		for (JsonWriterFiltersAndProcessors filtersAndProcessors : this.filtersAndProcessors) {
			for (ValueProcessor<?> valueProcessor : filtersAndProcessors.valueProcessors()) {
				value = processValue(value, valueProcessor);
			}
		}
		return value;
	}
	@SuppressWarnings({ 'unchecked', 'unchecked' })
	private <V> V processValue(V value, ValueProcessor<?> valueProcessor) {
		return (V) LambdaSafe.callback(ValueProcessor.class, valueProcessor, this.path, value)
			.invokeAnd((call) -> call.processValue(this.path, value))
			.get(value);
	}
	/**
	 * A series of items that can be written to the JSON output.
	 */
	enum Series {
		/**
		 * A JSON object series consisting of name/value pairs.
		 */
		OBJECT("{", "}"),
		/**
		 * A JSON array series consisting of elements.
		 */
		ARRAY("[", "]");
		final char openChar;
		final char closeChar;
		Series(char openChar, char closeChar) {
			this.openChar = openChar;
			this.closeChar = closeChar;
		}
	}
	/**
	 * Details of the currently active {@link Series}.
	 */
	private final class ActiveSeries {
		private final Series series;
		private int index;
		private ActiveSeries(Series series) {
			this.series = series;
		}
		MemberPath updatePath(MemberPath path) {
			return (this.series != Series.ARRAY) ? path : path.child(this.index);
		}
		MemberPath restorePath(MemberPath path) {
			return (this.series != Series.ARRAY) ? path : path.parent();
		}
		void incrementIndexAndAddCommaIfRequired() {
			if (this.index > 0) {
				append(",");
			}
			this.index++;
		}
	}
}
/*
/**
package org.springframework.boot.json;
/*
package org.springframework.boot.json;
/**
public class JacksonJsonParser extends AbstractJsonParser {
	private static final MapTypeReference MAP_TYPE = new MapTypeReference();
	private static final ListTypeReference LIST_TYPE = new ListTypeReference();
	private ObjectMapper objectMapper; // Late binding
	/**
	 * Creates an instance with the specified {@link ObjectMapper}.
	 * @param objectMapper the object mapper to use
	 */
	public JacksonJsonParser(ObjectMapper objectMapper) {
		this.objectMapper = objectMapper;
	}
	/**
	 * Creates an instance with a default {@link ObjectMapper} that is created lazily.
	 */
	public JacksonJsonParser() {
	}
	@Override
	public Map<String, Object> parseMap(String json) {
		return tryParse(() -> getObjectMapper().readValue(json, MAP_TYPE), Exception.class);
	}
	@Override
	public List<Object> parseList(String json) {
		return tryParse(() -> getObjectMapper().readValue(json, LIST_TYPE), Exception.class);
	}
	private ObjectMapper getObjectMapper() {
		if (this.objectMapper == null) {
			this.objectMapper = new ObjectMapper();
		}
		return this.objectMapper;
	}
	private static final class MapTypeReference extends TypeReference<Map<String, Object>> {
	}
	private static final class ListTypeReference extends TypeReference<List<Object>> {
	}
}
/*
package org.springframework.boot.json;
/**
public class JsonParseException extends IllegalArgumentException {
	public JsonParseException() {
		this(null);
	}
	public JsonParseException(Throwable cause) {
		super('Cannot parse JSON', cause);
	}
}
/*
package org.springframework.boot.json;
/**
record JsonWriterFiltersAndProcessors(List<Predicate<MemberPath>> pathFilters, List<NameProcessor> nameProcessors,
		List<ValueProcessor<?>> valueProcessors) {
	JsonWriterFiltersAndProcessors() {
		this(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());
	}
}
/*
package org.springframework.boot;
/**
public enum WebApplicationType {
	/**
	 * The application should not run as a web application and should not start an
	 * embedded web server.
	 */
	NONE,
	/**
	 * The application should run as a servlet-based web application and should start an
	 * embedded servlet web server.
	 */
	SERVLET,
	/**
	 * The application should run as a reactive web application and should start an
	 * embedded reactive web server.
	 */
	REACTIVE;
	private static final String[] SERVLET_INDICATOR_CLASSES = { 'jakarta.servlet.Servlet',
			'org.springframework.web.context.ConfigurableWebApplicationContext' };
	private static final String WEBMVC_INDICATOR_CLASS = 'org.springframework.web.servlet.DispatcherServlet';
	private static final String WEBFLUX_INDICATOR_CLASS = 'org.springframework.web.reactive.DispatcherHandler';
	private static final String JERSEY_INDICATOR_CLASS = 'org.glassfish.jersey.servlet.ServletContainer';
	static WebApplicationType deduceFromClasspath() {
		if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
				&& !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
			return WebApplicationType.REACTIVE;
		}
		for (String className : SERVLET_INDICATOR_CLASSES) {
			if (!ClassUtils.isPresent(className, null)) {
				return WebApplicationType.NONE;
			}
		}
		return WebApplicationType.SERVLET;
	}
	static class WebApplicationTypeRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			for (String servletIndicatorClass : SERVLET_INDICATOR_CLASSES) {
				registerTypeIfPresent(servletIndicatorClass, classLoader, hints);
			}
			registerTypeIfPresent(JERSEY_INDICATOR_CLASS, classLoader, hints);
			registerTypeIfPresent(WEBFLUX_INDICATOR_CLASS, classLoader, hints);
			registerTypeIfPresent(WEBMVC_INDICATOR_CLASS, classLoader, hints);
		}
		private void registerTypeIfPresent(String typeName, ClassLoader classLoader, RuntimeHints hints) {
			if (ClassUtils.isPresent(typeName, classLoader)) {
				hints.reflection().registerType(TypeReference.of(typeName));
			}
		}
	}
}
/*
package org.springframework.boot;
/**
class DefaultApplicationContextFactory implements ApplicationContextFactory {
	@Override
	public Class<? extends ConfigurableEnvironment> getEnvironmentType(WebApplicationType webApplicationType) {
		return getFromSpringFactories(webApplicationType, ApplicationContextFactory::getEnvironmentType, null);
	}
	@Override
	public ConfigurableEnvironment createEnvironment(WebApplicationType webApplicationType) {
		return getFromSpringFactories(webApplicationType, ApplicationContextFactory::createEnvironment, null);
	}
	@Override
	public ConfigurableApplicationContext create(WebApplicationType webApplicationType) {
		try {
			return getFromSpringFactories(webApplicationType, ApplicationContextFactory::create,
					this::createDefaultApplicationContext);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable create a default ApplicationContext instance, '
					+ 'you may need a custom ApplicationContextFactory', ex);
		}
	}
	private ConfigurableApplicationContext createDefaultApplicationContext() {
		if (!AotDetector.useGeneratedArtifacts()) {
			return new AnnotationConfigApplicationContext();
		}
		return new GenericApplicationContext();
	}
	private <T> T getFromSpringFactories(WebApplicationType webApplicationType,
			BiFunction<ApplicationContextFactory, WebApplicationType, T> action, Supplier<T> defaultResult) {
		for (ApplicationContextFactory candidate : SpringFactoriesLoader.loadFactories(ApplicationContextFactory.class,
				getClass().getClassLoader())) {
			T result = action.apply(candidate, webApplicationType);
			if (result != null) {
				return result;
			}
		}
		return (defaultResult != null) ? defaultResult.get() : null;
	}
}
/*
package org.springframework.boot;
/**
interface Runner {
}
/*
package org.springframework.boot.r2dbc;
/**
@FunctionalInterface
public interface ConnectionFactoryDecorator {
	/**
	 * Decorates the given {@link ConnectionFactory}.
	 * @param delegate the connection factory which should be decorated
	 * @return the decorated connection factory
	 */
	ConnectionFactory decorate(ConnectionFactory delegate);
}
/*
package org.springframework.boot.r2dbc;
/**
public enum EmbeddedDatabaseConnection {
	/**
	 * No Connection.
	 */
	NONE(null, null, (options) -> false),
	/**
	 * H2 Database Connection.
	 */
	H2('io.r2dbc.h2.H2ConnectionFactoryProvider', 'r2dbc:h2:mem:///%s?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE',
			(options) -> options.getValue(ConnectionFactoryOptions.DRIVER).equals('h2')
					&& options.getValue(ConnectionFactoryOptions.PROTOCOL).equals('mem'));
	private final String driverClassName;
	private final String url;
	private final Predicate<ConnectionFactoryOptions> embedded;
	EmbeddedDatabaseConnection(String driverClassName, String url, Predicate<ConnectionFactoryOptions> embedded) {
		this.driverClassName = driverClassName;
		this.url = url;
		this.embedded = embedded;
	}
	/**
	 * Returns the driver class name.
	 * @return the driver class name
	 */
	public String getDriverClassName() {
		return this.driverClassName;
	}
	/**
	 * Returns the R2DBC URL for the connection using the specified {@code databaseName}.
	 * @param databaseName the name of the database
	 * @return the connection URL
	 */
	public String getUrl(String databaseName) {
		Assert.hasText(databaseName, 'DatabaseName must not be empty');
		return (this.url != null) ? String.format(this.url, databaseName) : null;
	}
	/**
	 * Returns the most suitable {@link EmbeddedDatabaseConnection} for the given class
	 * loader.
	 * @param classLoader the class loader used to check for classes
	 * @return an {@link EmbeddedDatabaseConnection} or {@link #NONE}.
	 */
	public static EmbeddedDatabaseConnection get(ClassLoader classLoader) {
		for (EmbeddedDatabaseConnection candidate : EmbeddedDatabaseConnection.values()) {
			if (candidate != NONE && ClassUtils.isPresent(candidate.getDriverClassName(), classLoader)) {
				return candidate;
			}
		}
		return NONE;
	}
	/**
	 * Convenience method to determine if a given connection factory represents an
	 * embedded database type.
	 * @param connectionFactory the connection factory to interrogate
	 * @return true if the connection factory represents an embedded database
	 * @since 2.5.1
	 */
	public static boolean isEmbedded(ConnectionFactory connectionFactory) {
		OptionsCapableConnectionFactory optionsCapable = OptionsCapableConnectionFactory.unwrapFrom(connectionFactory);
		Assert.notNull(optionsCapable,
				() -> 'Cannot determine database"s type as ConnectionFactory is not options-capable. To be '
						+ 'options-capable, a ConnectionFactory should be created with '
						+ ConnectionFactoryBuilder.class.getName());
		ConnectionFactoryOptions options = optionsCapable.getOptions();
		for (EmbeddedDatabaseConnection candidate : values()) {
			if (candidate.embedded.test(options)) {
				return true;
			}
		}
		return false;
	}
}
/*
/**
package org.springframework.boot.r2dbc;
/*
package org.springframework.boot.r2dbc;
/**
public class OptionsCapableConnectionFactory implements Wrapped<ConnectionFactory>, ConnectionFactory {
	private final ConnectionFactoryOptions options;
	private final ConnectionFactory delegate;
	/**
	 * Create a new {@code OptionsCapableConnectionFactory} that will provide access to
	 * the given {@code options} that were used to build the given {@code delegate}
	 * {@link ConnectionFactory}.
	 * @param options the options from which the connection factory was built
	 * @param delegate the delegate connection factory that was built with options
	 */
	public OptionsCapableConnectionFactory(ConnectionFactoryOptions options, ConnectionFactory delegate) {
		this.options = options;
		this.delegate = delegate;
	}
	public ConnectionFactoryOptions getOptions() {
		return this.options;
	}
	@Override
	public Publisher<? extends Connection> create() {
		return this.delegate.create();
	}
	@Override
	public ConnectionFactoryMetadata getMetadata() {
		return this.delegate.getMetadata();
	}
	@Override
	public ConnectionFactory unwrap() {
		return this.delegate;
	}
	/**
	 * Returns, if possible, an {@code OptionsCapableConnectionFactory} by unwrapping the
	 * given {@code connectionFactory} as necessary. If the given
	 * {@code connectionFactory} does not wrap an {@code OptionsCapableConnectionFactory}
	 * and is not itself an {@code OptionsCapableConnectionFactory}, {@code null} is
	 * returned.
	 * @param connectionFactory the connection factory to unwrap
	 * @return the {@code OptionsCapableConnectionFactory} or {@code null}
	 * @since 2.5.1
	 */
	public static OptionsCapableConnectionFactory unwrapFrom(ConnectionFactory connectionFactory) {
		if (connectionFactory instanceof OptionsCapableConnectionFactory optionsCapableConnectionFactory) {
			return optionsCapableConnectionFactory;
		}
		if (connectionFactory instanceof Wrapped<?> wrappedConnectionFactory) {
			Object unwrapped = wrappedConnectionFactory.unwrap();
			if (unwrapped instanceof ConnectionFactory unwrappedConnectionFactory) {
				return unwrapFrom(unwrappedConnectionFactory);
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.r2dbc;
/**
public final class ConnectionFactoryBuilder {
	private static final OptionsCapableWrapper optionsCapableWrapper;
	static {
		if (ClassUtils.isPresent('io.r2dbc.pool.ConnectionPool', ConnectionFactoryBuilder.class.getClassLoader())) {
			optionsCapableWrapper = new PoolingAwareOptionsCapableWrapper();
		}
		else {
			optionsCapableWrapper = new OptionsCapableWrapper();
		}
	}
	private static final String COLON = ':';
	private final Builder optionsBuilder;
	private final List<ConnectionFactoryDecorator> decorators = new ArrayList<>();
	private ConnectionFactoryBuilder(Builder optionsBuilder) {
		this.optionsBuilder = optionsBuilder;
	}
	/**
	 * Initialize a new {@link ConnectionFactoryBuilder} based on the specified R2DBC url.
	 * @param url the url to use
	 * @return a new builder initialized with the options exposed in the specified url
	 * @see EmbeddedDatabaseConnection#getUrl(String)
	 */
	public static ConnectionFactoryBuilder withUrl(String url) {
		Assert.hasText(url, () -> 'Url must not be null');
		return withOptions(ConnectionFactoryOptions.parse(url).mutate());
	}
	/**
	 * Initialize a new {@link ConnectionFactoryBuilder} based on the specified
	 * {@link Builder options}.
	 * @param options the options to use to initialize the builder
	 * @return a new builder initialized with the settings defined in the given
	 * {@link Builder options}
	 */
	public static ConnectionFactoryBuilder withOptions(Builder options) {
		return new ConnectionFactoryBuilder(options);
	}
	/**
	 * Initialize a new {@link ConnectionFactoryBuilder} derived from the options of the
	 * specified {@code connectionFactory}.
	 * @param connectionFactory the connection factory whose options are to be used to
	 * initialize the builder
	 * @return a new builder initialized with the options from the connection factory
	 * @since 2.5.1
	 */
	public static ConnectionFactoryBuilder derivedFrom(ConnectionFactory connectionFactory) {
		ConnectionFactoryOptions options = extractOptionsIfPossible(connectionFactory);
		if (options == null) {
			throw new IllegalArgumentException(
					'ConnectionFactoryOptions could not be extracted from ' + connectionFactory);
		}
		return withOptions(options.mutate());
	}
	private static ConnectionFactoryOptions extractOptionsIfPossible(ConnectionFactory connectionFactory) {
		OptionsCapableConnectionFactory optionsCapable = OptionsCapableConnectionFactory.unwrapFrom(connectionFactory);
		if (optionsCapable != null) {
			return optionsCapable.getOptions();
		}
		return null;
	}
	/**
	 * Configure additional options.
	 * @param options a {@link Consumer} to customize the options
	 * @return this for method chaining
	 */
	public ConnectionFactoryBuilder configure(Consumer<Builder> options) {
		options.accept(this.optionsBuilder);
		return this;
	}
	/**
	 * Configure the {@linkplain ConnectionFactoryOptions#USER username}.
	 * @param username the connection factory username
	 * @return this for method chaining
	 */
	public ConnectionFactoryBuilder username(String username) {
		return configure((options) -> options.option(ConnectionFactoryOptions.USER, username));
	}
	/**
	 * Configure the {@linkplain ConnectionFactoryOptions#PASSWORD password}.
	 * @param password the connection factory password
	 * @return this for method chaining
	 */
	public ConnectionFactoryBuilder password(CharSequence password) {
		return configure((options) -> options.option(ConnectionFactoryOptions.PASSWORD, password));
	}
	/**
	 * Configure the {@linkplain ConnectionFactoryOptions#HOST host name}.
	 * @param host the connection factory hostname
	 * @return this for method chaining
	 */
	public ConnectionFactoryBuilder hostname(String host) {
		return configure((options) -> options.option(ConnectionFactoryOptions.HOST, host));
	}
	/**
	 * Configure the {@linkplain ConnectionFactoryOptions#PORT port}.
	 * @param port the connection factory port
	 * @return this for method chaining
	 */
	public ConnectionFactoryBuilder port(int port) {
		return configure((options) -> options.option(ConnectionFactoryOptions.PORT, port));
	}
	/**
	 * Configure the {@linkplain ConnectionFactoryOptions#DATABASE database}.
	 * @param database the connection factory database
	 * @return this for method chaining
	 */
	public ConnectionFactoryBuilder database(String database) {
		return configure((options) -> options.option(ConnectionFactoryOptions.DATABASE, database));
	}
	/**
	 * Add a {@link ConnectionFactoryDecorator decorator}.
	 * @param decorator the decorator to add
	 * @return this for method chaining
	 * @since 3.2.0
	 */
	public ConnectionFactoryBuilder decorator(ConnectionFactoryDecorator decorator) {
		this.decorators.add(decorator);
		return this;
	}
	/**
	 * Add {@link ConnectionFactoryDecorator decorators}.
	 * @param decorators the decorators to add
	 * @return this for method chaining
	 * @since 3.2.0
	 */
	public ConnectionFactoryBuilder decorators(Iterable<ConnectionFactoryDecorator> decorators) {
		for (ConnectionFactoryDecorator decorator : decorators) {
			this.decorators.add(decorator);
		}
		return this;
	}
	/**
	 * Build a {@link ConnectionFactory} based on the state of this builder.
	 * @return a connection factory
	 */
	public ConnectionFactory build() {
		ConnectionFactoryOptions options = buildOptions();
		ConnectionFactory connectionFactory = optionsCapableWrapper.buildAndWrap(options);
		for (ConnectionFactoryDecorator decorator : this.decorators) {
			connectionFactory = decorator.decorate(connectionFactory);
		}
		return connectionFactory;
	}
	/**
	 * Build a {@link ConnectionFactoryOptions} based on the state of this builder.
	 * @return the options
	 */
	public ConnectionFactoryOptions buildOptions() {
		return this.optionsBuilder.build();
	}
	private static class OptionsCapableWrapper {
		ConnectionFactory buildAndWrap(ConnectionFactoryOptions options) {
			ConnectionFactory connectionFactory = ConnectionFactories.get(options);
			return new OptionsCapableConnectionFactory(options, connectionFactory);
		}
	}
	static final class PoolingAwareOptionsCapableWrapper extends OptionsCapableWrapper {
		private final PoolingConnectionFactoryProvider poolingProvider = new PoolingConnectionFactoryProvider();
		@Override
		ConnectionFactory buildAndWrap(ConnectionFactoryOptions options) {
			if (!this.poolingProvider.supports(options)) {
				return super.buildAndWrap(options);
			}
			ConnectionFactoryOptions delegateOptions = delegateFactoryOptions(options);
			ConnectionFactory connectionFactory = super.buildAndWrap(delegateOptions);
			ConnectionPoolConfiguration poolConfiguration = connectionPoolConfiguration(delegateOptions,
					connectionFactory);
			return new ConnectionPool(poolConfiguration);
		}
		private ConnectionFactoryOptions delegateFactoryOptions(ConnectionFactoryOptions options) {
			String protocol = toString(options.getRequiredValue(ConnectionFactoryOptions.PROTOCOL));
			if (protocol.trim().isEmpty()) {
				throw new IllegalArgumentException(String.format('Protocol %s is not valid.', protocol));
			}
			String[] protocols = protocol.split(COLON, 2);
			String driverDelegate = protocols[0];
			String protocolDelegate = (protocols.length != 2) ? '' : protocols[1];
			return ConnectionFactoryOptions.builder()
				.from(options)
				.option(ConnectionFactoryOptions.DRIVER, driverDelegate)
				.option(ConnectionFactoryOptions.PROTOCOL, protocolDelegate)
				.build();
		}
		@SuppressWarnings('unchecked')
		ConnectionPoolConfiguration connectionPoolConfiguration(ConnectionFactoryOptions options,
				ConnectionFactory connectionFactory) {
			ConnectionPoolConfiguration.Builder builder = ConnectionPoolConfiguration.builder(connectionFactory);
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(options.getValue(PoolingConnectionFactoryProvider.BACKGROUND_EVICTION_INTERVAL))
				.as(this::toDuration)
				.to(builder::backgroundEvictionInterval);
			map.from(options.getValue(PoolingConnectionFactoryProvider.INITIAL_SIZE))
				.as(this::toInteger)
				.to(builder::initialSize);
			map.from(options.getValue(PoolingConnectionFactoryProvider.MAX_SIZE))
				.as(this::toInteger)
				.to(builder::maxSize);
			map.from(options.getValue(PoolingConnectionFactoryProvider.ACQUIRE_RETRY))
				.as(this::toInteger)
				.to(builder::acquireRetry);
			map.from(options.getValue(PoolingConnectionFactoryProvider.MAX_LIFE_TIME))
				.as(this::toDuration)
				.to(builder::maxLifeTime);
			map.from(options.getValue(PoolingConnectionFactoryProvider.MAX_ACQUIRE_TIME))
				.as(this::toDuration)
				.to(builder::maxAcquireTime);
			map.from(options.getValue(PoolingConnectionFactoryProvider.MAX_IDLE_TIME))
				.as(this::toDuration)
				.to(builder::maxIdleTime);
			map.from(options.getValue(PoolingConnectionFactoryProvider.MAX_CREATE_CONNECTION_TIME))
				.as(this::toDuration)
				.to(builder::maxCreateConnectionTime);
			map.from(options.getValue(PoolingConnectionFactoryProvider.MAX_VALIDATION_TIME))
				.as(this::toDuration)
				.to(builder::maxValidationTime);
			map.from(options.getValue(PoolingConnectionFactoryProvider.MIN_IDLE))
				.as(this::toInteger)
				.to(builder::minIdle);
			map.from(options.getValue(PoolingConnectionFactoryProvider.POOL_NAME)).as(this::toString).to(builder::name);
			map.from(options.getValue(PoolingConnectionFactoryProvider.PRE_RELEASE))
				.to((function) -> builder
					.preRelease((Function<? super Connection, ? extends Publisher<Void>>) function));
			map.from(options.getValue(PoolingConnectionFactoryProvider.POST_ALLOCATE))
				.to((function) -> builder
					.postAllocate((Function<? super Connection, ? extends Publisher<Void>>) function));
			map.from(options.getValue(PoolingConnectionFactoryProvider.REGISTER_JMX))
				.as(this::toBoolean)
				.to(builder::registerJmx);
			map.from(options.getValue(PoolingConnectionFactoryProvider.VALIDATION_QUERY))
				.as(this::toString)
				.to(builder::validationQuery);
			map.from(options.getValue(PoolingConnectionFactoryProvider.VALIDATION_DEPTH))
				.as(this::toValidationDepth)
				.to(builder::validationDepth);
			return builder.build();
		}
		private String toString(Object object) {
			return toType(String.class, object, String::valueOf);
		}
		private Integer toInteger(Object object) {
			return toType(Integer.class, object, Integer::valueOf);
		}
		private Duration toDuration(Object object) {
			return toType(Duration.class, object, Duration::parse);
		}
		private Boolean toBoolean(Object object) {
			return toType(Boolean.class, object, Boolean::valueOf);
		}
		private ValidationDepth toValidationDepth(Object object) {
			return toType(ValidationDepth.class, object,
					(string) -> ValidationDepth.valueOf(string.toUpperCase(Locale.ENGLISH)));
		}
		private <T> T toType(Class<T> type, Object object, Function<String, T> converter) {
			if (type.isInstance(object)) {
				return type.cast(object);
			}
			if (object instanceof String string) {
				return converter.apply(string);
			}
			throw new IllegalArgumentException('Cannot convert "' + object + '" to ' + type.getName());
		}
	}
}
/*
package org.springframework.boot.r2dbc.init;
/**
public class R2dbcScriptDatabaseInitializer extends AbstractScriptDatabaseInitializer {
	private final ConnectionFactory connectionFactory;
	/**
	 * Creates a new {@code R2dbcScriptDatabaseInitializer} that will initialize the
	 * database recognized by the given {@code connectionFactory} using the given
	 * {@code settings}.
	 * @param connectionFactory connectionFactory for the database
	 * @param settings initialization settings
	 */
	public R2dbcScriptDatabaseInitializer(ConnectionFactory connectionFactory,
			DatabaseInitializationSettings settings) {
		super(settings);
		this.connectionFactory = connectionFactory;
	}
	@Override
	protected boolean isEmbeddedDatabase() {
		return EmbeddedDatabaseConnection.isEmbedded(this.connectionFactory);
	}
	@Override
	protected void runScripts(Scripts scripts) {
		ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
		populator.setContinueOnError(scripts.isContinueOnError());
		populator.setSeparator(scripts.getSeparator());
		if (scripts.getEncoding() != null) {
			populator.setSqlScriptEncoding(scripts.getEncoding().name());
		}
		for (Resource script : scripts) {
			populator.addScript(script);
		}
		populator.populate(this.connectionFactory).block();
	}
}
/*
package org.springframework.boot.r2dbc.init;
/**
class R2dbcScriptDatabaseInitializerDetector extends AbstractBeansOfTypeDatabaseInitializerDetector {
	@Override
	protected Set<Class<?>> getDatabaseInitializerBeanTypes() {
		return Collections.singleton(R2dbcScriptDatabaseInitializer.class);
	}
}
/*
/**
package org.springframework.boot.r2dbc.init;
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface Banner {
	/**
	 * Print the banner to the specified print stream.
	 * @param environment the spring environment
	 * @param sourceClass the source class for the application
	 * @param out the output print stream
	 */
	void printBanner(Environment environment, Class<?> sourceClass, PrintStream out);
	/**
	 * An enumeration of possible values for configuring the Banner.
	 */
	enum Mode {
		/**
		 * Disable printing of the banner.
		 */
		OFF,
		/**
		 * Print the banner to System.out.
		 */
		CONSOLE,
		/**
		 * Print the banner to the log file.
		 */
		LOG
	}
}
/*
package org.springframework.boot;
/**
class SpringBootBanner implements Banner {
	private static final String BANNER = '''
			  .   ____          _            __ _ _
			 /\\\\ / ___"_ __ _ _(_)_ __  __ _ \\ \\ \\ \\
			( ( )\\___ | "_ | "_| | "_ \\/ _` | \\ \\ \\ \\
			 \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )
			  "  |____| .__|_| |_|_| |_\\__, | / / / /
			 =========|_|==============|___/=/_/_/_/
			''';
	private static final String SPRING_BOOT = ' :: Spring Boot :: ';
	private static final int STRAP_LINE_SIZE = 42;
	@Override
	public void printBanner(Environment environment, Class<?> sourceClass, PrintStream printStream) {
		printStream.println();
		printStream.println(BANNER);
		String version = String.format(' (v%s)', SpringBootVersion.getVersion());
		String padding = ' '.repeat(Math.max(0, STRAP_LINE_SIZE - (version.length() + SPRING_BOOT.length())));
		printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT, AnsiColor.DEFAULT, padding,
				AnsiStyle.FAINT, version));
		printStream.println();
	}
}
/*
package org.springframework.boot.rsocket.messaging;
/**
@FunctionalInterface
public interface RSocketStrategiesCustomizer {
	/**
	 * Callback to customize a {@link RSocketStrategies#builder()} instance.
	 * @param strategies rSocket codec strategies to customize
	 */
	void customize(RSocketStrategies.Builder strategies);
}
/*
/**
package org.springframework.boot.rsocket.messaging;
/*
package org.springframework.boot.rsocket.context;
/**
public class RSocketServerInitializedEvent extends ApplicationEvent {
	public RSocketServerInitializedEvent(RSocketServer server) {
		super(server);
	}
	/**
	 * Access the {@link RSocketServer}.
	 * @return the embedded RSocket server
	 */
	public RSocketServer getServer() {
		return getSource();
	}
	/**
	 * Access the source of the event (an {@link RSocketServer}).
	 * @return the embedded web server
	 */
	@Override
	public RSocketServer getSource() {
		return (RSocketServer) super.getSource();
	}
}
/*
package org.springframework.boot.rsocket.context;
/**
public class RSocketServerBootstrap implements ApplicationEventPublisherAware, SmartLifecycle {
	private final RSocketServer server;
	private ApplicationEventPublisher eventPublisher;
	public RSocketServerBootstrap(RSocketServerFactory serverFactory, SocketAcceptor socketAcceptor) {
		Assert.notNull(serverFactory, 'ServerFactory must not be null');
		this.server = serverFactory.create(socketAcceptor);
	}
	@Override
	public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
		this.eventPublisher = applicationEventPublisher;
	}
	@Override
	public void start() {
		this.server.start();
		this.eventPublisher.publishEvent(new RSocketServerInitializedEvent(this.server));
	}
	@Override
	public void stop() {
		this.server.stop();
	}
	@Override
	public boolean isRunning() {
		RSocketServer server = this.server;
		if (server != null) {
			return server.address() != null;
		}
		return false;
	}
}
/*
package org.springframework.boot.rsocket.context;
/**
public class RSocketPortInfoApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		applicationContext.addApplicationListener(new Listener(applicationContext));
	}
	private static class Listener implements ApplicationListener<RSocketServerInitializedEvent> {
		private static final String PROPERTY_NAME = 'local.rsocket.server.port';
		private static final String PROPERTY_SOURCE_NAME = 'server.ports';
		private final ConfigurableApplicationContext applicationContext;
		Listener(ConfigurableApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Override
		public void onApplicationEvent(RSocketServerInitializedEvent event) {
			if (event.getServer().address() != null) {
				setPortProperty(this.applicationContext, event.getServer().address().getPort());
			}
		}
		private void setPortProperty(ApplicationContext context, int port) {
			if (context instanceof ConfigurableApplicationContext configurableContext) {
				setPortProperty(configurableContext.getEnvironment(), port);
			}
			if (context.getParent() != null) {
				setPortProperty(context.getParent(), port);
			}
		}
		private void setPortProperty(ConfigurableEnvironment environment, int port) {
			MutablePropertySources sources = environment.getPropertySources();
			PropertySource<?> source = sources.get(PROPERTY_SOURCE_NAME);
			if (source == null) {
				source = new MapPropertySource(PROPERTY_SOURCE_NAME, new HashMap<>());
				sources.addFirst(source);
			}
			setPortProperty(port, source);
		}
		@SuppressWarnings('unchecked')
		private void setPortProperty(int port, PropertySource<?> source) {
			((Map<String, Object>) source.getSource()).put(PROPERTY_NAME, port);
		}
	}
}
/*
/**
package org.springframework.boot.rsocket.context;
/*
package org.springframework.boot.rsocket.server;
/**
@FunctionalInterface
public interface RSocketServerFactory {
	/**
	 * Gets a new fully configured but paused {@link RSocketServer} instance. Clients
	 * should not be able to connect to the returned server until
	 * {@link RSocketServer#start()} is called (which happens when the
	 * {@code ApplicationContext} has been fully refreshed).
	 * @param socketAcceptor the socket acceptor
	 * @return a fully configured and started {@link RSocketServer}
	 * @see RSocketServer#stop()
	 */
	RSocketServer create(SocketAcceptor socketAcceptor);
}
/*
package org.springframework.boot.rsocket.server;
/**
public interface RSocketServer {
	/**
	 * Starts the RSocket server. Calling this method on an already started server has no
	 * effect.
	 * @throws RSocketServerException if the server cannot be started
	 */
	void start() throws RSocketServerException;
	/**
	 * Stops the RSocket server. Calling this method on an already stopped server has no
	 * effect.
	 * @throws RSocketServerException if the server cannot be stopped
	 */
	void stop() throws RSocketServerException;
	/**
	 * Return the address this server is listening on.
	 * @return the address
	 */
	InetSocketAddress address();
	/**
	 * Choice of transport protocol for the RSocket server.
	 */
	enum Transport {
		/**
		 * TCP transport protocol.
		 */
		TCP,
		/**
		 * WebSocket transport protocol.
		 */
		WEBSOCKET
	}
}
/*
package org.springframework.boot.rsocket.server;
/**
public class RSocketServerException extends RuntimeException {
	public RSocketServerException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.rsocket.server;
/**
public interface ConfigurableRSocketServerFactory {
	/**
	 * Set the port that the server should listen on. If not specified port "9898" will be
	 * used.
	 * @param port the port to set
	 */
	void setPort(int port);
	/**
	 * Specify the maximum transmission unit. Frames larger than the specified
	 * {@code fragmentSize} are fragmented.
	 * @param fragmentSize the fragment size
	 * @since 2.4.0
	 */
	void setFragmentSize(DataSize fragmentSize);
	/**
	 * Set the specific network address that the server should bind to.
	 * @param address the address to set (defaults to {@code null})
	 */
	void setAddress(InetAddress address);
	/**
	 * Set the transport that the RSocket server should use.
	 * @param transport the transport protocol to use
	 */
	void setTransport(RSocketServer.Transport transport);
	/**
	 * Sets the SSL configuration that will be applied to the server"s default connector.
	 * @param ssl the SSL configuration
	 */
	void setSsl(Ssl ssl);
	/**
	 * Sets an SSL bundle that can be used to get SSL configuration.
	 * @param sslBundles the SSL bundles
	 * @since 3.1.0
	 */
	void setSslBundles(SslBundles sslBundles);
}
/*
package org.springframework.boot.rsocket.server;
/**
@FunctionalInterface
public interface RSocketServerCustomizer {
	/**
	 * Callback to customize a {@link RSocketServer} instance.
	 * @param rSocketServer the RSocket server to customize
	 */
	void customize(RSocketServer rSocketServer);
}
/*
/**
package org.springframework.boot.rsocket.server;
/*
package org.springframework.boot.rsocket.netty;
/**
public class NettyRSocketServerFactory implements RSocketServerFactory, ConfigurableRSocketServerFactory {
	private int port = 9898;
	private DataSize fragmentSize;
	private InetAddress address;
	private RSocketServer.Transport transport = RSocketServer.Transport.TCP;
	private ReactorResourceFactory resourceFactory;
	private Duration lifecycleTimeout;
	private List<RSocketServerCustomizer> rSocketServerCustomizers = new ArrayList<>();
	private Ssl ssl;
	private SslBundles sslBundles;
	@Override
	public void setPort(int port) {
		this.port = port;
	}
	@Override
	public void setFragmentSize(DataSize fragmentSize) {
		this.fragmentSize = fragmentSize;
	}
	@Override
	public void setAddress(InetAddress address) {
		this.address = address;
	}
	@Override
	public void setTransport(RSocketServer.Transport transport) {
		this.transport = transport;
	}
	@Override
	public void setSsl(Ssl ssl) {
		this.ssl = ssl;
	}
	@Override
	public void setSslBundles(SslBundles sslBundles) {
		this.sslBundles = sslBundles;
	}
	/**
	 * Set the {@link ReactorResourceFactory} to get the shared resources from.
	 * @param resourceFactory the server resources
	 */
	public void setResourceFactory(ReactorResourceFactory resourceFactory) {
		this.resourceFactory = resourceFactory;
	}
	/**
	 * Set {@link RSocketServerCustomizer}s that should be called to configure the
	 * {@link io.rsocket.core.RSocketServer} while building the server. Calling this
	 * method will replace any existing customizers.
	 * @param rSocketServerCustomizers customizers to apply before the server starts
	 * @since 2.2.7
	 */
	public void setRSocketServerCustomizers(Collection<? extends RSocketServerCustomizer> rSocketServerCustomizers) {
		Assert.notNull(rSocketServerCustomizers, 'RSocketServerCustomizers must not be null');
		this.rSocketServerCustomizers = new ArrayList<>(rSocketServerCustomizers);
	}
	/**
	 * Add {@link RSocketServerCustomizer}s that should be called to configure the
	 * {@link io.rsocket.core.RSocketServer}.
	 * @param rSocketServerCustomizers customizers to apply before the server starts
	 * @since 2.2.7
	 */
	public void addRSocketServerCustomizers(RSocketServerCustomizer... rSocketServerCustomizers) {
		Assert.notNull(rSocketServerCustomizers, 'RSocketServerCustomizers must not be null');
		this.rSocketServerCustomizers.addAll(Arrays.asList(rSocketServerCustomizers));
	}
	/**
	 * Set the maximum amount of time that should be waited when starting or stopping the
	 * server.
	 * @param lifecycleTimeout the lifecycle timeout
	 */
	public void setLifecycleTimeout(Duration lifecycleTimeout) {
		this.lifecycleTimeout = lifecycleTimeout;
	}
	@Override
	public NettyRSocketServer create(SocketAcceptor socketAcceptor) {
		ServerTransport<CloseableChannel> transport = createTransport();
		io.rsocket.core.RSocketServer server = io.rsocket.core.RSocketServer.create(socketAcceptor);
		configureServer(server);
		Mono<CloseableChannel> starter = server.bind(transport);
		return new NettyRSocketServer(starter, this.lifecycleTimeout);
	}
	private void configureServer(io.rsocket.core.RSocketServer server) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.fragmentSize).asInt(DataSize::toBytes).to(server::fragment);
		this.rSocketServerCustomizers.forEach((customizer) -> customizer.customize(server));
	}
	private ServerTransport<CloseableChannel> createTransport() {
		if (this.transport == RSocketServer.Transport.WEBSOCKET) {
			return createWebSocketTransport();
		}
		return createTcpTransport();
	}
	private ServerTransport<CloseableChannel> createWebSocketTransport() {
		HttpServer httpServer = HttpServer.create();
		if (this.resourceFactory != null) {
			httpServer = httpServer.runOn(this.resourceFactory.getLoopResources());
		}
		if (Ssl.isEnabled(this.ssl)) {
			httpServer = customizeSslConfiguration(httpServer);
		}
		return WebsocketServerTransport.create(httpServer.bindAddress(this::getListenAddress));
	}
	private HttpServer customizeSslConfiguration(HttpServer httpServer) {
		return new SslServerCustomizer(null, this.ssl.getClientAuth(), getSslBundle(), getServerNameSslBundles())
			.apply(httpServer);
	}
	private ServerTransport<CloseableChannel> createTcpTransport() {
		TcpServer tcpServer = TcpServer.create();
		if (this.resourceFactory != null) {
			tcpServer = tcpServer.runOn(this.resourceFactory.getLoopResources());
		}
		if (Ssl.isEnabled(this.ssl)) {
			tcpServer = new TcpSslServerCustomizer(this.ssl.getClientAuth(), getSslBundle(), getServerNameSslBundles())
				.apply(tcpServer);
		}
		return TcpServerTransport.create(tcpServer.bindAddress(this::getListenAddress));
	}
	private SslBundle getSslBundle() {
		return WebServerSslBundle.get(this.ssl, this.sslBundles);
	}
	protected final Map<String, SslBundle> getServerNameSslBundles() {
		return this.ssl.getServerNameBundles()
			.stream()
			.collect(Collectors.toMap(Ssl.ServerNameSslBundle::serverName, this::getBundle));
	}
	private SslBundle getBundle(ServerNameSslBundle serverNameSslBundle) {
		return this.sslBundles.getBundle(serverNameSslBundle.bundle());
	}
	private InetSocketAddress getListenAddress() {
		if (this.address != null) {
			return new InetSocketAddress(this.address.getHostAddress(), this.port);
		}
		return new InetSocketAddress(this.port);
	}
	private static final class TcpSslServerCustomizer
			extends org.springframework.boot.web.embedded.netty.SslServerCustomizer {
		private final SslBundle sslBundle;
		private TcpSslServerCustomizer(ClientAuth clientAuth, SslBundle sslBundle,
				Map<String, SslBundle> serverNameSslBundles) {
			super(null, clientAuth, sslBundle, serverNameSslBundles);
			this.sslBundle = sslBundle;
		}
		private TcpServer apply(TcpServer server) {
			GenericSslContextSpec<?> sslContextSpec = createSslContextSpec(this.sslBundle);
			return server.secure((spec) -> spec.sslContext(sslContextSpec));
		}
	}
}
/*
package org.springframework.boot.rsocket.netty;
/**
public class NettyRSocketServer implements RSocketServer {
	private static final Log logger = LogFactory.getLog(NettyRSocketServer.class);
	private final Mono<CloseableChannel> starter;
	private final Duration lifecycleTimeout;
	private CloseableChannel channel;
	public NettyRSocketServer(Mono<CloseableChannel> starter, Duration lifecycleTimeout) {
		Assert.notNull(starter, 'starter must not be null');
		this.starter = starter;
		this.lifecycleTimeout = lifecycleTimeout;
	}
	@Override
	public InetSocketAddress address() {
		if (this.channel != null) {
			return this.channel.address();
		}
		return null;
	}
	@Override
	public void start() throws RSocketServerException {
		this.channel = block(this.starter, this.lifecycleTimeout);
		logger.info('Netty RSocket started on port ' + address().getPort());
		startDaemonAwaitThread(this.channel);
	}
	private void startDaemonAwaitThread(CloseableChannel channel) {
		Thread awaitThread = new Thread(() -> channel.onClose().block(), 'rsocket');
		awaitThread.setContextClassLoader(getClass().getClassLoader());
		awaitThread.setDaemon(false);
		awaitThread.start();
	}
	@Override
	public void stop() throws RSocketServerException {
		if (this.channel != null) {
			this.channel.dispose();
			this.channel = null;
		}
	}
	private <T> T block(Mono<T> mono, Duration timeout) {
		return (timeout != null) ? mono.block(timeout) : mono.block();
	}
}
/*
/**
package org.springframework.boot.rsocket.netty;
/*
/**
package org.springframework.boot;
/*
package org.springframework.boot.diagnostics;
/**
public final class LoggingFailureAnalysisReporter implements FailureAnalysisReporter {
	private static final Log logger = LogFactory.getLog(LoggingFailureAnalysisReporter.class);
	@Override
	public void report(FailureAnalysis failureAnalysis) {
		if (logger.isDebugEnabled()) {
			logger.debug('Application failed to start due to an exception', failureAnalysis.getCause());
		}
		if (logger.isErrorEnabled()) {
			logger.error(buildMessage(failureAnalysis));
		}
	}
	private String buildMessage(FailureAnalysis failureAnalysis) {
		StringBuilder builder = new StringBuilder();
		builder.append(String.format('%n%n'));
		builder.append(String.format('***************************%n'));
		builder.append(String.format('APPLICATION FAILED TO START%n'));
		builder.append(String.format('***************************%n%n'));
		builder.append(String.format('Description:%n%n'));
		builder.append(String.format('%s%n', failureAnalysis.getDescription()));
		if (StringUtils.hasText(failureAnalysis.getAction())) {
			builder.append(String.format('%nAction:%n%n'));
			builder.append(String.format('%s%n', failureAnalysis.getAction()));
		}
		return builder.toString();
	}
}
/*
package org.springframework.boot.diagnostics;
/**
final class FailureAnalyzers implements SpringBootExceptionReporter {
	private static final Log logger = LogFactory.getLog(FailureAnalyzers.class);
	private final SpringFactoriesLoader springFactoriesLoader;
	private final List<FailureAnalyzer> analyzers;
	public FailureAnalyzers(ConfigurableApplicationContext context) {
		this(context,
				SpringFactoriesLoader.forDefaultResourceLocation((context != null) ? context.getClassLoader() : null));
	}
	FailureAnalyzers(ConfigurableApplicationContext context, SpringFactoriesLoader springFactoriesLoader) {
		this.springFactoriesLoader = springFactoriesLoader;
		this.analyzers = loadFailureAnalyzers(context, this.springFactoriesLoader);
	}
	private static List<FailureAnalyzer> loadFailureAnalyzers(ConfigurableApplicationContext context,
			SpringFactoriesLoader springFactoriesLoader) {
		return springFactoriesLoader.load(FailureAnalyzer.class, getArgumentResolver(context),
				FailureHandler.logging(logger));
	}
	private static ArgumentResolver getArgumentResolver(ConfigurableApplicationContext context) {
		if (context == null) {
			return null;
		}
		ArgumentResolver argumentResolver = ArgumentResolver.of(BeanFactory.class, context.getBeanFactory());
		argumentResolver = argumentResolver.and(Environment.class, context.getEnvironment());
		return argumentResolver;
	}
	@Override
	public boolean reportException(Throwable failure) {
		FailureAnalysis analysis = analyze(failure, this.analyzers);
		return report(analysis);
	}
	private FailureAnalysis analyze(Throwable failure, List<FailureAnalyzer> analyzers) {
		for (FailureAnalyzer analyzer : analyzers) {
			try {
				FailureAnalysis analysis = analyzer.analyze(failure);
				if (analysis != null) {
					return analysis;
				}
			}
			catch (Throwable ex) {
				logger.trace(LogMessage.format('FailureAnalyzer %s failed', analyzer), ex);
			}
		}
		return null;
	}
	private boolean report(FailureAnalysis analysis) {
		List<FailureAnalysisReporter> reporters = this.springFactoriesLoader.load(FailureAnalysisReporter.class);
		if (analysis == null || reporters.isEmpty()) {
			return false;
		}
		for (FailureAnalysisReporter reporter : reporters) {
			reporter.report(analysis);
		}
		return true;
	}
}
/*
package org.springframework.boot.diagnostics;
/**
public class FailureAnalysis {
	private final String description;
	private final String action;
	private final Throwable cause;
	/**
	 * Creates a new {@code FailureAnalysis} with the given {@code description} and
	 * {@code action}, if any, that the user should take to address the problem. The
	 * failure had the given underlying {@code cause}.
	 * @param description the description
	 * @param action the action
	 * @param cause the cause
	 */
	public FailureAnalysis(String description, String action, Throwable cause) {
		this.description = description;
		this.action = action;
		this.cause = cause;
	}
	/**
	 * Returns a description of the failure.
	 * @return the description
	 */
	public String getDescription() {
		return this.description;
	}
	/**
	 * Returns the action, if any, to be taken to address the failure.
	 * @return the action or {@code null}
	 */
	public String getAction() {
		return this.action;
	}
	/**
	 * Returns the cause of the failure.
	 * @return the cause
	 */
	public Throwable getCause() {
		return this.cause;
	}
}
/*
package org.springframework.boot.diagnostics;
/**
public abstract class AbstractFailureAnalyzer<T extends Throwable> implements FailureAnalyzer {
	@Override
	public FailureAnalysis analyze(Throwable failure) {
		T cause = findCause(failure, getCauseType());
		return (cause != null) ? analyze(failure, cause) : null;
	}
	/**
	 * Returns an analysis of the given {@code rootFailure}, or {@code null} if no
	 * analysis was possible.
	 * @param rootFailure the root failure passed to the analyzer
	 * @param cause the actual found cause
	 * @return the analysis or {@code null}
	 */
	protected abstract FailureAnalysis analyze(Throwable rootFailure, T cause);
	/**
	 * Return the cause type being handled by the analyzer. By default the class generic
	 * is used.
	 * @return the cause type
	 */
	@SuppressWarnings('unchecked')
	protected Class<? extends T> getCauseType() {
		return (Class<? extends T>) ResolvableType.forClass(AbstractFailureAnalyzer.class, getClass()).resolveGeneric();
	}
	@SuppressWarnings('unchecked')
	protected final <E extends Throwable> E findCause(Throwable failure, Class<E> type) {
		while (failure != null) {
			if (type.isInstance(failure)) {
				return (E) failure;
			}
			failure = failure.getCause();
		}
		return null;
	}
}
/*
package org.springframework.boot.diagnostics;
/**
@FunctionalInterface
public interface FailureAnalysisReporter {
	/**
	 * Reports the given {@code failureAnalysis} to the user.
	 * @param analysis the analysis
	 */
	void report(FailureAnalysis analysis);
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
@Order(Ordered.LOWEST_PRECEDENCE)
class MissingParameterNamesFailureAnalyzer implements FailureAnalyzer {
	private static final String USE_PARAMETERS_MESSAGE = 'Ensure that the compiler uses the "-parameters" flag';
	static final String POSSIBILITY = 'This may be due to missing parameter name information';
	static final String ACTION = '''
			Ensure that your compiler is configured to use the "-parameters" flag.
			You may need to update both your build tool settings as well as your IDE.
			(See https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-6.x#parameter-name-retention)
							''';
	@Override
	public FailureAnalysis analyze(Throwable failure) {
		return analyzeForMissingParameters(failure);
	}
	/**
	 * Analyze the given failure for missing parameter name exceptions.
	 * @param failure the failure to analyze
	 * @return a failure analysis or {@code null}
	 */
	static FailureAnalysis analyzeForMissingParameters(Throwable failure) {
		return analyzeForMissingParameters(failure, failure, new HashSet<>());
	}
	private static FailureAnalysis analyzeForMissingParameters(Throwable rootFailure, Throwable cause,
			Set<Throwable> seen) {
		if (cause != null && seen.add(cause)) {
			if (isSpringParametersException(cause)) {
				return getAnalysis(rootFailure, cause);
			}
			FailureAnalysis analysis = analyzeForMissingParameters(rootFailure, cause.getCause(), seen);
			if (analysis != null) {
				return analysis;
			}
			for (Throwable suppressed : cause.getSuppressed()) {
				analysis = analyzeForMissingParameters(rootFailure, suppressed, seen);
				if (analysis != null) {
					return analysis;
				}
			}
		}
		return null;
	}
	private static boolean isSpringParametersException(Throwable failure) {
		String message = failure.getMessage();
		return message != null && message.contains(USE_PARAMETERS_MESSAGE) && isSpringException(failure);
	}
	private static boolean isSpringException(Throwable failure) {
		StackTraceElement[] elements = failure.getStackTrace();
		return elements.length > 0 && isSpringClass(elements[0].getClassName());
	}
	private static boolean isSpringClass(String className) {
		return className != null && className.startsWith('org.springframework.');
	}
	private static FailureAnalysis getAnalysis(Throwable rootFailure, Throwable cause) {
		StringBuilder description = new StringBuilder(String.format('%s:%n', cause.getMessage()));
		if (rootFailure != cause) {
			description.append(String.format('%n    Resulting Failure: %s', getExceptionTypeAndMessage(rootFailure)));
		}
		return new FailureAnalysis(description.toString(), ACTION, rootFailure);
	}
	private static String getExceptionTypeAndMessage(Throwable ex) {
		String message = ex.getMessage();
		return ex.getClass().getName() + (StringUtils.hasText(message) ? ': ' + message : '');
	}
	static void appendPossibility(StringBuilder description) {
		if (!description.toString().endsWith(System.lineSeparator())) {
			description.append('%n'.formatted());
		}
		description.append('%n%s'.formatted(POSSIBILITY));
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class ValidationExceptionFailureAnalyzer extends AbstractFailureAnalyzer<ValidationException> {
	private static final String JAVAX_MISSING_IMPLEMENTATION_MESSAGE = 'Unable to create a '
			+ 'Configuration, because no Bean Validation provider could be found';
	private static final String JAKARTA_MISSING_IMPLEMENTATION_MESSAGE = 'Unable to create a '
			+ 'Configuration, because no Jakarta Bean Validation provider could be found';
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, ValidationException cause) {
		if (cause.getMessage().startsWith(JAVAX_MISSING_IMPLEMENTATION_MESSAGE)
				|| cause.getMessage().startsWith(JAKARTA_MISSING_IMPLEMENTATION_MESSAGE)) {
			return new FailureAnalysis(
					'The Bean Validation API is on the classpath but no implementation could be found',
					'Add an implementation, such as Hibernate Validator, to the classpath', cause);
		}
		return null;
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
public abstract class AbstractInjectionFailureAnalyzer<T extends Throwable> extends AbstractFailureAnalyzer<T> {
	@Override
	protected final FailureAnalysis analyze(Throwable rootFailure, T cause) {
		return analyze(rootFailure, cause, getDescription(rootFailure));
	}
	private String getDescription(Throwable rootFailure) {
		UnsatisfiedDependencyException unsatisfiedDependency = findMostNestedCause(rootFailure,
				UnsatisfiedDependencyException.class);
		if (unsatisfiedDependency != null) {
			return getDescription(unsatisfiedDependency);
		}
		BeanInstantiationException beanInstantiationException = findMostNestedCause(rootFailure,
				BeanInstantiationException.class);
		if (beanInstantiationException != null) {
			return getDescription(beanInstantiationException);
		}
		return null;
	}
	@SuppressWarnings('unchecked')
	private <C extends Exception> C findMostNestedCause(Throwable root, Class<C> type) {
		Throwable candidate = root;
		C result = null;
		while (candidate != null) {
			if (type.isAssignableFrom(candidate.getClass())) {
				result = (C) candidate;
			}
			candidate = candidate.getCause();
		}
		return result;
	}
	private String getDescription(UnsatisfiedDependencyException ex) {
		InjectionPoint injectionPoint = ex.getInjectionPoint();
		if (injectionPoint != null) {
			if (injectionPoint.getField() != null) {
				return String.format('Field %s in %s', injectionPoint.getField().getName(),
						injectionPoint.getField().getDeclaringClass().getName());
			}
			if (injectionPoint.getMethodParameter() != null) {
				if (injectionPoint.getMethodParameter().getConstructor() != null) {
					return String.format('Parameter %d of constructor in %s',
							injectionPoint.getMethodParameter().getParameterIndex(),
							injectionPoint.getMethodParameter().getDeclaringClass().getName());
				}
				return String.format('Parameter %d of method %s in %s',
						injectionPoint.getMethodParameter().getParameterIndex(),
						injectionPoint.getMethodParameter().getMethod().getName(),
						injectionPoint.getMethodParameter().getDeclaringClass().getName());
			}
		}
		return ex.getResourceDescription();
	}
	private String getDescription(BeanInstantiationException ex) {
		if (ex.getConstructingMethod() != null) {
			return String.format('Method %s in %s', ex.getConstructingMethod().getName(),
					ex.getConstructingMethod().getDeclaringClass().getName());
		}
		if (ex.getConstructor() != null) {
			return String.format('Constructor in %s',
					ClassUtils.getUserClass(ex.getConstructor().getDeclaringClass()).getName());
		}
		return ex.getBeanClass().getName();
	}
	/**
	 * Returns an analysis of the given {@code rootFailure}, or {@code null} if no
	 * analysis was possible.
	 * @param rootFailure the root failure passed to the analyzer
	 * @param cause the actual found cause
	 * @param description the description of the injection point or {@code null}
	 * @return the analysis or {@code null}
	 */
	protected abstract FailureAnalysis analyze(Throwable rootFailure, T cause, String description);
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class InvalidConfigurationPropertyNameFailureAnalyzer
		extends AbstractFailureAnalyzer<InvalidConfigurationPropertyNameException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, InvalidConfigurationPropertyNameException cause) {
		BeanCreationException exception = findCause(rootFailure, BeanCreationException.class);
		String action = String.format('Modify "%s" so that it conforms to the canonical names requirements.',
				cause.getName());
		return new FailureAnalysis(buildDescription(cause, exception), action, cause);
	}
	private String buildDescription(InvalidConfigurationPropertyNameException cause, BeanCreationException exception) {
		StringBuilder description = new StringBuilder(
				String.format('Configuration property name "%s" is not valid:%n', cause.getName()));
		String invalid = cause.getInvalidCharacters().stream().map(this::quote).collect(Collectors.joining(', '));
		description.append(String.format('%n    Invalid characters: %s', invalid));
		if (exception != null) {
			description.append(String.format('%n    Bean: %s', exception.getBeanName()));
		}
		description.append(String.format('%n    Reason: Canonical names should be '
				+ 'kebab-case ("-" separated), lowercase alpha-numeric characters and must start with a letter'));
		return description.toString();
	}
	private String quote(Character c) {
		return '"' + c + '"';
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class UnboundConfigurationPropertyFailureAnalyzer
		extends AbstractFailureAnalyzer<UnboundConfigurationPropertiesException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, UnboundConfigurationPropertiesException cause) {
		BindException exception = findCause(rootFailure, BindException.class);
		return analyzeUnboundConfigurationPropertiesException(exception, cause);
	}
	private FailureAnalysis analyzeUnboundConfigurationPropertiesException(BindException cause,
			UnboundConfigurationPropertiesException exception) {
		StringBuilder description = new StringBuilder(
				String.format('Binding to target %s failed:%n', cause.getTarget()));
		for (ConfigurationProperty property : exception.getUnboundProperties()) {
			buildDescription(description, property);
			description.append(String.format('%n    Reason: %s', exception.getMessage()));
		}
		return getFailureAnalysis(description, cause);
	}
	private void buildDescription(StringBuilder description, ConfigurationProperty property) {
		if (property != null) {
			description.append(String.format('%n    Property: %s', property.getName()));
			description.append(String.format('%n    Value: \'%s\'', property.getValue()));
			description.append(String.format('%n    Origin: %s', property.getOrigin()));
		}
	}
	private FailureAnalysis getFailureAnalysis(Object description, BindException cause) {
		return new FailureAnalysis(description.toString(), 'Update your application"s configuration', cause);
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class AotInitializerNotFoundFailureAnalyzer extends AbstractFailureAnalyzer<AotInitializerNotFoundException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, AotInitializerNotFoundException cause) {
		return new FailureAnalysis(cause.getMessage(), 'Consider the following:\n'
				+ '\tDid you build the application with enabled AOT processing?\n'
				+ '\tIs the main class %s correct?\n'.formatted(cause.getMainClass().getName())
				+ '\tIf you want to run the application in regular mode, remove the system property "spring.aot.enabled"',
				cause);
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BeanDefinitionOverrideFailureAnalyzer extends AbstractFailureAnalyzer<BeanDefinitionOverrideException> {
	private static final String ACTION = 'Consider renaming one of the beans or enabling '
			+ 'overriding by setting spring.main.allow-bean-definition-overriding=true';
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, BeanDefinitionOverrideException cause) {
		return new FailureAnalysis(getDescription(cause), ACTION, cause);
	}
	private String getDescription(BeanDefinitionOverrideException ex) {
		StringWriter description = new StringWriter();
		PrintWriter printer = new PrintWriter(description);
		printer.printf('The bean "%s"', ex.getBeanName());
		if (ex.getBeanDefinition().getResourceDescription() != null) {
			printer.printf(', defined in %s,', ex.getBeanDefinition().getResourceDescription());
		}
		printer.print(' could not be registered. A bean with that name has already been defined ');
		if (ex.getExistingDefinition().getResourceDescription() != null) {
			printer.printf('in %s ', ex.getExistingDefinition().getResourceDescription());
		}
		printer.print('and overriding is disabled.');
		return description.toString();
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class NoUniqueBeanDefinitionFailureAnalyzer extends AbstractInjectionFailureAnalyzer<NoUniqueBeanDefinitionException> {
	private final ConfigurableBeanFactory beanFactory;
	NoUniqueBeanDefinitionFailureAnalyzer(BeanFactory beanFactory) {
		Assert.isInstanceOf(ConfigurableBeanFactory.class, beanFactory);
		this.beanFactory = (ConfigurableBeanFactory) beanFactory;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, NoUniqueBeanDefinitionException cause,
			String description) {
		String[] beanNames = extractBeanNames(cause);
		if (beanNames == null) {
			return null;
		}
		StringBuilder message = new StringBuilder();
		message.append(String.format('%s required a single bean, but %d were found:%n',
				(description != null) ? description : 'A component', beanNames.length));
		for (String beanName : beanNames) {
			buildMessage(message, beanName);
		}
		MissingParameterNamesFailureAnalyzer.appendPossibility(message);
		StringBuilder action = new StringBuilder(
				'Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, '
						+ 'or using @Qualifier to identify the bean that should be consumed');
		action.append('%n%n%s'.formatted(MissingParameterNamesFailureAnalyzer.ACTION));
		return new FailureAnalysis(message.toString(), action.toString(), cause);
	}
	private void buildMessage(StringBuilder message, String beanName) {
		try {
			BeanDefinition definition = this.beanFactory.getMergedBeanDefinition(beanName);
			message.append(getDefinitionDescription(beanName, definition));
		}
		catch (NoSuchBeanDefinitionException ex) {
			message.append(String.format('\t- %s: a programmatically registered singleton%n', beanName));
		}
	}
	private String getDefinitionDescription(String beanName, BeanDefinition definition) {
		if (StringUtils.hasText(definition.getFactoryMethodName())) {
			return String.format('\t- %s: defined by method "%s" in %s%n', beanName, definition.getFactoryMethodName(),
					getResourceDescription(definition));
		}
		return String.format('\t- %s: defined in %s%n', beanName, getResourceDescription(definition));
	}
	private String getResourceDescription(BeanDefinition definition) {
		String resourceDescription = definition.getResourceDescription();
		return (resourceDescription != null) ? resourceDescription : 'unknown location';
	}
	private String[] extractBeanNames(NoUniqueBeanDefinitionException cause) {
		if (cause.getMessage().contains('but found')) {
			return StringUtils.commaDelimitedListToStringArray(
					cause.getMessage().substring(cause.getMessage().lastIndexOf(":") + 1).trim());
		}
		return null;
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
public class BeanNotOfRequiredTypeFailureAnalyzer extends AbstractFailureAnalyzer<BeanNotOfRequiredTypeException> {
	private static final String ACTION = 'Consider injecting the bean as one of its '
			+ 'interfaces or forcing the use of CGLib-based '
			+ 'proxies by setting proxyTargetClass=true on @EnableAsync and/or @EnableCaching.';
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, BeanNotOfRequiredTypeException cause) {
		if (!Proxy.isProxyClass(cause.getActualType())) {
			return null;
		}
		return new FailureAnalysis(getDescription(cause), ACTION, cause);
	}
	private String getDescription(BeanNotOfRequiredTypeException ex) {
		StringWriter description = new StringWriter();
		PrintWriter printer = new PrintWriter(description);
		printer.printf('The bean "%s" could not be injected because it is a JDK dynamic proxy%n%n', ex.getBeanName());
		printer.printf('The bean is of type "%s" and implements:%n', ex.getActualType().getName());
		for (Class<?> actualTypeInterface : ex.getActualType().getInterfaces()) {
			printer.println('\t' + actualTypeInterface.getName());
		}
		printer.printf('%nExpected a bean of type "%s" which implements:%n', ex.getRequiredType().getName());
		for (Class<?> requiredTypeInterface : ex.getRequiredType().getInterfaces()) {
			printer.println('\t' + requiredTypeInterface.getName());
		}
		return description.toString();
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class InvalidConfigurationPropertyValueFailureAnalyzer
		extends AbstractFailureAnalyzer<InvalidConfigurationPropertyValueException> {
	private final ConfigurableEnvironment environment;
	InvalidConfigurationPropertyValueFailureAnalyzer(Environment environment) {
		this.environment = (ConfigurableEnvironment) environment;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, InvalidConfigurationPropertyValueException cause) {
		List<Descriptor> descriptors = getDescriptors(cause.getName());
		if (descriptors.isEmpty()) {
			descriptors = List.of(new Descriptor(null, cause.getValue(), null));
		}
		StringBuilder description = new StringBuilder();
		appendDetails(description, cause, descriptors);
		appendReason(description, cause);
		appendAdditionalProperties(description, descriptors);
		return new FailureAnalysis(description.toString(), getAction(cause), cause);
	}
	private List<Descriptor> getDescriptors(String propertyName) {
		return getPropertySources().filter((source) -> source.containsProperty(propertyName))
			.map((source) -> Descriptor.get(source, propertyName))
			.toList();
	}
	private Stream<PropertySource<?>> getPropertySources() {
		if (this.environment == null) {
			return Stream.empty();
		}
		return this.environment.getPropertySources()
			.stream()
			.filter((source) -> !ConfigurationPropertySources.isAttachedConfigurationPropertySource(source));
	}
	private void appendDetails(StringBuilder message, InvalidConfigurationPropertyValueException cause,
			List<Descriptor> descriptors) {
		Descriptor mainDescriptor = descriptors.get(0);
		message.append('Invalid value "').append(mainDescriptor.getValue()).append('" for configuration property "');
		message.append(cause.getName()).append('"');
		mainDescriptor.appendOrigin(message);
		message.append('.');
	}
	private void appendReason(StringBuilder message, InvalidConfigurationPropertyValueException cause) {
		if (StringUtils.hasText(cause.getReason())) {
			message.append(String.format(' Validation failed for the following reason:%n%n'));
			message.append(cause.getReason());
		}
		else {
			message.append(' No reason was provided.');
		}
	}
	private void appendAdditionalProperties(StringBuilder message, List<Descriptor> descriptors) {
		List<Descriptor> others = descriptors.subList(1, descriptors.size());
		if (!others.isEmpty()) {
			message
				.append(String.format('%n%nAdditionally, this property is also set in the following property %s:%n%n',
						(others.size() > 1) ? 'sources' : 'source'));
			for (Descriptor other : others) {
				message.append('\t- In "').append(other.getPropertySource()).append('"');
				message.append(' with the value "').append(other.getValue()).append('"');
				other.appendOrigin(message);
				message.append(String.format('.%n'));
			}
		}
	}
	private String getAction(InvalidConfigurationPropertyValueException cause) {
		StringBuilder action = new StringBuilder();
		action.append('Review the value of the property');
		if (cause.getReason() != null) {
			action.append(' with the provided reason');
		}
		action.append('.');
		return action.toString();
	}
	private static final class Descriptor {
		private final String propertySource;
		private final Object value;
		private final Origin origin;
		private Descriptor(String propertySource, Object value, Origin origin) {
			this.propertySource = propertySource;
			this.value = value;
			this.origin = origin;
		}
		String getPropertySource() {
			return this.propertySource;
		}
		Object getValue() {
			return this.value;
		}
		void appendOrigin(StringBuilder message) {
			if (this.origin != null) {
				message.append(' (originating from "').append(this.origin).append('")');
			}
		}
		static Descriptor get(PropertySource<?> source, String propertyName) {
			Object value = source.getProperty(propertyName);
			Origin origin = OriginLookup.getOrigin(source, propertyName);
			return new Descriptor(source.getName(), value, origin);
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BindValidationFailureAnalyzer extends AbstractFailureAnalyzer<Throwable> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, Throwable cause) {
		ExceptionDetails details = getBindValidationExceptionDetails(rootFailure);
		if (details == null) {
			return null;
		}
		return analyzeBindValidationException(details);
	}
	private ExceptionDetails getBindValidationExceptionDetails(Throwable rootFailure) {
		BindValidationException validationException = findCause(rootFailure, BindValidationException.class);
		if (validationException != null) {
			BindException bindException = findCause(rootFailure, BindException.class);
			List<ObjectError> errors = validationException.getValidationErrors().getAllErrors();
			return new ExceptionDetails(errors, bindException.getTarget().getType(), validationException);
		}
		org.springframework.validation.BindException bindException = findCause(rootFailure,
				org.springframework.validation.BindException.class);
		if (bindException != null) {
			List<ObjectError> errors = bindException.getAllErrors();
			return new ExceptionDetails(errors, bindException.getTarget(), bindException);
		}
		return null;
	}
	private FailureAnalysis analyzeBindValidationException(ExceptionDetails details) {
		StringBuilder description = new StringBuilder(
				String.format('Binding to target %s failed:%n', details.getTarget()));
		for (ObjectError error : details.getErrors()) {
			if (error instanceof FieldError fieldError) {
				appendFieldError(description, fieldError);
			}
			description.append(String.format('%n    Reason: %s%n', error.getDefaultMessage()));
		}
		return getFailureAnalysis(description, details.getCause());
	}
	private void appendFieldError(StringBuilder description, FieldError error) {
		Origin origin = Origin.from(error);
		description.append(String.format('%n    Property: %s', error.getObjectName() + '.' + error.getField()));
		description.append(String.format('%n    Value: \'%s\'', error.getRejectedValue()));
		if (origin != null) {
			description.append(String.format('%n    Origin: %s', origin));
		}
	}
	private FailureAnalysis getFailureAnalysis(Object description, Throwable cause) {
		return new FailureAnalysis(description.toString(), 'Update your application"s configuration', cause);
	}
	private static class ExceptionDetails {
		private final List<ObjectError> errors;
		private final Object target;
		private final Throwable cause;
		ExceptionDetails(List<ObjectError> errors, Object target, Throwable cause) {
			this.errors = errors;
			this.target = target;
			this.cause = cause;
		}
		Object getTarget() {
			return this.target;
		}
		List<ObjectError> getErrors() {
			return this.errors;
		}
		Throwable getCause() {
			return this.cause;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BindFailureAnalyzer extends AbstractFailureAnalyzer<BindException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, BindException cause) {
		Throwable rootCause = cause.getCause();
		if (rootCause instanceof BindValidationException
				|| rootCause instanceof UnboundConfigurationPropertiesException) {
			return null;
		}
		return analyzeGenericBindException(rootFailure, cause);
	}
	private FailureAnalysis analyzeGenericBindException(Throwable rootFailure, BindException cause) {
		FailureAnalysis missingParametersAnalysis = MissingParameterNamesFailureAnalyzer
			.analyzeForMissingParameters(rootFailure);
		StringBuilder description = new StringBuilder(String.format('%s:%n', cause.getMessage()));
		ConfigurationProperty property = cause.getProperty();
		buildDescription(description, property);
		description.append(String.format('%n    Reason: %s', getMessage(cause)));
		if (missingParametersAnalysis != null) {
			MissingParameterNamesFailureAnalyzer.appendPossibility(description);
		}
		return getFailureAnalysis(description.toString(), cause, missingParametersAnalysis);
	}
	private void buildDescription(StringBuilder description, ConfigurationProperty property) {
		if (property != null) {
			description.append(String.format('%n    Property: %s', property.getName()));
			description.append(String.format('%n    Value: \'%s\'', property.getValue()));
			description.append(String.format('%n    Origin: %s', property.getOrigin()));
		}
	}
	private String getMessage(BindException cause) {
		Throwable rootCause = getRootCause(cause.getCause());
		ConversionFailedException conversionFailure = findCause(cause, ConversionFailedException.class);
		if (conversionFailure != null) {
			String message = 'failed to convert ' + conversionFailure.getSourceType() + ' to '
					+ conversionFailure.getTargetType();
			if (rootCause != null) {
				message += ' (caused by ' + getExceptionTypeAndMessage(rootCause) + ')';
			}
			return message;
		}
		if (rootCause != null && StringUtils.hasText(rootCause.getMessage())) {
			return getExceptionTypeAndMessage(rootCause);
		}
		return getExceptionTypeAndMessage(cause);
	}
	private Throwable getRootCause(Throwable cause) {
		Throwable rootCause = cause;
		while (rootCause != null && rootCause.getCause() != null) {
			rootCause = rootCause.getCause();
		}
		return rootCause;
	}
	private String getExceptionTypeAndMessage(Throwable ex) {
		String message = ex.getMessage();
		return ex.getClass().getName() + (StringUtils.hasText(message) ? ': ' + message : '');
	}
	private FailureAnalysis getFailureAnalysis(String description, BindException cause,
			FailureAnalysis missingParametersAnalysis) {
		StringBuilder action = new StringBuilder('Update your application"s configuration');
		Collection<String> validValues = findValidValues(cause);
		if (!validValues.isEmpty()) {
			action.append(String.format('. The following values are valid:%n'));
			validValues.forEach((value) -> action.append(String.format('%n    %s', value)));
		}
		if (missingParametersAnalysis != null) {
			action.append(String.format('%n%n%s', missingParametersAnalysis.getAction()));
		}
		return new FailureAnalysis(description, action.toString(), cause);
	}
	private Collection<String> findValidValues(BindException ex) {
		ConversionFailedException conversionFailure = findCause(ex, ConversionFailedException.class);
		if (conversionFailure != null) {
			Object[] enumConstants = conversionFailure.getTargetType().getType().getEnumConstants();
			if (enumConstants != null) {
				return Stream.of(enumConstants).map(Object::toString).collect(Collectors.toCollection(TreeSet::new));
			}
		}
		return Collections.emptySet();
	}
}
/*
/**
package org.springframework.boot.diagnostics.analyzer;
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class PatternParseFailureAnalyzer extends AbstractFailureAnalyzer<PatternParseException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, PatternParseException cause) {
		return new FailureAnalysis('Invalid mapping pattern detected:\n' + cause.toDetailedString(),
				'Fix this pattern in your application or switch to the legacy parser implementation with '
						+ '"spring.mvc.pathmatch.matching-strategy=ant_path_matcher".',
				cause);
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BeanCurrentlyInCreationFailureAnalyzer extends AbstractFailureAnalyzer<BeanCurrentlyInCreationException> {
	private final AbstractAutowireCapableBeanFactory beanFactory;
	BeanCurrentlyInCreationFailureAnalyzer(BeanFactory beanFactory) {
		if (beanFactory instanceof AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) {
			this.beanFactory = autowireCapableBeanFactory;
		}
		else {
			this.beanFactory = null;
		}
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, BeanCurrentlyInCreationException cause) {
		DependencyCycle dependencyCycle = findCycle(rootFailure);
		if (dependencyCycle == null) {
			return null;
		}
		return new FailureAnalysis(buildMessage(dependencyCycle), action(), cause);
	}
	private String action() {
		if (this.beanFactory != null && this.beanFactory.isAllowCircularReferences()) {
			return 'Despite circular references being allowed, the dependency cycle between beans could not be '
					+ 'broken. Update your application to remove the dependency cycle.';
		}
		return 'Relying upon circular references is discouraged and they are prohibited by default. '
				+ 'Update your application to remove the dependency cycle between beans. '
				+ 'As a last resort, it may be possible to break the cycle automatically by setting '
				+ 'spring.main.allow-circular-references to true.';
	}
	private DependencyCycle findCycle(Throwable rootFailure) {
		List<BeanInCycle> beansInCycle = new ArrayList<>();
		Throwable candidate = rootFailure;
		int cycleStart = -1;
		while (candidate != null) {
			BeanInCycle beanInCycle = BeanInCycle.get(candidate);
			if (beanInCycle != null) {
				int index = beansInCycle.indexOf(beanInCycle);
				if (index == -1) {
					beansInCycle.add(beanInCycle);
				}
				cycleStart = (cycleStart != -1) ? cycleStart : index;
			}
			candidate = candidate.getCause();
		}
		if (cycleStart == -1) {
			return null;
		}
		return new DependencyCycle(beansInCycle, cycleStart);
	}
	private String buildMessage(DependencyCycle dependencyCycle) {
		StringBuilder message = new StringBuilder();
		message.append(
				String.format('The dependencies of some of the beans in the application context form a cycle:%n%n'));
		List<BeanInCycle> beansInCycle = dependencyCycle.getBeansInCycle();
		boolean singleBean = beansInCycle.size() == 1;
		int cycleStart = dependencyCycle.getCycleStart();
		for (int i = 0; i < beansInCycle.size(); i++) {
			BeanInCycle beanInCycle = beansInCycle.get(i);
			if (i == cycleStart) {
				message.append(String.format(singleBean ? '->%n' : '%n'));
			}
			else if (i > 0) {
				String leftSide = (i < cycleStart) ? ' ' : '';
				message.append(String.format('%s     %n', leftSide));
			}
			String leftSide = (i < cycleStart) ? ' ' : '|';
			message.append(String.format('%s  %s%n', leftSide, beanInCycle));
		}
		message.append(String.format(singleBean ? '<-%n' : '%n'));
		return message.toString();
	}
	private static final class DependencyCycle {
		private final List<BeanInCycle> beansInCycle;
		private final int cycleStart;
		private DependencyCycle(List<BeanInCycle> beansInCycle, int cycleStart) {
			this.beansInCycle = beansInCycle;
			this.cycleStart = cycleStart;
		}
		List<BeanInCycle> getBeansInCycle() {
			return this.beansInCycle;
		}
		int getCycleStart() {
			return this.cycleStart;
		}
	}
	private static final class BeanInCycle {
		private final String name;
		private final String description;
		private BeanInCycle(BeanCreationException ex) {
			this.name = ex.getBeanName();
			this.description = determineDescription(ex);
		}
		private String determineDescription(BeanCreationException ex) {
			if (StringUtils.hasText(ex.getResourceDescription())) {
				return String.format(' defined in %s', ex.getResourceDescription());
			}
			InjectionPoint failedInjectionPoint = findFailedInjectionPoint(ex);
			if (failedInjectionPoint != null && failedInjectionPoint.getField() != null) {
				return String.format(' (field %s)', failedInjectionPoint.getField());
			}
			return '';
		}
		private InjectionPoint findFailedInjectionPoint(BeanCreationException ex) {
			if (ex instanceof UnsatisfiedDependencyException unsatisfiedDependencyException) {
				return unsatisfiedDependencyException.getInjectionPoint();
			}
			return null;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.name.equals(((BeanInCycle) obj).name);
		}
		@Override
		public int hashCode() {
			return this.name.hashCode();
		}
		@Override
		public String toString() {
			return this.name + this.description;
		}
		static BeanInCycle get(Throwable ex) {
			if (ex instanceof BeanCreationException beanCreationException) {
				return get(beanCreationException);
			}
			return null;
		}
		private static BeanInCycle get(BeanCreationException ex) {
			if (StringUtils.hasText(ex.getBeanName())) {
				return new BeanInCycle(ex);
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class MutuallyExclusiveConfigurationPropertiesFailureAnalyzer
		extends AbstractFailureAnalyzer<MutuallyExclusiveConfigurationPropertiesException> {
	private final ConfigurableEnvironment environment;
	MutuallyExclusiveConfigurationPropertiesFailureAnalyzer(Environment environment) {
		this.environment = (ConfigurableEnvironment) environment;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, MutuallyExclusiveConfigurationPropertiesException cause) {
		List<Descriptor> descriptors = new ArrayList<>();
		for (String name : cause.getConfiguredNames()) {
			List<Descriptor> descriptorsForName = getDescriptors(name);
			if (descriptorsForName.isEmpty()) {
				return null;
			}
			descriptors.addAll(descriptorsForName);
		}
		StringBuilder description = new StringBuilder();
		appendDetails(description, cause, descriptors);
		return new FailureAnalysis(description.toString(),
				'Update your configuration so that only one of the mutually exclusive properties is configured.',
				cause);
	}
	private List<Descriptor> getDescriptors(String propertyName) {
		return getPropertySources().filter((source) -> source.containsProperty(propertyName))
			.map((source) -> Descriptor.get(source, propertyName))
			.toList();
	}
	private Stream<PropertySource<?>> getPropertySources() {
		if (this.environment == null) {
			return Stream.empty();
		}
		return this.environment.getPropertySources()
			.stream()
			.filter((source) -> !ConfigurationPropertySources.isAttachedConfigurationPropertySource(source));
	}
	private void appendDetails(StringBuilder message, MutuallyExclusiveConfigurationPropertiesException cause,
			List<Descriptor> descriptors) {
		descriptors.sort(Comparator.comparing((descriptor) -> descriptor.propertyName));
		message.append(String.format('The following configuration properties are mutually exclusive:%n%n'));
		sortedStrings(cause.getMutuallyExclusiveNames())
			.forEach((name) -> message.append(String.format('\t%s%n', name)));
		message.append(String.format('%n'));
		message.append(
				String.format('However, more than one of those properties has been configured at the same time:%n%n'));
		Set<String> configuredDescriptions = sortedStrings(descriptors,
				(descriptor) -> String.format('\t%s%s%n', descriptor.propertyName,
						(descriptor.origin != null) ? ' (originating from "' + descriptor.origin + '")' : ''));
		configuredDescriptions.forEach(message::append);
	}
	private Set<String> sortedStrings(Collection<String> input) {
		return sortedStrings(input, Function.identity());
	}
	private <S> Set<String> sortedStrings(Collection<S> input, Function<S, String> converter) {
		TreeSet<String> results = new TreeSet<>();
		for (S item : input) {
			results.add(converter.apply(item));
		}
		return results;
	}
	private static final class Descriptor {
		private final String propertyName;
		private final Origin origin;
		private Descriptor(String propertyName, Origin origin) {
			this.propertyName = propertyName;
			this.origin = origin;
		}
		static Descriptor get(PropertySource<?> source, String propertyName) {
			Origin origin = OriginLookup.getOrigin(source, propertyName);
			return new Descriptor(propertyName, origin);
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class PortInUseFailureAnalyzer extends AbstractFailureAnalyzer<PortInUseException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, PortInUseException cause) {
		return new FailureAnalysis('Web server failed to start. Port ' + cause.getPort() + ' was already in use.',
				'Identify and stop the process that"s listening on port ' + cause.getPort() + ' or configure this '
						+ 'application to listen on another port.',
				cause);
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class NoSuchMethodFailureAnalyzer extends AbstractFailureAnalyzer<NoSuchMethodError> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchMethodError cause) {
		NoSuchMethodDescriptor callerDescriptor = getCallerMethodDescriptor(cause);
		if (callerDescriptor == null) {
			return null;
		}
		NoSuchMethodDescriptor calledDescriptor = getNoSuchMethodDescriptor(cause.getMessage());
		if (calledDescriptor == null) {
			return null;
		}
		String description = getDescription(callerDescriptor, calledDescriptor);
		String action = getAction(callerDescriptor, calledDescriptor);
		return new FailureAnalysis(description, action, cause);
	}
	private NoSuchMethodDescriptor getCallerMethodDescriptor(NoSuchMethodError cause) {
		StackTraceElement firstStackTraceElement = cause.getStackTrace()[0];
		String message = firstStackTraceElement.toString();
		String className = firstStackTraceElement.getClassName();
		return getDescriptorForClass(message, className);
	}
	protected NoSuchMethodDescriptor getNoSuchMethodDescriptor(String cause) {
		String message = cleanMessage(cause);
		String className = extractClassName(message);
		return getDescriptorForClass(message, className);
	}
	private NoSuchMethodDescriptor getDescriptorForClass(String message, String className) {
		if (className == null) {
			return null;
		}
		List<URL> candidates = findCandidates(className);
		if (candidates == null) {
			return null;
		}
		Class<?> type = load(className);
		if (type == null) {
			return null;
		}
		List<ClassDescriptor> typeHierarchy = getTypeHierarchy(type);
		if (typeHierarchy == null) {
			return null;
		}
		return new NoSuchMethodDescriptor(message, className, candidates, typeHierarchy);
	}
	private String cleanMessage(String message) {
		int loadedFromIndex = message.indexOf(' (loaded from');
		if (loadedFromIndex == -1) {
			return message;
		}
		return message.substring(0, loadedFromIndex);
	}
	private String extractClassName(String message) {
		if (message.startsWith('"') && message.endsWith('"')) {
			int splitIndex = message.indexOf(" ");
			if (splitIndex == -1) {
				return null;
			}
			message = message.substring(splitIndex + 1);
		}
		int descriptorIndex = message.indexOf("(");
		if (descriptorIndex == -1) {
			return null;
		}
		String classAndMethodName = message.substring(0, descriptorIndex);
		int methodNameIndex = classAndMethodName.lastIndexOf(".");
		if (methodNameIndex == -1) {
			return null;
		}
		String className = classAndMethodName.substring(0, methodNameIndex);
		return className.replace("/", ".");
	}
	private List<URL> findCandidates(String className) {
		try {
			return Collections.list(NoSuchMethodFailureAnalyzer.class.getClassLoader()
				.getResources(ClassUtils.convertClassNameToResourcePath(className) + '.class'));
		}
		catch (Throwable ex) {
			return null;
		}
	}
	private Class<?> load(String className) {
		try {
			return Class.forName(className, false, getClass().getClassLoader());
		}
		catch (Throwable ex) {
			return null;
		}
	}
	private List<ClassDescriptor> getTypeHierarchy(Class<?> type) {
		try {
			List<ClassDescriptor> typeHierarchy = new ArrayList<>();
			while (type != null && !type.equals(Object.class)) {
				typeHierarchy.add(new ClassDescriptor(type.getCanonicalName(),
						type.getProtectionDomain().getCodeSource().getLocation()));
				type = type.getSuperclass();
			}
			return typeHierarchy;
		}
		catch (Throwable ex) {
			return null;
		}
	}
	private String getDescription(NoSuchMethodDescriptor callerDescriptor, NoSuchMethodDescriptor calledDescriptor) {
		StringWriter description = new StringWriter();
		PrintWriter writer = new PrintWriter(description);
		writer.println('An attempt was made to call a method that does not'
				+ ' exist. The attempt was made from the following location:');
		writer.println();
		writer.printf('    %s%n', callerDescriptor.getErrorMessage());
		writer.println();
		writer.println('The following method did not exist:');
		writer.println();
		writer.printf('    %s%n', calledDescriptor.getErrorMessage());
		writer.println();
		if (callerDescriptor.getCandidateLocations().size() > 1) {
			writer.printf('The calling method"s class, %s, is available from the following locations:%n',
					callerDescriptor.getClassName());
			writer.println();
			for (URL candidate : callerDescriptor.getCandidateLocations()) {
				writer.printf('    %s%n', candidate);
			}
			writer.println();
			writer.println('The calling method"s class was loaded from the following location:');
			writer.println();
			writer.printf('    %s%n', callerDescriptor.getTypeHierarchy().get(0).getLocation());
		}
		else {
			writer.printf('The calling method"s class, %s, was loaded from the following location:%n',
					callerDescriptor.getClassName());
			writer.println();
			writer.printf('    %s%n', callerDescriptor.getCandidateLocations().get(0));
		}
		writer.println();
		writer.printf('The called method"s class, %s, is available from the following locations:%n',
				calledDescriptor.getClassName());
		writer.println();
		for (URL candidate : calledDescriptor.getCandidateLocations()) {
			writer.printf('    %s%n', candidate);
		}
		writer.println();
		writer.println('The called method"s class hierarchy was loaded from the following locations:');
		writer.println();
		for (ClassDescriptor type : calledDescriptor.getTypeHierarchy()) {
			writer.printf('    %s: %s%n', type.getName(), type.getLocation());
		}
		return description.toString();
	}
	private String getAction(NoSuchMethodDescriptor callerDescriptor, NoSuchMethodDescriptor calledDescriptor) {
		if (callerDescriptor.getClassName().equals(calledDescriptor.getClassName())) {
			return 'Correct the classpath of your application so that it contains a single, compatible version of '
					+ calledDescriptor.getClassName();
		}
		else {
			return 'Correct the classpath of your application so that it contains compatible versions of the classes '
					+ callerDescriptor.getClassName() + ' and ' + calledDescriptor.getClassName();
		}
	}
	protected static class NoSuchMethodDescriptor {
		private final String errorMessage;
		private final String className;
		private final List<URL> candidateLocations;
		private final List<ClassDescriptor> typeHierarchy;
		public NoSuchMethodDescriptor(String errorMessage, String className, List<URL> candidateLocations,
				List<ClassDescriptor> typeHierarchy) {
			this.errorMessage = errorMessage;
			this.className = className;
			this.candidateLocations = candidateLocations;
			this.typeHierarchy = typeHierarchy;
		}
		public String getErrorMessage() {
			return this.errorMessage;
		}
		public String getClassName() {
			return this.className;
		}
		public List<URL> getCandidateLocations() {
			return this.candidateLocations;
		}
		public List<ClassDescriptor> getTypeHierarchy() {
			return this.typeHierarchy;
		}
	}
	protected static class ClassDescriptor {
		private final String name;
		private final URL location;
		public ClassDescriptor(String name, URL location) {
			this.name = name;
			this.location = location;
		}
		public String getName() {
			return this.name;
		}
		public URL getLocation() {
			return this.location;
		}
	}
}
/*
package org.springframework.boot.diagnostics;
/**
@FunctionalInterface
public interface FailureAnalyzer {
	/**
	 * Returns an analysis of the given {@code failure}, or {@code null} if no analysis
	 * was possible.
	 * @param failure the failure
	 * @return the analysis or {@code null}
	 */
	FailureAnalysis analyze(Throwable failure);
}
/*
/**
package org.springframework.boot.diagnostics;
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface ApplicationContextFactory {
	/**
	 * A default {@link ApplicationContextFactory} implementation that will create an
	 * appropriate context for the {@link WebApplicationType}.
	 */
	ApplicationContextFactory DEFAULT = new DefaultApplicationContextFactory();
	/**
	 * Return the {@link Environment} type expected to be set on the
	 * {@link #create(WebApplicationType) created} application context. The result of this
	 * method can be used to convert an existing environment instance to the correct type.
	 * @param webApplicationType the web application type
	 * @return the expected application context type or {@code null} to use the default
	 * @since 2.6.14
	 */
	default Class<? extends ConfigurableEnvironment> getEnvironmentType(WebApplicationType webApplicationType) {
		return null;
	}
	/**
	 * Create a new {@link Environment} to be set on the
	 * {@link #create(WebApplicationType) created} application context. The result of this
	 * method must match the type returned by
	 * {@link #getEnvironmentType(WebApplicationType)}.
	 * @param webApplicationType the web application type
	 * @return an environment instance or {@code null} to use the default
	 * @since 2.6.14
	 */
	default ConfigurableEnvironment createEnvironment(WebApplicationType webApplicationType) {
		return null;
	}
	/**
	 * Creates the {@link ConfigurableApplicationContext application context} for a
	 * {@link SpringApplication}, respecting the given {@code webApplicationType}.
	 * @param webApplicationType the web application type
	 * @return the newly created application context
	 */
	ConfigurableApplicationContext create(WebApplicationType webApplicationType);
	/**
	 * Creates an {@code ApplicationContextFactory} that will create contexts by
	 * instantiating the given {@code contextClass} through its primary constructor.
	 * @param contextClass the context class
	 * @return the factory that will instantiate the context class
	 * @see BeanUtils#instantiateClass(Class)
	 */
	static ApplicationContextFactory ofContextClass(Class<? extends ConfigurableApplicationContext> contextClass) {
		return of(() -> BeanUtils.instantiateClass(contextClass));
	}
	/**
	 * Creates an {@code ApplicationContextFactory} that will create contexts by calling
	 * the given {@link Supplier}.
	 * @param supplier the context supplier, for example
	 * {@code AnnotationConfigApplicationContext::new}
	 * @return the factory that will instantiate the context class
	 */
	static ApplicationContextFactory of(Supplier<ConfigurableApplicationContext> supplier) {
		return (webApplicationType) -> supplier.get();
	}
}
/*
package org.springframework.boot;
/**
public final class LazyInitializationBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {
	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		Collection<LazyInitializationExcludeFilter> filters = getFilters(beanFactory);
		for (String beanName : beanFactory.getBeanDefinitionNames()) {
			BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
			if (beanDefinition instanceof AbstractBeanDefinition abstractBeanDefinition) {
				postProcess(beanFactory, filters, beanName, abstractBeanDefinition);
			}
		}
	}
	private Collection<LazyInitializationExcludeFilter> getFilters(ConfigurableListableBeanFactory beanFactory) {
		// Take care not to force the eager init of factory beans when getting filters
		ArrayList<LazyInitializationExcludeFilter> filters = new ArrayList<>(
				beanFactory.getBeansOfType(LazyInitializationExcludeFilter.class, false, false).values());
		filters.add(LazyInitializationExcludeFilter.forBeanTypes(SmartInitializingSingleton.class));
		filters.add(new InfrastructureRoleLazyInitializationExcludeFilter());
		return filters;
	}
	private void postProcess(ConfigurableListableBeanFactory beanFactory,
			Collection<LazyInitializationExcludeFilter> filters, String beanName,
			AbstractBeanDefinition beanDefinition) {
		Boolean lazyInit = beanDefinition.getLazyInit();
		if (lazyInit != null) {
			return;
		}
		Class<?> beanType = getBeanType(beanFactory, beanName);
		if (!isExcluded(filters, beanName, beanDefinition, beanType)) {
			beanDefinition.setLazyInit(true);
		}
	}
	private Class<?> getBeanType(ConfigurableListableBeanFactory beanFactory, String beanName) {
		try {
			return beanFactory.getType(beanName, false);
		}
		catch (NoSuchBeanDefinitionException ex) {
			return null;
		}
	}
	private boolean isExcluded(Collection<LazyInitializationExcludeFilter> filters, String beanName,
			AbstractBeanDefinition beanDefinition, Class<?> beanType) {
		if (beanType != null) {
			for (LazyInitializationExcludeFilter filter : filters) {
				if (filter.isExcluded(beanName, beanDefinition, beanType)) {
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE;
	}
	/**
	 * Excludes all {@link BeanDefinition bean definitions} which have the infrastructure
	 * role from lazy initialization.
	 */
	private static final class InfrastructureRoleLazyInitializationExcludeFilter
			implements LazyInitializationExcludeFilter {
		@Override
		public boolean isExcluded(String beanName, BeanDefinition beanDefinition, Class<?> beanType) {
			return beanDefinition.getRole() == BeanDefinition.ROLE_INFRASTRUCTURE;
		}
	}
}
/*
package org.springframework.boot;
/**
class StartupInfoLogger {
	private final Class<?> sourceClass;
	private final Environment environment;
	StartupInfoLogger(Class<?> sourceClass, Environment environment) {
		this.sourceClass = sourceClass;
		this.environment = environment;
	}
	void logStarting(Log applicationLog) {
		Assert.notNull(applicationLog, 'Log must not be null');
		applicationLog.info(LogMessage.of(this::getStartingMessage));
		applicationLog.debug(LogMessage.of(this::getRunningMessage));
	}
	void logStarted(Log applicationLog, Startup startup) {
		if (applicationLog.isInfoEnabled()) {
			applicationLog.info(getStartedMessage(startup));
		}
	}
	private CharSequence getStartingMessage() {
		StringBuilder message = new StringBuilder();
		message.append('Starting');
		appendAotMode(message);
		appendApplicationName(message);
		appendApplicationVersion(message);
		appendJavaVersion(message);
		appendPid(message);
		appendContext(message);
		return message;
	}
	private CharSequence getRunningMessage() {
		StringBuilder message = new StringBuilder();
		message.append('Running with Spring Boot');
		appendVersion(message, getClass());
		message.append(', Spring');
		appendVersion(message, ApplicationContext.class);
		return message;
	}
	private CharSequence getStartedMessage(Startup startup) {
		StringBuilder message = new StringBuilder();
		message.append(startup.action());
		appendApplicationName(message);
		message.append(' in ');
		message.append(startup.timeTakenToStarted().toMillis() / 1000.0);
		message.append(' seconds');
		Long uptimeMs = startup.processUptime();
		if (uptimeMs != null) {
			double uptime = uptimeMs / 1000.0;
			message.append(' (process running for ').append(uptime).append(')');
		}
		return message;
	}
	private void appendAotMode(StringBuilder message) {
		append(message, '', () -> AotDetector.useGeneratedArtifacts() ? 'AOT-processed' : null);
	}
	private void appendApplicationName(StringBuilder message) {
		append(message, '',
				() -> (this.sourceClass != null) ? ClassUtils.getShortName(this.sourceClass) : 'application');
	}
	private void appendVersion(StringBuilder message, Class<?> source) {
		append(message, 'v', () -> source.getPackage().getImplementationVersion());
	}
	private void appendApplicationVersion(StringBuilder message) {
		append(message, 'v', () -> this.environment.getProperty('spring.application.version'));
	}
	private void appendPid(StringBuilder message) {
		append(message, 'with PID ', () -> this.environment.getProperty('spring.application.pid'));
	}
	private void appendContext(StringBuilder message) {
		StringBuilder context = new StringBuilder();
		ApplicationHome home = new ApplicationHome(this.sourceClass);
		if (home.getSource() != null) {
			context.append(home.getSource().getAbsolutePath());
		}
		append(context, 'started by ', () -> System.getProperty('user.name'));
		append(context, 'in ', () -> System.getProperty('user.dir'));
		if (!context.isEmpty()) {
			message.append(' (');
			message.append(context);
			message.append(')');
		}
	}
	private void appendJavaVersion(StringBuilder message) {
		append(message, 'using Java ', () -> System.getProperty('java.version'));
	}
	private void append(StringBuilder message, String prefix, Callable<Object> call) {
		append(message, prefix, call, '');
	}
	private void append(StringBuilder message, String prefix, Callable<Object> call, String defaultValue) {
		Object result = callIfPossible(call);
		String value = (result != null) ? result.toString() : null;
		if (!StringUtils.hasLength(value)) {
			value = defaultValue;
		}
		if (StringUtils.hasLength(value)) {
			message.append((!message.isEmpty()) ? ' ' : '');
			message.append(prefix);
			message.append(value);
		}
	}
	private Object callIfPossible(Callable<Object> call) {
		try {
			return call.call();
		}
		catch (Exception ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.liquibase;
/**
class LiquibaseDatabaseInitializerDetector extends AbstractBeansOfTypeDatabaseInitializerDetector {
	@Override
	protected Set<Class<?>> getDatabaseInitializerBeanTypes() {
		return Collections.singleton(SpringLiquibase.class);
	}
}
/*
/**
package org.springframework.boot.liquibase;
/*
package org.springframework.boot.liquibase;
/**
class LiquibaseChangelogMissingFailureAnalyzer extends AbstractFailureAnalyzer<ChangeLogParseException> {
	private static final String MESSAGE_SUFFIX = ' does not exist';
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, ChangeLogParseException cause) {
		if (cause.getMessage().endsWith(MESSAGE_SUFFIX)) {
			String changelogPath = extractChangelogPath(cause);
			return new FailureAnalysis(getDescription(changelogPath),
					'Make sure a Liquibase changelog is present at the configured path.', cause);
		}
		return null;
	}
	private String extractChangelogPath(ChangeLogParseException cause) {
		return cause.getMessage().substring(0, cause.getMessage().length() - MESSAGE_SUFFIX.length());
	}
	private String getDescription(String changelogPath) {
		return 'Liquibase failed to start because no changelog could be found at "' + changelogPath + '".';
	}
}
/*
package org.springframework.boot.flyway;
/**
class FlywayDatabaseInitializerDetector extends AbstractBeansOfTypeDatabaseInitializerDetector {
	@Override
	protected Set<Class<?>> getDatabaseInitializerBeanTypes() {
		return Collections.singleton(Flyway.class);
	}
}
/*
/**
package org.springframework.boot.flyway;
/*
package org.springframework.boot;
/**
public class AotInitializerNotFoundException extends RuntimeException {
	private final Class<?> mainClass;
	public AotInitializerNotFoundException(Class<?> mainClass, String initializerClassName) {
		super('Startup with AOT mode enabled failed: AOT initializer %s could not be found'
			.formatted(initializerClassName));
		this.mainClass = mainClass;
	}
	public Class<?> getMainClass() {
		return this.mainClass;
	}
}
/*
package org.springframework.boot;
/**
public interface ConfigurableBootstrapContext extends BootstrapRegistry, BootstrapContext {
}
/*
package org.springframework.boot.origin;
/**
@FunctionalInterface
public interface OriginProvider {
	/**
	 * Return the source origin or {@code null} if the origin is not known.
	 * @return the origin or {@code null}
	 */
	Origin getOrigin();
}
/*
package org.springframework.boot.origin;
/**
public class TextResourceOrigin implements Origin {
	private final Resource resource;
	private final Location location;
	public TextResourceOrigin(Resource resource, Location location) {
		this.resource = resource;
		this.location = location;
	}
	/**
	 * Return the resource where the property originated.
	 * @return the text resource or {@code null}
	 */
	public Resource getResource() {
		return this.resource;
	}
	/**
	 * Return the location of the property within the source (if known).
	 * @return the location or {@code null}
	 */
	public Location getLocation() {
		return this.location;
	}
	@Override
	public Origin getParent() {
		return Origin.from(this.resource);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (obj instanceof TextResourceOrigin other) {
			boolean result = true;
			result = result && ObjectUtils.nullSafeEquals(this.resource, other.resource);
			result = result && ObjectUtils.nullSafeEquals(this.location, other.location);
			return result;
		}
		return super.equals(obj);
	}
	@Override
	public int hashCode() {
		int result = 1;
		result = 31 * result + ObjectUtils.nullSafeHashCode(this.resource);
		result = 31 * result + ObjectUtils.nullSafeHashCode(this.location);
		return result;
	}
	@Override
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(getResourceDescription(this.resource));
		if (this.location != null) {
			result.append(' - ').append(this.location);
		}
		return result.toString();
	}
	private String getResourceDescription(Resource resource) {
		if (resource instanceof OriginTrackedResource originTrackedResource) {
			return getResourceDescription(originTrackedResource.getResource());
		}
		if (resource == null) {
			return 'unknown resource [?]';
		}
		if (resource instanceof ClassPathResource classPathResource) {
			return getResourceDescription(classPathResource);
		}
		return resource.getDescription();
	}
	private String getResourceDescription(ClassPathResource resource) {
		try {
			JarUri jarUri = JarUri.from(resource.getURI());
			if (jarUri != null) {
				return jarUri.getDescription(resource.getDescription());
			}
		}
		catch (IOException ex) {
			// Ignore
		}
		return resource.getDescription();
	}
	/**
	 * A location (line and column number) within the resource.
	 */
	public static final class Location {
		private final int line;
		private final int column;
		/**
		 * Create a new {@link Location} instance.
		 * @param line the line number (zero indexed)
		 * @param column the column number (zero indexed)
		 */
		public Location(int line, int column) {
			this.line = line;
			this.column = column;
		}
		/**
		 * Return the line of the text resource where the property originated.
		 * @return the line number (zero indexed)
		 */
		public int getLine() {
			return this.line;
		}
		/**
		 * Return the column of the text resource where the property originated.
		 * @return the column number (zero indexed)
		 */
		public int getColumn() {
			return this.column;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			Location other = (Location) obj;
			boolean result = true;
			result = result && this.line == other.line;
			result = result && this.column == other.column;
			return result;
		}
		@Override
		public int hashCode() {
			return (31 * this.line) + this.column;
		}
		@Override
		public String toString() {
			return (this.line + 1) + ':' + (this.column + 1);
		}
	}
}
/*
package org.springframework.boot.origin;
/**
public interface Origin {
	/**
	 * Return the parent origin for this instance if there is one. The parent origin
	 * provides the origin of the item that created this one.
	 * @return the parent origin or {@code null}
	 * @since 2.4.0
	 * @see Origin#parentsFrom(Object)
	 */
	default Origin getParent() {
		return null;
	}
	/**
	 * Find the {@link Origin} that an object originated from. Checks if the source object
	 * is an {@link Origin} or {@link OriginProvider} and also searches exception stacks.
	 * @param source the source object or {@code null}
	 * @return an optional {@link Origin}
	 */
	static Origin from(Object source) {
		if (source instanceof Origin origin) {
			return origin;
		}
		Origin origin = null;
		if (source instanceof OriginProvider originProvider) {
			origin = originProvider.getOrigin();
		}
		if (origin == null && source instanceof Throwable throwable) {
			return from(throwable.getCause());
		}
		return origin;
	}
	/**
	 * Find the parents of the {@link Origin} that an object originated from. Checks if
	 * the source object is an {@link Origin} or {@link OriginProvider} and also searches
	 * exception stacks. Provides a list of all parents up to root {@link Origin},
	 * starting with the most immediate parent.
	 * @param source the source object or {@code null}
	 * @return a list of parents or an empty list if the source is {@code null}, has no
	 * origin, or no parent
	 * @since 2.4.0
	 */
	static List<Origin> parentsFrom(Object source) {
		Origin origin = from(source);
		if (origin == null) {
			return Collections.emptyList();
		}
		Set<Origin> parents = new LinkedHashSet<>();
		origin = origin.getParent();
		while (origin != null && !parents.contains(origin)) {
			parents.add(origin);
			origin = origin.getParent();
		}
		return Collections.unmodifiableList(new ArrayList<>(parents));
	}
}
/*
package org.springframework.boot.origin;
/**
final class JarUri {
	private static final String JAR_SCHEME = 'jar:';
	private static final String JAR_EXTENSION = '.jar';
	private final String uri;
	private final String description;
	private JarUri(String uri) {
		this.uri = uri;
		this.description = extractDescription(uri);
	}
	private String extractDescription(String uri) {
		uri = uri.substring(JAR_SCHEME.length());
		int firstDotJar = uri.indexOf(JAR_EXTENSION);
		String firstJar = getFilename(uri.substring(0, firstDotJar + JAR_EXTENSION.length()));
		uri = uri.substring(firstDotJar + JAR_EXTENSION.length());
		int lastDotJar = uri.lastIndexOf(JAR_EXTENSION);
		if (lastDotJar == -1) {
			return firstJar;
		}
		return firstJar + uri.substring(0, lastDotJar + JAR_EXTENSION.length());
	}
	private String getFilename(String string) {
		int lastSlash = string.lastIndexOf("/");
		return (lastSlash == -1) ? string : string.substring(lastSlash + 1);
	}
	String getDescription() {
		return this.description;
	}
	String getDescription(String existing) {
		return existing + ' from ' + this.description;
	}
	@Override
	public String toString() {
		return this.uri;
	}
	static JarUri from(URI uri) {
		return from(uri.toString());
	}
	static JarUri from(String uri) {
		if (uri.startsWith(JAR_SCHEME) && uri.contains(JAR_EXTENSION)) {
			return new JarUri(uri);
		}
		return null;
	}
}
/*
package org.springframework.boot.origin;
/**
@FunctionalInterface
public interface OriginLookup<K> {
	/**
	 * Return the origin of the given key or {@code null} if the origin cannot be
	 * determined.
	 * @param key the key to lookup
	 * @return the origin of the key or {@code null}
	 */
	Origin getOrigin(K key);
	/**
	 * Return {@code true} if this lookup is immutable and has contents that will never
	 * change.
	 * @return if the lookup is immutable
	 * @since 2.2.0
	 */
	default boolean isImmutable() {
		return false;
	}
	/**
	 * Return the implicit prefix that is applied when performing a lookup or {@code null}
	 * if no prefix is used. Prefixes can be used to disambiguate keys that would
	 * otherwise clash. For example, if multiple applications are running on the same
	 * machine a different prefix can be set on each application to ensure that different
	 * environment variables are used.
	 * @return the prefix applied by the lookup class or {@code null}.
	 * @since 2.5.0
	 */
	default String getPrefix() {
		return null;
	}
	/**
	 * Attempt to look up the origin from the given source. If the source is not a
	 * {@link OriginLookup} or if an exception occurs during lookup then {@code null} is
	 * returned.
	 * @param source the source object
	 * @param key the key to lookup
	 * @param <K> the key type
	 * @return an {@link Origin} or {@code null}
	 */
	@SuppressWarnings('unchecked')
	static <K> Origin getOrigin(Object source, K key) {
		if (!(source instanceof OriginLookup)) {
			return null;
		}
		try {
			return ((OriginLookup<K>) source).getOrigin(key);
		}
		catch (Throwable ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.origin;
/**
public class PropertySourceOrigin implements Origin, OriginProvider {
	private final PropertySource<?> propertySource;
	private final String propertyName;
	private final Origin origin;
	/**
	 * Create a new {@link PropertySourceOrigin} instance.
	 * @param propertySource the property source
	 * @param propertyName the name from the property source
	 */
	public PropertySourceOrigin(PropertySource<?> propertySource, String propertyName) {
		this(propertySource, propertyName, null);
	}
	/**
	 * Create a new {@link PropertySourceOrigin} instance.
	 * @param propertySource the property source
	 * @param propertyName the name from the property source
	 * @param origin the actual origin for the source if known
	 * @since 3.2.8
	 */
	public PropertySourceOrigin(PropertySource<?> propertySource, String propertyName, Origin origin) {
		Assert.notNull(propertySource, 'PropertySource must not be null');
		Assert.hasLength(propertyName, 'PropertyName must not be empty');
		this.propertySource = propertySource;
		this.propertyName = propertyName;
		this.origin = origin;
	}
	/**
	 * Return the origin {@link PropertySource}.
	 * @return the origin property source
	 */
	public PropertySource<?> getPropertySource() {
		return this.propertySource;
	}
	/**
	 * Return the property name that was used when obtaining the original value from the
	 * {@link #getPropertySource() property source}.
	 * @return the origin property name
	 */
	public String getPropertyName() {
		return this.propertyName;
	}
	/**
	 * Return the actual origin for the source if known.
	 * @return the actual source origin
	 * @since 3.2.8
	 */
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	@Override
	public Origin getParent() {
		return (this.origin != null) ? this.origin.getParent() : null;
	}
	@Override
	public String toString() {
		return (this.origin != null) ? this.origin.toString()
				: '\'' + this.propertyName + '\' from property source \'' + this.propertySource.getName() + '\'';
	}
	/**
	 * Get an {@link Origin} for the given {@link PropertySource} and
	 * {@code propertyName}. Will either return an {@link OriginLookup} result or a
	 * {@link PropertySourceOrigin}.
	 * @param propertySource the origin property source
	 * @param name the property name
	 * @return the property origin
	 */
	public static Origin get(PropertySource<?> propertySource, String name) {
		Origin origin = OriginLookup.getOrigin(propertySource, name);
		return (origin instanceof PropertySourceOrigin) ? origin
				: new PropertySourceOrigin(propertySource, name, origin);
	}
}
/*
package org.springframework.boot.origin;
/**
public class OriginTrackedResource implements Resource, OriginProvider {
	private final Resource resource;
	private final Origin origin;
	/**
	 * Create a new {@link OriginTrackedResource} instance.
	 * @param resource the resource to track
	 * @param origin the origin of the resource
	 */
	OriginTrackedResource(Resource resource, Origin origin) {
		Assert.notNull(resource, 'Resource must not be null');
		this.resource = resource;
		this.origin = origin;
	}
	@Override
	public InputStream getInputStream() throws IOException {
		return getResource().getInputStream();
	}
	@Override
	public boolean exists() {
		return getResource().exists();
	}
	@Override
	public boolean isReadable() {
		return getResource().isReadable();
	}
	@Override
	public boolean isOpen() {
		return getResource().isOpen();
	}
	@Override
	public boolean isFile() {
		return getResource().isFile();
	}
	@Override
	public URL getURL() throws IOException {
		return getResource().getURL();
	}
	@Override
	public URI getURI() throws IOException {
		return getResource().getURI();
	}
	@Override
	public File getFile() throws IOException {
		return getResource().getFile();
	}
	@Override
	public ReadableByteChannel readableChannel() throws IOException {
		return getResource().readableChannel();
	}
	@Override
	public long contentLength() throws IOException {
		return getResource().contentLength();
	}
	@Override
	public long lastModified() throws IOException {
		return getResource().lastModified();
	}
	@Override
	public Resource createRelative(String relativePath) throws IOException {
		return getResource().createRelative(relativePath);
	}
	@Override
	public String getFilename() {
		return getResource().getFilename();
	}
	@Override
	public String getDescription() {
		return getResource().getDescription();
	}
	public Resource getResource() {
		return this.resource;
	}
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		OriginTrackedResource other = (OriginTrackedResource) obj;
		return this.resource.equals(other) && ObjectUtils.nullSafeEquals(this.origin, other.origin);
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = this.resource.hashCode();
		result = prime * result + ObjectUtils.nullSafeHashCode(this.origin);
		return result;
	}
	@Override
	public String toString() {
		return this.resource.toString();
	}
	/**
	 * Return a new {@link OriginProvider origin tracked} version the given
	 * {@link WritableResource}.
	 * @param resource the tracked resource
	 * @param origin the origin of the resource
	 * @return an {@link OriginTrackedWritableResource} instance
	 */
	public static OriginTrackedWritableResource of(WritableResource resource, Origin origin) {
		return (OriginTrackedWritableResource) of((Resource) resource, origin);
	}
	/**
	 * Return a new {@link OriginProvider origin tracked} version the given
	 * {@link Resource}.
	 * @param resource the tracked resource
	 * @param origin the origin of the resource
	 * @return an {@link OriginTrackedResource} instance
	 */
	public static OriginTrackedResource of(Resource resource, Origin origin) {
		if (resource instanceof WritableResource writableResource) {
			return new OriginTrackedWritableResource(writableResource, origin);
		}
		return new OriginTrackedResource(resource, origin);
	}
	/**
	 * Variant of {@link OriginTrackedResource} for {@link WritableResource} instances.
	 */
	public static class OriginTrackedWritableResource extends OriginTrackedResource implements WritableResource {
		/**
		 * Create a new {@link OriginTrackedWritableResource} instance.
		 * @param resource the resource to track
		 * @param origin the origin of the resource
		 */
		OriginTrackedWritableResource(WritableResource resource, Origin origin) {
			super(resource, origin);
		}
		@Override
		public WritableResource getResource() {
			return (WritableResource) super.getResource();
		}
		@Override
		public OutputStream getOutputStream() throws IOException {
			return getResource().getOutputStream();
		}
	}
}
/*
package org.springframework.boot.origin;
/**
public class SystemEnvironmentOrigin implements Origin {
	private final String property;
	public SystemEnvironmentOrigin(String property) {
		Assert.notNull(property, 'Property name must not be null');
		Assert.hasText(property, 'Property name must not be empty');
		this.property = property;
	}
	public String getProperty() {
		return this.property;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		SystemEnvironmentOrigin other = (SystemEnvironmentOrigin) obj;
		return ObjectUtils.nullSafeEquals(this.property, other.property);
	}
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHashCode(this.property);
	}
	@Override
	public String toString() {
		return 'System Environment Property \'' + this.property + '\'';
	}
}
/*
/**
package org.springframework.boot.origin;
/*
package org.springframework.boot.origin;
/**
public class OriginTrackedValue implements OriginProvider {
	private final Object value;
	private final Origin origin;
	private OriginTrackedValue(Object value, Origin origin) {
		this.value = value;
		this.origin = origin;
	}
	/**
	 * Return the tracked value.
	 * @return the tracked value
	 */
	public Object getValue() {
		return this.value;
	}
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		return ObjectUtils.nullSafeEquals(this.value, ((OriginTrackedValue) obj).value);
	}
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHashCode(this.value);
	}
	@Override
	public String toString() {
		return (this.value != null) ? this.value.toString() : null;
	}
	public static OriginTrackedValue of(Object value) {
		return of(value, null);
	}
	/**
	 * Create an {@link OriginTrackedValue} containing the specified {@code value} and
	 * {@code origin}. If the source value implements {@link CharSequence} then so will
	 * the resulting {@link OriginTrackedValue}.
	 * @param value the source value
	 * @param origin the origin
	 * @return an {@link OriginTrackedValue} or {@code null} if the source value was
	 * {@code null}.
	 */
	public static OriginTrackedValue of(Object value, Origin origin) {
		if (value == null) {
			return null;
		}
		if (value instanceof CharSequence charSequence) {
			return new OriginTrackedCharSequence(charSequence, origin);
		}
		return new OriginTrackedValue(value, origin);
	}
	/**
	 * {@link OriginTrackedValue} for a {@link CharSequence}.
	 */
	private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence {
		OriginTrackedCharSequence(CharSequence value, Origin origin) {
			super(value, origin);
		}
		@Override
		public int length() {
			return getValue().length();
		}
		@Override
		public char charAt(int index) {
			return getValue().charAt(index);
		}
		@Override
		public CharSequence subSequence(int start, int end) {
			return getValue().subSequence(start, end);
		}
		@Override
		public CharSequence getValue() {
			return (CharSequence) super.getValue();
		}
	}
}
/*
package org.springframework.boot.env;
/**
public final class OriginTrackedMapPropertySource extends MapPropertySource implements OriginLookup<String> {
	private final boolean immutable;
	/**
	 * Create a new {@link OriginTrackedMapPropertySource} instance.
	 * @param name the property source name
	 * @param source the underlying map source
	 */
	@SuppressWarnings('rawtypes')
	public OriginTrackedMapPropertySource(String name, Map source) {
		this(name, source, false);
	}
	/**
	 * Create a new {@link OriginTrackedMapPropertySource} instance.
	 * @param name the property source name
	 * @param source the underlying map source
	 * @param immutable if the underlying source is immutable and guaranteed not to change
	 * @since 2.2.0
	 */
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	public OriginTrackedMapPropertySource(String name, Map source, boolean immutable) {
		super(name, source);
		this.immutable = immutable;
	}
	@Override
	public Object getProperty(String name) {
		Object value = super.getProperty(name);
		if (value instanceof OriginTrackedValue originTrackedValue) {
			return originTrackedValue.getValue();
		}
		return value;
	}
	@Override
	public Origin getOrigin(String name) {
		Object value = super.getProperty(name);
		if (value instanceof OriginTrackedValue originTrackedValue) {
			return originTrackedValue.getOrigin();
		}
		return null;
	}
	@Override
	public boolean isImmutable() {
		return this.immutable;
	}
}
/*
package org.springframework.boot.env;
/**
class OriginTrackedYamlLoader extends YamlProcessor {
	private final Resource resource;
	OriginTrackedYamlLoader(Resource resource) {
		this.resource = resource;
		setResources(resource);
	}
	@Override
	protected Yaml createYaml() {
		LoaderOptions loaderOptions = new LoaderOptions();
		loaderOptions.setAllowDuplicateKeys(false);
		loaderOptions.setMaxAliasesForCollections(Integer.MAX_VALUE);
		loaderOptions.setAllowRecursiveKeys(true);
		loaderOptions.setCodePointLimit(Integer.MAX_VALUE);
		return createYaml(loaderOptions);
	}
	private Yaml createYaml(LoaderOptions loaderOptions) {
		BaseConstructor constructor = new OriginTrackingConstructor(loaderOptions);
		DumperOptions dumperOptions = new DumperOptions();
		Representer representer = new Representer(dumperOptions);
		NoTimestampResolver resolver = new NoTimestampResolver();
		return new Yaml(constructor, representer, dumperOptions, loaderOptions, resolver);
	}
	List<Map<String, Object>> load() {
		List<Map<String, Object>> result = new ArrayList<>();
		process((properties, map) -> result.add(getFlattenedMap(map)));
		return result;
	}
	/**
	 * {@link Constructor} that tracks property origins.
	 */
	private class OriginTrackingConstructor extends SafeConstructor {
		OriginTrackingConstructor(LoaderOptions loadingConfig) {
			super(loadingConfig);
		}
		@Override
		public Object getData() throws NoSuchElementException {
			Object data = super.getData();
			if (data instanceof CharSequence charSequence && charSequence.isEmpty()) {
				return null;
			}
			return data;
		}
		@Override
		protected Object constructObject(Node node) {
			if (node instanceof SequenceNode sequenceNode && sequenceNode.getValue().isEmpty()) {
				return constructTrackedObject(node, '');
			}
			if (node instanceof ScalarNode) {
				if (!(node instanceof KeyScalarNode)) {
					return constructTrackedObject(node, super.constructObject(node));
				}
			}
			if (node instanceof MappingNode mappingNode) {
				replaceMappingNodeKeys(mappingNode);
			}
			return super.constructObject(node);
		}
		private void replaceMappingNodeKeys(MappingNode node) {
			List<NodeTuple> newValue = new ArrayList<>();
			node.getValue().stream().map(KeyScalarNode::get).forEach(newValue::add);
			node.setValue(newValue);
		}
		private Object constructTrackedObject(Node node, Object value) {
			Origin origin = getOrigin(node);
			return OriginTrackedValue.of(getValue(value), origin);
		}
		private Object getValue(Object value) {
			return (value != null) ? value : '';
		}
		private Origin getOrigin(Node node) {
			Mark mark = node.getStartMark();
			Location location = new Location(mark.getLine(), mark.getColumn());
			return new TextResourceOrigin(OriginTrackedYamlLoader.this.resource, location);
		}
	}
	/**
	 * {@link ScalarNode} that replaces the key node in a {@link NodeTuple}.
	 */
	private static class KeyScalarNode extends ScalarNode {
		KeyScalarNode(ScalarNode node) {
			super(node.getTag(), node.getValue(), node.getStartMark(), node.getEndMark(), node.getScalarStyle());
		}
		static NodeTuple get(NodeTuple nodeTuple) {
			Node keyNode = nodeTuple.getKeyNode();
			Node valueNode = nodeTuple.getValueNode();
			return new NodeTuple(KeyScalarNode.get(keyNode), valueNode);
		}
		private static Node get(Node node) {
			if (node instanceof ScalarNode scalarNode) {
				return new KeyScalarNode(scalarNode);
			}
			return node;
		}
	}
	/**
	 * {@link Resolver} that limits {@link Tag#TIMESTAMP} tags.
	 */
	private static final class NoTimestampResolver extends Resolver {
		@Override
		public void addImplicitResolver(Tag tag, Pattern regexp, String first, int limit) {
			if (tag == Tag.TIMESTAMP) {
				return;
			}
			super.addImplicitResolver(tag, regexp, first, limit);
		}
	}
}
/*
package org.springframework.boot.env;
/**
public class ConfigTreePropertySource extends EnumerablePropertySource<Path> implements OriginLookup<String> {
	private static final int MAX_DEPTH = 100;
	private final Map<String, PropertyFile> propertyFiles;
	private final String[] names;
	private final Set<Option> options;
	/**
	 * Create a new {@link ConfigTreePropertySource} instance.
	 * @param name the name of the property source
	 * @param sourceDirectory the underlying source directory
	 */
	public ConfigTreePropertySource(String name, Path sourceDirectory) {
		this(name, sourceDirectory, EnumSet.noneOf(Option.class));
	}
	/**
	 * Create a new {@link ConfigTreePropertySource} instance.
	 * @param name the name of the property source
	 * @param sourceDirectory the underlying source directory
	 * @param options the property source options
	 */
	public ConfigTreePropertySource(String name, Path sourceDirectory, Option... options) {
		this(name, sourceDirectory, EnumSet.copyOf(Arrays.asList(options)));
	}
	private ConfigTreePropertySource(String name, Path sourceDirectory, Set<Option> options) {
		super(name, sourceDirectory);
		Assert.isTrue(Files.exists(sourceDirectory), () -> 'Directory "' + sourceDirectory + '" does not exist');
		Assert.isTrue(Files.isDirectory(sourceDirectory), () -> 'File "' + sourceDirectory + '" is not a directory');
		this.propertyFiles = PropertyFile.findAll(sourceDirectory, options);
		this.options = options;
		this.names = StringUtils.toStringArray(this.propertyFiles.keySet());
	}
	@Override
	public String[] getPropertyNames() {
		return this.names.clone();
	}
	@Override
	public Value getProperty(String name) {
		PropertyFile propertyFile = this.propertyFiles.get(name);
		return (propertyFile != null) ? propertyFile.getContent() : null;
	}
	@Override
	public Origin getOrigin(String name) {
		PropertyFile propertyFile = this.propertyFiles.get(name);
		return (propertyFile != null) ? propertyFile.getOrigin() : null;
	}
	@Override
	public boolean isImmutable() {
		return !this.options.contains(Option.ALWAYS_READ);
	}
	/**
	 * Property source options.
	 */
	public enum Option {
		/**
		 * Always read the value of the file when accessing the property value. When this
		 * option is not set the property source will cache the value when it"s first
		 * read.
		 */
		ALWAYS_READ,
		/**
		 * Convert file and directory names to lowercase.
		 */
		USE_LOWERCASE_NAMES,
		/**
		 * Automatically attempt trim trailing new-line characters.
		 */
		AUTO_TRIM_TRAILING_NEW_LINE
	}
	/**
	 * A value returned from the property source which exposes the contents of the
	 * property file. Values can either be treated as {@link CharSequence} or as an
	 * {@link InputStreamSource}.
	 */
	public interface Value extends CharSequence, InputStreamSource {
	}
	/**
	 * A single property file that was found when the source was created.
	 */
	private static final class PropertyFile {
		private static final Location START_OF_FILE = new Location(0, 0);
		private final Path path;
		private final PathResource resource;
		private final Origin origin;
		private final PropertyFileContent cachedContent;
		private final boolean autoTrimTrailingNewLine;
		private PropertyFile(Path path, Set<Option> options) {
			this.path = path;
			this.resource = new PathResource(path);
			this.origin = new TextResourceOrigin(this.resource, START_OF_FILE);
			this.autoTrimTrailingNewLine = options.contains(Option.AUTO_TRIM_TRAILING_NEW_LINE);
			this.cachedContent = options.contains(Option.ALWAYS_READ) ? null
					: new PropertyFileContent(path, this.resource, this.origin, true, this.autoTrimTrailingNewLine);
		}
		PropertyFileContent getContent() {
			if (this.cachedContent != null) {
				return this.cachedContent;
			}
			return new PropertyFileContent(this.path, this.resource, this.origin, false, this.autoTrimTrailingNewLine);
		}
		Origin getOrigin() {
			return this.origin;
		}
		static Map<String, PropertyFile> findAll(Path sourceDirectory, Set<Option> options) {
			try {
				Map<String, PropertyFile> propertyFiles = new TreeMap<>();
				try (Stream<Path> pathStream = Files.find(sourceDirectory, MAX_DEPTH, PropertyFile::isPropertyFile,
						FileVisitOption.FOLLOW_LINKS)) {
					pathStream.forEach((path) -> {
						String name = getName(sourceDirectory.relativize(path));
						if (StringUtils.hasText(name)) {
							if (options.contains(Option.USE_LOWERCASE_NAMES)) {
								name = name.toLowerCase(Locale.getDefault());
							}
							propertyFiles.put(name, new PropertyFile(path, options));
						}
					});
				}
				return Collections.unmodifiableMap(propertyFiles);
			}
			catch (IOException ex) {
				throw new IllegalStateException('Unable to find files in "' + sourceDirectory + '"', ex);
			}
		}
		private static boolean isPropertyFile(Path path, BasicFileAttributes attributes) {
			return !hasHiddenPathElement(path) && (attributes.isRegularFile() || attributes.isSymbolicLink());
		}
		private static boolean hasHiddenPathElement(Path path) {
			for (Path element : path) {
				if (element.toString().startsWith('..')) {
					return true;
				}
			}
			return false;
		}
		private static String getName(Path relativePath) {
			int nameCount = relativePath.getNameCount();
			if (nameCount == 1) {
				return relativePath.toString();
			}
			StringBuilder name = new StringBuilder();
			for (int i = 0; i < nameCount; i++) {
				name.append((i != 0) ? '.' : '');
				name.append(relativePath.getName(i));
			}
			return name.toString();
		}
	}
	/**
	 * The contents of a found property file.
	 */
	private static final class PropertyFileContent implements Value, OriginProvider {
		private final Path path;
		private final Lock resourceLock = new ReentrantLock();
		private final Resource resource;
		private final Origin origin;
		private final boolean cacheContent;
		private final boolean autoTrimTrailingNewLine;
		private volatile byte[] content;
		private PropertyFileContent(Path path, Resource resource, Origin origin, boolean cacheContent,
				boolean autoTrimTrailingNewLine) {
			this.path = path;
			this.resource = resource;
			this.origin = origin;
			this.cacheContent = cacheContent;
			this.autoTrimTrailingNewLine = autoTrimTrailingNewLine;
		}
		@Override
		public Origin getOrigin() {
			return this.origin;
		}
		@Override
		public int length() {
			return toString().length();
		}
		@Override
		public char charAt(int index) {
			return toString().charAt(index);
		}
		@Override
		public CharSequence subSequence(int start, int end) {
			return toString().subSequence(start, end);
		}
		@Override
		public String toString() {
			String string = new String(getBytes());
			if (this.autoTrimTrailingNewLine) {
				string = autoTrimTrailingNewLine(string);
			}
			return string;
		}
		private String autoTrimTrailingNewLine(String string) {
			if (!string.endsWith('\n')) {
				return string;
			}
			int numberOfLines = 0;
			for (int i = 0; i < string.length(); i++) {
				char ch = string.charAt(i);
				if (ch == "\n") {
					numberOfLines++;
				}
			}
			if (numberOfLines > 1) {
				return string;
			}
			return (string.endsWith('\r\n')) ? string.substring(0, string.length() - 2)
					: string.substring(0, string.length() - 1);
		}
		@Override
		public InputStream getInputStream() throws IOException {
			if (!this.cacheContent) {
				assertStillExists();
				return this.resource.getInputStream();
			}
			return new ByteArrayInputStream(getBytes());
		}
		private byte[] getBytes() {
			try {
				if (!this.cacheContent) {
					assertStillExists();
					return FileCopyUtils.copyToByteArray(this.resource.getInputStream());
				}
				if (this.content == null) {
					assertStillExists();
					this.resourceLock.lock();
					try {
						if (this.content == null) {
							this.content = FileCopyUtils.copyToByteArray(this.resource.getInputStream());
						}
					}
					finally {
						this.resourceLock.unlock();
					}
				}
				return this.content;
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
		private void assertStillExists() {
			Assert.state(Files.exists(this.path), () -> 'The property file "' + this.path + '" no longer exists');
		}
	}
}
/*
package org.springframework.boot.env;
/**
public class PropertiesPropertySourceLoader implements PropertySourceLoader {
	private static final String XML_FILE_EXTENSION = '.xml';
	@Override
	public String[] getFileExtensions() {
		return new String[] { 'properties', 'xml' };
	}
	@Override
	public List<PropertySource<?>> load(String name, Resource resource) throws IOException {
		List<Map<String, ?>> properties = loadProperties(resource);
		if (properties.isEmpty()) {
			return Collections.emptyList();
		}
		List<PropertySource<?>> propertySources = new ArrayList<>(properties.size());
		for (int i = 0; i < properties.size(); i++) {
			String documentNumber = (properties.size() != 1) ? ' (document #' + i + ')' : '';
			propertySources.add(new OriginTrackedMapPropertySource(name + documentNumber,
					Collections.unmodifiableMap(properties.get(i)), true));
		}
		return propertySources;
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private List<Map<String, ?>> loadProperties(Resource resource) throws IOException {
		String filename = resource.getFilename();
		List<Map<String, ?>> result = new ArrayList<>();
		if (filename != null && filename.endsWith(XML_FILE_EXTENSION)) {
			result.add((Map) PropertiesLoaderUtils.loadProperties(resource));
		}
		else {
			List<Document> documents = new OriginTrackedPropertiesLoader(resource).load();
			documents.forEach((document) -> result.add(document.asMap()));
		}
		return result;
	}
}
/*
package org.springframework.boot.env;
/**
public class SystemEnvironmentPropertySourceEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
	/**
	 * The default order for the processor.
	 */
	public static final int DEFAULT_ORDER = SpringApplicationJsonEnvironmentPostProcessor.DEFAULT_ORDER - 1;
	private int order = DEFAULT_ORDER;
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		String sourceName = StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME;
		PropertySource<?> propertySource = environment.getPropertySources().get(sourceName);
		if (propertySource != null) {
			replacePropertySource(environment, sourceName, propertySource, application.getEnvironmentPrefix());
		}
	}
	@SuppressWarnings('unchecked')
	private void replacePropertySource(ConfigurableEnvironment environment, String sourceName,
			PropertySource<?> propertySource, String environmentPrefix) {
		Map<String, Object> originalSource = (Map<String, Object>) propertySource.getSource();
		SystemEnvironmentPropertySource source = new OriginAwareSystemEnvironmentPropertySource(sourceName,
				originalSource, environmentPrefix);
		environment.getPropertySources().replace(sourceName, source);
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	/**
	 * {@link SystemEnvironmentPropertySource} that also tracks {@link Origin}.
	 */
	protected static class OriginAwareSystemEnvironmentPropertySource extends SystemEnvironmentPropertySource
			implements OriginLookup<String> {
		private final String prefix;
		OriginAwareSystemEnvironmentPropertySource(String name, Map<String, Object> source, String environmentPrefix) {
			super(name, source);
			this.prefix = determinePrefix(environmentPrefix);
		}
		private String determinePrefix(String environmentPrefix) {
			if (!StringUtils.hasText(environmentPrefix)) {
				return null;
			}
			if (environmentPrefix.endsWith('.') || environmentPrefix.endsWith('_') || environmentPrefix.endsWith('-')) {
				return environmentPrefix.substring(0, environmentPrefix.length() - 1);
			}
			return environmentPrefix;
		}
		@Override
		public boolean containsProperty(String name) {
			return super.containsProperty(name);
		}
		@Override
		public Object getProperty(String name) {
			return super.getProperty(name);
		}
		@Override
		public Origin getOrigin(String key) {
			String property = resolvePropertyName(key);
			if (super.containsProperty(property)) {
				return new SystemEnvironmentOrigin(property);
			}
			return null;
		}
		@Override
		public String getPrefix() {
			return this.prefix;
		}
	}
}
/*
package org.springframework.boot.env;
/**
public class EnvironmentPostProcessorApplicationListener implements SmartApplicationListener, Ordered {
	private static final String AOT_FEATURE_NAME = 'EnvironmentPostProcessor';
	/**
	 * The default order for the processor.
	 */
	public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 10;
	private final DeferredLogs deferredLogs;
	private int order = DEFAULT_ORDER;
	private final Function<ClassLoader, EnvironmentPostProcessorsFactory> postProcessorsFactory;
	/**
	 * Create a new {@link EnvironmentPostProcessorApplicationListener} with
	 * {@link EnvironmentPostProcessor} classes loaded through {@code spring.factories}.
	 */
	public EnvironmentPostProcessorApplicationListener() {
		this(EnvironmentPostProcessorsFactory::fromSpringFactories);
	}
	/**
	 * Create a new {@link EnvironmentPostProcessorApplicationListener} with post
	 * processors created by the given factory.
	 * @param postProcessorsFactory the post processors factory
	 */
	private EnvironmentPostProcessorApplicationListener(
			Function<ClassLoader, EnvironmentPostProcessorsFactory> postProcessorsFactory) {
		this.postProcessorsFactory = postProcessorsFactory;
		this.deferredLogs = new DeferredLogs();
	}
	/**
	 * Factory method that creates an {@link EnvironmentPostProcessorApplicationListener}
	 * with a specific {@link EnvironmentPostProcessorsFactory}.
	 * @param postProcessorsFactory the environment post processor factory
	 * @return an {@link EnvironmentPostProcessorApplicationListener} instance
	 */
	public static EnvironmentPostProcessorApplicationListener with(
			EnvironmentPostProcessorsFactory postProcessorsFactory) {
		return new EnvironmentPostProcessorApplicationListener((classloader) -> postProcessorsFactory);
	}
	@Override
	public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
		return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType)
				|| ApplicationPreparedEvent.class.isAssignableFrom(eventType)
				|| ApplicationFailedEvent.class.isAssignableFrom(eventType);
	}
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof ApplicationEnvironmentPreparedEvent environmentPreparedEvent) {
			onApplicationEnvironmentPreparedEvent(environmentPreparedEvent);
		}
		if (event instanceof ApplicationPreparedEvent) {
			onApplicationPreparedEvent();
		}
		if (event instanceof ApplicationFailedEvent) {
			onApplicationFailedEvent();
		}
	}
	private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
		ConfigurableEnvironment environment = event.getEnvironment();
		SpringApplication application = event.getSpringApplication();
		List<EnvironmentPostProcessor> postProcessors = getEnvironmentPostProcessors(application.getResourceLoader(),
				event.getBootstrapContext());
		addAotGeneratedEnvironmentPostProcessorIfNecessary(postProcessors, application);
		for (EnvironmentPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessEnvironment(environment, application);
		}
	}
	private void onApplicationPreparedEvent() {
		finish();
	}
	private void onApplicationFailedEvent() {
		finish();
	}
	private void finish() {
		this.deferredLogs.switchOverAll();
	}
	List<EnvironmentPostProcessor> getEnvironmentPostProcessors(ResourceLoader resourceLoader,
			ConfigurableBootstrapContext bootstrapContext) {
		ClassLoader classLoader = (resourceLoader != null) ? resourceLoader.getClassLoader() : null;
		EnvironmentPostProcessorsFactory postProcessorsFactory = this.postProcessorsFactory.apply(classLoader);
		return postProcessorsFactory.getEnvironmentPostProcessors(this.deferredLogs, bootstrapContext);
	}
	private void addAotGeneratedEnvironmentPostProcessorIfNecessary(List<EnvironmentPostProcessor> postProcessors,
			SpringApplication springApplication) {
		if (AotDetector.useGeneratedArtifacts()) {
			ClassLoader classLoader = (springApplication.getResourceLoader() != null)
					? springApplication.getResourceLoader().getClassLoader() : null;
			String postProcessorClassName = springApplication.getMainApplicationClass().getName() + '__'
					+ AOT_FEATURE_NAME;
			if (ClassUtils.isPresent(postProcessorClassName, classLoader)) {
				postProcessors.add(0, instantiateEnvironmentPostProcessor(postProcessorClassName, classLoader));
			}
		}
	}
	private EnvironmentPostProcessor instantiateEnvironmentPostProcessor(String postProcessorClassName,
			ClassLoader classLoader) {
		try {
			Class<?> initializerClass = ClassUtils.resolveClassName(postProcessorClassName, classLoader);
			Assert.isAssignable(EnvironmentPostProcessor.class, initializerClass);
			return (EnvironmentPostProcessor) BeanUtils.instantiateClass(initializerClass);
		}
		catch (BeanInstantiationException ex) {
			throw new IllegalArgumentException(
					'Failed to instantiate EnvironmentPostProcessor: ' + postProcessorClassName, ex);
		}
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	/**
	 * Contribute a {@code <Application>__EnvironmentPostProcessor} class that stores AOT
	 * optimizations.
	 */
	static class EnvironmentBeanFactoryInitializationAotProcessor implements BeanFactoryInitializationAotProcessor {
		@Override
		public BeanFactoryInitializationAotContribution processAheadOfTime(
				ConfigurableListableBeanFactory beanFactory) {
			Environment environment = beanFactory.getBean(ConfigurableApplicationContext.ENVIRONMENT_BEAN_NAME,
					Environment.class);
			String[] activeProfiles = environment.getActiveProfiles();
			String[] defaultProfiles = environment.getDefaultProfiles();
			if (!ObjectUtils.isEmpty(activeProfiles) && !Arrays.equals(activeProfiles, defaultProfiles)) {
				return new EnvironmentAotContribution(activeProfiles);
			}
			return null;
		}
	}
	private static final class EnvironmentAotContribution implements BeanFactoryInitializationAotContribution {
		private static final String ENVIRONMENT_VARIABLE = 'environment';
		private final String[] activeProfiles;
		private EnvironmentAotContribution(String[] activeProfiles) {
			this.activeProfiles = activeProfiles;
		}
		@Override
		public void applyTo(GenerationContext generationContext,
				BeanFactoryInitializationCode beanFactoryInitializationCode) {
			GeneratedClass generatedClass = generationContext.getGeneratedClasses()
				.addForFeature(AOT_FEATURE_NAME, (type) -> {
					type.addModifiers(Modifier.PUBLIC);
					type.addJavadoc('Configure the environment with AOT optimizations.');
					type.addSuperinterface(EnvironmentPostProcessor.class);
				});
			generatedClass.getMethods().add('postProcessEnvironment', (method) -> {
				method.addModifiers(Modifier.PUBLIC);
				method.addAnnotation(Override.class);
				method.addParameter(ConfigurableEnvironment.class, ENVIRONMENT_VARIABLE);
				method.addParameter(SpringApplication.class, 'application');
				method.addCode(generateActiveProfilesInitializeCode());
			});
		}
		private CodeBlock generateActiveProfilesInitializeCode() {
			CodeBlock.Builder code = CodeBlock.builder();
			for (String activeProfile : this.activeProfiles) {
				code.addStatement('$L.addActiveProfile($S)', ENVIRONMENT_VARIABLE, activeProfile);
			}
			return code.build();
		}
	}
}
/*
package org.springframework.boot.env;
/**
public interface PropertySourceLoader {
	/**
	 * Returns the file extensions that the loader supports (excluding the ".").
	 * @return the file extensions
	 */
	String[] getFileExtensions();
	/**
	 * Load the resource into one or more property sources. Implementations may either
	 * return a list containing a single source, or in the case of a multi-document format
	 * such as yaml a source for each document in the resource.
	 * @param name the root name of the property source. If multiple documents are loaded
	 * an additional suffix should be added to the name for each source loaded.
	 * @param resource the resource to load
	 * @return a list property sources
	 * @throws IOException if the source cannot be loaded
	 */
	List<PropertySource<?>> load(String name, Resource resource) throws IOException;
}
/*
package org.springframework.boot.env;
/**
public class YamlPropertySourceLoader implements PropertySourceLoader {
	@Override
	public String[] getFileExtensions() {
		return new String[] { 'yml', 'yaml' };
	}
	@Override
	public List<PropertySource<?>> load(String name, Resource resource) throws IOException {
		if (!ClassUtils.isPresent('org.yaml.snakeyaml.Yaml', getClass().getClassLoader())) {
			throw new IllegalStateException(
					'Attempted to load ' + name + ' but snakeyaml was not found on the classpath');
		}
		List<Map<String, Object>> loaded = new OriginTrackedYamlLoader(resource).load();
		if (loaded.isEmpty()) {
			return Collections.emptyList();
		}
		List<PropertySource<?>> propertySources = new ArrayList<>(loaded.size());
		for (int i = 0; i < loaded.size(); i++) {
			String documentNumber = (loaded.size() != 1) ? ' (document #' + i + ')' : '';
			propertySources.add(new OriginTrackedMapPropertySource(name + documentNumber,
					Collections.unmodifiableMap(loaded.get(i)), true));
		}
		return propertySources;
	}
}
/*
package org.springframework.boot.env;
/**
class ReflectionEnvironmentPostProcessorsFactory implements EnvironmentPostProcessorsFactory {
	private final List<Class<?>> classes;
	private ClassLoader classLoader;
	private final List<String> classNames;
	ReflectionEnvironmentPostProcessorsFactory(Class<?>... classes) {
		this.classes = new ArrayList<>(Arrays.asList(classes));
		this.classNames = null;
	}
	ReflectionEnvironmentPostProcessorsFactory(ClassLoader classLoader, String... classNames) {
		this(classLoader, Arrays.asList(classNames));
	}
	ReflectionEnvironmentPostProcessorsFactory(ClassLoader classLoader, List<String> classNames) {
		this.classes = null;
		this.classLoader = classLoader;
		this.classNames = classNames;
	}
	@Override
	public List<EnvironmentPostProcessor> getEnvironmentPostProcessors(DeferredLogFactory logFactory,
			ConfigurableBootstrapContext bootstrapContext) {
		Instantiator<EnvironmentPostProcessor> instantiator = new Instantiator<>(EnvironmentPostProcessor.class,
				(parameters) -> {
					parameters.add(DeferredLogFactory.class, logFactory);
					parameters.add(Log.class, logFactory::getLog);
					parameters.add(ConfigurableBootstrapContext.class, bootstrapContext);
					parameters.add(BootstrapContext.class, bootstrapContext);
					parameters.add(BootstrapRegistry.class, bootstrapContext);
				});
		return (this.classes != null) ? instantiator.instantiateTypes(this.classes)
				: instantiator.instantiate(this.classLoader, this.classNames);
	}
}
/*
package org.springframework.boot.env;
/**
@FunctionalInterface
public interface EnvironmentPostProcessorsFactory {
	/**
	 * Create all requested {@link EnvironmentPostProcessor} instances.
	 * @param logFactory a deferred log factory
	 * @param bootstrapContext a bootstrap context
	 * @return the post processor instances
	 */
	List<EnvironmentPostProcessor> getEnvironmentPostProcessors(DeferredLogFactory logFactory,
			ConfigurableBootstrapContext bootstrapContext);
	/**
	 * Return a {@link EnvironmentPostProcessorsFactory} backed by
	 * {@code spring.factories}.
	 * @param classLoader the source class loader
	 * @return an {@link EnvironmentPostProcessorsFactory} instance
	 */
	static EnvironmentPostProcessorsFactory fromSpringFactories(ClassLoader classLoader) {
		return new SpringFactoriesEnvironmentPostProcessorsFactory(
				SpringFactoriesLoader.forDefaultResourceLocation(classLoader));
	}
	/**
	 * Return a {@link EnvironmentPostProcessorsFactory} that reflectively creates post
	 * processors from the given classes.
	 * @param classes the post processor classes
	 * @return an {@link EnvironmentPostProcessorsFactory} instance
	 */
	static EnvironmentPostProcessorsFactory of(Class<?>... classes) {
		return new ReflectionEnvironmentPostProcessorsFactory(classes);
	}
	/**
	 * Return a {@link EnvironmentPostProcessorsFactory} that reflectively creates post
	 * processors from the given class names.
	 * @param classNames the post processor class names
	 * @return an {@link EnvironmentPostProcessorsFactory} instance
	 */
	static EnvironmentPostProcessorsFactory of(String... classNames) {
		return of(null, classNames);
	}
	/**
	 * Return a {@link EnvironmentPostProcessorsFactory} that reflectively creates post
	 * processors from the given class names.
	 * @param classLoader the source class loader
	 * @param classNames the post processor class names
	 * @return an {@link EnvironmentPostProcessorsFactory} instance
	 * @since 2.4.8
	 */
	static EnvironmentPostProcessorsFactory of(ClassLoader classLoader, String... classNames) {
		return new ReflectionEnvironmentPostProcessorsFactory(classLoader, classNames);
	}
}
/*
package org.springframework.boot.env;
/**
public class RandomValuePropertySource extends PropertySource<Random> {
	/**
	 * Name of the random {@link PropertySource}.
	 */
	public static final String RANDOM_PROPERTY_SOURCE_NAME = 'random';
	private static final String PREFIX = 'random.';
	private static final Log logger = LogFactory.getLog(RandomValuePropertySource.class);
	public RandomValuePropertySource() {
		this(RANDOM_PROPERTY_SOURCE_NAME);
	}
	public RandomValuePropertySource(String name) {
		super(name, new Random());
	}
	@Override
	public Object getProperty(String name) {
		if (!name.startsWith(PREFIX)) {
			return null;
		}
		logger.trace(LogMessage.format('Generating random property for "%s"', name));
		return getRandomValue(name.substring(PREFIX.length()));
	}
	private Object getRandomValue(String type) {
		if (type.equals('int')) {
			return getSource().nextInt();
		}
		if (type.equals('long')) {
			return getSource().nextLong();
		}
		String range = getRange(type, 'int');
		if (range != null) {
			return getNextIntInRange(Range.of(range, Integer::parseInt));
		}
		range = getRange(type, 'long');
		if (range != null) {
			return getNextLongInRange(Range.of(range, Long::parseLong));
		}
		if (type.equals('uuid')) {
			return UUID.randomUUID().toString();
		}
		return getRandomBytes();
	}
	private String getRange(String type, String prefix) {
		if (type.startsWith(prefix)) {
			int startIndex = prefix.length() + 1;
			if (type.length() > startIndex) {
				return type.substring(startIndex, type.length() - 1);
			}
		}
		return null;
	}
	private int getNextIntInRange(Range<Integer> range) {
		OptionalInt first = getSource().ints(1, range.getMin(), range.getMax()).findFirst();
		assertPresent(first.isPresent(), range);
		return first.getAsInt();
	}
	private long getNextLongInRange(Range<Long> range) {
		OptionalLong first = getSource().longs(1, range.getMin(), range.getMax()).findFirst();
		assertPresent(first.isPresent(), range);
		return first.getAsLong();
	}
	private void assertPresent(boolean present, Range<?> range) {
		Assert.state(present, () -> 'Could not get random number for range "' + range + '"');
	}
	private Object getRandomBytes() {
		byte[] bytes = new byte[16];
		getSource().nextBytes(bytes);
		return HexFormat.of().withLowerCase().formatHex(bytes);
	}
	public static void addToEnvironment(ConfigurableEnvironment environment) {
		addToEnvironment(environment, logger);
	}
	static void addToEnvironment(ConfigurableEnvironment environment, Log logger) {
		MutablePropertySources sources = environment.getPropertySources();
		PropertySource<?> existing = sources.get(RANDOM_PROPERTY_SOURCE_NAME);
		if (existing != null) {
			logger.trace('RandomValuePropertySource already present');
			return;
		}
		RandomValuePropertySource randomSource = new RandomValuePropertySource(RANDOM_PROPERTY_SOURCE_NAME);
		if (sources.get(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME) != null) {
			sources.addAfter(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, randomSource);
		}
		else {
			sources.addLast(randomSource);
		}
		logger.trace('RandomValuePropertySource add to Environment');
	}
	static final class Range<T extends Number> {
		private final String value;
		private final T min;
		private final T max;
		private Range(String value, T min, T max) {
			this.value = value;
			this.min = min;
			this.max = max;
		}
		T getMin() {
			return this.min;
		}
		T getMax() {
			return this.max;
		}
		@Override
		public String toString() {
			return this.value;
		}
		static <T extends Number & Comparable<T>> Range<T> of(String value, Function<String, T> parse) {
			T zero = parse.apply('0');
			String[] tokens = StringUtils.commaDelimitedListToStringArray(value);
			T min = parse.apply(tokens[0]);
			if (tokens.length == 1) {
				Assert.isTrue(min.compareTo(zero) > 0, 'Bound must be positive.');
				return new Range<>(value, zero, min);
			}
			T max = parse.apply(tokens[1]);
			Assert.isTrue(min.compareTo(max) < 0, 'Lower bound must be less than upper bound.');
			return new Range<>(value, min, max);
		}
	}
}
/*
package org.springframework.boot.env;
/**
public class SpringApplicationJsonEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
	/**
	 * Name of the {@code spring.application.json} property.
	 */
	public static final String SPRING_APPLICATION_JSON_PROPERTY = 'spring.application.json';
	/**
	 * Name of the {@code SPRING_APPLICATION_JSON} environment variable.
	 */
	public static final String SPRING_APPLICATION_JSON_ENVIRONMENT_VARIABLE = 'SPRING_APPLICATION_JSON';
	private static final String SERVLET_ENVIRONMENT_CLASS = 'org.springframework.web.'
			+ 'context.support.StandardServletEnvironment';
	private static final Set<String> SERVLET_ENVIRONMENT_PROPERTY_SOURCES = new LinkedHashSet<>(
			Arrays.asList(StandardServletEnvironment.JNDI_PROPERTY_SOURCE_NAME,
					StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME,
					StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME));
	/**
	 * The default order for the processor.
	 */
	public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 5;
	private int order = DEFAULT_ORDER;
	@Override
	public int getOrder() {
		return this.order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		MutablePropertySources propertySources = environment.getPropertySources();
		propertySources.stream()
			.map(JsonPropertyValue::get)
			.filter(Objects::nonNull)
			.findFirst()
			.ifPresent((v) -> processJson(environment, v));
	}
	private void processJson(ConfigurableEnvironment environment, JsonPropertyValue propertyValue) {
		JsonParser parser = JsonParserFactory.getJsonParser();
		Map<String, Object> map = parser.parseMap(propertyValue.getJson());
		if (!map.isEmpty()) {
			addJsonPropertySource(environment, new JsonPropertySource(propertyValue, flatten(map)));
		}
	}
	/**
	 * Flatten the map keys using period separator.
	 * @param map the map that should be flattened
	 * @return the flattened map
	 */
	private Map<String, Object> flatten(Map<String, Object> map) {
		Map<String, Object> result = new LinkedHashMap<>();
		flatten(null, result, map);
		return result;
	}
	private void flatten(String prefix, Map<String, Object> result, Map<String, Object> map) {
		String namePrefix = (prefix != null) ? prefix + '.' : '';
		map.forEach((key, value) -> extract(namePrefix + key, result, value));
	}
	@SuppressWarnings('unchecked')
	private void extract(String name, Map<String, Object> result, Object value) {
		if (value instanceof Map<?, ?> map) {
			if (CollectionUtils.isEmpty(map)) {
				result.put(name, value);
				return;
			}
			flatten(name, result, (Map<String, Object>) value);
		}
		else if (value instanceof Collection<?> collection) {
			if (CollectionUtils.isEmpty(collection)) {
				result.put(name, value);
				return;
			}
			int index = 0;
			for (Object object : collection) {
				extract(name + '[' + index + ']', result, object);
				index++;
			}
		}
		else {
			result.put(name, value);
		}
	}
	private void addJsonPropertySource(ConfigurableEnvironment environment, PropertySource<?> source) {
		MutablePropertySources sources = environment.getPropertySources();
		String name = findPropertySource(sources);
		if (sources.contains(name)) {
			sources.addBefore(name, source);
		}
		else {
			sources.addFirst(source);
		}
	}
	private String findPropertySource(MutablePropertySources sources) {
		if (ClassUtils.isPresent(SERVLET_ENVIRONMENT_CLASS, null)) {
			PropertySource<?> servletPropertySource = sources.stream()
				.filter((source) -> SERVLET_ENVIRONMENT_PROPERTY_SOURCES.contains(source.getName()))
				.findFirst()
				.orElse(null);
			if (servletPropertySource != null) {
				return servletPropertySource.getName();
			}
		}
		return StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME;
	}
	private static class JsonPropertySource extends MapPropertySource implements OriginLookup<String> {
		private final JsonPropertyValue propertyValue;
		JsonPropertySource(JsonPropertyValue propertyValue, Map<String, Object> source) {
			super(SPRING_APPLICATION_JSON_PROPERTY, source);
			this.propertyValue = propertyValue;
		}
		@Override
		public Origin getOrigin(String key) {
			return this.propertyValue.getOrigin();
		}
	}
	private static class JsonPropertyValue {
		private static final String[] CANDIDATES = { SPRING_APPLICATION_JSON_PROPERTY,
				SPRING_APPLICATION_JSON_ENVIRONMENT_VARIABLE };
		private final PropertySource<?> propertySource;
		private final String propertyName;
		private final String json;
		JsonPropertyValue(PropertySource<?> propertySource, String propertyName, String json) {
			this.propertySource = propertySource;
			this.propertyName = propertyName;
			this.json = json;
		}
		String getJson() {
			return this.json;
		}
		Origin getOrigin() {
			return PropertySourceOrigin.get(this.propertySource, this.propertyName);
		}
		static JsonPropertyValue get(PropertySource<?> propertySource) {
			for (String candidate : CANDIDATES) {
				Object value = propertySource.getProperty(candidate);
				if (value instanceof String string && StringUtils.hasLength(string)) {
					return new JsonPropertyValue(propertySource, candidate, string);
				}
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.env;
/**
@FunctionalInterface
public interface EnvironmentPostProcessor {
	/**
	 * Post-process the given {@code environment}.
	 * @param environment the environment to post-process
	 * @param application the application to which the environment belongs
	 */
	void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application);
}
/*
package org.springframework.boot.env;
/**
class PropertySourceRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		hints.reflection()
			.registerTypeIfPresent(classLoader, 'org.yaml.snakeyaml.Yaml',
					(typeHint) -> typeHint.onReachableType(TypeReference.of(YamlPropertySourceLoader.class)));
	}
}
/*
package org.springframework.boot.env;
/**
class OriginTrackedPropertiesLoader {
	private final Resource resource;
	/**
	 * Create a new {@link OriginTrackedPropertiesLoader} instance.
	 * @param resource the resource of the {@code .properties} data
	 */
	OriginTrackedPropertiesLoader(Resource resource) {
		Assert.notNull(resource, 'Resource must not be null');
		this.resource = resource;
	}
	/**
	 * Load {@code .properties} data and return a list of documents.
	 * @return the loaded properties
	 * @throws IOException on read error
	 */
	List<Document> load() throws IOException {
		return load(true);
	}
	/**
	 * Load {@code .properties} data and return a map of {@code String} ->
	 * {@link OriginTrackedValue}.
	 * @param expandLists if list {@code name[]=a,b,c} shortcuts should be expanded
	 * @return the loaded properties
	 * @throws IOException on read error
	 */
	List<Document> load(boolean expandLists) throws IOException {
		List<Document> documents = new ArrayList<>();
		Document document = new Document();
		StringBuilder buffer = new StringBuilder();
		try (CharacterReader reader = new CharacterReader(this.resource)) {
			while (reader.read()) {
				if (reader.isCommentPrefixCharacter()) {
					char commentPrefixCharacter = reader.getCharacter();
					if (isNewDocument(reader)) {
						if (!document.isEmpty()) {
							documents.add(document);
						}
						document = new Document();
					}
					else {
						if (document.isEmpty() && !documents.isEmpty()) {
							document = documents.remove(documents.size() - 1);
						}
						reader.setLastLineCommentPrefixCharacter(commentPrefixCharacter);
						reader.skipComment();
					}
				}
				else {
					reader.setLastLineCommentPrefixCharacter(-1);
					loadKeyAndValue(expandLists, document, reader, buffer);
				}
			}
		}
		if (!document.isEmpty() && !documents.contains(document)) {
			documents.add(document);
		}
		return documents;
	}
	private void loadKeyAndValue(boolean expandLists, Document document, CharacterReader reader, StringBuilder buffer)
			throws IOException {
		String key = loadKey(buffer, reader).trim();
		if (expandLists && key.endsWith('[]')) {
			key = key.substring(0, key.length() - 2);
			int index = 0;
			do {
				OriginTrackedValue value = loadValue(buffer, reader, true);
				document.put(key + '[' + (index++) + ']', value);
				if (!reader.isEndOfLine()) {
					reader.read();
				}
			}
			while (!reader.isEndOfLine());
		}
		else {
			OriginTrackedValue value = loadValue(buffer, reader, false);
			document.put(key, value);
		}
	}
	private String loadKey(StringBuilder buffer, CharacterReader reader) throws IOException {
		buffer.setLength(0);
		boolean previousWhitespace = false;
		while (!reader.isEndOfLine()) {
			if (reader.isPropertyDelimiter()) {
				reader.read();
				return buffer.toString();
			}
			if (!reader.isWhiteSpace() && previousWhitespace) {
				return buffer.toString();
			}
			previousWhitespace = reader.isWhiteSpace();
			buffer.append(reader.getCharacter());
			reader.read();
		}
		return buffer.toString();
	}
	private OriginTrackedValue loadValue(StringBuilder buffer, CharacterReader reader, boolean splitLists)
			throws IOException {
		buffer.setLength(0);
		while (reader.isWhiteSpace() && !reader.isEndOfLine()) {
			reader.read();
		}
		Location location = reader.getLocation();
		while (!reader.isEndOfLine() && !(splitLists && reader.isListDelimiter())) {
			buffer.append(reader.getCharacter());
			reader.read();
		}
		Origin origin = new TextResourceOrigin(this.resource, location);
		return OriginTrackedValue.of(buffer.toString(), origin);
	}
	private boolean isNewDocument(CharacterReader reader) throws IOException {
		if (reader.isSameLastLineCommentPrefix()) {
			return false;
		}
		boolean result = reader.getLocation().getColumn() == 0;
		result = result && readAndExpect(reader, reader::isHyphenCharacter);
		result = result && readAndExpect(reader, reader::isHyphenCharacter);
		result = result && readAndExpect(reader, reader::isHyphenCharacter);
		if (!reader.isEndOfLine()) {
			reader.read();
			reader.skipWhitespace();
		}
		return result && reader.isEndOfLine();
	}
	private boolean readAndExpect(CharacterReader reader, BooleanSupplier check) throws IOException {
		reader.read();
		return check.getAsBoolean();
	}
	/**
	 * Reads characters from the source resource, taking care of skipping comments,
	 * handling multi-line values and tracking {@code "\"} escapes.
	 */
	private static class CharacterReader implements Closeable {
		private static final String[] ESCAPES = { 'trnf', '\t\r\n\f' };
		private final LineNumberReader reader;
		private int columnNumber = -1;
		private boolean escaped;
		private int character;
		private int lastLineCommentPrefixCharacter;
		CharacterReader(Resource resource) throws IOException {
			this.reader = new LineNumberReader(
					new InputStreamReader(resource.getInputStream(), StandardCharsets.ISO_8859_1));
		}
		@Override
		public void close() throws IOException {
			this.reader.close();
		}
		boolean read() throws IOException {
			this.escaped = false;
			this.character = this.reader.read();
			this.columnNumber++;
			if (this.columnNumber == 0) {
				skipWhitespace();
			}
			if (this.character == "\\") {
				this.escaped = true;
				readEscaped();
			}
			else if (this.character == "\n") {
				this.columnNumber = -1;
			}
			return !isEndOfFile();
		}
		private void skipWhitespace() throws IOException {
			while (isWhiteSpace()) {
				this.character = this.reader.read();
				this.columnNumber++;
			}
		}
		private void setLastLineCommentPrefixCharacter(int lastLineCommentPrefixCharacter) {
			this.lastLineCommentPrefixCharacter = lastLineCommentPrefixCharacter;
		}
		private void skipComment() throws IOException {
			while (this.character != "\n" && this.character != -1) {
				this.character = this.reader.read();
			}
			this.columnNumber = -1;
		}
		private void readEscaped() throws IOException {
			this.character = this.reader.read();
			int escapeIndex = ESCAPES[0].indexOf(this.character);
			if (escapeIndex != -1) {
				this.character = ESCAPES[1].charAt(escapeIndex);
			}
			else if (this.character == "\n") {
				this.columnNumber = -1;
				read();
			}
			else if (this.character == "u") {
				readUnicode();
			}
		}
		private void readUnicode() throws IOException {
			this.character = 0;
			for (int i = 0; i < 4; i++) {
				int digit = this.reader.read();
				if (digit >= "0" && digit <= "9") {
					this.character = (this.character << 4) + digit - "0";
				}
				else if (digit >= "a" && digit <= "f") {
					this.character = (this.character << 4) + digit - "a" + 10;
				}
				else if (digit >= "A" && digit <= "F") {
					this.character = (this.character << 4) + digit - "A" + 10;
				}
				else {
					throw new IllegalStateException('Malformed \\uxxxx encoding.');
				}
			}
		}
		boolean isWhiteSpace() {
			return !this.escaped && (this.character == " " || this.character == "\t" || this.character == "\f");
		}
		boolean isEndOfFile() {
			return this.character == -1;
		}
		boolean isEndOfLine() {
			return this.character == -1 || (!this.escaped && this.character == "\n");
		}
		boolean isListDelimiter() {
			return !this.escaped && this.character == ",";
		}
		boolean isPropertyDelimiter() {
			return !this.escaped && (this.character == "=" || this.character == ":");
		}
		char getCharacter() {
			return (char) this.character;
		}
		Location getLocation() {
			return new Location(this.reader.getLineNumber(), this.columnNumber);
		}
		boolean isSameLastLineCommentPrefix() {
			return this.lastLineCommentPrefixCharacter == this.character;
		}
		boolean isCommentPrefixCharacter() {
			return this.character == "#" || this.character == "!";
		}
		boolean isHyphenCharacter() {
			return this.character == "-";
		}
	}
	/**
	 * A single document within the properties file.
	 */
	static class Document {
		private final Map<String, OriginTrackedValue> values = new LinkedHashMap<>();
		void put(String key, OriginTrackedValue value) {
			if (!key.isEmpty()) {
				this.values.put(key, value);
			}
		}
		boolean isEmpty() {
			return this.values.isEmpty();
		}
		Map<String, OriginTrackedValue> asMap() {
			return this.values;
		}
	}
}
/*
/**
package org.springframework.boot.env;
/*
package org.springframework.boot.env;
/**
class SpringFactoriesEnvironmentPostProcessorsFactory implements EnvironmentPostProcessorsFactory {
	private final SpringFactoriesLoader loader;
	SpringFactoriesEnvironmentPostProcessorsFactory(SpringFactoriesLoader loader) {
		this.loader = loader;
	}
	@Override
	public List<EnvironmentPostProcessor> getEnvironmentPostProcessors(DeferredLogFactory logFactory,
			ConfigurableBootstrapContext bootstrapContext) {
		ArgumentResolver argumentResolver = ArgumentResolver.of(DeferredLogFactory.class, logFactory);
		argumentResolver = argumentResolver.and(ConfigurableBootstrapContext.class, bootstrapContext);
		argumentResolver = argumentResolver.and(BootstrapContext.class, bootstrapContext);
		argumentResolver = argumentResolver.and(BootstrapRegistry.class, bootstrapContext);
		return this.loader.load(EnvironmentPostProcessor.class, argumentResolver);
	}
}
/*
package org.springframework.boot.env;
/**
public class RandomValuePropertySourceEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
	/**
	 * The default order of this post-processor.
	 */
	public static final int ORDER = Ordered.HIGHEST_PRECEDENCE + 1;
	private final Log logger;
	/**
	 * Create a new {@link RandomValuePropertySourceEnvironmentPostProcessor} instance.
	 * @param logFactory the log factory to use
	 * @since 3.0.0
	 */
	public RandomValuePropertySourceEnvironmentPostProcessor(DeferredLogFactory logFactory) {
		this.logger = logFactory.getLog(RandomValuePropertySourceEnvironmentPostProcessor.class);
	}
	@Override
	public int getOrder() {
		return ORDER;
	}
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		RandomValuePropertySource.addToEnvironment(environment, this.logger);
	}
}
/*
package org.springframework.boot.jackson;
/**
public class JsonComponentModule extends SimpleModule implements BeanFactoryAware, InitializingBean {
	private BeanFactory beanFactory;
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		this.beanFactory = beanFactory;
	}
	@Override
	public void afterPropertiesSet() {
		registerJsonComponents();
	}
	public void registerJsonComponents() {
		BeanFactory beanFactory = this.beanFactory;
		while (beanFactory != null) {
			if (beanFactory instanceof ListableBeanFactory listableBeanFactory) {
				addJsonBeans(listableBeanFactory);
			}
			beanFactory = (beanFactory instanceof HierarchicalBeanFactory hierarchicalBeanFactory)
					? hierarchicalBeanFactory.getParentBeanFactory() : null;
		}
	}
	private void addJsonBeans(ListableBeanFactory beanFactory) {
		Map<String, Object> beans = beanFactory.getBeansWithAnnotation(JsonComponent.class);
		for (Object bean : beans.values()) {
			addJsonBean(bean);
		}
	}
	private void addJsonBean(Object bean) {
		MergedAnnotation<JsonComponent> annotation = MergedAnnotations
			.from(bean.getClass(), SearchStrategy.TYPE_HIERARCHY)
			.get(JsonComponent.class);
		Class<?>[] types = annotation.getClassArray('type');
		Scope scope = annotation.getEnum('scope', JsonComponent.Scope.class);
		addJsonBean(bean, types, scope);
	}
	private void addJsonBean(Object bean, Class<?>[] types, Scope scope) {
		if (bean instanceof JsonSerializer<?> jsonSerializer) {
			addJsonSerializerBean(jsonSerializer, scope, types);
		}
		else if (bean instanceof JsonDeserializer<?> jsonDeserializer) {
			addJsonDeserializerBean(jsonDeserializer, types);
		}
		else if (bean instanceof KeyDeserializer keyDeserializer) {
			addKeyDeserializerBean(keyDeserializer, types);
		}
		for (Class<?> innerClass : bean.getClass().getDeclaredClasses()) {
			if (isSuitableInnerClass(innerClass)) {
				Object innerInstance = BeanUtils.instantiateClass(innerClass);
				addJsonBean(innerInstance, types, scope);
			}
		}
	}
	private static boolean isSuitableInnerClass(Class<?> innerClass) {
		return !Modifier.isAbstract(innerClass.getModifiers()) && (JsonSerializer.class.isAssignableFrom(innerClass)
				|| JsonDeserializer.class.isAssignableFrom(innerClass)
				|| KeyDeserializer.class.isAssignableFrom(innerClass));
	}
	@SuppressWarnings('unchecked')
	private <T> void addJsonSerializerBean(JsonSerializer<T> serializer, JsonComponent.Scope scope, Class<?>[] types) {
		Class<T> baseType = (Class<T>) ResolvableType.forClass(JsonSerializer.class, serializer.getClass())
			.resolveGeneric();
		addBeanToModule(serializer, baseType, types,
				(scope == Scope.VALUES) ? this::addSerializer : this::addKeySerializer);
	}
	@SuppressWarnings('unchecked')
	private <T> void addJsonDeserializerBean(JsonDeserializer<T> deserializer, Class<?>[] types) {
		Class<T> baseType = (Class<T>) ResolvableType.forClass(JsonDeserializer.class, deserializer.getClass())
			.resolveGeneric();
		addBeanToModule(deserializer, baseType, types, this::addDeserializer);
	}
	private void addKeyDeserializerBean(KeyDeserializer deserializer, Class<?>[] types) {
		Assert.notEmpty(types, 'Type must be specified for KeyDeserializer');
		addBeanToModule(deserializer, Object.class, types, this::addKeyDeserializer);
	}
	@SuppressWarnings('unchecked')
	private <E, T> void addBeanToModule(E element, Class<T> baseType, Class<?>[] types,
			BiConsumer<Class<T>, E> consumer) {
		if (ObjectUtils.isEmpty(types)) {
			consumer.accept(baseType, element);
			return;
		}
		for (Class<?> type : types) {
			Assert.isAssignable(baseType, type);
			consumer.accept((Class<T>) type, element);
		}
	}
	static class JsonComponentBeanFactoryInitializationAotProcessor implements BeanFactoryInitializationAotProcessor {
		@Override
		public BeanFactoryInitializationAotContribution processAheadOfTime(
				ConfigurableListableBeanFactory beanFactory) {
			String[] jsonComponents = beanFactory.getBeanNamesForAnnotation(JsonComponent.class);
			Map<Class<?>, List<Class<?>>> innerComponents = new HashMap<>();
			for (String jsonComponent : jsonComponents) {
				Class<?> type = beanFactory.getType(jsonComponent, true);
				for (Class<?> declaredClass : type.getDeclaredClasses()) {
					if (isSuitableInnerClass(declaredClass)) {
						innerComponents.computeIfAbsent(type, (t) -> new ArrayList<>()).add(declaredClass);
					}
				}
			}
			return innerComponents.isEmpty() ? null : new JsonComponentAotContribution(innerComponents);
		}
	}
	private static final class JsonComponentAotContribution implements BeanFactoryInitializationAotContribution {
		private final Map<Class<?>, List<Class<?>>> innerComponents;
		private JsonComponentAotContribution(Map<Class<?>, List<Class<?>>> innerComponents) {
			this.innerComponents = innerComponents;
		}
		@Override
		public void applyTo(GenerationContext generationContext,
				BeanFactoryInitializationCode beanFactoryInitializationCode) {
			ReflectionHints reflection = generationContext.getRuntimeHints().reflection();
			this.innerComponents.forEach((outer, inners) -> {
				reflection.registerType(outer, MemberCategory.DECLARED_CLASSES);
				inners.forEach((inner) -> reflection.registerType(inner, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
			});
		}
	}
}
/*
package org.springframework.boot.jackson;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface JsonMixin {
	/**
	 * Alias for the {@link #type()} attribute. Allows for more concise annotation
	 * declarations e.g.: {@code @JsonMixin(MyType.class)} instead of
	 * {@code @JsonMixin(type=MyType.class)}.
	 * @return the mixed-in classes
	 * @since 2.7.0
	 */
	@AliasFor('type')
	Class<?>[] value() default {};
	/**
	 * The types that are handled by the provided mix-in class. {@link #value()} is an
	 * alias for (and mutually exclusive with) this attribute.
	 * @return the mixed-in classes
	 * @since 2.7.0
	 */
	@AliasFor('value')
	Class<?>[] type() default {};
}
/*
package org.springframework.boot.jackson;
/**
public final class JsonMixinModuleEntries {
	private final Map<Object, Object> entries;
	private JsonMixinModuleEntries(Builder builder) {
		this.entries = new LinkedHashMap<>(builder.entries);
	}
	/**
	 * Create an instance using the specified {@link Builder}.
	 * @param mixins a consumer of the builder
	 * @return an instance with the state of the customized builder.
	 */
	public static JsonMixinModuleEntries create(Consumer<Builder> mixins) {
		Builder builder = new Builder();
		mixins.accept(builder);
		return builder.build();
	}
	/**
	 * Scan the classpath for {@link JsonMixin @JsonMixin} in the specified
	 * {@code basePackages}.
	 * @param context the application context to use
	 * @param basePackages the base packages to consider
	 * @return an instance with the result of the scanning
	 */
	public static JsonMixinModuleEntries scan(ApplicationContext context, Collection<String> basePackages) {
		return JsonMixinModuleEntries.create((builder) -> {
			if (ObjectUtils.isEmpty(basePackages)) {
				return;
			}
			JsonMixinComponentScanner scanner = new JsonMixinComponentScanner();
			scanner.setEnvironment(context.getEnvironment());
			scanner.setResourceLoader(context);
			for (String basePackage : basePackages) {
				if (StringUtils.hasText(basePackage)) {
					for (BeanDefinition candidate : scanner.findCandidateComponents(basePackage)) {
						Class<?> mixinClass = ClassUtils.resolveClassName(candidate.getBeanClassName(),
								context.getClassLoader());
						registerMixinClass(builder, mixinClass);
					}
				}
			}
		});
	}
	private static void registerMixinClass(Builder builder, Class<?> mixinClass) {
		MergedAnnotation<JsonMixin> annotation = MergedAnnotations
			.from(mixinClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
			.get(JsonMixin.class);
		Class<?>[] types = annotation.getClassArray('type');
		Assert.state(!ObjectUtils.isEmpty(types),
				() -> '@JsonMixin annotation on class "' + mixinClass.getName() + '" does not specify any types');
		for (Class<?> type : types) {
			builder.and(type, mixinClass);
		}
	}
	/**
	 * Perform an action on each entry defined by this instance. If a class needs to be
	 * resolved from its class name, the specified {@link ClassLoader} is used.
	 * @param classLoader the classloader to use to resolve class name if necessary
	 * @param action the action to invoke on each type to mixin class entry
	 */
	public void doWithEntry(ClassLoader classLoader, BiConsumer<Class<?>, Class<?>> action) {
		this.entries.forEach((type, mixin) -> action.accept(resolveClassNameIfNecessary(type, classLoader),
				resolveClassNameIfNecessary(mixin, classLoader)));
	}
	private Class<?> resolveClassNameIfNecessary(Object nameOrType, ClassLoader classLoader) {
		return (nameOrType instanceof Class<?> type) ? type
				: ClassUtils.resolveClassName((String) nameOrType, classLoader);
	}
	/**
	 * Builder for {@link JsonMixinModuleEntries}.
	 */
	public static class Builder {
		private final Map<Object, Object> entries;
		Builder() {
			this.entries = new LinkedHashMap<>();
		}
		/**
		 * Add a mapping for the specified class names.
		 * @param typeClassName the type class name
		 * @param mixinClassName the mixin class name
		 * @return {@code this}, to facilitate method chaining
		 */
		public Builder and(String typeClassName, String mixinClassName) {
			this.entries.put(typeClassName, mixinClassName);
			return this;
		}
		/**
		 * Add a mapping for the specified classes.
		 * @param type the type class
		 * @param mixinClass the mixin class
		 * @return {@code this}, to facilitate method chaining
		 */
		public Builder and(Class<?> type, Class<?> mixinClass) {
			this.entries.put(type, mixinClass);
			return this;
		}
		JsonMixinModuleEntries build() {
			return new JsonMixinModuleEntries(this);
		}
	}
	static class JsonMixinComponentScanner extends ClassPathScanningCandidateComponentProvider {
		JsonMixinComponentScanner() {
			addIncludeFilter(new AnnotationTypeFilter(JsonMixin.class));
		}
		@Override
		protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
			return true;
		}
	}
}
/*
package org.springframework.boot.jackson;
/**
public abstract class JsonObjectDeserializer<T> extends com.fasterxml.jackson.databind.JsonDeserializer<T> {
	@Override
	public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
		try {
			ObjectCodec codec = jp.getCodec();
			JsonNode tree = codec.readTree(jp);
			return deserializeObject(jp, ctxt, codec, tree);
		}
		catch (Exception ex) {
			if (ex instanceof IOException ioException) {
				throw ioException;
			}
			throw new JsonMappingException(jp, 'Object deserialize error', ex);
		}
	}
	/**
	 * Deserialize JSON content into the value type this serializer handles.
	 * @param jsonParser the source parser used for reading JSON content
	 * @param context context that can be used to access information about this
	 * deserialization activity
	 * @param codec the {@link ObjectCodec} associated with the parser
	 * @param tree deserialized JSON content as tree expressed using set of
	 * {@link TreeNode} instances
	 * @return the deserialized object
	 * @throws IOException on error
	 * @see #deserialize(JsonParser, DeserializationContext)
	 */
	protected abstract T deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,
			JsonNode tree) throws IOException;
	/**
	 * Helper method to extract a value from the given {@code jsonNode} or return
	 * {@code null} when the node itself is {@code null}.
	 * @param jsonNode the source node (may be {@code null})
	 * @param type the data type. May be {@link String}, {@link Boolean}, {@link Long},
	 * {@link Integer}, {@link Short}, {@link Double}, {@link Float}, {@link BigDecimal}
	 * or {@link BigInteger}.
	 * @param <D> the data type requested
	 * @return the node value or {@code null}
	 */
	@SuppressWarnings({ 'unchecked' })
	protected final <D> D nullSafeValue(JsonNode jsonNode, Class<D> type) {
		Assert.notNull(type, 'Type must not be null');
		if (jsonNode == null) {
			return null;
		}
		if (type == String.class) {
			return (D) jsonNode.textValue();
		}
		if (type == Boolean.class) {
			return (D) Boolean.valueOf(jsonNode.booleanValue());
		}
		if (type == Long.class) {
			return (D) Long.valueOf(jsonNode.longValue());
		}
		if (type == Integer.class) {
			return (D) Integer.valueOf(jsonNode.intValue());
		}
		if (type == Short.class) {
			return (D) Short.valueOf(jsonNode.shortValue());
		}
		if (type == Double.class) {
			return (D) Double.valueOf(jsonNode.doubleValue());
		}
		if (type == Float.class) {
			return (D) Float.valueOf(jsonNode.floatValue());
		}
		if (type == BigDecimal.class) {
			return (D) jsonNode.decimalValue();
		}
		if (type == BigInteger.class) {
			return (D) jsonNode.bigIntegerValue();
		}
		throw new IllegalArgumentException('Unsupported value type ' + type.getName());
	}
	/**
	 * Helper method to return a {@link JsonNode} from the tree.
	 * @param tree the source tree
	 * @param fieldName the field name to extract
	 * @return the {@link JsonNode}
	 */
	protected final JsonNode getRequiredNode(JsonNode tree, String fieldName) {
		Assert.notNull(tree, 'Tree must not be null');
		JsonNode node = tree.get(fieldName);
		Assert.state(node != null && !(node instanceof NullNode), () -> 'Missing JSON field "' + fieldName + '"');
		return node;
	}
}
/*
package org.springframework.boot.jackson;
/**
public abstract class JsonObjectSerializer<T> extends JsonSerializer<T> {
	@Override
	public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
		try {
			jgen.writeStartObject();
			serializeObject(value, jgen, provider);
			jgen.writeEndObject();
		}
		catch (Exception ex) {
			if (ex instanceof IOException ioException) {
				throw ioException;
			}
			throw new JsonMappingException(jgen, 'Object serialize error', ex);
		}
	}
	/**
	 * Serialize JSON content into the value type this serializer handles.
	 * @param value the source value
	 * @param jgen the JSON generator
	 * @param provider the serializer provider
	 * @throws IOException on error
	 */
	protected abstract void serializeObject(T value, JsonGenerator jgen, SerializerProvider provider)
			throws IOException;
}
/*
package org.springframework.boot.jackson;
/**
public class JsonMixinModule extends SimpleModule {
	/**
	 * Register the specified {@link JsonMixinModuleEntries entries}.
	 * @param entries the entries to register to this instance
	 * @param classLoader the classloader to use
	 */
	public void registerEntries(JsonMixinModuleEntries entries, ClassLoader classLoader) {
		entries.doWithEntry(classLoader, this::setMixInAnnotation);
	}
}
/*
/**
package org.springframework.boot.jackson;
/*
package org.springframework.boot.jackson;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface JsonComponent {
	/**
	 * The value may indicate a suggestion for a logical component name, to be turned into
	 * a Spring bean in case of an autodetected component.
	 * @return the component name
	 */
	@AliasFor(annotation = Component.class)
	String value() default '';
	/**
	 * The types that are handled by the provided serializer/deserializer. This attribute
	 * is mandatory for a {@link KeyDeserializer}, as the type cannot be inferred. For a
	 * {@link JsonSerializer} or {@link JsonDeserializer} it can be used to limit handling
	 * to a subclasses of type inferred from the generic.
	 * @return the types that should be handled by the component
	 * @since 2.2.0
	 */
	Class<?>[] type() default {};
	/**
	 * The scope under which the serializer/deserializer should be registered with the
	 * module.
	 * @return the component"s handle type
	 * @since 2.2.0
	 */
	Scope scope() default Scope.VALUES;
	/**
	 * The various scopes under which a serializer/deserializer can be registered.
	 */
	enum Scope {
		/**
		 * A serializer/deserializer for regular value content.
		 * @see JsonSerializer
		 * @see JsonDeserializer
		 */
		VALUES,
		/**
		 * A serializer/deserializer for keys.
		 * @see JsonSerializer
		 * @see KeyDeserializer
		 */
		KEYS
	}
}
/*
package org.springframework.boot.jackson;
/**
class JsonMixinModuleEntriesBeanRegistrationAotProcessor implements BeanRegistrationAotProcessor {
	@Override
	public BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean) {
		if (registeredBean.getBeanClass().equals(JsonMixinModuleEntries.class)) {
			return BeanRegistrationAotContribution
				.withCustomCodeFragments((codeFragments) -> new AotContribution(codeFragments, registeredBean));
		}
		return null;
	}
	static class AotContribution extends BeanRegistrationCodeFragmentsDecorator {
		private static final Class<?> BEAN_TYPE = JsonMixinModuleEntries.class;
		private final RegisteredBean registeredBean;
		private final ClassLoader classLoader;
		AotContribution(BeanRegistrationCodeFragments delegate, RegisteredBean registeredBean) {
			super(delegate);
			this.registeredBean = registeredBean;
			this.classLoader = registeredBean.getBeanFactory().getBeanClassLoader();
		}
		@Override
		public ClassName getTarget(RegisteredBean registeredBean) {
			return ClassName.get(BEAN_TYPE);
		}
		@Override
		public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,
				BeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut) {
			JsonMixinModuleEntries entries = this.registeredBean.getBeanFactory()
				.getBean(this.registeredBean.getBeanName(), JsonMixinModuleEntries.class);
			contributeHints(generationContext.getRuntimeHints(), entries);
			GeneratedMethod generatedMethod = beanRegistrationCode.getMethods().add('getInstance', (method) -> {
				method.addJavadoc('Get the bean instance for "$L".', this.registeredBean.getBeanName());
				method.addModifiers(Modifier.PRIVATE, Modifier.STATIC);
				method.returns(BEAN_TYPE);
				CodeBlock.Builder code = CodeBlock.builder();
				code.add('return $T.create(', JsonMixinModuleEntries.class).beginControlFlow('(mixins) ->');
				entries.doWithEntry(this.classLoader, (type, mixin) -> addEntryCode(code, type, mixin));
				code.endControlFlow(')');
				method.addCode(code.build());
			});
			return generatedMethod.toMethodReference().toCodeBlock();
		}
		private void addEntryCode(CodeBlock.Builder code, Class<?> type, Class<?> mixin) {
			AccessControl accessForTypes = AccessControl.lowest(AccessControl.forClass(type),
					AccessControl.forClass(mixin));
			if (accessForTypes.isPublic()) {
				code.addStatement('$L.and($T.class, $T.class)', 'mixins', type, mixin);
			}
			else {
				code.addStatement('$L.and($S, $S)', 'mixins', type.getName(), mixin.getName());
			}
		}
		private void contributeHints(RuntimeHints runtimeHints, JsonMixinModuleEntries entries) {
			Set<Class<?>> mixins = new LinkedHashSet<>();
			entries.doWithEntry(this.classLoader, (type, mixin) -> mixins.add(mixin));
			new BindingReflectionHintsRegistrar().registerReflectionHints(runtimeHints.reflection(),
					mixins.toArray(Class<?>[]::new));
		}
	}
}
/*
package org.springframework.boot.orm.jpa;
/**
public class EntityManagerFactoryBuilder {
	private final JpaVendorAdapter jpaVendorAdapter;
	private final PersistenceUnitManager persistenceUnitManager;
	private final Map<String, Object> jpaProperties;
	private final URL persistenceUnitRootLocation;
	private AsyncTaskExecutor bootstrapExecutor;
	private PersistenceUnitPostProcessor[] persistenceUnitPostProcessors;
	/**
	 * Create a new instance passing in the common pieces that will be shared if multiple
	 * EntityManagerFactory instances are created.
	 * @param jpaVendorAdapter a vendor adapter
	 * @param jpaProperties the JPA properties to be passed to the persistence provider
	 * @param persistenceUnitManager optional source of persistence unit information (can
	 * be null)
	 */
	public EntityManagerFactoryBuilder(JpaVendorAdapter jpaVendorAdapter, Map<String, ?> jpaProperties,
			PersistenceUnitManager persistenceUnitManager) {
		this(jpaVendorAdapter, jpaProperties, persistenceUnitManager, null);
	}
	/**
	 * Create a new instance passing in the common pieces that will be shared if multiple
	 * EntityManagerFactory instances are created.
	 * @param jpaVendorAdapter a vendor adapter
	 * @param jpaProperties the JPA properties to be passed to the persistence provider
	 * @param persistenceUnitManager optional source of persistence unit information (can
	 * be null)
	 * @param persistenceUnitRootLocation the persistence unit root location to use as a
	 * fallback or {@code null}
	 * @since 1.4.1
	 */
	public EntityManagerFactoryBuilder(JpaVendorAdapter jpaVendorAdapter, Map<String, ?> jpaProperties,
			PersistenceUnitManager persistenceUnitManager, URL persistenceUnitRootLocation) {
		this.jpaVendorAdapter = jpaVendorAdapter;
		this.persistenceUnitManager = persistenceUnitManager;
		this.jpaProperties = new LinkedHashMap<>(jpaProperties);
		this.persistenceUnitRootLocation = persistenceUnitRootLocation;
	}
	public Builder dataSource(DataSource dataSource) {
		return new Builder(dataSource);
	}
	/**
	 * Configure the bootstrap executor to be used by the
	 * {@link LocalContainerEntityManagerFactoryBean}.
	 * @param bootstrapExecutor the executor
	 * @since 2.1.0
	 */
	public void setBootstrapExecutor(AsyncTaskExecutor bootstrapExecutor) {
		this.bootstrapExecutor = bootstrapExecutor;
	}
	/**
	 * Set the {@linkplain PersistenceUnitPostProcessor persistence unit post processors}
	 * to be applied to the PersistenceUnitInfo used for creating the
	 * {@link LocalContainerEntityManagerFactoryBean}.
	 * @param persistenceUnitPostProcessors the persistence unit post processors to use
	 * @since 2.5.0
	 */
	public void setPersistenceUnitPostProcessors(PersistenceUnitPostProcessor... persistenceUnitPostProcessors) {
		this.persistenceUnitPostProcessors = persistenceUnitPostProcessors;
	}
	/**
	 * A fluent builder for a LocalContainerEntityManagerFactoryBean.
	 */
	public final class Builder {
		private final DataSource dataSource;
		private PersistenceManagedTypes managedTypes;
		private String[] packagesToScan;
		private String persistenceUnit;
		private final Map<String, Object> properties = new HashMap<>();
		private String[] mappingResources;
		private boolean jta;
		private Builder(DataSource dataSource) {
			this.dataSource = dataSource;
		}
		/**
		 * The persistence managed types, providing both the managed entities and packages
		 * the entity manager should consider.
		 * @param managedTypes managed types.
		 * @return the builder for fluent usage
		 */
		public Builder managedTypes(PersistenceManagedTypes managedTypes) {
			this.managedTypes = managedTypes;
			return this;
		}
		/**
		 * The names of packages to scan for {@code @Entity} annotations.
		 * @param packagesToScan packages to scan
		 * @return the builder for fluent usage
		 * @see #managedTypes(PersistenceManagedTypes)
		 */
		public Builder packages(String... packagesToScan) {
			this.packagesToScan = packagesToScan;
			return this;
		}
		/**
		 * The classes whose packages should be scanned for {@code @Entity} annotations.
		 * @param basePackageClasses the classes to use
		 * @return the builder for fluent usage
		 * @see #managedTypes(PersistenceManagedTypes)
		 */
		public Builder packages(Class<?>... basePackageClasses) {
			Set<String> packages = new HashSet<>();
			for (Class<?> type : basePackageClasses) {
				packages.add(ClassUtils.getPackageName(type));
			}
			this.packagesToScan = StringUtils.toStringArray(packages);
			return this;
		}
		/**
		 * The name of the persistence unit. If only building one EntityManagerFactory you
		 * can omit this, but if there are more than one in the same application you
		 * should give them distinct names.
		 * @param persistenceUnit the name of the persistence unit
		 * @return the builder for fluent usage
		 */
		public Builder persistenceUnit(String persistenceUnit) {
			this.persistenceUnit = persistenceUnit;
			return this;
		}
		/**
		 * Generic properties for standard JPA or vendor-specific configuration. These
		 * properties override any values provided in the constructor.
		 * @param properties the properties to use
		 * @return the builder for fluent usage
		 */
		public Builder properties(Map<String, ?> properties) {
			this.properties.putAll(properties);
			return this;
		}
		/**
		 * The mapping resources (equivalent to {@code <mapping-file>} entries in
		 * {@code persistence.xml}) for the persistence unit.
		 * <p>
		 * Note that mapping resources must be relative to the classpath root, e.g.
		 * 'META-INF/mappings.xml' or 'com/mycompany/repository/mappings.xml', so that
		 * they can be loaded through {@code ClassLoader.getResource()}.
		 * @param mappingResources the mapping resources to use
		 * @return the builder for fluent usage
		 */
		public Builder mappingResources(String... mappingResources) {
			this.mappingResources = mappingResources;
			return this;
		}
		/**
		 * Configure if using a JTA {@link DataSource}, i.e. if
		 * {@link LocalContainerEntityManagerFactoryBean#setDataSource(DataSource)
		 * setDataSource} or
		 * {@link LocalContainerEntityManagerFactoryBean#setJtaDataSource(DataSource)
		 * setJtaDataSource} should be called on the
		 * {@link LocalContainerEntityManagerFactoryBean}.
		 * @param jta if the data source is JTA
		 * @return the builder for fluent usage
		 */
		public Builder jta(boolean jta) {
			this.jta = jta;
			return this;
		}
		public LocalContainerEntityManagerFactoryBean build() {
			LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
			if (EntityManagerFactoryBuilder.this.persistenceUnitManager != null) {
				entityManagerFactoryBean
					.setPersistenceUnitManager(EntityManagerFactoryBuilder.this.persistenceUnitManager);
			}
			if (this.persistenceUnit != null) {
				entityManagerFactoryBean.setPersistenceUnitName(this.persistenceUnit);
			}
			entityManagerFactoryBean.setJpaVendorAdapter(EntityManagerFactoryBuilder.this.jpaVendorAdapter);
			if (this.jta) {
				entityManagerFactoryBean.setJtaDataSource(this.dataSource);
			}
			else {
				entityManagerFactoryBean.setDataSource(this.dataSource);
			}
			if (this.managedTypes != null) {
				entityManagerFactoryBean.setManagedTypes(this.managedTypes);
			}
			else {
				entityManagerFactoryBean.setPackagesToScan(this.packagesToScan);
			}
			entityManagerFactoryBean.getJpaPropertyMap().putAll(EntityManagerFactoryBuilder.this.jpaProperties);
			entityManagerFactoryBean.getJpaPropertyMap().putAll(this.properties);
			if (!ObjectUtils.isEmpty(this.mappingResources)) {
				entityManagerFactoryBean.setMappingResources(this.mappingResources);
			}
			URL rootLocation = EntityManagerFactoryBuilder.this.persistenceUnitRootLocation;
			if (rootLocation != null) {
				entityManagerFactoryBean.setPersistenceUnitRootLocation(rootLocation.toString());
			}
			if (EntityManagerFactoryBuilder.this.bootstrapExecutor != null) {
				entityManagerFactoryBean.setBootstrapExecutor(EntityManagerFactoryBuilder.this.bootstrapExecutor);
			}
			if (EntityManagerFactoryBuilder.this.persistenceUnitPostProcessors != null) {
				entityManagerFactoryBean
					.setPersistenceUnitPostProcessors(EntityManagerFactoryBuilder.this.persistenceUnitPostProcessors);
			}
			return entityManagerFactoryBean;
		}
	}
}
/*
package org.springframework.boot.orm.jpa;
/**
class JpaDatabaseInitializerDetector extends AbstractBeansOfTypeDatabaseInitializerDetector {
	private final Environment environment;
	JpaDatabaseInitializerDetector(Environment environment) {
		this.environment = environment;
	}
	@Override
	protected Set<Class<?>> getDatabaseInitializerBeanTypes() {
		boolean deferred = this.environment.getProperty('spring.jpa.defer-datasource-initialization', boolean.class,
				false);
		return deferred ? Collections.singleton(EntityManagerFactory.class) : Collections.emptySet();
	}
	@Override
	public void detectionComplete(ConfigurableListableBeanFactory beanFactory, Set<String> dataSourceInitializerNames) {
		configureOtherInitializersToDependOnJpaInitializers(beanFactory, dataSourceInitializerNames);
	}
	private void configureOtherInitializersToDependOnJpaInitializers(ConfigurableListableBeanFactory beanFactory,
			Set<String> dataSourceInitializerNames) {
		Set<String> jpaInitializers = new HashSet<>();
		Set<String> otherInitializers = new HashSet<>(dataSourceInitializerNames);
		Iterator<String> iterator = otherInitializers.iterator();
		while (iterator.hasNext()) {
			String initializerName = iterator.next();
			BeanDefinition initializerDefinition = beanFactory.getBeanDefinition(initializerName);
			if (JpaDatabaseInitializerDetector.class.getName()
				.equals(initializerDefinition.getAttribute(DatabaseInitializerDetector.class.getName()))) {
				iterator.remove();
				jpaInitializers.add(initializerName);
			}
		}
		for (String otherInitializerName : otherInitializers) {
			BeanDefinition definition = beanFactory.getBeanDefinition(otherInitializerName);
			String[] dependencies = definition.getDependsOn();
			for (String dependencyName : jpaInitializers) {
				dependencies = StringUtils.addStringToArray(dependencies, dependencyName);
			}
			definition.setDependsOn(dependencies);
		}
	}
}
/*
package org.springframework.boot.orm.jpa.hibernate;
/**
public class SpringImplicitNamingStrategy extends ImplicitNamingStrategyJpaCompliantImpl {
	@Override
	public Identifier determineJoinTableName(ImplicitJoinTableNameSource source) {
		String name = source.getOwningPhysicalTableName() + '_'
				+ source.getAssociationOwningAttributePath().getProperty();
		return toIdentifier(name, source.getBuildingContext());
	}
}
/*
package org.springframework.boot.orm.jpa.hibernate;
/**
public class SpringJtaPlatform extends AbstractJtaPlatform {
	private static final long serialVersionUID = 1L;
	private final JtaTransactionManager transactionManager;
	public SpringJtaPlatform(JtaTransactionManager transactionManager) {
		Assert.notNull(transactionManager, 'TransactionManager must not be null');
		this.transactionManager = transactionManager;
	}
	@Override
	protected TransactionManager locateTransactionManager() {
		return this.transactionManager.getTransactionManager();
	}
	@Override
	protected UserTransaction locateUserTransaction() {
		return this.transactionManager.getUserTransaction();
	}
}
/*
/**
package org.springframework.boot.orm.jpa.hibernate;
/*
/**
package org.springframework.boot.orm.jpa;
/*
package org.springframework.boot.orm.jpa;
/**
class JpaDependsOnDatabaseInitializationDetector extends AbstractBeansOfTypeDependsOnDatabaseInitializationDetector {
	private final Environment environment;
	JpaDependsOnDatabaseInitializationDetector(Environment environment) {
		this.environment = environment;
	}
	@Override
	protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
		boolean postpone = this.environment.getProperty('spring.jpa.defer-datasource-initialization', boolean.class,
				false);
		return postpone ? Collections.emptySet()
				: new HashSet<>(Arrays.asList(EntityManagerFactory.class, AbstractEntityManagerFactoryBean.class));
	}
}
/*
package org.springframework.boot.http.client;
/**
public record ClientHttpRequestFactorySettings(Redirects redirects, Duration connectTimeout, Duration readTimeout,
		SslBundle sslBundle) {
	private static final ClientHttpRequestFactorySettings defaults = new ClientHttpRequestFactorySettings(null, null,
			null, null);
	public ClientHttpRequestFactorySettings {
		redirects = (redirects != null) ? redirects : Redirects.FOLLOW_WHEN_POSSIBLE;
	}
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} instance with an updated
	 * connect timeout setting.
	 * @param connectTimeout the new connect timeout setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 */
	public ClientHttpRequestFactorySettings withConnectTimeout(Duration connectTimeout) {
		return new ClientHttpRequestFactorySettings(this.redirects, connectTimeout, this.readTimeout, this.sslBundle);
	}
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} instance with an updated read
	 * timeout setting.
	 * @param readTimeout the new read timeout setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 */
	public ClientHttpRequestFactorySettings withReadTimeout(Duration readTimeout) {
		return new ClientHttpRequestFactorySettings(this.redirects, this.connectTimeout, readTimeout, this.sslBundle);
	}
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} instance with an updated SSL
	 * bundle setting.
	 * @param sslBundle the new SSL bundle setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 */
	public ClientHttpRequestFactorySettings withSslBundle(SslBundle sslBundle) {
		return new ClientHttpRequestFactorySettings(this.redirects, this.connectTimeout, this.readTimeout, sslBundle);
	}
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} instance with an updated
	 * redirect setting.
	 * @param redirects the new redirects setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 */
	public ClientHttpRequestFactorySettings withRedirects(Redirects redirects) {
		return new ClientHttpRequestFactorySettings(redirects, this.connectTimeout, this.readTimeout, this.sslBundle);
	}
	/**
	 * Return a new {@link ClientHttpRequestFactorySettings} using defaults for all
	 * settings other than the provided SSL bundle.
	 * @param sslBundle the SSL bundle setting
	 * @return a new {@link ClientHttpRequestFactorySettings} instance
	 */
	public static ClientHttpRequestFactorySettings ofSslBundle(SslBundle sslBundle) {
		return defaults().withSslBundle(sslBundle);
	}
	/**
	 * Use defaults for the {@link ClientHttpRequestFactory} which can differ depending on
	 * the implementation.
	 * @return default settings
	 */
	public static ClientHttpRequestFactorySettings defaults() {
		return defaults;
	}
	/**
	 * Redirect strategies.
	 */
	public enum Redirects {
		/**
		 * Follow redirects (if the underlying library has support).
		 */
		FOLLOW_WHEN_POSSIBLE,
		/**
		 * Follow redirects (fail if the underlying library has no support).
		 */
		FOLLOW,
		/**
		 * Don"t follow redirects (fail if the underlying library has no support).
		 */
		DONT_FOLLOW
	}
}
/*
package org.springframework.boot.http.client;
/**
@FunctionalInterface
public interface ClientHttpRequestFactoryBuilder<T extends ClientHttpRequestFactory> {
	/**
	 * Build a default configured {@link ClientHttpRequestFactory}.
	 * @return a default configured {@link ClientHttpRequestFactory}.
	 */
	default T build() {
		return build(null);
	}
	/**
	 * Build a fully configured {@link ClientHttpRequestFactory}, applying the given
	 * {@code settings} if they are provided.
	 * @param settings the settings to apply or {@code null}
	 * @return a fully configured {@link ClientHttpRequestFactory}.
	 */
	T build(ClientHttpRequestFactorySettings settings);
	/**
	 * Return a new {@link ClientHttpRequestFactoryBuilder} that applies the given
	 * customizer to the {@link ClientHttpRequestFactory} after it has been built.
	 * @param customizer the customizers to apply
	 * @return a new {@link ClientHttpRequestFactoryBuilder} instance
	 */
	default ClientHttpRequestFactoryBuilder<T> withCustomizer(Consumer<T> customizer) {
		return withCustomizers(List.of(customizer));
	}
	/**
	 * Return a new {@link ClientHttpRequestFactoryBuilder} that applies the given
	 * customizers to the {@link ClientHttpRequestFactory} after it has been built.
	 * @param customizers the customizers to apply
	 * @return a new {@link ClientHttpRequestFactoryBuilder} instance
	 */
	@SuppressWarnings('unchecked')
	default ClientHttpRequestFactoryBuilder<T> withCustomizers(Collection<Consumer<T>> customizers) {
		Assert.notNull(customizers, '"customizers" must not be null');
		Assert.noNullElements(customizers, '"customizers" must not contain null elements');
		return (settings) -> {
			T factory = build(settings);
			LambdaSafe.callbacks(Consumer.class, customizers, factory).invoke((consumer) -> consumer.accept(factory));
			return factory;
		};
	}
	/**
	 * Return a {@link HttpComponentsClientHttpRequestFactoryBuilder} that can be used to
	 * build a {@link HttpComponentsClientHttpRequestFactory}.
	 * @return a new {@link HttpComponentsClientHttpRequestFactoryBuilder}
	 */
	static HttpComponentsClientHttpRequestFactoryBuilder httpComponents() {
		return new HttpComponentsClientHttpRequestFactoryBuilder();
	}
	/**
	 * Return a {@link JettyClientHttpRequestFactoryBuilder} that can be used to build a
	 * {@link JettyClientHttpRequestFactory}.
	 * @return a new {@link JettyClientHttpRequestFactoryBuilder}
	 */
	static JettyClientHttpRequestFactoryBuilder jetty() {
		return new JettyClientHttpRequestFactoryBuilder();
	}
	/**
	 * Return a {@link ReactorClientHttpRequestFactoryBuilder} that can be used to build a
	 * {@link ReactorClientHttpRequestFactory}.
	 * @return a new {@link ReactorClientHttpRequestFactoryBuilder}
	 */
	static ReactorClientHttpRequestFactoryBuilder reactor() {
		return new ReactorClientHttpRequestFactoryBuilder();
	}
	/**
	 * Return a {@link JdkClientHttpRequestFactoryBuilder} that can be used to build a
	 * {@link JdkClientHttpRequestFactory} .
	 * @return a new {@link JdkClientHttpRequestFactoryBuilder}
	 */
	static JdkClientHttpRequestFactoryBuilder jdk() {
		return new JdkClientHttpRequestFactoryBuilder();
	}
	/**
	 * Return a {@link SimpleClientHttpRequestFactoryBuilder} that can be used to build a
	 * {@link SimpleClientHttpRequestFactory} .
	 * @return a new {@link SimpleClientHttpRequestFactoryBuilder}
	 */
	static SimpleClientHttpRequestFactoryBuilder simple() {
		return new SimpleClientHttpRequestFactoryBuilder();
	}
	/**
	 * Return a new {@link ClientHttpRequestFactoryBuilder} for the given
	 * {@code requestFactoryType}. The following implementations are supported without the
	 * use of reflection:
	 * <ul>
	 * <li>{@link HttpComponentsClientHttpRequestFactory}</li>
	 * <li>{@link JdkClientHttpRequestFactory}</li>
	 * <li>{@link JettyClientHttpRequestFactory}</li>
	 * <li>{@link ReactorClientHttpRequestFactory}</li>
	 * <li>{@link SimpleClientHttpRequestFactory}</li>
	 * </ul>
	 * @param <T> the {@link ClientHttpRequestFactory} type
	 * @param requestFactoryType the {@link ClientHttpRequestFactory} type
	 * @return a new {@link ClientHttpRequestFactoryBuilder}
	 */
	@SuppressWarnings('unchecked')
	static <T extends ClientHttpRequestFactory> ClientHttpRequestFactoryBuilder<T> of(Class<T> requestFactoryType) {
		Assert.notNull(requestFactoryType, '"requestFactoryType" must not be null');
		Assert.isTrue(requestFactoryType != ClientHttpRequestFactory.class,
				'"requestFactoryType" must be an implementation of ClientHttpRequestFactory');
		if (requestFactoryType == HttpComponentsClientHttpRequestFactory.class) {
			return (ClientHttpRequestFactoryBuilder<T>) httpComponents();
		}
		if (requestFactoryType == JettyClientHttpRequestFactory.class) {
			return (ClientHttpRequestFactoryBuilder<T>) jetty();
		}
		if (requestFactoryType == ReactorClientHttpRequestFactory.class) {
			return (ClientHttpRequestFactoryBuilder<T>) reactor();
		}
		if (requestFactoryType == JdkClientHttpRequestFactory.class) {
			return (ClientHttpRequestFactoryBuilder<T>) jdk();
		}
		if (requestFactoryType == SimpleClientHttpRequestFactory.class) {
			return (ClientHttpRequestFactoryBuilder<T>) simple();
		}
		return new ReflectiveComponentsClientHttpRequestFactoryBuilder<>(requestFactoryType);
	}
	/**
	 * Return a new {@link ClientHttpRequestFactoryBuilder} from the given supplier, using
	 * reflection to ultimately apply the {@link ClientHttpRequestFactorySettings}.
	 * @param <T> the {@link ClientHttpRequestFactory} type
	 * @param requestFactorySupplier the {@link ClientHttpRequestFactory} supplier
	 * @return a new {@link ClientHttpRequestFactoryBuilder}
	 */
	static <T extends ClientHttpRequestFactory> ClientHttpRequestFactoryBuilder<T> of(
			Supplier<T> requestFactorySupplier) {
		return new ReflectiveComponentsClientHttpRequestFactoryBuilder<>(requestFactorySupplier);
	}
	/**
	 * Detect the most suitable {@link ClientHttpRequestFactoryBuilder} based on the
	 * classpath. The methods favors builders in the following order:
	 * <ol>
	 * <li>{@link #httpComponents()}</li>
	 * <li>{@link #jetty()}</li>
	 * <li>{@link #reactor()}</li>
	 * <li>{@link #jdk()}</li>
	 * <li>{@link #simple()}</li>
	 * </ol>
	 * @return the most suitable {@link ClientHttpRequestFactoryBuilder} for the classpath
	 */
	static ClientHttpRequestFactoryBuilder<? extends ClientHttpRequestFactory> detect() {
		if (HttpComponentsClientHttpRequestFactoryBuilder.Classes.PRESENT) {
			return httpComponents();
		}
		if (JettyClientHttpRequestFactoryBuilder.Classes.PRESENT) {
			return jetty();
		}
		if (ReactorClientHttpRequestFactoryBuilder.Classes.PRESENT) {
			return reactor();
		}
		if (JdkClientHttpRequestFactoryBuilder.Classes.PRESENT) {
			return jdk();
		}
		return simple();
	}
}
/*
package org.springframework.boot.http.client;
/**
public final class SimpleClientHttpRequestFactoryBuilder
		extends AbstractClientHttpRequestFactoryBuilder<SimpleClientHttpRequestFactory> {
	SimpleClientHttpRequestFactoryBuilder() {
		this(null);
	}
	private SimpleClientHttpRequestFactoryBuilder(List<Consumer<SimpleClientHttpRequestFactory>> customizers) {
		super(customizers);
	}
	@Override
	public SimpleClientHttpRequestFactoryBuilder withCustomizer(Consumer<SimpleClientHttpRequestFactory> customizer) {
		return new SimpleClientHttpRequestFactoryBuilder(mergedCustomizers(customizer));
	}
	@Override
	public SimpleClientHttpRequestFactoryBuilder withCustomizers(
			Collection<Consumer<SimpleClientHttpRequestFactory>> customizers) {
		return new SimpleClientHttpRequestFactoryBuilder(mergedCustomizers(customizers));
	}
	@Override
	protected SimpleClientHttpRequestFactory createClientHttpRequestFactory(ClientHttpRequestFactorySettings settings) {
		SslBundle sslBundle = settings.sslBundle();
		SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpsRequestFactory(settings);
		Assert.state(sslBundle == null || !sslBundle.getOptions().isSpecified(),
				'SSL Options cannot be specified with Java connections');
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::readTimeout).asInt(Duration::toMillis).to(requestFactory::setReadTimeout);
		map.from(settings::connectTimeout).asInt(Duration::toMillis).to(requestFactory::setConnectTimeout);
		return requestFactory;
	}
	/**
	 * {@link SimpleClientHttpsRequestFactory} to configure SSL from an {@link SslBundle}
	 * and {@link Redirects}.
	 */
	private static class SimpleClientHttpsRequestFactory extends SimpleClientHttpRequestFactory {
		private final ClientHttpRequestFactorySettings settings;
		SimpleClientHttpsRequestFactory(ClientHttpRequestFactorySettings settings) {
			this.settings = settings;
		}
		@Override
		protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {
			super.prepareConnection(connection, httpMethod);
			if (this.settings.sslBundle() != null && connection instanceof HttpsURLConnection secureConnection) {
				SSLSocketFactory socketFactory = this.settings.sslBundle().createSslContext().getSocketFactory();
				secureConnection.setSSLSocketFactory(socketFactory);
			}
			if (this.settings.redirects() == Redirects.DONT_FOLLOW) {
				connection.setInstanceFollowRedirects(false);
			}
		}
	}
}
/*
package org.springframework.boot.http.client;
/**
public class JdkClientHttpRequestFactoryBuilder
		extends AbstractClientHttpRequestFactoryBuilder<JdkClientHttpRequestFactory> {
	JdkClientHttpRequestFactoryBuilder() {
		this(null);
	}
	private JdkClientHttpRequestFactoryBuilder(List<Consumer<JdkClientHttpRequestFactory>> customizers) {
		super(customizers);
	}
	@Override
	public JdkClientHttpRequestFactoryBuilder withCustomizer(Consumer<JdkClientHttpRequestFactory> customizer) {
		return new JdkClientHttpRequestFactoryBuilder(mergedCustomizers(customizer));
	}
	@Override
	public JdkClientHttpRequestFactoryBuilder withCustomizers(
			Collection<Consumer<JdkClientHttpRequestFactory>> customizers) {
		return new JdkClientHttpRequestFactoryBuilder(mergedCustomizers(customizers));
	}
	@Override
	protected JdkClientHttpRequestFactory createClientHttpRequestFactory(ClientHttpRequestFactorySettings settings) {
		HttpClient httpClient = createHttpClient(settings);
		JdkClientHttpRequestFactory requestFactory = new JdkClientHttpRequestFactory(httpClient);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::readTimeout).to(requestFactory::setReadTimeout);
		return requestFactory;
	}
	private HttpClient createHttpClient(ClientHttpRequestFactorySettings settings) {
		HttpClient.Builder httpClientBuilder = HttpClient.newBuilder();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::connectTimeout).to(httpClientBuilder::connectTimeout);
		map.from(settings::sslBundle).as(SslBundle::createSslContext).to(httpClientBuilder::sslContext);
		map.from(settings::redirects).as(this::asHttpClientRedirect).to(httpClientBuilder::followRedirects);
		return httpClientBuilder.build();
	}
	private Redirect asHttpClientRedirect(Redirects redirects) {
		return switch (redirects) {
			case FOLLOW_WHEN_POSSIBLE, FOLLOW -> Redirect.NORMAL;
			case DONT_FOLLOW -> Redirect.NEVER;
		};
	}
	static class Classes {
		static final String HTTP_CLIENT = 'java.net.http.HttpClient';
		static final boolean PRESENT = ClassUtils.isPresent(HTTP_CLIENT, null);
	}
}
/*
package org.springframework.boot.http.client;
/**
abstract class AbstractClientHttpRequestFactoryBuilder<T extends ClientHttpRequestFactory>
		implements ClientHttpRequestFactoryBuilder<T> {
	private final List<Consumer<T>> customizers;
	protected AbstractClientHttpRequestFactoryBuilder(List<Consumer<T>> customizers) {
		this.customizers = (customizers != null) ? customizers : Collections.emptyList();
	}
	protected final List<Consumer<T>> mergedCustomizers(Consumer<T> customizer) {
		Assert.notNull(this.customizers, '"customizer" must not be null');
		return merge(this.customizers, List.of(customizer));
	}
	protected final List<Consumer<T>> mergedCustomizers(Collection<Consumer<T>> customizers) {
		Assert.notNull(customizers, '"customizers" must not be null');
		Assert.noNullElements(customizers, '"customizers" must not contain null elements');
		return merge(this.customizers, customizers);
	}
	private <E> List<E> merge(Collection<E> list, Collection<? extends E> additional) {
		List<E> merged = new ArrayList<>(list);
		merged.addAll(additional);
		return List.copyOf(merged);
	}
	@Override
	@SuppressWarnings('unchecked')
	public final T build(ClientHttpRequestFactorySettings settings) {
		T factory = createClientHttpRequestFactory(
				(settings != null) ? settings : ClientHttpRequestFactorySettings.defaults());
		LambdaSafe.callbacks(Consumer.class, this.customizers, factory).invoke((consumer) -> consumer.accept(factory));
		return factory;
	}
	protected abstract T createClientHttpRequestFactory(ClientHttpRequestFactorySettings settings);
}
/*
package org.springframework.boot.http.client;
/**
public final class HttpComponentsClientHttpRequestFactoryBuilder
		extends AbstractClientHttpRequestFactoryBuilder<HttpComponentsClientHttpRequestFactory> {
	HttpComponentsClientHttpRequestFactoryBuilder() {
		this(Collections.emptyList());
	}
	private HttpComponentsClientHttpRequestFactoryBuilder(
			List<Consumer<HttpComponentsClientHttpRequestFactory>> customizers) {
		super(customizers);
	}
	@Override
	public HttpComponentsClientHttpRequestFactoryBuilder withCustomizer(
			Consumer<HttpComponentsClientHttpRequestFactory> customizer) {
		return new HttpComponentsClientHttpRequestFactoryBuilder(mergedCustomizers(customizer));
	}
	@Override
	public HttpComponentsClientHttpRequestFactoryBuilder withCustomizers(
			Collection<Consumer<HttpComponentsClientHttpRequestFactory>> customizers) {
		return new HttpComponentsClientHttpRequestFactoryBuilder(mergedCustomizers(customizers));
	}
	@Override
	protected HttpComponentsClientHttpRequestFactory createClientHttpRequestFactory(
			ClientHttpRequestFactorySettings settings) {
		HttpClient httpClient = createHttpClient(settings);
		HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::connectTimeout).asInt(Duration::toMillis).to(factory::setConnectTimeout);
		return factory;
	}
	private HttpClient createHttpClient(ClientHttpRequestFactorySettings settings) {
		return HttpClientBuilder.create()
			.useSystemProperties()
			.setRedirectStrategy(asRedirectStrategy(settings.redirects()))
			.setConnectionManager(createConnectionManager(settings))
			.build();
	}
	private RedirectStrategy asRedirectStrategy(Redirects redirects) {
		return switch (redirects) {
			case FOLLOW_WHEN_POSSIBLE, FOLLOW -> DefaultRedirectStrategy.INSTANCE;
			case DONT_FOLLOW -> NoFollowRedirectStrategy.INSTANCE;
		};
	}
	private PoolingHttpClientConnectionManager createConnectionManager(ClientHttpRequestFactorySettings settings) {
		PoolingHttpClientConnectionManagerBuilder builder = PoolingHttpClientConnectionManagerBuilder.create();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::readTimeout).as(this::createSocketConfig).to(builder::setDefaultSocketConfig);
		map.from(settings::sslBundle).as(this::createTlsSocketStrategy).to(builder::setTlsSocketStrategy);
		return builder.useSystemProperties().build();
	}
	private DefaultClientTlsStrategy createTlsSocketStrategy(SslBundle sslBundle) {
		SslOptions options = sslBundle.getOptions();
		return new DefaultClientTlsStrategy(sslBundle.createSslContext(), options.getEnabledProtocols(),
				options.getCiphers(), null, new DefaultHostnameVerifier());
	}
	private SocketConfig createSocketConfig(Duration readTimeout) {
		return SocketConfig.custom().setSoTimeout((int) readTimeout.toMillis(), TimeUnit.MILLISECONDS).build();
	}
	/**
	 * {@link RedirectStrategy} that never follows redirects.
	 */
	private static final class NoFollowRedirectStrategy implements RedirectStrategy {
		private static final RedirectStrategy INSTANCE = new NoFollowRedirectStrategy();
		private NoFollowRedirectStrategy() {
		}
		@Override
		public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
			return false;
		}
		@Override
		public URI getLocationURI(HttpRequest request, HttpResponse response, HttpContext context) {
			return null;
		}
	}
	static class Classes {
		static final String HTTP_CLIENTS = 'org.apache.hc.client5.http.impl.classic.HttpClients';
		static final boolean PRESENT = ClassUtils.isPresent(HTTP_CLIENTS, null);
	}
}
/*
package org.springframework.boot.http.client;
/**
public final class JettyClientHttpRequestFactoryBuilder
		extends AbstractClientHttpRequestFactoryBuilder<JettyClientHttpRequestFactory> {
	JettyClientHttpRequestFactoryBuilder() {
		this(null);
	}
	private JettyClientHttpRequestFactoryBuilder(List<Consumer<JettyClientHttpRequestFactory>> customizers) {
		super(customizers);
	}
	@Override
	public JettyClientHttpRequestFactoryBuilder withCustomizer(Consumer<JettyClientHttpRequestFactory> customizer) {
		return new JettyClientHttpRequestFactoryBuilder(mergedCustomizers(customizer));
	}
	@Override
	public JettyClientHttpRequestFactoryBuilder withCustomizers(
			Collection<Consumer<JettyClientHttpRequestFactory>> customizers) {
		return new JettyClientHttpRequestFactoryBuilder(mergedCustomizers(customizers));
	}
	@Override
	protected JettyClientHttpRequestFactory createClientHttpRequestFactory(ClientHttpRequestFactorySettings settings) {
		JettyClientHttpRequestFactory requestFactory = createRequestFactory(settings);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::connectTimeout).asInt(Duration::toMillis).to(requestFactory::setConnectTimeout);
		map.from(settings::readTimeout).asInt(Duration::toMillis).to(requestFactory::setReadTimeout);
		return requestFactory;
	}
	private JettyClientHttpRequestFactory createRequestFactory(ClientHttpRequestFactorySettings settings) {
		HttpClientTransport transport = createTransport(settings);
		HttpClient httpClient = new HttpClient(transport);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::redirects).as(this::followRedirects).to(httpClient::setFollowRedirects);
		return new JettyClientHttpRequestFactory(httpClient);
	}
	private HttpClientTransport createTransport(ClientHttpRequestFactorySettings settings) {
		if (settings.sslBundle() == null) {
			return new HttpClientTransportOverHTTP();
		}
		ClientConnector connector = createClientConnector(settings.sslBundle());
		return new HttpClientTransportDynamic(connector);
	}
	private ClientConnector createClientConnector(SslBundle sslBundle) {
		SSLContext sslContext = sslBundle.createSslContext();
		SslContextFactory.Client sslContextFactory = new SslContextFactory.Client();
		sslContextFactory.setSslContext(sslContext);
		ClientConnector connector = new ClientConnector();
		connector.setSslContextFactory(sslContextFactory);
		return connector;
	}
	private boolean followRedirects(Redirects redirects) {
		return switch (redirects) {
			case FOLLOW_WHEN_POSSIBLE, FOLLOW -> true;
			case DONT_FOLLOW -> false;
		};
	}
	static class Classes {
		static final String HTTP_CLIENT = 'org.eclipse.jetty.client.HttpClient';
		static final boolean PRESENT = ClassUtils.isPresent(HTTP_CLIENT, null);
	}
}
/*
package org.springframework.boot.http.client;
/**
class ClientHttpRequestFactoryRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		if (ClassUtils.isPresent('org.springframework.http.client.ClientHttpRequestFactory', classLoader)) {
			registerHints(hints.reflection(), classLoader);
		}
	}
	private void registerHints(ReflectionHints hints, ClassLoader classLoader) {
		hints.registerField(findField(AbstractClientHttpRequestFactoryWrapper.class, 'requestFactory'));
		registerClientHttpRequestFactoryHints(hints, classLoader,
				HttpComponentsClientHttpRequestFactoryBuilder.Classes.HTTP_CLIENTS,
				() -> registerReflectionHints(hints, HttpComponentsClientHttpRequestFactory.class));
		registerClientHttpRequestFactoryHints(hints, classLoader,
				JettyClientHttpRequestFactoryBuilder.Classes.HTTP_CLIENT,
				() -> registerReflectionHints(hints, JettyClientHttpRequestFactory.class, long.class));
		registerClientHttpRequestFactoryHints(hints, classLoader,
				ReactorClientHttpRequestFactoryBuilder.Classes.HTTP_CLIENT,
				() -> registerReflectionHints(hints, ReactorClientHttpRequestFactory.class, long.class));
		registerClientHttpRequestFactoryHints(hints, classLoader,
				JdkClientHttpRequestFactoryBuilder.Classes.HTTP_CLIENT,
				() -> registerReflectionHints(hints, JdkClientHttpRequestFactory.class));
		hints.registerType(SimpleClientHttpRequestFactory.class, (typeHint) -> {
			typeHint.onReachableType(HttpURLConnection.class);
			registerReflectionHints(hints, SimpleClientHttpRequestFactory.class);
		});
	}
	private void registerClientHttpRequestFactoryHints(ReflectionHints hints, ClassLoader classLoader, String className,
			Runnable action) {
		hints.registerTypeIfPresent(classLoader, className, (typeHint) -> {
			typeHint.onReachableType(TypeReference.of(className));
			action.run();
		});
	}
	private void registerReflectionHints(ReflectionHints hints,
			Class<? extends ClientHttpRequestFactory> requestFactoryType) {
		registerReflectionHints(hints, requestFactoryType, int.class);
	}
	private void registerReflectionHints(ReflectionHints hints,
			Class<? extends ClientHttpRequestFactory> requestFactoryType, Class<?> readTimeoutType) {
		registerMethod(hints, requestFactoryType, 'setConnectTimeout', int.class);
		registerMethod(hints, requestFactoryType, 'setReadTimeout', readTimeoutType);
	}
	private void registerMethod(ReflectionHints hints, Class<? extends ClientHttpRequestFactory> requestFactoryType,
			String methodName, Class<?>... parameterTypes) {
		Method method = ReflectionUtils.findMethod(requestFactoryType, methodName, parameterTypes);
		if (method != null) {
			hints.registerMethod(method, ExecutableMode.INVOKE);
		}
	}
	private Field findField(Class<?> type, String name) {
		Field field = ReflectionUtils.findField(type, name);
		Assert.state(field != null, () -> 'Unable to find field "%s" on %s'.formatted(type.getName(), name));
		return field;
	}
}
/*
/**
package org.springframework.boot.http.client;
/*
package org.springframework.boot.http.client;
/**
public final class ReactorClientHttpRequestFactoryBuilder
		extends AbstractClientHttpRequestFactoryBuilder<ReactorClientHttpRequestFactory> {
	ReactorClientHttpRequestFactoryBuilder() {
		this(null);
	}
	private ReactorClientHttpRequestFactoryBuilder(List<Consumer<ReactorClientHttpRequestFactory>> customizers) {
		super(customizers);
	}
	@Override
	public ReactorClientHttpRequestFactoryBuilder withCustomizer(Consumer<ReactorClientHttpRequestFactory> customizer) {
		return new ReactorClientHttpRequestFactoryBuilder(mergedCustomizers(customizer));
	}
	@Override
	public ReactorClientHttpRequestFactoryBuilder withCustomizers(
			Collection<Consumer<ReactorClientHttpRequestFactory>> customizers) {
		return new ReactorClientHttpRequestFactoryBuilder(mergedCustomizers(customizers));
	}
	@Override
	protected ReactorClientHttpRequestFactory createClientHttpRequestFactory(
			ClientHttpRequestFactorySettings settings) {
		ReactorClientHttpRequestFactory requestFactory = createRequestFactory(settings);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::connectTimeout).asInt(Duration::toMillis).to(requestFactory::setConnectTimeout);
		map.from(settings::readTimeout).asInt(Duration::toMillis).to(requestFactory::setReadTimeout);
		return requestFactory;
	}
	private ReactorClientHttpRequestFactory createRequestFactory(ClientHttpRequestFactorySettings settings) {
		HttpClient httpClient = applyDefaults(HttpClient.create());
		httpClient = httpClient.followRedirect(followRedirects(settings.redirects()));
		if (settings.sslBundle() != null) {
			httpClient = httpClient.secure((ThrowingConsumer.of((spec) -> configureSsl(spec, settings.sslBundle()))));
		}
		return new ReactorClientHttpRequestFactory(httpClient);
	}
	private boolean followRedirects(Redirects redirects) {
		return switch (redirects) {
			case FOLLOW_WHEN_POSSIBLE, FOLLOW -> true;
			case DONT_FOLLOW -> false;
		};
	}
	HttpClient applyDefaults(HttpClient httpClient) {
		// Aligns with ReactorClientHttpRequestFactory defaults
		return httpClient.compress(true);
	}
	private void configureSsl(SslContextSpec spec, SslBundle sslBundle) throws SSLException {
		SslOptions options = sslBundle.getOptions();
		SslManagerBundle managers = sslBundle.getManagers();
		SslContextBuilder builder = SslContextBuilder.forClient()
			.keyManager(managers.getKeyManagerFactory())
			.trustManager(managers.getTrustManagerFactory())
			.ciphers(SslOptions.asSet(options.getCiphers()))
			.protocols(options.getEnabledProtocols());
		spec.sslContext(builder.build());
	}
	static class Classes {
		static final String HTTP_CLIENT = 'reactor.netty.http.client.HttpClient';
		static final boolean PRESENT = ClassUtils.isPresent(HTTP_CLIENT, null);
	}
}
/*
package org.springframework.boot.http.client;
/**
final class ReflectiveComponentsClientHttpRequestFactoryBuilder<T extends ClientHttpRequestFactory>
		implements ClientHttpRequestFactoryBuilder<T> {
	private final Supplier<T> requestFactorySupplier;
	ReflectiveComponentsClientHttpRequestFactoryBuilder(Supplier<T> requestFactorySupplier) {
		Assert.notNull(requestFactorySupplier, '"requestFactorySupplier" must not be null');
		this.requestFactorySupplier = requestFactorySupplier;
	}
	ReflectiveComponentsClientHttpRequestFactoryBuilder(Class<T> requestFactoryType) {
		Assert.notNull(requestFactoryType, '"requestFactoryType" must not be null');
		this.requestFactorySupplier = () -> createRequestFactory(requestFactoryType);
	}
	private static <T extends ClientHttpRequestFactory> T createRequestFactory(Class<T> requestFactory) {
		try {
			Constructor<T> constructor = requestFactory.getDeclaredConstructor();
			constructor.setAccessible(true);
			return constructor.newInstance();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	@Override
	public T build(ClientHttpRequestFactorySettings settings) {
		T requestFactory = this.requestFactorySupplier.get();
		if (settings != null) {
			configure(requestFactory, settings);
		}
		return requestFactory;
	}
	private void configure(ClientHttpRequestFactory requestFactory, ClientHttpRequestFactorySettings settings) {
		Assert.state(settings.sslBundle() == null, 'Unable to set SSL bundle using reflection');
		Assert.state(settings.redirects() == Redirects.FOLLOW_WHEN_POSSIBLE,
				'Unable to set redirect follow using reflection');
		ClientHttpRequestFactory unwrapped = unwrapRequestFactoryIfNecessary(requestFactory);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(settings::connectTimeout).to((connectTimeout) -> setConnectTimeout(unwrapped, connectTimeout));
		map.from(settings::readTimeout).to((readTimeout) -> setReadTimeout(unwrapped, readTimeout));
	}
	private ClientHttpRequestFactory unwrapRequestFactoryIfNecessary(ClientHttpRequestFactory requestFactory) {
		if (!(requestFactory instanceof AbstractClientHttpRequestFactoryWrapper)) {
			return requestFactory;
		}
		Field field = ReflectionUtils.findField(AbstractClientHttpRequestFactoryWrapper.class, 'requestFactory');
		ReflectionUtils.makeAccessible(field);
		ClientHttpRequestFactory unwrappedRequestFactory = requestFactory;
		while (unwrappedRequestFactory instanceof AbstractClientHttpRequestFactoryWrapper) {
			unwrappedRequestFactory = (ClientHttpRequestFactory) ReflectionUtils.getField(field,
					unwrappedRequestFactory);
		}
		return unwrappedRequestFactory;
	}
	private void setConnectTimeout(ClientHttpRequestFactory factory, Duration connectTimeout) {
		Method method = tryFindMethod(factory, 'setConnectTimeout', Duration.class);
		if (method != null) {
			invoke(factory, method, connectTimeout);
			return;
		}
		method = findMethod(factory, 'setConnectTimeout', int.class);
		int timeout = Math.toIntExact(connectTimeout.toMillis());
		invoke(factory, method, timeout);
	}
	private void setReadTimeout(ClientHttpRequestFactory factory, Duration readTimeout) {
		Method method = tryFindMethod(factory, 'setReadTimeout', Duration.class);
		if (method != null) {
			invoke(factory, method, readTimeout);
			return;
		}
		method = findMethod(factory, 'setReadTimeout', int.class);
		int timeout = Math.toIntExact(readTimeout.toMillis());
		invoke(factory, method, timeout);
	}
	private Method findMethod(ClientHttpRequestFactory requestFactory, String methodName, Class<?>... parameters) {
		Method method = ReflectionUtils.findMethod(requestFactory.getClass(), methodName, parameters);
		Assert.state(method != null, () -> 'Request factory %s does not have a suitable %s method'
			.formatted(requestFactory.getClass().getName(), methodName));
		Assert.state(!method.isAnnotationPresent(Deprecated.class),
				() -> 'Request factory %s has the %s method marked as deprecated'
					.formatted(requestFactory.getClass().getName(), methodName));
		return method;
	}
	private Method tryFindMethod(ClientHttpRequestFactory requestFactory, String methodName, Class<?>... parameters) {
		Method method = ReflectionUtils.findMethod(requestFactory.getClass(), methodName, parameters);
		if (method == null) {
			return null;
		}
		if (method.isAnnotationPresent(Deprecated.class)) {
			return null;
		}
		return method;
	}
	private void invoke(ClientHttpRequestFactory requestFactory, Method method, Object... parameters) {
		ReflectionUtils.invokeMethod(method, requestFactory, parameters);
	}
}
/*
package org.springframework.boot.builder;
/**
public class ParentContextCloserApplicationListener
		implements ApplicationListener<ParentContextAvailableEvent>, ApplicationContextAware, Ordered {
	private final int order = Ordered.LOWEST_PRECEDENCE - 10;
	private ApplicationContext context;
	@Override
	public int getOrder() {
		return this.order;
	}
	@Override
	public void setApplicationContext(ApplicationContext context) throws BeansException {
		this.context = context;
	}
	@Override
	public void onApplicationEvent(ParentContextAvailableEvent event) {
		maybeInstallListenerInParent(event.getApplicationContext());
	}
	private void maybeInstallListenerInParent(ConfigurableApplicationContext child) {
		if (child == this.context && child.getParent() instanceof ConfigurableApplicationContext parent) {
			parent.addApplicationListener(createContextCloserListener(child));
		}
	}
	/**
	 * Subclasses may override to create their own subclass of ContextCloserListener. This
	 * still enforces the use of a weak reference.
	 * @param child the child context
	 * @return the {@link ContextCloserListener} to use
	 */
	protected ContextCloserListener createContextCloserListener(ConfigurableApplicationContext child) {
		return new ContextCloserListener(child);
	}
	/**
	 * {@link ApplicationListener} to close the context.
	 */
	protected static class ContextCloserListener implements ApplicationListener<ContextClosedEvent> {
		private final WeakReference<ConfigurableApplicationContext> childContext;
		public ContextCloserListener(ConfigurableApplicationContext childContext) {
			this.childContext = new WeakReference<>(childContext);
		}
		@Override
		public void onApplicationEvent(ContextClosedEvent event) {
			ConfigurableApplicationContext context = this.childContext.get();
			if ((context != null) && (event.getApplicationContext() == context.getParent()) && context.isActive()) {
				context.close();
			}
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (obj instanceof ContextCloserListener other) {
				return ObjectUtils.nullSafeEquals(this.childContext.get(), other.childContext.get());
			}
			return super.equals(obj);
		}
		@Override
		public int hashCode() {
			return ObjectUtils.nullSafeHashCode(this.childContext.get());
		}
	}
}
/*
package org.springframework.boot.builder;
/**
public class SpringApplicationBuilder {
	private final SpringApplication application;
	private volatile ConfigurableApplicationContext context;
	private SpringApplicationBuilder parent;
	private final AtomicBoolean running = new AtomicBoolean();
	private final Set<Class<?>> sources = new LinkedHashSet<>();
	private final Map<String, Object> defaultProperties = new LinkedHashMap<>();
	private ConfigurableEnvironment environment;
	private Set<String> additionalProfiles = new LinkedHashSet<>();
	private boolean registerShutdownHookApplied;
	private boolean configuredAsChild = false;
	public SpringApplicationBuilder(Class<?>... sources) {
		this(null, sources);
	}
	public SpringApplicationBuilder(ResourceLoader resourceLoader, Class<?>... sources) {
		this.application = createSpringApplication(resourceLoader, sources);
	}
	/**
	 * Creates a new {@link SpringApplication} instance from the given sources using the
	 * given {@link ResourceLoader}. Subclasses may override in order to provide a custom
	 * subclass of {@link SpringApplication}.
	 * @param resourceLoader the resource loader or {@code null}
	 * @param sources the sources
	 * @return the {@link SpringApplication} instance
	 * @since 2.6.0
	 */
	protected SpringApplication createSpringApplication(ResourceLoader resourceLoader, Class<?>... sources) {
		return new SpringApplication(resourceLoader, sources);
	}
	/**
	 * Accessor for the current application context.
	 * @return the current application context (or null if not yet running)
	 */
	public ConfigurableApplicationContext context() {
		return this.context;
	}
	/**
	 * Accessor for the current application.
	 * @return the current application (never null)
	 */
	public SpringApplication application() {
		return this.application;
	}
	/**
	 * Create an application context (and its parent if specified) with the command line
	 * args provided. The parent is run first with the same arguments if it has not yet
	 * been started.
	 * @param args the command line arguments
	 * @return an application context created from the current state
	 */
	public ConfigurableApplicationContext run(String... args) {
		if (this.running.get()) {
			// If already created we just return the existing context
			return this.context;
		}
		configureAsChildIfNecessary(args);
		if (this.running.compareAndSet(false, true)) {
			// If not already running copy the sources over and then run.
			this.context = build().run(args);
		}
		return this.context;
	}
	private void configureAsChildIfNecessary(String... args) {
		if (this.parent != null && !this.configuredAsChild) {
			this.configuredAsChild = true;
			if (!this.registerShutdownHookApplied) {
				this.application.setRegisterShutdownHook(false);
			}
			initializers(new ParentContextApplicationContextInitializer(this.parent.run(args)));
		}
	}
	/**
	 * Returns a fully configured {@link SpringApplication} that is ready to run.
	 * @return the fully configured {@link SpringApplication}.
	 */
	public SpringApplication build() {
		return build(new String[0]);
	}
	/**
	 * Returns a fully configured {@link SpringApplication} that is ready to run. Any
	 * parent that has been configured will be run with the given {@code args}.
	 * @param args the parent"s args
	 * @return the fully configured {@link SpringApplication}.
	 */
	public SpringApplication build(String... args) {
		configureAsChildIfNecessary(args);
		this.application.addPrimarySources(this.sources);
		return this.application;
	}
	/**
	 * Create a child application with the provided sources. Default args and environment
	 * are copied down into the child, but everything else is a clean sheet.
	 * @param sources the sources for the application (Spring configuration)
	 * @return the child application builder
	 */
	public SpringApplicationBuilder child(Class<?>... sources) {
		SpringApplicationBuilder child = new SpringApplicationBuilder();
		child.sources(sources);
		// Copy environment stuff from parent to child
		child.properties(this.defaultProperties)
			.environment(this.environment)
			.additionalProfiles(this.additionalProfiles);
		child.parent = this;
		// It"s not possible if embedded web server are enabled to support web contexts as
		// parents because the servlets cannot be initialized at the right point in
		// lifecycle.
		web(WebApplicationType.NONE);
		// Probably not interested in multiple banners
		bannerMode(Banner.Mode.OFF);
		// Make sure sources get copied over
		this.application.addPrimarySources(this.sources);
		return child;
	}
	/**
	 * Add a parent application with the provided sources. Default args and environment
	 * are copied up into the parent, but everything else is a clean sheet.
	 * @param sources the sources for the application (Spring configuration)
	 * @return the parent builder
	 */
	public SpringApplicationBuilder parent(Class<?>... sources) {
		if (this.parent == null) {
			this.parent = new SpringApplicationBuilder(sources).web(WebApplicationType.NONE)
				.properties(this.defaultProperties)
				.environment(this.environment);
		}
		else {
			this.parent.sources(sources);
		}
		return this.parent;
	}
	private SpringApplicationBuilder runAndExtractParent(String... args) {
		if (this.context == null) {
			run(args);
		}
		if (this.parent != null) {
			return this.parent;
		}
		throw new IllegalStateException(
				'No parent defined yet (please use the other overloaded parent methods to set one)');
	}
	/**
	 * Add an already running parent context to an existing application.
	 * @param parent the parent context
	 * @return the current builder (not the parent)
	 */
	public SpringApplicationBuilder parent(ConfigurableApplicationContext parent) {
		this.parent = new SpringApplicationBuilder();
		this.parent.context = parent;
		this.parent.running.set(true);
		return this;
	}
	/**
	 * Create a sibling application (one with the same parent). A side effect of calling
	 * this method is that the current application (and its parent) are started without
	 * any arguments if they are not already running. To supply arguments when starting
	 * the current application and its parent use {@link #sibling(Class[], String...)}
	 * instead.
	 * @param sources the sources for the application (Spring configuration)
	 * @return the new sibling builder
	 */
	public SpringApplicationBuilder sibling(Class<?>... sources) {
		return runAndExtractParent().child(sources);
	}
	/**
	 * Create a sibling application (one with the same parent). A side effect of calling
	 * this method is that the current application (and its parent) are started if they
	 * are not already running.
	 * @param sources the sources for the application (Spring configuration)
	 * @param args the command line arguments to use when starting the current app and its
	 * parent
	 * @return the new sibling builder
	 */
	public SpringApplicationBuilder sibling(Class<?>[] sources, String... args) {
		return runAndExtractParent(args).child(sources);
	}
	/**
	 * Explicitly set the factory used to create the application context.
	 * @param factory the factory to use
	 * @return the current builder
	 * @since 2.4.0
	 */
	public SpringApplicationBuilder contextFactory(ApplicationContextFactory factory) {
		this.application.setApplicationContextFactory(factory);
		return this;
	}
	/**
	 * Add more sources (configuration classes and components) to this application.
	 * @param sources the sources to add
	 * @return the current builder
	 */
	public SpringApplicationBuilder sources(Class<?>... sources) {
		this.sources.addAll(new LinkedHashSet<>(Arrays.asList(sources)));
		return this;
	}
	/**
	 * Flag to explicitly request a specific type of web application. Auto-detected based
	 * on the classpath if not set.
	 * @param webApplicationType the type of web application
	 * @return the current builder
	 * @since 2.0.0
	 */
	public SpringApplicationBuilder web(WebApplicationType webApplicationType) {
		this.application.setWebApplicationType(webApplicationType);
		return this;
	}
	/**
	 * Flag to indicate the startup information should be logged.
	 * @param logStartupInfo the flag to set. Default true.
	 * @return the current builder
	 */
	public SpringApplicationBuilder logStartupInfo(boolean logStartupInfo) {
		this.application.setLogStartupInfo(logStartupInfo);
		return this;
	}
	/**
	 * Sets the {@link Banner} instance which will be used to print the banner when no
	 * static banner file is provided.
	 * @param banner the banner to use
	 * @return the current builder
	 */
	public SpringApplicationBuilder banner(Banner banner) {
		this.application.setBanner(banner);
		return this;
	}
	public SpringApplicationBuilder bannerMode(Banner.Mode bannerMode) {
		this.application.setBannerMode(bannerMode);
		return this;
	}
	/**
	 * Sets if the application is headless and should not instantiate AWT. Defaults to
	 * {@code true} to prevent java icons appearing.
	 * @param headless if the application is headless
	 * @return the current builder
	 */
	public SpringApplicationBuilder headless(boolean headless) {
		this.application.setHeadless(headless);
		return this;
	}
	/**
	 * Sets if the created {@link ApplicationContext} should have a shutdown hook
	 * registered.
	 * @param registerShutdownHook if the shutdown hook should be registered
	 * @return the current builder
	 */
	public SpringApplicationBuilder registerShutdownHook(boolean registerShutdownHook) {
		this.registerShutdownHookApplied = true;
		this.application.setRegisterShutdownHook(registerShutdownHook);
		return this;
	}
	/**
	 * Fixes the main application class that is used to anchor the startup messages.
	 * @param mainApplicationClass the class to use.
	 * @return the current builder
	 */
	public SpringApplicationBuilder main(Class<?> mainApplicationClass) {
		this.application.setMainApplicationClass(mainApplicationClass);
		return this;
	}
	/**
	 * Flag to indicate that command line arguments should be added to the environment.
	 * @param addCommandLineProperties the flag to set. Default true.
	 * @return the current builder
	 */
	public SpringApplicationBuilder addCommandLineProperties(boolean addCommandLineProperties) {
		this.application.setAddCommandLineProperties(addCommandLineProperties);
		return this;
	}
	/**
	 * Flag to indicate if the {@link ApplicationConversionService} should be added to the
	 * application context"s {@link Environment}.
	 * @param addConversionService if the conversion service should be added.
	 * @return the current builder
	 * @since 2.1.0
	 */
	public SpringApplicationBuilder setAddConversionService(boolean addConversionService) {
		this.application.setAddConversionService(addConversionService);
		return this;
	}
	/**
	 * Adds {@link BootstrapRegistryInitializer} instances that can be used to initialize
	 * the {@link BootstrapRegistry}.
	 * @param bootstrapRegistryInitializer the bootstrap registry initializer to add
	 * @return the current builder
	 * @since 2.4.5
	 */
	public SpringApplicationBuilder addBootstrapRegistryInitializer(
			BootstrapRegistryInitializer bootstrapRegistryInitializer) {
		this.application.addBootstrapRegistryInitializer(bootstrapRegistryInitializer);
		return this;
	}
	/**
	 * Flag to control whether the application should be initialized lazily.
	 * @param lazyInitialization the flag to set. Defaults to false.
	 * @return the current builder
	 * @since 2.2
	 */
	public SpringApplicationBuilder lazyInitialization(boolean lazyInitialization) {
		this.application.setLazyInitialization(lazyInitialization);
		return this;
	}
	/**
	 * Default properties for the environment in the form {@code key=value} or
	 * {@code key:value}. Multiple calls to this method are cumulative and will not clear
	 * any previously set properties.
	 * @param defaultProperties the properties to set.
	 * @return the current builder
	 * @see SpringApplicationBuilder#properties(Properties)
	 * @see SpringApplicationBuilder#properties(Map)
	 */
	public SpringApplicationBuilder properties(String... defaultProperties) {
		return properties(getMapFromKeyValuePairs(defaultProperties));
	}
	private Map<String, Object> getMapFromKeyValuePairs(String[] properties) {
		Map<String, Object> map = new HashMap<>();
		for (String property : properties) {
			int index = lowestIndexOf(property, ':', '=');
			String key = (index > 0) ? property.substring(0, index) : property;
			String value = (index > 0) ? property.substring(index + 1) : '';
			map.put(key, value);
		}
		return map;
	}
	private int lowestIndexOf(String property, String... candidates) {
		int index = -1;
		for (String candidate : candidates) {
			int candidateIndex = property.indexOf(candidate);
			if (candidateIndex > 0) {
				index = (index != -1) ? Math.min(index, candidateIndex) : candidateIndex;
			}
		}
		return index;
	}
	/**
	 * Default properties for the environment.Multiple calls to this method are cumulative
	 * and will not clear any previously set properties.
	 * @param defaultProperties the properties to set.
	 * @return the current builder
	 * @see SpringApplicationBuilder#properties(String...)
	 * @see SpringApplicationBuilder#properties(Map)
	 */
	public SpringApplicationBuilder properties(Properties defaultProperties) {
		return properties(getMapFromProperties(defaultProperties));
	}
	private Map<String, Object> getMapFromProperties(Properties properties) {
		Map<String, Object> map = new HashMap<>();
		for (Object key : Collections.list(properties.propertyNames())) {
			map.put((String) key, properties.get(key));
		}
		return map;
	}
	/**
	 * Default properties for the environment. Multiple calls to this method are
	 * cumulative and will not clear any previously set properties.
	 * @param defaults the default properties
	 * @return the current builder
	 * @see SpringApplicationBuilder#properties(String...)
	 * @see SpringApplicationBuilder#properties(Properties)
	 */
	public SpringApplicationBuilder properties(Map<String, Object> defaults) {
		this.defaultProperties.putAll(defaults);
		this.application.setDefaultProperties(this.defaultProperties);
		if (this.parent != null) {
			this.parent.properties(this.defaultProperties);
			this.parent.environment(this.environment);
		}
		return this;
	}
	/**
	 * Add to the active Spring profiles for this app (and its parent and children).
	 * @param profiles the profiles to add.
	 * @return the current builder
	 */
	public SpringApplicationBuilder profiles(String... profiles) {
		this.additionalProfiles.addAll(Arrays.asList(profiles));
		this.application.setAdditionalProfiles(StringUtils.toStringArray(this.additionalProfiles));
		return this;
	}
	private SpringApplicationBuilder additionalProfiles(Collection<String> additionalProfiles) {
		this.additionalProfiles = new LinkedHashSet<>(additionalProfiles);
		this.application.setAdditionalProfiles(StringUtils.toStringArray(this.additionalProfiles));
		return this;
	}
	/**
	 * Bean name generator for automatically generated bean names in the application
	 * context.
	 * @param beanNameGenerator the generator to set.
	 * @return the current builder
	 */
	public SpringApplicationBuilder beanNameGenerator(BeanNameGenerator beanNameGenerator) {
		this.application.setBeanNameGenerator(beanNameGenerator);
		return this;
	}
	/**
	 * Environment for the application context.
	 * @param environment the environment to set.
	 * @return the current builder
	 */
	public SpringApplicationBuilder environment(ConfigurableEnvironment environment) {
		this.application.setEnvironment(environment);
		this.environment = environment;
		return this;
	}
	/**
	 * Prefix that should be applied when obtaining configuration properties from the
	 * system environment.
	 * @param environmentPrefix the environment property prefix to set
	 * @return the current builder
	 * @since 2.5.0
	 */
	public SpringApplicationBuilder environmentPrefix(String environmentPrefix) {
		this.application.setEnvironmentPrefix(environmentPrefix);
		return this;
	}
	/**
	 * {@link ResourceLoader} for the application context. If a custom class loader is
	 * needed, this is where it would be added.
	 * @param resourceLoader the resource loader to set.
	 * @return the current builder
	 */
	public SpringApplicationBuilder resourceLoader(ResourceLoader resourceLoader) {
		this.application.setResourceLoader(resourceLoader);
		return this;
	}
	/**
	 * Add some initializers to the application (applied to the {@link ApplicationContext}
	 * before any bean definitions are loaded).
	 * @param initializers some initializers to add
	 * @return the current builder
	 */
	public SpringApplicationBuilder initializers(ApplicationContextInitializer<?>... initializers) {
		this.application.addInitializers(initializers);
		return this;
	}
	/**
	 * Add some listeners to the application (listening for SpringApplication events as
	 * well as regular Spring events once the context is running). Any listeners that are
	 * also {@link ApplicationContextInitializer} will be added to the
	 * {@link #initializers(ApplicationContextInitializer...) initializers} automatically.
	 * @param listeners some listeners to add
	 * @return the current builder
	 */
	public SpringApplicationBuilder listeners(ApplicationListener<?>... listeners) {
		this.application.addListeners(listeners);
		return this;
	}
	/**
	 * Configure the {@link ApplicationStartup} to be used with the
	 * {@link ApplicationContext} for collecting startup metrics.
	 * @param applicationStartup the application startup to use
	 * @return the current builder
	 * @since 2.4.0
	 */
	public SpringApplicationBuilder applicationStartup(ApplicationStartup applicationStartup) {
		this.application.setApplicationStartup(applicationStartup);
		return this;
	}
	/**
	 * Whether to allow circular references between beans and automatically try to resolve
	 * them.
	 * @param allowCircularReferences whether circular references are allowed
	 * @return the current builder
	 * @since 2.6.0
	 * @see AbstractAutowireCapableBeanFactory#setAllowCircularReferences(boolean)
	 */
	public SpringApplicationBuilder allowCircularReferences(boolean allowCircularReferences) {
		this.application.setAllowCircularReferences(allowCircularReferences);
		return this;
	}
}
/*
/**
package org.springframework.boot.builder;
/*
package org.springframework.boot.builder;
/**
public class ParentContextApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext>, Ordered {
	private int order = Ordered.HIGHEST_PRECEDENCE;
	private final ApplicationContext parent;
	public ParentContextApplicationContextInitializer(ApplicationContext parent) {
		this.parent = parent;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		if (applicationContext != this.parent) {
			applicationContext.setParent(this.parent);
			applicationContext.addApplicationListener(EventPublisher.INSTANCE);
		}
	}
	private static final class EventPublisher implements ApplicationListener<ContextRefreshedEvent>, Ordered {
		private static final EventPublisher INSTANCE = new EventPublisher();
		@Override
		public int getOrder() {
			return Ordered.HIGHEST_PRECEDENCE;
		}
		@Override
		public void onApplicationEvent(ContextRefreshedEvent event) {
			ApplicationContext context = event.getApplicationContext();
			if (context instanceof ConfigurableApplicationContext configurableApplicationContext
					&& context == event.getSource()) {
				context.publishEvent(new ParentContextAvailableEvent(configurableApplicationContext));
			}
		}
	}
	/**
	 * {@link ApplicationEvent} fired when a parent context is available.
	 */
	public static class ParentContextAvailableEvent extends ApplicationEvent {
		public ParentContextAvailableEvent(ConfigurableApplicationContext applicationContext) {
			super(applicationContext);
		}
		public ConfigurableApplicationContext getApplicationContext() {
			return (ConfigurableApplicationContext) getSource();
		}
	}
}
/*
package org.springframework.boot;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
@Indexed
public @interface SpringBootConfiguration {
	/**
	 * Specify whether {@link Bean @Bean} methods should get proxied in order to enforce
	 * bean lifecycle behavior, e.g. to return shared singleton bean instances even in
	 * case of direct {@code @Bean} method calls in user code. This feature requires
	 * method interception, implemented through a runtime-generated CGLIB subclass which
	 * comes with limitations such as the configuration class and its methods not being
	 * allowed to declare {@code final}.
	 * <p>
	 * The default is {@code true}, allowing for "inter-bean references" within the
	 * configuration class as well as for external calls to this configuration"s
	 * {@code @Bean} methods, e.g. from another configuration class. If this is not needed
	 * since each of this particular configuration"s {@code @Bean} methods is
	 * self-contained and designed as a plain factory method for container use, switch
	 * this flag to {@code false} in order to avoid CGLIB subclass processing.
	 * <p>
	 * Turning off bean method interception effectively processes {@code @Bean} methods
	 * individually like when declared on non-{@code @Configuration} classes, a.k.a.
	 * '@Bean Lite Mode' (see {@link Bean @Bean"s javadoc}). It is therefore behaviorally
	 * equivalent to removing the {@code @Configuration} stereotype.
	 * @return whether to proxy {@code @Bean} methods
	 * @since 2.2
	 */
	@AliasFor(annotation = Configuration.class)
	boolean proxyBeanMethods() default true;
}
/*
package org.springframework.boot;
/**
class ApplicationProperties {
	/**
	 * Whether bean definition overriding, by registering a definition with the same name
	 * as an existing definition, is allowed.
	 */
	private boolean allowBeanDefinitionOverriding;
	/**
	 * Whether to allow circular references between beans and automatically try to resolve
	 * them.
	 */
	private boolean allowCircularReferences;
	/**
	 * Mode used to display the banner when the application runs.
	 */
	private Banner.Mode bannerMode;
	/**
	 * Whether to keep the application alive even if there are no more non-daemon threads.
	 */
	private boolean keepAlive;
	/**
	 * Whether initialization should be performed lazily.
	 */
	private boolean lazyInitialization = false;
	/**
	 * Whether to log information about the application when it starts.
	 */
	private boolean logStartupInfo = true;
	/**
	 * Whether the application should have a shutdown hook registered.
	 */
	private boolean registerShutdownHook = true;
	/**
	 * Sources (class names, package names, or XML resource locations) to include in the
	 * ApplicationContext.
	 */
	private Set<String> sources = new LinkedHashSet<>();
	/**
	 * Flag to explicitly request a specific type of web application. If not set,
	 * auto-detected based on the classpath.
	 */
	private WebApplicationType webApplicationType;
	boolean isAllowBeanDefinitionOverriding() {
		return this.allowBeanDefinitionOverriding;
	}
	void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
		this.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;
	}
	boolean isAllowCircularReferences() {
		return this.allowCircularReferences;
	}
	void setAllowCircularReferences(boolean allowCircularReferences) {
		this.allowCircularReferences = allowCircularReferences;
	}
	Mode getBannerMode(Environment environment) {
		if (this.bannerMode != null) {
			return this.bannerMode;
		}
		boolean structuredLoggingEnabled = environment
			.containsProperty(LoggingSystemProperty.CONSOLE_STRUCTURED_FORMAT.getApplicationPropertyName());
		return (structuredLoggingEnabled) ? Mode.OFF : Banner.Mode.CONSOLE;
	}
	void setBannerMode(Mode bannerMode) {
		this.bannerMode = bannerMode;
	}
	boolean isKeepAlive() {
		return this.keepAlive;
	}
	void setKeepAlive(boolean keepAlive) {
		this.keepAlive = keepAlive;
	}
	boolean isLazyInitialization() {
		return this.lazyInitialization;
	}
	void setLazyInitialization(boolean lazyInitialization) {
		this.lazyInitialization = lazyInitialization;
	}
	boolean isLogStartupInfo() {
		return this.logStartupInfo;
	}
	void setLogStartupInfo(boolean logStartupInfo) {
		this.logStartupInfo = logStartupInfo;
	}
	boolean isRegisterShutdownHook() {
		return this.registerShutdownHook;
	}
	void setRegisterShutdownHook(boolean registerShutdownHook) {
		this.registerShutdownHook = registerShutdownHook;
	}
	Set<String> getSources() {
		return this.sources;
	}
	void setSources(Set<String> sources) {
		this.sources = new LinkedHashSet<>(sources);
	}
	WebApplicationType getWebApplicationType() {
		return this.webApplicationType;
	}
	void setWebApplicationType(WebApplicationType webApplicationType) {
		this.webApplicationType = webApplicationType;
	}
	static class ApplicationPropertiesRuntimeHints extends BindableRuntimeHintsRegistrar {
		ApplicationPropertiesRuntimeHints() {
			super(ApplicationProperties.class);
		}
	}
}
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface LazyInitializationExcludeFilter {
	/**
	 * Returns {@code true} if the specified bean definition should be excluded from
	 * having {@code lazy-init} automatically set.
	 * @param beanName the bean name
	 * @param beanDefinition the bean definition
	 * @param beanType the bean type
	 * @return {@code true} if {@code lazy-init} should not be automatically set
	 */
	boolean isExcluded(String beanName, BeanDefinition beanDefinition, Class<?> beanType);
	/**
	 * Factory method that creates a filter for the given bean types.
	 * @param types the filtered types
	 * @return a new filter instance
	 */
	static LazyInitializationExcludeFilter forBeanTypes(Class<?>... types) {
		return (beanName, beanDefinition, beanType) -> {
			for (Class<?> type : types) {
				if (type.isAssignableFrom(beanType)) {
					return true;
				}
			}
			return false;
		};
	}
}
/*
package org.springframework.boot;
/**
public class BootstrapContextClosedEvent extends ApplicationEvent {
	private final ConfigurableApplicationContext applicationContext;
	BootstrapContextClosedEvent(BootstrapContext source, ConfigurableApplicationContext applicationContext) {
		super(source);
		this.applicationContext = applicationContext;
	}
	/**
	 * Return the {@link BootstrapContext} that was closed.
	 * @return the bootstrap context
	 */
	public BootstrapContext getBootstrapContext() {
		return (BootstrapContext) this.source;
	}
	/**
	 * Return the prepared application context.
	 * @return the application context
	 */
	public ConfigurableApplicationContext getApplicationContext() {
		return this.applicationContext;
	}
}
/*
package org.springframework.boot;
/**
public class DefaultBootstrapContext implements ConfigurableBootstrapContext {
	private final Map<Class<?>, InstanceSupplier<?>> instanceSuppliers = new HashMap<>();
	private final Map<Class<?>, Object> instances = new HashMap<>();
	private final ApplicationEventMulticaster events = new SimpleApplicationEventMulticaster();
	@Override
	public <T> void register(Class<T> type, InstanceSupplier<T> instanceSupplier) {
		register(type, instanceSupplier, true);
	}
	@Override
	public <T> void registerIfAbsent(Class<T> type, InstanceSupplier<T> instanceSupplier) {
		register(type, instanceSupplier, false);
	}
	private <T> void register(Class<T> type, InstanceSupplier<T> instanceSupplier, boolean replaceExisting) {
		Assert.notNull(type, 'Type must not be null');
		Assert.notNull(instanceSupplier, 'InstanceSupplier must not be null');
		synchronized (this.instanceSuppliers) {
			boolean alreadyRegistered = this.instanceSuppliers.containsKey(type);
			if (replaceExisting || !alreadyRegistered) {
				Assert.state(!this.instances.containsKey(type), () -> type.getName() + ' has already been created');
				this.instanceSuppliers.put(type, instanceSupplier);
			}
		}
	}
	@Override
	public <T> boolean isRegistered(Class<T> type) {
		synchronized (this.instanceSuppliers) {
			return this.instanceSuppliers.containsKey(type);
		}
	}
	@Override
	@SuppressWarnings('unchecked')
	public <T> InstanceSupplier<T> getRegisteredInstanceSupplier(Class<T> type) {
		synchronized (this.instanceSuppliers) {
			return (InstanceSupplier<T>) this.instanceSuppliers.get(type);
		}
	}
	@Override
	public void addCloseListener(ApplicationListener<BootstrapContextClosedEvent> listener) {
		this.events.addApplicationListener(listener);
	}
	@Override
	public <T> T get(Class<T> type) throws IllegalStateException {
		return getOrElseThrow(type, () -> new IllegalStateException(type.getName() + ' has not been registered'));
	}
	@Override
	public <T> T getOrElse(Class<T> type, T other) {
		return getOrElseSupply(type, () -> other);
	}
	@Override
	public <T> T getOrElseSupply(Class<T> type, Supplier<T> other) {
		synchronized (this.instanceSuppliers) {
			InstanceSupplier<?> instanceSupplier = this.instanceSuppliers.get(type);
			return (instanceSupplier != null) ? getInstance(type, instanceSupplier) : other.get();
		}
	}
	@Override
	public <T, X extends Throwable> T getOrElseThrow(Class<T> type, Supplier<? extends X> exceptionSupplier) throws X {
		synchronized (this.instanceSuppliers) {
			InstanceSupplier<?> instanceSupplier = this.instanceSuppliers.get(type);
			if (instanceSupplier == null) {
				throw exceptionSupplier.get();
			}
			return getInstance(type, instanceSupplier);
		}
	}
	@SuppressWarnings('unchecked')
	private <T> T getInstance(Class<T> type, InstanceSupplier<?> instanceSupplier) {
		T instance = (T) this.instances.get(type);
		if (instance == null) {
			instance = (T) instanceSupplier.get(this);
			if (instanceSupplier.getScope() == Scope.SINGLETON) {
				this.instances.put(type, instance);
			}
		}
		return instance;
	}
	/**
	 * Method to be called when {@link BootstrapContext} is closed and the
	 * {@link ApplicationContext} is prepared.
	 * @param applicationContext the prepared context
	 */
	public void close(ConfigurableApplicationContext applicationContext) {
		this.events.multicastEvent(new BootstrapContextClosedEvent(this, applicationContext));
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@SpringBootTest
@ContextConfiguration(initializers = SetupDockerCompose.class)
@AutoConfigureTestDatabase
@OverrideAutoConfiguration(enabled = false)
@DisabledIfDockerUnavailable
class AutoConfigureTestDatabaseDockerComposeIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void dataSourceIsNotReplaced() {
		assertThat(this.dataSource).isInstanceOf(HikariDataSource.class).isNotInstanceOf(EmbeddedDatabase.class);
	}
	@Configuration
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class Config {
	}
	static class SetupDockerCompose implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
			try {
				Path composeFile = Files.createTempFile('', '-postgres-compose');
				String composeFileContent = new ClassPathResource('postgres-compose.yaml')
					.getContentAsString(StandardCharsets.UTF_8)
					.replace('{imageName}', TestImage.POSTGRESQL.toString());
				Files.writeString(composeFile, composeFileContent);
				TestPropertySourceUtils.addInlinedPropertiesToEnvironment(applicationContext,
						'spring.docker.compose.skip.in-tests=false', 'spring.docker.compose.stop.command=down',
						'spring.docker.compose.file=' + composeFile.toAbsolutePath().toString());
			}
			catch (IOException ex) {
				throw new UncheckedIOException(ex);
			}
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@SpringBootTest
@ContextConfiguration(initializers = InitializeDatasourceUrl.class)
@AutoConfigureTestDatabase(replace = Replace.NON_TEST)
@Testcontainers(disabledWithoutDocker = true)
@OverrideAutoConfiguration(enabled = false)
class AutoConfigureTestDatabaseTestcontainersJdbcUrlIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void dataSourceIsNotReplaced() {
		assertThat(this.dataSource).isInstanceOf(HikariDataSource.class).isNotInstanceOf(EmbeddedDatabase.class);
	}
	@Configuration
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class Config {
	}
	static class InitializeDatasourceUrl implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(applicationContext,
					'spring.datasource.url=jdbc:tc:postgis:' + TestImage.POSTGRESQL.getTag() + ':///');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@SpringBootTest
@AutoConfigureTestDatabase
@Testcontainers(disabledWithoutDocker = true)
@OverrideAutoConfiguration(enabled = false)
class AutoConfigureTestDatabaseDynamicPropertySourceIntegrationTests {
	@Container
	static PostgreSQLContainer<?> postgres = TestImage.container(PostgreSQLContainer.class);
	@Autowired
	private DataSource dataSource;
	@DynamicPropertySource
	static void jdbcProperties(DynamicPropertyRegistry registry) {
		registry.add('spring.datasource.url', postgres::getJdbcUrl);
	}
	@Test
	void dataSourceIsNotReplaced() {
		assertThat(this.dataSource).isInstanceOf(HikariDataSource.class).isNotInstanceOf(EmbeddedDatabase.class);
	}
	@Configuration
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@SpringBootTest
@ContextConfiguration(initializers = SetupDatabase.class)
@AutoConfigureTestDatabase
@OverrideAutoConfiguration(enabled = false)
@DisabledIfDockerUnavailable
class AutoConfigureTestDatabaseNonTestDatabaseIntegrationTests {
	@Container
	static PostgreSQLContainer<?> postgres = TestImage.container(PostgreSQLContainer.class);
	@Autowired
	private DataSource dataSource;
	@Test
	void dataSourceIsReplaced() {
		assertThat(this.dataSource).isInstanceOf(EmbeddedDatabase.class);
	}
	@Configuration
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class Config {
	}
	static class SetupDatabase implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
			postgres.start();
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(applicationContext,
					'spring.datasource.url=' + postgres.getJdbcUrl());
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@SpringBootTest
@AutoConfigureTestDatabase(replace = Replace.NON_TEST)
@Testcontainers(disabledWithoutDocker = true)
@OverrideAutoConfiguration(enabled = false)
class AutoConfigureTestDatabaseServiceConnectionIntegrationTests {
	@Container
	@ServiceConnection
	static PostgreSQLContainer<?> postgres = TestImage.container(PostgreSQLContainer.class);
	@Autowired
	private DataSource dataSource;
	@Test
	void dataSourceIsNotReplaced() {
		assertThat(this.dataSource).isInstanceOf(HikariDataSource.class).isNotInstanceOf(EmbeddedDatabase.class);
	}
	@Configuration
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@DataCassandraTest(includeFilters = @Filter(Service.class),
		properties = { 'spring.cassandra.schema-action=create-if-not-exists',
				'spring.cassandra.connection.connect-timeout=60s', 'spring.cassandra.connection.init-query-timeout=60s',
				'spring.cassandra.request.timeout=60s' })
@Testcontainers(disabledWithoutDocker = true)
class DataCassandraTestWithIncludeFilterIntegrationTests {
	@Container
	@ServiceConnection
	static final CassandraContainer cassandra = TestImage.container(CassandraContainer.class);
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ExampleService service;
	@Test
	void testService() {
		ExampleEntity exampleEntity = new ExampleEntity();
		exampleEntity.setDescription('Look, new @DataCassandraTest!');
		String id = UUID.randomUUID().toString();
		exampleEntity.setId(id);
		this.exampleRepository.save(exampleEntity);
		assertThat(this.service.hasRecord(exampleEntity)).isTrue();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class KeyspaceTestConfiguration {
		@Bean
		CqlSession cqlSession(CqlSessionBuilder cqlSessionBuilder) {
			try (CqlSession session = cqlSessionBuilder.build()) {
				session.execute('CREATE KEYSPACE IF NOT EXISTS boot_test'
						+ ' WITH REPLICATION = { "class" : "SimpleStrategy", "replication_factor" : 1 };');
			}
			return cqlSessionBuilder.withKeyspace('boot_test').build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@DataCassandraTest(properties = { 'spring.cassandra.schema-action=create-if-not-exists',
		'spring.cassandra.connection.connect-timeout=60s', 'spring.cassandra.connection.init-query-timeout=60s',
		'spring.cassandra.request.timeout=60s' })
@Testcontainers(disabledWithoutDocker = true)
class DataCassandraTestIntegrationTests {
	@Container
	@ServiceConnection
	static final CassandraContainer cassandra = TestImage.container(CassandraContainer.class);
	@Autowired
	private CassandraTemplate cassandraTemplate;
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
	@Test
	void testRepository() {
		ExampleEntity entity = new ExampleEntity();
		entity.setDescription('Look, new @DataCassandraTest!');
		String id = UUID.randomUUID().toString();
		entity.setId(id);
		ExampleEntity savedEntity = this.exampleRepository.save(entity);
		ExampleEntity getEntity = this.cassandraTemplate.selectOneById(id, ExampleEntity.class);
		assertThat(getEntity).isNotNull();
		assertThat(getEntity.getId()).isNotNull();
		assertThat(getEntity.getId()).isEqualTo(savedEntity.getId());
		this.exampleRepository.deleteAll();
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class KeyspaceTestConfiguration {
		@Bean
		CqlSession cqlSession(CqlSessionBuilder cqlSessionBuilder) {
			try (CqlSession session = cqlSessionBuilder.build()) {
				session.execute('CREATE KEYSPACE IF NOT EXISTS boot_test'
						+ ' WITH REPLICATION = { "class" : "SimpleStrategy", "replication_factor" : 1 };');
			}
			return cqlSessionBuilder.withKeyspace('boot_test').build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@Table
public class ExampleEntity {
	@PrimaryKey
	private String id;
	private String description;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@Service
public class ExampleService {
	private final CassandraTemplate cassandraTemplate;
	public ExampleService(CassandraTemplate cassandraTemplate) {
		this.cassandraTemplate = cassandraTemplate;
	}
	public boolean hasRecord(ExampleEntity entity) {
		return this.cassandraTemplate.exists(entity.getId(), ExampleEntity.class);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
interface ExampleRepository extends CassandraRepository<ExampleEntity, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@SpringBootApplication
public class ExampleCassandraApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
interface ExampleReactiveRepository extends ReactiveCouchbaseRepository<ExampleDocument, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@DataCouchbaseTest(properties = { 'spring.data.couchbase.bucket-name=cbbucket',
		'spring.couchbase.env.timeouts.connect=2m', 'spring.couchbase.env.timeouts.key-value=1m' })
@Testcontainers(disabledWithoutDocker = true)
class DataCouchbaseTestReactiveIntegrationTests {
	private static final String BUCKET_NAME = 'cbbucket';
	@Container
	@ServiceConnection
	static final CouchbaseContainer couchbase = TestImage.container(CouchbaseContainer.class)
		.withEnabledServices(CouchbaseService.KV, CouchbaseService.INDEX, CouchbaseService.QUERY)
		.withBucket(new BucketDefinition(BUCKET_NAME));
	@Autowired
	private ReactiveCouchbaseTemplate couchbaseTemplate;
	@Autowired
	private ExampleReactiveRepository exampleReactiveRepository;
	@Test
	void testRepository() {
		ExampleDocument document = new ExampleDocument();
		document.setText('Look, new @DataCouchbaseTest!');
		document = this.exampleReactiveRepository.save(document).block(Duration.ofSeconds(30));
		assertThat(document.getId()).isNotNull();
		assertThat(this.couchbaseTemplate.getBucketName()).isEqualTo(BUCKET_NAME);
		this.exampleReactiveRepository.deleteAll();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@Document
public class ExampleDocument {
	@Id
	@GeneratedValue(strategy = GenerationStrategy.UNIQUE)
	private String id;
	private String text;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getText() {
		return this.text;
	}
	public void setText(String text) {
		this.text = text;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@SpringBootApplication
public class ExampleCouchbaseApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@DataCouchbaseTest(includeFilters = @Filter(Service.class),
		properties = { 'spring.data.couchbase.bucket-name=cbbucket', 'spring.couchbase.env.timeouts.connect=2m',
				'spring.couchbase.env.timeouts.key-value=1m' })
@Testcontainers(disabledWithoutDocker = true)
class DataCouchbaseTestWithIncludeFilterIntegrationTests {
	@Container
	@ServiceConnection
	static final CouchbaseContainer couchbase = TestImage.container(CouchbaseContainer.class)
		.withEnabledServices(CouchbaseService.KV, CouchbaseService.INDEX, CouchbaseService.QUERY)
		.withBucket(new BucketDefinition('cbbucket'));
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ExampleService service;
	@Test
	void testService() {
		ExampleDocument document = new ExampleDocument();
		document.setText('Look, new @DataCouchbaseTest!');
		document = this.exampleRepository.save(document);
		assertThat(this.service.findById(document.getId())).isNotNull();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@Service
public class ExampleService {
	private final CouchbaseTemplate couchbaseTemplate;
	public ExampleService(CouchbaseTemplate couchbaseTemplate) {
		this.couchbaseTemplate = couchbaseTemplate;
	}
	public ExampleDocument findById(String id) {
		return this.couchbaseTemplate.findById(ExampleDocument.class).one(id);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@DataCouchbaseTest(properties = { 'spring.couchbase.env.timeouts.connect=2m',
		'spring.couchbase.env.timeouts.key-value=1m', 'spring.data.couchbase.bucket-name=cbbucket' })
@Testcontainers(disabledWithoutDocker = true)
class DataCouchbaseTestIntegrationTests {
	private static final String BUCKET_NAME = 'cbbucket';
	@Container
	@ServiceConnection
	static final CouchbaseContainer couchbase = TestImage.container(CouchbaseContainer.class)
		.withEnabledServices(CouchbaseService.KV, CouchbaseService.INDEX, CouchbaseService.QUERY)
		.withBucket(new BucketDefinition(BUCKET_NAME));
	@Autowired
	private CouchbaseTemplate couchbaseTemplate;
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
	@Test
	void testRepository() {
		ExampleDocument document = new ExampleDocument();
		document.setText('Look, new @DataCouchbaseTest!');
		document = this.exampleRepository.save(document);
		assertThat(document.getId()).isNotNull();
		assertThat(this.couchbaseTemplate.getBucketName()).isEqualTo(BUCKET_NAME);
		this.exampleRepository.deleteAll();
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
interface ExampleRepository extends CouchbaseRepository<ExampleDocument, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
interface ExampleReactiveRepository extends ReactiveNeo4jRepository<ExampleGraph, Long> {
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataNeo4jTest(includeFilters = @Filter(Service.class))
class DataNeo4jTestWithIncludeFilterIntegrationTests {
	@Container
	@ServiceConnection
	static final Neo4jContainer<?> neo4j = TestImage.container(Neo4jContainer.class).withoutAuthentication();
	@Autowired
	private ExampleService service;
	@Test
	void testService() {
		assertThat(this.service.hasNode(ExampleGraph.class)).isFalse();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@DataNeo4jTest
@Testcontainers(disabledWithoutDocker = true)
class DataNeo4jTestIntegrationTests {
	@Container
	@ServiceConnection
	static final Neo4jContainer<?> neo4j = TestImage.container(Neo4jContainer.class);
	@Autowired
	private Neo4jTemplate neo4jTemplate;
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testRepository() {
		ExampleGraph exampleGraph = new ExampleGraph('Look, new @DataNeo4jTest!');
		assertThat(exampleGraph.getId()).isNull();
		ExampleGraph savedGraph = this.exampleRepository.save(exampleGraph);
		assertThat(savedGraph.getId()).isNotNull();
		assertThat(this.neo4jTemplate.count(ExampleGraph.class)).isOne();
	}
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@DataNeo4jTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
@Testcontainers(disabledWithoutDocker = true)
class DataNeo4jTestReactiveIntegrationTests {
	@Container
	@ServiceConnection
	static final Neo4jContainer<?> neo4j = TestImage.container(Neo4jContainer.class).withoutAuthentication();
	@Autowired
	private ReactiveNeo4jTemplate neo4jTemplate;
	@Autowired
	private ExampleReactiveRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testRepository() {
		Mono.just(new ExampleGraph('Look, new @DataNeo4jTest with reactive!'))
			.flatMap(this.exampleRepository::save)
			.as(StepVerifier::create)
			.expectNextCount(1)
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		StepVerifier.create(this.neo4jTemplate.count(ExampleGraph.class))
			.expectNext(1L)
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class ReactiveTransactionManagerConfiguration {
		@Bean
		ReactiveNeo4jTransactionManager reactiveTransactionManager(Driver driver,
				ReactiveDatabaseSelectionProvider databaseNameProvider) {
			return new ReactiveNeo4jTransactionManager(driver, databaseNameProvider);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@SpringBootApplication
public class ExampleNeo4jApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataNeo4jTest(properties = 'spring.profiles.active=test')
class DataNeo4jTestPropertiesIntegrationTests {
	@Container
	@ServiceConnection
	static final Neo4jContainer<?> neo4j = TestImage.container(Neo4jContainer.class).withoutAuthentication();
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataNeo4jTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@Node
public class ExampleGraph {
	@Id
	@GeneratedValue
	private Long id;
	@Property
	private String description;
	public ExampleGraph(String description) {
		this.description = description;
	}
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@Service
public class ExampleService {
	private final Neo4jTemplate neo4jTemplate;
	public ExampleService(Neo4jTemplate neo4jTemplate) {
		this.neo4jTemplate = neo4jTemplate;
	}
	public boolean hasNode(Class<?> type) {
		return this.neo4jTemplate.count(type) == 1;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
interface ExampleRepository extends Neo4jRepository<ExampleGraph, Long> {
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@DataElasticsearchTest
@Testcontainers(disabledWithoutDocker = true)
class DataElasticsearchTestReactiveIntegrationTests {
	@Container
	@ServiceConnection
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	@Autowired
	private ReactiveElasticsearchTemplate elasticsearchTemplate;
	@Autowired
	private ExampleReactiveRepository exampleReactiveRepository;
	@Test
	void testRepository() {
		ExampleDocument exampleDocument = new ExampleDocument();
		exampleDocument.setText('Look, new @DataElasticsearchTest!');
		exampleDocument = this.exampleReactiveRepository.save(exampleDocument).block(Duration.ofSeconds(30));
		assertThat(exampleDocument.getId()).isNotNull();
		assertThat(this.elasticsearchTemplate.exists(exampleDocument.getId(), ExampleDocument.class)
			.block(Duration.ofSeconds(30))).isTrue();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
interface ExampleReactiveRepository extends ReactiveElasticsearchRepository<ExampleDocument, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@DataElasticsearchTest(includeFilters = @Filter(Service.class))
@Testcontainers(disabledWithoutDocker = true)
class DataElasticsearchTestWithIncludeFilterIntegrationTests {
	@Container
	@ServiceConnection
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ExampleService service;
	@Test
	void testService() {
		ExampleDocument document = new ExampleDocument();
		document.setText('Look, new @DataElasticsearchTest!');
		String id = UUID.randomUUID().toString();
		document.setId(id);
		ExampleDocument savedDocument = this.exampleRepository.save(document);
		assertThat(this.service.findById(savedDocument.getId())).isNotNull();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@Document(indexName = 'examples')
public class ExampleDocument {
	@Id
	private String id;
	private String text;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getText() {
		return this.text;
	}
	public void setText(String text) {
		this.text = text;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@DataElasticsearchTest(properties = 'spring.profiles.active=test')
@Testcontainers(disabledWithoutDocker = true)
class DataElasticsearchTestPropertiesIntegrationTests {
	@Container
	@ServiceConnection
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataElasticsearchTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@Service
public class ExampleService {
	private final ElasticsearchTemplate elasticsearchTemplate;
	public ExampleService(ElasticsearchTemplate elasticsearchRestTemplate) {
		this.elasticsearchTemplate = elasticsearchRestTemplate;
	}
	public ExampleDocument findById(String id) {
		return this.elasticsearchTemplate.get(id, ExampleDocument.class);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@SpringBootApplication
public class ExampleElasticsearchApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
interface ExampleRepository extends ElasticsearchRepository<ExampleDocument, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@DataElasticsearchTest
@Testcontainers(disabledWithoutDocker = true)
class DataElasticsearchTestIntegrationTests {
	@Container
	@ServiceConnection
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	@Autowired
	private ElasticsearchTemplate elasticsearchTemplate;
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
	@Test
	void testRepository() {
		ExampleDocument document = new ExampleDocument();
		document.setText('Look, new @DataElasticsearchTest!');
		String id = UUID.randomUUID().toString();
		document.setId(id);
		ExampleDocument savedDocument = this.exampleRepository.save(document);
		ExampleDocument getDocument = this.elasticsearchTemplate.get(id, ExampleDocument.class);
		assertThat(getDocument).isNotNull();
		assertThat(getDocument.getId()).isNotNull();
		assertThat(getDocument.getId()).isEqualTo(savedDocument.getId());
		this.exampleRepository.deleteAll();
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataRedisTest(properties = 'spring.profiles.active=test')
class DataRedisTestPropertiesIntegrationTests {
	@Container
	@ServiceConnection
	static final RedisContainer redis = TestImage.container(RedisContainer.class);
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataRedisTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataRedisTest
class DataRedisTestReactiveIntegrationTests {
	@Container
	@ServiceConnection
	static RedisContainer redis = TestImage.container(RedisContainer.class);
	@Autowired
	private ReactiveRedisOperations<Object, Object> operations;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testRepository() {
		String id = UUID.randomUUID().toString();
		StepVerifier.create(this.operations.opsForValue().set(id, 'Hello World'))
			.expectNext(Boolean.TRUE)
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		StepVerifier.create(this.operations.opsForValue().get(id))
			.expectNext('Hello World')
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		StepVerifier.create(this.operations.execute((action) -> action.serverCommands().flushDb()))
			.expectNext('OK')
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@SpringBootApplication
public class ExampleRedisApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataRedisTest(includeFilters = @Filter(Service.class))
class DataRedisTestWithIncludeFilterIntegrationTests {
	@Container
	@ServiceConnection
	static final RedisContainer redis = TestImage.container(RedisContainer.class);
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ExampleService service;
	@Test
	void testService() {
		PersonHash personHash = new PersonHash();
		personHash.setDescription('Look, new @DataRedisTest!');
		assertThat(personHash.getId()).isNull();
		PersonHash savedEntity = this.exampleRepository.save(personHash);
		assertThat(this.service.hasRecord(savedEntity)).isTrue();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@RedisHash('persons')
public class PersonHash {
	@Id
	private String id;
	private String description;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@Service
public class ExampleService {
	private static final Charset CHARSET = StandardCharsets.UTF_8;
	private final RedisOperations<Object, Object> operations;
	public ExampleService(RedisOperations<Object, Object> operations) {
		this.operations = operations;
	}
	public boolean hasRecord(PersonHash personHash) {
		return this.operations.execute((RedisConnection connection) -> connection.keyCommands()
			.exists(('persons:' + personHash.getId()).getBytes(CHARSET)));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
interface ExampleRepository extends CrudRepository<PersonHash, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataRedisTest
class DataRedisTestIntegrationTests {
	private static final Charset CHARSET = StandardCharsets.UTF_8;
	@Container
	@ServiceConnection
	static RedisContainer redis = TestImage.container(RedisContainer.class);
	@Autowired
	private RedisOperations<Object, Object> operations;
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testRepository() {
		PersonHash personHash = new PersonHash();
		personHash.setDescription('Look, new @DataRedisTest!');
		assertThat(personHash.getId()).isNull();
		PersonHash savedEntity = this.exampleRepository.save(personHash);
		assertThat(savedEntity.getId()).isNotNull();
		assertThat(this.operations
			.execute((org.springframework.data.redis.connection.RedisConnection connection) -> connection.keyCommands()
				.exists(('persons:' + savedEntity.getId()).getBytes(CHARSET))))
			.isTrue();
		this.exampleRepository.deleteAll();
	}
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@DataLdapTest
@Testcontainers(disabledWithoutDocker = true)
class DataLdapTestDockerTests {
	@Container
	@ServiceConnection
	static final OpenLdapContainer openLdap = TestImage.container(OpenLdapContainer.class).withEnv('LDAP_TLS', 'false');
	@Autowired
	private ApplicationContext applicationContext;
	@Autowired
	private LdapTemplate ldapTemplate;
	@Test
	void connectionCanBeMadeToLdapContainer() {
		List<String> cn = this.ldapTemplate.search(LdapQueryBuilder.query().where('objectclass').is('dcObject'),
				(AttributesMapper<String>) (attributes) -> attributes.get('dc').get().toString());
		assertThat(cn).singleElement().isEqualTo('example');
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
interface ExampleReactiveRepository extends ReactiveMongoRepository<ExampleDocument, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@DataMongoTest
@Transactional
@Testcontainers(disabledWithoutDocker = true)
class TransactionalDataMongoTestIntegrationTests {
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	@Autowired
	private ExampleRepository exampleRepository;
	@Test
	void testRepository() {
		ExampleDocument exampleDocument = new ExampleDocument();
		exampleDocument.setText('Look, new @DataMongoTest!');
		exampleDocument = this.exampleRepository.save(exampleDocument);
		assertThat(exampleDocument.getId()).isNotNull();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class TransactionManagerConfiguration {
		@Bean
		MongoTransactionManager mongoTransactionManager(MongoDatabaseFactory dbFactory) {
			return new MongoTransactionManager(dbFactory);
		}
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class MongoInitializationConfiguration {
		@Bean
		MongoInitializer mongoInitializer(MongoTemplate template) {
			return new MongoInitializer(template);
		}
		static class MongoInitializer implements InitializingBean {
			private final MongoTemplate template;
			MongoInitializer(MongoTemplate template) {
				this.template = template;
			}
			@Override
			public void afterPropertiesSet() throws Exception {
				this.template.createCollection('exampleDocuments');
			}
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@DataMongoTest
@Testcontainers(disabledWithoutDocker = true)
class DataMongoTestReactiveIntegrationTests {
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	@Autowired
	private ReactiveMongoTemplate mongoTemplate;
	@Autowired
	private ExampleReactiveRepository exampleRepository;
	@Test
	void testRepository() {
		ExampleDocument exampleDocument = new ExampleDocument();
		exampleDocument.setText('Look, new @DataMongoTest!');
		exampleDocument = this.exampleRepository.save(exampleDocument).block(Duration.ofSeconds(30));
		assertThat(exampleDocument.getId()).isNotNull();
		assertThat(this.mongoTemplate.collectionExists('exampleDocuments').block(Duration.ofSeconds(30))).isTrue();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@SpringBootApplication
public class ExampleMongoApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@DataMongoTest
@Testcontainers(disabledWithoutDocker = true)
class DataMongoTestIntegrationTests {
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	@Autowired
	private MongoTemplate mongoTemplate;
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testRepository() {
		ExampleDocument exampleDocument = new ExampleDocument();
		exampleDocument.setText('Look, new @DataMongoTest!');
		exampleDocument = this.exampleRepository.save(exampleDocument);
		assertThat(exampleDocument.getId()).isNotNull();
		assertThat(this.mongoTemplate.collectionExists('exampleDocuments')).isTrue();
	}
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@Document(collection = 'exampleDocuments')
public class ExampleDocument {
	private String id;
	private String text;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getText() {
		return this.text;
	}
	public void setText(String text) {
		this.text = text;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@DataMongoTest(includeFilters = @Filter(Service.class))
@Testcontainers(disabledWithoutDocker = true)
class DataMongoTestWithIncludeFilterIntegrationTests {
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	@Autowired
	private ExampleService service;
	@Test
	void testService() {
		assertThat(this.service.hasCollection('foobar')).isFalse();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@Service
public class ExampleService {
	private final MongoTemplate mongoTemplate;
	public ExampleService(MongoTemplate mongoTemplate) {
		this.mongoTemplate = mongoTemplate;
	}
	public boolean hasCollection(String collectionName) {
		return this.mongoTemplate.collectionExists(collectionName);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
interface ExampleRepository extends MongoRepository<ExampleDocument, String> {
}
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
class TypeExcludeFiltersContextCustomizerFactoryTests {
	private final TypeExcludeFiltersContextCustomizerFactory factory = new TypeExcludeFiltersContextCustomizerFactory();
	private final MergedContextConfiguration mergedContextConfiguration = mock(MergedContextConfiguration.class);
	private final ConfigurableApplicationContext context = new AnnotationConfigApplicationContext();
	@Test
	void getContextCustomizerWhenHasNoAnnotationShouldReturnNull() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(NoAnnotation.class, null);
		assertThat(customizer).isNull();
	}
	@Test
	void getContextCustomizerWhenHasAnnotationShouldReturnCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(WithExcludeFilters.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void getContextCustomizerWhenEnclosingClassHasAnnotationShouldReturnCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(WithEnclosingClassExcludeFilters.class,
				null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void hashCodeAndEquals() {
		ContextCustomizer customizer1 = this.factory.createContextCustomizer(WithExcludeFilters.class, null);
		ContextCustomizer customizer2 = this.factory.createContextCustomizer(WithSameExcludeFilters.class, null);
		ContextCustomizer customizer3 = this.factory.createContextCustomizer(WithDifferentExcludeFilters.class, null);
		assertThat(customizer1).hasSameHashCodeAs(customizer2);
		assertThat(customizer1).isEqualTo(customizer1).isEqualTo(customizer2).isNotEqualTo(customizer3);
	}
	@Test
	void getContextCustomizerShouldAddExcludeFilters() throws Exception {
		ContextCustomizer customizer = this.factory.createContextCustomizer(WithExcludeFilters.class, null);
		customizer.customizeContext(this.context, this.mergedContextConfiguration);
		this.context.refresh();
		TypeExcludeFilter filter = this.context.getBean(TypeExcludeFilter.class);
		MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
		MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NoAnnotation.class.getName());
		assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();
		metadataReader = metadataReaderFactory.getMetadataReader(SimpleExclude.class.getName());
		assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();
		metadataReader = metadataReaderFactory.getMetadataReader(TestClassAwareExclude.class.getName());
		assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();
	}
	static class NoAnnotation {
	}
	@TypeExcludeFilters({ SimpleExclude.class, TestClassAwareExclude.class })
	static class WithExcludeFilters {
	}
	@TypeExcludeFilters({ SimpleExclude.class, TestClassAwareExclude.class })
	static class EnclosingClass {
		class WithEnclosingClassExcludeFilters {
		}
	}
	@TypeExcludeFilters({ TestClassAwareExclude.class, SimpleExclude.class })
	static class WithSameExcludeFilters {
	}
	@TypeExcludeFilters(SimpleExclude.class)
	static class WithDifferentExcludeFilters {
	}
	static class SimpleExclude extends TypeExcludeFilter {
		@Override
		public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) {
			return metadataReader.getClassMetadata().getClassName().equals(getClass().getName());
		}
		@Override
		public boolean equals(Object obj) {
			return obj.getClass() == getClass();
		}
		@Override
		public int hashCode() {
			return SimpleExclude.class.hashCode();
		}
	}
	static class TestClassAwareExclude extends SimpleExclude {
		TestClassAwareExclude(Class<?> testClass) {
			assertThat(testClass).isNotNull();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
class FilterAnnotationsTests {
	@Test
	void filterAnnotation() throws Exception {
		FilterAnnotations filterAnnotations = get(FilterByAnnotation.class);
		assertThat(match(filterAnnotations, ExampleWithAnnotation.class)).isTrue();
		assertThat(match(filterAnnotations, ExampleWithoutAnnotation.class)).isFalse();
	}
	@Test
	void filterAssignableType() throws Exception {
		FilterAnnotations filterAnnotations = get(FilterByType.class);
		assertThat(match(filterAnnotations, ExampleWithAnnotation.class)).isFalse();
		assertThat(match(filterAnnotations, ExampleWithoutAnnotation.class)).isTrue();
	}
	@Test
	void filterCustom() throws Exception {
		FilterAnnotations filterAnnotations = get(FilterByCustom.class);
		assertThat(match(filterAnnotations, ExampleWithAnnotation.class)).isFalse();
		assertThat(match(filterAnnotations, ExampleWithoutAnnotation.class)).isTrue();
	}
	@Test
	void filterAspectJ() throws Exception {
		FilterAnnotations filterAnnotations = get(FilterByAspectJ.class);
		assertThat(match(filterAnnotations, ExampleWithAnnotation.class)).isFalse();
		assertThat(match(filterAnnotations, ExampleWithoutAnnotation.class)).isTrue();
	}
	@Test
	void filterRegex() throws Exception {
		FilterAnnotations filterAnnotations = get(FilterByRegex.class);
		assertThat(match(filterAnnotations, ExampleWithAnnotation.class)).isFalse();
		assertThat(match(filterAnnotations, ExampleWithoutAnnotation.class)).isTrue();
	}
	private FilterAnnotations get(Class<?> type) {
		Filters filters = AnnotatedElementUtils.getMergedAnnotation(type, Filters.class);
		return new FilterAnnotations(getClass().getClassLoader(), filters.value());
	}
	private boolean match(FilterAnnotations filterAnnotations, Class<?> type) throws IOException {
		MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
		MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(type.getName());
		return filterAnnotations.anyMatches(metadataReader, metadataReaderFactory);
	}
	@Filters(@Filter(Service.class))
	static class FilterByAnnotation {
	}
	@Filters(@Filter(type = FilterType.ASSIGNABLE_TYPE, classes = ExampleWithoutAnnotation.class))
	static class FilterByType {
	}
	@Filters(@Filter(type = FilterType.CUSTOM, classes = ExampleCustomFilter.class))
	static class FilterByCustom {
	}
	@Filters(@Filter(type = FilterType.ASPECTJ, pattern = '(*..*ExampleWithoutAnnotation)'))
	static class FilterByAspectJ {
	}
	@Filters(@Filter(type = FilterType.REGEX, pattern = '.*ExampleWithoutAnnotation'))
	static class FilterByRegex {
	}
	@Target({ ElementType.TYPE })
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@interface Filters {
		Filter[] value();
	}
	static class ExampleCustomFilter implements TypeFilter {
		@Override
		public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) {
			return metadataReader.getClassMetadata().getClassName().equals(ExampleWithoutAnnotation.class.getName());
		}
	}
	@Service
	static class ExampleWithAnnotation {
	}
	static class ExampleWithoutAnnotation {
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@WebServiceServerTest(endpoints = ExampleWebServiceEndpoint.class)
class WebServiceServerIntegrationTests {
	@Autowired
	private MockWebServiceClient mock;
	@Test
	void payloadRootMethod() {
		this.mock
			.sendRequest(RequestCreators.withPayload(new StringSource('<request><message>Hello</message></request>')))
			.andExpect(ResponseMatchers.payload(new StringSource('<response><code>42</code></response>')));
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
class WebServiceServerTypeExcludeFilterTests {
	private final MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
	@Test
	void matchWhenHasNoEndpoints() throws IOException {
		WebServiceServerTypeExcludeFilter filter = new WebServiceServerTypeExcludeFilter(WithNoEndpoints.class);
		assertThat(exclude(filter, WebService1.class)).isFalse();
		assertThat(exclude(filter, WebService2.class)).isFalse();
		assertThat(exclude(filter, ExampleService.class)).isTrue();
		assertThat(exclude(filter, ExampleRepository.class)).isTrue();
	}
	@Test
	void matchWhenHasEndpoint() throws IOException {
		WebServiceServerTypeExcludeFilter filter = new WebServiceServerTypeExcludeFilter(WithEndpoint.class);
		assertThat(exclude(filter, WebService1.class)).isFalse();
		assertThat(exclude(filter, WebService2.class)).isTrue();
		assertThat(exclude(filter, ExampleService.class)).isTrue();
		assertThat(exclude(filter, ExampleRepository.class)).isTrue();
	}
	@Test
	void matchNotUsingDefaultFilters() throws IOException {
		WebServiceServerTypeExcludeFilter filter = new WebServiceServerTypeExcludeFilter(NotUsingDefaultFilters.class);
		assertThat(exclude(filter, WebService1.class)).isTrue();
		assertThat(exclude(filter, WebService2.class)).isTrue();
		assertThat(exclude(filter, ExampleService.class)).isTrue();
		assertThat(exclude(filter, ExampleRepository.class)).isTrue();
	}
	@Test
	void matchWithIncludeFilter() throws IOException {
		WebServiceServerTypeExcludeFilter filter = new WebServiceServerTypeExcludeFilter(WithIncludeFilter.class);
		assertThat(exclude(filter, WebService1.class)).isFalse();
		assertThat(exclude(filter, WebService2.class)).isFalse();
		assertThat(exclude(filter, ExampleService.class)).isTrue();
		assertThat(exclude(filter, ExampleRepository.class)).isFalse();
	}
	@Test
	void matchWithExcludeFilter() throws IOException {
		WebServiceServerTypeExcludeFilter filter = new WebServiceServerTypeExcludeFilter(WithExcludeFilter.class);
		assertThat(exclude(filter, WebService1.class)).isTrue();
		assertThat(exclude(filter, WebService2.class)).isFalse();
		assertThat(exclude(filter, ExampleService.class)).isTrue();
		assertThat(exclude(filter, ExampleRepository.class)).isTrue();
	}
	private boolean exclude(WebServiceServerTypeExcludeFilter filter, Class<?> type) throws IOException {
		MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(type.getName());
		return filter.match(metadataReader, this.metadataReaderFactory);
	}
	@WebServiceServerTest
	static class WithNoEndpoints {
	}
	@WebServiceServerTest(WebService1.class)
	static class WithEndpoint {
	}
	@WebServiceServerTest(useDefaultFilters = false)
	static class NotUsingDefaultFilters {
	}
	@WebServiceServerTest(includeFilters = @Filter(Repository.class))
	static class WithIncludeFilter {
	}
	@WebServiceServerTest(excludeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = WebService1.class))
	static class WithExcludeFilter {
	}
	@Endpoint
	static class WebService1 {
	}
	@Endpoint
	static class WebService2 {
	}
	@Service
	static class ExampleService {
	}
	@Repository
	static class ExampleRepository {
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@WebServiceServerTest(properties = 'spring.profiles.active=test')
class WebServiceServerPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(WebServiceServerPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@SpringBootApplication
public class ExampleWebServiceServerApplication {
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@Endpoint
public class ExampleWebServiceEndpoint {
	@PayloadRoot(localPart = 'request')
	@ResponsePayload
	Response payloadMethod(@RequestPayload Request request) {
		return new Response(42);
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@XmlRootElement(name = 'request')
class Request {
	@XmlElement(required = true)
	private String message;
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
class MockWebServiceClientAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MockWebServiceClientAutoConfiguration.class));
	@Test
	void shouldRegisterMockWebServiceClient() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MockWebServiceClient.class));
	}
	@Test
	void shouldNotRegisterMockWebServiceClientWhenItIsNotOnTheClasspath() {
		FilteredClassLoader classLoader = new FilteredClassLoader(MockWebServiceClient.class);
		this.contextRunner.withClassLoader(classLoader)
			.run((context) -> assertThat(context).doesNotHaveBean(MockWebServiceClient.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@XmlRootElement(name = 'response')
class Response {
	@XmlElement(required = true)
	private int code;
	Response(int code) {
		this.code = code;
	}
	Response() {
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@WebServiceClientTest
class WebServiceClientNoComponentIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Autowired
	private WebServiceTemplateBuilder webServiceTemplateBuilder;
	@Autowired
	private MockWebServiceServer server;
	@Test
	void exampleClientIsNotInjected() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleWebServiceClient.class));
	}
	@Test
	void manuallyCreateBean() {
		ExampleWebServiceClient client = new ExampleWebServiceClient(this.webServiceTemplateBuilder);
		this.server.expect(payload(new StringSource('<request/>')))
			.andRespond(withPayload(new StringSource('<response><status>200</status></response>')));
		assertThat(client.test()).extracting(Response::getStatus).isEqualTo(200);
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@SpringBootTest
@AutoConfigureWebServiceClient(registerWebServiceTemplate = true)
@AutoConfigureMockWebServiceServer
class AutoConfigureWebServiceClientWebServiceTemplateIntegrationTests {
	@Autowired
	private WebServiceTemplate webServiceTemplate;
	@Autowired
	private MockWebServiceServer server;
	@Test
	void webServiceTemplateTest() {
		this.server.expect(payload(new StringSource('<request/>')))
			.andRespond(withPayload(new StringSource('<response/>')));
		this.webServiceTemplate.marshalSendAndReceive('https://example.com', new Request());
	}
	@Configuration(proxyBeanMethods = false)
	@Import(WebServiceMarshallerConfiguration.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@Configuration(proxyBeanMethods = false)
class WebServiceMarshallerConfiguration {
	@Bean
	WebServiceTemplateCustomizer marshallerCustomizer(Marshaller marshaller) {
		return (webServiceTemplate) -> webServiceTemplate.setMarshaller(marshaller);
	}
	@Bean
	WebServiceTemplateCustomizer unmarshallerCustomizer(Unmarshaller unmarshaller) {
		return (webServiceTemplate) -> webServiceTemplate.setUnmarshaller(unmarshaller);
	}
	@Bean
	Jaxb2Marshaller createJaxbMarshaller() {
		Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();
		jaxb2Marshaller.setClassesToBeBound(Request.class, Response.class);
		return jaxb2Marshaller;
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@Service
public class ExampleWebServiceClient {
	private final WebServiceTemplate webServiceTemplate;
	public ExampleWebServiceClient(WebServiceTemplateBuilder builder) {
		this.webServiceTemplate = builder.build();
	}
	public Response test() {
		return (Response) this.webServiceTemplate.marshalSendAndReceive('https://example.com', new Request());
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@XmlRootElement(name = 'request')
class Request {
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@WebServiceClientTest
@AutoConfigureMockWebServiceServer(enabled = false)
class AutoConfigureMockWebServiceServerEnabledIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void mockWebServiceServerShouldNotBeRegistered() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(MockWebServiceServer.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@WebServiceClientTest(properties = 'spring.profiles.active=test')
class WebServiceClientPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(WebServiceClientPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@XmlRootElement(name = 'response')
@XmlAccessorType(XmlAccessType.FIELD)
class Response {
	private int status;
	int getStatus() {
		return this.status;
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@WebServiceClientTest(ExampleWebServiceClient.class)
class WebServiceClientIntegrationTests {
	@Autowired
	private MockWebServiceServer server;
	@Autowired
	private ExampleWebServiceClient client;
	@Test
	void mockServerCall() {
		this.server.expect(payload(new StringSource('<request/>')))
			.andRespond(withPayload(new StringSource('<response><status>200</status></response>')));
		assertThat(this.client.test()).extracting(Response::getStatus).isEqualTo(200);
	}
	@Test
	void mockServerCall1() {
		this.server.expect(connectionTo('https://example1')).andRespond(withPayload(new StringSource('<response/>')));
		assertThatExceptionOfType(SourceAssertionError.class).isThrownBy(this.client::test)
			.withMessageContaining('Unexpected connection expected');
	}
	@Test
	void mockServerCall2() {
		this.server.expect(payload(new StringSource('<request/>'))).andRespond(withError('Invalid Request'));
		assertThatExceptionOfType(WebServiceTransportException.class).isThrownBy(this.client::test)
			.withMessageContaining('Invalid Request');
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@SpringBootApplication
@Import(WebServiceMarshallerConfiguration.class)
public class ExampleWebServiceClientApplication {
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.HSQLDB)
@TestPropertySource(properties = 'spring.test.database.replace=ANY')
class JdbcTestWithAutoConfigureTestDatabaseReplacePropertyAnyIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void replacesDefinedDataSourceWithExplicit() throws Exception {
		// H2 is explicitly defined but HSQL is the override.
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('HSQL');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAutoConfiguration
	static class Config {
		@Bean
		DataSource dataSource() {
			return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.H2).build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class JdbcTestWithAutoConfigureTestDatabaseReplaceNoneIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void usesDefaultEmbeddedDatabase() throws Exception {
		// HSQL is explicitly defined and should not be replaced
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('HSQL');
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@TestPropertySource(
		properties = 'spring.sql.init.schemaLocations=classpath:org/springframework/boot/test/autoconfigure/jdbc/schema.sql')
class JdbcTestIntegrationTests {
	@Autowired
	private JdbcClient jdbcClient;
	@Autowired
	private JdbcTemplate jdbcTemplate;
	@Autowired
	private DataSource dataSource;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testJdbcClient() {
		ExampleJdbcClientRepository repository = new ExampleJdbcClientRepository(this.jdbcClient);
		repository.save(new ExampleEntity(1, 'John'));
		ExampleEntity entity = repository.findById(1);
		assertThat(entity.getId()).isOne();
		assertThat(entity.getName()).isEqualTo('John');
		Collection<ExampleEntity> entities = repository.findAll();
		assertThat(entities).hasSize(1);
		entity = entities.iterator().next();
		assertThat(entity.getId()).isOne();
		assertThat(entity.getName()).isEqualTo('John');
	}
	@Test
	void testJdbcTemplate() {
		ExampleRepository repository = new ExampleRepository(this.jdbcTemplate);
		repository.save(new ExampleEntity(1, 'John'));
		ExampleEntity entity = repository.findById(1);
		assertThat(entity.getId()).isOne();
		assertThat(entity.getName()).isEqualTo('John');
		Collection<ExampleEntity> entities = repository.findAll();
		assertThat(entities).hasSize(1);
		entity = entities.iterator().next();
		assertThat(entity.getId()).isOne();
		assertThat(entity.getName()).isEqualTo('John');
	}
	@Test
	void replacesDefinedDataSourceWithEmbeddedDefault() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).isEqualTo('H2');
	}
	@Test
	void didNotInjectExampleRepository() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleRepository.class));
	}
	@Test
	void flywayAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(FlywayAutoConfiguration.class));
	}
	@Test
	void liquibaseAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(LiquibaseAutoConfiguration.class));
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.HSQLDB)
@TestPropertySource(properties = 'spring.test.database.replace=AUTO_CONFIGURED')
class JdbcTestWithAutoConfigureTestDatabaseReplacePropertyAutoConfiguredIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void replacesAutoConfiguredDataSource() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('HSQL');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAutoConfiguration // Will auto-configure H2
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest(properties = 'spring.profiles.active=test')
class JdbcTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(JdbcTestPropertiesIntegrationTests.this.environment.getActiveProfiles()).containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
class TestDatabaseAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(TestDatabaseAutoConfiguration.class));
	@Test
	void replaceWithNoDataSourceAvailable() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(DataSource.class));
	}
	@Test
	void replaceWithUniqueDatabase() {
		this.contextRunner.withUserConfiguration(ExistingDataSourceConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(EmbeddedDataSourceFactoryBean.class);
			DataSource datasource = context.getBean(DataSource.class);
			JdbcTemplate jdbcTemplate = new JdbcTemplate(datasource);
			jdbcTemplate.execute('create table example (id int, name varchar);');
			this.contextRunner.withUserConfiguration(ExistingDataSourceConfiguration.class).run((secondContext) -> {
				DataSource anotherDatasource = secondContext.getBean(DataSource.class);
				JdbcTemplate anotherJdbcTemplate = new JdbcTemplate(anotherDatasource);
				anotherJdbcTemplate.execute('create table example (id int, name varchar);');
			});
		});
	}
	@Test
	void whenUsingAotGeneratedArtifactsEmbeddedDataSourceFactoryBeanIsNotDefined() {
		this.contextRunner.withUserConfiguration(ExistingDataSourceConfiguration.class)
			.withSystemProperties('spring.aot.enabled=true')
			.run((context) -> assertThat(context).doesNotHaveBean(EmbeddedDataSourceFactoryBean.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class ExistingDataSourceConfiguration {
		@Bean
		DataSource dataSource() {
			return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.HSQL).build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
public class ExampleEntity {
	private final int id;
	private String name;
	public ExampleEntity(int id, String name) {
		this.id = id;
		this.name = name;
	}
	public ExampleEntity(int id) {
		this(id, null);
	}
	public int getId() {
		return this.id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest(includeFilters = @Filter(Repository.class))
@TestPropertySource(
		properties = 'spring.sql.init.schemaLocations=classpath:org/springframework/boot/test/autoconfigure/jdbc/schema.sql')
class JdbcTestWithIncludeFilterIntegrationTests {
	@Autowired
	private ExampleRepository repository;
	@Test
	void testRepository() {
		this.repository.save(new ExampleEntity(42, 'Smith'));
		ExampleEntity entity = this.repository.findById(42);
		assertThat(entity).isNotNull();
		assertThat(entity.getName()).isEqualTo('Smith');
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@AutoConfigureTestDatabase
class AutoConfigureTestDatabaseWithMultipleDatasourcesIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void replacesDefinedDataSourceWithExplicit() throws Exception {
		// Look that the datasource is replaced with an H2 DB.
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('H2');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAutoConfiguration
	static class Config {
		@Bean
		@Primary
		DataSource dataSource() {
			return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.HSQL).build();
		}
		@Bean
		DataSource secondaryDataSource() {
			return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.HSQL).build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
class ExampleJdbcClientRepository {
	private static final ExampleEntityRowMapper ROW_MAPPER = new ExampleEntityRowMapper();
	private final JdbcClient jdbcClient;
	ExampleJdbcClientRepository(JdbcClient jdbcClient) {
		this.jdbcClient = jdbcClient;
	}
	void save(ExampleEntity entity) {
		this.jdbcClient.sql('insert into example (id, name) values (:id, :name)')
			.param('id', entity.getId())
			.param('name', entity.getName())
			.update();
	}
	ExampleEntity findById(int id) {
		return this.jdbcClient.sql('select id, name from example where id = :id')
			.param('id', id)
			.query(ROW_MAPPER)
			.single();
	}
	Collection<ExampleEntity> findAll() {
		return this.jdbcClient.sql('select id, name from example').query(ROW_MAPPER).list();
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.HSQLDB)
class JdbcTestWithAutoConfigureTestDatabaseReplaceExplicitIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void replacesDefinedDataSourceWithExplicit() throws Exception {
		// H2 is explicitly defined but HSQL is the override.
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('HSQL');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAutoConfiguration
	static class Config {
		@Bean
		DataSource dataSource() {
			return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.H2).build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
class ExampleEntityRowMapper implements RowMapper<ExampleEntity> {
	@Override
	public ExampleEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
		int id = rs.getInt('id');
		String name = rs.getString('name');
		return new ExampleEntity(id, name);
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@ExtendWith(SpringExtension.class)
@AutoConfigureTestDatabase
class AutoConfigureTestDatabaseWithNoDatabaseIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void testContextLoads() {
		// gh-6897
		assertThat(this.context).isNotNull();
		assertThat(this.context.getBeanNamesForType(DataSource.class)).isNotEmpty();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@SpringBootApplication
public class ExampleJdbcApplication {
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.HSQL).build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.AUTO_CONFIGURED,
		connection = EmbeddedDatabaseConnection.HSQLDB)
class JdbcTestWithAutoConfigureTestDatabaseReplaceAutoConfiguredIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void replacesAutoConfiguredDataSource() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('HSQL');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAutoConfiguration // Will auto-configure H2
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.AUTO_CONFIGURED)
class JdbcTestWithAutoConfigureTestDatabaseReplaceAutoConfiguredWithoutOverrideIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void usesDefaultEmbeddedDatabase() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		// @AutoConfigureTestDatabase would use H2 but HSQL is manually defined
		assertThat(product).startsWith('HSQL');
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@Repository
class ExampleRepository {
	private static final ExampleEntityRowMapper ROW_MAPPER = new ExampleEntityRowMapper();
	private final JdbcTemplate jdbcTemplate;
	ExampleRepository(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}
	@Transactional
	void save(ExampleEntity entity) {
		this.jdbcTemplate.update('insert into example (id, name) values (?, ?)', entity.getId(), entity.getName());
	}
	ExampleEntity findById(int id) {
		return this.jdbcTemplate.queryForObject('select id, name from example where id =?', ROW_MAPPER, id);
	}
	Collection<ExampleEntity> findAll() {
		return this.jdbcTemplate.query('select id, name from example', ROW_MAPPER);
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@JdbcTest
@TestPropertySource(properties = 'spring.test.database.replace=NONE')
class JdbcTestWithAutoConfigureTestDatabaseReplacePropertyNoneIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void usesDefaultEmbeddedDatabase() throws Exception {
		// HSQL is explicitly defined and should not be replaced
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('HSQL');
	}
}
/*
package org.springframework.boot.test.autoconfigure.cache;
/**
class ImportsContextCustomizerFactoryWithAutoConfigurationTests {
	static ApplicationContext contextFromTest;
	@Test
	void testClassesThatHaveSameAnnotationsShareAContext() {
		executeTests(DataJpaTest1.class);
		ApplicationContext test1Context = contextFromTest;
		executeTests(DataJpaTest3.class);
		ApplicationContext test2Context = contextFromTest;
		assertThat(test1Context).isSameAs(test2Context);
	}
	@Test
	void testClassesThatOnlyHaveDifferingUnrelatedAnnotationsShareAContext() {
		executeTests(DataJpaTest1.class);
		ApplicationContext test1Context = contextFromTest;
		executeTests(DataJpaTest2.class);
		ApplicationContext test2Context = contextFromTest;
		assertThat(test1Context).isSameAs(test2Context);
	}
	@Test
	void testClassesThatOnlyHaveDifferingPropertyMappedAnnotationAttributesDoNotShareAContext() {
		executeTests(DataJpaTest1.class);
		ApplicationContext test1Context = contextFromTest;
		executeTests(DataJpaTest4.class);
		ApplicationContext test2Context = contextFromTest;
		assertThat(test1Context).isNotSameAs(test2Context);
	}
	private void executeTests(Class<?> testClass) {
		LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
			.selectors(DiscoverySelectors.selectClass(testClass))
			.build();
		Launcher launcher = LauncherFactory.create();
		launcher.execute(request);
	}
	@DataJpaTest
	@ContextConfiguration(classes = EmptyConfig.class)
	@Unrelated1
	static class DataJpaTest1 {
		@Autowired
		private ApplicationContext context;
		@Test
		void test() {
			contextFromTest = this.context;
		}
	}
	@DataJpaTest
	@ContextConfiguration(classes = EmptyConfig.class)
	@Unrelated2
	static class DataJpaTest2 {
		@Autowired
		private ApplicationContext context;
		@Test
		void test() {
			contextFromTest = this.context;
		}
	}
	@DataJpaTest
	@ContextConfiguration(classes = EmptyConfig.class)
	@Unrelated1
	static class DataJpaTest3 {
		@Autowired
		private ApplicationContext context;
		@Test
		void test() {
			contextFromTest = this.context;
		}
	}
	@DataJpaTest(showSql = false)
	@ContextConfiguration(classes = EmptyConfig.class)
	@Unrelated1
	static class DataJpaTest4 {
		@Autowired
		private ApplicationContext context;
		@Test
		void test() {
			contextFromTest = this.context;
		}
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface Unrelated1 {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface Unrelated2 {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan(basePackageClasses = ExampleEntity.class)
	@AutoConfigurationPackage
	static class EmptyConfig {
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@ConfigurationProperties('example')
public class ExampleProperties {
	private final String name;
	public ExampleProperties(@DefaultValue('test') String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
class RestClientWithRestTemplateTests {
	@Test
	void buildUsingRestTemplateUriTemplateHandler() {
		RestTemplate restTemplate = new RestTemplate();
		DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory('https://resttemplate.example.com');
		restTemplate.setUriTemplateHandler(uriBuilderFactory);
		Builder builder = RestClient.builder(restTemplate);
		RestClient client = buildMockedClient(builder, 'https://resttemplate.example.com/test');
		assertThat(client.get().uri('/test').retrieve().toBodilessEntity().getStatusCode().is2xxSuccessful()).isTrue();
	}
	@Test
	void buildUsingRestClientBuilderBaseUrl() {
		RestTemplate restTemplate = new RestTemplate();
		Builder builder = RestClient.builder(restTemplate).baseUrl('https://restclient.example.com');
		RestClient client = buildMockedClient(builder, 'https://restclient.example.com/test');
		assertThat(client.get().uri('/test').retrieve().toBodilessEntity().getStatusCode().is2xxSuccessful()).isTrue();
	}
	@Test
	void buildUsingRestTemplateUriTemplateHandlerAndRestClientBuilderBaseUrl() {
		RestTemplate restTemplate = new RestTemplate();
		DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory('https://resttemplate.example.com');
		restTemplate.setUriTemplateHandler(uriBuilderFactory);
		Builder builder = RestClient.builder(restTemplate).baseUrl('https://restclient.example.com');
		RestClient client = buildMockedClient(builder, 'https://resttemplate.example.com/test');
		assertThat(client.get().uri('/test').retrieve().toBodilessEntity().getStatusCode().is2xxSuccessful()).isTrue();
	}
	private RestClient buildMockedClient(Builder builder, String url) {
		MockRestServiceServer server = MockRestServiceServer.bindTo(builder).build();
		server.expect(requestTo(url)).andRespond(withSuccess());
		return builder.build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@ClassPathExclusions('jackson-*.jar')
@RestClientTest(ExampleRestTemplateService.class)
class RestClientTestWithoutJacksonIntegrationTests {
	@Autowired
	private MockRestServiceServer server;
	@Autowired
	private ExampleRestTemplateService client;
	@Test
	void restClientTestCanBeUsedWhenJacksonIsNotOnTheClassPath() {
		ClassLoader classLoader = getClass().getClassLoader();
		assertThat(ClassUtils.isPresent('com.fasterxml.jackson.databind.Module', classLoader)).isFalse();
		this.server.expect(requestTo('/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		assertThat(this.client.test()).isEqualTo('hello');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest(ExampleRestTemplateService.class)
class RestClientTestRestTemplateIntegrationTests {
	@Autowired
	private MockRestServiceServer server;
	@Autowired
	private ExampleRestTemplateService client;
	@Test
	void mockServerCall1() {
		this.server.expect(requestTo('/test')).andRespond(withSuccess('1', MediaType.TEXT_HTML));
		assertThat(this.client.test()).isEqualTo('1');
	}
	@Test
	void mockServerCall2() {
		this.server.expect(requestTo('/test')).andRespond(withSuccess('2', MediaType.TEXT_HTML));
		assertThat(this.client.test()).isEqualTo('2');
	}
	@Test
	void mockServerCallWithContent() {
		this.server.expect(requestTo('/test'))
			.andExpect(content().string('test'))
			.andRespond(withSuccess('1', MediaType.TEXT_HTML));
		this.client.testPostWithBody('test');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest(ExampleRestClientService.class)
class RestClientTestRestClientIntegrationTests {
	@Autowired
	private MockRestServiceServer server;
	@Autowired
	private ExampleRestClientService client;
	@Test
	void mockServerCall1() {
		this.server.expect(requestTo(uri('/test'))).andRespond(withSuccess('1', MediaType.TEXT_HTML));
		assertThat(this.client.test()).isEqualTo('1');
	}
	@Test
	void mockServerCall2() {
		this.server.expect(requestTo(uri('/test'))).andRespond(withSuccess('2', MediaType.TEXT_HTML));
		assertThat(this.client.test()).isEqualTo('2');
	}
	@Test
	void mockServerCallWithContent() {
		this.server.expect(requestTo(uri('/test')))
			.andExpect(content().string('test'))
			.andRespond(withSuccess('1', MediaType.TEXT_HTML));
		this.client.testPostWithBody('test');
	}
	private static String uri(String path) {
		return 'https://example.com' + path;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest(ExampleRestClientService.class)
class RestClientTestWithRestClientComponentIntegrationTests {
	@Autowired
	private MockRestServiceServer server;
	@Autowired
	private ExampleRestClientService client;
	@Test
	void mockServerCall() {
		this.server.expect(requestTo('https://example.com/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		assertThat(this.client.test()).isEqualTo('hello');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@Service
public class AnotherExampleRestTemplateService {
	private final RestTemplate restTemplate;
	public AnotherExampleRestTemplateService(RestTemplateBuilder builder) {
		this.restTemplate = builder.rootUri('https://example.com').build();
	}
	protected RestTemplate getRestTemplate() {
		return this.restTemplate;
	}
	public String test() {
		return this.restTemplate.getForEntity('/test', String.class).getBody();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest({ ExampleRestTemplateService.class, AnotherExampleRestTemplateService.class })
class RestClientTestRestTemplateTwoComponentsIntegrationTests {
	@Autowired
	private ExampleRestTemplateService client1;
	@Autowired
	private AnotherExampleRestTemplateService client2;
	@Autowired
	private MockServerRestTemplateCustomizer customizer;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void serverShouldNotWork() {
		assertThatIllegalStateException()
			.isThrownBy(
					() -> this.server.expect(requestTo('/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML)))
			.withMessageContaining('Unable to use auto-configured');
	}
	@Test
	void client1RestCallViaCustomizer() {
		this.customizer.getServer(this.client1.getRestTemplate())
			.expect(requestTo('/test'))
			.andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		assertThat(this.client1.test()).isEqualTo('hello');
	}
	@Test
	void client2RestCallViaCustomizer() {
		this.customizer.getServer(this.client2.getRestTemplate())
			.expect(requestTo('/test'))
			.andRespond(withSuccess('there', MediaType.TEXT_HTML));
		assertThat(this.client2.test()).isEqualTo('there');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest({ ExampleRestTemplateService.class, ExampleRestClientService.class })
class RestClientTestRestTemplateAndRestClientTogetherIntegrationTests {
	@Autowired
	private ExampleRestTemplateService restTemplateClient;
	@Autowired
	private ExampleRestClientService restClientClient;
	@Autowired
	private MockServerRestTemplateCustomizer templateCustomizer;
	@Autowired
	private MockServerRestClientCustomizer clientCustomizer;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void serverShouldNotWork() {
		assertThatIllegalStateException().isThrownBy(
				() -> this.server.expect(requestTo(uri('/test'))).andRespond(withSuccess('hello', MediaType.TEXT_HTML)))
			.withMessageContaining('Unable to use auto-configured');
	}
	@Test
	void restTemplateClientRestCallViaCustomizer() {
		this.templateCustomizer.getServer()
			.expect(requestTo('/test'))
			.andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		assertThat(this.restTemplateClient.test()).isEqualTo('hello');
	}
	@Test
	void restClientClientRestCallViaCustomizer() {
		this.clientCustomizer.getServer()
			.expect(requestTo(uri('/test')))
			.andRespond(withSuccess('there', MediaType.TEXT_HTML));
		assertThat(this.restClientClient.test()).isEqualTo('there');
	}
	private static String uri(String path) {
		return 'https://example.com' + path;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest
class RestClientTestNoComponentIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Autowired
	private RestTemplateBuilder restTemplateBuilder;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void exampleRestClientIsNotInjected() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleRestTemplateService.class));
	}
	@Test
	void examplePropertiesIsNotInjected() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleProperties.class));
	}
	@Test
	void manuallyCreateBean() {
		ExampleRestTemplateService client = new ExampleRestTemplateService(this.restTemplateBuilder);
		this.server.expect(requestTo('/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		assertThat(client.test()).isEqualTo('hello');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@SpringBootTest
@AutoConfigureMockRestServiceServer
class AutoConfigureMockRestServiceServerWithRestTemplateRootUriIntegrationTests {
	@Autowired
	private RestTemplate restTemplate;
	@Autowired
	private MockRestServiceServer server;
	@Autowired
	MeterRegistry meterRegistry;
	@Test
	void whenRestTemplateAppliesARootUriThenMockServerExpectationsAreStillMatched() {
		this.server.expect(requestTo('/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/test', String.class);
		assertThat(entity.getBody()).isEqualTo('hello');
		assertThat(this.meterRegistry.find('http.client.requests').tag('uri', '/test').timer()).isNotNull();
	}
	@EnableAutoConfiguration(exclude = CassandraAutoConfiguration.class)
	@Configuration(proxyBeanMethods = false)
	static class RootUriConfiguration {
		@Bean
		RestTemplate restTemplate(RestTemplateBuilder restTemplateBuilder) {
			return restTemplateBuilder.rootUri('/rest').build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@SpringBootTest
@AutoConfigureMockRestServiceServer
class AutoConfigureMockRestServiceServerWithRestClientIntegrationTests {
	@Autowired
	private RestClient restClient;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void mockServerExpectationsAreMatched() {
		this.server.expect(requestTo('/rest/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restClient.get().uri('/test').retrieve().toEntity(String.class);
		assertThat(entity.getBody()).isEqualTo('hello');
	}
	@EnableAutoConfiguration(exclude = CassandraAutoConfiguration.class)
	@Configuration(proxyBeanMethods = false)
	static class RootUriConfiguration {
		@Bean
		RestClient restClient(Builder restClientBuilder) {
			return restClientBuilder.baseUrl('/rest').build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest(ExampleRestTemplateService.class)
class RestClientTestWithRestTemplateComponentIntegrationTests {
	@Autowired
	private MockRestServiceServer server;
	@Autowired
	private ExampleRestTemplateService client;
	@Test
	void mockServerCall() {
		this.server.expect(requestTo('/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		assertThat(this.client.test()).isEqualTo('hello');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@Service
public class AnotherExampleRestClientService {
	private final Builder builder;
	private final RestClient restClient;
	public AnotherExampleRestClientService(RestClient.Builder builder) {
		this.builder = builder;
		this.restClient = builder.baseUrl('https://example.com').build();
	}
	protected Builder getRestClientBuilder() {
		return this.builder;
	}
	public String test() {
		return this.restClient.get().uri('/test').retrieve().toEntity(String.class).getBody();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@SpringBootTest
@AutoConfigureWebClient(registerRestTemplate = true)
@AutoConfigureMockRestServiceServer
class AutoConfigureWebClientWithRestTemplateIntegrationTests {
	@Autowired
	private RestTemplate restTemplate;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void restTemplateTest() {
		this.server.expect(requestTo('/test')).andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/test', String.class);
		assertThat(entity.getBody()).isEqualTo('hello');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAutoConfiguration(exclude = CassandraAutoConfiguration.class)
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@Service
public class ExampleRestClientService {
	private final Builder builder;
	private final RestClient restClient;
	public ExampleRestClientService(RestClient.Builder builder) {
		this.builder = builder;
		this.restClient = builder.baseUrl('https://example.com').build();
	}
	protected Builder getRestClientBuilder() {
		return this.builder;
	}
	public String test() {
		return this.restClient.get().uri('/test').retrieve().toEntity(String.class).getBody();
	}
	public void testPostWithBody(String body) {
		this.restClient.post().uri('/test').body(body).retrieve().toBodilessEntity();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@Service
public class ExampleRestTemplateService {
	private final RestTemplate restTemplate;
	public ExampleRestTemplateService(RestTemplateBuilder builder) {
		this.restTemplate = builder.rootUri('https://example.com').build();
	}
	protected RestTemplate getRestTemplate() {
		return this.restTemplate;
	}
	public String test() {
		return this.restTemplate.getForEntity('/test', String.class).getBody();
	}
	public void testPostWithBody(String body) {
		this.restTemplate.postForObject('/test', body, String.class);
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@SpringBootApplication
@ConfigurationPropertiesScan
public class ExampleWebClientApplication {
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest(components = ExampleProperties.class, properties = 'example.name=Hello')
class RestClientTestWithConfigurationPropertiesIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void configurationPropertiesCanBeAddedAsComponent() {
		assertThat(this.applicationContext.getBeansOfType(ExampleProperties.class).keySet())
			.containsOnly('example-org.springframework.boot.test.autoconfigure.web.client.ExampleProperties');
		assertThat(this.applicationContext.getBean(ExampleProperties.class).getName()).isEqualTo('Hello');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest({ ExampleRestClientService.class, AnotherExampleRestClientService.class })
class RestClientTestRestClientTwoComponentsIntegrationTests {
	@Autowired
	private ExampleRestClientService client1;
	@Autowired
	private AnotherExampleRestClientService client2;
	@Autowired
	private MockServerRestClientCustomizer customizer;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void serverShouldNotWork() {
		assertThatIllegalStateException().isThrownBy(
				() -> this.server.expect(requestTo(uri('/test'))).andRespond(withSuccess('hello', MediaType.TEXT_HTML)))
			.withMessageContaining('Unable to use auto-configured');
	}
	@Test
	void client1RestCallViaCustomizer() {
		this.customizer.getServer(this.client1.getRestClientBuilder())
			.expect(requestTo(uri('/test')))
			.andRespond(withSuccess('hello', MediaType.TEXT_HTML));
		assertThat(this.client1.test()).isEqualTo('hello');
	}
	@Test
	void client2RestCallViaCustomizer() {
		this.customizer.getServer(this.client2.getRestClientBuilder())
			.expect(requestTo(uri('/test')))
			.andRespond(withSuccess('there', MediaType.TEXT_HTML));
		assertThat(this.client2.test()).isEqualTo('there');
	}
	private static String uri(String path) {
		return 'https://example.com' + path;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
class RestClientWithRestTemplateBuilderTests {
	@Test
	void buildUsingRestTemplateBuilderRootUri() {
		RestTemplate restTemplate = new RestTemplateBuilder().rootUri('https://resttemplate.example.com').build();
		RestClient.Builder builder = RestClient.builder(restTemplate);
		RestClient client = buildMockedClient(builder, 'https://resttemplate.example.com/test');
		assertThat(client.get().uri('/test').retrieve().toBodilessEntity().getStatusCode().is2xxSuccessful()).isTrue();
	}
	@Test
	void buildUsingRestClientBuilderBaseUrl() {
		RestTemplate restTemplate = new RestTemplateBuilder().build();
		RestClient.Builder builder = RestClient.builder(restTemplate).baseUrl('https://restclient.example.com');
		RestClient client = buildMockedClient(builder, 'https://restclient.example.com/test');
		assertThat(client.get().uri('/test').retrieve().toBodilessEntity().getStatusCode().is2xxSuccessful()).isTrue();
	}
	@Test
	void buildRestTemplateBuilderRootUriAndRestClientBuilderBaseUrl() {
		RestTemplate restTemplate = new RestTemplateBuilder().rootUri('https://resttemplate.example.com').build();
		RestClient.Builder builder = RestClient.builder(restTemplate).baseUrl('https://restclient.example.com');
		RestClient client = buildMockedClient(builder, 'https://resttemplate.example.com/test');
		assertThat(client.get().uri('/test').retrieve().toBodilessEntity().getStatusCode().is2xxSuccessful()).isTrue();
	}
	private RestClient buildMockedClient(Builder builder, String url) {
		MockRestServiceServer server = MockRestServiceServer.bindTo(builder).build();
		server.expect(requestTo(url)).andRespond(withSuccess());
		return builder.build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest
@AutoConfigureMockRestServiceServer(enabled = false)
class AutoConfigureMockRestServiceServerEnabledFalseIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void mockServerRestTemplateCustomizerShouldNotBeRegistered() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(MockServerRestTemplateCustomizer.class));
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(MockServerRestClientCustomizer.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@RestClientTest(properties = 'spring.profiles.active=test')
class RestClientTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(RestClientTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
class SpringBootMockMvcBuilderCustomizerTests {
	@Test
	void customizeShouldAddFilters() {
		AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext();
		MockServletContext servletContext = new MockServletContext();
		context.setServletContext(servletContext);
		context.register(ServletConfiguration.class, FilterConfiguration.class);
		context.refresh();
		DefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(context);
		SpringBootMockMvcBuilderCustomizer customizer = new SpringBootMockMvcBuilderCustomizer(context);
		customizer.customize(builder);
		FilterRegistrationBean<?> registrationBean = (FilterRegistrationBean<?>) context.getBean('otherTestFilter');
		TestFilter testFilter = context.getBean('testFilter', TestFilter.class);
		OtherTestFilter otherTestFilter = (OtherTestFilter) registrationBean.getFilter();
		assertThat(builder).extracting('filters', as(InstanceOfAssertFactories.LIST))
			.extracting('delegate', 'dispatcherTypes')
			.containsExactlyInAnyOrder(tuple(testFilter, EnumSet.of(DispatcherType.REQUEST)),
					tuple(otherTestFilter, EnumSet.of(DispatcherType.REQUEST, DispatcherType.ERROR)));
		builder.build();
		assertThat(testFilter.filterName).isEqualTo('testFilter');
		assertThat(testFilter.initParams).isEmpty();
		assertThat(otherTestFilter.filterName).isEqualTo('otherTestFilter');
		assertThat(otherTestFilter.initParams).isEqualTo(Map.of('a', 'alpha', 'b', 'bravo'));
	}
	@Test
	void whenCalledInParallelDeferredLinesWriterSeparatesOutputByThread() throws Exception {
		AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext();
		MockServletContext servletContext = new MockServletContext();
		context.setServletContext(servletContext);
		context.register(ServletConfiguration.class, FilterConfiguration.class);
		context.refresh();
		CapturingLinesWriter delegate = new CapturingLinesWriter();
		new DeferredLinesWriter(context, delegate);
		CountDownLatch latch = new CountDownLatch(10);
		for (int i = 0; i < 10; i++) {
			Thread thread = new Thread(() -> {
				for (int j = 0; j < 1000; j++) {
					DeferredLinesWriter writer = DeferredLinesWriter.get(context);
					writer.write(Arrays.asList('1', '2', '3', '4', '5'));
					writer.writeDeferredResult();
					writer.clear();
				}
				latch.countDown();
			});
			thread.start();
		}
		assertThat(latch.await(60, TimeUnit.SECONDS)).isTrue();
		assertThat(delegate.allWritten).hasSize(10000);
		assertThat(delegate.allWritten)
			.allSatisfy((written) -> assertThat(written).containsExactly('1', '2', '3', '4', '5'));
	}
	private static final class CapturingLinesWriter implements LinesWriter {
		List<List<String>> allWritten = new ArrayList<>();
		private final Object monitor = new Object();
		@Override
		public void write(List<String> lines) {
			List<String> written = new ArrayList<>(lines);
			synchronized (this.monitor) {
				this.allWritten.add(written);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ServletConfiguration {
		@Bean
		TestServlet testServlet() {
			return new TestServlet();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FilterConfiguration {
		@Bean
		FilterRegistrationBean<OtherTestFilter> otherTestFilter() {
			FilterRegistrationBean<OtherTestFilter> filterRegistrationBean = new FilterRegistrationBean<>(
					new OtherTestFilter());
			filterRegistrationBean.setInitParameters(Map.of('a', 'alpha', 'b', 'bravo'));
			filterRegistrationBean.setDispatcherTypes(EnumSet.of(DispatcherType.REQUEST, DispatcherType.ERROR));
			return filterRegistrationBean;
		}
		@Bean
		TestFilter testFilter() {
			return new TestFilter();
		}
	}
	static class TestServlet extends HttpServlet {
	}
	static class TestFilter implements Filter {
		private String filterName;
		private Map<String, String> initParams = new HashMap<>();
		@Override
		public void init(FilterConfig filterConfig) {
			this.filterName = filterConfig.getFilterName();
			Collections.list(filterConfig.getInitParameterNames())
				.forEach((name) -> this.initParams.put(name, filterConfig.getInitParameter(name)));
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
		}
		@Override
		public void destroy() {
		}
	}
	static class OtherTestFilter implements Filter {
		private String filterName;
		private Map<String, String> initParams = new HashMap<>();
		@Override
		public void init(FilterConfig filterConfig) {
			this.filterName = filterConfig.getFilterName();
			Collections.list(filterConfig.getInitParameterNames())
				.forEach((name) -> this.initParams.put(name, filterConfig.getInitParameter(name)));
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
		}
		@Override
		public void destroy() {
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
class WebMvcTypeExcludeFilterTests {
	private final MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
	@Test
	void matchWhenHasNoControllers() throws Exception {
		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithNoControllers.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleWebMvcRegistrations.class)).isFalse();
		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, SecurityFilterChain.class)).isFalse();
		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	@Test
	void matchWhenHasController() throws Exception {
		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithController.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isTrue();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleWebMvcRegistrations.class)).isFalse();
		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, SecurityFilterChain.class)).isFalse();
		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	@Test
	void matchNotUsingDefaultFilters() throws Exception {
		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(NotUsingDefaultFilters.class);
		assertThat(excludes(filter, Controller1.class)).isTrue();
		assertThat(excludes(filter, Controller2.class)).isTrue();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue();
		assertThat(excludes(filter, ExampleWeb.class)).isTrue();
		assertThat(excludes(filter, ExampleWebMvcRegistrations.class)).isTrue();
		assertThat(excludes(filter, ExampleMessageConverter.class)).isTrue();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, SecurityFilterChain.class)).isTrue();
		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isTrue();
		assertThat(excludes(filter, ExampleModule.class)).isTrue();
		assertThat(excludes(filter, ExampleDialect.class)).isTrue();
	}
	@Test
	void matchWithIncludeFilter() throws Exception {
		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithIncludeFilter.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleWebMvcRegistrations.class)).isFalse();
		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isFalse();
		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	@Test
	void matchWithExcludeFilter() throws Exception {
		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithExcludeFilter.class);
		assertThat(excludes(filter, Controller1.class)).isTrue();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleWebMvcRegistrations.class)).isFalse();
		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, SecurityFilterChain.class)).isFalse();
		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	private boolean excludes(WebMvcTypeExcludeFilter filter, Class<?> type) throws IOException {
		MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(type.getName());
		return filter.match(metadataReader, this.metadataReaderFactory);
	}
	@WebMvcTest
	static class WithNoControllers {
	}
	@WebMvcTest(Controller1.class)
	static class WithController {
	}
	@WebMvcTest(useDefaultFilters = false)
	static class NotUsingDefaultFilters {
	}
	@WebMvcTest(includeFilters = @Filter(Repository.class))
	static class WithIncludeFilter {
	}
	@WebMvcTest(excludeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = Controller1.class))
	static class WithExcludeFilter {
	}
	@Controller
	static class Controller1 {
	}
	@Controller
	static class Controller2 {
	}
	@ControllerAdvice
	static class ExampleControllerAdvice {
	}
	static class ExampleWeb implements WebMvcConfigurer {
	}
	static class ExampleWebMvcRegistrations implements WebMvcRegistrations {
	}
	static class ExampleMessageConverter extends MappingJackson2HttpMessageConverter {
	}
	@Service
	static class ExampleService {
	}
	@Repository
	static class ExampleRepository {
	}
	static class ExampleHandlerInterceptor implements HandlerInterceptor {
	}
	static class ExampleModule extends SimpleModule {
	}
	static class ExampleDialect implements IDialect {
		@Override
		public String getName() {
			return 'example';
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest(controllers = ExampleController2.class)
@WithMockUser
class WebMvcTestOneControllerIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldNotFindController1() {
		assertThat(this.mvc.get().uri('/one')).hasStatus(HttpStatus.NOT_FOUND);
	}
	@Test
	void shouldFindController2() {
		assertThat(this.mvc.get().uri('/two')).hasStatusOk().hasBodyTextEqualTo('hellotwo');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest(controllers = ExampleController2.class)
@WithMockUser
class WebMvcTestNestedIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldNotFindController1() {
		assertThat(this.mvc.get().uri('/one')).hasStatus(HttpStatus.NOT_FOUND);
	}
	@Test
	void shouldFindController2() {
		assertThat(this.mvc.get().uri('/two')).hasStatusOk().hasBodyTextEqualTo('hellotwo');
	}
	@Nested
	@WithMockUser
	class NestedTests {
		@Test
		void shouldNotFindController1() {
			assertThat(WebMvcTestNestedIntegrationTests.this.mvc.get().uri('/one')).hasStatus(HttpStatus.NOT_FOUND);
		}
		@Test
		void shouldFindController2() {
			assertThat(WebMvcTestNestedIntegrationTests.this.mvc.get().uri('/two')).hasStatusOk()
				.hasBodyTextEqualTo('hellotwo');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser(username = 'user', password = 'secret')
@Import(AfterSecurityFilter.class)
class AutoConfigureMockMvcSecurityFilterOrderingIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void afterSecurityFilterShouldFindAUserPrincipal() {
		assertThat(this.mvc.get().uri('/one')).hasStatusOk().hasBodyTextEqualTo('user');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@RestController
@RequestMapping('/hateoas')
class HateoasController {
	@RequestMapping('/resource')
	EntityModel<Map<String, String>> resource() {
		return EntityModel.of(new HashMap<>(), Link.of('self', LinkRelation.of('https://api.example.com')));
	}
	@RequestMapping('/plain')
	Map<String, String> plain() {
		return new HashMap<>();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
@TestPropertySource(properties = 'spring.messages.basename=web-test-messages')
class WebMvcTestMessageSourceIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void messageSourceHasBeenAutoConfigured() {
		assertThat(this.context.getMessage('a', null, Locale.ENGLISH)).isEqualTo('alpha');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@RestController
@Validated
public class ExampleController3 {
	@GetMapping('/three/{id}')
	public String three(@PathVariable @Size(max = 4) String id) {
		return 'Hello ' + id;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
class WebMvcTestServletFilterIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldApplyFilter() {
		assertThat(this.mvc.get().uri('/one')).hasHeader('x-test', 'abc');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@SpringBootApplication(exclude = CassandraAutoConfiguration.class)
public class ExampleWebMvcApplication {
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WebAppConfiguration('src/test/webapp')
class WebMvcTestWithWebAppConfigurationTests {
	@Autowired
	private ServletContext servletContext;
	@Test
	void whenBasePathIsCustomizedResourcesCanBeLoadedFromThatLocation() throws Exception {
		testResource('/inwebapp', 'src/test/webapp');
		testResource('/inmetainfresources', '/META-INF/resources');
		testResource('/inresources', '/resources');
		testResource('/instatic', '/static');
		testResource('/inpublic', '/public');
	}
	private void testResource(String path, String expectedLocation) throws MalformedURLException {
		URL resource = this.servletContext.getResource(path);
		assertThat(resource).isNotNull();
		assertThat(resource.getPath()).contains(expectedLocation);
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
@TestMethodOrder(MethodOrderer.MethodName.class)
class WebMvcTestWebDriverIntegrationTests {
	private static WebDriver previousWebDriver;
	@Autowired
	private WebDriver webDriver;
	@Test
	void shouldAutoConfigureWebClient() {
		this.webDriver.get('/html');
		WebElement element = this.webDriver.findElement(By.tagName('body'));
		assertThat(element.getText()).isEqualTo('Hello');
		WebMvcTestWebDriverIntegrationTests.previousWebDriver = this.webDriver;
	}
	@Test
	void shouldBeADifferentWebClient() {
		this.webDriver.get('/html');
		WebElement element = this.webDriver.findElement(By.tagName('body'));
		assertThat(element.getText()).isEqualTo('Hello');
		assertThatExceptionOfType(NoSuchSessionException.class).isThrownBy(previousWebDriver::getWindowHandle);
		assertThat(previousWebDriver).isNotNull().isNotSameAs(this.webDriver);
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
public class ExampleArgument {
	private final String value;
	public ExampleArgument(String value) {
		this.value = value;
	}
	@Override
	public String toString() {
		return this.value;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
@TestPropertySource(properties = 'spring.test.mockmvc.print=NONE')
@ExtendWith(OutputCaptureExtension.class)
class WebMvcTestPrintDefaultOverrideIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldFindController1(CapturedOutput output) {
		assertThat(this.mvc.get().uri('/one')).hasStatusOk().hasBodyTextEqualTo('one');
		assertThat(output).doesNotContain('Request URI = /one');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
@AutoConfigureMockMvc(print = MockMvcPrint.NONE)
@ExtendWith(OutputCaptureExtension.class)
class WebMvcTestPrintOverrideIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldNotPrint(CapturedOutput output) {
		assertThat(this.mvc.get().uri('/one')).hasStatusOk().hasBodyTextEqualTo('one');
		assertThat(output).doesNotContain('Request URI = /one');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@SpringBootTest
@AutoConfigureMockMvc(print = MockMvcPrint.SYSTEM_ERR, printOnlyOnFailure = false)
@WithMockUser(username = 'user', password = 'secret')
@ExtendWith(OutputCaptureExtension.class)
class MockMvcSpringBootTestIntegrationTests {
	@MockitoBean
	private ExampleMockableService service;
	@Autowired
	private ApplicationContext applicationContext;
	@Autowired
	private MockMvc mvc;
	@Test
	void shouldFindController1(CapturedOutput output) throws Exception {
		this.mvc.perform(get('/one')).andExpect(content().string('one')).andExpect(status().isOk());
		assertThat(output).contains('Request URI = /one');
	}
	@Test
	void shouldFindController2() throws Exception {
		this.mvc.perform(get('/two')).andExpect(content().string('hellotwo')).andExpect(status().isOk());
	}
	@Test
	void shouldFindControllerAdvice() throws Exception {
		this.mvc.perform(get('/error')).andExpect(content().string('recovered')).andExpect(status().isOk());
	}
	@Test
	void shouldHaveRealService() {
		assertThat(this.applicationContext.getBean(ExampleRealService.class)).isNotNull();
	}
	@Test
	void shouldTestWithWebTestClient(@Autowired WebTestClient webTestClient) {
		webTestClient.get().uri('/one').exchange().expectStatus().isOk().expectBody(String.class).isEqualTo('one');
	}
	@Test
	void shouldNotFailIfFormattingValueThrowsException(CapturedOutput output) throws Exception {
		this.mvc.perform(get('/formatting')).andExpect(content().string('formatting')).andExpect(status().isOk());
		assertThat(output).contains(
				'Session Attrs = << Exception "java.lang.IllegalStateException: Formatting failed" occurred while formatting >>');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@TestMethodOrder(MethodOrderer.MethodName.class)
class WebMvcTestWebDriverCustomScopeIntegrationTests {
	// gh-7454
	private static WebDriver previousWebDriver;
	@Autowired
	private WebDriver webDriver;
	@Test
	void shouldAutoConfigureWebClient() {
		WebMvcTestWebDriverCustomScopeIntegrationTests.previousWebDriver = this.webDriver;
	}
	@Test
	void shouldBeTheSameWebClient() {
		assertThat(previousWebDriver).isNotNull().isSameAs(this.webDriver);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		@Scope('singleton')
		WebDriverFactory webDriver(MockMvc mockMvc) {
			return new WebDriverFactory(mockMvc);
		}
	}
	static class WebDriverFactory implements FactoryBean<WebDriver> {
		private final HtmlUnitDriver driver;
		WebDriverFactory(MockMvc mockMvc) {
			this.driver = MockMvcHtmlUnitDriverBuilder.mockMvcSetup(mockMvc).build();
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
		@Override
		public Class<?> getObjectType() {
			return WebDriver.class;
		}
		@Override
		public WebDriver getObject() {
			return this.driver;
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
class WebMvcTestPageableIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldSupportPageable() {
		assertThat(this.mvc.get().uri('/paged').param('page', '2').param('size', '42')).hasStatusOk()
			.hasBodyTextEqualTo('2:42');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
class WebMvcTestHateoasIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void plainResponse() {
		assertThat(this.mvc.get().uri('/hateoas/plain')).hasContentType('application/json');
	}
	@Test
	void hateoasResponse() {
		assertThat(this.mvc.get().uri('/hateoas/resource')).hasContentType('application/hal+json');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@ExtendWith(OutputCaptureExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
class WebMvcTestPrintDefaultIntegrationTests {
	@Test
	void shouldNotPrint(CapturedOutput output) {
		executeTests(ShouldNotPrint.class);
		assertThat(output).doesNotContain('HTTP Method');
	}
	@Test
	void shouldPrint(CapturedOutput output) {
		executeTests(ShouldPrint.class);
		assertThat(output).containsOnlyOnce('HTTP Method');
	}
	private void executeTests(Class<?> testClass) {
		LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
			.selectors(DiscoverySelectors.selectClass(testClass))
			.build();
		Launcher launcher = LauncherFactory.create();
		launcher.execute(request);
	}
	@WebMvcTest
	@WithMockUser
	@AutoConfigureMockMvc
	static class ShouldNotPrint {
		@Autowired
		private MockMvcTester mvc;
		@Test
		void test() {
			assertThat(this.mvc.get().uri('/one')).hasStatusOk().hasBodyTextEqualTo('one');
		}
	}
	@WebMvcTest
	@WithMockUser
	@AutoConfigureMockMvc
	static class ShouldPrint {
		@Autowired
		private MockMvcTester mvc;
		@Test
		void test() {
			assertThat(this.mvc.get().uri('/one')).hasStatusOk().hasBodyTextEqualTo('none');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
@TestPropertySource(properties = { 'spring.mvc.throw-exception-if-no-handler-found=true',
		'spring.mvc.static-path-pattern=/static/**' })
class WebMvcTestCustomDispatcherServletIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void dispatcherServletIsCustomized() {
		assertThat(this.mvc.get().uri('/does-not-exist')).hasStatus(HttpStatus.BAD_REQUEST)
			.hasBodyTextEqualTo('Invalid request: /does-not-exist');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
public class ExampleId {
	private final UUID id;
	ExampleId(UUID id) {
		this.id = id;
	}
	public UUID getId() {
		return this.id;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@Service
public class ExampleRealService {
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest(controllers = ExampleController2.class)
@WithMockUser
class WebMvcTestConverterIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldFindConverter() {
		String id = UUID.randomUUID().toString();
		assertThat(this.mvc.get().uri('/two/' + id)).hasStatusOk().hasBodyTextEqualTo(id + 'two');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
class WebMvcTestAllControllersIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Autowired(required = false)
	private ErrorAttributes errorAttributes;
	@Test
	void shouldFindController1() {
		assertThat(this.mvc.get().uri('/one')).satisfies(hasBody('one'));
	}
	@Test
	void shouldFindController2() {
		assertThat(this.mvc.get().uri('/two')).satisfies(hasBody('hellotwo'));
	}
	@Test
	void shouldFindControllerAdvice() {
		assertThat(this.mvc.get().uri('/error')).satisfies(hasBody('recovered'));
	}
	@Test
	void shouldRunValidationSuccess() {
		assertThat(this.mvc.get().uri('/three/OK')).satisfies(hasBody('Hello OK'));
	}
	@Test
	void shouldRunValidationFailure() {
		assertThat(this.mvc.get().uri('/three/invalid')).failure()
			.isInstanceOf(ServletException.class)
			.hasCauseInstanceOf(ConstraintViolationException.class);
	}
	@Test
	void shouldNotFilterErrorAttributes() {
		assertThat(this.errorAttributes).isNotNull();
	}
	private Consumer<MvcTestResult> hasBody(String expected) {
		return (result) -> assertThat(result).hasStatusOk().hasBodyTextEqualTo(expected);
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@Component
public class ExampleWebMvcConfigurer implements WebMvcConfigurer {
	@Override
	public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
		argumentResolvers.add(new HandlerMethodArgumentResolver() {
			@Override
			public boolean supportsParameter(MethodParameter parameter) {
				return parameter.getParameterType().equals(ExampleArgument.class);
			}
			@Override
			public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
					NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
				return new ExampleArgument('hello');
			}
		});
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
public class ExampleException extends RuntimeException {
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
class WebMvcTestWebClientIntegrationTests {
	@Autowired
	private WebClient webClient;
	@Test
	void shouldAutoConfigureWebClient() throws Exception {
		HtmlPage page = this.webClient.getPage('/html');
		assertThat(page.getBody().getTextContent()).isEqualTo('Hello');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
class WebMvcTestServletContextResourceTests {
	@Autowired
	private ServletContext servletContext;
	@Test
	void getResourceLocation() throws Exception {
		testResource('/inwebapp', 'src/main/webapp');
		testResource('/inmetainfresources', '/META-INF/resources');
		testResource('/inresources', '/resources');
		testResource('/instatic', '/static');
		testResource('/inpublic', '/public');
	}
	private void testResource(String path, String expectedLocation) throws MalformedURLException {
		URL resource = this.servletContext.getResource(path);
		assertThat(resource).isNotNull();
		assertThat(resource.getPath()).contains(expectedLocation);
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@ControllerAdvice
public class ExampleControllerAdvice {
	@ExceptionHandler
	public ResponseEntity<String> onExampleError(ExampleException exception) {
		return ResponseEntity.ok('recovered');
	}
	@ExceptionHandler(NoHandlerFoundException.class)
	@ResponseStatus(HttpStatus.BAD_REQUEST)
	public ResponseEntity<String> noHandlerFoundHandler(NoHandlerFoundException exception) {
		return ResponseEntity.badRequest().body('Invalid request: ' + exception.getRequestURL());
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@Service
public class ExampleMockableService {
	public ExampleMockableService() {
		throw new IllegalStateException('Should not be called');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@RestController
public class ExampleController1 {
	@GetMapping('/one')
	public String one() {
		return 'one';
	}
	@GetMapping('/error')
	public String error() {
		throw new ExampleException();
	}
	@GetMapping(path = '/html', produces = 'text/html')
	public String html() {
		return '<html><body>Hello</body></html>';
	}
	@GetMapping('/formatting')
	public String formatting(WebRequest request) {
		Object formattingFails = new Object() {
			@Override
			public String toString() {
				throw new IllegalStateException('Formatting failed');
			}
		};
		request.setAttribute('attribute-1', formattingFails, RequestAttributes.SCOPE_SESSION);
		return 'formatting';
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@Component
public class ExampleFilter implements Filter, Ordered {
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		chain.doFilter(request, response);
		((HttpServletResponse) response).addHeader('x-test', 'abc');
	}
	@Override
	public void destroy() {
	}
	@Override
	public int getOrder() {
		return SecurityProperties.DEFAULT_FILTER_ORDER - 1;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@SpringBootTest
@AutoConfigureMockMvc(print = MockMvcPrint.SYSTEM_ERR, printOnlyOnFailure = false)
@WithMockUser(username = 'user', password = 'secret')
@ExtendWith(OutputCaptureExtension.class)
class MockMvcTesterSpringBootTestIntegrationTests {
	@MockitoBean
	private ExampleMockableService service;
	@Autowired
	private ApplicationContext applicationContext;
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldFindController1(CapturedOutput output) {
		assertThat(this.mvc.get().uri('/one')).hasStatusOk().hasBodyTextEqualTo('one');
		assertThat(output).contains('Request URI = /one');
	}
	@Test
	void shouldFindController2() {
		assertThat(this.mvc.get().uri('/two')).hasStatusOk().hasBodyTextEqualTo('hellotwo');
	}
	@Test
	void shouldFindControllerAdvice() {
		assertThat(this.mvc.get().uri('/error')).hasStatusOk().hasBodyTextEqualTo('recovered');
	}
	@Test
	void shouldHaveRealService() {
		assertThat(this.applicationContext.getBean(ExampleRealService.class)).isNotNull();
	}
	@Test
	void shouldTestWithWebTestClient(@Autowired WebTestClient webTestClient) {
		webTestClient.get().uri('/one').exchange().expectStatus().isOk().expectBody(String.class).isEqualTo('one');
	}
	@Test
	void shouldNotFailIfFormattingValueThrowsException(CapturedOutput output) {
		assertThat(this.mvc.get().uri('/formatting')).hasStatusOk().hasBodyTextEqualTo('formatting');
		assertThat(output).contains(
				'Session Attrs = << Exception "java.lang.IllegalStateException: Formatting failed" occurred while formatting >>');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@Component
public class ExampleIdConverter implements Converter<String, ExampleId> {
	@Override
	public ExampleId convert(String source) {
		return new ExampleId(UUID.fromString(source));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
public class AfterSecurityFilter implements Filter, Ordered {
	@Override
	public int getOrder() {
		return SecurityProperties.DEFAULT_FILTER_ORDER + 1;
	}
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		Principal principal = ((HttpServletRequest) request).getUserPrincipal();
		if (principal == null) {
			throw new ServletException('No user principal');
		}
		response.getWriter().write(principal.getName());
		response.getWriter().flush();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
class WebMvcTestServletFilterRegistrationDisabledIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldNotApplyFilter() {
		assertThat(this.mvc.get().uri('/one')).doesNotContainHeader('x-test');
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class DisabledRegistrationConfiguration {
		@Bean
		FilterRegistrationBean<ExampleFilter> exampleFilterRegistration(ExampleFilter filter) {
			FilterRegistrationBean<ExampleFilter> registration = new FilterRegistrationBean<>(filter);
			registration.setEnabled(false);
			return registration;
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@Controller
public class ExampleController2 {
	@GetMapping('/two')
	@ResponseBody
	public String two(ExampleArgument argument) {
		return argument + 'two';
	}
	@GetMapping('/two/{id}')
	@ResponseBody
	public String two(@PathVariable ExampleId id) {
		return id.getId() + 'two';
	}
	@GetMapping('/paged')
	@ResponseBody
	public String paged(Pageable pageable) {
		return String.format('%s:%s', pageable.getPageNumber(), pageable.getPageSize());
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@WithMockUser
@AutoConfigureMockMvc(printOnlyOnFailure = false)
@ExtendWith(OutputCaptureExtension.class)
class WebMvcTestPrintAlwaysIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldPrint(CapturedOutput output) {
		assertThat(this.mvc.get().uri('/one')).hasStatusOk().hasBodyTextEqualTo('one');
		assertThat(output).contains('Request URI = /one');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet.mockmvc;
/**
@WebMvcTest
@AutoConfigureMockMvc(addFilters = false, webClientEnabled = false, webDriverEnabled = false)
class WebMvcTestWithAutoConfigureMockMvcIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private MockMvcTester mvc;
	@Test
	void shouldNotAddFilters() {
		assertThat(this.mvc.get().uri('/one')).doesNotContainHeader('x-test');
	}
	@Test
	void shouldNotHaveWebDriver() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(WebDriver.class));
	}
	@Test
	void shouldNotHaveWebClient() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(WebClient.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@WebMvcTest(properties = 'spring.profiles.active=test')
class WebMvcTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(WebMvcTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@WebMvcTest
class WebMvcTestAutoConfigurationIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void freemarkerAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(FreeMarkerAutoConfiguration.class));
	}
	@Test
	void groovyTemplatesAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(GroovyTemplateAutoConfiguration.class));
	}
	@Test
	void mustacheAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(MustacheAutoConfiguration.class));
	}
	@Test
	void thymeleafAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ThymeleafAutoConfiguration.class));
	}
	@Test
	void taskExecutionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(TaskExecutionAutoConfiguration.class));
	}
	@Test
	void asyncTaskExecutorWithApplicationTaskExecutor() {
		assertThat(this.applicationContext.getBeansOfType(AsyncTaskExecutor.class)).hasSize(1);
		assertThat(this.applicationContext.getBean(RequestMappingHandlerAdapter.class)).extracting('taskExecutor')
			.isSameAs(this.applicationContext.getBean('applicationTaskExecutor'));
	}
	@Test
	void oAuth2ClientAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(OAuth2ClientAutoConfiguration.class));
	}
	@Test
	void oAuth2ResourceServerAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(OAuth2ResourceServerAutoConfiguration.class));
	}
	@Test
	void httpEncodingAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(HttpEncodingAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
class MockMvcAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MockMvcAutoConfiguration.class));
	@Test
	void registersDispatcherServletFromMockMvc() {
		this.contextRunner.run((context) -> {
			MockMvc mockMvc = context.getBean(MockMvc.class);
			assertThat(context).hasSingleBean(DispatcherServlet.class);
			assertThat(context.getBean(DispatcherServlet.class)).isEqualTo(mockMvc.getDispatcherServlet());
		});
	}
	@Test
	void registersMockMvcTester() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MockMvcTester.class));
	}
	@Test
	void shouldNotRegisterMockMvcTesterIfAssertJMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(org.assertj.core.api.Assert.class))
			.run((context) -> assertThat(context).doesNotHaveBean(MockMvcTester.class));
	}
	@Test
	void registeredMockMvcTesterDelegatesToConfiguredMockMvc() {
		MockMvc mockMvc = mock(MockMvc.class);
		this.contextRunner.withBean('customMockMvc', MockMvc.class, () -> mockMvc).run((context) -> {
			assertThat(context).hasSingleBean(MockMvc.class).hasSingleBean(MockMvcTester.class);
			MockMvcTester mvc = context.getBean(MockMvcTester.class);
			mvc.get().uri('/dummy').exchange();
			then(mockMvc).should().perform(any(RequestBuilder.class));
		});
	}
	@Test
	void registersWebTestClient() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(WebTestClient.class));
	}
	@Test
	void shouldNotRegisterWebTestClientIfWebFluxMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(WebClient.class))
			.run((context) -> assertThat(context).doesNotHaveBean(WebTestClient.class));
	}
	@Test
	void shouldApplyWebTestClientCustomizers() {
		this.contextRunner.withUserConfiguration(WebTestClientCustomConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(WebTestClient.class);
			assertThat(context).hasBean('myWebTestClientCustomizer');
			then(context.getBean('myWebTestClientCustomizer', WebTestClientBuilderCustomizer.class)).should()
				.customize(any(WebTestClient.Builder.class));
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class WebTestClientCustomConfig {
		@Bean
		WebTestClientBuilderCustomizer myWebTestClientCustomizer() {
			return mock(WebTestClientBuilderCustomizer.class);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
@WebFluxTest(properties = 'spring.profiles.active=test')
class WebFluxTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(WebFluxTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@WebFluxTest
@TestPropertySource(properties = 'spring.messages.basename=web-test-messages')
class WebFluxTestMessageSourceIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void messageSourceHasBeenAutoConfigured() {
		assertThat(this.context.getMessage('a', null, Locale.ENGLISH)).isEqualTo('alpha');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@SpringBootApplication(exclude = CassandraAutoConfiguration.class)
public class ExampleWebFluxApplication {
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@WithMockUser
@WebFluxTest(controllers = ExampleController1.class)
class WebFluxTestOneControllerIntegrationTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void shouldFindController() {
		this.webClient.get().uri('/one').exchange().expectStatus().isOk().expectBody(String.class).isEqualTo('one');
	}
	@Test
	void shouldNotScanOtherController() {
		this.webClient.get().uri('/two').exchange().expectStatus().isNotFound();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@WithMockUser
@WebFluxTest
class WebFluxTestAllControllersIntegrationTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void shouldFindController1() {
		this.webClient.get().uri('/one').exchange().expectStatus().isOk().expectBody(String.class).isEqualTo('one');
	}
	@Test
	void shouldFindController2() {
		this.webClient.get().uri('/two').exchange().expectStatus().isOk().expectBody(String.class).isEqualTo('two');
	}
	@Test
	void webExceptionHandling() {
		this.webClient.get().uri('/one/error').exchange().expectStatus().isBadRequest();
	}
	@Test
	void shouldFindJsonController() {
		this.webClient.get().uri('/json').exchange().expectStatus().isOk();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@WebFluxTest
class WebFluxTestAutoConfigurationIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void messageSourceAutoConfigurationIsImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(MessageSourceAutoConfiguration.class));
	}
	@Test
	void validationAutoConfigurationIsImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ValidationAutoConfiguration.class));
	}
	@Test
	void mustacheAutoConfigurationIsImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(MustacheAutoConfiguration.class));
	}
	@Test
	void freeMarkerAutoConfigurationIsImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(FreeMarkerAutoConfiguration.class));
	}
	@Test
	void thymeleafAutoConfigurationIsImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ThymeleafAutoConfiguration.class));
	}
	@Test
	void errorWebFluxAutoConfigurationIsImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ErrorWebFluxAutoConfiguration.class));
	}
	@Test
	void oAuth2ClientAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ReactiveOAuth2ClientAutoConfiguration.class));
	}
	@Test
	void oAuth2ResourceServerAutoConfigurationWasImported() {
		assertThat(this.applicationContext)
			.has(importedAutoConfiguration(ReactiveOAuth2ResourceServerAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@SpringBootTest(properties = 'spring.main.web-application-type=reactive',
		classes = { WebTestClientSpringBootTestIntegrationTests.TestConfiguration.class,
				ExampleWebFluxApplication.class })
@AutoConfigureWebTestClient
class WebTestClientSpringBootTestIntegrationTests {
	@Autowired
	private WebTestClient webClient;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void shouldFindController1() {
		this.webClient.get().uri('/one').exchange().expectStatus().isOk().expectBody(String.class).isEqualTo('one');
	}
	@Test
	void shouldFindController2() {
		this.webClient.get().uri('/two').exchange().expectStatus().isOk().expectBody(String.class).isEqualTo('two');
	}
	@Test
	void shouldHaveRealService() {
		assertThat(this.applicationContext.getBeansOfType(ExampleRealService.class)).hasSize(1);
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
			http.authorizeExchange((exchanges) -> exchanges.anyExchange().permitAll());
			return http.build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
public class ExamplePojo {
	private final String alpha;
	private final String bravo;
	public ExamplePojo(String alpha, String bravo) {
		this.alpha = alpha;
		this.bravo = bravo;
	}
	public String getAlpha() {
		return this.alpha;
	}
	public String getBravo() {
		return this.bravo;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
public class ExampleId {
	private final UUID id;
	ExampleId(UUID id) {
		this.id = id;
	}
	public UUID getId() {
		return this.id;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@Service
public class ExampleRealService {
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@WithMockUser
@WebFluxTest(controllers = JsonController.class)
class WebFluxTestWebTestClientCodecCustomizationIntegrationTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void shouldBeAbleToCreatePojoViaParametersModule() {
		this.webClient.get().uri('/json').exchange().expectStatus().isOk().expectBody(ExamplePojo.class);
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@WithMockUser
@WebFluxTest(controllers = ExampleController2.class)
class WebFluxTestConverterIntegrationTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void shouldFindConverter() {
		UUID id = UUID.randomUUID();
		this.webClient.get()
			.uri('/two/' + id)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo(id + 'two');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@RestController
public class ExampleController1 {
	@GetMapping('/one')
	public Mono<String> one() {
		return Mono.just('one');
	}
	@GetMapping('/one/error')
	public Mono<String> error() {
		throw new RuntimeException('foo');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@Component
public class ExampleIdConverter implements GenericConverter {
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(String.class, ExampleId.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (source == null) {
			return null;
		}
		return new ExampleId(UUID.fromString((String) source));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@RestController
public class ExampleController2 {
	@GetMapping('/two')
	public Mono<String> two() {
		return Mono.just('two');
	}
	@GetMapping('/two/{id}')
	public Mono<String> two(@PathVariable ExampleId id) {
		return Mono.just(id.getId() + 'two');
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@Component
@Order(-2)
public class ExampleWebExceptionHandler implements WebExceptionHandler {
	private final ErrorWebExceptionHandler fallback;
	public ExampleWebExceptionHandler(ErrorWebExceptionHandler fallback) {
		this.fallback = fallback;
	}
	@Override
	public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
		if (ex instanceof RuntimeException && 'foo'.equals(ex.getMessage())) {
			exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST);
			return exchange.getResponse().setComplete();
		}
		return this.fallback.handle(exchange, ex);
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive.webclient;
/**
@RestController
public class JsonController {
	@GetMapping(value = '/json', produces = MediaType.APPLICATION_JSON_VALUE)
	public Mono<ExamplePojo> json() {
		return Mono.just(new ExamplePojo('a', 'b'));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
class WebFluxTypeExcludeFilterTests {
	private final MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
	@Test
	void matchWhenHasNoControllers() throws Exception {
		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithNoControllers.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	@Test
	void matchWhenHasController() throws Exception {
		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithController.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isTrue();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	@Test
	void matchNotUsingDefaultFilters() throws Exception {
		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(NotUsingDefaultFilters.class);
		assertThat(excludes(filter, Controller1.class)).isTrue();
		assertThat(excludes(filter, Controller2.class)).isTrue();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue();
		assertThat(excludes(filter, ExampleWeb.class)).isTrue();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebFilter.class)).isTrue();
		assertThat(excludes(filter, ExampleModule.class)).isTrue();
		assertThat(excludes(filter, ExampleDialect.class)).isTrue();
	}
	@Test
	void matchWithIncludeFilter() throws Exception {
		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithIncludeFilter.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isFalse();
		assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	@Test
	void matchWithExcludeFilter() throws Exception {
		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithExcludeFilter.class);
		assertThat(excludes(filter, Controller1.class)).isTrue();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse();
		assertThat(excludes(filter, ExampleWeb.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDialect.class)).isFalse();
	}
	private boolean excludes(WebFluxTypeExcludeFilter filter, Class<?> type) throws IOException {
		MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(type.getName());
		return filter.match(metadataReader, this.metadataReaderFactory);
	}
	@WebFluxTest
	static class WithNoControllers {
	}
	@WebFluxTest(Controller1.class)
	static class WithController {
	}
	@WebFluxTest(useDefaultFilters = false)
	static class NotUsingDefaultFilters {
	}
	@WebFluxTest(includeFilters = @Filter(Repository.class))
	static class WithIncludeFilter {
	}
	@WebFluxTest(excludeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = Controller1.class))
	static class WithExcludeFilter {
	}
	@Controller
	static class Controller1 {
	}
	@Controller
	static class Controller2 {
	}
	@ControllerAdvice
	static class ExampleControllerAdvice {
	}
	static class ExampleWeb implements WebFluxConfigurer {
	}
	@Service
	static class ExampleService {
	}
	@Repository
	static class ExampleRepository {
	}
	static class ExampleWebFilter implements WebFilter {
		@Override
		public Mono<Void> filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {
			return null;
		}
	}
	static class ExampleModule extends SimpleModule {
	}
	static class ExampleDialect implements IDialect {
		@Override
		public String getName() {
			return 'example';
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
class WebTestClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(WebTestClientAutoConfiguration.class));
	@Test
	void shouldNotBeConfiguredWithoutWebHandler() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasNotFailed();
			assertThat(context).doesNotHaveBean(WebTestClient.class);
		});
	}
	@Test
	void shouldCustomizeClientCodecs() {
		this.contextRunner.withUserConfiguration(CodecConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(WebTestClient.class);
			assertThat(context).hasSingleBean(CodecCustomizer.class);
			then(context.getBean(CodecCustomizer.class)).should().customize(any(CodecConfigurer.class));
		});
	}
	@Test
	void shouldCustomizeTimeout() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('spring.test.webtestclient.timeout=15m')
			.run((context) -> {
				WebTestClient webTestClient = context.getBean(WebTestClient.class);
				assertThat(webTestClient).hasFieldOrPropertyWithValue('responseTimeout', Duration.ofMinutes(15));
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void shouldApplySpringSecurityConfigurer() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			WebTestClient webTestClient = context.getBean(WebTestClient.class);
			WebTestClient.Builder builder = (WebTestClient.Builder) ReflectionTestUtils.getField(webTestClient,
					'builder');
			WebHttpHandlerBuilder httpHandlerBuilder = (WebHttpHandlerBuilder) ReflectionTestUtils.getField(builder,
					'httpHandlerBuilder');
			List<WebFilter> filters = (List<WebFilter>) ReflectionTestUtils.getField(httpHandlerBuilder, 'filters');
			assertThat(filters.get(0).getClass().getName()).isEqualTo(
					'org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers$MutatorFilter');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void shouldNotApplySpringSecurityConfigurerWhenSpringSecurityNotOnClassPath() {
		FilteredClassLoader classLoader = new FilteredClassLoader(SecurityMockServerConfigurers.class);
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withClassLoader(classLoader)
			.run((context) -> {
				WebTestClient webTestClient = context.getBean(WebTestClient.class);
				WebTestClient.Builder builder = (WebTestClient.Builder) ReflectionTestUtils.getField(webTestClient,
						'builder');
				WebHttpHandlerBuilder httpHandlerBuilder = (WebHttpHandlerBuilder) ReflectionTestUtils.getField(builder,
						'httpHandlerBuilder');
				List<WebFilter> filters = (List<WebFilter>) ReflectionTestUtils.getField(httpHandlerBuilder, 'filters');
				assertThat(filters).isEmpty();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		WebHandler webHandler() {
			return mock(WebHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CodecConfiguration {
		@Bean
		CodecCustomizer myCodecCustomizer() {
			return mock(CodecCustomizer.class);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.actuate.observability;
/**
@SpringBootConfiguration
@EnableAutoConfiguration(exclude = { CassandraAutoConfiguration.class, MongoReactiveAutoConfiguration.class,
		MongoAutoConfiguration.class })
class AutoConfigureObservabilitySpringBootApplication {
}
/*
package org.springframework.boot.test.autoconfigure.actuate.observability;
/**
@SpringBootTest
@AutoConfigureObservability
@SuppressWarnings('deprecation')
class AutoConfigureObservabilityPresentIntegrationTests {
	@Test
	void customizerDoesNotDisableAvailableMeterRegistriesWhenAnnotationPresent(
			@Autowired ApplicationContext applicationContext) {
		assertThat(applicationContext.getBeansOfType(io.micrometer.prometheus.PrometheusMeterRegistry.class))
			.hasSize(1);
	}
	@Test
	void customizerDoesNotSetExclusionPropertiesWhenAnnotationPresent(@Autowired Environment environment) {
		assertThat(environment.containsProperty('management.defaults.metrics.export.enabled')).isFalse();
		assertThat(environment.containsProperty('management.simple.metrics.export.enabled')).isFalse();
		assertThat(environment.containsProperty('management.tracing.enabled')).isFalse();
	}
}
/*
package org.springframework.boot.test.autoconfigure.actuate.observability;
/**
@SpringBootTest
@SuppressWarnings('deprecation')
class AutoConfigureObservabilityMissingIntegrationTests {
	@Test
	void customizerRunsAndOnlyEnablesSimpleMeterRegistryWhenNoAnnotationPresent(
			@Autowired ApplicationContext applicationContext) {
		assertThat(applicationContext.getBean(MeterRegistry.class)).isInstanceOf(SimpleMeterRegistry.class);
		assertThat(applicationContext.getBeansOfType(io.micrometer.prometheus.PrometheusMeterRegistry.class)).isEmpty();
	}
	@Test
	void customizerRunsAndSetsExclusionPropertiesWhenNoAnnotationPresent(@Autowired Environment environment) {
		assertThat(environment.getProperty('management.defaults.metrics.export.enabled')).isEqualTo('false');
		assertThat(environment.getProperty('management.simple.metrics.export.enabled')).isEqualTo('true');
		assertThat(environment.getProperty('management.tracing.enabled')).isEqualTo('false');
	}
}
/*
package org.springframework.boot.test.autoconfigure.actuate.observability;
/**
class ObservabilityContextCustomizerFactoryTests {
	private final ObservabilityContextCustomizerFactory factory = new ObservabilityContextCustomizerFactory();
	@Test
	void shouldDisableBothWhenNotAnnotated() {
		ContextCustomizer customizer = createContextCustomizer(NoAnnotation.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreDisabled(context);
		assertThatTracingIsDisabled(context);
	}
	@Test
	void shouldDisableOnlyTracing() {
		ContextCustomizer customizer = createContextCustomizer(OnlyMetrics.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreEnabled(context);
		assertThatTracingIsDisabled(context);
	}
	@Test
	void shouldDisableOnlyMetrics() {
		ContextCustomizer customizer = createContextCustomizer(OnlyTracing.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreDisabled(context);
		assertThatTracingIsEnabled(context);
	}
	@Test
	void shouldEnableBothWhenAnnotated() {
		ContextCustomizer customizer = createContextCustomizer(WithAnnotation.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreEnabled(context);
		assertThatTracingIsEnabled(context);
	}
	@Test
	void notEquals() {
		ContextCustomizer customizer1 = createContextCustomizer(OnlyMetrics.class);
		ContextCustomizer customizer2 = createContextCustomizer(OnlyTracing.class);
		assertThat(customizer1).isNotEqualTo(customizer2);
	}
	@Test
	void equals() {
		ContextCustomizer customizer1 = createContextCustomizer(OnlyMetrics.class);
		ContextCustomizer customizer2 = createContextCustomizer(OnlyMetrics.class);
		assertThat(customizer1).isEqualTo(customizer2);
		assertThat(customizer1).hasSameHashCodeAs(customizer2);
	}
	@Test
	void metricsAndTracingCanBeEnabledViaProperty() {
		ContextCustomizer customizer = createContextCustomizer(NoAnnotation.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.test.observability.auto-configure', 'true');
		context.setEnvironment(environment);
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreEnabled(context);
		assertThatTracingIsEnabled(context);
	}
	@Test
	void metricsAndTracingCanBeDisabledViaProperty() {
		ContextCustomizer customizer = createContextCustomizer(NoAnnotation.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.test.observability.auto-configure', 'false');
		context.setEnvironment(environment);
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreDisabled(context);
		assertThatTracingIsDisabled(context);
	}
	@Test
	void annotationTakesPrecedenceOverDisabledProperty() {
		ContextCustomizer customizer = createContextCustomizer(WithAnnotation.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.test.observability.auto-configure', 'false');
		context.setEnvironment(environment);
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreEnabled(context);
		assertThatTracingIsEnabled(context);
	}
	@Test
	void annotationTakesPrecedenceOverEnabledProperty() {
		ContextCustomizer customizer = createContextCustomizer(WithDisabledAnnotation.class);
		ConfigurableApplicationContext context = new GenericApplicationContext();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.test.observability.auto-configure', 'true');
		context.setEnvironment(environment);
		applyCustomizerToContext(customizer, context);
		assertThatMetricsAreDisabled(context);
		assertThatTracingIsDisabled(context);
	}
	private void applyCustomizerToContext(ContextCustomizer customizer, ConfigurableApplicationContext context) {
		customizer.customizeContext(context, null);
	}
	private ContextCustomizer createContextCustomizer(Class<?> testClass) {
		ContextCustomizer contextCustomizer = this.factory.createContextCustomizer(testClass, Collections.emptyList());
		assertThat(contextCustomizer).as('contextCustomizer').isNotNull();
		return contextCustomizer;
	}
	private void assertThatTracingIsDisabled(ConfigurableApplicationContext context) {
		assertThat(context.getEnvironment().getProperty('management.tracing.enabled')).isEqualTo('false');
	}
	private void assertThatMetricsAreDisabled(ConfigurableApplicationContext context) {
		assertThat(context.getEnvironment().getProperty('management.defaults.metrics.export.enabled'))
			.isEqualTo('false');
		assertThat(context.getEnvironment().getProperty('management.simple.metrics.export.enabled')).isEqualTo('true');
	}
	private void assertThatTracingIsEnabled(ConfigurableApplicationContext context) {
		assertThat(context.getEnvironment().getProperty('management.tracing.enabled')).isNull();
	}
	private void assertThatMetricsAreEnabled(ConfigurableApplicationContext context) {
		assertThat(context.getEnvironment().getProperty('management.defaults.metrics.export.enabled')).isNull();
		assertThat(context.getEnvironment().getProperty('management.simple.metrics.export.enabled')).isNull();
	}
	static class NoAnnotation {
	}
	@AutoConfigureObservability(tracing = false)
	static class OnlyMetrics {
	}
	@AutoConfigureObservability(metrics = false)
	static class OnlyTracing {
	}
	@AutoConfigureObservability
	static class WithAnnotation {
	}
	@AutoConfigureObservability(metrics = false, tracing = false)
	static class WithDisabledAnnotation {
	}
}
/*
package org.springframework.boot.test.autoconfigure.actuate.observability;
/**
@WebMvcTest
@AutoConfigureObservability
class AutoConfigureObservabilitySlicedIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void shouldHaveTracer() {
		assertThat(this.context.getBean(Tracer.class)).isEqualTo(Tracer.NOOP);
	}
	@Test
	void shouldHaveMeterRegistry() {
		assertThat(this.context.getBean(MeterRegistry.class)).isInstanceOf(SimpleMeterRegistry.class);
	}
	@Test
	void shouldHaveObservationRegistry() {
		assertThat(this.context.getBean(ObservationRegistry.class)).isNotNull();
	}
}
/*
package org.springframework.boot.test.autoconfigure;
/**
@ExtendWith(OutputCaptureExtension.class)
@Deprecated(since = '3.2.11', forRemoval = true)
@SuppressWarnings('removal')
class ConditionReportApplicationContextFailureProcessorTests {
	@Test
	void loadFailureShouldPrintReport(CapturedOutput output) {
		SpringApplication application = new SpringApplication(TestConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableApplicationContext applicationContext = application.run();
		ConditionReportApplicationContextFailureProcessor processor = new ConditionReportApplicationContextFailureProcessor();
		processor.processLoadFailure(applicationContext, new IllegalStateException());
		assertThat(output).contains('CONDITIONS EVALUATION REPORT')
			.contains('Positive matches')
			.contains('Negative matches');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(JacksonAutoConfiguration.class)
	static class TestConfig {
	}
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
@ExtendWith(SpringExtension.class)
@ExampleMapping(exampleProperty = 'abc')
class PropertyMappingTests {
	@Autowired
	private Environment environment;
	@Test
	void hasProperty() {
		assertThat(this.environment.getProperty('example-property')).isEqualTo('abc');
	}
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
class PropertyMappingContextCustomizerFactoryTests {
	private final PropertyMappingContextCustomizerFactory factory = new PropertyMappingContextCustomizerFactory();
	@Test
	void getContextCustomizerWhenHasNoMappingShouldNotAddPropertySource() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(NoMapping.class, null);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		ConfigurableEnvironment environment = mock(ConfigurableEnvironment.class);
		ConfigurableListableBeanFactory beanFactory = mock(ConfigurableListableBeanFactory.class);
		given(context.getEnvironment()).willReturn(environment);
		given(context.getBeanFactory()).willReturn(beanFactory);
		customizer.customizeContext(context, null);
		then(environment).shouldHaveNoInteractions();
	}
	@Test
	void getContextCustomizerWhenHasTypeMappingShouldReturnCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(TypeMapping.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void getContextCustomizerWhenHasAttributeMappingShouldReturnCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(AttributeMapping.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void hashCodeAndEqualsShouldBeBasedOnPropertyValues() {
		ContextCustomizer customizer1 = this.factory.createContextCustomizer(TypeMapping.class, null);
		ContextCustomizer customizer2 = this.factory.createContextCustomizer(AttributeMapping.class, null);
		ContextCustomizer customizer3 = this.factory.createContextCustomizer(OtherMapping.class, null);
		assertThat(customizer1).hasSameHashCodeAs(customizer2);
		assertThat(customizer1).isEqualTo(customizer1).isEqualTo(customizer2).isNotEqualTo(customizer3);
	}
	@Test
	void prepareContextShouldAddPropertySource() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(AttributeMapping.class, null);
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		customizer.customizeContext(context, null);
		assertThat(context.getEnvironment().getProperty('mapped')).isEqualTo('Mapped');
	}
	@Test
	void propertyMappingShouldNotBeUsedWithComponent() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(AttributeMapping.class, null);
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(ConfigMapping.class);
		customizer.customizeContext(context, null);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(context::refresh)
			.withMessageContaining('The @PropertyMapping annotation '
					+ '@PropertyMappingContextCustomizerFactoryTests.TypeMappingAnnotation '
					+ 'cannot be used in combination with the @Component annotation @Configuration');
	}
	@NoMappingAnnotation
	static class NoMapping {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface NoMappingAnnotation {
	}
	@TypeMappingAnnotation
	static class TypeMapping {
	}
	@Configuration(proxyBeanMethods = false)
	@TypeMappingAnnotation
	static class ConfigMapping {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping
	@interface TypeMappingAnnotation {
		String mapped() default 'Mapped';
	}
	@AttributeMappingAnnotation
	static class AttributeMapping {
	}
	@AttributeMappingAnnotation('Other')
	static class OtherMapping {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface AttributeMappingAnnotation {
		@PropertyMapping('mapped')
		String value() default 'Mapped';
	}
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
class AnnotationsPropertySourceTests {
	@Test
	void createWhenSourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new AnnotationsPropertySource(null))
			.withMessageContaining('Property source must not be null');
	}
	@Test
	void propertiesWhenHasNoAnnotationShouldBeEmpty() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(NoAnnotation.class);
		assertThat(source.getPropertyNames()).isEmpty();
		assertThat(source.getProperty('value')).isNull();
	}
	@Test
	void propertiesWhenHasTypeLevelAnnotationShouldUseAttributeName() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(TypeLevel.class);
		assertThat(source.getPropertyNames()).containsExactly('value');
		assertThat(source.getProperty('value')).isEqualTo('abc');
	}
	@Test
	void propertiesWhenHasTypeLevelWithPrefixShouldUsePrefixedName() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(TypeLevelWithPrefix.class);
		assertThat(source.getPropertyNames()).containsExactly('test.value');
		assertThat(source.getProperty('test.value')).isEqualTo('abc');
	}
	@Test
	void propertiesWhenHasAttributeLevelWithPrefixShouldUsePrefixedName() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(AttributeLevelWithPrefix.class);
		assertThat(source.getPropertyNames()).containsExactly('test');
		assertThat(source.getProperty('test')).isEqualTo('abc');
	}
	@Test
	void propertiesWhenHasTypeAndAttributeLevelWithPrefixShouldUsePrefixedName() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(TypeAndAttributeLevelWithPrefix.class);
		assertThat(source.getPropertyNames()).containsExactly('test.example');
		assertThat(source.getProperty('test.example')).isEqualTo('abc');
	}
	@Test
	void propertiesWhenNotMappedAtTypeLevelShouldIgnoreAttributes() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(NotMappedAtTypeLevel.class);
		assertThat(source.getPropertyNames()).containsExactly('value');
		assertThat(source.getProperty('ignore')).isNull();
	}
	@Test
	void propertiesWhenNotMappedAtAttributeLevelShouldIgnoreAttributes() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(NotMappedAtAttributeLevel.class);
		assertThat(source.getPropertyNames()).containsExactly('value');
		assertThat(source.getProperty('ignore')).isNull();
	}
	@Test
	void propertiesWhenContainsArraysShouldExpandNames() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(Arrays.class);
		assertThat(source.getPropertyNames()).contains('strings[0]', 'strings[1]', 'classes[0]', 'classes[1]',
				'ints[0]', 'ints[1]', 'longs[0]', 'longs[1]', 'floats[0]', 'floats[1]', 'doubles[0]', 'doubles[1]',
				'booleans[0]', 'booleans[1]');
		assertThat(source.getProperty('strings[0]')).isEqualTo('a');
		assertThat(source.getProperty('strings[1]')).isEqualTo('b');
		assertThat(source.getProperty('classes[0]')).isEqualTo(Integer.class);
		assertThat(source.getProperty('classes[1]')).isEqualTo(Long.class);
		assertThat(source.getProperty('ints[0]')).isEqualTo(1);
		assertThat(source.getProperty('ints[1]')).isEqualTo(2);
		assertThat(source.getProperty('longs[0]')).isEqualTo(1L);
		assertThat(source.getProperty('longs[1]')).isEqualTo(2L);
		assertThat(source.getProperty('floats[0]')).isEqualTo(1.0f);
		assertThat(source.getProperty('floats[1]')).isEqualTo(2.0f);
		assertThat(source.getProperty('doubles[0]')).isEqualTo(1.0);
		assertThat(source.getProperty('doubles[1]')).isEqualTo(2.0);
		assertThat(source.getProperty('booleans[0]')).isEqualTo(false);
		assertThat(source.getProperty('booleans[1]')).isEqualTo(true);
	}
	@Test
	void propertiesWhenHasCamelCaseShouldConvertToKebabCase() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(CamelCaseToKebabCase.class);
		assertThat(source.getPropertyNames()).contains('camel-case-to-kebab-case');
	}
	@Test
	void propertiesFromMetaAnnotationsAreMapped() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(PropertiesFromSingleMetaAnnotation.class);
		assertThat(source.getPropertyNames()).containsExactly('value');
		assertThat(source.getProperty('value')).isEqualTo('foo');
	}
	@Test
	void propertiesFromMultipleMetaAnnotationsAreMappedUsingTheirOwnPropertyMapping() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(PropertiesFromMultipleMetaAnnotations.class);
		assertThat(source.getPropertyNames()).containsExactly('value', 'test.value', 'test.example');
		assertThat(source.getProperty('value')).isEqualTo('alpha');
		assertThat(source.getProperty('test.value')).isEqualTo('bravo');
		assertThat(source.getProperty('test.example')).isEqualTo('charlie');
	}
	@Test
	void propertyMappedAttributesCanBeAliased() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(PropertyMappedAttributeWithAnAlias.class);
		assertThat(source.getPropertyNames()).containsExactly('aliasing.value');
		assertThat(source.getProperty('aliasing.value')).isEqualTo('baz');
	}
	@Test
	void selfAnnotatingAnnotationDoesNotCauseStackOverflow() {
		new AnnotationsPropertySource(PropertyMappedWithSelfAnnotatingAnnotation.class);
	}
	@Test
	void typeLevelAnnotationOnSuperClass() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(PropertyMappedAnnotationOnSuperClass.class);
		assertThat(source.getPropertyNames()).containsExactly('value');
		assertThat(source.getProperty('value')).isEqualTo('abc');
	}
	@Test
	void typeLevelAnnotationOnEnclosingClass() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(
				PropertyMappedAnnotationOnEnclosingClass.class);
		assertThat(source.getPropertyNames()).containsExactly('value');
		assertThat(source.getProperty('value')).isEqualTo('abc');
	}
	@Test
	void aliasedPropertyMappedAttributeOnSuperClass() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(
				AliasedPropertyMappedAnnotationOnSuperClass.class);
		assertThat(source.getPropertyNames()).containsExactly('aliasing.value');
		assertThat(source.getProperty('aliasing.value')).isEqualTo('baz');
	}
	@Test
	void enumValueMapped() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(EnumValueMapped.class);
		assertThat(source.getProperty('testenum.value')).isEqualTo(EnumItem.TWO);
	}
	@Test
	void enumValueNotMapped() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(EnumValueNotMapped.class);
		assertThat(source.containsProperty('testenum.value')).isFalse();
	}
	@Test
	void nestedAnnotationsMapped() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(PropertyMappedWithNestedAnnotations.class);
		assertThat(source.getProperty('testnested')).isNull();
		assertThat(source.getProperty('testnested.entries[0]')).isNull();
		assertThat(source.getProperty('testnested.entries[0].value')).isEqualTo('one');
		assertThat(source.getProperty('testnested.entries[1]')).isNull();
		assertThat(source.getProperty('testnested.entries[1].value')).isEqualTo('two');
	}
	@Test
	void deeplyNestedAnnotationsMapped() {
		AnnotationsPropertySource source = new AnnotationsPropertySource(
				PropertyMappedWithDeeplyNestedAnnotations.class);
		assertThat(source.getProperty('testdeeplynested')).isNull();
		assertThat(source.getProperty('testdeeplynested.level1')).isNull();
		assertThat(source.getProperty('testdeeplynested.level1.level2')).isNull();
		assertThat(source.getProperty('testdeeplynested.level1.level2.value')).isEqualTo('level2');
	}
	static class NoAnnotation {
	}
	@TypeLevelAnnotation('abc')
	static class TypeLevel {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping
	@interface TypeLevelAnnotation {
		String value();
	}
	@TypeLevelWithPrefixAnnotation('abc')
	static class TypeLevelWithPrefix {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping('test')
	@interface TypeLevelWithPrefixAnnotation {
		String value();
	}
	@AttributeLevelWithPrefixAnnotation('abc')
	static class AttributeLevelWithPrefix {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface AttributeLevelWithPrefixAnnotation {
		@PropertyMapping('test')
		String value();
	}
	@TypeAndAttributeLevelWithPrefixAnnotation('abc')
	static class TypeAndAttributeLevelWithPrefix {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping('test')
	@interface TypeAndAttributeLevelWithPrefixAnnotation {
		@PropertyMapping('example')
		String value();
	}
	@NotMappedAtTypeLevelAnnotation('abc')
	static class NotMappedAtTypeLevel {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping(skip = SkipPropertyMapping.YES)
	@interface NotMappedAtTypeLevelAnnotation {
		@PropertyMapping
		String value();
		String ignore() default 'xyz';
	}
	@NotMappedAtAttributeLevelAnnotation('abc')
	static class NotMappedAtAttributeLevel {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping
	@interface NotMappedAtAttributeLevelAnnotation {
		String value();
		@PropertyMapping(skip = SkipPropertyMapping.YES)
		String ignore() default 'xyz';
	}
	@ArraysAnnotation(strings = { 'a', 'b' }, classes = { Integer.class, Long.class }, ints = { 1, 2 },
			longs = { 1, 2 }, floats = { 1.0f, 2.0f }, doubles = { 1.0, 2.0 }, booleans = { false, true })
	static class Arrays {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping
	@interface ArraysAnnotation {
		String[] strings();
		Class<?>[] classes();
		int[] ints();
		long[] longs();
		float[] floats();
		double[] doubles();
		boolean[] booleans();
	}
	@CamelCaseToKebabCaseAnnotation
	static class CamelCaseToKebabCase {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping
	@interface CamelCaseToKebabCaseAnnotation {
		String camelCaseToKebabCase() default 'abc';
	}
	@PropertiesFromSingleMetaAnnotationAnnotation
	static class PropertiesFromSingleMetaAnnotation {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@TypeLevelAnnotation('foo')
	@interface PropertiesFromSingleMetaAnnotationAnnotation {
	}
	@PropertiesFromMultipleMetaAnnotationsAnnotation
	static class PropertiesFromMultipleMetaAnnotations {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@TypeLevelAnnotation('alpha')
	@TypeLevelWithPrefixAnnotation('bravo')
	@TypeAndAttributeLevelWithPrefixAnnotation('charlie')
	@interface PropertiesFromMultipleMetaAnnotationsAnnotation {
	}
	@AttributeWithAliasAnnotation('baz')
	static class PropertyMappedAttributeWithAnAlias {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@AliasedAttributeAnnotation
	@interface AttributeWithAliasAnnotation {
		@AliasFor(annotation = AliasedAttributeAnnotation.class)
		String value() default 'foo';
		String someOtherAttribute() default 'shouldNotBeMapped';
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping('aliasing')
	@interface AliasedAttributeAnnotation {
		String value() default 'bar';
	}
	@Retention(RetentionPolicy.RUNTIME)
	@SelfAnnotating
	@interface SelfAnnotating {
	}
	@SelfAnnotating
	static class PropertyMappedWithSelfAnnotatingAnnotation {
	}
	static class PropertyMappedAnnotationOnSuperClass extends TypeLevel {
	}
	@TypeLevelAnnotation('abc')
	static class EnclosingClass {
		class PropertyMappedAnnotationOnEnclosingClass {
		}
	}
	static class AliasedPropertyMappedAnnotationOnSuperClass extends PropertyMappedAttributeWithAnAlias {
	}
	@EnumAnnotation(EnumItem.TWO)
	static class EnumValueMapped {
	}
	@EnumAnnotation(EnumItem.DEFAULT)
	static class EnumValueNotMapped {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping('testenum')
	@interface EnumAnnotation {
		@PropertyMapping(skip = SkipPropertyMapping.ON_DEFAULT_VALUE)
		EnumItem value() default EnumItem.DEFAULT;
	}
	enum EnumItem {
		DEFAULT,
		ONE,
		TWO
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping('testnested')
	@interface NestedAnnotations {
		Entry[] entries();
		@Retention(RetentionPolicy.RUNTIME)
		@interface Entry {
			String value();
		}
	}
	@NestedAnnotations(entries = { @Entry('one'), @Entry('two') })
	static class PropertyMappedWithNestedAnnotations {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@PropertyMapping('testdeeplynested')
	@interface DeeplyNestedAnnotations {
		Level1 level1();
		@Retention(RetentionPolicy.RUNTIME)
		@interface Level1 {
			Level2 level2();
		}
		@Retention(RetentionPolicy.RUNTIME)
		@interface Level2 {
			String value();
		}
	}
	@DeeplyNestedAnnotations(level1 = @Level1(level2 = @Level2('level2')))
	static class PropertyMappedWithDeeplyNestedAnnotations {
	}
	@TypeLevelAnnotation('outer')
	static class OuterWithTypeLevel {
		@Nested
		static class NestedClass {
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
@Retention(RetentionPolicy.RUNTIME)
@PropertyMapping
@interface ExampleMapping {
	String exampleProperty();
}
/*
package org.springframework.boot.test.autoconfigure.security;
/**
@WebMvcTest
@TestPropertySource(properties = { 'debug=true' })
class MockMvcSecurityIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	@WithMockUser(username = 'test', password = 'test', roles = 'USER')
	void okResponseWithMockUser() {
		assertThat(this.mvc.get().uri('/')).hasStatusOk();
	}
	@Test
	void unauthorizedResponseWithNoUser() {
		assertThat(this.mvc.get().uri('/').accept(MediaType.APPLICATION_JSON)).hasStatus(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void okResponseWithBasicAuthCredentialsForKnownUser() {
		assertThat(this.mvc.get()
			.uri('/')
			.header(HttpHeaders.AUTHORIZATION, 'Basic ' + Base64.getEncoder().encodeToString('user:secret'.getBytes())))
			.hasStatusOk();
	}
}
/*
package org.springframework.boot.test.autoconfigure.security;
/**
@SpringBootApplication
public class SecurityTestApplication {
	@RestController
	static class MyController {
		@RequestMapping('/')
		@Secured('ROLE_USER')
		String index() {
			return 'Hello';
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
@DataJdbcTest(properties = 'spring.profiles.active=test')
class DataJdbcTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataJdbcTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
@Table('EXAMPLE_ENTITY')
public class ExampleEntity {
	@Id
	private Long id;
	private final String name;
	private final String reference;
	public ExampleEntity(String name, String reference) {
		this.name = name;
		this.reference = reference;
	}
	public String getName() {
		return this.name;
	}
	public String getReference() {
		return this.reference;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
@DataJdbcTest
@TestPropertySource(
		properties = 'spring.sql.init.schemaLocations=classpath:org/springframework/boot/test/autoconfigure/data/jdbc/schema.sql')
class DataJdbcTestIntegrationTests {
	@Autowired
	private ExampleRepository repository;
	@Autowired
	private DataSource dataSource;
	@Autowired
	private ApplicationContext applicationContext;
	@Autowired
	private JdbcTemplate jdbcTemplate;
	@Test
	void testRepository() {
		this.jdbcTemplate.update('INSERT INTO EXAMPLE_ENTITY (id, name, reference) VALUES (1, "a", "alpha")');
		this.jdbcTemplate.update('INSERT INTO EXAMPLE_ENTITY (id, name, reference) VALUES (2, "b", "bravo")');
		assertThat(this.repository.findAll()).hasSize(2);
	}
	@Test
	void replacesDefinedDataSourceWithEmbeddedDefault() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).isEqualTo('H2');
	}
	@Test
	void didNotInjectExampleComponent() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleComponent.class));
	}
	@Test
	void flywayAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(FlywayAutoConfiguration.class));
	}
	@Test
	void liquibaseAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(LiquibaseAutoConfiguration.class));
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
@SpringBootApplication
public class ExampleDataJdbcApplication {
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.HSQL).build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
interface ExampleRepository extends CrudRepository<ExampleEntity, Long> {
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
class DataJdbcTypeExcludeFilterTests {
	private final MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
	@Test
	void matchUsingDefaultFilters() throws Exception {
		DataJdbcTypeExcludeFilter filter = new DataJdbcTypeExcludeFilter(UsingDefaultFilters.class);
		assertThat(excludes(filter, TestJdbcConfiguration.class)).isFalse();
	}
	@Test
	void matchNotUsingDefaultFilters() throws Exception {
		DataJdbcTypeExcludeFilter filter = new DataJdbcTypeExcludeFilter(NotUsingDefaultFilters.class);
		assertThat(excludes(filter, TestJdbcConfiguration.class)).isTrue();
	}
	private boolean excludes(DataJdbcTypeExcludeFilter filter, Class<?> type) throws IOException {
		MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(type.getName());
		return filter.match(metadataReader, this.metadataReaderFactory);
	}
	@DataJdbcTest
	static class UsingDefaultFilters {
	}
	@DataJdbcTest(useDefaultFilters = false)
	static class NotUsingDefaultFilters {
	}
	static class TestJdbcConfiguration extends AbstractJdbcConfiguration {
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
@Component
public class ExampleComponent {
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@Import(CassandraMockConfiguration.class)
@DataCassandraTest(properties = 'spring.profiles.active=test')
class DataCassandraTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataCassandraTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
	@TestConfiguration
	static class CassandraMockConfiguration {
		@Bean
		CqlSession cqlSession() {
			DriverContext context = mock(DriverContext.class);
			CodecRegistry codecRegistry = mock(CodecRegistry.class);
			given(context.getCodecRegistry()).willReturn(codecRegistry);
			CqlSession cqlSession = mock(CqlSession.class);
			given(cqlSession.getContext()).willReturn(context);
			return cqlSession;
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@DataCouchbaseTest(properties = 'spring.profiles.active=test')
class DataCouchbaseTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataCouchbaseTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
@Table
public class Example {
	@Id
	String id;
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
@DataR2dbcTest(properties = 'spring.profiles.active=test')
class DataR2dbcTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataR2dbcTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
@DataR2dbcTest(
		properties = 'spring.sql.init.schemaLocations=classpath:org/springframework/boot/test/autoconfigure/data/r2dbc/schema.sql')
class DataR2dbcTestIntegrationTests {
	@Autowired
	private DatabaseClient databaseClient;
	@Autowired
	private ConnectionFactory connectionFactory;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testDatabaseClient() {
		Flux<Map<String, Object>> all = this.databaseClient.sql('SELECT * FROM example').fetch().all();
		StepVerifier.create(all).expectNextCount(1).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void replacesDefinedConnectionFactoryWithEmbeddedDefault() {
		String product = this.connectionFactory.getMetadata().getName();
		assertThat(product).isEqualTo('H2');
	}
	@Test
	void registersExampleRepository() {
		assertThat(this.applicationContext.getBeanNamesForType(ExampleRepository.class)).isNotEmpty();
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
@SpringBootApplication
public class ExampleR2dbcApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
public interface ExampleRepository extends ReactiveCrudRepository<Example, String> {
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@SpringBootApplication
public class ExampleLdapApplication {
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@DataLdapTest
@TestPropertySource(properties = { 'spring.ldap.embedded.base-dn=dc=spring,dc=org',
		'spring.ldap.embedded.ldif=classpath:org/springframework/boot/test/autoconfigure/data/ldap/schema.ldif' })
class DataLdapTestIntegrationTests {
	@Autowired
	private LdapTemplate ldapTemplate;
	@Autowired
	private ExampleRepository exampleRepository;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testRepository() {
		LdapQuery ldapQuery = LdapQueryBuilder.query().where('cn').is('Bob Smith');
		Optional<ExampleEntry> entry = this.exampleRepository.findOne(ldapQuery);
		assertThat(entry).isPresent();
		assertThat(entry.get().getDn())
			.isEqualTo(LdapUtils.newLdapName('cn=Bob Smith,ou=company1,c=Sweden,dc=spring,dc=org'));
		assertThat(this.ldapTemplate.findOne(ldapQuery, ExampleEntry.class).getDn())
			.isEqualTo(LdapUtils.newLdapName('cn=Bob Smith,ou=company1,c=Sweden,dc=spring,dc=org'));
	}
	@Test
	void didNotInjectExampleService() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleService.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@Entry(objectClasses = { 'person', 'top' })
public class ExampleEntry {
	@Id
	private Name dn;
	public Name getDn() {
		return this.dn;
	}
	public void setDn(Name dn) {
		this.dn = dn;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@DataLdapTest(properties = 'spring.profiles.active=test')
class DataLdapTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataLdapTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@Service
public class ExampleService {
	private final LdapTemplate ldapTemplate;
	public ExampleService(LdapTemplate ldapTemplate) {
		this.ldapTemplate = ldapTemplate;
	}
	public boolean hasEntry(LdapQuery query) {
		return this.ldapTemplate.find(query, ExampleEntry.class).size() == 1;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
interface ExampleRepository extends LdapRepository<ExampleEntry> {
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@DataLdapTest(includeFilters = @Filter(Service.class))
@TestPropertySource(properties = { 'spring.ldap.embedded.base-dn=dc=spring,dc=org',
		'spring.ldap.embedded.ldif=classpath:org/springframework/boot/test/autoconfigure/data/ldap/schema.ldif' })
class DataLdapTestWithIncludeFilterIntegrationTests {
	@Autowired
	private ExampleService service;
	@Test
	void testService() {
		LdapQuery ldapQuery = LdapQueryBuilder.query().where('cn').is('Will Smith');
		assertThat(this.service.hasEntry(ldapQuery)).isFalse();
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@DataMongoTest(properties = 'spring.profiles.active=test')
class DataMongoTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(DataMongoTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@WebFluxTest
@WithMockUser
@AutoConfigureRestDocs(uriScheme = 'https', uriHost = 'api.example.com', uriPort = 443)
class WebTestClientRestDocsAutoConfigurationAdvancedConfigurationIntegrationTests {
	@Autowired
	private WebTestClient webTestClient;
	private File generatedSnippets;
	@BeforeEach
	void deleteSnippets() {
		this.generatedSnippets = new File(new BuildOutput(getClass()).getRootLocation(), 'generated-snippets');
		FileSystemUtils.deleteRecursively(this.generatedSnippets);
	}
	@Test
	void defaultSnippetsAreWritten() {
		this.webTestClient.get()
			.uri('/')
			.exchange()
			.expectStatus()
			.is2xxSuccessful()
			.expectBody()
			.consumeWith(document('default-snippets'));
		File defaultSnippetsDir = new File(this.generatedSnippets, 'default-snippets');
		assertThat(defaultSnippetsDir).exists();
		assertThat(contentOf(new File(defaultSnippetsDir, 'curl-request.md'))).contains('"https://api.example.com/"');
		assertThat(contentOf(new File(defaultSnippetsDir, 'http-request.md'))).contains('api.example.com');
		assertThat(new File(defaultSnippetsDir, 'http-response.md')).isFile();
		assertThat(new File(defaultSnippetsDir, 'response-fields.md')).isFile();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class CustomizationConfiguration {
		@Bean
		RestDocumentationResultHandler restDocumentation() {
			return MockMvcRestDocumentation.document('{method-name}');
		}
		@Bean
		RestDocsWebTestClientConfigurationCustomizer templateFormatCustomizer() {
			return (configurer) -> configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
		}
		@Bean
		RestDocsWebTestClientConfigurationCustomizer defaultSnippetsCustomizer() {
			return (configurer) -> configurer.snippets()
				.withAdditionalDefaults(responseFields(fieldWithPath('_links.self').description('Main URL')));
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
@RestController
public class RestDocsTestController {
	@ResponseBody
	@RequestMapping(path = '/', produces = MediaTypes.HAL_JSON_VALUE)
	public Map<String, Object> index() {
		Map<String, Object> response = new HashMap<>();
		Map<String, String> links = new HashMap<>();
		links.put('self', WebMvcLinkBuilder.linkTo(getClass()).toUri().toString());
		response.put('_links', links);
		return response;
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@WebMvcTest(controllers = RestDocsTestController.class)
@WithMockUser
@AutoConfigureRestDocs
class MockMvcRestDocsAutoConfigurationAdvancedConfigurationIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	@Autowired
	private RestDocumentationResultHandler documentationHandler;
	private File generatedSnippets;
	@BeforeEach
	void deleteSnippets() {
		this.generatedSnippets = new File(new BuildOutput(getClass()).getRootLocation(), 'generated-snippets');
		FileSystemUtils.deleteRecursively(this.generatedSnippets);
	}
	@Test
	void snippetGeneration() {
		assertThat(this.mvc.get().uri('/')).apply(this.documentationHandler
			.document(links(linkWithRel('self').description('Canonical location of this resource'))));
		File defaultSnippetsDir = new File(this.generatedSnippets, 'snippet-generation');
		assertThat(defaultSnippetsDir).exists();
		assertThat(contentOf(new File(defaultSnippetsDir, 'curl-request.md'))).contains('"http://localhost:8080/"');
		assertThat(new File(defaultSnippetsDir, 'links.md')).isFile();
		assertThat(new File(defaultSnippetsDir, 'response-fields.md')).isFile();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class CustomizationConfiguration {
		@Bean
		RestDocumentationResultHandler restDocumentation() {
			return MockMvcRestDocumentation.document('{method-name}');
		}
		@Bean
		RestDocsMockMvcConfigurationCustomizer templateFormatCustomizer() {
			return (configurer) -> configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
		}
		@Bean
		RestDocsMockMvcConfigurationCustomizer defaultSnippetsCustomizer() {
			return (configurer) -> configurer.snippets()
				.withAdditionalDefaults(responseFields(fieldWithPath('_links.self').description('Main URL')));
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureRestDocs
class RestAssuredRestDocsAutoConfigurationAdvancedConfigurationIntegrationTests {
	@LocalServerPort
	private int port;
	@Autowired
	private RequestSpecification documentationSpec;
	private File generatedSnippets;
	@BeforeEach
	void deleteSnippets() {
		this.generatedSnippets = new File(new BuildOutput(getClass()).getRootLocation(), 'generated-snippets');
		FileSystemUtils.deleteRecursively(this.generatedSnippets);
	}
	@Test
	void snippetGeneration() {
		given(this.documentationSpec)
			.filter(document('default-snippets',
					preprocessRequest(modifyUris().scheme('https').host('api.example.com').removePort())))
			.when()
			.port(this.port)
			.get('/')
			.then()
			.assertThat()
			.statusCode(is(200));
		File defaultSnippetsDir = new File(this.generatedSnippets, 'default-snippets');
		assertThat(defaultSnippetsDir).exists();
		assertThat(contentOf(new File(defaultSnippetsDir, 'curl-request.md'))).contains('"https://api.example.com/"');
		assertThat(contentOf(new File(defaultSnippetsDir, 'http-request.md'))).contains('api.example.com');
		assertThat(new File(defaultSnippetsDir, 'http-response.md')).isFile();
		assertThat(new File(defaultSnippetsDir, 'response-fields.md')).isFile();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class CustomizationConfiguration {
		@Bean
		RestDocumentationResultHandler restDocumentation() {
			return MockMvcRestDocumentation.document('{method-name}');
		}
		@Bean
		RestDocsRestAssuredConfigurationCustomizer templateFormatCustomizer() {
			return (configurer) -> configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
		}
		@Bean
		RestDocsRestAssuredConfigurationCustomizer defaultSnippetsCustomizer() {
			return (configurer) -> configurer.snippets()
				.withAdditionalDefaults(responseFields(fieldWithPath('_links.self').description('Main URL')));
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@WebMvcTest
@AutoConfigureRestDocs(uriScheme = 'https', uriHost = 'api.example.com', uriPort = 443)
class MockMvcRestDocsAutoConfigurationIntegrationTests {
	@Autowired
	private MockMvcTester mvc;
	private File generatedSnippets;
	@BeforeEach
	void deleteSnippets() {
		this.generatedSnippets = new File(new BuildOutput(getClass()).getRootLocation(), 'generated-snippets');
		FileSystemUtils.deleteRecursively(this.generatedSnippets);
	}
	@Test
	void defaultSnippetsAreWritten() {
		assertThat(this.mvc.get().uri('/')).apply(document('default-snippets'));
		File defaultSnippetsDir = new File(this.generatedSnippets, 'default-snippets');
		assertThat(defaultSnippetsDir).exists();
		assertThat(contentOf(new File(defaultSnippetsDir, 'curl-request.adoc'))).contains('"https://api.example.com/"');
		assertThat(contentOf(new File(defaultSnippetsDir, 'http-request.adoc'))).contains('api.example.com');
		assertThat(new File(defaultSnippetsDir, 'http-response.adoc')).isFile();
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@SpringBootApplication(exclude = { CassandraAutoConfiguration.class, SecurityAutoConfiguration.class,
		ManagementWebSecurityAutoConfiguration.class })
public class RestDocsTestApplication {
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureRestDocs
class RestAssuredRestDocsAutoConfigurationIntegrationTests {
	@LocalServerPort
	private int port;
	@Autowired
	private RequestSpecification documentationSpec;
	private File generatedSnippets;
	@BeforeEach
	void deleteSnippets() {
		this.generatedSnippets = new File(new BuildOutput(getClass()).getRootLocation(), 'generated-snippets');
		FileSystemUtils.deleteRecursively(this.generatedSnippets);
	}
	@Test
	void defaultSnippetsAreWritten() {
		given(this.documentationSpec)
			.filter(document('default-snippets',
					preprocessRequest(modifyUris().scheme('https').host('api.example.com').removePort())))
			.when()
			.port(this.port)
			.get('/')
			.then()
			.assertThat()
			.statusCode(is(200));
		File defaultSnippetsDir = new File(this.generatedSnippets, 'default-snippets');
		assertThat(defaultSnippetsDir).exists();
		assertThat(contentOf(new File(defaultSnippetsDir, 'curl-request.adoc'))).contains('"https://api.example.com/"');
		assertThat(contentOf(new File(defaultSnippetsDir, 'http-request.adoc'))).contains('api.example.com');
		assertThat(new File(defaultSnippetsDir, 'http-response.adoc')).isFile();
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@WebFluxTest
@WithMockUser
@AutoConfigureRestDocs(uriScheme = 'https', uriHost = 'api.example.com', uriPort = 443)
class WebTestClientRestDocsAutoConfigurationIntegrationTests {
	@Autowired
	private WebTestClient webTestClient;
	private File generatedSnippets;
	@BeforeEach
	void deleteSnippets() {
		this.generatedSnippets = new File(new BuildOutput(getClass()).getRootLocation(), 'generated-snippets');
		FileSystemUtils.deleteRecursively(this.generatedSnippets);
	}
	@Test
	void defaultSnippetsAreWritten() {
		this.webTestClient.get()
			.uri('/')
			.exchange()
			.expectStatus()
			.is2xxSuccessful()
			.expectBody()
			.consumeWith(document('default-snippets'));
		File defaultSnippetsDir = new File(this.generatedSnippets, 'default-snippets');
		assertThat(defaultSnippetsDir).exists();
		assertThat(contentOf(new File(defaultSnippetsDir, 'curl-request.adoc'))).contains('"https://api.example.com/"');
		assertThat(contentOf(new File(defaultSnippetsDir, 'http-request.adoc'))).contains('api.example.com');
		assertThat(new File(defaultSnippetsDir, 'http-response.adoc')).isFile();
	}
}
/*
package org.springframework.boot.test.autoconfigure;
/**
@SpringBootConfiguration
@EnableAutoConfiguration
public class ExampleSpringBootApplication {
}
/*
package org.springframework.boot.test.autoconfigure;
/**
@TestConfiguration(proxyBeanMethods = false)
@EntityScan('some.other.package')
public class ExampleTestConfig {
}
/*
package org.springframework.boot.test.autoconfigure;
/**
public final class AutoConfigurationImportedCondition extends Condition<ApplicationContext> {
	private final Class<?> autoConfigurationClass;
	private AutoConfigurationImportedCondition(Class<?> autoConfigurationClass) {
		super(new TextDescription('%s imported', autoConfigurationClass.getName()));
		this.autoConfigurationClass = autoConfigurationClass;
	}
	@Override
	public boolean matches(ApplicationContext context) {
		ConditionEvaluationReport report = ConditionEvaluationReport
			.get((ConfigurableListableBeanFactory) context.getAutowireCapableBeanFactory());
		return report.getConditionAndOutcomesBySource().containsKey(this.autoConfigurationClass.getName())
				|| report.getUnconditionalClasses().contains(this.autoConfigurationClass.getName());
	}
	/**
	 * Returns a {@link Condition} that verifies that the given
	 * {@code autoConfigurationClass} has been imported.
	 * @param autoConfigurationClass the auto-configuration class
	 * @return the condition
	 */
	public static AutoConfigurationImportedCondition importedAutoConfiguration(Class<?> autoConfigurationClass) {
		return new AutoConfigurationImportedCondition(autoConfigurationClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
@SpringBootApplication
public class ExampleJooqApplication {
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.HSQL).build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
@JooqTest
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)
class JooqTestWithAutoConfigureTestDatabaseIntegrationTests {
	@Autowired
	private DSLContext dsl;
	@Autowired
	private DataSource dataSource;
	@Test
	void replacesAutoConfiguredDataSource() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('H2');
		assertThat(this.dsl.configuration().dialect()).isEqualTo(SQLDialect.H2);
	}
}
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
@JooqTest(properties = 'spring.profiles.active=test')
class JooqTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(JooqTestPropertiesIntegrationTests.this.environment.getActiveProfiles()).containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
@JooqTest
class JooqTestIntegrationTests {
	@Autowired
	private DSLContext dsl;
	@Autowired
	private DataSource dataSource;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testDSLContext() {
		assertThat(this.dsl.selectCount().from('INFORMATION_SCHEMA.TABLES').fetchOne(0, Integer.class))
			.isGreaterThan(0);
	}
	@Test
	void useDefinedDataSource() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).startsWith('HSQL');
		assertThat(this.dsl.configuration().dialect()).isEqualTo(SQLDialect.HSQLDB);
	}
	@Test
	void didNotInjectExampleComponent() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleComponent.class));
	}
	@Test
	void flywayAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(FlywayAutoConfiguration.class));
	}
	@Test
	void liquibaseAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(LiquibaseAutoConfiguration.class));
	}
	@Test
	void cacheAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(CacheAutoConfiguration.class));
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.override;
/**
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = true)
@BootstrapWith(SpringBootTestContextBootstrapper.class)
@ImportAutoConfiguration(ExampleTestConfig.class)
class OverrideAutoConfigurationEnabledTrueIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void autoConfiguredContext() {
		ApplicationContext context = this.context;
		assertThat(context.getBean(OverrideAutoConfigurationSpringBootApplication.class)).isNotNull();
		assertThat(context.getBean(ConfigurationPropertiesBindingPostProcessor.class)).isNotNull();
	}
}
/*
package org.springframework.boot.test.autoconfigure.override;
/**
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@BootstrapWith(SpringBootTestContextBootstrapper.class)
@ImportAutoConfiguration(ExampleTestConfig.class)
class OverrideAutoConfigurationEnabledFalseIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void disabledAutoConfiguration() {
		ApplicationContext context = this.context;
		assertThat(context.getBean(ExampleTestConfig.class)).isNotNull();
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> context.getBean(ConfigurationPropertiesBindingPostProcessor.class));
	}
}
/*
package org.springframework.boot.test.autoconfigure.override;
/**
@SpringBootConfiguration
@EnableAutoConfiguration(exclude = CassandraAutoConfiguration.class)
public class OverrideAutoConfigurationSpringBootApplication {
}
/*
package org.springframework.boot.test.autoconfigure.json.app;
/**
@JsonComponent
public class ExampleJsonComponent {
	static class Serializer extends JsonObjectSerializer<ExampleCustomObject> {
		@Override
		protected void serializeObject(ExampleCustomObject value, JsonGenerator jgen, SerializerProvider provider)
				throws IOException {
			jgen.writeStringField('value', value.toString());
		}
	}
	static class Deserializer extends JsonObjectDeserializer<ExampleCustomObject> {
		@Override
		protected ExampleCustomObject deserializeObject(JsonParser jsonParser, DeserializationContext context,
				ObjectCodec codec, JsonNode tree) throws IOException {
			return new ExampleCustomObject(nullSafeValue(tree.get('value'), String.class));
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.json.app;
/**
public class ExampleBasicObject {
	private String value;
	public String getValue() {
		return this.value;
	}
	public void setValue(String value) {
		this.value = value;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj.getClass() == getClass()) {
			return this.value.equals(((ExampleBasicObject) obj).value);
		}
		return false;
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
}
/*
package org.springframework.boot.test.autoconfigure.json.app;
/**
@SpringBootApplication(exclude = CassandraAutoConfiguration.class)
public class ExampleJsonApplication {
}
/*
package org.springframework.boot.test.autoconfigure.json.app;
/**
public class ExampleJsonObjectWithView {
	@JsonView(TestView.class)
	private String value;
	private int id;
	public String getValue() {
		return this.value;
	}
	public void setValue(String value) {
		this.value = value;
	}
	public int getId() {
		return this.id;
	}
	public void setId(int id) {
		this.id = id;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		ExampleJsonObjectWithView other = (ExampleJsonObjectWithView) obj;
		return ObjectUtils.nullSafeEquals(this.value, other.value) && ObjectUtils.nullSafeEquals(this.id, other.id);
	}
	@Override
	public int hashCode() {
		return 0;
	}
	@Override
	public String toString() {
		return this.value + ' ' + this.id;
	}
	public static class TestView {
	}
}
/*
package org.springframework.boot.test.autoconfigure.json.app;
/**
public class ExampleCustomObject {
	private final String value;
	public ExampleCustomObject(String value) {
		this.value = value;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj.getClass() == getClass()) {
			return this.value.equals(((ExampleCustomObject) obj).value);
		}
		return false;
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@JsonTest(properties = 'spring.profiles.active=test')
class JsonTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(JsonTestPropertiesIntegrationTests.this.environment.getActiveProfiles()).containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@JsonTest
@AutoConfigureJsonTesters(enabled = false)
@ContextConfiguration(classes = ExampleJsonApplication.class)
class JsonTestWithAutoConfigureJsonTestersTests {
	@Autowired(required = false)
	private BasicJsonTester basicJson;
	@Autowired(required = false)
	private JacksonTester<ExampleBasicObject> jacksonTester;
	@Autowired(required = false)
	private GsonTester<ExampleBasicObject> gsonTester;
	@Autowired(required = false)
	private JsonbTester<ExampleBasicObject> jsonbTester;
	@Test
	void basicJson() {
		assertThat(this.basicJson).isNull();
	}
	@Test
	void jackson() {
		assertThat(this.jacksonTester).isNull();
	}
	@Test
	void gson() {
		assertThat(this.gsonTester).isNull();
	}
	@Test
	void jsonb() {
		assertThat(this.jsonbTester).isNull();
	}
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
class JsonTestersAutoConfigurationTests {
	@Test
	void withNoMarshallersOnlyBasicJsonTesterHintsAreContributed() {
		jsonTesters((runtimeHints) -> {
			ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
			assertThat(reflection.onType(BasicJsonTester.class)).accepts(runtimeHints);
			assertThat(reflection.onType(JacksonTester.class).negate()).accepts(runtimeHints);
			assertThat(reflection.onType(JsonbTester.class).negate()).accepts(runtimeHints);
			assertThat(reflection.onType(GsonTester.class).negate()).accepts(runtimeHints);
		});
	}
	@Test
	void withObjectMapperBeanJacksonTesterHintsAreContributed() {
		jsonTestersWith(JacksonAutoConfiguration.class, (runtimeHints) -> {
			ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
			assertThat(reflection.onType(BasicJsonTester.class)).accepts(runtimeHints);
			assertThat(reflection.onType(JacksonTester.class)).accepts(runtimeHints);
			assertThat(reflection.onType(JsonbTester.class).negate()).accepts(runtimeHints);
			assertThat(reflection.onType(GsonTester.class).negate()).accepts(runtimeHints);
		});
	}
	@Test
	void withGsonBeanGsonTesterHintsAreContributed() {
		jsonTestersWith(GsonAutoConfiguration.class, (runtimeHints) -> {
			ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
			assertThat(reflection.onType(BasicJsonTester.class)).accepts(runtimeHints);
			assertThat(reflection.onType(JacksonTester.class).negate()).accepts(runtimeHints);
			assertThat(reflection.onType(JsonbTester.class).negate()).accepts(runtimeHints);
			assertThat(reflection.onType(GsonTester.class)).accepts(runtimeHints);
		});
	}
	@Test
	void withJsonbBeanJsonbTesterHintsAreContributed() {
		jsonTestersWith(JsonbAutoConfiguration.class, (runtimeHints) -> {
			ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
			assertThat(reflection.onType(BasicJsonTester.class)).accepts(runtimeHints);
			assertThat(reflection.onType(JacksonTester.class).negate()).accepts(runtimeHints);
			assertThat(reflection.onType(JsonbTester.class)).accepts(runtimeHints);
			assertThat(reflection.onType(GsonTester.class).negate()).accepts(runtimeHints);
		});
	}
	private void jsonTesters(Consumer<RuntimeHints> hintsConsumer) {
		jsonTestersWith(null, hintsConsumer);
	}
	private void jsonTestersWith(Class<?> configuration, Consumer<RuntimeHints> hintsConsumer) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			TestPropertyValues.of('spring.test.jsontesters.enabled=true').applyTo(context);
			if (configuration != null) {
				context.register(configuration);
			}
			context.register(JsonTestersAutoConfiguration.class);
			TestGenerationContext generationContext = new TestGenerationContext();
			new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext);
			hintsConsumer.accept(generationContext.getRuntimeHints());
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@SpringBootTest
@AutoConfigureJsonTesters
@ContextConfiguration(classes = ExampleJsonApplication.class)
class SpringBootTestWithAutoConfigureJsonTestersTests {
	@Autowired
	private BasicJsonTester basicJson;
	@Autowired
	private JacksonTester<ExampleBasicObject> jacksonTester;
	@Autowired
	private GsonTester<ExampleBasicObject> gsonTester;
	@Autowired
	private JsonbTester<ExampleBasicObject> jsonbTester;
	@Test
	void contextLoads() {
		assertThat(this.basicJson).isNotNull();
		assertThat(this.jacksonTester).isNotNull();
		assertThat(this.jsonbTester).isNotNull();
		assertThat(this.gsonTester).isNotNull();
	}
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@JsonTest
@ContextConfiguration(classes = ExampleJsonApplication.class)
class JsonTestIntegrationTests {
	@Autowired
	private BasicJsonTester basicJson;
	@Autowired
	private JacksonTester<ExampleBasicObject> jacksonBasicJson;
	@Autowired
	private JacksonTester<ExampleJsonObjectWithView> jacksonWithViewJson;
	@Autowired
	private JacksonTester<ExampleCustomObject> jacksonCustomJson;
	@Autowired
	private GsonTester<ExampleBasicObject> gsonJson;
	@Autowired
	private JsonbTester<ExampleBasicObject> jsonbJson;
	@Test
	void basicJson() {
		assertThat(this.basicJson.from('{\'a\':\'b\'}')).hasJsonPathStringValue('@.a');
	}
	@Test
	void jacksonBasic() throws Exception {
		ExampleBasicObject object = new ExampleBasicObject();
		object.setValue('spring');
		assertThat(this.jacksonBasicJson.write(object)).isEqualToJson('example.json');
	}
	@Test
	void jacksonCustom() throws Exception {
		ExampleCustomObject object = new ExampleCustomObject('spring');
		assertThat(this.jacksonCustomJson.write(object)).isEqualToJson('example.json');
	}
	@Test
	void gson() throws Exception {
		ExampleBasicObject object = new ExampleBasicObject();
		object.setValue('spring');
		assertThat(this.gsonJson.write(object)).isEqualToJson('example.json');
	}
	@Test
	void jsonb() throws Exception {
		ExampleBasicObject object = new ExampleBasicObject();
		object.setValue('spring');
		assertThat(this.jsonbJson.write(object)).isEqualToJson('example.json');
	}
	@Test
	void customView() throws Exception {
		ExampleJsonObjectWithView object = new ExampleJsonObjectWithView();
		object.setValue('spring');
		JsonContent<ExampleJsonObjectWithView> content = this.jacksonWithViewJson
			.forView(ExampleJsonObjectWithView.TestView.class)
			.write(object);
		assertThat(content).doesNotHaveJsonPathValue('id');
		assertThat(content).isEqualToJson('example.json');
	}
}
/*
package org.springframework.boot.test.autoconfigure.core;
/**
@SpringBootTest
@AutoConfigureCache
class AutoConfigureCacheIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void shouldConfigureNoOpCacheManager() {
		CacheManager bean = this.applicationContext.getBean(CacheManager.class);
		assertThat(bean).isInstanceOf(NoOpCacheManager.class);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class Config {
	}
}
/*
package org.springframework.boot.test.autoconfigure.core;
/**
@SpringBootTest
@AutoConfigureCache
class AutoConfigureCacheWithExistingCacheManagerIntegrationTests {
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void shouldNotReplaceExistingCacheManager() {
		CacheManager bean = this.applicationContext.getBean(CacheManager.class);
		assertThat(bean).isInstanceOf(ConcurrentMapCacheManager.class);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class Config {
		@Bean
		ConcurrentMapCacheManager existingCacheManager() {
			return new ConcurrentMapCacheManager();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure;
/**
class OverrideAutoConfigurationContextCustomizerFactoryTests {
	private final OverrideAutoConfigurationContextCustomizerFactory factory = new OverrideAutoConfigurationContextCustomizerFactory();
	@Test
	void getContextCustomizerWhenHasNoAnnotationShouldReturnNull() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(NoAnnotation.class, null);
		assertThat(customizer).isNull();
	}
	@Test
	void getContextCustomizerWhenHasAnnotationEnabledTrueShouldReturnNull() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(WithAnnotationEnabledTrue.class, null);
		assertThat(customizer).isNull();
	}
	@Test
	void getContextCustomizerWhenHasAnnotationEnabledFalseShouldReturnCustomizer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(WithAnnotationEnabledFalse.class, null);
		assertThat(customizer).isNotNull();
	}
	@Test
	void hashCodeAndEquals() {
		ContextCustomizer customizer1 = this.factory.createContextCustomizer(WithAnnotationEnabledFalse.class, null);
		ContextCustomizer customizer2 = this.factory.createContextCustomizer(WithSameAnnotation.class, null);
		assertThat(customizer1).hasSameHashCodeAs(customizer2);
		assertThat(customizer1).isEqualTo(customizer1).isEqualTo(customizer2);
	}
	static class NoAnnotation {
	}
	@OverrideAutoConfiguration(enabled = true)
	static class WithAnnotationEnabledTrue {
	}
	@OverrideAutoConfiguration(enabled = false)
	static class WithAnnotationEnabledFalse {
	}
	@OverrideAutoConfiguration(enabled = false)
	static class WithSameAnnotation {
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
@SpringBootApplication
public class ExampleGraphQlApplication {
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
@GraphQlTest(BookController.class)
class GraphQlTestIntegrationTests {
	@Autowired
	private GraphQlTester graphQlTester;
	@Test
	void getBookdByIdShouldReturnTestBook() {
		String query = '{ bookById(id: \'book-1\'){ id name pageCount author } }';
		this.graphQlTester.document(query).execute().path('data.bookById.id').entity(String.class).isEqualTo('42');
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
@GraphQlTest(properties = 'spring.profiles.active=test')
class GraphQlTestPropertiesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Nested
	class NestedTests {
		@Autowired
		private Environment innerEnvironment;
		@Test
		void propertiesFromEnclosingClassAffectNestedTests() {
			assertThat(GraphQlTestPropertiesIntegrationTests.this.environment.getActiveProfiles())
				.containsExactly('test');
			assertThat(this.innerEnvironment.getActiveProfiles()).containsExactly('test');
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql.tester;
/**
class GraphQlTesterAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, GraphQlTesterAutoConfiguration.class));
	@Test
	void shouldNotContributeTesterIfGraphQlServiceNotPresent() {
		this.contextRunner.run((context) -> assertThat(context).hasNotFailed().doesNotHaveBean(GraphQlTester.class));
	}
	@Test
	void shouldContributeTester() {
		this.contextRunner.withUserConfiguration(CustomGraphQlServiceConfiguration.class)
			.run((context) -> assertThat(context).hasNotFailed().hasSingleBean(GraphQlTester.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomGraphQlServiceConfiguration {
		@Bean
		ExecutionGraphQlService graphQlService() {
			return mock(ExecutionGraphQlService.class);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
public class Book {
	String id;
	String name;
	int pageCount;
	String author;
	public Book() {
	}
	public Book(String id, String name, int pageCount, String author) {
		this.id = id;
		this.name = name;
		this.pageCount = pageCount;
		this.author = author;
	}
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getPageCount() {
		return this.pageCount;
	}
	public void setPageCount(int pageCount) {
		this.pageCount = pageCount;
	}
	public String getAuthor() {
		return this.author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
class GraphQlTypeExcludeFilterTests {
	private final MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
	@Test
	void matchWhenHasNoControllers() throws Exception {
		GraphQlTypeExcludeFilter filter = new GraphQlTypeExcludeFilter(WithNoControllers.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleRuntimeWiringConfigurer.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebInterceptor.class)).isTrue();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDataFetcherExceptionResolver.class)).isFalse();
		assertThat(excludes(filter, ExampleInstrumentation.class)).isFalse();
		assertThat(excludes(filter, ExampleGraphQlSourceBuilderCustomizer.class)).isFalse();
	}
	@Test
	void matchWhenHasController() throws Exception {
		GraphQlTypeExcludeFilter filter = new GraphQlTypeExcludeFilter(WithController.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isTrue();
		assertThat(excludes(filter, ExampleRuntimeWiringConfigurer.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebInterceptor.class)).isTrue();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDataFetcherExceptionResolver.class)).isFalse();
		assertThat(excludes(filter, ExampleInstrumentation.class)).isFalse();
		assertThat(excludes(filter, ExampleGraphQlSourceBuilderCustomizer.class)).isFalse();
	}
	@Test
	void matchNotUsingDefaultFilters() throws Exception {
		GraphQlTypeExcludeFilter filter = new GraphQlTypeExcludeFilter(NotUsingDefaultFilters.class);
		assertThat(excludes(filter, Controller1.class)).isTrue();
		assertThat(excludes(filter, Controller2.class)).isTrue();
		assertThat(excludes(filter, ExampleRuntimeWiringConfigurer.class)).isTrue();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebInterceptor.class)).isTrue();
		assertThat(excludes(filter, ExampleModule.class)).isTrue();
		assertThat(excludes(filter, ExampleDataFetcherExceptionResolver.class)).isTrue();
		assertThat(excludes(filter, ExampleInstrumentation.class)).isTrue();
		assertThat(excludes(filter, ExampleGraphQlSourceBuilderCustomizer.class)).isTrue();
	}
	@Test
	void matchWithIncludeFilter() throws Exception {
		GraphQlTypeExcludeFilter filter = new GraphQlTypeExcludeFilter(WithIncludeFilter.class);
		assertThat(excludes(filter, Controller1.class)).isFalse();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleRuntimeWiringConfigurer.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isFalse();
		assertThat(excludes(filter, ExampleWebInterceptor.class)).isTrue();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDataFetcherExceptionResolver.class)).isFalse();
		assertThat(excludes(filter, ExampleInstrumentation.class)).isFalse();
		assertThat(excludes(filter, ExampleGraphQlSourceBuilderCustomizer.class)).isFalse();
	}
	@Test
	void matchWithExcludeFilter() throws Exception {
		GraphQlTypeExcludeFilter filter = new GraphQlTypeExcludeFilter(WithExcludeFilter.class);
		assertThat(excludes(filter, Controller1.class)).isTrue();
		assertThat(excludes(filter, Controller2.class)).isFalse();
		assertThat(excludes(filter, ExampleRuntimeWiringConfigurer.class)).isFalse();
		assertThat(excludes(filter, ExampleService.class)).isTrue();
		assertThat(excludes(filter, ExampleRepository.class)).isTrue();
		assertThat(excludes(filter, ExampleWebInterceptor.class)).isTrue();
		assertThat(excludes(filter, ExampleModule.class)).isFalse();
		assertThat(excludes(filter, ExampleDataFetcherExceptionResolver.class)).isFalse();
		assertThat(excludes(filter, ExampleInstrumentation.class)).isFalse();
		assertThat(excludes(filter, ExampleGraphQlSourceBuilderCustomizer.class)).isFalse();
	}
	private boolean excludes(GraphQlTypeExcludeFilter filter, Class<?> type) throws IOException {
		MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(type.getName());
		return filter.match(metadataReader, this.metadataReaderFactory);
	}
	@GraphQlTest
	static class WithNoControllers {
	}
	@GraphQlTest(Controller1.class)
	static class WithController {
	}
	@GraphQlTest(useDefaultFilters = false)
	static class NotUsingDefaultFilters {
	}
	@GraphQlTest(includeFilters = @ComponentScan.Filter(Repository.class))
	static class WithIncludeFilter {
	}
	@GraphQlTest(excludeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = Controller1.class))
	static class WithExcludeFilter {
	}
	@Controller
	static class Controller1 {
	}
	@Controller
	static class Controller2 {
	}
	@Service
	static class ExampleService {
	}
	@Repository
	static class ExampleRepository {
	}
	static class ExampleRuntimeWiringConfigurer implements RuntimeWiringConfigurer {
		@Override
		public void configure(RuntimeWiring.Builder builder) {
		}
	}
	static class ExampleWebInterceptor implements WebGraphQlInterceptor {
		@Override
		public Mono<WebGraphQlResponse> intercept(WebGraphQlRequest request, Chain chain) {
			return null;
		}
	}
	@SuppressWarnings('serial')
	static class ExampleModule extends SimpleModule {
	}
	static class ExampleDataFetcherExceptionResolver implements DataFetcherExceptionResolver {
		@Override
		public Mono<List<GraphQLError>> resolveException(Throwable exception, DataFetchingEnvironment environment) {
			return null;
		}
	}
	static class ExampleInstrumentation implements Instrumentation {
	}
	static class ExampleGraphQlSourceBuilderCustomizer implements GraphQlSourceBuilderCustomizer {
		@Override
		public void customize(GraphQlSource.SchemaResourceBuilder builder) {
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
@Controller
public class BookController {
	@QueryMapping
	public Book bookById(@Argument String id) {
		return new Book('42', 'Sample Book', 100, 'Jane Spring');
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@ExtendWith(MockitoExtension.class)
class TestEntityManagerTests {
	@Mock
	private EntityManagerFactory entityManagerFactory;
	@Mock
	private EntityManager entityManager;
	@Mock
	private PersistenceUnitUtil persistenceUnitUtil;
	private TestEntityManager testEntityManager;
	@BeforeEach
	void setup() {
		this.testEntityManager = new TestEntityManager(this.entityManagerFactory);
	}
	@Test
	void createWhenEntityManagerIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TestEntityManager(null))
			.withMessageContaining('EntityManagerFactory must not be null');
	}
	@Test
	void persistAndGetIdShouldPersistAndGetId() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		given(this.entityManagerFactory.getPersistenceUnitUtil()).willReturn(this.persistenceUnitUtil);
		given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123);
		Object result = this.testEntityManager.persistAndGetId(entity);
		then(this.entityManager).should().persist(entity);
		assertThat(result).isEqualTo(123);
	}
	@Test
	void persistAndGetIdForTypeShouldPersistAndGetId() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		given(this.entityManagerFactory.getPersistenceUnitUtil()).willReturn(this.persistenceUnitUtil);
		given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123);
		Integer result = this.testEntityManager.persistAndGetId(entity, Integer.class);
		then(this.entityManager).should().persist(entity);
		assertThat(result).isEqualTo(123);
	}
	@Test
	void persistShouldPersist() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		TestEntity result = this.testEntityManager.persist(entity);
		then(this.entityManager).should().persist(entity);
		assertThat(result).isSameAs(entity);
	}
	@Test
	void persistAndFlushShouldPersistAndFlush() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		TestEntity result = this.testEntityManager.persistAndFlush(entity);
		then(this.entityManager).should().persist(entity);
		then(this.entityManager).should().flush();
		assertThat(result).isSameAs(entity);
	}
	@Test
	void persistFlushFindShouldPersistAndFlushAndFind() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		TestEntity found = new TestEntity();
		given(this.entityManagerFactory.getPersistenceUnitUtil()).willReturn(this.persistenceUnitUtil);
		given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123);
		given(this.entityManager.find(TestEntity.class, 123)).willReturn(found);
		TestEntity result = this.testEntityManager.persistFlushFind(entity);
		then(this.entityManager).should().persist(entity);
		then(this.entityManager).should().flush();
		assertThat(result).isSameAs(found);
	}
	@Test
	void mergeShouldMerge() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		given(this.entityManager.merge(entity)).willReturn(entity);
		TestEntity result = this.testEntityManager.merge(entity);
		then(this.entityManager).should().merge(entity);
		assertThat(result).isSameAs(entity);
	}
	@Test
	void removeShouldRemove() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		this.testEntityManager.remove(entity);
		then(this.entityManager).should().remove(entity);
	}
	@Test
	void findShouldFind() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		given(this.entityManager.find(TestEntity.class, 123)).willReturn(entity);
		TestEntity result = this.testEntityManager.find(TestEntity.class, 123);
		assertThat(result).isSameAs(entity);
	}
	@Test
	void flushShouldFlush() {
		bindEntityManager();
		this.testEntityManager.flush();
		then(this.entityManager).should().flush();
	}
	@Test
	void refreshShouldRefresh() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		this.testEntityManager.refresh(entity);
		then(this.entityManager).should().refresh(entity);
	}
	@Test
	void clearShouldClear() {
		bindEntityManager();
		this.testEntityManager.clear();
		then(this.entityManager).should().clear();
	}
	@Test
	void detachShouldDetach() {
		bindEntityManager();
		TestEntity entity = new TestEntity();
		this.testEntityManager.detach(entity);
		then(this.entityManager).should().detach(entity);
	}
	@Test
	void getIdForTypeShouldGetId() {
		TestEntity entity = new TestEntity();
		given(this.entityManagerFactory.getPersistenceUnitUtil()).willReturn(this.persistenceUnitUtil);
		given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123);
		Integer result = this.testEntityManager.getId(entity, Integer.class);
		assertThat(result).isEqualTo(123);
	}
	@Test
	void getIdForTypeWhenTypeIsWrongShouldThrowException() {
		TestEntity entity = new TestEntity();
		given(this.entityManagerFactory.getPersistenceUnitUtil()).willReturn(this.persistenceUnitUtil);
		given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123);
		assertThatIllegalArgumentException().isThrownBy(() -> this.testEntityManager.getId(entity, Long.class))
			.withMessageContaining('ID mismatch: Object of class [java.lang.Integer] '
					+ 'must be an instance of class java.lang.Long');
	}
	@Test
	void getIdShouldGetId() {
		TestEntity entity = new TestEntity();
		given(this.entityManagerFactory.getPersistenceUnitUtil()).willReturn(this.persistenceUnitUtil);
		given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123);
		Object result = this.testEntityManager.getId(entity);
		assertThat(result).isEqualTo(123);
	}
	@Test
	void getEntityManagerShouldGetEntityManager() {
		bindEntityManager();
		assertThat(this.testEntityManager.getEntityManager()).isEqualTo(this.entityManager);
	}
	@Test
	void getEntityManagerWhenNotSetShouldThrowException() {
		assertThatIllegalStateException().isThrownBy(this.testEntityManager::getEntityManager)
			.withMessageContaining('No transactional EntityManager found');
	}
	private void bindEntityManager() {
		EntityManagerHolder holder = new EntityManagerHolder(this.entityManager);
		TransactionSynchronizationManager.bindResource(this.entityManagerFactory, holder);
	}
	static class TestEntity {
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@Entity
public class ExampleEntity {
	@Id
	@GeneratedValue
	private Long id;
	private String name;
	private String reference;
	protected ExampleEntity() {
	}
	public ExampleEntity(String name, String reference) {
		this.name = name;
		this.reference = reference;
	}
	public String getName() {
		return this.name;
	}
	public String getReference() {
		return this.reference;
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@ClassPathExclusions({ 'h2-*.jar', 'hsqldb-*.jar', 'derby-*.jar' })
class TestDatabaseAutoConfigurationNoEmbeddedTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(ExistingDataSourceConfiguration.class)
		.withConfiguration(AutoConfigurations.of(TestDatabaseAutoConfiguration.class));
	@Test
	void applyAnyReplace() {
		this.contextRunner.run((context) -> assertThat(context).getFailure()
			.isInstanceOf(BeanCreationException.class)
			.hasMessageContaining('Failed to replace DataSource with an embedded database for tests.')
			.hasMessageContaining('If you want an embedded database please put a supported one on the classpath')
			.hasMessageContaining('or tune the replace attribute of @AutoConfigureTestDatabase.'));
	}
	@Test
	void applyNoReplace() {
		this.contextRunner.withPropertyValues('spring.test.database.replace=NONE').run((context) -> {
			assertThat(context).hasSingleBean(DataSource.class);
			assertThat(context).getBean(DataSource.class).isSameAs(context.getBean('myCustomDataSource'));
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class ExistingDataSourceConfiguration {
		@Bean
		DataSource myCustomDataSource() {
			return mock(DataSource.class);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@DataJpaTest
class DataJpaTestIntegrationTests {
	@Autowired
	private TestEntityManager entities;
	@Autowired
	private JdbcClient jdbcClient;
	@Autowired
	private JdbcTemplate jdbcTemplate;
	@Autowired
	private ExampleRepository repository;
	@Autowired
	private DataSource dataSource;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testEntityManager() {
		ExampleEntity entity = this.entities.persist(new ExampleEntity('spring', '123'));
		this.entities.flush();
		Object id = this.entities.getId(entity);
		ExampleEntity found = this.entities.find(ExampleEntity.class, id);
		assertThat(found.getName()).isEqualTo('spring');
	}
	@Test
	void testEntityManagerPersistAndGetId() {
		Long id = this.entities.persistAndGetId(new ExampleEntity('spring', '123'), Long.class);
		this.entities.flush();
		assertThat(id).isNotNull();
		String sql = 'SELECT REFERENCE FROM EXAMPLE_ENTITY WHERE ID = ?';
		String reference = this.jdbcTemplate.queryForObject(sql, String.class, id);
		assertThat(reference).isEqualTo('123');
		reference = this.jdbcClient.sql(sql).param(id).query(String.class).single();
		assertThat(reference).isEqualTo('123');
	}
	@Test
	void testRepository() {
		this.entities.persist(new ExampleEntity('spring', '123'));
		this.entities.persist(new ExampleEntity('boot', '124'));
		this.entities.flush();
		ExampleEntity found = this.repository.findByReference('124');
		assertThat(found.getName()).isEqualTo('boot');
	}
	@Test
	void replacesDefinedDataSourceWithEmbeddedDefault() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).isEqualTo('H2');
	}
	@Test
	void didNotInjectExampleComponent() {
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(ExampleComponent.class));
	}
	@Test
	void flywayAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(FlywayAutoConfiguration.class));
	}
	@Test
	void liquibaseAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(LiquibaseAutoConfiguration.class));
	}
	@Test
	void serviceConnectionAutoConfigurationWasImported() {
		assertThat(this.applicationContext).has(importedAutoConfiguration(ServiceConnectionAutoConfiguration.class));
	}
	@Test
	void bootstrapModeIsDefaultByDefault() {
		assertThat(this.applicationContext.getEnvironment().getProperty('spring.data.jpa.repositories.bootstrap-mode'))
			.isEqualTo(BootstrapMode.DEFAULT.name());
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@SpringBootApplication
public class ExampleDataJpaApplication {
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(EmbeddedDatabaseType.HSQL).build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@DataJpaTest(properties = 'spring.profiles.active=test', bootstrapMode = BootstrapMode.DEFERRED)
class DataJpaTestAttributesIntegrationTests {
	@Autowired
	private Environment environment;
	@Test
	void environmentWithNewProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@Test
	void bootstrapModeIsSet() {
		assertThat(this.environment.getProperty('spring.data.jpa.repositories.bootstrap-mode'))
			.isEqualTo(BootstrapMode.DEFERRED.name());
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
interface ExampleRepository extends Repository<ExampleEntity, Long> {
	ExampleEntity findByReference(String reference);
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@DataJpaTest(properties = { 'spring.sql.init.username=alice', 'spring.sql.init.password=secret',
		'spring.sql.init.schema-locations=classpath:org/springframework/boot/test/autoconfigure/orm/jpa/schema.sql' })
class DataJpaTestSchemaCredentialsIntegrationTests {
	@Autowired
	private DataSource dataSource;
	@Test
	void replacesDefinedDataSourceWithEmbeddedDefault() throws Exception {
		String product = this.dataSource.getConnection().getMetaData().getDatabaseProductName();
		assertThat(product).isEqualTo('H2');
		assertThat(new JdbcTemplate(this.dataSource).queryForList('SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES',
				String.class))
			.contains('EXAMPLE');
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@Component
public class ExampleComponent {
}
/*
package org.springframework.boot.test.autoconfigure;
/**
@ExtendWith(OutputCaptureExtension.class)
class OnFailureConditionReportContextCustomizerFactoryTests {
	@Test
	void loadFailureShouldPrintReport(CapturedOutput output) {
		assertThatIllegalStateException()
			.isThrownBy(() -> new TestContextManager(FailingTests.class).getTestContext().getApplicationContext());
		assertThat(output).contains('JacksonAutoConfiguration matched');
	}
	@SpringBootTest
	static class FailingTests {
		@Configuration(proxyBeanMethods = false)
		@ImportAutoConfiguration(JacksonAutoConfiguration.class)
		static class TestConfig {
			@Bean
			String faultyBean() {
				throw new IllegalStateException();
			}
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure;
/**
class OverrideAutoConfigurationContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configurationAttributes) {
		if (AotDetector.useGeneratedArtifacts()) {
			return null;
		}
		OverrideAutoConfiguration overrideAutoConfiguration = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				OverrideAutoConfiguration.class);
		boolean enabled = (overrideAutoConfiguration == null) || overrideAutoConfiguration.enabled();
		return !enabled ? new DisableAutoConfigurationContextCustomizer() : null;
	}
	/**
	 * {@link ContextCustomizer} to disable full auto-configuration.
	 */
	private static final class DisableAutoConfigurationContextCustomizer implements ContextCustomizer {
		@Override
		public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
			TestPropertyValues.of(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY + '=false').applyTo(context);
		}
		@Override
		public boolean equals(Object obj) {
			return (obj != null) && (obj.getClass() == getClass());
		}
		@Override
		public int hashCode() {
			return getClass().hashCode();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
public class FilterAnnotations implements Iterable<TypeFilter> {
	private final ClassLoader classLoader;
	private final List<TypeFilter> filters;
	public FilterAnnotations(ClassLoader classLoader, Filter[] filters) {
		Assert.notNull(filters, 'Filters must not be null');
		this.classLoader = classLoader;
		this.filters = createTypeFilters(filters);
	}
	private List<TypeFilter> createTypeFilters(Filter[] filters) {
		List<TypeFilter> typeFilters = new ArrayList<>();
		for (Filter filter : filters) {
			for (Class<?> filterClass : filter.classes()) {
				typeFilters.add(createTypeFilter(filter.type(), filterClass));
			}
			for (String pattern : filter.pattern()) {
				typeFilters.add(createTypeFilter(filter.type(), pattern));
			}
		}
		return Collections.unmodifiableList(typeFilters);
	}
	@SuppressWarnings('unchecked')
	private TypeFilter createTypeFilter(FilterType filterType, Class<?> filterClass) {
		return switch (filterType) {
			case ANNOTATION -> {
				Assert.isAssignable(Annotation.class, filterClass,
						'An error occurred while processing an ANNOTATION type filter: ');
				yield new AnnotationTypeFilter((Class<Annotation>) filterClass);
			}
			case ASSIGNABLE_TYPE -> new AssignableTypeFilter(filterClass);
			case CUSTOM -> {
				Assert.isAssignable(TypeFilter.class, filterClass,
						'An error occurred while processing a CUSTOM type filter: ');
				yield BeanUtils.instantiateClass(filterClass, TypeFilter.class);
			}
			default -> throw new IllegalArgumentException('Filter type not supported with Class value: ' + filterType);
		};
	}
	private TypeFilter createTypeFilter(FilterType filterType, String pattern) {
		return switch (filterType) {
			case ASPECTJ -> new AspectJTypeFilter(pattern, this.classLoader);
			case REGEX -> new RegexPatternTypeFilter(Pattern.compile(pattern));
			default ->
				throw new IllegalArgumentException('Filter type not supported with String pattern: ' + filterType);
		};
	}
	@Override
	public Iterator<TypeFilter> iterator() {
		return this.filters.iterator();
	}
	public boolean anyMatches(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		for (TypeFilter filter : this) {
			if (filter.match(metadataReader, metadataReaderFactory)) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
public abstract class StandardAnnotationCustomizableTypeExcludeFilter<A extends Annotation>
		extends AnnotationCustomizableTypeExcludeFilter {
	private static final Filter[] NO_FILTERS = {};
	private static final String[] FILTER_TYPE_ATTRIBUTES;
	static {
		FilterType[] filterValues = FilterType.values();
		FILTER_TYPE_ATTRIBUTES = new String[filterValues.length];
		for (int i = 0; i < filterValues.length; i++) {
			FILTER_TYPE_ATTRIBUTES[i] = filterValues[i].name().toLowerCase(Locale.ROOT) + 'Filters';
		}
	}
	private final MergedAnnotation<A> annotation;
	protected StandardAnnotationCustomizableTypeExcludeFilter(Class<?> testClass) {
		this.annotation = MergedAnnotations.from(testClass, SearchStrategy.INHERITED_ANNOTATIONS)
			.get(getAnnotationType());
	}
	protected final MergedAnnotation<A> getAnnotation() {
		return this.annotation;
	}
	@Override
	protected boolean hasAnnotation() {
		return this.annotation.isPresent();
	}
	@Override
	protected Filter[] getFilters(FilterType type) {
		return this.annotation.getValue(FILTER_TYPE_ATTRIBUTES[type.ordinal()], Filter[].class).orElse(NO_FILTERS);
	}
	@Override
	protected boolean isUseDefaultFilters() {
		return this.annotation.getValue('useDefaultFilters', Boolean.class).orElse(false);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		return Collections.emptySet();
	}
	@Override
	protected Set<Class<?>> getComponentIncludes() {
		return Collections.emptySet();
	}
	@SuppressWarnings('unchecked')
	protected Class<A> getAnnotationType() {
		ResolvableType type = ResolvableType.forClass(StandardAnnotationCustomizableTypeExcludeFilter.class,
				getClass());
		return (Class<A>) type.resolveGeneric();
	}
}
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
class TypeExcludeFiltersContextCustomizerFactory implements ContextCustomizerFactory {
	private static final Class<?>[] NO_FILTERS = {};
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configurationAttributes) {
		if (AotDetector.useGeneratedArtifacts()) {
			return null;
		}
		AnnotationDescriptor<TypeExcludeFilters> descriptor = TestContextAnnotationUtils
			.findAnnotationDescriptor(testClass, TypeExcludeFilters.class);
		Class<?>[] filterClasses = (descriptor != null) ? descriptor.getAnnotation().value() : NO_FILTERS;
		if (ObjectUtils.isEmpty(filterClasses)) {
			return null;
		}
		return createContextCustomizer(descriptor.getRootDeclaringClass(), filterClasses);
	}
	@SuppressWarnings('unchecked')
	private ContextCustomizer createContextCustomizer(Class<?> testClass, Class<?>[] filterClasses) {
		return new TypeExcludeFiltersContextCustomizer(testClass,
				new LinkedHashSet<>(Arrays.asList((Class<? extends TypeExcludeFilter>[]) filterClasses)));
	}
}
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
class TypeExcludeFiltersContextCustomizer implements ContextCustomizer {
	private static final String EXCLUDE_FILTER_BEAN_NAME = TypeExcludeFilters.class.getName();
	private final Set<TypeExcludeFilter> filters;
	TypeExcludeFiltersContextCustomizer(Class<?> testClass, Set<Class<? extends TypeExcludeFilter>> filterClasses) {
		this.filters = instantiateTypeExcludeFilters(testClass, filterClasses);
	}
	private Set<TypeExcludeFilter> instantiateTypeExcludeFilters(Class<?> testClass,
			Set<Class<? extends TypeExcludeFilter>> filterClasses) {
		Set<TypeExcludeFilter> filters = new LinkedHashSet<>();
		for (Class<? extends TypeExcludeFilter> filterClass : filterClasses) {
			filters.add(instantiateTypeExcludeFilter(testClass, filterClass));
		}
		return Collections.unmodifiableSet(filters);
	}
	private TypeExcludeFilter instantiateTypeExcludeFilter(Class<?> testClass, Class<?> filterClass) {
		try {
			Constructor<?> constructor = getTypeExcludeFilterConstructor(filterClass);
			ReflectionUtils.makeAccessible(constructor);
			if (constructor.getParameterCount() == 1) {
				return (TypeExcludeFilter) constructor.newInstance(testClass);
			}
			return (TypeExcludeFilter) constructor.newInstance();
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to create filter for ' + filterClass, ex);
		}
	}
	@Override
	public boolean equals(Object obj) {
		return (obj != null) && (getClass() == obj.getClass())
				&& this.filters.equals(((TypeExcludeFiltersContextCustomizer) obj).filters);
	}
	@Override
	public int hashCode() {
		return this.filters.hashCode();
	}
	@Override
	public void customizeContext(ConfigurableApplicationContext context,
			MergedContextConfiguration mergedContextConfiguration) {
		if (!this.filters.isEmpty()) {
			context.getBeanFactory().registerSingleton(EXCLUDE_FILTER_BEAN_NAME, createDelegatingTypeExcludeFilter());
		}
	}
	private TypeExcludeFilter createDelegatingTypeExcludeFilter() {
		return new TypeExcludeFilter() {
			@Override
			public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
					throws IOException {
				for (TypeExcludeFilter filter : TypeExcludeFiltersContextCustomizer.this.filters) {
					if (filter.match(metadataReader, metadataReaderFactory)) {
						return true;
					}
				}
				return false;
			}
		};
	}
	private Constructor<?> getTypeExcludeFilterConstructor(Class<?> type) throws NoSuchMethodException {
		try {
			return type.getDeclaredConstructor(Class.class);
		}
		catch (Exception ex) {
			return type.getDeclaredConstructor();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
public abstract class AnnotationCustomizableTypeExcludeFilter extends TypeExcludeFilter
		implements BeanClassLoaderAware {
	private ClassLoader classLoader;
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	@Override
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		if (hasAnnotation()) {
			return !(include(metadataReader, metadataReaderFactory) && !exclude(metadataReader, metadataReaderFactory));
		}
		return false;
	}
	protected boolean include(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		if (new FilterAnnotations(this.classLoader, getFilters(FilterType.INCLUDE)).anyMatches(metadataReader,
				metadataReaderFactory)) {
			return true;
		}
		return isUseDefaultFilters() && defaultInclude(metadataReader, metadataReaderFactory);
	}
	protected boolean defaultInclude(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		for (Class<?> include : getDefaultIncludes()) {
			if (isTypeOrAnnotated(metadataReader, metadataReaderFactory, include)) {
				return true;
			}
		}
		for (Class<?> component : getComponentIncludes()) {
			if (isTypeOrAnnotated(metadataReader, metadataReaderFactory, component)) {
				return true;
			}
		}
		return false;
	}
	protected boolean exclude(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		return new FilterAnnotations(this.classLoader, getFilters(FilterType.EXCLUDE)).anyMatches(metadataReader,
				metadataReaderFactory);
	}
	@SuppressWarnings('unchecked')
	protected final boolean isTypeOrAnnotated(MetadataReader metadataReader,
			MetadataReaderFactory metadataReaderFactory, Class<?> type) throws IOException {
		AnnotationTypeFilter annotationFilter = new AnnotationTypeFilter((Class<? extends Annotation>) type);
		AssignableTypeFilter typeFilter = new AssignableTypeFilter(type);
		return annotationFilter.match(metadataReader, metadataReaderFactory)
				|| typeFilter.match(metadataReader, metadataReaderFactory);
	}
	protected abstract boolean hasAnnotation();
	protected abstract Filter[] getFilters(FilterType type);
	protected abstract boolean isUseDefaultFilters();
	protected abstract Set<Class<?>> getDefaultIncludes();
	protected abstract Set<Class<?>> getComponentIncludes();
	protected enum FilterType {
		INCLUDE, EXCLUDE
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		AnnotationCustomizableTypeExcludeFilter other = (AnnotationCustomizableTypeExcludeFilter) obj;
		boolean result = hasAnnotation() == other.hasAnnotation();
		for (FilterType filterType : FilterType.values()) {
			result &= ObjectUtils.nullSafeEquals(getFilters(filterType), other.getFilters(filterType));
		}
		result = result && isUseDefaultFilters() == other.isUseDefaultFilters();
		result = result && ObjectUtils.nullSafeEquals(getDefaultIncludes(), other.getDefaultIncludes());
		result = result && ObjectUtils.nullSafeEquals(getComponentIncludes(), other.getComponentIncludes());
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 0;
		result = prime * result + Boolean.hashCode(hasAnnotation());
		for (FilterType filterType : FilterType.values()) {
			result = prime * result + Arrays.hashCode(getFilters(filterType));
		}
		result = prime * result + Boolean.hashCode(isUseDefaultFilters());
		result = prime * result + Objects.hashCode(getDefaultIncludes());
		result = prime * result + Objects.hashCode(getComponentIncludes());
		return result;
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.filter;
/*
package org.springframework.boot.test.autoconfigure.filter;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface TypeExcludeFilters {
	/**
	 * Specifies {@link TypeExcludeFilter} classes that should be applied to
	 * {@link SpringBootApplication @SpringBootApplication} component scanning. Classes
	 * specified here can either have a no-arg constructor or accept a single
	 * {@code Class<?>} argument if they need access to the {@code testClass}.
	 * @see TypeExcludeFilter
	 * @return the type exclude filters to apply
	 */
	Class<? extends TypeExcludeFilter>[] value();
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureWebServiceServer {
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureMockWebServiceClient {
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
class WebServiceServerTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected MergedContextConfiguration processMergedContextConfiguration(MergedContextConfiguration mergedConfig) {
		MergedContextConfiguration processedMergedConfiguration = super.processMergedContextConfiguration(mergedConfig);
		return new WebMergedContextConfiguration(processedMergedConfiguration, determineResourceBasePath(mergedConfig));
	}
	@Override
	protected String[] getProperties(Class<?> testClass) {
		WebServiceServerTest webServiceServerTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				WebServiceServerTest.class);
		return (webServiceServerTest != null) ? webServiceServerTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
public class WebServiceServerTypeExcludeFilter
		extends StandardAnnotationCustomizableTypeExcludeFilter<WebServiceServerTest> {
	private static final Class<?>[] NO_ENDPOINTS = {};
	private static final Set<Class<?>> DEFAULT_INCLUDES;
	private static final Set<Class<?>> DEFAULT_INCLUDES_AND_ENDPOINT;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>();
		includes.add(EndpointInterceptor.class);
		DEFAULT_INCLUDES = Collections.unmodifiableSet(includes);
	}
	static {
		Set<Class<?>> includes = new LinkedHashSet<>(DEFAULT_INCLUDES);
		includes.add(Endpoint.class);
		DEFAULT_INCLUDES_AND_ENDPOINT = Collections.unmodifiableSet(includes);
	}
	private final Class<?>[] endpoints;
	WebServiceServerTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
		this.endpoints = getAnnotation().getValue('endpoints', Class[].class).orElse(NO_ENDPOINTS);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		if (ObjectUtils.isEmpty(this.endpoints)) {
			return DEFAULT_INCLUDES_AND_ENDPOINT;
		}
		return DEFAULT_INCLUDES;
	}
	@Override
	protected Set<Class<?>> getComponentIncludes() {
		return new LinkedHashSet<>(Arrays.asList(this.endpoints));
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@AutoConfiguration
@ConditionalOnClass(MockWebServiceClient.class)
public class MockWebServiceClientAutoConfiguration {
	@Bean
	MockWebServiceClient mockWebServiceClient(ApplicationContext applicationContext) {
		return MockWebServiceClient.createClient(applicationContext);
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.webservices.server;
/*
package org.springframework.boot.test.autoconfigure.webservices.server;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(WebServiceServerTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(WebServiceServerTypeExcludeFilter.class)
@AutoConfigureWebServiceServer
@AutoConfigureMockWebServiceClient
@ImportAutoConfiguration
public @interface WebServiceServerTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	String[] properties() default {};
	/**
	 * Specifies the endpoints to test. This is an alias of {@link #endpoints()} which can
	 * be used for brevity if no other attributes are defined. See {@link #endpoints()}
	 * for details.
	 * @return the endpoints to test
	 * @see #endpoints()
	 */
	@AliasFor('endpoints')
	Class<?>[] value() default {};
	/**
	 * Specifies the endpoints to test. May be left blank if all {@code @Endpoint} beans
	 * should be added to the application context.
	 * @return the endpoints to test
	 * @see #value()
	 */
	@AliasFor('value')
	Class<?>[] endpoints() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default only
	 * {@code @Endpoint} (when no explicit {@link #endpoints() controllers} are defined)
	 * are included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	ComponentScan.Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	ComponentScan.Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@PropertyMapping('spring.test.webservice.client')
public @interface AutoConfigureWebServiceClient {
	/**
	 * If a {@link WebServiceTemplate} bean should be registered. Defaults to
	 * {@code false} with the assumption that the {@link WebServiceTemplateBuilder} will
	 * be used.
	 * @return if a {@link WebServiceTemplate} bean should be added.
	 */
	boolean registerWebServiceTemplate() default false;
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
public class MockWebServiceServerTestExecutionListener extends AbstractTestExecutionListener {
	private static final boolean MOCK_SERVER_PRESENT = ClassUtils.isPresent(
			'org.springframework.ws.test.client.MockWebServiceServer',
			MockWebServiceServerTestExecutionListener.class.getClassLoader());
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 100;
	}
	@Override
	public void afterTestMethod(TestContext testContext) {
		if (MOCK_SERVER_PRESENT) {
			ApplicationContext applicationContext = testContext.getApplicationContext();
			String[] names = applicationContext.getBeanNamesForType(MockWebServiceServer.class, false, false);
			for (String name : names) {
				MockWebServiceServer mockServer = applicationContext.getBean(name, MockWebServiceServer.class);
				mockServer.verify();
				mockServer.reset();
			}
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(WebServiceClientTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(WebServiceClientExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureMockWebServiceServer
@AutoConfigureWebServiceClient
@ImportAutoConfiguration
public @interface WebServiceClientTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	String[] properties() default {};
	/**
	 * Specifies the components to test. This is an alias of {@link #components()} which
	 * can be used for brevity if no other attributes are defined. See
	 * {@link #components()} for details.
	 * @see #components()
	 * @return the components to test
	 */
	@AliasFor('components')
	Class<?>[] value() default {};
	/**
	 * Specifies the components to test. May be left blank if components will be manually
	 * imported or created directly.
	 * @see #value()
	 * @return the components to test
	 */
	@AliasFor('value')
	Class<?>[] components() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default only
	 * {@code @JsonComponent} and {@code Module} beans are included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	ComponentScan.Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	ComponentScan.Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@AutoConfiguration(after = WebServiceTemplateAutoConfiguration.class)
@ConditionalOnProperty(prefix = 'spring.test.webservice.client', name = 'register-web-service-template')
@ConditionalOnClass(WebServiceTemplate.class)
@ConditionalOnBean(WebServiceTemplateBuilder.class)
public class WebServiceClientTemplateAutoConfiguration {
	@Bean
	public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
		return builder.build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
final class TestMockWebServiceServer extends MockWebServiceServer {
	private final MockWebServiceMessageSender mockMessageSender;
	TestMockWebServiceServer(MockWebServiceMessageSender mockMessageSender) {
		super(mockMessageSender);
		this.mockMessageSender = mockMessageSender;
	}
	MockWebServiceMessageSender getMockMessageSender() {
		return this.mockMessageSender;
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
class MockWebServiceServerWebServiceTemplateCustomizer implements WebServiceTemplateCustomizer {
	private final AtomicBoolean applied = new AtomicBoolean();
	private final TestMockWebServiceServer mockServer;
	MockWebServiceServerWebServiceTemplateCustomizer(TestMockWebServiceServer mockServer) {
		this.mockServer = mockServer;
	}
	@Override
	public void customize(WebServiceTemplate webServiceTemplate) {
		Assert.state(!this.applied.getAndSet(true), '@WebServiceClientTest supports only a single WebServiceTemplate');
		webServiceTemplate.setMessageSender(this.mockServer.getMockMessageSender());
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@AutoConfiguration
@ConditionalOnProperty(prefix = 'spring.test.webservice.client.mockserver', name = 'enabled')
@ConditionalOnClass({ MockWebServiceServer.class, WebServiceTemplate.class })
public class MockWebServiceServerAutoConfiguration {
	@Bean
	public TestMockWebServiceServer mockWebServiceServer() {
		return new TestMockWebServiceServer(new MockWebServiceMessageSender());
	}
	@Bean
	public MockWebServiceServerWebServiceTemplateCustomizer mockWebServiceServerWebServiceTemplateCustomizer(
			TestMockWebServiceServer mockWebServiceServer) {
		return new MockWebServiceServerWebServiceTemplateCustomizer(mockWebServiceServer);
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
class WebServiceClientTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		WebServiceClientTest webServiceClientTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				WebServiceClientTest.class);
		return (webServiceClientTest != null) ? webServiceClientTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@PropertyMapping('spring.test.webservice.client.mockserver')
public @interface AutoConfigureMockWebServiceServer {
	/**
	 * If {@link MockWebServiceServer} bean should be registered. Defaults to
	 * {@code true}.
	 * @return if mock support is enabled
	 */
	boolean enabled() default true;
}
/*
/**
package org.springframework.boot.test.autoconfigure.webservices.client;
/*
package org.springframework.boot.test.autoconfigure.webservices.client;
/**
public final class WebServiceClientExcludeFilter
		extends StandardAnnotationCustomizableTypeExcludeFilter<WebServiceClientTest> {
	private final Class<?>[] components;
	WebServiceClientExcludeFilter(Class<?> testClass) {
		super(testClass);
		this.components = getAnnotation().getValue('components', Class[].class).orElseGet(() -> new Class<?>[0]);
	}
	@Override
	protected Set<Class<?>> getComponentIncludes() {
		return new LinkedHashSet<>(Arrays.asList(this.components));
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(JdbcTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(JdbcTypeExcludeFilter.class)
@Transactional
@AutoConfigureCache
@AutoConfigureJdbc
@AutoConfigureTestDatabase
@ImportAutoConfiguration
public @interface JdbcTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	ComponentScan.Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	ComponentScan.Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureJdbc {
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
class JdbcTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		JdbcTest jdbcTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, JdbcTest.class);
		return (jdbcTest != null) ? jdbcTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
public final class JdbcTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<JdbcTest> {
	JdbcTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@AutoConfiguration(before = DataSourceAutoConfiguration.class)
public class TestDatabaseAutoConfiguration {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	@ConditionalOnProperty(prefix = 'spring.test.database', name = 'replace', havingValue = 'NON_TEST',
			matchIfMissing = true)
	static EmbeddedDataSourceBeanFactoryPostProcessor nonTestEmbeddedDataSourceBeanFactoryPostProcessor(
			Environment environment) {
		return new EmbeddedDataSourceBeanFactoryPostProcessor(environment, Replace.NON_TEST);
	}
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	@ConditionalOnProperty(prefix = 'spring.test.database', name = 'replace', havingValue = 'ANY')
	static EmbeddedDataSourceBeanFactoryPostProcessor embeddedDataSourceBeanFactoryPostProcessor(
			Environment environment) {
		return new EmbeddedDataSourceBeanFactoryPostProcessor(environment, Replace.ANY);
	}
	@Bean
	@ConditionalOnProperty(prefix = 'spring.test.database', name = 'replace', havingValue = 'AUTO_CONFIGURED')
	@ConditionalOnMissingBean
	public DataSource dataSource(Environment environment) {
		return new EmbeddedDataSourceFactory(environment).getEmbeddedDatabase();
	}
	@Order(Ordered.LOWEST_PRECEDENCE)
	static class EmbeddedDataSourceBeanFactoryPostProcessor implements BeanDefinitionRegistryPostProcessor {
		private static final ConfigurationPropertyName DATASOURCE_URL_PROPERTY = ConfigurationPropertyName
			.of('spring.datasource.url');
		private static final Bindable<String> BINDABLE_STRING = Bindable.of(String.class);
		private static final String DYNAMIC_VALUES_PROPERTY_SOURCE_CLASS = 'org.springframework.test.context.support.DynamicValuesPropertySource';
		private static final Log logger = LogFactory.getLog(EmbeddedDataSourceBeanFactoryPostProcessor.class);
		private final Environment environment;
		private final Replace replace;
		EmbeddedDataSourceBeanFactoryPostProcessor(Environment environment, Replace replace) {
			this.environment = environment;
			this.replace = replace;
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			if (AotDetector.useGeneratedArtifacts()) {
				return;
			}
			Assert.isInstanceOf(ConfigurableListableBeanFactory.class, registry,
					'Test Database Auto-configuration can only be used with a ConfigurableListableBeanFactory');
			process(registry, (ConfigurableListableBeanFactory) registry);
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
		private void process(BeanDefinitionRegistry registry, ConfigurableListableBeanFactory beanFactory) {
			BeanDefinitionHolder holder = getDataSourceBeanDefinition(beanFactory);
			if (holder != null && isReplaceable(beanFactory, holder)) {
				String beanName = holder.getBeanName();
				boolean primary = holder.getBeanDefinition().isPrimary();
				logger.info('Replacing "' + beanName + '" DataSource bean with ' + (primary ? 'primary ' : '')
						+ 'embedded version');
				registry.removeBeanDefinition(beanName);
				registry.registerBeanDefinition(beanName, createEmbeddedBeanDefinition(primary));
			}
		}
		private BeanDefinition createEmbeddedBeanDefinition(boolean primary) {
			BeanDefinition beanDefinition = new RootBeanDefinition(EmbeddedDataSourceFactoryBean.class);
			beanDefinition.setPrimary(primary);
			return beanDefinition;
		}
		private BeanDefinitionHolder getDataSourceBeanDefinition(ConfigurableListableBeanFactory beanFactory) {
			String[] beanNames = beanFactory.getBeanNamesForType(DataSource.class);
			if (ObjectUtils.isEmpty(beanNames)) {
				logger.warn('No DataSource beans found, embedded version will not be used');
				return null;
			}
			if (beanNames.length == 1) {
				String beanName = beanNames[0];
				BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
				return new BeanDefinitionHolder(beanDefinition, beanName);
			}
			for (String beanName : beanNames) {
				BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
				if (beanDefinition.isPrimary()) {
					return new BeanDefinitionHolder(beanDefinition, beanName);
				}
			}
			logger.warn('No primary DataSource found, embedded version will not be used');
			return null;
		}
		private boolean isReplaceable(ConfigurableListableBeanFactory beanFactory, BeanDefinitionHolder holder) {
			if (this.replace == Replace.NON_TEST) {
				return !isAutoConfigured(holder) || !isConnectingToTestDatabase(beanFactory);
			}
			return true;
		}
		private boolean isAutoConfigured(BeanDefinitionHolder holder) {
			if (holder.getBeanDefinition() instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {
				MethodMetadata factoryMethodMetadata = annotatedBeanDefinition.getFactoryMethodMetadata();
				return (factoryMethodMetadata != null) && (factoryMethodMetadata.getDeclaringClassName()
					.startsWith('org.springframework.boot.autoconfigure.'));
			}
			return false;
		}
		private boolean isConnectingToTestDatabase(ConfigurableListableBeanFactory beanFactory) {
			return isUsingTestServiceConnection(beanFactory) || isUsingTestDatasourceUrl();
		}
		private boolean isUsingTestServiceConnection(ConfigurableListableBeanFactory beanFactory) {
			for (String beanName : beanFactory.getBeanNamesForType(JdbcConnectionDetails.class)) {
				try {
					BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
					if (ContainerImageMetadata.isPresent(beanDefinition)) {
						return true;
					}
				}
				catch (NoSuchBeanDefinitionException ex) {
					// Ignore
				}
			}
			return false;
		}
		private boolean isUsingTestDatasourceUrl() {
			List<ConfigurationProperty> bound = new ArrayList<>();
			Binder.get(this.environment, new BoundPropertiesTrackingBindHandler(bound::add))
				.bind(DATASOURCE_URL_PROPERTY, BINDABLE_STRING);
			return !bound.isEmpty() && isUsingTestDatasourceUrl(bound.get(0));
		}
		private boolean isUsingTestDatasourceUrl(ConfigurationProperty configurationProperty) {
			return isBoundToDynamicValuesPropertySource(configurationProperty)
					|| isTestcontainersUrl(configurationProperty);
		}
		private boolean isBoundToDynamicValuesPropertySource(ConfigurationProperty configurationProperty) {
			if (configurationProperty.getOrigin() instanceof PropertySourceOrigin origin) {
				return isDynamicValuesPropertySource(origin.getPropertySource());
			}
			return false;
		}
		private boolean isDynamicValuesPropertySource(PropertySource<?> propertySource) {
			return propertySource != null
					&& DYNAMIC_VALUES_PROPERTY_SOURCE_CLASS.equals(propertySource.getClass().getName());
		}
		private boolean isTestcontainersUrl(ConfigurationProperty configurationProperty) {
			Object value = configurationProperty.getValue();
			return (value != null) && value.toString().startsWith('jdbc:tc:');
		}
	}
	static class EmbeddedDataSourceFactoryBean implements FactoryBean<DataSource>, EnvironmentAware, InitializingBean {
		private EmbeddedDataSourceFactory factory;
		private EmbeddedDatabase embeddedDatabase;
		@Override
		public void setEnvironment(Environment environment) {
			this.factory = new EmbeddedDataSourceFactory(environment);
		}
		@Override
		public void afterPropertiesSet() throws Exception {
			this.embeddedDatabase = this.factory.getEmbeddedDatabase();
		}
		@Override
		public DataSource getObject() throws Exception {
			return this.embeddedDatabase;
		}
		@Override
		public Class<?> getObjectType() {
			return EmbeddedDatabase.class;
		}
	}
	static class EmbeddedDataSourceFactory {
		private final Environment environment;
		EmbeddedDataSourceFactory(Environment environment) {
			this.environment = environment;
			if (environment instanceof ConfigurableEnvironment configurableEnvironment) {
				Map<String, Object> source = new HashMap<>();
				source.put('spring.datasource.schema-username', '');
				source.put('spring.sql.init.username', '');
				configurableEnvironment.getPropertySources().addFirst(new MapPropertySource('testDatabase', source));
			}
		}
		EmbeddedDatabase getEmbeddedDatabase() {
			EmbeddedDatabaseConnection connection = this.environment.getProperty('spring.test.database.connection',
					EmbeddedDatabaseConnection.class, EmbeddedDatabaseConnection.NONE);
			if (EmbeddedDatabaseConnection.NONE.equals(connection)) {
				connection = EmbeddedDatabaseConnection.get(getClass().getClassLoader());
			}
			Assert.state(connection != EmbeddedDatabaseConnection.NONE,
					'Failed to replace DataSource with an embedded database for tests. If '
							+ 'you want an embedded database please put a supported one '
							+ 'on the classpath or tune the replace attribute of @AutoConfigureTestDatabase.');
			return new EmbeddedDatabaseBuilder().generateUniqueName(true).setType(connection.getType()).build();
		}
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.jdbc;
/*
package org.springframework.boot.test.autoconfigure.jdbc;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@PropertyMapping('spring.test.database')
public @interface AutoConfigureTestDatabase {
	/**
	 * Determines what type of existing DataSource bean can be replaced.
	 * @return the type of existing DataSource to replace
	 */
	@PropertyMapping(skip = SkipPropertyMapping.ON_DEFAULT_VALUE)
	Replace replace() default Replace.NON_TEST;
	/**
	 * The type of connection to be established when {@link #replace() replacing} the
	 * DataSource. By default, will attempt to detect the connection based on the
	 * classpath.
	 * @return the type of connection to use
	 */
	EmbeddedDatabaseConnection connection() default EmbeddedDatabaseConnection.NONE;
	/**
	 * What the test database can replace.
	 */
	enum Replace {
		/**
		 * Replace the DataSource bean unless it is auto-configured and connecting to a
		 * test database. The following types of connections are considered test
		 * databases:
		 * <ul>
		 * <li>Any bean definition that includes {@link ContainerImageMetadata} (including
		 * {@code @ServiceConnection} annotated Testcontainer databases, and connections
		 * created using Docker Compose)</li>
		 * <li>Any connection configured using a {@code spring.datasource.url} backed by a
		 * {@link DynamicPropertySource @DynamicPropertySource}</li>
		 * <li>Any connection configured using a {@code spring.datasource.url} with the
		 * Testcontainers JDBC syntax</li>
		 * </ul>
		 * @since 3.4.0
		 */
		NON_TEST,
		/**
		 * Replace the DataSource bean whether it was auto-configured or manually defined.
		 */
		ANY,
		/**
		 * Only replace the DataSource if it was auto-configured.
		 */
		AUTO_CONFIGURED,
		/**
		 * Don"t replace the application default DataSource.
		 */
		NONE
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@AutoConfiguration
@ConditionalOnProperty(prefix = 'spring.test.webclient.mockrestserviceserver', name = 'enabled')
public class MockRestServiceServerAutoConfiguration {
	@Bean
	public MockServerRestTemplateCustomizer mockServerRestTemplateCustomizer() {
		return new MockServerRestTemplateCustomizer();
	}
	@Bean
	public MockServerRestClientCustomizer mockServerRestClientCustomizer() {
		return new MockServerRestClientCustomizer();
	}
	@Bean
	public MockRestServiceServer mockRestServiceServer(MockServerRestTemplateCustomizer restTemplateCustomizer,
			MockServerRestClientCustomizer restClientCustomizer) {
		try {
			return createDeferredMockRestServiceServer(restTemplateCustomizer, restClientCustomizer);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	private MockRestServiceServer createDeferredMockRestServiceServer(
			MockServerRestTemplateCustomizer restTemplateCustomizer,
			MockServerRestClientCustomizer restClientCustomizer) throws Exception {
		Constructor<MockRestServiceServer> constructor = MockRestServiceServer.class
			.getDeclaredConstructor(RequestExpectationManager.class);
		constructor.setAccessible(true);
		return constructor
			.newInstance(new DeferredRequestExpectationManager(restTemplateCustomizer, restClientCustomizer));
	}
	/**
	 * {@link RequestExpectationManager} with the injected {@link MockRestServiceServer}
	 * so that the bean can be created before the
	 * {@link MockServerRestTemplateCustomizer#customize(RestTemplate)
	 * MockServerRestTemplateCustomizer} has been called.
	 */
	private static class DeferredRequestExpectationManager implements RequestExpectationManager {
		private final MockServerRestTemplateCustomizer restTemplateCustomizer;
		private final MockServerRestClientCustomizer restClientCustomizer;
		DeferredRequestExpectationManager(MockServerRestTemplateCustomizer restTemplateCustomizer,
				MockServerRestClientCustomizer restClientCustomizer) {
			this.restTemplateCustomizer = restTemplateCustomizer;
			this.restClientCustomizer = restClientCustomizer;
		}
		@Override
		public ResponseActions expectRequest(ExpectedCount count, RequestMatcher requestMatcher) {
			return getDelegate().expectRequest(count, requestMatcher);
		}
		@Override
		public ClientHttpResponse validateRequest(ClientHttpRequest request) throws IOException {
			return getDelegate().validateRequest(request);
		}
		@Override
		public void verify() {
			getDelegate().verify();
		}
		@Override
		public void verify(Duration timeout) {
			getDelegate().verify(timeout);
		}
		@Override
		public void reset() {
			resetExpectations(this.restTemplateCustomizer.getExpectationManagers().values());
			resetExpectations(this.restClientCustomizer.getExpectationManagers().values());
		}
		private void resetExpectations(Collection<RequestExpectationManager> expectationManagers) {
			if (expectationManagers.size() == 1) {
				expectationManagers.iterator().next().reset();
			}
		}
		private RequestExpectationManager getDelegate() {
			Map<RestTemplate, RequestExpectationManager> restTemplateExpectationManagers = this.restTemplateCustomizer
				.getExpectationManagers();
			Map<RestClient.Builder, RequestExpectationManager> restClientExpectationManagers = this.restClientCustomizer
				.getExpectationManagers();
			boolean neitherBound = restTemplateExpectationManagers.isEmpty() && restClientExpectationManagers.isEmpty();
			boolean bothBound = !restTemplateExpectationManagers.isEmpty() && !restClientExpectationManagers.isEmpty();
			Assert.state(!neitherBound, 'Unable to use auto-configured MockRestServiceServer since '
					+ 'a mock server customizer has not been bound to a RestTemplate or RestClient');
			Assert.state(!bothBound, 'Unable to use auto-configured MockRestServiceServer since '
					+ 'mock server customizers have been bound to both a RestTemplate and a RestClient');
			if (!restTemplateExpectationManagers.isEmpty()) {
				Assert.state(restTemplateExpectationManagers.size() == 1,
						'Unable to use auto-configured MockRestServiceServer since '
								+ 'MockServerRestTemplateCustomizer has been bound to more than one RestTemplate');
				return restTemplateExpectationManagers.values().iterator().next();
			}
			Assert.state(restClientExpectationManagers.size() == 1,
					'Unable to use auto-configured MockRestServiceServer since '
							+ 'MockServerRestClientCustomizer has been bound to more than one RestClient');
			return restClientExpectationManagers.values().iterator().next();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
public final class RestClientTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<RestClientTest> {
	private static final Class<?>[] NO_COMPONENTS = {};
	private static final String DATABIND_MODULE_CLASS_NAME = 'com.fasterxml.jackson.databind.Module';
	private static final Set<Class<?>> DEFAULT_INCLUDES;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>();
		if (ClassUtils.isPresent(DATABIND_MODULE_CLASS_NAME, RestClientTypeExcludeFilter.class.getClassLoader())) {
			try {
				includes.add(Class.forName(DATABIND_MODULE_CLASS_NAME, true,
						RestClientTypeExcludeFilter.class.getClassLoader()));
			}
			catch (ClassNotFoundException ex) {
				throw new IllegalStateException('Failed to load ' + DATABIND_MODULE_CLASS_NAME, ex);
			}
			includes.add(JsonComponent.class);
		}
		DEFAULT_INCLUDES = Collections.unmodifiableSet(includes);
	}
	private final Class<?>[] components;
	RestClientTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
		this.components = getAnnotation().getValue('components', Class[].class).orElse(NO_COMPONENTS);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		return DEFAULT_INCLUDES;
	}
	@Override
	protected Set<Class<?>> getComponentIncludes() {
		return new LinkedHashSet<>(Arrays.asList(this.components));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
class RestClientTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		RestClientTest restClientTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				RestClientTest.class);
		return (restClientTest != null) ? restClientTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@PropertyMapping('spring.test.webclient.mockrestserviceserver')
public @interface AutoConfigureMockRestServiceServer {
	/**
	 * If {@link MockServerRestTemplateCustomizer} and
	 * {@link MockServerRestClientCustomizer} should be enabled and
	 * {@link MockRestServiceServer} beans should be registered. Defaults to {@code true}
	 * @return if mock support is enabled
	 */
	boolean enabled() default true;
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@AutoConfiguration(after = RestTemplateAutoConfiguration.class)
@ConditionalOnProperty(prefix = 'spring.test.webclient', name = 'register-rest-template')
public class WebClientRestTemplateAutoConfiguration {
	@Bean
	public RestTemplate restTemplate(RestTemplateBuilder builder) {
		return builder.build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigureJson
@ImportAutoConfiguration
@PropertyMapping('spring.test.webclient')
public @interface AutoConfigureWebClient {
	/**
	 * If a {@link RestTemplate} bean should be registered. Defaults to {@code false} with
	 * the assumption that the {@link RestTemplateBuilder} will be used.
	 * @return if a {@link RestTemplate} bean should be added.
	 */
	boolean registerRestTemplate() default false;
}
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(RestClientTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(RestClientTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureWebClient
@AutoConfigureMockRestServiceServer
@ImportAutoConfiguration
public @interface RestClientTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Specifies the components to test. This is an alias of {@link #components()} which
	 * can be used for brevity if no other attributes are defined. See
	 * {@link #components()} for details.
	 * @see #components()
	 * @return the components to test
	 */
	@AliasFor('components')
	Class<?>[] value() default {};
	/**
	 * Specifies the components to test. May be left blank if components will be manually
	 * imported or created directly.
	 * @see #value()
	 * @return the components to test
	 */
	@AliasFor('value')
	Class<?>[] components() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default only
	 * {@code @JsonComponent} and {@code Module} beans are included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	ComponentScan.Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	ComponentScan.Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
/**
package org.springframework.boot.test.autoconfigure.web.client;
/*
package org.springframework.boot.test.autoconfigure.web.client;
/**
class MockRestServiceServerResetTestExecutionListener extends AbstractTestExecutionListener {
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 100;
	}
	@Override
	public void afterTestMethod(TestContext testContext) throws Exception {
		ApplicationContext applicationContext = testContext.getApplicationContext();
		String[] names = applicationContext.getBeanNamesForType(MockRestServiceServer.class, false, false);
		for (String name : names) {
			applicationContext.getBean(name, MockRestServiceServer.class).reset();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@AutoConfiguration(after = MockMvcAutoConfiguration.class)
@ConditionalOnClass(WebClient.class)
@ConditionalOnProperty(prefix = 'spring.test.mockmvc.webclient', name = 'enabled', matchIfMissing = true)
public class MockMvcWebClientAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean({ WebClient.class, MockMvcWebClientBuilder.class })
	@ConditionalOnBean(MockMvc.class)
	public MockMvcWebClientBuilder mockMvcWebClientBuilder(MockMvc mockMvc, Environment environment) {
		return MockMvcWebClientBuilder.mockMvcSetup(mockMvc).withDelegate(new LocalHostWebClient(environment));
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(MockMvcWebClientBuilder.class)
	public WebClient htmlUnitWebClient(MockMvcWebClientBuilder builder) {
		return builder.build();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@AutoConfiguration(after = MockMvcAutoConfiguration.class)
@ConditionalOnClass(HtmlUnitDriver.class)
@ConditionalOnProperty(prefix = 'spring.test.mockmvc.webdriver', name = 'enabled', matchIfMissing = true)
public class MockMvcWebDriverAutoConfiguration {
	private static final String SECURITY_CONTEXT_EXECUTOR = 'org.springframework.security.concurrent.DelegatingSecurityContextExecutor';
	@Bean
	@ConditionalOnMissingBean({ WebDriver.class, MockMvcHtmlUnitDriverBuilder.class })
	@ConditionalOnBean(MockMvc.class)
	public MockMvcHtmlUnitDriverBuilder mockMvcHtmlUnitDriverBuilder(MockMvc mockMvc, Environment environment) {
		return MockMvcHtmlUnitDriverBuilder.mockMvcSetup(mockMvc)
			.withDelegate(new LocalHostWebConnectionHtmlUnitDriver(environment, BrowserVersion.CHROME));
	}
	@Bean
	@ConditionalOnMissingBean(WebDriver.class)
	@ConditionalOnBean(MockMvcHtmlUnitDriverBuilder.class)
	public HtmlUnitDriver htmlUnitDriver(MockMvcHtmlUnitDriverBuilder builder) {
		HtmlUnitDriver driver = builder.build();
		if (ClassUtils.isPresent(SECURITY_CONTEXT_EXECUTOR, getClass().getClassLoader())) {
			driver.setExecutor(new DelegatingSecurityContextExecutor(Executors.newSingleThreadExecutor()));
		}
		return driver;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(SecurityMockMvcRequestPostProcessors.class)
class MockMvcSecurityConfiguration {
	private static final String DEFAULT_SECURITY_FILTER_NAME = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME;
	@Bean
	@ConditionalOnBean(name = DEFAULT_SECURITY_FILTER_NAME)
	SecurityMockMvcBuilderCustomizer securityMockMvcBuilderCustomizer() {
		return new SecurityMockMvcBuilderCustomizer();
	}
	/**
	 * {@link MockMvcBuilderCustomizer} that ensures that requests run with the user in
	 * the {@link TestSecurityContextHolder}.
	 *
	 * @see SecurityMockMvcRequestPostProcessors#testSecurityContext
	 */
	class SecurityMockMvcBuilderCustomizer implements MockMvcBuilderCustomizer {
		@Override
		public void customize(ConfigurableMockMvcBuilder<?> builder) {
			builder.apply(new MockMvcConfigurerAdapter() {
				@Override
				public RequestPostProcessor beforeMockMvcCreated(ConfigurableMockMvcBuilder<?> builder,
						WebApplicationContext context) {
					return SecurityMockMvcRequestPostProcessors.testSecurityContext();
				}
			});
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(name = 'org.assertj.core.api.Assert')
class MockMvcTesterConfiguration {
	@Bean
	@ConditionalOnMissingBean
	MockMvcTester mockMvcTester(MockMvc mockMvc, ObjectProvider<HttpMessageConverters> httpMessageConverters) {
		MockMvcTester mockMvcTester = MockMvcTester.create(mockMvc);
		HttpMessageConverters converters = httpMessageConverters.getIfAvailable();
		if (converters != null) {
			mockMvcTester = mockMvcTester.withHttpMessageConverters(converters);
		}
		return mockMvcTester;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
public class WebDriverTestExecutionListener extends AbstractTestExecutionListener {
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 100;
	}
	@Override
	public void afterTestMethod(TestContext testContext) throws Exception {
		WebDriverScope scope = WebDriverScope.getFrom(testContext.getApplicationContext());
		if (scope != null && scope.reset()) {
			testContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE,
					Boolean.TRUE);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
class WebMvcTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected MergedContextConfiguration processMergedContextConfiguration(MergedContextConfiguration mergedConfig) {
		MergedContextConfiguration processedMergedConfiguration = super.processMergedContextConfiguration(mergedConfig);
		return new WebMergedContextConfiguration(processedMergedConfiguration, determineResourceBasePath(mergedConfig));
	}
	@Override
	protected String[] getProperties(Class<?> testClass) {
		WebMvcTest webMvcTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, WebMvcTest.class);
		return (webMvcTest != null) ? webMvcTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigureJson
@ImportAutoConfiguration
public @interface AutoConfigureWebMvc {
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@Configuration(proxyBeanMethods = false)
class MockMvcConfiguration {
	private final WebApplicationContext context;
	private final WebMvcProperties webMvcProperties;
	MockMvcConfiguration(WebApplicationContext context, WebMvcProperties webMvcProperties) {
		this.context = context;
		this.webMvcProperties = webMvcProperties;
	}
	@Bean
	@ConditionalOnMissingBean(MockMvcBuilder.class)
	DefaultMockMvcBuilder mockMvcBuilder(List<MockMvcBuilderCustomizer> customizers) {
		DefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(this.context);
		builder.addDispatcherServletCustomizer(new MockMvcDispatcherServletCustomizer(this.webMvcProperties));
		for (MockMvcBuilderCustomizer customizer : customizers) {
			customizer.customize(builder);
		}
		return builder;
	}
	@Bean
	@ConfigurationProperties(prefix = 'spring.test.mockmvc')
	SpringBootMockMvcBuilderCustomizer springBootMockMvcBuilderCustomizer() {
		return new SpringBootMockMvcBuilderCustomizer(this.context);
	}
	@Bean
	@ConditionalOnMissingBean
	MockMvc mockMvc(MockMvcBuilder builder) {
		return builder.build();
	}
	private static class MockMvcDispatcherServletCustomizer implements DispatcherServletCustomizer {
		private final WebMvcProperties webMvcProperties;
		MockMvcDispatcherServletCustomizer(WebMvcProperties webMvcProperties) {
			this.webMvcProperties = webMvcProperties;
		}
		@Override
		public void customize(DispatcherServlet dispatcherServlet) {
			dispatcherServlet.setDispatchOptionsRequest(this.webMvcProperties.isDispatchOptionsRequest());
			dispatcherServlet.setDispatchTraceRequest(this.webMvcProperties.isDispatchTraceRequest());
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
class MockMvcPrintOnlyOnFailureTestExecutionListener extends AbstractTestExecutionListener {
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 100;
	}
	@Override
	public void afterTestMethod(TestContext testContext) throws Exception {
		DeferredLinesWriter writer = DeferredLinesWriter.get(testContext.getApplicationContext());
		if (writer != null) {
			if (testContext.getTestException() != null) {
				writer.writeDeferredResult();
			}
			writer.clear();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(WebMvcTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(WebMvcTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureWebMvc
@AutoConfigureMockMvc
@ImportAutoConfiguration
public @interface WebMvcTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Specifies the controllers to test. This is an alias of {@link #controllers()} which
	 * can be used for brevity if no other attributes are defined. See
	 * {@link #controllers()} for details.
	 * @see #controllers()
	 * @return the controllers to test
	 */
	@AliasFor('controllers')
	Class<?>[] value() default {};
	/**
	 * Specifies the controllers to test. May be left blank if all {@code @Controller}
	 * beans should be added to the application context.
	 * @see #value()
	 * @return the controllers to test
	 */
	@AliasFor('value')
	Class<?>[] controllers() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default only
	 * {@code @Controller} (when no explicit {@link #controllers() controllers} are
	 * defined), {@code @ControllerAdvice} and {@code WebMvcConfigurer} beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
class WebDriverContextCustomizer implements ContextCustomizer {
	@Override
	public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
		WebDriverScope.registerWith(context);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		return obj != null && obj.getClass() == getClass();
	}
	@Override
	public int hashCode() {
		return getClass().hashCode();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
class WebDriverContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		return new WebDriverContextCustomizer();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@PropertyMapping('spring.test.mockmvc')
public @interface AutoConfigureMockMvc {
	/**
	 * If filters from the application context should be registered with MockMVC. Defaults
	 * to {@code true}.
	 * @return if filters should be added
	 */
	boolean addFilters() default true;
	/**
	 * How {@link MvcResult} information should be printed after each MockMVC invocation.
	 * @return how information is printed
	 */
	@PropertyMapping(skip = SkipPropertyMapping.ON_DEFAULT_VALUE)
	MockMvcPrint print() default MockMvcPrint.DEFAULT;
	/**
	 * If {@link MvcResult} information should be printed only if the test fails.
	 * @return {@code true} if printing only occurs on failure
	 */
	boolean printOnlyOnFailure() default true;
	/**
	 * If a {@link WebClient} should be auto-configured when HtmlUnit is on the classpath.
	 * Defaults to {@code true}.
	 * @return if a {@link WebClient} is auto-configured
	 */
	@PropertyMapping('webclient.enabled')
	boolean webClientEnabled() default true;
	/**
	 * If a {@link WebDriver} should be auto-configured when Selenium is on the classpath.
	 * Defaults to {@code true}.
	 * @return if a {@link WebDriver} is auto-configured
	 */
	@PropertyMapping('webdriver.enabled')
	boolean webDriverEnabled() default true;
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
public class WebDriverScope implements Scope {
	/**
	 * WebDriver bean scope name.
	 */
	public static final String NAME = 'webDriver';
	private static final String WEB_DRIVER_CLASS = 'org.openqa.selenium.WebDriver';
	private static final String[] BEAN_CLASSES = { WEB_DRIVER_CLASS,
			'org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilder' };
	private final Map<String, Object> instances = new HashMap<>();
	@Override
	public Object get(String name, ObjectFactory<?> objectFactory) {
		synchronized (this.instances) {
			Object instance = this.instances.get(name);
			if (instance == null) {
				instance = objectFactory.getObject();
				this.instances.put(name, instance);
			}
			return instance;
		}
	}
	@Override
	public Object remove(String name) {
		synchronized (this.instances) {
			return this.instances.remove(name);
		}
	}
	@Override
	public void registerDestructionCallback(String name, Runnable callback) {
	}
	@Override
	public Object resolveContextualObject(String key) {
		return null;
	}
	@Override
	public String getConversationId() {
		return null;
	}
	/**
	 * Reset all instances in the scope.
	 * @return {@code true} if items were reset
	 */
	boolean reset() {
		boolean reset = false;
		synchronized (this.instances) {
			for (Object instance : this.instances.values()) {
				reset = true;
				if (instance instanceof WebDriver webDriver) {
					webDriver.quit();
				}
			}
			this.instances.clear();
		}
		return reset;
	}
	/**
	 * Register this scope with the specified context and reassign appropriate bean
	 * definitions to use it.
	 * @param context the application context
	 */
	static void registerWith(ConfigurableApplicationContext context) {
		if (!ClassUtils.isPresent(WEB_DRIVER_CLASS, null)) {
			return;
		}
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		if (beanFactory.getRegisteredScope(NAME) == null) {
			beanFactory.registerScope(NAME, new WebDriverScope());
		}
		context.addBeanFactoryPostProcessor(WebDriverScope::postProcessBeanFactory);
	}
	private static void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		for (String beanClass : BEAN_CLASSES) {
			for (String beanName : beanFactory.getBeanNamesForType(ClassUtils.resolveClassName(beanClass, null))) {
				BeanDefinition definition = beanFactory.getBeanDefinition(beanName);
				if (!StringUtils.hasLength(definition.getScope())) {
					definition.setScope(NAME);
				}
			}
		}
	}
	/**
	 * Return the {@link WebDriverScope} being used by the specified context (if any).
	 * @param context the application context
	 * @return the web driver scope or {@code null}
	 */
	static WebDriverScope getFrom(ApplicationContext context) {
		if (context instanceof ConfigurableApplicationContext configurableContext) {
			Scope scope = configurableContext.getBeanFactory().getRegisteredScope(NAME);
			return (scope instanceof WebDriverScope webDriverScope) ? webDriverScope : null;
		}
		return null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
public class SpringBootMockMvcBuilderCustomizer implements MockMvcBuilderCustomizer {
	private final WebApplicationContext context;
	private boolean addFilters = true;
	private MockMvcPrint print = MockMvcPrint.DEFAULT;
	private boolean printOnlyOnFailure = true;
	/**
	 * Create a new {@link SpringBootMockMvcBuilderCustomizer} instance.
	 * @param context the source application context
	 */
	public SpringBootMockMvcBuilderCustomizer(WebApplicationContext context) {
		Assert.notNull(context, 'Context must not be null');
		this.context = context;
	}
	@Override
	public void customize(ConfigurableMockMvcBuilder<?> builder) {
		if (this.addFilters) {
			addFilters(builder);
		}
		ResultHandler printHandler = getPrintHandler();
		if (printHandler != null) {
			builder.alwaysDo(printHandler);
		}
	}
	private ResultHandler getPrintHandler() {
		LinesWriter writer = getLinesWriter();
		if (writer == null) {
			return null;
		}
		if (this.printOnlyOnFailure) {
			writer = new DeferredLinesWriter(this.context, writer);
		}
		return new LinesWritingResultHandler(writer);
	}
	private LinesWriter getLinesWriter() {
		if (this.print == MockMvcPrint.NONE) {
			return null;
		}
		if (this.print == MockMvcPrint.LOG_DEBUG) {
			return (LoggingLinesWriter.isDebugEnabled()) ? new LoggingLinesWriter() : null;
		}
		return new SystemLinesWriter(this.print);
	}
	private void addFilters(ConfigurableMockMvcBuilder<?> builder) {
		FilterRegistrationBeans registrations = new FilterRegistrationBeans(this.context);
		registrations.stream()
			.map(AbstractFilterRegistrationBean.class::cast)
			.filter(AbstractFilterRegistrationBean<?>::isEnabled)
			.forEach((registration) -> addFilter(builder, registration));
	}
	private void addFilter(ConfigurableMockMvcBuilder<?> builder, AbstractFilterRegistrationBean<?> registration) {
		Filter filter = registration.getFilter();
		Collection<String> urls = registration.getUrlPatterns();
		builder.addFilter(filter, registration.getFilterName(), registration.getInitParameters(),
				registration.determineDispatcherTypes(), StringUtils.toStringArray(urls));
	}
	public void setAddFilters(boolean addFilters) {
		this.addFilters = addFilters;
	}
	public boolean isAddFilters() {
		return this.addFilters;
	}
	public void setPrint(MockMvcPrint print) {
		this.print = print;
	}
	public MockMvcPrint getPrint() {
		return this.print;
	}
	public void setPrintOnlyOnFailure(boolean printOnlyOnFailure) {
		this.printOnlyOnFailure = printOnlyOnFailure;
	}
	public boolean isPrintOnlyOnFailure() {
		return this.printOnlyOnFailure;
	}
	/**
	 * {@link ResultHandler} that prints {@link MvcResult} details to a given
	 * {@link LinesWriter}.
	 */
	private static class LinesWritingResultHandler implements ResultHandler {
		private final LinesWriter writer;
		LinesWritingResultHandler(LinesWriter writer) {
			this.writer = writer;
		}
		@Override
		public void handle(MvcResult result) throws Exception {
			LinesPrintingResultHandler delegate = new LinesPrintingResultHandler();
			delegate.handle(result);
			delegate.write(this.writer);
		}
		private static class LinesPrintingResultHandler extends PrintingResultHandler {
			protected LinesPrintingResultHandler() {
				super(new Printer());
			}
			void write(LinesWriter writer) {
				writer.write(((Printer) getPrinter()).getLines());
			}
			private static final class Printer implements ResultValuePrinter {
				private final List<String> lines = new ArrayList<>();
				@Override
				public void printHeading(String heading) {
					this.lines.add('');
					this.lines.add(String.format('%s:', heading));
				}
				@Override
				public void printValue(String label, Object value) {
					if (value != null && value.getClass().isArray()) {
						value = CollectionUtils.arrayToList(value);
					}
					try {
						this.lines.add('%17s = %s'.formatted(label, value));
					}
					catch (RuntimeException ex) {
						this.lines.add('%17s = << Exception "%s" occurred while formatting >>'.formatted(label, ex));
					}
				}
				List<String> getLines() {
					return this.lines;
				}
			}
		}
	}
	/**
	 * Strategy interface to write MVC result lines.
	 */
	interface LinesWriter {
		void write(List<String> lines);
	}
	/**
	 * {@link LinesWriter} used to defer writing until errors are detected.
	 *
	 * @see MockMvcPrintOnlyOnFailureTestExecutionListener
	 */
	static class DeferredLinesWriter implements LinesWriter {
		private static final String BEAN_NAME = DeferredLinesWriter.class.getName();
		private final LinesWriter delegate;
		private final ThreadLocal<List<String>> lines = ThreadLocal.withInitial(ArrayList::new);
		DeferredLinesWriter(WebApplicationContext context, LinesWriter delegate) {
			Assert.state(context instanceof ConfigurableApplicationContext,
					'A ConfigurableApplicationContext is required for printOnlyOnFailure');
			((ConfigurableApplicationContext) context).getBeanFactory().registerSingleton(BEAN_NAME, this);
			this.delegate = delegate;
		}
		@Override
		public void write(List<String> lines) {
			this.lines.get().addAll(lines);
		}
		void writeDeferredResult() {
			this.delegate.write(this.lines.get());
		}
		static DeferredLinesWriter get(ApplicationContext applicationContext) {
			try {
				return applicationContext.getBean(BEAN_NAME, DeferredLinesWriter.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				return null;
			}
		}
		void clear() {
			this.lines.remove();
		}
	}
	/**
	 * {@link LinesWriter} to output results to the log.
	 */
	private static final class LoggingLinesWriter implements LinesWriter {
		private static final Log logger = LogFactory.getLog('org.springframework.test.web.servlet.result');
		@Override
		public void write(List<String> lines) {
			if (logger.isDebugEnabled()) {
				StringWriter stringWriter = new StringWriter();
				PrintWriter printWriter = new PrintWriter(stringWriter);
				for (String line : lines) {
					printWriter.println(line);
				}
				logger.debug('MvcResult details:\n' + stringWriter);
			}
		}
		static boolean isDebugEnabled() {
			return logger.isDebugEnabled();
		}
	}
	/**
	 * {@link LinesWriter} to output results to {@code System.out} or {@code System.err}.
	 */
	private static class SystemLinesWriter implements LinesWriter {
		private final MockMvcPrint print;
		SystemLinesWriter(MockMvcPrint print) {
			this.print = print;
		}
		@Override
		public void write(List<String> lines) {
			PrintStream printStream = getPrintStream();
			for (String line : lines) {
				printStream.println(line);
			}
		}
		private PrintStream getPrintStream() {
			if (this.print == MockMvcPrint.SYSTEM_ERR) {
				return System.err;
			}
			return System.out;
		}
	}
	private static class FilterRegistrationBeans extends ServletContextInitializerBeans {
		FilterRegistrationBeans(ListableBeanFactory beanFactory) {
			super(beanFactory, FilterRegistrationBean.class, DelegatingFilterProxyRegistrationBean.class);
		}
		@Override
		protected void addAdaptableBeans(ListableBeanFactory beanFactory) {
			addAsRegistrationBean(beanFactory, Filter.class, new FilterRegistrationBeanAdapter());
		}
		private static final class FilterRegistrationBeanAdapter implements RegistrationBeanAdapter<Filter> {
			@Override
			public RegistrationBean createRegistrationBean(String name, Filter source, int totalNumberOfSourceBeans) {
				FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>(source);
				bean.setName(name);
				return bean;
			}
		}
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.web.servlet;
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@FunctionalInterface
public interface MockMvcBuilderCustomizer {
	/**
	 * Customize the given {@code builder}.
	 * @param builder the builder
	 */
	void customize(ConfigurableMockMvcBuilder<?> builder);
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
public final class WebMvcTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<WebMvcTest> {
	private static final Class<?>[] NO_CONTROLLERS = {};
	private static final String[] OPTIONAL_INCLUDES = { 'com.fasterxml.jackson.databind.Module',
			'org.springframework.security.config.annotation.web.WebSecurityConfigurer',
			'org.springframework.security.web.SecurityFilterChain', 'org.thymeleaf.dialect.IDialect' };
	private static final Set<Class<?>> DEFAULT_INCLUDES;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>();
		includes.add(ControllerAdvice.class);
		includes.add(JsonComponent.class);
		includes.add(WebMvcConfigurer.class);
		includes.add(WebMvcRegistrations.class);
		includes.add(jakarta.servlet.Filter.class);
		includes.add(FilterRegistrationBean.class);
		includes.add(DelegatingFilterProxyRegistrationBean.class);
		includes.add(HandlerMethodArgumentResolver.class);
		includes.add(HttpMessageConverter.class);
		includes.add(ErrorAttributes.class);
		includes.add(Converter.class);
		includes.add(GenericConverter.class);
		includes.add(HandlerInterceptor.class);
		for (String optionalInclude : OPTIONAL_INCLUDES) {
			try {
				includes.add(ClassUtils.forName(optionalInclude, null));
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		DEFAULT_INCLUDES = Collections.unmodifiableSet(includes);
	}
	private static final Set<Class<?>> DEFAULT_INCLUDES_AND_CONTROLLER;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>(DEFAULT_INCLUDES);
		includes.add(Controller.class);
		DEFAULT_INCLUDES_AND_CONTROLLER = Collections.unmodifiableSet(includes);
	}
	private final Class<?>[] controllers;
	WebMvcTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
		this.controllers = getAnnotation().getValue('controllers', Class[].class).orElse(NO_CONTROLLERS);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		if (ObjectUtils.isEmpty(this.controllers)) {
			return DEFAULT_INCLUDES_AND_CONTROLLER;
		}
		return DEFAULT_INCLUDES;
	}
	@Override
	protected Set<Class<?>> getComponentIncludes() {
		return new LinkedHashSet<>(Arrays.asList(this.controllers));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
public enum MockMvcPrint {
	/**
	 * Use the default print setting ({@code MockMvcPrint.SYSTEM_OUT} unless explicitly
	 * overridden).
	 */
	DEFAULT,
	/**
	 * Log MVC interactions at the {@code DEBUG} level.
	 */
	LOG_DEBUG,
	/**
	 * Print MVC interactions to {@code System.out}.
	 */
	SYSTEM_OUT,
	/**
	 * Print MVC interactions to {@code System.err}.
	 */
	SYSTEM_ERR,
	/**
	 * Do not print MVC interactions.
	 */
	NONE
}
/*
package org.springframework.boot.test.autoconfigure.web.servlet;
/**
@AutoConfiguration(after = { WebMvcAutoConfiguration.class, WebTestClientAutoConfiguration.class })
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties({ ServerProperties.class, WebMvcProperties.class })
@Import({ MockMvcConfiguration.class, MockMvcTesterConfiguration.class })
public class MockMvcAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public DispatcherServletPath dispatcherServletPath(WebMvcProperties webMvcProperties) {
		return () -> webMvcProperties.getServlet().getPath();
	}
	@Bean
	@ConditionalOnMissingBean
	public DispatcherServlet dispatcherServlet(MockMvc mockMvc) {
		return mockMvc.getDispatcherServlet();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ WebClient.class, WebTestClient.class })
	static class WebTestClientMockMvcConfiguration {
		@Bean
		@ConditionalOnMissingBean
		WebTestClient webTestClient(MockMvc mockMvc, List<WebTestClientBuilderCustomizer> customizers) {
			WebTestClient.Builder builder = MockMvcWebTestClient.bindTo(mockMvc);
			for (WebTestClientBuilderCustomizer customizer : customizers) {
				customizer.customize(builder);
			}
			return builder.build();
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
public final class WebFluxTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<WebFluxTest> {
	private static final Class<?>[] NO_CONTROLLERS = {};
	private static final String[] OPTIONAL_INCLUDES = { 'com.fasterxml.jackson.databind.Module',
			'org.thymeleaf.dialect.IDialect' };
	private static final Set<Class<?>> DEFAULT_INCLUDES;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>();
		includes.add(ControllerAdvice.class);
		includes.add(JsonComponent.class);
		includes.add(WebFluxConfigurer.class);
		includes.add(Converter.class);
		includes.add(GenericConverter.class);
		includes.add(WebExceptionHandler.class);
		includes.add(WebFilter.class);
		for (String optionalInclude : OPTIONAL_INCLUDES) {
			try {
				includes.add(ClassUtils.forName(optionalInclude, null));
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		DEFAULT_INCLUDES = Collections.unmodifiableSet(includes);
	}
	private static final Set<Class<?>> DEFAULT_INCLUDES_AND_CONTROLLER;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>(DEFAULT_INCLUDES);
		includes.add(Controller.class);
		DEFAULT_INCLUDES_AND_CONTROLLER = Collections.unmodifiableSet(includes);
	}
	private final Class<?>[] controllers;
	WebFluxTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
		this.controllers = getAnnotation().getValue('controllers', Class[].class).orElse(NO_CONTROLLERS);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		if (ObjectUtils.isEmpty(this.controllers)) {
			return DEFAULT_INCLUDES_AND_CONTROLLER;
		}
		return DEFAULT_INCLUDES;
	}
	@Override
	protected Set<Class<?>> getComponentIncludes() {
		return new LinkedHashSet<>(Arrays.asList(this.controllers));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
public class SpringBootWebTestClientBuilderCustomizer implements WebTestClientBuilderCustomizer {
	private final Collection<CodecCustomizer> codecCustomizers;
	private Duration timeout;
	/**
	 * Create a new {@code SpringBootWebTestClientBuilderCustomizer} that will configure
	 * the builder"s codecs using the given {@code codecCustomizers}.
	 * @param codecCustomizers the codec customizers
	 */
	public SpringBootWebTestClientBuilderCustomizer(Collection<CodecCustomizer> codecCustomizers) {
		this.codecCustomizers = codecCustomizers;
	}
	public void setTimeout(Duration timeout) {
		this.timeout = timeout;
	}
	@Override
	public void customize(Builder builder) {
		if (this.timeout != null) {
			builder.responseTimeout(this.timeout);
		}
		customizeWebTestClientCodecs(builder);
	}
	private void customizeWebTestClientCodecs(WebTestClient.Builder builder) {
		if (!CollectionUtils.isEmpty(this.codecCustomizers)) {
			builder.exchangeStrategies(
					ExchangeStrategies.builder().codecs(applyCustomizers(this.codecCustomizers)).build());
		}
	}
	private Consumer<ClientCodecConfigurer> applyCustomizers(Collection<CodecCustomizer> customizers) {
		return (codecs) -> customizers.forEach((customizer) -> customizer.customize(codecs));
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(SecurityMockServerConfigurers.class)
class WebTestClientSecurityConfiguration {
	@Bean
	MockServerConfigurer mockServerConfigurer() {
		return SecurityMockServerConfigurers.springSecurity();
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
@AutoConfiguration(after = { CodecsAutoConfiguration.class, WebFluxAutoConfiguration.class })
@ConditionalOnClass({ WebClient.class, WebTestClient.class })
@Import(WebTestClientSecurityConfiguration.class)
@EnableConfigurationProperties
public class WebTestClientAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(WebHandler.class)
	public WebTestClient webTestClient(ApplicationContext applicationContext,
			List<WebTestClientBuilderCustomizer> customizers, List<MockServerConfigurer> configurers) {
		WebTestClient.MockServerSpec<?> mockServerSpec = WebTestClient.bindToApplicationContext(applicationContext);
		for (MockServerConfigurer configurer : configurers) {
			mockServerSpec.apply(configurer);
		}
		WebTestClient.Builder builder = mockServerSpec.configureClient();
		for (WebTestClientBuilderCustomizer customizer : customizers) {
			customizer.customize(builder);
		}
		return builder.build();
	}
	@Bean
	@ConfigurationProperties(prefix = 'spring.test.webtestclient')
	public SpringBootWebTestClientBuilderCustomizer springBootWebTestClientBuilderCustomizer(
			ObjectProvider<CodecCustomizer> codecCustomizers) {
		return new SpringBootWebTestClientBuilderCustomizer(codecCustomizers.orderedStream().toList());
	}
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@PropertyMapping('spring.test.webtestclient')
public @interface AutoConfigureWebTestClient {
	/**
	 * The timeout duration for the client (in any format handled by
	 * {@link Duration#parse(CharSequence)}).
	 * @return the web client timeout
	 */
	String timeout() default '';
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureWebFlux {
}
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
class WebFluxTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected MergedContextConfiguration processMergedContextConfiguration(MergedContextConfiguration mergedConfig) {
		return new ReactiveWebMergedContextConfiguration(super.processMergedContextConfiguration(mergedConfig));
	}
	@Override
	protected String[] getProperties(Class<?> testClass) {
		WebFluxTest webFluxTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, WebFluxTest.class);
		return (webFluxTest != null) ? webFluxTest.properties() : null;
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.web.reactive;
/*
package org.springframework.boot.test.autoconfigure.web.reactive;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(WebFluxTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(WebFluxTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureJson
@AutoConfigureWebFlux
@AutoConfigureWebTestClient
@ImportAutoConfiguration
public @interface WebFluxTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Specifies the controllers to test. This is an alias of {@link #controllers()} which
	 * can be used for brevity if no other attributes are defined. See
	 * {@link #controllers()} for details.
	 * @see #controllers()
	 * @return the controllers to test
	 */
	@AliasFor('controllers')
	Class<?>[] value() default {};
	/**
	 * Specifies the controllers to test. May be left blank if all {@code @Controller}
	 * beans should be added to the application context.
	 * @see #value()
	 * @return the controllers to test
	 */
	@AliasFor('value')
	Class<?>[] controllers() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default only
	 * {@code @Controller} (when no explicit {@link #controllers() controllers} are
	 * defined), {@code @ControllerAdvice} and {@code WebFluxConfigurer} beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	ComponentScan.Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	ComponentScan.Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.actuate.observability;
/**
class ObservabilityContextCustomizerFactory implements ContextCustomizerFactory {
	static final String AUTO_CONFIGURE_PROPERTY = 'spring.test.observability.auto-configure';
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		AutoConfigureObservability annotation = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				AutoConfigureObservability.class);
		return new DisableObservabilityContextCustomizer(annotation);
	}
	private static class DisableObservabilityContextCustomizer implements ContextCustomizer {
		private final AutoConfigureObservability annotation;
		DisableObservabilityContextCustomizer(AutoConfigureObservability annotation) {
			this.annotation = annotation;
		}
		@Override
		public void customizeContext(ConfigurableApplicationContext context,
				MergedContextConfiguration mergedContextConfiguration) {
			if (areMetricsDisabled(context.getEnvironment())) {
				TestPropertyValues
					.of('management.defaults.metrics.export.enabled=false',
							'management.simple.metrics.export.enabled=true')
					.applyTo(context);
			}
			if (isTracingDisabled(context.getEnvironment())) {
				TestPropertyValues.of('management.tracing.enabled=false').applyTo(context);
			}
		}
		private boolean areMetricsDisabled(Environment environment) {
			if (this.annotation != null) {
				return !this.annotation.metrics();
			}
			return !environment.getProperty(AUTO_CONFIGURE_PROPERTY, Boolean.class, false);
		}
		private boolean isTracingDisabled(Environment environment) {
			if (this.annotation != null) {
				return !this.annotation.tracing();
			}
			return !environment.getProperty(AUTO_CONFIGURE_PROPERTY, Boolean.class, false);
		}
		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (o == null || getClass() != o.getClass()) {
				return false;
			}
			DisableObservabilityContextCustomizer that = (DisableObservabilityContextCustomizer) o;
			return Objects.equals(this.annotation, that.annotation);
		}
		@Override
		public int hashCode() {
			return Objects.hash(this.annotation);
		}
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.actuate.observability;
/*
package org.springframework.boot.test.autoconfigure.actuate.observability;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureObservability {
	/**
	 * Whether metrics should be reported to external systems in the test.
	 * @return whether metrics should be reported to external systems in the test
	 */
	boolean metrics() default true;
	/**
	 * Whether traces should be reported to external systems in the test.
	 * @return whether traces should be reported to external systems in the test
	 */
	boolean tracing() default true;
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
class PropertyMappingContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configurationAttributes) {
		AnnotationsPropertySource propertySource = new AnnotationsPropertySource(testClass);
		return new PropertyMappingContextCustomizer(propertySource);
	}
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
public enum SkipPropertyMapping {
	/**
	 * Skip mapping the property.
	 */
	YES,
	/**
	 * Skip mapping the property when the default attribute value is specified.
	 */
	ON_DEFAULT_VALUE,
	/**
	 * Don"t skip mapping the property.
	 */
	NO
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
class PropertyMappingContextCustomizer implements ContextCustomizer {
	private final AnnotationsPropertySource propertySource;
	PropertyMappingContextCustomizer(AnnotationsPropertySource propertySource) {
		this.propertySource = propertySource;
	}
	@Override
	public void customizeContext(ConfigurableApplicationContext context,
			MergedContextConfiguration mergedContextConfiguration) {
		if (!this.propertySource.isEmpty()) {
			context.getEnvironment().getPropertySources().addFirst(this.propertySource);
		}
		context.getBeanFactory()
			.registerSingleton(PropertyMappingCheckBeanPostProcessor.class.getName(),
					new PropertyMappingCheckBeanPostProcessor());
	}
	@Override
	public boolean equals(Object obj) {
		return (obj != null) && (getClass() == obj.getClass())
				&& this.propertySource.equals(((PropertyMappingContextCustomizer) obj).propertySource);
	}
	@Override
	public int hashCode() {
		return this.propertySource.hashCode();
	}
	/**
	 * {@link BeanPostProcessor} to check that {@link PropertyMapping @PropertyMapping} is
	 * only used on test classes.
	 */
	static class PropertyMappingCheckBeanPostProcessor implements BeanPostProcessor {
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
			Class<?> beanClass = bean.getClass();
			MergedAnnotations annotations = MergedAnnotations.from(beanClass, SearchStrategy.SUPERCLASS);
			Set<Class<?>> components = annotations.stream(Component.class)
				.map(this::getRoot)
				.collect(Collectors.toSet());
			Set<Class<?>> propertyMappings = annotations.stream(PropertyMapping.class)
				.map(this::getRoot)
				.collect(Collectors.toSet());
			if (!components.isEmpty() && !propertyMappings.isEmpty()) {
				throw new IllegalStateException('The @PropertyMapping ' + getAnnotationsDescription(propertyMappings)
						+ ' cannot be used in combination with the @Component '
						+ getAnnotationsDescription(components));
			}
			return bean;
		}
		private Class<?> getRoot(MergedAnnotation<?> annotation) {
			return annotation.getRoot().getType();
		}
		private String getAnnotationsDescription(Set<Class<?>> annotations) {
			StringBuilder result = new StringBuilder();
			for (Class<?> annotation : annotations) {
				if (!result.isEmpty()) {
					result.append(', ');
				}
				result.append("@").append(ClassUtils.getShortName(annotation));
			}
			result.insert(0, (annotations.size() != 1) ? 'annotations ' : 'annotation ');
			return result.toString();
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			return bean;
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
public class AnnotationsPropertySource extends EnumerablePropertySource<Class<?>> {
	private static final Pattern CAMEL_CASE_PATTERN = Pattern.compile('([^A-Z-])([A-Z])');
	private final Map<String, Object> properties;
	public AnnotationsPropertySource(Class<?> source) {
		this('Annotations', source);
	}
	public AnnotationsPropertySource(String name, Class<?> source) {
		super(name, source);
		this.properties = getProperties(source);
	}
	private Map<String, Object> getProperties(Class<?> source) {
		Map<String, Object> properties = new LinkedHashMap<>();
		getProperties(source, properties);
		return properties;
	}
	private void getProperties(Class<?> source, Map<String, Object> properties) {
		MergedAnnotations.from(source, SearchStrategy.SUPERCLASS)
			.stream()
			.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getType))
			.forEach((annotation) -> {
				Class<Annotation> type = annotation.getType();
				MergedAnnotation<?> typeMapping = MergedAnnotations.from(type)
					.get(PropertyMapping.class, MergedAnnotation::isDirectlyPresent);
				String prefix = typeMapping.getValue(MergedAnnotation.VALUE, String.class).orElse('');
				SkipPropertyMapping defaultSkip = typeMapping.getValue('skip', SkipPropertyMapping.class)
					.orElse(SkipPropertyMapping.YES);
				for (Method attribute : type.getDeclaredMethods()) {
					collectProperties(prefix, defaultSkip, annotation, attribute, properties);
				}
			});
		if (TestContextAnnotationUtils.searchEnclosingClass(source)) {
			getProperties(source.getEnclosingClass(), properties);
		}
	}
	private void collectProperties(String prefix, SkipPropertyMapping skip, MergedAnnotation<?> annotation,
			Method attribute, Map<String, Object> properties) {
		MergedAnnotation<?> attributeMapping = MergedAnnotations.from(attribute).get(PropertyMapping.class);
		skip = attributeMapping.getValue('skip', SkipPropertyMapping.class).orElse(skip);
		if (skip == SkipPropertyMapping.YES) {
			return;
		}
		Optional<Object> value = annotation.getValue(attribute.getName());
		if (value.isEmpty()) {
			return;
		}
		if (skip == SkipPropertyMapping.ON_DEFAULT_VALUE) {
			if (ObjectUtils.nullSafeEquals(value.get(), annotation.getDefaultValue(attribute.getName()).orElse(null))) {
				return;
			}
		}
		String name = getName(prefix, attributeMapping, attribute);
		putProperties(name, skip, value.get(), properties);
	}
	private String getName(String prefix, MergedAnnotation<?> attributeMapping, Method attribute) {
		String name = attributeMapping.getValue(MergedAnnotation.VALUE, String.class).orElse('');
		if (!StringUtils.hasText(name)) {
			name = toKebabCase(attribute.getName());
		}
		return dotAppend(prefix, name);
	}
	private String toKebabCase(String name) {
		Matcher matcher = CAMEL_CASE_PATTERN.matcher(name);
		StringBuilder result = new StringBuilder();
		while (matcher.find()) {
			matcher.appendReplacement(result, matcher.group(1) + "-" + StringUtils.uncapitalize(matcher.group(2)));
		}
		matcher.appendTail(result);
		return result.toString().toLowerCase(Locale.ENGLISH);
	}
	private String dotAppend(String prefix, String postfix) {
		if (StringUtils.hasText(prefix)) {
			return prefix.endsWith('.') ? prefix + postfix : prefix + '.' + postfix;
		}
		return postfix;
	}
	private void putProperties(String name, SkipPropertyMapping defaultSkip, Object value,
			Map<String, Object> properties) {
		if (ObjectUtils.isArray(value)) {
			Object[] array = ObjectUtils.toObjectArray(value);
			for (int i = 0; i < array.length; i++) {
				putProperties(name + '[' + i + ']', defaultSkip, array[i], properties);
			}
		}
		else if (value instanceof MergedAnnotation<?> annotation) {
			for (Method attribute : annotation.getType().getDeclaredMethods()) {
				collectProperties(name, defaultSkip, (MergedAnnotation<?>) value, attribute, properties);
			}
		}
		else {
			properties.put(name, value);
		}
	}
	@Override
	public boolean containsProperty(String name) {
		return this.properties.containsKey(name);
	}
	@Override
	public Object getProperty(String name) {
		return this.properties.get(name);
	}
	@Override
	public String[] getPropertyNames() {
		return StringUtils.toStringArray(this.properties.keySet());
	}
	public boolean isEmpty() {
		return this.properties.isEmpty();
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.properties.equals(((AnnotationsPropertySource) obj).properties);
	}
	@Override
	public int hashCode() {
		return this.properties.hashCode();
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.properties;
/*
package org.springframework.boot.test.autoconfigure.properties;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
public @interface PropertyMapping {
	/**
	 * Defines the property mapping. When used at the type-level, this value will be used
	 * as a prefix for all mapped attributes. When used on an attribute, the value
	 * overrides the generated (kebab case) name.
	 * @return the property mapping
	 */
	String value() default '';
	/**
	 * Determines if mapping should be skipped. When specified at the type-level indicates
	 * if skipping should occur by default or not. When used at the attribute-level,
	 * overrides the type-level default.
	 * @return if mapping should be skipped
	 */
	SkipPropertyMapping skip() default SkipPropertyMapping.NO;
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
public final class DataJdbcTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataJdbcTest> {
	private static final Set<Class<?>> DEFAULT_INCLUDES = Collections.singleton(AbstractJdbcConfiguration.class);
	DataJdbcTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		return DEFAULT_INCLUDES;
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.jdbc;
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataJdbcTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataJdbcTypeExcludeFilter.class)
@Transactional
@AutoConfigureCache
@AutoConfigureDataJdbc
@AutoConfigureTestDatabase
@ImportAutoConfiguration
public @interface DataJdbcTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default, only
	 * {@code AbstractJdbcConfiguration} beans are included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
class DataJdbcTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataJdbcTest dataJdbcTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, DataJdbcTest.class);
		return (dataJdbcTest != null) ? dataJdbcTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.jdbc;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataJdbc {
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataCassandraTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataCassandraTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureDataCassandra
@ImportAutoConfiguration
public @interface DataCassandraTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataCassandra {
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
class DataCassandraTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataCassandraTest> {
	DataCassandraTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.cassandra;
/**
class DataCassandraTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataCassandraTest dataCassandraTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				DataCassandraTest.class);
		return (dataCassandraTest != null) ? dataCassandraTest.properties() : null;
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.cassandra;
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataCouchbase {
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
class DataCouchbaseTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataCouchbaseTest> {
	DataCouchbaseTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataCouchbaseTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataCouchbaseTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureDataCouchbase
@ImportAutoConfiguration
public @interface DataCouchbaseTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.data.couchbase;
/**
class DataCouchbaseTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataCouchbaseTest dataCouchbaseTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				DataCouchbaseTest.class);
		return (dataCouchbaseTest != null) ? dataCouchbaseTest.properties() : null;
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.couchbase;
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
public final class DataNeo4jTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataNeo4jTest> {
	DataNeo4jTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataNeo4jTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataNeo4jTypeExcludeFilter.class)
@Transactional
@AutoConfigureCache
@AutoConfigureDataNeo4j
@ImportAutoConfiguration
public @interface DataNeo4jTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataNeo4j {
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.neo4j;
/*
package org.springframework.boot.test.autoconfigure.data.neo4j;
/**
class DataNeo4jTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataNeo4jTest dataNeo4jTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, DataNeo4jTest.class);
		return (dataNeo4jTest != null) ? dataNeo4jTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
class DataElasticsearchTypeExcludeFilter
		extends StandardAnnotationCustomizableTypeExcludeFilter<DataElasticsearchTest> {
	DataElasticsearchTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataElasticsearch {
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
class DataElasticsearchTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataElasticsearchTest dataElasticsearchTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				DataElasticsearchTest.class);
		return (dataElasticsearchTest != null) ? dataElasticsearchTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataElasticsearchTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataElasticsearchTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureDataElasticsearch
@ImportAutoConfiguration
public @interface DataElasticsearchTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.elasticsearch;
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
public final class DataRedisTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataRedisTest> {
	DataRedisTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataRedis {
}
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataRedisTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataRedisTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureDataRedis
@ImportAutoConfiguration
public @interface DataRedisTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.redis;
/*
package org.springframework.boot.test.autoconfigure.data.redis;
/**
class DataRedisTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataRedisTest dataRedisTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, DataRedisTest.class);
		return (dataRedisTest != null) ? dataRedisTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataR2dbc {
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
class DataR2dbcTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataR2dbcTest> {
	DataR2dbcTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
class DataR2dbcTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataR2dbcTest dataR2dbcTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, DataR2dbcTest.class);
		return (dataR2dbcTest != null) ? dataR2dbcTest.properties() : null;
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/*
package org.springframework.boot.test.autoconfigure.data.r2dbc;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataR2dbcTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataR2dbcTypeExcludeFilter.class)
@AutoConfigureDataR2dbc
@ImportAutoConfiguration
public @interface DataR2dbcTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
public final class DataLdapTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataLdapTest> {
	DataLdapTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataLdap {
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
class DataLdapTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataLdapTest dataLdapTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, DataLdapTest.class);
		return (dataLdapTest != null) ? dataLdapTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.ldap;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataLdapTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataLdapTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureDataLdap
@ImportAutoConfiguration
public @interface DataLdapTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.ldap;
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataMongo {
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
class DataMongoTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		DataMongoTest dataMongoTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, DataMongoTest.class);
		return (dataMongoTest != null) ? dataMongoTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataMongoTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataMongoTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureDataMongo
@ImportAutoConfiguration
public @interface DataMongoTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.data.mongo;
/**
public final class DataMongoTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataMongoTest> {
	DataMongoTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.data.mongo;
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@AutoConfiguration
@ConditionalOnWebApplication
public class RestDocsAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(MockMvcRestDocumentation.class)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	@EnableConfigurationProperties(RestDocsProperties.class)
	static class RestDocsMockMvcConfiguration {
		@Bean
		@ConditionalOnMissingBean
		MockMvcRestDocumentationConfigurer restDocsMockMvcConfigurer(
				ObjectProvider<RestDocsMockMvcConfigurationCustomizer> configurationCustomizers,
				RestDocumentationContextProvider contextProvider) {
			MockMvcRestDocumentationConfigurer configurer = MockMvcRestDocumentation
				.documentationConfiguration(contextProvider);
			configurationCustomizers.orderedStream()
				.forEach((configurationCustomizer) -> configurationCustomizer.customize(configurer));
			return configurer;
		}
		@Bean
		RestDocsMockMvcBuilderCustomizer restDocumentationConfigurer(RestDocsProperties properties,
				MockMvcRestDocumentationConfigurer configurer,
				ObjectProvider<RestDocumentationResultHandler> resultHandler) {
			return new RestDocsMockMvcBuilderCustomizer(properties, configurer, resultHandler.getIfAvailable());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ RequestSpecification.class, RestAssuredRestDocumentation.class })
	@EnableConfigurationProperties(RestDocsProperties.class)
	static class RestDocsRestAssuredConfiguration {
		@Bean
		@ConditionalOnMissingBean
		RequestSpecification restDocsRestAssuredConfigurer(
				ObjectProvider<RestDocsRestAssuredConfigurationCustomizer> configurationCustomizers,
				RestDocumentationContextProvider contextProvider) {
			RestAssuredRestDocumentationConfigurer configurer = RestAssuredRestDocumentation
				.documentationConfiguration(contextProvider);
			configurationCustomizers.orderedStream()
				.forEach((configurationCustomizer) -> configurationCustomizer.customize(configurer));
			return new RequestSpecBuilder().addFilter(configurer).build();
		}
		@Bean
		RestDocsRestAssuredBuilderCustomizer restAssuredBuilderCustomizer(RestDocsProperties properties,
				RequestSpecification configurer) {
			return new RestDocsRestAssuredBuilderCustomizer(properties, configurer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(WebTestClientRestDocumentation.class)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	@EnableConfigurationProperties(RestDocsProperties.class)
	static class RestDocsWebTestClientConfiguration {
		@Bean
		@ConditionalOnMissingBean
		WebTestClientRestDocumentationConfigurer restDocsWebTestClientConfigurer(
				ObjectProvider<RestDocsWebTestClientConfigurationCustomizer> configurationCustomizers,
				RestDocumentationContextProvider contextProvider) {
			WebTestClientRestDocumentationConfigurer configurer = WebTestClientRestDocumentation
				.documentationConfiguration(contextProvider);
			configurationCustomizers.orderedStream()
				.forEach((configurationCustomizer) -> configurationCustomizer.customize(configurer));
			return configurer;
		}
		@Bean
		RestDocsWebTestClientBuilderCustomizer restDocumentationConfigurer(RestDocsProperties properties,
				WebTestClientRestDocumentationConfigurer configurer) {
			return new RestDocsWebTestClientBuilderCustomizer(properties, configurer);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@ConfigurationProperties('spring.test.restdocs')
public class RestDocsProperties {
	/**
	 * The URI scheme for to use (for example http).
	 */
	private String uriScheme;
	/**
	 * The URI host to use.
	 */
	private String uriHost;
	/**
	 * The URI port to use.
	 */
	private Integer uriPort;
	public String getUriScheme() {
		return this.uriScheme;
	}
	public void setUriScheme(String uriScheme) {
		this.uriScheme = uriScheme;
	}
	public String getUriHost() {
		return this.uriHost;
	}
	public void setUriHost(String uriHost) {
		this.uriHost = uriHost;
	}
	public Integer getUriPort() {
		return this.uriPort;
	}
	public void setUriPort(Integer uriPort) {
		this.uriPort = uriPort;
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
public class RestDocsMockMvcBuilderCustomizer implements InitializingBean, MockMvcBuilderCustomizer {
	private final RestDocsProperties properties;
	private final MockMvcRestDocumentationConfigurer delegate;
	private final RestDocumentationResultHandler resultHandler;
	RestDocsMockMvcBuilderCustomizer(RestDocsProperties properties, MockMvcRestDocumentationConfigurer delegate,
			RestDocumentationResultHandler resultHandler) {
		this.properties = properties;
		this.delegate = delegate;
		this.resultHandler = resultHandler;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		PropertyMapper map = PropertyMapper.get();
		RestDocsProperties properties = this.properties;
		UriConfigurer uri = this.delegate.uris();
		map.from(properties::getUriScheme).whenHasText().to(uri::withScheme);
		map.from(properties::getUriHost).whenHasText().to(uri::withHost);
		map.from(properties::getUriPort).whenNonNull().to(uri::withPort);
	}
	@Override
	public void customize(ConfigurableMockMvcBuilder<?> builder) {
		builder.apply(this.delegate);
		if (this.resultHandler != null) {
			builder.alwaysDo(this.resultHandler);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
class RestDocsRestAssuredBuilderCustomizer implements InitializingBean {
	private final RestDocsProperties properties;
	private final RequestSpecification delegate;
	RestDocsRestAssuredBuilderCustomizer(RestDocsProperties properties, RequestSpecification delegate) {
		this.properties = properties;
		this.delegate = delegate;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		PropertyMapper map = PropertyMapper.get();
		String host = this.properties.getUriHost();
		map.from(this.properties::getUriScheme)
			.when((scheme) -> StringUtils.hasText(scheme) && StringUtils.hasText(host))
			.to((scheme) -> this.delegate.baseUri(scheme + '://' + host));
		map.from(this.properties::getUriPort).whenNonNull().to(this.delegate::port);
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@Import(RestDocumentationContextProviderRegistrar.class)
@PropertyMapping('spring.test.restdocs')
public @interface AutoConfigureRestDocs {
	/**
	 * The output directory to which generated snippets will be written. An alias for
	 * {@link #outputDir}.
	 * @return the output directory
	 */
	@AliasFor('outputDir')
	String value() default '';
	/**
	 * The output directory to which generated snippets will be written. An alias for
	 * {@link #value}.
	 * @return the output directory
	 */
	@AliasFor('value')
	String outputDir() default '';
	/**
	 * The scheme (typically {@code http} or {@code https}) to be used in documented URIs.
	 * Defaults to {@code http}.
	 * @return the scheme
	 */
	String uriScheme() default 'http';
	/**
	 * The host to be used in documented URIs. Defaults to {@code localhost}.
	 * @return the host
	 */
	String uriHost() default 'localhost';
	/**
	 * The port to be used in documented URIs. Defaults to {@code 8080}.
	 * @return the port
	 */
	int uriPort() default 8080;
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
class RestDocsWebTestClientBuilderCustomizer implements WebTestClientBuilderCustomizer {
	private final RestDocsProperties properties;
	private final WebTestClientRestDocumentationConfigurer delegate;
	RestDocsWebTestClientBuilderCustomizer(RestDocsProperties properties,
			WebTestClientRestDocumentationConfigurer delegate) {
		this.properties = properties;
		this.delegate = delegate;
	}
	@Override
	public void customize(WebTestClient.Builder builder) {
		customizeBaseUrl(builder);
		builder.filter(this.delegate);
	}
	private void customizeBaseUrl(WebTestClient.Builder builder) {
		String scheme = this.properties.getUriScheme();
		String host = this.properties.getUriHost();
		String baseUrl = (StringUtils.hasText(scheme) ? scheme : 'http') + '://'
				+ (StringUtils.hasText(host) ? host : 'localhost');
		Integer port = this.properties.getUriPort();
		if (!isStandardPort(scheme, port)) {
			baseUrl += ':' + port;
		}
		builder.baseUrl(baseUrl);
	}
	private boolean isStandardPort(String scheme, Integer port) {
		if (port == null) {
			return true;
		}
		return ('http'.equals(scheme) && port == 80) || ('https'.equals(scheme) && port == 443);
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
class RestDocumentationContextProviderRegistrar implements ImportBeanDefinitionRegistrar {
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		Map<String, Object> annotationAttributes = importingClassMetadata
			.getAnnotationAttributes(AutoConfigureRestDocs.class.getName());
		BeanDefinitionBuilder definitionBuilder = BeanDefinitionBuilder
			.rootBeanDefinition(ManualRestDocumentation.class);
		String outputDir = (String) annotationAttributes.get('outputDir');
		if (StringUtils.hasText(outputDir)) {
			definitionBuilder.addConstructorArgValue(outputDir);
		}
		registry.registerBeanDefinition(ManualRestDocumentation.class.getName(), definitionBuilder.getBeanDefinition());
	}
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@FunctionalInterface
public interface RestDocsMockMvcConfigurationCustomizer {
	/**
	 * Customize the given {@code configurer}.
	 * @param configurer the configurer
	 */
	void customize(MockMvcRestDocumentationConfigurer configurer);
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@FunctionalInterface
public interface RestDocsWebTestClientConfigurationCustomizer {
	/**
	 * Customize the given {@code configurer}.
	 * @param configurer the configurer
	 */
	void customize(WebTestClientRestDocumentationConfigurer configurer);
}
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
public class RestDocsTestExecutionListener extends AbstractTestExecutionListener {
	private static final boolean REST_DOCS_PRESENT = ClassUtils.isPresent(
			'org.springframework.restdocs.ManualRestDocumentation',
			RestDocsTestExecutionListener.class.getClassLoader());
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 100;
	}
	@Override
	public void beforeTestMethod(TestContext testContext) throws Exception {
		if (REST_DOCS_PRESENT) {
			new DocumentationHandler().beforeTestMethod(testContext);
		}
	}
	@Override
	public void afterTestMethod(TestContext testContext) throws Exception {
		if (REST_DOCS_PRESENT) {
			new DocumentationHandler().afterTestMethod(testContext);
		}
	}
	private static final class DocumentationHandler {
		private void beforeTestMethod(TestContext testContext) {
			ManualRestDocumentation restDocumentation = findManualRestDocumentation(testContext);
			if (restDocumentation != null) {
				restDocumentation.beforeTest(testContext.getTestClass(), testContext.getTestMethod().getName());
			}
		}
		private void afterTestMethod(TestContext testContext) {
			ManualRestDocumentation restDocumentation = findManualRestDocumentation(testContext);
			if (restDocumentation != null) {
				restDocumentation.afterTest();
			}
		}
		private ManualRestDocumentation findManualRestDocumentation(TestContext testContext) {
			try {
				return testContext.getApplicationContext().getBean(ManualRestDocumentation.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				return null;
			}
		}
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.restdocs;
/*
package org.springframework.boot.test.autoconfigure.restdocs;
/**
@FunctionalInterface
public interface RestDocsRestAssuredConfigurationCustomizer {
	/**
	 * Customize the given {@code configurer}.
	 * @param configurer the configurer
	 */
	void customize(RestAssuredRestDocumentationConfigurer configurer);
}
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
class JooqTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		JooqTest jooqTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, JooqTest.class);
		return (jooqTest != null) ? jooqTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
public final class JooqTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<JooqTest> {
	JooqTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(JooqTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(JooqTypeExcludeFilter.class)
@Transactional
@AutoConfigureCache
@AutoConfigureJooq
@ImportAutoConfiguration
public @interface JooqTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
/**
package org.springframework.boot.test.autoconfigure.jooq;
/*
package org.springframework.boot.test.autoconfigure.jooq;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureJooq {
}
/*
package org.springframework.boot.test.autoconfigure;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface OverrideAutoConfiguration {
	/**
	 * The value of the {@link EnableAutoConfiguration#ENABLED_OVERRIDE_PROPERTY enabled
	 * override property}.
	 * @return the override value
	 */
	boolean enabled();
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureJson {
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
public final class JsonTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<JsonTest> {
	private static final String JACKSON_MODULE = 'com.fasterxml.jackson.databind.Module';
	private static final Set<Class<?>> DEFAULT_INCLUDES;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>();
		try {
			includes.add(ClassUtils.forName(JACKSON_MODULE, null));
		}
		catch (Exception ex) {
			// Ignore
		}
		includes.add(JsonComponent.class);
		DEFAULT_INCLUDES = Collections.unmodifiableSet(includes);
	}
	JsonTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		return DEFAULT_INCLUDES;
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.json;
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigureJson
@ImportAutoConfiguration
@PropertyMapping('spring.test.jsontesters')
public @interface AutoConfigureJsonTesters {
	/**
	 * If {@link BasicJsonTester}, {@link JacksonTester}, {@link JsonbTester} and
	 * {@link GsonTester} beans should be registered. Defaults to {@code true}.
	 * @return if tester support is enabled
	 */
	boolean enabled() default true;
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(JsonTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(JsonTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureJsonTesters
@ImportAutoConfiguration
public @interface JsonTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default only
	 * {@code @JsonComponent} and {@code Module} beans are included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
class JsonTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		JsonTest jsonTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, JsonTest.class);
		return (jsonTest != null) ? jsonTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.json;
/**
@AutoConfiguration(
		after = { JacksonAutoConfiguration.class, GsonAutoConfiguration.class, JsonbAutoConfiguration.class })
@ConditionalOnClass(name = 'org.assertj.core.api.Assert')
@ConditionalOnProperty('spring.test.jsontesters.enabled')
public class JsonTestersAutoConfiguration {
	@Bean
	public static JsonMarshalTestersBeanPostProcessor jsonMarshalTestersBeanPostProcessor() {
		return new JsonMarshalTestersBeanPostProcessor();
	}
	@Bean
	@Scope('prototype')
	@ImportRuntimeHints(BasicJsonTesterRuntimeHints.class)
	public FactoryBean<BasicJsonTester> basicJsonTesterFactoryBean() {
		return new JsonTesterFactoryBean<BasicJsonTester, Void>(BasicJsonTester.class, null);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ObjectMapper.class)
	static class JacksonJsonTestersConfiguration {
		@Bean
		@Scope('prototype')
		@ConditionalOnBean(ObjectMapper.class)
		@ImportRuntimeHints(JacksonTesterRuntimeHints.class)
		FactoryBean<JacksonTester<?>> jacksonTesterFactoryBean(ObjectMapper mapper) {
			return new JsonTesterFactoryBean<>(JacksonTester.class, mapper);
		}
		static class JacksonTesterRuntimeHints extends AbstractJsonMarshalTesterRuntimeHints {
			JacksonTesterRuntimeHints() {
				super(JacksonTester.class);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Gson.class)
	static class GsonJsonTestersConfiguration {
		@Bean
		@Scope('prototype')
		@ConditionalOnBean(Gson.class)
		@ImportRuntimeHints(GsonTesterRuntimeHints.class)
		FactoryBean<GsonTester<?>> gsonTesterFactoryBean(Gson gson) {
			return new JsonTesterFactoryBean<>(GsonTester.class, gson);
		}
		static class GsonTesterRuntimeHints extends AbstractJsonMarshalTesterRuntimeHints {
			GsonTesterRuntimeHints() {
				super(GsonTester.class);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Jsonb.class)
	static class JsonbJsonTesterConfiguration {
		@Bean
		@Scope('prototype')
		@ConditionalOnBean(Jsonb.class)
		@ImportRuntimeHints(JsonbJsonTesterRuntimeHints.class)
		FactoryBean<JsonbTester<?>> jsonbTesterFactoryBean(Jsonb jsonb) {
			return new JsonTesterFactoryBean<>(JsonbTester.class, jsonb);
		}
		static class JsonbJsonTesterRuntimeHints extends AbstractJsonMarshalTesterRuntimeHints {
			JsonbJsonTesterRuntimeHints() {
				super(JsonbTester.class);
			}
		}
	}
	/**
	 * {@link FactoryBean} used to create JSON Tester instances.
	 *
	 * @param <T> the object type
	 * @param <M> the marshaller type
	 */
	static class JsonTesterFactoryBean<T, M> implements FactoryBean<T> {
		private final Class<?> objectType;
		private final M marshaller;
		JsonTesterFactoryBean(Class<?> objectType, M marshaller) {
			this.objectType = objectType;
			this.marshaller = marshaller;
		}
		@Override
		public boolean isSingleton() {
			return false;
		}
		@Override
		@SuppressWarnings('unchecked')
		public T getObject() throws Exception {
			if (this.marshaller == null) {
				Constructor<?> constructor = this.objectType.getDeclaredConstructor();
				ReflectionUtils.makeAccessible(constructor);
				return (T) BeanUtils.instantiateClass(constructor);
			}
			Constructor<?>[] constructors = this.objectType.getDeclaredConstructors();
			for (Constructor<?> constructor : constructors) {
				if (constructor.getParameterCount() == 1
						&& constructor.getParameterTypes()[0].isInstance(this.marshaller)) {
					ReflectionUtils.makeAccessible(constructor);
					return (T) BeanUtils.instantiateClass(constructor, this.marshaller);
				}
			}
			throw new IllegalStateException(this.objectType + ' does not have a usable constructor');
		}
		@Override
		public Class<?> getObjectType() {
			return this.objectType;
		}
	}
	/**
	 * {@link BeanPostProcessor} used to initialize JSON testers.
	 */
	static class JsonMarshalTestersBeanPostProcessor implements InstantiationAwareBeanPostProcessor {
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			ReflectionUtils.doWithFields(bean.getClass(), (field) -> processField(bean, field));
			return bean;
		}
		private void processField(Object bean, Field field) {
			if (AbstractJsonMarshalTester.class.isAssignableFrom(field.getType())) {
				initializeTester(bean, field, bean.getClass(), ResolvableType.forField(field).getGeneric());
			}
			else if (BasicJsonTester.class.isAssignableFrom(field.getType())) {
				initializeTester(bean, field, bean.getClass());
			}
		}
		private void initializeTester(Object bean, Field field, Object... args) {
			ReflectionUtils.makeAccessible(field);
			Object tester = ReflectionUtils.getField(field, bean);
			if (tester != null) {
				ReflectionTestUtils.invokeMethod(tester, 'initialize', args);
			}
		}
	}
	@SuppressWarnings('rawtypes')
	static class AbstractJsonMarshalTesterRuntimeHints implements RuntimeHintsRegistrar {
		private final Class<? extends AbstractJsonMarshalTester> tester;
		AbstractJsonMarshalTesterRuntimeHints(Class<? extends AbstractJsonMarshalTester> tester) {
			this.tester = tester;
		}
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			ReflectionHints reflection = hints.reflection();
			reflection.registerType(this.tester, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
			reflection.registerMethod(
					ReflectionUtils.findMethod(this.tester, 'initialize', Class.class, ResolvableType.class),
					ExecutableMode.INVOKE);
		}
	}
	static class BasicJsonTesterRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			ReflectionHints reflection = hints.reflection();
			reflection.registerType(BasicJsonTester.class, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
			reflection.registerMethod(ReflectionUtils.findMethod(BasicJsonTester.class, 'initialize', Class.class),
					ExecutableMode.INVOKE);
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure;
/**
class OnFailureConditionReportContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		return new OnFailureConditionReportContextCustomizer();
	}
	static class OnFailureConditionReportContextCustomizer implements ContextCustomizer {
		@Override
		public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
			Supplier<ConditionEvaluationReport> reportSupplier;
			if (context instanceof GenericApplicationContext) {
				ConditionEvaluationReport report = ConditionEvaluationReport.get(context.getBeanFactory());
				reportSupplier = () -> report;
			}
			else {
				reportSupplier = () -> ConditionEvaluationReport.get(context.getBeanFactory());
			}
			context.addApplicationListener(new ApplicationFailureListener(reportSupplier));
		}
		@Override
		public boolean equals(Object obj) {
			return (obj != null) && (obj.getClass() == getClass());
		}
		@Override
		public int hashCode() {
			return getClass().hashCode();
		}
	}
	private static final class ApplicationFailureListener implements ApplicationListener<ApplicationFailedEvent> {
		private final Supplier<ConditionEvaluationReport> reportSupplier;
		private ApplicationFailureListener(Supplier<ConditionEvaluationReport> reportSupplier) {
			this.reportSupplier = reportSupplier;
		}
		@Override
		public void onApplicationEvent(ApplicationFailedEvent event) {
			System.err.println(new ConditionEvaluationReportMessage(this.reportSupplier.get()));
		}
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure;
/*
package org.springframework.boot.test.autoconfigure;
/**
@Deprecated(since = '3.2.11', forRemoval = true)
public class ConditionReportApplicationContextFailureProcessor implements ApplicationContextFailureProcessor {
	@Override
	public void processLoadFailure(ApplicationContext context, Throwable exception) {
		if (context instanceof ConfigurableApplicationContext configurableContext) {
			ConditionEvaluationReport report = ConditionEvaluationReport.get(configurableContext.getBeanFactory());
			System.err.println(new ConditionEvaluationReportMessage(report));
		}
	}
}
/*
package org.springframework.boot.test.autoconfigure.core;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureCache {
	@PropertyMapping('spring.cache.type')
	CacheType cacheProvider() default CacheType.NONE;
}
/*
/**
package org.springframework.boot.test.autoconfigure.core;
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
public class GraphQlTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<GraphQlTest> {
	private static final Class<?>[] NO_CONTROLLERS = {};
	private static final String[] OPTIONAL_INCLUDES = { 'com.fasterxml.jackson.databind.Module' };
	private static final Set<Class<?>> DEFAULT_INCLUDES;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>();
		includes.add(JsonComponent.class);
		includes.add(RuntimeWiringConfigurer.class);
		includes.add(Converter.class);
		includes.add(GenericConverter.class);
		includes.add(DataFetcherExceptionResolver.class);
		includes.add(Instrumentation.class);
		includes.add(GraphQlSourceBuilderCustomizer.class);
		for (String optionalInclude : OPTIONAL_INCLUDES) {
			try {
				includes.add(ClassUtils.forName(optionalInclude, null));
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		DEFAULT_INCLUDES = Collections.unmodifiableSet(includes);
	}
	private static final Set<Class<?>> DEFAULT_INCLUDES_AND_CONTROLLER;
	static {
		Set<Class<?>> includes = new LinkedHashSet<>(DEFAULT_INCLUDES);
		includes.add(Controller.class);
		DEFAULT_INCLUDES_AND_CONTROLLER = Collections.unmodifiableSet(includes);
	}
	private final Class<?>[] controllers;
	GraphQlTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
		this.controllers = getAnnotation().getValue('controllers', Class[].class).orElse(NO_CONTROLLERS);
	}
	@Override
	protected Set<Class<?>> getDefaultIncludes() {
		if (ObjectUtils.isEmpty(this.controllers)) {
			return DEFAULT_INCLUDES_AND_CONTROLLER;
		}
		return DEFAULT_INCLUDES;
	}
	@Override
	protected Set<Class<?>> getComponentIncludes() {
		return new LinkedHashSet<>(Arrays.asList(this.controllers));
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureGraphQl {
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
class GraphQlTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		GraphQlTest graphQlTest = TestContextAnnotationUtils.findMergedAnnotation(testClass, GraphQlTest.class);
		return (graphQlTest != null) ? graphQlTest.properties() : null;
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(GraphQlTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(GraphQlTypeExcludeFilter.class)
@AutoConfigureCache
@AutoConfigureJson
@AutoConfigureGraphQl
@AutoConfigureGraphQlTester
@ImportAutoConfiguration
public @interface GraphQlTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 */
	String[] properties() default {};
	/**
	 * Specifies the controllers to test. This is an alias of {@link #controllers()} which
	 * can be used for brevity if no other attributes are defined. See
	 * {@link #controllers()} for details.
	 * @see #controllers()
	 * @return the controllers to test
	 */
	@AliasFor('controllers')
	Class<?>[] value() default {};
	/**
	 * Specifies the controllers to test. May be left blank if all {@code @Controller}
	 * beans should be added to the application context.
	 * @see #value()
	 * @return the controllers to test
	 */
	@AliasFor('value')
	Class<?>[] controllers() default {};
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default, only
	 * {@code @Controller} (when no explicit {@link #controllers() controllers} are
	 * defined), {@code RuntimeWiringConfigurer}, {@code @JsonComponent},
	 * {@code Converter}, {@code GenericConverter}, {@code DataFetcherExceptionResolver},
	 * {@code Instrumentation} and {@code GraphQlSourceBuilderCustomizer} beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	ComponentScan.Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	ComponentScan.Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.graphql.tester;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigureMockMvc
@AutoConfigureWebTestClient
@ImportAutoConfiguration
public @interface AutoConfigureHttpGraphQlTester {
}
/*
package org.springframework.boot.test.autoconfigure.graphql.tester;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureGraphQlTester {
}
/*
package org.springframework.boot.test.autoconfigure.graphql.tester;
/**
@AutoConfiguration(after = { WebTestClientAutoConfiguration.class, MockMvcAutoConfiguration.class })
@ConditionalOnClass({ WebClient.class, WebTestClient.class, WebGraphQlTester.class })
public class HttpGraphQlTesterAutoConfiguration {
	@Bean
	@ConditionalOnBean(WebTestClient.class)
	@ConditionalOnMissingBean
	public HttpGraphQlTester webTestClientGraphQlTester(WebTestClient webTestClient, GraphQlProperties properties) {
		WebTestClient mutatedWebTestClient = webTestClient.mutate().baseUrl(properties.getPath()).build();
		return HttpGraphQlTester.create(mutatedWebTestClient);
	}
}
/*
package org.springframework.boot.test.autoconfigure.graphql.tester;
/**
@AutoConfiguration(after = { JacksonAutoConfiguration.class, GraphQlAutoConfiguration.class })
@ConditionalOnClass({ GraphQL.class, GraphQlTester.class })
public class GraphQlTesterAutoConfiguration {
	@Bean
	@ConditionalOnBean(ExecutionGraphQlService.class)
	@ConditionalOnMissingBean
	@SuppressWarnings('removal')
	public ExecutionGraphQlServiceTester graphQlTester(ExecutionGraphQlService graphQlService,
			ObjectProvider<ObjectMapper> objectMapperProvider) {
		ExecutionGraphQlServiceTester.Builder<?> builder = ExecutionGraphQlServiceTester.builder(graphQlService);
		objectMapperProvider.ifAvailable((objectMapper) -> {
			builder.encoder(new Jackson2JsonEncoder(objectMapper, MediaType.APPLICATION_GRAPHQL_RESPONSE,
					MediaType.APPLICATION_JSON, MediaType.APPLICATION_GRAPHQL));
			builder.decoder(new Jackson2JsonDecoder(objectMapper, MediaType.APPLICATION_JSON));
		});
		return builder.build();
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.graphql.tester;
/*
/**
package org.springframework.boot.test.autoconfigure.graphql;
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
class DataJpaTestContextBootstrapper extends SpringBootTestContextBootstrapper {
	@Override
	protected String[] getProperties(Class<?> testClass) {
		return MergedAnnotations.from(testClass, SearchStrategy.INHERITED_ANNOTATIONS)
			.get(DataJpaTest.class)
			.getValue('properties', String[].class)
			.orElse(null);
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureDataJpa {
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface AutoConfigureTestEntityManager {
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
public final class DataJpaTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<DataJpaTest> {
	DataJpaTypeExcludeFilter(Class<?> testClass) {
		super(testClass);
	}
}
/*
/**
package org.springframework.boot.test.autoconfigure.orm.jpa;
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@BootstrapWith(DataJpaTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
@OverrideAutoConfiguration(enabled = false)
@TypeExcludeFilters(DataJpaTypeExcludeFilter.class)
@Transactional
@AutoConfigureCache
@AutoConfigureDataJpa
@AutoConfigureTestDatabase
@AutoConfigureTestEntityManager
@ImportAutoConfiguration
public @interface DataJpaTest {
	/**
	 * Properties in form {@literal key=value} that should be added to the Spring
	 * {@link Environment} before the test runs.
	 * @return the properties to add
	 * @since 2.1.0
	 */
	String[] properties() default {};
	/**
	 * If SQL output should be logged.
	 * @return if SQL is logged
	 */
	@PropertyMapping('spring.jpa.show-sql')
	boolean showSql() default true;
	/**
	 * The {@link BootstrapMode} for the test repository support. Defaults to
	 * {@link BootstrapMode#DEFAULT}.
	 * @return the {@link BootstrapMode} to use for testing the repository
	 */
	@PropertyMapping('spring.data.jpa.repositories.bootstrap-mode')
	BootstrapMode bootstrapMode() default BootstrapMode.DEFAULT;
	/**
	 * Determines if default filtering should be used with
	 * {@link SpringBootApplication @SpringBootApplication}. By default no beans are
	 * included.
	 * @see #includeFilters()
	 * @see #excludeFilters()
	 * @return if default filters should be used
	 */
	boolean useDefaultFilters() default true;
	/**
	 * A set of include filters which can be used to add otherwise filtered beans to the
	 * application context.
	 * @return include filters to apply
	 */
	Filter[] includeFilters() default {};
	/**
	 * A set of exclude filters which can be used to filter beans that would otherwise be
	 * added to the application context.
	 * @return exclude filters to apply
	 */
	Filter[] excludeFilters() default {};
	/**
	 * Auto-configuration exclusions that should be applied for this test.
	 * @return auto-configuration exclusions to apply
	 */
	@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
	Class<?>[] excludeAutoConfiguration() default {};
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
public class TestEntityManager {
	private final EntityManagerFactory entityManagerFactory;
	/**
	 * Create a new {@link TestEntityManager} instance for the given
	 * {@link EntityManagerFactory}.
	 * @param entityManagerFactory the source entity manager factory
	 */
	public TestEntityManager(EntityManagerFactory entityManagerFactory) {
		Assert.notNull(entityManagerFactory, 'EntityManagerFactory must not be null');
		this.entityManagerFactory = entityManagerFactory;
	}
	/**
	 * Make an instance managed and persistent then return its ID. Delegates to
	 * {@link EntityManager#persist(Object)} then {@link #getId(Object)}.
	 * <p>
	 * Helpful when setting up test data in a test: <pre class='code'>
	 * Object entityId = this.testEntityManager.persist(new MyEntity('Spring'));
	 * </pre>
	 * @param entity the source entity
	 * @return the ID of the newly persisted entity
	 */
	public Object persistAndGetId(Object entity) {
		persist(entity);
		return getId(entity);
	}
	/**
	 * Make an instance managed and persistent then return its ID. Delegates to
	 * {@link EntityManager#persist(Object)} then {@link #getId(Object, Class)}.
	 * <p>
	 * Helpful when setting up test data in a test: <pre class='code'>
	 * Long entityId = this.testEntityManager.persist(new MyEntity('Spring'), Long.class);
	 * </pre>
	 * @param <T> the ID type
	 * @param entity the source entity
	 * @param idType the ID type
	 * @return the ID of the newly persisted entity
	 */
	public <T> T persistAndGetId(Object entity, Class<T> idType) {
		persist(entity);
		return getId(entity, idType);
	}
	/**
	 * Make an instance managed and persistent. Delegates to
	 * {@link EntityManager#persist(Object)} then returns the original source entity.
	 * <p>
	 * Helpful when setting up test data in a test: <pre class='code'>
	 * MyEntity entity = this.testEntityManager.persist(new MyEntity('Spring'));
	 * </pre>
	 * @param <E> the entity type
	 * @param entity the entity to persist
	 * @return the persisted entity
	 */
	public <E> E persist(E entity) {
		getEntityManager().persist(entity);
		return entity;
	}
	/**
	 * Make an instance managed and persistent, synchronize the persistence context to the
	 * underlying database and finally find the persisted entity by its ID. Delegates to
	 * {@link #persistAndFlush(Object)} then {@link #find(Class, Object)} with the
	 * {@link #getId(Object) entity ID}.
	 * <p>
	 * Helpful when ensuring that entity data is actually written and read from the
	 * underlying database correctly.
	 * @param <E> the entity type
	 * @param entity the entity to persist
	 * @return the entity found using the ID of the persisted entity
	 */
	@SuppressWarnings('unchecked')
	public <E> E persistFlushFind(E entity) {
		EntityManager entityManager = getEntityManager();
		persistAndFlush(entity);
		Object id = getId(entity);
		entityManager.detach(entity);
		return (E) entityManager.find(entity.getClass(), id);
	}
	/**
	 * Make an instance managed and persistent then synchronize the persistence context to
	 * the underlying database. Delegates to {@link EntityManager#persist(Object)} then
	 * {@link #flush()} and finally returns the original source entity.
	 * <p>
	 * Helpful when setting up test data in a test: <pre class='code'>
	 * MyEntity entity = this.testEntityManager.persistAndFlush(new MyEntity('Spring'));
	 * </pre>
	 * @param <E> the entity type
	 * @param entity the entity to persist
	 * @return the persisted entity
	 */
	public <E> E persistAndFlush(E entity) {
		persist(entity);
		flush();
		return entity;
	}
	/**
	 * Merge the state of the given entity into the current persistence context. Delegates
	 * to {@link EntityManager#merge(Object)}
	 * @param <E> the entity type
	 * @param entity the entity to merge
	 * @return the merged entity
	 */
	public <E> E merge(E entity) {
		return getEntityManager().merge(entity);
	}
	/**
	 * Remove the entity instance. Delegates to {@link EntityManager#remove(Object)}
	 * @param entity the entity to remove
	 */
	public void remove(Object entity) {
		getEntityManager().remove(entity);
	}
	/**
	 * Find by primary key. Delegates to {@link EntityManager#find(Class, Object)}.
	 * @param <E> the entity type
	 * @param entityClass the entity class
	 * @param primaryKey the entity primary key
	 * @return the found entity or {@code null} if the entity does not exist
	 * @see #getId(Object)
	 */
	public <E> E find(Class<E> entityClass, Object primaryKey) {
		return getEntityManager().find(entityClass, primaryKey);
	}
	/**
	 * Synchronize the persistence context to the underlying database. Delegates to
	 * {@link EntityManager#flush()}.
	 */
	public void flush() {
		getEntityManager().flush();
	}
	/**
	 * Refresh the state of the instance from the database, overwriting changes made to
	 * the entity, if any. Delegates to {@link EntityManager#refresh(Object)}.
	 * @param <E> the entity type
	 * @param entity the entity to refresh
	 * @return the refreshed entity
	 */
	public <E> E refresh(E entity) {
		getEntityManager().refresh(entity);
		return entity;
	}
	/**
	 * Clear the persistence context, causing all managed entities to become detached.
	 * Delegates to {@link EntityManager#clear()}
	 */
	public void clear() {
		getEntityManager().clear();
	}
	/**
	 * Remove the given entity from the persistence context, causing a managed entity to
	 * become detached. Delegates to {@link EntityManager#detach(Object)}.
	 * @param entity the entity to detach.
	 */
	public void detach(Object entity) {
		getEntityManager().detach(entity);
	}
	/**
	 * Return the ID of the given entity. Delegates to
	 * {@link PersistenceUnitUtil#getIdentifier(Object)}.
	 * @param entity the source entity
	 * @return the ID of the entity or {@code null}
	 * @see #getId(Object, Class)
	 */
	public Object getId(Object entity) {
		return this.entityManagerFactory.getPersistenceUnitUtil().getIdentifier(entity);
	}
	/**
	 * Return the ID of the given entity cast to a specific type. Delegates to
	 * {@link PersistenceUnitUtil#getIdentifier(Object)}.
	 * @param <T> the ID type
	 * @param entity the source entity
	 * @param idType the expected ID type
	 * @return the ID of the entity or {@code null}
	 * @see #getId(Object)
	 */
	@SuppressWarnings('unchecked')
	public <T> T getId(Object entity, Class<T> idType) {
		Object id = getId(entity);
		Assert.isInstanceOf(idType, id, 'ID mismatch:');
		return (T) id;
	}
	/**
	 * Return the underlying {@link EntityManager} that"s actually used to perform all
	 * operations.
	 * @return the entity manager
	 */
	public final EntityManager getEntityManager() {
		EntityManager manager = EntityManagerFactoryUtils.getTransactionalEntityManager(this.entityManagerFactory);
		Assert.state(manager != null, 'No transactional EntityManager found, is your test running in a transaction?');
		return manager;
	}
}
/*
package org.springframework.boot.test.autoconfigure.orm.jpa;
/**
@AutoConfiguration(after = HibernateJpaAutoConfiguration.class)
@ConditionalOnClass({ EntityManagerFactory.class })
public class TestEntityManagerAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public TestEntityManager testEntityManager(EntityManagerFactory entityManagerFactory) {
		return new TestEntityManager(entityManagerFactory);
	}
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
class ChangelogTests {
	@Test
	void diffContainsDifferencesBetweenLeftAndRightInputs() {
		Changelog differences = TestChangelog.load();
		assertThat(differences).isNotNull();
		assertThat(differences.oldVersionNumber()).isEqualTo('1.0');
		assertThat(differences.newVersionNumber()).isEqualTo('2.0');
		assertThat(differences.differences()).hasSize(4);
		List<Difference> added = differences.differences()
			.stream()
			.filter((difference) -> difference.type() == DifferenceType.ADDED)
			.toList();
		assertThat(added).hasSize(1);
		assertProperty(added.get(0).newProperty(), 'test.add', String.class, 'new');
		List<Difference> deleted = differences.differences()
			.stream()
			.filter((difference) -> difference.type() == DifferenceType.DELETED)
			.toList();
		assertThat(deleted).hasSize(2)
			.anySatisfy((entry) -> assertProperty(entry.oldProperty(), 'test.delete', String.class, 'delete'))
			.anySatisfy(
					(entry) -> assertProperty(entry.newProperty(), 'test.delete.deprecated', String.class, 'delete'));
		List<Difference> deprecated = differences.differences()
			.stream()
			.filter((difference) -> difference.type() == DifferenceType.DEPRECATED)
			.toList();
		assertThat(deprecated).hasSize(1);
		assertProperty(deprecated.get(0).oldProperty(), 'test.deprecate', String.class, 'wrong');
		assertProperty(deprecated.get(0).newProperty(), 'test.deprecate', String.class, 'wrong');
	}
	private void assertProperty(ConfigurationMetadataProperty property, String id, Class<?> type, Object defaultValue) {
		assertThat(property).isNotNull();
		assertThat(property.getId()).isEqualTo(id);
		assertThat(property.getType()).isEqualTo(type.getName());
		assertThat(property.getDefaultValue()).isEqualTo(defaultValue);
	}
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
final class TestChangelog {
	private TestChangelog() {
	}
	static Changelog load() {
		ConfigurationMetadataRepository previousRepository = load('sample-1.0.json');
		ConfigurationMetadataRepository repository = load('sample-2.0.json');
		return Changelog.of('1.0', previousRepository, '2.0', repository);
	}
	private static ConfigurationMetadataRepository load(String filename) {
		try (InputStream inputStream = new FileInputStream('src/test/resources/' + filename)) {
			return ConfigurationMetadataRepositoryJsonBuilder.create(inputStream).build();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
class ChangelogGeneratorTests {
	@TempDir
	File temp;
	@Test
	void generateChangeLog() throws IOException {
		File oldJars = new File(this.temp, '1.0');
		addJar(oldJars, 'sample-1.0.json');
		File newJars = new File(this.temp, '2.0');
		addJar(newJars, 'sample-2.0.json');
		File out = new File(this.temp, 'changes.adoc');
		String[] args = new String[] { oldJars.getAbsolutePath(), newJars.getAbsolutePath(), out.getAbsolutePath() };
		ChangelogGenerator.main(args);
		assertThat(out).usingCharset(StandardCharsets.UTF_8)
			.hasSameTextualContentAs(new File('src/test/resources/sample.adoc'));
	}
	private void addJar(File directory, String filename) throws IOException {
		directory.mkdirs();
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(new File(directory, 'sample.jar')))) {
			out.putNextEntry(new ZipEntry('META-INF/spring-configuration-metadata.json'));
			try (InputStream in = new FileInputStream('src/test/resources/' + filename)) {
				in.transferTo(out);
				out.closeEntry();
			}
		}
	}
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
class ChangelogWriterTests {
	@Test
	void writeChangelog() {
		StringWriter out = new StringWriter();
		try (ChangelogWriter writer = new ChangelogWriter(out)) {
			writer.write(TestChangelog.load());
		}
		String expected = Files.contentOf(new File('src/test/resources/sample.adoc'), StandardCharsets.UTF_8);
		assertThat(out).hasToString(expected);
	}
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
public final class ChangelogGenerator {
	private ChangelogGenerator() {
	}
	public static void main(String[] args) throws IOException {
		generate(new File(args[0]), new File(args[1]), new File(args[2]));
	}
	private static void generate(File oldDir, File newDir, File out) throws IOException {
		String oldVersionNumber = oldDir.getName();
		ConfigurationMetadataRepository oldMetadata = buildRepository(oldDir);
		String newVersionNumber = newDir.getName();
		ConfigurationMetadataRepository newMetadata = buildRepository(newDir);
		Changelog changelog = Changelog.of(oldVersionNumber, oldMetadata, newVersionNumber, newMetadata);
		try (ChangelogWriter writer = new ChangelogWriter(out)) {
			writer.write(changelog);
		}
		System.out.println('%nConfiguration metadata changelog written to "%s"'.formatted(out));
	}
	static ConfigurationMetadataRepository buildRepository(File directory) {
		ConfigurationMetadataRepositoryJsonBuilder builder = ConfigurationMetadataRepositoryJsonBuilder.create();
		for (File file : directory.listFiles()) {
			try (JarFile jarFile = new JarFile(file)) {
				JarEntry metadataEntry = jarFile.getJarEntry('META-INF/spring-configuration-metadata.json');
				if (metadataEntry != null) {
					builder.withJsonResource(jarFile.getInputStream(metadataEntry));
				}
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
		}
		return builder.build();
	}
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
enum DifferenceType {
	/**
	 * The entry has been added.
	 */
	ADDED,
	/**
	 * The entry has been made deprecated. It may or may not still exist in the previous
	 * version.
	 */
	DEPRECATED,
	/**
	 * The entry has been deleted.
	 */
	DELETED
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
class ChangelogWriter implements AutoCloseable {
	private static final Comparator<ConfigurationMetadataProperty> COMPARING_ID = Comparator
		.comparing(ConfigurationMetadataProperty::getId);
	private final PrintWriter out;
	ChangelogWriter(File out) throws IOException {
		this(new FileWriter(out));
	}
	ChangelogWriter(Writer out) {
		this.out = new PrintWriter(out);
	}
	void write(Changelog changelog) {
		String oldVersionNumber = changelog.oldVersionNumber();
		String newVersionNumber = changelog.newVersionNumber();
		Map<DifferenceType, List<Difference>> differencesByType = collateByType(changelog);
		write('Configuration property changes between `%s` and `%s`%n', oldVersionNumber, newVersionNumber);
		write('%n%n%n== Deprecated in %s%n%n', newVersionNumber);
		writeDeprecated(differencesByType.get(DifferenceType.DEPRECATED));
		write('%n%n%n== Added in %s%n%n', newVersionNumber);
		writeAdded(differencesByType.get(DifferenceType.ADDED));
		write('%n%n%n== Removed in %s%n%n', newVersionNumber);
		writeRemoved(differencesByType.get(DifferenceType.DELETED), differencesByType.get(DifferenceType.DEPRECATED));
	}
	private Map<DifferenceType, List<Difference>> collateByType(Changelog differences) {
		Map<DifferenceType, List<Difference>> byType = new HashMap<>();
		for (DifferenceType type : DifferenceType.values()) {
			byType.put(type, new ArrayList<>());
		}
		for (Difference difference : differences.differences()) {
			byType.get(difference.type()).add(difference);
		}
		return byType;
	}
	private void writeDeprecated(List<Difference> differences) {
		List<Difference> rows = sortProperties(differences, Difference::newProperty).stream()
			.filter(this::isDeprecatedInRelease)
			.toList();
		writeTable('| Key | Replacement | Reason', rows, this::writeDeprecated);
	}
	private void writeDeprecated(Difference difference) {
		writeDeprecatedPropertyRow(difference.newProperty());
	}
	private void writeAdded(List<Difference> differences) {
		List<Difference> rows = sortProperties(differences, Difference::newProperty);
		writeTable('| Key | Default value | Description', rows, this::writeAdded);
	}
	private void writeAdded(Difference difference) {
		writeRegularPropertyRow(difference.newProperty());
	}
	private void writeRemoved(List<Difference> deleted, List<Difference> deprecated) {
		List<Difference> rows = getRemoved(deleted, deprecated);
		writeTable('| Key | Replacement | Reason', rows, this::writeRemoved);
	}
	private List<Difference> getRemoved(List<Difference> deleted, List<Difference> deprecated) {
		List<Difference> result = new ArrayList<>(deleted);
		deprecated.stream().filter(Predicate.not(this::isDeprecatedInRelease)).forEach(result::remove);
		return sortProperties(result,
				(difference) -> getFirstNonNull(difference, Difference::oldProperty, Difference::newProperty));
	}
	private void writeRemoved(Difference difference) {
		writeDeprecatedPropertyRow(getFirstNonNull(difference, Difference::newProperty, Difference::oldProperty));
	}
	private List<Difference> sortProperties(List<Difference> differences,
			Function<Difference, ConfigurationMetadataProperty> extractor) {
		return differences.stream().sorted(Comparator.comparing(extractor, COMPARING_ID)).toList();
	}
	@SafeVarargs
	@SuppressWarnings('varargs')
	private <T, P> P getFirstNonNull(T t, Function<T, P>... extractors) {
		return Stream.of(extractors)
			.map((extractor) -> extractor.apply(t))
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(null);
	}
	private void writeTable(String header, List<Difference> rows, Consumer<Difference> action) {
		if (rows.isEmpty()) {
			write('_None_.%n');
		}
		else {
			writeTableBreak();
			write(header + '%n%n');
			for (Iterator<Difference> iterator = rows.iterator(); iterator.hasNext();) {
				action.accept(iterator.next());
				write((!iterator.hasNext()) ? null : '%n');
			}
			writeTableBreak();
		}
	}
	private void writeTableBreak() {
		write('|======================%n');
	}
	private void writeRegularPropertyRow(ConfigurationMetadataProperty property) {
		writeCell(monospace(property.getId()));
		writeCell(monospace(asString(property.getDefaultValue())));
		writeCell(property.getShortDescription());
	}
	private void writeDeprecatedPropertyRow(ConfigurationMetadataProperty property) {
		Deprecation deprecation = (property.getDeprecation() != null) ? property.getDeprecation() : new Deprecation();
		writeCell(monospace(property.getId()));
		writeCell(monospace(deprecation.getReplacement()));
		writeCell(getFirstSentence(deprecation.getReason()));
	}
	private String getFirstSentence(String text) {
		if (text == null) {
			return null;
		}
		int dot = text.indexOf(".");
		if (dot != -1) {
			BreakIterator breakIterator = BreakIterator.getSentenceInstance(Locale.US);
			breakIterator.setText(text);
			String sentence = text.substring(breakIterator.first(), breakIterator.next()).trim();
			return removeSpaceBetweenLine(sentence);
		}
		String[] lines = text.split(System.lineSeparator());
		return lines[0].trim();
	}
	private String removeSpaceBetweenLine(String text) {
		String[] lines = text.split(System.lineSeparator());
		return Arrays.stream(lines).map(String::trim).collect(Collectors.joining(' '));
	}
	private boolean isDeprecatedInRelease(Difference difference) {
		Deprecation deprecation = difference.newProperty().getDeprecation();
		return (deprecation != null) && (deprecation.getLevel() != Deprecation.Level.ERROR);
	}
	private String monospace(String value) {
		return (value != null) ? '`%s`'.formatted(value) : null;
	}
	private void writeCell(String content) {
		if (content == null) {
			write('|%n');
		}
		else {
			String escaped = escapeForTableCell(content);
			write('| %s%n'.formatted(escaped));
		}
	}
	private String escapeForTableCell(String content) {
		return content.replace('|', '\\|');
	}
	private void write(String format, Object... args) {
		if (format != null) {
			Object[] strings = Arrays.stream(args).map(this::asString).toArray();
			this.out.append(format.formatted(strings));
		}
	}
	private String asString(Object value) {
		if (value instanceof Object[] array) {
			return Stream.of(array).map(this::asString).collect(Collectors.joining(', '));
		}
		return (value != null) ? value.toString() : null;
	}
	@Override
	public void close() {
		this.out.close();
	}
}
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
record Difference(DifferenceType type, ConfigurationMetadataProperty oldProperty,
		ConfigurationMetadataProperty newProperty) {
	static Difference compute(ConfigurationMetadataProperty oldProperty, ConfigurationMetadataProperty newProperty) {
		if (newProperty == null) {
			if (!(oldProperty.isDeprecated() && oldProperty.getDeprecation().getLevel() == Level.ERROR)) {
				return new Difference(DifferenceType.DELETED, oldProperty, null);
			}
			return null;
		}
		if (newProperty.isDeprecated() && !oldProperty.isDeprecated()) {
			return new Difference(DifferenceType.DEPRECATED, oldProperty, newProperty);
		}
		if (oldProperty.isDeprecated() && oldProperty.getDeprecation().getLevel() == Level.WARNING
				&& newProperty.isDeprecated() && newProperty.getDeprecation().getLevel() == Level.ERROR) {
			return new Difference(DifferenceType.DELETED, oldProperty, newProperty);
		}
		return null;
	}
}
/*
/**
package org.springframework.boot.configurationmetadata.changelog;
/*
package org.springframework.boot.configurationmetadata.changelog;
/**
record Changelog(String oldVersionNumber, String newVersionNumber, List<Difference> differences) {
	static Changelog of(String oldVersionNumber, ConfigurationMetadataRepository oldMetadata, String newVersionNumber,
			ConfigurationMetadataRepository newMetadata) {
		return new Changelog(oldVersionNumber, newVersionNumber, computeDifferences(oldMetadata, newMetadata));
	}
	static List<Difference> computeDifferences(ConfigurationMetadataRepository oldMetadata,
			ConfigurationMetadataRepository newMetadata) {
		List<String> seenIds = new ArrayList<>();
		List<Difference> differences = new ArrayList<>();
		for (ConfigurationMetadataProperty oldProperty : oldMetadata.getAllProperties().values()) {
			String id = oldProperty.getId();
			seenIds.add(id);
			ConfigurationMetadataProperty newProperty = newMetadata.getAllProperties().get(id);
			Difference difference = Difference.compute(oldProperty, newProperty);
			if (difference != null) {
				differences.add(difference);
			}
		}
		for (ConfigurationMetadataProperty newProperty : newMetadata.getAllProperties().values()) {
			if ((!seenIds.contains(newProperty.getId())) && (!newProperty.isDeprecated())) {
				differences.add(new Difference(DifferenceType.ADDED, null, newProperty));
			}
		}
		return List.copyOf(differences);
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@GradleCompatibility(configurationCache = true)
@DisabledIfDockerUnavailable
class BootBuildImageIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void buildsImageWithDefaultBuilder() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('Running detector');
		assertThat(result.getOutput()).contains('Running builder');
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('Network status: HTTP/2 200');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithTrustBuilder() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('Running creator');
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('Network status: HTTP/2 200');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithWarPackaging() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage', '-PapplyWarPlugin');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		File buildLibs = new File(this.gradleBuild.getProjectDir(), 'build/libs');
		assertThat(buildLibs.listFiles())
			.containsExactly(new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '.war'));
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithWarPackagingAndJarConfiguration() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		File buildLibs = new File(this.gradleBuild.getProjectDir(), 'build/libs');
		assertThat(buildLibs.listFiles())
			.containsExactly(new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '.war'));
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithCustomName() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('example/test-image-name');
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages('example/test-image-name');
	}
	@TestTemplate
	void buildsImageWithCustomBuilderAndRunImage() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('example/test-image-custom');
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages('example/test-image-custom');
	}
	@TestTemplate
	void buildsImageWithCommandLineOptions() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage', '--pullPolicy=IF_NOT_PRESENT',
				'--imageName=example/test-image-cmd', '--builder=ghcr.io/spring-io/spring-boot-cnb-test-builder:0.0.1',
				'--trustBuilder', '--runImage=paketobuildpacks/run-jammy-tiny', '--createdDate=2020-07-01T12:34:56Z',
				'--applicationDirectory=/application');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('example/test-image-cmd');
		assertThat(result.getOutput()).contains('Running creator');
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		Image image = new DockerApi().image().inspect(ImageReference.of('example/test-image-cmd'));
		assertThat(image.getCreated()).isEqualTo('2020-07-01T12:34:56Z');
		removeImages('example/test-image-cmd');
	}
	@TestTemplate
	void buildsImageWithPullPolicy() throws IOException {
		writeMainClass();
		writeLongNameResource();
		String projectName = this.gradleBuild.getProjectDir().getName();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Pulled builder image').contains('Pulled run image');
		result = this.gradleBuild.build('bootBuildImage', '--pullPolicy=IF_NOT_PRESENT');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).doesNotContain('Pulled builder image').doesNotContain('Pulled run image');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithBuildpackFromBuilder() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building')
			.contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	@DisabledOnOs(OS.WINDOWS)
	void buildsImageWithBuildpackFromDirectory() throws IOException {
		writeMainClass();
		writeLongNameResource();
		writeBuildpackContent();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Hello World buildpack');
		removeImages(projectName);
	}
	@TestTemplate
	@DisabledOnOs(OS.WINDOWS)
	void buildsImageWithBuildpackFromTarGzip() throws IOException {
		writeMainClass();
		writeLongNameResource();
		writeBuildpackContent();
		tarGzipBuildpackContent();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Hello World buildpack');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithBuildpacksFromImages() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building')
			.contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithBinding() throws IOException {
		writeMainClass();
		writeLongNameResource();
		writeCertificateBindingFiles();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('binding: certificates/type=ca-certificates');
		assertThat(result.getOutput()).contains('binding: certificates/test1.crt=---certificate one---');
		assertThat(result.getOutput()).contains('binding: certificates/test2.crt=---certificate two---');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithTag() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		assertThat(result.getOutput()).contains('example.com/myapp:latest');
		removeImages(projectName, 'example.com/myapp:latest');
	}
	@TestTemplate
	void buildsImageWithLaunchScript() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithNetworkModeNone() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('Network status: curl failed');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithVolumeCaches() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
		deleteVolumes('cache-' + projectName + '.build', 'cache-' + projectName + '.launch');
	}
	@TestTemplate
	@EnabledOnOs(value = OS.LINUX, disabledReason = 'Works with Docker Engine on Linux but is not reliable with '
			+ 'Docker Desktop on other OSs')
	void buildsImageWithBindCaches() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
		String tempDir = System.getProperty('java.io.tmpdir');
		Path buildCachePath = Paths.get(tempDir, 'junit-image-cache-' + projectName + '-build');
		Path launchCachePath = Paths.get(tempDir, 'junit-image-cache-' + projectName + '-launch');
		assertThat(buildCachePath).exists().isDirectory();
		assertThat(launchCachePath).exists().isDirectory();
		cleanupCache(buildCachePath);
		cleanupCache(launchCachePath);
	}
	private static void cleanupCache(Path cachePath) {
		try {
			FileSystemUtils.deleteRecursively(cachePath);
		}
		catch (Exception ex) {
			// ignore
		}
	}
	@TestTemplate
	void buildsImageWithCreatedDate() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		Image image = new DockerApi().image().inspect(ImageReference.of('docker.io/library/' + projectName));
		assertThat(image.getCreated()).isEqualTo('2020-07-01T12:34:56Z');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithCurrentCreatedDate() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		Image image = new DockerApi().image().inspect(ImageReference.of('docker.io/library/' + projectName));
		OffsetDateTime createdDateTime = OffsetDateTime.parse(image.getCreated());
		OffsetDateTime current = OffsetDateTime.now().withOffsetSameInstant(createdDateTime.getOffset());
		assertThat(createdDateTime.getYear()).isEqualTo(current.getYear());
		assertThat(createdDateTime.getMonth()).isEqualTo(current.getMonth());
		assertThat(createdDateTime.getDayOfMonth()).isEqualTo(current.getDayOfMonth());
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithApplicationDirectory() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	void buildsImageWithEmptySecurityOptions() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName);
	}
	@TestTemplate
	@EnabledOnOs(value = { OS.LINUX, OS.MAC }, architectures = 'aarch64',
			disabledReason = 'Lifecycle will only run on ARM architecture')
	void buildsImageOnLinuxArmWithImagePlatformLinuxArm() throws IOException {
		writeMainClass();
		writeLongNameResource();
		String builderImage = 'ghcr.io/spring-io/spring-boot-cnb-test-builder:0.0.1';
		String runImage = 'docker.io/paketobuildpacks/run-jammy-tiny:latest';
		String buildpackImage = 'ghcr.io/spring-io/spring-boot-test-info:0.0.1';
		removeImages(builderImage, runImage, buildpackImage);
		BuildResult result = this.gradleBuild.build('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput())
			.contains('Pulling builder image "' + builderImage + '" for platform "linux/arm64"');
		assertThat(result.getOutput())
			.contains('Pulling builder image "' + builderImage + '" for platform "linux/arm64"');
		assertThat(result.getOutput()).contains('Pulling run image "' + runImage + '" for platform "linux/arm64"');
		assertThat(result.getOutput())
			.contains('Pulling buildpack image "' + buildpackImage + '" for platform "linux/arm64"');
		assertThat(result.getOutput()).contains('Running detector');
		assertThat(result.getOutput()).contains('Running builder');
		assertThat(result.getOutput()).contains('---> Test Info buildpack building');
		assertThat(result.getOutput()).contains('---> Test Info buildpack done');
		removeImages(projectName, builderImage, runImage, buildpackImage);
	}
	@TestTemplate
	@EnabledOnOs(value = { OS.LINUX, OS.MAC }, architectures = 'amd64',
			disabledReason = 'The expected failure condition will not fail on ARM architectures')
	void failsWhenBuildingOnLinuxAmdWithImagePlatformLinuxArm() throws IOException {
		writeMainClass();
		writeLongNameResource();
		String builderImage = 'ghcr.io/spring-io/spring-boot-cnb-test-builder:0.0.1';
		String runImage = 'docker.io/paketobuildpacks/run-jammy-tiny:latest';
		String buildpackImage = 'ghcr.io/spring-io/spring-boot-test-info:0.0.1';
		removeImages(builderImage, runImage, buildpackImage);
		BuildResult result = this.gradleBuild.buildAndFail('bootBuildImage');
		String projectName = this.gradleBuild.getProjectDir().getName();
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).contains('docker.io/library/' + projectName);
		assertThat(result.getOutput())
			.contains('Pulling builder image "' + builderImage + '" for platform "linux/arm64"');
		assertThat(result.getOutput()).contains('Pulling run image "' + runImage + '" for platform "linux/arm64"');
		assertThat(result.getOutput())
			.contains('Pulling buildpack image "' + buildpackImage + '" for platform "linux/arm64"');
		assertThat(result.getOutput()).contains('exec format error');
		removeImages(builderImage, runImage, buildpackImage);
	}
	@TestTemplate
	void failsWithInvalidCreatedDate() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.buildAndFail('bootBuildImage');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).contains('Error parsing "invalid date" as an image created date');
	}
	@TestTemplate
	void failsWithBuilderError() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.buildAndFail('bootBuildImage');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).contains('Forced builder failure');
		assertThat(result.getOutput()).containsPattern('Builder lifecycle ".*" failed with status code');
	}
	@TestTemplate
	void failsWithInvalidImageName() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.buildAndFail('bootBuildImage', '--imageName=example/Invalid-Image-Name');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).containsPattern('Unable to parse image reference')
			.containsPattern('example/Invalid-Image-Name');
	}
	@TestTemplate
	void failsWithBuildpackNotInBuilder() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.buildAndFail('bootBuildImage');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).contains('"urn:cnb:builder:example/does-not-exist:0.0.1" not found in builder');
	}
	@TestTemplate
	void failsWithInvalidTag() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.buildAndFail('bootBuildImage');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).containsPattern('Unable to parse image reference')
			.containsPattern('example/Invalid-Tag-Name');
	}
	@TestTemplate
	void failsWhenCachesAreConfiguredTwice() throws IOException {
		writeMainClass();
		writeLongNameResource();
		BuildResult result = this.gradleBuild.buildAndFail('bootBuildImage');
		assertThat(result.getOutput()).containsPattern('Each image building cache can be configured only once');
	}
	private void writeMainClass() throws IOException {
		File examplePackage = new File(this.gradleBuild.getProjectDir(), 'src/main/java/example');
		examplePackage.mkdirs();
		File main = new File(examplePackage, 'Main.java');
		try (PrintWriter writer = new PrintWriter(new FileWriter(main))) {
			writer.println('package example;');
			writer.println();
			writer.println('import java.io.IOException;');
			writer.println();
			writer.println('public class Main {');
			writer.println();
			writer.println('    public static void main(String[] args) throws Exception {');
			writer.println('        System.out.println(\'Launched\');');
			writer.println('        synchronized(args) {');
			writer.println('            args.wait(); // Prevent exit');
			writer.println('        }');
			writer.println('    }');
			writer.println();
			writer.println('}');
		}
	}
	private void writeLongNameResource() throws IOException {
		StringBuilder name = new StringBuilder();
		new Random().ints("a", "z" + 1).limit(128).forEach((i) -> name.append((char) i));
		Path path = this.gradleBuild.getProjectDir()
			.toPath()
			.resolve(Paths.get('src', 'main', 'resources', name.toString()));
		Files.createDirectories(path.getParent());
		Files.createFile(path);
	}
	private void writeBuildpackContent() throws IOException {
		FileAttribute<Set<PosixFilePermission>> dirAttribute = PosixFilePermissions
			.asFileAttribute(PosixFilePermissions.fromString('rwxr-xr-x'));
		FileAttribute<Set<PosixFilePermission>> execFileAttribute = PosixFilePermissions
			.asFileAttribute(PosixFilePermissions.fromString('rwxrwxrwx'));
		File buildpackDir = new File(this.gradleBuild.getProjectDir(), 'buildpack/hello-world');
		Files.createDirectories(buildpackDir.toPath(), dirAttribute);
		File binDir = new File(buildpackDir, 'bin');
		Files.createDirectories(binDir.toPath(), dirAttribute);
		File descriptor = new File(buildpackDir, 'buildpack.toml');
		try (PrintWriter writer = new PrintWriter(new FileWriter(descriptor))) {
			writer.println('api = \'0.10\'');
			writer.println('[buildpack]');
			writer.println('id = \'example/hello-world\'');
			writer.println('version = \'0.0.1\'');
			writer.println('name = \'Hello World Buildpack\'');
			writer.println('homepage = \'https://github.com/buildpacks/samples/tree/main/buildpacks/hello-world\'');
			writer.println('[[stacks]]\n');
			writer.println('id = \'*\'');
		}
		File detect = Files.createFile(Paths.get(binDir.getAbsolutePath(), 'detect'), execFileAttribute).toFile();
		try (PrintWriter writer = new PrintWriter(new FileWriter(detect))) {
			writer.println('#!/usr/bin/env bash');
			writer.println('set -eo pipefail');
			writer.println('exit 0');
		}
		File build = Files.createFile(Paths.get(binDir.getAbsolutePath(), 'build'), execFileAttribute).toFile();
		try (PrintWriter writer = new PrintWriter(new FileWriter(build))) {
			writer.println('#!/usr/bin/env bash');
			writer.println('set -eo pipefail');
			writer.println('echo \'---> Hello World buildpack\'');
			writer.println('echo \'---> done\'');
			writer.println('exit 0');
		}
	}
	private void tarGzipBuildpackContent() throws IOException {
		Path tarGzipPath = Paths.get(this.gradleBuild.getProjectDir().getAbsolutePath(), 'hello-world.tgz');
		try (TarArchiveOutputStream tar = new TarArchiveOutputStream(
				new GzipCompressorOutputStream(Files.newOutputStream(Files.createFile(tarGzipPath))))) {
			File buildpackDir = new File(this.gradleBuild.getProjectDir(), 'buildpack/hello-world');
			writeDirectoryToTar(tar, buildpackDir, buildpackDir.getAbsolutePath());
		}
	}
	private void writeDirectoryToTar(TarArchiveOutputStream tar, File dir, String baseDirPath) throws IOException {
		for (File file : dir.listFiles()) {
			String name = file.getAbsolutePath().replace(baseDirPath, '');
			int mode = FilePermissions.umaskForPath(file.toPath());
			if (file.isDirectory()) {
				writeTarEntry(tar, name + '/', mode);
				writeDirectoryToTar(tar, file, baseDirPath);
			}
			else {
				writeTarEntry(tar, file, name, mode);
			}
		}
	}
	private void writeTarEntry(TarArchiveOutputStream tar, String name, int mode) throws IOException {
		TarArchiveEntry entry = new TarArchiveEntry(name);
		entry.setMode(mode);
		tar.putArchiveEntry(entry);
		tar.closeArchiveEntry();
	}
	private void writeTarEntry(TarArchiveOutputStream tar, File file, String name, int mode) throws IOException {
		TarArchiveEntry entry = new TarArchiveEntry(file, name);
		entry.setMode(mode);
		tar.putArchiveEntry(entry);
		IOUtils.copy(Files.newInputStream(file.toPath()), tar);
		tar.closeArchiveEntry();
	}
	private void writeCertificateBindingFiles() throws IOException {
		File bindingDir = new File(this.gradleBuild.getProjectDir(), 'bindings/ca-certificates');
		bindingDir.mkdirs();
		File type = new File(bindingDir, 'type');
		try (PrintWriter writer = new PrintWriter(new FileWriter(type))) {
			writer.print('ca-certificates');
		}
		File cert1 = new File(bindingDir, 'test1.crt');
		try (PrintWriter writer = new PrintWriter(new FileWriter(cert1))) {
			writer.println('---certificate one---');
		}
		File cert2 = new File(bindingDir, 'test2.crt');
		try (PrintWriter writer = new PrintWriter(new FileWriter(cert2))) {
			writer.println('---certificate two---');
		}
	}
	private void removeImages(String... names) throws IOException {
		ImageApi imageApi = new DockerApi().image();
		for (String name : names) {
			try {
				imageApi.remove(ImageReference.of(name), false);
			}
			catch (DockerEngineException ex) {
				// ignore image remove failures
			}
		}
	}
	private void deleteVolumes(String... names) throws IOException {
		VolumeApi volumeApi = new DockerApi().volume();
		for (String name : names) {
			volumeApi.delete(VolumeName.of(name), false);
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@GradleCompatibility
@Testcontainers(disabledWithoutDocker = true)
@Disabled('Disabled until differences between running locally and in CI can be diagnosed')
class BootBuildImageRegistryIntegrationTests {
	@Container
	static final RegistryContainer registry = TestImage.container(RegistryContainer.class);
	String registryAddress;
	GradleBuild gradleBuild;
	@BeforeEach
	void setUp() {
		assertThat(registry.isRunning()).isTrue();
		this.registryAddress = registry.getHost() + ':' + registry.getFirstMappedPort();
	}
	@TestTemplate
	void buildsImageAndPublishesToRegistry() throws IOException {
		writeMainClass();
		String repoName = 'test-image';
		String imageName = this.registryAddress + '/' + repoName;
		BuildResult result = this.gradleBuild.build('bootBuildImage', '--imageName=' + imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Building image')
			.contains('Successfully built image')
			.contains('Pushing image "' + imageName + ':latest' + '"')
			.contains('Pushed image "' + imageName + ':latest' + '"');
		ImageReference imageReference = ImageReference.of(imageName);
		Image pulledImage = new DockerApi().image().pull(imageReference, null, UpdateListener.none());
		assertThat(pulledImage).isNotNull();
		new DockerApi().image().remove(imageReference, false);
	}
	private void writeMainClass() {
		File examplePackage = new File(this.gradleBuild.getProjectDir(), 'src/main/java/example');
		examplePackage.mkdirs();
		File main = new File(examplePackage, 'Main.java');
		try (PrintWriter writer = new PrintWriter(new FileWriter(main))) {
			writer.println('package example;');
			writer.println();
			writer.println('import java.io.IOException;');
			writer.println();
			writer.println('public class Main {');
			writer.println();
			writer.println('    public static void main(String[] args) {');
			writer.println('    }');
			writer.println();
			writer.println('}');
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.gradle;
/**
@AnalyzeClasses(packages = 'org.springframework.boot.gradle',
		importOptions = TaskConfigurationAvoidanceTests.DoNotIncludeTests.class)
class TaskConfigurationAvoidanceTests {
	@ArchTest
	void noApisThatCauseEagerTaskConfigurationShouldBeCalled(JavaClasses classes) {
		ProhibitedMethods prohibited = new ProhibitedMethods();
		prohibited.on(TaskContainer.class)
			.methodsNamed('create', 'findByPath, getByPath')
			.method('withType', Class.class, Action.class);
		prohibited.on(TaskCollection.class).methodsNamed('findByName', 'getByName');
		ArchRuleDefinition.noClasses()
			.should()
			.callMethodWhere(DescribedPredicate.describe('it would cause eager task configuration', prohibited))
			.check(classes);
	}
	static class DoNotIncludeTests implements ImportOption {
		@Override
		public boolean includes(Location location) {
			return !location.matches(Pattern.compile('.*Tests\\.class'));
		}
	}
	private static final class ProhibitedMethods implements Predicate<JavaMethodCall> {
		private final List<Predicate<JavaMethodCall>> prohibited = new ArrayList<>();
		private ProhibitedConfigurer on(Class<?> type) {
			return new ProhibitedConfigurer(type);
		}
		@Override
		public boolean apply(JavaMethodCall methodCall) {
			for (Predicate<JavaMethodCall> spec : this.prohibited) {
				if (spec.apply(methodCall)) {
					return true;
				}
			}
			return false;
		}
		private final class ProhibitedConfigurer {
			private final Class<?> type;
			private ProhibitedConfigurer(Class<?> type) {
				this.type = type;
			}
			private ProhibitedConfigurer methodsNamed(String... names) {
				for (String name : names) {
					ProhibitedMethods.this.prohibited.add(new ProhibitMethodsNamed(this.type, name));
				}
				return this;
			}
			private ProhibitedConfigurer method(String name, Class<?>... parameterTypes) {
				ProhibitedMethods.this.prohibited
					.add(new ProhibitMethod(this.type, name, Arrays.asList(parameterTypes)));
				return this;
			}
		}
		static class ProhibitMethodsNamed implements Predicate<JavaMethodCall> {
			private final Class<?> owner;
			private final String name;
			ProhibitMethodsNamed(Class<?> owner, String name) {
				this.owner = owner;
				this.name = name;
			}
			@Override
			public boolean apply(JavaMethodCall methodCall) {
				return methodCall.getTargetOwner().isEquivalentTo(this.owner) && methodCall.getName().equals(this.name);
			}
		}
		private static final class ProhibitMethod extends ProhibitMethodsNamed {
			private final List<Class<?>> parameterTypes;
			private ProhibitMethod(Class<?> owner, String name, List<Class<?>> parameterTypes) {
				super(owner, name);
				this.parameterTypes = parameterTypes;
			}
			@Override
			public boolean apply(JavaMethodCall methodCall) {
				return super.apply(methodCall) && match(methodCall.getTarget().getParameterTypes());
			}
			private boolean match(List<JavaType> callParameterTypes) {
				if (this.parameterTypes.size() != callParameterTypes.size()) {
					return false;
				}
				for (int i = 0; i < this.parameterTypes.size(); i++) {
					if (!callParameterTypes.get(i).toErasure().isEquivalentTo(this.parameterTypes.get(i))) {
						return false;
					}
				}
				return true;
			}
		}
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@GradleCompatibility
class WarPluginActionIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void noBootWarTaskWithoutWarPluginApplied() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=bootWar').getOutput())
			.contains('bootWar exists = false');
	}
	@TestTemplate
	void applyingWarPluginCreatesBootWarTask() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=bootWar', '-PapplyWarPlugin').getOutput())
			.contains('bootWar exists = true');
	}
	@TestTemplate
	void assembleRunsBootWarAndWar() {
		BuildResult result = this.gradleBuild.build('assemble');
		assertThat(result.task(':bootWar').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.task(':war').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		File buildLibs = new File(this.gradleBuild.getProjectDir(), 'build/libs');
		assertThat(buildLibs.listFiles()).containsExactlyInAnyOrder(
				new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '.war'),
				new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '-plain.war'));
	}
	@TestTemplate
	void errorMessageIsHelpfulWhenMainClassCannotBeResolved() {
		BuildResult result = this.gradleBuild.buildAndFail('build', '-PapplyWarPlugin');
		assertThat(result.task(':bootWar').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).contains('Main class name has not been configured and it could not be resolved');
	}
	@TestTemplate
	void taskConfigurationIsAvoided() throws IOException {
		BuildResult result = this.gradleBuild.build('help');
		String output = result.getOutput();
		BufferedReader reader = new BufferedReader(new StringReader(output));
		String line;
		Set<String> configured = new HashSet<>();
		while ((line = reader.readLine()) != null) {
			if (line.startsWith('Configuring :')) {
				configured.add(line.substring('Configuring :'.length()));
			}
		}
		if (GradleVersion.version(this.gradleBuild.getGradleVersion()).compareTo(GradleVersion.version('7.3.3')) < 0) {
			assertThat(configured).containsExactly('help');
		}
		else {
			assertThat(configured).containsExactlyInAnyOrder('help', 'clean');
		}
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@GradleCompatibility(configurationCache = true)
class JavaPluginActionIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void noBootJarTaskWithoutJavaPluginApplied() {
		assertThat(this.gradleBuild.build('tasks').getOutput()).doesNotContain('bootJar');
	}
	@TestTemplate
	void applyingJavaPluginCreatesBootJarTask() {
		assertThat(this.gradleBuild.build('tasks').getOutput()).contains('bootJar');
	}
	@TestTemplate
	void noBootRunTaskWithoutJavaPluginApplied() {
		assertThat(this.gradleBuild.build('tasks').getOutput()).doesNotContain('bootRun');
	}
	@TestTemplate
	void noBootTestRunTaskWithoutJavaPluginApplied() {
		assertThat(this.gradleBuild.build('tasks').getOutput()).doesNotContain('bootTestRun');
	}
	@TestTemplate
	void applyingJavaPluginCreatesBootRunTask() {
		assertThat(this.gradleBuild.build('tasks').getOutput()).contains('bootRun');
	}
	@TestTemplate
	void applyingJavaPluginCreatesBootTestRunTask() {
		assertThat(this.gradleBuild.build('tasks').getOutput()).contains('bootTestRun');
	}
	@TestTemplate
	void javaCompileTasksUseUtf8Encoding() {
		assertThat(this.gradleBuild.build('build').getOutput()).contains('compileJava = UTF-8')
			.contains('compileTestJava = UTF-8');
	}
	@TestTemplate
	void javaCompileTasksUseParametersCompilerFlagByDefault() {
		assertThat(this.gradleBuild.build('build').getOutput()).contains('compileJava compiler args: [-parameters]')
			.contains('compileTestJava compiler args: [-parameters]');
	}
	@TestTemplate
	void javaCompileTasksUseParametersAndAdditionalCompilerFlags() {
		assertThat(this.gradleBuild.build('build').getOutput())
			.contains('compileJava compiler args: [-parameters, -Xlint:all]')
			.contains('compileTestJava compiler args: [-parameters, -Xlint:all]');
	}
	@TestTemplate
	void javaCompileTasksCanOverrideDefaultParametersCompilerFlag() {
		assertThat(this.gradleBuild.build('build').getOutput()).contains('compileJava compiler args: [-Xlint:all]')
			.contains('compileTestJava compiler args: [-Xlint:all]');
	}
	@TestTemplate
	void assembleRunsBootJarAndJar() {
		BuildResult result = this.gradleBuild.build('assemble');
		assertThat(result.task(':bootJar').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.task(':jar').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		File buildLibs = new File(this.gradleBuild.getProjectDir(), 'build/libs');
		assertThat(buildLibs.listFiles()).containsExactlyInAnyOrder(
				new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '.jar'),
				new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '-plain.jar'));
	}
	@TestTemplate
	void errorMessageIsHelpfulWhenMainClassCannotBeResolved() {
		BuildResult result = this.gradleBuild.buildAndFail('build', '-PapplyJavaPlugin');
		assertThat(result.task(':bootJar').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		assertThat(result.getOutput()).contains('Main class name has not been configured and it could not be resolved');
	}
	@TestTemplate
	void additionalMetadataLocationsConfiguredWhenProcessorIsPresent() throws IOException {
		createMinimalMainSource();
		File libs = new File(this.gradleBuild.getProjectDir(), 'libs');
		libs.mkdirs();
		new JarOutputStream(new FileOutputStream(new File(libs, 'spring-boot-configuration-processor-1.2.3.jar')))
			.close();
		BuildResult result = this.gradleBuild.build('compileJava');
		assertThat(result.task(':compileJava').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('compileJava compiler args: [-parameters, -Aorg.springframework.boot.'
				+ 'configurationprocessor.additionalMetadataLocations='
				+ new File(this.gradleBuild.getProjectDir(), 'src/main/resources').getCanonicalPath());
	}
	@TestTemplate
	void additionalMetadataLocationsNotConfiguredWhenProcessorIsAbsent() throws IOException {
		createMinimalMainSource();
		BuildResult result = this.gradleBuild.build('compileJava');
		assertThat(result.task(':compileJava').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('compileJava compiler args: [-parameters]');
	}
	@TestTemplate
	void applyingJavaPluginCreatesDevelopmentOnlyConfiguration() {
		assertThat(this.gradleBuild.build('help').getOutput()).contains('developmentOnly exists = true');
	}
	@TestTemplate
	void applyingJavaPluginCreatesTestAndDevelopmentOnlyConfiguration() {
		assertThat(this.gradleBuild.build('help').getOutput()).contains('testAndDevelopmentOnly exists = true');
	}
	@TestTemplate
	void testCompileClasspathIncludesTestAndDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).contains('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void testRuntimeClasspathIncludesTestAndDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).contains('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void testCompileClasspathDoesNotIncludeDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).doesNotContain('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void testRuntimeClasspathDoesNotIncludeDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).doesNotContain('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void compileClasspathDoesNotIncludeTestAndDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).doesNotContain('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void runtimeClasspathIncludesTestAndDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).contains('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void compileClasspathDoesNotIncludeDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).doesNotContain('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void runtimeClasspathIncludesDevelopmentOnlyDependencies() {
		assertThat(this.gradleBuild.build('help').getOutput()).contains('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void productionRuntimeClasspathIsConfiguredWithAttributesThatMatchRuntimeClasspath() {
		String output = this.gradleBuild.build('build').getOutput();
		Matcher matcher = Pattern.compile('runtimeClasspath: (\\[.*])').matcher(output);
		assertThat(matcher.find()).as('%s found in %s', matcher, output).isTrue();
		String attributes = matcher.group(1);
		assertThat(output).contains('productionRuntimeClasspath: ' + attributes);
	}
	@TestTemplate
	void productionRuntimeClasspathIsConfiguredWithResolvabilityAndConsumabilityThatMatchesRuntimeClasspath() {
		String output = this.gradleBuild.build('build').getOutput();
		assertThat(output).contains('runtimeClasspath canBeResolved: true');
		assertThat(output).contains('runtimeClasspath canBeConsumed: false');
		assertThat(output).contains('productionRuntimeClasspath canBeResolved: true');
		assertThat(output).contains('productionRuntimeClasspath canBeConsumed: false');
	}
	@TestTemplate
	void taskConfigurationIsAvoided() throws IOException {
		BuildResult result = this.gradleBuild.build('help');
		String output = result.getOutput();
		BufferedReader reader = new BufferedReader(new StringReader(output));
		String line;
		Set<String> configured = new HashSet<>();
		while ((line = reader.readLine()) != null) {
			if (line.startsWith('Configuring :')) {
				configured.add(line.substring('Configuring :'.length()));
			}
		}
		if (!this.gradleBuild.isConfigurationCache() && GradleVersion.version(this.gradleBuild.getGradleVersion())
			.compareTo(GradleVersion.version('7.3.3')) < 0) {
			assertThat(configured).containsExactly('help');
		}
		else {
			assertThat(configured).containsExactlyInAnyOrder('help', 'clean');
		}
	}
	private void createMinimalMainSource() throws IOException {
		File examplePackage = new File(this.gradleBuild.getProjectDir(), 'src/main/java/com/example');
		examplePackage.mkdirs();
		new File(examplePackage, 'Application.java').createNewFile();
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@DisabledForJreRange(min = JRE.JAVA_20)
@ExtendWith(GradleBuildExtension.class)
class KotlinPluginActionIntegrationTests {
	GradleBuild gradleBuild = new PluginClasspathGradleBuild();
	@Test
	void noKotlinVersionPropertyWithoutKotlinPlugin() {
		assertThat(this.gradleBuild.build('kotlinVersion').getOutput()).contains('Kotlin version: none');
	}
	@Test
	void kotlinVersionPropertyIsSet() {
		String output = this.gradleBuild.build('kotlinVersion', 'dependencies', '--configuration', 'compileClasspath')
			.getOutput();
		assertThat(output).containsPattern('Kotlin version: [0-9]\\.[0-9]\\.[0-9]+');
	}
	@Test
	void kotlinCompileTasksUseJavaParametersFlagByDefault() {
		assertThat(this.gradleBuild.build('kotlinCompileTasksJavaParameters').getOutput())
			.contains('compileKotlin java parameters: true')
			.contains('compileTestKotlin java parameters: true');
	}
	@Test
	void kotlinCompileTasksCanOverrideDefaultJavaParametersFlag() {
		assertThat(this.gradleBuild.build('kotlinCompileTasksJavaParameters').getOutput())
			.contains('compileKotlin java parameters: false')
			.contains('compileTestKotlin java parameters: false');
	}
	@Test
	void taskConfigurationIsAvoided() throws IOException {
		BuildResult result = this.gradleBuild.build('help');
		String output = result.getOutput();
		BufferedReader reader = new BufferedReader(new StringReader(output));
		String line;
		Set<String> configured = new HashSet<>();
		while ((line = reader.readLine()) != null) {
			if (line.startsWith('Configuring :')) {
				configured.add(line.substring('Configuring :'.length()));
			}
		}
		assertThat(configured).containsExactlyInAnyOrder('help', 'compileJava', 'clean');
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@ClassPathExclusions('kotlin-daemon-client-*.jar')
class SpringBootPluginTests {
	@TempDir
	File temp;
	@Test
	void bootArchivesConfigurationsCannotBeResolved() {
		Project project = GradleProjectBuilder.builder().withProjectDir(this.temp).build();
		project.getPlugins().apply(SpringBootPlugin.class);
		Configuration bootArchives = project.getConfigurations()
			.getByName(SpringBootPlugin.BOOT_ARCHIVES_CONFIGURATION_NAME);
		assertThat(bootArchives.isCanBeResolved()).isFalse();
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@GradleCompatibility
class NativeImagePluginActionIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void applyingNativeImagePluginAppliesAotPlugin() {
		assertThat(this.gradleBuild.build('aotPluginApplied').getOutput())
			.contains('org.springframework.boot.aot applied = true');
	}
	@TestTemplate
	void reachabilityMetadataConfigurationFilesAreCopiedToJar() throws IOException {
		writeDummySpringApplicationAotProcessorMainClass();
		BuildResult result = this.gradleBuild.build('bootJar');
		assertThat(result.task(':bootJar').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		File buildLibs = new File(this.gradleBuild.getProjectDir(), 'build/libs');
		File jarFile = new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(buildLibs.listFiles()).contains(jarFile);
		assertThat(getEntryNames(jarFile)).contains(
				'META-INF/native-image/ch.qos.logback/logback-classic/1.2.11/reflect-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/jni-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/proxy-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/reflect-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/resource-config.json');
	}
	@TestTemplate
	void reachabilityMetadataConfigurationFilesFromFileRepositoryAreCopiedToJar() throws IOException {
		writeDummySpringApplicationAotProcessorMainClass();
		FileSystemUtils.copyRecursively(new File('src/test/resources/reachability-metadata-repository'),
				new File(this.gradleBuild.getProjectDir(), 'reachability-metadata-repository'));
		BuildResult result = this.gradleBuild.build('bootJar');
		assertThat(result.task(':bootJar').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		File buildLibs = new File(this.gradleBuild.getProjectDir(), 'build/libs');
		File jarFile = new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(buildLibs.listFiles()).contains(jarFile);
		assertThat(getEntryNames(jarFile)).contains(
				'META-INF/native-image/ch.qos.logback/logback-classic/1.2.11/reflect-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/jni-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/proxy-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/reflect-config.json',
				'META-INF/native-image/org.jline/jline/3.21.0/resource-config.json');
	}
	@TestTemplate
	void developmentOnlyDependenciesDoNotAppearInNativeImageClasspath() {
		writeDummySpringApplicationAotProcessorMainClass();
		BuildResult result = this.gradleBuild.build('checkNativeImageClasspath');
		assertThat(result.getOutput()).doesNotContain('commons-lang');
	}
	@TestTemplate
	void testAndDevelopmentOnlyDependenciesDoNotAppearInNativeImageClasspath() {
		writeDummySpringApplicationAotProcessorMainClass();
		BuildResult result = this.gradleBuild.build('checkNativeImageClasspath');
		assertThat(result.getOutput()).doesNotContain('commons-lang');
	}
	@TestTemplate
	void classesGeneratedDuringAotProcessingAreOnTheNativeImageClasspath() {
		BuildResult result = this.gradleBuild.build('checkNativeImageClasspath');
		assertThat(result.getOutput()).contains(projectPath('build/classes/java/aot'),
				projectPath('build/resources/aot'), projectPath('build/generated/aotClasses'));
	}
	@TestTemplate
	void classesGeneratedDuringAotTestProcessingAreOnTheTestNativeImageClasspath() {
		BuildResult result = this.gradleBuild.build('checkTestNativeImageClasspath');
		assertThat(result.getOutput()).contains(projectPath('build/classes/java/aotTest'),
				projectPath('build/resources/aotTest'), projectPath('build/generated/aotTestClasses'));
	}
	@TestTemplate
	void nativeEntryIsAddedToManifest() throws IOException {
		writeDummySpringApplicationAotProcessorMainClass();
		BuildResult result = this.gradleBuild.build('bootJar');
		assertThat(result.task(':bootJar').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		File buildLibs = new File(this.gradleBuild.getProjectDir(), 'build/libs');
		JarFile jarFile = new JarFile(new File(buildLibs, this.gradleBuild.getProjectDir().getName() + '.jar'));
		Manifest manifest = jarFile.getManifest();
		assertThat(manifest.getMainAttributes().getValue('Spring-Boot-Native-Processed')).isEqualTo('true');
	}
	private String projectPath(String path) {
		try {
			return new File(this.gradleBuild.getProjectDir(), path).getCanonicalPath();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void writeDummySpringApplicationAotProcessorMainClass() {
		File examplePackage = new File(this.gradleBuild.getProjectDir(), 'src/main/java/org/springframework/boot');
		examplePackage.mkdirs();
		File main = new File(examplePackage, 'SpringApplicationAotProcessor.java');
		try (PrintWriter writer = new PrintWriter(new FileWriter(main))) {
			writer.println('package org.springframework.boot;');
			writer.println();
			writer.println('import java.io.IOException;');
			writer.println();
			writer.println('public class SpringApplicationAotProcessor {');
			writer.println();
			writer.println('    public static void main(String[] args) {');
			writer.println('    }');
			writer.println();
			writer.println('}');
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	protected List<String> getEntryNames(File file) throws IOException {
		List<String> entryNames = new ArrayList<>();
		try (JarFile jarFile = new JarFile(file)) {
			Enumeration<JarEntry> entries = jarFile.entries();
			while (entries.hasMoreElements()) {
				entryNames.add(entries.nextElement().getName());
			}
		}
		return entryNames;
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@GradleCompatibility
class SpringBootAotPluginIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void noProcessAotTaskWithoutAotPluginApplied() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=processAot').getOutput())
			.contains('processAot exists = false');
	}
	@TestTemplate
	void noProcessTestAotTaskWithoutAotPluginApplied() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=processTestAot').getOutput())
			.contains('processTestAot exists = false');
	}
	@TestTemplate
	void applyingAotPluginCreatesProcessAotTask() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=processAot').getOutput())
			.contains('processAot exists = true');
	}
	@TestTemplate
	void applyingAotPluginCreatesProcessTestAotTask() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=processTestAot').getOutput())
			.contains('processTestAot exists = true');
	}
	@TestTemplate
	void processAotHasLibraryResourcesOnItsClasspath() throws IOException {
		File settings = new File(this.gradleBuild.getProjectDir(), 'settings.gradle');
		Files.write(settings.toPath(), List.of('include "library"'));
		File library = new File(this.gradleBuild.getProjectDir(), 'library');
		library.mkdirs();
		Files.write(library.toPath().resolve('build.gradle'), List.of('plugins {', '    id "java-library"', '}'));
		assertThat(this.gradleBuild.build('processAotClasspath').getOutput()).contains('library.jar');
	}
	@TestTemplate
	void processTestAotHasLibraryResourcesOnItsClasspath() throws IOException {
		File settings = new File(this.gradleBuild.getProjectDir(), 'settings.gradle');
		Files.write(settings.toPath(), List.of('include "library"'));
		File library = new File(this.gradleBuild.getProjectDir(), 'library');
		library.mkdirs();
		Files.write(library.toPath().resolve('build.gradle'), List.of('plugins {', '    id "java-library"', '}'));
		assertThat(this.gradleBuild.build('processTestAotClasspath').getOutput()).contains('library.jar');
	}
	@TestTemplate
	void processAotHasTransitiveRuntimeDependenciesOnItsClasspath() {
		String output = this.gradleBuild.build('processAotClasspath').getOutput();
		assertThat(output).contains('org.jboss.logging' + File.separatorChar + 'jboss-logging');
	}
	@TestTemplate
	void processTestAotHasTransitiveRuntimeDependenciesOnItsClasspath() {
		String output = this.gradleBuild.build('processTestAotClasspath').getOutput();
		assertThat(output).contains('org.jboss.logging' + File.separatorChar + 'jboss-logging');
	}
	@TestTemplate
	void processAotDoesNotHaveDevelopmentOnlyDependenciesOnItsClasspath() {
		String output = this.gradleBuild.build('processAotClasspath').getOutput();
		assertThat(output).doesNotContain('commons-lang');
	}
	@TestTemplate
	void processTestAotDoesNotHaveDevelopmentOnlyDependenciesOnItsClasspath() {
		String output = this.gradleBuild.build('processTestAotClasspath').getOutput();
		assertThat(output).doesNotContain('commons-lang');
	}
	@TestTemplate
	void processAotDoesNotHaveTestAndDevelopmentOnlyDependenciesOnItsClasspath() {
		String output = this.gradleBuild.build('processAotClasspath').getOutput();
		assertThat(output).doesNotContain('commons-lang');
	}
	@TestTemplate
	void processTestAotHasTestAndDevelopmentOnlyDependenciesOnItsClasspath() {
		String output = this.gradleBuild.build('processTestAotClasspath').getOutput();
		assertThat(output).contains('commons-lang');
	}
	@TestTemplate
	void processAotRunsWhenProjectHasMainSource() throws IOException {
		writeMainClass('org.springframework.boot', 'SpringApplicationAotProcessor');
		writeMainClass('com.example', 'Main');
		assertThat(this.gradleBuild.build('processAot').task(':processAot').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void processTestAotIsSkippedWhenProjectHasNoTestSource() {
		assertThat(this.gradleBuild.build('processTestAot').task(':processTestAot').getOutcome())
			.isEqualTo(TaskOutcome.NO_SOURCE);
	}
	// gh-37343
	@TestTemplate
	@EnabledOnJre(JRE.JAVA_17)
	void applyingAotPluginDoesNotPreventConfigurationOfJavaToolchainLanguageVersion() {
		assertThatNoException().isThrownBy(() -> this.gradleBuild.build('help').getOutput());
	}
	private void writeMainClass(String packageName, String className) throws IOException {
		File java = new File(this.gradleBuild.getProjectDir(),
				'src/main/java/' + packageName.replace('.', '/') + '/' + className + '.java');
		java.getParentFile().mkdirs();
		Files.writeString(java.toPath(), '''
				package %s;
				public class %s {
					public static void main(String[] args) {
					}
				}
				'''.formatted(packageName, className));
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@GradleCompatibility
class DependencyManagementPluginActionIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void noDependencyManagementIsAppliedByDefault() {
		assertThat(this.gradleBuild.build('doesNotHaveDependencyManagement')
			.task(':doesNotHaveDependencyManagement')
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void bomIsImportedWhenDependencyManagementPluginIsApplied() {
		assertThat(this.gradleBuild.build('hasDependencyManagement', '-PapplyDependencyManagementPlugin')
			.task(':hasDependencyManagement')
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@GradleCompatibility
class ApplicationPluginActionIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void noBootDistributionWithoutApplicationPluginApplied() {
		assertThat(this.gradleBuild.build('distributionExists', '-PdistributionName=boot').getOutput())
			.contains('boot exists = false');
	}
	@TestTemplate
	void applyingApplicationPluginCreatesBootDistribution() {
		assertThat(this.gradleBuild.build('distributionExists', '-PdistributionName=boot', '-PapplyApplicationPlugin')
			.getOutput()).contains('boot exists = true');
	}
	@TestTemplate
	void noBootStartScriptsTaskWithoutApplicationPluginApplied() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=bootStartScripts').getOutput())
			.contains('bootStartScripts exists = false');
	}
	@TestTemplate
	void applyingApplicationPluginCreatesBootStartScriptsTask() {
		assertThat(this.gradleBuild.build('taskExists', '-PtaskName=bootStartScripts', '-PapplyApplicationPlugin')
			.getOutput()).contains('bootStartScripts exists = true');
	}
	@TestTemplate
	void createsBootStartScriptsTaskUsesApplicationPluginsDefaultJvmOpts() {
		assertThat(this.gradleBuild.build('startScriptsDefaultJvmOpts', '-PapplyApplicationPlugin').getOutput())
			.contains('bootStartScripts defaultJvmOpts = [-Dcom.example.a=alpha, -Dcom.example.b=bravo]');
	}
	@TestTemplate
	void zipDistributionForJarCanBeBuilt() throws IOException {
		assertThat(this.gradleBuild.build('bootDistZip').task(':bootDistZip').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		String name = this.gradleBuild.getProjectDir().getName();
		File distribution = new File(this.gradleBuild.getProjectDir(), 'build/distributions/' + name + '-boot.zip');
		assertThat(distribution).isFile();
		assertThat(zipEntryNames(distribution)).containsExactlyInAnyOrder(name + '-boot/', name + '-boot/lib/',
				name + '-boot/lib/' + name + '.jar', name + '-boot/bin/', name + '-boot/bin/' + name,
				name + '-boot/bin/' + name + '.bat');
	}
	@TestTemplate
	void tarDistributionForJarCanBeBuilt() throws IOException {
		assertThat(this.gradleBuild.build('bootDistTar').task(':bootDistTar').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		String name = this.gradleBuild.getProjectDir().getName();
		File distribution = new File(this.gradleBuild.getProjectDir(), 'build/distributions/' + name + '-boot.tar');
		assertThat(distribution).isFile();
		assertThat(tarEntryNames(distribution)).containsExactlyInAnyOrder(name + '-boot/', name + '-boot/lib/',
				name + '-boot/lib/' + name + '.jar', name + '-boot/bin/', name + '-boot/bin/' + name,
				name + '-boot/bin/' + name + '.bat');
	}
	@TestTemplate
	void zipDistributionForWarCanBeBuilt() throws IOException {
		assertThat(this.gradleBuild.build('bootDistZip').task(':bootDistZip').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		String name = this.gradleBuild.getProjectDir().getName();
		File distribution = new File(this.gradleBuild.getProjectDir(), 'build/distributions/' + name + '-boot.zip');
		assertThat(distribution).isFile();
		assertThat(zipEntryNames(distribution)).containsExactlyInAnyOrder(name + '-boot/', name + '-boot/lib/',
				name + '-boot/lib/' + name + '.war', name + '-boot/bin/', name + '-boot/bin/' + name,
				name + '-boot/bin/' + name + '.bat');
	}
	@TestTemplate
	void tarDistributionForWarCanBeBuilt() throws IOException {
		assertThat(this.gradleBuild.build('bootDistTar').task(':bootDistTar').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		String name = this.gradleBuild.getProjectDir().getName();
		File distribution = new File(this.gradleBuild.getProjectDir(), 'build/distributions/' + name + '-boot.tar');
		assertThat(distribution).isFile();
		assertThat(tarEntryNames(distribution)).containsExactlyInAnyOrder(name + '-boot/', name + '-boot/lib/',
				name + '-boot/lib/' + name + '.war', name + '-boot/bin/', name + '-boot/bin/' + name,
				name + '-boot/bin/' + name + '.bat');
	}
	@TestTemplate
	void applicationNameCanBeUsedToCustomizeDistributionName() throws IOException {
		assertThat(this.gradleBuild.build('bootDistTar').task(':bootDistTar').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		File distribution = new File(this.gradleBuild.getProjectDir(), 'build/distributions/custom-boot.tar');
		assertThat(distribution).isFile();
		String name = this.gradleBuild.getProjectDir().getName();
		assertThat(tarEntryNames(distribution)).containsExactlyInAnyOrder('custom-boot/', 'custom-boot/lib/',
				'custom-boot/lib/' + name + '.jar', 'custom-boot/bin/', 'custom-boot/bin/custom',
				'custom-boot/bin/custom.bat');
	}
	@TestTemplate
	void scriptsHaveCorrectPermissions() throws IOException {
		assertThat(this.gradleBuild.build('bootDistTar').task(':bootDistTar').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		String name = this.gradleBuild.getProjectDir().getName();
		File distribution = new File(this.gradleBuild.getProjectDir(), 'build/distributions/' + name + '-boot.tar');
		assertThat(distribution).isFile();
		tarEntries(distribution, (entry) -> {
			int filePermissions = entry.getMode() & 0777;
			if (entry.isFile() && !entry.getName().startsWith(name + '-boot/bin/')) {
				assertThat(filePermissions).isEqualTo(0644);
			}
			else {
				assertThat(filePermissions).isEqualTo(0755);
			}
		});
	}
	@TestTemplate
	void taskConfigurationIsAvoided() throws IOException {
		BuildResult result = this.gradleBuild.build('help');
		String output = result.getOutput();
		BufferedReader reader = new BufferedReader(new StringReader(output));
		String line;
		Set<String> configured = new HashSet<>();
		while ((line = reader.readLine()) != null) {
			if (line.startsWith('Configuring :')) {
				configured.add(line.substring('Configuring :'.length()));
			}
		}
		if (GradleVersion.version(this.gradleBuild.getGradleVersion()).compareTo(GradleVersion.version('7.3.3')) < 0) {
			assertThat(configured).containsExactly('help');
		}
		else {
			assertThat(configured).containsExactlyInAnyOrder('help', 'clean');
		}
	}
	private List<String> zipEntryNames(File distribution) throws IOException {
		List<String> entryNames = new ArrayList<>();
		try (ZipFile zipFile = new ZipFile(distribution)) {
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while (entries.hasMoreElements()) {
				entryNames.add(entries.nextElement().getName());
			}
		}
		return entryNames;
	}
	private List<String> tarEntryNames(File distribution) throws IOException {
		List<String> entryNames = new ArrayList<>();
		try (TarArchiveInputStream input = new TarArchiveInputStream(new FileInputStream(distribution))) {
			TarArchiveEntry entry;
			while ((entry = input.getNextEntry()) != null) {
				entryNames.add(entry.getName());
			}
		}
		return entryNames;
	}
	private void tarEntries(File distribution, Consumer<TarArchiveEntry> consumer) throws IOException {
		try (TarArchiveInputStream input = new TarArchiveInputStream(new FileInputStream(distribution))) {
			TarArchiveEntry entry;
			while ((entry = input.getNextEntry()) != null) {
				consumer.accept(entry);
			}
		}
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
@GradleCompatibility
class OnlyDependencyManagementIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void dependencyManagementCanBeConfiguredUsingCoordinatesConstant() {
		assertThat(this.gradleBuild.build('dependencyManagement').getOutput())
			.contains('org.springframework.boot:spring-boot-starter ');
	}
}
/*
package org.springframework.boot.gradle.dsl;
/**
@GradleCompatibility
class BuildInfoDslIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void basicJar() {
		assertThat(this.gradleBuild.build('bootBuildInfo', '--stacktrace').task(':bootBuildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		Properties properties = buildInfoProperties();
		assertThat(properties).containsEntry('build.name', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.artifact', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.group', 'com.example');
		assertThat(properties).containsEntry('build.version', '1.0');
	}
	@TestTemplate
	void jarWithCustomName() {
		assertThat(this.gradleBuild.build('bootBuildInfo', '--stacktrace').task(':bootBuildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		Properties properties = buildInfoProperties();
		assertThat(properties).containsEntry('build.name', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.artifact', 'foo');
		assertThat(properties).containsEntry('build.group', 'com.example');
		assertThat(properties).containsEntry('build.version', '1.0');
	}
	@TestTemplate
	void basicWar() {
		assertThat(this.gradleBuild.build('bootBuildInfo', '--stacktrace').task(':bootBuildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		Properties properties = buildInfoProperties();
		assertThat(properties).containsEntry('build.name', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.artifact', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.group', 'com.example');
		assertThat(properties).containsEntry('build.version', '1.0');
	}
	@TestTemplate
	void warWithCustomName() {
		assertThat(this.gradleBuild.build('bootBuildInfo', '--stacktrace').task(':bootBuildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		Properties properties = buildInfoProperties();
		assertThat(properties).containsEntry('build.name', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.artifact', 'foo');
		assertThat(properties).containsEntry('build.group', 'com.example');
		assertThat(properties).containsEntry('build.version', '1.0');
	}
	@TestTemplate
	void additionalProperties() {
		assertThat(this.gradleBuild.build('bootBuildInfo', '--stacktrace').task(':bootBuildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		Properties properties = buildInfoProperties();
		assertThat(properties).containsEntry('build.name', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.artifact', this.gradleBuild.getProjectDir().getName());
		assertThat(properties).containsEntry('build.group', 'com.example');
		assertThat(properties).containsEntry('build.version', '1.0');
		assertThat(properties).containsEntry('build.a', 'alpha');
		assertThat(properties).containsEntry('build.b', 'bravo');
	}
	@TestTemplate
	void classesDependency() {
		assertThat(this.gradleBuild.build('classes', '--stacktrace').task(':bootBuildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
	}
	private Properties buildInfoProperties() {
		File file = new File(this.gradleBuild.getProjectDir(), 'build/resources/main/META-INF/build-info.properties');
		assertThat(file).isFile();
		Properties properties = new Properties();
		try (FileReader reader = new FileReader(file)) {
			properties.load(reader);
			return properties;
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.gradle.testkit;
/**
public class PluginClasspathGradleBuild extends GradleBuild {
	public PluginClasspathGradleBuild() {
		super();
	}
	public PluginClasspathGradleBuild(Dsl dsl) {
		super(dsl);
	}
	@Override
	public GradleRunner prepareRunner(String... arguments) throws IOException {
		return super.prepareRunner(arguments).withPluginClasspath(pluginClasspath());
	}
	private List<File> pluginClasspath() {
		return Arrays.asList(new File('bin/main'), new File('build/classes/java/main'),
				new File('build/resources/main'), new File(pathOfJarContaining(LaunchScript.class)),
				new File(pathOfJarContaining(ClassVisitor.class)),
				new File(pathOfJarContaining(DependencyManagementPlugin.class)),
				new File(pathOfJarContaining('org.jetbrains.kotlin.cli.common.PropertiesKt')),
				new File(pathOfJarContaining(KotlinPlatformJvmPlugin.class)),
				new File(pathOfJarContaining(KotlinProject.class)),
				new File(pathOfJarContaining(KotlinToolingVersion.class)),
				new File(pathOfJarContaining('org.jetbrains.kotlin.daemon.client.KotlinCompilerClient')),
				new File(pathOfJarContaining(KotlinCompilerPluginSupportPlugin.class)),
				new File(pathOfJarContaining(LanguageSettings.class)),
				new File(pathOfJarContaining(ArchiveEntry.class)), new File(pathOfJarContaining(BuildRequest.class)),
				new File(pathOfJarContaining(HttpClientConnectionManager.class)),
				new File(pathOfJarContaining(HttpRequest.class)),
				new File(pathOfJarContaining(HttpVersionPolicy.class)), new File(pathOfJarContaining(Module.class)),
				new File(pathOfJarContaining(Versioned.class)),
				new File(pathOfJarContaining(ParameterNamesModule.class)),
				new File(pathOfJarContaining(JsonView.class)), new File(pathOfJarContaining(Platform.class)),
				new File(pathOfJarContaining(Toml.class)), new File(pathOfJarContaining(Lexer.class)),
				new File(pathOfJarContaining('org.graalvm.buildtools.gradle.NativeImagePlugin')),
				new File(pathOfJarContaining('org.graalvm.reachability.GraalVMReachabilityMetadataRepository')),
				new File(pathOfJarContaining('org.graalvm.buildtools.utils.SharedConstants')));
	}
	private String pathOfJarContaining(String className) {
		try {
			return pathOfJarContaining(Class.forName(className));
		}
		catch (ClassNotFoundException ex) {
			throw new IllegalArgumentException(ex);
		}
	}
	private String pathOfJarContaining(Class<?> type) {
		return type.getProtectionDomain().getCodeSource().getLocation().getPath();
	}
}
/*
package org.springframework.boot.gradle.junit;
/**
public class GradleMultiDslExtension implements TestTemplateInvocationContextProvider {
	@Override
	public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {
		return Stream.of(Dsl.values()).map(DslTestTemplateInvocationContext::new);
	}
	@Override
	public boolean supportsTestTemplate(ExtensionContext context) {
		return true;
	}
	private static final class DslTestTemplateInvocationContext implements TestTemplateInvocationContext {
		private final Dsl dsl;
		DslTestTemplateInvocationContext(Dsl dsl) {
			this.dsl = dsl;
		}
		@Override
		public List<Extension> getAdditionalExtensions() {
			GradleBuild gradleBuild = new PluginClasspathGradleBuild(this.dsl)
				.gradleVersion(GradleVersions.minimumCompatible());
			return Arrays.asList(new GradleBuildFieldSetter(gradleBuild), new GradleBuildExtension());
		}
		@Override
		public String getDisplayName(int invocationIndex) {
			return this.dsl.getName();
		}
	}
}
/*
package org.springframework.boot.gradle.junit;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@ExtendWith(GradleCompatibilityExtension.class)
public @interface GradleCompatibility {
	/**
	 * Whether to include running Gradle with {@code --cache-configuration} cache in the
	 * compatibility matrix.
	 * @return {@code true} to enable the configuration cache, {@code false} otherwise
	 */
	boolean configurationCache() default false;
	String versionsLessThan() default '';
}
/*
package org.springframework.boot.gradle.junit;
/**
final class GradleCompatibilityExtension implements TestTemplateInvocationContextProvider {
	private static final List<String> GRADLE_VERSIONS = GradleVersions.allCompatible();
	@Override
	public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {
		GradleVersion highestVersion = GRADLE_VERSIONS.stream()
			.map(GradleVersion::version)
			.collect(Collectors.toCollection(TreeSet::new))
			.last();
		GradleCompatibility gradleCompatibility = AnnotationUtils
			.findAnnotation(context.getRequiredTestClass(), GradleCompatibility.class)
			.get();
		Stream<String> gradleVersions = GRADLE_VERSIONS.stream();
		if (StringUtils.hasText(gradleCompatibility.versionsLessThan())) {
			GradleVersion upperExclusive = GradleVersion.version(gradleCompatibility.versionsLessThan());
			gradleVersions = gradleVersions
				.filter((version) -> GradleVersion.version(version).compareTo(upperExclusive) < 0);
		}
		return gradleVersions.flatMap((version) -> {
			List<TestTemplateInvocationContext> invocationContexts = new ArrayList<>();
			invocationContexts.add(new GradleVersionTestTemplateInvocationContext(version, false));
			boolean configurationCache = gradleCompatibility.configurationCache();
			if (configurationCache && GradleVersion.version(version).equals(highestVersion)) {
				invocationContexts.add(new GradleVersionTestTemplateInvocationContext(version, true));
			}
			return invocationContexts.stream();
		});
	}
	@Override
	public boolean supportsTestTemplate(ExtensionContext context) {
		return true;
	}
	private static final class GradleVersionTestTemplateInvocationContext implements TestTemplateInvocationContext {
		private final String gradleVersion;
		private final boolean configurationCache;
		GradleVersionTestTemplateInvocationContext(String gradleVersion, boolean configurationCache) {
			this.gradleVersion = gradleVersion;
			this.configurationCache = configurationCache;
		}
		@Override
		public String getDisplayName(int invocationIndex) {
			return 'Gradle ' + this.gradleVersion + ((this.configurationCache) ? ' --configuration-cache' : '');
		}
		@Override
		public List<Extension> getAdditionalExtensions() {
			GradleBuild gradleBuild = new PluginClasspathGradleBuild().gradleVersion(this.gradleVersion);
			if (this.configurationCache) {
				gradleBuild.configurationCache();
			}
			return Arrays.asList(new GradleBuildFieldSetter(gradleBuild), new GradleBuildExtension());
		}
	}
}
/*
package org.springframework.boot.gradle.junit;
/**
final class GradleBuildFieldSetter implements BeforeEachCallback {
	private final GradleBuild gradleBuild;
	GradleBuildFieldSetter(GradleBuild gradleBuild) {
		this.gradleBuild = gradleBuild;
	}
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		Field field = ReflectionUtils.findField(context.getRequiredTestClass(), 'gradleBuild');
		field.setAccessible(true);
		field.set(context.getRequiredTestInstance(), this.gradleBuild);
	}
}
/*
package org.springframework.boot.gradle.junit;
/**
public final class GradleProjectBuilder {
	private File projectDir;
	private String name;
	private GradleProjectBuilder() {
	}
	public static GradleProjectBuilder builder() {
		return new GradleProjectBuilder();
	}
	public GradleProjectBuilder withProjectDir(File dir) {
		this.projectDir = dir;
		return this;
	}
	public GradleProjectBuilder withName(String name) {
		this.name = name;
		return this;
	}
	public Project build() {
		Assert.notNull(this.projectDir, 'ProjectDir must not be null');
		ProjectBuilder builder = ProjectBuilder.builder();
		builder.withProjectDir(this.projectDir);
		File userHome = new File(this.projectDir, 'userHome');
		builder.withGradleUserHomeDir(userHome);
		if (StringUtils.hasText(this.name)) {
			builder.withName(this.name);
		}
		return builder.build();
	}
}
/*
package org.springframework.boot.gradle.docs;
/**
final class Examples {
	static final String DIR = 'src/docs/antora/modules/gradle-plugin/examples/';
	private Examples() {
	}
}
/*
package org.springframework.boot.gradle.docs;
/**
@ExtendWith(GradleMultiDslExtension.class)
class ManagingDependenciesDocumentationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void dependenciesExampleEvaluatesSuccessfully() {
		this.gradleBuild.script(Examples.DIR + 'managing-dependencies/dependencies').build();
	}
	@TestTemplate
	void customManagedVersions() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'managing-dependencies/custom-version')
			.build('slf4jVersion')
			.getOutput()).contains('1.7.20');
	}
	@TestTemplate
	void dependencyManagementInIsolation() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'managing-dependencies/configure-bom')
			.build('dependencyManagement')
			.getOutput()).contains('org.springframework.boot:spring-boot-starter ');
	}
	@TestTemplate
	void dependencyManagementInIsolationWithPluginsBlock() {
		assumingThat(this.gradleBuild.getDsl() == Dsl.KOTLIN,
				() -> assertThat(
						this.gradleBuild.script(Examples.DIR + 'managing-dependencies/configure-bom-with-plugins')
							.build('dependencyManagement')
							.getOutput())
					.contains('org.springframework.boot:spring-boot-starter TEST-SNAPSHOT'));
	}
	@TestTemplate
	void configurePlatform() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'managing-dependencies/configure-platform')
			.build('dependencies', '--configuration', 'compileClasspath')
			.getOutput()).contains('org.springframework.boot:spring-boot-starter ');
	}
	@TestTemplate
	void customManagedVersionsWithPlatform() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'managing-dependencies/custom-version-with-platform')
			.build('dependencies', '--configuration', 'compileClasspath')
			.getOutput()).contains('1.7.20');
	}
}
/*
package org.springframework.boot.gradle.docs;
/**
@ExtendWith(GradleMultiDslExtension.class)
class IntegratingWithActuatorDocumentationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void basicBuildInfo() {
		this.gradleBuild.script(Examples.DIR + 'integrating-with-actuator/build-info-basic').build('bootBuildInfo');
		assertThat(new File(this.gradleBuild.getProjectDir(), 'build/resources/main/META-INF/build-info.properties'))
			.isFile();
	}
	@TestTemplate
	void buildInfoCustomValues() {
		this.gradleBuild.script(Examples.DIR + 'integrating-with-actuator/build-info-custom-values')
			.build('bootBuildInfo');
		File file = new File(this.gradleBuild.getProject