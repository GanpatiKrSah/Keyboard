);
		then(factory.getWebServer()).should().start();
		this.context.stop();
		then(factory.getWebServer()).should().stop();
		this.context.start();
		then(factory.getWebServer()).should(times(2)).start();
	}
	@Test
	void stopAndDestroyOnClose() {
		addWebServerFactoryBean();
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		this.context.close();
		then(factory.getWebServer()).should(times(2)).stop();
		then(factory.getWebServer()).should().destroy();
	}
	@Test
	void applicationIsUnreadyDuringShutdown() {
		TestApplicationListener listener = new TestApplicationListener();
		addWebServerFactoryBean();
		this.context.refresh();
		this.context.addApplicationListener(listener);
		this.context.close();
		assertThat(listener.receivedEvents()).hasSize(2)
			.extracting('class')
			.contains(AvailabilityChangeEvent.class, ContextClosedEvent.class);
	}
	@Test
	void whenContextIsNotActiveThenCloseDoesNotChangeTheApplicationAvailability() {
		addWebServerFactoryBean();
		TestApplicationListener listener = new TestApplicationListener();
		this.context.addApplicationListener(listener);
		this.context.registerBeanDefinition('refreshFailure', new RootBeanDefinition(RefreshFailure.class));
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(this.context::refresh);
		this.context.close();
		assertThat(listener.receivedEvents()).isEmpty();
	}
	@Test
	void cannotSecondRefresh() {
		addWebServerFactoryBean();
		this.context.refresh();
		assertThatIllegalStateException().isThrownBy(this.context::refresh);
	}
	@Test
	void servletContextAwareBeansAreInjected() {
		addWebServerFactoryBean();
		ServletContextAware bean = mock(ServletContextAware.class);
		this.context.registerBeanDefinition('bean', beanDefinition(bean));
		this.context.refresh();
		then(bean).should().setServletContext(getWebServerFactory().getServletContext());
	}
	@Test
	void missingServletWebServerFactory() {
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.withMessageContaining('Unable to start ServletWebServerApplicationContext due to missing '
					+ 'ServletWebServerFactory bean');
	}
	@Test
	void tooManyWebServerFactories() {
		addWebServerFactoryBean();
		this.context.registerBeanDefinition('webServerFactory2',
				new RootBeanDefinition(MockServletWebServerFactory.class));
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.withMessageContaining('Unable to start ServletWebServerApplicationContext due to '
					+ 'multiple ServletWebServerFactory beans');
	}
	@Test
	void singleServletBean() {
		addWebServerFactoryBean();
		Servlet servlet = mock(Servlet.class);
		this.context.registerBeanDefinition('servletBean', beanDefinition(servlet));
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		then(factory.getServletContext()).should().addServlet('servletBean', servlet);
		then(factory.getRegisteredServlet(0).getRegistration()).should().addMapping('/');
	}
	@Test
	void orderedBeanInsertedCorrectly() {
		addWebServerFactoryBean();
		OrderedFilter filter = new OrderedFilter();
		this.context.registerBeanDefinition('filterBean', beanDefinition(filter));
		FilterRegistrationBean<Filter> registration = new FilterRegistrationBean<>();
		registration.setName('filterBeanRegistration');
		registration.setFilter(mock(Filter.class));
		registration.setOrder(100);
		this.context.registerBeanDefinition('filterRegistrationBean', beanDefinition(registration));
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		then(factory.getServletContext()).should().addFilter('filterBean', filter);
		then(factory.getServletContext()).should().addFilter('filterBeanRegistration', registration.getFilter());
		assertThat(factory.getRegisteredFilter(0).getFilter()).isEqualTo(filter);
	}
	@Test
	void multipleServletBeans() {
		addWebServerFactoryBean();
		Servlet servlet1 = mock(Servlet.class, withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) servlet1).getOrder()).willReturn(1);
		Servlet servlet2 = mock(Servlet.class, withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) servlet2).getOrder()).willReturn(2);
		this.context.registerBeanDefinition('servletBean2', beanDefinition(servlet2));
		this.context.registerBeanDefinition('servletBean1', beanDefinition(servlet1));
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		ServletContext servletContext = factory.getServletContext();
		InOrder ordered = inOrder(servletContext);
		then(servletContext).should(ordered).addServlet('servletBean1', servlet1);
		then(servletContext).should(ordered).addServlet('servletBean2', servlet2);
		then(factory.getRegisteredServlet(0).getRegistration()).should().addMapping('/servletBean1/');
		then(factory.getRegisteredServlet(1).getRegistration()).should().addMapping('/servletBean2/');
	}
	@Test
	void multipleServletBeansWithMainDispatcher() {
		addWebServerFactoryBean();
		Servlet servlet1 = mock(Servlet.class, withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) servlet1).getOrder()).willReturn(1);
		Servlet servlet2 = mock(Servlet.class, withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) servlet2).getOrder()).willReturn(2);
		this.context.registerBeanDefinition('servletBean2', beanDefinition(servlet2));
		this.context.registerBeanDefinition('dispatcherServlet', beanDefinition(servlet1));
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		ServletContext servletContext = factory.getServletContext();
		InOrder ordered = inOrder(servletContext);
		then(servletContext).should(ordered).addServlet('dispatcherServlet', servlet1);
		then(servletContext).should(ordered).addServlet('servletBean2', servlet2);
		then(factory.getRegisteredServlet(0).getRegistration()).should().addMapping('/');
		then(factory.getRegisteredServlet(1).getRegistration()).should().addMapping('/servletBean2/');
	}
	@Test
	void servletAndFilterBeans() {
		addWebServerFactoryBean();
		Servlet servlet = mock(Servlet.class);
		Filter filter1 = mock(Filter.class, withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) filter1).getOrder()).willReturn(1);
		Filter filter2 = mock(Filter.class, withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) filter2).getOrder()).willReturn(2);
		this.context.registerBeanDefinition('servletBean', beanDefinition(servlet));
		this.context.registerBeanDefinition('filterBean2', beanDefinition(filter2));
		this.context.registerBeanDefinition('filterBean1', beanDefinition(filter1));
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		ServletContext servletContext = factory.getServletContext();
		InOrder ordered = inOrder(servletContext);
		then(factory.getServletContext()).should().addServlet('servletBean', servlet);
		then(factory.getRegisteredServlet(0).getRegistration()).should().addMapping('/');
		then(factory.getServletContext()).should(ordered).addFilter('filterBean1', filter1);
		then(factory.getServletContext()).should(ordered).addFilter('filterBean2', filter2);
		then(factory.getRegisteredFilter(0).getRegistration()).should()
			.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, '/*');
		then(factory.getRegisteredFilter(1).getRegistration()).should()
			.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, '/*');
	}
	@Test
	void servletContextInitializerBeans() throws Exception {
		addWebServerFactoryBean();
		ServletContextInitializer initializer1 = mock(ServletContextInitializer.class,
				withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) initializer1).getOrder()).willReturn(1);
		ServletContextInitializer initializer2 = mock(ServletContextInitializer.class,
				withSettings().extraInterfaces(Ordered.class));
		given(((Ordered) initializer2).getOrder()).willReturn(2);
		this.context.registerBeanDefinition('initializerBean2', beanDefinition(initializer2));
		this.context.registerBeanDefinition('initializerBean1', beanDefinition(initializer1));
		this.context.refresh();
		ServletContext servletContext = getWebServerFactory().getServletContext();
		InOrder ordered = inOrder(initializer1, initializer2);
		then(initializer1).should(ordered).onStartup(servletContext);
		then(initializer2).should(ordered).onStartup(servletContext);
	}
	@Test
	void servletContextListenerBeans() {
		addWebServerFactoryBean();
		ServletContextListener initializer = mock(ServletContextListener.class);
		this.context.registerBeanDefinition('initializerBean', beanDefinition(initializer));
		this.context.refresh();
		ServletContext servletContext = getWebServerFactory().getServletContext();
		then(servletContext).should().addListener(initializer);
	}
	@Test
	void unorderedServletContextInitializerBeans() throws Exception {
		addWebServerFactoryBean();
		ServletContextInitializer initializer1 = mock(ServletContextInitializer.class);
		ServletContextInitializer initializer2 = mock(ServletContextInitializer.class);
		this.context.registerBeanDefinition('initializerBean2', beanDefinition(initializer2));
		this.context.registerBeanDefinition('initializerBean1', beanDefinition(initializer1));
		this.context.refresh();
		ServletContext servletContext = getWebServerFactory().getServletContext();
		then(initializer1).should().onStartup(servletContext);
		then(initializer2).should().onStartup(servletContext);
	}
	@Test
	void servletContextInitializerBeansDoesNotSkipServletsAndFilters() throws Exception {
		addWebServerFactoryBean();
		ServletContextInitializer initializer = mock(ServletContextInitializer.class);
		Servlet servlet = mock(Servlet.class);
		Filter filter = mock(Filter.class);
		this.context.registerBeanDefinition('initializerBean', beanDefinition(initializer));
		this.context.registerBeanDefinition('servletBean', beanDefinition(servlet));
		this.context.registerBeanDefinition('filterBean', beanDefinition(filter));
		this.context.refresh();
		ServletContext servletContext = getWebServerFactory().getServletContext();
		then(initializer).should().onStartup(servletContext);
		then(servletContext).should().addServlet(anyString(), any(Servlet.class));
		then(servletContext).should().addFilter(anyString(), any(Filter.class));
	}
	@Test
	void servletContextInitializerBeansSkipsRegisteredServletsAndFilters() {
		addWebServerFactoryBean();
		Servlet servlet = mock(Servlet.class);
		Filter filter = mock(Filter.class);
		ServletRegistrationBean<Servlet> initializer = new ServletRegistrationBean<>(servlet, '/foo');
		this.context.registerBeanDefinition('initializerBean', beanDefinition(initializer));
		this.context.registerBeanDefinition('servletBean', beanDefinition(servlet));
		this.context.registerBeanDefinition('filterBean', beanDefinition(filter));
		this.context.refresh();
		ServletContext servletContext = getWebServerFactory().getServletContext();
		then(servletContext).should(atMost(1)).addServlet(anyString(), any(Servlet.class));
		then(servletContext).should(atMost(1)).addFilter(anyString(), any(Filter.class));
	}
	@Test
	void filterRegistrationBeansSkipsRegisteredFilters() {
		addWebServerFactoryBean();
		Filter filter = mock(Filter.class);
		FilterRegistrationBean<Filter> initializer = new FilterRegistrationBean<>(filter);
		this.context.registerBeanDefinition('initializerBean', beanDefinition(initializer));
		this.context.registerBeanDefinition('filterBean', beanDefinition(filter));
		this.context.refresh();
		ServletContext servletContext = getWebServerFactory().getServletContext();
		then(servletContext).should(atMost(1)).addFilter(anyString(), any(Filter.class));
	}
	@Test
	void delegatingFilterProxyRegistrationBeansSkipsTargetBeanNames() {
		addWebServerFactoryBean();
		DelegatingFilterProxyRegistrationBean initializer = new DelegatingFilterProxyRegistrationBean('filterBean');
		this.context.registerBeanDefinition('initializerBean', beanDefinition(initializer));
		BeanDefinition filterBeanDefinition = beanDefinition(new IllegalStateException('Create FilterBean Failure'));
		filterBeanDefinition.setLazyInit(true);
		this.context.registerBeanDefinition('filterBean', filterBeanDefinition);
		this.context.refresh();
		ServletContext servletContext = getWebServerFactory().getServletContext();
		then(servletContext).should(atMost(1)).addFilter(anyString(), this.filterCaptor.capture());
		// Up to this point the filterBean should not have been created, calling
		// the delegate proxy will trigger creation and an exception
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(() -> {
			this.filterCaptor.getValue().init(new MockFilterConfig());
			this.filterCaptor.getValue()
				.doFilter(new MockHttpServletRequest(), new MockHttpServletResponse(), new MockFilterChain());
		}).withMessageContaining('Create FilterBean Failure');
	}
	@Test
	void postProcessWebServerFactory() {
		RootBeanDefinition beanDefinition = new RootBeanDefinition(MockServletWebServerFactory.class);
		MutablePropertyValues pv = new MutablePropertyValues();
		pv.add('port', '${port}');
		beanDefinition.setPropertyValues(pv);
		this.context.registerBeanDefinition('webServerFactory', beanDefinition);
		PropertySourcesPlaceholderConfigurer propertySupport = new PropertySourcesPlaceholderConfigurer();
		Properties properties = new Properties();
		properties.put('port', 8080);
		propertySupport.setProperties(properties);
		this.context.registerBeanDefinition('propertySupport', beanDefinition(propertySupport));
		this.context.refresh();
		assertThat(getWebServerFactory().getWebServer().getPort()).isEqualTo(8080);
	}
	@Test
	void doesNotReplaceExistingScopes() {
		// gh-2082
		Scope scope = mock(Scope.class);
		ConfigurableListableBeanFactory factory = this.context.getBeanFactory();
		factory.registerScope(WebApplicationContext.SCOPE_REQUEST, scope);
		factory.registerScope(WebApplicationContext.SCOPE_SESSION, scope);
		addWebServerFactoryBean();
		this.context.refresh();
		assertThat(factory.getRegisteredScope(WebApplicationContext.SCOPE_REQUEST)).isSameAs(scope);
		assertThat(factory.getRegisteredScope(WebApplicationContext.SCOPE_SESSION)).isSameAs(scope);
	}
	@Test
	void servletRequestCanBeInjectedEarly(CapturedOutput output) {
		// gh-14990
		int initialOutputLength = output.length();
		addWebServerFactoryBean();
		RootBeanDefinition beanDefinition = new RootBeanDefinition(WithAutowiredServletRequest.class);
		beanDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
		this.context.registerBeanDefinition('withAutowiredServletRequest', beanDefinition);
		this.context.addBeanFactoryPostProcessor((beanFactory) -> {
			WithAutowiredServletRequest bean = beanFactory.getBean(WithAutowiredServletRequest.class);
			assertThat(bean.getRequest()).isNotNull();
		});
		this.context.refresh();
		assertThat(output.toString().substring(initialOutputLength)).doesNotContain('Replacing scope');
	}
	@Test
	void webApplicationScopeIsRegistered() {
		addWebServerFactoryBean();
		this.context.refresh();
		assertThat(this.context.getBeanFactory().getRegisteredScope(WebApplicationContext.SCOPE_APPLICATION))
			.isNotNull();
	}
	private void addWebServerFactoryBean() {
		this.context.registerBeanDefinition('webServerFactory',
				new RootBeanDefinition(MockServletWebServerFactory.class));
	}
	MockServletWebServerFactory getWebServerFactory() {
		return this.context.getBean(MockServletWebServerFactory.class);
	}
	private BeanDefinition beanDefinition(Object bean) {
		RootBeanDefinition beanDefinition = new RootBeanDefinition();
		beanDefinition.setBeanClass(getClass());
		beanDefinition.setFactoryMethodName('getBean');
		ConstructorArgumentValues constructorArguments = new ConstructorArgumentValues();
		constructorArguments.addGenericArgumentValue(bean);
		beanDefinition.setConstructorArgumentValues(constructorArguments);
		return beanDefinition;
	}
	static <T> T getBean(T object) {
		if (object instanceof RuntimeException runtimeException) {
			throw runtimeException;
		}
		return object;
	}
	static class TestApplicationListener implements ApplicationListener<ApplicationEvent> {
		private final Deque<ApplicationEvent> events = new ArrayDeque<>();
		@Override
		public void onApplicationEvent(ApplicationEvent event) {
			this.events.add(event);
		}
		List<ApplicationEvent> receivedEvents() {
			List<ApplicationEvent> receivedEvents = new ArrayList<>();
			while (!this.events.isEmpty()) {
				receivedEvents.add(this.events.pollFirst());
			}
			return receivedEvents;
		}
	}
	@Order(10)
	static class OrderedFilter extends GenericFilterBean {
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
		}
	}
	static class WithAutowiredServletRequest {
		private final ServletRequest request;
		WithAutowiredServletRequest(ServletRequest request) {
			this.request = request;
		}
		ServletRequest getRequest() {
			return this.request;
		}
	}
	static class RefreshFailure {
		RefreshFailure() {
			throw new RuntimeException('Fail refresh');
		}
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
class ApplicationServletEnvironmentTests extends AbstractApplicationEnvironmentTests {
	@Override
	protected StandardEnvironment createEnvironment() {
		return new ApplicationServletEnvironment();
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
class AnnotationConfigServletWebServerApplicationContextTests {
	private AnnotationConfigServletWebServerApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void createFromScan() {
		this.context = new AnnotationConfigServletWebServerApplicationContext(
				ExampleServletWebServerApplicationConfiguration.class.getPackage().getName());
		verifyContext();
	}
	@Test
	void sessionScopeAvailable() {
		this.context = new AnnotationConfigServletWebServerApplicationContext(
				ExampleServletWebServerApplicationConfiguration.class, SessionScopedComponent.class);
		verifyContext();
	}
	@Test
	void sessionScopeAvailableToServlet() {
		this.context = new AnnotationConfigServletWebServerApplicationContext(
				ExampleServletWebServerApplicationConfiguration.class, ExampleServletWithAutowired.class,
				SessionScopedComponent.class);
		Servlet servlet = this.context.getBean(ExampleServletWithAutowired.class);
		assertThat(servlet).isNotNull();
	}
	@Test
	void createFromConfigClass() {
		this.context = new AnnotationConfigServletWebServerApplicationContext(
				ExampleServletWebServerApplicationConfiguration.class);
		verifyContext();
	}
	@Test
	void registerAndRefresh() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.register(ExampleServletWebServerApplicationConfiguration.class);
		this.context.refresh();
		verifyContext();
	}
	@Test
	void multipleRegistersAndRefresh() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.register(WebServerConfiguration.class);
		this.context.register(ServletContextAwareConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeansOfType(Servlet.class)).hasSize(1);
		assertThat(this.context.getBeansOfType(ServletWebServerFactory.class)).hasSize(1);
	}
	@Test
	void scanAndRefresh() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.scan(ExampleServletWebServerApplicationConfiguration.class.getPackage().getName());
		this.context.refresh();
		verifyContext();
	}
	@Test
	void createAndInitializeCyclic() {
		this.context = new AnnotationConfigServletWebServerApplicationContext(
				ServletContextAwareEmbeddedConfiguration.class);
		verifyContext();
		// You can"t initialize the application context and inject the servlet context
		// because of a cycle - we"d like this to be not null, but it never will be
		assertThat(this.context.getBean(ServletContextAwareEmbeddedConfiguration.class).getServletContext()).isNull();
	}
	@Test
	void createAndInitializeWithParent() {
		AnnotationConfigServletWebServerApplicationContext parent = new AnnotationConfigServletWebServerApplicationContext(
				WebServerConfiguration.class);
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.register(WebServerConfiguration.class, ServletContextAwareConfiguration.class);
		this.context.setParent(parent);
		this.context.refresh();
		verifyContext();
		assertThat(this.context.getBean(ServletContextAwareConfiguration.class).getServletContext()).isNotNull();
	}
	private void verifyContext() {
		MockServletWebServerFactory factory = this.context.getBean(MockServletWebServerFactory.class);
		Servlet servlet = this.context.getBean(Servlet.class);
		then(factory.getServletContext()).should().addServlet('servlet', servlet);
	}
	@Component
	static class ExampleServletWithAutowired extends GenericServlet {
		@Autowired
		private SessionScopedComponent component;
		@Override
		public void service(ServletRequest req, ServletResponse res) {
			assertThat(this.component).isNotNull();
		}
	}
	@Component
	@Scope(value = 'session', proxyMode = ScopedProxyMode.TARGET_CLASS)
	static class SessionScopedComponent {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class ServletContextAwareEmbeddedConfiguration implements ServletContextAware {
		private ServletContext servletContext;
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new MockServletWebServerFactory();
		}
		@Bean
		Servlet servlet() {
			return new MockServlet();
		}
		@Override
		public void setServletContext(ServletContext servletContext) {
			this.servletContext = servletContext;
		}
		ServletContext getServletContext() {
			return this.servletContext;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerConfiguration {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new MockServletWebServerFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class ServletContextAwareConfiguration implements ServletContextAware {
		private ServletContext servletContext;
		@Bean
		Servlet servlet() {
			return new MockServlet();
		}
		@Override
		public void setServletContext(ServletContext servletContext) {
			this.servletContext = servletContext;
		}
		ServletContext getServletContext() {
			return this.servletContext;
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class DynamicRegistrationBeanTests {
	@Test
	void shouldUseNameIfSet() {
		DynamicRegistrationBean<?> bean = createBean();
		bean.setName('givenName');
		assertThat(bean.getOrDeduceName('dummy')).isEqualTo('givenName');
	}
	@Test
	void shouldUseBeanNameIfNameIsNotSet() {
		DynamicRegistrationBean<?> bean = createBean();
		bean.setBeanName('beanName');
		assertThat(bean.getOrDeduceName('dummy')).isEqualTo('beanName');
	}
	@Test
	void shouldUseConventionBasedNameIfNoNameOrBeanNameIsSet() {
		DynamicRegistrationBean<?> bean = createBean();
		assertThat(bean.getOrDeduceName('dummy')).isEqualTo('string');
	}
	private static DynamicRegistrationBean<?> createBean() {
		return new DynamicRegistrationBean<>() {
			@Override
			protected Dynamic addRegistration(String description, ServletContext servletContext) {
				return null;
			}
			@Override
			protected String getDescription() {
				return null;
			}
		};
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
@ExtendWith(OutputCaptureExtension.class)
@DirtiesUrlFactories
public abstract class AbstractServletWebServerFactoryTests {
	@TempDir
	protected File tempDir;
	protected WebServer webServer;
	private final HttpClientContext httpClientContext = HttpClientContext.create();
	private final Supplier<HttpClientBuilder> httpClientBuilder = () -> HttpClients.custom()
		.setRetryStrategy(new DefaultHttpRequestRetryStrategy(10, TimeValue.of(200, TimeUnit.MILLISECONDS)));
	@AfterEach
	void tearDown() {
		if (this.webServer != null) {
			try {
				this.webServer.stop();
				try {
					this.webServer.destroy();
				}
				catch (Exception ex) {
					// Ignore
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
	}
	@Test
	void startServlet() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
	}
	@Test
	void startCalledTwice(CapturedOutput output) throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		int port = this.webServer.getPort();
		this.webServer.start();
		assertThat(this.webServer.getPort()).isEqualTo(port);
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
		assertThat(output).containsOnlyOnce('started on port');
	}
	@Test
	void stopCalledTwice() {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		this.webServer.stop();
		this.webServer.stop();
	}
	@Test
	protected void restartAfterStop() throws IOException, URISyntaxException {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
		int port = this.webServer.getPort();
		this.webServer.stop();
		assertThatIOException().isThrownBy(() -> getResponse(getLocalUrl(port, '/hello')));
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
	}
	@Test
	void emptyServerWhenPortIsMinusOne() {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setPort(-1);
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(this.webServer.getPort()).isEqualTo(-1);
	}
	@Test
	void stopServlet() {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		int port = this.webServer.getPort();
		this.webServer.stop();
		assertThatIOException().isThrownBy(() -> getResponse(getLocalUrl(port, '/hello')));
	}
	@Test
	void startServletAndFilter() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration(),
				new FilterRegistrationBean<>(new ExampleFilter()));
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('[Hello World]');
	}
	@Test
	void startBlocksUntilReadyToServe() {
		AbstractServletWebServerFactory factory = getFactory();
		final Date[] date = new Date[1];
		this.webServer = factory.getWebServer((servletContext) -> {
			try {
				Thread.sleep(500);
				date[0] = new Date();
			}
			catch (InterruptedException ex) {
				throw new ServletException(ex);
			}
		});
		this.webServer.start();
		assertThat(date[0]).isNotNull();
	}
	@Test
	void loadOnStartAfterContextIsInitialized() {
		AbstractServletWebServerFactory factory = getFactory();
		final InitCountingServlet servlet = new InitCountingServlet();
		this.webServer = factory
			.getWebServer((servletContext) -> servletContext.addServlet('test', servlet).setLoadOnStartup(1));
		assertThat(servlet.getInitCount()).isZero();
		this.webServer.start();
		assertThat(servlet.getInitCount()).isOne();
	}
	@Test
	void portIsMinusOneWhenConnectionIsClosed() {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		this.webServer.start();
		assertThat(this.webServer.getPort()).isGreaterThan(0);
		this.webServer.destroy();
		assertThat(this.webServer.getPort()).isEqualTo(-1);
	}
	@Test
	void specificPort() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		int specificPort = doWithRetry(() -> {
			factory.setPort(0);
			this.webServer = factory.getWebServer(exampleServletRegistration());
			this.webServer.start();
			return this.webServer.getPort();
		});
		assertThat(getResponse('http://localhost:' + specificPort + '/hello')).isEqualTo('Hello World');
		assertThat(this.webServer.getPort()).isEqualTo(specificPort);
	}
	@Test
	void specificContextRoot() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setContextPath('/say');
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/say/hello'))).isEqualTo('Hello World');
	}
	@Test
	void contextPathIsLoggedOnStartup(CapturedOutput output) {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setContextPath('/custom');
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(output).containsOnlyOnce('with context path "/custom"');
	}
	@Test
	void contextPathMustStartWithSlash() {
		assertThatIllegalArgumentException().isThrownBy(() -> getFactory().setContextPath('missingslash'))
			.withMessageContaining('ContextPath must start with "/" and not end with "/"');
	}
	@Test
	void contextPathMustNotEndWithSlash() {
		assertThatIllegalArgumentException().isThrownBy(() -> getFactory().setContextPath('extraslash/'))
			.withMessageContaining('ContextPath must start with "/" and not end with "/"');
	}
	@Test
	void contextRootPathMustNotBeSlash() {
		assertThatIllegalArgumentException().isThrownBy(() -> getFactory().setContextPath('/'))
			.withMessageContaining('Root ContextPath must be specified using an empty string');
	}
	@Test
	void multipleConfigurations() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		ServletContextInitializer[] initializers = new ServletContextInitializer[6];
		Arrays.setAll(initializers, (i) -> mock(ServletContextInitializer.class));
		factory.setInitializers(Arrays.asList(initializers[2], initializers[3]));
		factory.addInitializers(initializers[4], initializers[5]);
		this.webServer = factory.getWebServer(initializers[0], initializers[1]);
		this.webServer.start();
		InOrder ordered = inOrder((Object[]) initializers);
		for (ServletContextInitializer initializer : initializers) {
			then(initializer).should(ordered).onStartup(any(ServletContext.class));
		}
	}
	@Test
	void documentRoot() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		this.webServer = factory.getWebServer();
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/test.txt'))).isEqualTo('test');
	}
	@Test
	void mimeType() throws Exception {
		FileCopyUtils.copy('test', new FileWriter(new File(this.tempDir, 'test.xxcss')));
		AbstractServletWebServerFactory factory = getFactory();
		factory.setRegisterDefaultServlet(true);
		factory.setDocumentRoot(this.tempDir);
		MimeMappings mimeMappings = new MimeMappings();
		mimeMappings.add('xxcss', 'text/css');
		factory.setMimeMappings(mimeMappings);
		this.webServer = factory.getWebServer();
		this.webServer.start();
		ClientHttpResponse response = getClientResponse(getLocalUrl('/test.xxcss'));
		assertThat(response.getHeaders().getContentType()).hasToString('text/css');
		response.close();
	}
	@Test
	void errorPage() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.addErrorPages(new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, '/hello'));
		this.webServer = factory.getWebServer(exampleServletRegistration(), errorServletRegistration());
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
		assertThat(getResponse(getLocalUrl('/bang'))).isEqualTo('Hello World');
	}
	@Test
	void errorPageFromPutRequest() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.addErrorPages(new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, '/hello'));
		this.webServer = factory.getWebServer(exampleServletRegistration(), errorServletRegistration());
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'), HttpMethod.PUT)).isEqualTo('Hello World');
		assertThat(getResponse(getLocalUrl('/bang'), HttpMethod.PUT)).isEqualTo('Hello World');
	}
	@Test
	void basicSslFromClassPath() throws Exception {
		testBasicSslWithKeyStore('classpath:test.jks');
	}
	@Test
	void basicSslFromFileSystem() throws Exception {
		testBasicSslWithKeyStore('src/test/resources/test.jks');
	}
	@Test
	void sslDisabled() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		Ssl ssl = getSsl(null, 'password', 'classpath:test.jks');
		ssl.setEnabled(false);
		factory.setSsl(ssl);
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(true, false), '/hello'));
		this.webServer.start();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				createTrustSelfSignedTlsSocketStrategy());
		assertThatExceptionOfType(SSLException.class)
			.isThrownBy(() -> getResponse(getLocalUrl('https', '/hello'), requestFactory));
	}
	@Test
	void sslGetScheme() throws Exception { // gh-2232
		AbstractServletWebServerFactory factory = getFactory();
		factory.setSsl(getSsl(null, 'password', 'src/test/resources/test.jks'));
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(true, false), '/hello'));
		this.webServer.start();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				createTrustSelfSignedTlsSocketStrategy());
		assertThat(getResponse(getLocalUrl('https', '/hello'), requestFactory)).contains('scheme=https');
	}
	@Test
	void sslKeyAlias() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		Ssl ssl = getSsl(null, 'password', 'test-alias', 'src/test/resources/test.jks');
		factory.setSsl(ssl);
		ServletRegistrationBean<ExampleServlet> registration = new ServletRegistrationBean<>(
				new ExampleServlet(true, false), '/hello');
		this.webServer = factory.getWebServer(registration);
		this.webServer.start();
		TrustStrategy trustStrategy = new SerialNumberValidatingTrustSelfSignedStrategy('14ca9ba6abe2a70d');
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, trustStrategy).build();
		PoolingHttpClientConnectionManager connectionManager = PoolingHttpClientConnectionManagerBuilder.create()
			.setTlsSocketStrategy(new DefaultClientTlsStrategy(sslContext))
			.build();
		HttpClient httpClient = HttpClients.custom().setConnectionManager(connectionManager).build();
		String response = getResponse(getLocalUrl('https', '/hello'),
				new HttpComponentsClientHttpRequestFactory(httpClient));
		assertThat(response).contains('scheme=https');
	}
	@Test
	void sslWithInvalidAliasFailsDuringStartup() {
		AbstractServletWebServerFactory factory = getFactory();
		Ssl ssl = getSsl(null, 'password', 'test-alias-404', 'src/test/resources/test.jks');
		factory.setSsl(ssl);
		ServletRegistrationBean<ExampleServlet> registration = new ServletRegistrationBean<>(
				new ExampleServlet(true, false), '/hello');
		ThrowingCallable call = () -> factory.getWebServer(registration).start();
		assertThatSslWithInvalidAliasCallFails(call);
	}
	protected void assertThatSslWithInvalidAliasCallFails(ThrowingCallable call) {
		assertThatException().isThrownBy(call)
			.withStackTraceContaining('Keystore does not contain alias "test-alias-404"');
	}
	@Test
	void serverHeaderIsDisabledByDefaultWhenUsingSsl() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setSsl(getSsl(null, 'password', 'src/test/resources/test.jks'));
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(true, false), '/hello'));
		this.webServer.start();
		PoolingHttpClientConnectionManager connectionManager = PoolingHttpClientConnectionManagerBuilder.create()
			.setTlsSocketStrategy(createTrustSelfSignedTlsSocketStrategy())
			.build();
		HttpClient httpClient = this.httpClientBuilder.get().setConnectionManager(connectionManager).build();
		ClientHttpResponse response = getClientResponse(getLocalUrl('https', '/hello'), HttpMethod.GET,
				new HttpComponentsClientHttpRequestFactory(httpClient));
		assertThat(response.getHeaders().get('Server')).isNullOrEmpty();
	}
	@Test
	void serverHeaderCanBeCustomizedWhenUsingSsl() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setServerHeader('MyServer');
		factory.setSsl(getSsl(null, 'password', 'src/test/resources/test.jks'));
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(true, false), '/hello'));
		this.webServer.start();
		PoolingHttpClientConnectionManager connectionManager = PoolingHttpClientConnectionManagerBuilder.create()
			.setTlsSocketStrategy(createTrustSelfSignedTlsSocketStrategy())
			.build();
		HttpClient httpClient = this.httpClientBuilder.get().setConnectionManager(connectionManager).build();
		ClientHttpResponse response = getClientResponse(getLocalUrl('https', '/hello'), HttpMethod.GET,
				new HttpComponentsClientHttpRequestFactory(httpClient));
		assertThat(response.getHeaders().get('Server')).containsExactly('MyServer');
	}
	protected final void testBasicSslWithKeyStore(String keyStore) throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setSsl(getSsl(null, 'password', keyStore));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				createTrustSelfSignedTlsSocketStrategy());
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void pkcs12KeyStoreAndTrustStore() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setSsl(getSsl(ClientAuth.NEED, null, 'classpath:test.p12', 'classpath:test.p12', null, null));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		KeyStore keyStore = KeyStore.getInstance('pkcs12');
		loadStore(keyStore, new FileSystemResource('src/test/resources/test.p12'));
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy())
			.loadKeyMaterial(keyStore, 'secret'.toCharArray())
			.build();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				new DefaultClientTlsStrategy(sslContext));
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void pemKeyStoreAndTrustStore() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setSsl(getSsl('classpath:test-cert.pem', 'classpath:test-key.pem'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		KeyStore keyStore = KeyStore.getInstance('pkcs12');
		loadStore(keyStore, new FileSystemResource('src/test/resources/test.p12'));
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy())
			.loadKeyMaterial(keyStore, 'secret'.toCharArray())
			.build();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				new DefaultClientTlsStrategy(sslContext));
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void pkcs12KeyStoreAndTrustStoreFromBundle() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setSsl(Ssl.forBundle('test'));
		factory.setSslBundles(
				new DefaultSslBundleRegistry('test', createJksSslBundle('classpath:test.p12', 'classpath:test.p12')));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		KeyStore keyStore = KeyStore.getInstance('pkcs12');
		loadStore(keyStore, new FileSystemResource('src/test/resources/test.p12'));
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy())
			.loadKeyMaterial(keyStore, 'secret'.toCharArray())
			.build();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				new DefaultClientTlsStrategy(sslContext));
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void pemKeyStoreAndTrustStoreFromBundle() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setSsl(Ssl.forBundle('test'));
		factory.setSslBundles(new DefaultSslBundleRegistry('test',
				createPemSslBundle('classpath:test-cert.pem', 'classpath:test-key.pem')));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		KeyStore keyStore = KeyStore.getInstance('pkcs12');
		loadStore(keyStore, new FileSystemResource('src/test/resources/test.p12'));
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy())
			.loadKeyMaterial(keyStore, 'secret'.toCharArray())
			.build();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				new DefaultClientTlsStrategy(sslContext));
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setRegisterDefaultServlet(true);
		addTestTxtFile(factory);
		factory.setSsl(getSsl(ClientAuth.NEED, 'password', 'classpath:test.jks', 'classpath:test.jks', null, null));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
		loadStore(keyStore, new FileSystemResource('src/test/resources/test.jks'));
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy())
			.loadKeyMaterial(keyStore, 'password'.toCharArray())
			.build();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				new DefaultClientTlsStrategy(sslContext));
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void sslNeedsClientAuthenticationFailsWithoutClientCertificate() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setSsl(getSsl(ClientAuth.NEED, 'password', 'classpath:test.jks'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				createTrustSelfSignedTlsSocketStrategy());
		String localUrl = getLocalUrl('https', '/test.txt');
		assertThatIOException().isThrownBy(() -> getResponse(localUrl, requestFactory));
	}
	@Test
	void sslWantsClientAuthenticationSucceedsWithClientCertificate() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory
			.setSsl(getSsl(ClientAuth.WANT, 'password', 'classpath:test.jks', null, new String[] { 'TLSv1.2' }, null));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
		loadStore(keyStore, new FileSystemResource('src/test/resources/test.jks'));
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy())
			.loadKeyMaterial(keyStore, 'password'.toCharArray())
			.build();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				new DefaultClientTlsStrategy(sslContext));
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void sslWantsClientAuthenticationSucceedsWithoutClientCertificate() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setSsl(getSsl(ClientAuth.WANT, 'password', 'classpath:test.jks'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				createTrustSelfSignedTlsSocketStrategy());
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Test
	void disableJspServletRegistration() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getJsp().setRegistered(false);
		this.webServer = factory.getWebServer();
		assertThat(getJspServlet()).isNull();
	}
	@Test
	void cannotReadClassPathFiles() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		ClientHttpResponse response = getClientResponse(
				getLocalUrl('/org/springframework/boot/SpringApplication.class'));
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	protected Ssl getSsl(ClientAuth clientAuth, String keyPassword, String keyStore) {
		return getSsl(clientAuth, keyPassword, keyStore, null, null, null);
	}
	protected Ssl getSsl(ClientAuth clientAuth, String keyPassword, String keyAlias, String keyStore) {
		return getSsl(clientAuth, keyPassword, keyAlias, keyStore, null, null, null);
	}
	private Ssl getSsl(ClientAuth clientAuth, String keyPassword, String keyStore, String trustStore,
			String[] supportedProtocols, String[] ciphers) {
		return getSsl(clientAuth, keyPassword, null, keyStore, trustStore, supportedProtocols, ciphers);
	}
	private Ssl getSsl(ClientAuth clientAuth, String keyPassword, String keyAlias, String keyStore, String trustStore,
			String[] supportedProtocols, String[] ciphers) {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(clientAuth);
		if (keyPassword != null) {
			ssl.setKeyPassword(keyPassword);
		}
		if (keyAlias != null) {
			ssl.setKeyAlias(keyAlias);
		}
		if (keyStore != null) {
			ssl.setKeyStore(keyStore);
			ssl.setKeyStorePassword('secret');
			ssl.setKeyStoreType(getStoreType(keyStore));
		}
		if (trustStore != null) {
			ssl.setTrustStore(trustStore);
			ssl.setTrustStorePassword('secret');
			ssl.setTrustStoreType(getStoreType(trustStore));
		}
		if (ciphers != null) {
			ssl.setCiphers(ciphers);
		}
		if (supportedProtocols != null) {
			ssl.setEnabledProtocols(supportedProtocols);
		}
		return ssl;
	}
	private Ssl getSsl(String cert, String privateKey) {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(ClientAuth.NEED);
		ssl.setCertificate(cert);
		ssl.setCertificatePrivateKey(privateKey);
		ssl.setTrustCertificate(cert);
		return ssl;
	}
	private SslBundle createJksSslBundle(String keyStore, String trustStore) {
		JksSslStoreDetails keyStoreDetails = getJksStoreDetails(keyStore);
		JksSslStoreDetails trustStoreDetails = getJksStoreDetails(trustStore);
		SslStoreBundle stores = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		return SslBundle.of(stores);
	}
	private JksSslStoreDetails getJksStoreDetails(String location) {
		return new JksSslStoreDetails(getStoreType(location), null, location, 'secret');
	}
	protected SslBundle createPemSslBundle(String cert, String privateKey) {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate(cert).withPrivateKey(privateKey);
		PemSslStoreDetails trustStoreDetails = PemSslStoreDetails.forCertificate(cert);
		SslStoreBundle stores = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		return SslBundle.of(stores);
	}
	protected void testRestrictedSSLProtocolsAndCipherSuites(String[] protocols, String[] ciphers) throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setSsl(getSsl(null, 'password', 'src/test/resources/restricted.jks', null, protocols, ciphers));
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(true, false), '/hello'));
		this.webServer.start();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				createTrustSelfSignedTlsSocketStrategy());
		assertThat(getResponse(getLocalUrl('https', '/hello'), requestFactory)).contains('scheme=https');
	}
	protected HttpComponentsClientHttpRequestFactory createHttpComponentsRequestFactory(
			TlsSocketStrategy tlsSocketStrategy) {
		PoolingHttpClientConnectionManager connectionManager = PoolingHttpClientConnectionManagerBuilder.create()
			.setTlsSocketStrategy(tlsSocketStrategy)
			.build();
		HttpClient httpClient = this.httpClientBuilder.get().setConnectionManager(connectionManager).build();
		return new HttpComponentsClientHttpRequestFactory(httpClient);
	}
	private String getStoreType(String keyStore) {
		return keyStore.endsWith('.p12') ? 'pkcs12' : null;
	}
	@Test
	void defaultSessionTimeout() {
		assertThat(getFactory().getSession().getTimeout()).hasMinutes(30);
	}
	@Test
	void persistSession() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getSession().setPersistent(true);
		this.webServer = factory.getWebServer(sessionServletRegistration());
		this.webServer.start();
		String s1 = getResponse(getLocalUrl('/session'));
		String s2 = getResponse(getLocalUrl('/session'));
		this.webServer.destroy();
		this.webServer = factory.getWebServer(sessionServletRegistration());
		this.webServer.start();
		String s3 = getResponse(getLocalUrl('/session'));
		String message = 'Session error s1=' + s1 + ' s2=' + s2 + ' s3=' + s3;
		assertThat(s2.split(':')[0]).as(message).isEqualTo(s1.split(':')[1]);
		assertThat(s3.split(':')[0]).as(message).isEqualTo(s2.split(':')[1]);
	}
	@Test
	void persistSessionInSpecificSessionStoreDir() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		File sessionStoreDir = new File(this.tempDir, 'sessions');
		sessionStoreDir.mkdir();
		factory.getSession().setPersistent(true);
		factory.getSession().setStoreDir(sessionStoreDir);
		this.webServer = factory.getWebServer(sessionServletRegistration());
		this.webServer.start();
		getResponse(getLocalUrl('/session'));
		this.webServer.destroy();
		File[] dirContents = sessionStoreDir.listFiles((dir, name) -> !('.'.equals(name) || '..'.equals(name)));
		assertThat(dirContents).isNotEmpty();
	}
	@Test
	void getValidSessionStoreWhenSessionStoreNotSet() {
		AbstractServletWebServerFactory factory = getFactory();
		File dir = factory.getValidSessionStoreDir(false);
		assertThat(dir).hasName('servlet-sessions');
		assertThat(dir).hasParent(new ApplicationTemp().getDir());
	}
	@Test
	void getValidSessionStoreWhenSessionStoreIsRelative() {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getSession().setStoreDir(new File('sessions'));
		File dir = factory.getValidSessionStoreDir(false);
		assertThat(dir).hasName('sessions');
		assertThat(dir).hasParent(new ApplicationHome().getDir());
	}
	@Test
	void getValidSessionStoreWhenSessionStoreReferencesFile() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		File file = new File(this.tempDir, 'file');
		file.createNewFile();
		factory.getSession().setStoreDir(file);
		assertThatIllegalStateException().isThrownBy(() -> factory.getValidSessionStoreDir(false))
			.withMessageContaining('points to a file');
	}
	@Test
	void sessionCookieConfiguration() {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getSession().getCookie().setName('testname');
		factory.getSession().getCookie().setDomain('testdomain');
		factory.getSession().getCookie().setPath('/testpath');
		factory.getSession().getCookie().setHttpOnly(true);
		factory.getSession().getCookie().setSecure(true);
		factory.getSession().getCookie().setPartitioned(true);
		factory.getSession().getCookie().setMaxAge(Duration.ofSeconds(60));
		final AtomicReference<SessionCookieConfig> configReference = new AtomicReference<>();
		this.webServer = factory.getWebServer((context) -> configReference.set(context.getSessionCookieConfig()));
		SessionCookieConfig sessionCookieConfig = configReference.get();
		assertThat(sessionCookieConfig.getName()).isEqualTo('testname');
		assertThat(sessionCookieConfig.getDomain()).isEqualTo('testdomain');
		assertThat(sessionCookieConfig.getPath()).isEqualTo('/testpath');
		assertThat(sessionCookieConfig.isHttpOnly()).isTrue();
		assertThat(sessionCookieConfig.isSecure()).isTrue();
		assertThat(sessionCookieConfig.getAttribute('Partitioned')).isEqualTo('true');
		assertThat(sessionCookieConfig.getMaxAge()).isEqualTo(60);
	}
	@ParameterizedTest
	@EnumSource(SameSite.class)
	void sessionCookieSameSiteAttributeCanBeConfiguredAndOnlyAffectsSessionCookies(SameSite sameSite) throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getSession().getCookie().setSameSite(sameSite);
		factory.addInitializers(new ServletRegistrationBean<>(new CookieServlet(false), '/'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		ClientHttpResponse clientResponse = getClientResponse(getLocalUrl('/'));
		List<String> setCookieHeaders = clientResponse.getHeaders().get('Set-Cookie');
		assertThat(setCookieHeaders).satisfiesExactlyInAnyOrder(
				(header) -> assertThat(header).contains('JSESSIONID').contains('SameSite=' + sameSite.attributeValue()),
				(header) -> assertThat(header).contains('test=test').doesNotContain('SameSite'));
	}
	@ParameterizedTest
	@EnumSource(SameSite.class)
	void sessionCookieSameSiteAttributeCanBeConfiguredAndOnlyAffectsSessionCookiesWhenUsingCustomName(SameSite sameSite)
			throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getSession().getCookie().setName('THESESSION');
		factory.getSession().getCookie().setSameSite(sameSite);
		factory.addInitializers(new ServletRegistrationBean<>(new CookieServlet(false), '/'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		ClientHttpResponse clientResponse = getClientResponse(getLocalUrl('/'));
		List<String> setCookieHeaders = clientResponse.getHeaders().get('Set-Cookie');
		assertThat(setCookieHeaders).satisfiesExactlyInAnyOrder(
				(header) -> assertThat(header).contains('THESESSION').contains('SameSite=' + sameSite.attributeValue()),
				(header) -> assertThat(header).contains('test=test').doesNotContain('SameSite'));
	}
	@Test
	void cookieSameSiteSuppliers() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.addCookieSameSiteSuppliers(CookieSameSiteSupplier.ofLax().whenHasName('relaxed'));
		factory.addCookieSameSiteSuppliers(CookieSameSiteSupplier.ofNone().whenHasName('empty'));
		factory.addCookieSameSiteSuppliers(CookieSameSiteSupplier.ofStrict().whenHasName('controlled'));
		factory.addInitializers(new ServletRegistrationBean<>(new CookieServlet(true), '/'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		ClientHttpResponse clientResponse = getClientResponse(getLocalUrl('/'));
		assertThat(clientResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
		List<String> setCookieHeaders = clientResponse.getHeaders().get('Set-Cookie');
		assertThat(setCookieHeaders).satisfiesExactlyInAnyOrder(
				(header) -> assertThat(header).contains('JSESSIONID').doesNotContain('SameSite'),
				(header) -> assertThat(header).contains('test=test').doesNotContain('SameSite'),
				(header) -> assertThat(header).contains('relaxed=test').contains('SameSite=Lax'),
				(header) -> assertThat(header).contains('empty=test').contains('SameSite=None'),
				(header) -> assertThat(header).contains('controlled=test').contains('SameSite=Strict'));
	}
	@Test
	void cookieSameSiteSuppliersShouldNotAffectSessionCookie() throws IOException, URISyntaxException {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getSession().getCookie().setSameSite(SameSite.LAX);
		factory.getSession().getCookie().setName('SESSIONCOOKIE');
		factory.addCookieSameSiteSuppliers(CookieSameSiteSupplier.ofStrict());
		factory.addInitializers(new ServletRegistrationBean<>(new CookieServlet(false), '/'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		ClientHttpResponse clientResponse = getClientResponse(getLocalUrl('/'));
		assertThat(clientResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
		List<String> setCookieHeaders = clientResponse.getHeaders().get('Set-Cookie');
		assertThat(setCookieHeaders).satisfiesExactlyInAnyOrder(
				(header) -> assertThat(header).contains('SESSIONCOOKIE').contains('SameSite=Lax'),
				(header) -> assertThat(header).contains('test=test').contains('SameSite=Strict'));
	}
	@Test
	protected void sslSessionTracking() {
		AbstractServletWebServerFactory factory = getFactory();
		Ssl ssl = new Ssl();
		ssl.setEnabled(true);
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setKeyPassword('password');
		factory.setSsl(ssl);
		factory.getSession().setTrackingModes(EnumSet.of(SessionTrackingMode.SSL));
		AtomicReference<ServletContext> contextReference = new AtomicReference<>();
		this.webServer = factory.getWebServer(contextReference::set);
		assertThat(contextReference.get().getEffectiveSessionTrackingModes())
			.isEqualTo(EnumSet.of(jakarta.servlet.SessionTrackingMode.SSL));
	}
	@Test
	void compressionOfResponseToGetRequest() throws Exception {
		assertThat(doTestCompression(10000, null, null)).isTrue();
	}
	@Test
	void compressionOfResponseToPostRequest() throws Exception {
		assertThat(doTestCompression(10000, null, null, HttpMethod.POST)).isTrue();
	}
	@Test
	void noCompressionForSmallResponse() throws Exception {
		assertThat(doTestCompression(100, null, null)).isFalse();
	}
	@Test
	void noCompressionForMimeType() throws Exception {
		String[] mimeTypes = new String[] { 'text/html', 'text/xml', 'text/css' };
		assertThat(doTestCompression(10000, mimeTypes, null)).isFalse();
	}
	@Test
	protected void noCompressionForUserAgent() throws Exception {
		assertThat(doTestCompression(10000, null, new String[] { 'testUserAgent' })).isFalse();
	}
	@Test
	void compressionWithoutContentSizeHeader() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		Compression compression = new Compression();
		compression.setEnabled(true);
		factory.setCompression(compression);
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(false, true), '/hello'));
		this.webServer.start();
		TestGzipInputStreamFactory inputStreamFactory = new TestGzipInputStreamFactory();
		LinkedHashMap<String, InputStreamFactory> contentDecoderMap = new LinkedHashMap<>();
		contentDecoderMap.put('gzip', inputStreamFactory);
		getResponse(getLocalUrl('/hello'), new HttpComponentsClientHttpRequestFactory(
				this.httpClientBuilder.get().setContentDecoderRegistry(contentDecoderMap).build()));
		assertThat(inputStreamFactory.wasCompressionUsed()).isTrue();
	}
	@Test
	void mimeMappingsAreCorrectlyConfigured() {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		Collection<MimeMappings.Mapping> configuredMimeMappings = getActualMimeMappings().entrySet()
			.stream()
			.map((entry) -> new MimeMappings.Mapping(entry.getKey(), entry.getValue()))
			.toList();
		Collection<MimeMappings.Mapping> expectedMimeMappings = MimeMappings.DEFAULT.getAll();
		assertThat(configuredMimeMappings).containsExactlyInAnyOrderElementsOf(expectedMimeMappings);
	}
	@Test
	void additionalMimeMappingsCanBeConfigured() {
		AbstractServletWebServerFactory factory = getFactory();
		MimeMappings additionalMimeMappings = new MimeMappings();
		additionalMimeMappings.add('a', 'alpha');
		additionalMimeMappings.add('b', 'bravo');
		factory.addMimeMappings(additionalMimeMappings);
		this.webServer = factory.getWebServer();
		Collection<MimeMappings.Mapping> configuredMimeMappings = getActualMimeMappings().entrySet()
			.stream()
			.map((entry) -> new MimeMappings.Mapping(entry.getKey(), entry.getValue()))
			.toList();
		List<MimeMappings.Mapping> expectedMimeMappings = new ArrayList<>(MimeMappings.DEFAULT.getAll());
		expectedMimeMappings.addAll(additionalMimeMappings.getAll());
		assertThat(configuredMimeMappings).containsExactlyInAnyOrderElementsOf(expectedMimeMappings);
	}
	@Test
	void rootServletContextResource() {
		AbstractServletWebServerFactory factory = getFactory();
		final AtomicReference<URL> rootResource = new AtomicReference<>();
		this.webServer = factory.getWebServer((servletContext) -> {
			try {
				rootResource.set(servletContext.getResource('/'));
			}
			catch (MalformedURLException ex) {
				throw new ServletException(ex);
			}
		});
		this.webServer.start();
		assertThat(rootResource.get()).isNotNull();
	}
	@Test
	void customServerHeader() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setServerHeader('MyServer');
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		ClientHttpResponse response = getClientResponse(getLocalUrl('/hello'));
		assertThat(response.getHeaders().getFirst('server')).isEqualTo('MyServer');
	}
	@Test
	void serverHeaderIsDisabledByDefault() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		ClientHttpResponse response = getClientResponse(getLocalUrl('/hello'));
		assertThat(response.getHeaders().getFirst('server')).isNull();
	}
	@Test
	protected void portClashOfPrimaryConnectorResultsInPortInUseException() throws Exception {
		doWithBlockedPort((port) -> {
			assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {
				AbstractServletWebServerFactory factory = getFactory();
				factory.setPort(port);
				AbstractServletWebServerFactoryTests.this.webServer = factory.getWebServer();
				AbstractServletWebServerFactoryTests.this.webServer.start();
			}).satisfies((ex) -> handleExceptionCausedByBlockedPortOnPrimaryConnector(ex, port));
		});
	}
	@Test
	protected void portClashOfSecondaryConnectorResultsInPortInUseException() throws Exception {
		doWithBlockedPort((port) -> {
			assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {
				AbstractServletWebServerFactory factory = getFactory();
				addConnector(port, factory);
				AbstractServletWebServerFactoryTests.this.webServer = factory.getWebServer();
				AbstractServletWebServerFactoryTests.this.webServer.start();
			}).satisfies((ex) -> handleExceptionCausedByBlockedPortOnSecondaryConnector(ex, port));
		});
	}
	@Test
	void malformedAddress() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setAddress(InetAddress.getByName('129.129.129.129'));
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {
			this.webServer = factory.getWebServer();
			this.webServer.start();
		}).isNotInstanceOf(PortInUseException.class);
	}
	@Test
	void localeCharsetMappingsAreConfigured() {
		AbstractServletWebServerFactory factory = getFactory();
		Map<Locale, Charset> mappings = new HashMap<>();
		mappings.put(Locale.GERMAN, StandardCharsets.UTF_8);
		factory.setLocaleCharsetMappings(mappings);
		this.webServer = factory.getWebServer();
		assertThat(getCharset(Locale.GERMAN)).isEqualTo(StandardCharsets.UTF_8);
		assertThat(getCharset(Locale.ITALIAN)).isNull();
	}
	@Test
	void jspServletInitParameters() throws Exception {
		Map<String, String> initParameters = new HashMap<>();
		initParameters.put('a', 'alpha');
		AbstractServletWebServerFactory factory = getFactory();
		factory.getJsp().setInitParameters(initParameters);
		this.webServer = factory.getWebServer();
		Assumptions.assumeFalse(getJspServlet() == null);
		JspServlet jspServlet = getJspServlet();
		assertThat(jspServlet.getInitParameter('a')).isEqualTo('alpha');
	}
	@Test
	void jspServletIsNotInDevelopmentModeByDefault() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		Assumptions.assumeFalse(getJspServlet() == null);
		JspServlet jspServlet = getJspServlet();
		EmbeddedServletOptions options = (EmbeddedServletOptions) ReflectionTestUtils.getField(jspServlet, 'options');
		assertThat(options.getDevelopment()).isFalse();
	}
	@Test
	void faultyFilterCausesStartFailure() {
		AbstractServletWebServerFactory factory = getFactory();
		factory.addInitializers((servletContext) -> servletContext.addFilter('faulty', new Filter() {
			@Override
			public void init(FilterConfig filterConfig) throws ServletException {
				throw new ServletException('Faulty filter');
			}
			@Override
			public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
					throws IOException, ServletException {
				chain.doFilter(request, response);
			}
			@Override
			public void destroy() {
			}
		}));
		assertThatExceptionOfType(WebServerException.class).isThrownBy(() -> factory.getWebServer().start());
	}
	@Test
	void sessionConfiguration() {
		AbstractServletWebServerFactory factory = getFactory();
		factory.getSession().setTimeout(Duration.ofSeconds(123));
		factory.getSession().setTrackingModes(EnumSet.of(SessionTrackingMode.COOKIE, SessionTrackingMode.URL));
		factory.getSession().getCookie().setName('testname');
		factory.getSession().getCookie().setDomain('testdomain');
		factory.getSession().getCookie().setPath('/testpath');
		factory.getSession().getCookie().setHttpOnly(true);
		factory.getSession().getCookie().setSecure(true);
		factory.getSession().getCookie().setPartitioned(false);
		factory.getSession().getCookie().setMaxAge(Duration.ofMinutes(1));
		AtomicReference<ServletContext> contextReference = new AtomicReference<>();
		factory.getWebServer(contextReference::set).start();
		ServletContext servletContext = contextReference.get();
		assertThat(servletContext.getEffectiveSessionTrackingModes())
			.isEqualTo(EnumSet.of(jakarta.servlet.SessionTrackingMode.COOKIE, jakarta.servlet.SessionTrackingMode.URL));
		assertThat(servletContext.getSessionCookieConfig().getName()).isEqualTo('testname');
		assertThat(servletContext.getSessionCookieConfig().getDomain()).isEqualTo('testdomain');
		assertThat(servletContext.getSessionCookieConfig().getPath()).isEqualTo('/testpath');
		assertThat(servletContext.getSessionCookieConfig().isHttpOnly()).isTrue();
		assertThat(servletContext.getSessionCookieConfig().isSecure()).isTrue();
		assertThat(servletContext.getSessionCookieConfig().getMaxAge()).isEqualTo(60);
		assertThat(servletContext.getSessionCookieConfig().getAttribute('Partitioned')).isEqualTo('false');
	}
	@Test
	protected void servletContextListenerContextDestroyedIsNotCalledWhenContainerIsStopped() throws Exception {
		ServletContextListener listener = mock(ServletContextListener.class);
		this.webServer = getFactory().getWebServer((servletContext) -> servletContext.addListener(listener));
		this.webServer.start();
		this.webServer.stop();
		then(listener).should(times(0)).contextDestroyed(any(ServletContextEvent.class));
	}
	@Test
	void servletContextListenerContextDestroyedIsCalledWhenContainerIsDestroyed() throws Exception {
		ServletContextListener listener = mock(ServletContextListener.class);
		this.webServer = getFactory().getWebServer((servletContext) -> servletContext.addListener(listener));
		this.webServer.start();
		this.webServer.destroy();
		then(listener).should().contextDestroyed(any(ServletContextEvent.class));
	}
	@Test
	void exceptionThrownOnLoadFailureIsRethrown() {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory
			.getWebServer((context) -> context.addServlet('failing', FailingServlet.class).setLoadOnStartup(0));
		assertThatExceptionOfType(WebServerException.class).isThrownBy(this.webServer::start)
			.satisfies(this::wrapsFailingServletException);
	}
	@Test
	void whenThereAreNoInFlightRequestsShutDownGracefullyInvokesCallbackWithIdle() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		this.webServer = factory.getWebServer();
		this.webServer.start();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> GracefulShutdownResult.IDLE == result.get());
	}
	@Test
	void whenARequestRemainsInFlightThenShutDownGracefullyDoesNotInvokeCallbackUntilTheRequestCompletes()
			throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
		});
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> request = initiateGetRequest(port, '/blocking');
		blockingServlet.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		blockingServlet.admitOne();
		assertThat(request.get()).isInstanceOf(HttpResponse.class);
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> GracefulShutdownResult.IDLE == result.get());
	}
	@Test
	void whenAnAsyncRequestRemainsInFlightThenShutDownGracefullyDoesNotInvokeCallbackUntilRequestCompletes()
			throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingAsyncServlet blockingAsyncServlet = new BlockingAsyncServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingAsyncServlet);
			registration.addMapping('/blockingAsync');
			registration.setAsyncSupported(true);
		});
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> request = initiateGetRequest(port, '/blockingAsync');
		blockingAsyncServlet.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		Thread.sleep(5000);
		assertThat(result.get()).isNull();
		assertThat(request.isDone()).isFalse();
		blockingAsyncServlet.admitOne();
		assertThat(request.get()).isInstanceOf(HttpResponse.class);
		Awaitility.await().atMost(Duration.ofSeconds(5)).until(() -> GracefulShutdownResult.IDLE == result.get());
	}
	@Test
	void whenARequestIsActiveThenStopWillComplete() throws InterruptedException {
		AbstractServletWebServerFactory factory = getFactory();
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory
			.getWebServer((context) -> context.addServlet('blockingServlet', blockingServlet).addMapping('/'));
		this.webServer.start();
		int port = this.webServer.getPort();
		initiateGetRequest(port, '/');
		blockingServlet.awaitQueue();
		this.webServer.stop();
		try {
			blockingServlet.admitOne();
		}
		catch (RuntimeException ex) {
			// Ignore
		}
	}
	@Test
	protected void whenHttp2IsEnabledAndSslIsDisabledThenH2cCanBeUsed() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		Http2 http2 = new Http2();
		http2.setEnabled(true);
		factory.setHttp2(http2);
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		org.eclipse.jetty.client.HttpClient client = new org.eclipse.jetty.client.HttpClient(
				new HttpClientTransportOverHTTP2(new HTTP2Client()));
		client.start();
		try {
			ContentResponse response = client.GET('http://localhost:' + this.webServer.getPort() + '/hello');
			assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value());
			assertThat(response.getContentAsString()).isEqualTo('Hello World');
		}
		finally {
			client.stop();
		}
	}
	@Test
	protected void whenHttp2IsEnabledAndSslIsDisabledThenHttp11CanStillBeUsed() throws IOException, URISyntaxException {
		AbstractServletWebServerFactory factory = getFactory();
		Http2 http2 = new Http2();
		http2.setEnabled(true);
		factory.setHttp2(http2);
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(getResponse('http://localhost:' + this.webServer.getPort() + '/hello')).isEqualTo('Hello World');
	}
	@Test
	void whenARequestIsActiveAfterGracefulShutdownEndsThenStopWillComplete() throws InterruptedException {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory
			.getWebServer((context) -> context.addServlet('blockingServlet', blockingServlet).addMapping('/'));
		this.webServer.start();
		int port = this.webServer.getPort();
		initiateGetRequest(port, '/');
		blockingServlet.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		this.webServer.stop();
		assertThat(Awaitility.await().atMost(Duration.ofSeconds(30)).until(result::get, Objects::nonNull))
			.isEqualTo(GracefulShutdownResult.REQUESTS_ACTIVE);
		try {
			blockingServlet.admitOne();
		}
		catch (RuntimeException ex) {
			// Ignore
		}
	}
	@Test
	void startedLogMessageWithSinglePort() {
		AbstractServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		this.webServer.start();
		assertThat(startedLogMessage()).matches('(Jetty|Tomcat|Undertow) started on port ' + this.webServer.getPort()
				+ ' \\(http(/1.1)?\\) with context path "/"');
	}
	@Test
	void startedLogMessageWithSinglePortAndContextPath() {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setContextPath('/test');
		this.webServer = factory.getWebServer();
		this.webServer.start();
		assertThat(startedLogMessage()).matches('(Jetty|Tomcat|Undertow) started on port ' + this.webServer.getPort()
				+ ' \\(http(/1.1)?\\) with context path "/test"');
	}
	@Test
	void startedLogMessageWithMultiplePorts() {
		AbstractServletWebServerFactory factory = getFactory();
		addConnector(0, factory);
		this.webServer = factory.getWebServer();
		this.webServer.start();
		assertThat(startedLogMessage()).matches('(Jetty|Tomcat|Undertow) started on ports ' + this.webServer.getPort()
				+ ' \\(http(/1.1)?\\), [0-9]+ \\(http(/1.1)?\\) with context path "/"');
	}
	@Test
	void servletComponentsAreInitializedWithTheSameThreadContextClassLoader() {
		AbstractServletWebServerFactory factory = getFactory();
		ThreadContextClassLoaderCapturingServlet servlet = new ThreadContextClassLoaderCapturingServlet();
		ThreadContextClassLoaderCapturingFilter filter = new ThreadContextClassLoaderCapturingFilter();
		ThreadContextClassLoaderCapturingListener listener = new ThreadContextClassLoaderCapturingListener();
		this.webServer = factory.getWebServer((context) -> {
			context.addServlet('tcclCapturingServlet', servlet).setLoadOnStartup(0);
			context.addFilter('tcclCapturingFilter', filter);
			context.addListener(listener);
		});
		this.webServer.start();
		assertThat(servlet.contextClassLoader).isNotNull();
		assertThat(filter.contextClassLoader).isNotNull();
		assertThat(listener.contextClassLoader).isNotNull();
		assertThat(new HashSet<>(
				Arrays.asList(servlet.contextClassLoader, filter.contextClassLoader, listener.contextClassLoader)))
			.hasSize(1);
	}
	protected Future<Object> initiateGetRequest(int port, String path) {
		return initiateGetRequest(HttpClients.createMinimal(), port, path);
	}
	protected Future<Object> initiateGetRequest(HttpClient httpClient, int port, String path) {
		RunnableFuture<Object> getRequest = new FutureTask<>(() -> {
			try {
				return httpClient.execute(new HttpGet('http://localhost:' + port + path),
						(HttpClientResponseHandler<HttpResponse>) (response) -> {
							response.getEntity().getContent().close();
							return response;
						});
			}
			catch (Exception ex) {
				return ex;
			}
		});
		new Thread(getRequest, 'GET ' + path).start();
		return getRequest;
	}
	private void wrapsFailingServletException(WebServerException ex) {
		Throwable cause = ex.getCause();
		while (cause != null) {
			if (cause instanceof FailingServletException) {
				return;
			}
			cause = cause.getCause();
		}
		fail('Exception did not wrap FailingServletException');
	}
	protected abstract void addConnector(int port, AbstractServletWebServerFactory factory);
	protected abstract void handleExceptionCausedByBlockedPortOnPrimaryConnector(RuntimeException ex, int blockedPort);
	protected abstract void handleExceptionCausedByBlockedPortOnSecondaryConnector(RuntimeException ex,
			int blockedPort);
	private boolean doTestCompression(int contentSize, String[] mimeTypes, String[] excludedUserAgents)
			throws Exception {
		return doTestCompression(contentSize, mimeTypes, excludedUserAgents, HttpMethod.GET);
	}
	private boolean doTestCompression(int contentSize, String[] mimeTypes, String[] excludedUserAgents,
			HttpMethod method) throws Exception {
		String testContent = setUpFactoryForCompression(contentSize, mimeTypes, excludedUserAgents);
		TestGzipInputStreamFactory inputStreamFactory = new TestGzipInputStreamFactory();
		LinkedHashMap<String, InputStreamFactory> contentDecoderMap = new LinkedHashMap<>();
		contentDecoderMap.put('gzip', inputStreamFactory);
		String response = getResponse(getLocalUrl('/test.txt'), method,
				new HttpComponentsClientHttpRequestFactory(HttpClientBuilder.create()
					.setUserAgent('testUserAgent')
					.setContentDecoderRegistry(contentDecoderMap)
					.build()));
		assertThat(response).isEqualTo(testContent);
		return inputStreamFactory.wasCompressionUsed();
	}
	private String setUpFactoryForCompression(int contentSize, String[] mimeTypes, String[] excludedUserAgents) {
		char[] chars = new char[contentSize];
		Arrays.fill(chars, "F");
		String testContent = new String(chars);
		AbstractServletWebServerFactory factory = getFactory();
		Compression compression = new Compression();
		compression.setEnabled(true);
		if (mimeTypes != null) {
			compression.setMimeTypes(mimeTypes);
		}
		if (excludedUserAgents != null) {
			compression.setExcludedUserAgents(excludedUserAgents);
		}
		factory.setCompression(compression);
		factory.addInitializers(new ServletRegistrationBean<>(new HttpServlet() {
			@Override
			protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException {
				resp.setContentType('text/plain');
				resp.setContentLength(testContent.length());
				resp.getWriter().write(testContent);
				resp.getWriter().flush();
			}
		}, '/test.txt'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		return testContent;
	}
	protected abstract Map<String, String> getActualMimeMappings();
	protected abstract Charset getCharset(Locale locale);
	protected void addTestTxtFile(AbstractServletWebServerFactory factory) throws IOException {
		FileCopyUtils.copy('test', new FileWriter(new File(this.tempDir, 'test.txt')));
		factory.setDocumentRoot(this.tempDir);
		factory.setRegisterDefaultServlet(true);
	}
	protected String getLocalUrl(String resourcePath) {
		return getLocalUrl('http', resourcePath);
	}
	protected String getLocalUrl(String scheme, String resourcePath) {
		return scheme + '://localhost:' + this.webServer.getPort() + resourcePath;
	}
	protected String getLocalUrl(int port, String resourcePath) {
		return 'http://localhost:' + port + resourcePath;
	}
	protected String getResponse(String url, String... headers) throws IOException, URISyntaxException {
		return getResponse(url, HttpMethod.GET, headers);
	}
	protected String getResponse(String url, HttpMethod method, String... headers)
			throws IOException, URISyntaxException {
		try (ClientHttpResponse response = getClientResponse(url, method, headers)) {
			return StreamUtils.copyToString(response.getBody(), StandardCharsets.UTF_8);
		}
	}
	protected String getResponse(String url, HttpComponentsClientHttpRequestFactory requestFactory, String... headers)
			throws IOException, URISyntaxException {
		return getResponse(url, HttpMethod.GET, requestFactory, headers);
	}
	protected String getResponse(String url, HttpMethod method, HttpComponentsClientHttpRequestFactory requestFactory,
			String... headers) throws IOException, URISyntaxException {
		try (ClientHttpResponse response = getClientResponse(url, method, requestFactory, headers)) {
			return StreamUtils.copyToString(response.getBody(), StandardCharsets.UTF_8);
		}
	}
	protected ClientHttpResponse getClientResponse(String url, String... headers)
			throws IOException, URISyntaxException {
		return getClientResponse(url, HttpMethod.GET, headers);
	}
	protected ClientHttpResponse getClientResponse(String url, HttpMethod method, String... headers)
			throws IOException, URISyntaxException {
		return getClientResponse(url, method,
				new HttpComponentsClientHttpRequestFactory(this.httpClientBuilder.get().build()) {
					@Override
					protected HttpContext createHttpContext(HttpMethod httpMethod, URI uri) {
						return AbstractServletWebServerFactoryTests.this.httpClientContext;
					}
				}, headers);
	}
	protected ClientHttpResponse getClientResponse(String url, HttpMethod method,
			HttpComponentsClientHttpRequestFactory requestFactory, String... headers)
			throws IOException, URISyntaxException {
		ClientHttpRequest request = requestFactory.createRequest(new URI(url), method);
		for (String header : headers) {
			String[] parts = header.split(':');
			request.getHeaders().add(parts[0], parts[1]);
		}
		return request.execute();
	}
	protected void assertForwardHeaderIsUsed(ServletWebServerFactory factory) throws IOException, URISyntaxException {
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(true, false), '/hello'));
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'), 'X-Forwarded-For:140.211.11.130'))
			.contains('remoteaddr=140.211.11.130');
	}
	protected abstract AbstractServletWebServerFactory getFactory();
	protected abstract org.apache.jasper.servlet.JspServlet getJspServlet() throws Exception;
	protected ServletContextInitializer exampleServletRegistration() {
		return new ServletRegistrationBean<>(new ExampleServlet(), '/hello');
	}
	@SuppressWarnings('serial')
	private ServletContextInitializer errorServletRegistration() {
		ServletRegistrationBean<ExampleServlet> bean = new ServletRegistrationBean<>(new ExampleServlet() {
			@Override
			public void service(ServletRequest request, ServletResponse response) {
				throw new RuntimeException('Planned');
			}
		}, '/bang');
		bean.setName('error');
		return bean;
	}
	protected final ServletContextInitializer sessionServletRegistration() {
		ServletRegistrationBean<ExampleServlet> bean = new ServletRegistrationBean<>(new ExampleServlet() {
			@Override
			public void service(ServletRequest request, ServletResponse response) throws IOException {
				HttpSession session = ((HttpServletRequest) request).getSession(true);
				long value = System.currentTimeMillis();
				Object existing = session.getAttribute('boot');
				session.setAttribute('boot', value);
				PrintWriter writer = response.getWriter();
				writer.append(String.valueOf(existing)).append(':').append(String.valueOf(value));
			}
		}, '/session');
		bean.setName('session');
		return bean;
	}
	private <T> T doWithRetry(Callable<T> action) throws Exception {
		Exception lastFailure = null;
		for (int i = 0; i < 10; i++) {
			try {
				return action.call();
			}
			catch (Exception ex) {
				lastFailure = ex;
			}
		}
		throw new IllegalStateException('Action was not successful in 10 attempts', lastFailure);
	}
	protected final void doWithBlockedPort(BlockedPortAction action) throws Exception {
		ServerSocket serverSocket = new ServerSocket();
		try (serverSocket) {
			int blockedPort = doWithRetry(() -> {
				serverSocket.bind(null);
				return serverSocket.getLocalPort();
			});
			action.run(blockedPort);
		}
	}
	private void loadStore(KeyStore keyStore, Resource resource)
			throws IOException, NoSuchAlgorithmException, CertificateException {
		try (InputStream stream = resource.getInputStream()) {
			keyStore.load(stream, 'secret'.toCharArray());
		}
	}
	protected abstract String startedLogMessage();
	protected TlsSocketStrategy createTrustSelfSignedTlsSocketStrategy()
			throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build();
		return new DefaultClientTlsStrategy(sslContext);
	}
	private final class TestGzipInputStreamFactory implements InputStreamFactory {
		private final AtomicBoolean requested = new AtomicBoolean();
		@Override
		public InputStream create(InputStream in) throws IOException {
			if (this.requested.get()) {
				throw new IllegalStateException('On deflated InputStream already requested');
			}
			this.requested.set(true);
			return new GZIPInputStream(in);
		}
		boolean wasCompressionUsed() {
			return this.requested.get();
		}
	}
	@SuppressWarnings('serial')
	static class InitCountingServlet extends GenericServlet {
		private int initCount;
		@Override
		public void init() {
			this.initCount++;
		}
		@Override
		public void service(ServletRequest req, ServletResponse res) {
		}
		int getInitCount() {
			return this.initCount;
		}
	}
	interface BlockedPortAction {
		void run(int port);
	}
	/**
	 * {@link TrustSelfSignedStrategy} that also validates certificate serial number.
	 */
	private static final class SerialNumberValidatingTrustSelfSignedStrategy extends TrustSelfSignedStrategy {
		private final String serialNumber;
		private SerialNumberValidatingTrustSelfSignedStrategy(String serialNumber) {
			this.serialNumber = serialNumber;
		}
		@Override
		public boolean isTrusted(X509Certificate[] chain, String authType) {
			String hexSerialNumber = chain[0].getSerialNumber().toString(16);
			boolean isMatch = hexSerialNumber.equalsIgnoreCase(this.serialNumber);
			return super.isTrusted(chain, authType) && isMatch;
		}
	}
	public static class FailingServlet extends HttpServlet {
		@Override
		public void init() throws ServletException {
			throw new FailingServletException();
		}
	}
	public static class FailingServletContextListener implements ServletContextListener {
		@Override
		public void contextInitialized(ServletContextEvent sce) {
			throw new FailingServletException();
		}
	}
	static class FailingServletException extends RuntimeException {
		FailingServletException() {
			super('Init Failure');
		}
	}
	protected static class BlockingServlet extends HttpServlet {
		private final BlockingQueue<Blocker> blockers = new ArrayBlockingQueue<>(10);
		public BlockingServlet() {
		}
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			Blocker blocker = new Blocker();
			this.blockers.add(blocker);
			blocker.await();
		}
		public void admitOne() throws InterruptedException {
			this.blockers.take().clear();
		}
		public void awaitQueue() throws InterruptedException {
			while (this.blockers.isEmpty()) {
				Thread.sleep(100);
			}
		}
		public void awaitQueue(int size) throws InterruptedException {
			while (this.blockers.size() < size) {
				Thread.sleep(100);
			}
		}
	}
	static class BlockingAsyncServlet extends HttpServlet {
		private final BlockingQueue<Blocker> blockers = new ArrayBlockingQueue<>(10);
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			Blocker blocker = new Blocker();
			this.blockers.add(blocker);
			AsyncContext async = req.startAsync();
			new Thread(() -> {
				blocker.await();
				async.complete();
			}).start();
		}
		private void admitOne() throws InterruptedException {
			this.blockers.take().clear();
		}
		private void awaitQueue() throws InterruptedException {
			while (this.blockers.isEmpty()) {
				Thread.sleep(100);
			}
		}
	}
	private static final class Blocker {
		private boolean block = true;
		private final Object monitor = new Object();
		private void await() {
			synchronized (this.monitor) {
				while (this.block) {
					try {
						this.monitor.wait();
					}
					catch (InterruptedException ex) {
						System.out.println('Interrupted!');
						// Keep waiting
					}
				}
			}
		}
		private void clear() {
			synchronized (this.monitor) {
				this.block = false;
				this.monitor.notifyAll();
			}
		}
	}
	static final class CookieServlet extends HttpServlet {
		private final boolean addSupplierTestCookies;
		CookieServlet(boolean addSupplierTestCookies) {
			this.addSupplierTestCookies = addSupplierTestCookies;
		}
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
			req.getSession(true);
			resp.addCookie(new Cookie('test', 'test'));
			if (this.addSupplierTestCookies) {
				resp.addCookie(new Cookie('relaxed', 'test'));
				resp.addCookie(new Cookie('empty', 'test'));
				resp.addCookie(new Cookie('controlled', 'test'));
			}
		}
	}
	protected static class TrustSelfSignedStrategy implements TrustStrategy {
		public TrustSelfSignedStrategy() {
		}
		@Override
		public boolean isTrusted(X509Certificate[] chain, String authType) {
			return chain.length == 1;
		}
	}
	static class ThreadContextClassLoaderCapturingServlet extends HttpServlet {
		private ClassLoader contextClassLoader;
		@Override
		public void init(ServletConfig config) throws ServletException {
			this.contextClassLoader = Thread.currentThread().getContextClassLoader();
		}
	}
	static class ThreadContextClassLoaderCapturingListener implements ServletContextListener {
		private ClassLoader contextClassLoader;
		@Override
		public void contextInitialized(ServletContextEvent sce) {
			this.contextClassLoader = Thread.currentThread().getContextClassLoader();
		}
	}
	static class ThreadContextClassLoaderCapturingFilter implements Filter {
		private ClassLoader contextClassLoader;
		@Override
		public void init(FilterConfig filterConfig) throws ServletException {
			this.contextClassLoader = Thread.currentThread().getContextClassLoader();
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
				throws IOException, ServletException {
			chain.doFilter(request, response);
		}
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
class DocumentRootTests {
	@TempDir
	File tempDir;
	private final DocumentRoot documentRoot = new DocumentRoot(LogFactory.getLog(getClass()));
	@Test
	void explodedWarFileDocumentRootWhenRunningFromExplodedWar() throws Exception {
		File codeSourceFile = new File(this.tempDir, 'test.war/WEB-INF/lib/spring-boot.jar');
		codeSourceFile.getParentFile().mkdirs();
		codeSourceFile.createNewFile();
		File directory = this.documentRoot.getExplodedWarFileDocumentRoot(codeSourceFile);
		assertThat(directory).isEqualTo(codeSourceFile.getParentFile().getParentFile().getParentFile());
	}
	@Test
	void explodedWarFileDocumentRootWhenRunningFromPackagedWar() {
		File codeSourceFile = new File(this.tempDir, 'test.war');
		File directory = this.documentRoot.getExplodedWarFileDocumentRoot(codeSourceFile);
		assertThat(directory).isNull();
	}
	@Test
	void codeSourceArchivePath() throws Exception {
		CodeSource codeSource = new CodeSource(new URL('file', '', '/some/test/path/'), (Certificate[]) null);
		File codeSourceArchive = this.documentRoot.getCodeSourceArchive(codeSource);
		assertThat(codeSourceArchive).isEqualTo(new File('/some/test/path/'));
	}
	@Test
	void codeSourceArchivePathContainingSpaces() throws Exception {
		CodeSource codeSource = new CodeSource(new URL('file', '', '/test/path/with%20space/'), (Certificate[]) null);
		File codeSourceArchive = this.documentRoot.getCodeSourceArchive(codeSource);
		assertThat(codeSourceArchive).isEqualTo(new File('/test/path/with space/'));
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
public class MockServletWebServerFactory extends AbstractServletWebServerFactory {
	private MockServletWebServer webServer;
	@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		this.webServer = spy(new MockServletWebServer(mergeInitializers(initializers), getPort()));
		return this.webServer;
	}
	public MockServletWebServer getWebServer() {
		return this.webServer;
	}
	public ServletContext getServletContext() {
		return (getWebServer() != null) ? getWebServer().getServletContext() : null;
	}
	public RegisteredServlet getRegisteredServlet(int index) {
		return (getWebServer() != null) ? getWebServer().getRegisteredServlet(index) : null;
	}
	public RegisteredFilter getRegisteredFilter(int index) {
		return (getWebServer() != null) ? getWebServer().getRegisteredFilters(index) : null;
	}
	public static class MockServletWebServer
			extends org.springframework.boot.testsupport.web.servlet.MockServletWebServer implements WebServer {
		MockServletWebServer(ServletContextInitializer[] initializers, int port) {
			super(Arrays.stream(initializers)
				.map((initializer) -> (Initializer) initializer::onStartup)
				.toArray(Initializer[]::new), port);
		}
		@Override
		public void start() {
		}
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
class SessionTests {
	@Test // gh-38589
	void getCookieIsBinaryBackCompatible() throws Exception {
		Class<?> returnType = Session.class.getDeclaredMethod('getCookie').getReturnType();
		assertThat(returnType.getName()).isEqualTo('org.springframework.boot.web.servlet.server.Session$Cookie');
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
class CookieSameSiteSupplierTests {
	@Test
	void whenHasNameWhenNameIsNullThrowsException() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThatIllegalArgumentException().isThrownBy(() -> supplier.whenHasName((String) null))
			.withMessage('Name must not be empty');
	}
	@Test
	void whenHasNameWhenNameIsEmptyThrowsException() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThatIllegalArgumentException().isThrownBy(() -> supplier.whenHasName(''))
			.withMessage('Name must not be empty');
	}
	@Test
	void whenHasNameWhenNameMatchesCallsGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThat(supplier.whenHasName('test').getSameSite(new Cookie('test', 'x'))).isEqualTo(SameSite.LAX);
	}
	@Test
	void whenHasNameWhenNameDoesNotMatchDoesNotCallGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> fail('Supplier Called');
		assertThat(supplier.whenHasName('test').getSameSite(new Cookie('tset', 'x'))).isNull();
	}
	@Test
	void whenHasSuppliedNameWhenNameIsNullThrowsException() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThatIllegalArgumentException().isThrownBy(() -> supplier.whenHasName((Supplier<String>) null))
			.withMessage('NameSupplier must not be empty');
	}
	@Test
	void whenHasSuppliedNameWhenNameMatchesCallsGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThat(supplier.whenHasName(() -> 'test').getSameSite(new Cookie('test', 'x'))).isEqualTo(SameSite.LAX);
	}
	@Test
	void whenHasSuppliedNameWhenNameDoesNotMatchDoesNotCallGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> fail('Supplier Called');
		assertThat(supplier.whenHasName(() -> 'test').getSameSite(new Cookie('tset', 'x'))).isNull();
	}
	@Test
	void whenHasNameMatchingRegexWhenRegexIsNullThrowsException() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThatIllegalArgumentException().isThrownBy(() -> supplier.whenHasNameMatching((String) null))
			.withMessage('Regex must not be empty');
	}
	@Test
	void whenHasNameMatchingRegexWhenRegexIsEmptyThrowsException() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThatIllegalArgumentException().isThrownBy(() -> supplier.whenHasNameMatching(''))
			.withMessage('Regex must not be empty');
	}
	@Test
	void whenHasNameMatchingRegexWhenNameMatchesCallsGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThat(supplier.whenHasNameMatching('te.*').getSameSite(new Cookie('test', 'x'))).isEqualTo(SameSite.LAX);
	}
	@Test
	void whenHasNameMatchingRegexWhenNameDoesNotMatchDoesNotCallGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> fail('Supplier Called');
		assertThat(supplier.whenHasNameMatching('te.*').getSameSite(new Cookie('tset', 'x'))).isNull();
	}
	@Test
	void whenHasNameMatchingPatternWhenPatternIsNullThrowsException() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThatIllegalArgumentException().isThrownBy(() -> supplier.whenHasNameMatching((Pattern) null))
			.withMessage('Pattern must not be null');
	}
	@Test
	void whenHasNameMatchingPatternWhenNameMatchesCallsGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThat(supplier.whenHasNameMatching(Pattern.compile('te.*')).getSameSite(new Cookie('test', 'x')))
			.isEqualTo(SameSite.LAX);
	}
	@Test
	void whenHasNameMatchingPatternWhenNameDoesNotMatchDoesNotCallGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> fail('Supplier Called');
		assertThat(supplier.whenHasNameMatching(Pattern.compile('te.*')).getSameSite(new Cookie('tset', 'x'))).isNull();
	}
	@Test
	void whenWhenPredicateIsNullThrowsException() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThatIllegalArgumentException().isThrownBy(() -> supplier.when(null))
			.withMessage('Predicate must not be null');
	}
	@Test
	void whenWhenPredicateMatchesCallsGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> SameSite.LAX;
		assertThat(supplier.when((cookie) -> cookie.getName().equals('test')).getSameSite(new Cookie('test', 'x')))
			.isEqualTo(SameSite.LAX);
	}
	@Test
	void whenWhenPredicateDoesNotMatchDoesNotCallGetSameSite() {
		CookieSameSiteSupplier supplier = (cookie) -> fail('Supplier Called');
		assertThat(supplier.when((cookie) -> cookie.getName().equals('test')).getSameSite(new Cookie('tset', 'x')))
			.isNull();
	}
	@Test
	void ofNoneSuppliesNone() {
		assertThat(CookieSameSiteSupplier.ofNone().getSameSite(new Cookie('test', 'x'))).isEqualTo(SameSite.NONE);
	}
	@Test
	void ofLaxSuppliesLax() {
		assertThat(CookieSameSiteSupplier.ofLax().getSameSite(new Cookie('test', 'x'))).isEqualTo(SameSite.LAX);
	}
	@Test
	void ofStrictSuppliesStrict() {
		assertThat(CookieSameSiteSupplier.ofStrict().getSameSite(new Cookie('test', 'x'))).isEqualTo(SameSite.STRICT);
	}
	@Test
	void ofWhenNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> CookieSameSiteSupplier.of(null))
			.withMessage('SameSite must not be null');
	}
	@Test
	void ofSuppliesValue() {
		assertThat(CookieSameSiteSupplier.of(SameSite.STRICT).getSameSite(new Cookie('test', 'x')))
			.isEqualTo(SameSite.STRICT);
	}
}
/*
package org.springframework.boot.web.servlet.server;
/**
class StaticResourceJarsTests {
	@TempDir
	File tempDir;
	@Test
	void includeJarWithStaticResources() throws Exception {
		File jarFile = createResourcesJar('test-resources.jar');
		List<URL> staticResourceJarUrls = new StaticResourceJars().getUrlsFrom(jarFile.toURI().toURL());
		assertThat(staticResourceJarUrls).hasSize(1);
	}
	@Test
	void includeJarWithStaticResourcesWithUrlEncodedSpaces() throws Exception {
		File jarFile = createResourcesJar('test resources.jar');
		List<URL> staticResourceJarUrls = new StaticResourceJars().getUrlsFrom(jarFile.toURI().toURL());
		assertThat(staticResourceJarUrls).hasSize(1);
	}
	@Test
	void includeJarWithStaticResourcesWithPlusInItsPath() throws Exception {
		File jarFile = createResourcesJar('test + resources.jar');
		List<URL> staticResourceJarUrls = new StaticResourceJars().getUrlsFrom(jarFile.toURI().toURL());
		assertThat(staticResourceJarUrls).hasSize(1);
	}
	@Test
	void excludeJarWithoutStaticResources() throws Exception {
		File jarFile = createJar('dependency.jar');
		List<URL> staticResourceJarUrls = new StaticResourceJars().getUrlsFrom(jarFile.toURI().toURL());
		assertThat(staticResourceJarUrls).isEmpty();
	}
	@Test
	void uncPathsAreTolerated() throws Exception {
		File jarFile = createResourcesJar('test-resources.jar');
		List<URL> staticResourceJarUrls = new StaticResourceJars().getUrlsFrom(jarFile.toURI().toURL(),
				new URL('file://unc.example.com/test.jar'));
		assertThat(staticResourceJarUrls).hasSize(1);
	}
	@Test
	void ignoreWildcardUrls() throws Exception {
		File jarFile = createResourcesJar('test-resources.jar');
		URL folderUrl = jarFile.getParentFile().toURI().toURL();
		URL wildcardUrl = new URL(folderUrl + '*.jar');
		List<URL> staticResourceJarUrls = new StaticResourceJars().getUrlsFrom(wildcardUrl);
		assertThat(staticResourceJarUrls).isEmpty();
	}
	@Test
	void doesNotCloseJarFromCachedConnection() throws Exception {
		File jarFile = createResourcesJar('test-resources.jar');
		TrackedURLStreamHandler handler = new TrackedURLStreamHandler(true);
		URL url = new URL('jar', null, 0, jarFile.toURI().toURL() + '!/', handler);
		try {
			new StaticResourceJars().getUrlsFrom(url);
			assertThatNoException()
				.isThrownBy(() -> ((JarURLConnection) handler.getConnection()).getJarFile().getComment());
		}
		finally {
			((JarURLConnection) handler.getConnection()).getJarFile().close();
		}
	}
	@Test
	void closesJarFromNonCachedConnection() throws Exception {
		File jarFile = createResourcesJar('test-resources.jar');
		TrackedURLStreamHandler handler = new TrackedURLStreamHandler(false);
		URL url = new URL('jar', null, 0, jarFile.toURI().toURL() + '!/', handler);
		new StaticResourceJars().getUrlsFrom(url);
		assertThatIllegalStateException()
			.isThrownBy(() -> ((JarURLConnection) handler.getConnection()).getJarFile().getComment())
			.withMessageContaining('closed');
	}
	private File createResourcesJar(String name) throws IOException {
		return createJar(name, (output) -> {
			JarEntry jarEntry = new JarEntry('META-INF/resources');
			try {
				output.putNextEntry(jarEntry);
				output.closeEntry();
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
		});
	}
	private File createJar(String name) throws IOException {
		return createJar(name, null);
	}
	private File createJar(String name, Consumer<JarOutputStream> customizer) throws IOException {
		File jarFile = new File(this.tempDir, name);
		JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(jarFile));
		if (customizer != null) {
			customizer.accept(jarOutputStream);
		}
		jarOutputStream.close();
		return jarFile;
	}
	private static class TrackedURLStreamHandler extends URLStreamHandler {
		private final boolean useCaches;
		private URLConnection connection;
		TrackedURLStreamHandler(boolean useCaches) {
			this.useCaches = useCaches;
		}
		@Override
		protected URLConnection openConnection(URL u) throws IOException {
			this.connection = new URL(u.toExternalForm()).openConnection();
			this.connection.setUseCaches(this.useCaches);
			return this.connection;
		}
		URLConnection getConnection() {
			return this.connection;
		}
	}
}
/*
package org.springframework.boot.web.servlet.testcomponents.filter;
@WebFilter('/*')
public class TestFilter implements Filter {
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		request.setAttribute('filterAttribute', 'bravo');
		chain.doFilter(request, response);
	}
	@Override
	public void destroy() {
	}
}
/*
package org.springframework.boot.web.servlet.testcomponents.servlet;
@WebServlet('/test')
public class TestServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		resp.getWriter()
			.print(((String) req.getServletContext().getAttribute('listenerAttribute')) + ' '
					+ req.getAttribute('filterAttribute') + ' ' + req.getAttribute('listenerAddedFilterAttribute'));
		resp.getWriter().flush();
	}
}
/*
package org.springframework.boot.web.servlet.testcomponents.servlet;
@WebServlet('/test-multipart')
@MultipartConfig(location = 'test', maxFileSize = 1024, maxRequestSize = 2048, fileSizeThreshold = 512)
public class TestMultipartServlet extends HttpServlet {
}
/*
package org.springframework.boot.web.servlet.testcomponents.listener;
@WebListener
public class TestListener implements ServletContextListener {
	@Override
	public void contextInitialized(ServletContextEvent sce) {
		sce.getServletContext()
			.addFilter('listenerAddedFilter', new ListenerAddedFilter())
			.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), true, '/*');
		sce.getServletContext().setAttribute('listenerAttribute', 'alpha');
	}
	@Override
	public void contextDestroyed(ServletContextEvent sce) {
	}
	static class ListenerAddedFilter implements Filter {
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
				throws IOException, ServletException {
			request.setAttribute('listenerAddedFilterAttribute', 'charlie');
			chain.doFilter(request, response);
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
@ExtendWith(MockitoExtension.class)
class ServletRegistrationBeanTests {
	private final MockServlet servlet = new MockServlet();
	@Mock
	private ServletContext servletContext;
	@Mock
	private ServletRegistration.Dynamic registration;
	@Test
	void startupWithDefaults() throws Exception {
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(this.registration);
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>(this.servlet);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addServlet('mockServlet', this.servlet);
		then(this.registration).should().setAsyncSupported(true);
		then(this.registration).should().addMapping('/*');
	}
	@Test
	void failsWithDoubleRegistration() {
		assertThatIllegalStateException().isThrownBy(this::doubleRegistration)
			.withMessage('Failed to register "servlet double-registration" on '
					+ 'the servlet context. Possibly already registered?');
	}
	private void doubleRegistration() throws ServletException {
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>(this.servlet);
		bean.setName('double-registration');
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(null);
		bean.onStartup(this.servletContext);
	}
	@Test
	void startupWithSpecifiedValues() throws Exception {
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(this.registration);
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>();
		bean.setName('test');
		bean.setServlet(this.servlet);
		bean.setAsyncSupported(false);
		bean.setInitParameters(Collections.singletonMap('a', 'b'));
		bean.addInitParameter('c', 'd');
		bean.setUrlMappings(new LinkedHashSet<>(Arrays.asList('/a', '/b')));
		bean.addUrlMappings('/c');
		bean.setLoadOnStartup(10);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addServlet('test', this.servlet);
		then(this.registration).should().setAsyncSupported(false);
		Map<String, String> expectedInitParameters = new HashMap<>();
		expectedInitParameters.put('a', 'b');
		expectedInitParameters.put('c', 'd');
		then(this.registration).should().setInitParameters(expectedInitParameters);
		then(this.registration).should().addMapping('/a', '/b', '/c');
		then(this.registration).should().setLoadOnStartup(10);
	}
	@Test
	void specificName() throws Exception {
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(this.registration);
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>();
		bean.setName('specificName');
		bean.setServlet(this.servlet);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addServlet('specificName', this.servlet);
	}
	@Test
	void deducedName() throws Exception {
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(this.registration);
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>();
		bean.setServlet(this.servlet);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addServlet('mockServlet', this.servlet);
	}
	@Test
	void disable() throws Exception {
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>();
		bean.setServlet(this.servlet);
		bean.setEnabled(false);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should(never()).addServlet('mockServlet', this.servlet);
	}
	@Test
	void setServletMustNotBeNull() {
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>();
		assertThatIllegalArgumentException().isThrownBy(() -> bean.onStartup(this.servletContext))
			.withMessageContaining('Servlet must not be null');
	}
	@Test
	void createServletMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ServletRegistrationBean<MockServlet>(null))
			.withMessageContaining('Servlet must not be null');
	}
	@Test
	void setMappingMustNotBeNull() {
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>(this.servlet);
		assertThatIllegalArgumentException().isThrownBy(() -> bean.setUrlMappings(null))
			.withMessageContaining('UrlMappings must not be null');
	}
	@Test
	void createMappingMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ServletRegistrationBean<>(this.servlet, (String[]) null))
			.withMessageContaining('UrlMappings must not be null');
	}
	@Test
	void addMappingMustNotBeNull() {
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>(this.servlet);
		assertThatIllegalArgumentException().isThrownBy(() -> bean.addUrlMappings((String[]) null))
			.withMessageContaining('UrlMappings must not be null');
	}
	@Test
	void setMappingReplacesValue() throws Exception {
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(this.registration);
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>(this.servlet, '/a', '/b');
		bean.setUrlMappings(new LinkedHashSet<>(Arrays.asList('/c', '/d')));
		bean.onStartup(this.servletContext);
		then(this.registration).should().addMapping('/c', '/d');
	}
	@Test
	void modifyInitParameters() throws Exception {
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(this.registration);
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>(this.servlet, '/a', '/b');
		bean.addInitParameter('a', 'b');
		bean.getInitParameters().put('a', 'c');
		bean.onStartup(this.servletContext);
		then(this.registration).should().setInitParameters(Collections.singletonMap('a', 'c'));
	}
	@Test
	void withoutDefaultMappings() throws Exception {
		given(this.servletContext.addServlet(anyString(), any(Servlet.class))).willReturn(this.registration);
		ServletRegistrationBean<MockServlet> bean = new ServletRegistrationBean<>(this.servlet, false);
		bean.onStartup(this.servletContext);
		then(this.registration).should(never()).addMapping(any(String[].class));
	}
}
/*
package org.springframework.boot.web.servlet.error;
/**
class ErrorAttributesOptionsTests {
	@Test
	void includingFromEmptyAttributesReturnAddedEntry() {
		ErrorAttributeOptions options = ErrorAttributeOptions.of(EnumSet.noneOf(Include.class));
		assertThat(options.including(Include.EXCEPTION).getIncludes()).containsOnly(Include.EXCEPTION);
	}
	@Test
	void includingFromMatchingAttributesDoesNotModifyOptions() {
		ErrorAttributeOptions options = ErrorAttributeOptions.of(EnumSet.of(Include.EXCEPTION, Include.STACK_TRACE));
		assertThat(options.including(Include.EXCEPTION).getIncludes()).containsOnly(Include.EXCEPTION,
				Include.STACK_TRACE);
	}
	@Test
	void excludingFromEmptyAttributesReturnEmptyList() {
		ErrorAttributeOptions options = ErrorAttributeOptions.of(EnumSet.noneOf(Include.class));
		assertThat(options.excluding(Include.EXCEPTION).getIncludes()).isEmpty();
	}
	@Test
	void excludingFromMatchingAttributesRemoveMatch() {
		ErrorAttributeOptions options = ErrorAttributeOptions.of(EnumSet.of(Include.EXCEPTION, Include.STACK_TRACE));
		assertThat(options.excluding(Include.EXCEPTION).getIncludes()).containsOnly(Include.STACK_TRACE);
	}
}
/*
package org.springframework.boot.web.servlet.error;
/**
class DefaultErrorAttributesTests {
	private final DefaultErrorAttributes errorAttributes = new DefaultErrorAttributes();
	private final MockHttpServletRequest request = new MockHttpServletRequest();
	private final WebRequest webRequest = new ServletWebRequest(this.request);
	@Test
	void includeTimeStamp() {
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults());
		assertThat(attributes.get('timestamp')).isInstanceOf(Date.class);
	}
	@Test
	void specificStatusCode() {
		this.request.setAttribute('jakarta.servlet.error.status_code', 404);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('error', HttpStatus.NOT_FOUND.getReasonPhrase());
		assertThat(attributes).containsEntry('status', 404);
	}
	@Test
	void missingStatusCode() {
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('error', 'None');
		assertThat(attributes).containsEntry('status', 999);
	}
	@Test
	void mvcError() {
		RuntimeException ex = new RuntimeException('Test');
		ModelAndView modelAndView = this.errorAttributes.resolveException(this.request, null, null, ex);
		this.request.setAttribute('jakarta.servlet.error.exception', new RuntimeException('Ignored'));
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(ex);
		assertThat(modelAndView).isNull();
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'Test');
	}
	@Test
	void servletErrorWithMessage() {
		RuntimeException ex = new RuntimeException('Test');
		this.request.setAttribute('jakarta.servlet.error.exception', ex);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(ex);
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'Test');
	}
	@Test
	void servletErrorWithoutMessage() {
		RuntimeException ex = new RuntimeException('Test');
		this.request.setAttribute('jakarta.servlet.error.exception', ex);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults());
		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(ex);
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).doesNotContainKey('message');
	}
	@Test
	void servletMessageWithMessage() {
		this.request.setAttribute('jakarta.servlet.error.message', 'Test');
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'Test');
	}
	@Test
	void servletMessageWithoutMessage() {
		this.request.setAttribute('jakarta.servlet.error.message', 'Test');
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults());
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).doesNotContainKey('message');
	}
	@Test
	void nullExceptionMessage() {
		this.request.setAttribute('jakarta.servlet.error.exception', new RuntimeException());
		this.request.setAttribute('jakarta.servlet.error.message', 'Test');
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'Test');
	}
	@Test
	void nullExceptionMessageAndServletMessage() {
		this.request.setAttribute('jakarta.servlet.error.exception', new RuntimeException());
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'No message available');
	}
	@Test
	void unwrapServletException() {
		RuntimeException ex = new RuntimeException('Test');
		ServletException wrapped = new ServletException(new ServletException(ex));
		this.request.setAttribute('jakarta.servlet.error.exception', wrapped);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(wrapped);
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'Test');
	}
	@Test
	void getError() {
		Error error = new OutOfMemoryError('Test error');
		this.request.setAttribute('jakarta.servlet.error.exception', error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(error);
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'Test error');
	}
	@Test
	void withBindingErrors() {
		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap('a', 'b'), 'objectName');
		bindingResult.addError(new ObjectError('c', 'd'));
		Exception ex = new BindException(bindingResult);
		testBindingResult(bindingResult, ex, ErrorAttributeOptions.of(Include.MESSAGE, Include.BINDING_ERRORS));
	}
	@Test
	void withoutBindingErrors() {
		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap('a', 'b'), 'objectName');
		bindingResult.addError(new ObjectError('c', 'd'));
		Exception ex = new BindException(bindingResult);
		testBindingResult(bindingResult, ex, ErrorAttributeOptions.defaults());
	}
	@Test
	void withMethodArgumentNotValidExceptionBindingErrors() {
		Method method = ReflectionUtils.findMethod(String.class, 'substring', int.class);
		MethodParameter parameter = new MethodParameter(method, 0);
		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap('a', 'b'), 'objectName');
		bindingResult.addError(new ObjectError('c', 'd'));
		Exception ex = new MethodArgumentNotValidException(parameter, bindingResult);
		testBindingResult(bindingResult, ex, ErrorAttributeOptions.of(Include.MESSAGE, Include.BINDING_ERRORS));
	}
	@Test
	void withHandlerMethodValidationExceptionBindingErrors() {
		Object target = 'test';
		Method method = ReflectionUtils.findMethod(String.class, 'substring', int.class);
		MethodParameter parameter = new MethodParameter(method, 0);
		MethodValidationResult methodValidationResult = MethodValidationResult.create(target, method,
				List.of(new ParameterValidationResult(parameter, -1,
						List.of(new ObjectError('beginIndex', 'beginIndex is negative')), null, null, null,
						(error, sourceType) -> {
							throw new IllegalArgumentException('No source object of the given type');
						})));
		HandlerMethodValidationException ex = new HandlerMethodValidationException(methodValidationResult);
		testErrors(methodValidationResult.getAllErrors(),
				'Validation failed for method="public java.lang.String java.lang.String.substring(int)". Error count: 1',
				ex, ErrorAttributeOptions.of(Include.MESSAGE, Include.BINDING_ERRORS));
	}
	private void testBindingResult(BindingResult bindingResult, Exception ex, ErrorAttributeOptions options) {
		testErrors(bindingResult.getAllErrors(), 'Validation failed for object="objectName". Error count: 1', ex,
				options);
	}
	private void testErrors(List<? extends MessageSourceResolvable> errors, String expectedMessage, Exception ex,
			ErrorAttributeOptions options) {
		this.request.setAttribute('jakarta.servlet.error.exception', ex);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, options);
		if (options.isIncluded(Include.MESSAGE)) {
			assertThat(attributes).containsEntry('message', expectedMessage);
		}
		else {
			assertThat(attributes).doesNotContainKey('message');
		}
		if (options.isIncluded(Include.BINDING_ERRORS)) {
			assertThat(attributes).containsEntry('errors', errors);
		}
		else {
			assertThat(attributes).doesNotContainKey('errors');
		}
	}
	@Test
	void withExceptionAttribute() {
		DefaultErrorAttributes errorAttributes = new DefaultErrorAttributes();
		RuntimeException ex = new RuntimeException('Test');
		this.request.setAttribute('jakarta.servlet.error.exception', ex);
		Map<String, Object> attributes = errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.EXCEPTION, Include.MESSAGE));
		assertThat(attributes).containsEntry('exception', RuntimeException.class.getName());
		assertThat(attributes).containsEntry('message', 'Test');
	}
	@Test
	void withStackTraceAttribute() {
		RuntimeException ex = new RuntimeException('Test');
		this.request.setAttribute('jakarta.servlet.error.exception', ex);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.STACK_TRACE));
		assertThat(attributes.get('trace').toString()).startsWith('java.lang');
	}
	@Test
	void withoutStackTraceAttribute() {
		RuntimeException ex = new RuntimeException('Test');
		this.request.setAttribute('jakarta.servlet.error.exception', ex);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults());
		assertThat(attributes).doesNotContainKey('trace');
	}
	@Test
	void shouldIncludePathByDefault() {
		this.request.setAttribute('jakarta.servlet.error.request_uri', 'path');
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('path', 'path');
	}
	@Test
	void shouldIncludePath() {
		this.request.setAttribute('jakarta.servlet.error.request_uri', 'path');
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of(Include.PATH));
		assertThat(attributes).containsEntry('path', 'path');
	}
	@Test
	void shouldExcludePath() {
		this.request.setAttribute('jakarta.servlet.error.request_uri', 'path');
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.of());
		assertThat(attributes).doesNotContainEntry('path', 'path');
	}
	@Test
	void whenGetMessageIsOverriddenThenMessageAttributeContainsValueReturnedFromIt() {
		Map<String, Object> attributes = new DefaultErrorAttributes() {
			@Override
			protected String getMessage(WebRequest webRequest, Throwable error) {
				return 'custom message';
			}
		}.getErrorAttributes(this.webRequest, ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(attributes).containsEntry('message', 'custom message');
	}
	@Test
	void excludeStatus() {
		this.request.setAttribute('jakarta.servlet.error.status_code', 404);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults().excluding(Include.STATUS));
		assertThat(attributes).doesNotContainKey('status');
	}
	@Test
	void excludeError() {
		this.request.setAttribute('jakarta.servlet.error.status_code', 404);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest,
				ErrorAttributeOptions.defaults().excluding(Include.ERROR));
		assertThat(attributes).doesNotContainKey('error');
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class ServletComponentScanRegistrarTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void after() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void packagesConfiguredWithValue() {
		this.context = new AnnotationConfigApplicationContext(ValuePackages.class);
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).contains('com.example.foo', 'com.example.bar');
	}
	@Test
	void packagesConfiguredWithValueAsm() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.registerBeanDefinition('valuePackages', new RootBeanDefinition(ValuePackages.class.getName()));
		this.context.refresh();
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).contains('com.example.foo', 'com.example.bar');
	}
	@Test
	void packagesConfiguredWithBackPackages() {
		this.context = new AnnotationConfigApplicationContext(BasePackages.class);
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).contains('com.example.foo', 'com.example.bar');
	}
	@Test
	void packagesConfiguredWithBasePackageClasses() {
		this.context = new AnnotationConfigApplicationContext(BasePackageClasses.class);
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).contains(getClass().getPackage().getName());
	}
	@Test
	void packagesConfiguredWithBothValueAndBasePackages() {
		assertThatExceptionOfType(AnnotationConfigurationException.class)
			.isThrownBy(() -> this.context = new AnnotationConfigApplicationContext(ValueAndBasePackages.class))
			.withMessageContaining('"value"')
			.withMessageContaining('"basePackages"')
			.withMessageContaining('com.example.foo')
			.withMessageContaining('com.example.bar');
	}
	@Test
	void packagesFromMultipleAnnotationsAreMerged() {
		this.context = new AnnotationConfigApplicationContext(BasePackages.class, AdditionalPackages.class);
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).contains('com.example.foo', 'com.example.bar', 'com.example.baz');
	}
	@Test
	void withNoBasePackagesScanningUsesBasePackageOfAnnotatedClass() {
		this.context = new AnnotationConfigApplicationContext(NoBasePackages.class);
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).containsExactly('org.springframework.boot.web.servlet');
	}
	@Test
	void noBasePackageAndBasePackageAreCombinedCorrectly() {
		this.context = new AnnotationConfigApplicationContext(NoBasePackages.class, BasePackages.class);
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).containsExactlyInAnyOrder('org.springframework.boot.web.servlet',
				'com.example.foo', 'com.example.bar');
	}
	@Test
	void basePackageAndNoBasePackageAreCombinedCorrectly() {
		this.context = new AnnotationConfigApplicationContext(BasePackages.class, NoBasePackages.class);
		ServletComponentRegisteringPostProcessor postProcessor = this.context
			.getBean(ServletComponentRegisteringPostProcessor.class);
		assertThat(postProcessor.getPackagesToScan()).containsExactlyInAnyOrder('org.springframework.boot.web.servlet',
				'com.example.foo', 'com.example.bar');
	}
	@Test
	@CompileWithForkedClassLoader
	void processAheadOfTimeDoesNotRegisterServletComponentRegisteringPostProcessor() {
		GenericApplicationContext context = new AnnotationConfigApplicationContext();
		context.registerBean(BasePackages.class);
		compile(context, (freshContext) -> {
			freshContext.refresh();
			assertThat(freshContext.getBeansOfType(ServletComponentRegisteringPostProcessor.class)).isEmpty();
		});
	}
	@Test
	void processAheadOfTimeRegistersReflectionHintsForWebListeners() {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();
		context.registerBean(ScanListenerPackage.class);
		TestGenerationContext generationContext = new TestGenerationContext(
				ClassName.get(getClass().getPackageName(), 'TestTarget'));
		new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext);
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(TestListener.class)
			.withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS))
			.accepts(generationContext.getRuntimeHints());
	}
	@Test
	void processAheadOfTimeSucceedsForWebServletWithMultipartConfig() {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();
		context.registerBean(ScanServletPackage.class);
		TestGenerationContext generationContext = new TestGenerationContext(
				ClassName.get(getClass().getPackageName(), 'TestTarget'));
		assertThatNoException()
			.isThrownBy(() -> new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext));
	}
	@SuppressWarnings('unchecked')
	private void compile(GenericApplicationContext context, Consumer<GenericApplicationContext> freshContext) {
		TestGenerationContext generationContext = new TestGenerationContext(
				ClassName.get(getClass().getPackageName(), 'TestTarget'));
		ClassName className = new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext);
		generationContext.writeGeneratedContent();
		TestCompiler.forSystem().with(generationContext).compile((compiled) -> {
			GenericApplicationContext freshApplicationContext = new GenericApplicationContext();
			ApplicationContextInitializer<GenericApplicationContext> initializer = compiled
				.getInstance(ApplicationContextInitializer.class, className.toString());
			initializer.initialize(freshApplicationContext);
			freshContext.accept(freshApplicationContext);
		});
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan({ 'com.example.foo', 'com.example.bar' })
	static class ValuePackages {
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan(basePackages = { 'com.example.foo', 'com.example.bar' })
	static class BasePackages {
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan(basePackages = 'com.example.baz')
	static class AdditionalPackages {
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan(basePackageClasses = ServletComponentScanRegistrarTests.class)
	static class BasePackageClasses {
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan(value = 'com.example.foo', basePackages = 'com.example.bar')
	static class ValueAndBasePackages {
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan
	static class NoBasePackages {
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan('org.springframework.boot.web.servlet.testcomponents.listener')
	static class ScanListenerPackage {
	}
	@Configuration(proxyBeanMethods = false)
	@ServletComponentScan('org.springframework.boot.web.servlet.testcomponents.servlet')
	static class ScanServletPackage {
	}
}
/*
package org.springframework.boot.web.servlet;
/**
@DirtiesUrlFactories
class ServletComponentScanIntegrationTests {
	private AnnotationConfigServletWebServerApplicationContext context;
	@TempDir
	File temp;
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void componentsAreRegistered(String serverName, Class<?> configuration) {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.register(configuration);
		new ServerPortInfoApplicationContextInitializer().initialize(this.context);
		this.context.refresh();
		String port = this.context.getEnvironment().getProperty('local.server.port');
		String response = new RestTemplate().getForObject('http://localhost:' + port + '/test', String.class);
		assertThat(response).isEqualTo('alpha bravo charlie');
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void indexedComponentsAreRegistered(String serverName, Class<?> configuration) throws IOException {
		writeIndex(this.temp);
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		try (URLClassLoader classLoader = new URLClassLoader(new URL[] { this.temp.toURI().toURL() },
				getClass().getClassLoader())) {
			this.context.setClassLoader(classLoader);
			this.context.register(configuration);
			new ServerPortInfoApplicationContextInitializer().initialize(this.context);
			this.context.refresh();
			String port = this.context.getEnvironment().getProperty('local.server.port');
			String response = new RestTemplate().getForObject('http://localhost:' + port + '/test', String.class);
			assertThat(response).isEqualTo('alpha bravo charlie');
		}
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void multipartConfigIsHonoured(String serverName, Class<?> configuration) {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.register(configuration);
		new ServerPortInfoApplicationContextInitializer().initialize(this.context);
		this.context.refresh();
		@SuppressWarnings('rawtypes')
		Map<String, ServletRegistrationBean> beans = this.context.getBeansOfType(ServletRegistrationBean.class);
		ServletRegistrationBean<?> servletRegistrationBean = beans.get(TestMultipartServlet.class.getName());
		assertThat(servletRegistrationBean).isNotNull();
		MultipartConfigElement multipartConfig = servletRegistrationBean.getMultipartConfig();
		assertThat(multipartConfig).isNotNull();
		assertThat(multipartConfig.getLocation()).isEqualTo('test');
		assertThat(multipartConfig.getMaxRequestSize()).isEqualTo(2048);
		assertThat(multipartConfig.getMaxFileSize()).isEqualTo(1024);
		assertThat(multipartConfig.getFileSizeThreshold()).isEqualTo(512);
	}
	private void writeIndex(File temp) throws IOException {
		File metaInf = new File(temp, 'META-INF');
		metaInf.mkdirs();
		Properties index = new Properties();
		index.setProperty(TestFilter.class.getName(), WebFilter.class.getName());
		index.setProperty(TestListener.class.getName(), WebListener.class.getName());
		index.setProperty(TestServlet.class.getName(), WebServlet.class.getName());
		try (FileWriter writer = new FileWriter(new File(metaInf, 'spring.components'))) {
			index.store(writer, null);
		}
	}
	static Stream<Arguments> testConfiguration() {
		return Stream.of(Arguments.of('Jetty', JettyTestConfiguration.class),
				Arguments.of('Tomcat', TomcatTestConfiguration.class),
				Arguments.of('Undertow', UndertowTestConfiguration.class));
	}
	@ServletComponentScan(basePackages = 'org.springframework.boot.web.servlet.testcomponents')
	abstract static class AbstractTestConfiguration {
		@Bean
		protected ServletWebServerFactory webServerFactory(ObjectProvider<WebListenerRegistrar> webListenerRegistrars) {
			ConfigurableServletWebServerFactory factory = createWebServerFactory();
			webListenerRegistrars.orderedStream().forEach((registrar) -> registrar.register(factory));
			return factory;
		}
		abstract ConfigurableServletWebServerFactory createWebServerFactory();
	}
	@Configuration(proxyBeanMethods = false)
	static class JettyTestConfiguration extends AbstractTestConfiguration {
		@Override
		ConfigurableServletWebServerFactory createWebServerFactory() {
			return new JettyServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatTestConfiguration extends AbstractTestConfiguration {
		@Override
		ConfigurableServletWebServerFactory createWebServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UndertowTestConfiguration extends AbstractTestConfiguration {
		@Override
		ConfigurableServletWebServerFactory createWebServerFactory() {
			return new UndertowServletWebServerFactory(0);
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class MultipartConfigFactoryTests {
	@Test
	void sensibleDefaults() {
		MultipartConfigFactory factory = new MultipartConfigFactory();
		MultipartConfigElement config = factory.createMultipartConfig();
		assertThat(config.getLocation()).isEmpty();
		assertThat(config.getMaxFileSize()).isEqualTo(-1L);
		assertThat(config.getMaxRequestSize()).isEqualTo(-1L);
		assertThat(config.getFileSizeThreshold()).isZero();
	}
	@Test
	void createWithDataSizes() {
		MultipartConfigFactory factory = new MultipartConfigFactory();
		factory.setMaxFileSize(DataSize.ofBytes(1));
		factory.setMaxRequestSize(DataSize.ofKilobytes(2));
		factory.setFileSizeThreshold(DataSize.ofMegabytes(3));
		MultipartConfigElement config = factory.createMultipartConfig();
		assertThat(config.getMaxFileSize()).isOne();
		assertThat(config.getMaxRequestSize()).isEqualTo(2 * 1024L);
		assertThat(config.getFileSizeThreshold()).isEqualTo(3 * 1024 * 1024);
	}
	@Test
	void createWithNegativeDataSizes() {
		MultipartConfigFactory factory = new MultipartConfigFactory();
		factory.setMaxFileSize(DataSize.ofBytes(-1));
		factory.setMaxRequestSize(DataSize.ofKilobytes(-2));
		factory.setFileSizeThreshold(DataSize.ofMegabytes(-3));
		MultipartConfigElement config = factory.createMultipartConfig();
		assertThat(config.getMaxFileSize()).isEqualTo(-1L);
		assertThat(config.getMaxRequestSize()).isEqualTo(-1);
		assertThat(config.getFileSizeThreshold()).isZero();
	}
}
/*
package org.springframework.boot.web.servlet;
/**
@ExtendWith(MockitoExtension.class)
class ServletListenerRegistrationBeanTests {
	@Mock
	private ServletContextListener listener;
	@Mock
	private ServletContext servletContext;
	@Test
	void startupWithDefaults() throws Exception {
		ServletListenerRegistrationBean<ServletContextListener> bean = new ServletListenerRegistrationBean<>(
				this.listener);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addListener(this.listener);
	}
	@Test
	void disable() throws Exception {
		ServletListenerRegistrationBean<ServletContextListener> bean = new ServletListenerRegistrationBean<>(
				this.listener);
		bean.setEnabled(false);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should(never()).addListener(any(ServletContextListener.class));
	}
	@Test
	void cannotRegisterUnsupportedType() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ServletListenerRegistrationBean<>(new EventListener() {
			}))
			.withMessageContaining('Listener is not of a supported type');
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class WebFilterHandlerTests {
	private final WebFilterHandler handler = new WebFilterHandler();
	private final SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();
	@SuppressWarnings('unchecked')
	@Test
	void defaultFilterConfiguration() throws IOException {
		AnnotatedBeanDefinition definition = createBeanDefinition(DefaultConfigurationFilter.class);
		this.handler.handle(definition, this.registry);
		BeanDefinition filterRegistrationBean = this.registry
			.getBeanDefinition(DefaultConfigurationFilter.class.getName());
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat(propertyValues.get('asyncSupported')).isEqualTo(false);
		assertThat((EnumSet<DispatcherType>) propertyValues.get('dispatcherTypes'))
			.containsExactly(DispatcherType.REQUEST);
		assertThat(((Map<String, String>) propertyValues.get('initParameters'))).isEmpty();
		assertThat((String[]) propertyValues.get('servletNames')).isEmpty();
		assertThat((String[]) propertyValues.get('urlPatterns')).isEmpty();
		assertThat(propertyValues.get('name')).isEqualTo(DefaultConfigurationFilter.class.getName());
		assertThat(propertyValues.get('filter')).isEqualTo(definition);
	}
	@Test
	void filterWithCustomName() throws IOException {
		AnnotatedBeanDefinition definition = createBeanDefinition(CustomNameFilter.class);
		this.handler.handle(definition, this.registry);
		BeanDefinition filterRegistrationBean = this.registry.getBeanDefinition('custom');
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat(propertyValues.get('name')).isEqualTo('custom');
	}
	@Test
	void asyncSupported() throws IOException {
		BeanDefinition filterRegistrationBean = handleBeanDefinitionForClass(AsyncSupportedFilter.class);
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat(propertyValues.get('asyncSupported')).isEqualTo(true);
	}
	@Test
	@SuppressWarnings('unchecked')
	void dispatcherTypes() throws IOException {
		BeanDefinition filterRegistrationBean = handleBeanDefinitionForClass(DispatcherTypesFilter.class);
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat((Set<DispatcherType>) propertyValues.get('dispatcherTypes')).containsExactly(DispatcherType.FORWARD,
				DispatcherType.INCLUDE, DispatcherType.REQUEST);
	}
	@SuppressWarnings('unchecked')
	@Test
	void initParameters() throws IOException {
		BeanDefinition filterRegistrationBean = handleBeanDefinitionForClass(InitParametersFilter.class);
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat((Map<String, String>) propertyValues.get('initParameters')).containsEntry('a', 'alpha')
			.containsEntry('b', 'bravo');
	}
	@Test
	void servletNames() throws IOException {
		BeanDefinition filterRegistrationBean = handleBeanDefinitionForClass(ServletNamesFilter.class);
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat((String[]) propertyValues.get('servletNames')).contains('alpha', 'bravo');
	}
	@Test
	void urlPatterns() throws IOException {
		BeanDefinition filterRegistrationBean = handleBeanDefinitionForClass(UrlPatternsFilter.class);
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat((String[]) propertyValues.get('urlPatterns')).contains('alpha', 'bravo');
	}
	@Test
	void urlPatternsFromValue() throws IOException {
		BeanDefinition filterRegistrationBean = handleBeanDefinitionForClass(UrlPatternsFromValueFilter.class);
		MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();
		assertThat((String[]) propertyValues.get('urlPatterns')).contains('alpha', 'bravo');
	}
	@Test
	void urlPatternsDeclaredTwice() {
		assertThatIllegalStateException()
			.isThrownBy(() -> handleBeanDefinitionForClass(UrlPatternsDeclaredTwiceFilter.class))
			.withMessageContaining('The urlPatterns and value attributes are mutually exclusive.');
	}
	private AnnotatedBeanDefinition createBeanDefinition(Class<?> filterClass) throws IOException {
		AnnotatedBeanDefinition definition = mock(AnnotatedBeanDefinition.class);
		given(definition.getBeanClassName()).willReturn(filterClass.getName());
		given(definition.getMetadata()).willReturn(
				new SimpleMetadataReaderFactory().getMetadataReader(filterClass.getName()).getAnnotationMetadata());
		return definition;
	}
	private BeanDefinition handleBeanDefinitionForClass(Class<?> filterClass) throws IOException {
		this.handler.handle(createBeanDefinition(filterClass), this.registry);
		return this.registry.getBeanDefinition(filterClass.getName());
	}
	@WebFilter
	class DefaultConfigurationFilter extends BaseFilter {
	}
	@WebFilter(asyncSupported = true)
	class AsyncSupportedFilter extends BaseFilter {
	}
	@WebFilter(dispatcherTypes = { DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE })
	class DispatcherTypesFilter extends BaseFilter {
	}
	@WebFilter(initParams = { @WebInitParam(name = 'a', value = 'alpha'), @WebInitParam(name = 'b', value = 'bravo') })
	class InitParametersFilter extends BaseFilter {
	}
	@WebFilter(servletNames = { 'alpha', 'bravo' })
	class ServletNamesFilter extends BaseFilter {
	}
	@WebFilter(urlPatterns = { 'alpha', 'bravo' })
	class UrlPatternsFilter extends BaseFilter {
	}
	@WebFilter({ 'alpha', 'bravo' })
	class UrlPatternsFromValueFilter extends BaseFilter {
	}
	@WebFilter(value = { 'alpha', 'bravo' }, urlPatterns = { 'alpha', 'bravo' })
	class UrlPatternsDeclaredTwiceFilter extends BaseFilter {
	}
	@WebFilter(filterName = 'custom')
	class CustomNameFilter extends BaseFilter {
	}
	class BaseFilter implements Filter {
		@Override
		public void init(FilterConfig filterConfig) {
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
		}
		@Override
		public void destroy() {
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class WebServletHandlerTests {
	private final WebServletHandler handler = new WebServletHandler();
	private final SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();
	@SuppressWarnings('unchecked')
	@Test
	void defaultServletConfiguration() throws IOException {
		AnnotatedBeanDefinition servletDefinition = createBeanDefinition(DefaultConfigurationServlet.class);
		this.handler.handle(servletDefinition, this.registry);
		BeanDefinition servletRegistrationBean = this.registry
			.getBeanDefinition(DefaultConfigurationServlet.class.getName());
		MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues();
		assertThat(propertyValues.get('asyncSupported')).isEqualTo(false);
		assertThat(((Map<String, String>) propertyValues.get('initParameters'))).isEmpty();
		assertThat((Integer) propertyValues.get('loadOnStartup')).isEqualTo(-1);
		assertThat(propertyValues.get('name')).isEqualTo(DefaultConfigurationServlet.class.getName());
		assertThat((String[]) propertyValues.get('urlMappings')).isEmpty();
		assertThat(propertyValues.get('servlet')).isEqualTo(servletDefinition);
	}
	@Test
	void servletWithCustomName() throws IOException {
		AnnotatedBeanDefinition definition = createBeanDefinition(CustomNameServlet.class);
		this.handler.handle(definition, this.registry);
		BeanDefinition servletRegistrationBean = this.registry.getBeanDefinition('custom');
		MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues();
		assertThat(propertyValues.get('name')).isEqualTo('custom');
	}
	@Test
	void asyncSupported() throws IOException {
		BeanDefinition servletRegistrationBean = handleBeanDefinitionForClass(AsyncSupportedServlet.class);
		MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues();
		assertThat(propertyValues.get('asyncSupported')).isEqualTo(true);
	}
	@SuppressWarnings('unchecked')
	@Test
	void initParameters() throws IOException {
		BeanDefinition servletRegistrationBean = handleBeanDefinitionForClass(InitParametersServlet.class);
		MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues();
		assertThat((Map<String, String>) propertyValues.get('initParameters')).containsEntry('a', 'alpha')
			.containsEntry('b', 'bravo');
	}
	@Test
	void urlMappings() throws IOException {
		BeanDefinition servletRegistrationBean = handleBeanDefinitionForClass(UrlPatternsServlet.class);
		MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues();
		assertThat((String[]) propertyValues.get('urlMappings')).contains('alpha', 'bravo');
	}
	@Test
	void urlMappingsFromValue() throws IOException {
		BeanDefinition servletRegistrationBean = handleBeanDefinitionForClass(UrlPatternsFromValueServlet.class);
		MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues();
		assertThat((String[]) propertyValues.get('urlMappings')).contains('alpha', 'bravo');
	}
	@Test
	void urlPatternsDeclaredTwice() {
		assertThatIllegalStateException()
			.isThrownBy(() -> handleBeanDefinitionForClass(UrlPatternsDeclaredTwiceServlet.class))
			.withMessageContaining('The urlPatterns and value attributes are mutually exclusive.');
	}
	private AnnotatedBeanDefinition createBeanDefinition(Class<?> servletClass) throws IOException {
		AnnotatedBeanDefinition definition = mock(AnnotatedBeanDefinition.class);
		given(definition.getBeanClassName()).willReturn(servletClass.getName());
		given(definition.getMetadata()).willReturn(
				new SimpleMetadataReaderFactory().getMetadataReader(servletClass.getName()).getAnnotationMetadata());
		return definition;
	}
	private BeanDefinition handleBeanDefinitionForClass(Class<?> filterClass) throws IOException {
		this.handler.handle(createBeanDefinition(filterClass), this.registry);
		return this.registry.getBeanDefinition(filterClass.getName());
	}
	@WebServlet
	class DefaultConfigurationServlet extends HttpServlet {
	}
	@WebServlet(asyncSupported = true)
	class AsyncSupportedServlet extends HttpServlet {
	}
	@WebServlet(initParams = { @WebInitParam(name = 'a', value = 'alpha'), @WebInitParam(name = 'b', value = 'bravo') })
	class InitParametersServlet extends HttpServlet {
	}
	@WebServlet(urlPatterns = { 'alpha', 'bravo' })
	class UrlPatternsServlet extends HttpServlet {
	}
	@WebServlet({ 'alpha', 'bravo' })
	class UrlPatternsFromValueServlet extends HttpServlet {
	}
	@WebServlet(value = { 'alpha', 'bravo' }, urlPatterns = { 'alpha', 'bravo' })
	class UrlPatternsDeclaredTwiceServlet extends HttpServlet {
	}
	@WebServlet(name = 'custom')
	class CustomNameServlet extends HttpServlet {
	}
}
/*
package org.springframework.boot.web.servlet.view;
/**
class MustacheViewResolverTests {
	private final String prefix = 'classpath:/' + getClass().getPackage().getName().replace('.', '/') + '/';
	private final MustacheViewResolver resolver = new MustacheViewResolver();
	@BeforeEach
	void init() {
		GenericApplicationContext applicationContext = new GenericApplicationContext();
		applicationContext.refresh();
		this.resolver.setApplicationContext(applicationContext);
		this.resolver.setServletContext(new MockServletContext());
		this.resolver.setPrefix(this.prefix);
		this.resolver.setSuffix('.html');
	}
	@Test
	void resolveNonExistent() throws Exception {
		assertThat(this.resolver.resolveViewName('bar', null)).isNull();
	}
	@Test
	void resolveExisting() throws Exception {
		assertThat(this.resolver.resolveViewName('template', null)).isNotNull();
	}
	@Test
	void setsContentType() throws Exception {
		this.resolver.setContentType('application/octet-stream');
		View view = this.resolver.resolveViewName('template', null);
		assertThat(view.getContentType()).isEqualTo('application/octet-stream');
	}
}
/*
package org.springframework.boot.web.servlet.view;
/**
class MustacheViewTests {
	private final String templateUrl = 'classpath:/' + getClass().getPackage().getName().replace('.', '/')
			+ '/template.html';
	private final MockHttpServletRequest request = new MockHttpServletRequest();
	private final MockHttpServletResponse response = new MockHttpServletResponse();
	private final AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext();
	@BeforeEach
	void init() {
		this.context.refresh();
		MockServletContext servletContext = new MockServletContext();
		this.context.setServletContext(servletContext);
		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
	}
	@Test
	void viewResolvesHandlebars() throws Exception {
		MustacheView view = new MustacheView();
		view.setCompiler(Mustache.compiler());
		view.setUrl(this.templateUrl);
		view.setApplicationContext(this.context);
		view.render(Collections.singletonMap('World', 'Spring'), this.request, this.response);
		assertThat(this.response.getContentAsString().trim()).isEqualTo('Hello Spring');
	}
}
/*
package org.springframework.boot.web.servlet.support;
/**
@ExtendWith(OutputCaptureExtension.class)
class ErrorPageFilterTests {
	private final ErrorPageFilter filter = new ErrorPageFilter();
	private final DispatchRecordingMockHttpServletRequest request = new DispatchRecordingMockHttpServletRequest();
	private final MockHttpServletResponse response = new MockHttpServletResponse();
	private MockFilterChain chain = new TestFilterChain((request, response, chain) -> {
	});
	@Test
	void notAnError() throws Exception {
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(this.response.getForwardedUrl()).isNull();
	}
	@Test
	void notAnErrorButNotOK() throws Exception {
		this.chain = new TestFilterChain((request, response, chain) -> {
			response.setStatus(201);
			chain.call();
			response.flushBuffer();
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponse) this.chain.getResponse()).getStatus()).isEqualTo(201);
		assertThat(((HttpServletResponse) ((HttpServletResponseWrapper) this.chain.getResponse()).getResponse())
			.getStatus()).isEqualTo(201);
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void unauthorizedWithErrorPath() throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.chain = new TestFilterChain((request, response, chain) -> response.sendError(401, 'UNAUTHORIZED'));
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		HttpServletResponseWrapper wrapper = (HttpServletResponseWrapper) this.chain.getResponse();
		assertThat(wrapper.getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(wrapper.getStatus()).isEqualTo(401);
		// The real response has to be 401 as well...
		assertThat(this.response.getStatus()).isEqualTo(401);
		assertThat(this.response.getForwardedUrl()).isEqualTo('/error');
	}
	@Test
	void responseCommitted() throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.response.setCommitted(true);
		this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, 'BAD'));
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400);
		assertThat(this.response.getForwardedUrl()).isNull();
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void responseCommittedWhenFromClientAbortException(CapturedOutput output) throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.response.setCommitted(true);
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new ClientAbortException();
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(output).doesNotContain('Cannot forward');
	}
	@Test
	void responseUncommittedWithoutErrorPage() throws Exception {
		this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, 'BAD'));
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400);
		assertThat(this.response.getForwardedUrl()).isNull();
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void oncePerRequest() throws Exception {
		this.chain = new TestFilterChain((request, response, chain) -> {
			response.sendError(400, 'BAD');
			assertThat(request.getAttribute('FILTER.FILTERED')).isNotNull();
		});
		this.filter.init(new MockFilterConfig('FILTER'));
		this.filter.doFilter(this.request, this.response, this.chain);
	}
	@Test
	void globalError() throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, 'BAD'));
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(400);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo('BAD');
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo('/test/path');
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(this.response.getForwardedUrl()).isEqualTo('/error');
	}
	@Test
	void statusError() throws Exception {
		this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, '/400'));
		this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, 'BAD'));
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(400);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo('BAD');
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo('/test/path');
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(this.response.getForwardedUrl()).isEqualTo('/400');
	}
	@Test
	void statusErrorWithCommittedResponse() throws Exception {
		this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, '/400'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			response.sendError(400, 'BAD');
			response.flushBuffer();
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400);
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(this.response.getForwardedUrl()).isNull();
	}
	@Test
	void exceptionError() throws Exception {
		this.filter.addErrorPages(new ErrorPage(RuntimeException.class, '/500'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new RuntimeException('BAD');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo('BAD');
		Map<String, Object> requestAttributes = getAttributesForDispatch('/500');
		assertThat(requestAttributes).containsEntry(RequestDispatcher.ERROR_EXCEPTION_TYPE, RuntimeException.class);
		assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION)).isInstanceOf(RuntimeException.class);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo('/test/path');
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(this.response.getForwardedUrl()).isEqualTo('/500');
	}
	@Test
	void exceptionErrorWithCommittedResponse() throws Exception {
		this.filter.addErrorPages(new ErrorPage(RuntimeException.class, '/500'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			response.flushBuffer();
			throw new RuntimeException('BAD');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.response.getForwardedUrl()).isNull();
	}
	@Test
	void statusCode() throws Exception {
		this.chain = new TestFilterChain((request, response, chain) -> assertThat(response.getStatus()).isEqualTo(200));
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(200);
	}
	@Test
	void subClassExceptionError() throws Exception {
		this.filter.addErrorPages(new ErrorPage(RuntimeException.class, '/500'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new IllegalStateException('BAD');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo('BAD');
		Map<String, Object> requestAttributes = getAttributesForDispatch('/500');
		assertThat(requestAttributes).containsEntry(RequestDispatcher.ERROR_EXCEPTION_TYPE,
				IllegalStateException.class);
		assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION)).isInstanceOf(IllegalStateException.class);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo('/test/path');
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void responseIsNotCommittedWhenRequestIsAsync() throws Exception {
		this.request.setAsyncStarted(true);
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isFalse();
	}
	@Test
	void responseIsCommittedWhenRequestIsAsyncAndExceptionIsThrown() throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.request.setAsyncStarted(true);
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new RuntimeException('BAD');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void responseIsCommittedWhenRequestIsAsyncAndStatusIs400Plus() throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.request.setAsyncStarted(true);
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			response.sendError(400, 'BAD');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void responseIsNotCommittedDuringAsyncDispatch() throws Exception {
		setUpAsyncDispatch();
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isFalse();
	}
	@Test
	void responseIsCommittedWhenExceptionIsThrownDuringAsyncDispatch() throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		setUpAsyncDispatch();
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new RuntimeException('BAD');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void responseIsCommittedWhenStatusIs400PlusDuringAsyncDispatch() throws Exception {
		this.filter.addErrorPages(new ErrorPage('/error'));
		setUpAsyncDispatch();
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			response.sendError(400, 'BAD');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.chain.getRequest()).isEqualTo(this.request);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response);
		assertThat(this.response.isCommitted()).isTrue();
	}
	@Test
	void responseIsNotFlushedIfStatusIsLessThan400AndItHasAlreadyBeenCommitted() throws Exception {
		HttpServletResponse committedResponse = mock(HttpServletResponse.class);
		given(committedResponse.isCommitted()).willReturn(true);
		given(committedResponse.getStatus()).willReturn(200);
		this.filter.doFilter(this.request, committedResponse, this.chain);
		then(committedResponse).should(never()).flushBuffer();
	}
	@Test
	void errorMessageForRequestWithoutPathInfo(CapturedOutput output) throws IOException, ServletException {
		this.request.setServletPath('/test');
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new RuntimeException();
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(output).contains('request [/test]');
	}
	@Test
	void errorMessageForRequestWithPathInfo(CapturedOutput output) throws IOException, ServletException {
		this.request.setServletPath('/test');
		this.request.setPathInfo('/alpha');
		this.filter.addErrorPages(new ErrorPage('/error'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new RuntimeException();
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(output).contains('request [/test/alpha]');
	}
	@Test
	void servletExceptionIsUnwrapped() throws Exception {
		this.filter.addErrorPages(new ErrorPage(RuntimeException.class, '/500'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new ServletException('Wrapper', new RuntimeException('BAD'));
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo('BAD');
		Map<String, Object> requestAttributes = getAttributesForDispatch('/500');
		assertThat(requestAttributes).containsEntry(RequestDispatcher.ERROR_EXCEPTION_TYPE, RuntimeException.class);
		assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION)).isInstanceOf(RuntimeException.class);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo('/test/path');
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(this.response.getForwardedUrl()).isEqualTo('/500');
	}
	@Test
	void servletExceptionWithNoCause() throws Exception {
		this.filter.addErrorPages(new ErrorPage(MissingServletRequestParameterException.class, '/500'));
		this.chain = new TestFilterChain((request, response, chain) -> {
			chain.call();
			throw new MissingServletRequestParameterException('test', 'string');
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(500);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE))
			.isEqualTo('Required request parameter "test" for method parameter type string is not present');
		Map<String, Object> requestAttributes = getAttributesForDispatch('/500');
		assertThat(requestAttributes).containsEntry(RequestDispatcher.ERROR_EXCEPTION_TYPE,
				MissingServletRequestParameterException.class);
		assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION))
			.isInstanceOf(MissingServletRequestParameterException.class);
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).isNull();
		assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo('/test/path');
		assertThat(this.response.isCommitted()).isTrue();
		assertThat(this.response.getForwardedUrl()).isEqualTo('/500');
	}
	@Test
	void whenErrorIsSentAndWriterIsFlushedErrorIsSentToTheClient() throws Exception {
		this.chain = new TestFilterChain((request, response, chain) -> {
			response.sendError(400);
			response.getWriter().flush();
		});
		this.filter.doFilter(this.request, this.response, this.chain);
		assertThat(this.response.getStatus()).isEqualTo(400);
	}
	private void setUpAsyncDispatch() throws Exception {
		this.request.setAsyncSupported(true);
		this.request.setAsyncStarted(true);
		DeferredResult<String> result = new DeferredResult<>();
		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(this.request);
		asyncManager.setAsyncWebRequest(new StandardServletAsyncWebRequest(this.request, this.response));
		asyncManager.startDeferredResultProcessing(result);
	}
	private Map<String, Object> getAttributesForDispatch(String path) {
		return this.request.getDispatcher(path).getRequestAttributes();
	}
	static class TestFilterChain extends MockFilterChain {
		private final FilterHandler handler;
		TestFilterChain(FilterHandler handler) {
			this.handler = handler;
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {
			AtomicBoolean called = new AtomicBoolean();
			Chain chain = () -> {
				if (called.compareAndSet(false, true)) {
					super.doFilter(request, response);
				}
			};
			this.handler.handle((HttpServletRequest) request, (HttpServletResponse) response, chain);
			chain.call();
		}
	}
	@FunctionalInterface
	interface FilterHandler {
		void handle(HttpServletRequest request, HttpServletResponse response, Chain chain)
				throws IOException, ServletException;
	}
	@FunctionalInterface
	interface Chain {
		void call() throws IOException, ServletException;
	}
	private static final class DispatchRecordingMockHttpServletRequest extends MockHttpServletRequest {
		private final Map<String, AttributeCapturingRequestDispatcher> dispatchers = new HashMap<>();
		private DispatchRecordingMockHttpServletRequest() {
			super('GET', '/test/path');
		}
		@Override
		public RequestDispatcher getRequestDispatcher(String path) {
			AttributeCapturingRequestDispatcher dispatcher = new AttributeCapturingRequestDispatcher(path);
			this.dispatchers.put(path, dispatcher);
			return dispatcher;
		}
		private AttributeCapturingRequestDispatcher getDispatcher(String path) {
			return this.dispatchers.get(path);
		}
		private static final class AttributeCapturingRequestDispatcher extends MockRequestDispatcher {
			private final Map<String, Object> requestAttributes = new HashMap<>();
			private AttributeCapturingRequestDispatcher(String resource) {
				super(resource);
			}
			@Override
			public void forward(ServletRequest request, ServletResponse response) {
				captureAttributes(request);
				super.forward(request, response);
			}
			private void captureAttributes(ServletRequest request) {
				Enumeration<String> names = request.getAttributeNames();
				while (names.hasMoreElements()) {
					String name = names.nextElement();
					this.requestAttributes.put(name, request.getAttribute(name));
				}
			}
			private Map<String, Object> getRequestAttributes() {
				return this.requestAttributes;
			}
		}
	}
}
/*
package org.springframework.boot.web.servlet.support;
/**
@ExtendWith(SpringExtension.class)
@DirtiesContext
@ContextConfiguration(classes = ErrorPageFilterIntegrationTests.TomcatConfig.class,
		loader = EmbeddedWebContextLoader.class)
class ErrorPageFilterIntegrationTests {
	@Autowired
	private HelloWorldController controller;
	@Autowired
	private AnnotationConfigServletWebServerApplicationContext context;
	@AfterEach
	void init() {
		this.controller.reset();
	}
	@Test
	void created() throws Exception {
		doTest(this.context, '/create', HttpStatus.CREATED);
		assertThat(this.controller.getStatus()).isEqualTo(201);
	}
	@Test
	void ok() throws Exception {
		doTest(this.context, '/hello', HttpStatus.OK);
		assertThat(this.controller.getStatus()).isEqualTo(200);
	}
	private void doTest(AnnotationConfigServletWebServerApplicationContext context, String resourcePath,
			HttpStatus status) throws Exception {
		int port = context.getWebServer().getPort();
		RestTemplate template = new RestTemplate();
		ResponseEntity<String> entity = template.getForEntity(new URI('http://localhost:' + port + resourcePath),
				String.class);
		assertThat(entity.getBody()).isEqualTo('Hello World');
		assertThat(entity.getStatusCode()).isEqualTo(status);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class TomcatConfig {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		ErrorPageFilter errorPageFilter() {
			return new ErrorPageFilter();
		}
		@Bean
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
		@Bean
		HelloWorldController helloWorldController() {
			return new HelloWorldController();
		}
	}
	@Controller
	static class HelloWorldController implements WebMvcConfigurer {
		private int status;
		private CountDownLatch latch = new CountDownLatch(1);
		int getStatus() throws InterruptedException {
			assertThat(this.latch.await(1, TimeUnit.SECONDS)).as('Timed out waiting for latch').isTrue();
			return this.status;
		}
		void setStatus(int status) {
			this.status = status;
		}
		void reset() {
			this.status = 0;
			this.latch = new CountDownLatch(1);
		}
		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new HandlerInterceptor() {
				@Override
				public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
						ModelAndView modelAndView) {
					HelloWorldController.this.setStatus(response.getStatus());
					HelloWorldController.this.latch.countDown();
				}
			});
		}
		@RequestMapping('/hello')
		@ResponseBody
		String sayHello() {
			return 'Hello World';
		}
		@RequestMapping('/create')
		@ResponseBody
		@ResponseStatus(HttpStatus.CREATED)
		String created() {
			return 'Hello World';
		}
	}
	static class EmbeddedWebContextLoader extends AbstractContextLoader {
		private static final String[] EMPTY_RESOURCE_SUFFIXES = {};
		@Override
		public ApplicationContext loadContext(MergedContextConfiguration config) {
			AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
					config.getClasses());
			context.registerShutdownHook();
			return context;
		}
		@Override
		protected String[] getResourceSuffixes() {
			return EMPTY_RESOURCE_SUFFIXES;
		}
		@Override
		protected String getResourceSuffix() {
			throw new UnsupportedOperationException();
		}
	}
}
/*
package org.springframework.boot.web.servlet.support;
/**
@ExtendWith(OutputCaptureExtension.class)
class SpringBootServletInitializerTests {
	private final ServletContext servletContext = new MockServletContext();
	private SpringApplication application;
	@AfterEach
	void verifyLoggingOutput(CapturedOutput output) {
		assertThat(output).doesNotContain(StandardServletEnvironment.class.getSimpleName());
	}
	@Test
	void failsWithoutConfigure() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new MockSpringBootServletInitializer().createRootApplicationContext(this.servletContext))
			.withMessageContaining('No SpringApplication sources have been defined');
	}
	@Test
	void withConfigurationAnnotation() {
		new WithConfigurationAnnotation().createRootApplicationContext(this.servletContext);
		assertThat(this.application.getAllSources()).containsOnly(WithConfigurationAnnotation.class,
				ErrorPageFilterConfiguration.class);
	}
	@Test
	void withConfiguredSource() {
		new WithConfiguredSource().createRootApplicationContext(this.servletContext);
		assertThat(this.application.getAllSources()).containsOnly(Config.class, ErrorPageFilterConfiguration.class);
	}
	@Test
	void applicationBuilderCanBeCustomized() {
		CustomSpringBootServletInitializer servletInitializer = new CustomSpringBootServletInitializer();
		servletInitializer.createRootApplicationContext(this.servletContext);
		assertThat(servletInitializer.applicationBuilder.built).isTrue();
	}
	@Test
	void mainClassHasSensibleDefault() {
		new WithConfigurationAnnotation().createRootApplicationContext(this.servletContext);
		assertThat(this.application).hasFieldOrPropertyWithValue('mainApplicationClass',
				WithConfigurationAnnotation.class);
	}
	@Test
	void shutdownHooksAreNotRegistered() throws ServletException {
		new WithConfigurationAnnotation().onStartup(this.servletContext);
		assertThat(this.servletContext.getAttribute(LoggingApplicationListener.REGISTER_SHUTDOWN_HOOK_PROPERTY))
			.isEqualTo(false);
		Object properties = ReflectionTestUtils.getField(this.application, 'properties');
		assertThat(properties).hasFieldOrPropertyWithValue('registerShutdownHook', false);
	}
	@Test
	void errorPageFilterRegistrationCanBeDisabled() {
		WebServer webServer = new UndertowServletWebServerFactory(0).getWebServer((servletContext) -> {
			try (AbstractApplicationContext context = (AbstractApplicationContext) new WithErrorPageFilterNotRegistered()
				.createRootApplicationContext(servletContext)) {
				assertThat(context.getBeansOfType(ErrorPageFilter.class)).isEmpty();
			}
		});
		try {
			webServer.start();
		}
		finally {
			webServer.stop();
		}
	}
	@Test
	@SuppressWarnings('rawtypes')
	void errorPageFilterIsRegisteredWithNearHighestPrecedence() {
		WebServer webServer = new UndertowServletWebServerFactory(0).getWebServer((servletContext) -> {
			try (AbstractApplicationContext context = (AbstractApplicationContext) new WithErrorPageFilter()
				.createRootApplicationContext(servletContext)) {
				Map<String, FilterRegistrationBean> registrations = context
					.getBeansOfType(FilterRegistrationBean.class);
				assertThat(registrations).hasSize(1);
				FilterRegistrationBean errorPageFilterRegistration = registrations.get('errorPageFilterRegistration');
				assertThat(errorPageFilterRegistration.getOrder()).isEqualTo(Ordered.HIGHEST_PRECEDENCE + 1);
			}
		});
		try {
			webServer.start();
		}
		finally {
			webServer.stop();
		}
	}
	@Test
	@SuppressWarnings('rawtypes')
	void errorPageFilterIsRegisteredForRequestAndAsyncDispatch() {
		WebServer webServer = new UndertowServletWebServerFactory(0).getWebServer((servletContext) -> {
			try (AbstractApplicationContext context = (AbstractApplicationContext) new WithErrorPageFilter()
				.createRootApplicationContext(servletContext)) {
				Map<String, FilterRegistrationBean> registrations = context
					.getBeansOfType(FilterRegistrationBean.class);
				assertThat(registrations).hasSize(1);
				FilterRegistrationBean errorPageFilterRegistration = registrations.get('errorPageFilterRegistration');
				assertThat(errorPageFilterRegistration).hasFieldOrPropertyWithValue('dispatcherTypes',
						EnumSet.of(DispatcherType.ASYNC, DispatcherType.REQUEST));
			}
		});
		try {
			webServer.start();
		}
		finally {
			webServer.stop();
		}
	}
	@Test
	void executableWarThatUsesServletInitializerDoesNotHaveErrorPageFilterConfigured() {
		try (ConfigurableApplicationContext context = new SpringApplication(ExecutableWar.class).run()) {
			assertThat(context.getBeansOfType(ErrorPageFilter.class)).isEmpty();
		}
	}
	@Test
	void servletContextPropertySourceIsAvailablePriorToRefresh() {
		ServletContext servletContext = mock(ServletContext.class);
		given(servletContext.addFilter(any(), any(Filter.class))).willReturn(mock(Dynamic.class));
		given(servletContext.getInitParameterNames())
			.willReturn(Collections.enumeration(Collections.singletonList('spring.profiles.active')));
		given(servletContext.getInitParameter('spring.profiles.active')).willReturn('from-servlet-context');
		given(servletContext.getAttributeNames()).willReturn(Collections.emptyEnumeration());
		try (ConfigurableApplicationContext context = (ConfigurableApplicationContext) new PropertySourceVerifyingSpringBootServletInitializer()
			.createRootApplicationContext(servletContext)) {
			assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('from-servlet-context');
		}
	}
	@Test
	void whenServletContextIsDestroyedThenJdbcDriversAreDeregistered() throws ServletException {
		ServletContext servletContext = mock(ServletContext.class);
		given(servletContext.addFilter(any(), any(Filter.class))).willReturn(mock(Dynamic.class));
		given(servletContext.getInitParameterNames()).willReturn(new Vector<String>().elements());
		given(servletContext.getAttributeNames()).willReturn(new Vector<String>().elements());
		AtomicBoolean driversDeregistered = new AtomicBoolean();
		new SpringBootServletInitializer() {
			@Override
			protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
				return builder.sources(Config.class);
			}
			@Override
			protected void deregisterJdbcDrivers(ServletContext servletContext) {
				driversDeregistered.set(true);
			}
		}.onStartup(servletContext);
		ArgumentCaptor<ServletContextListener> captor = ArgumentCaptor.forClass(ServletContextListener.class);
		then(servletContext).should().addListener(captor.capture());
		captor.getValue().contextDestroyed(new ServletContextEvent(servletContext));
		assertThat(driversDeregistered).isTrue();
	}
	@Test
	void whenServletContextIsDestroyedThenReactorSchedulersAreShutDown() throws ServletException {
		ServletContext servletContext = mock(ServletContext.class);
		given(servletContext.addFilter(any(), any(Filter.class))).willReturn(mock(Dynamic.class));
		given(servletContext.getInitParameterNames()).willReturn(new Vector<String>().elements());
		given(servletContext.getAttributeNames()).willReturn(new Vector<String>().elements());
		AtomicBoolean schedulersShutDown = new AtomicBoolean();
		new SpringBootServletInitializer() {
			@Override
			protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
				return builder.sources(Config.class);
			}
			@Override
			protected void shutDownSharedReactorSchedulers(ServletContext servletContext) {
				schedulersShutDown.set(true);
			}
		}.onStartup(servletContext);
		ArgumentCaptor<ServletContextListener> captor = ArgumentCaptor.forClass(ServletContextListener.class);
		then(servletContext).should().addListener(captor.capture());
		captor.getValue().contextDestroyed(new ServletContextEvent(servletContext));
		assertThat(schedulersShutDown).isTrue();
	}
	static class PropertySourceVerifyingSpringBootServletInitializer extends SpringBootServletInitializer {
		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
			return builder.sources(TestApp.class).listeners(new PropertySourceVerifyingApplicationListener());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestApp {
	}
	private class MockSpringBootServletInitializer extends SpringBootServletInitializer {
		@Override
		protected WebApplicationContext run(SpringApplication application) {
			SpringBootServletInitializerTests.this.application = application;
			return null;
		}
	}
	private final class CustomSpringBootServletInitializer extends MockSpringBootServletInitializer {
		private final CustomSpringApplicationBuilder applicationBuilder = new CustomSpringApplicationBuilder();
		@Override
		protected SpringApplicationBuilder createSpringApplicationBuilder() {
			return this.applicationBuilder;
		}
		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
			return application.sources(Config.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	public class WithConfigurationAnnotation extends MockSpringBootServletInitializer {
	}
	public class WithConfiguredSource extends MockSpringBootServletInitializer {
		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
			return application.sources(Config.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WithErrorPageFilterNotRegistered extends SpringBootServletInitializer {
		WithErrorPageFilterNotRegistered() {
			setRegisterErrorPageFilter(false);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WithErrorPageFilter extends SpringBootServletInitializer {
	}
	@Configuration(proxyBeanMethods = false)
	static class ExecutableWar extends SpringBootServletInitializer {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new UndertowServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
	static class CustomSpringApplicationBuilder extends SpringApplicationBuilder {
		private boolean built;
		@Override
		public SpringApplication build() {
			this.built = true;
			return super.build();
		}
	}
	private static final class PropertySourceVerifyingApplicationListener
			implements ApplicationListener<ApplicationEnvironmentPreparedEvent> {
		@Override
		public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
			PropertySource<?> propertySource = event.getEnvironment()
				.getPropertySources()
				.get(StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME);
			assertThat(propertySource.getProperty('spring.profiles.active')).isEqualTo('from-servlet-context');
		}
	}
}
/*
package org.springframework.boot.web.servlet.support;
/**
class ServletContextApplicationContextInitializerTests {
	private final ServletContext servletContext = mock(ServletContext.class);
	private final ConfigurableWebApplicationContext applicationContext = mock(ConfigurableWebApplicationContext.class);
	@Test
	void servletContextIsSetOnTheApplicationContext() {
		new ServletContextApplicationContextInitializer(this.servletContext).initialize(this.applicationContext);
		then(this.applicationContext).should().setServletContext(this.servletContext);
	}
	@Test
	void applicationContextIsNotStoredInServletContextByDefault() {
		new ServletContextApplicationContextInitializer(this.servletContext).initialize(this.applicationContext);
		then(this.servletContext).should(never())
			.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.applicationContext);
	}
	@Test
	void applicationContextCanBeStoredInServletContext() {
		new ServletContextApplicationContextInitializer(this.servletContext, true).initialize(this.applicationContext);
		then(this.servletContext).should()
			.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.applicationContext);
	}
}
/*
package org.springframework.boot.web.servlet;
class TestServletAndFilterAndListener implements Servlet, Filter, ServletRequestListener {
	@Override
	public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)
			throws IOException, ServletException {
	}
	@Override
	public void init(ServletConfig servletConfig) throws ServletException {
	}
	@Override
	public ServletConfig getServletConfig() {
		return null;
	}
	@Override
	public void service(ServletRequest servletRequest, ServletResponse servletResponse)
			throws ServletException, IOException {
	}
	@Override
	public String getServletInfo() {
		return null;
	}
	@Override
	public void destroy() {
	}
}
/*
package org.springframework.boot.web.servlet.mock;
/**
public class MockServlet extends GenericServlet {
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
	}
}
/*
/**
package org.springframework.boot.web.servlet.mock;
/*
package org.springframework.boot.web.servlet.mock;
/**
public class MockFilter implements Filter {
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
	}
	@Override
	public void destroy() {
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class FilterRegistrationBeanTests extends AbstractFilterRegistrationBeanTests {
	private final MockFilter filter = new MockFilter();
	private final OncePerRequestFilter oncePerRequestFilter = new OncePerRequestFilter() {
		@Override
		protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
				FilterChain filterChain) throws ServletException, IOException {
			filterChain.doFilter(request, response);
		}
	};
	@Test
	void setFilter() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>();
		bean.setFilter(this.filter);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addFilter('mockFilter', this.filter);
	}
	@Test
	void setFilterMustNotBeNull() {
		FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>();
		assertThatIllegalArgumentException().isThrownBy(() -> bean.onStartup(this.servletContext))
			.withMessageContaining('Filter must not be null');
	}
	@Test
	void constructFilterMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new FilterRegistrationBean<>(null))
			.withMessageContaining('Filter must not be null');
	}
	@Test
	void createServletRegistrationBeanMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new FilterRegistrationBean<>(this.filter, (ServletRegistrationBean[]) null))
			.withMessageContaining('ServletRegistrationBeans must not be null');
	}
	@Test
	void startupWithOncePerRequestDefaults() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		FilterRegistrationBean<?> bean = new FilterRegistrationBean<>(this.oncePerRequestFilter);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addFilter(eq('oncePerRequestFilter'), eq(this.oncePerRequestFilter));
		then(this.registration).should().setAsyncSupported(true);
		then(this.registration).should().addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, '/*');
	}
	@Override
	protected AbstractFilterRegistrationBean<MockFilter> createFilterRegistrationBean(
			ServletRegistrationBean<?>... servletRegistrationBeans) {
		return new FilterRegistrationBean<>(this.filter, servletRegistrationBeans);
	}
	@Override
	protected Filter getExpectedFilter() {
		return eq(this.filter);
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class ServletContextInitializerBeansTests {
	private ConfigurableApplicationContext context;
	@Test
	void servletThatImplementsServletContextInitializerIsOnlyRegisteredOnce() {
		load(ServletConfiguration.class);
		ServletContextInitializerBeans initializerBeans = new ServletContextInitializerBeans(
				this.context.getBeanFactory());
		assertThat(initializerBeans).hasSize(1);
		assertThat(initializerBeans.iterator()).toIterable().hasOnlyElementsOfType(TestServlet.class);
	}
	@Test
	void filterThatImplementsServletContextInitializerIsOnlyRegisteredOnce() {
		load(FilterConfiguration.class);
		ServletContextInitializerBeans initializerBeans = new ServletContextInitializerBeans(
				this.context.getBeanFactory());
		assertThat(initializerBeans).hasSize(1);
		assertThat(initializerBeans.iterator()).toIterable().hasOnlyElementsOfType(TestFilter.class);
	}
	@Test
	void looksForInitializerBeansOfSpecifiedType() {
		load(TestConfiguration.class);
		ServletContextInitializerBeans initializerBeans = new ServletContextInitializerBeans(
				this.context.getBeanFactory(), TestServletContextInitializer.class);
		assertThat(initializerBeans).hasSize(1);
		assertThat(initializerBeans.iterator()).toIterable().hasOnlyElementsOfType(TestServletContextInitializer.class);
	}
	@Test
	void whenAnHttpSessionIdListenerBeanIsDefinedThenARegistrationBeanIsCreatedForIt() {
		load(HttpSessionIdListenerConfiguration.class);
		ServletContextInitializerBeans initializerBeans = new ServletContextInitializerBeans(
				this.context.getBeanFactory());
		assertThat(initializerBeans).hasSize(1);
		assertThat(initializerBeans).first()
			.isInstanceOf(ServletListenerRegistrationBean.class)
			.extracting((initializer) -> ((ServletListenerRegistrationBean<?>) initializer).getListener())
			.isInstanceOf(HttpSessionIdListener.class);
	}
	@Test
	void classesThatImplementMultipleInterfacesAreRegisteredForAllOfThem() {
		load(MultipleInterfacesConfiguration.class);
		ServletContextInitializerBeans initializerBeans = new ServletContextInitializerBeans(
				this.context.getBeanFactory());
		assertThat(initializerBeans).hasSize(3);
		assertThat(initializerBeans).element(0)
			.isInstanceOf(ServletRegistrationBean.class)
			.extracting((initializer) -> ((ServletRegistrationBean<?>) initializer).getServlet())
			.isInstanceOf(TestServletAndFilterAndListener.class);
		assertThat(initializerBeans).element(1)
			.isInstanceOf(FilterRegistrationBean.class)
			.extracting((initializer) -> ((FilterRegistrationBean<?>) initializer).getFilter())
			.isInstanceOf(TestServletAndFilterAndListener.class);
		assertThat(initializerBeans).element(2)
			.isInstanceOf(ServletListenerRegistrationBean.class)
			.extracting((initializer) -> ((ServletListenerRegistrationBean<?>) initializer).getListener())
			.isInstanceOf(TestServletAndFilterAndListener.class);
	}
	private void load(Class<?>... configuration) {
		this.context = new AnnotationConfigApplicationContext(configuration);
	}
	@Configuration(proxyBeanMethods = false)
	static class ServletConfiguration {
		@Bean
		TestServlet testServlet() {
			return new TestServlet();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FilterConfiguration {
		@Bean
		TestFilter testFilter() {
			return new TestFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleInterfacesConfiguration {
		@Bean
		TestServletAndFilterAndListener testServletAndFilterAndListener() {
			return new TestServletAndFilterAndListener();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		TestServletContextInitializer testServletContextInitializer() {
			return new TestServletContextInitializer();
		}
		@Bean
		OtherTestServletContextInitializer otherTestServletContextInitializer() {
			return new OtherTestServletContextInitializer();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HttpSessionIdListenerConfiguration {
		@Bean
		HttpSessionIdListener httpSessionIdListener() {
			return (event, oldId) -> {
			};
		}
	}
	static class TestServlet extends HttpServlet implements ServletContextInitializer {
		@Override
		public void onStartup(ServletContext servletContext) {
		}
	}
	static class TestFilter implements Filter, ServletContextInitializer {
		@Override
		public void onStartup(ServletContext servletContext) {
		}
		@Override
		public void init(FilterConfig filterConfig) {
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
		}
		@Override
		public void destroy() {
		}
	}
	static class TestServletContextInitializer implements ServletContextInitializer {
		@Override
		public void onStartup(ServletContext servletContext) throws ServletException {
		}
	}
	static class OtherTestServletContextInitializer implements ServletContextInitializer {
		@Override
		public void onStartup(ServletContext servletContext) throws ServletException {
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class FilterRegistrationIntegrationTests {
	private AnnotationConfigServletWebServerApplicationContext context;
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void normalFiltersAreRegistered() {
		load(FilterConfiguration.class);
		assertThat(this.context.getServletContext().getFilterRegistrations()).hasSize(1);
	}
	@Test
	void scopedTargetFiltersAreNotRegistered() {
		load(ScopedTargetFilterConfiguration.class);
		assertThat(this.context.getServletContext().getFilterRegistrations()).isEmpty();
	}
	private void load(Class<?> configuration) {
		this.context = new AnnotationConfigServletWebServerApplicationContext(ContainerConfiguration.class,
				configuration);
	}
	@Configuration(proxyBeanMethods = false)
	static class ContainerConfiguration {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ScopedTargetFilterConfiguration {
		@Bean(name = 'scopedTarget.myFilter')
		Filter myFilter() {
			return new MockFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FilterConfiguration {
		@Bean
		Filter myFilter() {
			return new MockFilter();
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class DelegatingFilterProxyRegistrationBeanTests extends AbstractFilterRegistrationBeanTests {
	private static final ThreadLocal<Boolean> mockFilterInitialized = new ThreadLocal<>();
	private final GenericWebApplicationContext applicationContext = new GenericWebApplicationContext(
			new MockServletContext());
	@Test
	void targetBeanNameMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DelegatingFilterProxyRegistrationBean(null))
			.withMessageContaining('TargetBeanName must not be null or empty');
	}
	@Test
	void targetBeanNameMustNotBeEmpty() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DelegatingFilterProxyRegistrationBean(''))
			.withMessageContaining('TargetBeanName must not be null or empty');
	}
	@Test
	void nameDefaultsToTargetBeanName() {
		assertThat(new DelegatingFilterProxyRegistrationBean('myFilter').getOrDeduceName(null)).isEqualTo('myFilter');
	}
	@Test
	void getFilterUsesDelegatingFilterProxy() {
		DelegatingFilterProxyRegistrationBean registrationBean = createFilterRegistrationBean();
		Filter filter = registrationBean.getFilter();
		assertThat(filter).isInstanceOf(DelegatingFilterProxy.class);
		assertThat(filter).extracting('webApplicationContext').isEqualTo(this.applicationContext);
		assertThat(filter).extracting('targetBeanName').isEqualTo('mockFilter');
	}
	@Test
	void initShouldNotCauseEarlyInitialization() throws Exception {
		this.applicationContext.registerBeanDefinition('mockFilter', new RootBeanDefinition(MockFilter.class));
		DelegatingFilterProxyRegistrationBean registrationBean = createFilterRegistrationBean();
		Filter filter = registrationBean.getFilter();
		filter.init(new MockFilterConfig());
		mockFilterInitialized.remove();
		filter.doFilter(new MockHttpServletRequest(), new MockHttpServletResponse(), new MockFilterChain());
		assertThat(mockFilterInitialized.get()).isTrue();
	}
	@Test
	void createServletRegistrationBeanMustNotBeNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new DelegatingFilterProxyRegistrationBean('mockFilter', (ServletRegistrationBean<?>[]) null))
			.withMessageContaining('ServletRegistrationBeans must not be null');
	}
	@Override
	protected DelegatingFilterProxyRegistrationBean createFilterRegistrationBean(
			ServletRegistrationBean<?>... servletRegistrationBeans) {
		DelegatingFilterProxyRegistrationBean bean = new DelegatingFilterProxyRegistrationBean('mockFilter',
				servletRegistrationBeans);
		bean.setApplicationContext(this.applicationContext);
		return bean;
	}
	@Override
	protected Filter getExpectedFilter() {
		return isA(DelegatingFilterProxy.class);
	}
	static class MockFilter extends GenericFilterBean {
		MockFilter() {
			mockFilterInitialized.set(true);
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
@ExtendWith(MockitoExtension.class)
abstract class AbstractFilterRegistrationBeanTests {
	@Mock
	ServletContext servletContext;
	@Mock
	FilterRegistration.Dynamic registration;
	@Test
	void startupWithDefaults() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addFilter(eq('mockFilter'), getExpectedFilter());
		then(this.registration).should().setAsyncSupported(true);
		then(this.registration).should().addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, '/*');
	}
	@Test
	void startupWithSpecifiedValues() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.setName('test');
		bean.setAsyncSupported(false);
		bean.setInitParameters(Collections.singletonMap('a', 'b'));
		bean.addInitParameter('c', 'd');
		bean.setUrlPatterns(new LinkedHashSet<>(Arrays.asList('/a', '/b')));
		bean.addUrlPatterns('/c');
		bean.setServletNames(new LinkedHashSet<>(Arrays.asList('s1', 's2')));
		bean.addServletNames('s3');
		bean.setServletRegistrationBeans(Collections.singleton(mockServletRegistration('s4')));
		bean.addServletRegistrationBeans(mockServletRegistration('s5'));
		bean.setMatchAfter(true);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addFilter(eq('test'), getExpectedFilter());
		then(this.registration).should().setAsyncSupported(false);
		Map<String, String> expectedInitParameters = new HashMap<>();
		expectedInitParameters.put('a', 'b');
		expectedInitParameters.put('c', 'd');
		then(this.registration).should().setInitParameters(expectedInitParameters);
		then(this.registration).should()
			.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), true, '/a', '/b', '/c');
		then(this.registration).should()
			.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), true, 's4', 's5', 's1', 's2', 's3');
	}
	@Test
	void specificName() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.setName('specificName');
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addFilter(eq('specificName'), getExpectedFilter());
	}
	@Test
	void deducedName() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.onStartup(this.servletContext);
		then(this.servletContext).should().addFilter(eq('mockFilter'), getExpectedFilter());
	}
	@Test
	void disable() throws Exception {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.setEnabled(false);
		bean.onStartup(this.servletContext);
		then(this.servletContext).should(never()).addFilter(eq('mockFilter'), getExpectedFilter());
	}
	@Test
	void setServletRegistrationBeanMustNotBeNull() {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		assertThatIllegalArgumentException().isThrownBy(() -> bean.setServletRegistrationBeans(null))
			.withMessageContaining('ServletRegistrationBeans must not be null');
	}
	@Test
	void addServletRegistrationBeanMustNotBeNull() {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> bean.addServletRegistrationBeans((ServletRegistrationBean[]) null))
			.withMessageContaining('ServletRegistrationBeans must not be null');
	}
	@Test
	void setServletRegistrationBeanReplacesValue() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean(mockServletRegistration('a'));
		bean.setServletRegistrationBeans(
				new LinkedHashSet<ServletRegistrationBean<?>>(Collections.singletonList(mockServletRegistration('b'))));
		bean.onStartup(this.servletContext);
		then(this.registration).should().addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), false, 'b');
	}
	@Test
	void modifyInitParameters() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.addInitParameter('a', 'b');
		bean.getInitParameters().put('a', 'c');
		bean.onStartup(this.servletContext);
		then(this.registration).should().setInitParameters(Collections.singletonMap('a', 'c'));
	}
	@Test
	void setUrlPatternMustNotBeNull() {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		assertThatIllegalArgumentException().isThrownBy(() -> bean.setUrlPatterns(null))
			.withMessageContaining('UrlPatterns must not be null');
	}
	@Test
	void addUrlPatternMustNotBeNull() {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		assertThatIllegalArgumentException().isThrownBy(() -> bean.addUrlPatterns((String[]) null))
			.withMessageContaining('UrlPatterns must not be null');
	}
	@Test
	void setServletNameMustNotBeNull() {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		assertThatIllegalArgumentException().isThrownBy(() -> bean.setServletNames(null))
			.withMessageContaining('ServletNames must not be null');
	}
	@Test
	void addServletNameMustNotBeNull() {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		assertThatIllegalArgumentException().isThrownBy(() -> bean.addServletNames((String[]) null))
			.withMessageContaining('ServletNames must not be null');
	}
	@Test
	void withSpecificDispatcherTypes() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.setDispatcherTypes(DispatcherType.INCLUDE, DispatcherType.FORWARD);
		bean.onStartup(this.servletContext);
		then(this.registration).should()
			.addMappingForUrlPatterns(EnumSet.of(DispatcherType.INCLUDE, DispatcherType.FORWARD), false, '/*');
	}
	@Test
	void withSpecificDispatcherTypesEnumSet() throws Exception {
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(this.registration);
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		EnumSet<DispatcherType> types = EnumSet.of(DispatcherType.INCLUDE, DispatcherType.FORWARD);
		bean.setDispatcherTypes(types);
		bean.onStartup(this.servletContext);
		then(this.registration).should().addMappingForUrlPatterns(types, false, '/*');
	}
	@Test
	void failsWithDoubleRegistration() {
		assertThatIllegalStateException().isThrownBy(this::doubleRegistration)
			.withMessage('Failed to register "filter double-registration" on the '
					+ 'servlet context. Possibly already registered?');
	}
	private void doubleRegistration() throws ServletException {
		AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
		bean.setName('double-registration');
		given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(null);
		bean.onStartup(this.servletContext);
	}
	@Test
	void doesntFailIfDoubleRegistrationIsIgnored() {
		assertThatCode(() -> {
			AbstractFilterRegistrationBean<?> bean = createFilterRegistrationBean();
			bean.setName('double-registration');
			given(this.servletContext.addFilter(anyString(), any(Filter.class))).willReturn(null);
			bean.setIgnoreRegistrationFailure(true);
			bean.onStartup(this.servletContext);
		}).doesNotThrowAnyException();
	}
	protected abstract Filter getExpectedFilter();
	protected abstract AbstractFilterRegistrationBean<?> createFilterRegistrationBean(
			ServletRegistrationBean<?>... servletRegistrationBeans);
	protected final ServletRegistrationBean<?> mockServletRegistration(String name) {
		ServletRegistrationBean<?> bean = new ServletRegistrationBean<>();
		bean.setName(name);
		return bean;
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class MockWebEnvironmentServletComponentScanIntegrationTests {
	private AnnotationConfigServletWebApplicationContext context;
	@TempDir
	File temp;
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	@ForkedClassPath
	void componentsAreRegistered() {
		prepareContext();
		this.context.refresh();
		Map<String, RegistrationBean> registrationBeans = this.context.getBeansOfType(RegistrationBean.class);
		assertThat(registrationBeans).hasSize(3);
		assertThat(registrationBeans.keySet()).containsExactlyInAnyOrder(TestServlet.class.getName(),
				TestFilter.class.getName(), TestMultipartServlet.class.getName());
		WebListenerRegistry registry = mock(WebListenerRegistry.class);
		this.context.getBean(WebListenerRegistrar.class).register(registry);
		then(registry).should().addWebListeners(TestListener.class.getName());
	}
	@Test
	@ForkedClassPath
	void indexedComponentsAreRegistered() throws IOException {
		writeIndex(this.temp);
		prepareContext();
		try (URLClassLoader classLoader = new URLClassLoader(new URL[] { this.temp.toURI().toURL() },
				getClass().getClassLoader())) {
			this.context.setClassLoader(classLoader);
			this.context.refresh();
			Map<String, RegistrationBean> registrationBeans = this.context.getBeansOfType(RegistrationBean.class);
			assertThat(registrationBeans).hasSize(2);
			assertThat(registrationBeans.keySet()).containsExactlyInAnyOrder(TestServlet.class.getName(),
					TestFilter.class.getName());
			WebListenerRegistry registry = mock(WebListenerRegistry.class);
			this.context.getBean(WebListenerRegistrar.class).register(registry);
			then(registry).should().addWebListeners(TestListener.class.getName());
		}
	}
	@Test
	@ForkedClassPath
	void multipartConfigIsHonoured() {
		prepareContext();
		this.context.refresh();
		@SuppressWarnings('rawtypes')
		Map<String, ServletRegistrationBean> beans = this.context.getBeansOfType(ServletRegistrationBean.class);
		ServletRegistrationBean<?> servletRegistrationBean = beans.get(TestMultipartServlet.class.getName());
		assertThat(servletRegistrationBean).isNotNull();
		MultipartConfigElement multipartConfig = servletRegistrationBean.getMultipartConfig();
		assertThat(multipartConfig).isNotNull();
		assertThat(multipartConfig.getLocation()).isEqualTo('test');
		assertThat(multipartConfig.getMaxRequestSize()).isEqualTo(2048);
		assertThat(multipartConfig.getMaxFileSize()).isEqualTo(1024);
		assertThat(multipartConfig.getFileSizeThreshold()).isEqualTo(512);
	}
	private void writeIndex(File temp) throws IOException {
		File metaInf = new File(temp, 'META-INF');
		metaInf.mkdirs();
		Properties index = new Properties();
		index.setProperty(TestFilter.class.getName(), WebFilter.class.getName());
		index.setProperty(TestListener.class.getName(), WebListener.class.getName());
		index.setProperty(TestServlet.class.getName(), WebServlet.class.getName());
		try (FileWriter writer = new FileWriter(new File(metaInf, 'spring.components'))) {
			index.store(writer, null);
		}
	}
	private void prepareContext() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(ScanningConfiguration.class);
		this.context.setServletContext(new MockServletContext());
	}
	@ServletComponentScan(basePackages = 'org.springframework.boot.web.servlet.testcomponents')
	static class ScanningConfiguration {
	}
}
/*
package org.springframework.boot.web.servlet;
/**
@ClassPathExclusions('spring-web-*.jar')
class NoSpringWebFilterRegistrationBeanTests extends AbstractFilterRegistrationBeanTests {
	private final MockFilter filter = new MockFilter();
	@Override
	protected AbstractFilterRegistrationBean<MockFilter> createFilterRegistrationBean(
			ServletRegistrationBean<?>... servletRegistrationBeans) {
		return new FilterRegistrationBean<>(this.filter, servletRegistrationBeans);
	}
	@Override
	protected Filter getExpectedFilter() {
		return eq(this.filter);
	}
}
/*
package org.springframework.boot.web.reactive.result.view;
/**
class MustacheViewResolverTests {
	private final String prefix = 'classpath:/' + getClass().getPackage().getName().replace('.', '/') + '/';
	private final MustacheViewResolver resolver = new MustacheViewResolver();
	@BeforeEach
	void init() {
		GenericApplicationContext applicationContext = new GenericApplicationContext();
		applicationContext.refresh();
		this.resolver.setApplicationContext(applicationContext);
		this.resolver.setPrefix(this.prefix);
		this.resolver.setSuffix('.html');
	}
	@Test
	void resolveNonExistent() {
		assertThat(this.resolver.resolveViewName('bar', null).block(Duration.ofSeconds(30))).isNull();
	}
	@Test
	void resolveExisting() {
		assertThat(this.resolver.resolveViewName('template', null).block(Duration.ofSeconds(30))).isNotNull();
	}
}
/*
package org.springframework.boot.web.reactive.result.view;
/**
class MustacheViewTests {
	private final String templateUrl = 'classpath:/' + getClass().getPackage().getName().replace('.', '/')
			+ '/template.html';
	private final StaticApplicationContext context = new StaticApplicationContext();
	@Test
	void viewResolvesHandlebars() {
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get('/test').build());
		MustacheView view = new MustacheView();
		view.setCompiler(Mustache.compiler());
		view.setUrl(this.templateUrl);
		view.setCharset(StandardCharsets.UTF_8.displayName());
		view.setApplicationContext(this.context);
		view.render(Collections.singletonMap('World', 'Spring'), MediaType.TEXT_HTML, exchange)
			.block(Duration.ofSeconds(30));
		StepVerifier.create(exchange.getResponse().getBodyAsString())
			.assertNext((body) -> assertThat(body).isEqualToIgnoringWhitespace('Hello Spring'))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
class ReactiveWebServerApplicationContextTests {
	private final ReactiveWebServerApplicationContext context = new ReactiveWebServerApplicationContext();
	@AfterEach
	void cleanUp() {
		this.context.close();
	}
	@Test
	void whenThereIsNoWebServerFactoryBeanThenContextRefreshWillFail() {
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.withMessageContaining(
					'Unable to start ReactiveWebServerApplicationContext due to missing ReactiveWebServerFactory bean');
	}
	@Test
	void whenThereIsNoHttpHandlerBeanThenContextRefreshWillFail() {
		addWebServerFactoryBean();
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.withMessageContaining('Unable to start ReactiveWebApplicationContext due to missing HttpHandler bean');
	}
	@Test
	void whenThereAreMultipleWebServerFactoryBeansThenContextRefreshWillFail() {
		addWebServerFactoryBean();
		addWebServerFactoryBean('anotherWebServerFactory');
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.withMessageContaining(
					'Unable to start ReactiveWebApplicationContext due to multiple ReactiveWebServerFactory beans');
	}
	@Test
	void whenThereAreMultipleHttpHandlerBeansThenContextRefreshWillFail() {
		addWebServerFactoryBean();
		addHttpHandlerBean('httpHandler1');
		addHttpHandlerBean('httpHandler2');
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.withMessageContaining('Unable to start ReactiveWebApplicationContext due to multiple HttpHandler beans');
	}
	@Test
	void whenContextIsRefreshedThenReactiveWebServerInitializedEventIsPublished() {
		addWebServerFactoryBean();
		addHttpHandlerBean();
		TestApplicationListener listener = new TestApplicationListener();
		this.context.addApplicationListener(listener);
		this.context.refresh();
		List<ApplicationEvent> events = listener.receivedEvents();
		assertThat(events).hasSize(2)
			.extracting('class')
			.containsExactly(ReactiveWebServerInitializedEvent.class, ContextRefreshedEvent.class);
		ReactiveWebServerInitializedEvent initializedEvent = (ReactiveWebServerInitializedEvent) events.get(0);
		assertThat(initializedEvent.getSource().getPort()).isGreaterThanOrEqualTo(0);
		assertThat(initializedEvent.getApplicationContext()).isEqualTo(this.context);
	}
	@Test
	void whenContextIsRefreshedThenLocalServerPortIsAvailableFromTheEnvironment() {
		addWebServerFactoryBean();
		addHttpHandlerBean();
		new ServerPortInfoApplicationContextInitializer().initialize(this.context);
		this.context.refresh();
		ConfigurableEnvironment environment = this.context.getEnvironment();
		assertThat(environment.containsProperty('local.server.port')).isTrue();
		assertThat(environment.getProperty('local.server.port')).isEqualTo('8080');
	}
	@Test
	void whenContextIsClosedThenWebServerIsStopped() {
		addWebServerFactoryBean();
		addHttpHandlerBean();
		this.context.refresh();
		MockReactiveWebServerFactory factory = this.context.getBean(MockReactiveWebServerFactory.class);
		this.context.close();
		then(factory.getWebServer()).should().stop();
	}
	@Test
	@SuppressWarnings('unchecked')
	void whenContextIsClosedThenApplicationAvailabilityChangesToRefusingTraffic() {
		addWebServerFactoryBean();
		addHttpHandlerBean();
		TestApplicationListener listener = new TestApplicationListener();
		this.context.refresh();
		this.context.addApplicationListener(listener);
		this.context.close();
		List<ApplicationEvent> events = listener.receivedEvents();
		assertThat(events).hasSize(2)
			.extracting('class')
			.contains(AvailabilityChangeEvent.class, ContextClosedEvent.class);
		assertThat(((AvailabilityChangeEvent<ReadinessState>) events.get(0)).getState())
			.isEqualTo(ReadinessState.REFUSING_TRAFFIC);
	}
	@Test
	void whenContextIsNotActiveThenCloseDoesNotChangeTheApplicationAvailability() {
		addWebServerFactoryBean();
		addHttpHandlerBean();
		TestApplicationListener listener = new TestApplicationListener();
		this.context.addApplicationListener(listener);
		this.context.registerBeanDefinition('refreshFailure', new RootBeanDefinition(RefreshFailure.class));
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(this.context::refresh);
		this.context.close();
		assertThat(listener.receivedEvents()).isEmpty();
	}
	@Test
	void whenTheContextIsRefreshedThenASubsequentRefreshAttemptWillFail() {
		addWebServerFactoryBean();
		addHttpHandlerBean();
		this.context.refresh();
		assertThatIllegalStateException().isThrownBy(this.context::refresh)
			.withMessageContaining('multiple refresh attempts');
	}
	private void addHttpHandlerBean() {
		addHttpHandlerBean('httpHandler');
	}
	private void addHttpHandlerBean(String beanName) {
		this.context.registerBeanDefinition(beanName,
				new RootBeanDefinition(HttpHandler.class, () -> (request, response) -> null));
	}
	private void addWebServerFactoryBean() {
		addWebServerFactoryBean('webServerFactory');
	}
	private void addWebServerFactoryBean(String beanName) {
		this.context.registerBeanDefinition(beanName, new RootBeanDefinition(MockReactiveWebServerFactory.class));
	}
	static class TestApplicationListener implements ApplicationListener<ApplicationEvent> {
		private final Deque<ApplicationEvent> events = new ArrayDeque<>();
		@Override
		public void onApplicationEvent(ApplicationEvent event) {
			this.events.add(event);
		}
		List<ApplicationEvent> receivedEvents() {
			List<ApplicationEvent> receivedEvents = new ArrayList<>();
			while (!this.events.isEmpty()) {
				receivedEvents.add(this.events.pollFirst());
			}
			return receivedEvents;
		}
	}
	static class RefreshFailure {
		RefreshFailure() {
			throw new RuntimeException('Fail refresh');
		}
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
class ApplicationReactiveWebEnvironmentTests extends AbstractApplicationEnvironmentTests {
	@Override
	protected StandardEnvironment createEnvironment() {
		return new ApplicationReactiveWebEnvironment();
	}
}
/*
package org.springframework.boot.web.reactive.context.config;
/**
@Configuration(proxyBeanMethods = false)
public class ExampleReactiveWebServerApplicationConfiguration {
	@Bean
	public MockReactiveWebServerFactory webServerFactory() {
		return new MockReactiveWebServerFactory();
	}
	@Bean
	public HttpHandler httpHandler() {
		return mock(HttpHandler.class);
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
class GenericReactiveWebApplicationContextTests {
	@Test
	void getResourceByPath() throws Exception {
		GenericReactiveWebApplicationContext context = new GenericReactiveWebApplicationContext();
		Resource rootResource = context.getResourceByPath('/');
		assertThat(rootResource.exists()).isFalse();
		assertThat(rootResource.createRelative('application.properties').exists()).isFalse();
		context.close();
	}
}
/*
package org.springframework.boot.web.reactive.context;
/**
class AnnotationConfigReactiveWebServerApplicationContextTests {
	private AnnotationConfigReactiveWebServerApplicationContext context;
	@Test
	void createFromScan() {
		this.context = new AnnotationConfigReactiveWebServerApplicationContext(
				ExampleReactiveWebServerApplicationConfiguration.class.getPackage().getName());
		verifyContext();
	}
	@Test
	void createFromConfigClass() {
		this.context = new AnnotationConfigReactiveWebServerApplicationContext(
				ExampleReactiveWebServerApplicationConfiguration.class);
		verifyContext();
	}
	@Test
	void registerAndRefresh() {
		this.context = new AnnotationConfigReactiveWebServerApplicationContext();
		this.context.register(ExampleReactiveWebServerApplicationConfiguration.class);
		this.context.refresh();
		verifyContext();
	}
	@Test
	void multipleRegistersAndRefresh() {
		this.context = new AnnotationConfigReactiveWebServerApplicationContext();
		this.context.register(WebServerConfiguration.class);
		this.context.register(HttpHandlerConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeansOfType(WebServerConfiguration.class)).hasSize(1);
		assertThat(this.context.getBeansOfType(HttpHandlerConfiguration.class)).hasSize(1);
	}
	@Test
	void scanAndRefresh() {
		this.context = new AnnotationConfigReactiveWebServerApplicationContext();
		this.context.scan(ExampleReactiveWebServerApplicationConfiguration.class.getPackage().getName());
		this.context.refresh();
		verifyContext();
	}
	@Test
	void httpHandlerInitialization() {
		// gh-14666
		this.context = new AnnotationConfigReactiveWebServerApplicationContext(InitializationTestConfig.class);
		verifyContext();
	}
	private void verifyContext() {
		MockReactiveWebServerFactory factory = this.context.getBean(MockReactiveWebServerFactory.class);
		HttpHandler expectedHandler = this.context.getBean(HttpHandler.class);
		HttpHandler actualHandler = factory.getWebServer().getHttpHandler();
		if (actualHandler instanceof DelayedInitializationHttpHandler delayedHandler) {
			actualHandler = delayedHandler.getHandler();
		}
		assertThat(actualHandler).isEqualTo(expectedHandler);
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerConfiguration {
		@Bean
		ReactiveWebServerFactory webServerFactory() {
			return new MockReactiveWebServerFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HttpHandlerConfiguration {
		@Bean
		HttpHandler httpHandler() {
			return mock(HttpHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class InitializationTestConfig {
		private static boolean addedListener;
		@Bean
		ReactiveWebServerFactory webServerFactory() {
			return new MockReactiveWebServerFactory();
		}
		@Bean
		HttpHandler httpHandler() {
			if (!addedListener) {
				throw new RuntimeException(
						'Handlers should be added after listeners, we"re being initialized too early!');
			}
			return mock(HttpHandler.class);
		}
		@Bean
		Listener listener() {
			return new Listener();
		}
		@Bean
		ApplicationEventMulticaster applicationEventMulticaster() {
			return new SimpleApplicationEventMulticaster() {
				@Override
				public void addApplicationListenerBean(String listenerBeanName) {
					super.addApplicationListenerBean(listenerBeanName);
					if ('listener'.equals(listenerBeanName)) {
						addedListener = true;
					}
				}
			};
		}
		static class Listener implements ApplicationListener<ContextRefreshedEvent> {
			@Override
			public void onApplicationEvent(ContextRefreshedEvent event) {
			}
		}
	}
}
/*
package org.springframework.boot.web.reactive.server;
/**
public abstract class AbstractReactiveWebServerFactoryTests {
	protected WebServer webServer;
	@AfterEach
	void tearDown() {
		if (this.webServer != null) {
			try {
				this.webServer.stop();
				try {
					this.webServer.destroy();
				}
				catch (Exception ex) {
					// Ignore
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
	}
	protected abstract AbstractReactiveWebServerFactory getFactory();
	@Test
	void specificPort() throws Exception {
		AbstractReactiveWebServerFactory factory = getFactory();
		int specificPort = doWithRetry(() -> {
			factory.setPort(0);
			this.webServer = factory.getWebServer(new EchoHandler());
			this.webServer.start();
			return this.webServer.getPort();
		});
		Mono<String> result = getWebClient(this.webServer.getPort()).build()
			.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo('Hello World');
		assertThat(this.webServer.getPort()).isEqualTo(specificPort);
	}
	@Test
	protected void restartAfterStop() throws Exception {
		AbstractReactiveWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		int port = this.webServer.getPort();
		assertThat(getResponse(port, '/test')).isEqualTo('Hello World');
		this.webServer.stop();
		assertThatException().isThrownBy(() -> getResponse(port, '/test'));
		this.webServer.start();
		assertThat(getResponse(this.webServer.getPort(), '/test')).isEqualTo('Hello World');
	}
	private String getResponse(int port, String uri) {
		WebClient webClient = getWebClient(port).build();
		Mono<String> result = webClient.post()
			.uri(uri)
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		return result.block(Duration.ofSeconds(30));
	}
	@Test
	void portIsMinusOneWhenConnectionIsClosed() {
		AbstractReactiveWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		assertThat(this.webServer.getPort()).isGreaterThan(0);
		this.webServer.destroy();
		assertThat(this.webServer.getPort()).isEqualTo(-1);
	}
	@Test
	void basicSslFromClassPath() {
		testBasicSslWithKeyStore('classpath:test.jks', 'password');
	}
	@Test
	void basicSslFromFileSystem() {
		testBasicSslWithKeyStore('src/test/resources/test.jks', 'password');
	}
	protected final void testBasicSslWithKeyStore(String keyStore, String keyPassword) {
		AbstractReactiveWebServerFactory factory = getFactory();
		Ssl ssl = new Ssl();
		ssl.setKeyStore(keyStore);
		ssl.setKeyPassword(keyPassword);
		ssl.setKeyStorePassword('secret');
		factory.setSsl(ssl);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		ReactorClientHttpConnector connector = buildTrustAllSslConnector();
		WebClient client = WebClient.builder()
			.baseUrl('https://localhost:' + this.webServer.getPort())
			.clientConnector(connector)
			.build();
		Mono<String> result = client.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo('Hello World');
	}
	@Test
	void sslWithValidAlias() {
		String keyStore = 'classpath:test.jks';
		String keyPassword = 'password';
		AbstractReactiveWebServerFactory factory = getFactory();
		Ssl ssl = new Ssl();
		ssl.setKeyStore(keyStore);
		ssl.setKeyStorePassword('secret');
		ssl.setKeyPassword(keyPassword);
		ssl.setKeyAlias('test-alias');
		factory.setSsl(ssl);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		ReactorClientHttpConnector connector = buildTrustAllSslConnector();
		WebClient client = WebClient.builder()
			.baseUrl('https://localhost:' + this.webServer.getPort())
			.clientConnector(connector)
			.build();
		Mono<String> result = client.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		StepVerifier.create(result).expectNext('Hello World').expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void sslWithInvalidAliasFailsDuringStartup() {
		String keyStore = 'classpath:test.jks';
		String keyPassword = 'password';
		AbstractReactiveWebServerFactory factory = getFactory();
		Ssl ssl = new Ssl();
		ssl.setKeyStore(keyStore);
		ssl.setKeyPassword(keyPassword);
		ssl.setKeyAlias('test-alias-404');
		factory.setSsl(ssl);
		assertThatSslWithInvalidAliasCallFails(() -> factory.getWebServer(new EchoHandler()).start());
	}
	protected void assertThatSslWithInvalidAliasCallFails(ThrowingCallable call) {
		assertThatException().isThrownBy(call)
			.withStackTraceContaining('Keystore does not contain alias "test-alias-404"');
	}
	protected ReactorClientHttpConnector buildTrustAllSslConnector() {
		GenericSslContextSpec<?> sslContextSpec = Http11SslContextSpec.forClient()
			.configure((builder) -> builder.sslProvider(SslProvider.JDK)
				.trustManager(InsecureTrustManagerFactory.INSTANCE));
		HttpClient client = HttpClient.create().wiretap(true).secure((spec) -> spec.sslContext(sslContextSpec));
		return new ReactorClientHttpConnector(client);
	}
	@Test
	void sslWantsClientAuthenticationSucceedsWithClientCertificate() throws Exception {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(Ssl.ClientAuth.WANT);
		ssl.setKeyStore('classpath:test.jks');
		ssl.setKeyPassword('password');
		ssl.setKeyStorePassword('secret');
		ssl.setTrustStore('classpath:test.jks');
		testClientAuthSuccess(ssl, buildTrustAllSslWithClientKeyConnector('test.jks', 'password'));
	}
	@Test
	void sslWantsClientAuthenticationSucceedsWithoutClientCertificate() {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(Ssl.ClientAuth.WANT);
		ssl.setKeyStore('classpath:test.jks');
		ssl.setKeyPassword('password');
		ssl.setTrustStore('classpath:test.jks');
		ssl.setKeyStorePassword('secret');
		testClientAuthSuccess(ssl, buildTrustAllSslConnector());
	}
	protected ReactorClientHttpConnector buildTrustAllSslWithClientKeyConnector(String keyStoreFile,
			String keyStorePassword) throws Exception {
		KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
		try (InputStream stream = new FileInputStream('src/test/resources/' + keyStoreFile)) {
			clientKeyStore.load(stream, 'secret'.toCharArray());
		}
		KeyManagerFactory clientKeyManagerFactory = KeyManagerFactory
			.getInstance(KeyManagerFactory.getDefaultAlgorithm());
		clientKeyManagerFactory.init(clientKeyStore, keyStorePassword.toCharArray());
		GenericSslContextSpec<?> sslContextSpec = Http11SslContextSpec.forClient()
			.configure((builder) -> builder.sslProvider(SslProvider.JDK)
				.trustManager(InsecureTrustManagerFactory.INSTANCE)
				.keyManager(clientKeyManagerFactory));
		HttpClient client = HttpClient.create().wiretap(true).secure((spec) -> spec.sslContext(sslContextSpec));
		return new ReactorClientHttpConnector(client);
	}
	protected void testClientAuthSuccess(Ssl sslConfiguration, ReactorClientHttpConnector clientConnector) {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setSsl(sslConfiguration);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		WebClient client = WebClient.builder()
			.baseUrl('https://localhost:' + this.webServer.getPort())
			.clientConnector(clientConnector)
			.build();
		Mono<String> result = client.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo('Hello World');
	}
	@Test
	void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(Ssl.ClientAuth.NEED);
		ssl.setKeyStore('classpath:test.jks');
		ssl.setKeyStorePassword('secret');
		ssl.setKeyPassword('password');
		ssl.setTrustStore('classpath:test.jks');
		testClientAuthSuccess(ssl, buildTrustAllSslWithClientKeyConnector('test.jks', 'password'));
	}
	@Test
	void sslNeedsClientAuthenticationFailsWithoutClientCertificate() {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(Ssl.ClientAuth.NEED);
		ssl.setKeyStore('classpath:test.jks');
		ssl.setKeyStorePassword('secret');
		ssl.setKeyPassword('password');
		ssl.setTrustStore('classpath:test.jks');
		testClientAuthFailure(ssl, buildTrustAllSslConnector());
	}
	@Test
	void sslWithPemCertificates() throws Exception {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(Ssl.ClientAuth.NEED);
		ssl.setCertificate('classpath:test-cert.pem');
		ssl.setCertificatePrivateKey('classpath:test-key.pem');
		ssl.setTrustCertificate('classpath:test-cert.pem');
		testClientAuthSuccess(ssl, buildTrustAllSslWithClientKeyConnector('test.p12', 'secret'));
	}
	protected void testClientAuthFailure(Ssl sslConfiguration, ReactorClientHttpConnector clientConnector) {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setSsl(sslConfiguration);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		WebClient client = WebClient.builder()
			.baseUrl('https://localhost:' + this.webServer.getPort())
			.clientConnector(clientConnector)
			.build();
		Mono<String> result = client.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		StepVerifier.create(result).expectError(WebClientRequestException.class).verify(Duration.ofSeconds(10));
	}
	protected WebClient.Builder getWebClient(int port) {
		return getWebClient(HttpClient.create().wiretap(true), port);
	}
	protected WebClient.Builder getWebClient(HttpClient client, int port) {
		InetSocketAddress address = new InetSocketAddress(port);
		String baseUrl = 'http://' + address.getHostString() + ':' + address.getPort();
		return WebClient.builder().clientConnector(new ReactorClientHttpConnector(client)).baseUrl(baseUrl);
	}
	@Test
	protected void compressionOfResponseToGetRequest() {
		WebClient client = prepareCompressionTest();
		ResponseEntity<Void> response = client.get().retrieve().toBodilessEntity().block(Duration.ofSeconds(30));
		assertResponseIsCompressed(response);
	}
	@Test
	protected void compressionOfResponseToPostRequest() {
		WebClient client = prepareCompressionTest();
		ResponseEntity<Void> response = client.post().retrieve().toBodilessEntity().block(Duration.ofSeconds(30));
		assertResponseIsCompressed(response);
	}
	@Test
	void noCompressionForSmallResponse() {
		Compression compression = new Compression();
		compression.setEnabled(true);
		compression.setMinResponseSize(DataSize.ofBytes(3001));
		WebClient client = prepareCompressionTest(compression);
		ResponseEntity<Void> response = client.get().retrieve().toBodilessEntity().block(Duration.ofSeconds(30));
		assertResponseIsNotCompressed(response);
	}
	@Test
	void noCompressionForMimeType() {
		Compression compression = new Compression();
		compression.setEnabled(true);
		compression.setMimeTypes(new String[] { 'application/json' });
		WebClient client = prepareCompressionTest(compression);
		ResponseEntity<Void> response = client.get().retrieve().toBodilessEntity().block(Duration.ofSeconds(30));
		assertResponseIsNotCompressed(response);
	}
	@Test
	protected void noCompressionForUserAgent() {
		Compression compression = new Compression();
		compression.setEnabled(true);
		compression.setExcludedUserAgents(new String[] { 'testUserAgent' });
		WebClient client = prepareCompressionTest(compression);
		ResponseEntity<Void> response = client.get()
			.header('User-Agent', 'testUserAgent')
			.retrieve()
			.toBodilessEntity()
			.block(Duration.ofSeconds(30));
		assertResponseIsNotCompressed(response);
	}
	@Test
	void noCompressionForResponseWithInvalidContentType() {
		Compression compression = new Compression();
		compression.setEnabled(true);
		compression.setMimeTypes(new String[] { 'application/json' });
		WebClient client = prepareCompressionTest(compression, 'test~plain');
		ResponseEntity<Void> response = client.get().retrieve().toBodilessEntity().block(Duration.ofSeconds(30));
		assertResponseIsNotCompressed(response);
	}
	@Test
	void whenSslIsEnabledAndNoKeyStoreIsConfiguredThenServerFailsToStart() {
		assertThatIllegalStateException().isThrownBy(() -> testBasicSslWithKeyStore(null, null))
			.withMessageContaining('SSL is enabled but no trust material is configured');
	}
	@Test
	void whenThereAreNoInFlightRequestsShutDownGracefullyReturnsTrueBeforePeriodElapses() throws Exception {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> GracefulShutdownResult.IDLE == result.get());
	}
	@Test
	void whenARequestRemainsInFlightThenShutDownGracefullyDoesNotInvokeCallbackUntilTheRequestCompletes()
			throws Exception {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		Mono<ResponseEntity<Void>> request = getWebClient(this.webServer.getPort()).build()
			.get()
			.retrieve()
			.toBodilessEntity();
		AtomicReference<ResponseEntity<Void>> responseReference = new AtomicReference<>();
		CountDownLatch responseLatch = new CountDownLatch(1);
		request.subscribe((response) -> {
			responseReference.set(response);
			responseLatch.countDown();
		});
		blockingHandler.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		assertThat(responseReference.get()).isNull();
		blockingHandler.completeOne();
		assertThat(responseLatch.await(5, TimeUnit.SECONDS)).isTrue();
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> GracefulShutdownResult.IDLE == result.get());
	}
	@Test
	void givenAnInflightRequestWhenTheServerIsStoppedThenGracefulShutdownCallbackIsCalledWithRequestsActive()
			throws Exception {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		Mono<ResponseEntity<Void>> request = getWebClient(this.webServer.getPort()).build()
			.get()
			.retrieve()
			.toBodilessEntity();
		AtomicReference<ResponseEntity<Void>> responseReference = new AtomicReference<>();
		CountDownLatch responseLatch = new CountDownLatch(1);
		request.subscribe((response) -> {
			responseReference.set(response);
			responseLatch.countDown();
		});
		blockingHandler.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		assertThat(responseReference.get()).isNull();
		try {
			this.webServer.stop();
		}
		catch (Exception ex) {
			// Continue
		}
		System.out.println('Stopped');
		Awaitility.await()
			.atMost(Duration.ofSeconds(5))
			.until(() -> GracefulShutdownResult.REQUESTS_ACTIVE == result.get());
		blockingHandler.completeOne();
	}
	@Test
	void whenARequestIsActiveAfterGracefulShutdownEndsThenStopWillComplete() throws InterruptedException {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		Mono<ResponseEntity<Void>> request = getWebClient(this.webServer.getPort()).build()
			.get()
			.retrieve()
			.toBodilessEntity();
		AtomicReference<ResponseEntity<Void>> responseReference = new AtomicReference<>();
		CountDownLatch responseLatch = new CountDownLatch(1);
		request.subscribe((response) -> {
			responseReference.set(response);
			responseLatch.countDown();
		});
		blockingHandler.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		this.webServer.stop();
		Awaitility.await()
			.atMost(Duration.ofSeconds(30))
			.until(() -> GracefulShutdownResult.REQUESTS_ACTIVE == result.get());
		blockingHandler.completeOne();
	}
	@Test
	void whenARequestIsActiveThenStopWillComplete() throws InterruptedException {
		AbstractReactiveWebServerFactory factory = getFactory();
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		Mono<ResponseEntity<Void>> request = getWebClient(this.webServer.getPort()).build()
			.get()
			.retrieve()
			.toBodilessEntity();
		AtomicReference<ResponseEntity<Void>> responseReference = new AtomicReference<>();
		CountDownLatch responseLatch = new CountDownLatch(1);
		request.subscribe((response) -> {
			responseReference.set(response);
			responseLatch.countDown();
		});
		blockingHandler.awaitQueue();
		try {
			this.webServer.stop();
		}
		catch (Exception ex) {
			// Continue
		}
		blockingHandler.completeOne();
	}
	@Test
	protected void whenHttp2IsEnabledAndSslIsDisabledThenH2cCanBeUsed() throws Exception {
		AbstractReactiveWebServerFactory factory = getFactory();
		Http2 http2 = new Http2();
		http2.setEnabled(true);
		factory.setHttp2(http2);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		org.eclipse.jetty.client.HttpClient client = new org.eclipse.jetty.client.HttpClient(
				new HttpClientTransportOverHTTP2(new HTTP2Client()));
		client.start();
		try {
			ContentResponse response = client.POST('http://localhost:' + this.webServer.getPort())
				.body(new StringRequestContent('text/plain', 'Hello World'))
				.send();
			assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value());
			assertThat(response.getContentAsString()).isEqualTo('Hello World');
		}
		finally {
			client.stop();
		}
	}
	@Test
	protected void whenHttp2IsEnabledAndSslIsDisabledThenHttp11CanStillBeUsed() {
		AbstractReactiveWebServerFactory factory = getFactory();
		Http2 http2 = new Http2();
		http2.setEnabled(true);
		factory.setHttp2(http2);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		Mono<String> result = getWebClient(this.webServer.getPort()).build()
			.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo('Hello World');
	}
	@Test
	void startedLogMessageWithSinglePort() {
		AbstractReactiveWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		assertThat(startedLogMessage()).matches(
				'(Jetty|Netty|Tomcat|Undertow) started on port ' + this.webServer.getPort() + ' \\(http(/1.1)?\\)');
	}
	@Test
	protected void startedLogMessageWithMultiplePorts() {
		AbstractReactiveWebServerFactory factory = getFactory();
		addConnector(0, factory);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		assertThat(startedLogMessage()).matches('(Jetty|Tomcat|Undertow) started on ports ' + this.webServer.getPort()
				+ ' \\(http(/1.1)?\\), [0-9]+ \\(http(/1.1)?\\)');
	}
	protected WebClient prepareCompressionTest() {
		Compression compression = new Compression();
		compression.setEnabled(true);
		return prepareCompressionTest(compression);
	}
	protected WebClient prepareCompressionTest(Compression compression) {
		return prepareCompressionTest(compression, MediaType.TEXT_PLAIN_VALUE);
	}
	protected WebClient prepareCompressionTest(Compression compression, String responseContentType) {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setCompression(compression);
		this.webServer = factory.getWebServer(new CharsHandler(3000, responseContentType));
		this.webServer.start();
		HttpClient client = HttpClient.create()
			.wiretap(true)
			.compress(true)
			.doOnConnected((connection) -> connection.channel()
				.pipeline()
				.addBefore(NettyPipeline.HttpDecompressor, 'CompressionTest', new CompressionDetectionHandler()));
		return getWebClient(client, this.webServer.getPort()).build();
	}
	protected void assertResponseIsCompressed(ResponseEntity<Void> response) {
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(response.getHeaders().getFirst('X-Test-Compressed')).isEqualTo('true');
	}
	protected void assertResponseIsNotCompressed(ResponseEntity<Void> response) {
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(response.getHeaders().keySet()).doesNotContain('X-Test-Compressed');
	}
	protected void assertForwardHeaderIsUsed(AbstractReactiveWebServerFactory factory) {
		this.webServer = factory.getWebServer(new XForwardedHandler());
		this.webServer.start();
		String body = getWebClient(this.webServer.getPort()).build()
			.get()
			.header('X-Forwarded-Proto', 'https')
			.retrieve()
			.bodyToMono(String.class)
			.block(Duration.ofSeconds(30));
		assertThat(body).isEqualTo('https');
	}
	private <T> T doWithRetry(Callable<T> action) throws Exception {
		Exception lastFailure = null;
		for (int i = 0; i < 10; i++) {
			try {
				return action.call();
			}
			catch (Exception ex) {
				lastFailure = ex;
			}
		}
		throw new IllegalStateException('Action was not successful in 10 attempts', lastFailure);
	}
	protected final void doWithBlockedPort(BlockedPortAction action) throws Exception {
		ServerSocket serverSocket = new ServerSocket();
		try (serverSocket) {
			int blockedPort = doWithRetry(() -> {
				serverSocket.bind(null);
				return serverSocket.getLocalPort();
			});
			action.run(blockedPort);
		}
	}
	protected abstract String startedLogMessage();
	protected abstract void addConnector(int port, AbstractReactiveWebServerFactory factory);
	public interface BlockedPortAction {
		void run(int port);
	}
	protected static class EchoHandler implements HttpHandler {
		public EchoHandler() {
		}
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			response.setStatusCode(HttpStatus.OK);
			return response.writeWith(request.getBody());
		}
	}
	protected static class BlockingHandler implements HttpHandler {
		private final BlockingQueue<Sinks.Empty<Void>> processors = new ArrayBlockingQueue<>(10);
		private volatile boolean blocking = true;
		public BlockingHandler() {
		}
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			if (this.blocking) {
				Sinks.Empty<Void> completion = Sinks.empty();
				this.processors.add(completion);
				return completion.asMono().then(Mono.empty());
			}
			return Mono.empty();
		}
		public void completeOne() {
			try {
				Sinks.Empty<Void> processor = this.processors.take();
				processor.tryEmitEmpty();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
		public void awaitQueue() throws InterruptedException {
			while (this.processors.isEmpty()) {
				Thread.sleep(100);
			}
		}
		public void stopBlocking() {
			this.blocking = false;
			this.processors.forEach(Sinks.Empty::tryEmitEmpty);
		}
	}
	static class CompressionDetectionHandler extends ChannelInboundHandlerAdapter {
		@Override
		public void channelRead(ChannelHandlerContext ctx, Object msg) {
			if (msg instanceof HttpResponse response) {
				boolean compressed = response.headers().contains(HttpHeaderNames.CONTENT_ENCODING, 'gzip', true);
				if (compressed) {
					response.headers().set('X-Test-Compressed', 'true');
				}
			}
			ctx.fireChannelRead(msg);
		}
	}
	static class CharsHandler implements HttpHandler {
		private static final DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
		private final DataBuffer bytes;
		private final String mediaType;
		CharsHandler(int contentSize, String mediaType) {
			char[] chars = new char[contentSize];
			Arrays.fill(chars, "F");
			this.bytes = factory.wrap(new String(chars).getBytes(StandardCharsets.UTF_8));
			this.mediaType = mediaType;
		}
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			response.setStatusCode(HttpStatus.OK);
			response.getHeaders().set(HttpHeaders.CONTENT_TYPE, this.mediaType);
			response.getHeaders().setContentLength(this.bytes.readableByteCount());
			return response.writeWith(Mono.just(this.bytes));
		}
	}
	static class XForwardedHandler implements HttpHandler {
		@Override
		public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
			String scheme = request.getURI().getScheme();
			DataBufferFactory bufferFactory = new DefaultDataBufferFactory();
			DataBuffer buffer = bufferFactory.wrap(scheme.getBytes(StandardCharsets.UTF_8));
			return response.writeWith(Mono.just(buffer));
		}
	}
}
/*
package org.springframework.boot.web.reactive.server;
/**
public class MockReactiveWebServerFactory extends AbstractReactiveWebServerFactory {
	private MockReactiveWebServer webServer;
	@Override
	public WebServer getWebServer(HttpHandler httpHandler) {
		this.webServer = spy(new MockReactiveWebServer(httpHandler, getPort()));
		return this.webServer;
	}
	public MockReactiveWebServer getWebServer() {
		return this.webServer;
	}
	public static class MockReactiveWebServer implements WebServer {
		private final int port;
		private HttpHandler httpHandler;
		private Map<String, HttpHandler> httpHandlerMap;
		MockReactiveWebServer(HttpHandler httpHandler, int port) {
			this.httpHandler = httpHandler;
			this.port = port;
		}
		MockReactiveWebServer(Map<String, HttpHandler> httpHandlerMap, int port) {
			this.httpHandlerMap = httpHandlerMap;
			this.port = port;
		}
		public HttpHandler getHttpHandler() {
			return this.httpHandler;
		}
		public Map<String, HttpHandler> getHttpHandlerMap() {
			return this.httpHandlerMap;
		}
		@Override
		public void start() {
		}
		@Override
		public void stop() {
		}
		@Override
		public int getPort() {
			return this.port;
		}
	}
}
/*
package org.springframework.boot.web.reactive.error;
/**
class DefaultErrorAttributesTests {
	private static final ResponseStatusException NOT_FOUND = new ResponseStatusException(HttpStatus.NOT_FOUND);
	private DefaultErrorAttributes errorAttributes = new DefaultErrorAttributes();
	private final List<HttpMessageReader<?>> readers = ServerCodecConfigurer.create().getReaders();
	@Test
	void missingExceptionAttribute() {
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get('/test').build());
		ServerRequest request = ServerRequest.create(exchange, this.readers);
		assertThatIllegalStateException()
			.isThrownBy(() -> this.errorAttributes.getErrorAttributes(request, ErrorAttributeOptions.defaults()))
			.withMessageContaining('Missing exception attribute in ServerWebExchange');
	}
	@Test
	void includeTimeStamp() {
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND),
				ErrorAttributeOptions.defaults());
		assertThat(attributes.get('timestamp')).isInstanceOf(Date.class);
	}
	@Test
	void defaultStatusCode() {
		Error error = new OutOfMemoryError('Test error');
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error),
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('error', HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase());
		assertThat(attributes).containsEntry('status', 500);
	}
	@Test
	void annotatedResponseStatusCode() {
		Exception error = new CustomException();
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error),
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('error', HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());
		assertThat(attributes).doesNotContainKey('message');
		assertThat(attributes).containsEntry('status', HttpStatus.I_AM_A_TEAPOT.value());
	}
	@Test
	void annotatedResponseStatusCodeWithExceptionMessage() {
		Exception error = new CustomException('Test Message');
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error),
				ErrorAttributeOptions.of(Include.MESSAGE, Include.STATUS, Include.ERROR));
		assertThat(attributes).containsEntry('error', HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());
		assertThat(attributes).containsEntry('message', 'Test Message');
		assertThat(attributes).containsEntry('status', HttpStatus.I_AM_A_TEAPOT.value());
	}
	@Test
	void annotatedResponseStatusCodeWithCustomReasonPhrase() {
		Exception error = new Custom2Exception();
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error),
				ErrorAttributeOptions.of(Include.MESSAGE, Include.STATUS, Include.ERROR));
		assertThat(attributes).containsEntry('error', HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());
		assertThat(attributes).containsEntry('status', HttpStatus.I_AM_A_TEAPOT.value());
		assertThat(attributes).containsEntry('message', 'Nope!');
	}
	@Test
	void includeStatusCode() {
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND),
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('error', HttpStatus.NOT_FOUND.getReasonPhrase());
		assertThat(attributes).containsEntry('status', 404);
	}
	@Test
	void getError() {
		Error error = new OutOfMemoryError('Test error');
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.of(Include.MESSAGE));
		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error);
		assertThat(attributes).doesNotContainKey('exception');
		assertThat(attributes).containsEntry('message', 'Test error');
	}
	@Test
	void excludeMessage() {
		Error error = new OutOfMemoryError('Test error');
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.defaults());
		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error);
		assertThat(attributes).doesNotContainKey('message');
	}
	@Test
	void includeException() {
		RuntimeException error = new RuntimeException('Test');
		this.errorAttributes = new DefaultErrorAttributes();
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.of(Include.EXCEPTION, Include.MESSAGE));
		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error);
		assertThat(attributes).containsEntry('exception', RuntimeException.class.getName());
		assertThat(attributes).containsEntry('message', 'Test');
	}
	@Test
	void processResponseStatusException() {
		RuntimeException nested = new RuntimeException('Test');
		ResponseStatusException error = new ResponseStatusException(HttpStatus.BAD_REQUEST, 'invalid request', nested);
		this.errorAttributes = new DefaultErrorAttributes();
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.of(Include.EXCEPTION, Include.MESSAGE, Include.STATUS));
		assertThat(attributes).containsEntry('status', 400);
		assertThat(attributes).containsEntry('message', 'invalid request');
		assertThat(attributes).containsEntry('exception', RuntimeException.class.getName());
		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error);
	}
	@Test
	void processResponseStatusExceptionWithNoNestedCause() {
		ResponseStatusException error = new ResponseStatusException(HttpStatus.NOT_ACCEPTABLE,
				'could not process request');
		this.errorAttributes = new DefaultErrorAttributes();
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.of(Include.EXCEPTION, Include.MESSAGE, Include.STATUS));
		assertThat(attributes).containsEntry('status', 406);
		assertThat(attributes).containsEntry('message', 'could not process request');
		assertThat(attributes).containsEntry('exception', ResponseStatusException.class.getName());
		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error);
	}
	@Test
	void notIncludeTrace() {
		RuntimeException ex = new RuntimeException('Test');
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex),
				ErrorAttributeOptions.defaults());
		assertThat(attributes).doesNotContainKey('trace');
	}
	@Test
	void includeTrace() {
		RuntimeException ex = new RuntimeException('Test');
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex),
				ErrorAttributeOptions.of(Include.STACK_TRACE));
		assertThat(attributes.get('trace').toString()).startsWith('java.lang');
	}
	@Test
	void includePathByDefault() {
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND),
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('path', '/test');
	}
	@Test
	void includePath() {
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND),
				ErrorAttributeOptions.of(Include.PATH));
		assertThat(attributes).containsEntry('path', '/test');
	}
	@Test
	void pathShouldIncludeContext() {
		MockServerHttpRequest request = MockServerHttpRequest.get('/context/test').contextPath('/context').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND),
				ErrorAttributeOptions.of(Include.PATH));
		assertThat(attributes).containsEntry('path', '/context/test');
	}
	@Test
	void excludePath() {
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND),
				ErrorAttributeOptions.of());
		assertThat(attributes).doesNotContainEntry('path', '/test');
	}
	@Test
	void includeLogPrefix() {
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, NOT_FOUND);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.defaults());
		assertThat(attributes).containsEntry('requestId', serverRequest.exchange().getRequest().getId());
	}
	@Test
	void extractBindingResultErrors() throws Exception {
		Method method = getClass().getDeclaredMethod('method', String.class);
		MethodParameter stringParam = new MethodParameter(method, 0);
		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap('a', 'b'), 'objectName');
		bindingResult.addError(new ObjectError('c', 'd'));
		Exception ex = new WebExchangeBindException(stringParam, bindingResult);
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex),
				ErrorAttributeOptions.of(Include.MESSAGE, Include.BINDING_ERRORS));
		assertThat(attributes.get('message')).asString()
			.startsWith('Validation failed for argument at index 0 in method: '
					+ 'int org.springframework.boot.web.reactive.error.DefaultErrorAttributesTests'
					+ '.method(java.lang.String), with 1 error(s)');
		assertThat(attributes).containsEntry('errors', bindingResult.getAllErrors());
	}
	@Test
	void extractBindingResultErrorsThatCausedAResponseStatusException() throws Exception {
		Method method = getClass().getDeclaredMethod('method', String.class);
		MethodParameter stringParam = new MethodParameter(method, 0);
		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap('a', 'b'), 'objectName');
		bindingResult.addError(new ObjectError('c', 'd'));
		Exception ex = new WebExchangeBindException(stringParam, bindingResult);
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(
				buildServerRequest(request, new ResponseStatusException(HttpStatus.BAD_REQUEST, 'Invalid', ex)),
				ErrorAttributeOptions.of(Include.MESSAGE, Include.BINDING_ERRORS));
		assertThat(attributes.get('message')).isEqualTo('Invalid');
		assertThat(attributes).containsEntry('errors', bindingResult.getAllErrors());
	}
	@Test
	void extractMethodValidationResultErrors() throws Exception {
		Object target = 'test';
		Method method = String.class.getMethod('substring', int.class);
		MethodParameter parameter = new MethodParameter(method, 0);
		MethodValidationResult methodValidationResult = MethodValidationResult.create(target, method,
				List.of(new ParameterValidationResult(parameter, -1,
						List.of(new ObjectError('beginIndex', 'beginIndex is negative')), null, null, null,
						(error, sourceType) -> {
							throw new IllegalArgumentException('No source object of the given type');
						})));
		HandlerMethodValidationException ex = new HandlerMethodValidationException(methodValidationResult);
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex),
				ErrorAttributeOptions.of(Include.MESSAGE, Include.BINDING_ERRORS));
		assertThat(attributes.get('message')).asString()
			.isEqualTo(
					'Validation failed for method="public java.lang.String java.lang.String.substring(int)". Error count: 1');
		assertThat(attributes).containsEntry('errors',
				methodValidationResult.getAllErrors().stream().filter(ObjectError.class::isInstance).toList());
	}
	@Test
	void extractBindingResultErrorsExcludeMessageAndErrors() throws Exception {
		Method method = getClass().getDeclaredMethod('method', String.class);
		MethodParameter stringParam = new MethodParameter(method, 0);
		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap('a', 'b'), 'objectName');
		bindingResult.addError(new ObjectError('c', 'd'));
		Exception ex = new WebExchangeBindException(stringParam, bindingResult);
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex),
				ErrorAttributeOptions.defaults());
		assertThat(attributes).doesNotContainKey('message');
		assertThat(attributes).doesNotContainKey('errors');
	}
	@Test
	void excludeStatus() {
		ResponseStatusException error = new ResponseStatusException(HttpStatus.NOT_ACCEPTABLE,
				'could not process request');
		this.errorAttributes = new DefaultErrorAttributes();
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.defaults().excluding(Include.STATUS));
		assertThat(attributes).doesNotContainKey('status');
	}
	@Test
	void excludeError() {
		ResponseStatusException error = new ResponseStatusException(HttpStatus.NOT_ACCEPTABLE,
				'could not process request');
		this.errorAttributes = new DefaultErrorAttributes();
		MockServerHttpRequest request = MockServerHttpRequest.get('/test').build();
		ServerRequest serverRequest = buildServerRequest(request, error);
		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest,
				ErrorAttributeOptions.defaults().excluding(Include.ERROR));
		assertThat(attributes).doesNotContainKey('error');
	}
	private ServerRequest buildServerRequest(MockServerHttpRequest request, Throwable error) {
		ServerWebExchange exchange = MockServerWebExchange.from(request);
		this.errorAttributes.storeErrorInformation(error, exchange);
		return ServerRequest.create(exchange, this.readers);
	}
	int method(String firstParam) {
		return 42;
	}
	@ResponseStatus(HttpStatus.I_AM_A_TEAPOT)
	static class CustomException extends RuntimeException {
		CustomException() {
		}
		CustomException(String message) {
			super(message);
		}
	}
	@ResponseStatus(value = HttpStatus.I_AM_A_TEAPOT, reason = 'Nope!')
	static class Custom2Exception extends RuntimeException {
	}
}
/*
package org.springframework.boot;
/**
class ApplicationEnvironmentTests extends AbstractApplicationEnvironmentTests {
	@Override
	protected StandardEnvironment createEnvironment() {
		return new ApplicationEnvironment();
	}
}
/*
package org.springframework.boot;
/**
public abstract class AbstractApplicationEnvironmentTests {
	@Test
	void getActiveProfilesDoesNotResolveProperty() {
		StandardEnvironment environment = createEnvironment();
		new MockPropertySource().withProperty('', '');
		environment.getPropertySources()
			.addFirst(new MockPropertySource().withProperty(AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME, 'test'));
		assertThat(environment.getActiveProfiles()).isEmpty();
	}
	@Test
	void getDefaultProfilesDoesNotResolveProperty() {
		StandardEnvironment environment = createEnvironment();
		new MockPropertySource().withProperty('', '');
		environment.getPropertySources()
			.addFirst(
					new MockPropertySource().withProperty(AbstractEnvironment.DEFAULT_PROFILES_PROPERTY_NAME, 'test'));
		assertThat(environment.getDefaultProfiles()).containsExactly('default');
	}
	@Test
	void propertyResolverIsOptimizedForConfigurationProperties() {
		StandardEnvironment environment = createEnvironment();
		ConfigurablePropertyResolver expected = ConfigurationPropertySources
			.createPropertyResolver(new MutablePropertySources());
		assertThat(environment).extracting('propertyResolver').hasSameClassAs(expected);
	}
	protected abstract StandardEnvironment createEnvironment();
}
/*
package org.springframework.boot;
/**
class DefaultBootstrapContextTests {
	private final DefaultBootstrapContext context = new DefaultBootstrapContext();
	private final AtomicInteger counter = new AtomicInteger();
	private final StaticApplicationContext applicationContext = new StaticApplicationContext();
	@Test
	void registerWhenTypeIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.context.register(null, InstanceSupplier.of(1)))
			.withMessage('Type must not be null');
	}
	@Test
	void registerWhenRegistrationIsNullThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.context.register(Integer.class, null))
			.withMessage('InstanceSupplier must not be null');
	}
	@Test
	void registerWhenNotAlreadyRegisteredRegistersInstance() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		assertThat(this.context.get(Integer.class)).isZero();
		assertThat(this.context.get(Integer.class)).isZero();
	}
	@Test
	void registerWhenAlreadyRegisteredRegistersReplacedInstance() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		this.context.register(Integer.class, InstanceSupplier.of(100));
		assertThat(this.context.get(Integer.class)).isEqualTo(100);
		assertThat(this.context.get(Integer.class)).isEqualTo(100);
	}
	@Test
	void registerWhenSingletonAlreadyCreatedThrowsException() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		this.context.get(Integer.class);
		assertThatIllegalStateException()
			.isThrownBy(() -> this.context.register(Integer.class, InstanceSupplier.of(100)))
			.withMessage('java.lang.Integer has already been created');
	}
	@Test
	void registerWhenPrototypeAlreadyCreatedReplacesInstance() {
		this.context.register(Integer.class,
				InstanceSupplier.from(this.counter::getAndIncrement).withScope(Scope.PROTOTYPE));
		this.context.get(Integer.class);
		this.context.register(Integer.class, InstanceSupplier.of(100));
		assertThat(this.context.get(Integer.class)).isEqualTo(100);
	}
	@Test
	void registerWhenAlreadyCreatedThrowsException() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		this.context.get(Integer.class);
		assertThatIllegalStateException()
			.isThrownBy(() -> this.context.register(Integer.class, InstanceSupplier.of(100)))
			.withMessage('java.lang.Integer has already been created');
	}
	@Test
	void registerWithDependencyRegistersInstance() {
		this.context.register(Integer.class, InstanceSupplier.of(100));
		this.context.register(String.class, this::integerAsString);
		assertThat(this.context.get(String.class)).isEqualTo('100');
	}
	private String integerAsString(BootstrapContext context) {
		return String.valueOf(context.get(Integer.class));
	}
	@Test
	void registerIfAbsentWhenAbsentRegisters() {
		this.context.registerIfAbsent(Long.class, InstanceSupplier.of(100L));
		assertThat(this.context.get(Long.class)).isEqualTo(100L);
	}
	@Test
	void registerIfAbsentWhenPresentDoesNotRegister() {
		this.context.registerIfAbsent(Long.class, InstanceSupplier.of(1L));
		this.context.registerIfAbsent(Long.class, InstanceSupplier.of(100L));
		assertThat(this.context.get(Long.class)).isOne();
	}
	@Test
	void isRegisteredWhenNotRegisteredReturnsFalse() {
		this.context.register(Number.class, InstanceSupplier.of(1));
		assertThat(this.context.isRegistered(Long.class)).isFalse();
	}
	@Test
	void isRegisteredWhenRegisteredReturnsTrue() {
		this.context.register(Number.class, InstanceSupplier.of(1));
		assertThat(this.context.isRegistered(Number.class)).isTrue();
	}
	@Test
	void getRegisteredInstanceSupplierWhenNotRegisteredReturnsNull() {
		this.context.register(Number.class, InstanceSupplier.of(1));
		assertThat(this.context.getRegisteredInstanceSupplier(Long.class)).isNull();
	}
	@Test
	void getRegisteredInstanceSupplierWhenRegisteredReturnsRegistration() {
		InstanceSupplier<Number> instanceSupplier = InstanceSupplier.of(1);
		this.context.register(Number.class, instanceSupplier);
		assertThat(this.context.getRegisteredInstanceSupplier(Number.class)).isSameAs(instanceSupplier);
	}
	@Test
	void getWhenNoRegistrationThrowsIllegalStateException() {
		this.context.register(Number.class, InstanceSupplier.of(1));
		assertThatIllegalStateException().isThrownBy(() -> this.context.get(Long.class))
			.withMessageContaining('has not been registered');
	}
	@Test
	void getWhenRegisteredAsNullReturnsNull() {
		this.context.register(Number.class, InstanceSupplier.of(null));
		assertThat(this.context.get(Number.class)).isNull();
	}
	@Test
	void getWhenSingletonCreatesOnlyOneInstance() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		assertThat(this.context.get(Integer.class)).isZero();
		assertThat(this.context.get(Integer.class)).isZero();
	}
	@Test
	void getWhenPrototypeCreatesOnlyNewInstances() {
		this.context.register(Integer.class,
				InstanceSupplier.from(this.counter::getAndIncrement).withScope(Scope.PROTOTYPE));
		assertThat(this.context.get(Integer.class)).isZero();
		assertThat(this.context.get(Integer.class)).isOne();
	}
	@Test
	void testName() {
	}
	@Test
	void getOrElseWhenNoRegistrationReturnsOther() {
		this.context.register(Number.class, InstanceSupplier.of(1));
		assertThat(this.context.getOrElse(Long.class, -1L)).isEqualTo(-1);
	}
	@Test
	void getOrElseWhenRegisteredAsNullReturnsNull() {
		this.context.register(Number.class, InstanceSupplier.of(null));
		assertThat(this.context.getOrElse(Number.class, -1)).isNull();
	}
	@Test
	void getOrElseCreatesReturnsOnlyOneInstance() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		assertThat(this.context.getOrElse(Integer.class, -1)).isZero();
		assertThat(this.context.getOrElse(Integer.class, -1)).isZero();
	}
	@Test
	void getOrElseSupplyWhenNoRegistrationReturnsSupplied() {
		this.context.register(Number.class, InstanceSupplier.of(1));
		assertThat(this.context.getOrElseSupply(Long.class, () -> -1L)).isEqualTo(-1);
	}
	@Test
	void getOrElseSupplyWhenRegisteredAsNullReturnsNull() {
		this.context.register(Number.class, InstanceSupplier.of(null));
		assertThat(this.context.getOrElseSupply(Number.class, () -> -1L)).isNull();
	}
	@Test
	void getOrElseSupplyCreatesOnlyOneInstance() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		assertThat(this.context.getOrElseSupply(Integer.class, () -> -1)).isZero();
		assertThat(this.context.getOrElseSupply(Integer.class, () -> -1)).isZero();
	}
	@Test
	void getOrElseThrowWhenNoRegistrationThrowsSuppliedException() {
		this.context.register(Number.class, InstanceSupplier.of(1));
		assertThatIOException().isThrownBy(() -> this.context.getOrElseThrow(Long.class, IOException::new));
	}
	@Test
	void getOrElseThrowWhenRegisteredAsNullReturnsNull() {
		this.context.register(Number.class, InstanceSupplier.of(null));
		assertThat(this.context.getOrElseThrow(Number.class, RuntimeException::new)).isNull();
	}
	@Test
	void getOrElseThrowCreatesOnlyOneInstance() {
		this.context.register(Integer.class, InstanceSupplier.from(this.counter::getAndIncrement));
		assertThat(this.context.getOrElseThrow(Integer.class, RuntimeException::new)).isZero();
		assertThat(this.context.getOrElseThrow(Integer.class, RuntimeException::new)).isZero();
	}
	@Test
	void closeMulticastsEventToListeners() {
		TestCloseListener listener = new TestCloseListener();
		this.context.addCloseListener(listener);
		assertThat(listener).wasNotCalled();
		this.context.close(this.applicationContext);
		assertThat(listener).wasCalledOnlyOnce()
			.hasBootstrapContextSameAs(this.context)
			.hasApplicationContextSameAs(this.applicationContext);
	}
	@Test
	void addCloseListenerIgnoresMultipleCallsWithSameListener() {
		TestCloseListener listener = new TestCloseListener();
		this.context.addCloseListener(listener);
		this.context.addCloseListener(listener);
		this.context.close(this.applicationContext);
		assertThat(listener).wasCalledOnlyOnce();
	}
	@Test
	void instanceSupplierGetScopeWhenNotConfiguredReturnsSingleton() {
		InstanceSupplier<String> supplier = InstanceSupplier.of('test');
		assertThat(supplier.getScope()).isEqualTo(Scope.SINGLETON);
		assertThat(supplier.get(null)).isEqualTo('test');
	}
	@Test
	void instanceSupplierWithScopeChangesScope() {
		InstanceSupplier<String> supplier = InstanceSupplier.of('test').withScope(Scope.PROTOTYPE);
		assertThat(supplier.getScope()).isEqualTo(Scope.PROTOTYPE);
		assertThat(supplier.get(null)).isEqualTo('test');
	}
	private static final class TestCloseListener
			implements ApplicationListener<BootstrapContextClosedEvent>, AssertProvider<CloseListenerAssert> {
		private int called;
		private BootstrapContext bootstrapContext;
		private ConfigurableApplicationContext applicationContext;
		@Override
		public void onApplicationEvent(BootstrapContextClosedEvent event) {
			this.called++;
			this.bootstrapContext = event.getBootstrapContext();
			this.applicationContext = event.getApplicationContext();
		}
		@Override
		public CloseListenerAssert assertThat() {
			return new CloseListenerAssert(this);
		}
	}
	private static class CloseListenerAssert extends AbstractAssert<CloseListenerAssert, TestCloseListener> {
		CloseListenerAssert(TestCloseListener actual) {
			super(actual, CloseListenerAssert.class);
		}
		CloseListenerAssert wasCalledOnlyOnce() {
			assertThat(this.actual.called).as('action calls').isOne();
			return this;
		}
		CloseListenerAssert wasNotCalled() {
			assertThat(this.actual.called).as('action calls').isZero();
			return this;
		}
		CloseListenerAssert hasBootstrapContextSameAs(BootstrapContext bootstrapContext) {
			assertThat(this.actual.bootstrapContext).isSameAs(bootstrapContext);
			return this;
		}
		CloseListenerAssert hasApplicationContextSameAs(ApplicationContext applicationContext) {
			assertThat(this.actual.applicationContext).isSameAs(applicationContext);
			return this;
		}
	}
}
/*
package org.springframework.boot.validation;
/**
class MessageSourceMessageInterpolatorTests {
	private final Context context = mock(Context.class);
	private final StaticMessageSource messageSource = new StaticMessageSource();
	private final MessageSourceMessageInterpolator interpolator = new MessageSourceMessageInterpolator(
			this.messageSource, new IdentityMessageInterpolator());
	@Test
	void interpolateShouldReplaceParameters() {
		this.messageSource.addMessage('foo', Locale.getDefault(), 'fooValue');
		this.messageSource.addMessage('bar', Locale.getDefault(), '');
		assertThat(this.interpolator.interpolate('{foo}{bar}', this.context)).isEqualTo('fooValue');
	}
	@Test
	void interpolateWhenParametersAreUnknownShouldLeaveThemUnchanged() {
		this.messageSource.addMessage('top', Locale.getDefault(), '{child}+{child}');
		assertThat(this.interpolator.interpolate('{foo}{top}{bar}', this.context))
			.isEqualTo('{foo}{child}+{child}{bar}');
	}
	@Test
	void interpolateWhenParametersAreUnknownUsingCodeAsDefaultShouldLeaveThemUnchanged() {
		this.messageSource.setUseCodeAsDefaultMessage(true);
		this.messageSource.addMessage('top', Locale.getDefault(), '{child}+{child}');
		assertThat(this.interpolator.interpolate('{foo}{top}{bar}', this.context))
			.isEqualTo('{foo}{child}+{child}{bar}');
	}
	@Test
	void interpolateWhenParametersAreNestedShouldFullyReplaceAllParameters() {
		this.messageSource.addMessage('top', Locale.getDefault(), '{child}+{child}');
		this.messageSource.addMessage('child', Locale.getDefault(), '{{differentiator}.grandchild}');
		this.messageSource.addMessage('differentiator', Locale.getDefault(), 'first');
		this.messageSource.addMessage('first.grandchild', Locale.getDefault(), 'actualValue');
		assertThat(this.interpolator.interpolate('{top}', this.context)).isEqualTo('actualValue+actualValue');
	}
	@Test
	void interpolateWhenParameterBracesAreUnbalancedShouldLeaveThemUnchanged() {
		this.messageSource.addMessage('top', Locale.getDefault(), 'topValue');
		assertThat(this.interpolator.interpolate('\\{top}', this.context)).isEqualTo('\\{top}');
		assertThat(this.interpolator.interpolate('{top\\}', this.context)).isEqualTo('{top\\}');
		assertThat(this.interpolator.interpolate('{{top}', this.context)).isEqualTo('{{top}');
		assertThat(this.interpolator.interpolate('{top}}', this.context)).isEqualTo('topValue}');
	}
	@Test
	void interpolateWhenBracesAreEscapedShouldIgnore() {
		this.messageSource.addMessage('foo', Locale.getDefault(), 'fooValue');
		this.messageSource.addMessage('bar', Locale.getDefault(), '\\{foo}');
		this.messageSource.addMessage('bazz\\}', Locale.getDefault(), 'bazzValue');
		assertThat(this.interpolator.interpolate('{foo}', this.context)).isEqualTo('fooValue');
		assertThat(this.interpolator.interpolate('{foo}\\a', this.context)).isEqualTo('fooValue\\a');
		assertThat(this.interpolator.interpolate('\\\\{foo}', this.context)).isEqualTo('\\\\fooValue');
		assertThat(this.interpolator.interpolate('\\\\\\{foo}', this.context)).isEqualTo('\\\\\\{foo}');
		assertThat(this.interpolator.interpolate('\\{foo}', this.context)).isEqualTo('\\{foo}');
		assertThat(this.interpolator.interpolate('{foo\\}', this.context)).isEqualTo('{foo\\}');
		assertThat(this.interpolator.interpolate('\\{foo\\}', this.context)).isEqualTo('\\{foo\\}');
		assertThat(this.interpolator.interpolate('{foo}\\', this.context)).isEqualTo('fooValue\\');
		assertThat(this.interpolator.interpolate('{bar}', this.context)).isEqualTo('\\{foo}');
		assertThat(this.interpolator.interpolate('{bazz\\}}', this.context)).isEqualTo('bazzValue');
	}
	@Test
	void interpolateWhenParametersContainACycleShouldThrow() {
		this.messageSource.addMessage('a', Locale.getDefault(), '{b}');
		this.messageSource.addMessage('b', Locale.getDefault(), '{c}');
		this.messageSource.addMessage('c', Locale.getDefault(), '{a}');
		assertThatIllegalArgumentException().isThrownBy(() -> this.interpolator.interpolate('{a}', this.context))
			.withMessage('Circular reference "{a -> b -> c -> a}"');
	}
	private static final class IdentityMessageInterpolator implements MessageInterpolator {
		@Override
		public String interpolate(String messageTemplate, Context context) {
			return messageTemplate;
		}
		@Override
		public String interpolate(String messageTemplate, Context context, Locale locale) {
			return messageTemplate;
		}
	}
}
/*
package org.springframework.boot.validation;
/**
class MessageSourceMessageInterpolatorIntegrationTests {
	@NotNull
	private String defaultMessage;
	@NotNull(message = '{null}')
	private String nullable;
	@NotNull(message = '{blank}')
	private String blank;
	@NotNull(message = '{unknown}')
	private String unknown;
	@NotNull(message = '{recursion}')
	private String recursion;
	@NotNull(message = '\\{null}')
	private String escapePrefix;
	@NotNull(message = '{null\\}')
	private String escapeSuffix;
	@NotNull(message = '\\{null\\}')
	private String escapePrefixSuffix;
	@NotNull(message = '\\\\{null}')
	private String escapeEscape;
	@Test
	void defaultMessage() {
		assertThat(validate('defaultMessage')).containsExactly('must not be null');
	}
	@Test
	void nullable() {
		assertThat(validate('nullable')).containsExactly('must not be null');
	}
	@Test
	void blank() {
		assertThat(validate('blank')).containsExactly('must not be null or must not be blank');
	}
	@Test
	void recursion() {
		assertThatException().isThrownBy(() -> validate('recursion'))
			.withStackTraceContaining('Circular reference "{recursion -> middle -> recursion}"');
	}
	@Test
	void unknown() {
		assertThat(validate('unknown')).containsExactly('{unknown}');
	}
	@Test
	void escapePrefix() {
		assertThat(validate('escapePrefix')).containsExactly('\\{null}');
	}
	@Test
	void escapeSuffix() {
		assertThat(validate('escapeSuffix')).containsExactly('{null\\}');
	}
	@Test
	void escapePrefixSuffix() {
		assertThat(validate('escapePrefixSuffix')).containsExactly('{null}');
	}
	@Test
	void escapeEscape() {
		assertThat(validate('escapeEscape')).containsExactly('\\must not be null');
	}
	private List<String> validate(String property) {
		return withEnglishLocale(() -> {
			Validator validator = buildValidator();
			List<String> messages = new ArrayList<>();
			Set<ConstraintViolation<Object>> constraints = validator.validateProperty(this, property);
			for (ConstraintViolation<Object> constraint : constraints) {
				messages.add(constraint.getMessage());
			}
			return messages;
		});
	}
	private static Validator buildValidator() {
		Locale locale = LocaleContextHolder.getLocale();
		StaticMessageSource messageSource = new StaticMessageSource();
		messageSource.addMessage('blank', locale, '{null} or {jakarta.validation.constraints.NotBlank.message}');
		messageSource.addMessage('null', locale, '{jakarta.validation.constraints.NotNull.message}');
		messageSource.addMessage('recursion', locale, '{middle}');
		messageSource.addMessage('middle', locale, '{recursion}');
		MessageInterpolatorFactory messageInterpolatorFactory = new MessageInterpolatorFactory(messageSource);
		try (LocalValidatorFactoryBean validatorFactory = new LocalValidatorFactoryBean()) {
			validatorFactory.setMessageInterpolator(messageInterpolatorFactory.getObject());
			validatorFactory.afterPropertiesSet();
			return validatorFactory.getValidator();
		}
	}
	private static <T> T withEnglishLocale(Supplier<T> supplier) {
		Locale defaultLocale = Locale.getDefault();
		try {
			Locale.setDefault(Locale.ENGLISH);
			return supplier.get();
		}
		finally {
			Locale.setDefault(defaultLocale);
		}
	}
}
/*
package org.springframework.boot.validation.beanvalidation;
/**
class MethodValidationExcludeFilterTests {
	@Test
	void byAnnotationWhenClassIsAnnotatedExcludes() {
		MethodValidationExcludeFilter filter = MethodValidationExcludeFilter.byAnnotation(Indicator.class);
		assertThat(filter.isExcluded(Annotated.class)).isTrue();
	}
	@Test
	void byAnnotationWhenClassIsNotAnnotatedIncludes() {
		MethodValidationExcludeFilter filter = MethodValidationExcludeFilter.byAnnotation(Indicator.class);
		assertThat(filter.isExcluded(Plain.class)).isFalse();
	}
	@Test
	void byAnnotationWhenSuperclassIsAnnotatedWithInheritedAnnotationExcludes() {
		MethodValidationExcludeFilter filter = MethodValidationExcludeFilter.byAnnotation(Indicator.class);
		assertThat(filter.isExcluded(AnnotatedSuperClass.class)).isTrue();
	}
	@Test
	void byAnnotationWithDirectSearchStrategyWhenSuperclassIsAnnotatedWithInheritedAnnotationIncludes() {
		MethodValidationExcludeFilter filter = MethodValidationExcludeFilter.byAnnotation(Indicator.class,
				SearchStrategy.DIRECT);
		assertThat(filter.isExcluded(AnnotatedSuperClass.class)).isFalse();
	}
	static class Plain {
	}
	@Indicator
	static class Annotated {
	}
	@Inherited
	@Retention(RetentionPolicy.RUNTIME)
	@interface Indicator {
	}
	static class AnnotatedSuperClass extends Annotated {
	}
}
/*
package org.springframework.boot.validation;
/**
class MessageInterpolatorFactoryTests {
	@Test
	void getObjectShouldReturnResourceBundleMessageInterpolator() {
		MessageInterpolator interpolator = new MessageInterpolatorFactory().getObject();
		assertThat(interpolator).isInstanceOf(ResourceBundleMessageInterpolator.class);
	}
	@Test
	void getObjectShouldReturnMessageSourceMessageInterpolatorDelegateWithResourceBundleMessageInterpolator() {
		MessageSource messageSource = mock(MessageSource.class);
		MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory(messageSource);
		MessageInterpolator interpolator = interpolatorFactory.getObject();
		assertThat(interpolator).isInstanceOf(MessageSourceMessageInterpolator.class);
		assertThat(interpolator).hasFieldOrPropertyWithValue('messageSource', messageSource);
		assertThat(ReflectionTestUtils.getField(interpolator, 'messageInterpolator'))
			.isInstanceOf(ResourceBundleMessageInterpolator.class);
	}
}
/*
package org.springframework.boot.validation;
/**
@ClassPathExclusions('tomcat-embed-el-*.jar')
class MessageInterpolatorFactoryWithoutElIntegrationTests {
	@Test
	void defaultMessageInterpolatorShouldFail() {
		// Sanity test
		assertThatExceptionOfType(ValidationException.class)
			.isThrownBy(Validation.byDefaultProvider().configure()::getDefaultMessageInterpolator)
			.withMessageContaining('jakarta.el.ExpressionFactory');
	}
	@Test
	void getObjectShouldUseFallback() {
		MessageInterpolator interpolator = new MessageInterpolatorFactory().getObject();
		assertThat(interpolator).isInstanceOf(ParameterMessageInterpolator.class);
	}
	@Test
	void getObjectShouldUseMessageSourceMessageInterpolatorDelegateWithFallback() {
		MessageSource messageSource = mock(MessageSource.class);
		MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory(messageSource);
		MessageInterpolator interpolator = interpolatorFactory.getObject();
		assertThat(interpolator).isInstanceOf(MessageSourceMessageInterpolator.class);
		assertThat(interpolator).hasFieldOrPropertyWithValue('messageSource', messageSource);
		assertThat(ReflectionTestUtils.getField(interpolator, 'messageInterpolator'))
			.isInstanceOf(ParameterMessageInterpolator.class);
	}
}
/*
package org.springframework.boot.availability;
/**
class AvailabilityChangeEventTests {
	private final Object source = new Object();
	@Test
	void createWhenStateIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new AvailabilityChangeEvent<>(this.source, null))
			.withMessage('Payload must not be null');
	}
	@Test
	void getStateReturnsState() {
		LivenessState state = LivenessState.CORRECT;
		AvailabilityChangeEvent<LivenessState> event = new AvailabilityChangeEvent<>(this.source, state);
		assertThat(event.getState()).isEqualTo(state);
	}
	@Test
	void getResolvableType() {
		LivenessState state = LivenessState.CORRECT;
		AvailabilityChangeEvent<LivenessState> event = new AvailabilityChangeEvent<>(this.source, state);
		ResolvableType type = event.getResolvableType();
		assertThat(type.resolve()).isEqualTo(AvailabilityChangeEvent.class);
		assertThat(type.resolveGeneric()).isEqualTo(LivenessState.class);
	}
	@Test
	void getResolvableTypeWhenSubclassedEnum() {
		SubClassedEnum state = SubClassedEnum.TWO;
		AvailabilityChangeEvent<SubClassedEnum> event = new AvailabilityChangeEvent<>(this.source, state);
		ResolvableType type = event.getResolvableType();
		assertThat(type.resolve()).isEqualTo(AvailabilityChangeEvent.class);
		assertThat(type.resolveGeneric()).isEqualTo(SubClassedEnum.class);
	}
	@Test
	void publishPublishesEvent() {
		ApplicationContext context = mock(ApplicationContext.class);
		AvailabilityState state = LivenessState.CORRECT;
		AvailabilityChangeEvent.publish(context, state);
		then(context).should()
			.publishEvent(assertArg((event) -> assertThat(event).isInstanceOfSatisfying(AvailabilityChangeEvent.class,
					(castedEvent) -> {
						assertThat(castedEvent.getSource()).isEqualTo(context);
						assertThat(castedEvent.getState()).isEqualTo(state);
					})));
	}
	@Test
	void publishEvenToContextConsidersGenericType() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
		AvailabilityChangeEvent.publish(context, LivenessState.CORRECT);
		AvailabilityChangeEvent.publish(context, ReadinessState.ACCEPTING_TRAFFIC);
	}
	enum SubClassedEnum implements AvailabilityState {
		ONE {
			@Override
			String getDescription() {
				return 'I have been overridden';
			}
		},
		TWO {
			@Override
			String getDescription() {
				return 'I have also been overridden';
			}
		};
		abstract String getDescription();
	}
	@Configuration
	static class Config {
		@EventListener
		void onLivenessAvailabilityChange(AvailabilityChangeEvent<LivenessState> event) {
			assertThat(event.getState()).isInstanceOf(LivenessState.class).isEqualTo(LivenessState.CORRECT);
		}
	}
}
/*
package org.springframework.boot.availability;
/**
class ApplicationAvailabilityBeanTests {
	private AnnotationConfigApplicationContext context;
	private ApplicationAvailabilityBean availability;
	private MockLog log;
	@BeforeEach
	void setup() {
		this.context = new AnnotationConfigApplicationContext(TestConfiguration.class);
		this.availability = this.context.getBean(ApplicationAvailabilityBean.class);
		this.log = this.context.getBean(MockLog.class);
	}
	@Test
	void getLivenessStateWhenNoEventHasBeenPublishedReturnsDefaultState() {
		assertThat(this.availability.getLivenessState()).isEqualTo(LivenessState.BROKEN);
	}
	@Test
	void getLivenessStateWhenEventHasBeenPublishedReturnsPublishedState() {
		AvailabilityChangeEvent.publish(this.context, LivenessState.CORRECT);
		assertThat(this.availability.getLivenessState()).isEqualTo(LivenessState.CORRECT);
	}
	@Test
	void getReadinessStateWhenNoEventHasBeenPublishedReturnsDefaultState() {
		assertThat(this.availability.getReadinessState()).isEqualTo(ReadinessState.REFUSING_TRAFFIC);
	}
	@Test
	void getReadinessStateWhenEventHasBeenPublishedReturnsPublishedState() {
		AvailabilityChangeEvent.publish(this.context, ReadinessState.ACCEPTING_TRAFFIC);
		assertThat(this.availability.getReadinessState()).isEqualTo(ReadinessState.ACCEPTING_TRAFFIC);
	}
	@Test
	void getStateWhenNoEventHasBeenPublishedReturnsDefaultState() {
		assertThat(this.availability.getState(TestState.class)).isNull();
		assertThat(this.availability.getState(TestState.class, TestState.ONE)).isEqualTo(TestState.ONE);
	}
	@Test
	void getStateWhenEventHasBeenPublishedReturnsPublishedState() {
		AvailabilityChangeEvent.publish(this.context, TestState.TWO);
		assertThat(this.availability.getState(TestState.class)).isEqualTo(TestState.TWO);
		assertThat(this.availability.getState(TestState.class, TestState.ONE)).isEqualTo(TestState.TWO);
	}
	@Test
	void getLastChangeEventWhenNoEventHasBeenPublishedReturnsDefaultState() {
		assertThat(this.availability.getLastChangeEvent(TestState.class)).isNull();
	}
	@Test
	void getLastChangeEventWhenEventHasBeenPublishedReturnsPublishedState() {
		AvailabilityChangeEvent.publish(this.context, TestState.TWO);
		assertThat(this.availability.getLastChangeEvent(TestState.class)).isNotNull();
	}
	@Test
	void stateChangesAreLogged() {
		AvailabilityChangeEvent.publish(this.context, LivenessState.CORRECT);
		assertThat(this.log.getLogged()).contains('Application availability state LivenessState changed to CORRECT');
		AvailabilityChangeEvent.publish(this.context, LivenessState.BROKEN);
		assertThat(this.log.getLogged())
			.contains('Application availability state LivenessState changed from CORRECT to BROKEN');
	}
	@Test
	void stateChangesAreLoggedWithExceptionSource() {
		AvailabilityChangeEvent.publish(this.context, new IOException('connection error'), LivenessState.BROKEN);
		assertThat(this.log.getLogged()).contains('Application availability state LivenessState changed to BROKEN: '
				+ 'java.io.IOException: connection error');
	}
	@Test
	void stateChangesAreLoggedWithOtherSource() {
		AvailabilityChangeEvent.publish(this.context, new CustomEventSource(), LivenessState.BROKEN);
		assertThat(this.log.getLogged()).contains(
				'Application availability state LivenessState changed to BROKEN: ' + CustomEventSource.class.getName());
	}
	enum TestState implements AvailabilityState {
		ONE {
			@Override
			public String test() {
				return 'spring';
			}
		},
		TWO {
			@Override
			public String test() {
				return 'boot';
			}
		};
		abstract String test();
	}
	static class CustomEventSource {
	}
	@Configuration
	static class TestConfiguration {
		@Bean
		MockLog mockLog() {
			List<String> logged = new ArrayList<>();
			MockLog log = mock(MockLog.class);
			given(log.isDebugEnabled()).willReturn(true);
			given(log.getLogged()).willReturn(logged);
			willAnswer((invocation) -> logged.add('' + invocation.getArguments()[0])).given(log).debug(any());
			return log;
		}
		@Bean
		ApplicationAvailabilityBean applicationAvailabilityBean(MockLog log) {
			return new ApplicationAvailabilityBean(log);
		}
	}
	interface MockLog extends Log {
		List<String> getLogged();
	}
}
/*
package org.springframework.boot;
/**
class StartupInfoLoggerTests {
	private final Log log = mock(Log.class);
	private MockEnvironment environment;
	@BeforeEach
	void setUp() {
		this.environment = new MockEnvironment();
		this.environment.setProperty('spring.application.version', '1.2.3');
		this.environment.setProperty('spring.application.pid', '42');
	}
	@Test
	void startingFormat() {
		given(this.log.isInfoEnabled()).willReturn(true);
		new StartupInfoLogger(getClass(), this.environment).logStarting(this.log);
		then(this.log).should()
			.info(assertArg(
					(message) -> assertThat(message.toString()).contains('Starting ' + getClass().getSimpleName()
							+ ' v1.2.3 using Java ' + System.getProperty('java.version') + ' with PID 42 (started by '
							+ System.getProperty('user.name') + ' in ' + System.getProperty('user.dir') + ')')));
	}
	@Test
	void startingFormatWhenVersionIsNotAvailable() {
		this.environment.setProperty('spring.application.version', '');
		given(this.log.isInfoEnabled()).willReturn(true);
		new StartupInfoLogger(getClass(), this.environment).logStarting(this.log);
		then(this.log).should()
			.info(assertArg(
					(message) -> assertThat(message.toString()).contains('Starting ' + getClass().getSimpleName()
							+ ' using Java ' + System.getProperty('java.version') + ' with PID 42 (started by '
							+ System.getProperty('user.name') + ' in ' + System.getProperty('user.dir') + ')')));
	}
	@Test
	void startingFormatWhenPidIsNotAvailable() {
		this.environment.setProperty('spring.application.pid', '');
		given(this.log.isInfoEnabled()).willReturn(true);
		new StartupInfoLogger(getClass(), this.environment).logStarting(this.log);
		then(this.log).should()
			.info(assertArg(
					(message) -> assertThat(message.toString()).contains('Starting ' + getClass().getSimpleName()
							+ ' v1.2.3 using Java ' + System.getProperty('java.version') + ' (started by '
							+ System.getProperty('user.name') + ' in ' + System.getProperty('user.dir') + ')')));
	}
	@Test
	void startingFormatInAotMode() {
		System.setProperty('spring.aot.enabled', 'true');
		try {
			given(this.log.isInfoEnabled()).willReturn(true);
			new StartupInfoLogger(getClass(), this.environment).logStarting(this.log);
			then(this.log).should()
				.info(assertArg((message) -> assertThat(message.toString())
					.contains('Starting AOT-processed ' + getClass().getSimpleName() + ' v1.2.3 using Java '
							+ System.getProperty('java.version') + ' with PID 42 (started by '
							+ System.getProperty('user.name') + ' in ' + System.getProperty('user.dir') + ')')));
		}
		finally {
			System.clearProperty('spring.aot.enabled');
		}
	}
	@Test
	void startedFormat() {
		given(this.log.isInfoEnabled()).willReturn(true);
		new StartupInfoLogger(getClass(), this.environment).logStarted(this.log, new TestStartup(1345L, 'Started'));
		then(this.log).should()
			.info(assertArg((message) -> assertThat(message.toString()).matches('Started ' + getClass().getSimpleName()
					+ ' in \\d+\\.\\d{1,3} seconds \\(process running for 1.345\\)')));
	}
	@Test
	void startedWithoutUptimeFormat() {
		given(this.log.isInfoEnabled()).willReturn(true);
		new StartupInfoLogger(getClass(), this.environment).logStarted(this.log, new TestStartup(null, 'Started'));
		then(this.log).should()
			.info(assertArg((message) -> assertThat(message.toString())
				.matches('Started ' + getClass().getSimpleName() + ' in \\d+\\.\\d{1,3} seconds')));
	}
	@Test
	void restoredFormat() {
		given(this.log.isInfoEnabled()).willReturn(true);
		new StartupInfoLogger(getClass(), this.environment).logStarted(this.log, new TestStartup(null, 'Restored'));
		then(this.log).should()
			.info(assertArg((message) -> assertThat(message.toString())
				.matches('Restored ' + getClass().getSimpleName() + ' in \\d+\\.\\d{1,3} seconds')));
	}
	static class TestStartup extends Startup {
		private final long startTime = System.currentTimeMillis();
		private final Long uptime;
		private final String action;
		TestStartup(Long uptime, String action) {
			this.uptime = uptime;
			this.action = action;
			started();
		}
		@Override
		protected long startTime() {
			return this.startTime;
		}
		@Override
		protected Long processUptime() {
			return this.uptime;
		}
		@Override
		protected String action() {
			return this.action;
		}
	}
}
/*
package org.springframework.boot;
/**
class ApplicationPropertiesTests {
	@Test
	void bannerModeShouldBeConsoleIfStructuredLoggingIsNotEnabled() {
		ApplicationProperties properties = new ApplicationProperties();
		assertThat(properties.getBannerMode(new MockEnvironment())).isEqualTo(Mode.CONSOLE);
	}
	@Test
	void bannerModeShouldBeOffIfStructuredLoggingIsEnabled() {
		ApplicationProperties properties = new ApplicationProperties();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.format.console', 'ecs');
		assertThat(properties.getBannerMode(environment)).isEqualTo(Mode.OFF);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new ApplicationPropertiesRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ApplicationProperties.class)).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(ApplicationProperties.class, 'setBannerMode'))
			.accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(ApplicationProperties.class, 'getSources'))
			.accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(ApplicationProperties.class, 'setSources'))
			.accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(ApplicationProperties.class, 'getBannerMode'))
			.rejects(hints);
	}
}
/*
package org.springframework.boot.sql.init;
/**
public abstract class AbstractScriptDatabaseInitializerTests<T extends AbstractScriptDatabaseInitializer> {
	@Test
	void whenDatabaseIsInitializedThenSchemaAndDataScriptsAreApplied() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('schema.sql'));
		settings.setDataLocations(Arrays.asList('data.sql'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isTrue();
		assertThat(numberOfEmbeddedRows('SELECT COUNT(*) FROM EXAMPLE')).isOne();
	}
	@Test
	void whenDatabaseIsInitializedWithDirectoryLocationsThenFailureIsHelpful() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('/org/springframework/boot/sql/init'));
		settings.setDataLocations(Arrays.asList('/org/springframework/boot/sql/init'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThatIllegalStateException().isThrownBy(initializer::initializeDatabase)
			.withMessage('No schema scripts found at location "/org/springframework/boot/sql/init"');
	}
	@Test
	void whenContinueOnErrorIsFalseThenInitializationFailsOnError() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setDataLocations(Arrays.asList('data.sql'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThatExceptionOfType(DataAccessException.class).isThrownBy(initializer::initializeDatabase);
		assertThatDatabaseWasAccessed(initializer);
	}
	@Test
	void whenContinueOnErrorIsTrueThenInitializationDoesNotFailOnError() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setContinueOnError(true);
		settings.setDataLocations(Arrays.asList('data.sql'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isTrue();
		assertThatDatabaseWasAccessed(initializer);
	}
	@Test
	void whenNoScriptsExistAtASchemaLocationThenInitializationFails() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('does-not-exist.sql'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThatIllegalStateException().isThrownBy(initializer::initializeDatabase)
			.withMessage('No schema scripts found at location "does-not-exist.sql"');
		assertThatDatabaseWasNotAccessed(initializer);
	}
	@Test
	void whenNoScriptsExistAtADataLocationThenInitializationFails() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setDataLocations(Arrays.asList('does-not-exist.sql'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThatIllegalStateException().isThrownBy(initializer::initializeDatabase)
			.withMessage('No data scripts found at location "does-not-exist.sql"');
		assertThatDatabaseWasNotAccessed(initializer);
	}
	@Test
	void whenNoScriptsExistAtAnOptionalSchemaLocationThenDatabaseIsNotAccessed() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('optional:does-not-exist.sql'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isFalse();
		assertThatDatabaseWasNotAccessed(initializer);
	}
	@Test
	void whenNoScriptsExistAtAnOptionalDataLocationThenDatabaseIsNotAccessed() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setDataLocations(Arrays.asList('optional:does-not-exist.sql'));
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isFalse();
		assertThatDatabaseWasNotAccessed(initializer);
	}
	@Test
	void whenModeIsNeverThenEmbeddedDatabaseIsNotInitialized() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('schema.sql'));
		settings.setDataLocations(Arrays.asList('data.sql'));
		settings.setMode(DatabaseInitializationMode.NEVER);
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isFalse();
		assertThatDatabaseWasNotAccessed(initializer);
	}
	@Test
	void whenModeIsNeverThenStandaloneDatabaseIsNotInitialized() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('schema.sql'));
		settings.setDataLocations(Arrays.asList('data.sql'));
		settings.setMode(DatabaseInitializationMode.NEVER);
		T initializer = createStandaloneDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isFalse();
		assertThatDatabaseWasNotAccessed(initializer);
	}
	@Test
	void whenModeIsEmbeddedThenEmbeddedDatabaseIsInitialized() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('schema.sql'));
		settings.setDataLocations(Arrays.asList('data.sql'));
		settings.setMode(DatabaseInitializationMode.EMBEDDED);
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isTrue();
		assertThat(numberOfEmbeddedRows('SELECT COUNT(*) FROM EXAMPLE')).isOne();
	}
	@Test
	void whenModeIsEmbeddedThenStandaloneDatabaseIsNotInitialized() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('schema.sql'));
		settings.setDataLocations(Arrays.asList('data.sql'));
		settings.setMode(DatabaseInitializationMode.EMBEDDED);
		T initializer = createStandaloneDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isFalse();
		assertThatDatabaseWasAccessed(initializer);
	}
	@Test
	void whenModeIsAlwaysThenEmbeddedDatabaseIsInitialized() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('schema.sql'));
		settings.setDataLocations(Arrays.asList('data.sql'));
		settings.setMode(DatabaseInitializationMode.ALWAYS);
		T initializer = createEmbeddedDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isTrue();
		assertThat(numberOfEmbeddedRows('SELECT COUNT(*) FROM EXAMPLE')).isOne();
	}
	@Test
	void whenModeIsAlwaysThenStandaloneDatabaseIsInitialized() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(Arrays.asList('schema.sql'));
		settings.setDataLocations(Arrays.asList('data.sql'));
		settings.setMode(DatabaseInitializationMode.ALWAYS);
		T initializer = createStandaloneDatabaseInitializer(settings);
		assertThat(initializer.initializeDatabase()).isTrue();
		assertThat(numberOfStandaloneRows('SELECT COUNT(*) FROM EXAMPLE')).isOne();
	}
	protected abstract T createStandaloneDatabaseInitializer(DatabaseInitializationSettings settings);
	protected abstract T createEmbeddedDatabaseInitializer(DatabaseInitializationSettings settings);
	protected abstract int numberOfEmbeddedRows(String sql);
	protected abstract int numberOfStandaloneRows(String sql);
	private void assertThatDatabaseWasAccessed(T initializer) {
		assertDatabaseAccessed(true, initializer);
	}
	private void assertThatDatabaseWasNotAccessed(T initializer) {
		assertDatabaseAccessed(false, initializer);
	}
	protected abstract void assertDatabaseAccessed(boolean accessed, T initializer);
}
/*
package org.springframework.boot.sql.init.dependency;
/**
class DatabaseInitializationDependencyConfigurerTests {
	private final ConfigurableEnvironment environment = new MockEnvironment();
	@TempDir
	File temp;
	@BeforeEach
	void resetMocks() {
		reset(MockDatabaseInitializerDetector.instance, OrderedNearLowestMockDatabaseInitializerDetector.instance,
				OrderedLowestMockDatabaseInitializerDetector.instance,
				MockedDependsOnDatabaseInitializationDetector.instance);
	}
	@Test
	void beanFactoryPostProcessorHasOrderAllowingSubsequentPostProcessorsToFineTuneDependencies() {
		performDetection(Arrays.asList(MockDatabaseInitializerDetector.class,
				MockedDependsOnDatabaseInitializationDetector.class), (context) -> {
					BeanDefinition alpha = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
					BeanDefinition bravo = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
					context.register(DependsOnCaptor.class);
					context.register(DependencyConfigurerConfiguration.class);
					context.registerBeanDefinition('alpha', alpha);
					context.registerBeanDefinition('bravo', bravo);
					given(MockDatabaseInitializerDetector.instance.detect(context.getBeanFactory()))
						.willReturn(Collections.singleton('alpha'));
					given(MockedDependsOnDatabaseInitializationDetector.instance.detect(context.getBeanFactory()))
						.willReturn(Collections.singleton('bravo'));
					context.refresh();
					assertThat(DependsOnCaptor.dependsOn).hasEntrySatisfying('bravo',
							(dependencies) -> assertThat(dependencies).containsExactly('alpha'));
					assertThat(DependsOnCaptor.dependsOn).doesNotContainKey('alpha');
				});
	}
	@Test
	void whenDetectorsAreCreatedThenTheEnvironmentCanBeInjected() {
		performDetection(Arrays.asList(ConstructorInjectionDatabaseInitializerDetector.class,
				ConstructorInjectionDependsOnDatabaseInitializationDetector.class), (context) -> {
					BeanDefinition alpha = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
					context.registerBeanDefinition('alpha', alpha);
					context.register(DependencyConfigurerConfiguration.class);
					context.refresh();
					assertThat(ConstructorInjectionDatabaseInitializerDetector.environment).isEqualTo(this.environment);
					assertThat(ConstructorInjectionDependsOnDatabaseInitializationDetector.environment)
						.isEqualTo(this.environment);
				});
	}
	@Test
	void whenDependenciesAreConfiguredThenBeansThatDependUponDatabaseInitializationDependUponDetectedDatabaseInitializers() {
		BeanDefinition alpha = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
		BeanDefinition bravo = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
		performDetection(Arrays.asList(MockDatabaseInitializerDetector.class,
				MockedDependsOnDatabaseInitializationDetector.class), (context) -> {
					context.registerBeanDefinition('alpha', alpha);
					context.registerBeanDefinition('bravo', bravo);
					given(MockDatabaseInitializerDetector.instance.detect(context.getBeanFactory()))
						.willReturn(Collections.singleton('alpha'));
					given(MockedDependsOnDatabaseInitializationDetector.instance.detect(context.getBeanFactory()))
						.willReturn(Collections.singleton('bravo'));
					context.register(DependencyConfigurerConfiguration.class);
					context.refresh();
					assertThat(alpha.getAttribute(DatabaseInitializerDetector.class.getName()))
						.isEqualTo(MockDatabaseInitializerDetector.class.getName());
					assertThat(bravo.getAttribute(DatabaseInitializerDetector.class.getName())).isNull();
					then(MockDatabaseInitializerDetector.instance).should()
						.detectionComplete(context.getBeanFactory(), Collections.singleton('alpha'));
					assertThat(bravo.getDependsOn()).containsExactly('alpha');
				});
	}
	@Test
	void whenDependenciesAreConfiguredDetectedDatabaseInitializersAreInitializedInCorrectOrder() {
		BeanDefinition alpha = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
		BeanDefinition bravo1 = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
		BeanDefinition bravo2 = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
		BeanDefinition charlie = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
		BeanDefinition delta = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
		performDetection(
				Arrays.asList(MockDatabaseInitializerDetector.class, OrderedLowestMockDatabaseInitializerDetector.class,
						OrderedNearLowestMockDatabaseInitializerDetector.class,
						MockedDependsOnDatabaseInitializationDetector.class),
				(context) -> {
					given(MockDatabaseInitializerDetector.instance.detect(context.getBeanFactory()))
						.willReturn(Collections.singleton('alpha'));
					given(OrderedNearLowestMockDatabaseInitializerDetector.instance.detect(context.getBeanFactory()))
						.willReturn(new LinkedHashSet<>(Arrays.asList('bravo1', 'bravo2')));
					given(OrderedLowestMockDatabaseInitializerDetector.instance.detect(context.getBeanFactory()))
						.willReturn(new LinkedHashSet<>(Arrays.asList('charlie')));
					given(MockedDependsOnDatabaseInitializationDetector.instance.detect(context.getBeanFactory()))
						.willReturn(Collections.singleton('delta'));
					context.registerBeanDefinition('alpha', alpha);
					context.registerBeanDefinition('bravo1', bravo1);
					context.registerBeanDefinition('bravo2', bravo2);
					context.registerBeanDefinition('charlie', charlie);
					context.registerBeanDefinition('delta', delta);
					context.register(DependencyConfigurerConfiguration.class);
					context.refresh();
					assertThat(delta.getDependsOn()).containsExactlyInAnyOrder('alpha', 'bravo1', 'bravo2', 'charlie');
					assertThat(charlie.getDependsOn()).containsExactly('bravo1', 'bravo2');
					assertThat(bravo1.getDependsOn()).containsExactly('alpha');
					assertThat(bravo2.getDependsOn()).containsExactly('alpha');
					assertThat(alpha.getDependsOn()).isNullOrEmpty();
				});
	}
	@Test
	void whenInAnAotProcessedContextDependsOnDatabaseInitializationPostProcessorDoesNothing() {
		withAotEnabled(() -> {
			BeanDefinition alpha = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
			BeanDefinition bravo = BeanDefinitionBuilder.rootBeanDefinition(String.class).getBeanDefinition();
			performDetection(Arrays.asList(MockDatabaseInitializerDetector.class,
					MockedDependsOnDatabaseInitializationDetector.class), (context) -> {
						context.registerBeanDefinition('alpha', alpha);
						context.registerBeanDefinition('bravo', bravo);
						context.register(DependencyConfigurerConfiguration.class);
						context.refresh();
						assertThat(alpha.getAttribute(DatabaseInitializerDetector.class.getName())).isNull();
						assertThat(bravo.getAttribute(DatabaseInitializerDetector.class.getName())).isNull();
						then(MockDatabaseInitializerDetector.instance).shouldHaveNoInteractions();
						assertThat(bravo.getDependsOn()).isNull();
					});
		});
	}
	private void withAotEnabled(Runnable action) {
		System.setProperty('spring.aot.enabled', 'true');
		try {
			action.run();
		}
		finally {
			System.clearProperty('spring.aot.enabled');
		}
	}
	private void performDetection(Collection<Class<?>> detectors,
			Consumer<AnnotationConfigApplicationContext> contextCallback) {
		DetectorSpringFactoriesClassLoader detectorSpringFactories = new DetectorSpringFactoriesClassLoader(this.temp);
		detectors.forEach(detectorSpringFactories::register);
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			context.setEnvironment(this.environment);
			context.setClassLoader(detectorSpringFactories);
			contextCallback.accept(context);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(DatabaseInitializationDependencyConfigurer.class)
	static class DependencyConfigurerConfiguration {
	}
	static class ConstructorInjectionDatabaseInitializerDetector implements DatabaseInitializerDetector {
		private static Environment environment;
		ConstructorInjectionDatabaseInitializerDetector(Environment environment) {
			ConstructorInjectionDatabaseInitializerDetector.environment = environment;
		}
		@Override
		public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
			return Collections.singleton('alpha');
		}
	}
	static class ConstructorInjectionDependsOnDatabaseInitializationDetector
			implements DependsOnDatabaseInitializationDetector {
		private static Environment environment;
		ConstructorInjectionDependsOnDatabaseInitializationDetector(Environment environment) {
			ConstructorInjectionDependsOnDatabaseInitializationDetector.environment = environment;
		}
		@Override
		public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
			return Collections.emptySet();
		}
	}
	static class MockDatabaseInitializerDetector implements DatabaseInitializerDetector {
		private static final DatabaseInitializerDetector instance = mock(DatabaseInitializerDetector.class);
		@Override
		public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
			return instance.detect(beanFactory);
		}
		@Override
		public void detectionComplete(ConfigurableListableBeanFactory beanFactory,
				Set<String> databaseInitializerNames) {
			instance.detectionComplete(beanFactory, databaseInitializerNames);
		}
	}
	static class OrderedLowestMockDatabaseInitializerDetector implements DatabaseInitializerDetector {
		private static final DatabaseInitializerDetector instance = mock(DatabaseInitializerDetector.class);
		@Override
		public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
			return instance.detect(beanFactory);
		}
		@Override
		public int getOrder() {
			return Ordered.LOWEST_PRECEDENCE;
		}
	}
	static class OrderedNearLowestMockDatabaseInitializerDetector implements DatabaseInitializerDetector {
		private static final DatabaseInitializerDetector instance = mock(DatabaseInitializerDetector.class);
		@Override
		public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
			return instance.detect(beanFactory);
		}
		@Override
		public int getOrder() {
			return Ordered.LOWEST_PRECEDENCE - 100;
		}
	}
	static class MockedDependsOnDatabaseInitializationDetector implements DependsOnDatabaseInitializationDetector {
		private static final DependsOnDatabaseInitializationDetector instance = mock(
				DependsOnDatabaseInitializationDetector.class);
		@Override
		public Set<String> detect(ConfigurableListableBeanFactory beanFactory) {
			return instance.detect(beanFactory);
		}
	}
	static class DetectorSpringFactoriesClassLoader extends ClassLoader {
		private final Set<Class<DatabaseInitializerDetector>> databaseInitializerDetectors = new HashSet<>();
		private final Set<Class<DependsOnDatabaseInitializationDetector>> dependsOnDatabaseInitializationDetectors = new HashSet<>();
		private final File temp;
		DetectorSpringFactoriesClassLoader(File temp) {
			this.temp = temp;
		}
		@SuppressWarnings('unchecked')
		void register(Class<?> detector) {
			if (DatabaseInitializerDetector.class.isAssignableFrom(detector)) {
				this.databaseInitializerDetectors.add((Class<DatabaseInitializerDetector>) detector);
			}
			else if (DependsOnDatabaseInitializationDetector.class.isAssignableFrom(detector)) {
				this.dependsOnDatabaseInitializationDetectors
					.add((Class<DependsOnDatabaseInitializationDetector>) detector);
			}
			else {
				throw new IllegalArgumentException('Unsupported detector type "' + detector.getName() + '"');
			}
		}
		@Override
		public Enumeration<URL> getResources(String name) throws IOException {
			if (!'META-INF/spring.factories'.equals(name)) {
				return super.findResources(name);
			}
			Properties properties = new Properties();
			properties.put(DatabaseInitializerDetector.class.getName(),
					String.join(',', this.databaseInitializerDetectors.stream().map(Class::getName).toList()));
			properties.put(DependsOnDatabaseInitializationDetector.class.getName(), String.join(',',
					this.dependsOnDatabaseInitializationDetectors.stream().map(Class::getName).toList()));
			File springFactories = new File(this.temp, 'spring.factories');
			try (FileWriter writer = new FileWriter(springFactories)) {
				properties.store(writer, '');
			}
			return Collections.enumeration(Collections.singleton(springFactories.toURI().toURL()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DependsOnCaptor {
		static final Map<String, List<String>> dependsOn = new HashMap<>();
		@Bean
		static BeanFactoryPostProcessor dependsOnCapturingPostProcessor() {
			return (beanFactory) -> {
				dependsOn.clear();
				for (String name : beanFactory.getBeanDefinitionNames()) {
					storeDependsOn(name, beanFactory);
				}
			};
		}
		private static void storeDependsOn(String name, ConfigurableListableBeanFactory beanFactory) {
			String[] dependsOn = beanFactory.getBeanDefinition(name).getDependsOn();
			if (dependsOn != null) {
				DependsOnCaptor.dependsOn.put(name, Arrays.asList(dependsOn));
			}
		}
	}
}
/*
package org.springframework.boot;
/**
class SpringApplicationBannerPrinterTests {
	@Test
	void shouldRegisterRuntimeHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new SpringApplicationBannerPrinter.SpringApplicationBannerPrinterRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('banner.txt')).accepts(runtimeHints);
	}
	@Test
	void shouldUseUtf8() {
		ResourceLoader resourceLoader = new GenericApplicationContext();
		Resource resource = resourceLoader.getResource('classpath:/banner-utf8.txt');
		SpringApplicationBannerPrinter printer = new SpringApplicationBannerPrinter(resourceLoader,
				new ResourceBanner(resource));
		Log log = mock(Log.class);
		printer.print(new MockEnvironment(), SpringApplicationBannerPrinterTests.class, log);
		ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
		then(log).should().info(captor.capture());
		assertThat(captor.getValue()).isEqualToIgnoringNewLines('\uD83D\uDE0D Spring Boot! \uD83D\uDE0D');
	}
}
/*
package org.springframework.boot;
/**
@ExtendWith(MockitoExtension.class)
class DefaultPropertiesPropertySourceTests {
	@Mock
	private Consumer<DefaultPropertiesPropertySource> action;
	@Test
	void nameIsDefaultProperties() {
		assertThat(DefaultPropertiesPropertySource.NAME).isEqualTo('defaultProperties');
	}
	@Test
	void createCreatesSource() {
		DefaultPropertiesPropertySource propertySource = new DefaultPropertiesPropertySource(
				Collections.singletonMap('spring', 'boot'));
		assertThat(propertySource.getName()).isEqualTo('defaultProperties');
		assertThat(propertySource.getProperty('spring')).isEqualTo('boot');
	}
	@Test
	void hasMatchingNameWhenNameMatchesReturnsTrue() {
		MockPropertySource propertySource = new MockPropertySource('defaultProperties');
		assertThat(DefaultPropertiesPropertySource.hasMatchingName(propertySource)).isTrue();
	}
	@Test
	void hasMatchingNameWhenNameDoesNotMatchReturnsFalse() {
		MockPropertySource propertySource = new MockPropertySource('normalProperties');
		assertThat(DefaultPropertiesPropertySource.hasMatchingName(propertySource)).isFalse();
	}
	@Test
	void hasMatchingNameWhenPropertySourceIsNullReturnsFalse() {
		assertThat(DefaultPropertiesPropertySource.hasMatchingName(null)).isFalse();
	}
	@Test
	void ifNotEmptyWhenNullDoesNotCallAction() {
		DefaultPropertiesPropertySource.ifNotEmpty(null, this.action);
		then(this.action).shouldHaveNoInteractions();
	}
	@Test
	void ifNotEmptyWhenEmptyDoesNotCallAction() {
		DefaultPropertiesPropertySource.ifNotEmpty(Collections.emptyMap(), this.action);
		then(this.action).shouldHaveNoInteractions();
	}
	@Test
	void ifNotEmptyHasValueCallsAction() {
		DefaultPropertiesPropertySource.ifNotEmpty(Collections.singletonMap('spring', 'boot'), this.action);
		then(this.action).should()
			.accept(assertArg((properties) -> assertThat(properties.getProperty('spring')).isEqualTo('boot')));
	}
	@Test
	void moveToEndWhenNotPresentDoesNothing() {
		MockEnvironment environment = new MockEnvironment();
		DefaultPropertiesPropertySource.moveToEnd(environment);
	}
	@Test
	void addOrMergeWhenExistingNotFoundShouldAdd() {
		MockEnvironment environment = new MockEnvironment();
		MutablePropertySources propertySources = environment.getPropertySources();
		DefaultPropertiesPropertySource.addOrMerge(Collections.singletonMap('spring', 'boot'), propertySources);
		assertThat(propertySources.contains(DefaultPropertiesPropertySource.NAME)).isTrue();
		assertThat(propertySources.get(DefaultPropertiesPropertySource.NAME).getProperty('spring')).isEqualTo('boot');
	}
	@Test
	void addOrMergeWhenExistingFoundShouldMerge() {
		MockEnvironment environment = new MockEnvironment();
		MutablePropertySources propertySources = environment.getPropertySources();
		propertySources.addLast(new DefaultPropertiesPropertySource(Collections.singletonMap('spring', 'boot')));
		DefaultPropertiesPropertySource.addOrMerge(Collections.singletonMap('hello', 'world'), propertySources);
		assertThat(propertySources.contains(DefaultPropertiesPropertySource.NAME)).isTrue();
		assertThat(propertySources.get(DefaultPropertiesPropertySource.NAME).getProperty('spring')).isEqualTo('boot');
		assertThat(propertySources.get(DefaultPropertiesPropertySource.NAME).getProperty('hello')).isEqualTo('world');
	}
	@Test
	void addOrMergeWhenExistingNotMapPropertySourceShouldNotMerge() {
		MockEnvironment environment = new MockEnvironment();
		MutablePropertySources propertySources = environment.getPropertySources();
		CompositePropertySource composite = new CompositePropertySource(DefaultPropertiesPropertySource.NAME);
		composite.addPropertySource(new DefaultPropertiesPropertySource(Collections.singletonMap('spring', 'boot')));
		propertySources.addFirst(composite);
		DefaultPropertiesPropertySource.addOrMerge(Collections.singletonMap('hello', 'world'), propertySources);
		assertThat(propertySources.contains(DefaultPropertiesPropertySource.NAME)).isTrue();
		assertThat(propertySources.get(DefaultPropertiesPropertySource.NAME).getProperty('spring')).isNull();
		assertThat(propertySources.get(DefaultPropertiesPropertySource.NAME).getProperty('hello')).isEqualTo('world');
	}
	@Test
	void moveToEndWhenPresentMovesToEnd() {
		MockEnvironment environment = new MockEnvironment();
		MutablePropertySources propertySources = environment.getPropertySources();
		propertySources.addLast(new DefaultPropertiesPropertySource(Collections.singletonMap('spring', 'boot')));
		propertySources.addLast(new MockPropertySource('test'));
		DefaultPropertiesPropertySource.moveToEnd(environment);
		String[] names = propertySources.stream().map(PropertySource::getName).toArray(String[]::new);
		assertThat(names).containsExactly(MockPropertySource.MOCK_PROPERTIES_PROPERTY_SOURCE_NAME, 'test',
				DefaultPropertiesPropertySource.NAME);
	}
}
/*
package org.springframework.boot.security.servlet;
/**
class ApplicationContextRequestMatcherTests {
	@Test
	void createWhenContextClassIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TestApplicationContextRequestMatcher<>(null))
			.withMessageContaining('Context class must not be null');
	}
	@Test
	void matchesWhenContextClassIsApplicationContextShouldProvideContext() {
		StaticWebApplicationContext context = createWebApplicationContext();
		assertThat(new TestApplicationContextRequestMatcher<>(ApplicationContext.class)
			.callMatchesAndReturnProvidedContext(context)
			.get()).isEqualTo(context);
	}
	@Test
	void matchesWhenContextClassIsExistingBeanShouldProvideBean() {
		StaticWebApplicationContext context = createWebApplicationContext();
		context.registerSingleton('existingBean', ExistingBean.class);
		assertThat(new TestApplicationContextRequestMatcher<>(ExistingBean.class)
			.callMatchesAndReturnProvidedContext(context)
			.get()).isEqualTo(context.getBean(ExistingBean.class));
	}
	@Test
	void matchesWhenContextClassIsBeanThatDoesNotExistShouldSupplyException() {
		StaticWebApplicationContext context = createWebApplicationContext();
		Supplier<ExistingBean> supplier = new TestApplicationContextRequestMatcher<>(ExistingBean.class)
			.callMatchesAndReturnProvidedContext(context);
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class).isThrownBy(supplier::get);
	}
	@Test // gh-18012
	void matchesWhenCalledWithDifferentApplicationContextDoesNotCache() {
		StaticWebApplicationContext context1 = createWebApplicationContext();
		StaticWebApplicationContext context2 = createWebApplicationContext();
		TestApplicationContextRequestMatcher<ApplicationContext> matcher = new TestApplicationContextRequestMatcher<>(
				ApplicationContext.class);
		assertThat(matcher.callMatchesAndReturnProvidedContext(context1).get()).isEqualTo(context1);
		assertThat(matcher.callMatchesAndReturnProvidedContext(context2).get()).isEqualTo(context2);
	}
	@Test
	void initializeAndMatchesAreNotCalledIfContextIsIgnored() {
		StaticWebApplicationContext context = createWebApplicationContext();
		TestApplicationContextRequestMatcher<ApplicationContext> matcher = new TestApplicationContextRequestMatcher<>(
				ApplicationContext.class) {
			@Override
			protected boolean ignoreApplicationContext(WebApplicationContext webApplicationContext) {
				return true;
			}
			@Override
			protected void initialized(Supplier<ApplicationContext> context) {
				throw new IllegalStateException();
			}
			@Override
			protected boolean matches(HttpServletRequest request, Supplier<ApplicationContext> context) {
				throw new IllegalStateException();
			}
		};
		MockHttpServletRequest request = new MockHttpServletRequest(context.getServletContext());
		assertThat(matcher.matches(request)).isFalse();
	}
	@Test // gh-18211
	void matchesWhenConcurrentlyCalledWaitsForInitialize() {
		ConcurrentApplicationContextRequestMatcher matcher = new ConcurrentApplicationContextRequestMatcher();
		StaticWebApplicationContext context = createWebApplicationContext();
		Runnable target = () -> matcher.matches(new MockHttpServletRequest(context.getServletContext()));
		List<Thread> threads = new ArrayList<>();
		AssertingUncaughtExceptionHandler exceptionHandler = new AssertingUncaughtExceptionHandler();
		for (int i = 0; i < 2; i++) {
			Thread thread = new Thread(target);
			thread.setUncaughtExceptionHandler(exceptionHandler);
			threads.add(thread);
		}
		threads.forEach(Thread::start);
		threads.forEach(this::join);
		exceptionHandler.assertNoExceptions();
	}
	private void join(Thread thread) {
		try {
			thread.join(1000);
		}
		catch (InterruptedException ex) {
			// Ignore
		}
	}
	private StaticWebApplicationContext createWebApplicationContext() {
		StaticWebApplicationContext context = new StaticWebApplicationContext();
		MockServletContext servletContext = new MockServletContext();
		context.setServletContext(servletContext);
		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
		return context;
	}
	static class ExistingBean {
	}
	static class NewBean {
		private final ExistingBean bean;
		NewBean(ExistingBean bean) {
			this.bean = bean;
		}
		ExistingBean getBean() {
			return this.bean;
		}
	}
	static class TestApplicationContextRequestMatcher<C> extends ApplicationContextRequestMatcher<C> {
		private Supplier<C> providedContext;
		TestApplicationContextRequestMatcher(Class<? extends C> context) {
			super(context);
		}
		Supplier<C> callMatchesAndReturnProvidedContext(WebApplicationContext context) {
			return callMatchesAndReturnProvidedContext(new MockHttpServletRequest(context.getServletContext()));
		}
		Supplier<C> callMatchesAndReturnProvidedContext(HttpServletRequest request) {
			matches(request);
			return getProvidedContext();
		}
		@Override
		protected boolean matches(HttpServletRequest request, Supplier<C> context) {
			this.providedContext = context;
			return false;
		}
		Supplier<C> getProvidedContext() {
			return this.providedContext;
		}
	}
	static class ConcurrentApplicationContextRequestMatcher extends ApplicationContextRequestMatcher<Object> {
		ConcurrentApplicationContextRequestMatcher() {
			super(Object.class);
		}
		private final AtomicBoolean initialized = new AtomicBoolean();
		@Override
		protected void initialized(Supplier<Object> context) {
			try {
				Thread.sleep(200);
			}
			catch (InterruptedException ex) {
				// Ignore
			}
			this.initialized.set(true);
		}
		@Override
		protected boolean matches(HttpServletRequest request, Supplier<Object> context) {
			assertThat(this.initialized.get()).isTrue();
			return true;
		}
	}
	private static final class AssertingUncaughtExceptionHandler implements UncaughtExceptionHandler {
		private volatile Throwable ex;
		@Override
		public void uncaughtException(Thread thread, Throwable ex) {
			this.ex = ex;
		}
		void assertNoExceptions() {
			if (this.ex != null) {
				ReflectionUtils.rethrowRuntimeException(this.ex);
			}
		}
	}
}
/*
package org.springframework.boot.security.reactive;
/**
class ApplicationContextServerWebExchangeMatcherTests {
	@Test
	void createWhenContextClassIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestApplicationContextServerWebExchangeMatcher<>(null))
			.withMessageContaining('Context class must not be null');
	}
	@Test
	void matchesWhenContextClassIsApplicationContextShouldProvideContext() {
		ServerWebExchange exchange = createExchange();
		StaticApplicationContext context = (StaticApplicationContext) exchange.getApplicationContext();
		assertThat(new TestApplicationContextServerWebExchangeMatcher<>(ApplicationContext.class)
			.callMatchesAndReturnProvidedContext(exchange)
			.get()).isEqualTo(context);
	}
	@Test
	void matchesWhenContextClassIsExistingBeanShouldProvideBean() {
		ServerWebExchange exchange = createExchange();
		StaticApplicationContext context = (StaticApplicationContext) exchange.getApplicationContext();
		context.registerSingleton('existingBean', ExistingBean.class);
		assertThat(new TestApplicationContextServerWebExchangeMatcher<>(ExistingBean.class)
			.callMatchesAndReturnProvidedContext(exchange)
			.get()).isEqualTo(context.getBean(ExistingBean.class));
	}
	@Test
	void matchesWhenContextClassIsMissingBeanShouldProvideException() {
		ServerWebExchange exchange = createExchange();
		Supplier<ExistingBean> supplier = new TestApplicationContextServerWebExchangeMatcher<>(ExistingBean.class)
			.callMatchesAndReturnProvidedContext(exchange);
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class).isThrownBy(supplier::get);
	}
	@Test
	void matchesWhenContextIsNull() {
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get('/path').build());
		assertThatIllegalStateException()
			.isThrownBy(() -> new TestApplicationContextServerWebExchangeMatcher<>(ExistingBean.class)
				.callMatchesAndReturnProvidedContext(exchange))
			.withMessageContaining('No ApplicationContext found on ServerWebExchange.');
	}
	private ServerWebExchange createExchange() {
		StaticApplicationContext context = new StaticApplicationContext();
		TestHttpWebHandlerAdapter adapter = new TestHttpWebHandlerAdapter(mock(WebHandler.class));
		adapter.setApplicationContext(context);
		return adapter.createExchange(MockServerHttpRequest.get('/path').build(), new MockServerHttpResponse());
	}
	static class TestHttpWebHandlerAdapter extends HttpWebHandlerAdapter {
		TestHttpWebHandlerAdapter(WebHandler delegate) {
			super(delegate);
		}
		@Override
		protected ServerWebExchange createExchange(ServerHttpRequest request, ServerHttpResponse response) {
			return super.createExchange(request, response);
		}
	}
	static class ExistingBean {
	}
	static class NewBean {
		private final ExistingBean bean;
		NewBean(ExistingBean bean) {
			this.bean = bean;
		}
		ExistingBean getBean() {
			return this.bean;
		}
	}
	static class TestApplicationContextServerWebExchangeMatcher<C>
			extends ApplicationContextServerWebExchangeMatcher<C> {
		private Supplier<C> providedContext;
		TestApplicationContextServerWebExchangeMatcher(Class<? extends C> context) {
			super(context);
		}
		Supplier<C> callMatchesAndReturnProvidedContext(ServerWebExchange exchange) {
			matches(exchange);
			return getProvidedContext();
		}
		@Override
		protected Mono<MatchResult> matches(ServerWebExchange exchange, Supplier<C> context) {
			this.providedContext = context;
			return MatchResult.match();
		}
		Supplier<C> getProvidedContext() {
			return this.providedContext;
		}
	}
}
/*
package org.springframework.boot.type.classreading;
/**
class ConcurrentReferenceCachingMetadataReaderFactoryTests {
	@Test
	void getMetadataReaderUsesCache() throws Exception {
		TestConcurrentReferenceCachingMetadataReaderFactory factory = spy(
				new TestConcurrentReferenceCachingMetadataReaderFactory());
		MetadataReader metadataReader1 = factory.getMetadataReader(getClass().getName());
		MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName());
		assertThat(metadataReader1).isSameAs(metadataReader2);
		then(factory).should().createMetadataReader(any(Resource.class));
	}
	@Test
	void clearResetsCache() throws Exception {
		TestConcurrentReferenceCachingMetadataReaderFactory factory = spy(
				new TestConcurrentReferenceCachingMetadataReaderFactory());
		MetadataReader metadataReader1 = factory.getMetadataReader(getClass().getName());
		factory.clearCache();
		MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName());
		assertThat(metadataReader1).isNotSameAs(metadataReader2);
		then(factory).should(times(2)).createMetadataReader(any(Resource.class));
	}
	static class TestConcurrentReferenceCachingMetadataReaderFactory
			extends ConcurrentReferenceCachingMetadataReaderFactory {
		@Override
		public MetadataReader createMetadataReader(Resource resource) {
			return mock(MetadataReader.class);
		}
	}
}
/*
package org.springframework.boot.ansi;
/**
public final class AnsiOutputEnabledValue {
	private AnsiOutputEnabledValue() {
	}
	public static Enabled get() {
		return AnsiOutput.getEnabled();
	}
}
/*
package org.springframework.boot.ansi;
/**
class AnsiOutputTests {
	@BeforeAll
	static void enable() {
		AnsiOutput.setEnabled(Enabled.ALWAYS);
	}
	@AfterAll
	static void reset() {
		AnsiOutput.setEnabled(Enabled.DETECT);
	}
	@Test
	void encoding() {
		String encoded = AnsiOutput.toString('A', AnsiColor.RED, AnsiStyle.BOLD, 'B', AnsiStyle.NORMAL, 'D',
				AnsiColor.GREEN, 'E', AnsiStyle.FAINT, 'F');
		assertThat(encoded).isEqualTo('A[31;1mB[0mD[32mE[2mF[0;39m');
	}
}
/*
package org.springframework.boot.ansi;
/**
class Ansi8BitColorTests {
	@Test
	void toStringWhenForegroundAddsCorrectPrefix() {
		assertThat(Ansi8BitColor.foreground(208)).hasToString('38;5;208');
	}
	@Test
	void toStringWhenBackgroundAddsCorrectPrefix() {
		assertThat(Ansi8BitColor.background(208)).hasToString('48;5;208');
	}
	@Test
	void foregroundWhenOutsideBoundsThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Ansi8BitColor.foreground(-1))
			.withMessage('Code must be between 0 and 255');
		assertThatIllegalArgumentException().isThrownBy(() -> Ansi8BitColor.foreground(256))
			.withMessage('Code must be between 0 and 255');
	}
	@Test
	void backgroundWhenOutsideBoundsThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Ansi8BitColor.background(-1))
			.withMessage('Code must be between 0 and 255');
		assertThatIllegalArgumentException().isThrownBy(() -> Ansi8BitColor.background(256))
			.withMessage('Code must be between 0 and 255');
	}
	@Test
	void equalsAndHashCode() {
		Ansi8BitColor one = Ansi8BitColor.foreground(123);
		Ansi8BitColor two = Ansi8BitColor.foreground(123);
		Ansi8BitColor three = Ansi8BitColor.background(123);
		assertThat(one).hasSameHashCodeAs(two);
		assertThat(one).isEqualTo(one).isEqualTo(two).isNotEqualTo(three).isNotNull().isNotEqualTo('foo');
	}
}
/*
package org.springframework.boot.ansi;
/**
class AnsiPropertySourceTests {
	private final AnsiPropertySource source = new AnsiPropertySource('ansi', false);
	@AfterEach
	void reset() {
		AnsiOutput.setEnabled(Enabled.DETECT);
	}
	@Test
	void getAnsiStyle() {
		assertThat(this.source.getProperty('AnsiStyle.BOLD')).isEqualTo(AnsiStyle.BOLD);
	}
	@Test
	void getAnsiColor() {
		assertThat(this.source.getProperty('AnsiColor.RED')).isEqualTo(AnsiColor.RED);
		assertThat(this.source.getProperty('AnsiColor.100')).isEqualTo(Ansi8BitColor.foreground(100));
	}
	@Test
	void getAnsiBackground() {
		assertThat(this.source.getProperty('AnsiBackground.GREEN')).isEqualTo(AnsiBackground.GREEN);
		assertThat(this.source.getProperty('AnsiBackground.100')).isEqualTo(Ansi8BitColor.background(100));
	}
	@Test
	void getAnsi() {
		assertThat(this.source.getProperty('Ansi.BOLD')).isEqualTo(AnsiStyle.BOLD);
		assertThat(this.source.getProperty('Ansi.RED')).isEqualTo(AnsiColor.RED);
		assertThat(this.source.getProperty('Ansi.BG_RED')).isEqualTo(AnsiBackground.RED);
	}
	@Test
	void getMissing() {
		assertThat(this.source.getProperty('AnsiStyle.NOPE')).isNull();
	}
	@Test
	void encodeEnabled() {
		AnsiOutput.setEnabled(Enabled.ALWAYS);
		AnsiPropertySource source = new AnsiPropertySource('ansi', true);
		assertThat(source.getProperty('Ansi.RED')).isEqualTo('\033[31m');
		assertThat(source.getProperty('AnsiColor.100')).isEqualTo('\033[38;5;100m');
		assertThat(source.getProperty('AnsiBackground.100')).isEqualTo('\033[48;5;100m');
	}
	@Test
	void encodeDisabled() {
		AnsiOutput.setEnabled(Enabled.NEVER);
		AnsiPropertySource source = new AnsiPropertySource('ansi', true);
		assertThat(source.getProperty('Ansi.RED')).isEqualTo('');
		assertThat(source.getProperty('AnsiColor.100')).isEqualTo('');
		assertThat(source.getProperty('AnsiBackground.100')).isEqualTo('');
	}
}
/*
package org.springframework.boot.reactor;
/**
@Disabled('Tests rely on static initialization and are flaky on CI')
class ReactorEnvironmentPostProcessorTests {
	static {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.threads.virtual.enabled', 'true');
		ReactorEnvironmentPostProcessor postProcessor = new ReactorEnvironmentPostProcessor();
		postProcessor.postProcessEnvironment(environment, null);
	}
	@Test
	void enablesReactorDebugAgent() {
		InstrumentedFluxProvider fluxProvider = new InstrumentedFluxProvider();
		Flux<Integer> flux = fluxProvider.newFluxJust();
		assertThat(Scannable.from(flux).stepName())
			.startsWith('Flux.just  at org.springframework.boot.reactor.InstrumentedFluxProvider.newFluxJust');
	}
	@Test
	@EnabledForJreRange(max = JRE.JAVA_20)
	void shouldNotEnableVirtualThreads() {
		assertThat(System.getProperty('reactor.schedulers.defaultBoundedElasticOnVirtualThreads')).isNotEqualTo('true');
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldEnableVirtualThreads() {
		assertThat(System.getProperty('reactor.schedulers.defaultBoundedElasticOnVirtualThreads')).isEqualTo('true');
	}
	@AfterEach
	void cleanup() {
		System.setProperty('reactor.schedulers.defaultBoundedElasticOnVirtualThreads', 'false');
	}
}
/*
package org.springframework.boot.reactor;
/**
class InstrumentedFluxProvider {
	Flux<Integer> newFluxJust() {
		return Flux.just(1);
	}
}
/*
package org.springframework.boot;
/**
@ExtendWith(OutputCaptureExtension.class)
class SpringApplicationTests {
	private String headlessProperty;
	private ConfigurableApplicationContext context;
	private Environment getEnvironment() {
		if (this.context != null) {
			return this.context.getEnvironment();
		}
		throw new IllegalStateException('Could not obtain Environment');
	}
	@BeforeEach
	void storeAndClearHeadlessProperty() {
		this.headlessProperty = System.getProperty('java.awt.headless');
		System.clearProperty('java.awt.headless');
	}
	@AfterEach
	void reinstateHeadlessProperty() {
		if (this.headlessProperty == null) {
			System.clearProperty('java.awt.headless');
		}
		else {
			System.setProperty('java.awt.headless', this.headlessProperty);
		}
	}
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
		System.clearProperty('spring.main.banner-mode');
		SpringApplicationShutdownHookInstance.reset();
	}
	@Test
	void sourcesMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new SpringApplication((Class<?>[]) null).run())
			.withMessageContaining('PrimarySources must not be null');
	}
	@Test
	void sourcesMustNotBeEmpty() {
		assertThatIllegalArgumentException().isThrownBy(() -> new SpringApplication().run())
			.withMessageContaining('Sources must not be empty');
	}
	@Test
	void sourcesMustBeAccessible() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new SpringApplication(InaccessibleConfiguration.class).run())
			.withMessageContaining('No visible constructors');
	}
	@Test
	void customBanner(CapturedOutput output) {
		SpringApplication application = spy(new SpringApplication(ExampleConfig.class));
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.banner.location=classpath:test-banner.txt');
		assertThat(output).startsWith('Running a Test!');
	}
	@Test
	void customBannerWithProperties(CapturedOutput output) {
		SpringApplication application = spy(new SpringApplication(ExampleConfig.class));
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.banner.location=classpath:test-banner-with-placeholder.txt',
				'--test.property=123456');
		assertThat(output).containsPattern('Running a Test!\\s+123456');
	}
	@Test
	void logsActiveProfilesWithoutProfileAndSingleDefault(CapturedOutput output) {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(output).contains('No active profile set, falling back to 1 default profile: \'default\'');
	}
	@Test
	void logsActiveProfilesWithoutProfileAndMultipleDefaults(CapturedOutput output) {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('p0,p1', 'default');
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setEnvironment(environment);
		this.context = application.run();
		assertThat(output)
			.contains('No active profile set, falling back to 2 default profiles: \'p0,p1\', \'default\'');
	}
	@Test
	void logsActiveProfilesWithSingleProfile(CapturedOutput output) {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.profiles.active=myprofiles');
		assertThat(output).contains('The following 1 profile is active: \'myprofiles\'');
	}
	@Test
	void logsActiveProfilesWithMultipleProfiles(CapturedOutput output) {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setAdditionalProfiles('p1,p2', 'p3');
		application.run();
		assertThat(output).contains('The following 2 profiles are active: \'p1,p2\', \'p3\'');
	}
	@Test
	void enableBannerInLogViaProperty(CapturedOutput output) {
		SpringApplication application = spy(new SpringApplication(ExampleConfig.class));
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.main.banner-mode=log');
		assertThatBannerModeIs(application, Banner.Mode.LOG);
		assertThat(output).contains('o.s.b.SpringApplication');
	}
	@Test
	void triggersConfigFileApplicationListenerBeforeBinding() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.config.name=bindtoapplication');
		assertThatBannerModeIs(application, Mode.OFF);
	}
	@Test
	void bindsSystemPropertyToSpringApplication() {
		System.setProperty('spring.main.banner-mode', 'off');
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThatBannerModeIs(application, Mode.OFF);
	}
	@Test
	void bindsYamlStyleBannerModeToSpringApplication() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setDefaultProperties(Collections.singletonMap('spring.main.banner-mode', false));
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThatBannerModeIs(application, Mode.OFF);
	}
	@Test
	void bindsBooleanAsStringBannerModeToSpringApplication() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.main.banner-mode=false');
		assertThatBannerModeIs(application, Mode.OFF);
	}
	@Test
	void customId() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.application.name=foo');
		assertThat(this.context.getId()).startsWith('foo');
	}
	@Test
	void specificApplicationContextFactory() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application
			.setApplicationContextFactory(ApplicationContextFactory.ofContextClass(StaticApplicationContext.class));
		this.context = application.run();
		assertThat(this.context).isInstanceOf(StaticApplicationContext.class);
	}
	@Test
	void specificApplicationContextInitializer() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		final AtomicReference<ApplicationContext> reference = new AtomicReference<>();
		application.setInitializers(Collections
			.singletonList((ApplicationContextInitializer<ConfigurableApplicationContext>) reference::set));
		this.context = application.run('--foo=bar');
		assertThat(this.context).isSameAs(reference.get());
		// Custom initializers do not switch off the defaults
		assertThat(getEnvironment().getProperty('foo')).isEqualTo('bar');
	}
	@Test
	void applicationRunningEventListener() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		AtomicReference<ApplicationReadyEvent> reference = addListener(application, ApplicationReadyEvent.class);
		this.context = application.run('--foo=bar');
		assertThat(application).isSameAs(reference.get().getSpringApplication());
	}
	@Test
	void contextRefreshedEventListener() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		AtomicReference<ContextRefreshedEvent> reference = addListener(application, ContextRefreshedEvent.class);
		this.context = application.run('--foo=bar');
		assertThat(this.context).isSameAs(reference.get().getApplicationContext());
		// Custom initializers do not switch off the defaults
		assertThat(getEnvironment().getProperty('foo')).isEqualTo('bar');
	}
	@Test
	@SuppressWarnings('unchecked')
	void eventsArePublishedInExpectedOrder() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ApplicationListener<ApplicationEvent> listener = mock(ApplicationListener.class);
		application.addListeners(listener);
		this.context = application.run();
		InOrder inOrder = Mockito.inOrder(listener);
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationStartingEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationEnvironmentPreparedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationContextInitializedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationPreparedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ContextRefreshedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationStartedEvent.class));
		then(listener).should(inOrder)
			.onApplicationEvent(argThat(isAvailabilityChangeEventWithState(LivenessState.CORRECT)));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationReadyEvent.class));
		then(listener).should(inOrder)
			.onApplicationEvent(argThat(isAvailabilityChangeEventWithState(ReadinessState.ACCEPTING_TRAFFIC)));
		inOrder.verifyNoMoreInteractions();
	}
	@Test
	void applicationStartedEventHasStartedTime() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		AtomicReference<ApplicationStartedEvent> reference = addListener(application, ApplicationStartedEvent.class);
		this.context = application.run();
		assertThat(reference.get()).isNotNull().extracting(ApplicationStartedEvent::getTimeTaken).isNotNull();
	}
	@Test
	void applicationReadyEventHasReadyTime() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		AtomicReference<ApplicationReadyEvent> reference = addListener(application, ApplicationReadyEvent.class);
		this.context = application.run();
		assertThat(reference.get()).isNotNull().extracting(ApplicationReadyEvent::getTimeTaken).isNotNull();
	}
	@Test
	void defaultApplicationContext() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context).isInstanceOf(AnnotationConfigApplicationContext.class);
	}
	@Test
	void defaultApplicationContextForWeb() {
		SpringApplication application = new SpringApplication(ExampleWebConfig.class);
		application.setWebApplicationType(WebApplicationType.SERVLET);
		this.context = application.run();
		assertThat(this.context).isInstanceOf(AnnotationConfigServletWebServerApplicationContext.class);
	}
	@Test
	void defaultApplicationContextForReactiveWeb() {
		SpringApplication application = new SpringApplication(ExampleReactiveWebConfig.class);
		application.setWebApplicationType(WebApplicationType.REACTIVE);
		this.context = application.run();
		assertThat(this.context).isInstanceOf(AnnotationConfigReactiveWebServerApplicationContext.class);
	}
	@Test
	void environmentForWeb() {
		SpringApplication application = new SpringApplication(ExampleWebConfig.class);
		application.setWebApplicationType(WebApplicationType.SERVLET);
		this.context = application.run();
		assertThat(this.context.getEnvironment()).isInstanceOf(StandardServletEnvironment.class);
		assertThat(this.context.getEnvironment().getClass().getName()).endsWith('ApplicationServletEnvironment');
	}
	@Test
	void environmentForReactiveWeb() {
		SpringApplication application = new SpringApplication(ExampleReactiveWebConfig.class);
		application.setWebApplicationType(WebApplicationType.REACTIVE);
		this.context = application.run();
		assertThat(this.context.getEnvironment()).isInstanceOf(StandardReactiveWebEnvironment.class);
		assertThat(this.context.getEnvironment().getClass().getName()).endsWith('ApplicationReactiveWebEnvironment');
	}
	@Test
	void customEnvironment() {
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run();
		then(application.getLoader()).should().setEnvironment(environment);
	}
	@Test
	void customResourceLoader() {
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ResourceLoader resourceLoader = new DefaultResourceLoader();
		application.setResourceLoader(resourceLoader);
		this.context = application.run();
		then(application.getLoader()).should().setResourceLoader(resourceLoader);
	}
	@Test
	void customResourceLoaderFromConstructor() {
		ResourceLoader resourceLoader = new DefaultResourceLoader();
		TestSpringApplication application = new TestSpringApplication(resourceLoader, ExampleWebConfig.class);
		this.context = application.run();
		then(application.getLoader()).should().setResourceLoader(resourceLoader);
	}
	@Test
	void customBeanNameGenerator() {
		TestSpringApplication application = new TestSpringApplication(ExampleWebConfig.class);
		BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();
		application.setBeanNameGenerator(beanNameGenerator);
		this.context = application.run();
		then(application.getLoader()).should().setBeanNameGenerator(beanNameGenerator);
		Object actualGenerator = this.context.getBean(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
		assertThat(actualGenerator).isSameAs(beanNameGenerator);
	}
	@Test
	void customBeanNameGeneratorWithNonWebApplication() {
		TestSpringApplication application = new TestSpringApplication(ExampleWebConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();
		application.setBeanNameGenerator(beanNameGenerator);
		this.context = application.run();
		then(application.getLoader()).should().setBeanNameGenerator(beanNameGenerator);
		Object actualGenerator = this.context.getBean(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
		assertThat(actualGenerator).isSameAs(beanNameGenerator);
	}
	@Test
	void commandLinePropertySource() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run('--foo=bar');
		assertThat(environment).has(matchingPropertySource(CommandLinePropertySource.class, 'commandLineArgs'));
	}
	@Test
	void commandLinePropertySourceEnhancesEnvironment() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableEnvironment environment = new StandardEnvironment();
		environment.getPropertySources()
			.addFirst(new MapPropertySource('commandLineArgs', Collections.singletonMap('foo', 'original')));
		application.setEnvironment(environment);
		this.context = application.run('--foo=bar', '--bar=foo');
		assertThat(environment).has(matchingPropertySource(CompositePropertySource.class, 'commandLineArgs'));
		assertThat(environment.getProperty('bar')).isEqualTo('foo');
		// New command line properties take precedence
		assertThat(environment.getProperty('foo')).isEqualTo('bar');
		CompositePropertySource composite = (CompositePropertySource) environment.getPropertySources()
			.get('commandLineArgs');
		assertThat(composite.getPropertySources()).hasSize(2);
		assertThat(composite.getPropertySources()).first()
			.matches((source) -> source.getName().equals('springApplicationCommandLineArgs'),
					'is named springApplicationCommandLineArgs');
		assertThat(composite.getPropertySources()).element(1)
			.matches((source) -> source.getName().equals('commandLineArgs'), 'is named commandLineArgs');
	}
	@Test
	void propertiesFileEnhancesEnvironment() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run();
		assertThat(environment.getProperty('foo')).isEqualTo('bucket');
	}
	@Test
	void addProfiles() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setAdditionalProfiles('foo');
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run();
		assertThat(environment.acceptsProfiles(Profiles.of('foo'))).isTrue();
	}
	@Test
	void additionalProfilesOrderedBeforeActiveProfiles() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setAdditionalProfiles('foo');
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run('--spring.profiles.active=bar,spam');
		assertThat(environment.getActiveProfiles()).containsExactly('foo', 'bar', 'spam');
	}
	@Test
	void addProfilesOrderWithProperties() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setAdditionalProfiles('other');
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run();
		// Active profile should win over default
		assertThat(environment.getProperty('my.property')).isEqualTo('fromotherpropertiesfile');
	}
	@Test
	void emptyCommandLinePropertySourceNotAdded() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run();
		assertThat(environment.getProperty('foo')).isEqualTo('bucket');
	}
	@Test
	void disableCommandLinePropertySource() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setAddCommandLineProperties(false);
		ConfigurableEnvironment environment = new StandardEnvironment();
		application.setEnvironment(environment);
		this.context = application.run('--foo=bar');
		assertThat(environment).doesNotHave(matchingPropertySource(PropertySource.class, 'commandLineArgs'));
	}
	@Test
	void contextUsesApplicationConversionService() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context.getBeanFactory().getConversionService())
			.isInstanceOf(ApplicationConversionService.class);
		assertThat(this.context.getEnvironment().getConversionService())
			.isInstanceOf(ApplicationConversionService.class);
	}
	@Test
	void contextWhenHasAddConversionServiceFalseUsesRegularConversionService() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setAddConversionService(false);
		this.context = application.run();
		assertThat(this.context.getBeanFactory().getConversionService()).isNull();
		assertThat(this.context.getEnvironment().getConversionService())
			.isNotInstanceOf(ApplicationConversionService.class);
	}
	@Test
	void runCommandLineRunnersAndApplicationRunners() {
		SpringApplication application = new SpringApplication(CommandLineRunConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('arg');
		assertThat(this.context).has(runTestRunnerBean('runnerA'));
		assertThat(this.context).has(runTestRunnerBean('runnerB'));
		assertThat(this.context).has(runTestRunnerBean('runnerC'));
	}
	@Test
	void runCommandLineRunnersAndApplicationRunnersWithParentContext() {
		SpringApplication application = new SpringApplication(CommandLineRunConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.addInitializers(new ParentContextApplicationContextInitializer(
				new AnnotationConfigApplicationContext(CommandLineRunParentConfig.class)));
		this.context = application.run('arg');
		assertThat(this.context).has(runTestRunnerBean('runnerA'));
		assertThat(this.context).has(runTestRunnerBean('runnerB'));
		assertThat(this.context).has(runTestRunnerBean('runnerC'));
		assertThat(this.context).doesNotHave(runTestRunnerBean('runnerP'));
	}
	@Test
	void runCommandLineRunnersAndApplicationRunnersUsingOrderOnBeanDefinitions() {
		SpringApplication application = new SpringApplication(BeanDefinitionOrderRunnerConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('arg');
		BeanDefinitionOrderRunnerConfig config = this.context.getBean(BeanDefinitionOrderRunnerConfig.class);
		assertThat(config.runners).containsExactly('runnerA', 'runnerB', 'runnerC');
	}
	@Test
	@SuppressWarnings('unchecked')
	void runnersAreCalledAfterStartedIsLoggedAndBeforeApplicationReadyEventIsPublished(CapturedOutput output)
			throws Exception {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		ApplicationRunner applicationRunner = mock(ApplicationRunner.class);
		CommandLineRunner commandLineRunner = mock(CommandLineRunner.class);
		application.addInitializers((context) -> {
			ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
			beanFactory.registerSingleton('commandLineRunner', (CommandLineRunner) (args) -> {
				assertThat(output).contains('Started');
				commandLineRunner.run(args);
			});
			beanFactory.registerSingleton('applicationRunner', (ApplicationRunner) (args) -> {
				assertThat(output).contains('Started');
				applicationRunner.run(args);
			});
		});
		application.setWebApplicationType(WebApplicationType.NONE);
		ApplicationListener<ApplicationReadyEvent> eventListener = mock(ApplicationListener.class);
		application.addListeners(eventListener);
		this.context = application.run();
		InOrder applicationRunnerOrder = Mockito.inOrder(eventListener, applicationRunner);
		applicationRunnerOrder.verify(applicationRunner).run(any(ApplicationArguments.class));
		applicationRunnerOrder.verify(eventListener).onApplicationEvent(any(ApplicationReadyEvent.class));
		InOrder commandLineRunnerOrder = Mockito.inOrder(eventListener, commandLineRunner);
		commandLineRunnerOrder.verify(commandLineRunner).run();
		commandLineRunnerOrder.verify(eventListener).onApplicationEvent(any(ApplicationReadyEvent.class));
	}
	@Test
	void applicationRunnerFailureCausesApplicationFailedEventToBePublished() throws Exception {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		@SuppressWarnings('unchecked')
		ApplicationListener<SpringApplicationEvent> listener = mock(ApplicationListener.class);
		application.addListeners(listener);
		ApplicationRunner runner = mock(ApplicationRunner.class);
		Exception failure = new Exception();
		willThrow(failure).given(runner).run(isA(ApplicationArguments.class));
		application.addInitializers((context) -> context.getBeanFactory().registerSingleton('runner', runner));
		assertThatIllegalStateException().isThrownBy(application::run).withCause(failure);
		then(listener).should().onApplicationEvent(isA(ApplicationStartedEvent.class));
		then(listener).should().onApplicationEvent(isA(ApplicationFailedEvent.class));
		then(listener).should(never()).onApplicationEvent(isA(ApplicationReadyEvent.class));
	}
	@Test
	void commandLineRunnerFailureCausesApplicationFailedEventToBePublished() throws Exception {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		@SuppressWarnings('unchecked')
		ApplicationListener<SpringApplicationEvent> listener = mock(ApplicationListener.class);
		application.addListeners(listener);
		CommandLineRunner runner = mock(CommandLineRunner.class);
		Exception failure = new Exception();
		willThrow(failure).given(runner).run();
		application.addInitializers((context) -> context.getBeanFactory().registerSingleton('runner', runner));
		assertThatIllegalStateException().isThrownBy(application::run).withCause(failure);
		then(listener).should().onApplicationEvent(isA(ApplicationStartedEvent.class));
		then(listener).should().onApplicationEvent(isA(ApplicationFailedEvent.class));
		then(listener).should(never()).onApplicationEvent(isA(ApplicationReadyEvent.class));
	}
	@Test
	void failureInReadyEventListenerDoesNotCausePublicationOfFailedEvent() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		@SuppressWarnings('unchecked')
		ApplicationListener<SpringApplicationEvent> listener = mock(ApplicationListener.class);
		application.addListeners(listener);
		RuntimeException failure = new RuntimeException();
		willThrow(failure).given(listener).onApplicationEvent(isA(ApplicationReadyEvent.class));
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(application::run).isEqualTo(failure);
		then(listener).should().onApplicationEvent(isA(ApplicationReadyEvent.class));
		then(listener).should(never()).onApplicationEvent(isA(ApplicationFailedEvent.class));
	}
	@Test
	void failureInReadyEventListenerCloseApplicationContext(CapturedOutput output) {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ExitCodeListener exitCodeListener = new ExitCodeListener();
		application.addListeners(exitCodeListener);
		@SuppressWarnings('unchecked')
		ApplicationListener<SpringApplicationEvent> listener = mock(ApplicationListener.class);
		application.addListeners(listener);
		ExitStatusException failure = new ExitStatusException();
		willThrow(failure).given(listener).onApplicationEvent(isA(ApplicationReadyEvent.class));
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(application::run);
		then(listener).should().onApplicationEvent(isA(ApplicationReadyEvent.class));
		then(listener).should(never()).onApplicationEvent(isA(ApplicationFailedEvent.class));
		assertThat(exitCodeListener.getExitCode()).isEqualTo(11);
		assertThat(output).contains('Application run failed');
	}
	@Test
	void failureOnTheJvmLogsApplicationRunFailed(CapturedOutput output) {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		ExitCodeListener exitCodeListener = new ExitCodeListener();
		application.addListeners(exitCodeListener);
		@SuppressWarnings('unchecked')
		ApplicationListener<SpringApplicationEvent> listener = mock(ApplicationListener.class);
		application.addListeners(listener);
		ExitStatusException failure = new ExitStatusException();
		willThrow(failure).given(listener).onApplicationEvent(isA(ApplicationReadyEvent.class));
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(application::run);
		then(listener).should().onApplicationEvent(isA(ApplicationReadyEvent.class));
		then(listener).should(never()).onApplicationEvent(isA(ApplicationFailedEvent.class));
		assertThat(exitCodeListener.getExitCode()).isEqualTo(11);
		// Leading space only happens when logging
		assertThat(output).contains(' Application run failed').contains('ExitStatusException');
	}
	@Test
	@ForkedClassPath
	void failureInANativeImageWritesFailureToSystemOut(CapturedOutput output) {
		System.setProperty('org.graalvm.nativeimage.imagecode', 'true');
		try {
			SpringApplication application = new SpringApplication(ExampleConfig.class);
			application.setWebApplicationType(WebApplicationType.NONE);
			ExitCodeListener exitCodeListener = new ExitCodeListener();
			application.addListeners(exitCodeListener);
			@SuppressWarnings('unchecked')
			ApplicationListener<SpringApplicationEvent> listener = mock(ApplicationListener.class);
			application.addListeners(listener);
			ExitStatusException failure = new ExitStatusException();
			willThrow(failure).given(listener).onApplicationEvent(isA(ApplicationReadyEvent.class));
			assertThatExceptionOfType(RuntimeException.class).isThrownBy(application::run);
			then(listener).should().onApplicationEvent(isA(ApplicationReadyEvent.class));
			then(listener).should(never()).onApplicationEvent(isA(ApplicationFailedEvent.class));
			assertThat(exitCodeListener.getExitCode()).isEqualTo(11);
			// Leading space only happens when logging
			assertThat(output).doesNotContain(' Application run failed')
				.contains('Application run failed')
				.contains('ExitStatusException');
		}
		finally {
			System.clearProperty('org.graalvm.nativeimage.imagecode');
		}
	}
	@Test
	void loadSources() {
		Class<?>[] sources = { ExampleConfig.class, TestCommandLineRunner.class };
		TestSpringApplication application = new TestSpringApplication(sources);
		application.getSources().add('a');
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setUseMockLoader(true);
		this.context = application.run();
		Set<Object> allSources = application.getAllSources();
		assertThat(allSources).contains(ExampleConfig.class, TestCommandLineRunner.class, 'a');
	}
	@Test
	void wildcardSources() {
		TestSpringApplication application = new TestSpringApplication();
		application.getSources().add('classpath*:org/springframework/boot/sample-${sample.app.test.prop}.xml');
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
	}
	@Test
	void run() {
		this.context = SpringApplication.run(ExampleWebConfig.class);
		assertThat(this.context).isNotNull();
	}
	@Test
	void runComponents() {
		this.context = SpringApplication.run(new Class<?>[] { ExampleWebConfig.class, Object.class }, new String[0]);
		assertThat(this.context).isNotNull();
	}
	@Test
	void exit() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context).isNotNull();
		assertThat(SpringApplication.exit(this.context)).isZero();
	}
	@Test
	void exitWithExplicitCode() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		ExitCodeListener listener = new ExitCodeListener();
		application.addListeners(listener);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context).isNotNull();
		assertThat(SpringApplication.exit(this.context, (ExitCodeGenerator) () -> 2)).isEqualTo(2);
		assertThat(listener.getExitCode()).isEqualTo(2);
	}
	@Test
	void exitWithExplicitCodeFromException() {
		final SpringBootExceptionHandler handler = mock(SpringBootExceptionHandler.class);
		SpringApplication application = new SpringApplication(ExitCodeCommandLineRunConfig.class) {
			@Override
			SpringBootExceptionHandler getSpringBootExceptionHandler() {
				return handler;
			}
		};
		ExitCodeListener listener = new ExitCodeListener();
		application.addListeners(listener);
		application.setWebApplicationType(WebApplicationType.NONE);
		assertThatIllegalStateException().isThrownBy(application::run);
		then(handler).should().registerExitCode(11);
		assertThat(listener.getExitCode()).isEqualTo(11);
	}
	@Test
	void exitWithExplicitCodeFromMappedException() {
		final SpringBootExceptionHandler handler = mock(SpringBootExceptionHandler.class);
		SpringApplication application = new SpringApplication(MappedExitCodeCommandLineRunConfig.class) {
			@Override
			SpringBootExceptionHandler getSpringBootExceptionHandler() {
				return handler;
			}
		};
		ExitCodeListener listener = new ExitCodeListener();
		application.addListeners(listener);
		application.setWebApplicationType(WebApplicationType.NONE);
		assertThatIllegalStateException().isThrownBy(application::run);
		then(handler).should().registerExitCode(11);
		assertThat(listener.getExitCode()).isEqualTo(11);
	}
	@Test
	void exceptionFromRefreshIsHandledGracefully(CapturedOutput output) {
		final SpringBootExceptionHandler handler = mock(SpringBootExceptionHandler.class);
		SpringApplication application = new SpringApplication(RefreshFailureConfig.class) {
			@Override
			SpringBootExceptionHandler getSpringBootExceptionHandler() {
				return handler;
			}
		};
		ExitCodeListener listener = new ExitCodeListener();
		application.addListeners(listener);
		application.setWebApplicationType(WebApplicationType.NONE);
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(application::run);
		then(handler).should()
			.registerLoggedException(
					assertArg((exception) -> assertThat(exception).hasCauseInstanceOf(RefreshFailureException.class)));
		assertThat(output).doesNotContain('NullPointerException');
	}
	@Test
	void defaultCommandLineArgs() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setDefaultProperties(
				StringUtils.splitArrayElementsIntoProperties(new String[] { 'baz=', 'bar=spam' }, '='));
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--bar=foo', 'bucket', 'crap');
		assertThat(this.context).isInstanceOf(AnnotationConfigApplicationContext.class);
		assertThat(getEnvironment().getProperty('bar')).isEqualTo('foo');
		assertThat(getEnvironment().getProperty('baz')).isEmpty();
	}
	@Test
	void defaultPropertiesShouldBeMerged() {
		MockEnvironment environment = new MockEnvironment();
		environment.getPropertySources()
			.addFirst(new MapPropertySource(DefaultPropertiesPropertySource.NAME,
					Collections.singletonMap('bar', 'foo')));
		SpringApplication application = new SpringApplicationBuilder(ExampleConfig.class).environment(environment)
			.properties('baz=bing')
			.web(WebApplicationType.NONE)
			.build();
		this.context = application.run();
		assertThat(getEnvironment().getProperty('bar')).isEqualTo('foo');
		assertThat(getEnvironment().getProperty('baz')).isEqualTo('bing');
	}
	@Test
	void commandLineArgsApplyToSpringApplication() {
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.main.banner-mode=OFF');
		assertThat(application.getBannerMode()).isEqualTo(Banner.Mode.OFF);
	}
	@Test
	void registerShutdownHook() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(SpringApplicationShutdownHookInstance.get()).registeredApplicationContext(this.context);
	}
	@Test
	void registerShutdownHookOff() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setRegisterShutdownHook(false);
		this.context = application.run();
		assertThat(SpringApplicationShutdownHookInstance.get()).didNotRegisterApplicationContext(this.context);
	}
	@Test
	void registerListener() {
		SpringApplication application = new SpringApplication(ExampleConfig.class, ListenerConfig.class);
		application.setApplicationContextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		Set<ApplicationEvent> events = new LinkedHashSet<>();
		application.addListeners((ApplicationListener<ApplicationEvent>) events::add);
		this.context = application.run();
		assertThat(events).hasAtLeastOneElementOfType(ApplicationPreparedEvent.class);
		assertThat(events).hasAtLeastOneElementOfType(ContextRefreshedEvent.class);
		verifyRegisteredListenerSuccessEvents();
	}
	@Test
	void registerListenerWithCustomMulticaster() {
		SpringApplication application = new SpringApplication(ExampleConfig.class, ListenerConfig.class,
				Multicaster.class);
		application.setApplicationContextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		Set<ApplicationEvent> events = new LinkedHashSet<>();
		application.addListeners((ApplicationListener<ApplicationEvent>) events::add);
		this.context = application.run();
		assertThat(events).hasAtLeastOneElementOfType(ApplicationPreparedEvent.class);
		assertThat(events).hasAtLeastOneElementOfType(ContextRefreshedEvent.class);
		verifyRegisteredListenerSuccessEvents();
	}
	@SuppressWarnings('unchecked')
	private void verifyRegisteredListenerSuccessEvents() {
		ApplicationListener<ApplicationEvent> listener = this.context.getBean('testApplicationListener',
				ApplicationListener.class);
		InOrder inOrder = Mockito.inOrder(listener);
		then(listener).should(inOrder).onApplicationEvent(isA(ContextRefreshedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationStartedEvent.class));
		then(listener).should(inOrder)
			.onApplicationEvent(argThat(isAvailabilityChangeEventWithState(LivenessState.CORRECT)));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationReadyEvent.class));
		then(listener).should(inOrder)
			.onApplicationEvent(argThat(isAvailabilityChangeEventWithState(ReadinessState.ACCEPTING_TRAFFIC)));
		inOrder.verifyNoMoreInteractions();
	}
	@SuppressWarnings('unchecked')
	@Test
	void applicationListenerFromApplicationIsCalledWhenContextFailsRefreshBeforeListenerRegistration() {
		ApplicationListener<ApplicationEvent> listener = mock(ApplicationListener.class);
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.addListeners(listener);
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(application::run);
		verifyRegisteredListenerFailedFromApplicationEvents(listener);
	}
	@SuppressWarnings('unchecked')
	@Test
	void applicationListenerFromApplicationIsCalledWhenContextFailsRefreshAfterListenerRegistration() {
		ApplicationListener<ApplicationEvent> listener = mock(ApplicationListener.class);
		SpringApplication application = new SpringApplication(BrokenPostConstructConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.addListeners(listener);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(application::run);
		verifyRegisteredListenerFailedFromApplicationEvents(listener);
	}
	private void verifyRegisteredListenerFailedFromApplicationEvents(ApplicationListener<ApplicationEvent> listener) {
		InOrder inOrder = Mockito.inOrder(listener);
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationStartingEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationEnvironmentPreparedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationContextInitializedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationPreparedEvent.class));
		then(listener).should(inOrder).onApplicationEvent(isA(ApplicationFailedEvent.class));
		inOrder.verifyNoMoreInteractions();
	}
	@SuppressWarnings('unchecked')
	@Test
	void applicationListenerFromContextIsCalledWhenContextFailsRefreshBeforeListenerRegistration() {
		final ApplicationListener<ApplicationEvent> listener = mock(ApplicationListener.class);
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.addInitializers((applicationContext) -> applicationContext.addApplicationListener(listener));
		assertThatExceptionOfType(ApplicationContextException.class).isThrownBy(application::run);
		then(listener).should().onApplicationEvent(isA(ApplicationFailedEvent.class));
		then(listener).shouldHaveNoMoreInteractions();
	}
	@SuppressWarnings('unchecked')
	@Test
	void applicationListenerFromContextIsCalledWhenContextFailsRefreshAfterListenerRegistration() {
		ApplicationListener<ApplicationEvent> listener = mock(ApplicationListener.class);
		SpringApplication application = new SpringApplication(BrokenPostConstructConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.addInitializers((applicationContext) -> applicationContext.addApplicationListener(listener));
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(application::run);
		then(listener).should().onApplicationEvent(isA(ApplicationFailedEvent.class));
		then(listener).shouldHaveNoMoreInteractions();
	}
	@Test
	void headless() {
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(System.getProperty('java.awt.headless')).isEqualTo('true');
	}
	@Test
	void headlessFalse() {
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setHeadless(false);
		this.context = application.run();
		assertThat(System.getProperty('java.awt.headless')).isEqualTo('false');
	}
	@Test
	void headlessSystemPropertyTakesPrecedence() {
		System.setProperty('java.awt.headless', 'false');
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(System.getProperty('java.awt.headless')).isEqualTo('false');
	}
	@Test
	void getApplicationArgumentsBean() {
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--debug', 'spring', 'boot');
		ApplicationArguments args = this.context.getBean(ApplicationArguments.class);
		assertThat(args.getNonOptionArgs()).containsExactly('spring', 'boot');
		assertThat(args.containsOption('debug')).isTrue();
	}
	@Test
	void webApplicationSwitchedOffInListener() {
		TestSpringApplication application = new TestSpringApplication(ExampleConfig.class);
		application.addListeners((ApplicationListener<ApplicationEnvironmentPreparedEvent>) (event) -> {
			assertThat(event.getEnvironment().getClass().getName()).endsWith('ApplicationServletEnvironment');
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(event.getEnvironment(), 'foo=bar');
			event.getSpringApplication().setWebApplicationType(WebApplicationType.NONE);
		});
		this.context = application.run();
		assertThat(this.context.getEnvironment()).isNotInstanceOf(StandardServletEnvironment.class);
		assertThat(this.context.getEnvironment().getProperty('foo')).isEqualTo('bar');
		Iterator<PropertySource<?>> iterator = this.context.getEnvironment().getPropertySources().iterator();
		assertThat(iterator.next().getName()).isEqualTo('configurationProperties');
		assertThat(iterator.next().getName())
			.isEqualTo(TestPropertySourceUtils.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);
	}
	@Test
	void nonWebApplicationConfiguredViaAPropertyHasTheCorrectTypeOfContextAndEnvironment() {
		ConfigurableApplicationContext context = new SpringApplication(ExampleConfig.class)
			.run('--spring.main.web-application-type=none');
		assertThat(context).isNotInstanceOfAny(WebApplicationContext.class, ReactiveWebApplicationContext.class);
		assertThat(context.getEnvironment()).isNotInstanceOfAny(ConfigurableWebEnvironment.class);
	}
	@Test
	void webApplicationConfiguredViaAPropertyHasTheCorrectTypeOfContextAndEnvironment() {
		ConfigurableApplicationContext context = new SpringApplication(ExampleWebConfig.class)
			.run('--spring.main.web-application-type=servlet');
		assertThat(context).isInstanceOf(WebApplicationContext.class);
		assertThat(context.getEnvironment()).isInstanceOf(StandardServletEnvironment.class);
		assertThat(context.getEnvironment().getClass().getName()).endsWith('ApplicationServletEnvironment');
	}
	@Test
	void reactiveApplicationConfiguredViaAPropertyHasTheCorrectTypeOfContextAndEnvironment() {
		ConfigurableApplicationContext context = new SpringApplication(ExampleReactiveWebConfig.class)
			.run('--spring.main.web-application-type=reactive');
		assertThat(context).isInstanceOf(ReactiveWebApplicationContext.class);
		assertThat(context.getEnvironment()).isInstanceOf(StandardReactiveWebEnvironment.class);
		assertThat(context.getEnvironment().getClass().getName()).endsWith('ApplicationReactiveWebEnvironment');
	}
	@Test
	void environmentIsConvertedIfTypeDoesNotMatch() {
		ConfigurableApplicationContext context = new SpringApplication(ExampleReactiveWebConfig.class)
			.run('--spring.profiles.active=withwebapplicationtype');
		assertThat(context).isInstanceOf(ReactiveWebApplicationContext.class);
		assertThat(context.getEnvironment()).isInstanceOf(StandardReactiveWebEnvironment.class);
		assertThat(context.getEnvironment().getClass().getName()).endsWith('ApplicationReactiveWebEnvironment');
	}
	@Test
	void failureResultsInSingleStackTrace(CapturedOutput output) throws Exception {
		ThreadGroup group = new ThreadGroup('main');
		Thread thread = new Thread(group, 'main') {
			@Override
			public void run() {
				SpringApplication application = new SpringApplication(FailingConfig.class);
				application.setWebApplicationType(WebApplicationType.NONE);
				application.run();
			}
		};
		thread.start();
		thread.join(6000);
		assertThat(output).containsOnlyOnce('Caused by: java.lang.RuntimeException: ExpectedError');
	}
	@Test
	void beanDefinitionOverridingIsDisabledByDefault() {
		assertThatExceptionOfType(BeanDefinitionOverrideException.class)
			.isThrownBy(() -> new SpringApplication(ExampleConfig.class, OverrideConfig.class).run());
	}
	@Test
	void beanDefinitionOverridingCanBeEnabled() {
		assertThat(new SpringApplication(ExampleConfig.class, OverrideConfig.class)
			.run('--spring.main.allow-bean-definition-overriding=true', '--spring.main.web-application-type=none')
			.getBean('someBean')).isEqualTo('override');
	}
	@Test
	void circularReferencesAreDisabledByDefault() {
		assertThatExceptionOfType(UnsatisfiedDependencyException.class)
			.isThrownBy(
					() -> new SpringApplication(ExampleProducerConfiguration.class, ExampleConsumerConfiguration.class)
						.run('--spring.main.web-application-type=none'))
			.withRootCauseInstanceOf(BeanCurrentlyInCreationException.class);
	}
	@Test
	void circularReferencesCanBeEnabled() {
		assertThatNoException().isThrownBy(
				() -> new SpringApplication(ExampleProducerConfiguration.class, ExampleConsumerConfiguration.class)
					.run('--spring.main.web-application-type=none', '--spring.main.allow-circular-references=true'));
	}
	@Test
	void relaxedBindingShouldWorkBeforeEnvironmentIsPrepared() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.config.additionalLocation=classpath:custom-config/');
		assertThat(this.context.getEnvironment().getProperty('hello')).isEqualTo('world');
	}
	@Test
	void lazyInitializationIsDisabledByDefault() {
		assertThat(new SpringApplication(LazyInitializationConfig.class).run('--spring.main.web-application-type=none')
			.getBean(AtomicInteger.class)).hasValue(1);
	}
	@Test
	void lazyInitializationCanBeEnabled() {
		assertThat(new SpringApplication(LazyInitializationConfig.class)
			.run('--spring.main.web-application-type=none', '--spring.main.lazy-initialization=true')
			.getBean(AtomicInteger.class)).hasValue(0);
	}
	@Test
	void lazyInitializationIgnoresBeansThatAreExplicitlyNotLazy() {
		assertThat(new SpringApplication(NotLazyInitializationConfig.class)
			.run('--spring.main.web-application-type=none', '--spring.main.lazy-initialization=true')
			.getBean(AtomicInteger.class)).hasValue(1);
	}
	@Test
	void lazyInitializationIgnoresLazyInitializationExcludeFilteredBeans() {
		assertThat(new SpringApplication(LazyInitializationExcludeFilterConfig.class)
			.run('--spring.main.web-application-type=none', '--spring.main.lazy-initialization=true')
			.getBean(AtomicInteger.class)).hasValue(1);
	}
	@Test
	void customApplicationStartupPublishStartupSteps() {
		ApplicationStartup applicationStartup = mock(ApplicationStartup.class);
		StartupStep startupStep = mock(StartupStep.class);
		given(applicationStartup.start(anyString())).willReturn(startupStep);
		given(startupStep.tag(anyString(), anyString())).willReturn(startupStep);
		given(startupStep.tag(anyString(), ArgumentMatchers.<Supplier<String>>any())).willReturn(startupStep);
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setApplicationStartup(applicationStartup);
		this.context = application.run();
		assertThat(this.context.getBean(ApplicationStartup.class)).isEqualTo(applicationStartup);
		then(applicationStartup).should().start('spring.boot.application.starting');
		then(applicationStartup).should().start('spring.boot.application.environment-prepared');
		then(applicationStartup).should().start('spring.boot.application.context-prepared');
		then(applicationStartup).should().start('spring.boot.application.context-loaded');
		then(applicationStartup).should().start('spring.boot.application.started');
		then(applicationStartup).should().start('spring.boot.application.ready');
		long startCount = mockingDetails(applicationStartup).getInvocations()
			.stream()
			.filter((invocation) -> invocation.getMethod().toString().contains('start('))
			.count();
		long endCount = mockingDetails(startupStep).getInvocations()
			.stream()
			.filter((invocation) -> invocation.getMethod().toString().contains('end('))
			.count();
		assertThat(startCount).isEqualTo(endCount);
	}
	@Test
	void customApplicationStartupPublishStartupStepsWithFailure() {
		ApplicationStartup applicationStartup = mock(ApplicationStartup.class);
		StartupStep startupStep = mock(StartupStep.class);
		given(applicationStartup.start(anyString())).willReturn(startupStep);
		given(startupStep.tag(anyString(), anyString())).willReturn(startupStep);
		given(startupStep.tag(anyString(), ArgumentMatchers.<Supplier<String>>any())).willReturn(startupStep);
		SpringApplication application = new SpringApplication(BrokenPostConstructConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setApplicationStartup(applicationStartup);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(application::run);
		then(applicationStartup).should().start('spring.boot.application.starting');
		then(applicationStartup).should().start('spring.boot.application.environment-prepared');
		then(applicationStartup).should().start('spring.boot.application.failed');
		long startCount = mockingDetails(applicationStartup).getInvocations()
			.stream()
			.filter((invocation) -> invocation.getMethod().toString().contains('start('))
			.count();
		long endCount = mockingDetails(startupStep).getInvocations()
			.stream()
			.filter((invocation) -> invocation.getMethod().toString().contains('end('))
			.count();
		assertThat(startCount).isEqualTo(endCount);
	}
	@Test
	void addBootstrapRegistryInitializer() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.addBootstrapRegistryInitializer(
				(bootstrapContext) -> bootstrapContext.register(String.class, InstanceSupplier.of('boot')));
		TestApplicationListener listener = new TestApplicationListener();
		application.addListeners(listener);
		application.run();
		ApplicationStartingEvent startingEvent = listener.getEvent(ApplicationStartingEvent.class);
		assertThat(startingEvent.getBootstrapContext().get(String.class)).isEqualTo('boot');
		ApplicationEnvironmentPreparedEvent environmentPreparedEvent = listener
			.getEvent(ApplicationEnvironmentPreparedEvent.class);
		assertThat(environmentPreparedEvent.getBootstrapContext().get(String.class)).isEqualTo('boot');
	}
	@Test
	void addBootstrapRegistryInitializerCanRegisterBeans() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.addBootstrapRegistryInitializer((bootstrapContext) -> {
			bootstrapContext.register(String.class, InstanceSupplier.of('boot'));
			bootstrapContext.addCloseListener((event) -> event.getApplicationContext()
				.getBeanFactory()
				.registerSingleton('test', event.getBootstrapContext().get(String.class)));
		});
		ConfigurableApplicationContext applicationContext = application.run();
		assertThat(applicationContext.getBean('test')).isEqualTo('boot');
	}
	@Test
	void settingEnvironmentPrefixViaPropertiesThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new SpringApplication().run('--spring.main.environment-prefix=my'));
	}
	@Test
	void bindsEnvironmentPrefixToSpringApplication() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setEnvironmentPrefix('my');
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(application.getEnvironmentPrefix()).isEqualTo('my');
	}
	@Test
	void movesConfigClassPropertySourcesToEnd() {
		SpringApplication application = new SpringApplication(PropertySourceConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setDefaultProperties(Collections.singletonMap('test.name', 'test'));
		this.context = application.run();
		assertThat(this.context.getEnvironment().getProperty('test.name'))
			.isEqualTo('spring-application-config-property-source');
	}
	@Test
	void deregistersShutdownHookForFailedApplicationContext() {
		SpringApplication application = new SpringApplication(BrokenPostConstructConfig.class);
		List<ApplicationEvent> events = new ArrayList<>();
		application.addListeners(events::add);
		application.setWebApplicationType(WebApplicationType.NONE);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(application::run);
		assertThat(events).hasAtLeastOneElementOfType(ApplicationFailedEvent.class);
		ApplicationFailedEvent failure = events.stream()
			.filter((event) -> event instanceof ApplicationFailedEvent)
			.map(ApplicationFailedEvent.class::cast)
			.findFirst()
			.get();
		assertThat(SpringApplicationShutdownHookInstance.get())
			.didNotRegisterApplicationContext(failure.getApplicationContext());
	}
	@Test
	void withRunnableHookRunsWithHook() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		SpringApplicationRunListener runListener = mock(SpringApplicationRunListener.class);
		SpringApplicationHook hook = (springApplication) -> runListener;
		SpringApplication.withHook(hook, () -> this.context = application.run());
		then(runListener).should().starting(any());
		then(runListener).should().contextPrepared(this.context);
		then(runListener).should().ready(eq(this.context), any());
		assertThat(this.context.isRunning()).isTrue();
	}
	@Test
	void withCallableHookRunsWithHook() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		SpringApplicationRunListener runListener = mock(SpringApplicationRunListener.class);
		SpringApplicationHook hook = (springApplication) -> runListener;
		this.context = SpringApplication.withHook(hook, () -> application.run());
		then(runListener).should().starting(any());
		then(runListener).should().contextPrepared(this.context);
		then(runListener).should().ready(eq(this.context), any());
		assertThat(this.context.isRunning()).isTrue();
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void withHookWhenHookThrowsAbandonedRunExceptionAbandonsRun() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		ApplicationListener listener = mock(ApplicationListener.class);
		application.addListeners(listener);
		application.setWebApplicationType(WebApplicationType.NONE);
		SpringApplicationRunListener runListener = spy(new SpringApplicationRunListener() {
			@Override
			public void contextLoaded(ConfigurableApplicationContext context) {
				throw new SpringApplication.AbandonedRunException(context);
			}
		});
		SpringApplicationHook hook = (springApplication) -> runListener;
		assertThatExceptionOfType(SpringApplication.AbandonedRunException.class)
			.isThrownBy(() -> SpringApplication.withHook(hook, () -> application.run()))
			.satisfies((ex) -> assertThat(ex.getApplicationContext().isRunning()).isFalse());
		then(runListener).should().starting(any());
		then(runListener).should().contextPrepared(any());
		then(runListener).should(never()).ready(any(), any());
		then(runListener).should(never()).failed(any(), any());
		then(listener).should().onApplicationEvent(any(ApplicationStartingEvent.class));
		then(listener).should().onApplicationEvent(any(ApplicationEnvironmentPreparedEvent.class));
		then(listener).should().onApplicationEvent(any(ApplicationPreparedEvent.class));
		then(listener).should(never()).onApplicationEvent(any(ApplicationReadyEvent.class));
		then(listener).should(never()).onApplicationEvent(any(ApplicationFailedEvent.class));
	}
	@Test
	// gh-32555
	void shouldUseAotInitializer() {
		SpringApplication application = new SpringApplication(ExampleAotProcessedMainClass.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setMainApplicationClass(ExampleAotProcessedMainClass.class);
		System.setProperty(AotDetector.AOT_ENABLED, 'true');
		try {
			ApplicationContext context = application.run();
			assertThat(context.getBean('test')).isEqualTo('test');
		}
		finally {
			System.clearProperty(AotDetector.AOT_ENABLED);
		}
	}
	@Test
	void shouldReportFriendlyErrorIfAotInitializerNotFound() {
		SpringApplication application = new SpringApplication(TestSpringApplication.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setMainApplicationClass(TestSpringApplication.class);
		System.setProperty(AotDetector.AOT_ENABLED, 'true');
		try {
			assertThatExceptionOfType(AotInitializerNotFoundException.class).isThrownBy(application::run)
				.withMessageMatching('^.+AOT initializer .+ could not be found$');
		}
		finally {
			System.clearProperty(AotDetector.AOT_ENABLED);
		}
	}
	@Test
	void fromRunsWithAdditionalSources() {
		assertThat(ExampleAdditionalConfig.local.get()).isNull();
		this.context = SpringApplication.from(ExampleFromMainMethod::main)
			.with(ExampleAdditionalConfig.class)
			.run()
			.getApplicationContext();
		assertThat(ExampleAdditionalConfig.local.get()).isNotNull();
		ExampleAdditionalConfig.local.set(null);
	}
	@Test
	void fromReturnsApplicationContext() {
		this.context = SpringApplication.from(ExampleFromMainMethod::main)
			.with(ExampleAdditionalConfig.class)
			.run()
			.getApplicationContext();
		assertThat(this.context).isNotNull();
	}
	@Test
	void fromWithMultipleApplicationsOnlyAppliesAdditionalSourcesOnce() {
		this.context = SpringApplication.from(MultipleApplicationsMainMethod::main)
			.with(SingleUseAdditionalConfig.class)
			.run()
			.getApplicationContext();
		assertThatNoException().isThrownBy(() -> this.context.getBean(SingleUseAdditionalConfig.class));
	}
	@Test
	void fromAppliesProfiles() {
		this.context = SpringApplication.from(ExampleFromMainMethod::main)
			.with(ProfileConfig.class)
			.withAdditionalProfiles('custom')
			.run()
			.getApplicationContext();
		assertThat(this.context).isNotNull();
		assertThat(this.context.getBeanProvider(Example.class).getIfAvailable()).isNotNull();
	}
	@Test
	void shouldStartDaemonThreadIfKeepAliveIsEnabled() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--spring.main.keep-alive=true');
		Set<Thread> threads = getCurrentThreads();
		assertThat(threads).filteredOn((thread) -> thread.getName().equals('keep-alive'))
			.singleElement()
			.satisfies((thread) -> assertThat(thread.isDaemon()).isFalse());
	}
	@Test
	void shouldStopKeepAliveThreadIfContextIsClosed() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setKeepAlive(true);
		this.context = application.run();
		assertThat(getCurrentThreads()).filteredOn((thread) -> thread.getName().equals('keep-alive')).isNotEmpty();
		this.context.close();
		Awaitility.await()
			.atMost(Duration.ofSeconds(30))
			.untilAsserted(
					() -> assertThat(getCurrentThreads()).filteredOn((thread) -> thread.getName().equals('keep-alive'))
						.isEmpty());
	}
	private <S extends AvailabilityState> ArgumentMatcher<ApplicationEvent> isAvailabilityChangeEventWithState(
			S state) {
		return (argument) -> (argument instanceof AvailabilityChangeEvent<?> availabilityChangeEvent)
				&& availabilityChangeEvent.getState().equals(state);
	}
	private <E extends ApplicationEvent> AtomicReference<E> addListener(SpringApplication application,
			Class<E> eventType) {
		AtomicReference<E> reference = new AtomicReference<>();
		application.addListeners(new TestEventListener<>(eventType, reference));
		return reference;
	}
	private Condition<ConfigurableEnvironment> matchingPropertySource(final Class<?> propertySourceClass,
			final String name) {
		return new Condition<>('has property source') {
			@Override
			public boolean matches(ConfigurableEnvironment value) {
				for (PropertySource<?> source : value.getPropertySources()) {
					if (propertySourceClass.isInstance(source) && (name == null || name.equals(source.getName()))) {
						return true;
					}
				}
				return false;
			}
		};
	}
	private Condition<ConfigurableApplicationContext> runTestRunnerBean(String name) {
		return new Condition<>('run testrunner bean') {
			@Override
			public boolean matches(ConfigurableApplicationContext value) {
				return value.getBean(name, AbstractTestRunner.class).hasRun();
			}
		};
	}
	private Set<Thread> getCurrentThreads() {
		return Thread.getAllStackTraces().keySet();
	}
	private void assertThatBannerModeIs(SpringApplication application, Mode mode) {
		Object properties = ReflectionTestUtils.getField(application, 'properties');
		assertThat(properties).hasFieldOrPropertyWithValue('bannerMode', mode);
	}
	static class TestEventListener<E extends ApplicationEvent> implements SmartApplicationListener {
		private final Class<E> eventType;
		private final AtomicReference<E> reference;
		TestEventListener(Class<E> eventType, AtomicReference<E> reference) {
			this.eventType = eventType;
			this.reference = reference;
		}
		@Override
		public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
			return this.eventType.isAssignableFrom(eventType);
		}
		@Override
		@SuppressWarnings('unchecked')
		public void onApplicationEvent(ApplicationEvent event) {
			this.reference.set((E) event);
		}
	}
	@Configuration
	static class InaccessibleConfiguration {
		private InaccessibleConfiguration() {
		}
	}
	static class SpyApplicationContext extends AnnotationConfigApplicationContext {
		ConfigurableApplicationContext applicationContext = spy(new AnnotationConfigApplicationContext());
		@Override
		public void registerShutdownHook() {
			this.applicationContext.registerShutdownHook();
		}
		ConfigurableApplicationContext getApplicationContext() {
			return this.applicationContext;
		}
		@Override
		public void close() {
			this.applicationContext.close();
			super.close();
		}
	}
	static class TestSpringApplication extends SpringApplication {
		private BeanDefinitionLoader loader;
		private boolean useMockLoader;
		TestSpringApplication(Class<?>... primarySources) {
			super(primarySources);
		}
		TestSpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
			super(resourceLoader, primarySources);
		}
		void setUseMockLoader(boolean useMockLoader) {
			this.useMockLoader = useMockLoader;
		}
		@Override
		protected BeanDefinitionLoader createBeanDefinitionLoader(BeanDefinitionRegistry registry, Object[] sources) {
			if (this.useMockLoader) {
				this.loader = mock(BeanDefinitionLoader.class);
			}
			else {
				this.loader = spy(super.createBeanDefinitionLoader(registry, sources));
			}
			return this.loader;
		}
		BeanDefinitionLoader getLoader() {
			return this.loader;
		}
		Banner.Mode getBannerMode() {
			return this.properties.getBannerMode(new MockEnvironment());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleConfig {
		@Bean
		String someBean() {
			return 'test';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OverrideConfig {
		@Bean
		String someBean() {
			return 'override';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BrokenPostConstructConfig {
		@Bean
		Thing thing() {
			return new Thing();
		}
		static class Thing {
			@PostConstruct
			void boom() {
				throw new IllegalStateException();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ListenerConfig {
		@Bean
		ApplicationListener<?> testApplicationListener() {
			return mock(ApplicationListener.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Multicaster {
		@Bean(name = AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME)
		ApplicationEventMulticaster applicationEventMulticaster() {
			return spy(new SimpleApplicationEventMulticaster());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleWebConfig {
		@Bean
		TomcatServletWebServerFactory webServer() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleReactiveWebConfig {
		@Bean
		NettyReactiveWebServerFactory webServerFactory() {
			return new NettyReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler() {
			return (serverHttpRequest, serverHttpResponse) -> Mono.empty();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FailingConfig {
		@Bean
		Object fail() {
			throw new RuntimeException('ExpectedError');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CommandLineRunConfig {
		@Bean
		TestCommandLineRunner runnerC() {
			return new TestCommandLineRunner('runnerC', Ordered.LOWEST_PRECEDENCE, 'runnerB', 'runnerA');
		}
		@Bean
		TestApplicationRunner runnerB() {
			return new TestApplicationRunner('runnerB', Ordered.LOWEST_PRECEDENCE - 1, 'runnerA');
		}
		@Bean
		TestCommandLineRunner runnerA() {
			return new TestCommandLineRunner('runnerA', Ordered.HIGHEST_PRECEDENCE);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CommandLineRunParentConfig {
		@Bean
		TestCommandLineRunner runnerP() {
			return new TestCommandLineRunner('runnerP', Ordered.LOWEST_PRECEDENCE);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BeanDefinitionOrderRunnerConfig {
		private final List<String> runners = new ArrayList<>();
		@Bean
		@Order
		CommandLineRunner runnerC() {
			return (args) -> this.runners.add('runnerC');
		}
		@Bean
		@Order(Ordered.LOWEST_PRECEDENCE - 1)
		ApplicationRunner runnerB() {
			return (args) -> this.runners.add('runnerB');
		}
		@Bean
		@Order(Ordered.HIGHEST_PRECEDENCE)
		CommandLineRunner runnerA() {
			return (args) -> this.runners.add('runnerA');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExitCodeCommandLineRunConfig {
		@Bean
		CommandLineRunner runner() {
			return (args) -> {
				throw new IllegalStateException(new ExitStatusException());
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MappedExitCodeCommandLineRunConfig {
		@Bean
		CommandLineRunner runner() {
			return (args) -> {
				throw new IllegalStateException();
			};
		}
		@Bean
		ExitCodeExceptionMapper exceptionMapper() {
			return (exception) -> {
				if (exception instanceof IllegalStateException) {
					return 11;
				}
				return 0;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RefreshFailureConfig {
		@PostConstruct
		void fail() {
			throw new RefreshFailureException();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class LazyInitializationConfig {
		@Bean
		AtomicInteger counter() {
			return new AtomicInteger();
		}
		@Bean
		LazyBean lazyBean(AtomicInteger counter) {
			return new LazyBean(counter);
		}
		static class LazyBean {
			LazyBean(AtomicInteger counter) {
				counter.incrementAndGet();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NotLazyInitializationConfig {
		@Bean
		AtomicInteger counter() {
			return new AtomicInteger();
		}
		@Bean
		@Lazy(false)
		NotLazyBean NotLazyBean(AtomicInteger counter) {
			return new NotLazyBean(counter);
		}
		static class NotLazyBean {
			NotLazyBean(AtomicInteger counter) {
				counter.getAndIncrement();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class LazyInitializationExcludeFilterConfig {
		@Bean
		AtomicInteger counter() {
			return new AtomicInteger();
		}
		@Bean
		NotLazyBean notLazyBean(AtomicInteger counter) {
			return new NotLazyBean(counter);
		}
		@Bean
		static LazyInitializationExcludeFilter lazyInitializationExcludeFilter() {
			return LazyInitializationExcludeFilter.forBeanTypes(NotLazyBean.class);
		}
	}
	static class NotLazyBean {
		NotLazyBean(AtomicInteger counter) {
			counter.getAndIncrement();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@org.springframework.context.annotation.PropertySource('classpath:spring-application-config-property-source.properties')
	static class PropertySourceConfig {
	}
	static class ExitStatusException extends RuntimeException implements ExitCodeGenerator {
		@Override
		public int getExitCode() {
			return 11;
		}
	}
	static class RefreshFailureException extends RuntimeException {
	}
	abstract static class AbstractTestRunner implements ApplicationContextAware, Ordered {
		private final String[] expectedBefore;
		private ApplicationContext applicationContext;
		private final int order;
		private boolean run;
		AbstractTestRunner(int order, String... expectedBefore) {
			this.expectedBefore = expectedBefore;
			this.order = order;
		}
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Override
		public int getOrder() {
			return this.order;
		}
		void markAsRan() {
			this.run = true;
			for (String name : this.expectedBefore) {
				AbstractTestRunner bean = this.applicationContext.getBean(name, AbstractTestRunner.class);
				assertThat(bean.hasRun()).isTrue();
			}
		}
		boolean hasRun() {
			return this.run;
		}
	}
	static class TestCommandLineRunner extends AbstractTestRunner implements CommandLineRunner {
		private final String name;
		TestCommandLineRunner(String name, int order, String... expectedBefore) {
			super(order, expectedBefore);
			this.name = name;
		}
		@Override
		public void run(String... args) {
			System.out.println('>>> ' + this.name);
			markAsRan();
		}
	}
	static class TestApplicationRunner extends AbstractTestRunner implements ApplicationRunner {
		private final String name;
		TestApplicationRunner(String name, int order, String... expectedBefore) {
			super(order, expectedBefore);
			this.name = name;
		}
		@Override
		public void run(ApplicationArguments args) {
			System.out.println('>>> ' + this.name);
			markAsRan();
		}
	}
	static class ExitCodeListener implements ApplicationListener<ExitCodeEvent> {
		private Integer exitCode;
		@Override
		public void onApplicationEvent(ExitCodeEvent event) {
			this.exitCode = event.getExitCode();
		}
		Integer getExitCode() {
			return this.exitCode;
		}
	}
	static class MockResourceLoader implements ResourceLoader {
		private final Map<String, Resource> resources = new HashMap<>();
		void addResource(String source, String path) {
			this.resources.put(source, new ClassPathResource(path, getClass()));
		}
		@Override
		public Resource getResource(String path) {
			Resource resource = this.resources.get(path);
			return (resource != null) ? resource : new ClassPathResource('doesnotexist');
		}
		@Override
		public ClassLoader getClassLoader() {
			return getClass().getClassLoader();
		}
	}
	static class TestApplicationListener implements ApplicationListener<ApplicationEvent> {
		private final MultiValueMap<Class<?>, ApplicationEvent> events = new LinkedMultiValueMap<>();
		@Override
		public void onApplicationEvent(ApplicationEvent event) {
			this.events.add(event.getClass(), event);
		}
		@SuppressWarnings('unchecked')
		<E extends ApplicationEvent> E getEvent(Class<E> type) {
			return (E) this.events.get(type).get(0);
		}
	}
	static class Example {
	}
	@FunctionalInterface
	interface ExampleConfigurer {
		void configure(Example example);
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleProducerConfiguration {
		@Bean
		Example example(ObjectProvider<ExampleConfigurer> configurers) {
			Example example = new Example();
			configurers.orderedStream().forEach((configurer) -> configurer.configure(example));
			return example;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleConsumerConfiguration {
		@Autowired
		Example example;
		@Bean
		ExampleConfigurer configurer() {
			return (example) -> {
			};
		}
	}
	static class ExampleAotProcessedMainClass {
	}
	static class ExampleAotProcessedMainClass__ApplicationContextInitializer
			implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
			applicationContext.getBeanFactory().registerSingleton('test', 'test');
		}
	}
	static class ExampleFromMainMethod {
		static void main(String[] args) {
			SpringApplication application = new SpringApplication(ExampleConfig.class);
			application.setWebApplicationType(WebApplicationType.NONE);
			application.run(args);
		}
	}
	static class MultipleApplicationsMainMethod {
		static void main(String[] args) {
			SpringApplication application = new SpringApplication(ExampleConfig.class);
			application.setWebApplicationType(WebApplicationType.NONE);
			application.addListeners(new ApplicationListener<ApplicationEnvironmentPreparedEvent>() {
				@Override
				public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
					SpringApplicationBuilder builder = new SpringApplicationBuilder(
							InnerApplicationConfiguration.class);
					builder.web(WebApplicationType.NONE);
					builder.run().close();
				}
			});
			application.run(args);
		}
		static class InnerApplicationConfiguration {
		}
	}
	@Configuration
	static class ExampleAdditionalConfig {
		static ThreadLocal<ExampleAdditionalConfig> local = new ThreadLocal<>();
		ExampleAdditionalConfig() {
			local.set(this);
		}
	}
	@Configuration
	static class SingleUseAdditionalConfig {
		private static AtomicBoolean used = new AtomicBoolean(false);
		SingleUseAdditionalConfig() {
			if (!used.compareAndSet(false, true)) {
				throw new IllegalStateException('Single-use configuration has already been used');
			}
		}
	}
	@Configuration
	static class ProfileConfig {
		@Bean
		@Profile('custom')
		Example example() {
			return new Example();
		}
	}
}
/*
package org.springframework.boot.logging;
/**
class DeferredLogsTests {
	@Test
	void switchOverAllSwitchesLoggersWithOrderedOutput() {
		Log log1 = mock(Log.class);
		Log log2 = mock(Log.class);
		DeferredLogs loggers = new DeferredLogs();
		Log dlog1 = loggers.getLog(log1);
		Log dlog2 = loggers.getLog(log2);
		dlog1.info('a');
		dlog2.info('b');
		dlog1.info('c');
		dlog2.info('d');
		then(log1).shouldHaveNoInteractions();
		then(log2).shouldHaveNoInteractions();
		loggers.switchOverAll();
		InOrder ordered = inOrder(log1, log2);
		then(log1).should(ordered).info('a', null);
		then(log2).should(ordered).info('b', null);
		then(log1).should(ordered).info('c', null);
		then(log2).should(ordered).info('d', null);
		then(log1).shouldHaveNoMoreInteractions();
		then(log2).shouldHaveNoMoreInteractions();
		dlog1.info('e');
		dlog2.info('f');
		then(log1).should(ordered).info('e', null);
		then(log2).should(ordered).info('f', null);
	}
}
/*
package org.springframework.boot.logging;
/**
class DeferredLogTests {
	private final DeferredLog deferredLog = new DeferredLog();
	private final Object message = 'Message';
	private final Throwable throwable = new IllegalStateException();
	private final Log log = mock(Log.class);
	@Test
	void isTraceEnabled() {
		assertThat(this.deferredLog.isTraceEnabled()).isTrue();
	}
	@Test
	void isDebugEnabled() {
		assertThat(this.deferredLog.isDebugEnabled()).isTrue();
	}
	@Test
	void isInfoEnabled() {
		assertThat(this.deferredLog.isInfoEnabled()).isTrue();
	}
	@Test
	void isWarnEnabled() {
		assertThat(this.deferredLog.isWarnEnabled()).isTrue();
	}
	@Test
	void isErrorEnabled() {
		assertThat(this.deferredLog.isErrorEnabled()).isTrue();
	}
	@Test
	void isFatalEnabled() {
		assertThat(this.deferredLog.isFatalEnabled()).isTrue();
	}
	@Test
	void trace() {
		this.deferredLog.trace(this.message);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().trace(this.message, null);
	}
	@Test
	void traceWithThrowable() {
		this.deferredLog.trace(this.message, this.throwable);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().trace(this.message, this.throwable);
	}
	@Test
	void debug() {
		this.deferredLog.debug(this.message);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().debug(this.message, null);
	}
	@Test
	void debugWithThrowable() {
		this.deferredLog.debug(this.message, this.throwable);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().debug(this.message, this.throwable);
	}
	@Test
	void info() {
		this.deferredLog.info(this.message);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().info(this.message, null);
	}
	@Test
	void infoWithThrowable() {
		this.deferredLog.info(this.message, this.throwable);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().info(this.message, this.throwable);
	}
	@Test
	void warn() {
		this.deferredLog.warn(this.message);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().warn(this.message, null);
	}
	@Test
	void warnWithThrowable() {
		this.deferredLog.warn(this.message, this.throwable);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().warn(this.message, this.throwable);
	}
	@Test
	void error() {
		this.deferredLog.error(this.message);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().error(this.message, null);
	}
	@Test
	void errorWithThrowable() {
		this.deferredLog.error(this.message, this.throwable);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().error(this.message, this.throwable);
	}
	@Test
	void fatal() {
		this.deferredLog.fatal(this.message);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().fatal(this.message, null);
	}
	@Test
	void fatalWithThrowable() {
		this.deferredLog.fatal(this.message, this.throwable);
		this.deferredLog.replayTo(this.log);
		then(this.log).should().fatal(this.message, this.throwable);
	}
	@Test
	void clearsOnReplayTo() {
		this.deferredLog.info('1');
		this.deferredLog.fatal('2');
		Log log2 = mock(Log.class);
		this.deferredLog.replayTo(this.log);
		this.deferredLog.replayTo(log2);
		then(this.log).should().info('1', null);
		then(this.log).should().fatal('2', null);
		then(this.log).shouldHaveNoMoreInteractions();
		then(log2).shouldHaveNoInteractions();
	}
	@Test
	void switchTo() {
		Lines lines = (Lines) ReflectionTestUtils.getField(this.deferredLog, 'lines');
		assertThat(lines).isEmpty();
		this.deferredLog.error(this.message, this.throwable);
		assertThat(lines).hasSize(1);
		this.deferredLog.switchTo(this.log);
		assertThat(lines).isEmpty();
		this.deferredLog.info('Message2');
		assertThat(lines).isEmpty();
		then(this.log).should().error(this.message, this.throwable);
		then(this.log).should().info('Message2', null);
	}
}
/*
package org.springframework.boot.logging;
/**
class CorrelationIdFormatterTests {
	@Test
	void formatWithDefaultSpecWhenHasBothParts() {
		Map<String, String> context = new HashMap<>();
		context.put('traceId', '01234567890123456789012345678901');
		context.put('spanId', '0123456789012345');
		String formatted = CorrelationIdFormatter.DEFAULT.format(context::get);
		assertThat(formatted).isEqualTo('[01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void formatWithDefaultSpecWhenHasNoParts() {
		Map<String, String> context = new HashMap<>();
		String formatted = CorrelationIdFormatter.DEFAULT.format(context::get);
		assertThat(formatted).isEqualTo('[                                                 ] ');
	}
	@Test
	void formatWithDefaultSpecWhenHasOnlyFirstPart() {
		Map<String, String> context = new HashMap<>();
		context.put('traceId', '01234567890123456789012345678901');
		String formatted = CorrelationIdFormatter.DEFAULT.format(context::get);
		assertThat(formatted).isEqualTo('[01234567890123456789012345678901-                ] ');
	}
	@Test
	void formatWithDefaultSpecWhenHasOnlySecondPart() {
		Map<String, String> context = new HashMap<>();
		context.put('spanId', '0123456789012345');
		String formatted = CorrelationIdFormatter.DEFAULT.format(context::get);
		assertThat(formatted).isEqualTo('[                                -0123456789012345] ');
	}
	@Test
	void formatWhenPartsAreShort() {
		Map<String, String> context = new HashMap<>();
		context.put('traceId', '0123456789012345678901234567');
		context.put('spanId', '012345678901');
		String formatted = CorrelationIdFormatter.DEFAULT.format(context::get);
		assertThat(formatted).isEqualTo('[0123456789012345678901234567    -012345678901    ] ');
	}
	@Test
	void formatWhenPartsAreLong() {
		Map<String, String> context = new HashMap<>();
		context.put('traceId', '01234567890123456789012345678901FFFF');
		context.put('spanId', '0123456789012345FFFF');
		String formatted = CorrelationIdFormatter.DEFAULT.format(context::get);
		assertThat(formatted).isEqualTo('[01234567890123456789012345678901FFFF-0123456789012345FFFF] ');
	}
	@Test
	void formatWithCustomSpec() {
		Map<String, String> context = new HashMap<>();
		context.put('a', '01234567890123456789012345678901');
		context.put('b', '0123456789012345');
		String formatted = CorrelationIdFormatter.of('a(32),b(16)').format(context::get);
		assertThat(formatted).isEqualTo('[01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void formatToWithDefaultSpec() {
		Map<String, String> context = new HashMap<>();
		context.put('traceId', '01234567890123456789012345678901');
		context.put('spanId', '0123456789012345');
		StringBuilder formatted = new StringBuilder();
		CorrelationIdFormatter.DEFAULT.formatTo(context::get, formatted);
		assertThat(formatted).hasToString('[01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void ofWhenSpecIsMalformed() {
		assertThatIllegalStateException().isThrownBy(() -> CorrelationIdFormatter.of('good(12),bad'))
			.withMessage('Unable to parse correlation formatter spec "good(12),bad"')
			.havingCause()
			.withMessage('Invalid specification part "bad"');
	}
	@Test
	void ofWhenSpecIsEmpty() {
		assertThat(CorrelationIdFormatter.of('')).isSameAs(CorrelationIdFormatter.DEFAULT);
	}
	@Test
	void toStringReturnsSpec() {
		assertThat(CorrelationIdFormatter.DEFAULT).hasToString('traceId(32),spanId(16)');
		assertThat(CorrelationIdFormatter.of('a(32),b(16)')).hasToString('a(32),b(16)');
	}
}
/*
package org.springframework.boot.logging;
/**
class LogFileTests {
	@Test
	void noProperties() {
		PropertyResolver resolver = getPropertyResolver(Collections.emptyMap());
		LogFile logFile = LogFile.get(resolver);
		assertThat(logFile).isNull();
	}
	@Test
	void loggingFile() {
		PropertyResolver resolver = getPropertyResolver(Collections.singletonMap('logging.file.name', 'log.file'));
		testLoggingFile(resolver);
	}
	private void testLoggingFile(PropertyResolver resolver) {
		LogFile logFile = LogFile.get(resolver);
		Properties properties = new Properties();
		logFile.applyTo(properties);
		assertThat(logFile).hasToString('log.file');
		assertThat(properties.getProperty(LoggingSystemProperty.LOG_FILE.getEnvironmentVariableName()))
			.isEqualTo('log.file');
		assertThat(properties.getProperty(LoggingSystemProperty.LOG_PATH.getEnvironmentVariableName())).isNull();
	}
	@Test
	void loggingPath() {
		PropertyResolver resolver = getPropertyResolver(Collections.singletonMap('logging.file.path', 'logpath'));
		testLoggingPath(resolver);
	}
	private void testLoggingPath(PropertyResolver resolver) {
		LogFile logFile = LogFile.get(resolver);
		Properties properties = new Properties();
		logFile.applyTo(properties);
		assertThat(logFile).hasToString('logpath' + File.separatorChar + 'spring.log');
		assertThat(properties.getProperty(LoggingSystemProperty.LOG_FILE.getEnvironmentVariableName()))
			.isEqualTo('logpath' + File.separatorChar + 'spring.log');
		assertThat(properties.getProperty(LoggingSystemProperty.LOG_PATH.getEnvironmentVariableName()))
			.isEqualTo('logpath');
	}
	@Test
	void loggingFileAndPath() {
		Map<String, Object> properties = new LinkedHashMap<>();
		properties.put('logging.file.name', 'log.file');
		properties.put('logging.file.path', 'logpath');
		PropertyResolver resolver = getPropertyResolver(properties);
		testLoggingFileAndPath(resolver);
	}
	private void testLoggingFileAndPath(PropertyResolver resolver) {
		LogFile logFile = LogFile.get(resolver);
		Properties properties = new Properties();
		logFile.applyTo(properties);
		assertThat(logFile).hasToString('log.file');
		assertThat(properties.getProperty(LoggingSystemProperty.LOG_FILE.getEnvironmentVariableName()))
			.isEqualTo('log.file');
		assertThat(properties.getProperty(LoggingSystemProperty.LOG_PATH.getEnvironmentVariableName()))
			.isEqualTo('logpath');
	}
	private PropertyResolver getPropertyResolver(Map<String, Object> properties) {
		PropertySource<?> propertySource = new MapPropertySource('properties', properties);
		MutablePropertySources propertySources = new MutablePropertySources();
		propertySources.addFirst(propertySource);
		return new PropertySourcesPropertyResolver(propertySources);
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class SpringEnvironmentPropertySourceTests {
	private MockEnvironment environment;
	private SpringEnvironmentPropertySource propertySource;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.environment.setProperty('spring', 'boot');
		this.propertySource = new SpringEnvironmentPropertySource();
		this.propertySource.setEnvironment(this.environment);
	}
	@Test
	void getPriorityIsOrderedCorrectly() {
		int priority = this.propertySource.getPriority();
		assertThat(priority).isEqualTo(-100);
		assertThat(priority).isLessThan(new SystemPropertiesPropertySource().getPriority());
		assertThat(priority).isLessThan(new PropertiesPropertySource(new Properties()).getPriority());
	}
	@Test
	void getPropertyWhenInEnvironmentReturnsValue() {
		assertThat(this.propertySource.getProperty('spring')).isEqualTo('boot');
	}
	@Test
	void getPropertyWhenEnvironmentIsNullReturnsNull() {
		this.propertySource.setEnvironment(null);
		assertThat(this.propertySource.getProperty('spring')).isNull();
	}
	@Test
	void getPropertyWhenNotInEnvironmentReturnsNull() {
		assertThat(this.propertySource.getProperty('nope')).isNull();
	}
	@Test
	void containsPropertyWhenInEnvironmentReturnsTrue() {
		assertThat(this.propertySource.containsProperty('spring')).isTrue();
	}
	@Test
	void containsPropertyWhenEnvironmentIsNullReturnsFalse() {
		this.propertySource.setEnvironment(null);
		assertThat(this.propertySource.containsProperty('spring')).isFalse();
	}
	@Test
	void containsPropertyWhenNotInEnvironmentReturnsFalse() {
		assertThat(this.propertySource.containsProperty('nope')).isFalse();
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class CorrelationIdConverterTests {
	private CorrelationIdConverter converter = CorrelationIdConverter.newInstance(null);
	private final LogEvent event = new TestLogEvent();
	@Test
	void defaultPattern() {
		StringBuilder result = new StringBuilder();
		this.converter.format(this.event, result);
		assertThat(result).hasToString('[01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void customPattern() {
		this.converter = CorrelationIdConverter.newInstance(new String[] { 'traceId(0),spanId(0)' });
		StringBuilder result = new StringBuilder();
		this.converter.format(this.event, result);
		assertThat(result).hasToString('[01234567890123456789012345678901-0123456789012345] ');
	}
	static class TestLogEvent extends AbstractLogEvent {
		@Override
		public ReadOnlyStringMap getContextData() {
			return new JdkMapAdapterStringMap(
					Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'), true);
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class ColorConverterTests {
	private final String in = 'in';
	private TestLogEvent event;
	@BeforeAll
	static void setupAnsi() {
		AnsiOutput.setEnabled(AnsiOutput.Enabled.ALWAYS);
	}
	@AfterAll
	static void resetAnsi() {
		AnsiOutput.setEnabled(AnsiOutput.Enabled.DETECT);
	}
	@BeforeEach
	void setUp() {
		this.event = new TestLogEvent();
	}
	@Test
	void black() {
		StringBuilder output = new StringBuilder();
		newConverter('black').format(this.event, output);
		assertThat(output).hasToString('\033[30min\033[0;39m');
	}
	@Test
	void white() {
		StringBuilder output = new StringBuilder();
		newConverter('white').format(this.event, output);
		assertThat(output).hasToString('\033[37min\033[0;39m');
	}
	@Test
	void faint() {
		StringBuilder output = new StringBuilder();
		newConverter('faint').format(this.event, output);
		assertThat(output).hasToString('\033[2min\033[0;39m');
	}
	@Test
	void red() {
		StringBuilder output = new StringBuilder();
		newConverter('red').format(this.event, output);
		assertThat(output).hasToString('\033[31min\033[0;39m');
	}
	@Test
	void green() {
		StringBuilder output = new StringBuilder();
		newConverter('green').format(this.event, output);
		assertThat(output).hasToString('\033[32min\033[0;39m');
	}
	@Test
	void yellow() {
		StringBuilder output = new StringBuilder();
		newConverter('yellow').format(this.event, output);
		assertThat(output).hasToString('\033[33min\033[0;39m');
	}
	@Test
	void blue() {
		StringBuilder output = new StringBuilder();
		newConverter('blue').format(this.event, output);
		assertThat(output).hasToString('\033[34min\033[0;39m');
	}
	@Test
	void magenta() {
		StringBuilder output = new StringBuilder();
		newConverter('magenta').format(this.event, output);
		assertThat(output).hasToString('\033[35min\033[0;39m');
	}
	@Test
	void cyan() {
		StringBuilder output = new StringBuilder();
		newConverter('cyan').format(this.event, output);
		assertThat(output).hasToString('\033[36min\033[0;39m');
	}
	@Test
	void brightBlack() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_black').format(this.event, output);
		assertThat(output).hasToString('\033[90min\033[0;39m');
	}
	@Test
	void brightWhite() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_white').format(this.event, output);
		assertThat(output).hasToString('\033[97min\033[0;39m');
	}
	@Test
	void brightRed() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_red').format(this.event, output);
		assertThat(output).hasToString('\033[91min\033[0;39m');
	}
	@Test
	void brightGreen() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_green').format(this.event, output);
		assertThat(output).hasToString('\033[92min\033[0;39m');
	}
	@Test
	void brightYellow() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_yellow').format(this.event, output);
		assertThat(output).hasToString('\033[93min\033[0;39m');
	}
	@Test
	void brightBlue() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_blue').format(this.event, output);
		assertThat(output).hasToString('\033[94min\033[0;39m');
	}
	@Test
	void brightMagenta() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_magenta').format(this.event, output);
		assertThat(output).hasToString('\033[95min\033[0;39m');
	}
	@Test
	void brightCyan() {
		StringBuilder output = new StringBuilder();
		newConverter('bright_cyan').format(this.event, output);
		assertThat(output).hasToString('\033[96min\033[0;39m');
	}
	@Test
	void highlightFatal() {
		this.event.setLevel(Level.FATAL);
		StringBuilder output = new StringBuilder();
		newConverter(null).format(this.event, output);
		assertThat(output).hasToString('\033[31min\033[0;39m');
	}
	@Test
	void highlightError() {
		this.event.setLevel(Level.ERROR);
		StringBuilder output = new StringBuilder();
		newConverter(null).format(this.event, output);
		assertThat(output).hasToString('\033[31min\033[0;39m');
	}
	@Test
	void highlightWarn() {
		this.event.setLevel(Level.WARN);
		StringBuilder output = new StringBuilder();
		newConverter(null).format(this.event, output);
		assertThat(output).hasToString('\033[33min\033[0;39m');
	}
	@Test
	void highlightDebug() {
		this.event.setLevel(Level.DEBUG);
		StringBuilder output = new StringBuilder();
		newConverter(null).format(this.event, output);
		assertThat(output).hasToString('\033[32min\033[0;39m');
	}
	@Test
	void highlightTrace() {
		this.event.setLevel(Level.TRACE);
		StringBuilder output = new StringBuilder();
		newConverter(null).format(this.event, output);
		assertThat(output).hasToString('\033[32min\033[0;39m');
	}
	private ColorConverter newConverter(String styling) {
		return ColorConverter.newInstance(null, new String[] { this.in, styling });
	}
	static class TestLogEvent extends AbstractLogEvent {
		private Level level;
		@Override
		public Level getLevel() {
			return this.level;
		}
		void setLevel(Level level) {
			this.level = level;
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class LogstashStructuredLogFormatterTests extends AbstractStructuredLoggingTests {
	private LogstashStructuredLogFormatter formatter;
	@BeforeEach
	void setUp() {
		this.formatter = new LogstashStructuredLogFormatter(this.customizer);
	}
	@Test
	void callsCustomizer() {
		then(this.customizer).should().customize(any());
	}
	@Test
	void shouldFormat() {
		MutableLogEvent event = createEvent();
		event.setContextData(new JdkMapAdapterStringMap(Map.of('mdc-1', 'mdc-v-1'), true));
		Log4jMarker marker1 = new Log4jMarker('marker-1');
		marker1.addParents(new Log4jMarker('marker-2'));
		event.setMarker(marker1);
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		String timestamp = DateTimeFormatter.ISO_OFFSET_DATE_TIME
			.format(OffsetDateTime.ofInstant(EVENT_TIME, ZoneId.systemDefault()));
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('@timestamp', timestamp, '@version', '1',
				'message', 'message', 'logger_name', 'org.example.Test', 'thread_name', 'main', 'level', 'INFO',
				'level_value', 400, 'mdc-1', 'mdc-v-1', 'tags', List.of('marker-1', 'marker-2')));
	}
	@Test
	void shouldFormatException() {
		MutableLogEvent event = createEvent();
		event.setThrown(new RuntimeException('Boom'));
		String json = this.formatter.format(event);
		Map<String, Object> deserialized = deserialize(json);
		String stackTrace = (String) deserialized.get('stack_trace');
		assertThat(stackTrace).startsWith(
				'''
						java.lang.RuntimeException: Boom
						\tat org.springframework.boot.logging.log4j2.LogstashStructuredLogFormatterTests.shouldFormatException''');
		assertThat(json).contains(
				'''
						java.lang.RuntimeException: Boom\\n\\tat org.springframework.boot.logging.log4j2.LogstashStructuredLogFormatterTests.shouldFormatException''');
	}
	@Test
	void shouldFormatStructuredMessage() {
		MutableLogEvent event = createEvent();
		event.setMessage(new MapMessage<>().with('foo', true).with('bar', 1.0));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		Map<String, Object> expectedMessage = Map.of('foo', true, 'bar', 1.0);
		String timestamp = DateTimeFormatter.ISO_OFFSET_DATE_TIME
			.format(OffsetDateTime.ofInstant(EVENT_TIME, ZoneId.systemDefault()));
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(
				map('@timestamp', timestamp, '@version', '1', 'message', expectedMessage, 'logger_name',
						'org.example.Test', 'thread_name', 'main', 'level', 'INFO', 'level_value', 400));
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class ElasticCommonSchemaStructuredLogFormatterTests extends AbstractStructuredLoggingTests {
	private ElasticCommonSchemaStructuredLogFormatter formatter;
	@BeforeEach
	void setUp() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.ecs.service.name', 'name');
		environment.setProperty('logging.structured.ecs.service.version', '1.0.0');
		environment.setProperty('logging.structured.ecs.service.environment', 'test');
		environment.setProperty('logging.structured.ecs.service.node-name', 'node-1');
		environment.setProperty('spring.application.pid', '1');
		this.formatter = new ElasticCommonSchemaStructuredLogFormatter(environment, this.customizer);
	}
	@Test
	void callsCustomizer() {
		then(this.customizer).should().customize(any());
	}
	@Test
	void shouldFormat() {
		MutableLogEvent event = createEvent();
		event.setContextData(new JdkMapAdapterStringMap(Map.of('mdc-1', 'mdc-v-1'), true));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('@timestamp', '2024-07-02T08:49:53Z',
				'log.level', 'INFO', 'process.pid', 1, 'process.thread.name', 'main', 'service.name', 'name',
				'service.version', '1.0.0', 'service.environment', 'test', 'service.node.name', 'node-1', 'log.logger',
				'org.example.Test', 'message', 'message', 'mdc-1', 'mdc-v-1', 'ecs.version', '8.11'));
	}
	@Test
	void shouldFormatException() {
		MutableLogEvent event = createEvent();
		event.setThrown(new RuntimeException('Boom'));
		String json = this.formatter.format(event);
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized)
			.containsAllEntriesOf(map('error.type', 'java.lang.RuntimeException', 'error.message', 'Boom'));
		String stackTrace = (String) deserialized.get('error.stack_trace');
		assertThat(stackTrace).startsWith(
				'''
						java.lang.RuntimeException: Boom
						\tat org.springframework.boot.logging.log4j2.ElasticCommonSchemaStructuredLogFormatterTests.shouldFormatException''');
		assertThat(json).contains(
				'''
						java.lang.RuntimeException: Boom\\n\\tat org.springframework.boot.logging.log4j2.ElasticCommonSchemaStructuredLogFormatterTests.shouldFormatException''');
	}
	@Test
	void shouldFormatStructuredMessage() {
		MutableLogEvent event = createEvent();
		event.setMessage(new MapMessage<>().with('foo', true).with('bar', 1.0));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		Map<String, Object> expectedMessage = Map.of('foo', true, 'bar', 1.0);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('@timestamp', '2024-07-02T08:49:53Z',
				'log.level', 'INFO', 'process.pid', 1, 'process.thread.name', 'main', 'service.name', 'name',
				'service.version', '1.0.0', 'service.environment', 'test', 'service.node.name', 'node-1', 'log.logger',
				'org.example.Test', 'message', expectedMessage, 'ecs.version', '8.11'));
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@ExtendWith(OutputCaptureExtension.class)
@ClassPathExclusions('logback-*.jar')
@ConfigureClasspathToPreferLog4j2
class Log4J2LoggingSystemTests extends AbstractLoggingSystemTests {
	private TestLog4J2LoggingSystem loggingSystem;
	private MockEnvironment environment;
	private LoggingInitializationContext initializationContext;
	private Logger logger;
	private Configuration configuration;
	@BeforeEach
	void setup() {
		PluginRegistry.getInstance().clear();
		this.loggingSystem = new TestLog4J2LoggingSystem();
		this.environment = new MockEnvironment();
		this.initializationContext = new LoggingInitializationContext(this.environment);
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		this.configuration = loggerContext.getConfiguration();
		this.loggingSystem.cleanUp();
		this.logger = LogManager.getLogger(getClass());
	}
	@AfterEach
	void cleanUp() {
		this.loggingSystem.cleanUp();
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		loggerContext.stop();
		loggerContext.start(((Reconfigurable) this.configuration).reconfigure());
		PluginRegistry.getInstance().clear();
	}
	@Test
	void noFile(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.logger.info('Hidden');
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		Configuration configuration = this.loggingSystem.getConfiguration();
		assertThat(output).contains('Hello world').doesNotContain('Hidden');
		assertThat(new File(tmpDir() + '/spring.log')).doesNotExist();
		assertThat(configuration.getConfigurationSource().getFile()).isNotNull();
	}
	@Test
	void withFile(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.logger.info('Hidden');
		this.loggingSystem.initialize(this.initializationContext, getRelativeClasspathLocation('log4j2-file.xml'),
				getLogFile(null, tmpDir()));
		this.logger.info('Hello world');
		Configuration configuration = this.loggingSystem.getConfiguration();
		assertThat(output).contains('Hello world').doesNotContain('Hidden');
		assertThat(new File(tmpDir() + '/spring.log')).exists();
		assertThat(configuration.getConfigurationSource().getFile()).isNotNull();
	}
	@Test
	void testNonDefaultConfigLocation(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, 'classpath:log4j2-nondefault.xml',
				getLogFile(tmpDir() + '/tmp.log', null));
		this.logger.info('Hello world');
		Configuration configuration = this.loggingSystem.getConfiguration();
		assertThat(output).contains('Hello world').contains(tmpDir() + '/tmp.log');
		assertThat(new File(tmpDir() + '/tmp.log')).doesNotExist();
		assertThat(configuration.getConfigurationSource().getFile().getAbsolutePath())
			.contains('log4j2-nondefault.xml');
		assertThat(configuration.getWatchManager().getIntervalSeconds()).isEqualTo(30);
	}
	@Test
	void testNonexistentConfigLocation() {
		this.loggingSystem.beforeInitialize();
		assertThatIllegalStateException().isThrownBy(() -> this.loggingSystem.initialize(this.initializationContext,
				'classpath:log4j2-nonexistent.xml', null));
	}
	@Test
	void getSupportedLevels() {
		assertThat(this.loggingSystem.getSupportedLogLevels()).isEqualTo(EnumSet.allOf(LogLevel.class));
	}
	@Test
	void setLevel(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.debug('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', LogLevel.DEBUG);
		this.logger.debug('Hello');
		assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Hello')).isOne();
	}
	@Test
	void setLevelToNull(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.debug('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', LogLevel.DEBUG);
		this.logger.debug('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', null);
		this.logger.debug('Hello');
		assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Hello')).isOne();
	}
	@Test
	void getLoggerConfigurations() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		List<LoggerConfiguration> configurations = this.loggingSystem.getLoggerConfigurations();
		assertThat(configurations).isNotEmpty();
		assertThat(configurations.get(0).getName()).isEqualTo(LoggingSystem.ROOT_LOGGER_NAME);
	}
	@Test
	void getLoggerConfigurationsShouldReturnAllLoggers() {
		LogManager.getLogger('org.springframework.boot.logging.log4j2.Log4J2LoggingSystemTests$Nested');
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		List<LoggerConfiguration> configurations = this.loggingSystem.getLoggerConfigurations();
		assertThat(configurations).isNotEmpty();
		assertThat(configurations.get(0).getName()).isEqualTo(LoggingSystem.ROOT_LOGGER_NAME);
		Map<String, LogLevel> loggers = new LinkedHashMap<>();
		configurations.forEach((logger) -> loggers.put(logger.getName(), logger.getConfiguredLevel()));
		assertIsPresent('org', loggers, null);
		assertIsPresent('org.springframework.boot.logging.log4j2', loggers, null);
		assertIsPresent('org.springframework.boot.logging.log4j2.Log4J2LoggingSystemTests', loggers, LogLevel.DEBUG);
		assertIsPresent('org.springframework.boot.logging.log4j2.Log4J2LoggingSystemTests$Nested', loggers, null);
	}
	@Test // gh-35227
	void getLoggerConfigurationWhenHasCustomLevel() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		String loggerName = getClass().getName();
		org.apache.logging.log4j.Level level = org.apache.logging.log4j.Level.forName('CUSTOM_LEVEL', 1000);
		loggerContext.getConfiguration().addLogger(loggerName, new LoggerConfig(loggerName, level, true));
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration(loggerName);
		assertThat(configuration.getLevelConfiguration().getName()).isEqualTo('CUSTOM_LEVEL');
	}
	private void assertIsPresent(String loggerName, Map<String, LogLevel> loggers, LogLevel logLevel) {
		assertThat(loggers).containsKey(loggerName);
		assertThat(loggers).containsEntry(loggerName, logLevel);
	}
	@Test
	void getLoggerConfiguration() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration(getClass().getName());
		assertThat(configuration)
			.isEqualTo(new LoggerConfiguration(getClass().getName(), LogLevel.DEBUG, LogLevel.DEBUG));
	}
	@Test
	void getLoggerConfigurationShouldReturnLoggerWithNullConfiguredLevel() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration('org');
		assertThat(configuration).isEqualTo(new LoggerConfiguration('org', null, LogLevel.INFO));
	}
	@Test
	void getLoggerConfigurationForNonExistentLoggerShouldReturnNull() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration('doesnotexist');
		assertThat(configuration).isNull();
	}
	@Test
	void setLevelOfUnconfiguredLoggerDoesNotAffectRootConfiguration(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		LogManager.getRootLogger().debug('Hello');
		this.loggingSystem.setLogLevel('foo.bar.baz', LogLevel.DEBUG);
		LogManager.getRootLogger().debug('Hello');
		assertThat(output.toString()).doesNotContain('Hello');
	}
	@Test
	void loggingThatUsesJulIsCaptured(CapturedOutput output) {
		String name = getClass().getName();
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(name, LogLevel.TRACE);
		java.util.logging.Logger julLogger = java.util.logging.Logger.getLogger(name);
		julLogger.setLevel(java.util.logging.Level.INFO);
		julLogger.severe('Hello world');
		assertThat(output).contains('Hello world');
	}
	@Test
	void configLocationsWithNoExtraDependencies() {
		assertThat(this.loggingSystem.getStandardConfigLocations()).contains('log4j2-test.properties',
				'log4j2-test.xml', 'log4j2.properties', 'log4j2.xml');
	}
	@Test
	void configLocationsWithJacksonDatabind() {
		this.loggingSystem.availableClasses(ObjectMapper.class.getName());
		assertThat(this.loggingSystem.getStandardConfigLocations()).containsExactly('log4j2-test.properties',
				'log4j2-test.json', 'log4j2-test.jsn', 'log4j2-test.xml', 'log4j2.properties', 'log4j2.json',
				'log4j2.jsn', 'log4j2.xml');
	}
	@Test
	void configLocationsWithJacksonDataformatYaml() {
		this.loggingSystem.availableClasses('com.fasterxml.jackson.dataformat.yaml.YAMLParser');
		assertThat(this.loggingSystem.getStandardConfigLocations()).containsExactly('log4j2-test.properties',
				'log4j2-test.yaml', 'log4j2-test.yml', 'log4j2-test.xml', 'log4j2.properties', 'log4j2.yaml',
				'log4j2.yml', 'log4j2.xml');
	}
	@Test
	void configLocationsWithJacksonDatabindAndDataformatYaml() {
		this.loggingSystem.availableClasses('com.fasterxml.jackson.dataformat.yaml.YAMLParser',
				ObjectMapper.class.getName());
		assertThat(this.loggingSystem.getStandardConfigLocations()).containsExactly('log4j2-test.properties',
				'log4j2-test.yaml', 'log4j2-test.yml', 'log4j2-test.json', 'log4j2-test.jsn', 'log4j2-test.xml',
				'log4j2.properties', 'log4j2.yaml', 'log4j2.yml', 'log4j2.json', 'log4j2.jsn', 'log4j2.xml');
	}
	@Test
	void configLocationsWithConfigurationFileSystemProperty() {
		System.setProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY, 'custom-log4j2.properties');
		try {
			assertThat(this.loggingSystem.getStandardConfigLocations()).containsExactly('log4j2-test.properties',
					'log4j2-test.xml', 'log4j2.properties', 'log4j2.xml', 'custom-log4j2.properties');
		}
		finally {
			System.clearProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY);
		}
	}
	@Test
	void springConfigLocations() {
		String[] locations = getSpringConfigLocations(this.loggingSystem);
		assertThat(locations).containsExactly('log4j2-test-spring.properties', 'log4j2-test-spring.xml',
				'log4j2-spring.properties', 'log4j2-spring.xml');
	}
	@Test
	void exceptionsIncludeClassPackaging(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, getRelativeClasspathLocation('log4j2-file.xml'),
				getLogFile(null, tmpDir()));
		this.logger.warn('Expected exception', new RuntimeException('Expected'));
		String fileContents = contentOf(new File(tmpDir() + '/spring.log'));
		assertThat(fileContents).contains('[junit-');
		assertThat(output).contains('[junit-');
	}
	@Test
	void beforeInitializeFilterDisablesErrorLogging() {
		this.loggingSystem.beforeInitialize();
		assertThat(this.logger.isErrorEnabled()).isFalse();
		this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir()));
	}
	@Test
	void customExceptionConversionWord(CapturedOutput output) {
		System.setProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD.getEnvironmentVariableName(), '%ex');
		try {
			this.loggingSystem.beforeInitialize();
			this.logger.info('Hidden');
			this.loggingSystem.initialize(this.initializationContext, getRelativeClasspathLocation('log4j2-file.xml'),
					getLogFile(null, tmpDir()));
			this.logger.warn('Expected exception', new RuntimeException('Expected', new RuntimeException('Cause')));
			String fileContents = contentOf(new File(tmpDir() + '/spring.log'));
			assertThat(fileContents).contains('java.lang.RuntimeException: Expected').doesNotContain('Wrapped by:');
			assertThat(output).contains('java.lang.RuntimeException: Expected').doesNotContain('Wrapped by:');
		}
		finally {
			System.clearProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD.getEnvironmentVariableName());
		}
	}
	@Test
	void initializationIsOnlyPerformedOnceUntilCleanedUp() {
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		PropertyChangeListener listener = mock(PropertyChangeListener.class);
		loggerContext.addPropertyChangeListener(listener);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		then(listener).should(times(2)).propertyChange(any(PropertyChangeEvent.class));
		this.loggingSystem.cleanUp();
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		then(listener).should(times(4)).propertyChange(any(PropertyChangeEvent.class));
	}
	@Test
	void getLoggerConfigurationWithResetLevelReturnsNull() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel('com.example', LogLevel.WARN);
		this.loggingSystem.setLogLevel('com.example.test', LogLevel.DEBUG);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration('com.example.test');
		assertThat(configuration)
			.isEqualTo(new LoggerConfiguration('com.example.test', LogLevel.DEBUG, LogLevel.DEBUG));
		this.loggingSystem.setLogLevel('com.example.test', null);
		LoggerConfiguration updatedConfiguration = this.loggingSystem.getLoggerConfiguration('com.example.test');
		assertThat(updatedConfiguration).isNull();
	}
	@Test
	void getLoggerConfigurationWithResetLevelWhenAlreadyConfiguredReturnsParentConfiguredLevel() {
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		loggerContext.getConfiguration()
			.addLogger('com.example.test',
					new LoggerConfig('com.example.test', org.apache.logging.log4j.Level.INFO, false));
		this.loggingSystem.setLogLevel('com.example', LogLevel.WARN);
		this.loggingSystem.setLogLevel('com.example.test', LogLevel.DEBUG);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration('com.example.test');
		assertThat(configuration)
			.isEqualTo(new LoggerConfiguration('com.example.test', LogLevel.DEBUG, LogLevel.DEBUG));
		this.loggingSystem.setLogLevel('com.example.test', null);
		LoggerConfiguration updatedConfiguration = this.loggingSystem.getLoggerConfiguration('com.example.test');
		assertThat(updatedConfiguration)
			.isEqualTo(new LoggerConfiguration('com.example.test', LogLevel.WARN, LogLevel.WARN));
	}
	@Test
	void log4jLevelsArePropagatedToJul() {
		this.loggingSystem.beforeInitialize();
		java.util.logging.Logger rootLogger = java.util.logging.Logger.getLogger('');
		// check if Log4jBridgeHandler is used
		Handler[] handlers = rootLogger.getHandlers();
		assertThat(handlers).hasSize(1);
		assertThat(handlers[0]).isInstanceOf(Log4jBridgeHandler.class);
		this.loggingSystem.initialize(this.initializationContext, null, null);
		java.util.logging.Logger logger = java.util.logging.Logger.getLogger(Log4J2LoggingSystemTests.class.getName());
		logger.info('Log to trigger level propagation');
		assertThat(logger.getLevel()).isNull();
		this.loggingSystem.setLogLevel(Log4J2LoggingSystemTests.class.getName(), LogLevel.DEBUG);
		assertThat(logger.getLevel()).isEqualTo(Level.FINE);
	}
	@Test
	void shutdownHookIsDisabled() {
		assertThat(
				PropertiesUtil.getProperties().getBooleanProperty(ShutdownCallbackRegistry.SHUTDOWN_HOOK_ENABLED, true))
			.isFalse();
	}
	@Test
	void compositeConfigurationWithCustomBaseConfiguration() {
		this.environment.setProperty('logging.log4j2.config.override', 'src/test/resources/log4j2-override.xml');
		this.loggingSystem.initialize(this.initializationContext, 'src/test/resources/log4j2-nondefault.xml', null);
		assertThat(this.loggingSystem.getConfiguration()).isInstanceOf(CompositeConfiguration.class);
	}
	@Test
	void compositeConfigurationWithStandardConfigLocationConfiguration() {
		this.environment.setProperty('logging.log4j2.config.override', 'src/test/resources/log4j2-override.xml');
		this.loggingSystem.initialize(this.initializationContext, null, null);
		assertThat(this.loggingSystem.getConfiguration()).isInstanceOf(CompositeConfiguration.class);
	}
	@Test
	void initializeAttachesEnvironmentToLoggerContext() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		Environment environment = Log4J2LoggingSystem.getEnvironment(loggerContext);
		assertThat(environment).isSameAs(this.environment);
	}
	@Test
	void initializeAddsSpringEnvironmentPropertySource() {
		this.environment.setProperty('spring', 'boot');
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		PropertiesUtil properties = PropertiesUtil.getProperties();
		assertThat(properties.getStringProperty('spring')).isEqualTo('boot');
	}
	@Test
	void environmentIsUpdatedUponReinitialization() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring', 'boot: one');
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(new LoggingInitializationContext(environment), null, null);
		assertThat(PropertiesUtil.getProperties().getStringProperty('spring')).isEqualTo('boot: one');
		this.loggingSystem.cleanUp();
		this.environment.setProperty('spring', 'boot: two');
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		assertThat(PropertiesUtil.getProperties().getStringProperty('spring')).isEqualTo('boot: two');
	}
	@Test
	void nonFileUrlsAreResolvedUsingLog4J2UrlConnectionFactory() {
		this.loggingSystem.beforeInitialize();
		assertThatIllegalStateException()
			.isThrownBy(() -> this.loggingSystem.initialize(this.initializationContext,
					'http://localhost:8080/shouldnotwork', null))
			.havingCause()
			.isInstanceOf(ProtocolException.class)
			.withMessageContaining('http has not been enabled');
	}
	@Test
	void correlationLoggingToFileWhenExpectCorrelationIdTrueAndMdcContent() {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		new LoggingSystemProperties(this.environment).apply();
		File file = new File(tmpDir(), 'log4j2-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, logFile);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world'))
			.contains(' [01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void correlationLoggingToConsoleWhenExpectCorrelationIdTrueAndMdcContent(CapturedOutput output) {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.contains(' [01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void correlationLoggingToConsoleWhenExpectCorrelationIdFalseAndMdcContent(CapturedOutput output) {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'false');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).doesNotContain('0123456789012345');
	}
	@Test
	void correlationLoggingToConsoleWhenExpectCorrelationIdTrueAndNoMdcContent(CapturedOutput output) {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.contains(' [                                                 ] ');
	}
	@Test
	void correlationLoggingToConsoleWhenHasCorrelationPattern(CapturedOutput output) {
		this.environment.setProperty('logging.pattern.correlation', '%correlationId{spanId(0),traceId(0)}');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.contains(' [0123456789012345-01234567890123456789012345678901] ');
	}
	@Test
	void applicationNameLoggingToConsoleWhenHasApplicationName(CapturedOutput output) {
		this.environment.setProperty('spring.application.name', 'myapp');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[myapp] ');
	}
	@Test
	void applicationNameLoggingToConsoleWhenHasApplicationNameWithParenthesis(CapturedOutput output) {
		this.environment.setProperty('spring.application.name', 'myapp (dev)');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[myapp (dev)] ');
	}
	@Test
	void applicationNameLoggingToConsoleWhenDisabled(CapturedOutput output) {
		this.environment.setProperty('spring.application.name', 'myapp');
		this.environment.setProperty('logging.include-application-name', 'false');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).doesNotContain('${sys:LOGGED_APPLICATION_NAME}')
			.doesNotContain('${sys:APPLICATION_NAME}')
			.doesNotContain('myapp');
	}
	@Test
	void applicationNameLoggingToFileWhenHasApplicationName() {
		this.environment.setProperty('spring.application.name', 'myapp');
		new LoggingSystemProperties(this.environment).apply();
		File file = new File(tmpDir(), 'log4j2-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[myapp] ');
	}
	@Test
	void applicationNameLoggingToFileWhenHasApplicationNameWithParenthesis() {
		this.environment.setProperty('spring.application.name', 'myapp (dev)');
		new LoggingSystemProperties(this.environment).apply();
		File file = new File(tmpDir(), 'log4j2-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[myapp (dev)] ');
	}
	@Test
	void applicationNameLoggingToFileWhenDisabled() {
		this.environment.setProperty('spring.application.name', 'myapp');
		this.environment.setProperty('logging.include-application-name', 'false');
		new LoggingSystemProperties(this.environment).apply();
		File file = new File(tmpDir(), 'log4j2-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).doesNotContain('${sys:LOGGED_APPLICATION_NAME}')
			.doesNotContain('${sys:APPLICATION_NAME}')
			.doesNotContain('myapp');
	}
	@Test
	void applicationGroupLoggingToConsoleWhenHasApplicationGroup(CapturedOutput output) {
		this.environment.setProperty('spring.application.group', 'mygroup');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[mygroup] ');
	}
	@Test
	void applicationGroupLoggingToConsoleWhenHasApplicationGroupWithParenthesis(CapturedOutput output) {
		this.environment.setProperty('spring.application.group', 'mygroup (dev)');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[mygroup (dev)] ');
	}
	@Test
	void applicationGroupLoggingToConsoleWhenDisabled(CapturedOutput output) {
		this.environment.setProperty('spring.application.group', 'mygroup');
		this.environment.setProperty('logging.include-application-group', 'false');
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).doesNotContain('${sys:APPLICATION_GROUP}')
			.doesNotContain('mygroup');
	}
	@Test
	void applicationGroupLoggingToFileWhenHasApplicationGroup() {
		this.environment.setProperty('spring.application.group', 'mygroup');
		new LoggingSystemProperties(this.environment).apply();
		File file = new File(tmpDir(), 'log4j2-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[mygroup] ');
	}
	@Test
	void applicationGroupLoggingToFileWhenHasApplicationGroupWithParenthesis() {
		this.environment.setProperty('spring.application.group', 'mygroup (dev)');
		new LoggingSystemProperties(this.environment).apply();
		File file = new File(tmpDir(), 'log4j2-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[mygroup (dev)] ');
	}
	@Test
	void applicationGroupLoggingToFileWhenDisabled() {
		this.environment.setProperty('spring.application.group', 'mygroup');
		this.environment.setProperty('logging.include-application-group', 'false');
		new LoggingSystemProperties(this.environment).apply();
		File file = new File(tmpDir(), 'log4j2-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		this.loggingSystem.setStandardConfigLocations(false);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).doesNotContain('${sys:APPLICATION_GROUP}')
			.doesNotContain('mygroup');
	}
	@Test
	void shouldNotContainAnsiEscapeCodes(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(output).doesNotContain('\033[');
	}
	private String getRelativeClasspathLocation(String fileName) {
		String defaultPath = ClassUtils.getPackageName(getClass());
		defaultPath = defaultPath.replace(".", "/");
		defaultPath = defaultPath + '/' + fileName;
		defaultPath = 'classpath:' + defaultPath;
		return defaultPath;
	}
	/**
	 * Used for testing that loggers in nested classes are returned by
	 * {@link Log4J2LoggingSystem#getLoggerConfigurations()} .
	 */
	static class Nested {
		@SuppressWarnings('unused')
		private static final Log logger = LogFactory.getLog(Nested.class);
	}
}
/*
package org.springframework.boot.logging.log4j2;
class TestLog4J2LoggingSystem extends Log4J2LoggingSystem {
	private final List<String> availableClasses = new ArrayList<>();
	private String[] standardConfigLocations;
	TestLog4J2LoggingSystem() {
		super(TestLog4J2LoggingSystem.class.getClassLoader());
	}
	Configuration getConfiguration() {
		return ((org.apache.logging.log4j.core.LoggerContext) LogManager.getContext(false)).getConfiguration();
	}
	@Override
	protected boolean isClassAvailable(String className) {
		return this.availableClasses.contains(className);
	}
	void availableClasses(String... classNames) {
		Collections.addAll(this.availableClasses, classNames);
	}
	@Override
	protected String[] getStandardConfigLocations() {
		return (this.standardConfigLocations != null) ? this.standardConfigLocations
				: super.getStandardConfigLocations();
	}
	void setStandardConfigLocations(boolean standardConfigLocations) {
		this.standardConfigLocations = (!standardConfigLocations) ? new String[0] : null;
	}
	void setStandardConfigLocations(String[] standardConfigLocations) {
		this.standardConfigLocations = standardConfigLocations;
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@ExtendWith(MockitoExtension.class)
abstract class AbstractStructuredLoggingTests {
	static final Instant EVENT_TIME = Instant.ofEpochMilli(1719910193000L);
	private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
	@Mock
	StructureLoggingJsonMembersCustomizer<?> customizer;
	protected Map<String, Object> map(Object... values) {
		assertThat(values.length).isEven();
		Map<String, Object> result = new HashMap<>();
		for (int i = 0; i < values.length; i += 2) {
			result.put(values[i].toString(), values[i + 1]);
		}
		return result;
	}
	protected static MutableLogEvent createEvent() {
		MutableLogEvent event = new MutableLogEvent();
		event.setTimeMillis(EVENT_TIME.toEpochMilli());
		event.setLevel(Level.INFO);
		event.setThreadName('main');
		event.setLoggerName('org.example.Test');
		event.setMessage(new SimpleMessage('message'));
		return event;
	}
	protected Map<String, Object> deserialize(String json) {
		try {
			return OBJECT_MAPPER.readValue(json, new TypeReference<>() {
			});
		}
		catch (JsonProcessingException ex) {
			Assertions.fail('Failed to deserialize JSON: ' + json, ex);
			return null;
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class ExtendedWhitespaceThrowablePatternConverterTests {
	private final ThrowablePatternConverter converter = ExtendedWhitespaceThrowablePatternConverter
		.newInstance(new DefaultConfiguration(), new String[] {});
	@Test
	void noStackTrace() {
		LogEvent event = Log4jLogEvent.newBuilder().build();
		StringBuilder builder = new StringBuilder();
		this.converter.format(event, builder);
		assertThat(builder).isEmpty();
	}
	@Test
	void withStackTrace() {
		LogEvent event = Log4jLogEvent.newBuilder().setThrown(new Exception()).build();
		StringBuilder builder = new StringBuilder();
		this.converter.format(event, builder);
		assertThat(builder).startsWith(System.lineSeparator()).endsWith(System.lineSeparator());
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class StructuredLoggingLayoutTests extends AbstractStructuredLoggingTests {
	private MockEnvironment environment;
	private LoggerContext loggerContext;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.loggerContext = (LoggerContext) LogManager.getContext(false);
		this.loggerContext.putObject(Log4J2LoggingSystem.ENVIRONMENT_KEY, this.environment);
	}
	@AfterEach
	void cleanup() {
		this.loggerContext.removeObject(Log4J2LoggingSystem.ENVIRONMENT_KEY);
	}
	@Test
	void shouldSupportEcsCommonFormat() {
		StructuredLogLayout layout = newBuilder().setFormat('ecs').build();
		String json = layout.toSerializable(createEvent());
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsKey('ecs.version');
	}
	@Test
	void shouldSupportLogstashCommonFormat() {
		StructuredLogLayout layout = newBuilder().setFormat('logstash').build();
		String json = layout.toSerializable(createEvent());
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsKey('@version');
	}
	@Test
	void shouldSupportCustomFormat() {
		StructuredLogLayout layout = newBuilder().setFormat(CustomLog4j2StructuredLoggingFormatter.class.getName())
			.build();
		String format = layout.toSerializable(createEvent());
		assertThat(format).isEqualTo('custom-format');
	}
	@Test
	void shouldInjectCustomFormatConstructorParameters() {
		this.environment.setProperty('spring.application.pid', '42');
		StructuredLogLayout layout = newBuilder()
			.setFormat(CustomLog4j2StructuredLoggingFormatterWithInjection.class.getName())
			.build();
		String format = layout.toSerializable(createEvent());
		assertThat(format).isEqualTo('custom-format-with-injection pid=42');
	}
	@Test
	void shouldCheckTypeArgument() {
		assertThatIllegalArgumentException().isThrownBy(
				() -> newBuilder().setFormat(CustomLog4j2StructuredLoggingFormatterWrongType.class.getName()).build())
			.withMessageContaining('must be org.apache.logging.log4j.core.LogEvent but was java.lang.String');
	}
	@Test
	void shouldCheckTypeArgumentWithRawType() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> newBuilder().setFormat(CustomLog4j2StructuredLoggingFormatterRawType.class.getName()).build())
			.withMessageContaining('must be org.apache.logging.log4j.core.LogEvent but was null');
	}
	@Test
	void shouldFailIfNoCommonOrCustomFormatIsSet() {
		assertThatIllegalArgumentException().isThrownBy(() -> newBuilder().setFormat('does-not-exist').build())
			.withMessageContaining('Unknown format "does-not-exist". '
					+ 'Values can be a valid fully-qualified class name or one of the common formats: [ecs, gelf, logstash]');
	}
	private Builder newBuilder() {
		Builder builder = StructuredLogLayout.newBuilder();
		ReflectionTestUtils.setField(builder, 'loggerContext', this.loggerContext);
		return builder;
	}
	static final class CustomLog4j2StructuredLoggingFormatter implements StructuredLogFormatter<LogEvent> {
		@Override
		public String format(LogEvent event) {
			return 'custom-format';
		}
	}
	static final class CustomLog4j2StructuredLoggingFormatterWithInjection implements StructuredLogFormatter<LogEvent> {
		private final Environment environment;
		CustomLog4j2StructuredLoggingFormatterWithInjection(Environment environment) {
			this.environment = environment;
		}
		@Override
		public String format(LogEvent event) {
			return 'custom-format-with-injection pid=' + this.environment.getProperty('spring.application.pid');
		}
	}
	static final class CustomLog4j2StructuredLoggingFormatterWrongType implements StructuredLogFormatter<String> {
		@Override
		public String format(String event) {
			return event;
		}
	}
	@SuppressWarnings('rawtypes')
	static final class CustomLog4j2StructuredLoggingFormatterRawType implements StructuredLogFormatter {
		@Override
		public String format(Object event) {
			return '';
		}
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class WhitespaceThrowablePatternConverterTests {
	private final ThrowablePatternConverter converter = WhitespaceThrowablePatternConverter
		.newInstance(new DefaultConfiguration(), new String[] {});
	@Test
	void noStackTrace() {
		LogEvent event = Log4jLogEvent.newBuilder().build();
		StringBuilder builder = new StringBuilder();
		this.converter.format(event, builder);
		assertThat(builder).isEmpty();
	}
	@Test
	void withStackTrace() {
		LogEvent event = Log4jLogEvent.newBuilder().setThrown(new Exception()).build();
		StringBuilder builder = new StringBuilder();
		this.converter.format(event, builder);
		assertThat(builder.toString()).startsWith(System.lineSeparator()).endsWith(System.lineSeparator());
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class SpringEnvironmentLookupTests {
	private MockEnvironment environment;
	private LoggerContext loggerContext;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.loggerContext = (LoggerContext) LogManager.getContext(false);
		this.loggerContext.putObject(Log4J2LoggingSystem.ENVIRONMENT_KEY, this.environment);
	}
	@AfterEach
	void cleanup() {
		this.loggerContext.removeObject(Log4J2LoggingSystem.ENVIRONMENT_KEY);
	}
	@Test
	void lookupWhenFoundInEnvironmentReturnsValue() {
		this.environment.setProperty('test', 'test');
		Interpolator lookup = createLookup(this.loggerContext);
		assertThat(lookup.lookup('spring:test')).isEqualTo('test');
	}
	@Test
	void lookupWhenNotFoundInEnvironmentReturnsNull() {
		Interpolator lookup = createLookup(this.loggerContext);
		assertThat(lookup.lookup('spring:test')).isNull();
	}
	@Test
	void lookupWhenNoSpringEnvironmentThrowsException() {
		this.loggerContext.removeObject(Log4J2LoggingSystem.ENVIRONMENT_KEY);
		Interpolator lookup = createLookup(this.loggerContext);
		assertThatIllegalStateException().isThrownBy(() -> lookup.lookup('spring:test'))
			.withMessage('Unable to obtain Spring Environment from LoggerContext. '
					+ 'This can happen if your log4j2 configuration filename does not end with "-spring" '
					+ '(for example using "log4j2.xml" instead of "log4j2-spring.xml")');
	}
	private Interpolator createLookup(LoggerContext context) {
		Interpolator lookup = new Interpolator();
		lookup.setConfiguration(context.getConfiguration());
		lookup.setLoggerContext(context);
		return lookup;
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class Log4j2FileXmlTests extends Log4j2XmlTests {
	@TempDir
	File temp;
	@Override
	@AfterEach
	void stopConfiguration() {
		super.stopConfiguration();
		for (LoggingSystemProperty property : LoggingSystemProperty.values()) {
			System.getProperties().remove(property.getEnvironmentVariableName());
		}
	}
	@Test
	void whenLogExceptionConversionWordIsNotConfiguredThenFileAppenderUsesDefault() {
		assertThat(fileAppenderPattern()).contains('%xwEx');
	}
	@Test
	void whenLogExceptionConversionWordIsSetThenFileAppenderUsesIt() {
		withSystemProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD.getEnvironmentVariableName(), 'custom',
				() -> assertThat(fileAppenderPattern()).contains('custom'));
	}
	@Test
	void whenLogLevelPatternIsNotConfiguredThenFileAppenderUsesDefault() {
		assertThat(fileAppenderPattern()).contains('%5p');
	}
	@Test
	void whenLogLevelPatternIsSetThenFileAppenderUsesIt() {
		withSystemProperty(LoggingSystemProperty.LEVEL_PATTERN.getEnvironmentVariableName(), 'custom',
				() -> assertThat(fileAppenderPattern()).contains('custom'));
	}
	@Test
	void whenLogLDateformatPatternIsNotConfiguredThenFileAppenderUsesDefault() {
		assertThat(fileAppenderPattern()).contains('yyyy-MM-dd"T"HH:mm:ss.SSSXXX');
	}
	@Test
	void whenLogDateformatPatternIsSetThenFileAppenderUsesIt() {
		withSystemProperty(LoggingSystemProperty.DATEFORMAT_PATTERN.getEnvironmentVariableName(), 'dd-MM-yyyy',
				() -> assertThat(fileAppenderPattern()).contains('dd-MM-yyyy'));
	}
	@Override
	protected String getConfigFileName() {
		return 'log4j2-file.xml';
	}
	@Override
	protected void prepareConfiguration() {
		System.setProperty(LoggingSystemProperty.LOG_FILE.getEnvironmentVariableName(),
				new File(this.temp, 'test.log').getAbsolutePath());
		super.prepareConfiguration();
	}
	private String fileAppenderPattern() {
		prepareConfiguration();
		return ((PatternLayout) this.configuration.getAppender('File').getLayout()).getConversionPattern();
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@ExtendWith(OutputCaptureExtension.class)
class GraylogExtendedLogFormatStructuredLogFormatterTests extends AbstractStructuredLoggingTests {
	private GraylogExtendedLogFormatStructuredLogFormatter formatter;
	@BeforeEach
	void setUp() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.gelf.host', 'name');
		environment.setProperty('logging.structured.gelf.service.version', '1.0.0');
		environment.setProperty('spring.application.pid', '1');
		this.formatter = new GraylogExtendedLogFormatStructuredLogFormatter(environment, this.customizer);
	}
	@Test
	void callsCustomizer() {
		then(this.customizer).should().customize(any());
	}
	@Test
	void shouldFormat() {
		MutableLogEvent event = createEvent();
		event.setContextData(new JdkMapAdapterStringMap(Map.of('mdc-1', 'mdc-v-1'), true));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(
				map('version', '1.1', 'host', 'name', 'timestamp', 1719910193.0, 'level', 6, '_level_name', 'INFO',
						'_process_pid', 1, '_process_thread_name', 'main', '_service_version', '1.0.0', '_log_logger',
						'org.example.Test', 'short_message', 'message', '_mdc-1', 'mdc-v-1'));
	}
	@Test
	void shouldFormatMillisecondsInTimestamp() {
		MutableLogEvent event = createEvent();
		event.setTimeMillis(1719910193123L);
		String json = this.formatter.format(event);
		assertThat(json).contains('\'timestamp\':1719910193.123');
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('version', '1.1', 'host', 'name', 'timestamp',
				1719910193.123, 'level', 6, '_level_name', 'INFO', '_process_pid', 1, '_process_thread_name', 'main',
				'_service_version', '1.0.0', '_log_logger', 'org.example.Test', 'short_message', 'message'));
	}
	@Test
	void shouldNotAllowInvalidFieldNames(CapturedOutput output) {
		MutableLogEvent event = createEvent();
		event.setContextData(new JdkMapAdapterStringMap(Map.of('/', 'value'), true));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('version', '1.1', 'host', 'name', 'timestamp',
				1719910193.0, 'level', 6, '_level_name', 'INFO', '_process_pid', 1, '_process_thread_name', 'main',
				'_service_version', '1.0.0', '_log_logger', 'org.example.Test', 'short_message', 'message'));
		assertThat(output).contains('"/" is not a valid field name according to GELF standard');
	}
	@Test
	void shouldNotAllowIllegalFieldNames(CapturedOutput output) {
		MutableLogEvent event = createEvent();
		event.setContextData(new JdkMapAdapterStringMap(Map.of('id', '1'), true));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('version', '1.1', 'host', 'name', 'timestamp',
				1719910193.0, 'level', 6, '_level_name', 'INFO', '_process_pid', 1, '_process_thread_name', 'main',
				'_service_version', '1.0.0', '_log_logger', 'org.example.Test', 'short_message', 'message'));
		assertThat(output).contains('"id" is an illegal field name according to GELF standard');
	}
	@Test
	void shouldNotAddDoubleUnderscoreToCustomFields() {
		MutableLogEvent event = createEvent();
		event.setContextData(new JdkMapAdapterStringMap(Map.of('_custom', 'value'), true));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(
				map('version', '1.1', 'host', 'name', 'timestamp', 1719910193.0, 'level', 6, '_level_name', 'INFO',
						'_process_pid', 1, '_process_thread_name', 'main', '_service_version', '1.0.0', '_log_logger',
						'org.example.Test', 'short_message', 'message', '_custom', 'value'));
	}
	@Test
	void shouldFormatException() {
		MutableLogEvent event = createEvent();
		event.setThrown(new RuntimeException('Boom'));
		String json = this.formatter.format(event);
		Map<String, Object> deserialized = deserialize(json);
		String fullMessage = (String) deserialized.get('full_message');
		String stackTrace = (String) deserialized.get('_error_stack_trace');
		assertThat(fullMessage).startsWith(
				'''
						message
						java.lang.RuntimeException: Boom
						\tat org.springframework.boot.logging.log4j2.GraylogExtendedLogFormatStructuredLogFormatterTests.shouldFormatException''');
		assertThat(stackTrace).startsWith(
				'''
						java.lang.RuntimeException: Boom
						\tat org.springframework.boot.logging.log4j2.GraylogExtendedLogFormatStructuredLogFormatterTests.shouldFormatException''');
		assertThat(deserialized)
			.containsAllEntriesOf(map('_error_type', 'java.lang.RuntimeException', '_error_message', 'Boom'));
		assertThat(json).contains(
				'''
						message\\n\\njava.lang.RuntimeException: Boom\\n\\tat org.springframework.boot.logging.log4j2.GraylogExtendedLogFormatStructuredLogFormatterTests.shouldFormatException''');
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class EnclosedInSquareBracketsConverterTests {
	private TestLogEvent event;
	@Test
	void transformWhenEmpty() {
		StringBuilder output = new StringBuilder();
		newConverter('').format(this.event, output);
		assertThat(output).hasToString('');
	}
	@Test
	void transformWhenName() {
		StringBuilder output = new StringBuilder();
		newConverter('My Application').format(this.event, output);
		assertThat(output).hasToString('[My Application] ');
	}
	private EnclosedInSquareBracketsConverter newConverter(String in) {
		return EnclosedInSquareBracketsConverter.newInstance(null, new String[] { in });
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@ExtendWith(OutputCaptureExtension.class)
@ClassPathExclusions('logback-*.jar')
@ConfigureClasspathToPreferLog4j2
class SpringProfileArbiterTests {
	private CapturedOutput output;
	private final TestLog4J2LoggingSystem loggingSystem = new TestLog4J2LoggingSystem();
	private final MockEnvironment environment = new MockEnvironment();
	private final LoggingInitializationContext initializationContext = new LoggingInitializationContext(
			this.environment);
	private Logger logger;
	private Configuration configuration;
	@BeforeEach
	void setup(CapturedOutput output) {
		this.output = output;
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		this.configuration = loggerContext.getConfiguration();
		this.loggingSystem.cleanUp();
		this.logger = LogManager.getLogger(getClass());
		cleanUpPropertySources();
	}
	@AfterEach
	void cleanUp() {
		this.loggingSystem.cleanUp();
		LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
		loggerContext.stop();
		loggerContext.start(((Reconfigurable) this.configuration).reconfigure());
		cleanUpPropertySources();
	}
	@SuppressWarnings('unchecked')
	private void cleanUpPropertySources() { // https://issues.apache.org/jira/browse/LOG4J2-3618
		PropertiesUtil properties = PropertiesUtil.getProperties();
		Object environment = ReflectionTestUtils.getField(properties, 'environment');
		Set<PropertySource> sources = (Set<PropertySource>) ReflectionTestUtils.getField(environment, 'sources');
		sources.removeIf((candidate) -> candidate instanceof SpringEnvironmentPropertySource
				|| candidate instanceof SpringBootPropertySource);
	}
	@Test
	void profileActive() {
		this.environment.setActiveProfiles('production');
		initialize('production-profile.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void multipleNamesFirstProfileActive() {
		this.environment.setActiveProfiles('production');
		initialize('multi-profile-names.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void multipleNamesSecondProfileActive() {
		this.environment.setActiveProfiles('test');
		initialize('multi-profile-names.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void profileNotActive() {
		initialize('production-profile.xml');
		this.logger.trace('Hello');
		assertThat(this.output).doesNotContain('Hello');
	}
	@Test
	void profileExpressionMatchFirst() {
		this.environment.setActiveProfiles('production');
		initialize('profile-expression.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void profileExpressionMatchSecond() {
		this.environment.setActiveProfiles('test');
		initialize('profile-expression.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void profileExpressionNoMatch() {
		this.environment.setActiveProfiles('development');
		initialize('profile-expression.xml');
		this.logger.trace('Hello');
		assertThat(this.output).doesNotContain('Hello');
	}
	private void initialize(String config) {
		this.environment.setProperty('logging.log4j2.config.override', getPackageResource(config));
		this.loggingSystem.initialize(this.initializationContext, null, null);
	}
	private String getPackageResource(String fileName) {
		String path = ClassUtils.getPackageName(getClass());
		return 'src/test/resources/' + path.replace(".", "/") + '/' + fileName;
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
@ClassPathExclusions({ 'jakarta.servlet-api-*.jar', 'tomcat-embed-core-*.jar' })
class SpringBootPropertySourceTests {
	@Test
	void propertySourceHasDisabledShutdownHook() {
		// Log4j2 disables the hook automatically in a web app so we check that it doesn"t
		// think it"s in one
		assertThat(Constants.IS_WEB_APP).isFalse();
		assertThat(((ShutdownCallbackRegistry) LogManager.getFactory()).addShutdownCallback(() -> {
		})).isNull();
	}
	@Test
	void allDefaultMethodsAreImplemented() {
		assertThat(Stream.of(SpringBootPropertySource.class.getMethods()).filter(Method::isDefault)).isEmpty();
	}
}
/*
package org.springframework.boot.logging.log4j2;
/**
class Log4j2XmlTests {
	protected Configuration configuration;
	@AfterEach
	void stopConfiguration() {
		this.configuration.stop();
	}
	@Test
	void whenLogExceptionConversionWordIsNotConfiguredThenConsoleUsesDefault() {
		assertThat(consolePattern()).contains('%xwEx');
	}
	@Test
	void whenLogExceptionConversionWordIsSetThenConsoleUsesIt() {
		withSystemProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD.getEnvironmentVariableName(), 'custom',
				() -> assertThat(consolePattern()).contains('custom'));
	}
	@Test
	void whenLogLevelPatternIsNotConfiguredThenConsoleUsesDefault() {
		assertThat(consolePattern()).contains('%5p');
	}
	@Test
	void whenLogLevelPatternIsSetThenConsoleUsesIt() {
		withSystemProperty(LoggingSystemProperty.LEVEL_PATTERN.getEnvironmentVariableName(), 'custom',
				() -> assertThat(consolePattern()).contains('custom'));
	}
	@Test
	void whenLogLDateformatPatternIsNotConfiguredThenConsoleUsesDefault() {
		assertThat(consolePattern()).contains('yyyy-MM-dd"T"HH:mm:ss.SSSXXX');
	}
	@Test
	void whenLogDateformatPatternIsSetThenConsoleUsesIt() {
		withSystemProperty(LoggingSystemProperty.DATEFORMAT_PATTERN.getEnvironmentVariableName(), 'dd-MM-yyyy',
				() -> assertThat(consolePattern()).contains('dd-MM-yyyy'));
	}
	protected void withSystemProperty(String name, String value, Runnable action) {
		String previous = System.setProperty(name, value);
		action.run();
		if (previous == null) {
			System.clearProperty(name);
		}
		else {
			System.setProperty(name, previous);
		}
	}
	private String consolePattern() {
		prepareConfiguration();
		return ((PatternLayout) this.configuration.getAppender('Console').getLayout()).getConversionPattern();
	}
	protected void prepareConfiguration() {
		this.configuration = initializeConfiguration();
		this.configuration.start();
	}
	protected Configuration initializeConfiguration() {
		LoggerContext context = new LoggerContext('test');
		Configuration configuration = ConfigurationFactory.getInstance()
			.getConfiguration(context, configurationSource());
		configuration.initialize();
		return configuration;
	}
	private ConfigurationSource configurationSource() {
		try (InputStream in = getClass().getResourceAsStream(getConfigFileName())) {
			return new ConfigurationSource(in);
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	protected String getConfigFileName() {
		return 'log4j2.xml';
	}
}
/*
package org.springframework.boot.logging;
/**
class LoggerConfigurationTests {
	@Test
	void createWithLogLevelWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LoggerConfiguration(null, null, LogLevel.DEBUG))
			.withMessage('Name must not be null');
	}
	@Test
	void createWithLogLevelWhenEffectiveLevelIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LoggerConfiguration('test', null, (LogLevel) null))
			.withMessage('EffectiveLevel must not be null');
	}
	@Test
	void createWithLevelConfigurationWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new LoggerConfiguration(null, null, LevelConfiguration.of(LogLevel.DEBUG)))
			.withMessage('Name must not be null');
	}
	@Test
	void createWithLevelConfigurationWhenInheritedLevelConfigurationIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new LoggerConfiguration('test', null, (LevelConfiguration) null))
			.withMessage('InheritedLevelConfiguration must not be null');
	}
	@Test
	void getNameReturnsName() {
		LoggerConfiguration configuration = new LoggerConfiguration('test', null,
				LevelConfiguration.of(LogLevel.DEBUG));
		assertThat(configuration.getName()).isEqualTo('test');
	}
	@Test
	void getConfiguredLevelWhenConfiguredReturnsLevel() {
		LoggerConfiguration configuration = new LoggerConfiguration('test', LevelConfiguration.of(LogLevel.DEBUG),
				LevelConfiguration.of(LogLevel.DEBUG));
		assertThat(configuration.getConfiguredLevel()).isEqualTo(LogLevel.DEBUG);
	}
	@Test
	void getConfiguredLevelWhenNotConfiguredReturnsNull() {
		LoggerConfiguration configuration = new LoggerConfiguration('test', null,
				LevelConfiguration.of(LogLevel.DEBUG));
		assertThat(configuration.getConfiguredLevel()).isNull();
	}
	@Test
	void getEffectiveLevelReturnsEffectiveLevel() {
		LoggerConfiguration configuration = new LoggerConfiguration('test', null,
				LevelConfiguration.of(LogLevel.DEBUG));
		assertThat(configuration.getEffectiveLevel()).isEqualTo(LogLevel.DEBUG);
	}
	@Test
	void getLevelConfigurationWithDirectScopeWhenConfiguredReturnsConfiguration() {
		LevelConfiguration assigned = LevelConfiguration.of(LogLevel.DEBUG);
		LoggerConfiguration configuration = new LoggerConfiguration('test', assigned,
				LevelConfiguration.of(LogLevel.DEBUG));
		assertThat(configuration.getLevelConfiguration(ConfigurationScope.DIRECT)).isEqualTo(assigned);
	}
	@Test
	void getLevelConfigurationWithDirectScopeWhenNotConfiguredReturnsNull() {
		LoggerConfiguration configuration = new LoggerConfiguration('test', null,
				LevelConfiguration.of(LogLevel.DEBUG));
		assertThat(configuration.getLevelConfiguration(ConfigurationScope.DIRECT)).isNull();
	}
	@Test
	void getLevelConfigurationWithInheritedScopeReturnsConfiguration() {
		LevelConfiguration effective = LevelConfiguration.of(LogLevel.DEBUG);
		LoggerConfiguration configuration = new LoggerConfiguration('test', null, effective);
		assertThat(configuration.getLevelConfiguration(ConfigurationScope.INHERITED)).isEqualTo(effective);
	}
	/**
	 * Tests for {@link LevelConfiguration}.
	 */
	@Nested
	class LevelConfigurationTests {
		@Test
		void ofWhenLogLevelIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> LevelConfiguration.of(null))
				.withMessage('LogLevel must not be null');
		}
		@Test
		void ofCreatesConfiguration() {
			LevelConfiguration configuration = LevelConfiguration.of(LogLevel.DEBUG);
			assertThat(configuration.getLevel()).isEqualTo(LogLevel.DEBUG);
		}
		@Test
		void ofCustomWhenNameIsNullThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> LevelConfiguration.ofCustom(null))
				.withMessage('Name must not be empty');
		}
		@Test
		void ofCustomWhenNameIsEmptyThrowsException() {
			assertThatIllegalArgumentException().isThrownBy(() -> LevelConfiguration.ofCustom(''))
				.withMessage('Name must not be empty');
		}
		@Test
		void ofCustomCreatesConfiguration() {
			LevelConfiguration configuration = LevelConfiguration.ofCustom('FINE');
			assertThat(configuration).isNotNull();
		}
		@Test
		void getNameWhenFromLogLevelReturnsName() {
			LevelConfiguration configuration = LevelConfiguration.of(LogLevel.DEBUG);
			assertThat(configuration.getName()).isEqualTo('DEBUG');
		}
		@Test
		void getNameWhenCustomReturnsName() {
			LevelConfiguration configuration = LevelConfiguration.ofCustom('FINE');
			assertThat(configuration.getName()).isEqualTo('FINE');
		}
		@Test
		void getLevelWhenCustomThrowsException() {
			LevelConfiguration configuration = LevelConfiguration.ofCustom('FINE');
			assertThatIllegalStateException().isThrownBy(configuration::getLevel)
				.withMessage('Unable to provide LogLevel for "FINE"');
		}
		@Test
		void getLevelReturnsLevel() {
			LevelConfiguration configuration = LevelConfiguration.of(LogLevel.DEBUG);
			assertThat(configuration.getLevel()).isEqualTo(LogLevel.DEBUG);
		}
		@Test
		void isCustomWhenNotCustomReturnsFalse() {
			LevelConfiguration configuration = LevelConfiguration.of(LogLevel.DEBUG);
			assertThat(configuration.isCustom()).isFalse();
		}
		@Test
		void isCustomWhenCustomReturnsTrue() {
			LevelConfiguration configuration = LevelConfiguration.ofCustom('DEBUG');
			assertThat(configuration.isCustom()).isTrue();
		}
	}
}
/*
package org.springframework.boot.logging;
/**
class LoggingSystemTests {
	@AfterEach
	void clearSystemProperty() {
		System.clearProperty(LoggingSystem.SYSTEM_PROPERTY);
	}
	@Test
	void logbackIsTheDefaultLoggingSystem() {
		assertThat(LoggingSystem.get(getClass().getClassLoader())).isInstanceOf(LogbackLoggingSystem.class);
	}
	@Test
	void loggingSystemCanBeDisabled() {
		System.setProperty(LoggingSystem.SYSTEM_PROPERTY, LoggingSystem.NONE);
		LoggingSystem loggingSystem = LoggingSystem.get(getClass().getClassLoader());
		assertThat(loggingSystem).isInstanceOf(NoOpLoggingSystem.class);
	}
	@Test
	void getLoggerConfigurationIsUnsupported() {
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> new StubLoggingSystem().getLoggerConfiguration('test-logger-name'));
	}
	@Test
	void listLoggerConfigurationsIsUnsupported() {
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> new StubLoggingSystem().getLoggerConfigurations());
	}
	private static final class StubLoggingSystem extends LoggingSystem {
		@Override
		public void beforeInitialize() {
			// Stub implementation
		}
		@Override
		public void setLogLevel(String loggerName, LogLevel level) {
			// Stub implementation
		}
	}
}
/*
package org.springframework.boot.logging;
/**
class LoggingSystemPropertiesTests {
	private Set<Object> systemPropertyNames;
	@BeforeEach
	void captureSystemPropertyNames() {
		for (LoggingSystemProperty property : LoggingSystemProperty.values()) {
			System.getProperties().remove(property.getEnvironmentVariableName());
		}
		System.getProperties().remove('LOGGED_APPLICATION_NAME');
		this.systemPropertyNames = new HashSet<>(System.getProperties().keySet());
	}
	@AfterEach
	void restoreSystemProperties() {
		System.getProperties().keySet().retainAll(this.systemPropertyNames);
	}
	@Test
	void pidIsSet() {
		new LoggingSystemProperties(new MockEnvironment()).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.PID)).isNotNull();
	}
	@Test
	void consoleLogPatternIsSet() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.pattern.console', 'console pattern'))
			.apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.CONSOLE_PATTERN)).isEqualTo('console pattern');
	}
	@Test
	void consoleCharsetWhenNoPropertyUsesUtf8() {
		new LoggingSystemProperties(new MockEnvironment()).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.CONSOLE_CHARSET)).isEqualTo('UTF-8');
	}
	@Test
	void consoleCharsetIsSet() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.charset.console', 'UTF-16'))
			.apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.CONSOLE_CHARSET)).isEqualTo('UTF-16');
	}
	@Test
	void fileLogPatternIsSet() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.pattern.file', 'file pattern'))
			.apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.FILE_PATTERN)).isEqualTo('file pattern');
	}
	@Test
	void fileCharsetWhenNoPropertyUsesUtf8() {
		new LoggingSystemProperties(new MockEnvironment()).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.FILE_CHARSET)).isEqualTo('UTF-8');
	}
	@Test
	void fileCharsetIsSet() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.charset.file', 'UTF-16')).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.FILE_CHARSET)).isEqualTo('UTF-16');
	}
	@Test
	void consoleLogPatternCanReferencePid() {
		new LoggingSystemProperties(environment('logging.pattern.console', '${PID:unknown}')).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.CONSOLE_PATTERN)).matches('[0-9]+');
	}
	@Test
	void fileLogPatternCanReferencePid() {
		new LoggingSystemProperties(environment('logging.pattern.file', '${PID:unknown}')).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.FILE_PATTERN)).matches('[0-9]+');
	}
	private String getSystemProperty(LoggingSystemProperty property) {
		return System.getProperty(property.getEnvironmentVariableName());
	}
	@Test
	void correlationPatternIsSet() {
		new LoggingSystemProperties(
				new MockEnvironment().withProperty('logging.pattern.correlation', 'correlation pattern'))
			.apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.CORRELATION_PATTERN.getEnvironmentVariableName()))
			.isEqualTo('correlation pattern');
	}
	@Test
	void defaultValueResolverIsUsed() {
		MockEnvironment environment = new MockEnvironment();
		Map<String, String> defaultValues = Map
			.of(LoggingSystemProperty.CORRELATION_PATTERN.getApplicationPropertyName(), 'default correlation pattern');
		new LoggingSystemProperties(environment, defaultValues::get, null).apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.CORRELATION_PATTERN.getEnvironmentVariableName()))
			.isEqualTo('default correlation pattern');
	}
	@Test
	void loggedApplicationNameWhenHasApplicationName() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('spring.application.name', 'test')).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.APPLICATION_NAME)).isEqualTo('test');
	}
	@Test
	void loggedApplicationNameWhenHasNoApplicationName() {
		new LoggingSystemProperties(new MockEnvironment()).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.APPLICATION_NAME)).isNull();
	}
	@Test
	void loggedApplicationNameWhenApplicationNameLoggingDisabled() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('spring.application.name', 'test')
			.withProperty('logging.include-application-name', 'false')).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.APPLICATION_NAME)).isNull();
	}
	@Test
	void legacyLoggedApplicationNameWhenHasApplicationName() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('spring.application.name', 'test')).apply(null);
		assertThat(System.getProperty('LOGGED_APPLICATION_NAME')).isEqualTo('[test] ');
	}
	@Test
	void applicationGroupWhenHasApplicationGroup() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('spring.application.group', 'test')).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.APPLICATION_GROUP)).isEqualTo('test');
	}
	@Test
	void applicationGroupWhenHasNoApplicationGroup() {
		new LoggingSystemProperties(new MockEnvironment()).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.APPLICATION_GROUP)).isNull();
	}
	@Test
	void applicationGroupWhenApplicationGroupLoggingDisabled() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('spring.application.group', 'test')
			.withProperty('logging.include-application-group', 'false')).apply(null);
		assertThat(getSystemProperty(LoggingSystemProperty.APPLICATION_GROUP)).isNull();
	}
	@Test
	void shouldSupportFalseConsoleThreshold() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.threshold.console', 'false'))
			.apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.CONSOLE_THRESHOLD.getEnvironmentVariableName()))
			.isEqualTo('OFF');
	}
	@Test
	void shouldSupportFalseFileThreshold() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.threshold.file', 'false')).apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.FILE_THRESHOLD.getEnvironmentVariableName()))
			.isEqualTo('OFF');
	}
	@Test
	void shouldSetFileStructuredLogging() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.structured.format.file', 'ecs'))
			.apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.FILE_STRUCTURED_FORMAT.getEnvironmentVariableName()))
			.isEqualTo('ecs');
	}
	@Test
	void shouldSetConsoleStructuredLogging() {
		new LoggingSystemProperties(new MockEnvironment().withProperty('logging.structured.format.console', 'ecs'))
			.apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.CONSOLE_STRUCTURED_FORMAT.getEnvironmentVariableName()))
			.isEqualTo('ecs');
	}
	private Environment environment(String key, Object value) {
		StandardEnvironment environment = new StandardEnvironment();
		environment.getPropertySources().addLast(new MapPropertySource('test', Collections.singletonMap(key, value)));
		return environment;
	}
}
/*
package org.springframework.boot.logging;
/**
class LogLevelTests {
	private Log logger = mock(Log.class);
	private Exception exception = new Exception();
	@Test
	void logWhenTraceLogsAtTrace() {
		LogLevel.TRACE.log(this.logger, 'test');
		LogLevel.TRACE.log(this.logger, 'test', this.exception);
		then(this.logger).should().trace('test', null);
		then(this.logger).should().trace('test', this.exception);
	}
	@Test
	void logWhenDebugLogsAtDebug() {
		LogLevel.DEBUG.log(this.logger, 'test');
		LogLevel.DEBUG.log(this.logger, 'test', this.exception);
		then(this.logger).should().debug('test', null);
		then(this.logger).should().debug('test', this.exception);
	}
	@Test
	void logWhenInfoLogsAtInfo() {
		LogLevel.INFO.log(this.logger, 'test');
		LogLevel.INFO.log(this.logger, 'test', this.exception);
		then(this.logger).should().info('test', null);
		then(this.logger).should().info('test', this.exception);
	}
	@Test
	void logWhenWarnLogsAtWarn() {
		LogLevel.WARN.log(this.logger, 'test');
		LogLevel.WARN.log(this.logger, 'test', this.exception);
		then(this.logger).should().warn('test', null);
		then(this.logger).should().warn('test', this.exception);
	}
	@Test
	void logWhenErrorLogsAtError() {
		LogLevel.ERROR.log(this.logger, 'test');
		LogLevel.ERROR.log(this.logger, 'test', this.exception);
		then(this.logger).should().error('test', null);
		then(this.logger).should().error('test', this.exception);
	}
	@Test
	void logWhenFatalLogsAtFatal() {
		LogLevel.FATAL.log(this.logger, 'test');
		LogLevel.FATAL.log(this.logger, 'test', this.exception);
		then(this.logger).should().fatal('test', null);
		then(this.logger).should().fatal('test', this.exception);
	}
	@Test
	void logWhenOffDoesNotLog() {
		LogLevel.OFF.log(this.logger, 'test');
		LogLevel.OFF.log(this.logger, 'test', this.exception);
		then(this.logger).shouldHaveNoInteractions();
	}
}
/*
package org.springframework.boot.logging;
/**
class LoggerConfigurationComparatorTests {
	private final LoggerConfigurationComparator comparator = new LoggerConfigurationComparator('ROOT');
	@Test
	void rootLoggerFirst() {
		LoggerConfiguration first = new LoggerConfiguration('ROOT', null, LogLevel.OFF);
		LoggerConfiguration second = new LoggerConfiguration('alpha', null, LogLevel.OFF);
		assertThat(this.comparator.compare(first, second)).isLessThan(0);
	}
	@Test
	void rootLoggerSecond() {
		LoggerConfiguration first = new LoggerConfiguration('alpha', null, LogLevel.OFF);
		LoggerConfiguration second = new LoggerConfiguration('ROOT', null, LogLevel.OFF);
		assertThat(this.comparator.compare(first, second)).isGreaterThan(0);
	}
	@Test
	void rootLoggerFirstEmpty() {
		LoggerConfiguration first = new LoggerConfiguration('ROOT', null, LogLevel.OFF);
		LoggerConfiguration second = new LoggerConfiguration('', null, LogLevel.OFF);
		assertThat(this.comparator.compare(first, second)).isLessThan(0);
	}
	@Test
	void rootLoggerSecondEmpty() {
		LoggerConfiguration first = new LoggerConfiguration('', null, LogLevel.OFF);
		LoggerConfiguration second = new LoggerConfiguration('ROOT', null, LogLevel.OFF);
		assertThat(this.comparator.compare(first, second)).isGreaterThan(0);
	}
	@Test
	void lexicalFirst() {
		LoggerConfiguration first = new LoggerConfiguration('alpha', null, LogLevel.OFF);
		LoggerConfiguration second = new LoggerConfiguration('bravo', null, LogLevel.OFF);
		assertThat(this.comparator.compare(first, second)).isLessThan(0);
	}
	@Test
	void lexicalSecond() {
		LoggerConfiguration first = new LoggerConfiguration('bravo', null, LogLevel.OFF);
		LoggerConfiguration second = new LoggerConfiguration('alpha', null, LogLevel.OFF);
		assertThat(this.comparator.compare(first, second)).isGreaterThan(0);
	}
	@Test
	void lexicalEqual() {
		LoggerConfiguration first = new LoggerConfiguration('alpha', null, LogLevel.OFF);
		LoggerConfiguration second = new LoggerConfiguration('alpha', null, LogLevel.OFF);
		assertThat(this.comparator.compare(first, second)).isZero();
	}
}
/*
package org.springframework.boot.logging;
/**
class DelegatingLoggingSystemFactoryTests {
	private final ClassLoader classLoader = getClass().getClassLoader();
	@Test
	void getLoggingSystemWhenDelegatesFunctionIsNullReturnsNull() {
		DelegatingLoggingSystemFactory factory = new DelegatingLoggingSystemFactory(null);
		assertThat(factory.getLoggingSystem(this.classLoader)).isNull();
	}
	@Test
	void getLoggingSystemWhenDelegatesFunctionReturnsNullReturnsNull() {
		DelegatingLoggingSystemFactory factory = new DelegatingLoggingSystemFactory((cl) -> null);
		assertThat(factory.getLoggingSystem(this.classLoader)).isNull();
	}
	@Test
	void getLoggingSystemReturnsFirstNonNullLoggingSystem() {
		List<LoggingSystemFactory> delegates = new ArrayList<>();
		delegates.add(mock(LoggingSystemFactory.class));
		delegates.add(mock(LoggingSystemFactory.class));
		delegates.add(mock(LoggingSystemFactory.class));
		LoggingSystem result = mock(LoggingSystem.class);
		given(delegates.get(1).getLoggingSystem(this.classLoader)).willReturn(result);
		DelegatingLoggingSystemFactory factory = new DelegatingLoggingSystemFactory((cl) -> delegates);
		assertThat(factory.getLoggingSystem(this.classLoader)).isSameAs(result);
		then(delegates.get(0)).should().getLoggingSystem(this.classLoader);
		then(delegates.get(1)).should().getLoggingSystem(this.classLoader);
		then(delegates.get(2)).shouldHaveNoInteractions();
	}
}
/*
package org.springframework.boot.logging;
/**
class LoggerGroupsTests {
	@Test
	void putAllShouldAddLoggerGroups() {
		Map<String, List<String>> groups = Collections.singletonMap('test',
				Arrays.asList('test.member', 'test.member2'));
		LoggerGroups loggerGroups = new LoggerGroups();
		loggerGroups.putAll(groups);
		LoggerGroup group = loggerGroups.get('test');
		assertThat(group.getMembers()).containsExactly('test.member', 'test.member2');
	}
	@Test
	void iteratorShouldReturnLoggerGroups() {
		LoggerGroups groups = createLoggerGroups();
		assertThat(groups).hasSize(3);
		assertThat(groups).extracting('name').containsExactlyInAnyOrder('test0', 'test1', 'test2');
	}
	private LoggerGroups createLoggerGroups() {
		Map<String, List<String>> groups = new LinkedHashMap<>();
		groups.put('test0', Arrays.asList('test0.member', 'test0.member2'));
		groups.put('test1', Arrays.asList('test1.member', 'test1.member2'));
		groups.put('test2', Arrays.asList('test2.member', 'test2.member2'));
		return new LoggerGroups(groups);
	}
}
/*
package org.springframework.boot.logging;
/**
public abstract class AbstractLoggingSystemTests {
	private static final String JAVA_IO_TMPDIR = 'java.io.tmpdir';
	private String originalTempDirectory;
	@BeforeEach
	void configureTempDir(@TempDir Path temp) throws IOException {
		this.originalTempDirectory = System.getProperty(JAVA_IO_TMPDIR);
		Files.delete(Files.createTempFile('prevent', 'pollution'));
		File.createTempFile('prevent', 'pollution').delete();
		System.setProperty(JAVA_IO_TMPDIR, temp.toAbsolutePath().toString());
		MDC.clear();
	}
	@AfterEach
	void reinstateTempDir() {
		System.setProperty(JAVA_IO_TMPDIR, this.originalTempDirectory);
	}
	@AfterEach
	void clear() {
		for (LoggingSystemProperty property : LoggingSystemProperty.values()) {
			System.getProperties().remove(property.getEnvironmentVariableName());
		}
		MDC.clear();
	}
	protected final String[] getSpringConfigLocations(AbstractLoggingSystem system) {
		return system.getSpringConfigLocations();
	}
	protected final LogFile getLogFile(String file, String path) {
		return getLogFile(file, path, true);
	}
	protected final LogFile getLogFile(String file, String path, boolean applyToSystemProperties) {
		LogFile logFile = new LogFile(file, path);
		if (applyToSystemProperties) {
			logFile.applyToSystemProperties();
		}
		return logFile;
	}
	protected final String tmpDir() {
		String path = StringUtils.cleanPath(System.getProperty(JAVA_IO_TMPDIR));
		if (path.endsWith('/')) {
			path = path.substring(0, path.length() - 1);
		}
		return path;
	}
	protected final String getLineWithText(File file, CharSequence outputSearch) {
		return getLineWithText(contentOf(file), outputSearch);
	}
	protected final String getLineWithText(CharSequence output, CharSequence outputSearch) {
		return Arrays.stream(output.toString().split('\\r?\\n'))
			.filter((line) -> line.contains(outputSearch))
			.findFirst()
			.orElse(null);
	}
}
/*
package org.springframework.boot.logging.logback;
/**
@ExtendWith(OutputCaptureExtension.class)
class SpringBootJoranConfiguratorTests {
	private MockEnvironment environment;
	private LoggingInitializationContext initializationContext;
	private JoranConfigurator configurator;
	private LoggerContext context;
	private Logger logger;
	private CapturedOutput output;
	@BeforeEach
	void setup(CapturedOutput output) {
		this.output = output;
		this.environment = new MockEnvironment();
		this.initializationContext = new LoggingInitializationContext(this.environment);
		this.configurator = new SpringBootJoranConfigurator(this.initializationContext);
		this.context = (LoggerContext) LoggerFactory.getILoggerFactory();
		this.logger = this.context.getLogger(getClass());
	}
	@AfterEach
	void reset() {
		this.context.stop();
		new BasicConfigurator().configure((LoggerContext) LoggerFactory.getILoggerFactory());
		this.context.start();
	}
	@Test
	void profileActive() throws Exception {
		this.environment.setActiveProfiles('production');
		initialize('production-profile.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void profileInIncludeActive() throws Exception {
		this.environment.setActiveProfiles('production');
		initialize('profile-in-include.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void multipleNamesFirstProfileActive() throws Exception {
		this.environment.setActiveProfiles('production');
		initialize('multi-profile-names.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void multipleNamesSecondProfileActive() throws Exception {
		this.environment.setActiveProfiles('test');
		initialize('multi-profile-names.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void profileNotActive() throws Exception {
		initialize('production-profile.xml');
		this.logger.trace('Hello');
		assertThat(this.output).doesNotContain('Hello');
	}
	@Test
	void profileExpressionMatchFirst() throws Exception {
		this.environment.setActiveProfiles('production');
		initialize('profile-expression.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void profileExpressionMatchSecond() throws Exception {
		this.environment.setActiveProfiles('test');
		initialize('profile-expression.xml');
		this.logger.trace('Hello');
		assertThat(this.output).contains('Hello');
	}
	@Test
	void profileExpressionNoMatch() throws Exception {
		this.environment.setActiveProfiles('development');
		initialize('profile-expression.xml');
		this.logger.trace('Hello');
		assertThat(this.output).doesNotContain('Hello');
	}
	@Test
	void profileNestedActiveActive() throws Exception {
		doTestNestedProfile(true, 'outer', 'inner');
	}
	@Test
	void profileNestedActiveNotActive() throws Exception {
		doTestNestedProfile(false, 'outer');
	}
	@Test
	void profileNestedNotActiveActive() throws Exception {
		doTestNestedProfile(false, 'inner');
	}
	@Test
	void profileNestedNotActiveNotActive() throws Exception {
		doTestNestedProfile(false);
	}
	@Test
	void springProperty() throws Exception {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 'my.example-property=test');
		initialize('property.xml');
		assertThat(this.context.getProperty('MINE')).isEqualTo('test');
	}
	@Test
	void relaxedSpringProperty() throws Exception {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 'my.EXAMPLE_PROPERTY=test');
		ConfigurationPropertySources.attach(this.environment);
		initialize('property.xml');
		assertThat(this.context.getProperty('MINE')).isEqualTo('test');
	}
	@Test
	void springPropertyNoValue() throws Exception {
		initialize('property.xml');
		assertThat(this.context.getProperty('SIMPLE')).isNull();
	}
	@Test
	void relaxedSpringPropertyNoValue() throws Exception {
		initialize('property.xml');
		assertThat(this.context.getProperty('MINE')).isNull();
	}
	@Test
	void springPropertyWithDefaultValue() throws Exception {
		initialize('property-default-value.xml');
		assertThat(this.context.getProperty('SIMPLE')).isEqualTo('foo');
	}
	@Test
	void relaxedSpringPropertyWithDefaultValue() throws Exception {
		initialize('property-default-value.xml');
		assertThat(this.context.getProperty('MINE')).isEqualTo('bar');
	}
	@Test
	void springPropertyInIfWhenTrue() throws Exception {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 'my.example-property=true');
		initialize('property-in-if.xml');
		assertThat(this.context.getProperty('MYCHECK')).isEqualTo('i-was-included');
	}
	@Test
	void springPropertyInIfWhenFalse() throws Exception {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 'my.example-property=false');
		initialize('property-in-if.xml');
		assertThat(this.context.getProperty('MYCHECK')).isNull();
	}
	@Test
	void springPropertyInInclude() throws Exception {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 'my.example-property=test');
		initialize('property-in-include.xml');
		assertThat(this.context.getProperty('MINE')).isEqualTo('test');
	}
	@Test
	void addsAotContributionToContextDuringAotProcessing() throws Exception {
		withSystemProperty(AbstractAotProcessor.AOT_PROCESSING, 'true', () -> {
			initialize('property.xml');
			Object contribution = this.context.getObject(BeanFactoryInitializationAotContribution.class.getName());
			assertThat(contribution).isNotNull();
		});
	}
	private void withSystemProperty(String name, String value, Action action) throws Exception {
		System.setProperty(name, value);
		try {
			action.perform();
		}
		finally {
			System.clearProperty(name);
		}
	}
	private void doTestNestedProfile(boolean expected, String... profiles) throws JoranException {
		this.environment.setActiveProfiles(profiles);
		initialize('nested.xml');
		this.logger.trace('Hello');
		if (expected) {
			assertThat(this.output).contains('Hello');
		}
		else {
			assertThat(this.output).doesNotContain('Hello');
		}
	}
	private void initialize(String config) throws JoranException {
		this.configurator.setContext(this.context);
		this.configurator.doConfigure(getClass().getResourceAsStream(config));
	}
	private interface Action {
		void perform() throws Exception;
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class SpringProfileModelHandlerTests {
	private final Environment environment = mock(Environment.class);
	private final Context context = new ContextBase();
	private final SpringProfileModelHandler action = new SpringProfileModelHandler(this.context, this.environment);
	private final ModelInterpretationContext interpretationContext = new ModelInterpretationContext(this.context);
	@BeforeEach
	void setUp() {
		this.action.setContext(this.context);
	}
	@Test
	void environmentIsQueriedWithProfileFromModelName() throws ModelHandlerException {
		SpringProfileModel model = new SpringProfileModel();
		model.setName('dev');
		this.action.handle(this.interpretationContext, model);
		then(this.environment).should().acceptsProfiles(ArgumentMatchers.<Profiles>assertArg(((profiles) -> {
			List<String> profileNames = new ArrayList<>();
			profiles.matches((profile) -> {
				profileNames.add(profile);
				return false;
			});
			assertThat(profileNames).containsExactly('dev');
		})));
	}
	@Test
	void environmentIsQueriedWithMultipleProfilesFromCommaSeparatedModelName() throws ModelHandlerException {
		SpringProfileModel model = new SpringProfileModel();
		model.setName('dev,qa');
		this.action.handle(this.interpretationContext, model);
		then(this.environment).should().acceptsProfiles(ArgumentMatchers.<Profiles>assertArg(((profiles) -> {
			List<String> profileNames = new ArrayList<>();
			profiles.matches((profile) -> {
				profileNames.add(profile);
				return false;
			});
			assertThat(profileNames).containsExactly('dev', 'qa');
		})));
	}
	@Test
	void environmentIsQueriedWithResolvedValueWhenModelNameUsesAPlaceholder() throws ModelHandlerException {
		SpringProfileModel model = new SpringProfileModel();
		model.setName('${profile}');
		this.context.putProperty('profile', 'dev');
		this.action.handle(this.interpretationContext, model);
		then(this.environment).should().acceptsProfiles(ArgumentMatchers.<Profiles>assertArg(((profiles) -> {
			List<String> profileNames = new ArrayList<>();
			profiles.matches((profile) -> {
				profileNames.add(profile);
				return false;
			});
			assertThat(profileNames).containsExactly('dev');
		})));
	}
	@Test
	void environmentIsQueriedWithResolvedValuesFromCommaSeparatedNameNameAttributeWithPlaceholders()
			throws ModelHandlerException {
		SpringProfileModel model = new SpringProfileModel();
		model.setName('${profile1},${profile2}');
		this.context.putProperty('profile1', 'dev');
		this.context.putProperty('profile2', 'qa');
		this.action.handle(this.interpretationContext, model);
		then(this.environment).should().acceptsProfiles(ArgumentMatchers.<Profiles>assertArg(((profiles) -> {
			List<String> profileNames = new ArrayList<>();
			profiles.matches((profile) -> {
				profileNames.add(profile);
				return false;
			});
			assertThat(profileNames).containsExactly('dev', 'qa');
		})));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class CorrelationIdConverterTests {
	private final CorrelationIdConverter converter;
	private final LoggingEvent event = new LoggingEvent();
	CorrelationIdConverterTests() {
		this.converter = new CorrelationIdConverter();
		this.converter.setContext(new LoggerContext());
	}
	@Test
	void defaultPattern() {
		addMdcProperties(this.event);
		this.converter.start();
		String converted = this.converter.convert(this.event);
		this.converter.stop();
		assertThat(converted).isEqualTo('[01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void customPattern() {
		this.converter.setOptionList(List.of('traceId(0)', 'spanId(0)'));
		addMdcProperties(this.event);
		this.converter.start();
		String converted = this.converter.convert(this.event);
		this.converter.stop();
		assertThat(converted).isEqualTo('[01234567890123456789012345678901-0123456789012345] ');
	}
	private void addMdcProperties(LoggingEvent event) {
		event.setMDCPropertyMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class ColorConverterTests {
	private final ColorConverter converter = new ColorConverter();
	private final LoggingEvent event = new LoggingEvent();
	private final String in = 'in';
	@BeforeAll
	static void setupAnsi() {
		AnsiOutput.setEnabled(AnsiOutput.Enabled.ALWAYS);
	}
	@AfterAll
	static void resetAnsi() {
		AnsiOutput.setEnabled(AnsiOutput.Enabled.DETECT);
	}
	@Test
	void black() {
		this.converter.setOptionList(Collections.singletonList('black'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[30min\033[0;39m');
	}
	@Test
	void white() {
		this.converter.setOptionList(Collections.singletonList('white'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[37min\033[0;39m');
	}
	@Test
	void faint() {
		this.converter.setOptionList(Collections.singletonList('faint'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[2min\033[0;39m');
	}
	@Test
	void red() {
		this.converter.setOptionList(Collections.singletonList('red'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[31min\033[0;39m');
	}
	@Test
	void green() {
		this.converter.setOptionList(Collections.singletonList('green'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[32min\033[0;39m');
	}
	@Test
	void yellow() {
		this.converter.setOptionList(Collections.singletonList('yellow'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[33min\033[0;39m');
	}
	@Test
	void blue() {
		this.converter.setOptionList(Collections.singletonList('blue'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[34min\033[0;39m');
	}
	@Test
	void magenta() {
		this.converter.setOptionList(Collections.singletonList('magenta'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[35min\033[0;39m');
	}
	@Test
	void cyan() {
		this.converter.setOptionList(Collections.singletonList('cyan'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[36min\033[0;39m');
	}
	@Test
	void brightBlack() {
		this.converter.setOptionList(Collections.singletonList('bright_black'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[90min\033[0;39m');
	}
	@Test
	void brightWhite() {
		this.converter.setOptionList(Collections.singletonList('bright_white'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[97min\033[0;39m');
	}
	@Test
	void brightRed() {
		this.converter.setOptionList(Collections.singletonList('bright_red'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[91min\033[0;39m');
	}
	@Test
	void brightGreen() {
		this.converter.setOptionList(Collections.singletonList('bright_green'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[92min\033[0;39m');
	}
	@Test
	void brightYellow() {
		this.converter.setOptionList(Collections.singletonList('bright_yellow'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[93min\033[0;39m');
	}
	@Test
	void brightBlue() {
		this.converter.setOptionList(Collections.singletonList('bright_blue'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[94min\033[0;39m');
	}
	@Test
	void brightMagenta() {
		this.converter.setOptionList(Collections.singletonList('bright_magenta'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[95min\033[0;39m');
	}
	@Test
	void brightCyan() {
		this.converter.setOptionList(Collections.singletonList('bright_cyan'));
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[96min\033[0;39m');
	}
	@Test
	void highlightError() {
		this.event.setLevel(Level.ERROR);
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[31min\033[0;39m');
	}
	@Test
	void highlightWarn() {
		this.event.setLevel(Level.WARN);
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[33min\033[0;39m');
	}
	@Test
	void highlightDebug() {
		this.event.setLevel(Level.DEBUG);
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[32min\033[0;39m');
	}
	@Test
	void highlightTrace() {
		this.event.setLevel(Level.TRACE);
		String out = this.converter.transform(this.event, this.in);
		assertThat(out).isEqualTo('\033[32min\033[0;39m');
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogstashStructuredLogFormatterTests extends AbstractStructuredLoggingTests {
	private LogstashStructuredLogFormatter formatter;
	@Override
	@BeforeEach
	void setUp() {
		super.setUp();
		this.formatter = new LogstashStructuredLogFormatter(getThrowableProxyConverter(), this.customizer);
	}
	@Test
	void callsCustomizer() {
		then(this.customizer).should().customize(any());
	}
	@Test
	void shouldFormat() {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Map.of('mdc-1', 'mdc-v-1'));
		event.setKeyValuePairs(keyValuePairs('kv-1', 'kv-v-1'));
		Marker marker1 = getMarker('marker-1');
		marker1.add(getMarker('marker-2'));
		event.addMarker(marker1);
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		String timestamp = DateTimeFormatter.ISO_OFFSET_DATE_TIME
			.format(OffsetDateTime.ofInstant(EVENT_TIME, ZoneId.systemDefault()));
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('@timestamp', timestamp, '@version', '1',
				'message', 'message', 'logger_name', 'org.example.Test', 'thread_name', 'main', 'level', 'INFO',
				'level_value', 20000, 'mdc-1', 'mdc-v-1', 'kv-1', 'kv-v-1', 'tags', List.of('marker-1', 'marker-2')));
	}
	@Test
	void shouldFormatException() {
		LoggingEvent event = createEvent();
		event.setThrowableProxy(new ThrowableProxy(new RuntimeException('Boom')));
		event.setMDCPropertyMap(Collections.emptyMap());
		String json = this.formatter.format(event);
		Map<String, Object> deserialized = deserialize(json);
		String stackTrace = (String) deserialized.get('stack_trace');
		assertThat(stackTrace).startsWith(
				'java.lang.RuntimeException: Boom%n\tat org.springframework.boot.logging.logback.LogstashStructuredLogFormatterTests.shouldFormatException'
					.formatted());
		assertThat(json).contains(
				'java.lang.RuntimeException: Boom%n\\tat org.springframework.boot.logging.logback.LogstashStructuredLogFormatterTests.shouldFormatException'
					.formatted()
					.replace('\n', '\\n')
					.replace('\r', '\\r'));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogbackLoggingSystemPropertiesTests {
	private Set<Object> systemPropertyNames;
	private MockEnvironment environment;
	@BeforeEach
	void captureSystemPropertyNames() {
		for (LoggingSystemProperty property : LoggingSystemProperty.values()) {
			System.getProperties().remove(property.getEnvironmentVariableName());
		}
		this.systemPropertyNames = new HashSet<>(System.getProperties().keySet());
		this.environment = new MockEnvironment();
		this.environment
			.setConversionService((ConfigurableConversionService) ApplicationConversionService.getSharedInstance());
	}
	@AfterEach
	void restoreSystemProperties() {
		System.getProperties().keySet().retainAll(this.systemPropertyNames);
	}
	@Test
	void applySetsStandardSystemProperties() {
		this.environment.setProperty('logging.pattern.console', 'boot');
		new LogbackLoggingSystemProperties(this.environment).apply();
		assertThat(System.getProperties())
			.containsEntry(LoggingSystemProperty.CONSOLE_PATTERN.getEnvironmentVariableName(), 'boot');
	}
	@Test
	void applySetsLogbackSystemProperties() {
		this.environment.setProperty('logging.logback.rollingpolicy.file-name-pattern', 'fnp');
		this.environment.setProperty('logging.logback.rollingpolicy.clean-history-on-start', 'chos');
		this.environment.setProperty('logging.logback.rollingpolicy.max-file-size', '1KB');
		this.environment.setProperty('logging.logback.rollingpolicy.total-size-cap', '2KB');
		this.environment.setProperty('logging.logback.rollingpolicy.max-history', 'mh');
		new LogbackLoggingSystemProperties(this.environment).apply();
		assertThat(System.getProperties())
			.containsEntry(RollingPolicySystemProperty.FILE_NAME_PATTERN.getEnvironmentVariableName(), 'fnp')
			.containsEntry(RollingPolicySystemProperty.CLEAN_HISTORY_ON_START.getEnvironmentVariableName(), 'chos')
			.containsEntry(RollingPolicySystemProperty.MAX_FILE_SIZE.getEnvironmentVariableName(), '1024')
			.containsEntry(RollingPolicySystemProperty.TOTAL_SIZE_CAP.getEnvironmentVariableName(), '2048')
			.containsEntry(RollingPolicySystemProperty.MAX_HISTORY.getEnvironmentVariableName(), 'mh');
	}
	@Test
	void applySetsLogbackSystemPropertiesFromDeprecated() {
		this.environment.setProperty('logging.pattern.rolling-file-name', 'fnp');
		this.environment.setProperty('logging.file.clean-history-on-start', 'chos');
		this.environment.setProperty('logging.file.max-size', '1KB');
		this.environment.setProperty('logging.file.total-size-cap', '2KB');
		this.environment.setProperty('logging.file.max-history', 'mh');
		new LogbackLoggingSystemProperties(this.environment).apply();
		assertThat(System.getProperties())
			.containsEntry(RollingPolicySystemProperty.FILE_NAME_PATTERN.getEnvironmentVariableName(), 'fnp')
			.containsEntry(RollingPolicySystemProperty.CLEAN_HISTORY_ON_START.getEnvironmentVariableName(), 'chos')
			.containsEntry(RollingPolicySystemProperty.MAX_FILE_SIZE.getEnvironmentVariableName(), '1024')
			.containsEntry(RollingPolicySystemProperty.TOTAL_SIZE_CAP.getEnvironmentVariableName(), '2048')
			.containsEntry(RollingPolicySystemProperty.MAX_HISTORY.getEnvironmentVariableName(), 'mh');
	}
	@Test
	void consoleCharsetWhenNoPropertyUsesDefault() {
		new LoggingSystemProperties(new MockEnvironment()).apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.CONSOLE_CHARSET.getEnvironmentVariableName()))
			.isEqualTo(Charset.defaultCharset().name());
	}
	@Test
	void fileCharsetWhenNoPropertyUsesDefault() {
		new LoggingSystemProperties(new MockEnvironment()).apply(null);
		assertThat(System.getProperty(LoggingSystemProperty.FILE_CHARSET.getEnvironmentVariableName()))
			.isEqualTo(Charset.defaultCharset().name());
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class ElasticCommonSchemaStructuredLogFormatterTests extends AbstractStructuredLoggingTests {
	private ElasticCommonSchemaStructuredLogFormatter formatter;
	@Override
	@BeforeEach
	void setUp() {
		super.setUp();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.ecs.service.name', 'name');
		environment.setProperty('logging.structured.ecs.service.version', '1.0.0');
		environment.setProperty('logging.structured.ecs.service.environment', 'test');
		environment.setProperty('logging.structured.ecs.service.node-name', 'node-1');
		environment.setProperty('spring.application.pid', '1');
		this.formatter = new ElasticCommonSchemaStructuredLogFormatter(environment, getThrowableProxyConverter(),
				this.customizer);
	}
	@Test
	void callsCustomizer() {
		then(this.customizer).should().customize(any());
	}
	@Test
	void shouldFormat() {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Map.of('mdc-1', 'mdc-v-1'));
		event.setKeyValuePairs(keyValuePairs('kv-1', 'kv-v-1'));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('@timestamp', '2024-07-02T08:49:53Z',
				'log.level', 'INFO', 'process.pid', 1, 'process.thread.name', 'main', 'service.name', 'name',
				'service.version', '1.0.0', 'service.environment', 'test', 'service.node.name', 'node-1', 'log.logger',
				'org.example.Test', 'message', 'message', 'mdc-1', 'mdc-v-1', 'kv-1', 'kv-v-1', 'ecs.version', '8.11'));
	}
	@Test
	void shouldFormatException() {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Collections.emptyMap());
		event.setThrowableProxy(new ThrowableProxy(new RuntimeException('Boom')));
		String json = this.formatter.format(event);
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized)
			.containsAllEntriesOf(map('error.type', 'java.lang.RuntimeException', 'error.message', 'Boom'));
		String stackTrace = (String) deserialized.get('error.stack_trace');
		assertThat(stackTrace).startsWith(
				'java.lang.RuntimeException: Boom%n\tat org.springframework.boot.logging.logback.ElasticCommonSchemaStructuredLogFormatterTests.shouldFormatException'
					.formatted());
		assertThat(json).contains(
				'java.lang.RuntimeException: Boom%n\\tat org.springframework.boot.logging.logback.ElasticCommonSchemaStructuredLogFormatterTests.shouldFormatException'
					.formatted()
					.replace('\n', '\\n')
					.replace('\r', '\\r'));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
@ExtendWith(OutputCaptureExtension.class)
@ClassPathExclusions({ 'log4j-core-*.jar', 'log4j-api-*.jar' })
class LogbackLoggingSystemTests extends AbstractLoggingSystemTests {
	private final LogbackLoggingSystem loggingSystem = new LogbackLoggingSystem(getClass().getClassLoader());
	private Logger logger;
	private MockEnvironment environment;
	private LoggingInitializationContext initializationContext;
	private Set<Object> systemPropertyNames;
	@BeforeEach
	void setup() {
		for (LoggingSystemProperty property : LoggingSystemProperty.values()) {
			System.getProperties().remove(property.getEnvironmentVariableName());
		}
		this.systemPropertyNames = new HashSet<>(System.getProperties().keySet());
		this.loggingSystem.cleanUp();
		this.logger = ((LoggerContext) LoggerFactory.getILoggerFactory()).getLogger(getClass());
		this.environment = new MockEnvironment();
		ConversionService conversionService = ApplicationConversionService.getSharedInstance();
		this.environment.setConversionService((ConfigurableConversionService) conversionService);
		this.initializationContext = new LoggingInitializationContext(this.environment);
		this.loggingSystem.setStatusPrinterStream(System.out);
	}
	@AfterEach
	void cleanUp() {
		System.getProperties().keySet().retainAll(this.systemPropertyNames);
		this.loggingSystem.cleanUp();
		((LoggerContext) LoggerFactory.getILoggerFactory()).stop();
	}
	@Test
	void logbackDefaultsConfigurationDoesNotTriggerDeprecation(CapturedOutput output) {
		initialize(this.initializationContext, 'classpath:logback-include-defaults.xml', null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).isEqualTo('[INFO] - Hello world');
		assertThat(output.toString()).doesNotContain('WARN').doesNotContain('deprecated');
	}
	@Test
	void logbackBaseConfigurationDoesNotTriggerDeprecation(CapturedOutput output) {
		initialize(this.initializationContext, 'classpath:logback-include-base.xml', null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains(' INFO ').endsWith(': Hello world');
		assertThat(output.toString()).doesNotContain('WARN').doesNotContain('deprecated');
	}
	@Test
	@ClassPathOverrides({ 'org.jboss.logging:jboss-logging:3.5.0.Final', 'org.apache.logging.log4j:log4j-core:2.19.0' })
	void jbossLoggingRoutesThroughLog4j2ByDefault() {
		System.getProperties().remove('org.jboss.logging.provider');
		org.jboss.logging.Logger jbossLogger = org.jboss.logging.Logger.getLogger(getClass());
		assertThat(jbossLogger.getClass().getName()).isEqualTo('org.jboss.logging.Log4j2Logger');
	}
	@Test
	@ClassPathOverrides('org.jboss.logging:jboss-logging:3.5.0.Final')
	void jbossLoggingRoutesThroughSlf4jWhenLoggingSystemIsInitialized() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		assertThat(org.jboss.logging.Logger.getLogger(getClass()).getClass().getName())
			.isEqualTo('org.jboss.logging.Slf4jLocationAwareLogger');
	}
	@Test
	void noFile(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.logger.info('Hidden');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(output).contains('Hello world').doesNotContain('Hidden');
		assertThat(getLineWithText(output, 'Hello world')).contains('INFO');
		assertThat(new File(tmpDir() + '/spring.log')).doesNotExist();
	}
	@Test
	void withFile(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.logger.info('Hidden');
		initialize(this.initializationContext, null, getLogFile(null, tmpDir()));
		this.logger.info('Hello world');
		File file = new File(tmpDir() + '/spring.log');
		assertThat(output).doesNotContain('LOGBACK:');
		assertThat(output).contains('Hello world').doesNotContain('Hidden');
		assertThat(getLineWithText(output, 'Hello world')).contains('INFO');
		assertThat(file).exists();
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(ReflectionTestUtils.getField(getRollingPolicy(), 'maxFileSize')).hasToString('10 MB');
		assertThat(getRollingPolicy().getMaxHistory()).isEqualTo(7);
	}
	@Test
	void defaultConfigConfiguresAConsoleAppender() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		assertThat(getConsoleAppender()).isNotNull();
	}
	@Test
	void testNonDefaultConfigLocation(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, 'classpath:logback-nondefault.xml',
				getLogFile(tmpDir() + '/tmp.log', null));
		this.logger.info('Hello world');
		assertThat(output).doesNotContain('DEBUG')
			.contains('Hello world')
			.contains(tmpDir() + '/tmp.log')
			.endsWith('BOOTBOOT');
		assertThat(new File(tmpDir() + '/tmp.log')).doesNotExist();
	}
	@Test
	void testLogbackSpecificSystemProperty(CapturedOutput output) {
		System.setProperty('logback.configurationFile', '/foo/my-file.xml');
		try {
			this.loggingSystem.beforeInitialize();
			initialize(this.initializationContext, null, null);
			assertThat(output)
				.contains('Ignoring "logback.configurationFile" system property. Please use "logging.config" instead.');
		}
		finally {
			System.clearProperty('logback.configurationFile');
		}
	}
	@Test
	void testNonexistentConfigLocation() {
		this.loggingSystem.beforeInitialize();
		assertThatIllegalStateException()
			.isThrownBy(() -> initialize(this.initializationContext, 'classpath:logback-nonexistent.xml', null));
	}
	@Test
	void getSupportedLevels() {
		assertThat(this.loggingSystem.getSupportedLogLevels()).isEqualTo(
				EnumSet.of(LogLevel.TRACE, LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR, LogLevel.OFF));
	}
	@Test
	void setLevel(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.logger.debug('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', LogLevel.DEBUG);
		this.logger.debug('Hello');
		assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Hello')).isOne();
	}
	@Test
	void setLevelToNull(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.logger.debug('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', LogLevel.DEBUG);
		this.logger.debug('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', null);
		this.logger.debug('Hello');
		assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Hello')).isOne();
	}
	@Test
	void getLoggerConfigurations() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		List<LoggerConfiguration> configurations = this.loggingSystem.getLoggerConfigurations();
		assertThat(configurations).isNotEmpty();
		assertThat(configurations.get(0).getName()).isEqualTo(LoggingSystem.ROOT_LOGGER_NAME);
	}
	@Test
	void getLoggerConfiguration() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration(getClass().getName());
		assertThat(configuration)
			.isEqualTo(new LoggerConfiguration(getClass().getName(), LogLevel.DEBUG, LogLevel.DEBUG));
	}
	@Test
	void getLoggerConfigurationForLoggerThatDoesNotExistShouldReturnNull() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration('doesnotexist');
		assertThat(configuration).isNull();
	}
	@Test
	@Deprecated(since = '3.3.5', forRemoval = true)
	void getLoggerConfigurationForALL() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		Logger logger = (Logger) LoggerFactory.getILoggerFactory().getLogger(getClass().getName());
		logger.setLevel(Level.ALL);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration(getClass().getName());
		assertThat(configuration)
			.isEqualTo(new LoggerConfiguration(getClass().getName(), LogLevel.TRACE, LogLevel.TRACE));
	}
	@Test
	void systemLevelTraceShouldReturnNativeLevelTraceNotAll() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.TRACE);
		Logger logger = (Logger) LoggerFactory.getILoggerFactory().getLogger(getClass().getName());
		assertThat(logger.getLevel()).isEqualTo(Level.TRACE);
	}
	@Test
	void loggingThatUsesJulIsCaptured(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		java.util.logging.Logger julLogger = java.util.logging.Logger.getLogger(getClass().getName());
		julLogger.info('Hello world');
		assertThat(output).contains('Hello world');
	}
	@Test
	void loggingLevelIsPropagatedToJul(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		java.util.logging.Logger julLogger = java.util.logging.Logger.getLogger(getClass().getName());
		julLogger.fine('Hello debug world');
		assertThat(output).contains('Hello debug world');
	}
	@Test
	void bridgeHandlerLifecycle() {
		assertThat(bridgeHandlerInstalled()).isFalse();
		this.loggingSystem.beforeInitialize();
		assertThat(bridgeHandlerInstalled()).isTrue();
		this.loggingSystem.cleanUp();
		assertThat(bridgeHandlerInstalled()).isFalse();
	}
	@Test
	void standardConfigLocations() {
		String[] locations = this.loggingSystem.getStandardConfigLocations();
		assertThat(locations).containsExactly('logback-test.groovy', 'logback-test.xml', 'logback.groovy',
				'logback.xml');
	}
	@Test
	void springConfigLocations() {
		String[] locations = getSpringConfigLocations(this.loggingSystem);
		assertThat(locations).containsExactly('logback-test-spring.groovy', 'logback-test-spring.xml',
				'logback-spring.groovy', 'logback-spring.xml');
	}
	private boolean bridgeHandlerInstalled() {
		java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger('');
		Handler[] handlers = rootLogger.getHandlers();
		for (Handler handler : handlers) {
			if (handler instanceof SLF4JBridgeHandler) {
				return true;
			}
		}
		return false;
	}
	@Test
	void testConsolePatternProperty(CapturedOutput output) {
		this.environment.setProperty('logging.pattern.console', '%logger %msg');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		initialize(loggingInitializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).doesNotContain('INFO');
	}
	@Test
	void testLevelPatternProperty(CapturedOutput output) {
		this.environment.setProperty('logging.pattern.level', 'X%clr(%p)X');
		new LoggingSystemProperties(this.environment).apply();
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		initialize(loggingInitializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('XINFOX');
	}
	@Test
	void testFilePatternProperty(CapturedOutput output) {
		this.environment.setProperty('logging.pattern.file', '%logger %msg');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('INFO');
		assertThat(getLineWithText(file, 'Hello world')).doesNotContain('INFO');
	}
	@Test
	void testCleanHistoryOnStartProperty() {
		this.environment.setProperty('logging.file.clean-history-on-start', 'true');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(getRollingPolicy().isCleanHistoryOnStart()).isTrue();
	}
	@Test
	void testCleanHistoryOnStartPropertyWithXmlConfiguration() {
		this.environment.setProperty('logging.file.clean-history-on-start', 'true');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, 'classpath:logback-include-base.xml', logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(getRollingPolicy().isCleanHistoryOnStart()).isTrue();
	}
	@Test
	void testMaxFileSizePropertyWithLogbackFileSize() {
		testMaxFileSizeProperty('100 MB', '100 MB');
	}
	@Test
	void testMaxFileSizePropertyWithDataSize() {
		testMaxFileSizeProperty('15MB', '15 MB');
	}
	@Test
	void testMaxFileSizePropertyWithBytesValue() {
		testMaxFileSizeProperty(String.valueOf(10 * 1024 * 1024), '10 MB');
	}
	private void testMaxFileSizeProperty(String sizeValue, String expectedFileSize) {
		this.environment.setProperty('logging.file.max-size', sizeValue);
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(ReflectionTestUtils.getField(getRollingPolicy(), 'maxFileSize')).hasToString(expectedFileSize);
	}
	@Test
	void testMaxFileSizePropertyWithXmlConfiguration() {
		this.environment.setProperty('logging.file.max-size', '100MB');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, 'classpath:logback-include-base.xml', logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(ReflectionTestUtils.getField(getRollingPolicy(), 'maxFileSize')).hasToString('100 MB');
	}
	@Test
	void testMaxHistoryProperty() {
		this.environment.setProperty('logging.file.max-history', '30');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(getRollingPolicy().getMaxHistory()).isEqualTo(30);
	}
	@Test
	void testMaxHistoryPropertyWithXmlConfiguration() {
		this.environment.setProperty('logging.file.max-history', '30');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, 'classpath:logback-include-base.xml', logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(getRollingPolicy().getMaxHistory()).isEqualTo(30);
	}
	@Test
	void testTotalSizeCapPropertyWithLogbackFileSize() {
		testTotalSizeCapProperty('101 MB', '101 MB');
	}
	@Test
	void testTotalSizeCapPropertyWithDataSize() {
		testTotalSizeCapProperty('10MB', '10 MB');
	}
	@Test
	void testTotalSizeCapPropertyWithBytesValue() {
		testTotalSizeCapProperty(String.valueOf(10 * 1024 * 1024), '10 MB');
	}
	private void testTotalSizeCapProperty(String sizeValue, String expectedFileSize) {
		this.environment.setProperty('logging.file.total-size-cap', sizeValue);
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(ReflectionTestUtils.getField(getRollingPolicy(), 'totalSizeCap')).hasToString(expectedFileSize);
	}
	@Test
	void testTotalSizeCapPropertyWithXmlConfiguration() {
		String expectedSize = '101 MB';
		this.environment.setProperty('logging.file.total-size-cap', expectedSize);
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, 'classpath:logback-include-base.xml', logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(ReflectionTestUtils.getField(getRollingPolicy(), 'totalSizeCap')).hasToString(expectedSize);
	}
	@Test
	void exceptionsIncludeClassPackaging(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, getLogFile(null, tmpDir()));
		this.logger.warn('Expected exception', new RuntimeException('Expected'));
		String fileContents = contentOf(new File(tmpDir() + '/spring.log'));
		assertThat(fileContents).contains('[junit-');
		assertThat(output).contains('[junit-');
	}
	@Test
	void customExceptionConversionWord(CapturedOutput output) {
		System.setProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD.getEnvironmentVariableName(), '%ex');
		try {
			this.loggingSystem.beforeInitialize();
			this.logger.info('Hidden');
			initialize(this.initializationContext, null, getLogFile(null, tmpDir()));
			this.logger.warn('Expected exception', new RuntimeException('Expected', new RuntimeException('Cause')));
			String fileContents = contentOf(new File(tmpDir() + '/spring.log'));
			assertThat(fileContents).contains('java.lang.RuntimeException: Expected').doesNotContain('Wrapped by:');
			assertThat(output).contains('java.lang.RuntimeException: Expected').doesNotContain('Wrapped by:');
		}
		finally {
			System.clearProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD.getEnvironmentVariableName());
		}
	}
	@Test
	void initializeShouldSetSystemProperty() {
		// gh-5491
		this.loggingSystem.beforeInitialize();
		this.logger.info('Hidden');
		LogFile logFile = getLogFile(tmpDir() + '/example.log', null, false);
		initialize(this.initializationContext, 'classpath:logback-nondefault.xml', logFile);
		assertThat(System.getProperty(LoggingSystemProperty.LOG_FILE.getEnvironmentVariableName()))
			.endsWith('example.log');
	}
	@Test
	void initializeShouldApplyLogbackSystemPropertiesToTheContext() {
		this.environment.setProperty('logging.logback.rollingpolicy.file-name-pattern', 'file-name-pattern');
		this.environment.setProperty('logging.logback.rollingpolicy.clean-history-on-start', 'true');
		this.environment.setProperty('logging.logback.rollingpolicy.max-file-size', '10MB');
		this.environment.setProperty('logging.logback.rollingpolicy.total-size-cap', '100MB');
		this.environment.setProperty('logging.logback.rollingpolicy.max-history', '20');
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
		Map<String, String> properties = loggerContext.getCopyOfPropertyMap();
		Set<String> expectedProperties = new HashSet<>();
		Stream.of(RollingPolicySystemProperty.values())
			.map(RollingPolicySystemProperty::getEnvironmentVariableName)
			.forEach(expectedProperties::add);
		Stream.of(LoggingSystemProperty.values())
			.map(LoggingSystemProperty::getEnvironmentVariableName)
			.forEach(expectedProperties::add);
		expectedProperties.removeAll(List.of('LOG_FILE', 'LOG_PATH'));
		expectedProperties.add('org.jboss.logging.provider');
		expectedProperties.add('LOG_CORRELATION_PATTERN');
		expectedProperties.add('CONSOLE_LOG_STRUCTURED_FORMAT');
		expectedProperties.add('FILE_LOG_STRUCTURED_FORMAT');
		assertThat(properties).containsOnlyKeys(expectedProperties);
		assertThat(properties).containsEntry('CONSOLE_LOG_CHARSET', Charset.defaultCharset().name());
	}
	@Test
	void initializationIsOnlyPerformedOnceUntilCleanedUp() {
		LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
		LoggerContextListener listener = mock(LoggerContextListener.class);
		loggerContext.addListener(listener);
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		then(listener).should().onReset(loggerContext);
		this.loggingSystem.cleanUp();
		loggerContext.addListener(listener);
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		then(listener).should(times(2)).onReset(loggerContext);
	}
	@Test
	void testDateformatPatternDefault(CapturedOutput output) {
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		initialize(loggingInitializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.containsPattern('\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}([-+]\\d{2}:\\d{2}|Z)');
	}
	@Test
	void testDateformatPatternProperty(CapturedOutput output) {
		this.environment.setProperty('logging.pattern.dateformat', 'dd-MM-yyyy');
		new LoggingSystemProperties(this.environment).apply();
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		initialize(loggingInitializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).containsPattern('\\d{2}-\\d{2}-\\d{4}\\s');
	}
	@Test // gh-24835
	void testDateformatPatternPropertyDirect(CapturedOutput output) {
		this.environment.setProperty('logging.pattern.dateformat', 'yyyy');
		new LoggingSystemProperties(this.environment).apply();
		this.environment.setProperty('logging.pattern.dateformat', 'dd-MM-yyyy');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		initialize(loggingInitializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).containsPattern('\\d{2}-\\d{2}-\\d{4}\\s');
	}
	@Test
	void noDebugOutputIsProducedByDefault(CapturedOutput output) {
		System.clearProperty('logback.debug');
		this.loggingSystem.beforeInitialize();
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		assertThat(output).doesNotContain('LevelChangePropagator').doesNotContain('SizeAndTimeBasedFNATP');
	}
	@Test
	void logbackDebugPropertyIsHonored(CapturedOutput output) {
		System.setProperty('logback.debug', 'true');
		try {
			this.loggingSystem.beforeInitialize();
			File file = new File(tmpDir(), 'logback-test.log');
			LogFile logFile = getLogFile(file.getPath(), null);
			initialize(this.initializationContext, null, logFile);
			assertThat(output).contains('LevelChangePropagator')
				.contains('SizeAndTimeBasedFileNamingAndTriggeringPolicy')
				.contains('DebugLogbackConfigurator');
		}
		finally {
			System.clearProperty('logback.debug');
		}
	}
	@Test
	void testRollingFileNameProperty() {
		String rollingFile = 'my.log.%d{yyyyMMdd}.%i.gz';
		this.environment.setProperty('logging.pattern.rolling-file-name', rollingFile);
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'my.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('INFO');
		assertThat(getRollingPolicy().getFileNamePattern()).isEqualTo(rollingFile);
	}
	@Test
	void customCharset() {
		this.environment.setProperty('logging.charset.console', 'UTF-16');
		LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment);
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(loggingInitializationContext, null, logFile);
		this.logger.info('Hello world');
		LayoutWrappingEncoder<?> encoder = (LayoutWrappingEncoder<?>) getConsoleAppender().getEncoder();
		assertThat(encoder.getCharset()).isEqualTo(StandardCharsets.UTF_16);
	}
	@Test
	void whenContextHasNoAotContributionThenProcessAheadOfTimeReturnsNull() {
		BeanFactoryInitializationAotContribution contribution = this.loggingSystem.processAheadOfTime(null);
		assertThat(contribution).isNull();
	}
	@Test
	void whenContextHasAotContributionThenProcessAheadOfTimeClearsAndReturnsIt() {
		LoggerContext context = ((LoggerContext) LoggerFactory.getILoggerFactory());
		context.putObject(BeanFactoryInitializationAotContribution.class.getName(),
				mock(BeanFactoryInitializationAotContribution.class));
		BeanFactoryInitializationAotContribution contribution = this.loggingSystem.processAheadOfTime(null);
		assertThat(context.getObject(BeanFactoryInitializationAotContribution.class.getName())).isNull();
		assertThat(contribution).isNotNull();
	}
	@Test // gh-33610
	void springProfileIfNestedWithinSecondPhaseElementSanityChecker(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, 'classpath:logback-springprofile-in-root.xml', null);
		this.logger.info('Hello world');
		assertThat(output).contains('<springProfile> elements cannot be nested within an');
	}
	@Test
	void correlationLoggingToFileWhenExpectCorrelationIdTrueAndMdcContent() {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world'))
			.contains(' [01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void correlationLoggingToConsoleWhenExpectCorrelationIdTrueAndMdcContent(CapturedOutput output) {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		initialize(this.initializationContext, null, null);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.contains(' [01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void correlationLoggingToConsoleWhenExpectCorrelationIdFalseAndMdcContent(CapturedOutput output) {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'false');
		initialize(this.initializationContext, null, null);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).doesNotContain('0123456789012345');
	}
	@Test
	void correlationLoggingToConsoleWhenExpectCorrelationIdTrueAndNoMdcContent(CapturedOutput output) {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.contains(' [                                                 ] ');
	}
	@Test
	void correlationLoggingToConsoleWhenHasCorrelationPattern(CapturedOutput output) {
		this.environment.setProperty('logging.pattern.correlation', '%correlationId{spanId(0),traceId(0)}');
		initialize(this.initializationContext, null, null);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.contains(' [0123456789012345-01234567890123456789012345678901] ');
	}
	@Test
	void correlationLoggingToConsoleWhenUsingXmlConfiguration(CapturedOutput output) {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		initialize(this.initializationContext, 'classpath:logback-include-base.xml', null);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world'))
			.contains(' [01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void correlationLoggingToFileWhenUsingFileConfiguration() {
		this.environment.setProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, 'true');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, 'classpath:logback-include-base.xml', logFile);
		MDC.setContextMap(Map.of('traceId', '01234567890123456789012345678901', 'spanId', '0123456789012345'));
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world'))
			.contains(' [01234567890123456789012345678901-0123456789012345] ');
	}
	@Test
	void applicationNameLoggingToConsoleWhenHasApplicationName(CapturedOutput output) {
		this.environment.setProperty('spring.application.name', 'myapp');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[myapp] ');
	}
	@Test
	void applicationNameLoggingToConsoleWhenHasApplicationNameWithParenthesis(CapturedOutput output) {
		this.environment.setProperty('spring.application.name', 'myapp (dev)');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[myapp (dev)] ');
	}
	@Test
	void applicationNameLoggingToConsoleWhenDisabled(CapturedOutput output) {
		this.environment.setProperty('spring.application.name', 'myapp');
		this.environment.setProperty('logging.include-application-name', 'false');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).doesNotContain('myapp').doesNotContain('null');
	}
	@Test
	void applicationNameLoggingToFileWhenHasApplicationName() {
		this.environment.setProperty('spring.application.name', 'myapp');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[myapp] ');
	}
	@Test
	void applicationNameLoggingToFileWhenHasApplicationNameWithParenthesis() {
		this.environment.setProperty('spring.application.name', 'myapp (dev)');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[myapp (dev)] ');
	}
	@Test
	void applicationNameLoggingToFileWhenDisabled() {
		this.environment.setProperty('spring.application.name', 'myapp');
		this.environment.setProperty('logging.include-application-name', 'false');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).doesNotContain('myapp').doesNotContain('null');
	}
	@Test
	void whenConfigurationErrorIsDetectedUnderlyingCausesAreIncludedAsSuppressedExceptions() {
		this.loggingSystem.beforeInitialize();
		assertThatIllegalStateException()
			.isThrownBy(() -> initialize(this.initializationContext, 'classpath:logback-broken.xml',
					getLogFile(tmpDir() + '/tmp.log', null)))
			.satisfies((ex) -> assertThat(ex.getSuppressed())
				.hasAtLeastOneElementOfType(DynamicClassLoadingException.class));
	}
	@Test
	void whenConfigLocationIsNotXmlThenIllegalArgumentExceptionShouldBeThrown() {
		this.loggingSystem.beforeInitialize();
		assertThatIllegalStateException()
			.isThrownBy(() -> initialize(this.initializationContext, 'classpath:logback-invalid-format.txt',
					getLogFile(tmpDir() + '/tmp.log', null)))
			.satisfies((ex) -> assertThat(ex.getCause()).isInstanceOf(IllegalArgumentException.class)
				.hasMessageStartingWith('Unsupported file extension'));
	}
	@Test
	void whenConfigLocationIsXmlAndHasQueryParametersThenIllegalArgumentExceptionShouldNotBeThrown() {
		this.loggingSystem.beforeInitialize();
		assertThatIllegalStateException()
			.isThrownBy(() -> initialize(this.initializationContext, 'file:///logback-nonexistent.xml?raw=true',
					getLogFile(tmpDir() + '/tmp.log', null)))
			.satisfies((ex) -> assertThat(ex.getCause()).isNotInstanceOf(IllegalArgumentException.class));
	}
	@Test
	void shouldRespectConsoleThreshold(CapturedOutput output) {
		this.environment.setProperty('logging.threshold.console', 'warn');
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.logger.info('Some info message');
		this.logger.warn('Some warn message');
		assertThat(output).doesNotContain('Some info message').contains('Some warn message');
	}
	@Test
	void shouldRespectFileThreshold() {
		this.environment.setProperty('logging.threshold.file', 'warn');
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, getLogFile(null, tmpDir()));
		this.logger.info('Some info message');
		this.logger.warn('Some warn message');
		Path file = Path.of(tmpDir(), 'spring.log');
		assertThat(file).content(StandardCharsets.UTF_8)
			.doesNotContain('Some info message')
			.contains('Some warn message');
	}
	@Test
	void applyingSystemPropertiesDoesNotCauseUnwantedStatusWarnings(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.environment.getPropertySources()
			.addFirst(new MapPropertySource('test', Map.of('logging.pattern.console', '[CONSOLE]%m')));
		this.loggingSystem.initialize(this.initializationContext, 'classpath:logback-nondefault.xml', null);
		assertThat(output).doesNotContain('WARN');
	}
	@Test
	void applicationGroupLoggingToConsoleWhenHasApplicationGroup(CapturedOutput output) {
		this.environment.setProperty('spring.application.group', 'mygroup');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[mygroup] ');
	}
	@Test
	void applicationGroupLoggingToConsoleWhenHasApplicationGroupWithParenthesis(CapturedOutput output) {
		this.environment.setProperty('spring.application.group', 'mygroup (dev)');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).contains('[mygroup (dev)] ');
	}
	@Test
	void applicationGroupLoggingToConsoleWhenDisabled(CapturedOutput output) {
		this.environment.setProperty('spring.application.group', 'mygroup');
		this.environment.setProperty('logging.include-application-group', 'false');
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(getLineWithText(output, 'Hello world')).doesNotContain('mygroup').doesNotContain('null');
	}
	@Test
	void applicationGroupLoggingToFileWhenHasApplicationGroup() {
		this.environment.setProperty('spring.application.group', 'mygroup');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[mygroup] ');
	}
	@Test
	void applicationGroupLoggingToFileWhenHasApplicationGroupWithParenthesis() {
		this.environment.setProperty('spring.application.group', 'mygroup (dev)');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).contains('[mygroup (dev)] ');
	}
	@Test
	void applicationGroupLoggingToFileWhenDisabled() {
		this.environment.setProperty('spring.application.group', 'myGroup');
		this.environment.setProperty('logging.include-application-group', 'false');
		File file = new File(tmpDir(), 'logback-test.log');
		LogFile logFile = getLogFile(file.getPath(), null);
		initialize(this.initializationContext, null, logFile);
		this.logger.info('Hello world');
		assertThat(getLineWithText(file, 'Hello world')).doesNotContain('myGroup').doesNotContain('null');
	}
	@Test
	void shouldNotContainAnsiEscapeCodes(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		this.logger.info('Hello world');
		assertThat(output).doesNotContain('\033[');
	}
	@Test
	void getEnvironment() {
		this.loggingSystem.beforeInitialize();
		initialize(this.initializationContext, null, null);
		assertThat(this.logger.getLoggerContext().getObject(Environment.class.getName())).isSameAs(this.environment);
	}
	@Test
	void getEnvironmentWhenUsingFile() {
		this.loggingSystem.beforeInitialize();
		LogFile logFile = getLogFile(tmpDir() + '/example.log', null, false);
		initialize(this.initializationContext, 'classpath:logback-nondefault.xml', logFile);
		assertThat(this.logger.getLoggerContext().getObject(Environment.class.getName())).isSameAs(this.environment);
	}
	private void initialize(LoggingInitializationContext context, String configLocation, LogFile logFile) {
		this.loggingSystem.getSystemProperties((ConfigurableEnvironment) context.getEnvironment()).apply(logFile);
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(context, configLocation, logFile);
	}
	private static Logger getRootLogger() {
		ILoggerFactory factory = LoggerFactory.getILoggerFactory();
		LoggerContext context = (LoggerContext) factory;
		return context.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);
	}
	private static ConsoleAppender<?> getConsoleAppender() {
		return (ConsoleAppender<?>) getRootLogger().getAppender('CONSOLE');
	}
	private static RollingFileAppender<?> getFileAppender() {
		return (RollingFileAppender<?>) getRootLogger().getAppender('FILE');
	}
	private static SizeAndTimeBasedRollingPolicy<?> getRollingPolicy() {
		return (SizeAndTimeBasedRollingPolicy<?>) getFileAppender().getRollingPolicy();
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class StructuredLogEncoderTests extends AbstractStructuredLoggingTests {
	private StructuredLogEncoder encoder;
	private Context loggerContext;
	private MockEnvironment environment;
	@Override
	@BeforeEach
	void setUp() {
		super.setUp();
		this.environment = new MockEnvironment();
		this.loggerContext = new ContextBase();
		this.loggerContext.putObject(Environment.class.getName(), this.environment);
		this.encoder = new StructuredLogEncoder();
		this.encoder.setContext(this.loggerContext);
	}
	@Override
	@AfterEach
	void tearDown() {
		super.tearDown();
		this.encoder.stop();
	}
	@Test
	void shouldSupportEcsCommonFormat() {
		this.encoder.setFormat('ecs');
		this.encoder.start();
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Collections.emptyMap());
		String json = encode(event);
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsKey('ecs.version');
	}
	@Test
	void shouldSupportLogstashCommonFormat() {
		this.encoder.setFormat('logstash');
		this.encoder.start();
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Collections.emptyMap());
		String json = encode(event);
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsKey('@version');
	}
	@Test
	void shouldSupportCustomFormat() {
		this.encoder.setFormat(CustomLogbackStructuredLoggingFormatter.class.getName());
		this.encoder.start();
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Collections.emptyMap());
		String format = encode(event);
		assertThat(format).isEqualTo('custom-format');
	}
	@Test
	void shouldInjectCustomFormatConstructorParameters() {
		this.environment.setProperty('spring.application.pid', '42');
		this.encoder.setFormat(CustomLogbackStructuredLoggingFormatterWithInjection.class.getName());
		this.encoder.start();
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Collections.emptyMap());
		String format = encode(event);
		assertThat(format).isEqualTo('custom-format-with-injection pid=42 hasThrowableProxyConverter=true');
	}
	@Test
	void shouldCheckTypeArgument() {
		assertThatIllegalArgumentException().isThrownBy(() -> {
			this.encoder.setFormat(CustomLogbackStructuredLoggingFormatterWrongType.class.getName());
			this.encoder.start();
		}).withMessageContaining('must be ch.qos.logback.classic.spi.ILoggingEvent but was java.lang.String');
	}
	@Test
	void shouldCheckTypeArgumentWithRawType() {
		assertThatIllegalArgumentException().isThrownBy(() -> {
			this.encoder.setFormat(CustomLogbackStructuredLoggingFormatterRawType.class.getName());
			this.encoder.start();
		}).withMessageContaining('must be ch.qos.logback.classic.spi.ILoggingEvent but was null');
	}
	@Test
	void shouldFailIfNoCommonOrCustomFormatIsSet() {
		assertThatIllegalArgumentException().isThrownBy(() -> {
			this.encoder.setFormat('does-not-exist');
			this.encoder.start();
		})
			.withMessageContaining(
					'Unknown format "does-not-exist". Values can be a valid fully-qualified class name or one of the common formats: [ecs, gelf, logstash]');
	}
	private String encode(LoggingEvent event) {
		return new String(this.encoder.encode(event), StandardCharsets.UTF_8);
	}
	static final class CustomLogbackStructuredLoggingFormatter implements StructuredLogFormatter<ILoggingEvent> {
		@Override
		public String format(ILoggingEvent event) {
			return 'custom-format';
		}
	}
	static final class CustomLogbackStructuredLoggingFormatterWithInjection
			implements StructuredLogFormatter<ILoggingEvent> {
		private final Environment environment;
		private final ThrowableProxyConverter throwableProxyConverter;
		CustomLogbackStructuredLoggingFormatterWithInjection(Environment environment,
				ThrowableProxyConverter throwableProxyConverter) {
			this.environment = environment;
			this.throwableProxyConverter = throwableProxyConverter;
		}
		@Override
		public String format(ILoggingEvent event) {
			boolean hasThrowableProxyConverter = this.throwableProxyConverter != null;
			return 'custom-format-with-injection pid=' + this.environment.getProperty('spring.application.pid')
					+ ' hasThrowableProxyConverter=' + hasThrowableProxyConverter;
		}
	}
	static final class CustomLogbackStructuredLoggingFormatterWrongType implements StructuredLogFormatter<String> {
		@Override
		public String format(String event) {
			return event;
		}
	}
	@SuppressWarnings('rawtypes')
	static final class CustomLogbackStructuredLoggingFormatterRawType implements StructuredLogFormatter {
		@Override
		public String format(Object event) {
			return '';
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class DefaultLogbackConfigurationTests {
	@Test
	void defaultLogbackXmlContainsConsoleLogPattern() throws Exception {
		assertThatDefaultXmlContains('CONSOLE_LOG_PATTERN', DefaultLogbackConfiguration.CONSOLE_LOG_PATTERN);
	}
	@Test
	void defaultLogbackXmlContainsFileLogPattern() throws Exception {
		assertThatDefaultXmlContains('FILE_LOG_PATTERN', DefaultLogbackConfiguration.FILE_LOG_PATTERN);
	}
	private void assertThatDefaultXmlContains(String name, String value) throws Exception {
		String expected = '<property name=\'%s\' value=\'%s\'/>'.formatted(name, value);
		assertThat(defaultXmlContent()).contains(expected);
	}
	private String defaultXmlContent() throws IOException {
		return StreamUtils.copyToString(getClass().getResourceAsStream('defaults.xml'), StandardCharsets.UTF_8);
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class WhitespaceThrowableProxyConverterTests {
	private final WhitespaceThrowableProxyConverter converter = new WhitespaceThrowableProxyConverter();
	private final LoggingEvent event = new LoggingEvent();
	@Test
	void noStackTrace() {
		String s = this.converter.convert(this.event);
		assertThat(s).isEmpty();
	}
	@Test
	void withStackTrace() {
		this.event.setThrowableProxy(new ThrowableProxy(new RuntimeException()));
		String s = this.converter.convert(this.event);
		assertThat(s).startsWith(System.lineSeparator()).endsWith(System.lineSeparator());
	}
}
/*
package org.springframework.boot.logging.logback;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class ApplicationNameConverterTests {
	private final ApplicationNameConverter converter;
	private final LoggingEvent event = new LoggingEvent();
	ApplicationNameConverterTests() {
		this.converter = new ApplicationNameConverter();
		this.converter.setContext(new LoggerContext());
		this.event.setLoggerContextRemoteView(
				new LoggerContextVO('test', Collections.emptyMap(), System.currentTimeMillis()));
	}
	@Test
	void whenNoLoggedApplicationNameConvertReturnsEmptyString() {
		withLoggedApplicationName(null, () -> {
			this.converter.start();
			String converted = this.converter.convert(this.event);
			assertThat(converted).isEqualTo('');
		});
	}
	@Test
	void whenLoggedApplicationNameConvertReturnsIt() {
		withLoggedApplicationName('my-application', () -> {
			this.converter.start();
			String converted = this.converter.convert(this.event);
			assertThat(converted).isEqualTo('my-application');
		});
	}
	private void withLoggedApplicationName(String name, Runnable action) {
		if (name == null) {
			System.clearProperty(LoggingSystemProperty.APPLICATION_NAME.getEnvironmentVariableName());
		}
		else {
			System.setProperty(LoggingSystemProperty.APPLICATION_NAME.getEnvironmentVariableName(), name);
		}
		try {
			action.run();
		}
		finally {
			System.clearProperty(LoggingSystemProperty.APPLICATION_NAME.getEnvironmentVariableName());
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
@ExtendWith(MockitoExtension.class)
abstract class AbstractStructuredLoggingTests {
	static final Instant EVENT_TIME = Instant.ofEpochSecond(1719910193L);
	private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
	private ThrowableProxyConverter throwableProxyConverter;
	private BasicMarkerFactory markerFactory;
	@Mock
	StructureLoggingJsonMembersCustomizer<?> customizer;
	@BeforeEach
	void setUp() {
		this.markerFactory = new BasicMarkerFactory();
		this.throwableProxyConverter = new ThrowableProxyConverter();
		this.throwableProxyConverter.start();
	}
	@AfterEach
	void tearDown() {
		this.throwableProxyConverter.stop();
	}
	protected Marker getMarker(String name) {
		return this.markerFactory.getDetachedMarker(name);
	}
	protected ThrowableProxyConverter getThrowableProxyConverter() {
		return this.throwableProxyConverter;
	}
	protected Map<String, Object> map(Object... values) {
		assertThat(values.length).isEven();
		Map<String, Object> result = new HashMap<>();
		for (int i = 0; i < values.length; i += 2) {
			result.put(values[i].toString(), values[i + 1]);
		}
		return result;
	}
	protected List<KeyValuePair> keyValuePairs(Object... values) {
		assertThat(values.length).isEven();
		List<KeyValuePair> result = new ArrayList<>();
		for (int i = 0; i < values.length; i += 2) {
			result.add(new KeyValuePair(values[i].toString(), values[i + 1]));
		}
		return result;
	}
	protected static LoggingEvent createEvent() {
		LoggingEvent event = new LoggingEvent();
		event.setInstant(EVENT_TIME);
		event.setLevel(Level.INFO);
		event.setThreadName('main');
		event.setLoggerName('org.example.Test');
		event.setMessage('message');
		return event;
	}
	protected Map<String, Object> deserialize(String json) {
		try {
			return OBJECT_MAPPER.readValue(json, new TypeReference<>() {
			});
		}
		catch (JsonProcessingException ex) {
			Assertions.fail('Failed to deserialize JSON: ' + json, ex);
			return null;
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogbackLoggingSystemParallelInitializationTests {
	private final LoggingSystem loggingSystem = LoggingSystem.get(getClass().getClassLoader());
	@AfterEach
	void cleanUp() {
		this.loggingSystem.cleanUp();
		((LoggerContext) LoggerFactory.getILoggerFactory()).stop();
	}
	@Test
	@ForkedClassPath
	void noExceptionsAreThrownWhenBeforeInitializeIsCalledInParallel() {
		List<Thread> threads = new ArrayList<>();
		List<Throwable> exceptions = new CopyOnWriteArrayList<>();
		for (int i = 0; i < 10; i++) {
			Thread thread = new Thread(this.loggingSystem::beforeInitialize);
			thread.setUncaughtExceptionHandler((t, ex) -> exceptions.add(ex));
			threads.add(thread);
		}
		threads.forEach(Thread::start);
		threads.forEach(this::join);
		assertThat(exceptions).isEmpty();
	}
	private void join(Thread thread) {
		try {
			thread.join();
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
@ExtendWith(OutputCaptureExtension.class)
class GraylogExtendedLogFormatStructuredLogFormatterTests extends AbstractStructuredLoggingTests {
	private GraylogExtendedLogFormatStructuredLogFormatter formatter;
	@Override
	@BeforeEach
	void setUp() {
		super.setUp();
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.gelf.host', 'name');
		environment.setProperty('logging.structured.gelf.service.version', '1.0.0');
		environment.setProperty('spring.application.pid', '1');
		this.formatter = new GraylogExtendedLogFormatStructuredLogFormatter(environment, getThrowableProxyConverter(),
				this.customizer);
	}
	@Test
	void callsCustomizer() {
		then(this.customizer).should().customize(any());
	}
	@Test
	void shouldFormat() {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Map.of('mdc-1', 'mdc-v-1'));
		event.setKeyValuePairs(keyValuePairs('kv-1', 'kv-v-1'));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(
				map('version', '1.1', 'host', 'name', 'timestamp', 1719910193.0, 'level', 6, '_level_name', 'INFO',
						'_process_pid', 1, '_process_thread_name', 'main', '_service_version', '1.0.0', '_log_logger',
						'org.example.Test', 'short_message', 'message', '_mdc-1', 'mdc-v-1', '_kv-1', 'kv-v-1'));
	}
	@Test
	void shouldFormatMillisecondsInTimestamp() {
		LoggingEvent event = createEvent();
		event.setTimeStamp(1719910193123L);
		event.setMDCPropertyMap(Collections.emptyMap());
		String json = this.formatter.format(event);
		assertThat(json).contains('\'timestamp\':1719910193.123');
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('version', '1.1', 'host', 'name', 'timestamp',
				1719910193.123, 'level', 6, '_level_name', 'INFO', '_process_pid', 1, '_process_thread_name', 'main',
				'_service_version', '1.0.0', '_log_logger', 'org.example.Test', 'short_message', 'message'));
	}
	@Test
	void shouldNotAllowInvalidFieldNames(CapturedOutput output) {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Map.of('/', 'value'));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('version', '1.1', 'host', 'name', 'timestamp',
				1719910193.0, 'level', 6, '_level_name', 'INFO', '_process_pid', 1, '_process_thread_name', 'main',
				'_service_version', '1.0.0', '_log_logger', 'org.example.Test', 'short_message', 'message'));
		assertThat(output).contains('"/" is not a valid field name according to GELF standard');
	}
	@Test
	void shouldNotAllowIllegalFieldNames(CapturedOutput output) {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Map.of('id', '1'));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(map('version', '1.1', 'host', 'name', 'timestamp',
				1719910193.0, 'level', 6, '_level_name', 'INFO', '_process_pid', 1, '_process_thread_name', 'main',
				'_service_version', '1.0.0', '_log_logger', 'org.example.Test', 'short_message', 'message'));
		assertThat(output).contains('"id" is an illegal field name according to GELF standard');
	}
	@Test
	void shouldNotAddDoubleUnderscoreToCustomFields() {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Map.of('_custom', 'value'));
		String json = this.formatter.format(event);
		assertThat(json).endsWith('\n');
		Map<String, Object> deserialized = deserialize(json);
		assertThat(deserialized).containsExactlyInAnyOrderEntriesOf(
				map('version', '1.1', 'host', 'name', 'timestamp', 1719910193.0, 'level', 6, '_level_name', 'INFO',
						'_process_pid', 1, '_process_thread_name', 'main', '_service_version', '1.0.0', '_log_logger',
						'org.example.Test', 'short_message', 'message', '_custom', 'value'));
	}
	@Test
	void shouldFormatException() {
		LoggingEvent event = createEvent();
		event.setMDCPropertyMap(Collections.emptyMap());
		event.setThrowableProxy(new ThrowableProxy(new RuntimeException('Boom')));
		String json = this.formatter.format(event);
		Map<String, Object> deserialized = deserialize(json);
		String fullMessage = (String) deserialized.get('full_message');
		String stackTrace = (String) deserialized.get('_error_stack_trace');
		assertThat(fullMessage).startsWith(
				'message\n\njava.lang.RuntimeException: Boom%n\tat org.springframework.boot.logging.logback.GraylogExtendedLogFormatStructuredLogFormatterTests.shouldFormatException'
					.formatted());
		assertThat(deserialized)
			.containsAllEntriesOf(map('_error_type', 'java.lang.RuntimeException', '_error_message', 'Boom'));
		assertThat(stackTrace).startsWith(
				'java.lang.RuntimeException: Boom%n\tat org.springframework.boot.logging.logback.GraylogExtendedLogFormatStructuredLogFormatterTests.shouldFormatException'
					.formatted());
		assertThat(json).contains(
				'java.lang.RuntimeException: Boom%n\\tat org.springframework.boot.logging.logback.GraylogExtendedLogFormatStructuredLogFormatterTests.shouldFormatException'
					.formatted()
					.replace('\n', '\\n')
					.replace('\r', '\\r'));
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class ExtendedWhitespaceThrowableProxyConverterTests {
	private final ExtendedWhitespaceThrowableProxyConverter converter = new ExtendedWhitespaceThrowableProxyConverter();
	private final LoggingEvent event = new LoggingEvent();
	@Test
	void noStackTrace() {
		String s = this.converter.convert(this.event);
		assertThat(s).isEmpty();
	}
	@Test
	void withStackTrace() {
		this.event.setThrowableProxy(new ThrowableProxy(new RuntimeException()));
		String s = this.converter.convert(this.event);
		assertThat(s).startsWith(System.lineSeparator()).endsWith(System.lineSeparator());
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class EnclosedInSquareBracketsConverterTests {
	private final EnclosedInSquareBracketsConverter converter;
	private final LoggingEvent event = new LoggingEvent();
	EnclosedInSquareBracketsConverterTests() {
		this.converter = new EnclosedInSquareBracketsConverter();
		this.converter.setContext(new LoggerContext());
		this.event.setLoggerContextRemoteView(
				new LoggerContextVO('test', Collections.emptyMap(), System.currentTimeMillis()));
	}
	@Test
	void transformWhenNull() {
		assertThat(this.converter.transform(this.event, null)).isEqualTo('');
	}
	@Test
	void transformWhenEmpty() {
		assertThat(this.converter.transform(this.event, '')).isEqualTo('');
	}
	@Test
	void transformWhenName() {
		assertThat(this.converter.transform(this.event, 'My Application')).isEqualTo('[My Application] ');
	}
	@Test
	void transformWhenEmptyFromFirstOption() {
		withLoggedApplicationName('spring', null, () -> {
			this.converter.setOptionList(List.of('spring'));
			this.converter.start();
			String converted = this.converter.convert(this.event);
			assertThat(converted).isEqualTo('');
		});
	}
	@Test
	void transformWhenNameFromFirstOption() {
		withLoggedApplicationName('spring', 'boot', () -> {
			this.converter.setOptionList(List.of('spring'));
			this.converter.start();
			String converted = this.converter.convert(this.event);
			assertThat(converted).isEqualTo('[boot] ');
		});
	}
	private void withLoggedApplicationName(String name, String value, Runnable action) {
		if (value == null) {
			System.clearProperty(name);
		}
		else {
			System.setProperty(name, value);
		}
		try {
			action.run();
		}
		finally {
			System.clearProperty(name);
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogbackRuntimeHintsTests {
	@Test
	void registersHintsForTypesCheckedByLogbackLoggingSystem() {
		ReflectionHints reflection = registerHints();
		assertThat(reflection.getTypeHint(LoggerContext.class)).isNotNull();
		assertThat(reflection.getTypeHint(SLF4JBridgeHandler.class)).isNotNull();
	}
	@Test
	void registersHintsForBuiltInLogbackConverters() {
		ReflectionHints reflection = registerHints();
		assertThat(logbackConverters()).allSatisfy(registeredForPublicConstructorInvocation(reflection));
	}
	@Test
	void registersHintsForSpringBootConverters() throws IOException {
		ReflectionHints reflection = registerHints();
		assertThat(converterClasses()).allSatisfy(registeredForPublicConstructorInvocation(reflection));
	}
	@SuppressWarnings('unchecked')
	private Stream<Class<Converter<?>>> converterClasses() throws IOException {
		PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
		return Stream.of(resolver.getResources('classpath:org/springframework/boot/logging/logback/*.class'))
			.filter(Resource::isFile)
			.map(this::loadClass)
			.filter(Converter.class::isAssignableFrom)
			.map((type) -> (Class<Converter<?>>) type);
	}
	private Class<?> loadClass(Resource resource) {
		try {
			return getClass().getClassLoader()
				.loadClass('org.springframework.boot.logging.logback.' + resource.getFilename().replace('.class', ''));
		}
		catch (ClassNotFoundException ex) {
			throw new RuntimeException(ex);
		}
	}
	@Test
	void doesNotRegisterHintsWhenLoggerContextIsNotAvailable() {
		RuntimeHints hints = new RuntimeHints();
		new LogbackRuntimeHints().registerHints(hints, ClassLoader.getPlatformClassLoader());
		assertThat(hints.reflection().typeHints()).isEmpty();
	}
	private ReflectionHints registerHints() {
		RuntimeHints hints = new RuntimeHints();
		new LogbackRuntimeHints().registerHints(hints, getClass().getClassLoader());
		ReflectionHints reflection = hints.reflection();
		return reflection;
	}
	private Consumer<Class<?>> registeredForPublicConstructorInvocation(ReflectionHints reflection) {
		return (converter) -> {
			TypeHint typeHint = reflection.getTypeHint(converter);
			assertThat(typeHint).isNotNull();
			assertThat(typeHint.getMemberCategories()).containsExactly(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);
		};
	}
	private List<Class<?>> logbackConverters() {
		return List.of(DateTokenConverter.class, IntegerTokenConverter.class, SyslogStartConverter.class);
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class RootLogLevelConfiguratorTests {
	@Test
	void shouldSetRootLogLevelToInfo() {
		LoggerContext context = new LoggerContext();
		assertThat(context.getLogger(Logger.ROOT_LOGGER_NAME).getLevel()).isEqualTo(Level.DEBUG);
		assertThat(new RootLogLevelConfigurator().configure(context)).isEqualTo(ExecutionStatus.INVOKE_NEXT_IF_ANY);
		assertThat(context.getLogger(Logger.ROOT_LOGGER_NAME).getLevel()).isEqualTo(Level.INFO);
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogbackConfigurationAotContributionTests {
	@BeforeEach
	@AfterEach
	void prepare() {
		LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();
		context.reset();
	}
	@Test
	void contributionOfBasicModel() {
		TestGenerationContext generationContext = applyContribution(new Model());
		InMemoryGeneratedFiles generatedFiles = generationContext.getGeneratedFiles();
		assertThat(generatedFiles).has(resource('META-INF/spring/logback-model'));
		assertThat(generatedFiles).has(resource('META-INF/spring/logback-pattern-rules'));
		SerializationHints serializationHints = generationContext.getRuntimeHints().serialization();
		assertThat(serializationHints.javaSerializationHints()
			.map(JavaSerializationHint::getType)
			.map(TypeReference::getName))
			.containsExactlyInAnyOrder(namesOf(Model.class, ArrayList.class, Boolean.class, Integer.class));
		assertThat(generationContext.getRuntimeHints().reflection().typeHints()).isEmpty();
		Properties patternRules = load(
				generatedFiles.getGeneratedFile(Kind.RESOURCE, 'META-INF/spring/logback-pattern-rules'));
		assertThat(patternRules).isEmpty();
	}
	@Test
	void contributionOfBasicModelThatMatchesExistingModel() {
		TestGenerationContext generationContext = new TestGenerationContext();
		Model model = new Model();
		applyContribution(model, generationContext);
		applyContribution(model, generationContext);
		InMemoryGeneratedFiles generatedFiles = generationContext.getGeneratedFiles();
		assertThat(generatedFiles).has(resource('META-INF/spring/logback-model'));
		assertThat(generatedFiles).has(resource('META-INF/spring/logback-pattern-rules'));
		SerializationHints serializationHints = generationContext.getRuntimeHints().serialization();
		assertThat(serializationHints.javaSerializationHints()
			.map(JavaSerializationHint::getType)
			.map(TypeReference::getName))
			.containsExactlyInAnyOrder(namesOf(Model.class, ArrayList.class, Boolean.class, Integer.class));
		assertThat(generationContext.getRuntimeHints().reflection().typeHints()).isEmpty();
		Properties patternRules = load(
				generatedFiles.getGeneratedFile(Kind.RESOURCE, 'META-INF/spring/logback-pattern-rules'));
		assertThat(patternRules).isEmpty();
	}
	@Test
	void contributionOfBasicModelThatDiffersFromExistingModelThrows() {
		TestGenerationContext generationContext = new TestGenerationContext();
		applyContribution(new Model(), generationContext);
		Model model = new Model();
		model.addSubModel(new RootLoggerModel());
		assertThatIllegalStateException().isThrownBy(() -> applyContribution(model, generationContext))
			.withMessage('Logging configuration differs from the configuration that has already been written. '
					+ 'Update your logging configuration so that it is the same for each context');
	}
	@Test
	void patternRulesAreStoredAndRegisteredForReflection() {
		LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();
		context.putObject(CoreConstants.PATTERN_RULE_REGISTRY,
				Map.of('a', 'com.example.Alpha', 'b', 'com.example.Bravo'));
		TestGenerationContext generationContext = applyContribution(new Model());
		assertThat(invokePublicConstructorsOf('com.example.Alpha')).accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsOf('com.example.Bravo')).accepts(generationContext.getRuntimeHints());
		Properties patternRules = load(generationContext.getGeneratedFiles()
			.getGeneratedFile(Kind.RESOURCE, 'META-INF/spring/logback-pattern-rules'));
		assertThat(patternRules).hasSize(2);
		assertThat(patternRules).containsEntry('a', 'com.example.Alpha');
		assertThat(patternRules).containsEntry('b', 'com.example.Bravo');
	}
	@Test
	void componentModelClassAndSetterParametersAreRegisteredForReflection() {
		ComponentModel component = new ComponentModel();
		component.setClassName(SizeAndTimeBasedRollingPolicy.class.getName());
		Model model = new Model();
		model.getSubModels().add(component);
		TestGenerationContext generationContext = applyContribution(model);
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(SizeAndTimeBasedRollingPolicy.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(FileAppender.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(FileSize.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(
				TimeBasedFileNamingAndTriggeringPolicy.class))
			.accepts(generationContext.getRuntimeHints());
	}
	@Test
	void implicitModelClassAndSetterParametersAreRegisteredForReflection() {
		ImplicitModel implicit = new ImplicitModel();
		implicit.setTag('encoder');
		Model model = new Model();
		model.getSubModels().add(implicit);
		TestGenerationContext generationContext = applyContribution(model);
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(PatternLayoutEncoder.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Layout.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Charset.class))
			.accepts(generationContext.getRuntimeHints());
	}
	@Test
	void componentModelReferencingImportedClassNameIsRegisteredForReflection() {
		ImportModel importModel = new ImportModel();
		importModel.setClassName(SizeAndTimeBasedRollingPolicy.class.getName());
		ComponentModel component = new ComponentModel();
		component.setClassName(SizeAndTimeBasedRollingPolicy.class.getSimpleName());
		Model model = new Model();
		model.getSubModels().addAll(List.of(importModel, component));
		TestGenerationContext generationContext = applyContribution(model);
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(SizeAndTimeBasedRollingPolicy.class))
			.accepts(generationContext.getRuntimeHints());
	}
	@Test
	void typeFromParentsSetterIsRegisteredForReflection() {
		ImplicitModel implementation = new ImplicitModel();
		implementation.setTag('implementation');
		ComponentModel component = new ComponentModel();
		component.setClassName(Outer.class.getName());
		component.getSubModels().add(implementation);
		TestGenerationContext generationContext = applyContribution(component);
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Outer.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Implementation.class))
			.accepts(generationContext.getRuntimeHints());
	}
	@Test
	void typeFromParentsDefaultClassAnnotatedSetterIsRegisteredForReflection() {
		ImplicitModel contract = new ImplicitModel();
		contract.setTag('contract');
		ComponentModel component = new ComponentModel();
		component.setClassName(OuterWithDefaultClass.class.getName());
		component.getSubModels().add(contract);
		TestGenerationContext generationContext = applyContribution(component);
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(OuterWithDefaultClass.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Implementation.class))
			.accepts(generationContext.getRuntimeHints());
	}
	@Test
	void componentTypesOfArraysAreRegisteredForReflection() {
		ComponentModel component = new ComponentModel();
		component.setClassName(ArrayParameters.class.getName());
		TestGenerationContext generationContext = applyContribution(component);
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(InetSocketAddress.class))
			.accepts(generationContext.getRuntimeHints());
	}
	@Test
	void placeholdersInComponentClassAttributeAreReplaced() {
		ComponentModel component = new ComponentModel();
		component.setClassName('${VARIABLE_CLASS_NAME}');
		TestGenerationContext generationContext = applyContribution(component,
				(context) -> context.putProperty('VARIABLE_CLASS_NAME', Outer.class.getName()));
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Outer.class))
			.accepts(generationContext.getRuntimeHints());
		assertThat(invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Implementation.class))
			.accepts(generationContext.getRuntimeHints());
	}
	private Predicate<RuntimeHints> invokePublicConstructorsOf(String name) {
		return RuntimeHintsPredicates.reflection()
			.onType(TypeReference.of(name))
			.withMemberCategory(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);
	}
	private Predicate<RuntimeHints> invokePublicConstructorsAndInspectAndInvokePublicMethodsOf(Class<?> type) {
		return RuntimeHintsPredicates.reflection()
			.onType(TypeReference.of(type))
			.withMemberCategories(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INTROSPECT_PUBLIC_METHODS,
					MemberCategory.INVOKE_PUBLIC_METHODS);
	}
	private Properties load(InputStreamSource source) {
		try (InputStream inputStream = source.getInputStream()) {
			Properties properties = new Properties();
			properties.load(inputStream);
			return properties;
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private Condition<InMemoryGeneratedFiles> resource(String name) {
		return new Condition<>((files) -> files.getGeneratedFile(Kind.RESOURCE, name) != null,
				'has a resource named "%s"', name);
	}
	private TestGenerationContext applyContribution(Model model) {
		return this.applyContribution(model, (context) -> {
		});
	}
	private TestGenerationContext applyContribution(Model model, Consumer<LoggerContext> contextCustomizer) {
		TestGenerationContext generationContext = new TestGenerationContext();
		applyContribution(model, contextCustomizer, generationContext);
		return generationContext;
	}
	private void applyContribution(Model model, TestGenerationContext generationContext) {
		applyContribution(model, (context) -> {
		}, generationContext);
	}
	private void applyContribution(Model model, Consumer<LoggerContext> contextCustomizer,
			TestGenerationContext generationContext) {
		LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();
		contextCustomizer.accept(context);
		SpringBootJoranConfigurator configurator = new SpringBootJoranConfigurator(null);
		configurator.setContext(context);
		withSystemProperty(AbstractAotProcessor.AOT_PROCESSING, 'true', () -> configurator.processModel(model));
		LogbackConfigurationAotContribution contribution = (LogbackConfigurationAotContribution) context
			.getObject(BeanFactoryInitializationAotContribution.class.getName());
		contribution.applyTo(generationContext, null);
	}
	private String[] namesOf(Class<?>... types) {
		return Stream.of(types).map(Class::getName).toArray(String[]::new);
	}
	private void withSystemProperty(String name, String value, Runnable action) {
		System.setProperty(name, value);
		try {
			action.run();
		}
		finally {
			System.clearProperty(name);
		}
	}
	public static class Outer {
		public void setImplementation(Implementation implementation) {
		}
	}
	public static class OuterWithDefaultClass {
		@DefaultClass(Implementation.class)
		public void setContract(Contract contract) {
		}
	}
	public static class Implementation implements Contract {
	}
	public interface Contract {
	}
	public static class ArrayParameters {
		public void addDestinations(InetSocketAddress... addresses) {
		}
	}
}
/*
package org.springframework.boot.logging.logback;
/**
class LogbackConfigurationTests {
	@Test
	void consolePatternCanBeOverridden() throws JoranException {
		JoranConfigurator configurator = new JoranConfigurator();
		LoggerContext context = new LoggerContext();
		configurator.setContext(context);
		configurator.doConfigure(new File('src/test/resources/custom-console-log-pattern.xml'));
		Appender<ILoggingEvent> appender = context.getLogger('ROOT').getAppender('CONSOLE');
		assertThat(appender).isInstanceOf(ConsoleAppender.class);
		Encoder<?> encoder = ((ConsoleAppender<?>) appender).getEncoder();
		assertThat(encoder).isInstanceOf(PatternLayoutEncoder.class);
		assertThat(((PatternLayoutEncoder) encoder).getPattern()).isEqualTo('foo');
	}
	@Test
	void filePatternCanBeOverridden() throws JoranException {
		JoranConfigurator configurator = new JoranConfigurator();
		LoggerContext context = new LoggerContext();
		configurator.setContext(context);
		configurator.doConfigure(new File('src/test/resources/custom-file-log-pattern.xml'));
		Appender<ILoggingEvent> appender = context.getLogger('ROOT').getAppender('FILE');
		assertThat(appender).isInstanceOf(FileAppender.class);
		Encoder<?> encoder = ((FileAppender<?>) appender).getEncoder();
		assertThat(encoder).isInstanceOf(PatternLayoutEncoder.class);
		assertThat(((PatternLayoutEncoder) encoder).getPattern()).isEqualTo('bar');
	}
	@Test
	void defaultRollingFileNamePattern() throws JoranException {
		JoranConfigurator configurator = new JoranConfigurator();
		LoggerContext context = new LoggerContext();
		configurator.setContext(context);
		configurator.doConfigure(new File('src/test/resources/custom-file-log-pattern.xml'));
		Appender<ILoggingEvent> appender = context.getLogger('ROOT').getAppender('FILE');
		assertThat(appender).isInstanceOf(RollingFileAppender.class);
		RollingPolicy rollingPolicy = ((RollingFileAppender<?>) appender).getRollingPolicy();
		String fileNamePattern = ((SizeAndTimeBasedRollingPolicy<?>) rollingPolicy).getFileNamePattern();
		assertThat(fileNamePattern).endsWith('spring.log.%d{yyyy-MM-dd}.%i.gz');
	}
	@Test
	void customRollingFileNamePattern() throws JoranException {
		JoranConfigurator configurator = new JoranConfigurator();
		LoggerContext context = new LoggerContext();
		configurator.setContext(context);
		configurator.doConfigure(new File('src/test/resources/custom-file-log-pattern-with-fileNamePattern.xml'));
		Appender<ILoggingEvent> appender = context.getLogger('ROOT').getAppender('FILE');
		assertThat(appender).isInstanceOf(RollingFileAppender.class);
		RollingPolicy rollingPolicy = ((RollingFileAppender<?>) appender).getRollingPolicy();
		String fileNamePattern = ((SizeAndTimeBasedRollingPolicy<?>) rollingPolicy).getFileNamePattern();
		assertThat(fileNamePattern).endsWith('my.log.%d{yyyyMMdd}.%i.gz');
	}
}
/*
package org.springframework.boot.logging.structured;
/**
class StructuredLoggingJsonPropertiesTests {
	@Test
	void getBindsFromEnvironment() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.json.include', 'a,b');
		environment.setProperty('logging.structured.json.exclude', 'c,d');
		environment.setProperty('logging.structured.json.rename.e', 'f');
		environment.setProperty('logging.structured.json.add.g', 'h');
		environment.setProperty('logging.structured.json.customizer', 'i');
		StructuredLoggingJsonProperties properties = StructuredLoggingJsonProperties.get(environment);
		assertThat(properties).isEqualTo(new StructuredLoggingJsonProperties(Set.of('a', 'b'), Set.of('c', 'd'),
				Map.of('e', 'f'), Map.of('g', 'h'), 'i'));
	}
	@Test
	void getWhenNoBoundPropertiesReturnsNull() {
		MockEnvironment environment = new MockEnvironment();
		StructuredLoggingJsonProperties.get(environment);
	}
}
/*
package org.springframework.boot.logging.structured;
/**
class ElasticCommonSchemaPropertiesTests {
	@Test
	void getBindsFromEnvironment() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.ecs.service.name', 'spring');
		environment.setProperty('logging.structured.ecs.service.version', '1.2.3');
		environment.setProperty('logging.structured.ecs.service.environment', 'prod');
		environment.setProperty('logging.structured.ecs.service.node-name', 'boot');
		ElasticCommonSchemaProperties properties = ElasticCommonSchemaProperties.get(environment);
		assertThat(properties)
			.isEqualTo(new ElasticCommonSchemaProperties(new Service('spring', '1.2.3', 'prod', 'boot')));
	}
	@Test
	void getWhenNoServiceNameUsesApplicationName() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.application.name', 'spring');
		ElasticCommonSchemaProperties properties = ElasticCommonSchemaProperties.get(environment);
		assertThat(properties).isEqualTo(new ElasticCommonSchemaProperties(new Service('spring', null, null, null)));
	}
	@Test
	void getWhenNoServiceVersionUsesApplicationVersion() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.application.version', '1.2.3');
		ElasticCommonSchemaProperties properties = ElasticCommonSchemaProperties.get(environment);
		assertThat(properties).isEqualTo(new ElasticCommonSchemaProperties(new Service(null, '1.2.3', null, null)));
	}
	@Test
	void getWhenNoPropertiesToBind() {
		MockEnvironment environment = new MockEnvironment();
		ElasticCommonSchemaProperties properties = ElasticCommonSchemaProperties.get(environment);
		assertThat(properties).isEqualTo(new ElasticCommonSchemaProperties(new Service(null, null, null, null)));
	}
	@Test
	void addToJsonMembersCreatesValidJson() {
		ElasticCommonSchemaProperties properties = new ElasticCommonSchemaProperties(
				new Service('spring', '1.2.3', 'prod', 'boot'));
		JsonWriter<ElasticCommonSchemaProperties> writer = JsonWriter.of(properties::jsonMembers);
		assertThat(writer.writeToString(properties))
			.isEqualTo('{\'service.name\':\'spring\',\'service.version\':\'1.2.3\','
					+ '\'service.environment\':\'prod\',\'service.node.name\':\'boot\'}');
	}
}
/*
package org.springframework.boot.logging.structured;
/**
class CommonStructuredLogFormatTests {
	@Test
	void forIdReturnsCommonStructuredLogFormat() {
		assertThat(CommonStructuredLogFormat.forId('ecs')).isEqualTo(CommonStructuredLogFormat.ELASTIC_COMMON_SCHEMA);
		assertThat(CommonStructuredLogFormat.forId('logstash')).isEqualTo(CommonStructuredLogFormat.LOGSTASH);
	}
	@Test
	void forIdWhenIdIsInDifferentCaseReturnsCommonStructuredLogFormat() {
		assertThat(CommonStructuredLogFormat.forId('ECS')).isEqualTo(CommonStructuredLogFormat.ELASTIC_COMMON_SCHEMA);
		assertThat(CommonStructuredLogFormat.forId('logSTAsh')).isEqualTo(CommonStructuredLogFormat.LOGSTASH);
	}
	@Test
	void forIdWhenNotKnownReturnsNull() {
		assertThat(CommonStructuredLogFormat.forId('madeup')).isNull();
	}
}
/*
package org.springframework.boot.logging.structured;
/**
class StructuredLogFormatterFactoryTests {
	private final StructuredLogFormatterFactory<LogEvent> factory;
	private final MockEnvironment environment = new MockEnvironment();
	StructuredLogFormatterFactoryTests() {
		this.environment.setProperty('logging.structured.ecs.service.version', '1.2.3');
		this.factory = new StructuredLogFormatterFactory<>(LogEvent.class, this.environment,
				this::addAvailableParameters, this::addCommonFormatters);
	}
	private void addAvailableParameters(AvailableParameters availableParameters) {
		availableParameters.add(StringBuilder.class, new StringBuilder('Hello'));
	}
	private void addCommonFormatters(CommonFormatters<LogEvent> commonFormatters) {
		commonFormatters.add(CommonStructuredLogFormat.ELASTIC_COMMON_SCHEMA,
				(instantiator) -> new TestEcsFormatter(instantiator.getArg(Environment.class),
						instantiator.getArg(StringBuilder.class)));
	}
	@Test
	void getUsingCommonFormat() {
		assertThat(this.factory.get('ecs')).isInstanceOf(TestEcsFormatter.class);
	}
	@Test
	void getUsingClassName() {
		assertThat(this.factory.get(ExtendedTestEcsFormatter.class.getName()))
			.isInstanceOf(ExtendedTestEcsFormatter.class);
	}
	@Test
	void getUsingClassNameWhenNoSuchClass() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> assertThat(this.factory.get('com.example.WeMadeItUp')).isNull())
			.withMessage('Unknown format "com.example.WeMadeItUp". '
					+ 'Values can be a valid fully-qualified class name or one of the common formats: [ecs]');
	}
	@Test
	void getUsingClassNameWhenHasGenericMismatch() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.factory.get(DifferentFormatter.class.getName()))
			.withMessage('Type argument of org.springframework.boot.logging.structured.'
					+ 'StructuredLogFormatterFactoryTests$DifferentFormatter '
					+ 'must be org.springframework.boot.logging.structured.'
					+ 'StructuredLogFormatterFactoryTests$LogEvent '
					+ 'but was org.springframework.boot.logging.structured.'
					+ 'StructuredLogFormatterFactoryTests$DifferentLogEvent');
	}
	@Test
	void getUsingClassNameInjectsApplicationMetadata() {
		TestEcsFormatter formatter = (TestEcsFormatter) this.factory.get(TestEcsFormatter.class.getName());
		assertThat(formatter.getEnvironment()).isSameAs(this.environment);
	}
	@Test
	void getUsingClassNameInjectsCustomParameter() {
		TestEcsFormatter formatter = (TestEcsFormatter) this.factory.get(TestEcsFormatter.class.getName());
		assertThat(formatter.getCustom()).hasToString('Hello');
	}
	@Test
	void getInjectCustomizers() {
		this.environment.setProperty('logging.structured.json.rename.spring', 'test');
		SpringFactoriesLoader factoriesLoader = mock(SpringFactoriesLoader.class);
		StructureLoggingJsonMembersCustomizer<?> customizer = (members) -> members
			.applyingValueProcessor(ValueProcessor.of(String.class, String::toUpperCase));
		given(factoriesLoader.load(any(), any(ArgumentResolver.class))).willReturn(List.of(customizer));
		StructuredLogFormatterFactory<LogEvent> factory = new StructuredLogFormatterFactory<>(factoriesLoader,
				LogEvent.class, this.environment, this::addAvailableParameters, this::addCommonFormatters);
		CutomizedFormatter formatter = (CutomizedFormatter) factory.get(CutomizedFormatter.class.getName());
		assertThat(formatter.format(new LogEvent())).contains('\'test\':\'BOOT\'');
	}
	static class LogEvent {
	}
	static class DifferentLogEvent {
	}
	static class TestEcsFormatter implements StructuredLogFormatter<LogEvent> {
		private Environment environment;
		private StringBuilder custom;
		TestEcsFormatter(Environment environment, StringBuilder custom) {
			this.environment = environment;
			this.custom = custom;
		}
		@Override
		public String format(LogEvent event) {
			return 'formatted ' + this.environment.getProperty('logging.structured.ecs.service.version');
		}
		Environment getEnvironment() {
			return this.environment;
		}
		StringBuilder getCustom() {
			return this.custom;
		}
	}
	static class ExtendedTestEcsFormatter extends TestEcsFormatter {
		ExtendedTestEcsFormatter(Environment environment, StringBuilder custom) {
			super(environment, custom);
		}
	}
	static class DifferentFormatter implements StructuredLogFormatter<DifferentLogEvent> {
		@Override
		public String format(DifferentLogEvent event) {
			return '';
		}
	}
	static class CutomizedFormatter extends JsonWriterStructuredLogFormatter<LogEvent> {
		CutomizedFormatter(StructureLoggingJsonMembersCustomizer<?> customizer) {
			super((members) -> members.add('spring', 'boot'), customizer);
		}
	}
}
/*
package org.springframework.boot.logging.structured;
/**
@ExtendWith(MockitoExtension.class)
class StructuredLoggingJsonPropertiesJsonMembersCustomizerTests {
	@Mock
	private Instantiator<?> instantiator;
	@Test
	void customizeWhenHasExcludeFiltersMember() {
		StructuredLoggingJsonProperties properties = new StructuredLoggingJsonProperties(Collections.emptySet(),
				Set.of('a'), Collections.emptyMap(), Collections.emptyMap(), null);
		StructuredLoggingJsonPropertiesJsonMembersCustomizer customizer = new StructuredLoggingJsonPropertiesJsonMembersCustomizer(
				this.instantiator, properties);
		assertThat(writeSampleJson(customizer)).doesNotContain('a').contains('b');
	}
	@Test
	void customizeWhenHasIncludeFiltersOtherMembers() {
		StructuredLoggingJsonProperties properties = new StructuredLoggingJsonProperties(Set.of('a'),
				Collections.emptySet(), Collections.emptyMap(), Collections.emptyMap(), null);
		StructuredLoggingJsonPropertiesJsonMembersCustomizer customizer = new StructuredLoggingJsonPropertiesJsonMembersCustomizer(
				this.instantiator, properties);
		assertThat(writeSampleJson(customizer)).contains('a')
			.doesNotContain('b')
			.doesNotContain('c')
			.doesNotContain('d');
	}
	@Test
	void customizeWhenHasIncludeAndExcludeFiltersMembers() {
		StructuredLoggingJsonProperties properties = new StructuredLoggingJsonProperties(Set.of('a', 'b'), Set.of('b'),
				Collections.emptyMap(), Collections.emptyMap(), null);
		StructuredLoggingJsonPropertiesJsonMembersCustomizer customizer = new StructuredLoggingJsonPropertiesJsonMembersCustomizer(
				this.instantiator, properties);
		assertThat(writeSampleJson(customizer)).contains('a')
			.doesNotContain('b')
			.doesNotContain('c')
			.doesNotContain('d');
	}
	@Test
	void customizeWhenHasRenameRenamesMember() {
		StructuredLoggingJsonProperties properties = new StructuredLoggingJsonProperties(Collections.emptySet(),
				Collections.emptySet(), Map.of('a', 'z'), Collections.emptyMap(), null);
		StructuredLoggingJsonPropertiesJsonMembersCustomizer customizer = new StructuredLoggingJsonPropertiesJsonMembersCustomizer(
				this.instantiator, properties);
		assertThat(writeSampleJson(customizer)).contains('\'z\':\'a\'');
	}
	@Test
	void customizeWhenHasAddAddsMemeber() {
		StructuredLoggingJsonProperties properties = new StructuredLoggingJsonProperties(Collections.emptySet(),
				Collections.emptySet(), Collections.emptyMap(), Map.of('z', 'z'), null);
		StructuredLoggingJsonPropertiesJsonMembersCustomizer customizer = new StructuredLoggingJsonPropertiesJsonMembersCustomizer(
				this.instantiator, properties);
		assertThat(writeSampleJson(customizer)).contains('\'z\':\'z\'');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void customizeWhenHasCustomizerCustomizesMember() {
		StructureLoggingJsonMembersCustomizer<?> uppercaseCustomizer = (members) -> members
			.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
		given(((Instantiator) this.instantiator).instantiate('test')).willReturn(uppercaseCustomizer);
		StructuredLoggingJsonProperties properties = new StructuredLoggingJsonProperties(Collections.emptySet(),
				Collections.emptySet(), Collections.emptyMap(), Collections.emptyMap(), 'test');
		StructuredLoggingJsonPropertiesJsonMembersCustomizer customizer = new StructuredLoggingJsonPropertiesJsonMembersCustomizer(
				this.instantiator, properties);
		assertThat(writeSampleJson(customizer)).contains('\'A\':\'a\'');
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private String writeSampleJson(StructureLoggingJsonMembersCustomizer customizer) {
		return JsonWriter.of((members) -> {
			members.add('a', 'a');
			members.add('b', 'b');
			members.add('c', 'c');
			customizer.customize(members);
		}).writeToString(new Object());
	}
}
/*
package org.springframework.boot.logging.structured;
/**
class GraylogExtendedLogFormatPropertiesTests {
	@Test
	void getBindsFromEnvironment() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('logging.structured.gelf.host', 'spring');
		environment.setProperty('logging.structured.gelf.service.version', '1.2.3');
		GraylogExtendedLogFormatProperties properties = GraylogExtendedLogFormatProperties.get(environment);
		assertThat(properties).isEqualTo(new GraylogExtendedLogFormatProperties('spring', new Service('1.2.3')));
	}
	@Test
	void getWhenNoServiceNameUsesApplicationName() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.application.name', 'spring');
		GraylogExtendedLogFormatProperties properties = GraylogExtendedLogFormatProperties.get(environment);
		assertThat(properties).isEqualTo(new GraylogExtendedLogFormatProperties('spring', new Service(null)));
	}
	@Test
	void getWhenNoServiceVersionUsesApplicationVersion() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.application.version', '1.2.3');
		GraylogExtendedLogFormatProperties properties = GraylogExtendedLogFormatProperties.get(environment);
		assertThat(properties).isEqualTo(new GraylogExtendedLogFormatProperties(null, new Service('1.2.3')));
	}
	@Test
	void getWhenNoPropertiesToBind() {
		MockEnvironment environment = new MockEnvironment();
		GraylogExtendedLogFormatProperties properties = GraylogExtendedLogFormatProperties.get(environment);
		assertThat(properties).isEqualTo(new GraylogExtendedLogFormatProperties(null, new Service(null)));
	}
	@Test
	void addToJsonMembersCreatesValidJson() {
		GraylogExtendedLogFormatProperties properties = new GraylogExtendedLogFormatProperties('spring',
				new Service('1.2.3'));
		JsonWriter<GraylogExtendedLogFormatProperties> writer = JsonWriter.of(properties::jsonMembers);
		assertThat(writer.writeToString(properties)).isEqualTo('{\'host\':\'spring\',\'_service_version\':\'1.2.3\'}');
	}
}
/*
package org.springframework.boot.logging;
/**
@ClassPathExclusions({ 'log4j-*.jar', 'logback-*.jar' })
class LogbackAndLog4J2ExcludedLoggingSystemTests {
	@Test
	void whenLogbackAndLog4J2AreNotPresentJULIsTheLoggingSystem() {
		assertThat(LoggingSystem.get(getClass().getClassLoader())).isInstanceOf(JavaLoggingSystem.class);
	}
}
/*
package org.springframework.boot.logging;
/**
class DeferredLogFactoryTests {
	private final DeferredLogFactory factory = (supplier) -> this.log = supplier.get();
	private Log log;
	@Test
	void getLogFromClassCreatesLogSupplier() {
		this.factory.getLog(DeferredLogFactoryTests.class);
		assertThat(this.log).isNotNull();
	}
	@Test
	void getLogFromDestinationCreatesLogSupplier() {
		Log log = mock(Log.class);
		this.factory.getLog(log);
		assertThat(this.log).isSameAs(log);
	}
}
/*
package org.springframework.boot.logging.java;
/**
@ExtendWith(OutputCaptureExtension.class)
class JavaLoggingSystemTests extends AbstractLoggingSystemTests {
	private static final FileFilter SPRING_LOG_FILTER = (pathname) -> pathname.getName().startsWith('spring.log');
	private final JavaLoggingSystem loggingSystem = new JavaLoggingSystem(getClass().getClassLoader());
	private Logger logger;
	private Locale defaultLocale;
	@BeforeEach
	void init() {
		this.logger = Logger.getLogger(getClass().getName());
		this.defaultLocale = Locale.getDefault();
		Locale.setDefault(Locale.ENGLISH);
	}
	@AfterEach
	void resetLogger() {
		this.logger.setLevel(Level.OFF);
		this.loggingSystem.getShutdownHandler().run();
	}
	@AfterEach
	void restoreLocale() {
		Locale.setDefault(this.defaultLocale);
	}
	@Test
	void noFile(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.logger.info('Hidden');
		this.loggingSystem.initialize(null, null, null);
		this.logger.info('Hello world');
		assertThat(output).contains('Hello world').doesNotContain('Hidden');
		assertThat(new File(tmpDir() + '/spring.log')).doesNotExist();
	}
	@Test
	void withFile(CapturedOutput output) {
		File temp = new File(tmpDir());
		File[] logFiles = temp.listFiles(SPRING_LOG_FILTER);
		for (File file : logFiles) {
			file.delete();
		}
		this.loggingSystem.beforeInitialize();
		this.logger.info('Hidden');
		this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir()));
		this.logger.info('Hello world');
		assertThat(output).contains('Hello world').doesNotContain('Hidden');
		assertThat(temp.listFiles(SPRING_LOG_FILTER)).isNotEmpty();
	}
	@Test
	void testCustomFormatter(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null, null, null);
		this.logger.info('Hello world');
		assertThat(output).contains('Hello world').contains('???? INFO [');
	}
	@Test
	void testSystemPropertyInitializesFormat(CapturedOutput output) {
		System.setProperty(LoggingSystemProperty.PID.getEnvironmentVariableName(), '1234');
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null,
				'classpath:' + ClassUtils.addResourcePathToPackagePath(getClass(), 'logging.properties'), null);
		this.logger.info('Hello world');
		this.logger.info('Hello world');
		assertThat(output).contains('Hello world').contains('1234 INFO [');
	}
	@Test
	void testNonDefaultConfigLocation(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null, 'classpath:logging-nondefault.properties', null);
		this.logger.info('Hello world');
		assertThat(output).contains('INFO: Hello');
	}
	@Test
	void testNonexistentConfigLocation() {
		this.loggingSystem.beforeInitialize();
		assertThatIllegalStateException()
			.isThrownBy(() -> this.loggingSystem.initialize(null, 'classpath:logging-nonexistent.properties', null));
	}
	@Test
	void getSupportedLevels() {
		assertThat(this.loggingSystem.getSupportedLogLevels()).isEqualTo(
				EnumSet.of(LogLevel.TRACE, LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR, LogLevel.OFF));
	}
	@Test
	void setLevel(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null, null, null);
		this.logger.fine('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', LogLevel.DEBUG);
		this.logger.fine('Hello');
		assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Hello')).isOne();
	}
	@Test
	void setLevelToNull(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null, null, null);
		this.logger.fine('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', LogLevel.DEBUG);
		this.logger.fine('Hello');
		this.loggingSystem.setLogLevel('org.springframework.boot', null);
		this.logger.fine('Hello');
		assertThat(StringUtils.countOccurrencesOf(output.toString(), 'Hello')).isOne();
	}
	@Test
	void getLoggerConfigurations() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		List<LoggerConfiguration> configurations = this.loggingSystem.getLoggerConfigurations();
		assertThat(configurations).isNotEmpty();
		assertThat(configurations.get(0).getName()).isEqualTo(LoggingSystem.ROOT_LOGGER_NAME);
	}
	@Test
	void getLoggerConfiguration() {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null, null, null);
		this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG);
		LoggerConfiguration configuration = this.loggingSystem.getLoggerConfiguration(getClass().getName());
		assertThat(configuration)
			.isEqualTo(new LoggerConfiguration(getClass().getName(), LogLevel.DEBUG, LogLevel.DEBUG));
	}
	@Test
	void shouldNotContainAnsiEscapeCodes(CapturedOutput output) {
		this.loggingSystem.beforeInitialize();
		this.loggingSystem.initialize(null, null, null);
		this.logger.info('Hello world');
		assertThat(output).doesNotContain('\033[');
	}
}
/*
package org.springframework.boot.logging.java;
/**
public class TestFormatter extends Formatter {
	@Override
	public String format(LogRecord record) {
		return String.format('foo: %s -- %s%n', record.getLoggerName(), record.getMessage());
	}
}
/*
package org.springframework.boot;
/**
class EnvironmentConverterTests {
	private final EnvironmentConverter environmentConverter = new EnvironmentConverter(getClass().getClassLoader());
	@Test
	void convertedEnvironmentHasSameActiveProfiles() {
		AbstractEnvironment originalEnvironment = new MockEnvironment();
		originalEnvironment.setActiveProfiles('activeProfile1', 'activeProfile2');
		ConfigurableEnvironment convertedEnvironment = this.environmentConverter
			.convertEnvironmentIfNecessary(originalEnvironment, StandardEnvironment.class);
		assertThat(convertedEnvironment.getActiveProfiles()).containsExactly('activeProfile1', 'activeProfile2');
	}
	@Test
	void convertedEnvironmentHasSameConversionService() {
		AbstractEnvironment originalEnvironment = new MockEnvironment();
		ConfigurableConversionService conversionService = mock(ConfigurableConversionService.class);
		originalEnvironment.setConversionService(conversionService);
		ConfigurableEnvironment convertedEnvironment = this.environmentConverter
			.convertEnvironmentIfNecessary(originalEnvironment, StandardEnvironment.class);
		assertThat(convertedEnvironment.getConversionService()).isEqualTo(conversionService);
	}
	@Test
	void envClassSameShouldReturnEnvironmentUnconverted() {
		StandardEnvironment standardEnvironment = new StandardEnvironment();
		ConfigurableEnvironment convertedEnvironment = this.environmentConverter
			.convertEnvironmentIfNecessary(standardEnvironment, StandardEnvironment.class);
		assertThat(convertedEnvironment).isSameAs(standardEnvironment);
	}
	@Test
	void standardServletEnvironmentIsConverted() {
		StandardServletEnvironment standardServletEnvironment = new StandardServletEnvironment();
		ConfigurableEnvironment convertedEnvironment = this.environmentConverter
			.convertEnvironmentIfNecessary(standardServletEnvironment, StandardEnvironment.class);
		assertThat(convertedEnvironment).isNotSameAs(standardServletEnvironment);
	}
	@Test
	void servletPropertySourcesAreNotCopiedOverIfNotWebEnvironment() {
		StandardServletEnvironment standardServletEnvironment = new StandardServletEnvironment();
		ConfigurableEnvironment convertedEnvironment = this.environmentConverter
			.convertEnvironmentIfNecessary(standardServletEnvironment, StandardEnvironment.class);
		assertThat(convertedEnvironment).isNotSameAs(standardServletEnvironment);
		Set<String> names = new HashSet<>();
		for (PropertySource<?> propertySource : convertedEnvironment.getPropertySources()) {
			names.add(propertySource.getName());
		}
		assertThat(names).doesNotContain(StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME,
				StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME,
				StandardServletEnvironment.JNDI_PROPERTY_SOURCE_NAME);
	}
	@Test
	void envClassSameShouldReturnEnvironmentUnconvertedEvenForWeb() {
		StandardServletEnvironment standardServletEnvironment = new StandardServletEnvironment();
		ConfigurableEnvironment convertedEnvironment = this.environmentConverter
			.convertEnvironmentIfNecessary(standardServletEnvironment, StandardServletEnvironment.class);
		assertThat(convertedEnvironment).isSameAs(standardServletEnvironment);
	}
	@Test
	void servletPropertySourcesArePresentWhenTypeToConvertIsWeb() {
		StandardEnvironment standardEnvironment = new StandardEnvironment();
		ConfigurableEnvironment convertedEnvironment = this.environmentConverter
			.convertEnvironmentIfNecessary(standardEnvironment, StandardServletEnvironment.class);
		assertThat(convertedEnvironment).isNotSameAs(standardEnvironment);
		Set<String> names = new HashSet<>();
		for (PropertySource<?> propertySource : convertedEnvironment.getPropertySources()) {
			names.add(propertySource.getName());
		}
		assertThat(names).contains(StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME,
				StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME);
	}
}
/*
package org.springframework.boot;
/**
class DefaultApplicationArgumentsTests {
	private static final String[] ARGS = new String[] { '--foo=bar', '--foo=baz', '--debug', 'spring', 'boot' };
	@Test
	void argumentsMustNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DefaultApplicationArguments((String[]) null))
			.withMessageContaining('Args must not be null');
	}
	@Test
	void getArgs() {
		ApplicationArguments arguments = new DefaultApplicationArguments(ARGS);
		assertThat(arguments.getSourceArgs()).isEqualTo(ARGS);
	}
	@Test
	void optionNames() {
		ApplicationArguments arguments = new DefaultApplicationArguments(ARGS);
		Set<String> expected = new HashSet<>(Arrays.asList('foo', 'debug'));
		assertThat(arguments.getOptionNames()).isEqualTo(expected);
	}
	@Test
	void containsOption() {
		ApplicationArguments arguments = new DefaultApplicationArguments(ARGS);
		assertThat(arguments.containsOption('foo')).isTrue();
		assertThat(arguments.containsOption('debug')).isTrue();
		assertThat(arguments.containsOption('spring')).isFalse();
	}
	@Test
	void getOptionValues() {
		ApplicationArguments arguments = new DefaultApplicationArguments(ARGS);
		assertThat(arguments.getOptionValues('foo')).isEqualTo(Arrays.asList('bar', 'baz'));
		assertThat(arguments.getOptionValues('debug')).isEmpty();
		assertThat(arguments.getOptionValues('spring')).isNull();
	}
	@Test
	void getNonOptionArgs() {
		ApplicationArguments arguments = new DefaultApplicationArguments(ARGS);
		assertThat(arguments.getNonOptionArgs()).containsExactly('spring', 'boot');
	}
	@Test
	void getNoNonOptionArgs() {
		ApplicationArguments arguments = new DefaultApplicationArguments('--debug');
		assertThat(arguments.getNonOptionArgs()).isEmpty();
	}
}
/*
package org.springframework.boot.info;
/**
class JavaInfoTests {
	@Test
	void javaInfoIsAvailable() {
		JavaInfo javaInfo = new JavaInfo();
		assertThat(javaInfo.getVersion()).isEqualTo(System.getProperty('java.version'));
		assertThat(javaInfo.getVendor()).satisfies((vendorInfo) -> {
			assertThat(vendorInfo.getName()).isEqualTo(System.getProperty('java.vendor'));
			assertThat(vendorInfo.getVersion()).isEqualTo(System.getProperty('java.vendor.version'));
		});
		assertThat(javaInfo.getRuntime()).satisfies((jreInfo) -> {
			assertThat(jreInfo.getName()).isEqualTo(System.getProperty('java.runtime.name'));
			assertThat(jreInfo.getVersion()).isEqualTo(System.getProperty('java.runtime.version'));
		});
		assertThat(javaInfo.getJvm()).satisfies((jvmInfo) -> {
			assertThat(jvmInfo.getName()).isEqualTo(System.getProperty('java.vm.name'));
			assertThat(jvmInfo.getVendor()).isEqualTo(System.getProperty('java.vm.vendor'));
			assertThat(jvmInfo.getVersion()).isEqualTo(System.getProperty('java.vm.version'));
		});
	}
}
/*
package org.springframework.boot.info;
/**
class InfoPropertiesTests {
	@Test
	void inputIsImmutable() {
		Properties p = new Properties();
		p.put('foo', 'bar');
		InfoProperties infoProperties = new InfoProperties(p);
		assertThat(infoProperties.get('foo')).isEqualTo('bar');
		p.remove('foo');
		assertThat(infoProperties.get('foo')).isEqualTo('bar');
	}
	@Test
	void iterator() {
		Properties p = new Properties();
		p.put('one', 'first');
		p.put('two', 'second');
		InfoProperties infoProperties = new InfoProperties(p);
		Properties copy = new Properties();
		for (InfoProperties.Entry entry : infoProperties) {
			copy.put(entry.getKey(), entry.getValue());
		}
		assertThat(p).isEqualTo(copy);
	}
	@Test
	void removeNotSupported() {
		Properties p = new Properties();
		p.put('foo', 'bar');
		InfoProperties infoProperties = new InfoProperties(p);
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(infoProperties.iterator()::remove);
	}
	@Test
	void toPropertySources() {
		Properties p = new Properties();
		p.put('one', 'first');
		p.put('two', 'second');
		InfoProperties infoProperties = new MyInfoProperties(p);
		PropertySource<?> source = infoProperties.toPropertySource();
		assertThat(source.getProperty('one')).isEqualTo('first');
		assertThat(source.getProperty('two')).isEqualTo('second');
		assertThat(source.getName()).isEqualTo('MyInfoProperties');
	}
	static class MyInfoProperties extends InfoProperties {
		MyInfoProperties(Properties entries) {
			super(entries);
		}
	}
}
/*
package org.springframework.boot.info;
/**
class BuildPropertiesTests {
	@Test
	void basicInfo() {
		Instant instant = Instant.now();
		BuildProperties properties = new BuildProperties(
				createProperties('com.example', 'demo', '0.0.1', DateTimeFormatter.ISO_INSTANT.format(instant)));
		assertThat(properties.getGroup()).isEqualTo('com.example');
		assertThat(properties.getArtifact()).isEqualTo('demo');
		assertThat(properties.getVersion()).isEqualTo('0.0.1');
		assertThat(properties.getTime()).isEqualTo(instant.truncatedTo(ChronoUnit.MILLIS));
		assertThat(properties.get('time')).isEqualTo(String.valueOf(instant.toEpochMilli()));
	}
	@Test
	void noInfo() {
		BuildProperties properties = new BuildProperties(new Properties());
		assertThat(properties.getGroup()).isNull();
		assertThat(properties.getArtifact()).isNull();
		assertThat(properties.getVersion()).isNull();
		assertThat(properties.getTime()).isNull();
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new BuildProperties.BuildPropertiesRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('META-INF/build-info.properties'))
			.accepts(runtimeHints);
	}
	private static Properties createProperties(String group, String artifact, String version, String buildTime) {
		Properties properties = new Properties();
		properties.put('group', group);
		properties.put('artifact', artifact);
		properties.put('version', version);
		properties.put('time', buildTime);
		return properties;
	}
}
/*
package org.springframework.boot.info;
/**
class GitPropertiesTests {
	@Test
	void basicInfo() {
		GitProperties properties = new GitProperties(
				createProperties('master', 'abcdefghijklmno', 'abcdefg', '1457527123'));
		assertThat(properties.getBranch()).isEqualTo('master');
		assertThat(properties.getCommitId()).isEqualTo('abcdefghijklmno');
		assertThat(properties.getShortCommitId()).isEqualTo('abcdefg');
	}
	@Test
	void noInfo() {
		GitProperties properties = new GitProperties(new Properties());
		assertThat(properties.getBranch()).isNull();
		assertThat(properties.getCommitId()).isNull();
		assertThat(properties.getShortCommitId()).isNull();
		assertThat(properties.getCommitTime()).isNull();
	}
	@Test
	void coerceEpochSecond() {
		GitProperties properties = new GitProperties(createProperties('master', 'abcdefg', null, '1457527123'));
		assertThat(properties.getCommitTime()).isNotNull();
		assertThat(properties.get('commit.time')).isEqualTo('1457527123000');
		assertThat(properties.getCommitTime().toEpochMilli()).isEqualTo(1457527123000L);
	}
	@Test
	void coerceLegacyDateString() {
		GitProperties properties = new GitProperties(
				createProperties('master', 'abcdefg', null, '2016-03-04T14:36:33+0100'));
		assertThat(properties.getCommitTime()).isNotNull();
		assertThat(properties.get('commit.time')).isEqualTo('1457098593000');
		assertThat(properties.getCommitTime().toEpochMilli()).isEqualTo(1457098593000L);
	}
	@Test
	void coerceDateString() {
		GitProperties properties = new GitProperties(
				createProperties('master', 'abcdefg', null, '2016-03-04T14:36:33+01:00'));
		assertThat(properties.getCommitTime()).isNotNull();
		assertThat(properties.get('commit.time')).isEqualTo('1457098593000');
		assertThat(properties.getCommitTime().toEpochMilli()).isEqualTo(1457098593000L);
	}
	@Test
	void coerceUnsupportedFormat() {
		GitProperties properties = new GitProperties(
				createProperties('master', 'abcdefg', null, '2016-03-04 15:22:24'));
		assertThat(properties.getCommitTime()).isNull();
		assertThat(properties.get('commit.time')).isEqualTo('2016-03-04 15:22:24');
	}
	@Test
	void shortCommitUsedIfPresent() {
		GitProperties properties = new GitProperties(
				createProperties('master', 'abcdefghijklmno', 'abcdefgh', '1457527123'));
		assertThat(properties.getCommitId()).isEqualTo('abcdefghijklmno');
		assertThat(properties.getShortCommitId()).isEqualTo('abcdefgh');
	}
	@Test
	void shortenCommitIdShorterThan7() {
		GitProperties properties = new GitProperties(createProperties('master', 'abc', null, '1457527123'));
		assertThat(properties.getCommitId()).isEqualTo('abc');
		assertThat(properties.getShortCommitId()).isEqualTo('abc');
	}
	@Test
	void shortenCommitIdLongerThan7() {
		GitProperties properties = new GitProperties(createProperties('master', 'abcdefghijklmno', null, '1457527123'));
		assertThat(properties.getCommitId()).isEqualTo('abcdefghijklmno');
		assertThat(properties.getShortCommitId()).isEqualTo('abcdefg');
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new GitProperties.GitPropertiesRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('git.properties')).accepts(runtimeHints);
	}
	private static Properties createProperties(String branch, String commitId, String commitIdAbbrev,
			String commitTime) {
		Properties properties = new Properties();
		properties.put('branch', branch);
		properties.put('commit.id', commitId);
		if (commitIdAbbrev != null) {
			properties.put('commit.id.abbrev', commitIdAbbrev);
		}
		properties.put('commit.time', commitTime);
		return properties;
	}
}
/*
package org.springframework.boot.info;
/**
class ProcessInfoTests {
	@Test
	void processInfoIsAvailable() {
		ProcessInfo processInfo = new ProcessInfo();
		assertThat(processInfo.getCpus()).isEqualTo(Runtime.getRuntime().availableProcessors());
		assertThat(processInfo.getOwner()).isEqualTo(ProcessHandle.current().info().user().orElse(null));
		assertThat(processInfo.getPid()).isEqualTo(ProcessHandle.current().pid());
		assertThat(processInfo.getParentPid())
			.isEqualTo(ProcessHandle.current().parent().map(ProcessHandle::pid).orElse(null));
	}
	@Test
	void memoryInfoIsAvailable() {
		ProcessInfo processInfo = new ProcessInfo();
		MemoryUsageInfo heapUsageInfo = processInfo.getMemory().getHeap();
		MemoryUsageInfo nonHeapUsageInfo = processInfo.getMemory().getNonHeap();
		assertThat(heapUsageInfo.getInit()).isPositive().isLessThanOrEqualTo(heapUsageInfo.getMax());
		assertThat(heapUsageInfo.getUsed()).isPositive().isLessThanOrEqualTo(heapUsageInfo.getCommitted());
		assertThat(heapUsageInfo.getCommitted()).isPositive().isLessThanOrEqualTo(heapUsageInfo.getMax());
		assertThat(heapUsageInfo.getMax()).isPositive();
		assertThat(nonHeapUsageInfo.getInit()).isPositive();
		assertThat(nonHeapUsageInfo.getUsed()).isPositive().isLessThanOrEqualTo(heapUsageInfo.getCommitted());
		assertThat(nonHeapUsageInfo.getCommitted()).isPositive();
		assertThat(nonHeapUsageInfo.getMax()).isEqualTo(-1);
	}
}
/*
package org.springframework.boot.info;
/**
class SslInfoTests {
	@Test
	void validCertificatesShouldProvideSslInfo() {
		SslInfo sslInfo = createSslInfo('classpath:test.p12');
		assertThat(sslInfo.getBundles()).hasSize(1);
		BundleInfo bundle = sslInfo.getBundles().get(0);
		assertThat(bundle.getName()).isEqualTo('test-0');
		assertThat(bundle.getCertificateChains()).hasSize(4);
		assertThat(bundle.getCertificateChains().get(0).getAlias()).isEqualTo('spring-boot');
		assertThat(bundle.getCertificateChains().get(0).getCertificates()).hasSize(1);
		assertThat(bundle.getCertificateChains().get(1).getAlias()).isEqualTo('test-alias');
		assertThat(bundle.getCertificateChains().get(1).getCertificates()).hasSize(1);
		assertThat(bundle.getCertificateChains().get(2).getAlias()).isEqualTo('spring-boot-cert');
		assertThat(bundle.getCertificateChains().get(2).getCertificates()).isEmpty();
		assertThat(bundle.getCertificateChains().get(3).getAlias()).isEqualTo('test-alias-cert');
		assertThat(bundle.getCertificateChains().get(3).getCertificates()).isEmpty();
		CertificateInfo cert1 = bundle.getCertificateChains().get(0).getCertificates().get(0);
		assertThat(cert1.getSubject()).isEqualTo('CN=localhost,OU=Spring,O=VMware,L=Palo Alto,ST=California,C=US');
		assertThat(cert1.getIssuer()).isEqualTo(cert1.getSubject());
		assertThat(cert1.getSerialNumber()).isNotEmpty();
		assertThat(cert1.getVersion()).isEqualTo('V3');
		assertThat(cert1.getSignatureAlgorithmName()).isEqualTo('SHA256withRSA');
		assertThat(cert1.getValidityStarts()).isInThePast();
		assertThat(cert1.getValidityEnds()).isInTheFuture();
		assertThat(cert1.getValidity()).isNotNull();
		assertThat(cert1.getValidity().getStatus()).isSameAs(Status.VALID);
		assertThat(cert1.getValidity().getMessage()).isNull();
		CertificateInfo cert2 = bundle.getCertificateChains().get(1).getCertificates().get(0);
		assertThat(cert2.getSubject()).isEqualTo('CN=localhost,OU=Spring,O=VMware,L=Palo Alto,ST=California,C=US');
		assertThat(cert2.getIssuer()).isEqualTo(cert2.getSubject());
		assertThat(cert2.getSerialNumber()).isNotEmpty();
		assertThat(cert2.getVersion()).isEqualTo('V3');
		assertThat(cert2.getSignatureAlgorithmName()).isEqualTo('SHA256withRSA');
		assertThat(cert2.getValidityStarts()).isInThePast();
		assertThat(cert2.getValidityEnds()).isInTheFuture();
		assertThat(cert2.getValidity()).isNotNull();
		assertThat(cert2.getValidity().getStatus()).isSameAs(Status.VALID);
		assertThat(cert2.getValidity().getMessage()).isNull();
	}
	@Test
	void notYetValidCertificateShouldProvideSslInfo() {
		SslInfo sslInfo = createSslInfo('classpath:test-not-yet-valid.p12');
		assertThat(sslInfo.getBundles()).hasSize(1);
		BundleInfo bundle = sslInfo.getBundles().get(0);
		assertThat(bundle.getName()).isEqualTo('test-0');
		assertThat(bundle.getCertificateChains()).hasSize(1);
		CertificateChainInfo certificateChain = bundle.getCertificateChains().get(0);
		assertThat(certificateChain.getAlias()).isEqualTo('spring-boot');
		List<CertificateInfo> certs = certificateChain.getCertificates();
		assertThat(certs).hasSize(1);
		CertificateInfo cert = certs.get(0);
		assertThat(cert.getSubject()).isEqualTo('CN=localhost,OU=Spring,O=VMware,L=Palo Alto,ST=California,C=US');
		assertThat(cert.getIssuer()).isEqualTo(cert.getSubject());
		assertThat(cert.getSerialNumber()).isNotEmpty();
		assertThat(cert.getVersion()).isEqualTo('V3');
		assertThat(cert.getSignatureAlgorithmName()).isEqualTo('SHA256withRSA');
		assertThat(cert.getValidityStarts()).isInTheFuture();
		assertThat(cert.getValidityEnds()).isInTheFuture();
		assertThat(cert.getValidity()).isNotNull();
		assertThat(cert.getValidity().getStatus()).isSameAs(Status.NOT_YET_VALID);
		assertThat(cert.getValidity().getMessage()).startsWith('Not valid before');
	}
	@Test
	void expiredCertificateShouldProvideSslInfo() {
		SslInfo sslInfo = createSslInfo('classpath:test-expired.p12');
		assertThat(sslInfo.getBundles()).hasSize(1);
		BundleInfo bundle = sslInfo.getBundles().get(0);
		assertThat(bundle.getName()).isEqualTo('test-0');
		assertThat(bundle.getCertificateChains()).hasSize(1);
		CertificateChainInfo certificateChain = bundle.getCertificateChains().get(0);
		assertThat(certificateChain.getAlias()).isEqualTo('spring-boot');
		List<CertificateInfo> certs = certificateChain.getCertificates();
		assertThat(certs).hasSize(1);
		CertificateInfo cert = certs.get(0);
		assertThat(cert.getSubject()).isEqualTo('CN=localhost,OU=Spring,O=VMware,L=Palo Alto,ST=California,C=US');
		assertThat(cert.getIssuer()).isEqualTo(cert.getSubject());
		assertThat(cert.getSerialNumber()).isNotEmpty();
		assertThat(cert.getVersion()).isEqualTo('V3');
		assertThat(cert.getSignatureAlgorithmName()).isEqualTo('SHA256withRSA');
		assertThat(cert.getValidityStarts()).isInThePast();
		assertThat(cert.getValidityEnds()).isInThePast();
		assertThat(cert.getValidity()).isNotNull();
		assertThat(cert.getValidity().getStatus()).isSameAs(Status.EXPIRED);
		assertThat(cert.getValidity().getMessage()).startsWith('Not valid after');
	}
	@Test
	void soonToBeExpiredCertificateShouldProvideSslInfo(@TempDir Path tempDir)
			throws IOException, InterruptedException {
		Path keyStore = createKeyStore(tempDir);
		SslInfo sslInfo = createSslInfo(keyStore.toString());
		assertThat(sslInfo.getBundles()).hasSize(1);
		BundleInfo bundle = sslInfo.getBundles().get(0);
		assertThat(bundle.getName()).isEqualTo('test-0');
		assertThat(bundle.getCertificateChains()).hasSize(1);
		CertificateChainInfo certificateChain = bundle.getCertificateChains().get(0);
		assertThat(certificateChain.getAlias()).isEqualTo('spring-boot');
		List<CertificateInfo> certs = certificateChain.getCertificates();
		assertThat(certs).hasSize(1);
		CertificateInfo cert = certs.get(0);
		assertThat(cert.getSubject()).isEqualTo('CN=localhost,OU=Spring,O=VMware,L=Palo Alto,ST=California,C=US');
		assertThat(cert.getIssuer()).isEqualTo(cert.getSubject());
		assertThat(cert.getSerialNumber()).isNotEmpty();
		assertThat(cert.getVersion()).isEqualTo('V3');
		assertThat(cert.getSignatureAlgorithmName()).isNotEmpty();
		assertThat(cert.getValidityStarts()).isInThePast();
		assertThat(cert.getValidityEnds()).isInTheFuture();
		assertThat(cert.getValidity()).isNotNull();
		assertThat(cert.getValidity().getStatus()).isSameAs(Status.WILL_EXPIRE_SOON);
		assertThat(cert.getValidity().getMessage()).startsWith('Certificate will expire within threshold');
	}
	@Test
	void multipleBundlesShouldProvideSslInfo(@TempDir Path tempDir) throws IOException, InterruptedException {
		Path keyStore = createKeyStore(tempDir);
		SslInfo sslInfo = createSslInfo('classpath:test.p12', 'classpath:test-not-yet-valid.p12',
				'classpath:test-expired.p12', keyStore.toString());
		assertThat(sslInfo.getBundles()).hasSize(4);
		assertThat(sslInfo.getBundles()).allSatisfy((bundle) -> assertThat(bundle.getName()).startsWith('test-'));
		List<CertificateInfo> certs = sslInfo.getBundles()
			.stream()
			.flatMap((bundle) -> bundle.getCertificateChains().stream())
			.flatMap((certificateChain) -> certificateChain.getCertificates().stream())
			.toList();
		assertThat(certs).hasSize(5);
		assertThat(certs).allSatisfy((cert) -> {
			assertThat(cert.getSubject()).isEqualTo('CN=localhost,OU=Spring,O=VMware,L=Palo Alto,ST=California,C=US');
			assertThat(cert.getIssuer()).isEqualTo(cert.getSubject());
			assertThat(cert.getSerialNumber()).isNotEmpty();
			assertThat(cert.getVersion()).isEqualTo('V3');
			assertThat(cert.getSignatureAlgorithmName()).isNotEmpty();
			assertThat(cert.getValidity()).isNotNull();
		});
		assertThat(certs).anySatisfy((cert) -> {
			assertThat(cert.getValidityStarts()).isInThePast();
			assertThat(cert.getValidityEnds()).isInTheFuture();
			assertThat(cert.getValidity()).isNotNull();
			assertThat(cert.getValidity().getStatus()).isSameAs(Status.VALID);
			assertThat(cert.getValidity().getMessage()).isNull();
		});
		assertThat(certs).satisfiesOnlyOnce((cert) -> {
			assertThat(cert.getValidityStarts()).isInTheFuture();
			assertThat(cert.getValidityEnds()).isInTheFuture();
			assertThat(cert.getValidity()).isNotNull();
			assertThat(cert.getValidity().getStatus()).isSameAs(Status.NOT_YET_VALID);
			assertThat(cert.getValidity().getMessage()).startsWith('Not valid before');
		});
		assertThat(certs).satisfiesOnlyOnce((cert) -> {
			assertThat(cert.getValidityStarts()).isInThePast();
			assertThat(cert.getValidityEnds()).isInThePast();
			assertThat(cert.getValidity()).isNotNull();
			assertThat(cert.getValidity().getStatus()).isSameAs(Status.EXPIRED);
			assertThat(cert.getValidity().getMessage()).startsWith('Not valid after');
		});
		assertThat(certs).satisfiesOnlyOnce((cert) -> {
			assertThat(cert.getValidityStarts()).isInThePast();
			assertThat(cert.getValidityEnds()).isInTheFuture();
			assertThat(cert.getValidity()).isNotNull();
			assertThat(cert.getValidity().getStatus()).isSameAs(Status.WILL_EXPIRE_SOON);
			assertThat(cert.getValidity().getMessage()).startsWith('Certificate will expire within threshold');
		});
	}
	private SslInfo createSslInfo(String... locations) {
		DefaultSslBundleRegistry sslBundleRegistry = new DefaultSslBundleRegistry();
		for (int i = 0; i < locations.length; i++) {
			JksSslStoreDetails keyStoreDetails = JksSslStoreDetails.forLocation(locations[i]).withPassword('secret');
			SslStoreBundle sslStoreBundle = new JksSslStoreBundle(keyStoreDetails, null);
			sslBundleRegistry.registerBundle('test-%d'.formatted(i), SslBundle.of(sslStoreBundle));
		}
		return new SslInfo(sslBundleRegistry, Duration.ofDays(7));
	}
	private Path createKeyStore(Path directory) throws IOException, InterruptedException {
		Path keyStore = directory.resolve('test.p12');
		Process process = createProcessBuilder(keyStore).start();
		int exitCode = process.waitFor();
		if (exitCode != 0) {
			try (BufferedReader reader = new BufferedReader(
					new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {
				String out = reader.lines().collect(Collectors.joining('\n'));
				throw new RuntimeException('Unexpected exit code from keytool: %d\n%s'.formatted(exitCode, out));
			}
		}
		return keyStore;
	}
	private ProcessBuilder createProcessBuilder(Path keystore) {
		// @formatter:off
		ProcessBuilder processBuilder = new ProcessBuilder(
				'keytool',
				'-genkeypair',
				'-storetype', 'PKCS12',
				'-alias', 'spring-boot',
				'-keyalg', 'RSA',
				'-storepass', 'secret',
				'-keypass', 'secret',
				'-keystore', keystore.toString(),
				'-dname', 'CN=localhost,OU=Spring,O=VMware,L=Palo Alto,ST=California,C=US',
				'-validity', '1',
				'-ext', 'SAN=DNS:localhost,IP:::1,IP:127.0.0.1'
		);
		// @formatter:on
		processBuilder.redirectErrorStream(true);
		return processBuilder;
	}
}
/*
package org.springframework.boot.info;
/**
class OsInfoTests {
	@Test
	void osInfoIsAvailable() {
		OsInfo osInfo = new OsInfo();
		assertThat(osInfo.getName()).isEqualTo(System.getProperty('os.name'));
		assertThat(osInfo.getVersion()).isEqualTo(System.getProperty('os.version'));
		assertThat(osInfo.getArch()).isEqualTo(System.getProperty('os.arch'));
	}
}
/*
package org.springframework.boot.system;
/**
class ApplicationTempTests {
	@BeforeEach
	@AfterEach
	void cleanup() {
		FileSystemUtils.deleteRecursively(new ApplicationTemp().getDir());
	}
	@Test
	void generatesConsistentTemp() {
		ApplicationTemp t1 = new ApplicationTemp();
		ApplicationTemp t2 = new ApplicationTemp();
		assertThat(t1.getDir()).isNotNull();
		assertThat(t1.getDir()).isEqualTo(t2.getDir());
	}
	@Test
	void differentBasedOnUserDir() {
		String userDir = System.getProperty('user.dir');
		try {
			File t1 = new ApplicationTemp().getDir();
			System.setProperty('user.dir', 'abc');
			File t2 = new ApplicationTemp().getDir();
			assertThat(t1).isNotEqualTo(t2);
		}
		finally {
			System.setProperty('user.dir', userDir);
		}
	}
	@Test
	void getSubDir() {
		ApplicationTemp temp = new ApplicationTemp();
		assertThat(temp.getDir('abc')).isEqualTo(new File(temp.getDir(), 'abc'));
	}
	@Test
	void posixPermissions() throws IOException {
		ApplicationTemp temp = new ApplicationTemp();
		Path path = temp.getDir().toPath();
		FileSystem fileSystem = path.getFileSystem();
		if (fileSystem.supportedFileAttributeViews().contains('posix')) {
			assertDirectoryPermissions(path);
			assertDirectoryPermissions(temp.getDir('sub').toPath());
		}
	}
	private void assertDirectoryPermissions(Path path) throws IOException {
		Set<PosixFilePermission> permissions = Files.getFileAttributeView(path, PosixFileAttributeView.class)
			.readAttributes()
			.permissions();
		assertThat(permissions).containsExactlyInAnyOrder(PosixFilePermission.OWNER_READ,
				PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_EXECUTE);
	}
}
/*
package org.springframework.boot.system;
/**
class ApplicationPidTests {
	@TempDir
	File tempDir;
	@Test
	void toStringWithPid() {
		assertThat(new ApplicationPid(123L)).hasToString('123');
	}
	@Test
	void toStringWithoutPid() {
		assertThat(new ApplicationPid(null)).hasToString('???');
	}
	@Test
	void throwIllegalStateWritingMissingPid() {
		ApplicationPid pid = new ApplicationPid(null);
		assertThatIllegalStateException().isThrownBy(() -> pid.write(new File(this.tempDir, 'pid')))
			.withMessageContaining('No PID available');
	}
	@Test
	void writePid() throws Exception {
		ApplicationPid pid = new ApplicationPid(123L);
		File file = new File(this.tempDir, 'pid');
		pid.write(file);
		assertThat(contentOf(file)).isEqualTo('123');
	}
	@Test
	void writeNewPid() throws Exception {
		// gh-10784
		ApplicationPid pid = new ApplicationPid(123L);
		File file = new File(this.tempDir, 'pid');
		file.delete();
		pid.write(file);
		assertThat(contentOf(file)).isEqualTo('123');
	}
	@Test
	void toLong() {
		ApplicationPid pid = new ApplicationPid(123L);
		assertThat(pid.toLong()).isEqualTo(123L);
	}
	@Test
	void toLongWhenNotAvailable() {
		ApplicationPid pid = new ApplicationPid(null);
		assertThat(pid.toLong()).isNull();
	}
	@Test
	void isAvailableWhenAvailable() {
		ApplicationPid pid = new ApplicationPid(123L);
		assertThat(pid.isAvailable()).isTrue();
	}
	@Test
	void isAvailableWhenNotAvailable() {
		ApplicationPid pid = new ApplicationPid(null);
		assertThat(pid.isAvailable()).isFalse();
	}
	@Test
	void getPidFromJvm() {
		assertThat(new ApplicationPid().toString()).isNotEmpty();
	}
}
/*
package org.springframework.boot.system;
/**
public final class MockApplicationPid {
	private MockApplicationPid() {
	}
	public static ApplicationPid of(long value) {
		return new ApplicationPid(value);
	}
}
/*
package org.springframework.boot.system;
/**
class ApplicationHomeTests {
	@TempDir
	File tempDir;
	@Test
	void whenSourceClassIsProvidedThenApplicationHomeReflectsItsLocation() throws Exception {
		File app = new File(this.tempDir, 'app');
		ApplicationHome applicationHome = createApplicationHome(app);
		assertThat(applicationHome.getDir()).isEqualTo(app);
	}
	@Test
	void whenSourceClassIsProvidedWithSpaceInItsPathThenApplicationHomeReflectsItsLocation() throws Exception {
		File app = new File(this.tempDir, 'app location');
		ApplicationHome applicationHome = createApplicationHome(app);
		assertThat(applicationHome.getDir()).isEqualTo(app);
	}
	private ApplicationHome createApplicationHome(File location) throws Exception {
		File examplePackage = new File(location, 'com/example');
		examplePackage.mkdirs();
		FileCopyUtils.copy(
				new ByteArrayInputStream(
						new ByteBuddy().subclass(Object.class).name('com.example.Source').make().getBytes()),
				new FileOutputStream(new File(examplePackage, 'Source.class')));
		try (URLClassLoader classLoader = new URLClassLoader(new URL[] { location.toURI().toURL() })) {
			Class<?> sourceClass = classLoader.loadClass('com.example.Source');
			// Separate thread to bypass stack-based unit test detection in
			// ApplicationHome
			ExecutorService executor = Executors.newSingleThreadExecutor();
			try {
				return executor.submit(() -> new ApplicationHome(sourceClass)).get();
			}
			finally {
				executor.shutdown();
			}
		}
	}
}
/*
package org.springframework.boot.system;
/**
class JavaVersionTests {
	@Test
	void getJavaVersionShouldBeAvailable() {
		assertThat(JavaVersion.getJavaVersion()).isNotNull();
	}
	@Test
	void compareToWhenComparingSmallerToGreaterShouldBeLessThanZero() {
		assertThat(JavaVersion.SEVENTEEN).isLessThan(JavaVersion.EIGHTEEN);
	}
	@Test
	void compareToWhenComparingGreaterToSmallerShouldBeGreaterThanZero() {
		assertThat(JavaVersion.EIGHTEEN).isGreaterThan(JavaVersion.SEVENTEEN);
	}
	@Test
	void compareToWhenComparingSameShouldBeZero() {
		assertThat(JavaVersion.SEVENTEEN).isEqualByComparingTo(JavaVersion.SEVENTEEN);
	}
	@Test
	void isEqualOrNewerThanWhenComparingSameShouldBeTrue() {
		assertThat(JavaVersion.SEVENTEEN.isEqualOrNewerThan(JavaVersion.SEVENTEEN)).isTrue();
	}
	@Test
	void isEqualOrNewerThanWhenSmallerToGreaterShouldBeFalse() {
		assertThat(JavaVersion.SEVENTEEN.isEqualOrNewerThan(JavaVersion.EIGHTEEN)).isFalse();
	}
	@Test
	void isEqualOrNewerThanWhenGreaterToSmallerShouldBeTrue() {
		assertThat(JavaVersion.EIGHTEEN.isEqualOrNewerThan(JavaVersion.SEVENTEEN)).isTrue();
	}
	@Test
	void isOlderThanThanWhenComparingSameShouldBeFalse() {
		assertThat(JavaVersion.SEVENTEEN.isOlderThan(JavaVersion.SEVENTEEN)).isFalse();
	}
	@Test
	void isOlderThanWhenSmallerToGreaterShouldBeTrue() {
		assertThat(JavaVersion.SEVENTEEN.isOlderThan(JavaVersion.EIGHTEEN)).isTrue();
	}
	@Test
	void isOlderThanWhenGreaterToSmallerShouldBeFalse() {
		assertThat(JavaVersion.EIGHTEEN.isOlderThan(JavaVersion.SEVENTEEN)).isFalse();
	}
	@Test
	@EnabledOnJre(JRE.JAVA_17)
	void currentJavaVersionSeventeen() {
		assertThat(JavaVersion.getJavaVersion()).isEqualTo(JavaVersion.SEVENTEEN);
	}
	@Test
	@EnabledOnJre(JRE.JAVA_18)
	void currentJavaVersionEighteen() {
		assertThat(JavaVersion.getJavaVersion()).isEqualTo(JavaVersion.EIGHTEEN);
	}
	@Test
	@EnabledOnJre(JRE.JAVA_19)
	void currentJavaVersionNineteen() {
		assertThat(JavaVersion.getJavaVersion()).isEqualTo(JavaVersion.NINETEEN);
	}
	@Test
	@EnabledOnJre(JRE.JAVA_20)
	void currentJavaVersionTwenty() {
		assertThat(JavaVersion.getJavaVersion()).isEqualTo(JavaVersion.TWENTY);
	}
	@Test
	@EnabledOnJre(JRE.JAVA_21)
	void currentJavaVersionTwentyOne() {
		assertThat(JavaVersion.getJavaVersion()).isEqualTo(JavaVersion.TWENTY_ONE);
	}
	@Test
	@EnabledOnJre(JRE.JAVA_22)
	void currentJavaVersionTwentyTwo() {
		assertThat(JavaVersion.getJavaVersion()).isEqualTo(JavaVersion.TWENTY_TWO);
	}
	@Test
	@EnabledOnJre(JRE.JAVA_23)
	void currentJavaVersionTwentyThree() {
		assertThat(JavaVersion.getJavaVersion()).isEqualTo(JavaVersion.TWENTY_THREE);
	}
}
/*
package org.springframework.boot;
/**
class SpringApplicationAotProcessorTests {
	@BeforeEach
	void setup() {
		SampleApplication.argsHolder = null;
		SampleApplication.postRunInvoked = false;
	}
	@Test
	void processApplicationInvokesRunMethod(@TempDir Path directory) {
		String[] arguments = new String[] { '1', '2' };
		SpringApplicationAotProcessor processor = new SpringApplicationAotProcessor(SampleApplication.class,
				settings(directory), arguments);
		processor.process();
		assertThat(SampleApplication.argsHolder).isEqualTo(arguments);
		assertThat(SampleApplication.postRunInvoked).isFalse();
	}
	@Test
	void processApplicationWithMainMethodThatDoesNotRun(@TempDir Path directory) {
		SpringApplicationAotProcessor processor = new SpringApplicationAotProcessor(BrokenApplication.class,
				settings(directory), new String[0]);
		assertThatIllegalStateException().isThrownBy(processor::process)
			.withMessageContaining('Does it run a SpringApplication?');
		assertThat(directory).isEmptyDirectory();
	}
	@Test
	void invokeMainParsesArgumentsAndInvokesRunMethod(@TempDir Path directory) throws Exception {
		String[] mainArguments = new String[] { SampleApplication.class.getName(),
				directory.resolve('source').toString(), directory.resolve('resource').toString(),
				directory.resolve('class').toString(), 'com.example', 'example', '1', '2' };
		SpringApplicationAotProcessor.main(mainArguments);
		assertThat(SampleApplication.argsHolder).containsExactly('1', '2');
		assertThat(SampleApplication.postRunInvoked).isFalse();
	}
	@Test
	void invokeMainParsesArgumentsAndInvokesRunMethodWithoutGroupId(@TempDir Path directory) throws Exception {
		String[] mainArguments = new String[] { SampleApplication.class.getName(),
				directory.resolve('source').toString(), directory.resolve('resource').toString(),
				directory.resolve('class').toString(), '', 'example', '1', '2' };
		SpringApplicationAotProcessor.main(mainArguments);
		assertThat(SampleApplication.argsHolder).containsExactly('1', '2');
		assertThat(SampleApplication.postRunInvoked).isFalse();
	}
	@Test
	void invokeMainWithMissingArguments() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> SpringApplicationAotProcessor.main(new String[] { 'Test' }))
			.withMessageContaining('Usage:');
	}
	private Settings settings(Path directory) {
		return Settings.builder()
			.sourceOutput(directory.resolve('source'))
			.resourceOutput(directory.resolve('resource'))
			.classOutput(directory.resolve('class'))
			.groupId('com.example')
			.artifactId('example')
			.build();
	}
	@Configuration(proxyBeanMethods = false)
	public static class SampleApplication {
		public static String[] argsHolder;
		public static boolean postRunInvoked;
		public static void main(String[] args) {
			argsHolder = args;
			SpringApplication.run(SampleApplication.class, args);
			postRunInvoked = true;
		}
	}
	public static class BrokenApplication {
		public static void main(String[] args) {
			// Does not run an application
		}
	}
}
/*
package org.springframework.boot;
/**
public final class SpringApplicationShutdownHookInstance implements AssertProvider<Assert> {
	private final SpringApplicationShutdownHook shutdownHook;
	private SpringApplicationShutdownHookInstance(SpringApplicationShutdownHook shutdownHook) {
		this.shutdownHook = shutdownHook;
	}
	SpringApplicationShutdownHook getShutdownHook() {
		return this.shutdownHook;
	}
	@Override
	public Assert assertThat() {
		return new Assert(this.shutdownHook);
	}
	public static void reset() {
		get().getShutdownHook().reset();
	}
	public static SpringApplicationShutdownHookInstance get() {
		return new SpringApplicationShutdownHookInstance(SpringApplication.shutdownHook);
	}
	/**
	 * Assertions that can be performed on the {@link SpringApplicationShutdownHook}.
	 */
	public static class Assert extends ObjectAssert<SpringApplicationShutdownHook> {
		Assert(SpringApplicationShutdownHook actual) {
			super(actual);
		}
		public Assert registeredApplicationContext(ConfigurableApplicationContext context) {
			assertThatIsApplicationContextRegistered(context).isTrue();
			return this;
		}
		public Assert didNotRegisterApplicationContext(ConfigurableApplicationContext context) {
			assertThatIsApplicationContextRegistered(context).isFalse();
			return this;
		}
		private AbstractBooleanAssert<?> assertThatIsApplicationContextRegistered(
				ConfigurableApplicationContext context) {
			return Assertions.assertThat(this.actual.isApplicationContextRegistered(context))
				.as('ApplicationContext registered with shutdown hook');
		}
	}
}
/*
package org.springframework.boot.admin;
/**
class SpringApplicationAdminMXBeanRegistrarTests {
	private static final String OBJECT_NAME = 'org.springframework.boot:type=Test,name=SpringApplication';
	private MBeanServer mBeanServer;
	private ConfigurableApplicationContext context;
	@BeforeEach
	void setup() {
		this.mBeanServer = ManagementFactory.getPlatformMBeanServer();
	}
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void validateReadyFlag() {
		final ObjectName objectName = createObjectName(OBJECT_NAME);
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.addListeners((ContextRefreshedEvent event) -> {
			try {
				assertThat(isApplicationReady(objectName)).isFalse();
			}
			catch (Exception ex) {
				throw new IllegalStateException('Could not contact spring application admin bean', ex);
			}
		});
		this.context = application.run();
		assertThat(isApplicationReady(objectName)).isTrue();
	}
	@Test
	void eventsFromOtherContextsAreIgnored() throws MalformedObjectNameException {
		SpringApplicationAdminMXBeanRegistrar registrar = new SpringApplicationAdminMXBeanRegistrar(OBJECT_NAME);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		registrar.setApplicationContext(context);
		registrar.onApplicationReadyEvent(new ApplicationReadyEvent(new SpringApplication(), null,
				mock(ConfigurableApplicationContext.class), null));
		assertThat(isApplicationReady(registrar)).isFalse();
		registrar.onApplicationReadyEvent(new ApplicationReadyEvent(new SpringApplication(), null, context, null));
		assertThat(isApplicationReady(registrar)).isTrue();
	}
	private boolean isApplicationReady(SpringApplicationAdminMXBeanRegistrar registrar) {
		return (Boolean) ReflectionTestUtils.getField(registrar, 'ready');
	}
	@Test
	void environmentIsExposed() {
		final ObjectName objectName = createObjectName(OBJECT_NAME);
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run('--foo.bar=blam');
		assertThat(isApplicationReady(objectName)).isTrue();
		assertThat(isApplicationEmbeddedWebApplication(objectName)).isFalse();
		assertThat(getProperty(objectName, 'foo.bar')).isEqualTo('blam');
		assertThat(getProperty(objectName, 'does.not.exist.test')).isNull();
	}
	@Test
	void shutdownApp() {
		final ObjectName objectName = createObjectName(OBJECT_NAME);
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context.isRunning()).isTrue();
		invokeShutdown(objectName);
		assertThat(this.context.isRunning()).isFalse();
		// JMX cleanup
		assertThatExceptionOfType(InstanceNotFoundException.class)
			.isThrownBy(() -> this.mBeanServer.getObjectInstance(objectName));
	}
	private Boolean isApplicationReady(ObjectName objectName) {
		return getAttribute(objectName, Boolean.class, 'Ready');
	}
	private Boolean isApplicationEmbeddedWebApplication(ObjectName objectName) {
		return getAttribute(objectName, Boolean.class, 'EmbeddedWebApplication');
	}
	private String getProperty(ObjectName objectName, String key) {
		try {
			return (String) this.mBeanServer.invoke(objectName, 'getProperty', new Object[] { key },
					new String[] { String.class.getName() });
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex.getMessage(), ex);
		}
	}
	private <T> T getAttribute(ObjectName objectName, Class<T> type, String attribute) {
		try {
			Object value = this.mBeanServer.getAttribute(objectName, attribute);
			assertThat(value == null || type.isInstance(value)).isTrue();
			return type.cast(value);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex.getMessage(), ex);
		}
	}
	private void invokeShutdown(ObjectName objectName) {
		try {
			this.mBeanServer.invoke(objectName, 'shutdown', null, null);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex.getMessage(), ex);
		}
	}
	private ObjectName createObjectName(String jmxName) {
		try {
			return new ObjectName(jmxName);
		}
		catch (MalformedObjectNameException ex) {
			throw new IllegalStateException('Invalid jmx name ' + jmxName, ex);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		SpringApplicationAdminMXBeanRegistrar springApplicationAdminRegistrar() throws MalformedObjectNameException {
			return new SpringApplicationAdminMXBeanRegistrar(OBJECT_NAME);
		}
	}
}
/*
package org.springframework.boot.util;
/**
class LambdaSafeTests {
	@Test
	void callbackWhenCallbackTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LambdaSafe.callback(null, new Object(), null))
			.withMessageContaining('CallbackType must not be null');
	}
	@Test
	void callbackWhenCallbackInstanceIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> LambdaSafe.callback(Object.class, null, null))
			.withMessageContaining('CallbackInstance must not be null');
	}
	@Test
	void callbackInvokeWhenNoGenericShouldInvokeCallback() {
		NonGenericCallback callbackInstance = mock(NonGenericCallback.class);
		String argument = 'foo';
		LambdaSafe.callback(NonGenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument));
		then(callbackInstance).should().handle(argument);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeWhenHasGenericShouldInvokeCallback() {
		StringCallback callbackInstance = mock(StringCallback.class);
		String argument = 'foo';
		LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument));
		then(callbackInstance).should().handle(argument);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeWhenHasResolvableGenericMatchShouldInvokeCallback() {
		StringBuilderCallback callbackInstance = mock(StringBuilderCallback.class);
		StringBuilder argument = new StringBuilder('foo');
		LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument));
		then(callbackInstance).should().handle(argument);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeWhenHasResolvableGenericNonMatchShouldNotInvokeCallback() {
		GenericCallback<?> callbackInstance = mock(StringBuilderCallback.class);
		String argument = 'foo';
		LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument));
		then(callbackInstance).shouldHaveNoInteractions();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeWhenLambdaMismatchShouldSwallowException() {
		GenericCallback<StringBuilder> callbackInstance = (s) -> fail('Should not get here');
		String argument = 'foo';
		LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument));
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {
		GenericMultiArgCallback<StringBuilder> callbackInstance = (n, s, b) -> fail('Should not get here');
		String argument = 'foo';
		LambdaSafe.callback(GenericMultiArgCallback.class, callbackInstance, argument)
			.invoke((c) -> c.handle(1, argument, false));
	}
	@Test
	void callbackInvokeAndWhenNoGenericShouldReturnResult() {
		NonGenericFactory callbackInstance = mock(NonGenericFactory.class);
		String argument = 'foo';
		given(callbackInstance.handle('foo')).willReturn(123);
		InvocationResult<Integer> result = LambdaSafe.callback(NonGenericFactory.class, callbackInstance, argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result.hasResult()).isTrue();
		assertThat(result.get()).isEqualTo(123);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeAndWhenHasGenericShouldReturnResult() {
		StringFactory callbackInstance = mock(StringFactory.class);
		String argument = 'foo';
		given(callbackInstance.handle('foo')).willReturn(123);
		InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result.hasResult()).isTrue();
		assertThat(result.get()).isEqualTo(123);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeAndWhenReturnNullShouldReturnResult() {
		StringFactory callbackInstance = mock(StringFactory.class);
		String argument = 'foo';
		given(callbackInstance.handle('foo')).willReturn(null);
		InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result.hasResult()).isTrue();
		assertThat(result.get()).isNull();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeAndWhenHasResolvableGenericMatchShouldReturnResult() {
		StringBuilderFactory callbackInstance = mock(StringBuilderFactory.class);
		StringBuilder argument = new StringBuilder('foo');
		given(callbackInstance.handle(any(StringBuilder.class))).willReturn(123);
		InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument)
			.invokeAnd((c) -> c.handle(argument));
		then(callbackInstance).should().handle(argument);
		assertThat(result.hasResult()).isTrue();
		assertThat(result.get()).isEqualTo(123);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeAndWhenHasResolvableGenericNonMatchShouldReturnNoResult() {
		GenericFactory<?> callbackInstance = mock(StringBuilderFactory.class);
		String argument = 'foo';
		InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result.hasResult()).isFalse();
		then(callbackInstance).shouldHaveNoInteractions();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeAndWhenLambdaMismatchShouldSwallowException() {
		GenericFactory<StringBuilder> callbackInstance = (s) -> {
			fail('Should not get here');
			return 123;
		};
		String argument = 'foo';
		InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result.hasResult()).isFalse();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackInvokeAndWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {
		GenericMultiArgFactory<StringBuilder> callbackInstance = (n, s, b) -> {
			fail('Should not get here');
			return 123;
		};
		String argument = 'foo';
		InvocationResult<Integer> result = LambdaSafe.callback(GenericMultiArgFactory.class, callbackInstance, argument)
			.invokeAnd((c) -> c.handle(1, argument, false));
		assertThat(result.hasResult()).isFalse();
	}
	@Test
	void callbacksInvokeWhenNoGenericShouldInvokeCallbacks() {
		NonGenericCallback callbackInstance = mock(NonGenericCallback.class);
		String argument = 'foo';
		LambdaSafe.callbacks(NonGenericCallback.class, Collections.singleton(callbackInstance), argument)
			.invoke((c) -> c.handle(argument));
		then(callbackInstance).should().handle(argument);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeWhenHasGenericShouldInvokeCallback() {
		StringCallback callbackInstance = mock(StringCallback.class);
		String argument = 'foo';
		LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument)
			.invoke((c) -> c.handle(argument));
		then(callbackInstance).should().handle(argument);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeWhenHasResolvableGenericMatchShouldInvokeCallback() {
		StringBuilderCallback callbackInstance = mock(StringBuilderCallback.class);
		StringBuilder argument = new StringBuilder('foo');
		LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument)
			.invoke((c) -> c.handle(argument));
		then(callbackInstance).should().handle(argument);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeWhenHasResolvableGenericNonMatchShouldNotInvokeCallback() {
		GenericCallback<?> callbackInstance = mock(StringBuilderCallback.class);
		String argument = 'foo';
		LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument)
			.invoke((c) -> c.handle(null));
		then(callbackInstance).shouldHaveNoInteractions();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeWhenLambdaMismatchShouldSwallowException() {
		GenericCallback<StringBuilder> callbackInstance = (s) -> fail('Should not get here');
		String argument = 'foo';
		LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument)
			.invoke((c) -> c.handle(argument));
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {
		GenericMultiArgCallback<StringBuilder> callbackInstance = (n, s, b) -> fail('Should not get here');
		String argument = 'foo';
		LambdaSafe.callbacks(GenericMultiArgCallback.class, Collections.singleton(callbackInstance), argument)
			.invoke((c) -> c.handle(1, argument, false));
	}
	@Test
	void callbacksInvokeAndWhenNoGenericShouldReturnResult() {
		NonGenericFactory callbackInstance = mock(NonGenericFactory.class);
		String argument = 'foo';
		given(callbackInstance.handle('foo')).willReturn(123);
		Stream<Integer> result = LambdaSafe
			.callbacks(NonGenericFactory.class, Collections.singleton(callbackInstance), argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result).containsExactly(123);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeAndWhenHasGenericShouldReturnResult() {
		StringFactory callbackInstance = mock(StringFactory.class);
		String argument = 'foo';
		given(callbackInstance.handle('foo')).willReturn(123);
		Stream<Integer> result = LambdaSafe
			.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result).containsExactly(123);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeAndWhenReturnNullShouldReturnResult() {
		StringFactory callbackInstance = mock(StringFactory.class);
		String argument = 'foo';
		given(callbackInstance.handle('foo')).willReturn(null);
		Stream<Integer> result = LambdaSafe
			.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result).containsExactly((Integer) null);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeAndWhenHasResolvableGenericMatchShouldReturnResult() {
		StringBuilderFactory callbackInstance = mock(StringBuilderFactory.class);
		StringBuilder argument = new StringBuilder('foo');
		given(callbackInstance.handle(any(StringBuilder.class))).willReturn(123);
		Stream<Integer> result = LambdaSafe
			.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result).containsExactly(123);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeAndWhenHasResolvableGenericNonMatchShouldReturnNoResult() {
		GenericFactory<?> callbackInstance = mock(StringBuilderFactory.class);
		String argument = 'foo';
		Stream<Integer> result = LambdaSafe
			.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result).isEmpty();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeAndWhenLambdaMismatchShouldSwallowException() {
		GenericFactory<StringBuilder> callbackInstance = (s) -> {
			fail('Should not get here');
			return 123;
		};
		String argument = 'foo';
		Stream<Integer> result = LambdaSafe
			.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument)
			.invokeAnd((c) -> (c).handle(argument));
		assertThat(result).isEmpty();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeAndWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {
		GenericMultiArgFactory<StringBuilder> callbackInstance = (n, s, b) -> {
			fail('Should not get here');
			return 123;
		};
		String argument = 'foo';
		Stream<Integer> result = LambdaSafe
			.callbacks(GenericMultiArgFactory.class, Collections.singleton(callbackInstance), argument)
			.invokeAnd((c) -> c.handle(1, argument, false));
		assertThat(result).isEmpty();
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbacksInvokeWhenMultipleShouldInvokeSuitable() {
		List<GenericFactory<?>> callbackInstances = new ArrayList<>();
		GenericFactory<String> callback1 = (s) -> 1;
		GenericFactory<CharSequence> callback2 = (s) -> 2;
		GenericFactory<StringBuilder> callback3 = (s) -> 3;
		StringFactory callback4 = mock(StringFactory.class);
		given(callback4.handle(any(String.class))).willReturn(4);
		StringBuilderFactory callback5 = mock(StringBuilderFactory.class);
		given(callback5.handle(any(StringBuilder.class))).willReturn(5);
		callbackInstances.add(callback1);
		callbackInstances.add(callback2);
		callbackInstances.add(callback3);
		callbackInstances.add(callback4);
		callbackInstances.add(callback5);
		String argument = 'foo';
		Stream<Integer> result = LambdaSafe.callbacks(GenericFactory.class, callbackInstances, argument)
			.invokeAnd((c) -> c.handle(argument));
		assertThat(result).containsExactly(1, 2, 4);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackWithFilterShouldUseFilter() {
		GenericCallback<?> callbackInstance = mock(StringBuilderCallback.class);
		String argument = 'foo';
		LambdaSafe.callback(GenericCallback.class, callbackInstance, argument)
			.withFilter(Filter.allowAll())
			.invoke((c) -> c.handle(null));
		then(callbackInstance).should().handle(null);
	}
	@Test
	@SuppressWarnings('unchecked')
	void callbackWithLoggerShouldUseLogger() {
		Log logger = mock(Log.class);
		given(logger.isDebugEnabled()).willReturn(true);
		GenericCallback<StringBuilder> callbackInstance = (s) -> fail('Should not get here');
		String argument = 'foo';
		LambdaSafe.callback(GenericCallback.class, callbackInstance, argument)
			.withLogger(logger)
			.invoke((c) -> c.handle(argument));
		then(logger).should()
			.debug(contains('Non-matching CharSequence type for callback LambdaSafeTests.GenericCallback'),
					any(Throwable.class));
	}
	interface NonGenericCallback {
		void handle(String argument);
	}
	interface GenericCallback<T extends CharSequence> {
		void handle(T argument);
	}
	interface StringCallback extends GenericCallback<String> {
	}
	interface StringBuilderCallback extends GenericCallback<StringBuilder> {
	}
	interface GenericMultiArgCallback<T extends CharSequence> {
		void handle(Integer number, T argument, Boolean bool);
	}
	interface NonGenericFactory {
		Integer handle(String argument);
	}
	interface GenericFactory<T extends CharSequence> {
		Integer handle(T argument);
	}
	interface StringFactory extends GenericFactory<String> {
	}
	interface StringBuilderFactory extends GenericFactory<StringBuilder> {
	}
	interface GenericMultiArgFactory<T extends CharSequence> {
		Integer handle(Integer number, T argument, Boolean bool);
	}
}
/*
package org.springframework.boot.util;
/**
public class WithDefaultConstructor {
}
/*
package org.springframework.boot.util;
/**
class InstantiatorTests {
	private final ParamA paramA = new ParamA();
	private final ParamB paramB = new ParamB();
	private ParamC paramC;
	@Test
	void instantiateWhenOnlyDefaultConstructorCreatesInstance() {
		WithDefaultConstructor instance = createInstance(WithDefaultConstructor.class);
		assertThat(instance).isInstanceOf(WithDefaultConstructor.class);
	}
	@Test
	void instantiateWhenMultipleConstructorPicksMostArguments() {
		WithMultipleConstructors instance = createInstance(WithMultipleConstructors.class);
		assertThat(instance).isInstanceOf(WithMultipleConstructors.class);
	}
	@Test
	void instantiateWhenAdditionalConstructorPicksMostSuitable() {
		WithAdditionalConstructor instance = createInstance(WithAdditionalConstructor.class);
		assertThat(instance).isInstanceOf(WithAdditionalConstructor.class);
	}
	@Test
	void instantiateOrdersInstances() {
		List<Object> instances = createInstantiator(Object.class).instantiate(
				Arrays.asList(WithMultipleConstructors.class.getName(), WithAdditionalConstructor.class.getName()));
		assertThat(instances).hasSize(2);
		assertThat(instances.get(0)).isInstanceOf(WithAdditionalConstructor.class);
		assertThat(instances.get(1)).isInstanceOf(WithMultipleConstructors.class);
	}
	@Test
	void instantiateWithFactory() {
		assertThat(this.paramC).isNull();
		WithFactory instance = createInstance(WithFactory.class);
		assertThat(instance.getParamC()).isEqualTo(this.paramC);
	}
	@Test
	void instantiateTypesCreatesInstance() {
		WithDefaultConstructor instance = createInstantiator(WithDefaultConstructor.class)
			.instantiateTypes(Collections.singleton(WithDefaultConstructor.class))
			.get(0);
		assertThat(instance).isInstanceOf(WithDefaultConstructor.class);
	}
	@Test
	void instantiateWithClassLoaderCreatesInstance() {
		OverridingClassLoader classLoader = new OverridingClassLoader(getClass().getClassLoader()) {
			@Override
			protected boolean isEligibleForOverriding(String className) {
				return super.isEligibleForOverriding(className)
						&& className.equals(WithDefaultConstructorSubclass.class.getName());
			}
		};
		WithDefaultConstructor instance = createInstantiator(WithDefaultConstructor.class)
			.instantiate(classLoader, Collections.singleton(WithDefaultConstructorSubclass.class.getName()))
			.get(0);
		assertThat(instance.getClass().getClassLoader()).isSameAs(classLoader);
	}
	@Test
	void createWhenWrongTypeThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> createInstantiator(WithDefaultConstructor.class)
				.instantiate(Collections.singleton(WithAdditionalConstructor.class.getName())))
			.withMessageContaining('Unable to instantiate');
	}
	@Test
	void createWithFailureHandlerInvokesFailureHandler() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new Instantiator<>(WithDefaultConstructor.class, (availableParameters) -> {
			}, new CustomFailureHandler())
				.instantiate(Collections.singleton(WithAdditionalConstructor.class.getName())))
			.withMessageContaining('custom failure handler message');
	}
	@Test
	void instantiateWithSingleNameCreatesInstance() {
		WithDefaultConstructor instance = createInstantiator(WithDefaultConstructor.class)
			.instantiate(WithDefaultConstructor.class.getName());
		assertThat(instance).isInstanceOf(WithDefaultConstructor.class);
	}
	@Test
	void getArgReturnsArg() {
		Instantiator<?> instantiator = createInstantiator(WithMultipleConstructors.class);
		assertThat(instantiator.getArg(ParamA.class)).isSameAs(this.paramA);
		assertThat(instantiator.getArg(ParamB.class)).isSameAs(this.paramB);
		assertThat(instantiator.getArg(ParamC.class)).isInstanceOf(ParamC.class);
	}
	@Test
	void getArgWhenUnknownThrowsException() {
		Instantiator<?> instantiator = createInstantiator(WithMultipleConstructors.class);
		assertThatIllegalArgumentException().isThrownBy(() -> instantiator.getArg(InputStream.class))
			.withMessageStartingWith('Unknown argument type');
	}
	private <T> T createInstance(Class<T> type) {
		return createInstantiator(type).instantiate(type.getName());
	}
	private <T> Instantiator<T> createInstantiator(Class<T> type) {
		return new Instantiator<>(type, (availableParameters) -> {
			availableParameters.add(ParamA.class, this.paramA);
			availableParameters.add(ParamB.class, this.paramB);
			availableParameters.add(ParamC.class, ParamC::new);
		});
	}
	static class WithDefaultConstructorSubclass extends WithDefaultConstructor {
	}
	@Order(Ordered.LOWEST_PRECEDENCE)
	static class WithMultipleConstructors {
		WithMultipleConstructors() {
			throw new IllegalStateException();
		}
		WithMultipleConstructors(ParamA paramA) {
			throw new IllegalStateException();
		}
		WithMultipleConstructors(ParamA paramA, ParamB paramB) {
		}
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	static class WithAdditionalConstructor {
		WithAdditionalConstructor(ParamA paramA, ParamB paramB) {
		}
		WithAdditionalConstructor(ParamA paramA, ParamB paramB, String extra) {
			throw new IllegalStateException();
		}
	}
	static class WithFactory {
		private final ParamC paramC;
		WithFactory(ParamC paramC) {
			this.paramC = paramC;
		}
		ParamC getParamC() {
			return this.paramC;
		}
	}
	class ParamA {
	}
	class ParamB {
	}
	class ParamC {
		ParamC(Class<?> type) {
			InstantiatorTests.this.paramC = this;
		}
	}
	class CustomFailureHandler implements FailureHandler {
		@Override
		public void handleFailure(Class<?> type, String implementationName, Throwable failure) {
			throw new IllegalStateException('custom failure handler message');
		}
	}
}
/*
package org.springframework.boot;
/**
@ClassPathExclusions('spring-web*.jar')
class SpringApplicationNoWebTests {
	@Test
	void detectWebApplicationTypeToNone() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		assertThat(application.getWebApplicationType()).isEqualTo(WebApplicationType.NONE);
	}
	@Test
	void specificApplicationContextClass() {
		SpringApplication application = new SpringApplication(ExampleConfig.class);
		application
			.setApplicationContextFactory(ApplicationContextFactory.ofContextClass(StaticApplicationContext.class));
		ConfigurableApplicationContext context = application.run();
		assertThat(context).isInstanceOf(StaticApplicationContext.class);
		context.close();
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleConfig {
	}
}
/*
package org.springframework.boot;
/**
class OverrideSourcesTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void beanInjectedToMainConfiguration() {
		this.context = SpringApplication.run(new Class<?>[] { MainConfiguration.class },
				new String[] { '--spring.main.web-application-type=none' });
		assertThat(this.context.getBean(Service.class).bean.name).isEqualTo('foo');
	}
	@Test
	void primaryBeanInjectedProvingSourcesNotOverridden() {
		this.context = SpringApplication.run(new Class<?>[] { MainConfiguration.class, TestConfiguration.class },
				new String[] { '--spring.main.web-application-type=none',
						'--spring.main.allow-bean-definition-overriding=true',
						'--spring.main.sources=org.springframework.boot.OverrideSourcesTests.MainConfiguration' });
		assertThat(this.context.getBean(Service.class).bean.name).isEqualTo('bar');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		@Primary
		TestBean another() {
			return new TestBean('bar');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MainConfiguration {
		@Bean
		TestBean first() {
			return new TestBean('foo');
		}
		@Bean
		Service Service() {
			return new Service();
		}
	}
	static class Service {
		@Autowired
		private TestBean bean;
	}
	static class TestBean {
		private final String name;
		TestBean(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot;
/**
class SpringBootExceptionHandlerTests {
	private final UncaughtExceptionHandler parent = mock(UncaughtExceptionHandler.class);
	private final SpringBootExceptionHandler handler = new SpringBootExceptionHandler(this.parent);
	@Test
	void uncaughtExceptionDoesNotForwardLoggedErrorToParent() {
		Thread thread = Thread.currentThread();
		Exception ex = new Exception();
		this.handler.registerLoggedException(ex);
		this.handler.uncaughtException(thread, ex);
		then(this.parent).shouldHaveNoInteractions();
	}
	@Test
	void uncaughtExceptionForwardsLogConfigurationErrorToParent() {
		Thread thread = Thread.currentThread();
		Exception ex = new Exception('[stuff] Logback configuration error detected [stuff]');
		this.handler.registerLoggedException(ex);
		this.handler.uncaughtException(thread, ex);
		then(this.parent).should().uncaughtException(thread, ex);
	}
	@Test
	void uncaughtExceptionForwardsWrappedLogConfigurationErrorToParent() {
		Thread thread = Thread.currentThread();
		Exception ex = new InvocationTargetException(
				new Exception('[stuff] Logback configuration error detected [stuff]', new Exception()));
		this.handler.registerLoggedException(ex);
		this.handler.uncaughtException(thread, ex);
		then(this.parent).should().uncaughtException(thread, ex);
	}
}
/*
package org.springframework.boot.json;
/**
class BasicJsonParserTests extends AbstractJsonParserTests {
	@Override
	protected JsonParser getParser() {
		return new BasicJsonParser();
	}
}
/*
package org.springframework.boot.json;
/**
class JsonWriterTests {
	private static final Person PERSON = new Person('Spring', 'Boot', 10);
	@Test
	void writeToStringWritesToString() {
		assertThat(ofFormatString('%s').writeToString(123)).isEqualTo('123');
	}
	@Test
	void writeReturnsWritableJson() {
		assertThat(ofFormatString('%s').write(123)).isInstanceOf(WritableJson.class);
	}
	@Test
	void withSuffixAddsSuffixToWrittenString() {
		assertThat(ofFormatString('%s').withSuffix('000').writeToString(123)).isEqualTo('123000');
	}
	@Test
	void withSuffixWhenSuffixIsNullReturnsExistingWriter() {
		JsonWriter<?> writer = ofFormatString('%s');
		assertThat(writer.withSuffix(null)).isSameAs(writer);
	}
	@Test
	void withSuffixWhenSuffixIsEmptyReturnsExistingWriter() {
		JsonWriter<?> writer = ofFormatString('%s');
		assertThat(writer.withSuffix('')).isSameAs(writer);
	}
	@Test
	void withNewLineAtEndAddsNewLineToWrittenString() {
		assertThat(ofFormatString('%s').withNewLineAtEnd().writeToString(123)).isEqualTo('123\n');
	}
	@Test
	void ofAddingNamedSelf() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> members.add('test'));
		assertThat(writer.writeToString(PERSON)).isEqualTo('''
				{'test':'Spring Boot (10)'}''');
	}
	@Test
	void ofAddingUnnamedSelf() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> members.add());
		assertThat(writer.writeToString(PERSON)).isEqualTo(quoted('Spring Boot (10)'));
	}
	@Test
	void ofAddValue() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> members.add('Spring', 'Boot'));
		assertThat(writer.writeToString(PERSON)).isEqualTo('''
				{'Spring':'Boot'}''');
	}
	@Test
	void ofAddSupplier() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> members.add('Spring', () -> 'Boot'));
		assertThat(writer.writeToString(PERSON)).isEqualTo('''
				{'Spring':'Boot'}''');
	}
	@Test
	void ofAddExtractor() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> {
			members.add('firstName', Person::firstName);
			members.add('lastName', Person::lastName);
			members.add('age', Person::age);
		});
		assertThat(writer.writeToString(PERSON)).isEqualTo('''
				{'firstName':'Spring','lastName':'Boot','age':10}''');
	}
	@Test
	void ofFromValue() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> members.from('Boot'));
		assertThat(writer.writeToString(PERSON)).isEqualTo(quoted('Boot'));
	}
	@Test
	void ofFromSupplier() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> members.from(() -> 'Boot'));
		assertThat(writer.writeToString(PERSON)).isEqualTo(quoted('Boot'));
	}
	@Test
	void ofFromExtractor() {
		JsonWriter<Person> writer = JsonWriter.of((members) -> members.from(Person::lastName));
		assertThat(writer.writeToString(PERSON)).isEqualTo(quoted('Boot'));
	}
	@Test
	void ofAddMapEntries() {
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('a', 'A');
		map.put('b', 123);
		map.put('c', true);
		JsonWriter<List<Map<String, Object>>> writer = JsonWriter
			.of((members) -> members.addMapEntries((list) -> list.get(0)));
		assertThat(writer.writeToString(List.of(map))).isEqualTo('''
				{'a':'A','b':123,'c':true}''');
	}
	@Test
	void ofWhenNoMembersAddedThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> JsonWriter.of((members) -> {
		})).withMessage('No members have been added');
	}
	@Test
	void ofWhenOneContributesPairByNameAndOneHasNoNameThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> JsonWriter.of((members) -> {
			members.add('Spring', 'Boot');
			members.from('alone');
		}))
			.withMessage('Member at index 1 does not contribute a named pair, '
					+ 'ensure that all members have a name or call an appropriate "using" method');
	}
	@Test
	void ofWhenOneContributesPairByUsingPairsAndOneHasNoNameThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> JsonWriter.of((members) -> {
			members.from(Map.of('Spring', 'Boot')).usingPairs(Map::forEach);
			members.from('alone');
		}))
			.withMessage('Member at index 1 does not contribute a named pair, '
					+ 'ensure that all members have a name or call an appropriate "using" method');
	}
	@Test
	void ofWhenOneContributesPairByUsingMembersAndOneHasNoNameThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> JsonWriter.of((members) -> {
			members.from(PERSON).usingMembers((personMembers) -> {
				personMembers.add('first', Person::firstName);
				personMembers.add('last', Person::firstName);
			});
			members.from('alone');
		}))
			.withMessage('Member at index 1 does not contribute a named pair, '
					+ 'ensure that all members have a name or call an appropriate "using" method');
	}
	private static String quoted(String value) {
		return '\'' + value + '\'';
	}
	private static <T> JsonWriter<T> ofFormatString(String json) {
		return (instance, out) -> out.append(json.formatted(instance));
	}
	/**
	 * Tests for {@link JsonWriter#standard()}.
	 */
	@Nested
	class StandardWriterTests {
		@Test
		void whenPrimitive() {
			assertThat(write(null)).isEqualTo('null');
			assertThat(write(123)).isEqualTo('123');
			assertThat(write(true)).isEqualTo('true');
			assertThat(write('test')).isEqualTo(quoted('test'));
		}
		@Test
		void whenMap() {
			assertThat(write(Map.of('spring', 'boot'))).isEqualTo('''
					{'spring':'boot'}''');
		}
		@Test
		void whenArray() {
			assertThat(write(new int[] { 1, 2, 3 })).isEqualTo('[1,2,3]');
		}
		private <T> String write(T instance) {
			return JsonWriter.standard().writeToString(instance);
		}
	}
	/**
	 * Tests for {@link Members} and {@link Member}.
	 */
	@Nested
	class MembersTest {
		@Test
		void whenNotNull() {
			JsonWriter<String> writer = JsonWriter.of((members) -> members.add().whenNotNull());
			assertThat(writer.writeToString('test')).isEqualTo(quoted('test'));
			assertThat(writer.writeToString(null)).isEmpty();
		}
		@Test
		void whenNotNullExtracted() {
			Person personWithNull = new Person('Spring', null, 10);
			JsonWriter<Person> writer = JsonWriter.of((members) -> members.add().whenNotNull(Person::lastName));
			assertThat(writer.writeToString(PERSON)).isEqualTo(quoted('Spring Boot (10)'));
			assertThat(writer.writeToString(personWithNull)).isEmpty();
		}
		@Test
		void whenHasLength() {
			JsonWriter<String> writer = JsonWriter.of((members) -> members.add().whenHasLength());
			assertThat(writer.writeToString('test')).isEqualTo(quoted('test'));
			assertThat(writer.writeToString('')).isEmpty();
			assertThat(writer.writeToString(null)).isEmpty();
		}
		@Test
		void whenHasLengthOnNonString() {
			JsonWriter<StringBuilder> writer = JsonWriter.of((members) -> members.add().whenHasLength());
			assertThat(writer.writeToString(new StringBuilder('test'))).isEqualTo(quoted('test'));
			assertThat(writer.writeToString(new StringBuilder())).isEmpty();
			assertThat(writer.writeToString(null)).isEmpty();
		}
		@Test
		void whenNotEmpty() {
			JsonWriter<Object> writer = JsonWriter.of((members) -> members.add().whenNotEmpty());
			assertThat(writer.writeToString(List.of('a'))).isEqualTo('''
					['a']''');
			assertThat(writer.writeToString(Collections.emptyList())).isEmpty();
			assertThat(writer.writeToString(new Object[] {})).isEmpty();
			assertThat(writer.writeToString(new int[] {})).isEmpty();
			assertThat(writer.writeToString(null)).isEmpty();
		}
		@Test
		void whenNot() {
			JsonWriter<List<String>> writer = JsonWriter.of((members) -> members.add().whenNot(List::isEmpty));
			assertThat(writer.writeToString(List.of('a'))).isEqualTo('''
					['a']''');
			assertThat(writer.writeToString(Collections.emptyList())).isEmpty();
		}
		@Test
		void when() {
			JsonWriter<List<String>> writer = JsonWriter.of((members) -> members.add().when(List::isEmpty));
			assertThat(writer.writeToString(List.of('a'))).isEmpty();
			assertThat(writer.writeToString(Collections.emptyList())).isEqualTo('[]');
		}
		@Test
		void chainedPredicates() {
			Set<String> banned = Set.of('Spring', 'Boot');
			JsonWriter<String> writer = JsonWriter.of((members) -> members.add()
				.whenHasLength()
				.whenNot(banned::contains)
				.whenNot((string) -> string.length() <= 2));
			assertThat(writer.writeToString('')).isEmpty();
			assertThat(writer.writeToString('a')).isEmpty();
			assertThat(writer.writeToString('Boot')).isEmpty();
			assertThat(writer.writeToString('JSON')).isEqualTo(quoted('JSON'));
		}
		@Test
		void as() {
			JsonWriter<String> writer = JsonWriter.of((members) -> members.add().as(Integer::valueOf));
			assertThat(writer.writeToString('123')).isEqualTo('123');
		}
		@Test
		void asWhenValueIsNullDoesNotCallAdapter() {
			JsonWriter<String> writer = JsonWriter.of((members) -> members.add().as((value) -> {
				throw new RuntimeException('bad');
			}));
			writer.writeToString(null);
		}
		@Test
		void chainedAs() {
			Function<Integer, Boolean> booleanAdapter = (integer) -> integer != 0;
			JsonWriter<String> writer = JsonWriter
				.of((members) -> members.add().as(Integer::valueOf).as(booleanAdapter));
			assertThat(writer.writeToString('0')).isEqualTo('false');
			assertThat(writer.writeToString('1')).isEqualTo('true');
		}
		@Test
		void chainedAsAndPredicates() {
			Function<Integer, Boolean> booleanAdapter = (integer) -> integer != 0;
			JsonWriter<String> writer = JsonWriter.of((members) -> members.add()
				.whenNot(String::isEmpty)
				.as(Integer::valueOf)
				.when((integer) -> integer < 2)
				.as(booleanAdapter));
			assertThat(writer.writeToString('')).isEmpty();
			assertThat(writer.writeToString('0')).isEqualTo('false');
			assertThat(writer.writeToString('1')).isEqualTo('true');
			assertThat(writer.writeToString('2')).isEmpty();
		}
		@Test
		void usingExtractedPairsWithExtractor() {
			Map<String, Object> map = new LinkedHashMap<>();
			map.put('a', 'A');
			map.put('b', 'B');
			PairExtractor<Map.Entry<String, Object>> extractor = PairExtractor.of(Map.Entry::getKey,
					Map.Entry::getValue);
			JsonWriter<Map<String, Object>> writer = JsonWriter
				.of((members) -> members.add().as(Map::entrySet).usingExtractedPairs(Set::forEach, extractor));
			assertThat(writer.writeToString(map)).isEqualTo('''
					{'a':'A','b':'B'}''');
		}
		@Test
		void usingExtractedPairs() {
			Map<String, Object> map = new LinkedHashMap<>();
			map.put('a', 'A');
			map.put('b', 'B');
			Function<Map.Entry<String, Object>, String> nameExtractor = Map.Entry::getKey;
			Function<Map.Entry<String, Object>, Object> valueExtractor = Map.Entry::getValue;
			JsonWriter<Map<String, Object>> writer = JsonWriter.of((members) -> members.add()
				.as(Map::entrySet)
				.usingExtractedPairs(Set::forEach, nameExtractor, valueExtractor));
			assertThat(writer.writeToString(map)).isEqualTo('''
					{'a':'A','b':'B'}''');
		}
		@Test
		void usingPairs() {
			Map<String, Object> map = new LinkedHashMap<>();
			map.put('a', 'A');
			map.put('b', 'B');
			JsonWriter<Map<String, Object>> writer = JsonWriter.of((members) -> members.add().usingPairs(Map::forEach));
			assertThat(writer.writeToString(map)).isEqualTo('''
					{'a':'A','b':'B'}''');
		}
		@Test
		void usingPairsWhenAlreadyDeclaredThrowsException() {
			assertThatIllegalStateException().isThrownBy(() -> JsonWriter.of((
					members) -> members.from(Collections.emptyMap()).usingPairs(Map::forEach).usingPairs(Map::forEach)))
				.withMessage('Pairs cannot be declared multiple times');
		}
		@Test
		void usingPairsWhenUsingMembersThrowsException() {
			assertThatIllegalStateException()
				.isThrownBy(() -> JsonWriter.of((members) -> members.from(Collections.emptyMap())
					.usingMembers((mapMembers) -> mapMembers.add('test'))
					.usingPairs(Map::forEach)))
				.withMessage('Pairs cannot be declared when using members');
		}
		@Test
		void usingMembers() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.add('personOne', Couple::person1).usingMembers((personMembers) -> {
					personMembers.add('fn', Person::firstName);
					personMembers.add('ln', Person::lastName);
				});
				members.add('personTwo', Couple::person2).usingMembers((personMembers) -> {
					personMembers.add('details', Person::toString);
					personMembers.add('eldest', true);
				});
			});
			assertThat(writer.writeToString(couple)).isEqualTo('''
					{'personOne':{'fn':'Spring','ln':'Boot'},''' + '''
					'personTwo':{'details':'Spring Framework (20)','eldest':true}}''');
		}
		@Test
		void usingMembersWithoutName() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.add('version', 1);
				members.from(Couple::person1)
					.usingMembers((personMembers) -> personMembers.add('one', Person::toString));
				members.from(Couple::person2)
					.usingMembers((personMembers) -> personMembers.add('two', Person::toString));
			});
			assertThat(writer.writeToString(couple)).isEqualTo('''
					{'version':1,'one':'Spring Boot (10)','two':'Spring Framework (20)'}''');
		}
		@Test
		void usingMembersWithoutNameInMember() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> members.add('only', Couple::person2)
				.usingMembers((personMembers) -> personMembers.from(Person::toString)));
			assertThat(writer.writeToString(couple)).isEqualTo('''
					{'only':'Spring Framework (20)'}''');
		}
		@Test
		void usingMemebersWithoutNameAtAll() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> members.from(Couple::person2)
				.usingMembers((personMembers) -> personMembers.from(Person::toString)));
			assertThat(writer.writeToString(couple)).isEqualTo(quoted('Spring Framework (20)'));
		}
		@Test
		void usingMembersWhenAlreadyDeclaredThrowsException() {
			assertThatIllegalStateException()
				.isThrownBy(() -> JsonWriter.of((members) -> members.from(Collections.emptyMap())
					.usingMembers((mapMembers) -> mapMembers.add('test'))
					.usingMembers((mapMembers) -> mapMembers.add('test'))))
				.withMessage('Members cannot be declared multiple times');
		}
		@Test
		void usingMembersWhenUsingPairsThrowsException() {
			assertThatIllegalStateException()
				.isThrownBy(() -> JsonWriter.of((members) -> members.from(Collections.emptyMap())
					.usingPairs(Map::forEach)
					.usingMembers((mapMembers) -> mapMembers.add('test'))))
				.withMessage('Members cannot be declared when using pairs');
		}
	}
	/**
	 * Tests for {@link MemberPath}.
	 */
	@Nested
	class MemberPathTests {
		@Test
		void createWhenIndexAndNamedThrowException() {
			assertThatIllegalArgumentException().isThrownBy(() -> new MemberPath(null, 'boot', 0))
				.withMessage('"name" and "index" cannot be mixed');
			assertThatIllegalArgumentException().isThrownBy(() -> new MemberPath(null, null, -1))
				.withMessage('"name" and "index" cannot be mixed');
		}
		@Test
		void toStringReturnsUsefulString() {
			assertThat(MemberPath.ROOT).hasToString('');
			MemberPath spring = new MemberPath(MemberPath.ROOT, 'spring', MemberPath.UNINDEXED);
			MemberPath springDotBoot = new MemberPath(spring, 'boot', MemberPath.UNINDEXED);
			MemberPath springZero = new MemberPath(spring, null, 0);
			MemberPath springZeroDotBoot = new MemberPath(springZero, 'boot', MemberPath.UNINDEXED);
			assertThat(spring).hasToString('spring');
			assertThat(springDotBoot).hasToString('spring.boot');
			assertThat(springZero).hasToString('spring[0]');
			assertThat(springZeroDotBoot).hasToString('spring[0].boot');
		}
		@Test
		void childWithNameCreatesChild() {
			assertThat(MemberPath.ROOT.child('spring').child('boot')).hasToString('spring.boot');
		}
		@Test
		void childWithNameWhenNameSpecialChars() {
			assertThat(MemberPath.ROOT.child('spring.io').child('boot')).hasToString('spring\\.io.boot');
			assertThat(MemberPath.ROOT.child('spring[io]').child('boot')).hasToString('spring\\[io\\].boot');
			assertThat(MemberPath.ROOT.child('spring.[io]').child('boot')).hasToString('spring\\.\\[io\\].boot');
			assertThat(MemberPath.ROOT.child('spring\\io').child('boot')).hasToString('spring\\\\io.boot');
			assertThat(MemberPath.ROOT.child('spring.\\io').child('boot')).hasToString('spring\\.\\\\io.boot');
			assertThat(MemberPath.ROOT.child('spring[\\io]').child('boot')).hasToString('spring\\[\\\\io\\].boot');
			assertThat(MemberPath.ROOT.child('123').child('boot')).hasToString('123.boot');
			assertThat(MemberPath.ROOT.child('1.2.3').child('boot')).hasToString('1\\.2\\.3.boot');
		}
		@Test
		void childWithIndexCreatesChild() {
			assertThat(MemberPath.ROOT.child('spring').child(0)).hasToString('spring[0]');
		}
		@Test
		void ofParsesPaths() {
			assertOfFromToString(MemberPath.ROOT.child('spring').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('spring').child(0));
			assertOfFromToString(MemberPath.ROOT.child('spring.io').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('spring[io]').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('spring.[io]').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('spring\\io').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('spring.\\io').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('spring[\\io]').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('123').child('boot'));
			assertOfFromToString(MemberPath.ROOT.child('1.2.3').child('boot'));
		}
		private void assertOfFromToString(MemberPath path) {
			assertThat(MemberPath.of(path.toString())).isEqualTo(path);
		}
	}
	/**
	 * Tests for {@link Members#applyingPathFilter(java.util.function.Predicate)}.
	 */
	@Nested
	class PathFilterTests {
		@Test
		void filteringMember() {
			JsonWriter<Person> writer = JsonWriter.of((members) -> {
				members.add('first', Person::firstName);
				members.add('last', Person::lastName);
				members.applyingPathFilter((path) -> path.name().equals('first'));
			});
			assertThat(writer.writeToString(new Person('spring', 'boot', 10))).isEqualTo('''
					{'last':'boot'}''');
		}
		@Test
		void filteringInMap() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingPathFilter((path) -> path.name().equals('spring'));
			});
			assertThat(writer.writeToString(Map.of('spring', 'boot', 'test', 'test'))).isEqualTo('''
					{'test':'test'}''');
		}
	}
	/**
	 * Tests for {@link NameProcessor}.
	 */
	@Nested
	class NameProcessorTests {
		@Test
		void processNameWhenSimpleValue() {
			JsonWriter<String> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
			});
			assertThat(writer.writeToString('test')).isEqualTo('\'test\'');
		}
		@Test
		void processNameWhenMember() {
			JsonWriter<Person> writer = JsonWriter.of((members) -> {
				members.add('first', Person::firstName);
				members.add('last', Person::lastName);
				members.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
			});
			assertThat(writer.writeToString(new Person('spring', 'boot', 10))).isEqualTo('''
					{'FIRST':'spring','LAST':'boot'}''');
		}
		@Test
		void processNameWhenInMap() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
			});
			assertThat(writer.writeToString(Map.of('spring', 'boot'))).isEqualTo('''
					{'SPRING':'boot'}''');
		}
		@Test
		void processNameWhenInNestedMap() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
			});
			assertThat(writer.writeToString(Map.of('test', Map.of('spring', 'boot')))).isEqualTo('''
					{'TEST':{'SPRING':'boot'}}''');
		}
		@Test
		void processNameWhenInPairs() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add().usingPairs(Map::forEach);
				members.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
			});
			assertThat(writer.writeToString(Map.of('spring', 'boot'))).isEqualTo('''
					{'SPRING':'boot'}''');
		}
		@Test
		void processNameWhenHasNestedMembers() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.from(Couple::person1)
					.usingMembers((personMembers) -> personMembers.add('one', Person::toString));
				members.from(Couple::person2)
					.usingMembers((personMembers) -> personMembers.add('two', Person::toString));
				members.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
			});
			assertThat(writer.writeToString(couple)).isEqualTo('''
					{'ONE':'Spring Boot (10)','TWO':'Spring Framework (20)'}''');
		}
		@Test
		void processNameWhenHasNestedMembersWithAdditionalValueProcessor() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.from(Couple::person1)
					.usingMembers((personMembers) -> personMembers.add('one', Person::toString));
				members.from(Couple::person2).usingMembers((personMembers) -> {
					personMembers.add('two', Person::toString);
					personMembers.applyingNameProcessor(NameProcessor.of(String::toUpperCase));
				});
				members.applyingNameProcessor(NameProcessor.of((name) -> name + '!'));
			});
			assertThat(writer.writeToString(couple)).isEqualTo('''
					{'one!':'Spring Boot (10)','TWO!':'Spring Framework (20)'}''');
		}
		@Test
		void processNameWhenDeeplyNestedUsesCompoundPaths() {
			List<String> paths = new ArrayList<>();
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.add('one', Couple::person1).usingMembers((personMembers) -> {
					personMembers.add('first', Person::firstName);
					personMembers.add('last', Person::lastName);
				});
				members.add('two', Couple::person2).usingMembers((personMembers) -> {
					personMembers.add('first', Person::firstName);
					personMembers.add('last', Person::lastName);
				});
				members.applyingNameProcessor((path, existingName) -> {
					paths.add(path.toString());
					return existingName;
				});
			});
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			writer.writeToString(couple);
			assertThat(paths).containsExactly('one', 'one.first', 'one.last', 'two', 'two.first', 'two.last');
		}
		@Test
		void processNameWhenReturnsNullThrowsException() {
			JsonWriter<Person> writer = JsonWriter.of((members) -> {
				members.add('first', Person::firstName);
				members.add('last', Person::lastName);
				members
					.applyingNameProcessor((path, existingName) -> !'first'.equals(existingName) ? existingName : null);
			});
			assertThatIllegalStateException().isThrownBy(() -> writer.writeToString(new Person('spring', 'boot', 10)))
				.withMessageContaining('NameProcessor')
				.withMessageContaining('returned an empty result');
		}
		@Test
		void processNameWhenReturnsEmptyStringThrowsException() {
			JsonWriter<Person> writer = JsonWriter.of((members) -> {
				members.add('first', Person::firstName);
				members.add('last', Person::lastName);
				members
					.applyingNameProcessor((path, existingName) -> !'first'.equals(existingName) ? existingName : '');
			});
			assertThatIllegalStateException().isThrownBy(() -> writer.writeToString(new Person('spring', 'boot', 10)))
				.withMessageContaining('NameProcessor')
				.withMessageContaining('returned an empty result');
		}
	}
	/**
	 * Tests for {@link ValueProcessor}.
	 */
	@Nested
	class ValueProcessorTests {
		@Test
		void of() {
			ValueProcessor<String> processor = ValueProcessor.of(String::toUpperCase);
			assertThat(processor.processValue(null, 'test')).isEqualTo('TEST');
		}
		@Test
		void ofWhenNull() {
			assertThatIllegalArgumentException().isThrownBy(() -> ValueProcessor.of(null))
				.withMessage('"action" must not be null');
		}
		@Test
		void whenHasPathWithStringWhenPathMatches() {
			ValueProcessor<String> processor = ValueProcessor.<String>of(String::toUpperCase).whenHasPath('foo');
			assertThat(processor.processValue(MemberPath.ROOT.child('foo'), 'test')).isEqualTo('TEST');
		}
		@Test
		void whenHasPathWithStringWhenPathDoesNotMatch() {
			ValueProcessor<String> processor = ValueProcessor.<String>of(String::toUpperCase).whenHasPath('foo');
			assertThat(processor.processValue(MemberPath.ROOT.child('bar'), 'test')).isEqualTo('test');
		}
		@Test
		void whenHasPathWithPredicateWhenPathMatches() {
			ValueProcessor<String> processor = ValueProcessor.<String>of(String::toUpperCase)
				.whenHasPath((path) -> path.toString().startsWith('f'));
			assertThat(processor.processValue(MemberPath.ROOT.child('foo'), 'test')).isEqualTo('TEST');
		}
		@Test
		void whenHasPathWithPredicateWhenPathDoesNotMatch() {
			ValueProcessor<String> processor = ValueProcessor.<String>of(String::toUpperCase)
				.whenHasPath((path) -> path.toString().startsWith('f'));
			assertThat(processor.processValue(MemberPath.ROOT.child('bar'), 'test')).isEqualTo('test');
		}
		@Test
		void whenInstanceOfWhenInstanceMatches() {
			ValueProcessor<Object> processor = ValueProcessor.of((value) -> value.toString().toUpperCase(Locale.ROOT))
				.whenInstanceOf(String.class);
			assertThat(processor.processValue(null, 'test')).hasToString('TEST');
		}
		@Test
		void whenInstanceOfWhenInstanceDoesNotMatch() {
			ValueProcessor<Object> processor = ValueProcessor.of((value) -> value.toString().toUpperCase(Locale.ROOT))
				.whenInstanceOf(String.class);
			assertThat(processor.processValue(null, new StringBuilder('test'))).hasToString('test');
		}
		@Test
		void whenWhenPredicateMatches() {
			ValueProcessor<String> processor = ValueProcessor.<String>of(String::toUpperCase).when('test'::equals);
			assertThat(processor.processValue(null, 'test')).isEqualTo('TEST');
		}
		@Test
		void whenWhenPredicateDoesNotMatch() {
			ValueProcessor<String> processor = ValueProcessor.<String>of(String::toUpperCase).when('test'::equals);
			assertThat(processor.processValue(null, 'other')).isEqualTo('other');
		}
		@Test
		void processValueWhenSimpleValue() {
			JsonWriter<String> writer = simpleWriterWithUppercaseProcessor();
			assertThat(writer.writeToString('test')).isEqualTo('\'TEST\'');
		}
		@Test
		void processValueWhenMemberValue() {
			JsonWriter<Person> writer = JsonWriter.of((members) -> {
				members.add('first', Person::firstName);
				members.add('last', Person::lastName);
				members.applyingValueProcessor(ValueProcessor.of(StringUtils::capitalize));
			});
			assertThat(writer.writeToString(new Person('spring', 'boot', 10))).isEqualTo('''
					{'first':'Spring','last':'Boot'}''');
		}
		@Test
		void processValueWhenInMap() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingValueProcessor(ValueProcessor.of(StringUtils::capitalize));
			});
			assertThat(writer.writeToString(Map.of('spring', 'boot'))).isEqualTo('''
					{'spring':'Boot'}''');
		}
		@Test
		void processValueWhenInNestedMap() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingValueProcessor(ValueProcessor.of(StringUtils::capitalize));
			});
			assertThat(writer.writeToString(Map.of('test', Map.of('spring', 'boot')))).isEqualTo('''
					{'test':{'spring':'Boot'}}''');
		}
		@Test
		void processValueWhenInPairs() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add().usingPairs(Map::forEach);
				members.applyingValueProcessor(ValueProcessor.of(StringUtils::capitalize));
			});
			assertThat(writer.writeToString(Map.of('spring', 'boot'))).isEqualTo('''
					{'spring':'Boot'}''');
		}
		@Test
		void processValueWhenCalledWithMultipleTypesIgnoresLambdaErrors() {
			JsonWriter<Object> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingValueProcessor(ValueProcessor.of(StringUtils::capitalize));
			});
			assertThat(writer.writeToString('spring')).isEqualTo('\'Spring\'');
			assertThat(writer.writeToString(123)).isEqualTo('123');
			assertThat(writer.writeToString(true)).isEqualTo('true');
		}
		@Test
		void processValueWhenLimitedToPath() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingValueProcessor(ValueProcessor.of(StringUtils::capitalize).whenHasPath('spring'));
			});
			assertThat(writer.writeToString(Map.of('spring', 'boot'))).isEqualTo('''
					{'spring':'Boot'}''');
			assertThat(writer.writeToString(Map.of('boot', 'spring'))).isEqualTo('''
					{'boot':'spring'}''');
		}
		@Test
		void processValueWhen() {
			JsonWriter<Map<?, ?>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingValueProcessor(
						ValueProcessor.of(StringUtils::capitalize).when((candidate) -> candidate.startsWith('b')));
			});
			assertThat(writer.writeToString(Map.of('spring', 'boot'))).isEqualTo('''
					{'spring':'Boot'}''');
			assertThat(writer.writeToString(Map.of('boot', 'spring'))).isEqualTo('''
					{'boot':'spring'}''');
		}
		@Test
		void processValueWhenHasNestedMembers() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.from(Couple::person1)
					.usingMembers((personMembers) -> personMembers.add('one', Person::toString));
				members.from(Couple::person2)
					.usingMembers((personMembers) -> personMembers.add('two', Person::toString));
				members.applyingValueProcessor(ValueProcessor.of(String.class, String::toUpperCase));
			});
			assertThat(writer.writeToString(couple)).isEqualTo('''
					{'one':'SPRING BOOT (10)','two':'SPRING FRAMEWORK (20)'}''');
		}
		@Test
		void processValueWhenHasNestedMembersWithAdditionalValueProcessor() {
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.from(Couple::person1)
					.usingMembers((personMembers) -> personMembers.add('one', Person::toString));
				members.from(Couple::person2).usingMembers((personMembers) -> {
					personMembers.add('two', Person::toString);
					personMembers.applyingValueProcessor(ValueProcessor.of(String.class, (item) -> item + '!'));
				});
				members.applyingValueProcessor(ValueProcessor.of(String.class, String::toUpperCase));
			});
			assertThat(writer.writeToString(couple)).isEqualTo('''
					{'one':'SPRING BOOT (10)','two':'SPRING FRAMEWORK (20)!'}''');
		}
		@Test
		void processValueWhenDeeplyNestedUsesCompoundPaths() {
			List<String> paths = new ArrayList<>();
			JsonWriter<Couple> writer = JsonWriter.of((members) -> {
				members.add('one', Couple::person1).usingMembers((personMembers) -> {
					personMembers.add('first', Person::firstName);
					personMembers.add('last', Person::lastName);
				});
				members.add('two', Couple::person2).usingMembers((personMembers) -> {
					personMembers.add('first', Person::firstName);
					personMembers.add('last', Person::lastName);
				});
				members.applyingValueProcessor((path, value) -> {
					paths.add(path.toString());
					return value;
				});
			});
			Couple couple = new Couple(PERSON, new Person('Spring', 'Framework', 20));
			writer.writeToString(couple);
			assertThat(paths).containsExactly('one', 'one.first', 'one.last', 'two', 'two.first', 'two.last');
		}
		@Test
		void processValueWhenUsingListUsesIndexedPaths() {
			List<String> paths = new ArrayList<>();
			JsonWriter<List<String>> writer = JsonWriter.of((members) -> {
				members.add();
				members.applyingValueProcessor((path, value) -> {
					paths.add(path.toString());
					return value;
				});
			});
			writer.writeToString(List.of('a', 'b', 'c'));
			assertThat(paths).containsExactly('', '[0]', '[1]', '[2]');
		}
		@Test
		void processValueUsesUnprocessedNameInPath() {
			List<String> paths = new ArrayList<>();
			JsonWriter<Person> writer = JsonWriter.of((members) -> {
				members.add('first', Person::firstName);
				members.add('last', Person::lastName);
				members.applyingValueProcessor((path, value) -> {
					paths.add(path.toString());
					return value;
				});
				members.applyingNameProcessor((path, existingName) -> 'the-' + existingName);
			});
			writer.writeToString(PERSON);
			assertThat(paths).containsExactly('first', 'last');
		}
		private JsonWriter<String> simpleWriterWithUppercaseProcessor() {
			return JsonWriter.of((members) -> {
				members.add();
				members.applyingValueProcessor(ValueProcessor.of(String.class, String::toUpperCase));
			});
		}
	}
	record Person(String firstName, String lastName, int age) {
		@Override
		public String toString() {
			return '%s %s (%s)'.formatted(this.firstName, this.lastName, this.age);
		}
	}
	record Couple(Person person1, Person person2) {
	}
}
/*
package org.springframework.boot.json;
/**
class JacksonJsonParserTests extends AbstractJsonParserTests {
	@Override
	protected JsonParser getParser() {
		return new JacksonJsonParser();
	}
	@Test
	@SuppressWarnings('unchecked')
	void instanceWithSpecificObjectMapper() throws IOException {
		ObjectMapper objectMapper = spy(new ObjectMapper());
		new JacksonJsonParser(objectMapper).parseMap('{}');
		then(objectMapper).should().readValue(eq('{}'), any(TypeReference.class));
	}
	@Override
	@Disabled('Jackson"s array handling is no longer stack bound so protection has been removed.')
	// https://github.com/FasterXML/jackson-databind/commit/8238ab41d0350fb915797c89d46777b4496b74fd
	void listWithRepeatedOpenArray() throws IOException {
	}
}
/*
package org.springframework.boot.json;
/**
class JacksonRuntimeHintsTests {
	@Test
	void shouldRegisterSerializerConstructors() {
		ReflectionHints hints = registerHints();
		Stream
			.of(AtomicBooleanSerializer.class, AtomicIntegerSerializer.class, AtomicLongSerializer.class,
					FileSerializer.class, ClassSerializer.class, TokenBufferSerializer.class)
			.forEach((serializer) -> {
				TypeHint typeHint = hints.getTypeHint(serializer);
				assertThat(typeHint).withFailMessage(() -> 'No hints found for serializer ' + serializer).isNotNull();
				Set<MemberCategory> memberCategories = typeHint.getMemberCategories();
				assertThat(memberCategories).containsExactly(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);
			});
	}
	private ReflectionHints registerHints() {
		RuntimeHints hints = new RuntimeHints();
		new JacksonRuntimeHints().registerHints(hints, getClass().getClassLoader());
		return hints.reflection();
	}
}
/*
package org.springframework.boot.json;
/**
abstract class AbstractJsonParserTests {
	private final JsonParser parser = getParser();
	protected abstract JsonParser getParser();
	@Test
	void simpleMap() {
		Map<String, Object> map = this.parser.parseMap('{\'foo\':\'bar\',\'spam\':1}');
		assertThat(map).hasSize(2);
		assertThat(map).containsEntry('foo', 'bar');
		assertThat(((Number) map.get('spam')).longValue()).isOne();
	}
	@Test
	void doubleValue() {
		Map<String, Object> map = this.parser.parseMap('{\'foo\':\'bar\',\'spam\':1.23}');
		assertThat(map).hasSize(2);
		assertThat(map).containsEntry('foo', 'bar');
		assertThat(map).containsEntry('spam', 1.23d);
	}
	@Test
	void stringContainingNumber() {
		Map<String, Object> map = this.parser.parseMap('{\'foo\':\'123\'}');
		assertThat(map).hasSize(1);
		assertThat(map).containsEntry('foo', '123');
	}
	@Test
	void stringContainingComma() {
		Map<String, Object> map = this.parser.parseMap('{\'foo\':\'bar1,bar2\'}');
		assertThat(map).hasSize(1);
		assertThat(map).containsEntry('foo', 'bar1,bar2');
	}
	@Test
	void emptyMap() {
		Map<String, Object> map = this.parser.parseMap('{}');
		assertThat(map).isEmpty();
	}
	@Test
	void simpleList() {
		List<Object> list = this.parser.parseList('[\'foo\',\'bar\',1]');
		assertThat(list).hasSize(3);
		assertThat(list.get(1)).isEqualTo('bar');
	}
	@Test
	void emptyList() {
		List<Object> list = this.parser.parseList('[]');
		assertThat(list).isEmpty();
	}
	@SuppressWarnings('unchecked')
	@Test
	void listOfMaps() {
		List<Object> list = this.parser.parseList('[{\'foo\':\'bar\',\'spam\':1},{\'foo\':\'baz\',\'spam\':2}]');
		assertThat(list).hasSize(2);
		assertThat(((Map<String, Object>) list.get(1))).hasSize(2);
	}
	@SuppressWarnings('unchecked')
	@Test
	void mapOfLists() {
		Map<String, Object> map = this.parser
			.parseMap('{\'foo\':[{\'foo\':\'bar\',\'spam\':1},{\'foo\':\'baz\',\'spam\':2}]}');
		assertThat(map).hasSize(1);
		assertThat(((List<Object>) map.get('foo'))).hasSize(2);
		assertThat(map.get('foo')).asInstanceOf(InstanceOfAssertFactories.LIST).allMatch(Map.class::isInstance);
	}
	@SuppressWarnings('unchecked')
	@Test
	void nestedLeadingAndTrailingWhitespace() {
		Map<String, Object> map = this.parser
			.parseMap(' {\'foo\': [ { \'foo\' : \'bar\' , \'spam\' : 1 } , { \'foo\' : \'baz\' , \'spam\' : 2 } ] } ');
		assertThat(map).hasSize(1);
		assertThat(((List<Object>) map.get('foo'))).hasSize(2);
		assertThat(map.get('foo')).asInstanceOf(InstanceOfAssertFactories.LIST).allMatch(Map.class::isInstance);
	}
	@Test
	void mapWithNullThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseMap(null));
	}
	@Test
	void listWithNullThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseList(null));
	}
	@Test
	void mapWithEmptyStringThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseMap(''));
	}
	@Test
	void listWithEmptyStringThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseList(''));
	}
	@Test
	void mapWithListThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseMap('[]'));
	}
	@Test
	void listWithMapThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseList('{}'));
	}
	@Test
	void listWithLeadingWhitespace() {
		List<Object> list = this.parser.parseList('\n\t[\'foo\']');
		assertThat(list).hasSize(1);
		assertThat(list.get(0)).isEqualTo('foo');
	}
	@Test
	void mapWithLeadingWhitespace() {
		Map<String, Object> map = this.parser.parseMap('\n\t{\'foo\':\'bar\'}');
		assertThat(map).hasSize(1);
		assertThat(map).containsEntry('foo', 'bar');
	}
	@Test
	void mapWithLeadingWhitespaceListThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseMap('\n\t[]'));
	}
	@Test
	void listWithLeadingWhitespaceMapThrowsARuntimeException() {
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> this.parser.parseList('\n\t{}'));
	}
	@Test
	void escapeDoubleQuote() {
		String input = '{\'foo\': \'\\\'bar\\\'\'}';
		Map<String, Object> map = this.parser.parseMap(input);
		assertThat(map).containsEntry('foo', '\'bar\'');
	}
	@Test
	void listWithMalformedMap() {
		assertThatExceptionOfType(JsonParseException.class)
			.isThrownBy(() -> this.parser.parseList('[tru,erqett,{\'foo\':fatrue,true,true,true,tr""ue}]'));
	}
	@Test
	void mapWithKeyAndNoValue() {
		assertThatExceptionOfType(JsonParseException.class).isThrownBy(() -> this.parser.parseMap('{\'foo\'}'));
	}
	@Test // gh-31868
	void listWithRepeatedOpenArray() throws IOException {
		String input = StreamUtils.copyToString(
				AbstractJsonParserTests.class.getResourceAsStream('repeated-open-array.txt'), StandardCharsets.UTF_8);
		assertThatExceptionOfType(JsonParseException.class).isThrownBy(() -> this.parser.parseList(input))
			.havingCause()
			.withMessageContaining('too deeply nested');
	}
	@Test // gh-31869
	void largeMalformed() throws IOException {
		String input = StreamUtils.copyToString(
				AbstractJsonParserTests.class.getResourceAsStream('large-malformed-json.txt'), StandardCharsets.UTF_8);
		assertThatExceptionOfType(JsonParseException.class).isThrownBy(() -> this.parser.parseList(input));
	}
	@Test // gh-32029
	void deeplyNestedMap() throws IOException {
		String input = StreamUtils.copyToString(
				AbstractJsonParserTests.class.getResourceAsStream('deeply-nested-map-json.txt'),
				StandardCharsets.UTF_8);
		assertThatExceptionOfType(JsonParseException.class).isThrownBy(() -> this.parser.parseList(input));
	}
}
/*
package org.springframework.boot.json;
/**
class GsonJsonParserTests extends AbstractJsonParserTests {
	@Override
	protected JsonParser getParser() {
		return new GsonJsonParser();
	}
	@Override
	void listWithRepeatedOpenArray() throws IOException {
		// Gson does not protect against deeply nested JSON
	}
}
/*
package org.springframework.boot.json;
/**
class JsonValueWriterTests {
	@Test
	void writeNameAndValueWhenNameIsNull() {
		assertThat(doWrite((writer) -> writer.write(null, 'test'))).isEqualTo(quoted('test'));
	}
	@Test
	void writeNameAndValueWhenNameIsNotNull() {
		assertThat(doWrite((writer) -> {
			writer.start(Series.OBJECT);
			writer.write('name', 'value');
			writer.end(Series.OBJECT);
		})).isEqualTo('''
				{'name':'value'}''');
	}
	@Test
	void writeWhenNull() {
		assertThat(write(null)).isEqualTo('null');
	}
	@Test
	void writeWhenWritableJson() {
		JsonWriter<String> writer = (instance, out) -> out.append('''
				{'test':'%s'}'''.formatted(instance));
		assertThat(write(writer.write('hello'))).isEqualTo('''
				{'test':'hello'}''');
	}
	@Test
	void writeWhenStringArray() {
		assertThat(write(new String[] { 'a', 'b', 'c' })).isEqualTo('''
				['a','b','c']''');
	}
	@Test
	void writeWhenNumberArray() {
		assertThat(write(new int[] { 1, 2, 3 })).isEqualTo('[1,2,3]');
		assertThat(write(new double[] { 1.0, 2.0, 3.0 })).isEqualTo('[1.0,2.0,3.0]');
	}
	@Test
	void writeWhenBooleanArray() {
		assertThat(write(new boolean[] { true, false, true })).isEqualTo('[true,false,true]');
	}
	@Test
	void writeWhenArrayWithNullElements() {
		assertThat(write(new Object[] { null, null })).isEqualTo('[null,null]');
	}
	@Test
	void writeWhenArrayWithMixedElementTypes() {
		assertThat(write(new Object[] { 'a', 'b', 'c', 1, 2, true, null })).isEqualTo('''
				['a','b','c',1,2,true,null]''');
	}
	@Test
	void writeWhenCollection() {
		assertThat(write(List.of('a', 'b', 'c'))).isEqualTo('''
				['a','b','c']''');
		assertThat(write(new LinkedHashSet<>(List.of('a', 'b', 'c')))).isEqualTo('''
				['a','b','c']''');
	}
	@Test
	void writeWhenMap() {
		Map<String, String> map = new LinkedHashMap<>();
		map.put('a', 'A');
		map.put('b', 'B');
		assertThat(write(map)).isEqualTo('''
				{'a':'A','b':'B'}''');
	}
	@Test
	void writeWhenMapWithNumericalKeys() {
		Map<Integer, String> map = new LinkedHashMap<>();
		map.put(1, 'A');
		map.put(2, 'B');
		assertThat(write(map)).isEqualTo('''
				{'1':'A','2':'B'}''');
	}
	@Test
	void writeWhenMapWithMixedValueTypes() {
		Map<Object, Object> map = new LinkedHashMap<>();
		map.put('a', 1);
		map.put('b', 2.0);
		map.put('c', true);
		map.put('d', 'd');
		map.put('e', null);
		assertThat(write(map)).isEqualTo('''
				{'a':1,'b':2.0,'c':true,'d':'d','e':null}''');
	}
	@Test
	void writeWhenNumber() {
		assertThat(write((byte) 123)).isEqualTo('123');
		assertThat(write(123)).isEqualTo('123');
		assertThat(write(123L)).isEqualTo('123');
		assertThat(write(2.0)).isEqualTo('2.0');
		assertThat(write(2.0f)).isEqualTo('2.0');
		assertThat(write(Byte.valueOf((byte) 123))).isEqualTo('123');
		assertThat(write(Integer.valueOf(123))).isEqualTo('123');
		assertThat(write(Long.valueOf(123L))).isEqualTo('123');
		assertThat(write(Double.valueOf(2.0))).isEqualTo('2.0');
		assertThat(write(Float.valueOf(2.0f))).isEqualTo('2.0');
	}
	@Test
	void writeWhenBoolean() {
		assertThat(write(true)).isEqualTo('true');
		assertThat(write(Boolean.TRUE)).isEqualTo('true');
		assertThat(write(false)).isEqualTo('false');
		assertThat(write(Boolean.FALSE)).isEqualTo('false');
	}
	@Test
	void writeWhenString() {
		assertThat(write('test')).isEqualTo(quoted('test'));
	}
	@Test
	void writeWhenStringRequiringEscape() {
		assertThat(write('\'')).isEqualTo(quoted('\\\''));
		assertThat(write('\\')).isEqualTo(quoted('\\\\'));
		assertThat(write('/')).isEqualTo(quoted('\\/'));
		assertThat(write('\b')).isEqualTo(quoted('\\b'));
		assertThat(write('\f')).isEqualTo(quoted('\\f'));
		assertThat(write('\n')).isEqualTo(quoted('\\n'));
		assertThat(write('\r')).isEqualTo(quoted('\\r'));
		assertThat(write('\t')).isEqualTo(quoted('\\t'));
		assertThat(write('\u0000\u001F')).isEqualTo(quoted('\\u0000\\u001F'));
	}
	@Test
	void writeObject() {
		Map<String, String> map = Map.of('a', 'A');
		String actual = doWrite((valueWriter) -> valueWriter.writeObject(map::forEach));
		assertThat(actual).isEqualTo('''
				{'a':'A'}''');
	}
	@Test
	void writePairs() {
		String actual = doWrite((valueWriter) -> {
			valueWriter.start(Series.OBJECT);
			valueWriter.writePairs(Map.of('a', 'A')::forEach);
			valueWriter.writePairs(Map.of('b', 'B')::forEach);
			valueWriter.end(Series.OBJECT);
		});
		assertThat(actual).isEqualTo('''
				{'a':'A','b':'B'}''');
	}
	@Test
	void writeArray() {
		List<String> list = List.of('a', 'b', 'c');
		String actual = doWrite((valueWriter) -> valueWriter.writeArray(list::forEach));
		assertThat(actual).isEqualTo('''
				['a','b','c']''');
	}
	@Test
	void writeElements() {
		String actual = doWrite((valueWriter) -> {
			valueWriter.start(Series.ARRAY);
			valueWriter.writeElements(List.of('a', 'b')::forEach);
			valueWriter.writeElements(List.of('c', 'd')::forEach);
			valueWriter.end(Series.ARRAY);
		});
		assertThat(actual).isEqualTo('''
				['a','b','c','d']''');
	}
	@Test
	void startAndEndWithNull() {
		String actual = doWrite((valueWriter) -> {
			valueWriter.start(null);
			valueWriter.write('test');
			valueWriter.end(null);
		});
		assertThat(actual).isEqualTo(quoted('test'));
	}
	@Test
	void endWhenNotStartedThrowsException() {
		doWrite((valueWriter) -> assertThatExceptionOfType(NoSuchElementException.class)
			.isThrownBy(() -> valueWriter.end(Series.ARRAY)));
	}
	private <V> String write(V value) {
		return doWrite((valueWriter) -> valueWriter.write(value));
	}
	private String doWrite(Consumer<JsonValueWriter> action) {
		StringBuilder out = new StringBuilder();
		action.accept(new JsonValueWriter(out));
		return out.toString();
	}
	private String quoted(String string) {
		return '\'' + string + '\'';
	}
}
/*
package org.springframework.boot.json;
/**
class WritableJsonTests {
	@TempDir
	File temp;
	@Test
	void toJsonStringReturnsString() {
		WritableJson writable = (out) -> out.append('{}');
		assertThat(writable.toJsonString()).isEqualTo('{}');
	}
	@Test
	void toJsonStringWhenIOExceptionIsThrownThrowsUncheckedIOException() {
		WritableJson writable = (out) -> {
			throw new IOException('bad');
		};
		assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> writable.toJsonString())
			.havingCause()
			.withMessage('bad');
	}
	@Test
	void toByteArrayReturnsByteArray() {
		WritableJson writable = (out) -> out.append('{}');
		assertThat(writable.toByteArray()).isEqualTo('{}'.getBytes());
	}
	@Test
	void toResourceWritesJson() throws Exception {
		File file = new File(this.temp, 'out.json');
		WritableJson writable = (out) -> out.append('{}');
		writable.toResource(new FileSystemResource(file));
		assertThat(file).content().isEqualTo('{}');
	}
	@Test
	void toResourceWithCharsetWritesJson() throws Exception {
		File file = new File(this.temp, 'out.json');
		WritableJson writable = (out) -> out.append('{}');
		writable.toResource(new FileSystemResource(file), StandardCharsets.ISO_8859_1);
		assertThat(file).content(StandardCharsets.ISO_8859_1).isEqualTo('{}');
	}
	@Test
	void toResourceWithCharsetWhenOutIsNullThrowsException() {
		WritableJson writable = (out) -> out.append('{}');
		assertThatIllegalArgumentException().isThrownBy(() -> writable.toResource(null, StandardCharsets.UTF_8))
			.withMessage('"out" must not be null');
	}
	@Test
	void toResourceWithCharsetWhenCharsetIsNullThrowsException() {
		File file = new File(this.temp, 'out.json');
		WritableJson writable = (out) -> out.append('{}');
		assertThatIllegalArgumentException().isThrownBy(() -> writable.toResource(new FileSystemResource(file), null))
			.withMessage('"charset" must not be null');
	}
	@Test
	void toOutputStreamWritesJson() throws Exception {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		WritableJson writable = (out) -> out.append('{}');
		writable.toOutputStream(outputStream);
		assertThat(outputStream.toString(StandardCharsets.UTF_8)).isEqualTo('{}');
	}
	@Test
	void toOutputStreamWithCharsetWritesJson() throws Exception {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		WritableJson writable = (out) -> out.append('{}');
		writable.toOutputStream(outputStream, StandardCharsets.ISO_8859_1);
		assertThat(outputStream.toString(StandardCharsets.ISO_8859_1)).isEqualTo('{}');
	}
	@Test
	void toOutputStreamWithCharsetWhenOutIsNullThrowsException() {
		WritableJson writable = (out) -> out.append('{}');
		assertThatIllegalArgumentException().isThrownBy(() -> writable.toOutputStream(null, StandardCharsets.UTF_8))
			.withMessage('"out" must not be null');
	}
	@Test
	void toOutputStreamWithCharsetWhenCharsetIsNullThrowsException() {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		WritableJson writable = (out) -> out.append('{}');
		assertThatIllegalArgumentException().isThrownBy(() -> writable.toOutputStream(outputStream, null))
			.withMessage('"charset" must not be null');
	}
	@Test
	void toWriterWritesJson() throws Exception {
		StringWriter writer = new StringWriter();
		WritableJson writable = (out) -> out.append('{}');
		writable.toWriter(writer);
		assertThat(writer).hasToString('{}');
	}
	@Test
	void toWriterWhenWriterIsNullThrowsException() {
		WritableJson writable = (out) -> out.append('{}');
		assertThatIllegalArgumentException().isThrownBy(() -> writable.toWriter(null))
			.withMessage('"out" must not be null');
	}
	@Test
	void ofReturnsInstanceWithSensibleToString() {
		WritableJson writable = WritableJson.of((out) -> out.append('{}'));
		assertThat(writable).hasToString('{}');
	}
}
/*
package org.springframework.boot;
/**
class ApplicationInfoPropertySourceTests {
	@Test
	void shouldAddVersion() {
		MockEnvironment environment = new MockEnvironment();
		environment.getPropertySources().addLast(new ApplicationInfoPropertySource('1.2.3'));
		assertThat(environment.getProperty('spring.application.version')).isEqualTo('1.2.3');
	}
	@Test
	void shouldNotAddVersionIfVersionIsNotAvailable() {
		MockEnvironment environment = new MockEnvironment();
		environment.getPropertySources().addLast(new ApplicationInfoPropertySource((String) null));
		assertThat(environment.containsProperty('spring.application.version')).isFalse();
	}
	@Test
	void shouldAddPid() {
		MockEnvironment environment = new MockEnvironment();
		environment.getPropertySources().addLast(new ApplicationInfoPropertySource('1.2.3'));
		assertThat(environment.getProperty('spring.application.pid', Long.class))
			.isEqualTo(new ApplicationPid().toLong());
	}
	@Test
	void shouldMoveToEnd() {
		MockEnvironment environment = new MockEnvironment();
		environment.getPropertySources().addFirst(new MapPropertySource('first', Collections.emptyMap()));
		environment.getPropertySources().addAfter('first', new MapPropertySource('second', Collections.emptyMap()));
		environment.getPropertySources().addFirst(new ApplicationInfoPropertySource('1.2.3'));
		List<String> propertySources = environment.getPropertySources().stream().map(PropertySource::getName).toList();
		assertThat(propertySources).containsExactly('applicationInfo', 'first', 'second', 'mockProperties');
		ApplicationInfoPropertySource.moveToEnd(environment);
		List<String> propertySourcesAfterMove = environment.getPropertySources()
			.stream()
			.map(PropertySource::getName)
			.toList();
		assertThat(propertySourcesAfterMove).containsExactly('first', 'second', 'mockProperties', 'applicationInfo');
	}
}
/*
package org.springframework.boot;
/**
class ResourceBannerTests {
	@AfterEach
	void reset() {
		AnsiOutput.setEnabled(Enabled.DETECT);
	}
	@Test
	void renderVersions() {
		Resource resource = new ByteArrayResource(
				'banner ${a} ${spring-boot.version} ${application.version}'.getBytes());
		String banner = printBanner(resource, '10.2', '2.0', null);
		assertThat(banner).startsWith('banner 1 10.2 2.0');
	}
	@Test
	void renderWithoutVersions() {
		Resource resource = new ByteArrayResource(
				'banner ${a} ${spring-boot.version} ${application.version}'.getBytes());
		String banner = printBanner(resource, null, null, null);
		assertThat(banner).startsWith('banner 1  ');
	}
	@Test
	void renderFormattedVersions() {
		Resource resource = new ByteArrayResource(
				'banner ${a}${spring-boot.formatted-version}${application.formatted-version}'.getBytes());
		String banner = printBanner(resource, '10.2', '2.0', null);
		assertThat(banner).startsWith('banner 1 (v10.2) (v2.0)');
	}
	@Test
	void renderWithoutFormattedVersions() {
		Resource resource = new ByteArrayResource(
				'banner ${a}${spring-boot.formatted-version}${application.formatted-version}'.getBytes());
		String banner = printBanner(resource, null, null, null);
		assertThat(banner).startsWith('banner 1');
	}
	@Test
	void renderWithColors() {
		Resource resource = new ByteArrayResource('${Ansi.RED}This is red.${Ansi.NORMAL}'.getBytes());
		AnsiOutput.setEnabled(AnsiOutput.Enabled.ALWAYS);
		String banner = printBanner(resource, null, null, null);
		assertThat(banner).startsWith('\u001B[31mThis is red.\u001B[0m');
	}
	@Test
	void renderWithColorsButDisabled() {
		Resource resource = new ByteArrayResource('${Ansi.RED}This is red.${Ansi.NORMAL}'.getBytes());
		AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER);
		String banner = printBanner(resource, null, null, null);
		assertThat(banner).startsWith('This is red.');
	}
	@Test
	void renderWith256Colors() {
		Resource resource = new ByteArrayResource('${AnsiColor.208}This is orange.${Ansi.NORMAL}'.getBytes());
		AnsiOutput.setEnabled(AnsiOutput.Enabled.ALWAYS);
		String banner = printBanner(resource, null, null, null);
		assertThat(banner).startsWith('\033[38;5;208mThis is orange.\u001B[0m');
	}
	@Test
	void renderWith256ColorsButDisabled() {
		Resource resource = new ByteArrayResource('${AnsiColor.208}This is orange.${Ansi.NORMAL}'.getBytes());
		AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER);
		String banner = printBanner(resource, null, null, null);
		assertThat(banner).startsWith('This is orange.');
	}
	@Test
	void renderWithTitle() {
		Resource resource = new ByteArrayResource('banner ${application.title} ${a}'.getBytes());
		String banner = printBanner(resource, null, null, 'title');
		assertThat(banner).startsWith('banner title 1');
	}
	@Test
	void renderWithoutTitle() {
		Resource resource = new ByteArrayResource('banner ${application.title} ${a}'.getBytes());
		String banner = printBanner(resource, null, null, null);
		assertThat(banner).startsWith('banner  1');
	}
	@Test
	void renderWithDefaultValues() {
		Resource resource = new ByteArrayResource(
				'banner ${a:default-a} ${b:default-b} ${spring-boot.version:default-boot-version} ${application.version:default-application-version}'
					.getBytes());
		String banner = printBanner(resource, '10.2', '1.0', null);
		assertThat(banner).startsWith('banner 1 default-b 10.2 1.0');
	}
	@Test
	void renderWithMutation() {
		Resource resource = new ByteArrayResource('banner ${foo}'.getBytes());
		String banner = printBanner(new MutatingResourceBanner(resource, '1', null), '2');
		assertThat(banner).startsWith('banner bar');
	}
	private String printBanner(Resource resource, String bootVersion, String applicationVersion,
			String applicationTitle) {
		return printBanner(new MockResourceBanner(resource, bootVersion, applicationTitle), applicationVersion);
	}
	private String printBanner(ResourceBanner banner, String applicationVersion) {
		MockEnvironment environment = new MockEnvironment();
		if (applicationVersion != null) {
			environment.setProperty('spring.application.version', applicationVersion);
		}
		Map<String, Object> source = Collections.singletonMap('a', '1');
		environment.getPropertySources().addLast(new MapPropertySource('map', source));
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		banner.printBanner(environment, getClass(), new PrintStream(out));
		return out.toString();
	}
	static class MockResourceBanner extends ResourceBanner {
		private final String bootVersion;
		private final String applicationTitle;
		MockResourceBanner(Resource resource, String bootVersion, String applicationTitle) {
			super(resource);
			this.bootVersion = bootVersion;
			this.applicationTitle = applicationTitle;
		}
		@Override
		protected String getBootVersion() {
			return this.bootVersion;
		}
		@Override
		protected String getApplicationTitle(Class<?> sourceClass) {
			return this.applicationTitle;
		}
	}
	static class MutatingResourceBanner extends MockResourceBanner {
		MutatingResourceBanner(Resource resource, String bootVersion, String applicationTitle) {
			super(resource, bootVersion, applicationTitle);
		}
		@Override
		protected List<PropertyResolver> getPropertyResolvers(Environment environment, Class<?> sourceClass) {
			List<PropertyResolver> resolvers = super.getPropertyResolvers(environment, sourceClass);
			PropertyResolver resolver = new AbstractPropertyResolver() {
				@Override
				@SuppressWarnings('unchecked')
				public <T> T getProperty(String key, Class<T> targetType) {
					return String.class.equals(targetType) ? (T) getPropertyAsRawString(key) : null;
				}
				@Override
				protected String getPropertyAsRawString(String key) {
					return ('foo'.equals(key)) ? 'bar' : null;
				}
			};
			resolvers.add(resolver);
			return resolvers;
		}
	}
}
/*
package org.springframework.boot;
/**
class SpringBootVersionTests {
	@Test
	void getVersionShouldReturnVersionMatchingGradleProperties() throws IOException {
		String expectedVersion = PropertiesLoaderUtils.loadProperties(new FileSystemResource(findGradleProperties()))
			.getProperty('version');
		assertThat(SpringBootVersion.getVersion()).isEqualTo(expectedVersion);
	}
	private File findGradleProperties() {
		File current = new File('.').getAbsoluteFile();
		while (current != null) {
			File gradleProperties = new File(current, 'gradle.properties');
			System.out.println(gradleProperties);
			if (gradleProperties.isFile()) {
				return gradleProperties;
			}
			current = current.getParentFile();
		}
		throw new IllegalStateException('Could not find gradle.properties');
	}
}
/*
package org.springframework.boot;
/**
class BeanDefinitionLoaderTests {
	private StaticApplicationContext registry;
	@BeforeEach
	void setup() {
		this.registry = new StaticApplicationContext();
	}
	@AfterEach
	void cleanUp() {
		this.registry.close();
	}
	@Test
	void loadClass() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, MyComponent.class);
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myComponent')).isTrue();
	}
	@Test
	void anonymousClassNotLoaded() {
		MyComponent myComponent = new MyComponent() {
		};
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, myComponent.getClass());
		assertThat(load(loader)).isZero();
	}
	@Test
	void loadJsr330Class() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, MyNamedComponent.class);
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myNamedComponent')).isTrue();
	}
	@Test
	void loadXmlResource() {
		ClassPathResource resource = new ClassPathResource('sample-beans.xml', getClass());
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, resource);
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myXmlComponent')).isTrue();
	}
	@Test
	void loadGroovyResource() {
		ClassPathResource resource = new ClassPathResource('sample-beans.groovy', getClass());
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, resource);
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myGroovyComponent')).isTrue();
	}
	@Test
	void loadGroovyResourceWithNamespace() {
		ClassPathResource resource = new ClassPathResource('sample-namespace.groovy', getClass());
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, resource);
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myGroovyComponent')).isTrue();
	}
	@Test
	void loadPackage() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, MyComponent.class.getPackage());
		assertThat(load(loader)).isEqualTo(2);
		assertThat(this.registry.containsBean('myComponent')).isTrue();
		assertThat(this.registry.containsBean('myNamedComponent')).isTrue();
	}
	@Test
	void loadClassName() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, MyComponent.class.getName());
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myComponent')).isTrue();
	}
	@Test
	void loadResourceName() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry,
				'classpath:org/springframework/boot/sample-beans.xml');
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myXmlComponent')).isTrue();
	}
	@Test
	void loadGroovyName() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry,
				'classpath:org/springframework/boot/sample-beans.groovy');
		assertThat(load(loader)).isOne();
		assertThat(this.registry.containsBean('myGroovyComponent')).isTrue();
	}
	@Test
	void loadPackageName() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, MyComponent.class.getPackage().getName());
		assertThat(load(loader)).isEqualTo(2);
		assertThat(this.registry.containsBean('myComponent')).isTrue();
		assertThat(this.registry.containsBean('myNamedComponent')).isTrue();
	}
	@Test
	void loadPackageNameWithoutDot() {
		// See gh-6126
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry,
				MyComponentInPackageWithoutDot.class.getPackage().getName());
		int loaded = load(loader);
		assertThat(loaded).isOne();
		assertThat(this.registry.containsBean('myComponentInPackageWithoutDot')).isTrue();
	}
	@Test
	void loadPackageAndClassDoesNotDoubleAdd() {
		BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, MyComponent.class.getPackage(),
				MyComponent.class);
		assertThat(load(loader)).isEqualTo(2);
		assertThat(this.registry.containsBean('myComponent')).isTrue();
		assertThat(this.registry.containsBean('myNamedComponent')).isTrue();
	}
	private int load(BeanDefinitionLoader loader) {
		int beans = this.registry.getBeanDefinitionCount();
		loader.load();
		return this.registry.getBeanDefinitionCount() - beans;
	}
}
/*
package org.springframework.boot.r2dbc;
/**
class EmbeddedDatabaseConnectionTests {
	@ParameterizedTest
	@MethodSource('urlParameters')
	void getUrlWithTestDatabase(EmbeddedDatabaseConnection connection, String expectUrl) {
		assertThat(connection.getUrl('test-database')).isEqualTo(expectUrl);
	}
	@Test
	void getReturnsH2ByDefault() {
		assertThat(EmbeddedDatabaseConnection.get(EmbeddedDatabaseConnectionTests.class.getClassLoader()))
			.isEqualTo(EmbeddedDatabaseConnection.H2);
	}
	@Test
	void getWhenH2IsNotOnTheClasspathReturnsNone() {
		assertThat(EmbeddedDatabaseConnection.get(new HidePackagesClassLoader('io.r2dbc.h2')))
			.isEqualTo(EmbeddedDatabaseConnection.NONE);
	}
	@Test
	void whenH2IsInMemoryThenIsEmbeddedReturnsTrue() {
		assertThat(EmbeddedDatabaseConnection
			.isEmbedded(ConnectionFactoryBuilder.withUrl('r2dbc:h2:mem:///' + UUID.randomUUID()).build())).isTrue();
	}
	@Test
	void whenH2IsUsingFileStorageThenIsEmbeddedReturnsFalse() {
		assertThat(EmbeddedDatabaseConnection
			.isEmbedded(ConnectionFactoryBuilder.withUrl('r2dbc:h2:file:///' + UUID.randomUUID()).build())).isFalse();
	}
	@Test
	void whenPoolIsBasedByH2InMemoryThenIsEmbeddedReturnsTrue() {
		assertThat(EmbeddedDatabaseConnection
			.isEmbedded(ConnectionFactoryBuilder.withUrl('r2dbc:pool:h2:mem:///' + UUID.randomUUID()).build()))
			.isTrue();
	}
	@Test
	void whenPoolIsBasedByH2WithFileStorageThenIsEmbeddedReturnsFalse() {
		assertThat(EmbeddedDatabaseConnection
			.isEmbedded(ConnectionFactoryBuilder.withUrl('r2dbc:pool:h2:file:///' + UUID.randomUUID()).build()))
			.isFalse();
	}
	@Test
	void whenConnectionFactoryIsNotOptionsCapableThenIsEmbeddedThrows() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> EmbeddedDatabaseConnection
				.isEmbedded(ConnectionFactories.get('r2dbc:pool:h2:mem:///' + UUID.randomUUID())))
			.withMessage('Cannot determine database"s type as ConnectionFactory is not options-capable. To be '
					+ 'options-capable, a ConnectionFactory should be created with '
					+ 'org.springframework.boot.r2dbc.ConnectionFactoryBuilder');
	}
	static Stream<Arguments> urlParameters() {
		return Stream.of(Arguments.arguments(EmbeddedDatabaseConnection.NONE, null),
				Arguments.arguments(EmbeddedDatabaseConnection.H2,
						'r2dbc:h2:mem:///test-database?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE'));
	}
	private static class HidePackagesClassLoader extends URLClassLoader {
		private final String[] hiddenPackages;
		HidePackagesClassLoader(String... hiddenPackages) {
			super(new URL[0], EmbeddedDatabaseConnectionTests.HidePackagesClassLoader.class.getClassLoader());
			this.hiddenPackages = hiddenPackages;
		}
		@Override
		protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
			if (Arrays.stream(this.hiddenPackages).anyMatch(name::startsWith)) {
				throw new ClassNotFoundException();
			}
			return super.loadClass(name, resolve);
		}
	}
}
/*
package org.springframework.boot.r2dbc;
/**
class ConnectionFactoryBuilderTests {
	@Test
	void createWithNullUrlShouldFail() {
		assertThatIllegalArgumentException().isThrownBy(() -> ConnectionFactoryBuilder.withUrl(null));
	}
	@Test
	void createWithEmptyUrlShouldFail() {
		assertThatIllegalArgumentException().isThrownBy(() -> ConnectionFactoryBuilder.withUrl('  '));
	}
	@Test
	void createWithEmbeddedConnectionNoneShouldFail() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ConnectionFactoryBuilder.withUrl(EmbeddedDatabaseConnection.NONE.getUrl('test')));
	}
	@Test
	void buildOptionsWithBasicUrlShouldExposeOptions() {
		ConnectionFactoryOptions options = ConnectionFactoryBuilder.withUrl('r2dbc:simple://:pool:').buildOptions();
		assertThat(options.hasOption(ConnectionFactoryOptions.USER)).isFalse();
		assertThat(options.hasOption(ConnectionFactoryOptions.PASSWORD)).isFalse();
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.DRIVER)).isEqualTo('simple');
	}
	@Test
	void buildOptionsWithEmbeddedConnectionH2ShouldExposeOptions() {
		ConnectionFactoryOptions options = ConnectionFactoryBuilder
			.withUrl(EmbeddedDatabaseConnection.H2.getUrl('testdb'))
			.buildOptions();
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.DRIVER)).isEqualTo('h2');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.PROTOCOL)).isEqualTo('mem');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.DATABASE)).isEqualTo('testdb');
		assertThat(options.hasOption(ConnectionFactoryOptions.HOST)).isFalse();
		assertThat(options.hasOption(ConnectionFactoryOptions.PORT)).isFalse();
		assertThat(options.hasOption(ConnectionFactoryOptions.USER)).isFalse();
		assertThat(options.hasOption(ConnectionFactoryOptions.PASSWORD)).isFalse();
		assertThat(options.getValue(Option.<String>valueOf('options')))
			.isEqualTo('DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE');
	}
	@Test
	void buildOptionsWithCompleteUrlShouldExposeOptions() {
		ConnectionFactoryOptions options = ConnectionFactoryBuilder
			.withUrl('r2dbc:simple:proto://user:password@myhost:4711/mydatabase')
			.buildOptions();
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.DRIVER)).isEqualTo('simple');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.PROTOCOL)).isEqualTo('proto');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.USER)).isEqualTo('user');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('password');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.HOST)).isEqualTo('myhost');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.PORT)).isEqualTo(4711);
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.DATABASE)).isEqualTo('mydatabase');
	}
	@Test
	void buildOptionsWithSpecificSettingsShouldOverrideUrlOptions() {
		ConnectionFactoryOptions options = ConnectionFactoryBuilder
			.withUrl('r2dbc:simple://user:password@myhost/mydatabase')
			.username('another-user')
			.password('another-password')
			.hostname('another-host')
			.port(1234)
			.database('another-database')
			.buildOptions();
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.USER)).isEqualTo('another-user');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('another-password');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.HOST)).isEqualTo('another-host');
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.PORT)).isEqualTo(1234);
		assertThat(options.getRequiredValue(ConnectionFactoryOptions.DATABASE)).isEqualTo('another-database');
	}
	@Test
	void buildOptionsWithDriverPropertiesShouldExposeOptions() {
		ConnectionFactoryOptions options = ConnectionFactoryBuilder.withUrl('r2dbc:simple://user:password@myhost')
			.configure((o) -> o.option(Option.valueOf('simpleOne'), 'one').option(Option.valueOf('simpleTwo'), 'two'))
			.buildOptions();
		assertThat(options.getRequiredValue(Option.<String>valueOf('simpleOne'))).isEqualTo('one');
		assertThat(options.getRequiredValue(Option.<String>valueOf('simpleTwo'))).isEqualTo('two');
	}
	@Test
	void buildShouldExposeConnectionFactory() {
		String databaseName = UUID.randomUUID().toString();
		ConnectionFactory connectionFactory = ConnectionFactoryBuilder
			.withUrl(EmbeddedDatabaseConnection.H2.getUrl(databaseName))
			.build();
		assertThat(connectionFactory).isNotNull();
		assertThat(connectionFactory.getMetadata().getName()).isEqualTo(H2ConnectionFactoryMetadata.NAME);
	}
	@Test
	void buildWhenDerivedWithNewDatabaseReturnsNewConnectionFactory() {
		String initialDatabaseName = UUID.randomUUID().toString();
		ConnectionFactory connectionFactory = ConnectionFactoryBuilder
			.withUrl(EmbeddedDatabaseConnection.H2.getUrl(initialDatabaseName))
			.build();
		ConnectionFactoryOptions initialOptions = ((OptionsCapableConnectionFactory) connectionFactory).getOptions();
		String derivedDatabaseName = UUID.randomUUID().toString();
		ConnectionFactory derived = ConnectionFactoryBuilder.derivedFrom(connectionFactory)
			.database(derivedDatabaseName)
			.build();
		ConnectionFactoryOptions derivedOptions = ((OptionsCapableConnectionFactory) derived).getOptions();
		assertThat(derivedOptions.getRequiredValue(ConnectionFactoryOptions.DATABASE)).isEqualTo(derivedDatabaseName);
		assertMatchingOptions(derivedOptions, initialOptions, ConnectionFactoryOptions.CONNECT_TIMEOUT,
				ConnectionFactoryOptions.DRIVER, ConnectionFactoryOptions.HOST, ConnectionFactoryOptions.PASSWORD,
				ConnectionFactoryOptions.PORT, ConnectionFactoryOptions.PROTOCOL, ConnectionFactoryOptions.SSL,
				ConnectionFactoryOptions.USER);
	}
	@Test
	void buildWhenDerivedWithNewCredentialsReturnsNewConnectionFactory() {
		ConnectionFactory connectionFactory = ConnectionFactoryBuilder
			.withUrl(EmbeddedDatabaseConnection.H2.getUrl(UUID.randomUUID().toString()))
			.build();
		ConnectionFactoryOptions initialOptions = ((OptionsCapableConnectionFactory) connectionFactory).getOptions();
		ConnectionFactory derived = ConnectionFactoryBuilder.derivedFrom(connectionFactory)
			.username('admin')
			.password('secret')
			.build();
		ConnectionFactoryOptions derivedOptions = ((OptionsCapableConnectionFactory) derived).getOptions();
		assertThat(derivedOptions.getRequiredValue(ConnectionFactoryOptions.USER)).isEqualTo('admin');
		assertThat(derivedOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('secret');
		assertMatchingOptions(derivedOptions, initialOptions, ConnectionFactoryOptions.CONNECT_TIMEOUT,
				ConnectionFactoryOptions.DATABASE, ConnectionFactoryOptions.DRIVER, ConnectionFactoryOptions.HOST,
				ConnectionFactoryOptions.PORT, ConnectionFactoryOptions.PROTOCOL, ConnectionFactoryOptions.SSL);
	}
	@Test
	void buildWhenDerivedFromPoolReturnsNewNonPooledConnectionFactory() {
		ConnectionFactory connectionFactory = ConnectionFactoryBuilder
			.withUrl(EmbeddedDatabaseConnection.H2.getUrl(UUID.randomUUID().toString()))
			.build();
		ConnectionFactoryOptions initialOptions = ((OptionsCapableConnectionFactory) connectionFactory).getOptions();
		ConnectionPoolConfiguration poolConfiguration = ConnectionPoolConfiguration.builder(connectionFactory).build();
		ConnectionPool pool = new ConnectionPool(poolConfiguration);
		ConnectionFactory derived = ConnectionFactoryBuilder.derivedFrom(pool)
			.username('admin')
			.password('secret')
			.build();
		assertThat(derived).isNotInstanceOf(ConnectionPool.class).isInstanceOf(OptionsCapableConnectionFactory.class);
		ConnectionFactoryOptions derivedOptions = ((OptionsCapableConnectionFactory) derived).getOptions();
		assertThat(derivedOptions.getRequiredValue(ConnectionFactoryOptions.USER)).isEqualTo('admin');
		assertThat(derivedOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('secret');
		assertMatchingOptions(derivedOptions, initialOptions, ConnectionFactoryOptions.CONNECT_TIMEOUT,
				ConnectionFactoryOptions.DATABASE, ConnectionFactoryOptions.DRIVER, ConnectionFactoryOptions.HOST,
				ConnectionFactoryOptions.PORT, ConnectionFactoryOptions.PROTOCOL, ConnectionFactoryOptions.SSL);
	}
	@ParameterizedTest
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	@MethodSource('poolingConnectionProviderOptions')
	void optionIsMappedWhenCreatingPoolConfiguration(Option option) {
		String url = 'r2dbc:pool:h2:mem:///' + UUID.randomUUID();
		ExpectedOption expectedOption = ExpectedOption.get(option);
		ConnectionFactoryOptions options = ConnectionFactoryBuilder.withUrl(url)
			.configure((builder) -> builder.option(PoolingConnectionFactoryProvider.POOL_NAME, 'defaultName')
				.option(option, expectedOption.value))
			.buildOptions();
		ConnectionPoolConfiguration configuration = new PoolingAwareOptionsCapableWrapper()
			.connectionPoolConfiguration(options, mock(ConnectionFactory.class));
		assertThat(configuration).extracting(expectedOption.property).isEqualTo(expectedOption.value);
	}
	private static Iterable<Arguments> poolingConnectionProviderOptions() {
		return extractPoolingConnectionProviderOptions((field) -> Option.class.equals(field.getType()));
	}
	@ParameterizedTest
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	@MethodSource('primitivePoolingConnectionProviderOptions')
	void stringlyTypedOptionIsMappedWhenCreatingPoolConfiguration(Option option) {
		String url = 'r2dbc:pool:h2:mem:///' + UUID.randomUUID();
		ExpectedOption expectedOption = ExpectedOption.get(option);
		ConnectionFactoryOptions options = ConnectionFactoryBuilder.withUrl(url)
			.configure((builder) -> builder.option(PoolingConnectionFactoryProvider.POOL_NAME, 'defaultName')
				.option(option, expectedOption.value.toString()))
			.buildOptions();
		ConnectionPoolConfiguration configuration = new PoolingAwareOptionsCapableWrapper()
			.connectionPoolConfiguration(options, mock(ConnectionFactory.class));
		assertThat(configuration).extracting(expectedOption.property).isEqualTo(expectedOption.value);
	}
	@Test
	void shouldApplyDecorators() {
		String url = 'r2dbc:pool:h2:mem:///' + UUID.randomUUID();
		ConnectionFactory connectionFactory = ConnectionFactoryBuilder.withUrl(url)
			.decorator((ignored) -> new MyConnectionFactory())
			.build();
		assertThat(connectionFactory).isInstanceOf(MyConnectionFactory.class);
	}
	private static Iterable<Arguments> primitivePoolingConnectionProviderOptions() {
		return extractPoolingConnectionProviderOptions((field) -> {
			ResolvableType type = ResolvableType.forField(field);
			if (!type.toClass().equals(Option.class)) {
				return false;
			}
			Class<?> valueType = type.as(Option.class).getGenerics()[0].toClass();
			return valueType.getPackage().getName().equals('java.lang');
		});
	}
	private static Iterable<Arguments> extractPoolingConnectionProviderOptions(FieldFilter filter) {
		List<Arguments> arguments = new ArrayList<>();
		ReflectionUtils.doWithFields(PoolingConnectionFactoryProvider.class,
				(field) -> arguments.add(Arguments.of(ReflectionUtils.getField(field, null))), filter);
		return arguments;
	}
	private void assertMatchingOptions(ConnectionFactoryOptions actualOptions, ConnectionFactoryOptions expectedOptions,
			Option<?>... optionsToCheck) {
		for (Option<?> option : optionsToCheck) {
			assertThat(actualOptions.getValue(option)).as(option.name()).isEqualTo(expectedOptions.getValue(option));
		}
	}
	private enum ExpectedOption {
		ACQUIRE_RETRY(PoolingConnectionFactoryProvider.ACQUIRE_RETRY, 4, 'acquireRetry'),
		BACKGROUND_EVICTION_INTERVAL(PoolingConnectionFactoryProvider.BACKGROUND_EVICTION_INTERVAL,
				Duration.ofSeconds(120), 'backgroundEvictionInterval'),
		INITIAL_SIZE(PoolingConnectionFactoryProvider.INITIAL_SIZE, 2, 'initialSize'),
		MAX_SIZE(PoolingConnectionFactoryProvider.MAX_SIZE, 8, 'maxSize'),
		MAX_LIFE_TIME(PoolingConnectionFactoryProvider.MAX_LIFE_TIME, Duration.ofMinutes(2), 'maxLifeTime'),
		MAX_ACQUIRE_TIME(PoolingConnectionFactoryProvider.MAX_ACQUIRE_TIME, Duration.ofSeconds(30), 'maxAcquireTime'),
		MAX_IDLE_TIME(PoolingConnectionFactoryProvider.MAX_IDLE_TIME, Duration.ofMinutes(1), 'maxIdleTime'),
		MAX_CREATE_CONNECTION_TIME(PoolingConnectionFactoryProvider.MAX_CREATE_CONNECTION_TIME, Duration.ofSeconds(10),
				'maxCreateConnectionTime'),
		MAX_VALIDATION_TIME(PoolingConnectionFactoryProvider.MAX_VALIDATION_TIME, Duration.ofMinutes(4),
				'maxValidationTime'),
		MIN_IDLE(PoolingConnectionFactoryProvider.MIN_IDLE, 5, 'minIdle'),
		POOL_NAME(PoolingConnectionFactoryProvider.POOL_NAME, 'testPool', 'name'),
		POST_ALLOCATE(PoolingConnectionFactoryProvider.POST_ALLOCATE, mock(Function.class), 'postAllocate'),
		PRE_RELEASE(PoolingConnectionFactoryProvider.PRE_RELEASE, mock(Function.class), 'preRelease'),
		REGISTER_JMX(PoolingConnectionFactoryProvider.REGISTER_JMX, true, 'registerJmx'),
		VALIDATION_QUERY(PoolingConnectionFactoryProvider.VALIDATION_QUERY, 'SELECT 1', 'validationQuery'),
		VALIDATION_DEPTH(PoolingConnectionFactoryProvider.VALIDATION_DEPTH, ValidationDepth.REMOTE, 'validationDepth');
		private final Option<?> option;
		private final Object value;
		private final String property;
		ExpectedOption(Option<?> option, Object value, String property) {
			this.option = option;
			this.value = value;
			this.property = property;
		}
		static ExpectedOption get(Option<?> option) {
			for (ExpectedOption expectedOption : values()) {
				if (expectedOption.option == option) {
					return expectedOption;
				}
			}
			throw new IllegalArgumentException('Unexpected option: "' + option + '"');
		}
	}
	private static final class MyConnectionFactory implements ConnectionFactory {
		@Override
		public Publisher<? extends Connection> create() {
			return null;
		}
		@Override
		public ConnectionFactoryMetadata getMetadata() {
			return null;
		}
	}
}
/*
package org.springframework.boot.r2dbc.init;
/**
class R2dbcScriptDatabaseInitializerTests
		extends AbstractScriptDatabaseInitializerTests<R2dbcScriptDatabaseInitializer> {
	private final ConnectionFactory embeddedConnectionFactory = ConnectionFactoryBuilder
		.withUrl('r2dbc:h2:mem:///' + UUID.randomUUID() + '?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
		.build();
	private final ConnectionFactory standaloneConnectionFactory = ConnectionFactoryBuilder
		.withUrl(
				'r2dbc:h2:file:///'
						+ new BuildOutput(R2dbcScriptDatabaseInitializerTests.class).getRootLocation()
							.getAbsolutePath()
							.replace("\\", "/")
						+ '/' + UUID.randomUUID() + '?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
		.build();
	@Override
	protected R2dbcScriptDatabaseInitializer createEmbeddedDatabaseInitializer(
			DatabaseInitializationSettings settings) {
		return new R2dbcScriptDatabaseInitializer(this.embeddedConnectionFactory, settings);
	}
	@Override
	protected R2dbcScriptDatabaseInitializer createStandaloneDatabaseInitializer(
			DatabaseInitializationSettings settings) {
		return new R2dbcScriptDatabaseInitializer(this.standaloneConnectionFactory, settings);
	}
	@Override
	protected int numberOfEmbeddedRows(String sql) {
		return numberOfRows(this.embeddedConnectionFactory, sql);
	}
	@Override
	protected int numberOfStandaloneRows(String sql) {
		return numberOfRows(this.standaloneConnectionFactory, sql);
	}
	private int numberOfRows(ConnectionFactory connectionFactory, String sql) {
		return DatabaseClient.create(connectionFactory)
			.sql(sql)
			.map((row, metadata) -> row.get(0))
			.first()
			.map((number) -> ((Number) number).intValue())
			.block();
	}
	@Override
	protected void assertDatabaseAccessed(boolean accessed, R2dbcScriptDatabaseInitializer initializer) {
		// No-op as R2DBC does not need to access the database to determine its type
	}
}
/*
package org.springframework.boot.rsocket.context;
/**
class RSocketPortInfoApplicationContextInitializerTests {
	@Test
	void whenServerHasAddressThenInitializerSetsPortProperty() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(Config.class)) {
			context.getBean(RSocketPortInfoApplicationContextInitializer.class).initialize(context);
			RSocketServer server = mock(RSocketServer.class);
			given(server.address()).willReturn(new InetSocketAddress(65535));
			context.publishEvent(new RSocketServerInitializedEvent(server));
			assertThat(context.getEnvironment().getProperty('local.rsocket.server.port')).isEqualTo('65535');
		}
	}
	@Test
	void whenServerHasNoAddressThenInitializerDoesNotSetPortProperty() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(Config.class)) {
			context.getBean(RSocketPortInfoApplicationContextInitializer.class).initialize(context);
			RSocketServer server = mock(RSocketServer.class);
			context.publishEvent(new RSocketServerInitializedEvent(server));
			then(server).should().address();
			assertThat(context.getEnvironment().getProperty('local.rsocket.server.port')).isNull();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		RSocketPortInfoApplicationContextInitializer rSocketPortInfoApplicationContextInitializer() {
			return new RSocketPortInfoApplicationContextInitializer();
		}
	}
}
/*
package org.springframework.boot.rsocket.netty;
/**
class NettyRSocketServerFactoryTests {
	private NettyRSocketServer server;
	private RSocketRequester requester;
	@AfterEach
	void tearDown() {
		if (this.requester != null) {
			this.requester.rsocketClient().dispose();
		}
		if (this.server != null) {
			try {
				this.server.stop();
			}
			catch (Exception ex) {
				// Ignore
			}
		}
	}
	private NettyRSocketServerFactory getFactory() {
		NettyRSocketServerFactory factory = new NettyRSocketServerFactory();
		factory.setPort(0);
		return factory;
	}
	@Test
	void specificPort() {
		NettyRSocketServerFactory factory = getFactory();
		int specificPort = doWithRetry(() -> {
			factory.setPort(0);
			this.server = factory.create(new EchoRequestResponseAcceptor());
			this.server.start();
			return this.server.address().getPort();
		});
		this.requester = createRSocketTcpClient();
		assertThat(this.server.address().getPort()).isEqualTo(specificPort);
		checkEchoRequest();
	}
	@Test
	void websocketTransport() {
		NettyRSocketServerFactory factory = getFactory();
		factory.setTransport(RSocketServer.Transport.WEBSOCKET);
		this.server = factory.create(new EchoRequestResponseAcceptor());
		this.server.start();
		this.requester = createRSocketWebSocketClient();
		checkEchoRequest();
	}
	@Test
	void websocketTransportWithReactorResource() {
		NettyRSocketServerFactory factory = getFactory();
		factory.setTransport(RSocketServer.Transport.WEBSOCKET);
		ReactorResourceFactory resourceFactory = new ReactorResourceFactory();
		resourceFactory.afterPropertiesSet();
		factory.setResourceFactory(resourceFactory);
		this.server = factory.create(new EchoRequestResponseAcceptor());
		this.server.start();
		this.requester = createRSocketWebSocketClient();
		checkEchoRequest();
	}
	@Test
	void serverCustomizers() {
		NettyRSocketServerFactory factory = getFactory();
		RSocketServerCustomizer[] customizers = new RSocketServerCustomizer[2];
		for (int i = 0; i < customizers.length; i++) {
			customizers[i] = mock(RSocketServerCustomizer.class);
			will((invocation) -> invocation.getArgument(0)).given(customizers[i])
				.customize(any(io.rsocket.core.RSocketServer.class));
		}
		factory.setRSocketServerCustomizers(Arrays.asList(customizers));
		this.server = factory.create(new EchoRequestResponseAcceptor());
		InOrder ordered = inOrder((Object[]) customizers);
		for (RSocketServerCustomizer customizer : customizers) {
			ordered.verify(customizer).customize(any(io.rsocket.core.RSocketServer.class));
		}
	}
	@Test
	void tcpTransportBasicSslFromClassPath() {
		testBasicSslWithKeyStore('classpath:test.jks', 'password', Transport.TCP);
	}
	@Test
	void tcpTransportBasicSslFromFileSystem() {
		testBasicSslWithKeyStore('src/test/resources/test.jks', 'password', Transport.TCP);
	}
	@Test
	void websocketTransportBasicSslFromClassPath() {
		testBasicSslWithKeyStore('classpath:test.jks', 'password', Transport.WEBSOCKET);
	}
	@Test
	void websocketTransportBasicSslFromFileSystem() {
		testBasicSslWithKeyStore('src/test/resources/test.jks', 'password', Transport.WEBSOCKET);
	}
	@Test
	void tcpTransportBasicSslCertificateFromClassPath() {
		testBasicSslWithPemCertificate('classpath:test-cert.pem', 'classpath:test-key.pem', 'classpath:test-cert.pem',
				Transport.TCP);
	}
	@Test
	void tcpTransportBasicSslCertificateFromFileSystem() {
		testBasicSslWithPemCertificate('src/test/resources/test-cert.pem', 'src/test/resources/test-key.pem',
				'src/test/resources/test-cert.pem', Transport.TCP);
	}
	@Test
	void websocketTransportBasicSslCertificateFromClassPath() {
		testBasicSslWithPemCertificate('classpath:test-cert.pem', 'classpath:test-key.pem', 'classpath:test-cert.pem',
				Transport.WEBSOCKET);
	}
	@Test
	void websocketTransportBasicSslCertificateFromFileSystem() {
		testBasicSslWithPemCertificate('src/test/resources/test-cert.pem', 'src/test/resources/test-key.pem',
				'src/test/resources/test-cert.pem', Transport.WEBSOCKET);
	}
	@Test
	void tcpTransportBasicSslFromClassPathWithBundle() {
		testBasicSslWithKeyStoreFromBundle('classpath:test.jks', 'password', Transport.TCP);
	}
	@Test
	void tcpTransportBasicSslFromFileSystemWithBundle() {
		testBasicSslWithKeyStoreFromBundle('src/test/resources/test.jks', 'password', Transport.TCP);
	}
	@Test
	void websocketTransportBasicSslFromClassPathWithBundle() {
		testBasicSslWithKeyStoreFromBundle('classpath:test.jks', 'password', Transport.WEBSOCKET);
	}
	@Test
	void websocketTransportBasicSslFromFileSystemWithBundle() {
		testBasicSslWithKeyStoreFromBundle('src/test/resources/test.jks', 'password', Transport.WEBSOCKET);
	}
	@Test
	void tcpTransportBasicSslCertificateFromClassPathWithBundle() {
		testBasicSslWithPemCertificateFromBundle('classpath:test-cert.pem', 'classpath:test-key.pem',
				'classpath:test-cert.pem', Transport.TCP);
	}
	@Test
	void tcpTransportBasicSslCertificateFromFileSystemWithBundle() {
		testBasicSslWithPemCertificateFromBundle('src/test/resources/test-cert.pem', 'src/test/resources/test-key.pem',
				'src/test/resources/test-cert.pem', Transport.TCP);
	}
	@Test
	void websocketTransportBasicSslCertificateFromClassPathWithBundle() {
		testBasicSslWithPemCertificateFromBundle('classpath:test-cert.pem', 'classpath:test-key.pem',
				'classpath:test-cert.pem', Transport.WEBSOCKET);
	}
	@Test
	void websocketTransportBasicSslCertificateFromFileSystemWithBundle() {
		testBasicSslWithPemCertificateFromBundle('src/test/resources/test-cert.pem', 'src/test/resources/test-key.pem',
				'src/test/resources/test-cert.pem', Transport.WEBSOCKET);
	}
	private void checkEchoRequest() {
		String payload = 'test payload';
		Mono<String> response = this.requester.route('test').data(payload).retrieveMono(String.class);
		StepVerifier.create(response).expectNext(payload).expectComplete().verify(Duration.ofSeconds(30));
	}
	private void testBasicSslWithKeyStore(String keyStore, String keyPassword, Transport transport) {
		NettyRSocketServerFactory factory = getFactory();
		factory.setTransport(transport);
		Ssl ssl = new Ssl();
		ssl.setKeyStore(keyStore);
		ssl.setKeyPassword(keyPassword);
		factory.setSsl(ssl);
		this.server = factory.create(new EchoRequestResponseAcceptor());
		this.server.start();
		this.requester = (transport == Transport.TCP) ? createSecureRSocketTcpClient()
				: createSecureRSocketWebSocketClient();
		checkEchoRequest();
	}
	private void testBasicSslWithPemCertificate(String certificate, String certificatePrivateKey,
			String trustCertificate, Transport transport) {
		NettyRSocketServerFactory factory = getFactory();
		factory.setTransport(transport);
		Ssl ssl = new Ssl();
		ssl.setCertificate(certificate);
		ssl.setCertificatePrivateKey(certificatePrivateKey);
		ssl.setTrustCertificate(trustCertificate);
		ssl.setKeyStorePassword('');
		factory.setSsl(ssl);
		this.server = factory.create(new EchoRequestResponseAcceptor());
		this.server.start();
		this.requester = (transport == Transport.TCP) ? createSecureRSocketTcpClient()
				: createSecureRSocketWebSocketClient();
		checkEchoRequest();
	}
	private void testBasicSslWithKeyStoreFromBundle(String keyStore, String keyPassword, Transport transport) {
		NettyRSocketServerFactory factory = getFactory();
		factory.setTransport(transport);
		JksSslStoreDetails keyStoreDetails = JksSslStoreDetails.forLocation(keyStore);
		JksSslStoreDetails trustStoreDetails = null;
		SslBundle sslBundle = SslBundle.of(new JksSslStoreBundle(keyStoreDetails, trustStoreDetails),
				SslBundleKey.of(keyPassword));
		factory.setSsl(Ssl.forBundle('test'));
		factory.setSslBundles(new DefaultSslBundleRegistry('test', sslBundle));
		this.server = factory.create(new EchoRequestResponseAcceptor());
		this.server.start();
		this.requester = (transport == Transport.TCP) ? createSecureRSocketTcpClient()
				: createSecureRSocketWebSocketClient();
		checkEchoRequest();
	}
	private void testBasicSslWithPemCertificateFromBundle(String certificate, String certificatePrivateKey,
			String trustCertificate, Transport transport) {
		NettyRSocketServerFactory factory = getFactory();
		factory.setTransport(transport);
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate(certificate)
			.withPrivateKey(certificatePrivateKey);
		PemSslStoreDetails trustStoreDetails = PemSslStoreDetails.forCertificate(trustCertificate);
		SslBundle sslBundle = SslBundle.of(new PemSslStoreBundle(keyStoreDetails, trustStoreDetails));
		factory.setSsl(Ssl.forBundle('test'));
		factory.setSslBundles(new DefaultSslBundleRegistry('test', sslBundle));
		this.server = factory.create(new EchoRequestResponseAcceptor());
		this.server.start();
		this.requester = (transport == Transport.TCP) ? createSecureRSocketTcpClient()
				: createSecureRSocketWebSocketClient();
		checkEchoRequest();
	}
	@Test
	void tcpTransportSslRejectsInsecureClient() {
		NettyRSocketServerFactory factory = getFactory();
		factory.setTransport(Transport.TCP);
		Ssl ssl = new Ssl();
		ssl.setKeyStore('classpath:test.jks');
		ssl.setKeyPassword('password');
		factory.setSsl(ssl);
		this.server = factory.create(new EchoRequestResponseAcceptor());
		this.server.start();
		this.requester = createRSocketTcpClient();
		String payload = 'test payload';
		Mono<String> responseMono = this.requester.route('test').data(payload).retrieveMono(String.class);
		StepVerifier.create(responseMono)
			.verifyErrorSatisfies((ex) -> assertThat(ex).isInstanceOf(ClosedChannelException.class));
	}
	private RSocketRequester createRSocketTcpClient() {
		return createRSocketRequesterBuilder().transport(TcpClientTransport.create(createTcpClient()));
	}
	private RSocketRequester createRSocketWebSocketClient() {
		return createRSocketRequesterBuilder().transport(WebsocketClientTransport.create(createHttpClient(), '/'));
	}
	private RSocketRequester createSecureRSocketTcpClient() {
		return createRSocketRequesterBuilder().transport(TcpClientTransport.create(createSecureTcpClient()));
	}
	private RSocketRequester createSecureRSocketWebSocketClient() {
		return createRSocketRequesterBuilder()
			.transport(WebsocketClientTransport.create(createSecureHttpClient(), '/'));
	}
	private HttpClient createSecureHttpClient() {
		HttpClient httpClient = createHttpClient();
		GenericSslContextSpec<?> sslContextSpec = Http11SslContextSpec.forClient()
			.configure((builder) -> builder.sslProvider(SslProvider.JDK)
				.trustManager(InsecureTrustManagerFactory.INSTANCE));
		return httpClient.secure((spec) -> spec.sslContext(sslContextSpec));
	}
	private HttpClient createHttpClient() {
		Assertions.assertThat(this.server).isNotNull();
		InetSocketAddress address = this.server.address();
		return HttpClient.create().host(address.getHostName()).port(address.getPort());
	}
	private TcpClient createSecureTcpClient() {
		TcpClient tcpClient = createTcpClient();
		GenericSslContextSpec<?> sslContextSpec = Http11SslContextSpec.forClient()
			.configure((builder) -> builder.sslProvider(SslProvider.JDK)
				.trustManager(InsecureTrustManagerFactory.INSTANCE));
		return tcpClient.secure((spec) -> spec.sslContext(sslContextSpec));
	}
	private TcpClient createTcpClient() {
		Assertions.assertThat(this.server).isNotNull();
		InetSocketAddress address = this.server.address();
		return TcpClient.create().host(address.getHostName()).port(address.getPort());
	}
	private RSocketRequester.Builder createRSocketRequesterBuilder() {
		RSocketStrategies strategies = RSocketStrategies.builder()
			.decoder(StringDecoder.allMimeTypes())
			.encoder(CharSequenceEncoder.allMimeTypes())
			.dataBufferFactory(new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT))
			.build();
		return RSocketRequester.builder().rsocketStrategies(strategies);
	}
	private <T> T doWithRetry(Callable<T> action) {
		Exception lastFailure = null;
		for (int i = 0; i < 10; i++) {
			try {
				return action.call();
			}
			catch (Exception ex) {
				lastFailure = ex;
			}
		}
		throw new IllegalStateException('Action was not successful in 10 attempts', lastFailure);
	}
	static class EchoRequestResponseAcceptor implements SocketAcceptor {
		@Override
		public Mono<RSocket> accept(ConnectionSetupPayload setupPayload, RSocket rSocket) {
			return Mono.just(new RSocket() {
				@Override
				public Mono<Payload> requestResponse(Payload payload) {
					return Mono.just(DefaultPayload.create(payload));
				}
			});
		}
	}
}
/*
package org.springframework.boot;
/**
public class MockApplicationEnvironment extends MockEnvironment {
	@Override
	protected String doGetActiveProfilesProperty() {
		return null;
	}
	@Override
	protected String doGetDefaultProfilesProperty() {
		return null;
	}
}
/*
package org.springframework.boot.diagnostics;
/**
@ExtendWith(OutputCaptureExtension.class)
class FailureAnalyzersIntegrationTests {
	@Test
	void analysisIsPerformed(CapturedOutput output) {
		assertThatException()
			.isThrownBy(() -> new SpringApplicationBuilder(TestConfiguration.class).web(WebApplicationType.NONE).run());
		assertThat(output).contains('APPLICATION FAILED TO START');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@PostConstruct
		void fail() {
			throw new PortInUseException(8080);
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BeanCurrentlyInCreationFailureAnalyzerTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	private final BeanCurrentlyInCreationFailureAnalyzer analyzer = new BeanCurrentlyInCreationFailureAnalyzer(
			this.context.getBeanFactory());
	@Test
	void cyclicBeanMethods() throws IOException {
		FailureAnalysis analysis = performAnalysis(CyclicBeanMethodsConfiguration.class);
		List<String> lines = readDescriptionLines(analysis);
		assertThat(lines).hasSize(9);
		assertThat(lines.get(0))
			.isEqualTo('The dependencies of some of the beans in the application context form a cycle:');
		assertThat(lines.get(1)).isEmpty();
		assertThat(lines.get(2)).isEqualTo('');
		assertThat(lines.get(3)).startsWith('|  one defined in ' + InnerInnerConfiguration.class.getName());
		assertThat(lines.get(4)).isEqualTo('     ');
		assertThat(lines.get(5)).startsWith('|  two defined in ' + InnerConfiguration.class.getName());
		assertThat(lines.get(6)).isEqualTo('     ');
		assertThat(lines.get(7)).startsWith('|  three defined in ' + CyclicBeanMethodsConfiguration.class.getName());
		assertThat(lines.get(8)).isEqualTo('');
		assertThat(analysis.getAction()).isNotNull();
	}
	@Test
	void cycleWithAutowiredFields() throws IOException {
		FailureAnalysis analysis = performAnalysis(CycleWithAutowiredFields.class);
		assertThat(analysis.getDescription())
			.startsWith('The dependencies of some of the beans in the application context form a cycle:');
		List<String> lines = readDescriptionLines(analysis);
		assertThat(lines).hasSize(9);
		assertThat(lines.get(0))
			.isEqualTo('The dependencies of some of the beans in the application context form a cycle:');
		assertThat(lines.get(1)).isEmpty();
		assertThat(lines.get(2)).isEqualTo('');
		assertThat(lines.get(3)).startsWith('|  three defined in ' + BeanThreeConfiguration.class.getName());
		assertThat(lines.get(4)).isEqualTo('     ');
		assertThat(lines.get(5)).startsWith('|  one defined in ' + CycleWithAutowiredFields.class.getName());
		assertThat(lines.get(6)).isEqualTo('     ');
		assertThat(lines.get(7))
			.startsWith('|  ' + BeanTwoConfiguration.class.getName() + ' (field private ' + BeanThree.class.getName());
		assertThat(lines.get(8)).isEqualTo('');
		assertThat(analysis.getAction()).isNotNull();
	}
	@Test
	void cycleReferencedViaOtherBeans() throws IOException {
		FailureAnalysis analysis = performAnalysis(CycleReferencedViaOtherBeansConfiguration.class);
		List<String> lines = readDescriptionLines(analysis);
		assertThat(lines).hasSize(12);
		assertThat(lines.get(0))
			.isEqualTo('The dependencies of some of the beans in the application context form a cycle:');
		assertThat(lines.get(1)).isEmpty();
		assertThat(lines.get(2)).contains('refererOne (field ' + RefererTwo.class.getName());
		assertThat(lines.get(3)).isEqualTo('      ');
		assertThat(lines.get(4)).contains('refererTwo (field ' + BeanOne.class.getName());
		assertThat(lines.get(5)).isEqualTo('');
		assertThat(lines.get(6))
			.startsWith('|  one defined in ' + CycleReferencedViaOtherBeansConfiguration.class.getName());
		assertThat(lines.get(7)).isEqualTo('     ');
		assertThat(lines.get(8))
			.startsWith('|  two defined in ' + CycleReferencedViaOtherBeansConfiguration.class.getName());
		assertThat(lines.get(9)).isEqualTo('     ');
		assertThat(lines.get(10))
			.startsWith('|  three defined in ' + CycleReferencedViaOtherBeansConfiguration.class.getName());
		assertThat(lines.get(11)).isEqualTo('');
		assertThat(analysis.getAction()).isNotNull();
	}
	@Test
	void testSelfReferenceCycle() throws IOException {
		FailureAnalysis analysis = performAnalysis(SelfReferenceBeanConfiguration.class);
		List<String> lines = readDescriptionLines(analysis);
		assertThat(lines).hasSize(5);
		assertThat(lines.get(0))
			.isEqualTo('The dependencies of some of the beans in the application context form a cycle:');
		assertThat(lines.get(1)).isEmpty();
		assertThat(lines.get(2)).isEqualTo('->');
		assertThat(lines.get(3)).startsWith('|  bean defined in ' + SelfReferenceBeanConfiguration.class.getName());
		assertThat(lines.get(4)).isEqualTo('<-');
		assertThat(analysis.getAction()).isNotNull();
	}
	@Test
	void cycleWithAnUnknownStartIsNotAnalyzed() {
		assertThat(this.analyzer.analyze(new BeanCurrentlyInCreationException('test'))).isNull();
	}
	@Test
	void cycleWithCircularReferencesAllowed() {
		FailureAnalysis analysis = performAnalysis(CyclicBeanMethodsConfiguration.class, true);
		assertThat(analysis.getAction()).contains('Despite circular references being allowed');
	}
	@Test
	void cycleWithCircularReferencesProhibited() {
		FailureAnalysis analysis = performAnalysis(CyclicBeanMethodsConfiguration.class, false);
		assertThat(analysis.getAction()).contains('As a last resort');
	}
	private List<String> readDescriptionLines(FailureAnalysis analysis) throws IOException {
		try (BufferedReader reader = new BufferedReader(new StringReader(analysis.getDescription()))) {
			return reader.lines().toList();
		}
	}
	private FailureAnalysis performAnalysis(Class<?> configuration) {
		return performAnalysis(configuration, true);
	}
	private FailureAnalysis performAnalysis(Class<?> configuration, boolean allowCircularReferences) {
		FailureAnalysis analysis = this.analyzer.analyze(createFailure(configuration, allowCircularReferences));
		assertThat(analysis).isNotNull();
		return analysis;
	}
	private Exception createFailure(Class<?> configuration, boolean allowCircularReferences) {
		try {
			this.context.register(configuration);
			AbstractAutowireCapableBeanFactory beanFactory = (AbstractAutowireCapableBeanFactory) this.context
				.getBeanFactory();
			beanFactory.setAllowCircularReferences(allowCircularReferences);
			this.context.refresh();
			fail('Expected failure did not occur');
			return null;
		}
		catch (Exception ex) {
			return ex;
		}
	}
	@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
	static class CyclicBeanMethodsConfiguration {
		@Bean
		BeanThree three(BeanOne one) {
			return new BeanThree();
		}
		@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
		static class InnerConfiguration {
			@Bean
			BeanTwo two(BeanThree three) {
				return new BeanTwo();
			}
			@Configuration(proxyBeanMethods = false)
			static class InnerInnerConfiguration {
				@Bean
				BeanOne one(BeanTwo two) {
					return new BeanOne();
				}
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CycleReferencedViaOtherBeansConfiguration {
		@Bean
		BeanOne one(BeanTwo two) {
			return new BeanOne();
		}
		@Bean
		BeanTwo two(BeanThree three) {
			return new BeanTwo();
		}
		@Bean
		BeanThree three(BeanOne beanOne) {
			return new BeanThree();
		}
		@Configuration(proxyBeanMethods = false)
		static class InnerConfiguration {
			@Bean
			RefererTwo refererTwo() {
				return new RefererTwo();
			}
			@Configuration(proxyBeanMethods = false)
			static class InnerInnerConfiguration {
				@Bean
				RefererOne refererOne() {
					return new RefererOne();
				}
			}
		}
	}
	@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
	static class CycleWithAutowiredFields {
		@Bean
		BeanOne one(BeanTwo two) {
			return new BeanOne();
		}
		@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
		static class BeanTwoConfiguration {
			@SuppressWarnings('unused')
			@Autowired
			private BeanThree three;
			@Bean
			BeanTwo two() {
				return new BeanTwo();
			}
		}
		@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
		static class BeanThreeConfiguration {
			@Bean
			BeanThree three(BeanOne one) {
				return new BeanThree();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SelfReferenceBeanConfiguration {
		@Bean
		SelfReferenceBean bean(SelfReferenceBean bean) {
			return new SelfReferenceBean();
		}
	}
	static class RefererOne {
		@Autowired
		RefererTwo refererTwo;
	}
	static class RefererTwo {
		@Autowired
		BeanOne beanOne;
	}
	static class BeanOne {
	}
	static class BeanTwo {
	}
	static class BeanThree {
	}
	static class SelfReferenceBean {
		@Autowired
		SelfReferenceBean bean;
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class MissingParameterNamesFailureAnalyzerTests {
	@Test
	void analyzeWhenMissingParametersExceptionReturnsFailure() throws Exception {
		MissingParameterNamesFailureAnalyzer analyzer = new MissingParameterNamesFailureAnalyzer();
		FailureAnalysis analysis = analyzer.analyze(getSpringFrameworkMissingParameterException());
		assertThat(analysis.getDescription())
			.isEqualTo(String.format('Name for argument of type [java.lang.String] not specified, and parameter name '
					+ 'information not available via reflection. Ensure that the compiler uses the "-parameters" flag.:%n'));
		assertThat(analysis.getAction()).isEqualTo(MissingParameterNamesFailureAnalyzer.ACTION);
	}
	@Test
	void analyzeForMissingParametersWhenMissingParametersExceptionReturnsFailure() throws Exception {
		FailureAnalysis analysis = MissingParameterNamesFailureAnalyzer
			.analyzeForMissingParameters(getSpringFrameworkMissingParameterException());
		assertThat(analysis.getDescription())
			.isEqualTo(String.format('Name for argument of type [java.lang.String] not specified, and parameter name '
					+ 'information not available via reflection. Ensure that the compiler uses the "-parameters" flag.:%n'));
		assertThat(analysis.getAction()).isEqualTo(MissingParameterNamesFailureAnalyzer.ACTION);
	}
	@Test
	void analyzeForMissingParametersWhenInCauseReturnsFailure() throws Exception {
		RuntimeException exception = new RuntimeException('Badness', getSpringFrameworkMissingParameterException());
		FailureAnalysis analysis = MissingParameterNamesFailureAnalyzer.analyzeForMissingParameters(exception);
		assertThat(analysis.getDescription())
			.isEqualTo(String.format('Name for argument of type [java.lang.String] not specified, and parameter name '
					+ 'information not available via reflection. Ensure that the compiler uses the "-parameters" flag.:%n%n'
					+ '    Resulting Failure: java.lang.RuntimeException: Badness'));
		assertThat(analysis.getAction()).isEqualTo(MissingParameterNamesFailureAnalyzer.ACTION);
	}
	@Test
	void analyzeForMissingParametersWhenInSuppressedReturnsFailure() throws Exception {
		RuntimeException exception = new RuntimeException('Badness');
		exception.addSuppressed(getSpringFrameworkMissingParameterException());
		FailureAnalysis analysis = MissingParameterNamesFailureAnalyzer.analyzeForMissingParameters(exception);
		assertThat(analysis.getDescription())
			.isEqualTo(String.format('Name for argument of type [java.lang.String] not specified, and parameter name '
					+ 'information not available via reflection. Ensure that the compiler uses the "-parameters" flag.:%n%n'
					+ '    Resulting Failure: java.lang.RuntimeException: Badness'));
		assertThat(analysis.getAction()).isEqualTo(MissingParameterNamesFailureAnalyzer.ACTION);
	}
	@Test
	void analyzeForMissingParametersWhenNotPresentReturnsNull() {
		RuntimeException exception = new RuntimeException('Badness');
		FailureAnalysis analysis = MissingParameterNamesFailureAnalyzer.analyzeForMissingParameters(exception);
		assertThat(analysis).isNull();
	}
	private RuntimeException getSpringFrameworkMissingParameterException() throws Exception {
		MockResolver resolver = new MockResolver();
		Method method = getClass().getDeclaredMethod('example', String.class);
		MethodParameter parameter = new MethodParameter(method, 0);
		try {
			resolver.resolveArgument(parameter, null, null, null);
		}
		catch (RuntimeException ex) {
			return ex;
		}
		throw new AssertionError('Did not throw');
	}
	void example(String name) {
	}
	static class MockResolver extends AbstractNamedValueMethodArgumentResolver {
		@Override
		public boolean supportsParameter(MethodParameter parameter) {
			return true;
		}
		@Override
		protected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {
			return new NamedValueInfo('', false, null);
		}
		@Override
		protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)
				throws Exception {
			return null;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class NoUniqueBeanDefinitionFailureAnalyzerTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	private final NoUniqueBeanDefinitionFailureAnalyzer analyzer = new NoUniqueBeanDefinitionFailureAnalyzer(
			this.context.getBeanFactory());
	@Test
	void failureAnalysisForFieldConsumer() {
		FailureAnalysis failureAnalysis = analyzeFailure(createFailure(FieldConsumer.class));
		assertThat(failureAnalysis.getDescription()).startsWith(
				'Field testBean in ' + FieldConsumer.class.getName() + ' required a single bean, but 6 were found:');
		assertFoundBeans(failureAnalysis);
	}
	@Test
	void failureAnalysisForMethodConsumer() {
		FailureAnalysis failureAnalysis = analyzeFailure(createFailure(MethodConsumer.class));
		assertThat(failureAnalysis.getDescription()).startsWith('Parameter 0 of method consumer in '
				+ MethodConsumer.class.getName() + ' required a single bean, but 6 were found:');
		assertFoundBeans(failureAnalysis);
	}
	@Test
	void failureAnalysisForConstructorConsumer() {
		FailureAnalysis failureAnalysis = analyzeFailure(createFailure(ConstructorConsumer.class));
		assertThat(failureAnalysis.getDescription()).startsWith('Parameter 0 of constructor in '
				+ ConstructorConsumer.class.getName() + ' required a single bean, but 6 were found:');
		assertFoundBeans(failureAnalysis);
	}
	@Test
	void failureAnalysisForObjectProviderMethodConsumer() {
		FailureAnalysis failureAnalysis = analyzeFailure(createFailure(ObjectProviderMethodConsumer.class));
		assertThat(failureAnalysis.getDescription()).startsWith('Method consumer in '
				+ ObjectProviderMethodConsumer.class.getName() + ' required a single bean, but 6 were found:');
		assertFoundBeans(failureAnalysis);
	}
	@Test
	void failureAnalysisForXmlConsumer() {
		FailureAnalysis failureAnalysis = analyzeFailure(createFailure(XmlConsumer.class));
		assertThat(failureAnalysis.getDescription()).startsWith('Parameter 0 of constructor in '
				+ TestBeanConsumer.class.getName() + ' required a single bean, but 6 were found:');
		assertFoundBeans(failureAnalysis);
	}
	@Test
	void failureAnalysisForObjectProviderConstructorConsumer() {
		FailureAnalysis failureAnalysis = analyzeFailure(createFailure(ObjectProviderConstructorConsumer.class));
		assertThat(failureAnalysis.getDescription()).startsWith('Constructor in '
				+ ObjectProviderConstructorConsumer.class.getName() + ' required a single bean, but 6 were found:');
		assertFoundBeans(failureAnalysis);
	}
	@Test
	void failureAnalysisIncludesPossiblyMissingParameterNames() {
		FailureAnalysis failureAnalysis = analyzeFailure(createFailure(MethodConsumer.class));
		assertThat(failureAnalysis.getDescription()).contains(MissingParameterNamesFailureAnalyzer.POSSIBILITY);
		assertThat(failureAnalysis.getAction()).contains(MissingParameterNamesFailureAnalyzer.ACTION);
		assertFoundBeans(failureAnalysis);
	}
	@Test
	void failureAnalysisWithoutInjectionPoints() {
		this.context.registerBean('beanOne', TestBean.class);
		this.context.register(DuplicateBeansProducer.class);
		this.context.refresh();
		FailureAnalysis failureAnalysis = analyzeFailure(new NoUniqueBeanDefinitionException(TestBean.class, 3,
				'no TestBeanProvider specified and expected single matching TestBean but found 3: beanOne,beanTwo,xmlBean'));
		assertThat(failureAnalysis.getDescription())
			.startsWith('A component required a single bean, but 3 were found:');
		assertThat(failureAnalysis.getDescription()).contains('beanOne: defined in unknown location');
		assertThat(failureAnalysis.getDescription())
			.contains('beanTwo: defined by method "beanTwo" in ' + DuplicateBeansProducer.class.getName());
		assertThat(failureAnalysis.getDescription()).contains('xmlBean: a programmatically registered singleton');
	}
	private BeanCreationException createFailure(Class<?> consumer) {
		this.context.registerBean('beanOne', TestBean.class);
		this.context.register(DuplicateBeansProducer.class, consumer);
		this.context.setParent(new AnnotationConfigApplicationContext(ParentProducer.class));
		try {
			this.context.refresh();
		}
		catch (BeanCreationException ex) {
			return ex;
		}
		return null;
	}
	private FailureAnalysis analyzeFailure(Exception failure) {
		return this.analyzer.analyze(failure);
	}
	private void assertFoundBeans(FailureAnalysis analysis) {
		assertThat(analysis.getDescription()).contains('beanOne: defined in unknown location');
		assertThat(analysis.getDescription())
			.contains('beanTwo: defined by method "beanTwo" in ' + DuplicateBeansProducer.class.getName());
		assertThat(analysis.getDescription())
			.contains('beanThree: defined by method "beanThree" in ' + ParentProducer.class.getName());
		assertThat(analysis.getDescription()).contains('barTestBean');
		assertThat(analysis.getDescription()).contains('fooTestBean');
		assertThat(analysis.getDescription()).contains('xmlTestBean');
	}
	@Configuration(proxyBeanMethods = false)
	@ComponentScan(basePackageClasses = TestBean.class)
	@ImportResource('/org/springframework/boot/diagnostics/analyzer/nounique/producer.xml')
	static class DuplicateBeansProducer {
		@Bean
		TestBean beanTwo() {
			return new TestBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParentProducer {
		@Bean
		TestBean beanThree() {
			return new TestBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FieldConsumer {
		@SuppressWarnings('unused')
		@Autowired
		private TestBean testBean;
	}
	@Configuration(proxyBeanMethods = false)
	static class ObjectProviderConstructorConsumer {
		ObjectProviderConstructorConsumer(ObjectProvider<TestBean> objectProvider) {
			objectProvider.getIfAvailable();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConstructorConsumer {
		ConstructorConsumer(TestBean testBean) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MethodConsumer {
		@Bean
		String consumer(TestBean testBean) {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ObjectProviderMethodConsumer {
		@Bean
		String consumer(ObjectProvider<TestBean> testBeanProvider) {
			testBeanProvider.getIfAvailable();
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportResource('/org/springframework/boot/diagnostics/analyzer/nounique/consumer.xml')
	static class XmlConsumer {
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class UnboundConfigurationPropertyFailureAnalyzerTests {
	@BeforeEach
	void setup() {
		LocaleContextHolder.setLocale(Locale.US);
	}
	@AfterEach
	void cleanup() {
		LocaleContextHolder.resetLocaleContext();
	}
	@Test
	void bindExceptionDueToUnboundElements() {
		FailureAnalysis analysis = performAnalysis(UnboundElementsFailureConfiguration.class,
				'test.foo.listValue[0]=hello', 'test.foo.listValue[2]=world');
		assertThat(analysis.getDescription()).contains(
				failure('test.foo.listvalue[2]', 'world', '\'test.foo.listValue[2]\' from property source \'test\'',
						'The elements [test.foo.listvalue[2]] were left unbound.'));
	}
	private static String failure(String property, String value, String origin, String reason) {
		return String.format('Property: %s%n    Value: \'%s\'%n    Origin: %s%n    Reason: %s', property, value, origin,
				reason);
	}
	private FailureAnalysis performAnalysis(Class<?> configuration, String... environment) {
		BeanCreationException failure = createFailure(configuration, environment);
		assertThat(failure).isNotNull();
		return new UnboundConfigurationPropertyFailureAnalyzer().analyze(failure);
	}
	private BeanCreationException createFailure(Class<?> configuration, String... environment) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			addEnvironment(context, environment);
			context.register(configuration);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	private void addEnvironment(AnnotationConfigApplicationContext context, String[] environment) {
		MutablePropertySources sources = context.getEnvironment().getPropertySources();
		Map<String, Object> map = new HashMap<>();
		for (String pair : environment) {
			int index = pair.indexOf("=");
			String key = (index > 0) ? pair.substring(0, index) : pair;
			String value = (index > 0) ? pair.substring(index + 1) : '';
			map.put(key.trim(), value.trim());
		}
		sources.addFirst(new MapPropertySource('test', map));
	}
	@EnableConfigurationProperties(UnboundElementsFailureProperties.class)
	static class UnboundElementsFailureConfiguration {
	}
	@ConfigurationProperties('test.foo')
	static class UnboundElementsFailureProperties {
		private List<String> listValue;
		List<String> getListValue() {
			return this.listValue;
		}
		void setListValue(List<String> listValue) {
			this.listValue = listValue;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BeanDefinitionOverrideFailureAnalyzerTests {
	@Test
	void analyzeBeanDefinitionOverrideException() {
		FailureAnalysis analysis = performAnalysis(BeanOverrideConfiguration.class);
		String description = analysis.getDescription();
		assertThat(description).contains('The bean "testBean", defined in ' + SecondConfiguration.class.getName()
				+ ', could not be registered.');
		assertThat(description).contains(FirstConfiguration.class.getName());
	}
	@Test
	void analyzeBeanDefinitionOverrideExceptionWithDefinitionsWithNoResourceDescription() {
		FailureAnalysis analysis = performAnalysis((context) -> {
			context.registerBean('testBean', String.class, (Supplier<String>) String::new);
			context.registerBean('testBean', String.class, (Supplier<String>) String::new);
		});
		String description = analysis.getDescription();
		assertThat(description)
			.isEqualTo('The bean "testBean" could not be registered. A bean with that name has already'
					+ ' been defined and overriding is disabled.');
	}
	private FailureAnalysis performAnalysis(Class<?> configuration) {
		BeanDefinitionOverrideException failure = createFailure(configuration);
		assertThat(failure).isNotNull();
		return new BeanDefinitionOverrideFailureAnalyzer().analyze(failure);
	}
	private BeanDefinitionOverrideException createFailure(Class<?> configuration) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			context.setAllowBeanDefinitionOverriding(false);
			context.register(configuration);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanDefinitionOverrideException ex) {
			return ex;
		}
	}
	private FailureAnalysis performAnalysis(
			ApplicationContextInitializer<AnnotationConfigApplicationContext> initializer) {
		BeanDefinitionOverrideException failure = createFailure(initializer);
		assertThat(failure).isNotNull();
		return new BeanDefinitionOverrideFailureAnalyzer().analyze(failure);
	}
	private BeanDefinitionOverrideException createFailure(
			ApplicationContextInitializer<AnnotationConfigApplicationContext> initializer) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			context.setAllowBeanDefinitionOverriding(false);
			initializer.initialize(context);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanDefinitionOverrideException ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ FirstConfiguration.class, SecondConfiguration.class })
	static class BeanOverrideConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class FirstConfiguration {
		@Bean
		String testBean() {
			return 'test';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SecondConfiguration {
		@Bean
		String testBean() {
			return 'test';
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BindValidationFailureAnalyzerTests {
	@BeforeEach
	void setup() {
		LocaleContextHolder.setLocale(Locale.US);
	}
	@AfterEach
	void cleanup() {
		LocaleContextHolder.resetLocaleContext();
	}
	@Test
	void bindExceptionWithFieldErrorsDueToValidationFailure() {
		FailureAnalysis analysis = performAnalysis(FieldValidationFailureConfiguration.class);
		assertThat(analysis.getDescription()).contains(failure('test.foo.foo', 'null', 'must not be null'))
			.contains(failure('test.foo.value', '0', 'at least five'))
			.contains(failure('test.foo.nested.bar', 'null', 'must not be null'))
			.contains(
					'Binding to target org.springframework.boot.diagnostics.analyzer.BindValidationFailureAnalyzerTests$FieldValidationFailureProperties failed:');
	}
	@Test
	void bindExceptionWithOriginDueToValidationFailure() {
		FailureAnalysis analysis = performAnalysis(FieldValidationFailureConfiguration.class, 'test.foo.value=4');
		assertThat(analysis.getDescription()).contains('Origin: \'test.foo.value\' from property source \'test\'');
	}
	@Test
	void bindExceptionWithObjectErrorsDueToValidationFailure() {
		FailureAnalysis analysis = performAnalysis(ObjectValidationFailureConfiguration.class);
		assertThat(analysis.getDescription()).contains('Reason: This object could not be bound.');
	}
	@Test
	void otherBindExceptionShouldReturnAnalysis() {
		BindException cause = new BindException(new FieldValidationFailureProperties(),
				'fieldValidationFailureProperties');
		cause.addError(new FieldError('test', 'value', 'must not be null'));
		BeanCreationException rootFailure = new BeanCreationException('bean creation failure', cause);
		FailureAnalysis analysis = new BindValidationFailureAnalyzer().analyze(rootFailure, rootFailure);
		assertThat(analysis.getDescription()).contains(failure('test.value', 'null', 'must not be null'));
	}
	private static String failure(String property, String value, String reason) {
		return String.format('Property: %s%n    Value: \'%s\'%n    Reason: %s', property, value, reason);
	}
	private FailureAnalysis performAnalysis(Class<?> configuration, String... environment) {
		BeanCreationException failure = createFailure(configuration, environment);
		assertThat(failure).isNotNull();
		return new BindValidationFailureAnalyzer().analyze(failure);
	}
	private BeanCreationException createFailure(Class<?> configuration, String... environment) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			addEnvironment(context, environment);
			context.register(configuration);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	private void addEnvironment(AnnotationConfigApplicationContext context, String[] environment) {
		MutablePropertySources sources = context.getEnvironment().getPropertySources();
		Map<String, Object> map = new HashMap<>();
		for (String pair : environment) {
			int index = pair.indexOf("=");
			String key = (index > 0) ? pair.substring(0, index) : pair;
			String value = (index > 0) ? pair.substring(index + 1) : '';
			map.put(key.trim(), value.trim());
		}
		sources.addFirst(new MapPropertySource('test', map));
	}
	@EnableConfigurationProperties(FieldValidationFailureProperties.class)
	static class FieldValidationFailureConfiguration {
	}
	@EnableConfigurationProperties(ObjectErrorFailureProperties.class)
	static class ObjectValidationFailureConfiguration {
	}
	@ConfigurationProperties('test.foo')
	@Validated
	static class FieldValidationFailureProperties {
		@NotNull
		private String foo;
		@Min(value = 5, message = 'at least five')
		private int value;
		@Valid
		private FieldValidationFailureProperties.Nested nested = new FieldValidationFailureProperties.Nested();
		String getFoo() {
			return this.foo;
		}
		void setFoo(String foo) {
			this.foo = foo;
		}
		int getValue() {
			return this.value;
		}
		void setValue(int value) {
			this.value = value;
		}
		FieldValidationFailureProperties.Nested getNested() {
			return this.nested;
		}
		void setNested(FieldValidationFailureProperties.Nested nested) {
			this.nested = nested;
		}
		static class Nested {
			@NotNull
			private String bar;
			String getBar() {
				return this.bar;
			}
			void setBar(String bar) {
				this.bar = bar;
			}
		}
	}
	@ConfigurationProperties('foo.bar')
	@Validated
	static class ObjectErrorFailureProperties implements Validator {
		@Override
		public void validate(Object target, Errors errors) {
			errors.reject('my.objectError', 'This object could not be bound.');
		}
		@Override
		public boolean supports(Class<?> type) {
			return true;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
@ClassPathOverrides({ 'org.springframework:spring-core:5.3.12',
		'org.springframework.data:spring-data-relational:1.1.7.RELEASE' })
class NoSuchMethodFailureAnalyzerTests {
	@Test
	void parseHotspotErrorMessage() {
		NoSuchMethodDescriptor descriptor = new NoSuchMethodFailureAnalyzer().getNoSuchMethodDescriptor(
				'"boolean org.springframework.util.MimeType.isMoreSpecific(org.springframework.util.MimeType)"');
		assertThat(descriptor).isNotNull();
		assertThat(descriptor.getErrorMessage())
			.isEqualTo('"boolean org.springframework.util.MimeType.isMoreSpecific(org.springframework.util.MimeType)"');
		assertThat(descriptor.getClassName()).isEqualTo('org.springframework.util.MimeType');
		assertThat(descriptor.getCandidateLocations()).hasSizeGreaterThan(1);
		List<ClassDescriptor> typeHierarchy = descriptor.getTypeHierarchy();
		assertThat(typeHierarchy).hasSize(1);
		assertThat(typeHierarchy.get(0).getLocation()).asString().contains('spring-core-5.3.12.jar');
	}
	@Test
	void parseOpenJ9ErrorMessage() {
		NoSuchMethodDescriptor descriptor = new NoSuchMethodFailureAnalyzer().getNoSuchMethodDescriptor(
				'org/springframework/util/MimeType.isMoreSpecific(Lorg/springframework/util/MimeType;)Z '
						+ '(loaded from ...) '
						+ 'called from class org.springframework.boot.diagnostics.analyzer.NoSuchMethodFailureAnalyzerTests '
						+ '(loaded from ... '
						+ 'by org.springframework.boot.testsupport.classpath.ModifiedClassPathClassLoader@e0ce6310).');
		assertThat(descriptor).isNotNull();
		assertThat(descriptor.getErrorMessage())
			.isEqualTo('org/springframework/util/MimeType.isMoreSpecific(Lorg/springframework/util/MimeType;)Z');
		assertThat(descriptor.getClassName()).isEqualTo('org.springframework.util.MimeType');
		assertThat(descriptor.getCandidateLocations()).hasSizeGreaterThan(1);
		List<ClassDescriptor> typeHierarchy = descriptor.getTypeHierarchy();
		assertThat(typeHierarchy).hasSize(1);
		assertThat(typeHierarchy.get(0).getLocation()).asString().contains('spring-core-5.3.12.jar');
	}
	@Test
	void whenAMethodOnAClassIsMissingThenNoSuchMethodErrorIsAnalyzed() {
		Throwable failure = createFailureForMissingMethod();
		assertThat(failure).isNotNull();
		failure.printStackTrace();
		FailureAnalysis analysis = new NoSuchMethodFailureAnalyzer().analyze(failure);
		assertThat(analysis).isNotNull();
		assertThat(analysis.getDescription())
			.contains(NoSuchMethodFailureAnalyzerTests.class.getName() + '.createFailureForMissingMethod(')
			.contains('isMoreSpecific(')
			.contains('calling method"s class, ' + NoSuchMethodFailureAnalyzerTests.class.getName() + ',')
			.contains('called method"s class, org.springframework.util.MimeType,');
		assertThat(analysis.getAction()).contains(NoSuchMethodFailureAnalyzerTests.class.getName())
			.contains('org.springframework.util.MimeType');
	}
	@Test
	void whenAnInheritedMethodIsMissingThenNoSuchMethodErrorIsAnalyzed() {
		Throwable failure = createFailureForMissingInheritedMethod();
		assertThat(failure).isNotNull();
		FailureAnalysis analysis = new NoSuchMethodFailureAnalyzer().analyze(failure);
		assertThat(analysis).isNotNull();
		assertThat(analysis.getDescription()).contains(R2dbcMappingContext.class.getName() + '.<init>(')
			.contains(R2dbcMappingContext.class.getName() + '.setForceQuote(')
			.contains('calling method"s class, org.springframework.data.r2dbc.mapping.R2dbcMappingContext,')
			.contains('called method"s class, org.springframework.data.r2dbc.mapping.R2dbcMappingContext,')
			.contains('    org.springframework.data.r2dbc.mapping.R2dbcMappingContext')
			.contains('    org.springframework.data.relational.core.mapping.RelationalMappingContext')
			.contains('    org.springframework.data.mapping.context.AbstractMappingContext');
		assertThat(analysis.getAction()).contains('org.springframework.data.r2dbc.mapping.R2dbcMappingContext');
	}
	private Throwable createFailureForMissingMethod() {
		try {
			System.out.println(MimeType.class.getProtectionDomain().getCodeSource().getLocation());
			MimeType mimeType = new MimeType('application', 'json');
			System.out.println(mimeType.isMoreSpecific(null));
			return null;
		}
		catch (Throwable ex) {
			return ex;
		}
	}
	private Throwable createFailureForMissingInheritedMethod() {
		try {
			new R2dbcMappingContext();
			return null;
		}
		catch (Throwable ex) {
			return ex;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class AotInitializerNotFoundFailureAnalyzerTests {
	@Test
	void shouldAnalyze() {
		FailureAnalysis analysis = analyze();
		assertThat(analysis.getDescription()).isEqualTo(
				'Startup with AOT mode enabled failed: AOT initializer class org.springframework.boot.diagnostics.analyzer.AotInitializerNotFoundFailureAnalyzerTests__ApplicationContextInitializer could not be found');
		assertThat(analysis.getAction()).isEqualTo(
				'''
						Consider the following:
						\tDid you build the application with enabled AOT processing?
						\tIs the main class org.springframework.boot.diagnostics.analyzer.AotInitializerNotFoundFailureAnalyzerTests correct?
						\tIf you want to run the application in regular mode, remove the system property "spring.aot.enabled"''');
	}
	private FailureAnalysis analyze() {
		return new AotInitializerNotFoundFailureAnalyzer()
			.analyze(new AotInitializerNotFoundException(AotInitializerNotFoundFailureAnalyzerTests.class,
					AotInitializerNotFoundFailureAnalyzerTests.class + '__ApplicationContextInitializer'));
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BeanNotOfRequiredTypeFailureAnalyzerTests {
	private final FailureAnalyzer analyzer = new BeanNotOfRequiredTypeFailureAnalyzer();
	@Test
	void jdkProxyCausesInjectionFailure() {
		FailureAnalysis analysis = performAnalysis(JdkProxyConfiguration.class);
		assertThat(analysis.getDescription()).startsWith('The bean "asyncBean"');
		assertThat(analysis.getDescription())
			.containsPattern('The bean is of type "' + AsyncBean.class.getPackage().getName() + '.\\$Proxy.*"');
		assertThat(analysis.getDescription())
			.contains(String.format('and implements:%n\t') + SomeInterface.class.getName());
		assertThat(analysis.getDescription()).contains('Expected a bean of type "' + AsyncBean.class.getName() + '"');
		assertThat(analysis.getDescription())
			.contains(String.format('which implements:%n\t') + SomeInterface.class.getName());
	}
	private FailureAnalysis performAnalysis(Class<?> configuration) {
		FailureAnalysis analysis = this.analyzer.analyze(createFailure(configuration));
		assertThat(analysis).isNotNull();
		return analysis;
	}
	private Exception createFailure(Class<?> configuration) {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(configuration)) {
			fail('Expected failure did not occur');
			return null;
		}
		catch (Exception ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAsync
	@Import(UserConfiguration.class)
	static class JdkProxyConfiguration {
		@Bean
		AsyncBean asyncBean() {
			return new AsyncBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserConfiguration {
		@Bean
		AsyncBeanUser user(AsyncBean bean) {
			return new AsyncBeanUser(bean);
		}
	}
	static class AsyncBean implements SomeInterface {
		@Async
		void foo() {
		}
		@Override
		public void bar() {
		}
	}
	interface SomeInterface {
		void bar();
	}
	static class AsyncBeanUser {
		AsyncBeanUser(AsyncBean asyncBean) {
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class InvalidConfigurationPropertyNameFailureAnalyzerTests {
	private final InvalidConfigurationPropertyNameFailureAnalyzer analyzer = new InvalidConfigurationPropertyNameFailureAnalyzer();
	@Test
	void analysisWhenRootCauseIsBeanCreationFailureShouldContainBeanName() {
		BeanCreationException failure = createFailure(InvalidPrefixConfiguration.class);
		FailureAnalysis analysis = this.analyzer.analyze(failure);
		assertThat(analysis.getDescription())
			.contains(String.format('%n    Invalid characters: %s%n    Bean: %s%n    Reason: %s', '"F", "P"',
					'invalidPrefixProperties', 'Canonical names should be kebab-case ("-" separated), '
							+ 'lowercase alpha-numeric characters and must start with a letter'));
	}
	private BeanCreationException createFailure(Class<?> configuration) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			context.register(configuration);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(InvalidPrefixProperties.class)
	static class InvalidPrefixConfiguration {
		@Bean(name = 'invalidPrefixProperties')
		InvalidPrefixProperties invalidPrefixProperties() {
			return new InvalidPrefixProperties();
		}
	}
	@ConfigurationProperties('FooPrefix')
	static class InvalidPrefixProperties {
		private String value;
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class BindFailureAnalyzerTests {
	@Test
	void analysisForUnboundElementsIsNull() {
		FailureAnalysis analysis = performAnalysis(UnboundElementsFailureConfiguration.class,
				'test.foo.listValue[0]=hello', 'test.foo.listValue[2]=world');
		assertThat(analysis).isNull();
	}
	@Test
	void analysisForValidationExceptionIsNull() {
		FailureAnalysis analysis = performAnalysis(FieldValidationFailureConfiguration.class, 'test.foo.value=1');
		assertThat(analysis).isNull();
	}
	@Test
	void bindExceptionDueToOtherFailure() {
		FailureAnalysis analysis = performAnalysis(GenericFailureConfiguration.class, 'test.foo.value=alpha');
		assertThat(analysis.getDescription()).contains(failure('test.foo.value', 'alpha',
				'\'test.foo.value\' from property source \'test\'', 'failed to convert java.lang.String to int'));
	}
	@Test
	void bindExceptionForUnknownValueInEnumListsValidValuesInAction() {
		FailureAnalysis analysis = performAnalysis(EnumFailureConfiguration.class, 'test.foo.fruit=apple,strawberry');
		for (Fruit fruit : Fruit.values()) {
			assertThat(analysis.getAction()).contains(fruit.name());
		}
	}
	@Test
	void bindExceptionWithNestedFailureShouldDisplayNestedMessage() {
		FailureAnalysis analysis = performAnalysis(NestedFailureConfiguration.class, 'test.foo.value=hello');
		assertThat(analysis.getDescription()).contains(failure('test.foo.value', 'hello',
				'\'test.foo.value\' from property source \'test\'', 'java.lang.RuntimeException: This is a failure'));
	}
	@Test // gh-27028
	void bindExceptionDueToClassNotFoundConversionFailure() {
		FailureAnalysis analysis = performAnalysis(GenericFailureConfiguration.class,
				'test.foo.type=com.example.Missing');
		assertThat(analysis.getDescription()).contains(failure('test.foo.type', 'com.example.Missing',
				'\'test.foo.type\' from property source \'test\'',
				'failed to convert java.lang.String to java.lang.Class<?> (caused by java.lang.ClassNotFoundException: com.example.Missing'));
	}
	@Test
	void bindExceptionDueToMapConversionFailure() {
		FailureAnalysis analysis = performAnalysis(LoggingLevelFailureConfiguration.class, 'logging.level=debug');
		assertThat(analysis.getDescription()).contains(failure('logging.level', 'debug',
				'\'logging.level\' from property source \'test\'',
				'org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting '
						+ 'from type [java.lang.String] to type [java.util.Map<java.lang.String, '
						+ 'org.springframework.boot.logging.LogLevel>]'));
	}
	@Test
	void bindExceptionWithSuppressedMissingParametersException() {
		BeanCreationException failure = createFailure(GenericFailureConfiguration.class, 'test.foo.value=alpha');
		failure.addSuppressed(new IllegalStateException(
				'Missing parameter names. Ensure that the compiler uses the "-parameters" flag'));
		FailureAnalysis analysis = new BindFailureAnalyzer().analyze(failure);
		assertThat(analysis.getDescription())
			.contains(failure('test.foo.value', 'alpha', '\'test.foo.value\' from property source \'test\'',
					'failed to convert java.lang.String to int'))
			.contains(MissingParameterNamesFailureAnalyzer.POSSIBILITY);
		assertThat(analysis.getAction()).contains(MissingParameterNamesFailureAnalyzer.ACTION);
	}
	private static String failure(String property, String value, String origin, String reason) {
		return String.format('Property: %s%n    Value: \'%s\'%n    Origin: %s%n    Reason: %s', property, value, origin,
				reason);
	}
	private FailureAnalysis performAnalysis(Class<?> configuration, String... environment) {
		BeanCreationException failure = createFailure(configuration, environment);
		assertThat(failure).isNotNull();
		return new BindFailureAnalyzer().analyze(failure);
	}
	private BeanCreationException createFailure(Class<?> configuration, String... environment) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			addEnvironment(context, environment);
			context.register(configuration);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	private void addEnvironment(AnnotationConfigApplicationContext context, String[] environment) {
		MutablePropertySources sources = context.getEnvironment().getPropertySources();
		Map<String, Object> map = new HashMap<>();
		for (String pair : environment) {
			int index = pair.indexOf("=");
			String key = (index > 0) ? pair.substring(0, index) : pair;
			String value = (index > 0) ? pair.substring(index + 1) : '';
			map.put(key.trim(), value.trim());
		}
		sources.addFirst(new MapPropertySource('test', map));
	}
	@EnableConfigurationProperties(BindValidationFailureAnalyzerTests.FieldValidationFailureProperties.class)
	static class FieldValidationFailureConfiguration {
	}
	@EnableConfigurationProperties(UnboundElementsFailureProperties.class)
	static class UnboundElementsFailureConfiguration {
	}
	@EnableConfigurationProperties(GenericFailureProperties.class)
	static class GenericFailureConfiguration {
	}
	@EnableConfigurationProperties(EnumFailureProperties.class)
	static class EnumFailureConfiguration {
	}
	@EnableConfigurationProperties(NestedFailureProperties.class)
	static class NestedFailureConfiguration {
	}
	@EnableConfigurationProperties(LoggingProperties.class)
	static class LoggingLevelFailureConfiguration {
	}
	@ConfigurationProperties('test.foo')
	@Validated
	static class FieldValidationFailureProperties {
		@Min(value = 5, message = 'at least five')
		private int value;
		int getValue() {
			return this.value;
		}
		void setValue(int value) {
			this.value = value;
		}
	}
	@ConfigurationProperties('test.foo')
	static class UnboundElementsFailureProperties {
		private List<String> listValue;
		List<String> getListValue() {
			return this.listValue;
		}
		void setListValue(List<String> listValue) {
			this.listValue = listValue;
		}
	}
	@ConfigurationProperties('test.foo')
	static class GenericFailureProperties {
		private int value;
		private Class<?> type;
		int getValue() {
			return this.value;
		}
		void setValue(int value) {
			this.value = value;
		}
		Class<?> getType() {
			return this.type;
		}
		void setType(Class<?> type) {
			this.type = type;
		}
	}
	@ConfigurationProperties('test.foo')
	static class EnumFailureProperties {
		private Set<Fruit> fruit;
		Set<Fruit> getFruit() {
			return this.fruit;
		}
		void setFruit(Set<Fruit> fruit) {
			this.fruit = fruit;
		}
	}
	@ConfigurationProperties('test.foo')
	static class NestedFailureProperties {
		private String value;
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			throw new RuntimeException('This is a failure');
		}
	}
	@ConfigurationProperties('logging')
	static class LoggingProperties {
		private Map<String, LogLevel> level = new HashMap<>();
		Map<String, LogLevel> getLevel() {
			return this.level;
		}
		void setLevel(Map<String, LogLevel> level) {
			this.level = level;
		}
	}
	enum Fruit {
		APPLE, BANANA, ORANGE
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class MutuallyExclusiveConfigurationPropertiesFailureAnalyzerTests {
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void analyzeWhenEnvironmentIsNullShouldReturnNull() {
		MutuallyExclusiveConfigurationPropertiesException failure = new MutuallyExclusiveConfigurationPropertiesException(
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')),
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')));
		FailureAnalysis failureAnalysis = new MutuallyExclusiveConfigurationPropertiesFailureAnalyzer(null)
			.analyze(failure);
		assertThat(failureAnalysis).isNull();
	}
	@Test
	void analyzeWhenNotAllPropertiesAreInTheEnvironmentShouldReturnNull() {
		MapPropertySource source = new MapPropertySource('test', Collections.singletonMap('com.example.a', 'alpha'));
		this.environment.getPropertySources().addFirst(OriginCapablePropertySource.get(source));
		MutuallyExclusiveConfigurationPropertiesException failure = new MutuallyExclusiveConfigurationPropertiesException(
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')),
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')));
		FailureAnalysis analysis = performAnalysis(failure);
		assertThat(analysis).isNull();
	}
	@Test
	void analyzeWhenAllConfiguredPropertiesAreInTheEnvironmentShouldReturnAnalysis() {
		Map<String, Object> properties = new HashMap<>();
		properties.put('com.example.a', 'alpha');
		properties.put('com.example.b', 'bravo');
		MapPropertySource source = new MapPropertySource('test', properties);
		this.environment.getPropertySources().addFirst(OriginCapablePropertySource.get(source));
		MutuallyExclusiveConfigurationPropertiesException failure = new MutuallyExclusiveConfigurationPropertiesException(
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')),
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')));
		FailureAnalysis analysis = performAnalysis(failure);
		assertThat(analysis.getAction()).isEqualTo(
				'Update your configuration so that only one of the mutually exclusive properties is configured.');
		assertThat(analysis.getDescription()).contains(String.format(
				'The following configuration properties are mutually exclusive:%n%n\tcom.example.a%n\tcom.example.b%n'))
			.contains(
					String.format('However, more than one of those properties has been configured at the same time:%n%n'
							+ '\tcom.example.a (originating from "TestOrigin test")%n'
							+ '\tcom.example.b (originating from "TestOrigin test")%n'));
	}
	@Test
	void analyzeWhenPropertyIsInMultiplePropertySourcesShouldListEachSourceInAnalysis() {
		Map<String, Object> properties = new LinkedHashMap<>();
		properties.put('com.example.a', 'alpha');
		properties.put('com.example.b', 'bravo');
		this.environment.getPropertySources()
			.addFirst(OriginCapablePropertySource.get(new MapPropertySource('test-one', properties)));
		this.environment.getPropertySources()
			.addLast(OriginCapablePropertySource.get(new MapPropertySource('test-two', properties)));
		MutuallyExclusiveConfigurationPropertiesException failure = new MutuallyExclusiveConfigurationPropertiesException(
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')),
				new HashSet<>(Arrays.asList('com.example.a', 'com.example.b')));
		FailureAnalysis analysis = performAnalysis(failure);
		assertThat(analysis.getAction()).isEqualTo(
				'Update your configuration so that only one of the mutually exclusive properties is configured.');
		assertThat(analysis.getDescription()).contains(String.format(
				'The following configuration properties are mutually exclusive:%n%n\tcom.example.a%n\tcom.example.b%n'))
			.contains(
					String.format('However, more than one of those properties has been configured at the same time:%n%n'
							+ '\tcom.example.a (originating from "TestOrigin test-one")%n'
							+ '\tcom.example.a (originating from "TestOrigin test-two")%n'
							+ '\tcom.example.b (originating from "TestOrigin test-one")%n'
							+ '\tcom.example.b (originating from "TestOrigin test-two")%n'));
	}
	private FailureAnalysis performAnalysis(MutuallyExclusiveConfigurationPropertiesException failure) {
		MutuallyExclusiveConfigurationPropertiesFailureAnalyzer analyzer = new MutuallyExclusiveConfigurationPropertiesFailureAnalyzer(
				this.environment);
		return analyzer.analyze(failure);
	}
	static class OriginCapablePropertySource<T> extends EnumerablePropertySource<T> implements OriginLookup<String> {
		private final EnumerablePropertySource<T> propertySource;
		OriginCapablePropertySource(EnumerablePropertySource<T> propertySource) {
			super(propertySource.getName(), propertySource.getSource());
			this.propertySource = propertySource;
		}
		@Override
		public Object getProperty(String name) {
			return this.propertySource.getProperty(name);
		}
		@Override
		public String[] getPropertyNames() {
			return this.propertySource.getPropertyNames();
		}
		@Override
		public Origin getOrigin(String name) {
			return new Origin() {
				@Override
				public String toString() {
					return 'TestOrigin ' + getName();
				}
			};
		}
		static <T> OriginCapablePropertySource<T> get(EnumerablePropertySource<T> propertySource) {
			return new OriginCapablePropertySource<>(propertySource);
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class PatternParseFailureAnalyzerTests {
	private final PathPatternParser parser = new PathPatternParser();
	@Test
	void patternParseFailureQuotesPattern() {
		FailureAnalysis failureAnalysis = performAnalysis('/spring/**/framework');
		assertThat(failureAnalysis.getDescription())
			.contains('Invalid mapping pattern detected:\n' + '/spring/**/framework\n' + '       ^');
		assertThat(failureAnalysis.getAction())
			.contains('Fix this pattern in your application or switch to the legacy parser'
					+ ' implementation with "spring.mvc.pathmatch.matching-strategy=ant_path_matcher".');
	}
	private FailureAnalysis performAnalysis(String pattern) {
		PatternParseException failure = createFailure(pattern);
		assertThat(failure).isNotNull();
		return new PatternParseFailureAnalyzer().analyze(failure);
	}
	PatternParseException createFailure(String pattern) {
		try {
			this.parser.parse(pattern);
			return null;
		}
		catch (PatternParseException ex) {
			return ex;
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer.nounique;
public class TestBeanConsumer {
	TestBeanConsumer(TestBean testBean) {
	}
}
/*
package org.springframework.boot.diagnostics.analyzer.nounique;
public class TestBean {
}
/*
package org.springframework.boot.diagnostics.analyzer.nounique;
@Component
public class FooTestBean extends TestBean {
}
/*
package org.springframework.boot.diagnostics.analyzer.nounique;
@Component
public class BarTestBean extends TestBean {
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
class InvalidConfigurationPropertyValueFailureAnalyzerTests {
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void analysisWithNullEnvironment() {
		InvalidConfigurationPropertyValueException failure = new InvalidConfigurationPropertyValueException(
				'test.property', 'invalid', 'This is not valid.');
		FailureAnalysis analysis = new InvalidConfigurationPropertyValueFailureAnalyzer(null).analyze(failure);
		assertThat(analysis.getDescription())
			.contains('Invalid value "invalid" for configuration property "test.property".');
	}
	@Test
	void analysisWithKnownProperty() {
		MapPropertySource source = new MapPropertySource('test', Collections.singletonMap('test.property', 'invalid'));
		this.environment.getPropertySources().addFirst(OriginCapablePropertySource.get(source));
		InvalidConfigurationPropertyValueException failure = new InvalidConfigurationPropertyValueException(
				'test.property', 'invalid', 'This is not valid.');
		FailureAnalysis analysis = performAnalysis(failure);
		assertCommonParts(failure, analysis);
		assertThat(analysis.getAction()).contains('Review the value of the property with the provided reason.');
		assertThat(analysis.getDescription()).contains('Validation failed for the following reason')
			.contains('This is not valid.')
			.doesNotContain('Additionally, this property is also set');
	}
	@Test
	void analysisWithKnownPropertyAndNoReason() {
		MapPropertySource source = new MapPropertySource('test', Collections.singletonMap('test.property', 'invalid'));
		this.environment.getPropertySources().addFirst(OriginCapablePropertySource.get(source));
		InvalidConfigurationPropertyValueException failure = new InvalidConfigurationPropertyValueException(
				'test.property', 'invalid', null);
		FailureAnalysis analysis = performAnalysis(failure);
		assertThat(analysis.getAction()).contains('Review the value of the property.');
		assertThat(analysis.getDescription()).contains('No reason was provided.')
			.doesNotContain('Additionally, this property is also set');
	}
	@Test
	void analysisWithKnownPropertyAndOtherCandidates() {
		MapPropertySource source = new MapPropertySource('test', Collections.singletonMap('test.property', 'invalid'));
		MapPropertySource additional = new MapPropertySource('additional',
				Collections.singletonMap('test.property', 'valid'));
		MapPropertySource another = new MapPropertySource('another', Collections.singletonMap('test.property', 'test'));
		this.environment.getPropertySources().addFirst(OriginCapablePropertySource.get(source));
		this.environment.getPropertySources().addLast(additional);
		this.environment.getPropertySources().addLast(OriginCapablePropertySource.get(another));
		InvalidConfigurationPropertyValueException failure = new InvalidConfigurationPropertyValueException(
				'test.property', 'invalid', 'This is not valid.');
		FailureAnalysis analysis = performAnalysis(failure);
		assertCommonParts(failure, analysis);
		assertThat(analysis.getAction()).contains('Review the value of the property with the provided reason.');
		assertThat(analysis.getDescription())
			.contains('Additionally, this property is also set in the following property sources:')
			.contains('In "additional" with the value "valid"')
			.contains('In "another" with the value "test" (originating from "TestOrigin test.property")');
	}
	@Test
	void analysisWithUnknownKey() {
		InvalidConfigurationPropertyValueException failure = new InvalidConfigurationPropertyValueException(
				'test.key.not.defined', 'invalid', 'This is not valid.');
		FailureAnalysis analysis = performAnalysis(failure);
		assertThat(analysis.getDescription())
			.contains('Invalid value "invalid" for configuration property "test.key.not.defined".');
	}
	private void assertCommonParts(InvalidConfigurationPropertyValueException failure, FailureAnalysis analysis) {
		assertThat(analysis.getDescription()).contains('test.property')
			.contains('invalid')
			.contains('TestOrigin test.property');
		assertThat(analysis.getCause()).isSameAs(failure);
	}
	private FailureAnalysis performAnalysis(InvalidConfigurationPropertyValueException failure) {
		InvalidConfigurationPropertyValueFailureAnalyzer analyzer = new InvalidConfigurationPropertyValueFailureAnalyzer(
				this.environment);
		return analyzer.analyze(failure);
	}
	static class OriginCapablePropertySource<T> extends EnumerablePropertySource<T> implements OriginLookup<String> {
		private final EnumerablePropertySource<T> propertySource;
		OriginCapablePropertySource(EnumerablePropertySource<T> propertySource) {
			super(propertySource.getName(), propertySource.getSource());
			this.propertySource = propertySource;
		}
		@Override
		public Object getProperty(String name) {
			return this.propertySource.getProperty(name);
		}
		@Override
		public String[] getPropertyNames() {
			return this.propertySource.getPropertyNames();
		}
		@Override
		public Origin getOrigin(String name) {
			return new Origin() {
				@Override
				public String toString() {
					return 'TestOrigin ' + name;
				}
			};
		}
		static <T> OriginCapablePropertySource<T> get(EnumerablePropertySource<T> propertySource) {
			return new OriginCapablePropertySource<>(propertySource);
		}
	}
}
/*
package org.springframework.boot.diagnostics.analyzer;
/**
@ClassPathExclusions('hibernate-validator-*.jar')
class JakartaApiValidationExceptionFailureAnalyzerTests {
	@Test
	void validatedPropertiesTest() {
		assertThatException().isThrownBy(() -> new AnnotationConfigApplicationContext(TestConfiguration.class).close())
			.satisfies((ex) -> assertThat(new ValidationExceptionFailureAnalyzer().analyze(ex)).isNotNull());
	}
	@Test
	void nonValidatedPropertiesTest() {
		new AnnotationConfigApplicationContext(NonValidatedTestConfiguration.class).close();
	}
	@EnableConfigurationProperties(TestProperties.class)
	static class TestConfiguration {
		TestConfiguration(TestProperties testProperties) {
		}
	}
	@ConfigurationProperties('test')
	@Validated
	static class TestProperties {
	}
	@EnableConfigurationProperties(NonValidatedTestProperties.class)
	static class NonValidatedTestConfiguration {
		NonValidatedTestConfiguration(NonValidatedTestProperties testProperties) {
		}
	}
	@ConfigurationProperties('test')
	static class NonValidatedTestProperties {
	}
}
/*
package org.springframework.boot.diagnostics;
/**
@ExtendWith(OutputCaptureExtension.class)
class FailureAnalyzersTests {
	private static FailureAnalyzer failureAnalyzer;
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@BeforeEach
	void configureMock() {
		failureAnalyzer = mock(FailureAnalyzer.class);
	}
	@Test
	void analyzersAreLoadedAndCalled() {
		RuntimeException failure = new RuntimeException();
		analyzeAndReport(failure, BasicFailureAnalyzer.class, BasicFailureAnalyzer.class);
		then(failureAnalyzer).should(times(2)).analyze(failure);
	}
	@Test
	void analyzerIsConstructedWithBeanFactory() {
		RuntimeException failure = new RuntimeException();
		analyzeAndReport(failure, BasicFailureAnalyzer.class, BeanFactoryConstructorFailureAnalyzer.class);
		then(failureAnalyzer).should(times(2)).analyze(failure);
	}
	@Test
	void analyzerIsConstructedWithEnvironment() {
		RuntimeException failure = new RuntimeException();
		analyzeAndReport(failure, BasicFailureAnalyzer.class, EnvironmentConstructorFailureAnalyzer.class);
		then(failureAnalyzer).should(times(2)).analyze(failure);
	}
	@Test
	void analyzerThatFailsDuringInitializationDoesNotPreventOtherAnalyzersFromBeingCalled() {
		RuntimeException failure = new RuntimeException();
		analyzeAndReport(failure, BrokenInitializationFailureAnalyzer.class, BasicFailureAnalyzer.class);
		then(failureAnalyzer).should().analyze(failure);
	}
	@Test
	void analyzerThatFailsDuringAnalysisDoesNotPreventOtherAnalyzersFromBeingCalled() {
		RuntimeException failure = new RuntimeException();
		analyzeAndReport(failure, BrokenAnalysisFailureAnalyzer.class, BasicFailureAnalyzer.class);
		then(failureAnalyzer).should().analyze(failure);
	}
	@SafeVarargs
	private void analyzeAndReport(Throwable failure, Class<? extends FailureAnalyzer>... failureAnalyzerClasses) {
		analyzeAndReport(failure, this.context, failureAnalyzerClasses);
	}
	@SafeVarargs
	private void analyzeAndReport(Throwable failure, AnnotationConfigApplicationContext context,
			Class<? extends FailureAnalyzer>... failureAnalyzerClasses) {
		MockSpringFactoriesLoader loader = new MockSpringFactoriesLoader();
		for (Class<? extends FailureAnalyzer> failureAnalyzerClass : failureAnalyzerClasses) {
			loader.add(FailureAnalyzer.class, failureAnalyzerClass);
		}
		new FailureAnalyzers(context, loader).reportException(failure);
	}
	static class BasicFailureAnalyzer implements FailureAnalyzer {
		@Override
		public FailureAnalysis analyze(Throwable failure) {
			return failureAnalyzer.analyze(failure);
		}
	}
	static class BrokenInitializationFailureAnalyzer implements FailureAnalyzer {
		static {
			Object foo = null;
			foo.toString();
		}
		@Override
		public FailureAnalysis analyze(Throwable failure) {
			return null;
		}
	}
	static class BrokenAnalysisFailureAnalyzer implements FailureAnalyzer {
		@Override
		public FailureAnalysis analyze(Throwable failure) {
			throw new NoClassDefFoundError();
		}
	}
	static class BeanFactoryConstructorFailureAnalyzer extends BasicFailureAnalyzer {
		BeanFactoryConstructorFailureAnalyzer(BeanFactory beanFactory) {
			assertThat(beanFactory).isNotNull();
		}
	}
	static class EnvironmentConstructorFailureAnalyzer extends BasicFailureAnalyzer {
		EnvironmentConstructorFailureAnalyzer(Environment environment) {
			assertThat(environment).isNotNull();
		}
	}
}
/*
package org.springframework.boot.diagnostics;
/**
class AbstractFailureAnalyzerTests {
	private final TestFailureAnalyzer failureAnalyzer = new TestFailureAnalyzer();
	@Test
	void findCauseWithNullException() {
		assertThat(this.failureAnalyzer.findCause(null, Throwable.class)).isNull();
	}
	@Test
	void findCauseWithDirectExactMatch() {
		TestException ex = new TestException();
		assertThat(this.failureAnalyzer.findCause(ex, TestException.class)).isEqualTo(ex);
	}
	@Test
	void findCauseWithDirectSubClass() {
		SpecificTestException ex = new SpecificTestException();
		assertThat(this.failureAnalyzer.findCause(ex, TestException.class)).isEqualTo(ex);
	}
	@Test
	void findCauseWitNestedAndExactMatch() {
		TestException ex = new TestException();
		assertThat(this.failureAnalyzer.findCause(new IllegalArgumentException(new IllegalStateException(ex)),
				TestException.class))
			.isEqualTo(ex);
	}
	@Test
	void findCauseWitNestedAndSubClass() {
		SpecificTestException ex = new SpecificTestException();
		assertThat(this.failureAnalyzer.findCause(new IOException(new IllegalStateException(ex)), TestException.class))
			.isEqualTo(ex);
	}
	@Test
	void findCauseWithUnrelatedException() {
		IOException ex = new IOException();
		assertThat(this.failureAnalyzer.findCause(ex, TestException.class)).isNull();
	}
	@Test
	void findCauseWithMoreSpecificException() {
		TestException ex = new TestException();
		assertThat(this.failureAnalyzer.findCause(ex, SpecificTestException.class)).isNull();
	}
	static class TestFailureAnalyzer extends AbstractFailureAnalyzer<Throwable> {
		@Override
		protected FailureAnalysis analyze(Throwable rootFailure, Throwable cause) {
			return null;
		}
	}
	static class TestException extends Exception {
	}
	static class SpecificTestException extends TestException {
	}
}
/*
package org.springframework.boot.sampleconfig;
@Component
public class MyComponent {
}
/*
package org.springframework.boot.sampleconfig;
@Named
public class MyNamedComponent {
	MyNamedComponent() {
	}
}
/*
/**
package org.springframework.boot.sampleconfig;
/*
package org.springframework.boot.liquibase;
/**
@ClassPathExclusions('derby-*')
class LiquibaseChangelogMissingFailureAnalyzerTests {
	@Test
	void changelogParseExceptionDueToChangelogNotPresent() {
		FailureAnalysis analysis = performAnalysis();
		assertThat(analysis.getDescription())
			.isEqualTo('Liquibase failed to start because no changelog could be found at "'
					+ 'classpath:/db/changelog/db.changelog-master.yaml".');
		assertThat(analysis.getAction())
			.isEqualTo('Make sure a Liquibase changelog is present at the configured path.');
	}
	private FailureAnalysis performAnalysis() {
		BeanCreationException failure = createFailure();
		assertThat(failure).isNotNull();
		return new LiquibaseChangelogMissingFailureAnalyzer().analyze(failure);
	}
	private BeanCreationException createFailure() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				LiquibaseConfiguration.class)) {
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class LiquibaseConfiguration {
		@Bean
		DataSource dataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:test').username('sa').build();
		}
		@Bean
		SpringLiquibase springLiquibase(DataSource dataSource) {
			SpringLiquibase liquibase = new SpringLiquibase();
			liquibase.setChangeLog('classpath:/db/changelog/db.changelog-master.yaml');
			liquibase.setDataSource(dataSource);
			return liquibase;
		}
	}
}
/*
package org.springframework.boot;
/**
class ExitCodeGeneratorsTests {
	@Test
	void addAllWhenGeneratorsIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> {
			List<ExitCodeGenerator> generators = null;
			new ExitCodeGenerators().addAll(generators);
		}).withMessageContaining('Generators must not be null');
	}
	@Test
	void addWhenGeneratorIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ExitCodeGenerators().add(null))
			.withMessageContaining('Generator must not be null');
	}
	@Test
	void getExitCodeWhenNoGeneratorsShouldReturnZero() {
		assertThat(new ExitCodeGenerators().getExitCode()).isZero();
	}
	@Test
	void getExitCodeWhenGeneratorThrowsShouldReturnOne() {
		ExitCodeGenerator generator = mock(ExitCodeGenerator.class);
		given(generator.getExitCode()).willThrow(new IllegalStateException());
		ExitCodeGenerators generators = new ExitCodeGenerators();
		generators.add(generator);
		assertThat(generators.getExitCode()).isOne();
	}
	@Test
	void getExitCodeWithUnorderedGeneratorsReturnsFirstNonZeroExitCode() {
		ExitCodeGenerators generators = new ExitCodeGenerators();
		generators.add(mockGenerator(0));
		generators.add(mockGenerator(3));
		generators.add(mockGenerator(2));
		assertThat(generators.getExitCode()).isEqualTo(3);
	}
	@Test
	void getExitCodeWhenUsingExitCodeExceptionMapperShouldCallMapper() {
		ExitCodeGenerators generators = new ExitCodeGenerators();
		Exception e = new IOException();
		generators.add(e, mockMapper(IllegalStateException.class, 1));
		generators.add(e, mockMapper(IOException.class, 2));
		generators.add(e, mockMapper(UnsupportedOperationException.class, 3));
		assertThat(generators.getExitCode()).isEqualTo(2);
	}
	@Test
	void getExitCodeWithOrderedGeneratorsReturnsFirstNonZeroExitCode() {
		ExitCodeGenerators generators = new ExitCodeGenerators();
		generators.add(orderedMockGenerator(0, 1));
		generators.add(orderedMockGenerator(1, 3));
		generators.add(orderedMockGenerator(2, 2));
		generators.add(mockGenerator(3));
		assertThat(generators.getExitCode()).isEqualTo(2);
	}
	private ExitCodeGenerator mockGenerator(int exitCode) {
		ExitCodeGenerator generator = mock(ExitCodeGenerator.class);
		given(generator.getExitCode()).willReturn(exitCode);
		return generator;
	}
	private ExitCodeGenerator orderedMockGenerator(int exitCode, int order) {
		ExitCodeGenerator generator = mock(ExitCodeGenerator.class, withSettings().extraInterfaces(Ordered.class));
		given(generator.getExitCode()).willReturn(exitCode);
		given(((Ordered) generator).getOrder()).willReturn(order);
		return generator;
	}
	private ExitCodeExceptionMapper mockMapper(Class<?> exceptionType, int exitCode) {
		return (exception) -> {
			if (exceptionType.isInstance(exception)) {
				return exitCode;
			}
			return 0;
		};
	}
}
/*
package org.springframework.boot;
/**
class LazyInitializationBeanFactoryPostProcessorTests {
	@Test
	void whenLazyInitializationIsEnabledThenNormalBeansAreNotInitializedUntilRequired() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
			context.register(BeanState.class, ExampleBean.class);
			context.refresh();
			BeanState beanState = context.getBean(BeanState.class);
			assertThat(beanState.initializedBeans).isEmpty();
			context.getBean(ExampleBean.class);
			assertThat(beanState.initializedBeans).containsExactly(ExampleBean.class);
		}
	}
	@Test
	void whenLazyInitializationIsEnabledThenSmartInitializingSingletonsAreInitializedDuringRefresh() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
			context.register(BeanState.class, ExampleSmartInitializingSingleton.class);
			context.refresh();
			BeanState beanState = context.getBean(BeanState.class);
			assertThat(beanState.initializedBeans).containsExactly(ExampleSmartInitializingSingleton.class);
			assertThat(context.getBean(ExampleSmartInitializingSingleton.class).callbackInvoked).isTrue();
		}
	}
	@Test
	void whenLazyInitializationIsEnabledThenInfrastructureRoleBeansAreInitializedDuringRefresh() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
			context.register(BeanState.class);
			context.registerBean(ExampleBean.class,
					(definition) -> definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE));
			context.refresh();
			BeanState beanState = context.getBean(BeanState.class);
			assertThat(beanState.initializedBeans).containsExactly(ExampleBean.class);
		}
	}
	static class ExampleBean {
		ExampleBean(BeanState beanState) {
			beanState.initializedBeans.add(getClass());
		}
	}
	static class ExampleSmartInitializingSingleton implements SmartInitializingSingleton {
		private boolean callbackInvoked;
		ExampleSmartInitializingSingleton(BeanState beanState) {
			beanState.initializedBeans.add(getClass());
		}
		@Override
		public void afterSingletonsInstantiated() {
			this.callbackInvoked = true;
		}
	}
	static class BeanState {
		private final List<Class<?>> initializedBeans = new ArrayList<>();
	}
}
/*
package org.springframework.boot.origin;
/**
class OriginTrackedResourceTests {
	private Origin origin;
	private WritableResource resource;
	private OriginTrackedWritableResource tracked;
	@BeforeEach
	void setup() {
		this.origin = MockOrigin.of('test');
		this.resource = mock(WritableResource.class);
		this.tracked = OriginTrackedResource.of(this.resource, this.origin);
	}
	@Test
	void getInputStreamDelegatesToResource() throws IOException {
		this.tracked.getInputStream();
		then(this.resource).should().getInputStream();
	}
	@Test
	void existsDelegatesToResource() {
		this.tracked.exists();
		then(this.resource).should().exists();
	}
	@Test
	void isReadableDelegatesToResource() {
		this.tracked.isReadable();
		then(this.resource).should().isReadable();
	}
	@Test
	void isOpenDelegatesToResource() {
		this.tracked.isOpen();
		then(this.resource).should().isOpen();
	}
	@Test
	void isFileDelegatesToResource() {
		this.tracked.isFile();
		then(this.resource).should().isFile();
	}
	@Test
	void getURLDelegatesToResource() throws IOException {
		this.tracked.getURL();
		then(this.resource).should().getURL();
	}
	@Test
	void getURIDelegatesToResource() throws IOException {
		this.tracked.getURI();
		then(this.resource).should().getURI();
	}
	@Test
	void getFileDelegatesToResource() throws IOException {
		this.tracked.getFile();
		then(this.resource).should().getFile();
	}
	@Test
	void readableChannelDelegatesToResource() throws IOException {
		try (ReadableByteChannel ignore = this.tracked.readableChannel()) {
			then(this.resource).should().readableChannel();
		}
	}
	@Test
	void contentLengthDelegatesToResource() throws IOException {
		this.tracked.contentLength();
		then(this.resource).should().contentLength();
	}
	@Test
	void lastModifiedDelegatesToResource() throws IOException {
		this.tracked.lastModified();
		then(this.resource).should().lastModified();
	}
	@Test
	void createRelativeDelegatesToResource() throws IOException {
		this.tracked.createRelative('path');
		then(this.resource).should().createRelative('path');
	}
	@Test
	void getFilenameDelegatesToResource() {
		this.tracked.getFilename();
		then(this.resource).should().getFilename();
	}
	@Test
	void getDescriptionDelegatesToResource() {
		this.tracked.getDescription();
		then(this.resource).should().getDescription();
	}
	@Test
	void getOutputStreamDelegatesToResource() throws IOException {
		this.tracked.getOutputStream();
		then(this.resource).should().getOutputStream();
	}
	@Test
	void toStringDelegatesToResource() {
		Resource resource = new ClassPathResource('test');
		Resource tracked = OriginTrackedResource.of(resource, this.origin);
		assertThat(tracked).hasToString(resource.toString());
	}
	@Test
	void getOriginReturnsOrigin() {
		assertThat(this.tracked.getOrigin()).isEqualTo(this.origin);
	}
	@Test
	void getResourceReturnsResource() {
		assertThat(this.tracked.getResource()).isEqualTo(this.resource);
	}
	@Test
	void equalsAndHashCode() {
		Origin o1 = MockOrigin.of('o1');
		Origin o2 = MockOrigin.of('o2');
		Resource r1 = mock(Resource.class);
		Resource r2 = mock(Resource.class);
		OriginTrackedResource r1o1a = OriginTrackedResource.of(r1, o1);
		OriginTrackedResource r1o1b = OriginTrackedResource.of(r1, o1);
		OriginTrackedResource r1o2 = OriginTrackedResource.of(r1, o2);
		OriginTrackedResource r2o1 = OriginTrackedResource.of(r2, o1);
		OriginTrackedResource r2o2 = OriginTrackedResource.of(r2, o2);
		assertThat(r1o1a).isEqualTo(r1o1a).isEqualTo(r1o1a).isNotEqualTo(r1o2).isNotEqualTo(r2o1).isNotEqualTo(r2o2);
		assertThat(r1o1a).hasSameHashCodeAs(r1o1b);
	}
	@Test
	void ofReturnsOriginTrackedResource() {
		Resource resource = mock(Resource.class);
		Resource tracked = OriginTrackedResource.of(resource, this.origin);
		assertThat(tracked).isExactlyInstanceOf(OriginTrackedResource.class);
	}
	@Test
	void ofWhenWritableReturnsOriginTrackedWritableResource() {
		Resource resource = mock(WritableResource.class);
		Resource tracked = OriginTrackedResource.of(resource, this.origin);
		assertThat(tracked).isInstanceOf(WritableResource.class)
			.isExactlyInstanceOf(OriginTrackedWritableResource.class);
	}
}
/*
package org.springframework.boot.origin;
/**
class SystemEnvironmentOriginTests {
	@Test
	void createWhenPropertyIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new SystemEnvironmentOrigin(null));
	}
	@Test
	void createWhenPropertyNameIsEmptyShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new SystemEnvironmentOrigin(''));
	}
	@Test
	void getPropertyShouldReturnProperty() {
		SystemEnvironmentOrigin origin = new SystemEnvironmentOrigin('FOO_BAR');
		assertThat(origin.getProperty()).isEqualTo('FOO_BAR');
	}
	@Test
	void toStringShouldReturnStringWithDetails() {
		SystemEnvironmentOrigin origin = new SystemEnvironmentOrigin('FOO_BAR');
		assertThat(origin).hasToString('System Environment Property \'FOO_BAR\'');
	}
}
/*
package org.springframework.boot.origin;
/**
class TextResourceOriginTests {
	@Test
	void createWithNullResourceSetsNullResource() {
		TextResourceOrigin origin = new TextResourceOrigin(null, null);
		assertThat(origin.getResource()).isNull();
	}
	@Test
	void createWithNullLocationSetsNullLocation() {
		TextResourceOrigin origin = new TextResourceOrigin(null, null);
		assertThat(origin.getLocation()).isNull();
	}
	@Test
	void getResourceReturnResource() {
		ClassPathResource resource = new ClassPathResource('foo.txt');
		TextResourceOrigin origin = new TextResourceOrigin(resource, null);
		assertThat(origin.getResource()).isEqualTo(resource);
	}
	@Test
	void getLocationReturnsLocation() {
		Location location = new Location(1, 2);
		TextResourceOrigin origin = new TextResourceOrigin(null, location);
		assertThat(origin.getLocation()).isEqualTo(location);
	}
	@Test
	void getParentWhenResourceIsNotOriginTrackedReturnsNull() {
		ClassPathResource resource = new ClassPathResource('foo.txt');
		TextResourceOrigin origin = new TextResourceOrigin(resource, null);
		assertThat(origin.getParent()).isNull();
	}
	@Test
	void getParentWhenResourceIsOriginTrackedReturnsResourceOrigin() {
		Origin resourceOrigin = MockOrigin.of('test');
		Resource resource = OriginTrackedResource.of(new ClassPathResource('foo.txt'), resourceOrigin);
		TextResourceOrigin origin = new TextResourceOrigin(resource, null);
		assertThat(origin.getParent()).isSameAs(resourceOrigin);
	}
	@Test
	void getLocationLineReturnsLine() {
		Location location = new Location(1, 2);
		assertThat(location.getLine()).isOne();
	}
	@Test
	void getLocationColumnReturnsColumn() {
		Location location = new Location(1, 2);
		assertThat(location.getColumn()).isEqualTo(2);
	}
	@Test
	void locationToStringReturnsNiceString() {
		Location location = new Location(1, 2);
		assertThat(location).hasToString('2:3');
	}
	@Test
	void toStringReturnsNiceString() {
		ClassPathResource resource = new ClassPathResource('foo.txt');
		Location location = new Location(1, 2);
		TextResourceOrigin origin = new TextResourceOrigin(resource, location);
		assertThat(origin).hasToString('class path resource [foo.txt] - 2:3');
	}
	@Test
	void toStringWhenResourceIsNullReturnsNiceString() {
		Location location = new Location(1, 2);
		TextResourceOrigin origin = new TextResourceOrigin(null, location);
		assertThat(origin).hasToString('unknown resource [?] - 2:3');
	}
	@Test
	void toStringWhenLocationIsNullReturnsNiceString() {
		ClassPathResource resource = new ClassPathResource('foo.txt');
		TextResourceOrigin origin = new TextResourceOrigin(resource, null);
		assertThat(origin).hasToString('class path resource [foo.txt]');
	}
	@Test
	void toStringWhenResourceIsClasspathResourceReturnsToStringWithJar() {
		ClassPathResource resource = new ClassPathResource('foo.txt') {
			@Override
			public URI getURI() throws IOException {
				try {
					return new URI('jar:file:/home/user/project/target/project-0.0.1-SNAPSHOT.jar'
							+ '!/BOOT-INF/classes!/foo.txt');
				}
				catch (URISyntaxException ex) {
					throw new IllegalStateException(ex);
				}
			}
		};
		Location location = new Location(1, 2);
		TextResourceOrigin origin = new TextResourceOrigin(resource, location);
		assertThat(origin).hasToString('class path resource [foo.txt] from project-0.0.1-SNAPSHOT.jar - 2:3');
	}
	@Test
	void locationEqualsAndHashCodeUsesLineAndColumn() {
		Location location1 = new Location(1, 2);
		Location location2 = new Location(1, 2);
		Location location3 = new Location(2, 2);
		assertThat(location1).hasSameHashCodeAs(location1);
		assertThat(location1).hasSameHashCodeAs(location2);
		assertThat(location1.hashCode()).isNotEqualTo(location3.hashCode());
		assertThat(location1).isEqualTo(location1);
		assertThat(location1).isEqualTo(location2);
		assertThat(location1).isNotEqualTo(location3);
	}
	@Test
	void equalsAndHashCodeUsesResourceAndLocation() {
		TextResourceOrigin origin1 = new TextResourceOrigin(new ClassPathResource('foo.txt'), new Location(1, 2));
		TextResourceOrigin origin2 = new TextResourceOrigin(new ClassPathResource('foo.txt'), new Location(1, 2));
		TextResourceOrigin origin3 = new TextResourceOrigin(new ClassPathResource('foo.txt'), new Location(2, 2));
		TextResourceOrigin origin4 = new TextResourceOrigin(new ClassPathResource('foo2.txt'), new Location(1, 2));
		assertThat(origin1).hasSameHashCodeAs(origin1);
		assertThat(origin1).hasSameHashCodeAs(origin2);
		assertThat(origin1.hashCode()).isNotEqualTo(origin3.hashCode());
		assertThat(origin1.hashCode()).isNotEqualTo(origin4.hashCode());
		assertThat(origin1).isEqualTo(origin1);
		assertThat(origin1).isEqualTo(origin2);
		assertThat(origin1).isNotEqualTo(origin3);
		assertThat(origin1).isNotEqualTo(origin4);
	}
}
/*
package org.springframework.boot.origin;
/**
class OriginLookupTests {
	@Test
	void getOriginWhenSourceIsNullShouldReturnNull() {
		assertThat(OriginLookup.getOrigin(null, 'foo')).isNull();
	}
	@Test
	void getOriginWhenSourceIsNotLookupShouldReturnLookupOrigin() {
		Object source = new Object();
		assertThat(OriginLookup.getOrigin(source, 'foo')).isNull();
	}
	@Test
	@SuppressWarnings('unchecked')
	void getOriginWhenSourceIsLookupShouldReturnLookupOrigin() {
		OriginLookup<String> source = mock(OriginLookup.class);
		Origin origin = MockOrigin.of('bar');
		given(source.getOrigin('foo')).willReturn(origin);
		assertThat(OriginLookup.getOrigin(source, 'foo')).isEqualTo(origin);
	}
	@Test
	@SuppressWarnings('unchecked')
	void getOriginWhenSourceLookupThrowsAndErrorShouldReturnNull() {
		OriginLookup<String> source = mock(OriginLookup.class);
		willThrow(RuntimeException.class).given(source).getOrigin('foo');
		assertThat(OriginLookup.getOrigin(source, 'foo')).isNull();
	}
}
/*
package org.springframework.boot.origin;
/**
class PropertySourceOriginTests {
	@Test
	void createWhenPropertySourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new PropertySourceOrigin(null, 'name'))
			.withMessageContaining('PropertySource must not be null');
	}
	@Test
	void createWhenPropertyNameIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PropertySourceOrigin(mock(PropertySource.class), null))
			.withMessageContaining('PropertyName must not be empty');
	}
	@Test
	void createWhenPropertyNameIsEmptyShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new PropertySourceOrigin(mock(PropertySource.class), ''))
			.withMessageContaining('PropertyName must not be empty');
	}
	@Test
	void getPropertySourceShouldReturnPropertySource() {
		MapPropertySource propertySource = new MapPropertySource('test', new HashMap<>());
		PropertySourceOrigin origin = new PropertySourceOrigin(propertySource, 'foo');
		assertThat(origin.getPropertySource()).isEqualTo(propertySource);
	}
	@Test
	void getPropertyNameShouldReturnPropertyName() {
		MapPropertySource propertySource = new MapPropertySource('test', new HashMap<>());
		PropertySourceOrigin origin = new PropertySourceOrigin(propertySource, 'foo');
		assertThat(origin.getPropertyName()).isEqualTo('foo');
	}
	@Test
	void toStringShouldShowDetails() {
		MapPropertySource propertySource = new MapPropertySource('test', new HashMap<>());
		PropertySourceOrigin origin = new PropertySourceOrigin(propertySource, 'foo');
		assertThat(origin).hasToString('\'foo\' from property source \'test\'');
	}
	@Test
	@SuppressWarnings('unchecked')
	void getWhenPropertySourceSupportsOriginLookupShouldReturnOrigin() {
		Origin origin = mock(Origin.class);
		PropertySource<?> propertySource = mock(PropertySource.class,
				withSettings().extraInterfaces(OriginLookup.class));
		OriginLookup<String> originCapablePropertySource = (OriginLookup<String>) propertySource;
		given(originCapablePropertySource.getOrigin('foo')).willReturn(origin);
		Origin actual = PropertySourceOrigin.get(propertySource, 'foo');
		assertThat(actual).hasToString(origin.toString());
		assertThat(((PropertySourceOrigin) actual).getOrigin()).isSameAs(origin);
	}
	@Test
	void getWhenPropertySourceSupportsOriginLookupButNoOriginShouldWrap() {
		PropertySource<?> propertySource = mock(PropertySource.class,
				withSettings().extraInterfaces(OriginLookup.class));
		assertThat(PropertySourceOrigin.get(propertySource, 'foo')).isInstanceOf(PropertySourceOrigin.class);
	}
	@Test
	void getWhenPropertySourceIsNotOriginAwareShouldWrap() {
		MapPropertySource propertySource = new MapPropertySource('test', new HashMap<>());
		PropertySourceOrigin origin = new PropertySourceOrigin(propertySource, 'foo');
		assertThat(origin.getPropertySource()).isEqualTo(propertySource);
		assertThat(origin.getPropertyName()).isEqualTo('foo');
	}
}
/*
package org.springframework.boot.origin;
/**
class OriginTests {
	@Test
	void getParentWhenDefaultIsNull() {
		Origin origin = new Origin() {
		};
		assertThat(origin.getParent()).isNull();
	}
	@Test
	void fromWhenSourceIsNullReturnsNull() {
		assertThat(Origin.from(null)).isNull();
	}
	@Test
	void fromWhenSourceIsRegularObjectReturnsNull() {
		Object source = new Object();
		assertThat(Origin.from(source)).isNull();
	}
	@Test
	void fromWhenSourceIsOriginReturnsSource() {
		Origin origin = mock(Origin.class);
		assertThat(Origin.from(origin)).isEqualTo(origin);
	}
	@Test
	void fromWhenSourceIsOriginProviderReturnsProvidedOrigin() {
		Origin origin = mock(Origin.class);
		OriginProvider originProvider = mock(OriginProvider.class);
		given(originProvider.getOrigin()).willReturn(origin);
		assertThat(Origin.from(origin)).isEqualTo(origin);
	}
	@Test
	void fromWhenSourceIsThrowableUsesCause() {
		Origin origin = mock(Origin.class);
		Exception exception = new RuntimeException(new TestException(origin, null));
		assertThat(Origin.from(exception)).isEqualTo(origin);
	}
	@Test
	void fromWhenSourceIsThrowableAndOriginProviderThatReturnsNullUsesCause() {
		Origin origin = mock(Origin.class);
		Exception exception = new TestException(null, new TestException(origin, null));
		assertThat(Origin.from(exception)).isEqualTo(origin);
	}
	@Test
	void parentsFromWhenSourceIsNullReturnsEmptyList() {
		assertThat(Origin.parentsFrom(null)).isEmpty();
	}
	@Test
	void parentsFromReturnsParents() {
		Origin o1 = MockOrigin.of('1');
		Origin o2 = MockOrigin.of('2', o1);
		Origin o3 = MockOrigin.of('3', o2);
		List<Origin> parents = Origin.parentsFrom(o3);
		assertThat(parents).containsExactly(o2, o1);
	}
	static class TestException extends RuntimeException implements OriginProvider {
		private final Origin origin;
		TestException(Origin origin, Throwable cause) {
			super(cause);
			this.origin = origin;
		}
		@Override
		public Origin getOrigin() {
			return this.origin;
		}
	}
}
/*
package org.springframework.boot.origin;
/**
class OriginTrackedValueTests {
	@Test
	void getValueShouldReturnValue() {
		Object value = new Object();
		assertThat(OriginTrackedValue.of(value).getValue()).isEqualTo(value);
	}
	@Test
	void getOriginShouldReturnOrigin() {
		Object value = new Object();
		Origin origin = mock(Origin.class);
		assertThat(OriginTrackedValue.of(value, origin).getOrigin()).isEqualTo(origin);
	}
	@Test
	void toStringShouldReturnValueToString() {
		Object value = new Object();
		assertThat(OriginTrackedValue.of(value)).hasToString(value.toString());
	}
	@Test
	void hashCodeAndEqualsShouldIgnoreOrigin() {
		Object value1 = new Object();
		OriginTrackedValue tracked1 = OriginTrackedValue.of(value1);
		OriginTrackedValue tracked2 = OriginTrackedValue.of(value1, mock(Origin.class));
		OriginTrackedValue tracked3 = OriginTrackedValue.of(new Object());
		assertThat(tracked1).hasSameHashCodeAs(tracked2);
		assertThat(tracked1).isEqualTo(tracked1).isEqualTo(tracked2).isNotEqualTo(tracked3);
	}
	@Test
	void ofWhenValueIsNullShouldReturnNull() {
		assertThat(OriginTrackedValue.of(null)).isNull();
		assertThat(OriginTrackedValue.of(null, mock(Origin.class))).isNull();
	}
	@Test
	void ofWhenValueIsCharSequenceShouldReturnCharSequence() {
		String value = 'foo';
		OriginTrackedValue tracked = OriginTrackedValue.of(value);
		assertThat(tracked).isInstanceOf(CharSequence.class);
		CharSequence charSequence = (CharSequence) tracked;
		assertThat(charSequence).hasSameSizeAs(value);
		assertThat(charSequence.charAt(0)).isEqualTo(value.charAt(0));
		assertThat(charSequence.subSequence(0, 1)).isEqualTo(value.subSequence(0, 1));
	}
}
/*
package org.springframework.boot.origin;
/**
public final class MockOrigin implements Origin {
	private final String value;
	private final Origin parent;
	private MockOrigin(String value, Origin parent) {
		Assert.notNull(value, 'Value must not be null');
		this.value = value;
		this.parent = parent;
	}
	@Override
	public Origin getParent() {
		return this.parent;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.value.equals(((MockOrigin) obj).value);
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return this.value;
	}
	public static Origin of(String value) {
		return of(value, null);
	}
	public static Origin of(String value, Origin parent) {
		return (value != null) ? new MockOrigin(value, parent) : null;
	}
}
/*
package org.springframework.boot.origin;
/**
class JarUriTests {
	@Test
	void describeBootInfClassesUri() {
		JarUri uri = JarUri.from('jar:file:/home/user/project/target/project-0.0.1-SNAPSHOT.jar'
				+ '!/BOOT-INF/classes!/application.properties');
		assertThat(uri.getDescription()).isEqualTo('project-0.0.1-SNAPSHOT.jar');
	}
	@Test
	void describeBootInfLibUri() {
		JarUri uri = JarUri.from('jar:file:/home/user/project/target/project-0.0.1-SNAPSHOT.jar'
				+ '!/BOOT-INF/lib/nested.jar!/application.properties');
		assertThat(uri.getDescription()).isEqualTo('project-0.0.1-SNAPSHOT.jar!/BOOT-INF/lib/nested.jar');
	}
	@Test
	void describeRegularJar() {
		JarUri uri = JarUri
			.from('jar:file:/home/user/project/target/project-0.0.1-SNAPSHOT.jar!/application.properties');
		assertThat(uri.getDescription()).isEqualTo('project-0.0.1-SNAPSHOT.jar');
	}
	@Test
	void getDescriptionMergedWithExisting() {
		JarUri uri = JarUri.from('jar:file:/project-0.0.1-SNAPSHOT.jar!/application.properties');
		assertThat(uri.getDescription('classpath: [application.properties]'))
			.isEqualTo('classpath: [application.properties] from project-0.0.1-SNAPSHOT.jar');
	}
}
/*
package org.springframework.boot.env;
/**
class RandomValuePropertySourceTests {
	private final RandomValuePropertySource source = new RandomValuePropertySource();
	@Test
	void getPropertyWhenNotRandomReturnsNull() {
		assertThat(this.source.getProperty('foo')).isNull();
	}
	@Test
	void getPropertyWhenStringReturnsValue() {
		assertThat(this.source.getProperty('random.string')).isNotNull();
	}
	@Test
	void getPropertyWhenIntReturnsValue() {
		Integer value = (Integer) this.source.getProperty('random.int');
		assertThat(value).isNotNull();
	}
	@Test
	void getPropertyWhenUuidReturnsValue() {
		String value = (String) this.source.getProperty('random.uuid');
		assertThat(value).isNotNull();
		assertThat(UUID.fromString(value)).isNotNull();
	}
	@Test
	void getPropertyWhenIntRangeReturnsValue() {
		Integer value = (Integer) this.source.getProperty('random.int[4,10]');
		assertThat(value).isNotNull();
		assertThat(value).isGreaterThanOrEqualTo(4);
		assertThat(value).isLessThan(10);
	}
	@Test
	void intRangeWhenLowerBoundEqualsUpperBoundShouldFailWithIllegalArgumentException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.source.getProperty('random.int[4,4]'))
			.withMessage('Lower bound must be less than upper bound.');
	}
	@Test
	void intRangeWhenLowerBoundNegative() {
		Integer value = (Integer) this.source.getProperty('random.int[-4,4]');
		assertThat(value).isGreaterThanOrEqualTo(-4);
		assertThat(value).isLessThan(4);
	}
	@Test
	void getPropertyWhenIntMaxReturnsValue() {
		Integer value = (Integer) this.source.getProperty('random.int(10)');
		assertThat(value).isNotNull().isLessThan(10);
	}
	@Test
	void intMaxZero() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.source.getProperty('random.int(0)'))
			.withMessage('Bound must be positive.');
	}
	@Test
	void intNegativeBound() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.source.getProperty('random.int(-5)'))
			.withMessage('Bound must be positive.');
	}
	@Test
	void getPropertyWhenLongReturnsValue() {
		Long value = (Long) this.source.getProperty('random.long');
		assertThat(value).isNotNull();
	}
	@Test
	void getPropertyWhenLongRangeReturnsValue() {
		Long value = (Long) this.source.getProperty('random.long[4,10]');
		assertThat(value).isNotNull().isBetween(4L, 10L);
	}
	@Test
	void longRangeWhenLowerBoundEqualsUpperBoundShouldFailWithIllegalArgumentException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.source.getProperty('random.long[4,4]'))
			.withMessage('Lower bound must be less than upper bound.');
	}
	@Test
	void longRangeWhenLowerBoundNegative() {
		Long value = (Long) this.source.getProperty('random.long[-4,4]');
		assertThat(value).isGreaterThanOrEqualTo(-4);
		assertThat(value).isLessThan(4);
	}
	@Test
	void getPropertyWhenLongMaxReturnsValue() {
		Long value = (Long) this.source.getProperty('random.long(10)');
		assertThat(value).isNotNull().isLessThan(10L);
	}
	@Test
	void longMaxZero() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.source.getProperty('random.long(0)'))
			.withMessage('Bound must be positive.');
	}
	@Test
	void longNegativeBound() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.source.getProperty('random.long(-5)'))
			.withMessage('Bound must be positive.');
	}
	@Test
	void getPropertyWhenLongOverflowReturnsValue() {
		RandomValuePropertySource source = spy(this.source);
		given(source.getSource()).willReturn(new Random() {
			@Override
			public long nextLong() {
				// constant that used to become -8, now becomes 8
				return Long.MIN_VALUE;
			}
		});
		Long value = (Long) source.getProperty('random.long(10)');
		assertThat(value).isNotNull().isGreaterThanOrEqualTo(0L).isLessThan(10L);
		value = (Long) source.getProperty('random.long[4,10]');
		assertThat(value).isNotNull().isGreaterThanOrEqualTo(4L).isLessThan(10L);
	}
	@Test
	void addToEnvironmentAddsSource() {
		MockEnvironment environment = new MockEnvironment();
		RandomValuePropertySource.addToEnvironment(environment);
		assertThat(environment.getProperty('random.string')).isNotNull();
	}
	@Test
	void addToEnvironmentWhenAlreadyAddedAddsSource() {
		MockEnvironment environment = new MockEnvironment();
		RandomValuePropertySource.addToEnvironment(environment);
		RandomValuePropertySource.addToEnvironment(environment);
		assertThat(environment.getProperty('random.string')).isNotNull();
	}
	@Test
	void addToEnvironmentAddsAfterSystemEnvironment() {
		MockEnvironment environment = new MockEnvironment();
		environment.getPropertySources()
			.addFirst(new SystemEnvironmentPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
					Collections.emptyMap()));
		RandomValuePropertySource.addToEnvironment(environment);
		assertThat(environment.getPropertySources().stream().map(PropertySource::getName)).containsExactly(
				StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				RandomValuePropertySource.RANDOM_PROPERTY_SOURCE_NAME, 'mockProperties');
	}
	@Test
	void randomStringIs32CharsLong() {
		assertThat(this.source.getProperty('random.string')).asString().hasSize(32);
	}
}
/*
package org.springframework.boot.env;
/**
class RandomValuePropertySourceEnvironmentPostProcessorTests {
	private final RandomValuePropertySourceEnvironmentPostProcessor postProcessor = new RandomValuePropertySourceEnvironmentPostProcessor(
			Supplier::get);
	@Test
	void getOrderIsBeforeConfigData() {
		assertThat(this.postProcessor.getOrder()).isLessThan(ConfigDataEnvironmentPostProcessor.ORDER);
	}
	@Test
	void postProcessEnvironmentAddsPropertySource() {
		MockEnvironment environment = new MockEnvironment();
		this.postProcessor.postProcessEnvironment(environment, mock(SpringApplication.class));
		assertThat(environment.getProperty('random.string')).isNotNull();
	}
}
/*
package org.springframework.boot.env;
/**
class PropertiesPropertySourceLoaderTests {
	private final PropertiesPropertySourceLoader loader = new PropertiesPropertySourceLoader();
	@Test
	void getFileExtensions() {
		assertThat(this.loader.getFileExtensions()).isEqualTo(new String[] { 'properties', 'xml' });
	}
	@Test
	void loadProperties() throws Exception {
		List<PropertySource<?>> loaded = this.loader.load('test.properties',
				new ClassPathResource('test-properties.properties', getClass()));
		PropertySource<?> source = loaded.get(0);
		assertThat(source.getProperty('test')).isEqualTo('properties');
	}
	@Test
	void loadMultiDocumentPropertiesWithSeparatorAtTheBeginningOfFile() throws Exception {
		List<PropertySource<?>> loaded = this.loader.load('test.properties',
				new ClassPathResource('multi-document-properties-2.properties', getClass()));
		assertThat(loaded).hasSize(2);
		PropertySource<?> source1 = loaded.get(0);
		PropertySource<?> source2 = loaded.get(1);
		assertThat(source1.getProperty('blah')).isEqualTo('hello world');
		assertThat(source2.getProperty('foo')).isEqualTo('bar');
	}
	@Test
	void loadMultiDocumentProperties() throws Exception {
		List<PropertySource<?>> loaded = this.loader.load('test.properties',
				new ClassPathResource('multi-document-properties.properties', getClass()));
		assertThat(loaded).hasSize(2);
		PropertySource<?> source1 = loaded.get(0);
		PropertySource<?> source2 = loaded.get(1);
		assertThat(source1.getProperty('blah')).isEqualTo('hello world');
		assertThat(source2.getProperty('foo')).isEqualTo('bar');
	}
	@Test
	void loadMultiDocumentPropertiesWithEmptyDocument() throws Exception {
		List<PropertySource<?>> loaded = this.loader.load('test.properties',
				new ClassPathResource('multi-document-properties-empty.properties', getClass()));
		assertThat(loaded).hasSize(2);
		PropertySource<?> source1 = loaded.get(0);
		PropertySource<?> source2 = loaded.get(1);
		assertThat(source1.getProperty('blah')).isEqualTo('hello world');
		assertThat(source2.getProperty('foo')).isEqualTo('bar');
	}
	@Test
	void loadXml() throws Exception {
		List<PropertySource<?>> loaded = this.loader.load('test.xml',
				new ClassPathResource('test-xml.xml', getClass()));
		PropertySource<?> source = loaded.get(0);
		assertThat(source.getProperty('test')).isEqualTo('xml');
	}
}
/*
package org.springframework.boot.env;
/**
class SystemEnvironmentPropertySourceEnvironmentPostProcessorTests {
	private final ConfigurableEnvironment environment = new StandardEnvironment();
	private final SpringApplication application = new SpringApplication();
	@Test
	void postProcessShouldReplaceSystemEnvironmentPropertySource() {
		SystemEnvironmentPropertySourceEnvironmentPostProcessor postProcessor = new SystemEnvironmentPropertySourceEnvironmentPostProcessor();
		postProcessor.postProcessEnvironment(this.environment, this.application);
		PropertySource<?> replaced = this.environment.getPropertySources().get('systemEnvironment');
		assertThat(replaced).isInstanceOf(OriginAwareSystemEnvironmentPropertySource.class);
	}
	@Test
	@SuppressWarnings('unchecked')
	void replacedPropertySourceShouldBeOriginAware() {
		SystemEnvironmentPropertySourceEnvironmentPostProcessor postProcessor = new SystemEnvironmentPropertySourceEnvironmentPostProcessor();
		PropertySource<?> original = this.environment.getPropertySources().get('systemEnvironment');
		postProcessor.postProcessEnvironment(this.environment, this.application);
		OriginAwareSystemEnvironmentPropertySource replaced = (OriginAwareSystemEnvironmentPropertySource) this.environment
			.getPropertySources()
			.get('systemEnvironment');
		Map<String, Object> originalMap = (Map<String, Object>) original.getSource();
		Map<String, Object> replacedMap = replaced.getSource();
		originalMap.forEach((key, value) -> {
			Object actual = replacedMap.get(key);
			assertThat(actual).isEqualTo(value);
			assertThat(replaced.getOrigin(key)).isInstanceOf(SystemEnvironmentOrigin.class);
		});
	}
	@Test
	void replacedPropertySourceWhenPropertyAbsentShouldReturnNullOrigin() {
		SystemEnvironmentPropertySourceEnvironmentPostProcessor postProcessor = new SystemEnvironmentPropertySourceEnvironmentPostProcessor();
		postProcessor.postProcessEnvironment(this.environment, this.application);
		OriginAwareSystemEnvironmentPropertySource replaced = (OriginAwareSystemEnvironmentPropertySource) this.environment
			.getPropertySources()
			.get('systemEnvironment');
		assertThat(replaced.getOrigin('NON_EXISTENT')).isNull();
	}
	@Test
	void replacedPropertySourceShouldResolveProperty() {
		SystemEnvironmentPropertySourceEnvironmentPostProcessor postProcessor = new SystemEnvironmentPropertySourceEnvironmentPostProcessor();
		Map<String, Object> source = Collections.singletonMap('FOO_BAR_BAZ', 'hello');
		this.environment.getPropertySources()
			.replace('systemEnvironment', new SystemEnvironmentPropertySource('systemEnvironment', source));
		postProcessor.postProcessEnvironment(this.environment, this.application);
		OriginAwareSystemEnvironmentPropertySource replaced = (OriginAwareSystemEnvironmentPropertySource) this.environment
			.getPropertySources()
			.get('systemEnvironment');
		SystemEnvironmentOrigin origin = (SystemEnvironmentOrigin) replaced.getOrigin('foo.bar.baz');
		assertThat(origin.getProperty()).isEqualTo('FOO_BAR_BAZ');
		assertThat(replaced.getProperty('foo.bar.baz')).isEqualTo('hello');
	}
	@Test
	void propertySourceShouldBePrefixed() {
		SystemEnvironmentPropertySourceEnvironmentPostProcessor postProcessor = new SystemEnvironmentPropertySourceEnvironmentPostProcessor();
		SpringApplication application = new SpringApplication();
		application.setEnvironmentPrefix('my');
		postProcessor.postProcessEnvironment(this.environment, application);
		OriginAwareSystemEnvironmentPropertySource replaced = (OriginAwareSystemEnvironmentPropertySource) this.environment
			.getPropertySources()
			.get('systemEnvironment');
		assertThat(replaced.getPrefix()).isEqualTo('my');
	}
}
/*
package org.springframework.boot.env;
/**
class SpringApplicationJsonEnvironmentPostProcessorTests {
	private final SpringApplicationJsonEnvironmentPostProcessor processor = new SpringApplicationJsonEnvironmentPostProcessor();
	private final ConfigurableEnvironment environment = new StandardEnvironment();
	@Test
	void error() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 'spring.application.json=foo:bar');
		assertThatExceptionOfType(JsonParseException.class)
			.isThrownBy(() -> this.processor.postProcessEnvironment(this.environment, null))
			.withMessageContaining('Cannot parse JSON');
	}
	@Test
	void missing() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
	}
	@Test
	void empty() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 'spring.application.json={}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
	}
	@Test
	void periodSeparated() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'spring.application.json={\'foo\':\'bar\'}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEqualTo('bar');
	}
	@Test
	void envVar() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':\'bar\'}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEqualTo('bar');
	}
	@Test
	void nested() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':{\'bar\':\'spam\',\'rab\':\'maps\'}}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo.bar:}')).isEqualTo('spam');
		assertThat(this.environment.resolvePlaceholders('${foo.rab:}')).isEqualTo('maps');
	}
	@Test
	void prefixed() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo.bar\':\'spam\'}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo.bar:}')).isEqualTo('spam');
	}
	@Test
	void list() {
		assertThat(this.environment.resolvePlaceholders('${foo[1]:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':[\'bar\',\'spam\']}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo[1]:}')).isEqualTo('spam');
	}
	@Test
	void listOfObject() {
		assertThat(this.environment.resolvePlaceholders('${foo[0].bar:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':[{\'bar\':\'spam\'}]}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo[0].bar:}')).isEqualTo('spam');
	}
	@Test
	void propertySourceShouldTrackOrigin() {
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEmpty();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'spring.application.json={\'foo\':\'bar\'}');
		this.processor.postProcessEnvironment(this.environment, null);
		PropertySource<?> propertySource = this.environment.getPropertySources().get('spring.application.json');
		PropertySourceOrigin origin = (PropertySourceOrigin) PropertySourceOrigin.get(propertySource, 'foo');
		assertThat(origin.getPropertySource().getName()).isEqualTo('Inlined Test Properties');
		assertThat(origin.getPropertyName()).isEqualTo('spring.application.json');
		assertThat(this.environment.resolvePlaceholders('${foo:}')).isEqualTo('bar');
	}
	@Test
	void propertySourceShouldBeOrderedBeforeJndiPropertySource() {
		testServletPropertySource(StandardServletEnvironment.JNDI_PROPERTY_SOURCE_NAME);
	}
	@Test
	void propertySourceShouldBeOrderedBeforeServletContextPropertySource() {
		testServletPropertySource(StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME);
	}
	@Test
	void propertySourceShouldBeOrderedBeforeServletConfigPropertySource() {
		testServletPropertySource(StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME);
	}
	@Test
	void propertySourceOrderingWhenMultipleServletSpecificPropertySources() {
		MapPropertySource jndi = getPropertySource(StandardServletEnvironment.JNDI_PROPERTY_SOURCE_NAME, 'jndi');
		this.environment.getPropertySources().addFirst(jndi);
		MapPropertySource servlet = getPropertySource(StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME,
				'servlet');
		this.environment.getPropertySources().addFirst(servlet);
		MapPropertySource custom = getPropertySource('custom', 'custom');
		this.environment.getPropertySources().addFirst(custom);
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':\'bar\'}');
		this.processor.postProcessEnvironment(this.environment, null);
		PropertySource<?> json = this.environment.getPropertySources().get('spring.application.json');
		assertThat(this.environment.getProperty('foo')).isEqualTo('custom');
		assertThat(this.environment.getPropertySources()).containsSequence(custom, json, servlet, jndi);
	}
	@Test
	void nullValuesShouldBeAddedToPropertySource() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':null}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.containsProperty('foo')).isTrue();
	}
	@Test
	void emptyValuesForCollectionShouldNotBeIgnored() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':[]}');
		MockPropertySource source = new MockPropertySource();
		source.setProperty('foo', 'bar');
		this.environment.getPropertySources().addLast(source);
		assertThat(this.environment.resolvePlaceholders('${foo}')).isEqualTo('bar');
		this.environment.getPropertySources().addLast(source);
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.resolvePlaceholders('${foo}')).isEmpty();
	}
	@Test
	@SuppressWarnings('unchecked')
	void emptyMapValuesShouldNotBeIgnored() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':{}}');
		MockPropertySource source = new MockPropertySource();
		source.setProperty('foo.baz', 'bar');
		this.environment.getPropertySources().addLast(source);
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('foo', Map.class)).isEmpty();
	}
	private void testServletPropertySource(String servletPropertySourceName) {
		this.environment.getPropertySources().addFirst(getPropertySource(servletPropertySourceName, 'servlet'));
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'SPRING_APPLICATION_JSON={\'foo\':\'bar\'}');
		this.processor.postProcessEnvironment(this.environment, null);
		assertThat(this.environment.getProperty('foo')).isEqualTo('bar');
	}
	private MapPropertySource getPropertySource(String name, String value) {
		return new MapPropertySource(name, Collections.singletonMap('foo', value));
	}
}
/*
package org.springframework.boot.env;
/**
class OriginTrackedPropertiesLoaderTests {
	private ClassPathResource resource;
	private List<Document> documents;
	@BeforeEach
	void setUp() throws Exception {
		String path = 'test-properties.properties';
		this.resource = new ClassPathResource(path, getClass());
		this.documents = new OriginTrackedPropertiesLoader(this.resource).load();
	}
	@Test
	void compareToJavaProperties() throws Exception {
		Properties java = PropertiesLoaderUtils.loadProperties(this.resource);
		Properties ours = new Properties();
		new OriginTrackedPropertiesLoader(this.resource).load(false)
			.get(0)
			.asMap()
			.forEach((k, v) -> ours.put(k, v.getValue()));
		assertThat(ours).isEqualTo(java);
	}
	@Test
	void getSimpleProperty() {
		OriginTrackedValue value = getFromFirst('test');
		assertThat(getValue(value)).isEqualTo('properties');
		assertThat(getLocation(value)).isEqualTo('11:6');
	}
	@Test
	void getSimplePropertyWithColonSeparator() {
		OriginTrackedValue value = getFromFirst('test-colon-separator');
		assertThat(getValue(value)).isEqualTo('my-property');
		assertThat(getLocation(value)).isEqualTo('15:23');
	}
	@Test
	void getPropertyWithSeparatorSurroundedBySpaces() {
		OriginTrackedValue value = getFromFirst('blah');
		assertThat(getValue(value)).isEqualTo('hello world');
		assertThat(getLocation(value)).isEqualTo('2:12');
	}
	@Test
	void getUnicodeProperty() {
		OriginTrackedValue value = getFromFirst('test-unicode');
		assertThat(getValue(value)).isEqualTo('properties&test');
		assertThat(getLocation(value)).isEqualTo('12:14');
	}
	@Test
	void getMalformedUnicodeProperty() {
		// gh-12716
		ClassPathResource resource = new ClassPathResource('test-properties-malformed-unicode.properties', getClass());
		assertThatIllegalStateException().isThrownBy(() -> new OriginTrackedPropertiesLoader(resource).load())
			.withMessageContaining('Malformed \\uxxxx encoding');
	}
	@Test
	void getEscapedProperty() {
		OriginTrackedValue value = getFromFirst('test=property');
		assertThat(getValue(value)).isEqualTo('helloworld');
		assertThat(getLocation(value)).isEqualTo('14:15');
	}
	@Test
	void getPropertyWithTab() {
		OriginTrackedValue value = getFromFirst('test-tab-property');
		assertThat(getValue(value)).isEqualTo('foo\tbar');
		assertThat(getLocation(value)).isEqualTo('16:19');
	}
	@Test
	void getPropertyWithBang() {
		OriginTrackedValue value = getFromFirst('test-bang-property');
		assertThat(getValue(value)).isEqualTo('foo!');
		assertThat(getLocation(value)).isEqualTo('34:20');
	}
	@Test
	void getPropertyWithValueComment() {
		OriginTrackedValue value = getFromFirst('test-property-value-comment');
		assertThat(getValue(value)).isEqualTo('foo !bar #foo');
		assertThat(getLocation(value)).isEqualTo('36:29');
	}
	@Test
	void getPropertyWithMultilineImmediateBang() {
		OriginTrackedValue value = getFromFirst('test-multiline-immediate-bang');
		assertThat(getValue(value)).isEqualTo('!foo');
		assertThat(getLocation(value)).isEqualTo('39:1');
	}
	@Test
	void getPropertyWithCarriageReturn() {
		OriginTrackedValue value = getFromFirst('test-return-property');
		assertThat(getValue(value)).isEqualTo('foo\rbar');
		assertThat(getLocation(value)).isEqualTo('17:22');
	}
	@Test
	void getPropertyWithNewLine() {
		OriginTrackedValue value = getFromFirst('test-newline-property');
		assertThat(getValue(value)).isEqualTo('foo\nbar');
		assertThat(getLocation(value)).isEqualTo('18:23');
	}
	@Test
	void getPropertyWithFormFeed() {
		OriginTrackedValue value = getFromFirst('test-form-feed-property');
		assertThat(getValue(value)).isEqualTo('foo\fbar');
		assertThat(getLocation(value)).isEqualTo('19:25');
	}
	@Test
	void getPropertyWithWhiteSpace() {
		OriginTrackedValue value = getFromFirst('test-whitespace-property');
		assertThat(getValue(value)).isEqualTo('foo   bar');
		assertThat(getLocation(value)).isEqualTo('20:32');
	}
	@Test
	void getCommentedOutPropertyShouldBeNull() {
		assertThat(getFromFirst('commented-property')).isNull();
		assertThat(getFromFirst('#commented-property')).isNull();
		assertThat(getFromFirst('commented-two')).isNull();
		assertThat(getFromFirst('!commented-two')).isNull();
	}
	@Test
	void getMultiline() {
		OriginTrackedValue value = getFromFirst('test-multiline');
		assertThat(getValue(value)).isEqualTo('ab\\c');
		assertThat(getLocation(value)).isEqualTo('21:17');
	}
	@Test
	void getImmediateMultiline() {
		OriginTrackedValue value = getFromFirst('test-multiline-immediate');
		assertThat(getValue(value)).isEqualTo('foo');
		assertThat(getLocation(value)).isEqualTo('32:1');
	}
	@Test
	void loadWhenMultiDocumentWithPoundPrefixAndWithoutWhitespaceLoadsMultiDoc() throws IOException {
		String content = 'a=a\n#---\nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(2);
	}
	@Test
	void loadWhenMultiDocumentWithExclamationPrefixAndWithoutWhitespaceLoadsMultiDoc() throws IOException {
		String content = 'a=a\n!---\nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(2);
	}
	@Test
	void loadWhenMultiDocumentWithPoundPrefixAndLeadingWhitespaceLoadsSingleDoc() throws IOException {
		String content = 'a=a\n \t#---\nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(1);
	}
	@Test
	void loadWhenMultiDocumentWithExclamationPrefixAndLeadingWhitespaceLoadsSingleDoc() throws IOException {
		String content = 'a=a\n \t!---\nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(1);
	}
	@Test
	void loadWhenMultiDocumentWithPoundPrefixAndTrailingWhitespaceLoadsMultiDoc() throws IOException {
		String content = 'a=a\n#--- \t \nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(2);
	}
	@Test
	void loadWhenMultiDocumentWithExclamationPrefixAndTrailingWhitespaceLoadsMultiDoc() throws IOException {
		String content = 'a=a\n!--- \t \nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(2);
	}
	@Test
	void loadWhenMultiDocumentWithPoundPrefixAndTrailingCharsLoadsSingleDoc() throws IOException {
		String content = 'a=a\n#--- \tcomment\nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(1);
	}
	@Test
	void loadWhenMultiDocumentWithExclamationPrefixAndTrailingCharsLoadsSingleDoc() throws IOException {
		String content = 'a=a\n!--- \tcomment\nb=b';
		List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
		assertThat(loaded).hasSize(1);
	}
	@Test
	void loadWhenMultiDocumentSeparatorPrefixDifferentFromCommentPrefixLoadsMultiDoc() throws IOException {
		String[] contents = new String[] { 'a=a\n# comment\n!---\nb=b', 'a=a\n! comment\n#---\nb=b' };
		for (String content : contents) {
			List<Document> loaded = new OriginTrackedPropertiesLoader(new ByteArrayResource(content.getBytes())).load();
			assertThat(loaded).hasSize(2);
		}
	}
	@Test
	void getPropertyWithWhitespaceAfterKey() {
		OriginTrackedValue value = getFromFirst('bar');
		assertThat(getValue(value)).isEqualTo('foo=baz');
		assertThat(getLocation(value)).isEqualTo('3:7');
	}
	@Test
	void getPropertyWithSpaceSeparator() {
		OriginTrackedValue value = getFromFirst('hello');
		assertThat(getValue(value)).isEqualTo('world');
		assertThat(getLocation(value)).isEqualTo('4:9');
	}
	@Test
	void getPropertyWithBackslashEscaped() {
		OriginTrackedValue value = getFromFirst('proper\\ty');
		assertThat(getValue(value)).isEqualTo('test');
		assertThat(getLocation(value)).isEqualTo('5:11');
	}
	@Test
	void getPropertyWithEmptyValue() {
		OriginTrackedValue value = getFromFirst('foo');
		assertThat(getValue(value)).isEqualTo('');
		assertThat(getLocation(value)).isEqualTo('7:0');
	}
	@Test
	void getPropertyWithBackslashEscapedInValue() {
		OriginTrackedValue value = getFromFirst('bat');
		assertThat(getValue(value)).isEqualTo('a\\');
		assertThat(getLocation(value)).isEqualTo('7:7');
	}
	@Test
	void getPropertyWithSeparatorInValue() {
		OriginTrackedValue value = getFromFirst('bling');
		assertThat(getValue(value)).isEqualTo('a=b');
		assertThat(getLocation(value)).isEqualTo('8:9');
	}
	@Test
	void getListProperty() {
		OriginTrackedValue apple = getFromFirst('foods[0]');
		assertThat(getValue(apple)).isEqualTo('Apple');
		assertThat(getLocation(apple)).isEqualTo('24:9');
		OriginTrackedValue orange = getFromFirst('foods[1]');
		assertThat(getValue(orange)).isEqualTo('Orange');
		assertThat(getLocation(orange)).isEqualTo('25:1');
		OriginTrackedValue strawberry = getFromFirst('foods[2]');
		assertThat(getValue(strawberry)).isEqualTo('Strawberry');
		assertThat(getLocation(strawberry)).isEqualTo('26:1');
		OriginTrackedValue mango = getFromFirst('foods[3]');
		assertThat(getValue(mango)).isEqualTo('Mango');
		assertThat(getLocation(mango)).isEqualTo('27:1');
	}
	@Test
	void getPropertyWithISO88591Character() {
		OriginTrackedValue value = getFromFirst('test-iso8859-1-chars');
		assertThat(getValue(value)).isEqualTo('');
	}
	@Test
	void getPropertyWithTrailingSpace() {
		OriginTrackedValue value = getFromFirst('test-with-trailing-space');
		assertThat(getValue(value)).isEqualTo('trailing ');
	}
	@Test
	void getPropertyWithEscapedTrailingSpace() {
		OriginTrackedValue value = getFromFirst('test-with-escaped-trailing-space');
		assertThat(getValue(value)).isEqualTo('trailing ');
	}
	@Test
	void existingCommentsAreNotTreatedAsMultiDoc() throws Exception {
		this.resource = new ClassPathResource('existing-non-multi-document.properties', getClass());
		this.documents = new OriginTrackedPropertiesLoader(this.resource).load();
		assertThat(this.documents).hasSize(1);
	}
	@Test
	void getPropertyAfterPoundCharacter() {
		OriginTrackedValue value = getFromFirst('test-line-after-empty-pound');
		assertThat(getValue(value)).isEqualTo('abc');
	}
	private OriginTrackedValue getFromFirst(String key) {
		return this.documents.get(0).asMap().get(key);
	}
	private Object getValue(OriginTrackedValue value) {
		return (value != null) ? value.getValue() : null;
	}
	private String getLocation(OriginTrackedValue value) {
		if (value == null) {
			return null;
		}
		return ((TextResourceOrigin) value.getOrigin()).getLocation().toString();
	}
}
/*
package org.springframework.boot.env;
/**
class YamlPropertySourceLoaderTests {
	private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();
	@Test
	void load() throws Exception {
		ByteArrayResource resource = new ByteArrayResource('foo:\n  bar: spam'.getBytes());
		PropertySource<?> source = this.loader.load('resource', resource).get(0);
		assertThat(source).isNotNull();
		assertThat(source.getProperty('foo.bar')).isEqualTo('spam');
	}
	@Test
	void orderedItems() throws Exception {
		StringBuilder yaml = new StringBuilder();
		List<String> expected = new ArrayList<>();
		for (char c = "a"; c <= "z"; c++) {
			yaml.append(c).append(': value').append(c).append('\n');
			expected.add(String.valueOf(c));
		}
		ByteArrayResource resource = new ByteArrayResource(yaml.toString().getBytes());
		EnumerablePropertySource<?> source = (EnumerablePropertySource<?>) this.loader.load('resource', resource)
			.get(0);
		assertThat(source).isNotNull();
		assertThat(source.getPropertyNames()).isEqualTo(StringUtils.toStringArray(expected));
	}
	@Test
	void mergeItems() throws Exception {
		StringBuilder yaml = new StringBuilder();
		yaml.append('foo:\n  bar: spam\n');
		yaml.append('---\n');
		yaml.append('foo:\n  baz: wham\n');
		ByteArrayResource resource = new ByteArrayResource(yaml.toString().getBytes());
		List<PropertySource<?>> loaded = this.loader.load('resource', resource);
		assertThat(loaded).hasSize(2);
		assertThat(loaded.get(0).getProperty('foo.bar')).isEqualTo('spam');
		assertThat(loaded.get(1).getProperty('foo.baz')).isEqualTo('wham');
	}
	@Test
	void timestampLikeItemsDoNotBecomeDates() throws Exception {
		ByteArrayResource resource = new ByteArrayResource('foo: 2015-01-28'.getBytes());
		PropertySource<?> source = this.loader.load('resource', resource).get(0);
		assertThat(source).isNotNull();
		assertThat(source.getProperty('foo')).isEqualTo('2015-01-28');
	}
	@Test
	void loadOriginAware() throws Exception {
		Resource resource = new ClassPathResource('test-yaml.yml', getClass());
		List<PropertySource<?>> loaded = this.loader.load('resource', resource);
		for (PropertySource<?> source : loaded) {
			EnumerablePropertySource<?> enumerableSource = (EnumerablePropertySource<?>) source;
			for (String name : enumerableSource.getPropertyNames()) {
				System.out.println(name + ' = ' + enumerableSource.getProperty(name));
			}
		}
	}
}
/*
package org.springframework.boot.env;
/**
class OriginTrackedMapPropertySourceTests {
	private final Map<String, Object> map = new LinkedHashMap<>();
	private final OriginTrackedMapPropertySource source = new OriginTrackedMapPropertySource('test', this.map);
	private final Origin origin = mock(Origin.class);
	@Test
	void getPropertyWhenMissingShouldReturnNull() {
		assertThat(this.source.getProperty('test')).isNull();
	}
	@Test
	void getPropertyWhenNonTrackedShouldReturnValue() {
		this.map.put('test', 'foo');
		assertThat(this.source.getProperty('test')).isEqualTo('foo');
	}
	@Test
	void getPropertyWhenTrackedShouldReturnValue() {
		this.map.put('test', OriginTrackedValue.of('foo', this.origin));
		assertThat(this.source.getProperty('test')).isEqualTo('foo');
	}
	@Test
	void getPropertyOriginWhenMissingShouldReturnNull() {
		assertThat(this.source.getOrigin('test')).isNull();
	}
	@Test
	void getPropertyOriginWhenNonTrackedShouldReturnNull() {
		this.map.put('test', 'foo');
		assertThat(this.source.getOrigin('test')).isNull();
	}
	@Test
	void getPropertyOriginWhenTrackedShouldReturnOrigin() {
		this.map.put('test', OriginTrackedValue.of('foo', this.origin));
		assertThat(this.source.getOrigin('test')).isEqualTo(this.origin);
	}
}
/*
package org.springframework.boot.env;
/**
class EnvironmentPostProcessorApplicationListenerTests {
	@Nested
	class ListenerTests {
		private final DeferredLogs deferredLogs = spy(new DeferredLogs());
		private final DefaultBootstrapContext bootstrapContext = spy(new DefaultBootstrapContext());
		private final EnvironmentPostProcessorApplicationListener listener = new EnvironmentPostProcessorApplicationListener();
		@BeforeEach
		void setup() {
			ReflectionTestUtils.setField(this.listener, 'deferredLogs', this.deferredLogs);
			ReflectionTestUtils.setField(this.listener, 'postProcessorsFactory',
					(Function<ClassLoader, EnvironmentPostProcessorsFactory>) (
							classLoader) -> EnvironmentPostProcessorsFactory.of(TestEnvironmentPostProcessor.class));
		}
		@Test
		void createUsesSpringFactories() {
			EnvironmentPostProcessorApplicationListener listener = new EnvironmentPostProcessorApplicationListener();
			assertThat(listener.getEnvironmentPostProcessors(null, this.bootstrapContext)).hasSizeGreaterThan(1);
		}
		@Test
		void createWhenHasFactoryUsesFactory() {
			EnvironmentPostProcessorApplicationListener listener = EnvironmentPostProcessorApplicationListener
				.with(EnvironmentPostProcessorsFactory.of(TestEnvironmentPostProcessor.class));
			List<EnvironmentPostProcessor> postProcessors = listener.getEnvironmentPostProcessors(null,
					this.bootstrapContext);
			assertThat(postProcessors).hasSize(1);
			assertThat(postProcessors.get(0)).isInstanceOf(TestEnvironmentPostProcessor.class);
		}
		@Test
		void supportsEventTypeWhenApplicationEnvironmentPreparedEventReturnsTrue() {
			assertThat(this.listener.supportsEventType(ApplicationEnvironmentPreparedEvent.class)).isTrue();
		}
		@Test
		void supportsEventTypeWhenApplicationPreparedEventReturnsTrue() {
			assertThat(this.listener.supportsEventType(ApplicationPreparedEvent.class)).isTrue();
		}
		@Test
		void supportsEventTypeWhenApplicationFailedEventReturnsTrue() {
			assertThat(this.listener.supportsEventType(ApplicationFailedEvent.class)).isTrue();
		}
		@Test
		void supportsEventTypeWhenOtherEventReturnsFalse() {
			assertThat(this.listener.supportsEventType(ApplicationStartingEvent.class)).isFalse();
		}
		@Test
		void onApplicationEventWhenApplicationEnvironmentPreparedEventCallsPostProcessors() {
			SpringApplication application = mock(SpringApplication.class);
			MockEnvironment environment = new MockEnvironment();
			ApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(this.bootstrapContext,
					application, new String[0], environment);
			this.listener.onApplicationEvent(event);
			assertThat(environment.getProperty('processed')).isEqualTo('true');
		}
		@Test
		void onApplicationEventWhenApplicationPreparedEventSwitchesLogs() {
			SpringApplication application = mock(SpringApplication.class);
			ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
			ApplicationPreparedEvent event = new ApplicationPreparedEvent(application, new String[0], context);
			this.listener.onApplicationEvent(event);
			then(this.deferredLogs).should().switchOverAll();
		}
		@Test
		void onApplicationEventWhenApplicationFailedEventSwitchesLogs() {
			SpringApplication application = mock(SpringApplication.class);
			ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
			ApplicationFailedEvent event = new ApplicationFailedEvent(application, new String[0], context,
					new RuntimeException());
			this.listener.onApplicationEvent(event);
			then(this.deferredLogs).should().switchOverAll();
		}
		static class TestEnvironmentPostProcessor implements EnvironmentPostProcessor {
			TestEnvironmentPostProcessor(DeferredLogFactory logFactory, BootstrapRegistry bootstrapRegistry) {
				assertThat(logFactory).isNotNull();
				assertThat(bootstrapRegistry).isNotNull();
			}
			@Override
			public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
				((MockEnvironment) environment).setProperty('processed', 'true');
			}
		}
	}
	@Nested
	class AotTests {
		private static final ClassName TEST_APP = ClassName.get('com.example', 'TestApp');
		@Test
		void aotContributionIsNotNecessaryWithDefaultConfiguration() {
			assertThat(getContribution(new StandardEnvironment())).isNull();
		}
		@Test
		void aotContributionIsNotNecessaryWithDefaultProfileActive() {
			StandardEnvironment environment = new StandardEnvironment();
			environment.setDefaultProfiles('fallback');
			environment.setActiveProfiles('fallback');
			assertThat(getContribution(environment)).isNull();
		}
		@Test
		void aotContributionRegistersActiveProfiles() {
			ConfigurableEnvironment environment = new StandardEnvironment();
			environment.setActiveProfiles('one', 'two');
			compile(createContext(environment), (compiled) -> {
				EnvironmentPostProcessor environmentPostProcessor = compiled.getInstance(EnvironmentPostProcessor.class,
						ClassName.get('com.example', 'TestApp__EnvironmentPostProcessor').toString());
				StandardEnvironment freshEnvironment = new StandardEnvironment();
				environmentPostProcessor.postProcessEnvironment(freshEnvironment, new SpringApplication());
				assertThat(freshEnvironment.getActiveProfiles()).containsExactly('one', 'two');
			});
		}
		@Test
		void shouldUseAotEnvironmentPostProcessor() {
			SpringApplication application = new SpringApplication(ExampleAotProcessedApp.class);
			application.setWebApplicationType(WebApplicationType.NONE);
			application.setMainApplicationClass(ExampleAotProcessedApp.class);
			System.setProperty(AotDetector.AOT_ENABLED, 'true');
			try {
				ApplicationContext context = application.run();
				assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('one', 'three');
				assertThat(context.getBean('test')).isEqualTo('test');
			}
			finally {
				System.clearProperty(AotDetector.AOT_ENABLED);
			}
		}
		@Test
		void aotEnvironmentPostProcessorShouldBeAppliedFirst(@TempDir Path tempDir) {
			Properties properties = new Properties();
			properties.put(EnvironmentPostProcessor.class.getName(), TestEnvironmentPostProcessor.class.getName());
			ClassLoader classLoader = createClassLoaderWithAdditionalSpringFactories(tempDir, properties);
			DefaultResourceLoader resourceLoader = new DefaultResourceLoader(classLoader);
			SpringApplication application = new SpringApplication(ExampleAotProcessedApp.class);
			application.setResourceLoader(resourceLoader);
			application.setWebApplicationType(WebApplicationType.NONE);
			application.setMainApplicationClass(ExampleAotProcessedApp.class);
			System.setProperty(AotDetector.AOT_ENABLED, 'true');
			try {
				ApplicationContext context = application.run();
				// See TestEnvironmentPostProcessor
				assertThat(context.getEnvironment().getProperty('test.activeProfiles')).isEqualTo('one,three');
				assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('one', 'three');
				assertThat(context.getBean('test')).isEqualTo('test');
			}
			finally {
				System.clearProperty(AotDetector.AOT_ENABLED);
			}
		}
		@Test
		void shouldBeLenientIfAotEnvironmentPostProcessorDoesNotExist() {
			SpringApplication application = new SpringApplication(ExampleAotProcessedNoProfileApp.class);
			application.setWebApplicationType(WebApplicationType.NONE);
			application.setMainApplicationClass(ExampleAotProcessedNoProfileApp.class);
			System.setProperty(AotDetector.AOT_ENABLED, 'true');
			try {
				ApplicationContext context = application.run();
				assertThat(context.getEnvironment().getActiveProfiles()).isEmpty();
				assertThat(context.getBean('test')).isEqualTo('test');
			}
			finally {
				System.clearProperty(AotDetector.AOT_ENABLED);
			}
		}
		private BeanFactoryInitializationAotContribution getContribution(ConfigurableEnvironment environment) {
			DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
			beanFactory.registerSingleton(ConfigurableApplicationContext.ENVIRONMENT_BEAN_NAME, environment);
			return new EnvironmentBeanFactoryInitializationAotProcessor().processAheadOfTime(beanFactory);
		}
		private GenericApplicationContext createContext(ConfigurableEnvironment environment) {
			GenericApplicationContext context = new GenericApplicationContext();
			context.setEnvironment(environment);
			return context;
		}
		private void compile(GenericApplicationContext context, Consumer<Compiled> compiled) {
			TestGenerationContext generationContext = new TestGenerationContext(TEST_APP);
			new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext);
			generationContext.writeGeneratedContent();
			TestCompiler.forSystem().with(generationContext).compile(compiled);
		}
		private ClassLoader createClassLoaderWithAdditionalSpringFactories(Path tempDir, Properties properties) {
			return new ClassLoader() {
				@Override
				public Enumeration<URL> getResources(String name) throws IOException {
					Enumeration<URL> resources = super.getResources(name);
					if (SpringFactoriesLoader.FACTORIES_RESOURCE_LOCATION.equals(name)) {
						Path springFactories = tempDir.resolve('spring.factories');
						try (BufferedWriter writer = Files.newBufferedWriter(springFactories)) {
							properties.store(writer, '');
						}
						List<URL> allResources = new ArrayList<>();
						allResources.add(springFactories.toUri().toURL());
						allResources.addAll(Collections.list(resources));
						return Collections.enumeration(allResources);
					}
					return resources;
				}
			};
		}
		static class TestEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
			@Override
			public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
				MockPropertySource propertySource = new MockPropertySource().withProperty('test.activeProfiles',
						StringUtils.arrayToCommaDelimitedString(environment.getActiveProfiles()));
				environment.getPropertySources().addLast(propertySource);
			}
			@Override
			public int getOrder() {
				return Ordered.HIGHEST_PRECEDENCE;
			}
		}
		static class ExampleAotProcessedApp {
		}
		static class ExampleAotProcessedApp__ApplicationContextInitializer
				implements ApplicationContextInitializer<ConfigurableApplicationContext> {
			@Override
			public void initialize(ConfigurableApplicationContext applicationContext) {
				applicationContext.getBeanFactory().registerSingleton('test', 'test');
			}
		}
		static class ExampleAotProcessedApp__EnvironmentPostProcessor implements EnvironmentPostProcessor {
			@Override
			public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
				environment.addActiveProfile('one');
				environment.addActiveProfile('three');
			}
		}
		static class ExampleAotProcessedNoProfileApp {
		}
		static class ExampleAotProcessedNoProfileApp__ApplicationContextInitializer
				implements ApplicationContextInitializer<ConfigurableApplicationContext> {
			@Override
			public void initialize(ConfigurableApplicationContext applicationContext) {
				applicationContext.getBeanFactory().registerSingleton('test', 'test');
			}
		}
	}
}
/*
package org.springframework.boot.env;
/**
@ClassPathExclusions('snakeyaml-*.jar')
class NoSnakeYamlPropertySourceLoaderTests {
	private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();
	@Test
	void load() {
		ByteArrayResource resource = new ByteArrayResource('foo:\n  bar: spam'.getBytes());
		assertThatIllegalStateException().isThrownBy(() -> this.loader.load('resource', resource))
			.withMessageContaining('Attempted to load resource but snakeyaml was not found on the classpath');
	}
}
/*
package org.springframework.boot.env;
/**
class OriginTrackedYamlLoaderTests {
	private OriginTrackedYamlLoader loader;
	private List<Map<String, Object>> result;
	@BeforeEach
	void setUp() {
		Resource resource = new ClassPathResource('test-yaml.yml', getClass());
		this.loader = new OriginTrackedYamlLoader(resource);
	}
	@Test
	void processSimpleKey() {
		OriginTrackedValue value = getValue('name');
		assertThat(value).hasToString('Martin D"vloper');
		assertThat(getLocation(value)).isEqualTo('3:7');
	}
	@Test
	void processMap() {
		OriginTrackedValue perl = getValue('languages.perl');
		OriginTrackedValue python = getValue('languages.python');
		OriginTrackedValue pascal = getValue('languages.pascal');
		assertThat(perl).hasToString('Elite');
		assertThat(getLocation(perl)).isEqualTo('13:11');
		assertThat(python).hasToString('Elite');
		assertThat(getLocation(python)).isEqualTo('14:13');
		assertThat(pascal).hasToString('Lame');
		assertThat(getLocation(pascal)).isEqualTo('15:13');
	}
	@Test
	void processCollection() {
		OriginTrackedValue apple = getValue('foods[0]');
		OriginTrackedValue orange = getValue('foods[1]');
		OriginTrackedValue strawberry = getValue('foods[2]');
		OriginTrackedValue mango = getValue('foods[3]');
		assertThat(apple).hasToString('Apple');
		assertThat(getLocation(apple)).isEqualTo('8:7');
		assertThat(orange).hasToString('Orange');
		assertThat(getLocation(orange)).isEqualTo('9:7');
		assertThat(strawberry).hasToString('Strawberry');
		assertThat(getLocation(strawberry)).isEqualTo('10:7');
		assertThat(mango).hasToString('Mango');
		assertThat(getLocation(mango)).isEqualTo('11:7');
	}
	@Test
	void processMultiline() {
		OriginTrackedValue education = getValue('education');
		assertThat(education).hasToString('4 GCSEs\n3 A-Levels\nBSc in the Internet of Things\n');
		assertThat(getLocation(education)).isEqualTo('16:12');
	}
	@Test
	void processListOfMaps() {
		OriginTrackedValue name = getValue('example.foo[0].name');
		OriginTrackedValue url = getValue('example.foo[0].url');
		OriginTrackedValue bar1 = getValue('example.foo[0].bar[0].bar1');
		OriginTrackedValue bar2 = getValue('example.foo[0].bar[1].bar2');
		assertThat(name).hasToString('springboot');
		assertThat(getLocation(name)).isEqualTo('22:15');
		assertThat(url).hasToString('https://springboot.example.com/');
		assertThat(getLocation(url)).isEqualTo('23:14');
		assertThat(bar1).hasToString('baz');
		assertThat(getLocation(bar1)).isEqualTo('25:19');
		assertThat(bar2).hasToString('bling');
		assertThat(getLocation(bar2)).isEqualTo('26:19');
	}
	@Test
	void processEmptyAndNullValues() {
		OriginTrackedValue empty = getValue('empty');
		OriginTrackedValue nullValue = getValue('null-value');
		OriginTrackedValue emptyList = getValue('emptylist');
		assertThat(empty.getValue()).isEqualTo('');
		assertThat(getLocation(empty)).isEqualTo('27:8');
		assertThat(nullValue.getValue()).isEqualTo('');
		assertThat(getLocation(nullValue)).isEqualTo('28:13');
		assertThat(emptyList.getValue()).isEqualTo('');
		assertThat(getLocation(emptyList)).isEqualTo('29:12');
	}
	@Test
	void emptyMapsAreDropped() {
		Object emptyMap = getValue('emptymap');
		assertThat(emptyMap).isNull();
	}
	@Test
	void unsupportedType() {
		String yaml = 'value: !!java.net.URL [!!java.lang.String [!!java.lang.StringBuilder [\'http://localhost:9000/\']]]';
		Resource resource = new ByteArrayResource(yaml.getBytes(StandardCharsets.UTF_8));
		this.loader = new OriginTrackedYamlLoader(resource);
		assertThatExceptionOfType(ComposerException.class).isThrownBy(this.loader::load);
	}
	@Test
	void emptyDocuments() {
		this.loader = new OriginTrackedYamlLoader(new ClassPathResource('test-empty-yaml.yml', getClass()));
		List<Map<String, Object>> loaded = this.loader.load();
		assertThat(loaded).isEmpty();
	}
	@Test
	void loadWhenLargeNumberOfNodesLoadsYaml() {
		StringBuilder yaml = new StringBuilder();
		int size = 500;
		yaml.append('defs:\n');
		for (int i = 0; i < size; i++) {
			yaml.append(' - def' + i + ': &def' + i + '\n');
			yaml.append('    - value: ' + i + '\n');
		}
		yaml.append('refs:\n');
		for (int i = 0; i < size; i++) {
			yaml.append('  ref' + i + ':\n');
			yaml.append('   - value: *def' + i + '\n');
		}
		Resource resource = new ByteArrayResource(yaml.toString().getBytes(StandardCharsets.UTF_8));
		this.loader = new OriginTrackedYamlLoader(resource);
		Map<String, Object> loaded = this.loader.load().get(0);
		assertThat(loaded).hasSize(size * 2);
	}
	@Test
	void loadWhenRecursiveLoadsYaml() {
		Resource resource = new ClassPathResource('recursive.yml', getClass());
		this.loader = new OriginTrackedYamlLoader(resource);
		Map<String, Object> loaded = this.loader.load().get(0);
		assertThat(loaded.get('test.a.spring')).hasToString('a');
		assertThat(loaded.get('test.b.boot')).hasToString('b');
	}
	@Test
	void loadWhenUsingAnchors() {
		Resource resource = new ClassPathResource('anchors.yml', getClass());
		this.loader = new OriginTrackedYamlLoader(resource);
		Map<String, Object> loaded = this.loader.load().get(0);
		assertThat(loaded.get('some.path.config.key')).hasToString('value');
		assertThat(loaded.get('some.anotherpath.config.key')).hasToString('value');
	}
	@Test
	void canLoadFilesBiggerThan3Mb() {
		StringBuilder yaml = new StringBuilder();
		while (yaml.length() < 4_194_304) {
			yaml.append('- some list entry\n');
		}
		Resource resource = new ByteArrayResource(yaml.toString().getBytes(StandardCharsets.UTF_8));
		this.loader = new OriginTrackedYamlLoader(resource);
		Map<String, Object> loaded = this.loader.load().get(0);
		assertThat(loaded).isNotEmpty();
	}
	@SuppressWarnings('unchecked')
	private <T> T getValue(String name) {
		if (this.result == null) {
			this.result = this.loader.load();
		}
		return (T) this.result.get(0).get(name);
	}
	private String getLocation(OriginTrackedValue value) {
		return ((TextResourceOrigin) value.getOrigin()).getLocation().toString();
	}
}
/*
package org.springframework.boot.env;
/**
class ReflectionEnvironmentPostProcessorsFactoryTests {
	private final DeferredLogFactory logFactory = Supplier::get;
	private final DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
	@Test
	void createWithClassesCreatesFactory() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(
				TestEnvironmentPostProcessor.class);
		assertThatFactory(factory).createsSinglePostProcessor(TestEnvironmentPostProcessor.class);
	}
	@Test
	void createWithClassNamesArrayCreatesFactory() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(null,
				TestEnvironmentPostProcessor.class.getName());
		assertThatFactory(factory).createsSinglePostProcessor(TestEnvironmentPostProcessor.class);
	}
	@Test
	void createWithClassNamesListCreatesFactory() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(null,
				Arrays.asList(TestEnvironmentPostProcessor.class.getName()));
		assertThatFactory(factory).createsSinglePostProcessor(TestEnvironmentPostProcessor.class);
	}
	@Test
	void createWithClassNamesAndClassLoaderListCreatesFactory() {
		OverridingClassLoader classLoader = new OverridingClassLoader(getClass().getClassLoader()) {
			@Override
			protected boolean isEligibleForOverriding(String className) {
				return super.isEligibleForOverriding(className)
						&& className.equals(TestEnvironmentPostProcessor.class.getName());
			}
		};
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(classLoader,
				Arrays.asList(TestEnvironmentPostProcessor.class.getName()));
		assertThatFactory(factory).createsSinglePostProcessorWithClassLoader(classLoader);
	}
	@Test
	void getEnvironmentPostProcessorsWhenHasDefaultConstructorCreatesPostProcessors() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(null,
				TestEnvironmentPostProcessor.class.getName());
		assertThatFactory(factory).createsSinglePostProcessor(TestEnvironmentPostProcessor.class);
	}
	@Test
	void getEnvironmentPostProcessorsWhenHasLogFactoryConstructorCreatesPostProcessors() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(null,
				TestLogFactoryEnvironmentPostProcessor.class.getName());
		assertThatFactory(factory).createsSinglePostProcessor(TestLogFactoryEnvironmentPostProcessor.class);
	}
	@Test
	void getEnvironmentPostProcessorsWhenHasLogConstructorCreatesPostProcessors() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(null,
				TestLogEnvironmentPostProcessor.class.getName());
		assertThatFactory(factory).createsSinglePostProcessor(TestLogEnvironmentPostProcessor.class);
	}
	@Test
	void getEnvironmentPostProcessorsWhenHasBootstrapRegistryConstructorCreatesPostProcessors() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(null,
				TestBootstrapRegistryEnvironmentPostProcessor.class.getName());
		assertThatFactory(factory).createsSinglePostProcessor(TestBootstrapRegistryEnvironmentPostProcessor.class);
	}
	@Test
	void getEnvironmentPostProcessorsWhenHasNoSuitableConstructorThrowsException() {
		ReflectionEnvironmentPostProcessorsFactory factory = new ReflectionEnvironmentPostProcessorsFactory(null,
				BadEnvironmentPostProcessor.class.getName());
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.getEnvironmentPostProcessors(this.logFactory, this.bootstrapContext))
			.withMessageContaining('Unable to instantiate');
	}
	private EnvironmentPostProcessorsFactoryAssert assertThatFactory(EnvironmentPostProcessorsFactory factory) {
		return new EnvironmentPostProcessorsFactoryAssert(factory);
	}
	class EnvironmentPostProcessorsFactoryAssert {
		private final EnvironmentPostProcessorsFactory factory;
		EnvironmentPostProcessorsFactoryAssert(EnvironmentPostProcessorsFactory factory) {
			this.factory = factory;
		}
		void createsSinglePostProcessor(Class<?> expectedType) {
			EnvironmentPostProcessor processor = getSingleProcessor();
			assertThat(processor).isInstanceOf(expectedType);
		}
		void createsSinglePostProcessorWithClassLoader(OverridingClassLoader classLoader) {
			EnvironmentPostProcessor processor = getSingleProcessor();
			assertThat(processor.getClass().getClassLoader()).isSameAs(classLoader);
		}
		private EnvironmentPostProcessor getSingleProcessor() {
			List<EnvironmentPostProcessor> processors = this.factory.getEnvironmentPostProcessors(
					ReflectionEnvironmentPostProcessorsFactoryTests.this.logFactory,
					ReflectionEnvironmentPostProcessorsFactoryTests.this.bootstrapContext);
			assertThat(processors).hasSize(1);
			return processors.get(0);
		}
	}
	static class TestEnvironmentPostProcessor implements EnvironmentPostProcessor {
		@Override
		public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		}
	}
	static class TestLogFactoryEnvironmentPostProcessor implements EnvironmentPostProcessor {
		TestLogFactoryEnvironmentPostProcessor(DeferredLogFactory logFactory) {
			assertThat(logFactory).isNotNull();
		}
		@Override
		public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		}
	}
	static class TestLogEnvironmentPostProcessor implements EnvironmentPostProcessor {
		TestLogEnvironmentPostProcessor(Log log) {
			assertThat(log).isNotNull();
		}
		@Override
		public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		}
	}
	static class TestBootstrapRegistryEnvironmentPostProcessor implements EnvironmentPostProcessor {
		TestBootstrapRegistryEnvironmentPostProcessor(BootstrapRegistry bootstrapRegistry) {
			assertThat(bootstrapRegistry).isNotNull();
		}
		@Override
		public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		}
	}
	static class BadEnvironmentPostProcessor implements EnvironmentPostProcessor {
		BadEnvironmentPostProcessor(InputStream inputStream) {
		}
		@Override
		public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		}
	}
}
/*
package org.springframework.boot.env;
/**
class EnvironmentPostProcessorsFactoryTests {
	private final DeferredLogFactory logFactory = Supplier::get;
	private final DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
	@Test
	void fromSpringFactoriesReturnsFactory() {
		EnvironmentPostProcessorsFactory factory = EnvironmentPostProcessorsFactory.fromSpringFactories(null);
		List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory,
				this.bootstrapContext);
		assertThat(processors).hasSizeGreaterThan(1);
	}
	@Test
	void ofClassesReturnsFactory() {
		EnvironmentPostProcessorsFactory factory = EnvironmentPostProcessorsFactory
			.of(TestEnvironmentPostProcessor.class);
		List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory,
				this.bootstrapContext);
		assertThat(processors).hasSize(1);
		assertThat(processors.get(0)).isInstanceOf(TestEnvironmentPostProcessor.class);
	}
	@Test
	void ofClassNamesReturnsFactory() {
		EnvironmentPostProcessorsFactory factory = EnvironmentPostProcessorsFactory
			.of(TestEnvironmentPostProcessor.class.getName());
		List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory,
				this.bootstrapContext);
		assertThat(processors).hasSize(1);
		assertThat(processors.get(0)).isInstanceOf(TestEnvironmentPostProcessor.class);
	}
	@Test
	void ofClassNamesWithClassLoaderReturnsFactory() {
		OverridingClassLoader classLoader = new OverridingClassLoader(getClass().getClassLoader()) {
			@Override
			protected boolean isEligibleForOverriding(String className) {
				return super.isEligibleForOverriding(className)
						&& className.equals(TestEnvironmentPostProcessor.class.getName());
			}
		};
		EnvironmentPostProcessorsFactory factory = EnvironmentPostProcessorsFactory.of(classLoader,
				TestEnvironmentPostProcessor.class.getName());
		List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory,
				this.bootstrapContext);
		assertThat(processors).hasSize(1);
		assertThat(processors.get(0).getClass().getClassLoader()).isSameAs(classLoader);
	}
	static class TestEnvironmentPostProcessor implements EnvironmentPostProcessor {
		TestEnvironmentPostProcessor(DeferredLogFactory logFactory) {
		}
		@Override
		public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		}
	}
}
/*
package org.springframework.boot.env;
/**
class ConfigTreePropertySourceTests {
	@TempDir
	Path directory;
	@Test
	void createWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigTreePropertySource(null, this.directory))
			.withMessageContaining('name must contain');
	}
	@Test
	void createWhenSourceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigTreePropertySource('test', null))
			.withMessage('Property source must not be null');
	}
	@Test
	void createWhenSourceDoesNotExistThrowsException() {
		Path missing = this.directory.resolve('missing');
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigTreePropertySource('test', missing))
			.withMessage('Directory "' + missing + '" does not exist');
	}
	@Test
	void createWhenSourceIsFileThrowsException() throws Exception {
		Path file = this.directory.resolve('file');
		FileCopyUtils.copy('test'.getBytes(StandardCharsets.UTF_8), file.toFile());
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigTreePropertySource('test', file))
			.withMessage('File "' + file + '" is not a directory');
	}
	@Test
	void getPropertyNamesFromFlatReturnsPropertyNames() throws Exception {
		ConfigTreePropertySource propertySource = getFlatPropertySource();
		assertThat(propertySource.getPropertyNames()).containsExactly('a', 'b', 'c', 'one');
	}
	@Test
	void getPropertyNamesFromNestedReturnsPropertyNames() throws Exception {
		ConfigTreePropertySource propertySource = getNestedPropertySource();
		assertThat(propertySource.getPropertyNames()).containsExactly('c', 'fa.a', 'fa.b', 'fb.a', 'fb.fa.a');
	}
	@Test
	void getPropertyNamesFromNestedWithSymlinkInPathReturnsPropertyNames() throws Exception {
		addNested();
		Path symlinkTempDir = Files.createSymbolicLink(this.directory.resolveSibling('symlinkTempDir'), this.directory);
		ConfigTreePropertySource propertySource = new ConfigTreePropertySource('test', symlinkTempDir);
		Files.delete(symlinkTempDir);
		assertThat(propertySource.getPropertyNames()).containsExactly('c', 'fa.a', 'fa.b', 'fb.a', 'fb.fa.a');
	}
	@Test
	void getPropertyNamesFromFlatWithSymlinksIgnoresHiddenFiles() throws Exception {
		ConfigTreePropertySource propertySource = getSymlinkedFlatPropertySource();
		assertThat(propertySource.getPropertyNames()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getPropertyNamesFromNestedWithSymlinksIgnoresHiddenFiles() throws Exception {
		ConfigTreePropertySource propertySource = getSymlinkedNestedPropertySource();
		assertThat(propertySource.getPropertyNames()).containsExactly('aa', 'ab', 'baa', 'c');
	}
	@Test
	void getPropertyNamesWhenLowercaseReturnsPropertyNames() throws Exception {
		addProperty('SpRiNg', 'boot');
		ConfigTreePropertySource propertySource = new ConfigTreePropertySource('test', this.directory,
				Option.USE_LOWERCASE_NAMES);
		assertThat(propertySource.getPropertyNames()).containsExactly('spring');
	}
	@Test
	void getPropertyFromFlatReturnsFileContent() throws Exception {
		ConfigTreePropertySource propertySource = getFlatPropertySource();
		assertThat(propertySource.getProperty('b')).hasToString('B');
	}
	@Test
	void getPropertyFromFlatWhenMissingReturnsNull() throws Exception {
		ConfigTreePropertySource propertySource = getFlatPropertySource();
		assertThat(propertySource.getProperty('missing')).isNull();
	}
	@Test
	void getPropertyFromFlatWhenFileDeletedThrowsException() throws Exception {
		ConfigTreePropertySource propertySource = getFlatPropertySource();
		Path b = this.directory.resolve('b');
		Files.delete(b);
		assertThatIllegalStateException().isThrownBy(() -> propertySource.getProperty('b').toString())
			.withMessage('The property file "' + b + '" no longer exists');
	}
	@Test
	void getOriginFromFlatReturnsOrigin() throws Exception {
		ConfigTreePropertySource propertySource = getFlatPropertySource();
		TextResourceOrigin origin = (TextResourceOrigin) propertySource.getOrigin('b');
		assertThat(origin.getResource().getFile()).isEqualTo(this.directory.resolve('b').toFile());
		assertThat(origin.getLocation().getLine()).isZero();
		assertThat(origin.getLocation().getColumn()).isZero();
	}
	@Test
	void getOriginFromFlatWhenMissingReturnsNull() throws Exception {
		ConfigTreePropertySource propertySource = getFlatPropertySource();
		assertThat(propertySource.getOrigin('missing')).isNull();
	}
	@Test
	void getPropertyViaEnvironmentSupportsConversion() throws Exception {
		StandardEnvironment environment = new StandardEnvironment();
		ConversionService conversionService = ApplicationConversionService.getSharedInstance();
		environment.setConversionService((ConfigurableConversionService) conversionService);
		environment.getPropertySources().addFirst(getFlatPropertySource());
		assertThat(environment.getProperty('a')).isEqualTo('A');
		assertThat(environment.getProperty('b')).isEqualTo('B');
		assertThat(environment.getProperty('c', InputStreamSource.class).getInputStream()).hasContent('C');
		assertThat(environment.getProperty('c', byte[].class)).contains("C");
		assertThat(environment.getProperty('one', Integer.class)).isOne();
	}
	@Test
	void getPropertyFromNestedReturnsFileContent() throws Exception {
		ConfigTreePropertySource propertySource = getNestedPropertySource();
		assertThat(propertySource.getProperty('fb.fa.a')).hasToString('BAA');
	}
	@Test
	void getPropertyWhenNotAlwaysReadIgnoresUpdates() throws Exception {
		ConfigTreePropertySource propertySource = getNestedPropertySource();
		Value v1 = propertySource.getProperty('fa.b');
		Value v2 = propertySource.getProperty('fa.b');
		assertThat(v1).isSameAs(v2);
		assertThat(v1).hasToString('AB');
		assertThat(FileCopyUtils.copyToByteArray(v1.getInputStream())).containsExactly("A", "B");
		addProperty('fa/b', 'XX');
		assertThat(v1).hasToString('AB');
		assertThat(FileCopyUtils.copyToByteArray(v1.getInputStream())).containsExactly("A", "B");
	}
	@Test
	void getPropertyWhenAlwaysReadReflectsUpdates() throws Exception {
		addNested();
		ConfigTreePropertySource propertySource = new ConfigTreePropertySource('test', this.directory,
				Option.ALWAYS_READ);
		Value v1 = propertySource.getProperty('fa.b');
		Value v2 = propertySource.getProperty('fa.b');
		assertThat(v1).isNotSameAs(v2);
		assertThat(v1).hasToString('AB');
		assertThat(FileCopyUtils.copyToByteArray(v1.getInputStream())).containsExactly("A", "B");
		addProperty('fa/b', 'XX');
		assertThat(v1).hasToString('XX');
		assertThat(FileCopyUtils.copyToByteArray(v1.getInputStream())).containsExactly("X", "X");
		assertThat(propertySource.getProperty('fa.b')).hasToString('XX');
	}
	@Test
	void getPropertyWhenLowercaseReturnsValue() throws Exception {
		addProperty('SpRiNg', 'boot');
		ConfigTreePropertySource propertySource = new ConfigTreePropertySource('test', this.directory,
				Option.USE_LOWERCASE_NAMES);
		assertThat(propertySource.getProperty('spring')).hasToString('boot');
	}
	@Test
	void getPropertyAsStringWhenMultiLinePropertyReturnsNonTrimmed() throws Exception {
		addProperty('a', 'a\nb\n');
		ConfigTreePropertySource propertySource = new ConfigTreePropertySource('test', this.directory,
				Option.AUTO_TRIM_TRAILING_NEW_LINE);
		assertThat(propertySource.getProperty('a')).hasToString('a\nb\n');
	}
	@Test
	void getPropertyAsStringWhenPropertyEndsWithNewLineReturnsTrimmed() throws Exception {
		addProperty('a', 'a\n');
		ConfigTreePropertySource propertySource = new ConfigTreePropertySource('test', this.directory,
				Option.AUTO_TRIM_TRAILING_NEW_LINE);
		assertThat(propertySource.getProperty('a')).hasToString('a');
	}
	@Test
	void getPropertyAsStringWhenPropertyEndsWithWindowsNewLineReturnsTrimmed() throws Exception {
		addProperty('a', 'a\r\n');
		ConfigTreePropertySource propertySource = new ConfigTreePropertySource('test', this.directory,
				Option.AUTO_TRIM_TRAILING_NEW_LINE);
		assertThat(propertySource.getProperty('a')).hasToString('a');
	}
	private ConfigTreePropertySource getFlatPropertySource() throws IOException {
		addProperty('a', 'A');
		addProperty('b', 'B');
		addProperty('c', 'C');
		addProperty('one', '1');
		return new ConfigTreePropertySource('test', this.directory);
	}
	private ConfigTreePropertySource getSymlinkedFlatPropertySource() throws IOException {
		addProperty('..hidden-a', 'A');
		addProperty('..hidden-b', 'B');
		addProperty('..hidden-c', 'C');
		createSymbolicLink('a', '..hidden-a');
		createSymbolicLink('b', '..hidden-b');
		createSymbolicLink('c', '..hidden-c');
		return new ConfigTreePropertySource('test', this.directory);
	}
	private ConfigTreePropertySource getNestedPropertySource() throws IOException {
		addNested();
		return new ConfigTreePropertySource('test', this.directory);
	}
	private void addNested() throws IOException {
		addProperty('fa/a', 'AA');
		addProperty('fa/b', 'AB');
		addProperty('fb/a', 'BA');
		addProperty('fb/fa/a', 'BAA');
		addProperty('c', 'C');
	}
	private ConfigTreePropertySource getSymlinkedNestedPropertySource() throws IOException {
		addProperty('..hidden-a/a', 'AA');
		addProperty('..hidden-a/b', 'AB');
		addProperty('..hidden-b/fa/a', 'BAA');
		addProperty('c', 'C');
		createSymbolicLink('aa', '..hidden-a/a');
		createSymbolicLink('ab', '..hidden-a/b');
		createSymbolicLink('baa', '..hidden-b/fa/a');
		return new ConfigTreePropertySource('test', this.directory);
	}
	private void addProperty(String path, String value) throws IOException {
		File file = this.directory.resolve(path).toFile();
		file.getParentFile().mkdirs();
		FileCopyUtils.copy(value.getBytes(StandardCharsets.UTF_8), file);
	}
	private void createSymbolicLink(String link, String target) throws IOException {
		Files.createSymbolicLink(this.directory.resolve(link).toAbsolutePath(),
				this.directory.resolve(target).toAbsolutePath());
	}
}
/*
package org.springframework.boot.jackson;
/**
class JsonMixinModuleTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void jsonWithModuleEmptyMixInWithEmptyTypesShouldFailed() {
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(() -> load(EmptyMixIn.class))
			.withMessageContaining('Error creating bean with name "jsonMixinModule"')
			.withStackTraceContaining('@JsonMixin annotation on class '
					+ '"org.springframework.boot.jackson.scan.f.EmptyMixIn" does not specify any types');
	}
	@Test
	void jsonWithModuleWithRenameMixInClassShouldBeMixedIn() throws Exception {
		load(RenameMixInClass.class);
		JsonMixinModule module = this.context.getBean(JsonMixinModule.class);
		assertMixIn(module, new Name('spring'), '{\'username\':\'spring\'}');
		assertMixIn(module, new NameAndAge('spring', 100), '{\'age\':100,\'username\':\'spring\'}');
	}
	@Test
	void jsonWithModuleWithEmptyMixInClassShouldNotBeMixedIn() throws Exception {
		load(EmptyMixInClass.class);
		JsonMixinModule module = this.context.getBean(JsonMixinModule.class);
		assertMixIn(module, new Name('spring'), '{\'name\':\'spring\'}');
		assertMixIn(module, new NameAndAge('spring', 100), '{\'name\':\'spring\',\'age\':100}');
	}
	@Test
	void jsonWithModuleWithRenameMixInAbstractClassShouldBeMixedIn() throws Exception {
		load(RenameMixInAbstractClass.class);
		JsonMixinModule module = this.context.getBean(JsonMixinModule.class);
		assertMixIn(module, new NameAndAge('spring', 100), '{\'age\':100,\'username\':\'spring\'}');
	}
	@Test
	void jsonWithModuleWithRenameMixInInterfaceShouldBeMixedIn() throws Exception {
		load(RenameMixInInterface.class);
		JsonMixinModule module = this.context.getBean(JsonMixinModule.class);
		assertMixIn(module, new NameAndAge('spring', 100), '{\'age\':100,\'username\':\'spring\'}');
	}
	private void load(Class<?>... basePackageClasses) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.registerBean(JsonMixinModule.class, () -> createJsonMixinModule(context, basePackageClasses));
		context.refresh();
		this.context = context;
	}
	private JsonMixinModule createJsonMixinModule(AnnotationConfigApplicationContext context,
			Class<?>... basePackageClasses) {
		List<String> basePackages = Arrays.stream(basePackageClasses).map(ClassUtils::getPackageName).toList();
		JsonMixinModuleEntries entries = JsonMixinModuleEntries.scan(context, basePackages);
		JsonMixinModule jsonMixinModule = new JsonMixinModule();
		jsonMixinModule.registerEntries(entries, context.getClassLoader());
		return jsonMixinModule;
	}
	private void assertMixIn(Module module, Name value, String expectedJson) throws Exception {
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		String json = mapper.writeValueAsString(value);
		assertThat(json).isEqualToIgnoringWhitespace(expectedJson);
	}
}
/*
package org.springframework.boot.jackson;
/**
class JsonObjectDeserializerTests {
	private final TestJsonObjectDeserializer<Object> testDeserializer = new TestJsonObjectDeserializer<>();
	@Test
	void deserializeObjectShouldReadJson() throws Exception {
		Deserializer deserializer = new NameAndAgeJsonComponent.Deserializer();
		SimpleModule module = new SimpleModule();
		module.addDeserializer(NameAndAge.class, deserializer);
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		NameAndAge nameAndAge = mapper.readValue('{\'name\':\'spring\',\'age\':100}', NameAndAge.class);
		assertThat(nameAndAge.getName()).isEqualTo('spring');
		assertThat(nameAndAge.getAge()).isEqualTo(100);
	}
	@Test
	void nullSafeValueWhenValueIsNullShouldReturnNull() {
		String value = this.testDeserializer.testNullSafeValue(null, String.class);
		assertThat(value).isNull();
	}
	@Test
	void nullSafeValueWhenClassIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.testDeserializer.testNullSafeValue(mock(JsonNode.class), null))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void nullSafeValueWhenClassIsStringShouldReturnString() {
		JsonNode node = mock(JsonNode.class);
		given(node.textValue()).willReturn('abc');
		String value = this.testDeserializer.testNullSafeValue(node, String.class);
		assertThat(value).isEqualTo('abc');
	}
	@Test
	void nullSafeValueWhenClassIsBooleanShouldReturnBoolean() {
		JsonNode node = mock(JsonNode.class);
		given(node.booleanValue()).willReturn(true);
		Boolean value = this.testDeserializer.testNullSafeValue(node, Boolean.class);
		assertThat(value).isTrue();
	}
	@Test
	void nullSafeValueWhenClassIsLongShouldReturnLong() {
		JsonNode node = mock(JsonNode.class);
		given(node.longValue()).willReturn(10L);
		Long value = this.testDeserializer.testNullSafeValue(node, Long.class);
		assertThat(value).isEqualTo(10L);
	}
	@Test
	void nullSafeValueWhenClassIsIntegerShouldReturnInteger() {
		JsonNode node = mock(JsonNode.class);
		given(node.intValue()).willReturn(10);
		Integer value = this.testDeserializer.testNullSafeValue(node, Integer.class);
		assertThat(value).isEqualTo(10);
	}
	@Test
	void nullSafeValueWhenClassIsShortShouldReturnShort() {
		JsonNode node = mock(JsonNode.class);
		given(node.shortValue()).willReturn((short) 10);
		Short value = this.testDeserializer.testNullSafeValue(node, Short.class);
		assertThat(value).isEqualTo((short) 10);
	}
	@Test
	void nullSafeValueWhenClassIsDoubleShouldReturnDouble() {
		JsonNode node = mock(JsonNode.class);
		given(node.doubleValue()).willReturn(1.1D);
		Double value = this.testDeserializer.testNullSafeValue(node, Double.class);
		assertThat(value).isEqualTo(1.1D);
	}
	@Test
	void nullSafeValueWhenClassIsFloatShouldReturnFloat() {
		JsonNode node = mock(JsonNode.class);
		given(node.floatValue()).willReturn(1.1F);
		Float value = this.testDeserializer.testNullSafeValue(node, Float.class);
		assertThat(value).isEqualTo(1.1F);
	}
	@Test
	void nullSafeValueWhenClassIsBigDecimalShouldReturnBigDecimal() {
		JsonNode node = mock(JsonNode.class);
		given(node.decimalValue()).willReturn(BigDecimal.TEN);
		BigDecimal value = this.testDeserializer.testNullSafeValue(node, BigDecimal.class);
		assertThat(value).isEqualTo(BigDecimal.TEN);
	}
	@Test
	void nullSafeValueWhenClassIsBigIntegerShouldReturnBigInteger() {
		JsonNode node = mock(JsonNode.class);
		given(node.bigIntegerValue()).willReturn(BigInteger.TEN);
		BigInteger value = this.testDeserializer.testNullSafeValue(node, BigInteger.class);
		assertThat(value).isEqualTo(BigInteger.TEN);
	}
	@Test
	void nullSafeValueWhenClassIsUnknownShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.testDeserializer.testNullSafeValue(mock(JsonNode.class), InputStream.class))
			.withMessageContaining('Unsupported value type java.io.InputStream');
	}
	@Test
	void getRequiredNodeWhenTreeIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.testDeserializer.testGetRequiredNode(null, 'test'))
			.withMessageContaining('Tree must not be null');
	}
	@Test
	void getRequiredNodeWhenNodeIsNullShouldThrowException() {
		JsonNode tree = mock(JsonNode.class);
		given(tree.get('test')).willReturn(null);
		assertThatIllegalStateException().isThrownBy(() -> this.testDeserializer.testGetRequiredNode(tree, 'test'))
			.withMessageContaining('Missing JSON field "test"');
	}
	@Test
	void getRequiredNodeWhenNodeIsNullNodeShouldThrowException() {
		JsonNode tree = mock(JsonNode.class);
		given(tree.get('test')).willReturn(NullNode.instance);
		assertThatIllegalStateException().isThrownBy(() -> this.testDeserializer.testGetRequiredNode(tree, 'test'))
			.withMessageContaining('Missing JSON field "test"');
	}
	@Test
	void getRequiredNodeWhenNodeIsFoundShouldReturnNode() {
		JsonNode node = mock(JsonNode.class);
		given(node.get('test')).willReturn(node);
		assertThat(this.testDeserializer.testGetRequiredNode(node, 'test')).isEqualTo(node);
	}
	static class TestJsonObjectDeserializer<T> extends JsonObjectDeserializer<T> {
		@Override
		protected T deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,
				JsonNode tree) {
			return null;
		}
		<D> D testNullSafeValue(JsonNode jsonNode, Class<D> type) {
			return nullSafeValue(jsonNode, type);
		}
		JsonNode testGetRequiredNode(JsonNode tree, String fieldName) {
			return getRequiredNode(tree, fieldName);
		}
	}
}
/*
package org.springframework.boot.jackson;
/**
class JsonObjectSerializerTests {
	@Test
	void serializeObjectShouldWriteJson() throws Exception {
		Serializer serializer = new NameAndAgeJsonComponent.Serializer();
		SimpleModule module = new SimpleModule();
		module.addSerializer(NameAndAge.class, serializer);
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		String json = mapper.writeValueAsString(new NameAndAge('spring', 100));
		assertThat(json).isEqualToIgnoringWhitespace('{\'name\':\'spring\',\'age\':100}');
	}
}
/*
package org.springframework.boot.jackson.types;
/**
public class Name {
	protected final String name;
	public Name(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
}
/*
package org.springframework.boot.jackson.types;
/**
public class NameAndCareer extends Name {
	private final String career;
	public NameAndCareer(String name, String career) {
		super(name);
		this.career = career;
	}
	public String getCareer() {
		return this.career;
	}
}
/*
package org.springframework.boot.jackson.types;
/**
public final class NameAndAge extends Name {
	private final int age;
	public NameAndAge(String name, int age) {
		super(name);
		this.age = age;
	}
	public int getAge() {
		return this.age;
	}
	public String asKey() {
		return this.name + ' is ' + this.age;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (obj instanceof NameAndAge other) {
			boolean rtn = true;
			rtn = rtn && ObjectUtils.nullSafeEquals(this.name, other.name);
			rtn = rtn && ObjectUtils.nullSafeEquals(this.age, other.age);
			return rtn;
		}
		return super.equals(obj);
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ObjectUtils.nullSafeHashCode(this.name);
		result = prime * result + ObjectUtils.nullSafeHashCode(this.age);
		return result;
	}
}
/*
package org.springframework.boot.jackson;
/**
@JsonComponent
public class NameAndAgeJsonComponent {
	static class Serializer extends JsonObjectSerializer<NameAndAge> {
		@Override
		protected void serializeObject(NameAndAge value, JsonGenerator jgen, SerializerProvider provider)
				throws IOException {
			jgen.writeStringField('name', value.getName());
			jgen.writeNumberField('age', value.getAge());
		}
	}
	static class Deserializer extends JsonObjectDeserializer<NameAndAge> {
		@Override
		protected NameAndAge deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,
				JsonNode tree) throws IOException {
			String name = nullSafeValue(tree.get('name'), String.class);
			Integer age = nullSafeValue(tree.get('age'), Integer.class);
			return new NameAndAge(name, age);
		}
	}
}
/*
package org.springframework.boot.jackson;
/**
@JsonComponent(type = NameAndAge.class, scope = JsonComponent.Scope.KEYS)
public class NameAndAgeJsonKeyComponent {
	static class Serializer extends JsonSerializer<NameAndAge> {
		@Override
		public void serialize(NameAndAge value, JsonGenerator jgen, SerializerProvider serializers) throws IOException {
			jgen.writeFieldName(value.asKey());
		}
	}
	static class Deserializer extends KeyDeserializer {
		@Override
		public NameAndAge deserializeKey(String key, DeserializationContext ctxt) throws IOException {
			String[] keys = key.split('is');
			return new NameAndAge(keys[0].trim(), Integer.parseInt(keys[1].trim()));
		}
	}
}
/*
package org.springframework.boot.jackson;
/**
@CompileWithForkedClassLoader
class JsonMixinModuleEntriesBeanRegistrationAotProcessorTests {
	private final TestGenerationContext generationContext = new TestGenerationContext();
	private final GenericApplicationContext applicationContext = new AnnotationConfigApplicationContext();
	@Test
	void processAheadOfTimeShouldRegisterBindingHintsForMixins() {
		registerEntries(RenameMixInClass.class);
		processAheadOfTime();
		RuntimeHints runtimeHints = this.generationContext.getRuntimeHints();
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(RenameMixInClass.class)
			.withMemberCategories(MemberCategory.DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS))
			.accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(RenameMixInClass.class, 'getName').introspect())
			.accepts(runtimeHints);
	}
	@Test
	void processAheadOfTimeWhenPublicClassShouldRegisterClass() {
		registerEntries(RenameMixInClass.class);
		compile((freshContext, compiled) -> {
			assertThat(freshContext.getBean(TestConfiguration.class).scanningInvoked).isFalse();
			JsonMixinModuleEntries jsonMixinModuleEntries = freshContext.getBean(JsonMixinModuleEntries.class);
			assertThat(jsonMixinModuleEntries).extracting('entries', InstanceOfAssertFactories.MAP)
				.containsExactly(entry(Name.class, RenameMixInClass.class),
						entry(NameAndAge.class, RenameMixInClass.class));
		});
	}
	@Test
	void processAheadOfTimeWhenNonAccessibleClassShouldRegisterClassName() {
		Class<?> privateMixinClass = ClassUtils
			.resolveClassName('org.springframework.boot.jackson.scan.e.PrivateMixInClass', null);
		registerEntries(privateMixinClass);
		compile((freshContext, compiled) -> {
			assertThat(freshContext.getBean(TestConfiguration.class).scanningInvoked).isFalse();
			JsonMixinModuleEntries jsonMixinModuleEntries = freshContext.getBean(JsonMixinModuleEntries.class);
			assertThat(jsonMixinModuleEntries).extracting('entries', InstanceOfAssertFactories.MAP)
				.containsExactly(entry(Name.class.getName(), privateMixinClass.getName()),
						entry(NameAndAge.class.getName(), privateMixinClass.getName()));
		});
	}
	private ClassName processAheadOfTime() {
		ClassName className = new ApplicationContextAotGenerator().processAheadOfTime(this.applicationContext,
				this.generationContext);
		this.generationContext.writeGeneratedContent();
		return className;
	}
	@SuppressWarnings('unchecked')
	private void compile(BiConsumer<GenericApplicationContext, Compiled> result) {
		ClassName className = processAheadOfTime();
		TestCompiler.forSystem().with(this.generationContext).compile((compiled) -> {
			GenericApplicationContext freshApplicationContext = new GenericApplicationContext();
			ApplicationContextInitializer<GenericApplicationContext> initializer = compiled
				.getInstance(ApplicationContextInitializer.class, className.toString());
			initializer.initialize(freshApplicationContext);
			freshApplicationContext.refresh();
			result.accept(freshApplicationContext, compiled);
		});
	}
	private void registerEntries(Class<?>... basePackageClasses) {
		List<String> packageNames = Arrays.stream(basePackageClasses).map(Class::getPackageName).toList();
		this.applicationContext.registerBeanDefinition('configuration',
				BeanDefinitionBuilder.rootBeanDefinition(TestConfiguration.class)
					.addConstructorArgValue(packageNames)
					.getBeanDefinition());
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		public boolean scanningInvoked;
		private final Collection<String> packageNames;
		TestConfiguration(Collection<String> packageNames) {
			this.packageNames = packageNames;
		}
		@Bean
		JsonMixinModuleEntries jsonMixinModuleEntries(ApplicationContext applicationContext) {
			this.scanningInvoked = true;
			return JsonMixinModuleEntries.scan(applicationContext, this.packageNames);
		}
	}
}
/*
package org.springframework.boot.jackson;
/**
class JsonComponentModuleTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void moduleShouldRegisterSerializers() throws Exception {
		load(OnlySerializer.class);
		JsonComponentModule module = this.context.getBean(JsonComponentModule.class);
		assertSerialize(module);
	}
	@Test
	void moduleShouldRegisterDeserializers() throws Exception {
		load(OnlyDeserializer.class);
		JsonComponentModule module = this.context.getBean(JsonComponentModule.class);
		assertDeserialize(module);
	}
	@Test
	void moduleShouldRegisterInnerClasses() throws Exception {
		load(NameAndAgeJsonComponent.class);
		JsonComponentModule module = this.context.getBean(JsonComponentModule.class);
		assertSerialize(module);
		assertDeserialize(module);
	}
	@Test
	void moduleShouldAllowInnerAbstractClasses() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(JsonComponentModule.class,
				ComponentWithInnerAbstractClass.class);
		JsonComponentModule module = context.getBean(JsonComponentModule.class);
		assertSerialize(module);
		context.close();
	}
	@Test
	void moduleShouldRegisterKeySerializers() throws Exception {
		load(OnlyKeySerializer.class);
		JsonComponentModule module = this.context.getBean(JsonComponentModule.class);
		assertKeySerialize(module);
	}
	@Test
	void moduleShouldRegisterKeyDeserializers() throws Exception {
		load(OnlyKeyDeserializer.class);
		JsonComponentModule module = this.context.getBean(JsonComponentModule.class);
		assertKeyDeserialize(module);
	}
	@Test
	void moduleShouldRegisterInnerClassesForKeyHandlers() throws Exception {
		load(NameAndAgeJsonKeyComponent.class);
		JsonComponentModule module = this.context.getBean(JsonComponentModule.class);
		assertKeySerialize(module);
		assertKeyDeserialize(module);
	}
	@Test
	void moduleShouldRegisterOnlyForSpecifiedClasses() throws Exception {
		load(NameAndCareerJsonComponent.class);
		JsonComponentModule module = this.context.getBean(JsonComponentModule.class);
		assertSerialize(module, new NameAndCareer('spring', 'developer'), '{\'name\':\'spring\'}');
		assertSerialize(module);
		assertDeserializeForSpecifiedClasses(module);
	}
	@Test
	void aotContributionRegistersReflectionHintsForSuitableInnerClasses() {
		load(ComponentWithInnerAbstractClass.class);
		ConfigurableListableBeanFactory beanFactory = this.context.getBeanFactory();
		BeanFactoryInitializationAotContribution contribution = new JsonComponentBeanFactoryInitializationAotProcessor()
			.processAheadOfTime(beanFactory);
		TestGenerationContext generationContext = new TestGenerationContext();
		contribution.applyTo(generationContext, null);
		RuntimeHints runtimeHints = generationContext.getRuntimeHints();
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(ComponentWithInnerAbstractClass.class)
			.withMemberCategory(MemberCategory.DECLARED_CLASSES)).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(ConcreteSerializer.class)
			.withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(AbstractSerializer.class)
			.withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)
			.negate()).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(NotSuitable.class)
			.withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)
			.negate()).accepts(runtimeHints);
	}
	private void load(Class<?>... configs) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(configs);
		context.register(JsonComponentModule.class);
		context.refresh();
		this.context = context;
	}
	private void assertSerialize(Module module, Name value, String expectedJson) throws Exception {
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		String json = mapper.writeValueAsString(value);
		assertThat(json).isEqualToIgnoringWhitespace(expectedJson);
	}
	private void assertSerialize(Module module) throws Exception {
		assertSerialize(module, new NameAndAge('spring', 100), '{\'name\':\'spring\',\'age\':100}');
	}
	private void assertDeserialize(Module module) throws Exception {
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		NameAndAge nameAndAge = mapper.readValue('{\'name\':\'spring\',\'age\':100}', NameAndAge.class);
		assertThat(nameAndAge.getName()).isEqualTo('spring');
		assertThat(nameAndAge.getAge()).isEqualTo(100);
	}
	private void assertDeserializeForSpecifiedClasses(JsonComponentModule module) throws IOException {
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		assertThatExceptionOfType(JsonMappingException.class)
			.isThrownBy(() -> mapper.readValue('{\'name\':\'spring\',\'age\':100}', NameAndAge.class));
		NameAndCareer nameAndCareer = mapper.readValue('{\'name\':\'spring\',\'career\':\'developer\'}',
				NameAndCareer.class);
		assertThat(nameAndCareer.getName()).isEqualTo('spring');
		assertThat(nameAndCareer.getCareer()).isEqualTo('developer');
	}
	private void assertKeySerialize(Module module) throws Exception {
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		Map<NameAndAge, Boolean> map = new HashMap<>();
		map.put(new NameAndAge('spring', 100), true);
		String json = mapper.writeValueAsString(map);
		assertThat(json).isEqualToIgnoringWhitespace('{\'spring is 100\':  true}');
	}
	private void assertKeyDeserialize(Module module) throws IOException {
		ObjectMapper mapper = new ObjectMapper();
		mapper.registerModule(module);
		TypeReference<Map<NameAndAge, Boolean>> typeRef = new TypeReference<>() {
		};
		Map<NameAndAge, Boolean> map = mapper.readValue('{\'spring is 100\':  true}', typeRef);
		assertThat(map).containsEntry(new NameAndAge('spring', 100), true);
	}
	@JsonComponent
	static class OnlySerializer extends NameAndAgeJsonComponent.Serializer {
	}
	@JsonComponent
	static class OnlyDeserializer extends NameAndAgeJsonComponent.Deserializer {
	}
	@JsonComponent
	static class ComponentWithInnerAbstractClass {
		abstract static class AbstractSerializer extends NameAndAgeJsonComponent.Serializer {
		}
		static class ConcreteSerializer extends AbstractSerializer {
		}
		static class NotSuitable {
		}
	}
	@JsonComponent(scope = JsonComponent.Scope.KEYS)
	static class OnlyKeySerializer extends NameAndAgeJsonKeyComponent.Serializer {
	}
	@JsonComponent(scope = JsonComponent.Scope.KEYS, type = NameAndAge.class)
	static class OnlyKeyDeserializer extends NameAndAgeJsonKeyComponent.Deserializer {
	}
}
/*
package org.springframework.boot.jackson.scan.f;
@JsonMixin
public interface EmptyMixIn {
	@JsonProperty('username')
	String getName();
}
/*
package org.springframework.boot.jackson.scan.e;
@JsonMixin(type = { Name.class, NameAndAge.class })
class PrivateMixInClass {
	@JsonProperty('username')
	String getName() {
		return null;
	}
}
/*
package org.springframework.boot.jackson.scan.c;
@JsonMixin(type = NameAndAge.class)
public interface RenameMixInInterface {
	@JsonProperty('username')
	String getName();
}
/*
package org.springframework.boot.jackson.scan.b;
@JsonMixin(type = NameAndAge.class)
public abstract class RenameMixInAbstractClass {
	@JsonProperty('username')
	abstract String getName();
}
/*
package org.springframework.boot.jackson.scan.a;
@JsonMixin(type = { Name.class, NameAndAge.class })
public abstract class RenameMixInClass {
	@JsonProperty('username')
	public abstract String getName();
}
/*
package org.springframework.boot.jackson.scan.d;
@JsonMixin(type = { Name.class, NameAndAge.class })
public class EmptyMixInClass {
}
/*
package org.springframework.boot.jackson;
/**
@JsonComponent(type = NameAndCareer.class)
public class NameAndCareerJsonComponent {
	static class Serializer extends JsonObjectSerializer<Name> {
		@Override
		protected void serializeObject(Name value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
			jgen.writeStringField('name', value.getName());
		}
	}
	static class Deserializer extends JsonObjectDeserializer<Name> {
		@Override
		protected Name deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,
				JsonNode tree) throws IOException {
			String name = nullSafeValue(tree.get('name'), String.class);
			String career = nullSafeValue(tree.get('career'), String.class);
			return new NameAndCareer(name, career);
		}
	}
}
/*
package org.springframework.boot.http.client;
/**
class HttpComponentsClientHttpRequestFactoryBuilderTests
		extends AbstractClientHttpRequestFactoryBuilderTests<HttpComponentsClientHttpRequestFactory> {
	HttpComponentsClientHttpRequestFactoryBuilderTests() {
		super(HttpComponentsClientHttpRequestFactory.class, ClientHttpRequestFactoryBuilder.httpComponents());
	}
	@Override
	protected long connectTimeout(HttpComponentsClientHttpRequestFactory requestFactory) {
		return (long) ReflectionTestUtils.getField(requestFactory, 'connectTimeout');
	}
	@Override
	@SuppressWarnings('unchecked')
	protected long readTimeout(HttpComponentsClientHttpRequestFactory requestFactory) {
		HttpClient httpClient = requestFactory.getHttpClient();
		Object connectionManager = ReflectionTestUtils.getField(httpClient, 'connManager');
		SocketConfig socketConfig = ((Resolver<HttpRoute, SocketConfig>) ReflectionTestUtils.getField(connectionManager,
				'socketConfigResolver'))
			.resolve(null);
		return socketConfig.getSoTimeout().toMilliseconds();
	}
}
/*
package org.springframework.boot.http.client;
/**
class ReactorClientHttpRequestFactoryBuilderTests
		extends AbstractClientHttpRequestFactoryBuilderTests<ReactorClientHttpRequestFactory> {
	ReactorClientHttpRequestFactoryBuilderTests() {
		super(ReactorClientHttpRequestFactory.class, ClientHttpRequestFactoryBuilder.reactor());
	}
	@Override
	protected long connectTimeout(ReactorClientHttpRequestFactory requestFactory) {
		return (int) ((HttpClient) ReflectionTestUtils.getField(requestFactory, 'httpClient')).configuration()
			.options()
			.get(ChannelOption.CONNECT_TIMEOUT_MILLIS);
	}
	@Override
	protected long readTimeout(ReactorClientHttpRequestFactory requestFactory) {
		return ((Duration) ReflectionTestUtils.getField(requestFactory, 'readTimeout')).toMillis();
	}
}
/*
package org.springframework.boot.http.client;
/**
@DirtiesUrlFactories
abstract class AbstractClientHttpRequestFactoryBuilderTests<T extends ClientHttpRequestFactory> {
	private final Class<T> requestFactoryType;
	private final ClientHttpRequestFactoryBuilder<T> builder;
	AbstractClientHttpRequestFactoryBuilderTests(Class<T> requestFactoryType,
			ClientHttpRequestFactoryBuilder<T> builder) {
		this.requestFactoryType = requestFactoryType;
		this.builder = builder;
	}
	@Test
	void buildReturnsRequestFactoryOfExpectedType() {
		T requestFactory = this.builder.build();
		assertThat(requestFactory).isInstanceOf(this.requestFactoryType);
	}
	@Test
	void buildWhenHasConnectTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(60));
		T requestFactory = this.builder.build(settings);
		assertThat(connectTimeout(requestFactory)).isEqualTo(Duration.ofSeconds(60).toMillis());
	}
	@Test
	void buildWhenHadReadTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withReadTimeout(Duration.ofSeconds(120));
		T requestFactory = this.builder.build(settings);
		assertThat(readTimeout(requestFactory)).isEqualTo(Duration.ofSeconds(120).toMillis());
	}
	@ParameterizedTest
	@ValueSource(strings = { 'GET', 'POST' })
	void connectWithSslBundle(String httpMethod) throws Exception {
		TomcatServletWebServerFactory webServerFactory = new TomcatServletWebServerFactory(0);
		webServerFactory.setSsl(ssl());
		WebServer webServer = webServerFactory
			.getWebServer((context) -> context.addServlet('test', TestServlet.class).addMapping('/'));
		try {
			webServer.start();
			int port = webServer.getPort();
			URI uri = new URI('https://localhost:%s'.formatted(port));
			ClientHttpRequestFactory insecureRequestFactory = this.builder.build();
			ClientHttpRequest insecureRequest = request(insecureRequestFactory, uri, httpMethod);
			assertThatExceptionOfType(SSLHandshakeException.class)
				.isThrownBy(() -> insecureRequest.execute().getBody());
			ClientHttpRequestFactory secureRequestFactory = this.builder
				.build(ClientHttpRequestFactorySettings.ofSslBundle(sslBundle()));
			ClientHttpRequest secureRequest = request(secureRequestFactory, uri, httpMethod);
			String secureResponse = StreamUtils.copyToString(secureRequest.execute().getBody(), StandardCharsets.UTF_8);
			assertThat(secureResponse).contains('Received ' + httpMethod + ' request to /');
		}
		finally {
			webServer.stop();
		}
	}
	@Test
	void redirectDefault() throws Exception {
		testRedirect(null, HttpStatus.OK);
	}
	@Test
	void redirectFollow() throws Exception {
		testRedirect(ClientHttpRequestFactorySettings.defaults().withRedirects(Redirects.FOLLOW), HttpStatus.OK);
	}
	@Test
	void redirectDontFollow() throws Exception {
		testRedirect(ClientHttpRequestFactorySettings.defaults().withRedirects(Redirects.DONT_FOLLOW),
				HttpStatus.FOUND);
	}
	private void testRedirect(ClientHttpRequestFactorySettings settings, HttpStatus expectedStatus)
			throws URISyntaxException, IOException {
		TomcatServletWebServerFactory webServerFactory = new TomcatServletWebServerFactory(0);
		WebServer webServer = webServerFactory
			.getWebServer((context) -> context.addServlet('test', TestServlet.class).addMapping('/'));
		try {
			webServer.start();
			int port = webServer.getPort();
			URI uri = new URI('http://localhost:%s'.formatted(port) + '/redirect');
			ClientHttpRequestFactory requestFactory = this.builder.build(settings);
			ClientHttpRequest request = requestFactory.createRequest(uri, HttpMethod.GET);
			ClientHttpResponse response = request.execute();
			assertThat(response.getStatusCode()).isEqualTo(expectedStatus);
			if (expectedStatus == HttpStatus.OK) {
				assertThat(response.getBody()).asString(StandardCharsets.UTF_8)
					.contains('Received GET request to /redirected');
			}
		}
		finally {
			webServer.stop();
		}
	}
	private ClientHttpRequest request(ClientHttpRequestFactory factory, URI uri, String method) throws IOException {
		return factory.createRequest(uri, HttpMethod.valueOf(method));
	}
	private Ssl ssl() {
		Ssl ssl = new Ssl();
		ssl.setClientAuth(ClientAuth.NEED);
		ssl.setKeyPassword('password');
		ssl.setKeyStore('classpath:test.jks');
		ssl.setTrustStore('classpath:test.jks');
		return ssl;
	}
	protected final SslBundle sslBundle() {
		JksSslStoreDetails storeDetails = JksSslStoreDetails.forLocation('classpath:test.jks');
		JksSslStoreBundle stores = new JksSslStoreBundle(storeDetails, storeDetails);
		return SslBundle.of(stores, SslBundleKey.of('password'));
	}
	protected abstract long connectTimeout(T requestFactory);
	protected abstract long readTimeout(T requestFactory);
	public static class TestServlet extends HttpServlet {
		@Override
		public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
			if ('/redirect'.equals(req.getRequestURI())) {
				res.sendRedirect('/redirected');
				return;
			}
			res.getWriter().println('Received ' + req.getMethod() + ' request to ' + req.getRequestURI());
		}
	}
}
/*
package org.springframework.boot.http.client;
/**
class JettyClientHttpRequestFactoryBuilderTests
		extends AbstractClientHttpRequestFactoryBuilderTests<JettyClientHttpRequestFactory> {
	JettyClientHttpRequestFactoryBuilderTests() {
		super(JettyClientHttpRequestFactory.class, ClientHttpRequestFactoryBuilder.jetty());
	}
	@Override
	protected long connectTimeout(JettyClientHttpRequestFactory requestFactory) {
		return ((HttpClient) ReflectionTestUtils.getField(requestFactory, 'httpClient')).getConnectTimeout();
	}
	@Override
	protected long readTimeout(JettyClientHttpRequestFactory requestFactory) {
		return (long) ReflectionTestUtils.getField(requestFactory, 'readTimeout');
	}
}
/*
package org.springframework.boot.http.client;
/**
class ClientHttpRequestFactoryRuntimeHintsTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new ClientHttpRequestFactoryRuntimeHints().registerHints(hints, getClass().getClassLoader());
		ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
		Field requestFactoryField = ReflectionUtils.findField(AbstractClientHttpRequestFactoryWrapper.class,
				'requestFactory');
		assertThat(requestFactoryField).isNotNull();
		assertThat(reflection.onField(requestFactoryField)).accepts(hints);
	}
	@Test
	void shouldRegisterHttpComponentHints() {
		RuntimeHints hints = new RuntimeHints();
		new ClientHttpRequestFactoryRuntimeHints().registerHints(hints, getClass().getClassLoader());
		ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
		assertThat(reflection
			.onMethod(method(HttpComponentsClientHttpRequestFactory.class, 'setConnectTimeout', int.class)))
			.accepts(hints);
	}
	@Test
	void shouldRegisterJettyClientHints() {
		RuntimeHints hints = new RuntimeHints();
		new ClientHttpRequestFactoryRuntimeHints().registerHints(hints, getClass().getClassLoader());
		ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
		assertThat(reflection.onMethod(method(JettyClientHttpRequestFactory.class, 'setConnectTimeout', int.class)))
			.accepts(hints);
		assertThat(reflection.onMethod(method(JettyClientHttpRequestFactory.class, 'setReadTimeout', long.class)))
			.accepts(hints);
	}
	@Test
	void shouldRegisterReactorHints() {
		RuntimeHints hints = new RuntimeHints();
		new ClientHttpRequestFactoryRuntimeHints().registerHints(hints, getClass().getClassLoader());
		ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
		assertThat(reflection.onMethod(method(ReactorClientHttpRequestFactory.class, 'setConnectTimeout', int.class)))
			.accepts(hints);
		assertThat(reflection.onMethod(method(ReactorClientHttpRequestFactory.class, 'setReadTimeout', long.class)))
			.accepts(hints);
	}
	@Test
	void shouldRegisterSimpleHttpHints() {
		RuntimeHints hints = new RuntimeHints();
		new ClientHttpRequestFactoryRuntimeHints().registerHints(hints, getClass().getClassLoader());
		ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
		assertThat(reflection.onMethod(method(SimpleClientHttpRequestFactory.class, 'setConnectTimeout', int.class)))
			.accepts(hints);
		assertThat(reflection.onMethod(method(SimpleClientHttpRequestFactory.class, 'setReadTimeout', int.class)))
			.accepts(hints);
	}
	private static Method method(Class<?> target, String name, Class<?>... parameterTypes) {
		Method method = ReflectionUtils.findMethod(target, name, parameterTypes);
		assertThat(method).isNotNull();
		return method;
	}
}
/*
package org.springframework.boot.http.client;
/**
class ClientHttpRequestFactoryBuilderTests {
	@Test
	void withCustomizerAppliesCustomizers() {
		ClientHttpRequestFactoryBuilder<JettyClientHttpRequestFactory> builder = (
				settings) -> new JettyClientHttpRequestFactory();
		builder = builder.withCustomizer(this::setJettyReadTimeout);
		JettyClientHttpRequestFactory factory = builder.build(null);
		assertThat(factory).extracting('readTimeout').isEqualTo(5000L);
	}
	@Test
	void withCustomizersAppliesCustomizers() {
		ClientHttpRequestFactoryBuilder<JettyClientHttpRequestFactory> builder = (
				settings) -> new JettyClientHttpRequestFactory();
		builder = builder.withCustomizers(List.of(this::setJettyReadTimeout));
		JettyClientHttpRequestFactory factory = builder.build(null);
		assertThat(factory).extracting('readTimeout').isEqualTo(5000L);
	}
	@Test
	void httpComponentsReturnsHttpComponentsFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.httpComponents())
			.isInstanceOf(HttpComponentsClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void jettyReturnsJettyFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.jetty()).isInstanceOf(JettyClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void reactorReturnsReactorFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.reactor())
			.isInstanceOf(ReactorClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void jdkReturnsJdkFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.jdk()).isInstanceOf(JdkClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void simpleReturnsSimpleFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.simple()).isInstanceOf(SimpleClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void ofWhenExactlyClientHttpRequestFactoryTypeThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ClientHttpRequestFactoryBuilder.of(ClientHttpRequestFactory.class))
			.withMessage('"requestFactoryType" must be an implementation of ClientHttpRequestFactory');
	}
	@Test
	void ofWhenSimpleFactoryReturnsSimpleFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.of(SimpleClientHttpRequestFactory.class))
			.isInstanceOf(SimpleClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void ofWhenHttpComponentsFactoryReturnsHttpComponentsFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.of(HttpComponentsClientHttpRequestFactory.class))
			.isInstanceOf(HttpComponentsClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void ofWhenReactorFactoryReturnsReactorFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.of(ReactorClientHttpRequestFactory.class))
			.isInstanceOf(ReactorClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void ofWhenJdkFactoryReturnsJdkFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.of(JdkClientHttpRequestFactory.class))
			.isInstanceOf(JdkClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void ofWhenUnknownTypeReturnsReflectiveFactoryBuilder() {
		ClientHttpRequestFactoryBuilder<TestClientHttpRequestFactory> builder = ClientHttpRequestFactoryBuilder
			.of(TestClientHttpRequestFactory.class);
		assertThat(builder).isInstanceOf(ReflectiveComponentsClientHttpRequestFactoryBuilder.class);
		assertThat(builder.build(null)).isInstanceOf(TestClientHttpRequestFactory.class);
	}
	@Test
	void ofWithSupplierWhenSupplierIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ClientHttpRequestFactoryBuilder.of((Supplier<ClientHttpRequestFactory>) null))
			.withMessage('"requestFactorySupplier" must not be null');
	}
	@Test
	void ofWithSupplierReturnsReflectiveFactoryBuilder() {
		assertThat(ClientHttpRequestFactoryBuilder.of(SimpleClientHttpRequestFactory::new))
			.isInstanceOf(ReflectiveComponentsClientHttpRequestFactoryBuilder.class);
	}
	@Test
	void detectWhenHttpComponents() {
		assertThat(ClientHttpRequestFactoryBuilder.detect())
			.isInstanceOf(HttpComponentsClientHttpRequestFactoryBuilder.class);
	}
	@Test
	@ClassPathExclusions('httpclient5-*.jar')
	void detectWhenJetty() {
		assertThat(ClientHttpRequestFactoryBuilder.detect()).isInstanceOf(JettyClientHttpRequestFactoryBuilder.class);
	}
	@Test
	@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar' })
	void detectWhenReactor() {
		assertThat(ClientHttpRequestFactoryBuilder.detect()).isInstanceOf(ReactorClientHttpRequestFactoryBuilder.class);
	}
	@Test
	@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar', 'reactor-netty-http-*.jar' })
	void detectWhenJdk() {
		assertThat(ClientHttpRequestFactoryBuilder.detect()).isInstanceOf(JdkClientHttpRequestFactoryBuilder.class);
	}
	private void setJettyReadTimeout(JettyClientHttpRequestFactory factory) {
		factory.setReadTimeout(Duration.ofSeconds(5));
	}
	public static class TestClientHttpRequestFactory implements ClientHttpRequestFactory {
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {
			throw new UnsupportedOperationException();
		}
	}
}
/*
package org.springframework.boot.http.client;
/**
class ReflectiveComponentsClientHttpRequestFactoryBuilderTests
		extends AbstractClientHttpRequestFactoryBuilderTests<ClientHttpRequestFactory> {
	ReflectiveComponentsClientHttpRequestFactoryBuilderTests() {
		super(ClientHttpRequestFactory.class, ClientHttpRequestFactoryBuilder.of(JettyClientHttpRequestFactory::new));
	}
	@Override
	void connectWithSslBundle(String httpMethod) throws Exception {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.ofSslBundle(sslBundle());
		assertThatIllegalStateException().isThrownBy(() -> ofTestRequestFactory().build(settings))
			.withMessage('Unable to set SSL bundler using reflection');
	}
	@Override
	void redirectFollow() throws Exception {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withRedirects(Redirects.FOLLOW);
		assertThatIllegalStateException().isThrownBy(() -> ofTestRequestFactory().build(settings))
			.withMessage('Unable to set redirect follow using reflection');
	}
	@Override
	void redirectDontFollow() throws Exception {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withRedirects(Redirects.DONT_FOLLOW);
		assertThatIllegalStateException().isThrownBy(() -> ofTestRequestFactory().build(settings))
			.withMessage('Unable to set redirect follow using reflection');
	}
	@Test
	void buildWithClassCreatesFactory() {
		assertThat(ofTestRequestFactory().build()).isInstanceOf(TestClientHttpRequestFactory.class);
	}
	@Test
	void buildWithClassWhenHasConnectTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(60));
		TestClientHttpRequestFactory requestFactory = ofTestRequestFactory().build(settings);
		assertThat(requestFactory.connectTimeout).isEqualTo(Duration.ofSeconds(60).toMillis());
	}
	@Test
	void buildWithClassWhenHasReadTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withReadTimeout(Duration.ofSeconds(90));
		TestClientHttpRequestFactory requestFactory = ofTestRequestFactory().build(settings);
		assertThat(requestFactory.readTimeout).isEqualTo(Duration.ofSeconds(90).toMillis());
	}
	@Test
	void buildWithClassWhenUnconfigurableTypeWithConnectTimeoutThrowsException() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(60));
		assertThatIllegalStateException().isThrownBy(() -> ofUnconfigurableRequestFactory().build(settings))
			.withMessageContaining('suitable setConnectTimeout method');
	}
	@Test
	void buildWithClassWhenUnconfigurableTypeWithReadTimeoutThrowsException() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withReadTimeout(Duration.ofSeconds(60));
		assertThatIllegalStateException().isThrownBy(() -> ofUnconfigurableRequestFactory().build(settings))
			.withMessageContaining('suitable setReadTimeout method');
	}
	@Test
	void buildWithClassWhenDeprecatedMethodsTypeWithConnectTimeoutThrowsException() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(60));
		assertThatIllegalStateException().isThrownBy(() -> ofDeprecatedMethodsRequestFactory().build(settings))
			.withMessageContaining('setConnectTimeout method marked as deprecated');
	}
	@Test
	void buildWithClassWhenDeprecatedMethodsTypeWithReadTimeoutThrowsException() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withReadTimeout(Duration.ofSeconds(60));
		assertThatIllegalStateException().isThrownBy(() -> ofDeprecatedMethodsRequestFactory().build(settings))
			.withMessageContaining('setReadTimeout method marked as deprecated');
	}
	@Test
	void buildWithSupplierWhenWrappedRequestFactoryTypeWithConnectTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofMillis(1234));
		SimpleClientHttpRequestFactory wrappedRequestFactory = new SimpleClientHttpRequestFactory();
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactoryBuilder
			.of(() -> new BufferingClientHttpRequestFactory(wrappedRequestFactory))
			.build(settings);
		assertThat(requestFactory).extracting('requestFactory').isSameAs(wrappedRequestFactory);
		assertThat(wrappedRequestFactory).hasFieldOrPropertyWithValue('connectTimeout', 1234);
	}
	@Test
	void buildWithSupplierWhenWrappedRequestFactoryTypeWithReadTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withReadTimeout(Duration.ofMillis(1234));
		SimpleClientHttpRequestFactory wrappedRequestFactory = new SimpleClientHttpRequestFactory();
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactoryBuilder
			.of(() -> new BufferingClientHttpRequestFactory(wrappedRequestFactory))
			.build(settings);
		assertThat(requestFactory).extracting('requestFactory').isSameAs(wrappedRequestFactory);
		assertThat(wrappedRequestFactory).hasFieldOrPropertyWithValue('readTimeout', 1234);
	}
	@Test
	void buildWithClassWhenHasMultipleTimeoutSettersFavorsDurationMethods() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(1))
			.withReadTimeout(Duration.ofSeconds(2));
		IntAndDurationTimeoutsClientHttpRequestFactory requestFactory = ClientHttpRequestFactoryBuilder
			.of(IntAndDurationTimeoutsClientHttpRequestFactory.class)
			.build(settings);
		assertThat((requestFactory).connectTimeout).isZero();
		assertThat((requestFactory).readTimeout).isZero();
		assertThat((requestFactory).connectTimeoutDuration).isEqualTo(Duration.ofSeconds(1));
		assertThat((requestFactory).readTimeoutDuration).isEqualTo(Duration.ofSeconds(2));
	}
	private ClientHttpRequestFactoryBuilder<TestClientHttpRequestFactory> ofTestRequestFactory() {
		return ClientHttpRequestFactoryBuilder.of(TestClientHttpRequestFactory.class);
	}
	private ClientHttpRequestFactoryBuilder<UnconfigurableClientHttpRequestFactory> ofUnconfigurableRequestFactory() {
		return ClientHttpRequestFactoryBuilder.of(UnconfigurableClientHttpRequestFactory.class);
	}
	private ClientHttpRequestFactoryBuilder<DeprecatedMethodsClientHttpRequestFactory> ofDeprecatedMethodsRequestFactory() {
		return ClientHttpRequestFactoryBuilder.of(DeprecatedMethodsClientHttpRequestFactory.class);
	}
	@Override
	protected long connectTimeout(ClientHttpRequestFactory requestFactory) {
		return ((HttpClient) ReflectionTestUtils.getField(requestFactory, 'httpClient')).getConnectTimeout();
	}
	@Override
	protected long readTimeout(ClientHttpRequestFactory requestFactory) {
		return (long) ReflectionTestUtils.getField(requestFactory, 'readTimeout');
	}
	public static class TestClientHttpRequestFactory implements ClientHttpRequestFactory {
		private int connectTimeout;
		private int readTimeout;
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
		public void setConnectTimeout(int timeout) {
			this.connectTimeout = timeout;
		}
		public void setReadTimeout(int timeout) {
			this.readTimeout = timeout;
		}
	}
	public static class UnconfigurableClientHttpRequestFactory implements ClientHttpRequestFactory {
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
	}
	public static class DeprecatedMethodsClientHttpRequestFactory implements ClientHttpRequestFactory {
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
		@Deprecated(since = '3.0.0', forRemoval = false)
		public void setConnectTimeout(int timeout) {
		}
		@Deprecated(since = '3.0.0', forRemoval = false)
		public void setReadTimeout(int timeout) {
		}
		@Deprecated(since = '3.0.0', forRemoval = false)
		public void setBufferRequestBody(boolean bufferRequestBody) {
		}
	}
	public static class IntAndDurationTimeoutsClientHttpRequestFactory implements ClientHttpRequestFactory {
		private int readTimeout;
		private int connectTimeout;
		private Duration readTimeoutDuration;
		private Duration connectTimeoutDuration;
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
		public void setConnectTimeout(int timeout) {
			this.connectTimeout = timeout;
		}
		public void setReadTimeout(int timeout) {
			this.readTimeout = timeout;
		}
		public void setConnectTimeout(Duration timeout) {
			this.connectTimeoutDuration = timeout;
		}
		public void setReadTimeout(Duration timeout) {
			this.readTimeoutDuration = timeout;
		}
	}
}
/*
package org.springframework.boot.http.client;
/**
class SimpleClientHttpRequestFactoryBuilderTests
		extends AbstractClientHttpRequestFactoryBuilderTests<SimpleClientHttpRequestFactory> {
	SimpleClientHttpRequestFactoryBuilderTests() {
		super(SimpleClientHttpRequestFactory.class, ClientHttpRequestFactoryBuilder.simple());
	}
	@Override
	protected long connectTimeout(SimpleClientHttpRequestFactory requestFactory) {
		return (int) ReflectionTestUtils.getField(requestFactory, 'connectTimeout');
	}
	@Override
	protected long readTimeout(SimpleClientHttpRequestFactory requestFactory) {
		return (int) ReflectionTestUtils.getField(requestFactory, 'readTimeout');
	}
}
/*
package org.springframework.boot.http.client;
/**
class ClientHttpRequestFactorySettingsTests {
	private static final Duration ONE_SECOND = Duration.ofSeconds(1);
	@Test
	void defaults() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults();
		assertThat(settings.redirects()).isEqualTo(Redirects.FOLLOW_WHEN_POSSIBLE);
		assertThat(settings.connectTimeout()).isNull();
		assertThat(settings.readTimeout()).isNull();
		assertThat(settings.sslBundle()).isNull();
	}
	@Test
	void createWithNullsUsesDefaults() {
		ClientHttpRequestFactorySettings settings = new ClientHttpRequestFactorySettings(null, null, null, null);
		assertThat(settings.redirects()).isEqualTo(Redirects.FOLLOW_WHEN_POSSIBLE);
		assertThat(settings.connectTimeout()).isNull();
		assertThat(settings.readTimeout()).isNull();
		assertThat(settings.sslBundle()).isNull();
	}
	@Test
	void withConnectTimeoutReturnsInstanceWithUpdatedConnectionTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(ONE_SECOND);
		assertThat(settings.connectTimeout()).isEqualTo(ONE_SECOND);
		assertThat(settings.readTimeout()).isNull();
		assertThat(settings.sslBundle()).isNull();
	}
	@Test
	void withReadTimeoutReturnsInstanceWithUpdatedReadTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withReadTimeout(ONE_SECOND);
		assertThat(settings.connectTimeout()).isNull();
		assertThat(settings.readTimeout()).isEqualTo(ONE_SECOND);
		assertThat(settings.sslBundle()).isNull();
	}
	@Test
	void withSslBundleReturnsInstanceWithUpdatedSslBundle() {
		SslBundle sslBundle = mock(SslBundle.class);
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withSslBundle(sslBundle);
		assertThat(settings.connectTimeout()).isNull();
		assertThat(settings.readTimeout()).isNull();
		assertThat(settings.sslBundle()).isSameAs(sslBundle);
	}
	@Test
	void withRedirectsReturnsInstanceWithUpdatedRedirect() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withRedirects(Redirects.DONT_FOLLOW);
		assertThat(settings.redirects()).isEqualTo(Redirects.DONT_FOLLOW);
	}
}
/*
package org.springframework.boot.http.client;
/**
class JdkClientHttpRequestFactoryBuilderTests
		extends AbstractClientHttpRequestFactoryBuilderTests<JdkClientHttpRequestFactory> {
	JdkClientHttpRequestFactoryBuilderTests() {
		super(JdkClientHttpRequestFactory.class, ClientHttpRequestFactoryBuilder.jdk());
	}
	@Override
	protected long connectTimeout(JdkClientHttpRequestFactory requestFactory) {
		HttpClient httpClient = (HttpClient) ReflectionTestUtils.getField(requestFactory, 'httpClient');
		return httpClient.connectTimeout().get().toMillis();
	}
	@Override
	protected long readTimeout(JdkClientHttpRequestFactory requestFactory) {
		Duration readTimeout = (Duration) ReflectionTestUtils.getField(requestFactory, 'readTimeout');
		return readTimeout.toMillis();
	}
}
/*
package org.springframework.boot;
/**
class SpringBootConfigurationTests {
	@Test
	void proxyBeanMethodsIsEnabledByDefault() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(DefaultSpringBootConfiguration.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', true);
	}
	@Test
	void proxyBeanMethodsCanBeDisabled() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(NoBeanMethodProxyingSpringBootConfiguration.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', false);
	}
	@SpringBootConfiguration
	static class DefaultSpringBootConfiguration {
	}
	@SpringBootConfiguration(proxyBeanMethods = false)
	static class NoBeanMethodProxyingSpringBootConfiguration {
	}
}
/*
package org.springframework.boot;
/**
@ExtendWith({ MockitoExtension.class, OutputCaptureExtension.class })
class BannerTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Captor
	private ArgumentCaptor<Class<?>> sourceClassCaptor;
	@Test
	void testDefaultBanner(CapturedOutput output) {
		SpringApplication application = createSpringApplication();
		this.context = application.run();
		assertThat(output).contains(':: Spring Boot ::');
	}
	@Test
	void testDefaultBannerInLog(CapturedOutput output) {
		SpringApplication application = createSpringApplication();
		this.context = application.run();
		assertThat(output).contains(':: Spring Boot ::');
	}
	@Test
	void testCustomBanner(CapturedOutput output) {
		SpringApplication application = createSpringApplication();
		application.setBanner(new DummyBanner());
		this.context = application.run();
		assertThat(output).contains('My Banner');
	}
	@Test
	void testBannerInContext() {
		SpringApplication application = createSpringApplication();
		this.context = application.run();
		assertThat(this.context.containsBean('springBootBanner')).isTrue();
	}
	@Test
	void testCustomBannerInContext() {
		SpringApplication application = createSpringApplication();
		Banner banner = mock(Banner.class);
		application.setBanner(banner);
		this.context = application.run();
		Banner printedBanner = (Banner) this.context.getBean('springBootBanner');
		assertThat(printedBanner).hasFieldOrPropertyWithValue('banner', banner);
		then(banner).should()
			.printBanner(any(Environment.class), this.sourceClassCaptor.capture(), any(PrintStream.class));
		reset(banner);
		printedBanner.printBanner(this.context.getEnvironment(), null, System.out);
		then(banner).should()
			.printBanner(any(Environment.class), eq(this.sourceClassCaptor.getValue()), any(PrintStream.class));
	}
	@Test
	void testDisableBannerInContext() {
		SpringApplication application = createSpringApplication();
		application.setBannerMode(Mode.OFF);
		this.context = application.run();
		assertThat(this.context.containsBean('springBootBanner')).isFalse();
	}
	private SpringApplication createSpringApplication() {
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		return application;
	}
	static class DummyBanner implements Banner {
		@Override
		public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
			out.println('My Banner');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.builder;
/**
class SpringApplicationBuilderTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void close() {
		close(this.context);
		SpringApplicationShutdownHookInstance.reset();
	}
	private void close(ApplicationContext context) {
		if (context != null) {
			if (context instanceof ConfigurableApplicationContext configurableContext) {
				configurableContext.close();
			}
			close(context.getParent());
		}
	}
	@Test
	void profileAndProperties() {
		SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(StaticApplicationContext.class))
			.profiles('foo')
			.properties('foo=bar');
		this.context = application.run();
		assertThat(this.context).isInstanceOf(StaticApplicationContext.class);
		assertThat(this.context.getEnvironment().getProperty('foo')).isEqualTo('bucket');
		assertThat(this.context.getEnvironment().acceptsProfiles(Profiles.of('foo'))).isTrue();
	}
	@Test
	void propertiesAsMap() {
		SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(StaticApplicationContext.class))
			.properties(Collections.singletonMap('bar', 'foo'));
		this.context = application.run();
		assertThat(this.context.getEnvironment().getProperty('bar')).isEqualTo('foo');
	}
	@Test
	void propertiesAsProperties() {
		SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(StaticApplicationContext.class))
			.properties(StringUtils.splitArrayElementsIntoProperties(new String[] { 'bar=foo' }, '='));
		this.context = application.run();
		assertThat(this.context.getEnvironment().getProperty('bar')).isEqualTo('foo');
	}
	@Test
	void propertiesWithRepeatSeparator() {
		SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(StaticApplicationContext.class))
			.properties('one=c:\\logging.file.name', 'two=a:b', 'three:c:\\logging.file.name', 'four:a:b');
		this.context = application.run();
		ConfigurableEnvironment environment = this.context.getEnvironment();
		assertThat(environment.getProperty('one')).isEqualTo('c:\\logging.file.name');
		assertThat(environment.getProperty('two')).isEqualTo('a:b');
		assertThat(environment.getProperty('three')).isEqualTo('c:\\logging.file.name');
		assertThat(environment.getProperty('four')).isEqualTo('a:b');
	}
	@Test
	void specificApplicationContextFactory() {
		SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(StaticApplicationContext.class));
		this.context = application.run();
		assertThat(this.context).isInstanceOf(StaticApplicationContext.class);
	}
	@Test
	void parentContextCreationThatIsRunDirectly() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		application.parent(ExampleConfig.class);
		this.context = application.run('foo.bar=baz');
		then(((SpyApplicationContext) this.context).getApplicationContext()).should()
			.setParent(any(ApplicationContext.class));
		assertThat(SpringApplicationShutdownHookInstance.get()).didNotRegisterApplicationContext(this.context);
		assertThat(this.context.getParent().getBean(ApplicationArguments.class).getNonOptionArgs())
			.contains('foo.bar=baz');
		assertThat(this.context.getBean(ApplicationArguments.class).getNonOptionArgs()).contains('foo.bar=baz');
	}
	@Test
	void parentContextCreationThatIsBuiltThenRun() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		application.parent(ExampleConfig.class);
		this.context = application.build('a=alpha').run('b=bravo');
		then(((SpyApplicationContext) this.context).getApplicationContext()).should()
			.setParent(any(ApplicationContext.class));
		assertThat(SpringApplicationShutdownHookInstance.get()).didNotRegisterApplicationContext(this.context);
		assertThat(this.context.getParent().getBean(ApplicationArguments.class).getNonOptionArgs()).contains('a=alpha');
		assertThat(this.context.getBean(ApplicationArguments.class).getNonOptionArgs()).contains('b=bravo');
	}
	@Test
	void parentContextCreationWithChildShutdown() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class))
			.registerShutdownHook(true);
		application.parent(ExampleConfig.class);
		this.context = application.run();
		then(((SpyApplicationContext) this.context).getApplicationContext()).should()
			.setParent(any(ApplicationContext.class));
		assertThat(SpringApplicationShutdownHookInstance.get()).registeredApplicationContext(this.context);
	}
	@Test
	void contextWithClassLoader() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		ClassLoader classLoader = new URLClassLoader(new URL[0], getClass().getClassLoader());
		application.resourceLoader(new DefaultResourceLoader(classLoader));
		this.context = application.run();
		assertThat(this.context.getClassLoader()).isEqualTo(classLoader);
	}
	@Test
	void parentContextWithClassLoader() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class)
			.contextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		ClassLoader classLoader = new URLClassLoader(new URL[0], getClass().getClassLoader());
		application.resourceLoader(new DefaultResourceLoader(classLoader));
		application.parent(ExampleConfig.class);
		this.context = application.run();
		assertThat(((SpyApplicationContext) this.context).getResourceLoader().getClassLoader()).isEqualTo(classLoader);
	}
	@Test
	void parentFirstCreation() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class)
			.child(ChildConfig.class);
		application.contextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		this.context = application.run();
		then(((SpyApplicationContext) this.context).getApplicationContext()).should()
			.setParent(any(ApplicationContext.class));
		assertThat(SpringApplicationShutdownHookInstance.get()).didNotRegisterApplicationContext(this.context);
	}
	@Test
	void parentFirstCreationWithProfileAndDefaultArgs() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class).profiles('node')
			.properties('transport=redis')
			.child(ChildConfig.class)
			.web(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context.getEnvironment().acceptsProfiles(Profiles.of('node'))).isTrue();
		assertThat(this.context.getEnvironment().getProperty('transport')).isEqualTo('redis');
		assertThat(this.context.getParent().getEnvironment().acceptsProfiles(Profiles.of('node'))).isTrue();
		assertThat(this.context.getParent().getEnvironment().getProperty('transport')).isEqualTo('redis');
		// only defined in node profile
		assertThat(this.context.getEnvironment().getProperty('bar')).isEqualTo('spam');
	}
	@Test
	void parentFirstWithDifferentProfile() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class).profiles('node')
			.properties('transport=redis')
			.child(ChildConfig.class)
			.profiles('admin')
			.web(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context.getEnvironment().acceptsProfiles(Profiles.of('node', 'admin'))).isTrue();
		assertThat(this.context.getParent().getEnvironment().acceptsProfiles(Profiles.of('admin'))).isFalse();
	}
	@Test
	void parentWithDifferentProfile() {
		SpringApplicationBuilder shared = new SpringApplicationBuilder(ExampleConfig.class).profiles('node')
			.properties('transport=redis');
		SpringApplicationBuilder application = shared.child(ChildConfig.class)
			.profiles('admin')
			.web(WebApplicationType.NONE);
		shared.profiles('parent');
		this.context = application.run();
		assertThat(this.context.getEnvironment().acceptsProfiles(Profiles.of('node', 'admin'))).isTrue();
		assertThat(this.context.getParent().getEnvironment().acceptsProfiles(Profiles.of('node', 'parent'))).isTrue();
		assertThat(this.context.getParent().getEnvironment().acceptsProfiles(Profiles.of('admin'))).isFalse();
	}
	@Test
	void parentFirstWithDifferentProfileAndExplicitEnvironment() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class)
			.environment(new StandardEnvironment())
			.profiles('node')
			.properties('transport=redis')
			.child(ChildConfig.class)
			.profiles('admin')
			.web(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(this.context.getEnvironment().acceptsProfiles(Profiles.of('node', 'admin'))).isTrue();
		// Now they share an Environment explicitly so there"s no way to keep the profiles
		// separate
		assertThat(this.context.getParent().getEnvironment().acceptsProfiles(Profiles.of('admin'))).isTrue();
	}
	@Test
	void parentContextIdentical() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class);
		application.parent(ExampleConfig.class);
		application.contextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));
		this.context = application.run();
		then(((SpyApplicationContext) this.context).getApplicationContext()).should()
			.setParent(any(ApplicationContext.class));
	}
	@Test
	void initializersCreatedOnce() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class)
			.web(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(application.application().getInitializers()).hasSize(5);
	}
	@Test
	void initializersCreatedOnceForChild() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class)
			.child(ChildConfig.class)
			.web(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(application.application().getInitializers()).hasSize(6);
	}
	@Test
	void initializersIncludeDefaults() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class)
			.web(WebApplicationType.NONE)
			.initializers((ConfigurableApplicationContext applicationContext) -> {
			});
		this.context = application.run();
		assertThat(application.application().getInitializers()).hasSize(6);
	}
	@Test
	void sourcesWithBoundSources() {
		SpringApplicationBuilder application = new SpringApplicationBuilder().web(WebApplicationType.NONE)
			.sources(ExampleConfig.class)
			.properties('spring.main.sources=' + ChildConfig.class.getName());
		this.context = application.run();
		this.context.getBean(ExampleConfig.class);
		this.context.getBean(ChildConfig.class);
	}
	@Test
	void addBootstrapRegistryInitializer() {
		SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class)
			.web(WebApplicationType.NONE)
			.addBootstrapRegistryInitializer((context) -> context.addCloseListener(
					(event) -> event.getApplicationContext().getBeanFactory().registerSingleton('test', 'spring')));
		this.context = application.run();
		assertThat(this.context.getBean('test')).isEqualTo('spring');
	}
	@Test
	void setEnvironmentPrefix() {
		SpringApplicationBuilder builder = new SpringApplicationBuilder(ExampleConfig.class).environmentPrefix('test');
		assertThat(builder.application().getEnvironmentPrefix()).isEqualTo('test');
	}
	@Test
	void customApplicationWithResourceLoader() {
		ResourceLoader resourceLoader = mock(ResourceLoader.class);
		SpringApplicationBuilder applicationBuilder = new SpringApplicationBuilder(resourceLoader,
				ExampleConfig.class) {
			@Override
			protected SpringApplication createSpringApplication(ResourceLoader resourceLoader, Class<?>... sources) {
				return new CustomSpringApplication(resourceLoader, sources);
			}
		};
		SpringApplication application = applicationBuilder.build();
		assertThat(application).asInstanceOf(InstanceOfAssertFactories.type(CustomSpringApplication.class))
			.satisfies((customApp) -> assertThat(customApp.resourceLoader).isEqualTo(resourceLoader));
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class ChildConfig {
	}
	static class CustomSpringApplication extends SpringApplication {
		private final ResourceLoader resourceLoader;
		CustomSpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
			super(resourceLoader, primarySources);
			this.resourceLoader = resourceLoader;
		}
	}
	static class SpyApplicationContext extends AnnotationConfigApplicationContext {
		private final ConfigurableApplicationContext applicationContext = spy(new AnnotationConfigApplicationContext());
		private ResourceLoader resourceLoader;
		@Override
		public void setParent(ApplicationContext parent) {
			this.applicationContext.setParent(parent);
		}
		ConfigurableApplicationContext getApplicationContext() {
			return this.applicationContext;
		}
		@Override
		public void setResourceLoader(ResourceLoader resourceLoader) {
			super.setResourceLoader(resourceLoader);
			this.resourceLoader = resourceLoader;
		}
		ResourceLoader getResourceLoader() {
			return this.resourceLoader;
		}
		@Override
		public void close() {
			super.close();
			this.applicationContext.close();
		}
		@Override
		public ApplicationContext getParent() {
			return this.applicationContext.getParent();
		}
	}
}
/*
package sampleconfig;
@Component
public class MyComponentInPackageWithoutDot {
}
/*
package org.springframework.boot;
/**
public final class SpringBootVersion {
	private SpringBootVersion() {
	}
	/**
	 * Return the full version string of the present Spring Boot codebase.
	 * @return the version of Spring Boot
	 */
	public static String getVersion() {
		return '${springBootVersion}';
	}
}
/*
package org.springframework.boot.ssl;
/**
public interface SslBundleRegistry {
	/**
	 * Register a named {@link SslBundle}.
	 * @param name the bundle name
	 * @param bundle the bundle
	 */
	void registerBundle(String name, SslBundle bundle);
	/**
	 * Updates an {@link SslBundle}.
	 * @param name the bundle name
	 * @param updatedBundle the updated bundle
	 * @throws NoSuchSslBundleException if the bundle cannot be found
	 * @since 3.2.0
	 */
	void updateBundle(String name, SslBundle updatedBundle) throws NoSuchSslBundleException;
}
/*
package org.springframework.boot.ssl;
/**
public interface SslBundleKey {
	/**
	 * {@link SslBundleKey} that returns no values.
	 */
	SslBundleKey NONE = of(null, null);
	/**
	 * Return the password that should be used to access the key or {@code null} if no
	 * password is required.
	 * @return the key password
	 */
	String getPassword();
	/**
	 * Return the alias of the key or {@code null} if the key has no alias.
	 * @return the key alias
	 */
	String getAlias();
	/**
	 * Assert that the alias is contained in the given keystore.
	 * @param keyStore the keystore to check
	 */
	default void assertContainsAlias(KeyStore keyStore) {
		String alias = getAlias();
		if (StringUtils.hasLength(alias) && keyStore != null) {
			try {
				Assert.state(keyStore.containsAlias(alias),
						() -> String.format('Keystore does not contain alias "%s"', alias));
			}
			catch (KeyStoreException ex) {
				throw new IllegalStateException(
						String.format('Could not determine if keystore contains alias "%s"', alias), ex);
			}
		}
	}
	/**
	 * Factory method to create a new {@link SslBundleKey} instance.
	 * @param password the password used to access the key
	 * @return a new {@link SslBundleKey} instance
	 */
	static SslBundleKey of(String password) {
		return of(password, null);
	}
	/**
	 * Factory method to create a new {@link SslBundleKey} instance.
	 * @param password the password used to access the key
	 * @param alias the alias of the key
	 * @return a new {@link SslBundleKey} instance
	 */
	static SslBundleKey of(String password, String alias) {
		return new SslBundleKey() {
			@Override
			public String getPassword() {
				return password;
			}
			@Override
			public String getAlias() {
				return alias;
			}
			@Override
			public String toString() {
				ToStringCreator creator = new ToStringCreator(this);
				creator.append('alias', alias);
				creator.append('password', (password != null) ? '******' : null);
				return creator.toString();
			}
		};
	}
}
/*
package org.springframework.boot.ssl;
/**
public interface SslStoreBundle {
	/**
	 * {@link SslStoreBundle} that returns {@code null} for each method.
	 */
	SslStoreBundle NONE = of(null, null, null);
	/**
	 * Return a key store generated from the trust material or {@code null}.
	 * @return the key store
	 */
	KeyStore getKeyStore();
	/**
	 * Return the password for the key in the key store or {@code null}.
	 * @return the key password
	 */
	String getKeyStorePassword();
	/**
	 * Return a trust store generated from the trust material or {@code null}.
	 * @return the trust store
	 */
	KeyStore getTrustStore();
	/**
	 * Factory method to create a new {@link SslStoreBundle} instance.
	 * @param keyStore the key store or {@code null}
	 * @param keyStorePassword the key store password or {@code null}
	 * @param trustStore the trust store or {@code null}
	 * @return a new {@link SslStoreBundle} instance
	 */
	static SslStoreBundle of(KeyStore keyStore, String keyStorePassword, KeyStore trustStore) {
		return new SslStoreBundle() {
			@Override
			public KeyStore getKeyStore() {
				return keyStore;
			}
			@Override
			public KeyStore getTrustStore() {
				return trustStore;
			}
			@Override
			public String getKeyStorePassword() {
				return keyStorePassword;
			}
			@Override
			public String toString() {
				ToStringCreator creator = new ToStringCreator(this);
				creator.append('keyStore.type', (keyStore != null) ? keyStore.getType() : 'none');
				creator.append('keyStorePassword', (keyStorePassword != null) ? '******' : null);
				creator.append('trustStore.type', (trustStore != null) ? trustStore.getType() : 'none');
				return creator.toString();
			}
		};
	}
}
/*
package org.springframework.boot.ssl.jks;
/**
public class JksSslStoreBundle implements SslStoreBundle {
	private final JksSslStoreDetails keyStoreDetails;
	private final ResourceLoader resourceLoader;
	private final Supplier<KeyStore> keyStore;
	private final Supplier<KeyStore> trustStore;
	/**
	 * Create a new {@link JksSslStoreBundle} instance.
	 * @param keyStoreDetails the key store details
	 * @param trustStoreDetails the trust store details
	 */
	public JksSslStoreBundle(JksSslStoreDetails keyStoreDetails, JksSslStoreDetails trustStoreDetails) {
		this(keyStoreDetails, trustStoreDetails, ApplicationResourceLoader.get());
	}
	/**
	 * Create a new {@link JksSslStoreBundle} instance.
	 * @param keyStoreDetails the key store details
	 * @param trustStoreDetails the trust store details
	 * @param resourceLoader the resource loader used to load content
	 * @since 3.3.5
	 */
	public JksSslStoreBundle(JksSslStoreDetails keyStoreDetails, JksSslStoreDetails trustStoreDetails,
			ResourceLoader resourceLoader) {
		Assert.notNull(resourceLoader, 'ResourceLoader must not be null');
		this.keyStoreDetails = keyStoreDetails;
		this.resourceLoader = resourceLoader;
		this.keyStore = SingletonSupplier.of(() -> createKeyStore('key', keyStoreDetails));
		this.trustStore = SingletonSupplier.of(() -> createKeyStore('trust', trustStoreDetails));
	}
	@Override
	public KeyStore getKeyStore() {
		return this.keyStore.get();
	}
	@Override
	public String getKeyStorePassword() {
		return (this.keyStoreDetails != null) ? this.keyStoreDetails.password() : null;
	}
	@Override
	public KeyStore getTrustStore() {
		return this.trustStore.get();
	}
	private KeyStore createKeyStore(String name, JksSslStoreDetails details) {
		if (details == null || details.isEmpty()) {
			return null;
		}
		try {
			String type = (!StringUtils.hasText(details.type())) ? KeyStore.getDefaultType() : details.type();
			char[] password = (details.password() != null) ? details.password().toCharArray() : null;
			String location = details.location();
			KeyStore store = getKeyStoreInstance(type, details.provider());
			if (isHardwareKeystoreType(type)) {
				loadHardwareKeyStore(store, location, password);
			}
			else {
				loadKeyStore(store, location, password);
			}
			return store;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to create %s store: %s'.formatted(name, ex.getMessage()), ex);
		}
	}
	private KeyStore getKeyStoreInstance(String type, String provider)
			throws KeyStoreException, NoSuchProviderException {
		return (!StringUtils.hasText(provider)) ? KeyStore.getInstance(type) : KeyStore.getInstance(type, provider);
	}
	private boolean isHardwareKeystoreType(String type) {
		return type.equalsIgnoreCase('PKCS11');
	}
	private void loadHardwareKeyStore(KeyStore store, String location, char[] password)
			throws IOException, NoSuchAlgorithmException, CertificateException {
		Assert.state(!StringUtils.hasText(location),
				() -> 'Location is "%s", but must be empty or null for PKCS11 hardware key stores'.formatted(location));
		store.load(null, password);
	}
	private void loadKeyStore(KeyStore store, String location, char[] password) {
		Assert.state(StringUtils.hasText(location), () -> 'Location must not be empty or null');
		try {
			try (InputStream stream = this.resourceLoader.getResource(location).getInputStream()) {
				store.load(stream, password);
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Could not load store from "' + location + '"', ex);
		}
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this);
		KeyStore keyStore = this.keyStore.get();
		creator.append('keyStore.type', (keyStore != null) ? keyStore.getType() : 'none');
		String keyStorePassword = getKeyStorePassword();
		creator.append('keyStorePassword', (keyStorePassword != null) ? '******' : null);
		KeyStore trustStore = this.trustStore.get();
		creator.append('trustStore.type', (trustStore != null) ? trustStore.getType() : 'none');
		return creator.toString();
	}
}
/*
package org.springframework.boot.ssl.jks;
/**
public record JksSslStoreDetails(String type, String provider, String location, String password) {
	/**
	 * Return a new {@link JksSslStoreDetails} instance with a new password.
	 * @param password the new password
	 * @return a new {@link JksSslStoreDetails} instance
	 */
	public JksSslStoreDetails withPassword(String password) {
		return new JksSslStoreDetails(this.type, this.provider, this.location, password);
	}
	boolean isEmpty() {
		return isEmpty(this.type) && isEmpty(this.provider) && isEmpty(this.location);
	}
	private boolean isEmpty(String value) {
		return !StringUtils.hasText(value);
	}
	/**
	 * Factory method to create a new {@link JksSslStoreDetails} instance for the given
	 * location.
	 * @param location the location
	 * @return a new {@link JksSslStoreDetails} instance.
	 */
	public static JksSslStoreDetails forLocation(String location) {
		return new JksSslStoreDetails(null, null, location, null);
	}
}
/*
/**
package org.springframework.boot.ssl.jks;
/*
package org.springframework.boot.ssl;
/**
class DefaultSslManagerBundle implements SslManagerBundle {
	private final SslStoreBundle storeBundle;
	private final SslBundleKey key;
	DefaultSslManagerBundle(SslStoreBundle storeBundle, SslBundleKey key) {
		this.storeBundle = (storeBundle != null) ? storeBundle : SslStoreBundle.NONE;
		this.key = (key != null) ? key : SslBundleKey.NONE;
	}
	@Override
	public KeyManagerFactory getKeyManagerFactory() {
		try {
			KeyStore store = this.storeBundle.getKeyStore();
			this.key.assertContainsAlias(store);
			String alias = this.key.getAlias();
			String algorithm = KeyManagerFactory.getDefaultAlgorithm();
			KeyManagerFactory factory = getKeyManagerFactoryInstance(algorithm);
			factory = (alias != null) ? new AliasKeyManagerFactory(factory, alias, algorithm) : factory;
			String password = this.key.getPassword();
			password = (password != null) ? password : this.storeBundle.getKeyStorePassword();
			factory.init(store, (password != null) ? password.toCharArray() : null);
			return factory;
		}
		catch (RuntimeException ex) {
			throw ex;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Could not load key manager factory: ' + ex.getMessage(), ex);
		}
	}
	@Override
	public TrustManagerFactory getTrustManagerFactory() {
		try {
			KeyStore store = this.storeBundle.getTrustStore();
			String algorithm = TrustManagerFactory.getDefaultAlgorithm();
			TrustManagerFactory factory = getTrustManagerFactoryInstance(algorithm);
			factory.init(store);
			return factory;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Could not load trust manager factory: ' + ex.getMessage(), ex);
		}
	}
	protected KeyManagerFactory getKeyManagerFactoryInstance(String algorithm) throws NoSuchAlgorithmException {
		return KeyManagerFactory.getInstance(algorithm);
	}
	protected TrustManagerFactory getTrustManagerFactoryInstance(String algorithm) throws NoSuchAlgorithmException {
		return TrustManagerFactory.getInstance(algorithm);
	}
}
/*
package org.springframework.boot.ssl;
/**
final class AliasKeyManagerFactory extends KeyManagerFactory {
	AliasKeyManagerFactory(KeyManagerFactory delegate, String alias, String algorithm) {
		super(new AliasKeyManagerFactorySpi(delegate, alias), delegate.getProvider(), algorithm);
	}
	/**
	 * {@link KeyManagerFactorySpi} that allows a configurable key alias to be used.
	 */
	private static final class AliasKeyManagerFactorySpi extends KeyManagerFactorySpi {
		private final KeyManagerFactory delegate;
		private final String alias;
		private AliasKeyManagerFactorySpi(KeyManagerFactory delegate, String alias) {
			this.delegate = delegate;
			this.alias = alias;
		}
		@Override
		protected void engineInit(KeyStore keyStore, char[] chars)
				throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException {
			this.delegate.init(keyStore, chars);
		}
		@Override
		protected void engineInit(ManagerFactoryParameters managerFactoryParameters)
				throws InvalidAlgorithmParameterException {
			throw new InvalidAlgorithmParameterException('Unsupported ManagerFactoryParameters');
		}
		@Override
		protected KeyManager[] engineGetKeyManagers() {
			return Arrays.stream(this.delegate.getKeyManagers())
				.filter(X509ExtendedKeyManager.class::isInstance)
				.map(X509ExtendedKeyManager.class::cast)
				.map(this::wrap)
				.toArray(KeyManager[]::new);
		}
		private AliasKeyManagerFactory.AliasX509ExtendedKeyManager wrap(X509ExtendedKeyManager keyManager) {
			return new AliasX509ExtendedKeyManager(keyManager, this.alias);
		}
	}
	/**
	 * {@link X509ExtendedKeyManager} that allows a configurable key alias to be used.
	 */
	static final class AliasX509ExtendedKeyManager extends X509ExtendedKeyManager {
		private final X509ExtendedKeyManager delegate;
		private final String alias;
		private AliasX509ExtendedKeyManager(X509ExtendedKeyManager keyManager, String alias) {
			this.delegate = keyManager;
			this.alias = alias;
		}
		@Override
		public String chooseEngineClientAlias(String[] strings, Principal[] principals, SSLEngine sslEngine) {
			return this.delegate.chooseEngineClientAlias(strings, principals, sslEngine);
		}
		@Override
		public String chooseEngineServerAlias(String s, Principal[] principals, SSLEngine sslEngine) {
			return this.alias;
		}
		@Override
		public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {
			return this.delegate.chooseClientAlias(keyType, issuers, socket);
		}
		@Override
		public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {
			return this.delegate.chooseServerAlias(keyType, issuers, socket);
		}
		@Override
		public X509Certificate[] getCertificateChain(String alias) {
			return this.delegate.getCertificateChain(alias);
		}
		@Override
		public String[] getClientAliases(String keyType, Principal[] issuers) {
			return this.delegate.getClientAliases(keyType, issuers);
		}
		@Override
		public PrivateKey getPrivateKey(String alias) {
			return this.delegate.getPrivateKey(alias);
		}
		@Override
		public String[] getServerAliases(String keyType, Principal[] issuers) {
			return this.delegate.getServerAliases(keyType, issuers);
		}
	}
}
/*
package org.springframework.boot.ssl;
/**
public interface SslBundles {
	/**
	 * Return an {@link SslBundle} with the provided name.
	 * @param name the bundle name
	 * @return the bundle
	 * @throws NoSuchSslBundleException if a bundle with the provided name does not exist
	 */
	SslBundle getBundle(String name) throws NoSuchSslBundleException;
	/**
	 * Add a handler that will be called each time the named bundle is updated.
	 * @param name the bundle name
	 * @param updateHandler the handler that should be called
	 * @throws NoSuchSslBundleException if a bundle with the provided name does not exist
	 * @since 3.2.0
	 */
	void addBundleUpdateHandler(String name, Consumer<SslBundle> updateHandler) throws NoSuchSslBundleException;
	/**
	 * Return the names of all bundles managed by this instance.
	 * @return the bundle names
	 * @since 3.4.0
	 */
	List<String> getBundleNames();
}
/*
package org.springframework.boot.ssl;
/**
public class DefaultSslBundleRegistry implements SslBundleRegistry, SslBundles {
	private static final Log logger = LogFactory.getLog(DefaultSslBundleRegistry.class);
	private final Map<String, RegisteredSslBundle> registeredBundles = new ConcurrentHashMap<>();
	public DefaultSslBundleRegistry() {
	}
	public DefaultSslBundleRegistry(String name, SslBundle bundle) {
		registerBundle(name, bundle);
	}
	@Override
	public void registerBundle(String name, SslBundle bundle) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(bundle, 'Bundle must not be null');
		RegisteredSslBundle previous = this.registeredBundles.putIfAbsent(name, new RegisteredSslBundle(name, bundle));
		Assert.state(previous == null, () -> 'Cannot replace existing SSL bundle "%s"'.formatted(name));
	}
	@Override
	public void updateBundle(String name, SslBundle updatedBundle) {
		getRegistered(name).update(updatedBundle);
	}
	@Override
	public SslBundle getBundle(String name) {
		return getRegistered(name).getBundle();
	}
	@Override
	public void addBundleUpdateHandler(String name, Consumer<SslBundle> updateHandler) throws NoSuchSslBundleException {
		getRegistered(name).addUpdateHandler(updateHandler);
	}
	@Override
	public List<String> getBundleNames() {
		List<String> names = new ArrayList<>(this.registeredBundles.keySet());
		Collections.sort(names);
		return Collections.unmodifiableList(names);
	}
	private RegisteredSslBundle getRegistered(String name) throws NoSuchSslBundleException {
		Assert.notNull(name, 'Name must not be null');
		RegisteredSslBundle registered = this.registeredBundles.get(name);
		if (registered == null) {
			throw new NoSuchSslBundleException(name, 'SSL bundle name "%s" cannot be found'.formatted(name));
		}
		return registered;
	}
	private static class RegisteredSslBundle {
		private final String name;
		private final List<Consumer<SslBundle>> updateHandlers = new CopyOnWriteArrayList<>();
		private volatile SslBundle bundle;
		RegisteredSslBundle(String name, SslBundle bundle) {
			this.name = name;
			this.bundle = bundle;
		}
		void update(SslBundle updatedBundle) {
			Assert.notNull(updatedBundle, 'UpdatedBundle must not be null');
			this.bundle = updatedBundle;
			if (this.updateHandlers.isEmpty()) {
				logger.warn(LogMessage.format(
						'SSL bundle "%s" has been updated but may be in use by a technology that doesn"t support SSL reloading',
						this.name));
			}
			this.updateHandlers.forEach((handler) -> handler.accept(updatedBundle));
		}
		SslBundle getBundle() {
			return this.bundle;
		}
		void addUpdateHandler(Consumer<SslBundle> updateHandler) {
			Assert.notNull(updateHandler, 'UpdateHandler must not be null');
			this.updateHandlers.add(updateHandler);
		}
	}
}
/*
package org.springframework.boot.ssl;
/**
public interface SslBundle {
	/**
	 * The default protocol to use.
	 */
	String DEFAULT_PROTOCOL = 'TLS';
	/**
	 * Return the {@link SslStoreBundle} that can be used to access this bundle"s key and
	 * trust stores.
	 * @return the {@code SslStoreBundle} instance for this bundle
	 */
	SslStoreBundle getStores();
	/**
	 * Return a reference to the key that should be used for this bundle or
	 * {@link SslBundleKey#NONE}.
	 * @return a reference to the SSL key that should be used
	 */
	SslBundleKey getKey();
	/**
	 * Return {@link SslOptions} that should be applied when establishing the SSL
	 * connection.
	 * @return the options that should be applied
	 */
	SslOptions getOptions();
	/**
	 * Return the protocol to use when establishing the connection. Values should be
	 * supported by {@link SSLContext#getInstance(String)}.
	 * @return the SSL protocol
	 * @see SSLContext#getInstance(String)
	 */
	String getProtocol();
	/**
	 * Return the {@link SslManagerBundle} that can be used to access this bundle"s
	 * {@link KeyManager key} and {@link TrustManager trust} managers.
	 * @return the {@code SslManagerBundle} instance for this bundle
	 */
	SslManagerBundle getManagers();
	/**
	 * Factory method to create a new {@link SSLContext} for this bundle.
	 * @return a new {@link SSLContext} instance
	 */
	default SSLContext createSslContext() {
		return getManagers().createSslContext(getProtocol());
	}
	/**
	 * Factory method to create a new {@link SslBundle} instance.
	 * @param stores the stores or {@code null}
	 * @return a new {@link SslBundle} instance
	 */
	static SslBundle of(SslStoreBundle stores) {
		return of(stores, null, null);
	}
	/**
	 * Factory method to create a new {@link SslBundle} instance.
	 * @param stores the stores or {@code null}
	 * @param key the key or {@code null}
	 * @return a new {@link SslBundle} instance
	 */
	static SslBundle of(SslStoreBundle stores, SslBundleKey key) {
		return of(stores, key, null);
	}
	/**
	 * Factory method to create a new {@link SslBundle} instance.
	 * @param stores the stores or {@code null}
	 * @param key the key or {@code null}
	 * @param options the options or {@code null}
	 * @return a new {@link SslBundle} instance
	 */
	static SslBundle of(SslStoreBundle stores, SslBundleKey key, SslOptions options) {
		return of(stores, key, options, null);
	}
	/**
	 * Factory method to create a new {@link SslBundle} instance.
	 * @param stores the stores or {@code null}
	 * @param key the key or {@code null}
	 * @param options the options or {@code null}
	 * @param protocol the protocol or {@code null}
	 * @return a new {@link SslBundle} instance
	 */
	static SslBundle of(SslStoreBundle stores, SslBundleKey key, SslOptions options, String protocol) {
		return of(stores, key, options, protocol, null);
	}
	/**
	 * Factory method to create a new {@link SslBundle} instance.
	 * @param stores the stores or {@code null}
	 * @param key the key or {@code null}
	 * @param options the options or {@code null}
	 * @param protocol the protocol or {@code null}
	 * @param managers the managers or {@code null}
	 * @return a new {@link SslBundle} instance
	 */
	static SslBundle of(SslStoreBundle stores, SslBundleKey key, SslOptions options, String protocol,
			SslManagerBundle managers) {
		SslManagerBundle managersToUse = (managers != null) ? managers : SslManagerBundle.from(stores, key);
		return new SslBundle() {
			@Override
			public SslStoreBundle getStores() {
				return (stores != null) ? stores : SslStoreBundle.NONE;
			}
			@Override
			public SslBundleKey getKey() {
				return (key != null) ? key : SslBundleKey.NONE;
			}
			@Override
			public SslOptions getOptions() {
				return (options != null) ? options : SslOptions.NONE;
			}
			@Override
			public String getProtocol() {
				return (!StringUtils.hasText(protocol)) ? DEFAULT_PROTOCOL : protocol;
			}
			@Override
			public SslManagerBundle getManagers() {
				return managersToUse;
			}
			@Override
			public String toString() {
				ToStringCreator creator = new ToStringCreator(this);
				creator.append('key', getKey());
				creator.append('options', getOptions());
				creator.append('protocol', getProtocol());
				creator.append('stores', getStores());
				return creator.toString();
			}
		};
	}
}
/*
package org.springframework.boot.ssl;
/**
public interface SslOptions {
	/**
	 * {@link SslOptions} that returns {@code null} results.
	 */
	SslOptions NONE = of((Set<String>) null, (Set<String>) null);
	/**
	 * Return if any SSL options have been specified.
	 * @return {@code true} if SSL options have been specified
	 */
	default boolean isSpecified() {
		return (getCiphers() != null) && (getEnabledProtocols() != null);
	}
	/**
	 * Return the ciphers that can be used or an empty set. The cipher names in this set
	 * should be compatible with those supported by
	 * {@link SSLEngine#getSupportedCipherSuites()}.
	 * @return the ciphers that can be used or {@code null}
	 */
	String[] getCiphers();
	/**
	 * Return the protocols that should be enabled or an empty set. The protocols names in
	 * this set should be compatible with those supported by
	 * {@link SSLEngine#getSupportedProtocols()}.
	 * @return the protocols to enable or {@code null}
	 */
	String[] getEnabledProtocols();
	/**
	 * Factory method to create a new {@link SslOptions} instance.
	 * @param ciphers the ciphers
	 * @param enabledProtocols the enabled protocols
	 * @return a new {@link SslOptions} instance
	 */
	static SslOptions of(String[] ciphers, String[] enabledProtocols) {
		return new SslOptions() {
			@Override
			public String[] getCiphers() {
				return ciphers;
			}
			@Override
			public String[] getEnabledProtocols() {
				return enabledProtocols;
			}
			@Override
			public String toString() {
				ToStringCreator creator = new ToStringCreator(this);
				creator.append('ciphers', ciphers);
				creator.append('enabledProtocols', enabledProtocols);
				return creator.toString();
			}
		};
	}
	/**
	 * Factory method to create a new {@link SslOptions} instance.
	 * @param ciphers the ciphers
	 * @param enabledProtocols the enabled protocols
	 * @return a new {@link SslOptions} instance
	 */
	static SslOptions of(Set<String> ciphers, Set<String> enabledProtocols) {
		return of(toArray(ciphers), toArray(enabledProtocols));
	}
	/**
	 * Helper method that provides a null-safe way to convert a {@code String[]} to a
	 * {@link Collection} for client libraries to use.
	 * @param array the array to convert
	 * @return a collection or {@code null}
	 */
	static Set<String> asSet(String[] array) {
		return (array != null) ? Collections.unmodifiableSet(new LinkedHashSet<>(Arrays.asList(array))) : null;
	}
	private static String[] toArray(Collection<String> collection) {
		return (collection != null) ? collection.toArray(String[]::new) : null;
	}
}
/*
package org.springframework.boot.ssl;
/**
public interface SslManagerBundle {
	/**
	 * Return the {@code KeyManager} instances used to establish identity.
	 * @return the key managers
	 */
	default KeyManager[] getKeyManagers() {
		return getKeyManagerFactory().getKeyManagers();
	}
	/**
	 * Return the {@code KeyManagerFactory} used to establish identity.
	 * @return the key manager factory
	 */
	KeyManagerFactory getKeyManagerFactory();
	/**
	 * Return the {@link TrustManager} instances used to establish trust.
	 * @return the trust managers
	 */
	default TrustManager[] getTrustManagers() {
		return getTrustManagerFactory().getTrustManagers();
	}
	/**
	 * Return the {@link TrustManagerFactory} used to establish trust.
	 * @return the trust manager factory
	 */
	TrustManagerFactory getTrustManagerFactory();
	/**
	 * Factory method to create a new {@link SSLContext} for the {@link #getKeyManagers()
	 * key managers} and {@link #getTrustManagers() trust managers} managed by this
	 * instance.
	 * @param protocol the standard name of the SSL protocol. See
	 * {@link SSLContext#getInstance(String)}
	 * @return a new {@link SSLContext} instance
	 */
	default SSLContext createSslContext(String protocol) {
		try {
			SSLContext sslContext = SSLContext.getInstance(protocol);
			sslContext.init(getKeyManagers(), getTrustManagers(), null);
			return sslContext;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Could not load SSL context: ' + ex.getMessage(), ex);
		}
	}
	/**
	 * Factory method to create a new {@link SslManagerBundle} instance.
	 * @param keyManagerFactory the key manager factory
	 * @param trustManagerFactory the trust manager factory
	 * @return a new {@link SslManagerBundle} instance
	 */
	static SslManagerBundle of(KeyManagerFactory keyManagerFactory, TrustManagerFactory trustManagerFactory) {
		Assert.notNull(keyManagerFactory, 'KeyManagerFactory must not be null');
		Assert.notNull(trustManagerFactory, 'TrustManagerFactory must not be null');
		return new SslManagerBundle() {
			@Override
			public KeyManagerFactory getKeyManagerFactory() {
				return keyManagerFactory;
			}
			@Override
			public TrustManagerFactory getTrustManagerFactory() {
				return trustManagerFactory;
			}
		};
	}
	/**
	 * Factory method to create a new {@link SslManagerBundle} backed by the given
	 * {@link SslBundle} and {@link SslBundleKey}.
	 * @param storeBundle the SSL store bundle
	 * @param key the key reference
	 * @return a new {@link SslManagerBundle} instance
	 */
	static SslManagerBundle from(SslStoreBundle storeBundle, SslBundleKey key) {
		return new DefaultSslManagerBundle(storeBundle, key);
	}
}
/*
/**
package org.springframework.boot.ssl;
/*
package org.springframework.boot.ssl.pem;
/**
public record PemSslStoreDetails(String type, String alias, String password, String certificates, String privateKey,
		String privateKeyPassword) {
	/**
	 * Create a new {@link PemSslStoreDetails} instance.
	 * @param type the key store type, for example {@code JKS} or {@code PKCS11}. A
	 * {@code null} value will use {@link KeyStore#getDefaultType()}).
	 * @param alias the alias used when setting entries in the {@link KeyStore}
	 * @param password the password used
	 * {@link KeyStore#setKeyEntry(String, java.security.Key, char[], java.security.cert.Certificate[])
	 * setting key entries} in the {@link KeyStore}
	 * @param certificates the certificate content (either the PEM content itself or a
	 * reference to the resource to load)
	 * @param privateKey the private key content (either the PEM content itself or a
	 * reference to the resource to load)
	 * @param privateKeyPassword a password used to decrypt an encrypted private key
	 * @since 3.2.0
	 */
	public PemSslStoreDetails {
	}
	/**
	 * Create a new {@link PemSslStoreDetails} instance.
	 * @param type the key store type, for example {@code JKS} or {@code PKCS11}. A
	 * {@code null} value will use {@link KeyStore#getDefaultType()}).
	 * @param certificate the certificate content (either the PEM content itself or a
	 * reference to the resource to load)
	 * @param privateKey the private key content (either the PEM content itself or a
	 * reference to the resource to load)
	 * @param privateKeyPassword a password used to decrypt an encrypted private key
	 */
	public PemSslStoreDetails(String type, String certificate, String privateKey, String privateKeyPassword) {
		this(type, null, null, certificate, privateKey, privateKeyPassword);
	}
	/**
	 * Create a new {@link PemSslStoreDetails} instance.
	 * @param type the key store type, for example {@code JKS} or {@code PKCS11}. A
	 * {@code null} value will use {@link KeyStore#getDefaultType()}).
	 * @param certificate the certificate content (either the PEM content itself or a
	 * reference to the resource to load)
	 * @param privateKey the private key content (either the PEM content itself or a
	 * reference to the resource to load)
	 */
	public PemSslStoreDetails(String type, String certificate, String privateKey) {
		this(type, certificate, privateKey, null);
	}
	/**
	 * Return a new {@link PemSslStoreDetails} instance with a new alias.
	 * @param alias the new alias
	 * @return a new {@link PemSslStoreDetails} instance
	 * @since 3.2.0
	 */
	public PemSslStoreDetails withAlias(String alias) {
		return new PemSslStoreDetails(this.type, alias, this.password, this.certificates, this.privateKey,
				this.privateKeyPassword);
	}
	/**
	 * Return a new {@link PemSslStoreDetails} instance with a new password.
	 * @param password the new password
	 * @return a new {@link PemSslStoreDetails} instance
	 * @since 3.2.0
	 */
	public PemSslStoreDetails withPassword(String password) {
		return new PemSslStoreDetails(this.type, this.alias, password, this.certificates, this.privateKey,
				this.privateKeyPassword);
	}
	/**
	 * Return a new {@link PemSslStoreDetails} instance with a new private key.
	 * @param privateKey the new private key
	 * @return a new {@link PemSslStoreDetails} instance
	 */
	public PemSslStoreDetails withPrivateKey(String privateKey) {
		return new PemSslStoreDetails(this.type, this.alias, this.password, this.certificates, privateKey,
				this.privateKeyPassword);
	}
	/**
	 * Return a new {@link PemSslStoreDetails} instance with a new private key password.
	 * @param privateKeyPassword the new private key password
	 * @return a new {@link PemSslStoreDetails} instance
	 */
	public PemSslStoreDetails withPrivateKeyPassword(String privateKeyPassword) {
		return new PemSslStoreDetails(this.type, this.alias, this.password, this.certificates, this.privateKey,
				privateKeyPassword);
	}
	boolean isEmpty() {
		return isEmpty(this.type) && isEmpty(this.certificates) && isEmpty(this.privateKey);
	}
	private boolean isEmpty(String value) {
		return !StringUtils.hasText(value);
	}
	/**
	 * Factory method to create a new {@link PemSslStoreDetails} instance for the given
	 * certificate. <b>Note:</b> This method doesn"t actually check if the provided value
	 * only contains a single certificate. It is functionally equivalent to
	 * {@link #forCertificates(String)}.
	 * @param certificate the certificate content (either the PEM content itself or a
	 * reference to the resource to load)
	 * @return a new {@link PemSslStoreDetails} instance.
	 */
	public static PemSslStoreDetails forCertificate(String certificate) {
		return forCertificates(certificate);
	}
	/**
	 * Factory method to create a new {@link PemSslStoreDetails} instance for the given
	 * certificates.
	 * @param certificates the certificates content (either the PEM content itself or a
	 * reference to the resource to load)
	 * @return a new {@link PemSslStoreDetails} instance.
	 * @since 3.2.0
	 */
	public static PemSslStoreDetails forCertificates(String certificates) {
		return new PemSslStoreDetails(null, certificates, null);
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
final class PemCertificateParser {
	private static final String HEADER = '-+BEGIN\\s+.*CERTIFICATE[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String BASE64_TEXT = '([a-z0-9+/=\\r\\n]+)';
	private static final String FOOTER = '-+END\\s+.*CERTIFICATE[^-]*-+';
	private static final Pattern PATTERN = Pattern.compile(HEADER + BASE64_TEXT + FOOTER, Pattern.CASE_INSENSITIVE);
	private PemCertificateParser() {
	}
	/**
	 * Parse certificates from the specified string.
	 * @param text the text to parse
	 * @return the parsed certificates
	 */
	static List<X509Certificate> parse(String text) {
		if (text == null) {
			return null;
		}
		CertificateFactory factory = getCertificateFactory();
		List<X509Certificate> certs = new ArrayList<>();
		readCertificates(text, factory, certs::add);
		Assert.state(!CollectionUtils.isEmpty(certs), 'Missing certificates or unrecognized format');
		return List.copyOf(certs);
	}
	private static CertificateFactory getCertificateFactory() {
		try {
			return CertificateFactory.getInstance('X.509');
		}
		catch (CertificateException ex) {
			throw new IllegalStateException('Unable to get X.509 certificate factory', ex);
		}
	}
	private static void readCertificates(String text, CertificateFactory factory, Consumer<X509Certificate> consumer) {
		try {
			Matcher matcher = PATTERN.matcher(text);
			while (matcher.find()) {
				String encodedText = matcher.group(1);
				byte[] decodedBytes = decodeBase64(encodedText);
				ByteArrayInputStream inputStream = new ByteArrayInputStream(decodedBytes);
				while (inputStream.available() > 0) {
					consumer.accept((X509Certificate) factory.generateCertificate(inputStream));
				}
			}
		}
		catch (CertificateException ex) {
			throw new IllegalStateException('Error reading certificate: ' + ex.getMessage(), ex);
		}
	}
	private static byte[] decodeBase64(String content) {
		byte[] bytes = content.replaceAll('\r', '').replaceAll('\n', '').getBytes();
		return Base64.getDecoder().decode(bytes);
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
public interface PemSslStore {
	/**
	 * The key store type, for example {@code JKS} or {@code PKCS11}. A {@code null} value
	 * will use {@link KeyStore#getDefaultType()}).
	 * @return the key store type
	 */
	String type();
	/**
	 * The alias used when setting entries in the {@link KeyStore}.
	 * @return the alias
	 */
	String alias();
	/**
	 * The password used when
	 * {@link KeyStore#setKeyEntry(String, java.security.Key, char[], java.security.cert.Certificate[])
	 * setting key entries} in the {@link KeyStore}.
	 * @return the password
	 */
	String password();
	/**
	 * The certificates for this store. When a {@link #privateKey() private key} is
	 * present the returned value is treated as a certificate chain, otherwise it is
	 * treated a list of certificates that should all be registered.
	 * @return the X509 certificates
	 */
	List<X509Certificate> certificates();
	/**
	 * The private key for this store or {@code null}.
	 * @return the private key
	 */
	PrivateKey privateKey();
	/**
	 * Return a new {@link PemSslStore} instance with a new alias.
	 * @param alias the new alias
	 * @return a new {@link PemSslStore} instance
	 */
	default PemSslStore withAlias(String alias) {
		return of(type(), alias, password(), certificates(), privateKey());
	}
	/**
	 * Return a new {@link PemSslStore} instance with a new password.
	 * @param password the new password
	 * @return a new {@link PemSslStore} instance
	 */
	default PemSslStore withPassword(String password) {
		return of(type(), alias(), password, certificates(), privateKey());
	}
	/**
	 * Return a {@link PemSslStore} instance loaded using the given
	 * {@link PemSslStoreDetails}.
	 * @param details the PEM store details
	 * @return a loaded {@link PemSslStore} or {@code null}.
	 */
	static PemSslStore load(PemSslStoreDetails details) {
		return load(details, ApplicationResourceLoader.get());
	}
	/**
	 * Return a {@link PemSslStore} instance loaded using the given
	 * {@link PemSslStoreDetails}.
	 * @param details the PEM store details
	 * @param resourceLoader the resource loader used to load content
	 * @return a loaded {@link PemSslStore} or {@code null}.
	 * @since 3.3.5
	 */
	static PemSslStore load(PemSslStoreDetails details, ResourceLoader resourceLoader) {
		if (details == null || details.isEmpty()) {
			return null;
		}
		return new LoadedPemSslStore(details, resourceLoader);
	}
	/**
	 * Factory method that can be used to create a new {@link PemSslStore} with the given
	 * values.
	 * @param type the key store type
	 * @param certificates the certificates for this store
	 * @param privateKey the private key
	 * @return a new {@link PemSslStore} instance
	 */
	static PemSslStore of(String type, List<X509Certificate> certificates, PrivateKey privateKey) {
		return of(type, null, null, certificates, privateKey);
	}
	/**
	 * Factory method that can be used to create a new {@link PemSslStore} with the given
	 * values.
	 * @param certificates the certificates for this store
	 * @param privateKey the private key
	 * @return a new {@link PemSslStore} instance
	 */
	static PemSslStore of(List<X509Certificate> certificates, PrivateKey privateKey) {
		return of(null, null, null, certificates, privateKey);
	}
	/**
	 * Factory method that can be used to create a new {@link PemSslStore} with the given
	 * values.
	 * @param type the key store type
	 * @param alias the alias used when setting entries in the {@link KeyStore}
	 * @param password the password used
	 * {@link KeyStore#setKeyEntry(String, java.security.Key, char[], java.security.cert.Certificate[])
	 * setting key entries} in the {@link KeyStore}
	 * @param certificates the certificates for this store
	 * @param privateKey the private key
	 * @return a new {@link PemSslStore} instance
	 */
	static PemSslStore of(String type, String alias, String password, List<X509Certificate> certificates,
			PrivateKey privateKey) {
		Assert.notEmpty(certificates, 'Certificates must not be empty');
		return new PemSslStore() {
			@Override
			public String type() {
				return type;
			}
			@Override
			public String alias() {
				return alias;
			}
			@Override
			public String password() {
				return password;
			}
			@Override
			public List<X509Certificate> certificates() {
				return certificates;
			}
			@Override
			public PrivateKey privateKey() {
				return privateKey;
			}
		};
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
public class PemSslStoreBundle implements SslStoreBundle {
	private static final String DEFAULT_ALIAS = 'ssl';
	private final Supplier<KeyStore> keyStore;
	private final Supplier<KeyStore> trustStore;
	/**
	 * Create a new {@link PemSslStoreBundle} instance.
	 * @param keyStoreDetails the key store details
	 * @param trustStoreDetails the trust store details
	 */
	public PemSslStoreBundle(PemSslStoreDetails keyStoreDetails, PemSslStoreDetails trustStoreDetails) {
		this(PemSslStore.load(keyStoreDetails), PemSslStore.load(trustStoreDetails));
	}
	/**
	 * Create a new {@link PemSslStoreBundle} instance.
	 * @param pemKeyStore the PEM key store
	 * @param pemTrustStore the PEM trust store
	 * @since 3.2.0
	 */
	public PemSslStoreBundle(PemSslStore pemKeyStore, PemSslStore pemTrustStore) {
		this.keyStore = SingletonSupplier.of(() -> createKeyStore('key', pemKeyStore));
		this.trustStore = SingletonSupplier.of(() -> createKeyStore('trust', pemTrustStore));
	}
	@Override
	public KeyStore getKeyStore() {
		return this.keyStore.get();
	}
	@Override
	public String getKeyStorePassword() {
		return null;
	}
	@Override
	public KeyStore getTrustStore() {
		return this.trustStore.get();
	}
	private static KeyStore createKeyStore(String name, PemSslStore pemSslStore) {
		if (pemSslStore == null) {
			return null;
		}
		try {
			List<X509Certificate> certificates = pemSslStore.certificates();
			Assert.notEmpty(certificates, 'Certificates must not be empty');
			String alias = (pemSslStore.alias() != null) ? pemSslStore.alias() : DEFAULT_ALIAS;
			KeyStore store = createKeyStore(pemSslStore.type());
			PrivateKey privateKey = pemSslStore.privateKey();
			if (privateKey != null) {
				addPrivateKey(store, privateKey, alias, pemSslStore.password(), certificates);
			}
			else {
				addCertificates(store, certificates, alias);
			}
			return store;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to create %s store: %s'.formatted(name, ex.getMessage()), ex);
		}
	}
	private static KeyStore createKeyStore(String type)
			throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
		KeyStore store = KeyStore.getInstance(StringUtils.hasText(type) ? type : KeyStore.getDefaultType());
		store.load(null);
		return store;
	}
	private static void addPrivateKey(KeyStore keyStore, PrivateKey privateKey, String alias, String keyPassword,
			List<X509Certificate> certificateChain) throws KeyStoreException {
		keyStore.setKeyEntry(alias, privateKey, (keyPassword != null) ? keyPassword.toCharArray() : null,
				certificateChain.toArray(X509Certificate[]::new));
	}
	private static void addCertificates(KeyStore keyStore, List<X509Certificate> certificates, String alias)
			throws KeyStoreException {
		for (int index = 0; index < certificates.size(); index++) {
			String entryAlias = alias + ((certificates.size() == 1) ? '' : '-' + index);
			X509Certificate certificate = certificates.get(index);
			keyStore.setCertificateEntry(entryAlias, certificate);
		}
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this);
		KeyStore keyStore = this.keyStore.get();
		KeyStore trustStore = this.trustStore.get();
		creator.append('keyStore.type', (keyStore != null) ? keyStore.getType() : 'none');
		creator.append('keyStorePassword', null);
		creator.append('trustStore.type', (trustStore != null) ? trustStore.getType() : 'none');
		return creator.toString();
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
final class LoadedPemSslStore implements PemSslStore {
	private final PemSslStoreDetails details;
	private final ResourceLoader resourceLoader;
	private final Supplier<List<X509Certificate>> certificatesSupplier;
	private final Supplier<PrivateKey> privateKeySupplier;
	LoadedPemSslStore(PemSslStoreDetails details, ResourceLoader resourceLoader) {
		Assert.notNull(details, 'Details must not be null');
		Assert.notNull(resourceLoader, 'ResourceLoader must not be null');
		this.details = details;
		this.resourceLoader = resourceLoader;
		this.certificatesSupplier = supplier(() -> loadCertificates(details, resourceLoader));
		this.privateKeySupplier = supplier(() -> loadPrivateKey(details, resourceLoader));
	}
	private static <T> Supplier<T> supplier(ThrowingSupplier<T> supplier) {
		return SingletonSupplier.of(supplier.throwing(LoadedPemSslStore::asUncheckedIOException));
	}
	private static UncheckedIOException asUncheckedIOException(String message, Exception cause) {
		return new UncheckedIOException(message, (IOException) cause);
	}
	private static List<X509Certificate> loadCertificates(PemSslStoreDetails details, ResourceLoader resourceLoader)
			throws IOException {
		PemContent pemContent = PemContent.load(details.certificates(), resourceLoader);
		if (pemContent == null) {
			return null;
		}
		List<X509Certificate> certificates = pemContent.getCertificates();
		Assert.state(!CollectionUtils.isEmpty(certificates), 'Loaded certificates are empty');
		return certificates;
	}
	private static PrivateKey loadPrivateKey(PemSslStoreDetails details, ResourceLoader resourceLoader)
			throws IOException {
		PemContent pemContent = PemContent.load(details.privateKey(), resourceLoader);
		return (pemContent != null) ? pemContent.getPrivateKey(details.privateKeyPassword()) : null;
	}
	@Override
	public String type() {
		return this.details.type();
	}
	@Override
	public String alias() {
		return this.details.alias();
	}
	@Override
	public String password() {
		return this.details.password();
	}
	@Override
	public List<X509Certificate> certificates() {
		return this.certificatesSupplier.get();
	}
	@Override
	public PrivateKey privateKey() {
		return this.privateKeySupplier.get();
	}
	@Override
	public PemSslStore withAlias(String alias) {
		return new LoadedPemSslStore(this.details.withAlias(alias), this.resourceLoader);
	}
	@Override
	public PemSslStore withPassword(String password) {
		return new LoadedPemSslStore(this.details.withPassword(password), this.resourceLoader);
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
final class PemPrivateKeyParser {
	private static final String PKCS1_RSA_HEADER = '-+BEGIN\\s+RSA\\s+PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String PKCS1_RSA_FOOTER = '-+END\\s+RSA\\s+PRIVATE\\s+KEY[^-]*-+';
	private static final String PKCS8_HEADER = '-+BEGIN\\s+PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String PKCS8_FOOTER = '-+END\\s+PRIVATE\\s+KEY[^-]*-+';
	private static final String PKCS8_ENCRYPTED_HEADER = '-+BEGIN\\s+ENCRYPTED\\s+PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String PKCS8_ENCRYPTED_FOOTER = '-+END\\s+ENCRYPTED\\s+PRIVATE\\s+KEY[^-]*-+';
	private static final String SEC1_EC_HEADER = '-+BEGIN\\s+EC\\s+PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+';
	private static final String SEC1_EC_FOOTER = '-+END\\s+EC\\s+PRIVATE\\s+KEY[^-]*-+';
	private static final String BASE64_TEXT = '([a-z0-9+/=\\r\\n]+)';
	public static final int BASE64_TEXT_GROUP = 1;
	private static final EncodedOid RSA_ALGORITHM = EncodedOid.OID_1_2_840_113549_1_1_1;
	private static final EncodedOid ELLIPTIC_CURVE_ALGORITHM = EncodedOid.OID_1_2_840_10045_2_1;
	private static final EncodedOid ELLIPTIC_CURVE_384_BIT = EncodedOid.OID_1_3_132_0_34;
	private static final Map<EncodedOid, String> ALGORITHMS;
	static {
		Map<EncodedOid, String> algorithms = new HashMap<>();
		algorithms.put(EncodedOid.OID_1_2_840_113549_1_1_1, 'RSA');
		algorithms.put(EncodedOid.OID_1_2_840_113549_1_1_10, 'RSA');
		algorithms.put(EncodedOid.OID_1_2_840_10040_4_1, 'DSA');
		algorithms.put(EncodedOid.OID_1_3_101_110, 'XDH');
		algorithms.put(EncodedOid.OID_1_3_101_111, 'XDH');
		algorithms.put(EncodedOid.OID_1_3_101_112, 'EdDSA');
		algorithms.put(EncodedOid.OID_1_3_101_113, 'EdDSA');
		algorithms.put(EncodedOid.OID_1_2_840_10045_2_1, 'EC');
		ALGORITHMS = Collections.unmodifiableMap(algorithms);
	}
	private static final List<PemParser> PEM_PARSERS;
	static {
		List<PemParser> parsers = new ArrayList<>();
		parsers.add(new PemParser(PKCS1_RSA_HEADER, PKCS1_RSA_FOOTER, PemPrivateKeyParser::createKeySpecForPkcs1Rsa,
				'RSA'));
		parsers.add(new PemParser(SEC1_EC_HEADER, SEC1_EC_FOOTER, PemPrivateKeyParser::createKeySpecForSec1Ec, 'EC'));
		parsers.add(new PemParser(PKCS8_HEADER, PKCS8_FOOTER, PemPrivateKeyParser::createKeySpecForPkcs8, 'RSA',
				'RSASSA-PSS', 'EC', 'DSA', 'EdDSA', 'XDH'));
		parsers.add(new PemParser(PKCS8_ENCRYPTED_HEADER, PKCS8_ENCRYPTED_FOOTER,
				PemPrivateKeyParser::createKeySpecForPkcs8Encrypted, 'RSA', 'RSASSA-PSS', 'EC', 'DSA', 'EdDSA', 'XDH'));
		PEM_PARSERS = Collections.unmodifiableList(parsers);
	}
	private PemPrivateKeyParser() {
	}
	private static PKCS8EncodedKeySpec createKeySpecForPkcs1Rsa(byte[] bytes, String password) {
		return createKeySpecForAlgorithm(bytes, RSA_ALGORITHM, null);
	}
	private static PKCS8EncodedKeySpec createKeySpecForSec1Ec(byte[] bytes, String password) {
		DerElement ecPrivateKey = DerElement.of(bytes);
		Assert.state(ecPrivateKey.isType(ValueType.ENCODED, TagType.SEQUENCE),
				'Key spec should be an ASN.1 encoded sequence');
		DerElement version = DerElement.of(ecPrivateKey.getContents());
		Assert.state(version != null && version.isType(ValueType.PRIMITIVE, TagType.INTEGER),
				'Key spec should start with version');
		Assert.state(version.getContents().remaining() == 1 && version.getContents().get() == 1,
				'Key spec version must be 1');
		DerElement privateKey = DerElement.of(ecPrivateKey.getContents());
		Assert.state(privateKey != null && privateKey.isType(ValueType.PRIMITIVE, TagType.OCTET_STRING),
				'Key spec should contain private key');
		DerElement parameters = DerElement.of(ecPrivateKey.getContents());
		return createKeySpecForAlgorithm(bytes, ELLIPTIC_CURVE_ALGORITHM, getEcParameters(parameters));
	}
	private static EncodedOid getEcParameters(DerElement parameters) {
		if (parameters == null) {
			return ELLIPTIC_CURVE_384_BIT;
		}
		Assert.state(parameters.isType(ValueType.ENCODED), 'Key spec should contain encoded parameters');
		DerElement contents = DerElement.of(parameters.getContents());
		Assert.state(contents != null && contents.isType(ValueType.PRIMITIVE, TagType.OBJECT_IDENTIFIER),
				'Key spec parameters should contain object identifier');
		return EncodedOid.of(contents);
	}
	private static PKCS8EncodedKeySpec createKeySpecForAlgorithm(byte[] bytes, EncodedOid algorithm,
			EncodedOid parameters) {
		try {
			DerEncoder encoder = new DerEncoder();
			encoder.integer(0x00); // Version 0
			DerEncoder algorithmIdentifier = new DerEncoder();
			algorithmIdentifier.objectIdentifier(algorithm);
			algorithmIdentifier.objectIdentifier(parameters);
			encoder.sequence(algorithmIdentifier.toByteArray());
			encoder.octetString(bytes);
			return new PKCS8EncodedKeySpec(encoder.toSequence());
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private static PKCS8EncodedKeySpec createKeySpecForPkcs8(byte[] bytes, String password) {
		DerElement ecPrivateKey = DerElement.of(bytes);
		Assert.state(ecPrivateKey.isType(ValueType.ENCODED, TagType.SEQUENCE),
				'Key spec should be an ASN.1 encoded sequence');
		DerElement version = DerElement.of(ecPrivateKey.getContents());
		Assert.state(version != null && version.isType(ValueType.PRIMITIVE, TagType.INTEGER),
				'Key spec should start with version');
		DerElement sequence = DerElement.of(ecPrivateKey.getContents());
		Assert.state(sequence != null && sequence.isType(ValueType.ENCODED, TagType.SEQUENCE),
				'Key spec should contain private key');
		DerElement algorithmId = DerElement.of(sequence.getContents());
		Assert.state(algorithmId != null && algorithmId.isType(ValueType.PRIMITIVE, TagType.OBJECT_IDENTIFIER),
				'Key spec container object identifier');
		String algorithmName = ALGORITHMS.get(EncodedOid.of(algorithmId));
		return (algorithmName != null) ? new PKCS8EncodedKeySpec(bytes, algorithmName) : new PKCS8EncodedKeySpec(bytes);
	}
	private static PKCS8EncodedKeySpec createKeySpecForPkcs8Encrypted(byte[] bytes, String password) {
		return Pkcs8PrivateKeyDecryptor.decrypt(bytes, password);
	}
	/**
	 * Parse a private key from the specified string.
	 * @param text the text to parse
	 * @return the parsed private key
	 */
	static PrivateKey parse(String text) {
		return parse(text, null);
	}
	/**
	 * Parse a private key from the specified string, using the provided password for
	 * decryption if necessary.
	 * @param text the text to parse
	 * @param password the password used to decrypt an encrypted private key
	 * @return the parsed private key
	 */
	static PrivateKey parse(String text, String password) {
		if (text == null) {
			return null;
		}
		try {
			for (PemParser pemParser : PEM_PARSERS) {
				PrivateKey privateKey = pemParser.parse(text, password);
				if (privateKey != null) {
					return privateKey;
				}
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Error loading private key file: ' + ex.getMessage(), ex);
		}
		throw new IllegalStateException('Missing private key or unrecognized format');
	}
	/**
	 * Parser for a specific PEM format.
	 */
	private static class PemParser {
		private final Pattern pattern;
		private final BiFunction<byte[], String, PKCS8EncodedKeySpec> keySpecFactory;
		private final String[] algorithms;
		PemParser(String header, String footer, BiFunction<byte[], String, PKCS8EncodedKeySpec> keySpecFactory,
				String... algorithms) {
			this.pattern = Pattern.compile(header + BASE64_TEXT + footer, Pattern.CASE_INSENSITIVE);
			this.keySpecFactory = keySpecFactory;
			this.algorithms = algorithms;
		}
		PrivateKey parse(String text, String password) {
			Matcher matcher = this.pattern.matcher(text);
			return (!matcher.find()) ? null : parse(decodeBase64(matcher.group(BASE64_TEXT_GROUP)), password);
		}
		private static byte[] decodeBase64(String content) {
			byte[] contentBytes = content.replaceAll('\r', '').replaceAll('\n', '').getBytes();
			return Base64.getDecoder().decode(contentBytes);
		}
		private PrivateKey parse(byte[] bytes, String password) {
			PKCS8EncodedKeySpec keySpec = this.keySpecFactory.apply(bytes, password);
			if (keySpec.getAlgorithm() != null) {
				try {
					KeyFactory keyFactory = KeyFactory.getInstance(keySpec.getAlgorithm());
					return keyFactory.generatePrivate(keySpec);
				}
				catch (InvalidKeySpecException | NoSuchAlgorithmException ex) {
					// Ignore
				}
			}
			for (String algorithm : this.algorithms) {
				try {
					KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
					return keyFactory.generatePrivate(keySpec);
				}
				catch (InvalidKeySpecException | NoSuchAlgorithmException ex) {
					// Ignore
				}
			}
			return null;
		}
	}
	/**
	 * Simple ASN.1 DER encoder.
	 */
	static class DerEncoder {
		private final ByteArrayOutputStream stream = new ByteArrayOutputStream();
		void objectIdentifier(EncodedOid encodedOid) throws IOException {
			int code = (encodedOid != null) ? 0x06 : 0x05;
			codeLengthBytes(code, (encodedOid != null) ? encodedOid.toByteArray() : null);
		}
		void integer(int... encodedInteger) throws IOException {
			codeLengthBytes(0x02, bytes(encodedInteger));
		}
		void octetString(byte[] bytes) throws IOException {
			codeLengthBytes(0x04, bytes);
		}
		void sequence(byte[] bytes) throws IOException {
			codeLengthBytes(0x30, bytes);
		}
		void codeLengthBytes(int code, byte[] bytes) throws IOException {
			this.stream.write(code);
			int length = (bytes != null) ? bytes.length : 0;
			if (length <= 127) {
				this.stream.write(length & 0xFF);
			}
			else {
				ByteArrayOutputStream lengthStream = new ByteArrayOutputStream();
				while (length != 0) {
					lengthStream.write(length & 0xFF);
					length = length >> 8;
				}
				byte[] lengthBytes = lengthStream.toByteArray();
				this.stream.write(0x80 | lengthBytes.length);
				for (int i = lengthBytes.length - 1; i >= 0; i--) {
					this.stream.write(lengthBytes[i]);
				}
			}
			if (bytes != null) {
				this.stream.write(bytes);
			}
		}
		private static byte[] bytes(int... elements) {
			if (elements == null) {
				return null;
			}
			byte[] result = new byte[elements.length];
			for (int i = 0; i < elements.length; i++) {
				result[i] = (byte) elements[i];
			}
			return result;
		}
		byte[] toSequence() throws IOException {
			DerEncoder sequenceEncoder = new DerEncoder();
			sequenceEncoder.sequence(toByteArray());
			return sequenceEncoder.toByteArray();
		}
		byte[] toByteArray() {
			return this.stream.toByteArray();
		}
	}
	/**
	 * An ASN.1 DER encoded element.
	 */
	static final class DerElement {
		private final ValueType valueType;
		private final long tagType;
		private final ByteBuffer contents;
		private DerElement(ByteBuffer bytes) {
			byte b = bytes.get();
			this.valueType = ((b & 0x20) == 0) ? ValueType.PRIMITIVE : ValueType.ENCODED;
			this.tagType = decodeTagType(b, bytes);
			int length = decodeLength(bytes);
			bytes.limit(bytes.position() + length);
			this.contents = bytes.slice();
			bytes.limit(bytes.capacity());
			bytes.position(bytes.position() + length);
		}
		private long decodeTagType(byte b, ByteBuffer bytes) {
			long tagType = (b & 0x1F);
			if (tagType != 0x1F) {
				return tagType;
			}
			tagType = 0;
			b = bytes.get();
			while ((b & 0x80) != 0) {
				tagType <<= 7;
				tagType = tagType | (b & 0x7F);
				b = bytes.get();
			}
			return tagType;
		}
		private int decodeLength(ByteBuffer bytes) {
			byte b = bytes.get();
			if ((b & 0x80) == 0) {
				return b & 0x7F;
			}
			int numberOfLengthBytes = (b & 0x7F);
			Assert.state(numberOfLengthBytes != 0, 'Infinite length encoding is not supported');
			Assert.state(numberOfLengthBytes != 0x7F, 'Reserved length encoding is not supported');
			Assert.state(numberOfLengthBytes <= 4, 'Length overflow');
			int length = 0;
			for (int i = 0; i < numberOfLengthBytes; i++) {
				length <<= 8;
				length |= (bytes.get() & 0xFF);
			}
			return length;
		}
		boolean isType(ValueType valueType) {
			return this.valueType == valueType;
		}
		boolean isType(ValueType valueType, TagType tagType) {
			return this.valueType == valueType && this.tagType == tagType.getNumber();
		}
		ByteBuffer getContents() {
			return this.contents;
		}
		static DerElement of(byte[] bytes) {
			return of(ByteBuffer.wrap(bytes));
		}
		static DerElement of(ByteBuffer bytes) {
			return (bytes.remaining() > 0) ? new DerElement(bytes) : null;
		}
		enum ValueType {
			PRIMITIVE, ENCODED
		}
		enum TagType {
			INTEGER(0x02), OCTET_STRING(0x04), OBJECT_IDENTIFIER(0x06), SEQUENCE(0x10);
			private final int number;
			TagType(int number) {
				this.number = number;
			}
			int getNumber() {
				return this.number;
			}
		}
	}
	/**
	 * Decryptor for PKCS8 encoded private keys.
	 */
	static class Pkcs8PrivateKeyDecryptor {
		public static final String PBES2_ALGORITHM = 'PBES2';
		static PKCS8EncodedKeySpec decrypt(byte[] bytes, String password) {
			Assert.notNull(password, 'Password is required for an encrypted private key');
			try {
				EncryptedPrivateKeyInfo keyInfo = new EncryptedPrivateKeyInfo(bytes);
				AlgorithmParameters algorithmParameters = keyInfo.getAlgParameters();
				String encryptionAlgorithm = getEncryptionAlgorithm(algorithmParameters, keyInfo.getAlgName());
				SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(encryptionAlgorithm);
				SecretKey key = keyFactory.generateSecret(new PBEKeySpec(password.toCharArray()));
				Cipher cipher = Cipher.getInstance(encryptionAlgorithm);
				cipher.init(Cipher.DECRYPT_MODE, key, algorithmParameters);
				return keyInfo.getKeySpec(cipher);
			}
			catch (IOException | GeneralSecurityException ex) {
				throw new IllegalArgumentException('Error decrypting private key', ex);
			}
		}
		private static String getEncryptionAlgorithm(AlgorithmParameters algParameters, String algName) {
			if (algParameters != null && PBES2_ALGORITHM.equals(algName)) {
				return algParameters.toString();
			}
			return algName;
		}
	}
	/**
	 * ANS.1 encoded object identifier.
	 */
	static final class EncodedOid {
		static final EncodedOid OID_1_2_840_10040_4_1 = EncodedOid.of('2a8648ce380401');
		static final EncodedOid OID_1_2_840_113549_1_1_1 = EncodedOid.of('2A864886F70D010101');
		static final EncodedOid OID_1_2_840_113549_1_1_10 = EncodedOid.of('2a864886f70d01010a');
		static final EncodedOid OID_1_3_101_110 = EncodedOid.of('2b656e');
		static final EncodedOid OID_1_3_101_111 = EncodedOid.of('2b656f');
		static final EncodedOid OID_1_3_101_112 = EncodedOid.of('2b6570');
		static final EncodedOid OID_1_3_101_113 = EncodedOid.of('2b6571');
		static final EncodedOid OID_1_2_840_10045_2_1 = EncodedOid.of('2a8648ce3d0201');
		static final EncodedOid OID_1_3_132_0_34 = EncodedOid.of('2b81040022');
		private final byte[] value;
		private EncodedOid(byte[] value) {
			this.value = value;
		}
		byte[] toByteArray() {
			return this.value.clone();
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return Arrays.equals(this.value, ((EncodedOid) obj).value);
		}
		@Override
		public int hashCode() {
			return Arrays.hashCode(this.value);
		}
		static EncodedOid of(String hexString) {
			return of(HexFormat.of().parseHex(hexString));
		}
		static EncodedOid of(DerElement derElement) {
			return of(derElement.getContents());
		}
		static EncodedOid of(ByteBuffer byteBuffer) {
			return of(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
		}
		static EncodedOid of(byte[] bytes) {
			return of(bytes, 0, bytes.length);
		}
		static EncodedOid of(byte[] bytes, int off, int len) {
			byte[] value = new byte[len];
			System.arraycopy(bytes, off, value, 0, len);
			return new EncodedOid(value);
		}
	}
}
/*
/**
package org.springframework.boot.ssl.pem;
/*
package org.springframework.boot.ssl.pem;
/**
public final class PemContent {
	private static final Pattern PEM_HEADER = Pattern.compile('-+BEGIN\\s+[^-]*-+', Pattern.CASE_INSENSITIVE);
	private static final Pattern PEM_FOOTER = Pattern.compile('-+END\\s+[^-]*-+', Pattern.CASE_INSENSITIVE);
	private final String text;
	private PemContent(String text) {
		this.text = text.lines().map(String::trim).collect(Collectors.joining('\n'));
	}
	/**
	 * Parse and return all {@link X509Certificate certificates} from the PEM content.
	 * Most PEM files either contain a single certificate or a certificate chain.
	 * @return the certificates
	 * @throws IllegalStateException if no certificates could be loaded
	 */
	public List<X509Certificate> getCertificates() {
		return PemCertificateParser.parse(this.text);
	}
	/**
	 * Parse and return the {@link PrivateKey private keys} from the PEM content.
	 * @return the private keys
	 * @throws IllegalStateException if no private key could be loaded
	 */
	public PrivateKey getPrivateKey() {
		return getPrivateKey(null);
	}
	/**
	 * Parse and return the {@link PrivateKey private keys} from the PEM content or
	 * {@code null} if there is no private key.
	 * @param password the password to decrypt the private keys or {@code null}
	 * @return the private keys
	 */
	public PrivateKey getPrivateKey(String password) {
		return PemPrivateKeyParser.parse(this.text, password);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return Objects.equals(this.text, ((PemContent) obj).text);
	}
	@Override
	public int hashCode() {
		return Objects.hash(this.text);
	}
	@Override
	public String toString() {
		return this.text;
	}
	/**
	 * Load {@link PemContent} from the given content (either the PEM content itself or a
	 * reference to the resource to load).
	 * @param content the content to load
	 * @param resourceLoader the resource loader used to load content
	 * @return a new {@link PemContent} instance
	 * @throws IOException on IO error
	 */
	static PemContent load(String content, ResourceLoader resourceLoader) throws IOException {
		if (content == null) {
			return null;
		}
		if (isPresentInText(content)) {
			return new PemContent(content);
		}
		try {
			return load(resourceLoader.getResource(content).getInputStream());
		}
		catch (IOException | UncheckedIOException ex) {
			throw new IOException('Error reading certificate or key from file "%s"'.formatted(content), ex);
		}
	}
	/**
	 * Load {@link PemContent} from the given {@link Path}.
	 * @param path a path to load the content from
	 * @return the loaded PEM content
	 * @throws IOException on IO error
	 */
	public static PemContent load(Path path) throws IOException {
		Assert.notNull(path, 'Path must not be null');
		try (InputStream in = Files.newInputStream(path, StandardOpenOption.READ)) {
			return load(in);
		}
	}
	/**
	 * Load {@link PemContent} from the given {@link InputStream}.
	 * @param in an input stream to load the content from
	 * @return the loaded PEM content
	 * @throws IOException on IO error
	 */
	public static PemContent load(InputStream in) throws IOException {
		return of(StreamUtils.copyToString(in, StandardCharsets.UTF_8));
	}
	/**
	 * Return a new {@link PemContent} instance containing the given text.
	 * @param text the text containing PEM encoded content
	 * @return a new {@link PemContent} instance
	 */
	public static PemContent of(String text) {
		return (text != null) ? new PemContent(text) : null;
	}
	/**
	 * Return if PEM content is present in the given text.
	 * @param text the text to check
	 * @return if the text includes PEM encoded content.
	 */
	public static boolean isPresentInText(String text) {
		return text != null && PEM_HEADER.matcher(text).find() && PEM_FOOTER.matcher(text).find();
	}
}
/*
package org.springframework.boot.ssl;
/**
public class NoSuchSslBundleException extends RuntimeException {
	private final String bundleName;
	/**
	 * Create a new {@code SslBundleNotFoundException} instance.
	 * @param bundleName the name of the bundle that could not be found
	 * @param message the exception message
	 */
	public NoSuchSslBundleException(String bundleName, String message) {
		this(bundleName, message, null);
	}
	/**
	 * Create a new {@code SslBundleNotFoundException} instance.
	 * @param bundleName the name of the bundle that could not be found
	 * @param message the exception message
	 * @param cause the exception cause
	 */
	public NoSuchSslBundleException(String bundleName, String message, Throwable cause) {
		super(message, cause);
		this.bundleName = bundleName;
	}
	/**
	 * Return the name of the bundle that was not found.
	 * @return the bundle name
	 */
	public String getBundleName() {
		return this.bundleName;
	}
}
/*
package org.springframework.boot;
/**
class BeanDefinitionLoader {
	private static final Pattern GROOVY_CLOSURE_PATTERN = Pattern.compile('.*\\$_.*closure.*');
	private final Object[] sources;
	private final AnnotatedBeanDefinitionReader annotatedReader;
	private final AbstractBeanDefinitionReader xmlReader;
	private final BeanDefinitionReader groovyReader;
	private final ClassPathBeanDefinitionScanner scanner;
	private ResourceLoader resourceLoader;
	/**
	 * Create a new {@link BeanDefinitionLoader} that will load beans into the specified
	 * {@link BeanDefinitionRegistry}.
	 * @param registry the bean definition registry that will contain the loaded beans
	 * @param sources the bean sources
	 */
	BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {
		Assert.notNull(registry, 'Registry must not be null');
		Assert.notEmpty(sources, 'Sources must not be empty');
		this.sources = sources;
		this.annotatedReader = new AnnotatedBeanDefinitionReader(registry);
		this.xmlReader = new XmlBeanDefinitionReader(registry);
		this.groovyReader = (isGroovyPresent() ? new GroovyBeanDefinitionReader(registry) : null);
		this.scanner = new ClassPathBeanDefinitionScanner(registry);
		this.scanner.addExcludeFilter(new ClassExcludeFilter(sources));
	}
	/**
	 * Set the bean name generator to be used by the underlying readers and scanner.
	 * @param beanNameGenerator the bean name generator
	 */
	void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
		this.annotatedReader.setBeanNameGenerator(beanNameGenerator);
		this.scanner.setBeanNameGenerator(beanNameGenerator);
		this.xmlReader.setBeanNameGenerator(beanNameGenerator);
	}
	/**
	 * Set the resource loader to be used by the underlying readers and scanner.
	 * @param resourceLoader the resource loader
	 */
	void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
		this.scanner.setResourceLoader(resourceLoader);
		this.xmlReader.setResourceLoader(resourceLoader);
	}
	/**
	 * Set the environment to be used by the underlying readers and scanner.
	 * @param environment the environment
	 */
	void setEnvironment(ConfigurableEnvironment environment) {
		this.annotatedReader.setEnvironment(environment);
		this.scanner.setEnvironment(environment);
		this.xmlReader.setEnvironment(environment);
	}
	/**
	 * Load the sources into the reader.
	 */
	void load() {
		for (Object source : this.sources) {
			load(source);
		}
	}
	private void load(Object source) {
		Assert.notNull(source, 'Source must not be null');
		if (source instanceof Class<?> type) {
			load(type);
			return;
		}
		if (source instanceof Resource resource) {
			load(resource);
			return;
		}
		if (source instanceof Package pack) {
			load(pack);
			return;
		}
		if (source instanceof CharSequence sequence) {
			load(sequence);
			return;
		}
		throw new IllegalArgumentException('Invalid source type ' + source.getClass());
	}
	private void load(Class<?> source) {
		if (isGroovyPresent() && GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {
			// Any GroovyLoaders added in beans{} DSL can contribute beans here
			GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);
			((GroovyBeanDefinitionReader) this.groovyReader).beans(loader.getBeans());
		}
		if (isEligible(source)) {
			this.annotatedReader.register(source);
		}
	}
	private void load(Resource source) {
		if (source.getFilename().endsWith('.groovy')) {
			if (this.groovyReader == null) {
				throw new BeanDefinitionStoreException('Cannot load Groovy beans without Groovy on classpath');
			}
			this.groovyReader.loadBeanDefinitions(source);
		}
		else {
			this.xmlReader.loadBeanDefinitions(source);
		}
	}
	private void load(Package source) {
		this.scanner.scan(source.getName());
	}
	private void load(CharSequence source) {
		String resolvedSource = this.scanner.getEnvironment().resolvePlaceholders(source.toString());
		// Attempt as a Class
		try {
			load(ClassUtils.forName(resolvedSource, null));
			return;
		}
		catch (IllegalArgumentException | ClassNotFoundException ex) {
			// swallow exception and continue
		}
		// Attempt as Resources
		if (loadAsResources(resolvedSource)) {
			return;
		}
		// Attempt as package
		Package packageResource = findPackage(resolvedSource);
		if (packageResource != null) {
			load(packageResource);
			return;
		}
		throw new IllegalArgumentException('Invalid source "' + resolvedSource + '"');
	}
	private boolean loadAsResources(String resolvedSource) {
		boolean foundCandidate = false;
		Resource[] resources = findResources(resolvedSource);
		for (Resource resource : resources) {
			if (isLoadCandidate(resource)) {
				foundCandidate = true;
				load(resource);
			}
		}
		return foundCandidate;
	}
	private boolean isGroovyPresent() {
		return ClassUtils.isPresent('groovy.lang.MetaClass', null);
	}
	private Resource[] findResources(String source) {
		ResourceLoader loader = (this.resourceLoader != null) ? this.resourceLoader
				: new PathMatchingResourcePatternResolver();
		try {
			if (loader instanceof ResourcePatternResolver resolver) {
				return resolver.getResources(source);
			}
			return new Resource[] { loader.getResource(source) };
		}
		catch (IOException ex) {
			throw new IllegalStateException('Error reading source "' + source + '"');
		}
	}
	private boolean isLoadCandidate(Resource resource) {
		if (resource == null || !resource.exists()) {
			return false;
		}
		if (resource instanceof ClassPathResource classPathResource) {
			// A simple package without a "." may accidentally get loaded as an XML
			// document if we"re not careful. The result of getInputStream() will be
			// a file list of the package content. We double-check here that it"s not
			// actually a package.
			String path = classPathResource.getPath();
			if (path.indexOf(".") == -1) {
				try {
					return getClass().getClassLoader().getDefinedPackage(path) == null;
				}
				catch (Exception ex) {
					// Ignore
				}
			}
		}
		return true;
	}
	private Package findPackage(CharSequence source) {
		Package pkg = getClass().getClassLoader().getDefinedPackage(source.toString());
		if (pkg != null) {
			return pkg;
		}
		try {
			// Attempt to find a class in this package
			ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(getClass().getClassLoader());
			Resource[] resources = resolver
				.getResources(ClassUtils.convertClassNameToResourcePath(source.toString()) + '/*.class');
			for (Resource resource : resources) {
				String className = StringUtils.stripFilenameExtension(resource.getFilename());
				load(Class.forName(source + '.' + className));
				break;
			}
		}
		catch (Exception ex) {
			// swallow exception and continue
		}
		return getClass().getClassLoader().getDefinedPackage(source.toString());
	}
	/**
	 * Check whether the bean is eligible for registration.
	 * @param type candidate bean type
	 * @return true if the given bean type is eligible for registration, i.e. not a groovy
	 * closure nor an anonymous class
	 */
	private boolean isEligible(Class<?> type) {
		return !(type.isAnonymousClass() || isGroovyClosure(type) || hasNoConstructors(type));
	}
	private boolean isGroovyClosure(Class<?> type) {
		return GROOVY_CLOSURE_PATTERN.matcher(type.getName()).matches();
	}
	private boolean hasNoConstructors(Class<?> type) {
		Constructor<?>[] constructors = type.getDeclaredConstructors();
		return ObjectUtils.isEmpty(constructors);
	}
	/**
	 * Simple {@link TypeFilter} used to ensure that specified {@link Class} sources are
	 * not accidentally re-added during scanning.
	 */
	private static class ClassExcludeFilter extends AbstractTypeHierarchyTraversingFilter {
		private final Set<String> classNames = new HashSet<>();
		ClassExcludeFilter(Object... sources) {
			super(false, false);
			for (Object source : sources) {
				if (source instanceof Class<?> classSource) {
					this.classNames.add(classSource.getName());
				}
			}
		}
		@Override
		protected boolean matchClassName(String className) {
			return this.classNames.contains(className);
		}
	}
	/**
	 * Source for Bean definitions defined in Groovy.
	 */
	@FunctionalInterface
	protected interface GroovyBeanDefinitionSource {
		Closure<?> getBeans();
	}
}
/*
package org.springframework.boot;
/**
class ApplicationEnvironment extends StandardEnvironment {
	@Override
	protected String doGetActiveProfilesProperty() {
		return null;
	}
	@Override
	protected String doGetDefaultProfilesProperty() {
		return null;
	}
	@Override
	protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {
		return ConfigurationPropertySources.createPropertyResolver(propertySources);
	}
}
/*
package org.springframework.boot.io;
/**
public class ApplicationResourceLoader extends DefaultResourceLoader {
	/**
	 * Create a new {@code ApplicationResourceLoader}.
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of {@link #get()}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public ApplicationResourceLoader() {
		this(null);
	}
	/**
	 * Create a new {@code ApplicationResourceLoader}.
	 * @param classLoader the {@link ClassLoader} to load class path resources with, or
	 * {@code null} for using the thread context class loader at the time of actual
	 * resource access
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of {@link #get(ClassLoader)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public ApplicationResourceLoader(ClassLoader classLoader) {
		super(classLoader);
		SpringFactoriesLoader loader = SpringFactoriesLoader.forDefaultResourceLocation(classLoader);
		getProtocolResolvers().addAll(loader.load(ProtocolResolver.class));
	}
	@Override
	protected Resource getResourceByPath(String path) {
		return new ApplicationResource(path);
	}
	/**
	 * Return a {@link ResourceLoader} supporting additional {@link ProtocolResolver
	 * ProtocolResolvers} registered in {@code spring.factories}. The factories file will
	 * be resolved using the default class loader at the time this call is made. Resources
	 * will be resolved using the default class loader at the time they are resolved.
	 * @return a {@link ResourceLoader} instance
	 * @since 3.4.0
	 */
	public static ResourceLoader get() {
		return get((ClassLoader) null);
	}
	/**
	 * Return a {@link ResourceLoader} supporting additional {@link ProtocolResolver
	 * ProtocolResolvers} registered in {@code spring.factories}. The factories files and
	 * resources will be resolved using the specified class loader.
	 * @param classLoader the class loader to use or {@code null} to use the default class
	 * loader
	 * @return a {@link ResourceLoader} instance
	 * @since 3.4.0
	 */
	public static ResourceLoader get(ClassLoader classLoader) {
		return get(classLoader, SpringFactoriesLoader.forDefaultResourceLocation(classLoader));
	}
	/**
	 * Return a {@link ResourceLoader} supporting additional {@link ProtocolResolver
	 * ProtocolResolvers} registered in {@code spring.factories}.
	 * @param classLoader the class loader to use or {@code null} to use the default class
	 * loader
	 * @param springFactoriesLoader the {@link SpringFactoriesLoader} used to load
	 * {@link ProtocolResolver ProtocolResolvers}
	 * @return a {@link ResourceLoader} instance
	 * @since 3.4.0
	 */
	public static ResourceLoader get(ClassLoader classLoader, SpringFactoriesLoader springFactoriesLoader) {
		return get(ApplicationFileSystemResourceLoader.get(classLoader), springFactoriesLoader);
	}
	/**
	 * Return a {@link ResourceLoader} delegating to the given resource loader and
	 * supporting additional {@link ProtocolResolver ProtocolResolvers} registered in
	 * {@code spring.factories}. The factories file will be resolved using the default
	 * class loader at the time this call is made.
	 * @param resourceLoader the delegate resource loader
	 * @return a {@link ResourceLoader} instance
	 * @since 3.4.0
	 */
	public static ResourceLoader get(ResourceLoader resourceLoader) {
		Assert.notNull(resourceLoader, '"resourceLoader" must not be null');
		return get(resourceLoader, SpringFactoriesLoader.forDefaultResourceLocation(resourceLoader.getClassLoader()));
	}
	/**
	 * Return a {@link ResourceLoader} delegating to the given resource loader and
	 * supporting additional {@link ProtocolResolver ProtocolResolvers} registered in
	 * {@code spring.factories}.
	 * @param resourceLoader the delegate resource loader
	 * @param springFactoriesLoader the {@link SpringFactoriesLoader} used to load
	 * {@link ProtocolResolver ProtocolResolvers}
	 * @return a {@link ResourceLoader} instance
	 * @since 3.4.0
	 */
	public static ResourceLoader get(ResourceLoader resourceLoader, SpringFactoriesLoader springFactoriesLoader) {
		Assert.notNull(resourceLoader, '"resourceLoader" must not be null');
		Assert.notNull(springFactoriesLoader, '"springFactoriesLoader" must not be null');
		return new ProtocolResolvingResourceLoader(resourceLoader, springFactoriesLoader.load(ProtocolResolver.class));
	}
	/**
	 * Internal {@link ResourceLoader} used to load {@link ApplicationResource}.
	 */
	private static final class ApplicationFileSystemResourceLoader extends DefaultResourceLoader {
		private static final ResourceLoader shared = new ApplicationFileSystemResourceLoader(null);
		private ApplicationFileSystemResourceLoader(ClassLoader classLoader) {
			super(classLoader);
		}
		@Override
		protected Resource getResourceByPath(String path) {
			return new ApplicationResource(path);
		}
		static ResourceLoader get(ClassLoader classLoader) {
			return (classLoader != null) ? new ApplicationFileSystemResourceLoader(classLoader)
					: ApplicationFileSystemResourceLoader.shared;
		}
	}
	/**
	 * An application {@link Resource}.
	 */
	private static final class ApplicationResource extends FileSystemResource implements ContextResource {
		ApplicationResource(String path) {
			super(path);
		}
		@Override
		public String getPathWithinContext() {
			return getPath();
		}
	}
	/**
	 * {@link ResourceLoader} decorator that adds support for additional
	 * {@link ProtocolResolver ProtocolResolvers}.
	 */
	private static class ProtocolResolvingResourceLoader implements ResourceLoader {
		private final ResourceLoader resourceLoader;
		private final List<ProtocolResolver> protocolResolvers;
		ProtocolResolvingResourceLoader(ResourceLoader resourceLoader, List<ProtocolResolver> protocolResolvers) {
			this.resourceLoader = resourceLoader;
			this.protocolResolvers = protocolResolvers;
		}
		@Override
		public Resource getResource(String location) {
			if (StringUtils.hasLength(location)) {
				for (ProtocolResolver protocolResolver : this.protocolResolvers) {
					Resource resource = protocolResolver.resolve(location, this);
					if (resource != null) {
						return resource;
					}
				}
			}
			return this.resourceLoader.getResource(location);
		}
		@Override
		public ClassLoader getClassLoader() {
			return this.resourceLoader.getClassLoader();
		}
	}
}
/*
package org.springframework.boot.io;
/**
class ProtocolResolverApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		SpringFactoriesLoader loader = SpringFactoriesLoader
			.forDefaultResourceLocation(applicationContext.getClassLoader());
		List<ProtocolResolver> protocolResolvers = loader.load(ProtocolResolver.class);
		protocolResolvers.forEach(applicationContext::addProtocolResolver);
	}
}
/*
package org.springframework.boot.io;
/**
class Base64ProtocolResolver implements ProtocolResolver {
	private static final String BASE64_PREFIX = 'base64:';
	@Override
	public Resource resolve(String location, ResourceLoader resourceLoader) {
		if (location.startsWith(BASE64_PREFIX)) {
			String value = location.substring(BASE64_PREFIX.length());
			return new ByteArrayResource(decode(value));
		}
		return null;
	}
	private static byte[] decode(String location) {
		return Base64.getDecoder().decode(location);
	}
}
/*
/**
package org.springframework.boot.io;
/*
package org.springframework.boot;
/**
public class ResourceBanner implements Banner {
	private static final Log logger = LogFactory.getLog(ResourceBanner.class);
	private final Resource resource;
	public ResourceBanner(Resource resource) {
		Assert.notNull(resource, 'Resource must not be null');
		Assert.isTrue(resource.exists(), 'Resource must exist');
		this.resource = resource;
	}
	@Override
	public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
		try {
			String banner = StreamUtils.copyToString(this.resource.getInputStream(),
					environment.getProperty('spring.banner.charset', Charset.class, StandardCharsets.UTF_8));
			for (PropertyResolver resolver : getPropertyResolvers(environment, sourceClass)) {
				banner = resolver.resolvePlaceholders(banner);
			}
			out.println(banner);
		}
		catch (Exception ex) {
			logger.warn(LogMessage.format('Banner not printable: %s (%s: "%s")', this.resource, ex.getClass(),
					ex.getMessage()), ex);
		}
	}
	/**
	 * Return a mutable list of the {@link PropertyResolver} instances that will be used
	 * to resolve placeholders.
	 * @param environment the environment
	 * @param sourceClass the source class
	 * @return a mutable list of property resolvers
	 */
	protected List<PropertyResolver> getPropertyResolvers(Environment environment, Class<?> sourceClass) {
		MutablePropertySources sources = new MutablePropertySources();
		if (environment instanceof ConfigurableEnvironment configurableEnvironment) {
			configurableEnvironment.getPropertySources().forEach(sources::addLast);
		}
		sources.addLast(getTitleSource(sourceClass));
		sources.addLast(getAnsiSource());
		sources.addLast(getVersionSource(sourceClass, environment));
		List<PropertyResolver> resolvers = new ArrayList<>();
		resolvers.add(new PropertySourcesPropertyResolver(sources));
		return resolvers;
	}
	private MapPropertySource getTitleSource(Class<?> sourceClass) {
		String applicationTitle = getApplicationTitle(sourceClass);
		Map<String, Object> titleMap = Collections.singletonMap('application.title',
				(applicationTitle != null) ? applicationTitle : '');
		return new MapPropertySource('title', titleMap);
	}
	/**
	 * Return the application title that should be used for the source class. By default
	 * will use {@link Package#getImplementationTitle()}.
	 * @param sourceClass the source class
	 * @return the application title
	 */
	protected String getApplicationTitle(Class<?> sourceClass) {
		Package sourcePackage = (sourceClass != null) ? sourceClass.getPackage() : null;
		return (sourcePackage != null) ? sourcePackage.getImplementationTitle() : null;
	}
	private AnsiPropertySource getAnsiSource() {
		return new AnsiPropertySource('ansi', true);
	}
	private MapPropertySource getVersionSource(Class<?> sourceClass, Environment environment) {
		return new MapPropertySource('version', getVersionsMap(sourceClass, environment));
	}
	private Map<String, Object> getVersionsMap(Class<?> sourceClass, Environment environment) {
		String appVersion = getApplicationVersion(sourceClass);
		if (appVersion == null) {
			appVersion = getApplicationVersion(environment);
		}
		String bootVersion = getBootVersion();
		Map<String, Object> versions = new HashMap<>();
		versions.put('application.version', getVersionString(appVersion, false));
		versions.put('spring-boot.version', getVersionString(bootVersion, false));
		versions.put('application.formatted-version', getVersionString(appVersion, true));
		versions.put('spring-boot.formatted-version', getVersionString(bootVersion, true));
		return versions;
	}
	/**
	 * Returns the application version.
	 * @param sourceClass the source class
	 * @return the application version or {@code null} if unknown
	 * @deprecated since 3.4.0 for removal in 3.6.0
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	protected String getApplicationVersion(Class<?> sourceClass) {
		return null;
	}
	private String getApplicationVersion(Environment environment) {
		return environment.getProperty('spring.application.version');
	}
	protected String getBootVersion() {
		return SpringBootVersion.getVersion();
	}
	private String getVersionString(String version, boolean format) {
		if (version == null) {
			return '';
		}
		return format ? ' (v' + version + ')' : version;
	}
}
/*
package org.springframework.boot;
/**
class SpringApplicationShutdownHook implements Runnable {
	private static final int SLEEP = 50;
	private static final long TIMEOUT = TimeUnit.MINUTES.toMillis(10);
	private static final Log logger = LogFactory.getLog(SpringApplicationShutdownHook.class);
	private final Handlers handlers = new Handlers();
	private final Set<ConfigurableApplicationContext> contexts = new LinkedHashSet<>();
	private final Set<ConfigurableApplicationContext> closedContexts = Collections.newSetFromMap(new WeakHashMap<>());
	private final ApplicationContextClosedListener contextCloseListener = new ApplicationContextClosedListener();
	private final AtomicBoolean shutdownHookAdded = new AtomicBoolean();
	private volatile boolean shutdownHookAdditionEnabled = false;
	private boolean inProgress;
	SpringApplicationShutdownHandlers getHandlers() {
		return this.handlers;
	}
	void enableShutdownHookAddition() {
		this.shutdownHookAdditionEnabled = true;
	}
	void registerApplicationContext(ConfigurableApplicationContext context) {
		addRuntimeShutdownHookIfNecessary();
		synchronized (SpringApplicationShutdownHook.class) {
			assertNotInProgress();
			context.addApplicationListener(this.contextCloseListener);
			this.contexts.add(context);
		}
	}
	private void addRuntimeShutdownHookIfNecessary() {
		if (this.shutdownHookAdditionEnabled && this.shutdownHookAdded.compareAndSet(false, true)) {
			addRuntimeShutdownHook();
		}
	}
	void addRuntimeShutdownHook() {
		Runtime.getRuntime().addShutdownHook(new Thread(this, 'SpringApplicationShutdownHook'));
	}
	void deregisterFailedApplicationContext(ConfigurableApplicationContext applicationContext) {
		synchronized (SpringApplicationShutdownHook.class) {
			Assert.state(!applicationContext.isActive(), 'Cannot unregister active application context');
			SpringApplicationShutdownHook.this.contexts.remove(applicationContext);
		}
	}
	@Override
	public void run() {
		Set<ConfigurableApplicationContext> contexts;
		Set<ConfigurableApplicationContext> closedContexts;
		Set<Runnable> actions;
		synchronized (SpringApplicationShutdownHook.class) {
			this.inProgress = true;
			contexts = new LinkedHashSet<>(this.contexts);
			closedContexts = new LinkedHashSet<>(this.closedContexts);
			actions = new LinkedHashSet<>(this.handlers.getActions());
		}
		contexts.forEach(this::closeAndWait);
		closedContexts.forEach(this::closeAndWait);
		actions.forEach(Runnable::run);
	}
	boolean isApplicationContextRegistered(ConfigurableApplicationContext context) {
		synchronized (SpringApplicationShutdownHook.class) {
			return this.contexts.contains(context);
		}
	}
	void reset() {
		synchronized (SpringApplicationShutdownHook.class) {
			this.contexts.clear();
			this.closedContexts.clear();
			this.handlers.getActions().clear();
			this.inProgress = false;
		}
	}
	/**
	 * Call {@link ConfigurableApplicationContext#close()} and wait until the context
	 * becomes inactive. We can"t assume that just because the close method returns that
	 * the context is actually inactive. It could be that another thread is still in the
	 * process of disposing beans.
	 * @param context the context to clean
	 */
	private void closeAndWait(ConfigurableApplicationContext context) {
		if (!context.isActive()) {
			return;
		}
		context.close();
		try {
			int waited = 0;
			while (context.isActive()) {
				if (waited > TIMEOUT) {
					throw new TimeoutException();
				}
				Thread.sleep(SLEEP);
				waited += SLEEP;
			}
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			logger.warn('Interrupted waiting for application context ' + context + ' to become inactive');
		}
		catch (TimeoutException ex) {
			logger.warn('Timed out waiting for application context ' + context + ' to become inactive', ex);
		}
	}
	private void assertNotInProgress() {
		Assert.state(!SpringApplicationShutdownHook.this.inProgress, 'Shutdown in progress');
	}
	/**
	 * The handler actions for this shutdown hook.
	 */
	private final class Handlers implements SpringApplicationShutdownHandlers, Runnable {
		private final Set<Runnable> actions = Collections.newSetFromMap(new IdentityHashMap<>());
		@Override
		public void add(Runnable action) {
			Assert.notNull(action, 'Action must not be null');
			addRuntimeShutdownHookIfNecessary();
			synchronized (SpringApplicationShutdownHook.class) {
				assertNotInProgress();
				this.actions.add(action);
			}
		}
		@Override
		public void remove(Runnable action) {
			Assert.notNull(action, 'Action must not be null');
			synchronized (SpringApplicationShutdownHook.class) {
				assertNotInProgress();
				this.actions.remove(action);
			}
		}
		Set<Runnable> getActions() {
			return this.actions;
		}
		@Override
		public void run() {
			SpringApplicationShutdownHook.this.run();
			SpringApplicationShutdownHook.this.reset();
		}
	}
	/**
	 * {@link ApplicationListener} to track closed contexts.
	 */
	private final class ApplicationContextClosedListener implements ApplicationListener<ContextClosedEvent> {
		@Override
		public void onApplicationEvent(ContextClosedEvent event) {
			// The ContextClosedEvent is fired at the start of a call to {@code close()}
			// and if that happens in a different thread then the context may still be
			// active. Rather than just removing the context, we add it to a {@code
			// closedContexts} set. This is weak set so that the context can be GC"d once
			// the {@code close()} method returns.
			synchronized (SpringApplicationShutdownHook.class) {
				ApplicationContext applicationContext = event.getApplicationContext();
				SpringApplicationShutdownHook.this.contexts.remove(applicationContext);
				SpringApplicationShutdownHook.this.closedContexts
					.add((ConfigurableApplicationContext) applicationContext);
			}
		}
	}
}
/*
package org.springframework.boot.convert;
/**
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface PeriodFormat {
	/**
	 * The {@link Period} format style.
	 * @return the period format style.
	 */
	PeriodStyle value();
}
/*
package org.springframework.boot.convert;
/**
@SuppressWarnings('rawtypes')
abstract class LenientObjectToEnumConverterFactory<T> implements ConverterFactory<T, Enum<?>> {
	private static final Map<String, List<String>> ALIASES;
	static {
		MultiValueMap<String, String> aliases = new LinkedMultiValueMap<>();
		aliases.add('true', 'on');
		aliases.add('false', 'off');
		ALIASES = Collections.unmodifiableMap(aliases);
	}
	@Override
	@SuppressWarnings('unchecked')
	public <E extends Enum<?>> Converter<T, E> getConverter(Class<E> targetType) {
		Class<?> enumType = targetType;
		while (enumType != null && !enumType.isEnum()) {
			enumType = enumType.getSuperclass();
		}
		Assert.notNull(enumType, () -> 'The target type ' + targetType.getName() + ' does not refer to an enum');
		return new LenientToEnumConverter<>((Class<E>) enumType);
	}
	@SuppressWarnings('unchecked')
	private class LenientToEnumConverter<E extends Enum> implements Converter<T, E> {
		private final Class<E> enumType;
		LenientToEnumConverter(Class<E> enumType) {
			this.enumType = enumType;
		}
		@Override
		public E convert(T source) {
			String value = source.toString().trim();
			if (value.isEmpty()) {
				return null;
			}
			try {
				return (E) Enum.valueOf(this.enumType, value);
			}
			catch (Exception ex) {
				return findEnum(value);
			}
		}
		private E findEnum(String value) {
			String name = getCanonicalName(value);
			List<String> aliases = ALIASES.getOrDefault(name, Collections.emptyList());
			for (E candidate : (Set<E>) EnumSet.allOf(this.enumType)) {
				String candidateName = getCanonicalName(candidate.name());
				if (name.equals(candidateName) || aliases.contains(candidateName)) {
					return candidate;
				}
			}
			throw new IllegalArgumentException('No enum constant ' + this.enumType.getCanonicalName() + '.' + value);
		}
		private String getCanonicalName(String name) {
			StringBuilder canonicalName = new StringBuilder(name.length());
			name.chars()
				.filter(Character::isLetterOrDigit)
				.map(Character::toLowerCase)
				.forEach((c) -> canonicalName.append((char) c));
			return canonicalName.toString();
		}
	}
}
/*
package org.springframework.boot.convert;
/**
public enum DurationStyle {
	/**
	 * Simple formatting, for example "1s".
	 */
	SIMPLE('^([+-]?\\d+)([a-zA-Z]{0,2})$') {
		@Override
		public Duration parse(String value, ChronoUnit unit) {
			try {
				Matcher matcher = matcher(value);
				Assert.state(matcher.matches(), 'Does not match simple duration pattern');
				String suffix = matcher.group(2);
				return (StringUtils.hasLength(suffix) ? Unit.fromSuffix(suffix) : Unit.fromChronoUnit(unit))
					.parse(matcher.group(1));
			}
			catch (Exception ex) {
				throw new IllegalArgumentException('"' + value + '" is not a valid simple duration', ex);
			}
		}
		@Override
		public String print(Duration value, ChronoUnit unit) {
			return Unit.fromChronoUnit(unit).print(value);
		}
	},
	/**
	 * ISO-8601 formatting.
	 */
	ISO8601('^[+-]?[pP].*$') {
		@Override
		public Duration parse(String value, ChronoUnit unit) {
			try {
				return Duration.parse(value);
			}
			catch (Exception ex) {
				throw new IllegalArgumentException('"' + value + '" is not a valid ISO-8601 duration', ex);
			}
		}
		@Override
		public String print(Duration value, ChronoUnit unit) {
			return value.toString();
		}
	};
	private final Pattern pattern;
	DurationStyle(String pattern) {
		this.pattern = Pattern.compile(pattern);
	}
	protected final boolean matches(String value) {
		return this.pattern.matcher(value).matches();
	}
	protected final Matcher matcher(String value) {
		return this.pattern.matcher(value);
	}
	/**
	 * Parse the given value to a duration.
	 * @param value the value to parse
	 * @return a duration
	 */
	public Duration parse(String value) {
		return parse(value, null);
	}
	/**
	 * Parse the given value to a duration.
	 * @param value the value to parse
	 * @param unit the duration unit to use if the value doesn"t specify one ({@code null}
	 * will default to ms)
	 * @return a duration
	 */
	public abstract Duration parse(String value, ChronoUnit unit);
	/**
	 * Print the specified duration.
	 * @param value the value to print
	 * @return the printed result
	 */
	public String print(Duration value) {
		return print(value, null);
	}
	/**
	 * Print the specified duration using the given unit.
	 * @param value the value to print
	 * @param unit the value to use for printing
	 * @return the printed result
	 */
	public abstract String print(Duration value, ChronoUnit unit);
	/**
	 * Detect the style then parse the value to return a duration.
	 * @param value the value to parse
	 * @return the parsed duration
	 * @throws IllegalArgumentException if the value is not a known style or cannot be
	 * parsed
	 */
	public static Duration detectAndParse(String value) {
		return detectAndParse(value, null);
	}
	/**
	 * Detect the style then parse the value to return a duration.
	 * @param value the value to parse
	 * @param unit the duration unit to use if the value doesn"t specify one ({@code null}
	 * will default to ms)
	 * @return the parsed duration
	 * @throws IllegalArgumentException if the value is not a known style or cannot be
	 * parsed
	 */
	public static Duration detectAndParse(String value, ChronoUnit unit) {
		return detect(value).parse(value, unit);
	}
	/**
	 * Detect the style from the given source value.
	 * @param value the source value
	 * @return the duration style
	 * @throws IllegalArgumentException if the value is not a known style
	 */
	public static DurationStyle detect(String value) {
		Assert.notNull(value, 'Value must not be null');
		for (DurationStyle candidate : values()) {
			if (candidate.matches(value)) {
				return candidate;
			}
		}
		throw new IllegalArgumentException('"' + value + '" is not a valid duration');
	}
	/**
	 * Units that we support.
	 */
	enum Unit {
		/**
		 * Nanoseconds.
		 */
		NANOS(ChronoUnit.NANOS, 'ns', Duration::toNanos),
		/**
		 * Microseconds.
		 */
		MICROS(ChronoUnit.MICROS, 'us', (duration) -> duration.toNanos() / 1000L),
		/**
		 * Milliseconds.
		 */
		MILLIS(ChronoUnit.MILLIS, 'ms', Duration::toMillis),
		/**
		 * Seconds.
		 */
		SECONDS(ChronoUnit.SECONDS, 's', Duration::getSeconds),
		/**
		 * Minutes.
		 */
		MINUTES(ChronoUnit.MINUTES, 'm', Duration::toMinutes),
		/**
		 * Hours.
		 */
		HOURS(ChronoUnit.HOURS, 'h', Duration::toHours),
		/**
		 * Days.
		 */
		DAYS(ChronoUnit.DAYS, 'd', Duration::toDays);
		private final ChronoUnit chronoUnit;
		private final String suffix;
		private final Function<Duration, Long> longValue;
		Unit(ChronoUnit chronoUnit, String suffix, Function<Duration, Long> toUnit) {
			this.chronoUnit = chronoUnit;
			this.suffix = suffix;
			this.longValue = toUnit;
		}
		public Duration parse(String value) {
			return Duration.of(Long.parseLong(value), this.chronoUnit);
		}
		public String print(Duration value) {
			return longValue(value) + this.suffix;
		}
		public long longValue(Duration value) {
			return this.longValue.apply(value);
		}
		public static Unit fromChronoUnit(ChronoUnit chronoUnit) {
			if (chronoUnit == null) {
				return Unit.MILLIS;
			}
			for (Unit candidate : values()) {
				if (candidate.chronoUnit == chronoUnit) {
					return candidate;
				}
			}
			throw new IllegalArgumentException('Unknown unit ' + chronoUnit);
		}
		public static Unit fromSuffix(String suffix) {
			for (Unit candidate : values()) {
				if (candidate.suffix.equalsIgnoreCase(suffix)) {
					return candidate;
				}
			}
			throw new IllegalArgumentException('Unknown unit "' + suffix + '"');
		}
	}
}
/*
package org.springframework.boot.convert;
/**
final class PeriodToStringConverter implements GenericConverter {
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Period.class, String.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (ObjectUtils.isEmpty(source)) {
			return null;
		}
		return convert((Period) source, getPeriodStyle(sourceType), getPeriodUnit(sourceType));
	}
	private PeriodStyle getPeriodStyle(TypeDescriptor sourceType) {
		PeriodFormat annotation = sourceType.getAnnotation(PeriodFormat.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private String convert(Period source, PeriodStyle style, ChronoUnit unit) {
		style = (style != null) ? style : PeriodStyle.ISO8601;
		return style.print(source, unit);
	}
	private ChronoUnit getPeriodUnit(TypeDescriptor sourceType) {
		PeriodUnit annotation = sourceType.getAnnotation(PeriodUnit.class);
		return (annotation != null) ? annotation.value() : null;
	}
}
/*
package org.springframework.boot.convert;
/**
public enum PeriodStyle {
	/**
	 * Simple formatting, for example "1d".
	 */
	SIMPLE('^' + '(?:([-+]?[0-9]+)Y)?' + '(?:([-+]?[0-9]+)M)?' + '(?:([-+]?[0-9]+)W)?' + '(?:([-+]?[0-9]+)D)?' + '$',
			Pattern.CASE_INSENSITIVE) {
		@Override
		public Period parse(String value, ChronoUnit unit) {
			try {
				if (NUMERIC.matcher(value).matches()) {
					return Unit.fromChronoUnit(unit).parse(value);
				}
				Matcher matcher = matcher(value);
				Assert.state(matcher.matches(), 'Does not match simple period pattern');
				Assert.isTrue(hasAtLeastOneGroupValue(matcher), () -> '"' + value + '" is not a valid simple period');
				int years = parseInt(matcher, 1);
				int months = parseInt(matcher, 2);
				int weeks = parseInt(matcher, 3);
				int days = parseInt(matcher, 4);
				return Period.of(years, months, Math.addExact(Math.multiplyExact(weeks, 7), days));
			}
			catch (Exception ex) {
				throw new IllegalArgumentException('"' + value + '" is not a valid simple period', ex);
			}
		}
		boolean hasAtLeastOneGroupValue(Matcher matcher) {
			for (int i = 0; i < matcher.groupCount(); i++) {
				if (matcher.group(i + 1) != null) {
					return true;
				}
			}
			return false;
		}
		private int parseInt(Matcher matcher, int group) {
			String value = matcher.group(group);
			return (value != null) ? Integer.parseInt(value) : 0;
		}
		@Override
		protected boolean matches(String value) {
			return NUMERIC.matcher(value).matches() || matcher(value).matches();
		}
		@Override
		public String print(Period value, ChronoUnit unit) {
			if (value.isZero()) {
				return Unit.fromChronoUnit(unit).print(value);
			}
			StringBuilder result = new StringBuilder();
			append(result, value, Unit.YEARS);
			append(result, value, Unit.MONTHS);
			append(result, value, Unit.DAYS);
			return result.toString();
		}
		private void append(StringBuilder result, Period value, Unit unit) {
			if (!unit.isZero(value)) {
				result.append(unit.print(value));
			}
		}
	},
	/**
	 * ISO-8601 formatting.
	 */
	ISO8601('^[+-]?P.*$', Pattern.CASE_INSENSITIVE) {
		@Override
		public Period parse(String value, ChronoUnit unit) {
			try {
				return Period.parse(value);
			}
			catch (Exception ex) {
				throw new IllegalArgumentException('"' + value + '" is not a valid ISO-8601 period', ex);
			}
		}
		@Override
		public String print(Period value, ChronoUnit unit) {
			return value.toString();
		}
	};
	private static final Pattern NUMERIC = Pattern.compile('^[-+]?[0-9]+$');
	private final Pattern pattern;
	PeriodStyle(String pattern, int flags) {
		this.pattern = Pattern.compile(pattern, flags);
	}
	protected boolean matches(String value) {
		return this.pattern.matcher(value).matches();
	}
	protected final Matcher matcher(String value) {
		return this.pattern.matcher(value);
	}
	/**
	 * Parse the given value to a Period.
	 * @param value the value to parse
	 * @return a period
	 */
	public Period parse(String value) {
		return parse(value, null);
	}
	/**
	 * Parse the given value to a period.
	 * @param value the value to parse
	 * @param unit the period unit to use if the value doesn"t specify one ({@code null}
	 * will default to d)
	 * @return a period
	 */
	public abstract Period parse(String value, ChronoUnit unit);
	/**
	 * Print the specified period.
	 * @param value the value to print
	 * @return the printed result
	 */
	public String print(Period value) {
		return print(value, null);
	}
	/**
	 * Print the specified period using the given unit.
	 * @param value the value to print
	 * @param unit the value to use for printing
	 * @return the printed result
	 */
	public abstract String print(Period value, ChronoUnit unit);
	/**
	 * Detect the style then parse the value to return a period.
	 * @param value the value to parse
	 * @return the parsed period
	 * @throws IllegalArgumentException if the value is not a known style or cannot be
	 * parsed
	 */
	public static Period detectAndParse(String value) {
		return detectAndParse(value, null);
	}
	/**
	 * Detect the style then parse the value to return a period.
	 * @param value the value to parse
	 * @param unit the period unit to use if the value doesn"t specify one ({@code null}
	 * will default to ms)
	 * @return the parsed period
	 * @throws IllegalArgumentException if the value is not a known style or cannot be
	 * parsed
	 */
	public static Period detectAndParse(String value, ChronoUnit unit) {
		return detect(value).parse(value, unit);
	}
	/**
	 * Detect the style from the given source value.
	 * @param value the source value
	 * @return the period style
	 * @throws IllegalArgumentException if the value is not a known style
	 */
	public static PeriodStyle detect(String value) {
		Assert.notNull(value, 'Value must not be null');
		for (PeriodStyle candidate : values()) {
			if (candidate.matches(value)) {
				return candidate;
			}
		}
		throw new IllegalArgumentException('"' + value + '" is not a valid period');
	}
	private enum Unit {
		/**
		 * Days, represented by suffix {@code d}.
		 */
		DAYS(ChronoUnit.DAYS, 'd', Period::getDays, Period::ofDays),
		/**
		 * Weeks, represented by suffix {@code w}.
		 */
		WEEKS(ChronoUnit.WEEKS, 'w', null, Period::ofWeeks),
		/**
		 * Months, represented by suffix {@code m}.
		 */
		MONTHS(ChronoUnit.MONTHS, 'm', Period::getMonths, Period::ofMonths),
		/**
		 * Years, represented by suffix {@code y}.
		 */
		YEARS(ChronoUnit.YEARS, 'y', Period::getYears, Period::ofYears);
		private final ChronoUnit chronoUnit;
		private final String suffix;
		private final Function<Period, Integer> intValue;
		private final Function<Integer, Period> factory;
		Unit(ChronoUnit chronoUnit, String suffix, Function<Period, Integer> intValue,
				Function<Integer, Period> factory) {
			this.chronoUnit = chronoUnit;
			this.suffix = suffix;
			this.intValue = intValue;
			this.factory = factory;
		}
		private Period parse(String value) {
			return this.factory.apply(Integer.parseInt(value));
		}
		private String print(Period value) {
			return intValue(value) + this.suffix;
		}
		private boolean isZero(Period value) {
			return intValue(value) == 0;
		}
		private int intValue(Period value) {
			Assert.notNull(this.intValue, () -> 'intValue cannot be extracted from ' + name());
			return this.intValue.apply(value);
		}
		private static Unit fromChronoUnit(ChronoUnit chronoUnit) {
			if (chronoUnit == null) {
				return Unit.DAYS;
			}
			for (Unit candidate : values()) {
				if (candidate.chronoUnit == chronoUnit) {
					return candidate;
				}
			}
			throw new IllegalArgumentException('Unsupported unit ' + chronoUnit);
		}
	}
}
/*
package org.springframework.boot.convert;
/**
class CharSequenceToObjectConverter implements ConditionalGenericConverter {
	private static final TypeDescriptor STRING = TypeDescriptor.valueOf(String.class);
	private static final TypeDescriptor BYTE_ARRAY = TypeDescriptor.valueOf(byte[].class);
	private static final Set<ConvertiblePair> TYPES;
	private final ThreadLocal<Boolean> disable = new ThreadLocal<>();
	static {
		TYPES = Collections.singleton(new ConvertiblePair(CharSequence.class, Object.class));
	}
	private final ConversionService conversionService;
	CharSequenceToObjectConverter(ConversionService conversionService) {
		this.conversionService = conversionService;
	}
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return TYPES;
	}
	@Override
	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (sourceType.getType() == String.class || this.disable.get() == Boolean.TRUE) {
			return false;
		}
		this.disable.set(Boolean.TRUE);
		try {
			boolean canDirectlyConvertCharSequence = this.conversionService.canConvert(sourceType, targetType);
			if (canDirectlyConvertCharSequence && !isStringConversionBetter(sourceType, targetType)) {
				return false;
			}
			return this.conversionService.canConvert(STRING, targetType);
		}
		finally {
			this.disable.remove();
		}
	}
	/**
	 * Return if String based conversion is better based on the target type. This is
	 * required when ObjectTo... conversion produces incorrect results.
	 * @param sourceType the source type to test
	 * @param targetType the target type to test
	 * @return if string conversion is better
	 */
	private boolean isStringConversionBetter(TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (this.conversionService instanceof ApplicationConversionService applicationConversionService) {
			if (applicationConversionService.isConvertViaObjectSourceType(sourceType, targetType)) {
				// If an ObjectTo... converter is being used then there might be a better
				// StringTo... version
				return true;
			}
		}
		if ((targetType.isArray() || targetType.isCollection()) && !targetType.equals(BYTE_ARRAY)) {
			// StringToArrayConverter / StringToCollectionConverter are better than
			// ObjectToArrayConverter / ObjectToCollectionConverter
			return true;
		}
		return false;
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		return this.conversionService.convert(source.toString(), STRING, targetType);
	}
}
/*
package org.springframework.boot.convert;
/**
final class InetAddressFormatter implements Formatter<InetAddress> {
	@Override
	public String print(InetAddress object, Locale locale) {
		return object.getHostAddress();
	}
	@Override
	public InetAddress parse(String text, Locale locale) throws ParseException {
		try {
			return InetAddress.getByName(text);
		}
		catch (UnknownHostException ex) {
			throw new IllegalStateException('Unknown host ' + text, ex);
		}
	}
}
/*
package org.springframework.boot.convert;
/**
final class LenientStringToEnumConverterFactory extends LenientObjectToEnumConverterFactory<String> {
}
/*
package org.springframework.boot.convert;
/**
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DurationUnit {
	/**
	 * The duration unit to use if one is not specified.
	 * @return the duration unit
	 */
	ChronoUnit value();
}
/*
package org.springframework.boot.convert;
/**
public class ApplicationConversionService extends FormattingConversionService {
	private static volatile ApplicationConversionService sharedInstance;
	private final boolean unmodifiable;
	public ApplicationConversionService() {
		this(null);
	}
	public ApplicationConversionService(StringValueResolver embeddedValueResolver) {
		this(embeddedValueResolver, false);
	}
	private ApplicationConversionService(StringValueResolver embeddedValueResolver, boolean unmodifiable) {
		if (embeddedValueResolver != null) {
			setEmbeddedValueResolver(embeddedValueResolver);
		}
		configure(this);
		this.unmodifiable = unmodifiable;
	}
	@Override
	public void addPrinter(Printer<?> printer) {
		assertModifiable();
		super.addPrinter(printer);
	}
	@Override
	public void addParser(Parser<?> parser) {
		assertModifiable();
		super.addParser(parser);
	}
	@Override
	public void addFormatter(Formatter<?> formatter) {
		assertModifiable();
		super.addFormatter(formatter);
	}
	@Override
	public void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter) {
		assertModifiable();
		super.addFormatterForFieldType(fieldType, formatter);
	}
	@Override
	public void addConverter(Converter<?, ?> converter) {
		assertModifiable();
		super.addConverter(converter);
	}
	@Override
	public void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser) {
		assertModifiable();
		super.addFormatterForFieldType(fieldType, printer, parser);
	}
	@Override
	public void addFormatterForFieldAnnotation(
			AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory) {
		assertModifiable();
		super.addFormatterForFieldAnnotation(annotationFormatterFactory);
	}
	@Override
	public <S, T> void addConverter(Class<S> sourceType, Class<T> targetType,
			Converter<? super S, ? extends T> converter) {
		assertModifiable();
		super.addConverter(sourceType, targetType, converter);
	}
	@Override
	public void addConverter(GenericConverter converter) {
		assertModifiable();
		super.addConverter(converter);
	}
	@Override
	public void addConverterFactory(ConverterFactory<?, ?> factory) {
		assertModifiable();
		super.addConverterFactory(factory);
	}
	@Override
	public void removeConvertible(Class<?> sourceType, Class<?> targetType) {
		assertModifiable();
		super.removeConvertible(sourceType, targetType);
	}
	private void assertModifiable() {
		if (this.unmodifiable) {
			throw new UnsupportedOperationException('This ApplicationConversionService cannot be modified');
		}
	}
	/**
	 * Return {@code true} if objects of {@code sourceType} can be converted to the
	 * {@code targetType} and the converter has {@code Object.class} as a supported source
	 * type.
	 * @param sourceType the source type to test
	 * @param targetType the target type to test
	 * @return if conversion happens through an {@code ObjectTo...} converter
	 * @since 2.4.3
	 */
	public boolean isConvertViaObjectSourceType(TypeDescriptor sourceType, TypeDescriptor targetType) {
		GenericConverter converter = getConverter(sourceType, targetType);
		Set<ConvertiblePair> pairs = (converter != null) ? converter.getConvertibleTypes() : null;
		if (pairs != null) {
			for (ConvertiblePair pair : pairs) {
				if (Object.class.equals(pair.getSourceType())) {
					return true;
				}
			}
		}
		return false;
	}
	/**
	 * Return a shared default application {@code ConversionService} instance, lazily
	 * building it once needed.
	 * <p>
	 * Note: This method actually returns an {@link ApplicationConversionService}
	 * instance. However, the {@code ConversionService} signature has been preserved for
	 * binary compatibility.
	 * @return the shared {@code ApplicationConversionService} instance (never
	 * {@code null})
	 */
	public static ConversionService getSharedInstance() {
		ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;
		if (sharedInstance == null) {
			synchronized (ApplicationConversionService.class) {
				sharedInstance = ApplicationConversionService.sharedInstance;
				if (sharedInstance == null) {
					sharedInstance = new ApplicationConversionService(null, true);
					ApplicationConversionService.sharedInstance = sharedInstance;
				}
			}
		}
		return sharedInstance;
	}
	/**
	 * Configure the given {@link FormatterRegistry} with formatters and converters
	 * appropriate for most Spring Boot applications.
	 * @param registry the registry of converters to add to (must also be castable to
	 * ConversionService, e.g. being a {@link ConfigurableConversionService})
	 * @throws ClassCastException if the given FormatterRegistry could not be cast to a
	 * ConversionService
	 */
	public static void configure(FormatterRegistry registry) {
		DefaultConversionService.addDefaultConverters(registry);
		DefaultFormattingConversionService.addDefaultFormatters(registry);
		addApplicationFormatters(registry);
		addApplicationConverters(registry);
	}
	/**
	 * Add converters useful for most Spring Boot applications.
	 * @param registry the registry of converters to add to (must also be castable to
	 * ConversionService, e.g. being a {@link ConfigurableConversionService})
	 * @throws ClassCastException if the given ConverterRegistry could not be cast to a
	 * ConversionService
	 */
	public static void addApplicationConverters(ConverterRegistry registry) {
		addDelimitedStringConverters(registry);
		registry.addConverter(new StringToDurationConverter());
		registry.addConverter(new DurationToStringConverter());
		registry.addConverter(new NumberToDurationConverter());
		registry.addConverter(new DurationToNumberConverter());
		registry.addConverter(new StringToPeriodConverter());
		registry.addConverter(new PeriodToStringConverter());
		registry.addConverter(new NumberToPeriodConverter());
		registry.addConverter(new StringToDataSizeConverter());
		registry.addConverter(new NumberToDataSizeConverter());
		registry.addConverter(new StringToFileConverter());
		registry.addConverter(new InputStreamSourceToByteArrayConverter());
		registry.addConverterFactory(new LenientStringToEnumConverterFactory());
		registry.addConverterFactory(new LenientBooleanToEnumConverterFactory());
		if (registry instanceof ConversionService conversionService) {
			addApplicationConverters(registry, conversionService);
		}
	}
	private static void addApplicationConverters(ConverterRegistry registry, ConversionService conversionService) {
		registry.addConverter(new CharSequenceToObjectConverter(conversionService));
	}
	/**
	 * Add converters to support delimited strings.
	 * @param registry the registry of converters to add to (must also be castable to
	 * ConversionService, e.g. being a {@link ConfigurableConversionService})
	 * @throws ClassCastException if the given ConverterRegistry could not be cast to a
	 * ConversionService
	 */
	public static void addDelimitedStringConverters(ConverterRegistry registry) {
		ConversionService service = (ConversionService) registry;
		registry.addConverter(new ArrayToDelimitedStringConverter(service));
		registry.addConverter(new CollectionToDelimitedStringConverter(service));
		registry.addConverter(new DelimitedStringToArrayConverter(service));
		registry.addConverter(new DelimitedStringToCollectionConverter(service));
	}
	/**
	 * Add formatters useful for most Spring Boot applications.
	 * @param registry the service to register default formatters with
	 */
	public static void addApplicationFormatters(FormatterRegistry registry) {
		registry.addFormatter(new CharArrayFormatter());
		registry.addFormatter(new InetAddressFormatter());
		registry.addFormatter(new IsoOffsetFormatter());
	}
	/**
	 * Add {@link GenericConverter}, {@link Converter}, {@link Printer}, {@link Parser}
	 * and {@link Formatter} beans from the specified context.
	 * @param registry the service to register beans with
	 * @param beanFactory the bean factory to get the beans from
	 * @since 2.2.0
	 */
	public static void addBeans(FormatterRegistry registry, ListableBeanFactory beanFactory) {
		Set<Object> beans = new LinkedHashSet<>();
		beans.addAll(beanFactory.getBeansOfType(GenericConverter.class).values());
		beans.addAll(beanFactory.getBeansOfType(Converter.class).values());
		beans.addAll(beanFactory.getBeansOfType(Printer.class).values());
		beans.addAll(beanFactory.getBeansOfType(Parser.class).values());
		for (Object bean : beans) {
			if (bean instanceof GenericConverter genericConverter) {
				registry.addConverter(genericConverter);
			}
			else if (bean instanceof Converter<?, ?> converter) {
				registry.addConverter(converter);
			}
			else if (bean instanceof Formatter<?> formatter) {
				registry.addFormatter(formatter);
			}
			else if (bean instanceof Printer<?> printer) {
				registry.addPrinter(printer);
			}
			else if (bean instanceof Parser<?> parser) {
				registry.addParser(parser);
			}
		}
	}
}
/*
package org.springframework.boot.convert;
/**
final class DurationToNumberConverter implements GenericConverter {
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Duration.class, Number.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (source == null) {
			return null;
		}
		return convert((Duration) source, getDurationUnit(sourceType), targetType.getObjectType());
	}
	private ChronoUnit getDurationUnit(TypeDescriptor sourceType) {
		DurationUnit annotation = sourceType.getAnnotation(DurationUnit.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private Object convert(Duration source, ChronoUnit unit, Class<?> type) {
		try {
			return type.getConstructor(String.class)
				.newInstance(String.valueOf(DurationStyle.Unit.fromChronoUnit(unit).longValue(source)));
		}
		catch (Exception ex) {
			ReflectionUtils.rethrowRuntimeException(ex);
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.convert;
/**
final class ArrayToDelimitedStringConverter implements ConditionalGenericConverter {
	private final CollectionToDelimitedStringConverter delegate;
	ArrayToDelimitedStringConverter(ConversionService conversionService) {
		this.delegate = new CollectionToDelimitedStringConverter(conversionService);
	}
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Object[].class, String.class));
	}
	@Override
	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
		return this.delegate.matches(sourceType, targetType);
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		List<Object> list = Arrays.asList(ObjectUtils.toObjectArray(source));
		return this.delegate.convert(list, sourceType, targetType);
	}
}
/*
package org.springframework.boot.convert;
/**
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })
public @interface Delimiter {
	/**
	 * A delimiter value used to indicate that no delimiter is required and the result
	 * should be a single element containing the entire string.
	 */
	String NONE = '';
	/**
	 * The delimiter to use or {@code NONE} if the entire contents should be treated as a
	 * single element.
	 * @return the delimiter
	 */
	String value();
}
/*
package org.springframework.boot.convert;
/**
final class DelimitedStringToCollectionConverter implements ConditionalGenericConverter {
	private final ConversionService conversionService;
	DelimitedStringToCollectionConverter(ConversionService conversionService) {
		Assert.notNull(conversionService, 'ConversionService must not be null');
		this.conversionService = conversionService;
	}
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(String.class, Collection.class));
	}
	@Override
	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
		return targetType.getElementTypeDescriptor() == null
				|| this.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor());
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (source == null) {
			return null;
		}
		return convert((String) source, sourceType, targetType);
	}
	private Object convert(String source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		Delimiter delimiter = targetType.getAnnotation(Delimiter.class);
		String[] elements = getElements(source, (delimiter != null) ? delimiter.value() : ',');
		TypeDescriptor elementDescriptor = targetType.getElementTypeDescriptor();
		Collection<Object> target = createCollection(targetType, elementDescriptor, elements.length);
		Stream<Object> stream = Arrays.stream(elements).map(String::trim);
		if (elementDescriptor != null) {
			stream = stream.map((element) -> this.conversionService.convert(element, sourceType, elementDescriptor));
		}
		stream.forEach(target::add);
		return target;
	}
	private Collection<Object> createCollection(TypeDescriptor targetType, TypeDescriptor elementDescriptor,
			int length) {
		return CollectionFactory.createCollection(targetType.getType(),
				(elementDescriptor != null) ? elementDescriptor.getType() : null, length);
	}
	private String[] getElements(String source, String delimiter) {
		return StringUtils.delimitedListToStringArray(source, Delimiter.NONE.equals(delimiter) ? null : delimiter);
	}
}
/*
package org.springframework.boot.convert;
/**
final class LenientBooleanToEnumConverterFactory extends LenientObjectToEnumConverterFactory<Boolean> {
}
/*
package org.springframework.boot.convert;
/**
class IsoOffsetFormatter implements Formatter<OffsetDateTime> {
	@Override
	public String print(OffsetDateTime object, Locale locale) {
		return DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(object);
	}
	@Override
	public OffsetDateTime parse(String text, Locale locale) throws ParseException {
		return OffsetDateTime.parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);
	}
}
/*
package org.springframework.boot.convert;
/**
final class StringToDurationConverter implements GenericConverter {
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(String.class, Duration.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (ObjectUtils.isEmpty(source)) {
			return null;
		}
		return convert(source.toString(), getStyle(targetType), getDurationUnit(targetType));
	}
	private DurationStyle getStyle(TypeDescriptor targetType) {
		DurationFormat annotation = targetType.getAnnotation(DurationFormat.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private ChronoUnit getDurationUnit(TypeDescriptor targetType) {
		DurationUnit annotation = targetType.getAnnotation(DurationUnit.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private Duration convert(String source, DurationStyle style, ChronoUnit unit) {
		style = (style != null) ? style : DurationStyle.detect(source);
		return style.parse(source, unit);
	}
}
/*
package org.springframework.boot.convert;
/**
final class CollectionToDelimitedStringConverter implements ConditionalGenericConverter {
	private final ConversionService conversionService;
	CollectionToDelimitedStringConverter(ConversionService conversionService) {
		this.conversionService = conversionService;
	}
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Collection.class, String.class));
	}
	@Override
	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
		TypeDescriptor sourceElementType = sourceType.getElementTypeDescriptor();
		if (targetType == null || sourceElementType == null) {
			return true;
		}
		return this.conversionService.canConvert(sourceElementType, targetType)
				|| sourceElementType.getType().isAssignableFrom(targetType.getType());
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (source == null) {
			return null;
		}
		Collection<?> sourceCollection = (Collection<?>) source;
		return convert(sourceCollection, sourceType, targetType);
	}
	private Object convert(Collection<?> source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (source.isEmpty()) {
			return '';
		}
		return source.stream()
			.map((element) -> convertElement(element, sourceType, targetType))
			.collect(Collectors.joining(getDelimiter(sourceType)));
	}
	private CharSequence getDelimiter(TypeDescriptor sourceType) {
		Delimiter annotation = sourceType.getAnnotation(Delimiter.class);
		return (annotation != null) ? annotation.value() : ',';
	}
	private String convertElement(Object element, TypeDescriptor sourceType, TypeDescriptor targetType) {
		return String
			.valueOf(this.conversionService.convert(element, sourceType.elementTypeDescriptor(element), targetType));
	}
}
/*
package org.springframework.boot.convert;
/**
class StringToFileConverter implements Converter<String, File> {
	@Override
	public File convert(String source) {
		return getFile(ApplicationResourceLoader.get().getResource(source));
	}
	private File getFile(Resource resource) {
		try {
			return resource.getFile();
		}
		catch (IOException ex) {
			throw new IllegalStateException('Could not retrieve file for ' + resource + ': ' + ex.getMessage());
		}
	}
}
/*
package org.springframework.boot.convert;
/**
final class NumberToDurationConverter implements GenericConverter {
	private final StringToDurationConverter delegate = new StringToDurationConverter();
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Number.class, Duration.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		return this.delegate.convert((source != null) ? source.toString() : null, TypeDescriptor.valueOf(String.class),
				targetType);
	}
}
/*
package org.springframework.boot.convert;
/**
final class NumberToDataSizeConverter implements GenericConverter {
	private final StringToDataSizeConverter delegate = new StringToDataSizeConverter();
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Number.class, DataSize.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		return this.delegate.convert((source != null) ? source.toString() : null, TypeDescriptor.valueOf(String.class),
				targetType);
	}
}
/*
package org.springframework.boot.convert;
/**
final class NumberToPeriodConverter implements GenericConverter {
	private final StringToPeriodConverter delegate = new StringToPeriodConverter();
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Number.class, Period.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		return this.delegate.convert((source != null) ? source.toString() : null, TypeDescriptor.valueOf(String.class),
				targetType);
	}
}
/*
package org.springframework.boot.convert;
/**
final class StringToPeriodConverter implements GenericConverter {
	@Override
	public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new GenericConverter.ConvertiblePair(String.class, Period.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (ObjectUtils.isEmpty(source)) {
			return null;
		}
		return convert(source.toString(), getStyle(targetType), getPeriodUnit(targetType));
	}
	private PeriodStyle getStyle(TypeDescriptor targetType) {
		PeriodFormat annotation = targetType.getAnnotation(PeriodFormat.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private ChronoUnit getPeriodUnit(TypeDescriptor targetType) {
		PeriodUnit annotation = targetType.getAnnotation(PeriodUnit.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private Period convert(String source, PeriodStyle style, ChronoUnit unit) {
		style = (style != null) ? style : PeriodStyle.detect(source);
		return style.parse(source, unit);
	}
}
/*
/**
package org.springframework.boot.convert;
/*
package org.springframework.boot.convert;
/**
final class CharArrayFormatter implements Formatter<char[]> {
	@Override
	public String print(char[] object, Locale locale) {
		return new String(object);
	}
	@Override
	public char[] parse(String text, Locale locale) throws ParseException {
		return text.toCharArray();
	}
}
/*
package org.springframework.boot.convert;
/**
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataSizeUnit {
	/**
	 * The {@link DataUnit} to use if one is not specified.
	 * @return the data unit
	 */
	DataUnit value();
}
/*
package org.springframework.boot.convert;
/**
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface PeriodUnit {
	/**
	 * The Period unit to use if one is not specified.
	 * @return the Period unit
	 */
	ChronoUnit value();
}
/*
package org.springframework.boot.convert;
/**
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DurationFormat {
	/**
	 * The duration format style.
	 * @return the duration format style.
	 */
	DurationStyle value();
}
/*
package org.springframework.boot.convert;
/**
class InputStreamSourceToByteArrayConverter implements Converter<InputStreamSource, byte[]> {
	@Override
	public byte[] convert(InputStreamSource source) {
		try {
			return FileCopyUtils.copyToByteArray(source.getInputStream());
		}
		catch (IOException ex) {
			throw new IllegalStateException('Unable to read from ' + getName(source), ex);
		}
	}
	private String getName(InputStreamSource source) {
		Origin origin = Origin.from(source);
		if (origin != null) {
			return origin.toString();
		}
		if (source instanceof Resource resource) {
			return resource.getDescription();
		}
		return 'input stream source';
	}
}
/*
package org.springframework.boot.convert;
/**
final class StringToDataSizeConverter implements GenericConverter {
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(String.class, DataSize.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (ObjectUtils.isEmpty(source)) {
			return null;
		}
		return convert(source.toString(), getDataUnit(targetType));
	}
	private DataUnit getDataUnit(TypeDescriptor targetType) {
		DataSizeUnit annotation = targetType.getAnnotation(DataSizeUnit.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private DataSize convert(String source, DataUnit unit) {
		return DataSize.parse(source, unit);
	}
}
/*
package org.springframework.boot.convert;
/**
final class DelimitedStringToArrayConverter implements ConditionalGenericConverter {
	private final ConversionService conversionService;
	DelimitedStringToArrayConverter(ConversionService conversionService) {
		Assert.notNull(conversionService, 'ConversionService must not be null');
		this.conversionService = conversionService;
	}
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(String.class, Object[].class));
	}
	@Override
	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
		return targetType.getElementTypeDescriptor() == null
				|| this.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor());
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (source == null) {
			return null;
		}
		return convert((String) source, sourceType, targetType);
	}
	private Object convert(String source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		Delimiter delimiter = targetType.getAnnotation(Delimiter.class);
		String[] elements = getElements(source, (delimiter != null) ? delimiter.value() : ',');
		TypeDescriptor elementDescriptor = targetType.getElementTypeDescriptor();
		Object target = Array.newInstance(elementDescriptor.getType(), elements.length);
		for (int i = 0; i < elements.length; i++) {
			String sourceElement = elements[i];
			Object targetElement = this.conversionService.convert(sourceElement.trim(), sourceType, elementDescriptor);
			Array.set(target, i, targetElement);
		}
		return target;
	}
	private String[] getElements(String source, String delimiter) {
		return StringUtils.delimitedListToStringArray(source, Delimiter.NONE.equals(delimiter) ? null : delimiter);
	}
}
/*
package org.springframework.boot.convert;
/**
final class DurationToStringConverter implements GenericConverter {
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return Collections.singleton(new ConvertiblePair(Duration.class, String.class));
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (source == null) {
			return null;
		}
		return convert((Duration) source, getDurationStyle(sourceType), getDurationUnit(sourceType));
	}
	private ChronoUnit getDurationUnit(TypeDescriptor sourceType) {
		DurationUnit annotation = sourceType.getAnnotation(DurationUnit.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private DurationStyle getDurationStyle(TypeDescriptor sourceType) {
		DurationFormat annotation = sourceType.getAnnotation(DurationFormat.class);
		return (annotation != null) ? annotation.value() : null;
	}
	private String convert(Duration source, DurationStyle style, ChronoUnit unit) {
		style = (style != null) ? style : DurationStyle.ISO8601;
		return style.print(source, unit);
	}
}
/*
package org.springframework.boot;
/**
@FunctionalInterface
public interface BootstrapRegistryInitializer {
	/**
	 * Initialize the given {@link BootstrapRegistry} with any required registrations.
	 * @param registry the registry to initialize
	 */
	void initialize(BootstrapRegistry registry);
}
/*
package org.springframework.boot.cloud;
/**
public enum CloudPlatform {
	/**
	 * No Cloud platform. Useful when false-positives are detected.
	 */
	NONE {
		@Override
		public boolean isDetected(Environment environment) {
			return false;
		}
	},
	/**
	 * Cloud Foundry platform.
	 */
	CLOUD_FOUNDRY {
		@Override
		public boolean isDetected(Environment environment) {
			return environment.containsProperty('VCAP_APPLICATION') || environment.containsProperty('VCAP_SERVICES');
		}
	},
	/**
	 * Heroku platform.
	 */
	HEROKU {
		@Override
		public boolean isDetected(Environment environment) {
			return environment.containsProperty('DYNO');
		}
	},
	/**
	 * SAP Cloud platform.
	 */
	SAP {
		@Override
		public boolean isDetected(Environment environment) {
			return environment.containsProperty('HC_LANDSCAPE');
		}
	},
	/**
	 * Nomad platform.
	 * @since 3.1.0
	 */
	NOMAD {
		@Override
		public boolean isDetected(Environment environment) {
			return environment.containsProperty('NOMAD_ALLOC_ID');
		}
	},
	/**
	 * Kubernetes platform.
	 */
	KUBERNETES {
		private static final String KUBERNETES_SERVICE_HOST = 'KUBERNETES_SERVICE_HOST';
		private static final String KUBERNETES_SERVICE_PORT = 'KUBERNETES_SERVICE_PORT';
		private static final String SERVICE_HOST_SUFFIX = '_SERVICE_HOST';
		private static final String SERVICE_PORT_SUFFIX = '_SERVICE_PORT';
		@Override
		public boolean isDetected(Environment environment) {
			if (environment instanceof ConfigurableEnvironment configurableEnvironment) {
				return isAutoDetected(configurableEnvironment);
			}
			return false;
		}
		private boolean isAutoDetected(ConfigurableEnvironment environment) {
			PropertySource<?> environmentPropertySource = environment.getPropertySources()
				.get(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME);
			if (environmentPropertySource != null) {
				if (environmentPropertySource.containsProperty(KUBERNETES_SERVICE_HOST)
						&& environmentPropertySource.containsProperty(KUBERNETES_SERVICE_PORT)) {
					return true;
				}
				if (environmentPropertySource instanceof EnumerablePropertySource<?> enumerablePropertySource) {
					return isAutoDetected(enumerablePropertySource);
				}
			}
			return false;
		}
		private boolean isAutoDetected(EnumerablePropertySource<?> environmentPropertySource) {
			for (String propertyName : environmentPropertySource.getPropertyNames()) {
				if (propertyName.endsWith(SERVICE_HOST_SUFFIX)) {
					String serviceName = propertyName.substring(0,
							propertyName.length() - SERVICE_HOST_SUFFIX.length());
					if (environmentPropertySource.getProperty(serviceName + SERVICE_PORT_SUFFIX) != null) {
						return true;
					}
				}
			}
			return false;
		}
	},
	/**
	 * Azure App Service platform.
	 */
	AZURE_APP_SERVICE {
		private final List<String> azureEnvVariables = Arrays.asList('WEBSITE_SITE_NAME', 'WEBSITE_INSTANCE_ID',
				'WEBSITE_RESOURCE_GROUP', 'WEBSITE_SKU');
		@Override
		public boolean isDetected(Environment environment) {
			return this.azureEnvVariables.stream().allMatch(environment::containsProperty);
		}
	};
	private static final String PROPERTY_NAME = 'spring.main.cloud-platform';
	/**
	 * Determines if the platform is active (i.e. the application is running in it).
	 * @param environment the environment
	 * @return if the platform is active.
	 */
	public boolean isActive(Environment environment) {
		String platformProperty = environment.getProperty(PROPERTY_NAME);
		return isEnforced(platformProperty) || (platformProperty == null && isDetected(environment));
	}
	/**
	 * Determines if the platform is enforced by looking at the
	 * {@code 'spring.main.cloud-platform'} configuration property.
	 * @param environment the environment
	 * @return if the platform is enforced
	 * @since 2.3.0
	 */
	public boolean isEnforced(Environment environment) {
		return isEnforced(environment.getProperty(PROPERTY_NAME));
	}
	/**
	 * Determines if the platform is enforced by looking at the
	 * {@code 'spring.main.cloud-platform'} configuration property.
	 * @param binder the binder
	 * @return if the platform is enforced
	 * @since 2.4.0
	 */
	public boolean isEnforced(Binder binder) {
		return isEnforced(binder.bind(PROPERTY_NAME, String.class).orElse(null));
	}
	private boolean isEnforced(String platform) {
		return name().equalsIgnoreCase(platform);
	}
	/**
	 * Determines if the platform is detected by looking for platform-specific environment
	 * variables.
	 * @param environment the environment
	 * @return if the platform is auto-detected.
	 * @since 2.3.0
	 */
	public abstract boolean isDetected(Environment environment);
	/**
	 * Returns if the platform is behind a load balancer and uses
	 * {@literal X-Forwarded-For} headers.
	 * @return if {@literal X-Forwarded-For} headers are used
	 */
	public boolean isUsingForwardHeaders() {
		return true;
	}
	/**
	 * Returns the active {@link CloudPlatform} or {@code null} if one is not active.
	 * @param environment the environment
	 * @return the {@link CloudPlatform} or {@code null}
	 */
	public static CloudPlatform getActive(Environment environment) {
		if (environment != null) {
			for (CloudPlatform cloudPlatform : values()) {
				if (cloudPlatform.isActive(environment)) {
					return cloudPlatform;
				}
			}
		}
		return null;
	}
}
/*
/**
package org.springframework.boot.cloud;
/*
package org.springframework.boot.cloud;
/**
public class CloudFoundryVcapEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
	private static final String VCAP_APPLICATION = 'VCAP_APPLICATION';
	private static final String VCAP_SERVICES = 'VCAP_SERVICES';
	private final Log logger;
	// Before ConfigDataEnvironmentPostProcessor so values there can use these
	private int order = ConfigDataEnvironmentPostProcessor.ORDER - 5;
	/**
	 * Create a new {@link CloudFoundryVcapEnvironmentPostProcessor} instance.
	 * @param logFactory the log factory to use
	 * @since 3.0.0
	 */
	public CloudFoundryVcapEnvironmentPostProcessor(DeferredLogFactory logFactory) {
		this.logger = logFactory.getLog(CloudFoundryVcapEnvironmentPostProcessor.class);
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		if (CloudPlatform.CLOUD_FOUNDRY.isActive(environment)) {
			Properties properties = new Properties();
			JsonParser jsonParser = JsonParserFactory.getJsonParser();
			addWithPrefix(properties, getPropertiesFromApplication(environment, jsonParser), 'vcap.application.');
			addWithPrefix(properties, getPropertiesFromServices(environment, jsonParser), 'vcap.services.');
			MutablePropertySources propertySources = environment.getPropertySources();
			if (propertySources.contains(CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME)) {
				propertySources.addAfter(CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME,
						new PropertiesPropertySource('vcap', properties));
			}
			else {
				propertySources.addFirst(new PropertiesPropertySource('vcap', properties));
			}
		}
	}
	private void addWithPrefix(Properties properties, Properties other, String prefix) {
		for (String key : other.stringPropertyNames()) {
			String prefixed = prefix + key;
			properties.setProperty(prefixed, other.getProperty(key));
		}
	}
	private Properties getPropertiesFromApplication(Environment environment, JsonParser parser) {
		Properties properties = new Properties();
		try {
			String property = environment.getProperty(VCAP_APPLICATION, '{}');
			Map<String, Object> map = parser.parseMap(property);
			extractPropertiesFromApplication(properties, map);
		}
		catch (Exception ex) {
			this.logger.error('Could not parse VCAP_APPLICATION', ex);
		}
		return properties;
	}
	private Properties getPropertiesFromServices(Environment environment, JsonParser parser) {
		Properties properties = new Properties();
		try {
			String property = environment.getProperty(VCAP_SERVICES, '{}');
			Map<String, Object> map = parser.parseMap(property);
			extractPropertiesFromServices(properties, map);
		}
		catch (Exception ex) {
			this.logger.error('Could not parse VCAP_SERVICES', ex);
		}
		return properties;
	}
	private void extractPropertiesFromApplication(Properties properties, Map<String, Object> map) {
		if (map != null) {
			flatten(properties, map, '');
		}
	}
	private void extractPropertiesFromServices(Properties properties, Map<String, Object> map) {
		if (map != null) {
			for (Object services : map.values()) {
				@SuppressWarnings('unchecked')
				List<Object> list = (List<Object>) services;
				for (Object object : list) {
					@SuppressWarnings('unchecked')
					Map<String, Object> service = (Map<String, Object>) object;
					String key = (String) service.get('name');
					if (key == null) {
						key = (String) service.get('label');
					}
					flatten(properties, service, key);
				}
			}
		}
	}
	@SuppressWarnings('unchecked')
	private void flatten(Properties properties, Map<String, Object> input, String path) {
		input.forEach((key, value) -> {
			String name = getPropertyName(path, key);
			if (value instanceof Map) {
				// Need a compound key
				flatten(properties, (Map<String, Object>) value, name);
			}
			else if (value instanceof Collection<?> collection) {
				// Need a compound key
				properties.put(name, StringUtils.collectionToCommaDelimitedString(collection));
				int count = 0;
				for (Object item : collection) {
					String itemKey = '[' + (count++) + ']';
					flatten(properties, Collections.singletonMap(itemKey, item), name);
				}
			}
			else if (value instanceof String) {
				properties.put(name, value);
			}
			else if (value instanceof Number || value instanceof Boolean) {
				properties.put(name, value.toString());
			}
			else {
				properties.put(name, (value != null) ? value : '');
			}
		});
	}
	private String getPropertyName(String path, String key) {
		if (!StringUtils.hasText(path)) {
			return key;
		}
		if (key.startsWith('[')) {
			return path + key;
		}
		return path + '.' + key;
	}
}
/*
package org.springframework.boot;
/**
class SpringApplicationRunListeners {
	private final Log log;
	private final List<SpringApplicationRunListener> listeners;
	private final ApplicationStartup applicationStartup;
	SpringApplicationRunListeners(Log log, List<SpringApplicationRunListener> listeners,
			ApplicationStartup applicationStartup) {
		this.log = log;
		this.listeners = List.copyOf(listeners);
		this.applicationStartup = applicationStartup;
	}
	void starting(ConfigurableBootstrapContext bootstrapContext, Class<?> mainApplicationClass) {
		doWithListeners('spring.boot.application.starting', (listener) -> listener.starting(bootstrapContext),
				(step) -> {
					if (mainApplicationClass != null) {
						step.tag('mainApplicationClass', mainApplicationClass.getName());
					}
				});
	}
	void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) {
		doWithListeners('spring.boot.application.environment-prepared',
				(listener) -> listener.environmentPrepared(bootstrapContext, environment));
	}
	void contextPrepared(ConfigurableApplicationContext context) {
		doWithListeners('spring.boot.application.context-prepared', (listener) -> listener.contextPrepared(context));
	}
	void contextLoaded(ConfigurableApplicationContext context) {
		doWithListeners('spring.boot.application.context-loaded', (listener) -> listener.contextLoaded(context));
	}
	void started(ConfigurableApplicationContext context, Duration timeTaken) {
		doWithListeners('spring.boot.application.started', (listener) -> listener.started(context, timeTaken));
	}
	void ready(ConfigurableApplicationContext context, Duration timeTaken) {
		doWithListeners('spring.boot.application.ready', (listener) -> listener.ready(context, timeTaken));
	}
	void failed(ConfigurableApplicationContext context, Throwable exception) {
		doWithListeners('spring.boot.application.failed',
				(listener) -> callFailedListener(listener, context, exception), (step) -> {
					step.tag('exception', exception.getClass().toString());
					step.tag('message', exception.getMessage());
				});
	}
	private void callFailedListener(SpringApplicationRunListener listener, ConfigurableApplicationContext context,
			Throwable exception) {
		try {
			listener.failed(context, exception);
		}
		catch (Throwable ex) {
			if (exception == null) {
				ReflectionUtils.rethrowRuntimeException(ex);
			}
			if (this.log.isDebugEnabled()) {
				this.log.error('Error handling failed', ex);
			}
			else {
				String message = ex.getMessage();
				message = (message != null) ? message : 'no error message';
				this.log.warn('Error handling failed (' + message + ')');
			}
		}
	}
	private void doWithListeners(String stepName, Consumer<SpringApplicationRunListener> listenerAction) {
		doWithListeners(stepName, listenerAction, null);
	}
	private void doWithListeners(String stepName, Consumer<SpringApplicationRunListener> listenerAction,
			Consumer<StartupStep> stepAction) {
		StartupStep step = this.applicationStartup.start(stepName);
		this.listeners.forEach(listenerAction);
		if (stepAction != null) {
			stepAction.accept(step);
		}
		step.end();
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public class HttpWebServiceMessageSenderBuilder {
	private ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder;
	private ClientHttpRequestFactorySettings requestFactorySettings = ClientHttpRequestFactorySettings.defaults();
	/**
	 * Set the connection timeout.
	 * @param connectTimeout the connection timeout
	 * @return a new builder instance
	 */
	public HttpWebServiceMessageSenderBuilder setConnectTimeout(Duration connectTimeout) {
		this.requestFactorySettings = this.requestFactorySettings.withConnectTimeout(connectTimeout);
		return this;
	}
	/**
	 * Set the read timeout.
	 * @param readTimeout the read timeout
	 * @return a new builder instance
	 */
	public HttpWebServiceMessageSenderBuilder setReadTimeout(Duration readTimeout) {
		this.requestFactorySettings = this.requestFactorySettings.withReadTimeout(readTimeout);
		return this;
	}
	/**
	 * Set an {@link SslBundle} that will be used to configure a secure connection.
	 * @param sslBundle the SSL bundle
	 * @return a new builder instance
	 */
	public HttpWebServiceMessageSenderBuilder sslBundle(SslBundle sslBundle) {
		this.requestFactorySettings = this.requestFactorySettings.withSslBundle(sslBundle);
		return this;
	}
	/**
	 * Set the {@code Supplier} of {@link ClientHttpRequestFactory} that should be called
	 * to create the HTTP-based {@link WebServiceMessageSender}.
	 * @param requestFactorySupplier the supplier for the request factory
	 * @return a new builder instance
	 */
	public HttpWebServiceMessageSenderBuilder requestFactory(
			Supplier<ClientHttpRequestFactory> requestFactorySupplier) {
		Assert.notNull(requestFactorySupplier, 'RequestFactorySupplier must not be null');
		this.requestFactoryBuilder = ClientHttpRequestFactoryBuilder.of(requestFactorySupplier);
		return this;
	}
	/**
	 * Set the {@code Function} of {@link ClientHttpRequestFactorySettings} to
	 * {@link ClientHttpRequestFactory} that should be called to create the HTTP-based
	 * {@link WebServiceMessageSender}.
	 * @param requestFactoryFunction the function for the request factory
	 * @return a new builder instance
	 * @since 3.0.0
	 */
	public HttpWebServiceMessageSenderBuilder requestFactory(
			Function<ClientHttpRequestFactorySettings, ClientHttpRequestFactory> requestFactoryFunction) {
		Assert.notNull(requestFactoryFunction, 'RequestFactoryFunction must not be null');
		this.requestFactoryBuilder = requestFactoryFunction::apply;
		return this;
	}
	/**
	 * Set the {@link ClientHttpRequestFactoryBuilder} to use when creating the HTTP-based
	 * {@link WebServiceMessageSender}.
	 * @param requestFactoryBuilder the {@link ClientHttpRequestFactoryBuilder} to use
	 * @return this builder instance
	 * @since 3.4.0
	 */
	public HttpWebServiceMessageSenderBuilder requestFactoryBuilder(
			ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder) {
		Assert.notNull(requestFactoryBuilder, 'ClientHttpRequestFactoryBuilder must not be null');
		this.requestFactoryBuilder = requestFactoryBuilder;
		return this;
	}
	/**
	 * Build the {@link WebServiceMessageSender} instance.
	 * @return the {@link WebServiceMessageSender} instance
	 */
	public WebServiceMessageSender build() {
		ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder = getOrDetectRequestFactoryBuilder();
		return WebServiceMessageSenderFactory.http(requestFactoryBuilder, this.requestFactorySettings)
			.getWebServiceMessageSender();
	}
	private ClientHttpRequestFactoryBuilder<?> getOrDetectRequestFactoryBuilder() {
		if (this.requestFactoryBuilder != null) {
			return this.requestFactoryBuilder;
		}
		ClientHttpRequestFactoryBuilder<?> builder = ClientHttpRequestFactoryBuilder.detect();
		if (builder instanceof JdkClientHttpRequestFactoryBuilder) {
			// Same logic as earlier versions which did not support JDK client factories
			return ClientHttpRequestFactoryBuilder.simple();
		}
		return builder;
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@FunctionalInterface
public interface WebServiceTemplateCustomizer {
	/**
	 * Callback to customize a {@link WebServiceTemplate} instance.
	 * @param webServiceTemplate the template to customize
	 */
	void customize(WebServiceTemplate webServiceTemplate);
}
/*
package org.springframework.boot.webservices.client;
/**
public class WebServiceTemplateBuilder {
	private final WebServiceMessageSenderFactory httpMessageSenderFactory;
	private final boolean detectHttpMessageSender;
	private final Set<ClientInterceptor> interceptors;
	private final Set<WebServiceTemplateCustomizer> internalCustomizers;
	private final Set<WebServiceTemplateCustomizer> customizers;
	private final WebServiceMessageSenders messageSenders;
	private final Marshaller marshaller;
	private final Unmarshaller unmarshaller;
	private final DestinationProvider destinationProvider;
	private final Class<? extends TransformerFactory> transformerFactoryClass;
	private final WebServiceMessageFactory messageFactory;
	public WebServiceTemplateBuilder(WebServiceTemplateCustomizer... customizers) {
		this.httpMessageSenderFactory = null;
		this.detectHttpMessageSender = true;
		this.interceptors = null;
		this.internalCustomizers = null;
		this.customizers = Collections.unmodifiableSet(new LinkedHashSet<>(Arrays.asList(customizers)));
		this.messageSenders = new WebServiceMessageSenders();
		this.marshaller = null;
		this.unmarshaller = null;
		this.destinationProvider = null;
		this.transformerFactoryClass = null;
		this.messageFactory = null;
	}
	private WebServiceTemplateBuilder(WebServiceMessageSenderFactory messageSenderFactory,
			boolean detectHttpMessageSender, Set<ClientInterceptor> interceptors,
			Set<WebServiceTemplateCustomizer> internalCustomizers, Set<WebServiceTemplateCustomizer> customizers,
			WebServiceMessageSenders messageSenders, Marshaller marshaller, Unmarshaller unmarshaller,
			DestinationProvider destinationProvider, Class<? extends TransformerFactory> transformerFactoryClass,
			WebServiceMessageFactory messageFactory) {
		this.httpMessageSenderFactory = messageSenderFactory;
		this.detectHttpMessageSender = detectHttpMessageSender;
		this.interceptors = interceptors;
		this.internalCustomizers = internalCustomizers;
		this.customizers = customizers;
		this.messageSenders = messageSenders;
		this.marshaller = marshaller;
		this.unmarshaller = unmarshaller;
		this.destinationProvider = destinationProvider;
		this.transformerFactoryClass = transformerFactoryClass;
		this.messageFactory = messageFactory;
	}
	/**
	 * Set the {@link WebServiceMessageSenderFactory} that should be used to send HTTP
	 * messages.
	 * @param messageSenderFactory the {@link WebServiceMessageSenderFactory} to use
	 * @return a new builder instance
	 * @since 3.4.0
	 * @see HttpWebServiceMessageSenderBuilder
	 */
	public WebServiceTemplateBuilder httpMessageSenderFactory(WebServiceMessageSenderFactory messageSenderFactory) {
		Assert.notNull(this.messageSenders, 'HttpWebServiceMessageSenderBuilder must not be null');
		return new WebServiceTemplateBuilder(messageSenderFactory, this.detectHttpMessageSender, this.interceptors,
				this.internalCustomizers, this.customizers, this.messageSenders, this.marshaller, this.unmarshaller,
				this.destinationProvider, this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Set if a suitable HTTP-based {@link WebServiceMessageSender} should be detected
	 * based on the classpath when one has not been specified. Default is {@code true}.
	 * @param detectHttpMessageSender if an HTTP-based {@link WebServiceMessageSender}
	 * should be detected
	 * @return a new builder instance
	 * @see HttpWebServiceMessageSenderBuilder
	 */
	public WebServiceTemplateBuilder detectHttpMessageSender(boolean detectHttpMessageSender) {
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, detectHttpMessageSender, this.interceptors,
				this.internalCustomizers, this.customizers, this.messageSenders, this.marshaller, this.unmarshaller,
				this.destinationProvider, this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Sets the {@link WebServiceMessageSender WebServiceMessageSenders} that should be
	 * used with the {@link WebServiceTemplate}. Setting this value will replace any
	 * previously defined message senders, including the HTTP-based message sender, if
	 * any. Consider using {@link #additionalMessageSenders(WebServiceMessageSender...)}
	 * to keep it with user-defined message senders.
	 * @param messageSenders the message senders to set
	 * @return a new builder instance.
	 * @see #additionalMessageSenders(WebServiceMessageSender...)
	 * @see #detectHttpMessageSender(boolean)
	 */
	public WebServiceTemplateBuilder messageSenders(WebServiceMessageSender... messageSenders) {
		Assert.notNull(messageSenders, 'MessageSenders must not be null');
		return messageSenders(Arrays.asList(messageSenders));
	}
	/**
	 * Sets the {@link WebServiceMessageSender WebServiceMessageSenders} that should be
	 * used with the {@link WebServiceTemplate}. Setting this value will replace any
	 * previously defined message senders, including the HTTP-based message sender, if
	 * any. Consider using {@link #additionalMessageSenders(Collection)} to keep it with
	 * user-defined message senders.
	 * @param messageSenders the message senders to set
	 * @return a new builder instance.
	 * @see #additionalMessageSenders(Collection)
	 * @see #detectHttpMessageSender(boolean)
	 */
	public WebServiceTemplateBuilder messageSenders(Collection<? extends WebServiceMessageSender> messageSenders) {
		Assert.notNull(messageSenders, 'MessageSenders must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, this.customizers, this.messageSenders.set(messageSenders),
				this.marshaller, this.unmarshaller, this.destinationProvider, this.transformerFactoryClass,
				this.messageFactory);
	}
	/**
	 * Add additional {@link WebServiceMessageSender WebServiceMessageSenders} that should
	 * be used with the {@link WebServiceTemplate}.
	 * @param messageSenders the message senders to add
	 * @return a new builder instance.
	 * @see #messageSenders(WebServiceMessageSender...)
	 */
	public WebServiceTemplateBuilder additionalMessageSenders(WebServiceMessageSender... messageSenders) {
		Assert.notNull(messageSenders, 'MessageSenders must not be null');
		return additionalMessageSenders(Arrays.asList(messageSenders));
	}
	/**
	 * Add additional {@link WebServiceMessageSender WebServiceMessageSenders} that should
	 * be used with the {@link WebServiceTemplate}.
	 * @param messageSenders the message senders to add
	 * @return a new builder instance.
	 * @see #messageSenders(Collection)
	 */
	public WebServiceTemplateBuilder additionalMessageSenders(
			Collection<? extends WebServiceMessageSender> messageSenders) {
		Assert.notNull(messageSenders, 'MessageSenders must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, this.customizers, this.messageSenders.add(messageSenders),
				this.marshaller, this.unmarshaller, this.destinationProvider, this.transformerFactoryClass,
				this.messageFactory);
	}
	/**
	 * Set the {@link ClientInterceptor ClientInterceptors} that should be used with the
	 * {@link WebServiceTemplate}. Setting this value will replace any previously defined
	 * interceptors.
	 * @param interceptors the interceptors to set
	 * @return a new builder instance
	 * @see #additionalInterceptors(ClientInterceptor...)
	 */
	public WebServiceTemplateBuilder interceptors(ClientInterceptor... interceptors) {
		Assert.notNull(interceptors, 'Interceptors must not be null');
		return interceptors(Arrays.asList(interceptors));
	}
	/**
	 * Set the {@link ClientInterceptor ClientInterceptors} that should be used with the
	 * {@link WebServiceTemplate}. Setting this value will replace any previously defined
	 * interceptors.
	 * @param interceptors the interceptors to set
	 * @return a new builder instance
	 * @see #additionalInterceptors(Collection)
	 */
	public WebServiceTemplateBuilder interceptors(Collection<? extends ClientInterceptor> interceptors) {
		Assert.notNull(interceptors, 'Interceptors must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				append(Collections.<ClientInterceptor>emptySet(), interceptors), this.internalCustomizers,
				this.customizers, this.messageSenders, this.marshaller, this.unmarshaller, this.destinationProvider,
				this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Add additional {@link ClientInterceptor ClientInterceptors} that should be used
	 * with the {@link WebServiceTemplate}.
	 * @param interceptors the interceptors to add
	 * @return a new builder instance
	 * @see #interceptors(ClientInterceptor...)
	 */
	public WebServiceTemplateBuilder additionalInterceptors(ClientInterceptor... interceptors) {
		Assert.notNull(interceptors, 'Interceptors must not be null');
		return additionalInterceptors(Arrays.asList(interceptors));
	}
	/**
	 * Add additional {@link ClientInterceptor ClientInterceptors} that should be used
	 * with the {@link WebServiceTemplate}.
	 * @param interceptors the interceptors to add
	 * @return a new builder instance
	 * @see #interceptors(Collection)
	 */
	public WebServiceTemplateBuilder additionalInterceptors(Collection<? extends ClientInterceptor> interceptors) {
		Assert.notNull(interceptors, 'Interceptors must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				append(this.interceptors, interceptors), this.internalCustomizers, this.customizers,
				this.messageSenders, this.marshaller, this.unmarshaller, this.destinationProvider,
				this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Set {@link WebServiceTemplateCustomizer WebServiceTemplateCustomizers} that should
	 * be applied to the {@link WebServiceTemplate}. Customizers are applied in the order
	 * that they were added after builder configuration has been applied. Setting this
	 * value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(WebServiceTemplateCustomizer...)
	 */
	public WebServiceTemplateBuilder customizers(WebServiceTemplateCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return customizers(Arrays.asList(customizers));
	}
	/**
	 * Set {@link WebServiceTemplateCustomizer WebServiceTemplateCustomizers} that should
	 * be applied to the {@link WebServiceTemplate}. Customizers are applied in the order
	 * that they were added after builder configuration has been applied. Setting this
	 * value will replace any previously configured customizers.
	 * @param customizers the customizers to set
	 * @return a new builder instance
	 * @see #additionalCustomizers(Collection)
	 */
	public WebServiceTemplateBuilder customizers(Collection<? extends WebServiceTemplateCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers,
				append(Collections.<WebServiceTemplateCustomizer>emptySet(), customizers), this.messageSenders,
				this.marshaller, this.unmarshaller, this.destinationProvider, this.transformerFactoryClass,
				this.messageFactory);
	}
	/**
	 * Add additional {@link WebServiceTemplateCustomizer WebServiceTemplateCustomizers}
	 * that should be applied to the {@link WebServiceTemplate}. Customizers are applied
	 * in the order that they were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(WebServiceTemplateCustomizer...)
	 */
	public WebServiceTemplateBuilder additionalCustomizers(WebServiceTemplateCustomizer... customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return additionalCustomizers(Arrays.asList(customizers));
	}
	/**
	 * Add additional {@link WebServiceTemplateCustomizer WebServiceTemplateCustomizers}
	 * that should be applied to the {@link WebServiceTemplate}. Customizers are applied
	 * in the order that they were added after builder configuration has been applied.
	 * @param customizers the customizers to add
	 * @return a new builder instance
	 * @see #customizers(Collection)
	 */
	public WebServiceTemplateBuilder additionalCustomizers(
			Collection<? extends WebServiceTemplateCustomizer> customizers) {
		Assert.notNull(customizers, 'Customizers must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, append(this.customizers, customizers), this.messageSenders,
				this.marshaller, this.unmarshaller, this.destinationProvider, this.transformerFactoryClass,
				this.messageFactory);
	}
	/**
	 * Indicates whether the connection should be checked for fault indicators
	 * ({@code true}), or whether we should rely on the message only ({@code false}).
	 * @param checkConnectionForFault whether to check for fault indicators
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setCheckConnectionForFault(boolean)
	 */
	public WebServiceTemplateBuilder setCheckConnectionForFault(boolean checkConnectionForFault) {
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors,
				append(this.internalCustomizers, new CheckConnectionFaultCustomizer(checkConnectionForFault)),
				this.customizers, this.messageSenders, this.marshaller, this.unmarshaller, this.destinationProvider,
				this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Indicates whether the connection should be checked for error indicators
	 * ({@code true}), or whether these should be ignored ({@code false}).
	 * @param checkConnectionForError whether to check for error indicators
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setCheckConnectionForError(boolean)
	 */
	public WebServiceTemplateBuilder setCheckConnectionForError(boolean checkConnectionForError) {
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors,
				append(this.internalCustomizers, new CheckConnectionForErrorCustomizer(checkConnectionForError)),
				this.customizers, this.messageSenders, this.marshaller, this.unmarshaller, this.destinationProvider,
				this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Sets the {@link WebServiceMessageFactory} to use for creating messages.
	 * @param messageFactory the message factory to use for creating messages
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setMessageFactory(WebServiceMessageFactory)
	 */
	public WebServiceTemplateBuilder setWebServiceMessageFactory(WebServiceMessageFactory messageFactory) {
		Assert.notNull(messageFactory, 'MessageFactory must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, this.customizers, this.messageSenders, this.marshaller,
				this.unmarshaller, this.destinationProvider, this.transformerFactoryClass, messageFactory);
	}
	/**
	 * Set the {@link Unmarshaller} to use to deserialize messages.
	 * @param unmarshaller the message unmarshaller
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setUnmarshaller(Unmarshaller)
	 */
	public WebServiceTemplateBuilder setUnmarshaller(Unmarshaller unmarshaller) {
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, this.customizers, this.messageSenders, this.marshaller,
				unmarshaller, this.destinationProvider, this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Set the {@link Marshaller} to use to serialize messages.
	 * @param marshaller the message marshaller
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setMarshaller(Marshaller)
	 */
	public WebServiceTemplateBuilder setMarshaller(Marshaller marshaller) {
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, this.customizers, this.messageSenders, marshaller,
				this.unmarshaller, this.destinationProvider, this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Set the {@link FaultMessageResolver} to use.
	 * @param faultMessageResolver the fault message resolver to use
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setFaultMessageResolver(FaultMessageResolver)
	 */
	public WebServiceTemplateBuilder setFaultMessageResolver(FaultMessageResolver faultMessageResolver) {
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors,
				append(this.internalCustomizers, new FaultMessageResolverCustomizer(faultMessageResolver)),
				this.customizers, this.messageSenders, this.marshaller, this.unmarshaller, this.destinationProvider,
				this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Set the {@link TransformerFactory} implementation to use.
	 * @param transformerFactoryClass the transformer factory implementation to use
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setTransformerFactoryClass(Class)
	 */
	public WebServiceTemplateBuilder setTransformerFactoryClass(
			Class<? extends TransformerFactory> transformerFactoryClass) {
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, this.customizers, this.messageSenders, this.marshaller,
				this.unmarshaller, this.destinationProvider, transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Set the default URI to be used on operations that do not have a URI parameter.
	 * Typically, either this property is set, or
	 * {@link #setDestinationProvider(DestinationProvider)}, but not both.
	 * @param defaultUri the destination provider URI to be used on operations that do not
	 * have a URI parameter.
	 * @return a new builder instance.
	 * @see #setDestinationProvider(DestinationProvider)
	 */
	public WebServiceTemplateBuilder setDefaultUri(String defaultUri) {
		Assert.hasText(defaultUri, 'DefaultUri must not be empty');
		return setDestinationProvider(() -> URI.create(defaultUri));
	}
	/**
	 * Set the {@link DestinationProvider} to use. Typically, either this property is set,
	 * or {@link #setDefaultUri(String)}, but not both.
	 * @param destinationProvider the destination provider to be used on operations that
	 * do not have a URI parameter.
	 * @return a new builder instance.
	 * @see WebServiceTemplate#setDestinationProvider(DestinationProvider)
	 */
	public WebServiceTemplateBuilder setDestinationProvider(DestinationProvider destinationProvider) {
		Assert.notNull(destinationProvider, 'DestinationProvider must not be null');
		return new WebServiceTemplateBuilder(this.httpMessageSenderFactory, this.detectHttpMessageSender,
				this.interceptors, this.internalCustomizers, this.customizers, this.messageSenders, this.marshaller,
				this.unmarshaller, destinationProvider, this.transformerFactoryClass, this.messageFactory);
	}
	/**
	 * Build a new {@link WebServiceTemplate} instance and configure it using this
	 * builder.
	 * @return a configured {@link WebServiceTemplate} instance.
	 * @see #build(Class)
	 * @see #configure(WebServiceTemplate)
	 */
	public WebServiceTemplate build() {
		return configure(new WebServiceTemplate());
	}
	/**
	 * Build a new {@link WebServiceTemplate} instance of the specified type and configure
	 * it using this builder.
	 * @param <T> the type of web service template
	 * @param webServiceTemplateClass the template type to create
	 * @return a configured {@link WebServiceTemplate} instance.
	 * @see WebServiceTemplateBuilder#build()
	 * @see #configure(WebServiceTemplate)
	 */
	public <T extends WebServiceTemplate> T build(Class<T> webServiceTemplateClass) {
		Assert.notNull(webServiceTemplateClass, 'WebServiceTemplateClass must not be null');
		return configure(BeanUtils.instantiateClass(webServiceTemplateClass));
	}
	/**
	 * Configure the provided {@link WebServiceTemplate} instance using this builder.
	 * @param <T> the type of web service template
	 * @param webServiceTemplate the {@link WebServiceTemplate} to configure
	 * @return the web service template instance
	 * @see #build()
	 * @see #build(Class)
	 */
	public <T extends WebServiceTemplate> T configure(T webServiceTemplate) {
		Assert.notNull(webServiceTemplate, 'WebServiceTemplate must not be null');
		configureMessageSenders(webServiceTemplate);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		applyCustomizers(webServiceTemplate, this.internalCustomizers);
		map.from(this.marshaller).to(webServiceTemplate::setMarshaller);
		map.from(this.unmarshaller).to(webServiceTemplate::setUnmarshaller);
		map.from(this.destinationProvider).to(webServiceTemplate::setDestinationProvider);
		map.from(this.transformerFactoryClass).to(webServiceTemplate::setTransformerFactoryClass);
		map.from(this.messageFactory).to(webServiceTemplate::setMessageFactory);
		if (!CollectionUtils.isEmpty(this.interceptors)) {
			Set<ClientInterceptor> merged = new LinkedHashSet<>(this.interceptors);
			if (webServiceTemplate.getInterceptors() != null) {
				merged.addAll(Arrays.asList(webServiceTemplate.getInterceptors()));
			}
			webServiceTemplate.setInterceptors(merged.toArray(new ClientInterceptor[0]));
		}
		applyCustomizers(webServiceTemplate, this.customizers);
		return webServiceTemplate;
	}
	private void applyCustomizers(WebServiceTemplate webServiceTemplate,
			Set<WebServiceTemplateCustomizer> customizers) {
		if (!CollectionUtils.isEmpty(customizers)) {
			for (WebServiceTemplateCustomizer customizer : customizers) {
				customizer.customize(webServiceTemplate);
			}
		}
	}
	private <T extends WebServiceTemplate> void configureMessageSenders(T webServiceTemplate) {
		if (this.messageSenders.isOnlyAdditional()
				&& (this.httpMessageSenderFactory != null || this.detectHttpMessageSender)) {
			WebServiceMessageSenderFactory httpMessageSenderFactory = (this.httpMessageSenderFactory != null)
					? this.httpMessageSenderFactory : WebServiceMessageSenderFactory.http();
			Set<WebServiceMessageSender> merged = append(this.messageSenders.getMessageSenders(),
					httpMessageSenderFactory.getWebServiceMessageSender());
			webServiceTemplate.setMessageSenders(merged.toArray(new WebServiceMessageSender[0]));
		}
		else if (!CollectionUtils.isEmpty(this.messageSenders.getMessageSenders())) {
			webServiceTemplate
				.setMessageSenders(this.messageSenders.getMessageSenders().toArray(new WebServiceMessageSender[0]));
		}
	}
	private <T> Set<T> append(Set<T> set, T addition) {
		return append(set, Collections.singleton(addition));
	}
	private static <T> Set<T> append(Set<T> set, Collection<? extends T> additions) {
		Set<T> result = new LinkedHashSet<>((set != null) ? set : Collections.emptySet());
		result.addAll((additions != null) ? additions : Collections.emptyList());
		return Collections.unmodifiableSet(result);
	}
	/**
	 * Collect user-defined {@link WebServiceMessageSender} and whether only additional
	 * message senders were added or not.
	 */
	private static final class WebServiceMessageSenders {
		private final boolean onlyAdditional;
		private final Set<WebServiceMessageSender> messageSenders;
		private WebServiceMessageSenders() {
			this(true, Collections.emptySet());
		}
		private WebServiceMessageSenders(boolean onlyAdditional, Set<WebServiceMessageSender> messageSenders) {
			this.onlyAdditional = onlyAdditional;
			this.messageSenders = messageSenders;
		}
		boolean isOnlyAdditional() {
			return this.onlyAdditional;
		}
		Set<WebServiceMessageSender> getMessageSenders() {
			return this.messageSenders;
		}
		WebServiceMessageSenders set(Collection<? extends WebServiceMessageSender> messageSenders) {
			return new WebServiceMessageSenders(false, new LinkedHashSet<>(messageSenders));
		}
		WebServiceMessageSenders add(Collection<? extends WebServiceMessageSender> messageSenders) {
			return new WebServiceMessageSenders(this.onlyAdditional, append(this.messageSenders, messageSenders));
		}
	}
	/**
	 * {@link WebServiceTemplateCustomizer} to set
	 * {@link WebServiceTemplate#setCheckConnectionForFault(boolean)
	 * checkConnectionForFault}.
	 */
	private static final class CheckConnectionFaultCustomizer implements WebServiceTemplateCustomizer {
		private final boolean checkConnectionFault;
		private CheckConnectionFaultCustomizer(boolean checkConnectionFault) {
			this.checkConnectionFault = checkConnectionFault;
		}
		@Override
		public void customize(WebServiceTemplate webServiceTemplate) {
			webServiceTemplate.setCheckConnectionForFault(this.checkConnectionFault);
		}
	}
	/**
	 * {@link WebServiceTemplateCustomizer} to set
	 * {@link WebServiceTemplate#setCheckConnectionForError(boolean)
	 * checkConnectionForError}.
	 */
	private static final class CheckConnectionForErrorCustomizer implements WebServiceTemplateCustomizer {
		private final boolean checkConnectionForError;
		private CheckConnectionForErrorCustomizer(boolean checkConnectionForError) {
			this.checkConnectionForError = checkConnectionForError;
		}
		@Override
		public void customize(WebServiceTemplate webServiceTemplate) {
			webServiceTemplate.setCheckConnectionForError(this.checkConnectionForError);
		}
	}
	/**
	 * {@link WebServiceTemplateCustomizer} to set
	 * {@link WebServiceTemplate#setFaultMessageResolver(FaultMessageResolver)
	 * faultMessageResolver}.
	 */
	private static final class FaultMessageResolverCustomizer implements WebServiceTemplateCustomizer {
		private final FaultMessageResolver faultMessageResolver;
		private FaultMessageResolverCustomizer(FaultMessageResolver faultMessageResolver) {
			this.faultMessageResolver = faultMessageResolver;
		}
		@Override
		public void customize(WebServiceTemplate webServiceTemplate) {
			webServiceTemplate.setFaultMessageResolver(this.faultMessageResolver);
		}
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@FunctionalInterface
public interface WebServiceMessageSenderFactory {
	/**
	 * Return a new {@link WebServiceMessageSender} instance.
	 * @return the web service message sender
	 */
	WebServiceMessageSender getWebServiceMessageSender();
	/**
	 * Returns a factory that will create a {@link ClientHttpRequestMessageSender} backed
	 * by a detected {@link ClientHttpRequestFactory}.
	 * @return a new {@link WebServiceMessageSenderFactory}
	 */
	static WebServiceMessageSenderFactory http() {
		return http(ClientHttpRequestFactoryBuilder.detect(), null);
	}
	/**
	 * Returns a factory that will create a {@link ClientHttpRequestMessageSender} backed
	 * by a detected {@link ClientHttpRequestFactory}.
	 * @param requestFactorySettings the setting to apply
	 * @return a new {@link WebServiceMessageSenderFactory}
	 */
	static WebServiceMessageSenderFactory http(ClientHttpRequestFactorySettings requestFactorySettings) {
		return http(ClientHttpRequestFactoryBuilder.detect(), requestFactorySettings);
	}
	/**
	 * Returns a factory that will create a {@link ClientHttpRequestMessageSender} backed
	 * by a {@link ClientHttpRequestFactory} created from the given
	 * {@link ClientHttpRequestFactoryBuilder}.
	 * @param requestFactoryBuilder the request factory builder to use
	 * @param requestFactorySettings the settings to apply
	 * @return a new {@link WebServiceMessageSenderFactory}
	 */
	static WebServiceMessageSenderFactory http(ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder,
			ClientHttpRequestFactorySettings requestFactorySettings) {
		Assert.notNull(requestFactoryBuilder, '"requestFactoryBuilder" must not be null');
		return () -> new ClientHttpRequestMessageSender(requestFactoryBuilder.build(requestFactorySettings));
	}
}
/*
/**
package org.springframework.boot.webservices.client;
/*
package org.springframework.boot;
/**
class ClearCachesApplicationListener implements ApplicationListener<ContextRefreshedEvent> {
	@Override
	public void onApplicationEvent(ContextRefreshedEvent event) {
		ReflectionUtils.clearCache();
		clearClassLoaderCaches(Thread.currentThread().getContextClassLoader());
	}
	private void clearClassLoaderCaches(ClassLoader classLoader) {
		if (classLoader == null) {
			return;
		}
		try {
			Method clearCacheMethod = classLoader.getClass().getDeclaredMethod('clearCache');
			clearCacheMethod.invoke(classLoader);
		}
		catch (Exception ex) {
			// Ignore
		}
		clearClassLoaderCaches(classLoader.getParent());
	}
}
/*
package org.springframework.boot.jdbc;
/**
@FunctionalInterface
public interface XADataSourceWrapper {
	/**
	 * Wrap the specific {@link XADataSource} and enroll it with a JTA
	 * {@link TransactionManager}.
	 * @param dataSource the data source to wrap
	 * @return the wrapped data source
	 * @throws Exception if the data source cannot be wrapped
	 */
	DataSource wrapDataSource(XADataSource dataSource) throws Exception;
}
/*
package org.springframework.boot.jdbc;
/**
@FunctionalInterface
public interface SchemaManagementProvider {
	/**
	 * Return the {@link SchemaManagement} for the specified {@link DataSource}.
	 * @param dataSource the dataSource to handle
	 * @return the {@link SchemaManagement} for the {@link DataSource}.
	 */
	SchemaManagement getSchemaManagement(DataSource dataSource);
}
/*
package org.springframework.boot.jdbc;
/**
class SpringJdbcDependsOnDatabaseInitializationDetector
		extends AbstractBeansOfTypeDependsOnDatabaseInitializationDetector {
	@Override
	protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
		return Set.of(JdbcClient.class, JdbcOperations.class, NamedParameterJdbcOperations.class);
	}
}
/*
package org.springframework.boot.jdbc;
/**
public final class DataSourceUnwrapper {
	private static final boolean DELEGATING_DATA_SOURCE_PRESENT = ClassUtils.isPresent(
			'org.springframework.jdbc.datasource.DelegatingDataSource', DataSourceUnwrapper.class.getClassLoader());
	private DataSourceUnwrapper() {
	}
	/**
	 * Return an object that implements the given {@code target} type, unwrapping delegate
	 * or proxy if necessary using the specified {@code unwrapInterface}.
	 * @param dataSource the datasource to handle
	 * @param unwrapInterface the interface that the target type must implement
	 * @param target the type that the result must implement
	 * @param <I> the interface that the target type must implement
	 * @param <T> the target type
	 * @return an object that implements the target type or {@code null}
	 * @since 2.3.8
	 * @see Wrapper#unwrap(Class)
	 */
	public static <I, T extends I> T unwrap(DataSource dataSource, Class<I> unwrapInterface, Class<T> target) {
		if (target.isInstance(dataSource)) {
			return target.cast(dataSource);
		}
		I unwrapped = safeUnwrap(dataSource, unwrapInterface);
		if (unwrapped != null && unwrapInterface.isAssignableFrom(target)) {
			return target.cast(unwrapped);
		}
		if (DELEGATING_DATA_SOURCE_PRESENT) {
			DataSource targetDataSource = DelegatingDataSourceUnwrapper.getTargetDataSource(dataSource);
			if (targetDataSource != null) {
				return unwrap(targetDataSource, unwrapInterface, target);
			}
		}
		if (AopUtils.isAopProxy(dataSource)) {
			Object proxyTarget = AopProxyUtils.getSingletonTarget(dataSource);
			if (proxyTarget instanceof DataSource proxyDataSource) {
				return unwrap(proxyDataSource, unwrapInterface, target);
			}
		}
		return null;
	}
	/**
	 * Return an object that implements the given {@code target} type, unwrapping delegate
	 * or proxy if necessary. Consider using {@link #unwrap(DataSource, Class, Class)} as
	 * {@link Wrapper#unwrap(Class) unwrapping} won"t be considered if {@code target} is
	 * not an interface.
	 * @param dataSource the datasource to handle
	 * @param target the type that the result must implement
	 * @param <T> the target type
	 * @return an object that implements the target type or {@code null}
	 */
	public static <T> T unwrap(DataSource dataSource, Class<T> target) {
		return unwrap(dataSource, target, target);
	}
	private static <S> S safeUnwrap(Wrapper wrapper, Class<S> target) {
		try {
			if (target.isInterface() && wrapper.isWrapperFor(target)) {
				return wrapper.unwrap(target);
			}
		}
		catch (Exception ex) {
			// Continue
		}
		return null;
	}
	private static final class DelegatingDataSourceUnwrapper {
		private static DataSource getTargetDataSource(DataSource dataSource) {
			if (dataSource instanceof DelegatingDataSource delegatingDataSource) {
				return delegatingDataSource.getTargetDataSource();
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.jdbc;
/**
public class HikariCheckpointRestoreLifecycle implements Lifecycle {
	private static final Log logger = LogFactory.getLog(HikariCheckpointRestoreLifecycle.class);
	private static final Field CLOSE_CONNECTION_EXECUTOR;
	static {
		Field closeConnectionExecutor = ReflectionUtils.findField(HikariPool.class, 'closeConnectionExecutor');
		Assert.notNull(closeConnectionExecutor, 'Unable to locate closeConnectionExecutor for HikariPool');
		Assert.isAssignable(ThreadPoolExecutor.class, closeConnectionExecutor.getType(),
				'Expected ThreadPoolExecutor for closeConnectionExecutor but found %s'
					.formatted(closeConnectionExecutor.getType()));
		ReflectionUtils.makeAccessible(closeConnectionExecutor);
		CLOSE_CONNECTION_EXECUTOR = closeConnectionExecutor;
	}
	private final Function<HikariPool, Boolean> hasOpenConnections;
	private final HikariDataSource dataSource;
	/**
	 * Creates a new {@code HikariCheckpointRestoreLifecycle} that will allow the given
	 * {@code dataSource} to participate in checkpoint-restore. The {@code dataSource} is
	 * {@link DataSourceUnwrapper#unwrap unwrapped} to a {@link HikariDataSource}. If such
	 * unwrapping is not possible, the lifecycle will have no effect.
	 * @param dataSource the checkpoint-restore participant
	 */
	public HikariCheckpointRestoreLifecycle(DataSource dataSource) {
		this.dataSource = DataSourceUnwrapper.unwrap(dataSource, HikariConfigMXBean.class, HikariDataSource.class);
		this.hasOpenConnections = (pool) -> {
			ThreadPoolExecutor closeConnectionExecutor = (ThreadPoolExecutor) ReflectionUtils
				.getField(CLOSE_CONNECTION_EXECUTOR, pool);
			Assert.notNull(closeConnectionExecutor, 'CloseConnectionExecutor was null');
			return closeConnectionExecutor.getActiveCount() > 0;
		};
	}
	@Override
	public void start() {
		if (this.dataSource == null || this.dataSource.isRunning()) {
			return;
		}
		Assert.state(!this.dataSource.isClosed(), 'DataSource has been closed and cannot be restarted');
		if (this.dataSource.isAllowPoolSuspension()) {
			logger.info('Resuming Hikari pool');
			this.dataSource.getHikariPoolMXBean().resumePool();
		}
	}
	@Override
	public void stop() {
		if (this.dataSource == null || !this.dataSource.isRunning()) {
			return;
		}
		if (this.dataSource.isAllowPoolSuspension()) {
			logger.info('Suspending Hikari pool');
			this.dataSource.getHikariPoolMXBean().suspendPool();
		}
		closeConnections(Duration.ofMillis(this.dataSource.getConnectionTimeout() + 250));
	}
	private void closeConnections(Duration shutdownTimeout) {
		logger.info('Evicting Hikari connections');
		this.dataSource.getHikariPoolMXBean().softEvictConnections();
		logger.debug('Waiting for Hikari connections to be closed');
		CompletableFuture<Void> allConnectionsClosed = CompletableFuture.runAsync(this::waitForConnectionsToClose);
		try {
			allConnectionsClosed.get(shutdownTimeout.toMillis(), TimeUnit.MILLISECONDS);
			logger.debug('Hikari connections closed');
		}
		catch (InterruptedException ex) {
			logger.warn('Interrupted while waiting for connections to be closed', ex);
			Thread.currentThread().interrupt();
		}
		catch (TimeoutException ex) {
			logger.warn(LogMessage.format('Hikari connections could not be closed within %s', shutdownTimeout), ex);
		}
		catch (ExecutionException ex) {
			throw new RuntimeException('Failed to close Hikari connections', ex);
		}
	}
	private void waitForConnectionsToClose() {
		while (this.hasOpenConnections.apply((HikariPool) this.dataSource.getHikariPoolMXBean())) {
			try {
				TimeUnit.MILLISECONDS.sleep(50);
			}
			catch (InterruptedException ex) {
				logger.error('Interrupted while waiting for datasource connections to be closed', ex);
				Thread.currentThread().interrupt();
			}
		}
	}
	@Override
	public boolean isRunning() {
		return this.dataSource != null && this.dataSource.isRunning();
	}
}
/*
package org.springframework.boot.jdbc;
/**
public enum EmbeddedDatabaseConnection {
	/**
	 * No Connection.
	 */
	NONE(null),
	/**
	 * H2 Database Connection.
	 */
	H2('jdbc:h2:mem:%s;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE'),
	/**
	 * Derby Database Connection.
	 */
	DERBY('jdbc:derby:memory:%s;create=true'),
	/**
	 * HSQL Database Connection.
	 * @since 2.4.0
	 */
	HSQLDB('org.hsqldb.jdbcDriver', 'jdbc:hsqldb:mem:%s');
	private final String alternativeDriverClass;
	private final String url;
	EmbeddedDatabaseConnection(String url) {
		this(null, url);
	}
	EmbeddedDatabaseConnection(String fallbackDriverClass, String url) {
		this.alternativeDriverClass = fallbackDriverClass;
		this.url = url;
	}
	/**
	 * Returns the driver class name.
	 * @return the driver class name
	 */
	public String getDriverClassName() {
		// See https://github.com/spring-projects/spring-boot/issues/32865
		return switch (this) {
			case NONE -> null;
			case H2 -> DatabaseDriver.H2.getDriverClassName();
			case DERBY -> DatabaseDriver.DERBY.getDriverClassName();
			case HSQLDB -> DatabaseDriver.HSQLDB.getDriverClassName();
		};
	}
	/**
	 * Returns the {@link EmbeddedDatabaseType} for the connection.
	 * @return the database type
	 */
	public EmbeddedDatabaseType getType() {
		// See https://github.com/spring-projects/spring-boot/issues/32865
		return switch (this) {
			case NONE -> null;
			case H2 -> EmbeddedDatabaseType.H2;
			case DERBY -> EmbeddedDatabaseType.DERBY;
			case HSQLDB -> EmbeddedDatabaseType.HSQL;
		};
	}
	/**
	 * Returns the URL for the connection using the specified {@code databaseName}.
	 * @param databaseName the name of the database
	 * @return the connection URL
	 */
	public String getUrl(String databaseName) {
		Assert.hasText(databaseName, 'DatabaseName must not be empty');
		return (this.url != null) ? String.format(this.url, databaseName) : null;
	}
	boolean isEmbeddedUrl(String url) {
		// See https://github.com/spring-projects/spring-boot/issues/32865
		return switch (this) {
			case NONE -> false;
			case H2 -> url.contains(':h2:mem');
			case DERBY -> true;
			case HSQLDB -> url.contains(':hsqldb:mem:');
		};
	}
	boolean isDriverCompatible(String driverClass) {
		return (driverClass != null
				&& (driverClass.equals(getDriverClassName()) || driverClass.equals(this.alternativeDriverClass)));
	}
	/**
	 * Convenience method to determine if a given driver class name and url represent an
	 * embedded database type.
	 * @param driverClass the driver class
	 * @param url the jdbc url (can be {@code null})
	 * @return true if the driver class and url refer to an embedded database
	 * @since 2.4.0
	 */
	public static boolean isEmbedded(String driverClass, String url) {
		if (driverClass == null) {
			return false;
		}
		EmbeddedDatabaseConnection connection = getEmbeddedDatabaseConnection(driverClass);
		if (connection == NONE) {
			return false;
		}
		return (url == null || connection.isEmbeddedUrl(url));
	}
	private static EmbeddedDatabaseConnection getEmbeddedDatabaseConnection(String driverClass) {
		return Stream.of(H2, HSQLDB, DERBY)
			.filter((connection) -> connection.isDriverCompatible(driverClass))
			.findFirst()
			.orElse(NONE);
	}
	/**
	 * Convenience method to determine if a given data source represents an embedded
	 * database type.
	 * @param dataSource the data source to interrogate
	 * @return true if the data source is one of the embedded types
	 */
	public static boolean isEmbedded(DataSource dataSource) {
		try {
			return new JdbcTemplate(dataSource).execute(new IsEmbedded());
		}
		catch (DataAccessException ex) {
			// Could not connect, which means it"s not embedded
			return false;
		}
	}
	/**
	 * Returns the most suitable {@link EmbeddedDatabaseConnection} for the given class
	 * loader.
	 * @param classLoader the class loader used to check for classes
	 * @return an {@link EmbeddedDatabaseConnection} or {@link #NONE}.
	 */
	public static EmbeddedDatabaseConnection get(ClassLoader classLoader) {
		for (EmbeddedDatabaseConnection candidate : EmbeddedDatabaseConnection.values()) {
			if (candidate != NONE && ClassUtils.isPresent(candidate.getDriverClassName(), classLoader)) {
				return candidate;
			}
		}
		return NONE;
	}
	/**
	 * {@link ConnectionCallback} to determine if a connection is embedded.
	 */
	private static final class IsEmbedded implements ConnectionCallback<Boolean> {
		@Override
		public Boolean doInConnection(Connection connection) throws SQLException, DataAccessException {
			DatabaseMetaData metaData = connection.getMetaData();
			String productName = metaData.getDatabaseProductName();
			if (productName == null) {
				return false;
			}
			productName = productName.toUpperCase(Locale.ENGLISH);
			EmbeddedDatabaseConnection[] candidates = EmbeddedDatabaseConnection.values();
			for (EmbeddedDatabaseConnection candidate : candidates) {
				if (candidate != NONE && productName.contains(candidate.getType().name())) {
					String url = metaData.getURL();
					return (url == null || candidate.isEmbeddedUrl(url));
				}
			}
			return false;
		}
	}
}
/*
package org.springframework.boot.jdbc;
/**
public enum SchemaManagement {
	/**
	 * The schema is managed and will be created at the appropriate time.
	 */
	MANAGED,
	/**
	 * The schema is not managed.
	 */
	UNMANAGED
}
/*
package org.springframework.boot.jdbc;
/**
public enum DatabaseDriver {
	/**
	 * Unknown type.
	 */
	UNKNOWN(null, null),
	/**
	 * Apache Derby.
	 */
	DERBY('Apache Derby', 'org.apache.derby.jdbc.EmbeddedDriver', 'org.apache.derby.jdbc.EmbeddedXADataSource',
			'SELECT 1 FROM SYSIBM.SYSDUMMY1'),
	/**
	 * H2.
	 */
	H2('H2', 'org.h2.Driver', 'org.h2.jdbcx.JdbcDataSource', 'SELECT 1'),
	/**
	 * HyperSQL DataBase.
	 */
	HSQLDB('HSQL Database Engine', 'org.hsqldb.jdbc.JDBCDriver', 'org.hsqldb.jdbc.pool.JDBCXADataSource',
			'SELECT COUNT(*) FROM INFORMATION_SCHEMA.SYSTEM_USERS'),
	/**
	 * SQLite.
	 */
	SQLITE('SQLite', 'org.sqlite.JDBC'),
	/**
	 * MySQL.
	 */
	MYSQL('MySQL', 'com.mysql.cj.jdbc.Driver', 'com.mysql.cj.jdbc.MysqlXADataSource', '/* ping */ SELECT 1'),
	/**
	 * Maria DB.
	 */
	MARIADB('MariaDB', 'org.mariadb.jdbc.Driver', 'org.mariadb.jdbc.MariaDbDataSource', 'SELECT 1'),
	/**
	 * Oracle.
	 */
	ORACLE('Oracle', 'oracle.jdbc.OracleDriver', 'oracle.jdbc.xa.client.OracleXADataSource',
			'SELECT "Hello" from DUAL'),
	/**
	 * Postgres.
	 */
	POSTGRESQL('PostgreSQL', 'org.postgresql.Driver', 'org.postgresql.xa.PGXADataSource', 'SELECT 1'),
	/**
	 * Amazon Redshift.
	 * @since 2.2.0
	 */
	REDSHIFT('Redshift', 'com.amazon.redshift.jdbc.Driver', null, 'SELECT 1'),
	/**
	 * HANA - SAP HANA Database - HDB.
	 * @since 2.1.0
	 */
	HANA('HDB', 'com.sap.db.jdbc.Driver', 'com.sap.db.jdbcext.XADataSourceSAP', 'SELECT 1 FROM SYS.DUMMY') {
		@Override
		protected Collection<String> getUrlPrefixes() {
			return Collections.singleton('sap');
		}
	},
	/**
	 * jTDS. As it can be used for several databases, there isn"t a single product name we
	 * could rely on.
	 */
	JTDS(null, 'net.sourceforge.jtds.jdbc.Driver'),
	/**
	 * SQL Server.
	 */
	SQLSERVER('Microsoft SQL Server', 'com.microsoft.sqlserver.jdbc.SQLServerDriver',
			'com.microsoft.sqlserver.jdbc.SQLServerXADataSource', 'SELECT 1') {
		@Override
		protected boolean matchProductName(String productName) {
			return super.matchProductName(productName) || 'SQL SERVER'.equalsIgnoreCase(productName);
		}
	},
	/**
	 * Firebird.
	 */
	FIREBIRD('Firebird', 'org.firebirdsql.jdbc.FBDriver', 'org.firebirdsql.ds.FBXADataSource',
			'SELECT 1 FROM RDB$DATABASE') {
		@Override
		protected Collection<String> getUrlPrefixes() {
			return Arrays.asList('firebirdsql', 'firebird');
		}
		@Override
		protected boolean matchProductName(String productName) {
			return super.matchProductName(productName)
					|| productName.toLowerCase(Locale.ENGLISH).startsWith('firebird');
		}
	},
	/**
	 * DB2 Server.
	 */
	DB2('DB2', 'com.ibm.db2.jcc.DB2Driver', 'com.ibm.db2.jcc.DB2XADataSource', 'SELECT 1 FROM SYSIBM.SYSDUMMY1') {
		@Override
		protected boolean matchProductName(String productName) {
			return super.matchProductName(productName) || productName.toLowerCase(Locale.ENGLISH).startsWith('db2/');
		}
	},
	/**
	 * DB2 AS400 Server.
	 */
	DB2_AS400('DB2 UDB for AS/400', 'com.ibm.as400.access.AS400JDBCDriver',
			'com.ibm.as400.access.AS400JDBCXADataSource', 'SELECT 1 FROM SYSIBM.SYSDUMMY1') {
		@Override
		public String getId() {
			return 'db2';
		}
		@Override
		protected Collection<String> getUrlPrefixes() {
			return Collections.singleton('as400');
		}
		@Override
		protected boolean matchProductName(String productName) {
			return super.matchProductName(productName) || productName.toLowerCase(Locale.ENGLISH).contains('as/400');
		}
	},
	/**
	 * Teradata.
	 */
	TERADATA('Teradata', 'com.teradata.jdbc.TeraDriver'),
	/**
	 * Informix.
	 */
	INFORMIX('Informix Dynamic Server', 'com.informix.jdbc.IfxDriver', null, 'select count(*) from systables') {
		@Override
		protected Collection<String> getUrlPrefixes() {
			return Arrays.asList('informix-sqli', 'informix-direct');
		}
	},
	/**
	 * Apache Phoenix.
	 * @since 2.5.0
	 */
	PHOENIX('Apache Phoenix', 'org.apache.phoenix.jdbc.PhoenixDriver', null, 'SELECT 1 FROM SYSTEM.CATALOG LIMIT 1'),
	/**
	 * Testcontainers.
	 */
	TESTCONTAINERS(null, 'org.testcontainers.jdbc.ContainerDatabaseDriver') {
		@Override
		protected Collection<String> getUrlPrefixes() {
			return Collections.singleton('tc');
		}
	},
	/**
	 * ClickHouse.
	 * @since 3.4.0
	 */
	CLICKHOUSE('ClickHouse', 'com.clickhouse.jdbc.ClickHouseDriver', null, 'SELECT 1') {
		@Override
		protected Collection<String> getUrlPrefixes() {
			return Arrays.asList('ch', 'clickhouse');
		}
	};
	private final String productName;
	private final String driverClassName;
	private final String xaDataSourceClassName;
	private final String validationQuery;
	DatabaseDriver(String productName, String driverClassName) {
		this(productName, driverClassName, null);
	}
	DatabaseDriver(String productName, String driverClassName, String xaDataSourceClassName) {
		this(productName, driverClassName, xaDataSourceClassName, null);
	}
	DatabaseDriver(String productName, String driverClassName, String xaDataSourceClassName, String validationQuery) {
		this.productName = productName;
		this.driverClassName = driverClassName;
		this.xaDataSourceClassName = xaDataSourceClassName;
		this.validationQuery = validationQuery;
	}
	/**
	 * Return the identifier of this driver.
	 * @return the identifier
	 */
	public String getId() {
		return name().toLowerCase(Locale.ENGLISH);
	}
	/**
	 * Return the url prefixes of this driver.
	 * @return the url prefixes
	 */
	protected Collection<String> getUrlPrefixes() {
		return Collections.singleton(name().toLowerCase(Locale.ENGLISH));
	}
	protected boolean matchProductName(String productName) {
		return this.productName != null && this.productName.equalsIgnoreCase(productName);
	}
	/**
	 * Return the driver class name.
	 * @return the class name or {@code null}
	 */
	public String getDriverClassName() {
		return this.driverClassName;
	}
	/**
	 * Return the XA driver source class name.
	 * @return the class name or {@code null}
	 */
	public String getXaDataSourceClassName() {
		return this.xaDataSourceClassName;
	}
	/**
	 * Return the validation query.
	 * @return the validation query or {@code null}
	 */
	public String getValidationQuery() {
		return this.validationQuery;
	}
	/**
	 * Find a {@link DatabaseDriver} for the given URL.
	 * @param url the JDBC URL
	 * @return the database driver or {@link #UNKNOWN} if not found
	 */
	public static DatabaseDriver fromJdbcUrl(String url) {
		if (StringUtils.hasLength(url)) {
			Assert.isTrue(url.startsWith('jdbc'), 'URL must start with "jdbc"');
			String urlWithoutPrefix = url.substring('jdbc'.length()).toLowerCase(Locale.ENGLISH);
			for (DatabaseDriver driver : values()) {
				for (String urlPrefix : driver.getUrlPrefixes()) {
					String prefix = ':' + urlPrefix + ':';
					if (driver != UNKNOWN && urlWithoutPrefix.startsWith(prefix)) {
						return driver;
					}
				}
			}
		}
		return UNKNOWN;
	}
	/**
	 * Find a {@link DatabaseDriver} for the given product name.
	 * @param productName product name
	 * @return the database driver or {@link #UNKNOWN} if not found
	 */
	public static DatabaseDriver fromProductName(String productName) {
		if (StringUtils.hasLength(productName)) {
			for (DatabaseDriver candidate : values()) {
				if (candidate.matchProductName(productName)) {
					return candidate;
				}
			}
		}
		return UNKNOWN;
	}
}
/*
package org.springframework.boot.jdbc;
/**
class DataSourceBuilderRuntimeHints implements RuntimeHintsRegistrar {
	private static final List<String> TYPE_NAMES;
	static {
		List<String> typeNames = new ArrayList<>();
		typeNames.add('com.mchange.v2.c3p0.ComboPooledDataSource');
		typeNames.add('org.h2.jdbcx.JdbcDataSource');
		typeNames.add('com.zaxxer.hikari.HikariDataSource');
		typeNames.add('org.apache.commons.dbcp2.BasicDataSource');
		typeNames.add('oracle.jdbc.datasource.OracleDataSource');
		typeNames.add('oracle.ucp.jdbc.PoolDataSource');
		typeNames.add('org.postgresql.ds.PGSimpleDataSource');
		typeNames.add('org.springframework.jdbc.datasource.SimpleDriverDataSource');
		typeNames.add('org.apache.tomcat.jdbc.pool.DataSource');
		TYPE_NAMES = Collections.unmodifiableList(typeNames);
	}
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		for (String typeName : TYPE_NAMES) {
			hints.reflection()
				.registerTypeIfPresent(classLoader, typeName,
						(hint) -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
		}
	}
}
/*
package org.springframework.boot.jdbc;
/**
public final class DataSourceBuilder<T extends DataSource> {
	private final ClassLoader classLoader;
	private final Map<DataSourceProperty, String> values = new HashMap<>();
	private Class<T> type;
	private final DataSource deriveFrom;
	private DataSourceBuilder(ClassLoader classLoader) {
		this.classLoader = classLoader;
		this.deriveFrom = null;
	}
	@SuppressWarnings('unchecked')
	private DataSourceBuilder(T deriveFrom) {
		Assert.notNull(deriveFrom, 'DataSource must not be null');
		this.classLoader = deriveFrom.getClass().getClassLoader();
		this.type = (Class<T>) deriveFrom.getClass();
		this.deriveFrom = deriveFrom;
	}
	/**
	 * Set the {@link DataSource} type that should be built.
	 * @param <D> the datasource type
	 * @param type the datasource type
	 * @return this builder
	 */
	@SuppressWarnings('unchecked')
	public <D extends DataSource> DataSourceBuilder<D> type(Class<D> type) {
		this.type = (Class<T>) type;
		return (DataSourceBuilder<D>) this;
	}
	/**
	 * Set the URL that should be used when building the datasource.
	 * @param url the JDBC url
	 * @return this builder
	 */
	public DataSourceBuilder<T> url(String url) {
		set(DataSourceProperty.URL, url);
		return this;
	}
	/**
	 * Set the driver class name that should be used when building the datasource.
	 * @param driverClassName the driver class name
	 * @return this builder
	 */
	public DataSourceBuilder<T> driverClassName(String driverClassName) {
		set(DataSourceProperty.DRIVER_CLASS_NAME, driverClassName);
		return this;
	}
	/**
	 * Set the username that should be used when building the datasource.
	 * @param username the user name
	 * @return this builder
	 */
	public DataSourceBuilder<T> username(String username) {
		set(DataSourceProperty.USERNAME, username);
		return this;
	}
	/**
	 * Set the password that should be used when building the datasource.
	 * @param password the password
	 * @return this builder
	 */
	public DataSourceBuilder<T> password(String password) {
		set(DataSourceProperty.PASSWORD, password);
		return this;
	}
	private void set(DataSourceProperty property, String value) {
		this.values.put(property, value);
	}
	/**
	 * Return a newly built {@link DataSource} instance.
	 * @return the built datasource
	 */
	public T build() {
		DataSourceProperties<T> properties = DataSourceProperties.forType(this.classLoader, this.type);
		DataSourceProperties<DataSource> deriveFromProperties = getDeriveFromProperties();
		Class<? extends T> instanceType = (this.type != null) ? this.type : properties.getDataSourceInstanceType();
		T dataSource = BeanUtils.instantiateClass(instanceType);
		Set<DataSourceProperty> applied = new HashSet<>();
		for (DataSourceProperty property : DataSourceProperty.values()) {
			String value = this.values.get(property);
			if (value == null && deriveFromProperties != null && properties.canSet(property)) {
				value = deriveFromProperties.get(this.deriveFrom, property);
			}
			if (value != null) {
				properties.set(dataSource, property, value);
				applied.add(property);
			}
		}
		if (!applied.contains(DataSourceProperty.DRIVER_CLASS_NAME)
				&& properties.canSet(DataSourceProperty.DRIVER_CLASS_NAME)
				&& applied.contains(DataSourceProperty.URL)) {
			String url = properties.get(dataSource, DataSourceProperty.URL);
			DatabaseDriver driver = DatabaseDriver.fromJdbcUrl(url);
			properties.set(dataSource, DataSourceProperty.DRIVER_CLASS_NAME, driver.getDriverClassName());
		}
		return dataSource;
	}
	@SuppressWarnings('unchecked')
	private DataSourceProperties<DataSource> getDeriveFromProperties() {
		if (this.deriveFrom == null) {
			return null;
		}
		return DataSourceProperties.forType(this.classLoader, (Class<DataSource>) this.deriveFrom.getClass());
	}
	/**
	 * Create a new {@link DataSourceBuilder} instance.
	 * @return a new datasource builder instance
	 */
	public static DataSourceBuilder<?> create() {
		return create(null);
	}
	/**
	 * Create a new {@link DataSourceBuilder} instance.
	 * @param classLoader the classloader used to discover preferred settings
	 * @return a new {@link DataSource} builder instance
	 */
	public static DataSourceBuilder<?> create(ClassLoader classLoader) {
		return new DataSourceBuilder<>(classLoader);
	}
	/**
	 * Create a new {@link DataSourceBuilder} instance derived from the specified data
	 * source. The returned builder can be used to build the same type of
	 * {@link DataSource} with {@code username}, {@code password}, {@code url} and
	 * {@code driverClassName} properties copied from the original when not specifically
	 * set.
	 * @param dataSource the source {@link DataSource}
	 * @return a new {@link DataSource} builder
	 * @since 2.5.0
	 */
	public static DataSourceBuilder<?> derivedFrom(DataSource dataSource) {
		if (dataSource instanceof EmbeddedDatabase) {
			try {
				dataSource = dataSource.unwrap(DataSource.class);
			}
			catch (SQLException ex) {
				throw new IllegalStateException('Unable to unwrap embedded database', ex);
			}
		}
		return new DataSourceBuilder<>(unwrap(dataSource));
	}
	private static DataSource unwrap(DataSource dataSource) {
		try {
			while (dataSource.isWrapperFor(DataSource.class)) {
				DataSource unwrapped = dataSource.unwrap(DataSource.class);
				if (unwrapped == dataSource) {
					return unwrapped;
				}
				dataSource = unwrapped;
			}
		}
		catch (SQLException ex) {
			// Try to continue with the existing, potentially still wrapped, DataSource
		}
		return dataSource;
	}
	/**
	 * Find the {@link DataSource} type preferred for the given classloader.
	 * @param classLoader the classloader used to discover preferred settings
	 * @return the preferred {@link DataSource} type
	 */
	public static Class<? extends DataSource> findType(ClassLoader classLoader) {
		MappedDataSourceProperties<?> mappings = MappedDataSourceProperties.forType(classLoader, null);
		return (mappings != null) ? mappings.getDataSourceInstanceType() : null;
	}
	/**
	 * An individual DataSource property supported by the builder.
	 */
	private enum DataSourceProperty {
		URL(false, 'url', 'URL'),
		DRIVER_CLASS_NAME(true, 'driverClassName'),
		USERNAME(false, 'username', 'user'),
		PASSWORD(false, 'password');
		private final boolean optional;
		private final String[] names;
		DataSourceProperty(boolean optional, String... names) {
			this.optional = optional;
			this.names = names;
		}
		boolean isOptional() {
			return this.optional;
		}
		@Override
		public String toString() {
			return this.names[0];
		}
		Method findSetter(Class<?> type) {
			return findMethod('set', type, String.class);
		}
		Method findGetter(Class<?> type) {
			return findMethod('get', type);
		}
		private Method findMethod(String prefix, Class<?> type, Class<?>... paramTypes) {
			for (String name : this.names) {
				String candidate = prefix + StringUtils.capitalize(name);
				Method method = ReflectionUtils.findMethod(type, candidate, paramTypes);
				if (method != null) {
					return method;
				}
			}
			return null;
		}
	}
	private interface DataSourceProperties<T extends DataSource> {
		Class<? extends T> getDataSourceInstanceType();
		boolean canSet(DataSourceProperty property);
		void set(T dataSource, DataSourceProperty property, String value);
		String get(T dataSource, DataSourceProperty property);
		static <T extends DataSource> DataSourceProperties<T> forType(ClassLoader classLoader, Class<T> type) {
			MappedDataSourceProperties<T> mapped = MappedDataSourceProperties.forType(classLoader, type);
			return (mapped != null) ? mapped : new ReflectionDataSourceProperties<>(type);
		}
	}
	private static class MappedDataSourceProperties<T extends DataSource> implements DataSourceProperties<T> {
		private final Map<DataSourceProperty, MappedDataSourceProperty<T, ?>> mappedProperties = new HashMap<>();
		private final Class<T> dataSourceType;
		@SuppressWarnings('unchecked')
		MappedDataSourceProperties() {
			this.dataSourceType = (Class<T>) ResolvableType.forClass(MappedDataSourceProperties.class, getClass())
				.resolveGeneric();
		}
		@Override
		public Class<? extends T> getDataSourceInstanceType() {
			return this.dataSourceType;
		}
		protected void add(DataSourceProperty property, Getter<T, String> getter, Setter<T, String> setter) {
			add(property, String.class, getter, setter);
		}
		protected <V> void add(DataSourceProperty property, Class<V> type, Getter<T, V> getter, Setter<T, V> setter) {
			this.mappedProperties.put(property, new MappedDataSourceProperty<>(property, type, getter, setter));
		}
		@Override
		public boolean canSet(DataSourceProperty property) {
			return this.mappedProperties.containsKey(property);
		}
		@Override
		public void set(T dataSource, DataSourceProperty property, String value) {
			MappedDataSourceProperty<T, ?> mappedProperty = getMapping(property);
			if (mappedProperty != null) {
				mappedProperty.set(dataSource, value);
			}
		}
		@Override
		public String get(T dataSource, DataSourceProperty property) {
			MappedDataSourceProperty<T, ?> mappedProperty = getMapping(property);
			if (mappedProperty != null) {
				return mappedProperty.get(dataSource);
			}
			return null;
		}
		private MappedDataSourceProperty<T, ?> getMapping(DataSourceProperty property) {
			MappedDataSourceProperty<T, ?> mappedProperty = this.mappedProperties.get(property);
			UnsupportedDataSourcePropertyException.throwIf(!property.isOptional() && mappedProperty == null,
					() -> 'No mapping found for ' + property);
			return mappedProperty;
		}
		static <T extends DataSource> MappedDataSourceProperties<T> forType(ClassLoader classLoader, Class<T> type) {
			MappedDataSourceProperties<T> pooled = lookupPooled(classLoader, type);
			if (type == null || pooled != null) {
				return pooled;
			}
			return lookupBasic(classLoader, type);
		}
		private static <T extends DataSource> MappedDataSourceProperties<T> lookupPooled(ClassLoader classLoader,
				Class<T> type) {
			MappedDataSourceProperties<T> result = null;
			result = lookup(classLoader, type, result, 'com.zaxxer.hikari.HikariDataSource',
					HikariDataSourceProperties::new);
			result = lookup(classLoader, type, result, 'org.apache.tomcat.jdbc.pool.DataSource',
					TomcatPoolDataSourceProperties::new);
			result = lookup(classLoader, type, result, 'org.apache.commons.dbcp2.BasicDataSource',
					MappedDbcp2DataSource::new);
			result = lookup(classLoader, type, result, 'oracle.ucp.jdbc.PoolDataSourceImpl',
					OraclePoolDataSourceProperties::new, 'oracle.jdbc.OracleConnection');
			result = lookup(classLoader, type, result, 'com.mchange.v2.c3p0.ComboPooledDataSource',
					ComboPooledDataSourceProperties::new);
			return result;
		}
		private static <T extends DataSource> MappedDataSourceProperties<T> lookupBasic(ClassLoader classLoader,
				Class<T> dataSourceType) {
			MappedDataSourceProperties<T> result = null;
			result = lookup(classLoader, dataSourceType, result,
					'org.springframework.jdbc.datasource.SimpleDriverDataSource', SimpleDataSourceProperties::new);
			result = lookup(classLoader, dataSourceType, result, 'oracle.jdbc.datasource.OracleDataSource',
					OracleDataSourceProperties::new);
			result = lookup(classLoader, dataSourceType, result, 'org.h2.jdbcx.JdbcDataSource',
					H2DataSourceProperties::new);
			result = lookup(classLoader, dataSourceType, result, 'org.postgresql.ds.PGSimpleDataSource',
					PostgresDataSourceProperties::new);
			return result;
		}
		@SuppressWarnings('unchecked')
		private static <T extends DataSource> MappedDataSourceProperties<T> lookup(ClassLoader classLoader,
				Class<T> dataSourceType, MappedDataSourceProperties<T> existing, String dataSourceClassName,
				Supplier<MappedDataSourceProperties<?>> propertyMappingsSupplier, String... requiredClassNames) {
			if (existing != null || !allPresent(classLoader, dataSourceClassName, requiredClassNames)) {
				return existing;
			}
			MappedDataSourceProperties<?> propertyMappings = propertyMappingsSupplier.get();
			return (dataSourceType == null
					|| propertyMappings.getDataSourceInstanceType().isAssignableFrom(dataSourceType))
							? (MappedDataSourceProperties<T>) propertyMappings : null;
		}
		private static boolean allPresent(ClassLoader classLoader, String dataSourceClassName,
				String[] requiredClassNames) {
			boolean result = ClassUtils.isPresent(dataSourceClassName, classLoader);
			for (String requiredClassName : requiredClassNames) {
				result = result && ClassUtils.isPresent(requiredClassName, classLoader);
			}
			return result;
		}
	}
	private static class MappedDataSourceProperty<T extends DataSource, V> {
		private final DataSourceProperty property;
		private final Class<V> type;
		private final Getter<T, V> getter;
		private final Setter<T, V> setter;
		MappedDataSourceProperty(DataSourceProperty property, Class<V> type, Getter<T, V> getter, Setter<T, V> setter) {
			this.property = property;
			this.type = type;
			this.getter = getter;
			this.setter = setter;
		}
		void set(T dataSource, String value) {
			try {
				if (this.setter == null) {
					UnsupportedDataSourcePropertyException.throwIf(!this.property.isOptional(),
							() -> 'No setter mapped for "' + this.property + '" property');
					return;
				}
				this.setter.set(dataSource, convertFromString(value));
			}
			catch (SQLException ex) {
				throw new IllegalStateException(ex);
			}
		}
		String get(T dataSource) {
			try {
				if (this.getter == null) {
					UnsupportedDataSourcePropertyException.throwIf(!this.property.isOptional(),
							() -> 'No getter mapped for "' + this.property + '" property');
					return null;
				}
				return convertToString(this.getter.get(dataSource));
			}
			catch (SQLException ex) {
				throw new IllegalStateException(ex);
			}
		}
		@SuppressWarnings('unchecked')
		private V convertFromString(String value) {
			if (String.class.equals(this.type)) {
				return (V) value;
			}
			if (Class.class.equals(this.type)) {
				return (V) ClassUtils.resolveClassName(value, null);
			}
			throw new IllegalStateException('Unsupported value type ' + this.type);
		}
		private String convertToString(V value) {
			if (String.class.equals(this.type)) {
				return (String) value;
			}
			if (Class.class.equals(this.type)) {
				return ((Class<?>) value).getName();
			}
			throw new IllegalStateException('Unsupported value type ' + this.type);
		}
	}
	private static class ReflectionDataSourceProperties<T extends DataSource> implements DataSourceProperties<T> {
		private final Map<DataSourceProperty, Method> getters;
		private final Map<DataSourceProperty, Method> setters;
		private final Class<T> dataSourceType;
		ReflectionDataSourceProperties(Class<T> dataSourceType) {
			Assert.state(dataSourceType != null, 'No supported DataSource type found');
			Map<DataSourceProperty, Method> getters = new HashMap<>();
			Map<DataSourceProperty, Method> setters = new HashMap<>();
			for (DataSourceProperty property : DataSourceProperty.values()) {
				putIfNotNull(getters, property, property.findGetter(dataSourceType));
				putIfNotNull(setters, property, property.findSetter(dataSourceType));
			}
			this.dataSourceType = dataSourceType;
			this.getters = Collections.unmodifiableMap(getters);
			this.setters = Collections.unmodifiableMap(setters);
		}
		private void putIfNotNull(Map<DataSourceProperty, Method> map, DataSourceProperty property, Method method) {
			if (method != null) {
				map.put(property, method);
			}
		}
		@Override
		public Class<T> getDataSourceInstanceType() {
			return this.dataSourceType;
		}
		@Override
		public boolean canSet(DataSourceProperty property) {
			return this.setters.containsKey(property);
		}
		@Override
		public void set(T dataSource, DataSourceProperty property, String value) {
			Method method = getMethod(property, this.setters);
			if (method != null) {
				ReflectionUtils.invokeMethod(method, dataSource, value);
			}
		}
		@Override
		public String get(T dataSource, DataSourceProperty property) {
			Method method = getMethod(property, this.getters);
			if (method != null) {
				return (String) ReflectionUtils.invokeMethod(method, dataSource);
			}
			return null;
		}
		private Method getMethod(DataSourceProperty property, Map<DataSourceProperty, Method> methods) {
			Method method = methods.get(property);
			if (method == null) {
				UnsupportedDataSourcePropertyException.throwIf(!property.isOptional(),
						() -> 'Unable to find suitable method for ' + property);
				return null;
			}
			ReflectionUtils.makeAccessible(method);
			return method;
		}
	}
	@FunctionalInterface
	private interface Getter<T, V> {
		V get(T instance) throws SQLException;
	}
	@FunctionalInterface
	private interface Setter<T, V> {
		void set(T instance, V value) throws SQLException;
	}
	/**
	 * {@link DataSourceProperties} for Hikari.
	 */
	private static class HikariDataSourceProperties extends MappedDataSourceProperties<HikariDataSource> {
		HikariDataSourceProperties() {
			add(DataSourceProperty.URL, HikariDataSource::getJdbcUrl, HikariDataSource::setJdbcUrl);
			add(DataSourceProperty.DRIVER_CLASS_NAME, HikariDataSource::getDriverClassName,
					HikariDataSource::setDriverClassName);
			add(DataSourceProperty.USERNAME, HikariDataSource::getUsername, HikariDataSource::setUsername);
			add(DataSourceProperty.PASSWORD, HikariDataSource::getPassword, HikariDataSource::setPassword);
		}
	}
	/**
	 * {@link DataSourceProperties} for Tomcat Pool.
	 */
	private static class TomcatPoolDataSourceProperties
			extends MappedDataSourceProperties<org.apache.tomcat.jdbc.pool.DataSource> {
		TomcatPoolDataSourceProperties() {
			add(DataSourceProperty.URL, org.apache.tomcat.jdbc.pool.DataSource::getUrl,
					org.apache.tomcat.jdbc.pool.DataSource::setUrl);
			add(DataSourceProperty.DRIVER_CLASS_NAME, org.apache.tomcat.jdbc.pool.DataSource::getDriverClassName,
					org.apache.tomcat.jdbc.pool.DataSource::setDriverClassName);
			add(DataSourceProperty.USERNAME, org.apache.tomcat.jdbc.pool.DataSource::getUsername,
					org.apache.tomcat.jdbc.pool.DataSource::setUsername);
			add(DataSourceProperty.PASSWORD, org.apache.tomcat.jdbc.pool.DataSource::getPassword,
					org.apache.tomcat.jdbc.pool.DataSource::setPassword);
		}
	}
	/**
	 * {@link DataSourceProperties} for DBCP2.
	 */
	private static class MappedDbcp2DataSource extends MappedDataSourceProperties<BasicDataSource> {
		MappedDbcp2DataSource() {
			add(DataSourceProperty.URL, BasicDataSource::getUrl, BasicDataSource::setUrl);
			add(DataSourceProperty.DRIVER_CLASS_NAME, BasicDataSource::getDriverClassName,
					BasicDataSource::setDriverClassName);
			add(DataSourceProperty.USERNAME, BasicDataSource::getUserName, BasicDataSource::setUsername);
			add(DataSourceProperty.PASSWORD, null, BasicDataSource::setPassword);
		}
	}
	/**
	 * {@link DataSourceProperties} for Oracle Pool.
	 */
	private static class OraclePoolDataSourceProperties extends MappedDataSourceProperties<PoolDataSource> {
		@Override
		public Class<? extends PoolDataSource> getDataSourceInstanceType() {
			return PoolDataSourceImpl.class;
		}
		OraclePoolDataSourceProperties() {
			add(DataSourceProperty.URL, PoolDataSource::getURL, PoolDataSource::setURL);
			add(DataSourceProperty.DRIVER_CLASS_NAME, PoolDataSource::getConnectionFactoryClassName,
					PoolDataSource::setConnectionFactoryClassName);
			add(DataSourceProperty.USERNAME, PoolDataSource::getUser, PoolDataSource::setUser);
			add(DataSourceProperty.PASSWORD, null, PoolDataSource::setPassword);
		}
	}
	/**
	 * {@link DataSourceProperties} for C3P0.
	 */
	private static class ComboPooledDataSourceProperties extends MappedDataSourceProperties<ComboPooledDataSource> {
		ComboPooledDataSourceProperties() {
			add(DataSourceProperty.URL, ComboPooledDataSource::getJdbcUrl, ComboPooledDataSource::setJdbcUrl);
			add(DataSourceProperty.DRIVER_CLASS_NAME, ComboPooledDataSource::getDriverClass, this::setDriverClass);
			add(DataSourceProperty.USERNAME, ComboPooledDataSource::getUser, ComboPooledDataSource::setUser);
			add(DataSourceProperty.PASSWORD, ComboPooledDataSource::getPassword, ComboPooledDataSource::setPassword);
		}
		private void setDriverClass(ComboPooledDataSource dataSource, String driverClass) {
			try {
				dataSource.setDriverClass(driverClass);
			}
			catch (PropertyVetoException ex) {
				throw new IllegalArgumentException(ex);
			}
		}
	}
	/**
	 * {@link DataSourceProperties} for Spring"s {@link SimpleDriverDataSource}.
	 */
	private static class SimpleDataSourceProperties extends MappedDataSourceProperties<SimpleDriverDataSource> {
		@SuppressWarnings('unchecked')
		SimpleDataSourceProperties() {
			add(DataSourceProperty.URL, SimpleDriverDataSource::getUrl, SimpleDriverDataSource::setUrl);
			add(DataSourceProperty.DRIVER_CLASS_NAME, Class.class, (dataSource) -> dataSource.getDriver().getClass(),
					SimpleDriverDataSource::setDriverClass);
			add(DataSourceProperty.USERNAME, SimpleDriverDataSource::getUsername, SimpleDriverDataSource::setUsername);
			add(DataSourceProperty.PASSWORD, SimpleDriverDataSource::getPassword, SimpleDriverDataSource::setPassword);
		}
	}
	/**
	 * {@link DataSourceProperties} for Oracle.
	 */
	private static class OracleDataSourceProperties extends MappedDataSourceProperties<OracleDataSource> {
		OracleDataSourceProperties() {
			add(DataSourceProperty.URL, OracleDataSource::getURL, OracleDataSource::setURL);
			add(DataSourceProperty.USERNAME, OracleDataSource::getUser, OracleDataSource::setUser);
			add(DataSourceProperty.PASSWORD, null, OracleDataSource::setPassword);
		}
	}
	/**
	 * {@link DataSourceProperties} for H2.
	 */
	private static class H2DataSourceProperties extends MappedDataSourceProperties<JdbcDataSource> {
		H2DataSourceProperties() {
			add(DataSourceProperty.URL, JdbcDataSource::getUrl, JdbcDataSource::setUrl);
			add(DataSourceProperty.USERNAME, JdbcDataSource::getUser, JdbcDataSource::setUser);
			add(DataSourceProperty.PASSWORD, JdbcDataSource::getPassword, JdbcDataSource::setPassword);
		}
	}
	/**
	 * {@link DataSourceProperties} for Postgres.
	 */
	private static class PostgresDataSourceProperties extends MappedDataSourceProperties<PGSimpleDataSource> {
		PostgresDataSourceProperties() {
			add(DataSourceProperty.URL, PGSimpleDataSource::getUrl, PGSimpleDataSource::setUrl);
			add(DataSourceProperty.USERNAME, PGSimpleDataSource::getUser, PGSimpleDataSource::setUser);
			add(DataSourceProperty.PASSWORD, PGSimpleDataSource::getPassword, PGSimpleDataSource::setPassword);
		}
	}
}
/*
package org.springframework.boot.jdbc;
/**
public class UnsupportedDataSourcePropertyException extends RuntimeException {
	UnsupportedDataSourcePropertyException(String message) {
		super(message);
	}
	static void throwIf(boolean test, Supplier<String> message) {
		if (test) {
			throw new UnsupportedDataSourcePropertyException(message.get());
		}
	}
}
/*
/**
package org.springframework.boot.jdbc;
/*
package org.springframework.boot.jdbc.init;
/**
class DataSourceScriptDatabaseInitializerDetector extends AbstractBeansOfTypeDatabaseInitializerDetector {
	static final int PRECEDENCE = Ordered.LOWEST_PRECEDENCE - 100;
	@Override
	protected Set<Class<?>> getDatabaseInitializerBeanTypes() {
		return Collections.singleton(DataSourceScriptDatabaseInitializer.class);
	}
	@Override
	public int getOrder() {
		return PRECEDENCE;
	}
}
/*
package org.springframework.boot.jdbc.init;
/**
public class DataSourceScriptDatabaseInitializer extends AbstractScriptDatabaseInitializer {
	private static final Log logger = LogFactory.getLog(DataSourceScriptDatabaseInitializer.class);
	private final DataSource dataSource;
	/**
	 * Creates a new {@link DataSourceScriptDatabaseInitializer} that will initialize the
	 * given {@code DataSource} using the given settings.
	 * @param dataSource data source to initialize
	 * @param settings the initialization settings
	 */
	public DataSourceScriptDatabaseInitializer(DataSource dataSource, DatabaseInitializationSettings settings) {
		super(settings);
		this.dataSource = dataSource;
	}
	/**
	 * Returns the {@code DataSource} that will be initialized.
	 * @return the initialization data source
	 */
	protected final DataSource getDataSource() {
		return this.dataSource;
	}
	@Override
	protected boolean isEmbeddedDatabase() {
		try {
			return EmbeddedDatabaseConnection.isEmbedded(this.dataSource);
		}
		catch (Exception ex) {
			logger.debug('Could not determine if datasource is embedded', ex);
			return false;
		}
	}
	@Override
	protected void runScripts(Scripts scripts) {
		ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
		populator.setContinueOnError(scripts.isContinueOnError());
		populator.setSeparator(scripts.getSeparator());
		if (scripts.getEncoding() != null) {
			populator.setSqlScriptEncoding(scripts.getEncoding().name());
		}
		for (Resource resource : scripts) {
			populator.addScript(resource);
		}
		customize(populator);
		DatabasePopulatorUtils.execute(populator, this.dataSource);
	}
	/**
	 * Customize the {@link ResourceDatabasePopulator}.
	 * @param populator the configured database populator
	 * @since 2.6.2
	 */
	protected void customize(ResourceDatabasePopulator populator) {
	}
}
/*
/**
package org.springframework.boot.jdbc.init;
/*
package org.springframework.boot.jdbc.init;
/**
public class PlatformPlaceholderDatabaseDriverResolver {
	private final String placeholder;
	private final Map<DatabaseDriver, String> driverMappings;
	/**
	 * Creates a new resolver that will use the default {@code '@@platform@@'}
	 * placeholder.
	 */
	public PlatformPlaceholderDatabaseDriverResolver() {
		this('@@platform@@');
	}
	/**
	 * Creates a new resolver that will use the given {@code placeholder}.
	 * @param placeholder the placeholder to use
	 */
	public PlatformPlaceholderDatabaseDriverResolver(String placeholder) {
		this(placeholder, Collections.emptyMap());
	}
	private PlatformPlaceholderDatabaseDriverResolver(String placeholder, Map<DatabaseDriver, String> driverMappings) {
		this.placeholder = placeholder;
		this.driverMappings = driverMappings;
	}
	/**
	 * Creates a new {@link PlatformPlaceholderDatabaseDriverResolver} that will map the
	 * given {@code driver} to the given {@code platform}.
	 * @param driver the driver
	 * @param platform the platform
	 * @return the new resolver
	 */
	public PlatformPlaceholderDatabaseDriverResolver withDriverPlatform(DatabaseDriver driver, String platform) {
		Map<DatabaseDriver, String> driverMappings = new LinkedHashMap<>(this.driverMappings);
		driverMappings.put(driver, platform);
		return new PlatformPlaceholderDatabaseDriverResolver(this.placeholder, driverMappings);
	}
	/**
	 * Resolves the placeholders in the given {@code values}, replacing them with the
	 * platform derived from the {@link DatabaseDriver} of the given {@code dataSource}.
	 * @param dataSource the DataSource from which the {@link DatabaseDriver} is derived
	 * @param values the values in which placeholders are resolved
	 * @return the values with their placeholders resolved
	 */
	public List<String> resolveAll(DataSource dataSource, String... values) {
		Assert.notNull(dataSource, 'DataSource must not be null');
		return resolveAll(() -> determinePlatform(dataSource), values);
	}
	/**
	 * Resolves the placeholders in the given {@code values}, replacing them with the
	 * given platform.
	 * @param platform the platform to use
	 * @param values the values in which placeholders are resolved
	 * @return the values with their placeholders resolved
	 * @since 2.6.2
	 */
	public List<String> resolveAll(String platform, String... values) {
		Assert.notNull(platform, 'Platform must not be null');
		return resolveAll(() -> platform, values);
	}
	private List<String> resolveAll(Supplier<String> platformProvider, String... values) {
		if (ObjectUtils.isEmpty(values)) {
			return Collections.emptyList();
		}
		List<String> resolved = new ArrayList<>(values.length);
		String platform = null;
		for (String value : values) {
			if (StringUtils.hasLength(value)) {
				if (value.contains(this.placeholder)) {
					platform = (platform != null) ? platform : platformProvider.get();
					value = value.replace(this.placeholder, platform);
				}
			}
			resolved.add(value);
		}
		return Collections.unmodifiableList(resolved);
	}
	private String determinePlatform(DataSource dataSource) {
		DatabaseDriver databaseDriver = getDatabaseDriver(dataSource);
		Assert.state(databaseDriver != DatabaseDriver.UNKNOWN, 'Unable to detect database type');
		return this.driverMappings.getOrDefault(databaseDriver, databaseDriver.getId());
	}
	DatabaseDriver getDatabaseDriver(DataSource dataSource) {
		try {
			String productName = JdbcUtils.commonDatabaseName(
					JdbcUtils.extractDatabaseMetaData(dataSource, DatabaseMetaData::getDatabaseProductName));
			return DatabaseDriver.fromProductName(productName);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Failed to determine DatabaseDriver', ex);
		}
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public interface DataSourcePoolMetadata {
	/**
	 * Return the usage of the pool as value between 0 and 1 (or -1 if the pool is not
	 * limited).
	 * <ul>
	 * <li>1 means that the maximum number of connections have been allocated</li>
	 * <li>0 means that no connection is currently active</li>
	 * <li>-1 means there is not limit to the number of connections that can be allocated
	 * </li>
	 * </ul>
	 * This may also return {@code null} if the data source does not provide the necessary
	 * information to compute the poll usage.
	 * @return the usage value or {@code null}
	 */
	Float getUsage();
	/**
	 * Return the current number of active connections that have been allocated from the
	 * data source or {@code null} if that information is not available.
	 * @return the number of active connections or {@code null}
	 */
	Integer getActive();
	/**
	 * Return the number of established but idle connections. Can also return {@code null}
	 * if that information is not available.
	 * @return the number of established but idle connections or {@code null}
	 * @since 2.2.0
	 * @see #getActive()
	 */
	default Integer getIdle() {
		return null;
	}
	/**
	 * Return the maximum number of active connections that can be allocated at the same
	 * time or {@code -1} if there is no limit. Can also return {@code null} if that
	 * information is not available.
	 * @return the maximum number of active connections or {@code null}
	 */
	Integer getMax();
	/**
	 * Return the minimum number of idle connections in the pool or {@code null} if that
	 * information is not available.
	 * @return the minimum number of active connections or {@code null}
	 */
	Integer getMin();
	/**
	 * Return the query to use to validate that a connection is valid or {@code null} if
	 * that information is not available.
	 * @return the validation query or {@code null}
	 */
	String getValidationQuery();
	/**
	 * The default auto-commit state of connections created by this pool. If not set
	 * ({@code null}), default is JDBC driver default (If set to null then the
	 * java.sql.Connection.setAutoCommit(boolean) method will not be called.)
	 * @return the default auto-commit state or {@code null}
	 */
	Boolean getDefaultAutoCommit();
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public class CompositeDataSourcePoolMetadataProvider implements DataSourcePoolMetadataProvider {
	private final List<DataSourcePoolMetadataProvider> providers;
	/**
	 * Create a {@link CompositeDataSourcePoolMetadataProvider} instance with an initial
	 * collection of delegates to use.
	 * @param providers the data source pool metadata providers
	 */
	public CompositeDataSourcePoolMetadataProvider(Collection<? extends DataSourcePoolMetadataProvider> providers) {
		this.providers = (providers != null) ? List.copyOf(providers) : Collections.emptyList();
	}
	@Override
	public DataSourcePoolMetadata getDataSourcePoolMetadata(DataSource dataSource) {
		for (DataSourcePoolMetadataProvider provider : this.providers) {
			DataSourcePoolMetadata metadata = provider.getDataSourcePoolMetadata(dataSource);
			if (metadata != null) {
				return metadata;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public class HikariDataSourcePoolMetadata extends AbstractDataSourcePoolMetadata<HikariDataSource> {
	public HikariDataSourcePoolMetadata(HikariDataSource dataSource) {
		super(dataSource);
	}
	@Override
	public Integer getActive() {
		try {
			return getHikariPool().getActiveConnections();
		}
		catch (Exception ex) {
			return null;
		}
	}
	@Override
	public Integer getIdle() {
		try {
			return getHikariPool().getIdleConnections();
		}
		catch (Exception ex) {
			return null;
		}
	}
	private HikariPool getHikariPool() {
		return (HikariPool) new DirectFieldAccessor(getDataSource()).getPropertyValue('pool');
	}
	@Override
	public Integer getMax() {
		return getDataSource().getMaximumPoolSize();
	}
	@Override
	public Integer getMin() {
		return getDataSource().getMinimumIdle();
	}
	@Override
	public String getValidationQuery() {
		return getDataSource().getConnectionTestQuery();
	}
	@Override
	public Boolean getDefaultAutoCommit() {
		return getDataSource().isAutoCommit();
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public class TomcatDataSourcePoolMetadata extends AbstractDataSourcePoolMetadata<DataSource> {
	public TomcatDataSourcePoolMetadata(DataSource dataSource) {
		super(dataSource);
	}
	@Override
	public Integer getActive() {
		ConnectionPool pool = getDataSource().getPool();
		return (pool != null) ? pool.getActive() : 0;
	}
	@Override
	public Integer getIdle() {
		return getDataSource().getNumIdle();
	}
	@Override
	public Integer getMax() {
		return getDataSource().getMaxActive();
	}
	@Override
	public Integer getMin() {
		return getDataSource().getMinIdle();
	}
	@Override
	public String getValidationQuery() {
		return getDataSource().getValidationQuery();
	}
	@Override
	public Boolean getDefaultAutoCommit() {
		return getDataSource().isDefaultAutoCommit();
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public class OracleUcpDataSourcePoolMetadata extends AbstractDataSourcePoolMetadata<PoolDataSource> {
	public OracleUcpDataSourcePoolMetadata(PoolDataSource dataSource) {
		super(dataSource);
	}
	@Override
	public Integer getActive() {
		try {
			return getDataSource().getBorrowedConnectionsCount();
		}
		catch (SQLException ex) {
			return null;
		}
	}
	@Override
	public Integer getIdle() {
		try {
			return getDataSource().getAvailableConnectionsCount();
		}
		catch (SQLException ex) {
			return null;
		}
	}
	@Override
	public Integer getMax() {
		return getDataSource().getMaxPoolSize();
	}
	@Override
	public Integer getMin() {
		return getDataSource().getMinPoolSize();
	}
	@Override
	public String getValidationQuery() {
		return getDataSource().getSQLForValidateConnection();
	}
	@Override
	public Boolean getDefaultAutoCommit() {
		String autoCommit = getDataSource().getConnectionProperty('autoCommit');
		return StringUtils.hasText(autoCommit) ? Boolean.valueOf(autoCommit) : null;
	}
}
/*
/**
package org.springframework.boot.jdbc.metadata;
/*
package org.springframework.boot.jdbc.metadata;
/**
@FunctionalInterface
public interface DataSourcePoolMetadataProvider {
	/**
	 * Return the {@link DataSourcePoolMetadata} instance able to manage the specified
	 * {@link DataSource} or {@code null} if the given data source could not be handled.
	 * @param dataSource the data source
	 * @return the data source pool metadata
	 */
	DataSourcePoolMetadata getDataSourcePoolMetadata(DataSource dataSource);
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public abstract class AbstractDataSourcePoolMetadata<T extends DataSource> implements DataSourcePoolMetadata {
	private final T dataSource;
	/**
	 * Create an instance with the data source to use.
	 * @param dataSource the data source
	 */
	protected AbstractDataSourcePoolMetadata(T dataSource) {
		this.dataSource = dataSource;
	}
	@Override
	public Float getUsage() {
		Integer maxSize = getMax();
		Integer currentSize = getActive();
		if (maxSize == null || currentSize == null) {
			return null;
		}
		if (maxSize < 0) {
			return -1f;
		}
		if (currentSize == 0) {
			return 0f;
		}
		return (float) currentSize / (float) maxSize;
	}
	protected final T getDataSource() {
		return this.dataSource;
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public class CommonsDbcp2DataSourcePoolMetadata extends AbstractDataSourcePoolMetadata<BasicDataSource> {
	public CommonsDbcp2DataSourcePoolMetadata(BasicDataSource dataSource) {
		super(dataSource);
	}
	@Override
	public Integer getActive() {
		return getDataSource().getNumActive();
	}
	@Override
	public Integer getIdle() {
		return getDataSource().getNumIdle();
	}
	@Override
	public Integer getMax() {
		return getDataSource().getMaxTotal();
	}
	@Override
	public Integer getMin() {
		return getDataSource().getMinIdle();
	}
	@Override
	public String getValidationQuery() {
		return getDataSource().getValidationQuery();
	}
	@Override
	public Boolean getDefaultAutoCommit() {
		return getDataSource().getDefaultAutoCommit();
	}
}
/*
package org.springframework.boot.jms;
/**
public final class ConnectionFactoryUnwrapper {
	private ConnectionFactoryUnwrapper() {
	}
	/**
	 * Return the native {@link ConnectionFactory} by unwrapping it from a cache or pool
	 * connection factory. Return the given {@link ConnectionFactory} if no caching
	 * wrapper has been detected.
	 * @param connectionFactory a connection factory
	 * @return the native connection factory that it wraps, if any
	 */
	public static ConnectionFactory unwrap(ConnectionFactory connectionFactory) {
		if (connectionFactory instanceof CachingConnectionFactory cachingConnectionFactory) {
			return unwrap(cachingConnectionFactory.getTargetConnectionFactory());
		}
		ConnectionFactory unwrapedConnectionFactory = unwrapFromJmsPoolConnectionFactory(connectionFactory);
		return (unwrapedConnectionFactory != null) ? unwrap(unwrapedConnectionFactory) : connectionFactory;
	}
	private static ConnectionFactory unwrapFromJmsPoolConnectionFactory(ConnectionFactory connectionFactory) {
		try {
			if (connectionFactory instanceof JmsPoolConnectionFactory jmsPoolConnectionFactory) {
				return (ConnectionFactory) jmsPoolConnectionFactory.getConnectionFactory();
			}
		}
		catch (Throwable ex) {
			// ignore
		}
		return null;
	}
}
/*
/**
package org.springframework.boot.jms;
/*
package org.springframework.boot.jms;
/**
@FunctionalInterface
public interface XAConnectionFactoryWrapper {
	/**
	 * Wrap the specific {@link XAConnectionFactory} and enroll it with a JTA
	 * {@link TransactionManager}.
	 * @param connectionFactory the connection factory to wrap
	 * @return the wrapped connection factory
	 * @throws Exception if the connection factory cannot be wrapped
	 */
	ConnectionFactory wrapConnectionFactory(XAConnectionFactory connectionFactory) throws Exception;
}
/*
package org.springframework.boot.context;
/**
public class ContextIdApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext>, Ordered {
	private int order = Ordered.LOWEST_PRECEDENCE - 10;
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		ContextId contextId = getContextId(applicationContext);
		applicationContext.setId(contextId.getId());
		applicationContext.getBeanFactory().registerSingleton(ContextId.class.getName(), contextId);
	}
	private ContextId getContextId(ConfigurableApplicationContext applicationContext) {
		ApplicationContext parent = applicationContext.getParent();
		if (parent != null && parent.containsBean(ContextId.class.getName())) {
			return parent.getBean(ContextId.class).createChildId();
		}
		return new ContextId(getApplicationId(applicationContext.getEnvironment()));
	}
	private String getApplicationId(ConfigurableEnvironment environment) {
		String name = environment.getProperty('spring.application.name');
		return StringUtils.hasText(name) ? name : 'application';
	}
	/**
	 * The ID of a context.
	 */
	static class ContextId {
		private final AtomicLong children = new AtomicLong();
		private final String id;
		ContextId(String id) {
			this.id = id;
		}
		ContextId createChildId() {
			return new ContextId(this.id + '-' + this.children.incrementAndGet());
		}
		String getId() {
			return this.id;
		}
	}
}
/*
package org.springframework.boot.context;
/**
public class ApplicationPidFileWriter implements ApplicationListener<SpringApplicationEvent>, Ordered {
	private static final Log logger = LogFactory.getLog(ApplicationPidFileWriter.class);
	private static final String DEFAULT_FILE_NAME = 'application.pid';
	private static final List<Property> FILE_PROPERTIES;
	static {
		List<Property> properties = new ArrayList<>();
		properties.add(new SpringProperty('spring.pid.', 'file'));
		properties.add(new SpringProperty('spring.', 'pidfile'));
		properties.add(new SystemProperty('PIDFILE'));
		FILE_PROPERTIES = Collections.unmodifiableList(properties);
	}
	private static final List<Property> FAIL_ON_WRITE_ERROR_PROPERTIES;
	static {
		List<Property> properties = new ArrayList<>();
		properties.add(new SpringProperty('spring.pid.', 'fail-on-write-error'));
		properties.add(new SystemProperty('PID_FAIL_ON_WRITE_ERROR'));
		FAIL_ON_WRITE_ERROR_PROPERTIES = Collections.unmodifiableList(properties);
	}
	private static final AtomicBoolean created = new AtomicBoolean();
	private int order = Ordered.HIGHEST_PRECEDENCE + 13;
	private final File file;
	private Class<? extends SpringApplicationEvent> triggerEventType = ApplicationPreparedEvent.class;
	/**
	 * Create a new {@link ApplicationPidFileWriter} instance using the filename
	 * "application.pid".
	 */
	public ApplicationPidFileWriter() {
		this(new File(DEFAULT_FILE_NAME));
	}
	/**
	 * Create a new {@link ApplicationPidFileWriter} instance with a specified filename.
	 * @param filename the name of file containing pid
	 */
	public ApplicationPidFileWriter(String filename) {
		this(new File(filename));
	}
	/**
	 * Create a new {@link ApplicationPidFileWriter} instance with a specified file.
	 * @param file the file containing pid
	 */
	public ApplicationPidFileWriter(File file) {
		Assert.notNull(file, 'File must not be null');
		this.file = file;
	}
	/**
	 * Sets the type of application event that will trigger writing of the PID file.
	 * Defaults to {@link ApplicationPreparedEvent}. NOTE: If you use the
	 * {@link org.springframework.boot.context.event.ApplicationStartingEvent} to trigger
	 * the write, you will not be able to specify the PID filename in the Spring
	 * {@link Environment}.
	 * @param triggerEventType the trigger event type
	 */
	public void setTriggerEventType(Class<? extends SpringApplicationEvent> triggerEventType) {
		Assert.notNull(triggerEventType, 'Trigger event type must not be null');
		this.triggerEventType = triggerEventType;
	}
	@Override
	public void onApplicationEvent(SpringApplicationEvent event) {
		if (this.triggerEventType.isInstance(event) && created.compareAndSet(false, true)) {
			try {
				writePidFile(event);
			}
			catch (Exception ex) {
				String message = String.format('Cannot create pid file %s', this.file);
				if (failOnWriteError(event)) {
					throw new IllegalStateException(message, ex);
				}
				logger.warn(message, ex);
			}
		}
	}
	private void writePidFile(SpringApplicationEvent event) throws IOException {
		File pidFile = this.file;
		String override = getProperty(event, FILE_PROPERTIES);
		if (override != null) {
			pidFile = new File(override);
		}
		new ApplicationPid().write(pidFile);
		pidFile.deleteOnExit();
	}
	private boolean failOnWriteError(SpringApplicationEvent event) {
		String value = getProperty(event, FAIL_ON_WRITE_ERROR_PROPERTIES);
		return Boolean.parseBoolean(value);
	}
	private String getProperty(SpringApplicationEvent event, List<Property> candidates) {
		for (Property candidate : candidates) {
			String value = candidate.getValue(event);
			if (value != null) {
				return value;
			}
		}
		return null;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Reset the created flag for testing purposes.
	 */
	protected static void reset() {
		created.set(false);
	}
	/**
	 * Provides access to a property value.
	 */
	private interface Property {
		String getValue(SpringApplicationEvent event);
	}
	/**
	 * {@link Property} obtained from Spring"s {@link Environment}.
	 */
	private static class SpringProperty implements Property {
		private final String prefix;
		private final String key;
		SpringProperty(String prefix, String key) {
			this.prefix = prefix;
			this.key = key;
		}
		@Override
		public String getValue(SpringApplicationEvent event) {
			Environment environment = getEnvironment(event);
			if (environment == null) {
				return null;
			}
			return environment.getProperty(this.prefix + this.key);
		}
		private Environment getEnvironment(SpringApplicationEvent event) {
			if (event instanceof ApplicationEnvironmentPreparedEvent environmentPreparedEvent) {
				return environmentPreparedEvent.getEnvironment();
			}
			if (event instanceof ApplicationPreparedEvent preparedEvent) {
				return preparedEvent.getApplicationContext().getEnvironment();
			}
			if (event instanceof ApplicationReadyEvent readyEvent) {
				return readyEvent.getApplicationContext().getEnvironment();
			}
			return null;
		}
	}
	/**
	 * {@link Property} obtained from {@link SystemProperties}.
	 */
	private static class SystemProperty implements Property {
		private final String[] properties;
		SystemProperty(String name) {
			this.properties = new String[] { name.toUpperCase(Locale.ENGLISH), name.toLowerCase(Locale.ENGLISH) };
		}
		@Override
		public String getValue(SpringApplicationEvent event) {
			return SystemProperties.get(this.properties);
		}
	}
}
/*
package org.springframework.boot.context.annotation;
/**
@FunctionalInterface
public interface DeterminableImports {
	/**
	 * Return a set of objects that represent the imports. Objects within the returned
	 * {@code Set} must implement a valid {@link Object#hashCode() hashCode} and
	 * {@link Object#equals(Object) equals}.
	 * <p>
	 * Imports from multiple {@link DeterminableImports} instances may be combined by the
	 * caller to create a complete set.
	 * <p>
	 * Unlike {@link ImportSelector} and {@link ImportBeanDefinitionRegistrar} any
	 * {@link Aware} callbacks will not be invoked before this method is called.
	 * @param metadata the source meta-data
	 * @return a key representing the annotations that actually drive the import
	 */
	Set<Object> determineImports(AnnotationMetadata metadata);
}
/*
package org.springframework.boot.context.annotation;
/**
public class UserConfigurations extends Configurations implements PriorityOrdered {
	protected UserConfigurations(Collection<Class<?>> classes) {
		super(classes);
	}
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE;
	}
	@Override
	protected UserConfigurations merge(Set<Class<?>> mergedClasses) {
		return new UserConfigurations(mergedClasses);
	}
	public static UserConfigurations of(Class<?>... classes) {
		return new UserConfigurations(Arrays.asList(classes));
	}
}
/*
package org.springframework.boot.context.annotation;
/**
public abstract class Configurations {
	private static final Comparator<Object> COMPARATOR = OrderComparator.INSTANCE
		.thenComparing((other) -> other.getClass().getName());
	private final UnaryOperator<Collection<Class<?>>> sorter;
	private final Set<Class<?>> classes;
	/**
	 * Create a new {@link Configurations} instance.
	 * @param classes the configuration classes
	 */
	protected Configurations(Collection<Class<?>> classes) {
		Assert.notNull(classes, 'Classes must not be null');
		Collection<Class<?>> sorted = sort(classes);
		this.sorter = null;
		this.classes = Collections.unmodifiableSet(new LinkedHashSet<>(sorted));
	}
	/**
	 * Create a new {@link Configurations} instance.
	 * @param sorter a {@link UnaryOperator} used to sort the configurations
	 * @param classes the configuration classes
	 * @since 3.4.0
	 */
	protected Configurations(UnaryOperator<Collection<Class<?>>> sorter, Collection<Class<?>> classes) {
		Assert.notNull(sorter, 'Sorter must not be null');
		Assert.notNull(classes, 'Classes must not be null');
		Collection<Class<?>> sorted = sorter.apply(classes);
		this.sorter = sorter;
		this.classes = Collections.unmodifiableSet(new LinkedHashSet<>(sorted));
	}
	/**
	 * Sort configuration classes into the order that they should be applied.
	 * @param classes the classes to sort
	 * @return a sorted set of classes
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #Configurations(UnaryOperator, Collection)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	protected Collection<Class<?>> sort(Collection<Class<?>> classes) {
		return classes;
	}
	protected final Set<Class<?>> getClasses() {
		return this.classes;
	}
	/**
	 * Merge configurations from another source of the same type.
	 * @param other the other {@link Configurations} (must be of the same type as this
	 * instance)
	 * @return a new configurations instance (must be of the same type as this instance)
	 */
	protected Configurations merge(Configurations other) {
		Set<Class<?>> mergedClasses = new LinkedHashSet<>(getClasses());
		mergedClasses.addAll(other.getClasses());
		if (this.sorter != null) {
			mergedClasses = new LinkedHashSet<>(this.sorter.apply(mergedClasses));
		}
		return merge(mergedClasses);
	}
	/**
	 * Merge configurations.
	 * @param mergedClasses the merged classes
	 * @return a new configurations instance (must be of the same type as this instance)
	 */
	protected abstract Configurations merge(Set<Class<?>> mergedClasses);
	/**
	 * Return the classes from all the specified configurations in the order that they
	 * would be registered.
	 * @param configurations the source configuration
	 * @return configuration classes in registration order
	 */
	public static Class<?>[] getClasses(Configurations... configurations) {
		return getClasses(Arrays.asList(configurations));
	}
	/**
	 * Return the classes from all the specified configurations in the order that they
	 * would be registered.
	 * @param configurations the source configuration
	 * @return configuration classes in registration order
	 */
	public static Class<?>[] getClasses(Collection<Configurations> configurations) {
		List<Configurations> ordered = new ArrayList<>(configurations);
		ordered.sort(COMPARATOR);
		List<Configurations> collated = collate(ordered);
		LinkedHashSet<Class<?>> classes = collated.stream()
			.flatMap(Configurations::streamClasses)
			.collect(Collectors.toCollection(LinkedHashSet::new));
		return ClassUtils.toClassArray(classes);
	}
	private static Stream<Class<?>> streamClasses(Configurations configurations) {
		return configurations.getClasses().stream();
	}
	private static List<Configurations> collate(List<Configurations> orderedConfigurations) {
		LinkedList<Configurations> collated = new LinkedList<>();
		for (Configurations item : orderedConfigurations) {
			if (collated.isEmpty() || collated.getLast().getClass() != item.getClass()) {
				collated.add(item);
			}
			else {
				collated.set(collated.size() - 1, collated.getLast().merge(item));
			}
		}
		return collated;
	}
}
/*
package org.springframework.boot.context.annotation;
/**
public final class ImportCandidates implements Iterable<String> {
	private static final String LOCATION = 'META-INF/spring/%s.imports';
	private static final String COMMENT_START = '#';
	private final List<String> candidates;
	private ImportCandidates(List<String> candidates) {
		Assert.notNull(candidates, '"candidates" must not be null');
		this.candidates = Collections.unmodifiableList(candidates);
	}
	@Override
	public Iterator<String> iterator() {
		return this.candidates.iterator();
	}
	/**
	 * Returns the list of loaded import candidates.
	 * @return the list of import candidates
	 */
	public List<String> getCandidates() {
		return this.candidates;
	}
	/**
	 * Loads the names of import candidates from the classpath. The names of the import
	 * candidates are stored in files named
	 * {@code META-INF/spring/full-qualified-annotation-name.imports} on the classpath.
	 * Every line contains the full qualified name of the candidate class. Comments are
	 * supported using the # character.
	 * @param annotation annotation to load
	 * @param classLoader class loader to use for loading
	 * @return list of names of annotated classes
	 */
	public static ImportCandidates load(Class<?> annotation, ClassLoader classLoader) {
		Assert.notNull(annotation, '"annotation" must not be null');
		ClassLoader classLoaderToUse = decideClassloader(classLoader);
		String location = String.format(LOCATION, annotation.getName());
		Enumeration<URL> urls = findUrlsInClasspath(classLoaderToUse, location);
		List<String> importCandidates = new ArrayList<>();
		while (urls.hasMoreElements()) {
			URL url = urls.nextElement();
			importCandidates.addAll(readCandidateConfigurations(url));
		}
		return new ImportCandidates(importCandidates);
	}
	private static ClassLoader decideClassloader(ClassLoader classLoader) {
		if (classLoader == null) {
			return ImportCandidates.class.getClassLoader();
		}
		return classLoader;
	}
	private static Enumeration<URL> findUrlsInClasspath(ClassLoader classLoader, String location) {
		try {
			return classLoader.getResources(location);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException('Failed to load configurations from location [' + location + ']', ex);
		}
	}
	private static List<String> readCandidateConfigurations(URL url) {
		try (BufferedReader reader = new BufferedReader(
				new InputStreamReader(new UrlResource(url).getInputStream(), StandardCharsets.UTF_8))) {
			List<String> candidates = new ArrayList<>();
			String line;
			while ((line = reader.readLine()) != null) {
				line = stripComment(line);
				line = line.trim();
				if (line.isEmpty()) {
					continue;
				}
				candidates.add(line);
			}
			return candidates;
		}
		catch (IOException ex) {
			throw new IllegalArgumentException('Unable to load configurations from location [' + url + ']', ex);
		}
	}
	private static String stripComment(String line) {
		int commentStart = line.indexOf(COMMENT_START);
		if (commentStart == -1) {
			return line;
		}
		return line.substring(0, commentStart);
	}
}
/*
/**
package org.springframework.boot.context.annotation;
/*
package org.springframework.boot.context.metrics.buffering;
/**
public class BufferingApplicationStartup implements ApplicationStartup {
	private final int capacity;
	private final Clock clock;
	private Instant startTime;
	private final AtomicInteger idSeq = new AtomicInteger();
	private Predicate<StartupStep> filter = (step) -> true;
	private final AtomicReference<BufferedStartupStep> current = new AtomicReference<>();
	private final AtomicInteger estimatedSize = new AtomicInteger();
	private final ConcurrentLinkedQueue<TimelineEvent> events = new ConcurrentLinkedQueue<>();
	/**
	 * Create a new buffered {@link ApplicationStartup} with a limited capacity and starts
	 * the recording of steps.
	 * @param capacity the configured capacity; once reached, new steps are not recorded.
	 */
	public BufferingApplicationStartup(int capacity) {
		this(capacity, Clock.systemDefaultZone());
	}
	BufferingApplicationStartup(int capacity, Clock clock) {
		this.capacity = capacity;
		this.clock = clock;
		this.startTime = clock.instant();
	}
	/**
	 * Start the recording of steps and mark the beginning of the {@link StartupTimeline}.
	 * The class constructor already implicitly calls this, but it is possible to reset it
	 * as long as steps have not been recorded already.
	 * @throws IllegalStateException if called and {@link StartupStep} have been recorded
	 * already.
	 */
	public void startRecording() {
		Assert.state(this.events.isEmpty(), 'Cannot restart recording once steps have been buffered.');
		this.startTime = this.clock.instant();
	}
	/**
	 * Add a predicate filter to the list of existing ones.
	 * <p>
	 * A {@link StartupStep step} that doesn"t match all filters will not be recorded.
	 * @param filter the predicate filter to add.
	 */
	public void addFilter(Predicate<StartupStep> filter) {
		this.filter = this.filter.and(filter);
	}
	@Override
	public StartupStep start(String name) {
		int id = this.idSeq.getAndIncrement();
		Instant start = this.clock.instant();
		while (true) {
			BufferedStartupStep current = this.current.get();
			BufferedStartupStep parent = getLatestActive(current);
			BufferedStartupStep next = new BufferedStartupStep(parent, name, id, start, this::record);
			if (this.current.compareAndSet(current, next)) {
				return next;
			}
		}
	}
	private void record(BufferedStartupStep step) {
		if (this.filter.test(step) && this.estimatedSize.get() < this.capacity) {
			this.estimatedSize.incrementAndGet();
			this.events.add(new TimelineEvent(step, this.clock.instant()));
		}
		while (true) {
			BufferedStartupStep current = this.current.get();
			BufferedStartupStep next = getLatestActive(current);
			if (this.current.compareAndSet(current, next)) {
				return;
			}
		}
	}
	private BufferedStartupStep getLatestActive(BufferedStartupStep step) {
		while (step != null && step.isEnded()) {
			step = step.getParent();
		}
		return step;
	}
	/**
	 * Return the {@link StartupTimeline timeline} as a snapshot of currently buffered
	 * steps.
	 * <p>
	 * This will not remove steps from the buffer, see {@link #drainBufferedTimeline()}
	 * for its counterpart.
	 * @return a snapshot of currently buffered steps.
	 */
	public StartupTimeline getBufferedTimeline() {
		return new StartupTimeline(this.startTime, new ArrayList<>(this.events));
	}
	/**
	 * Return the {@link StartupTimeline timeline} by pulling steps from the buffer.
	 * <p>
	 * This removes steps from the buffer, see {@link #getBufferedTimeline()} for its
	 * read-only counterpart.
	 * @return buffered steps drained from the buffer.
	 */
	public StartupTimeline drainBufferedTimeline() {
		List<TimelineEvent> events = new ArrayList<>();
		Iterator<TimelineEvent> iterator = this.events.iterator();
		while (iterator.hasNext()) {
			events.add(iterator.next());
			iterator.remove();
		}
		this.estimatedSize.set(0);
		return new StartupTimeline(this.startTime, events);
	}
}
/*
package org.springframework.boot.context.metrics.buffering;
/**
public class StartupTimeline {
	private final Instant startTime;
	private final List<TimelineEvent> events;
	StartupTimeline(Instant startTime, List<TimelineEvent> events) {
		this.startTime = startTime;
		this.events = Collections.unmodifiableList(events);
	}
	/**
	 * Return the start time of this timeline.
	 * @return the start time
	 */
	public Instant getStartTime() {
		return this.startTime;
	}
	/**
	 * Return the recorded events.
	 * @return the events
	 */
	public List<TimelineEvent> getEvents() {
		return this.events;
	}
	/**
	 * Event on the current {@link StartupTimeline}. Each event has a start/end time, a
	 * precise duration and the complete {@link StartupStep} information associated with
	 * it.
	 */
	public static class TimelineEvent {
		private final BufferedStartupStep step;
		private final Instant endTime;
		private final Duration duration;
		TimelineEvent(BufferedStartupStep step, Instant endTime) {
			this.step = step;
			this.endTime = endTime;
			this.duration = Duration.between(step.getStartTime(), endTime);
		}
		/**
		 * Return the start time of this event.
		 * @return the start time
		 */
		public Instant getStartTime() {
			return this.step.getStartTime();
		}
		/**
		 * Return the end time of this event.
		 * @return the end time
		 */
		public Instant getEndTime() {
			return this.endTime;
		}
		/**
		 * Return the duration of this event, i.e. the processing time of the associated
		 * {@link StartupStep} with nanoseconds precision.
		 * @return the event duration
		 */
		public Duration getDuration() {
			return this.duration;
		}
		/**
		 * Return the {@link StartupStep} information for this event.
		 * @return the step information.
		 */
		public StartupStep getStartupStep() {
			return this.step;
		}
	}
}
/*
/**
package org.springframework.boot.context.metrics.buffering;
/*
package org.springframework.boot.context.metrics.buffering;
/**
class BufferedStartupStep implements StartupStep {
	private final String name;
	private final long id;
	private final BufferedStartupStep parent;
	private final List<Tag> tags = new ArrayList<>();
	private final Consumer<BufferedStartupStep> recorder;
	private final Instant startTime;
	private final AtomicBoolean ended = new AtomicBoolean();
	BufferedStartupStep(BufferedStartupStep parent, String name, long id, Instant startTime,
			Consumer<BufferedStartupStep> recorder) {
		this.parent = parent;
		this.name = name;
		this.id = id;
		this.startTime = startTime;
		this.recorder = recorder;
	}
	BufferedStartupStep getParent() {
		return this.parent;
	}
	@Override
	public String getName() {
		return this.name;
	}
	@Override
	public long getId() {
		return this.id;
	}
	Instant getStartTime() {
		return this.startTime;
	}
	@Override
	public Long getParentId() {
		return (this.parent != null) ? this.parent.getId() : null;
	}
	@Override
	public Tags getTags() {
		return Collections.unmodifiableList(this.tags)::iterator;
	}
	@Override
	public StartupStep tag(String key, Supplier<String> value) {
		return tag(key, value.get());
	}
	@Override
	public StartupStep tag(String key, String value) {
		Assert.state(!this.ended.get(), 'StartupStep has already ended.');
		this.tags.add(new DefaultTag(key, value));
		return this;
	}
	@Override
	public void end() {
		this.ended.set(true);
		this.recorder.accept(this);
	}
	boolean isEnded() {
		return this.ended.get();
	}
	static class DefaultTag implements Tag {
		private final String key;
		private final String value;
		DefaultTag(String key, String value) {
			this.key = key;
			this.value = value;
		}
		@Override
		public String getKey() {
			return this.key;
		}
		@Override
		public String getValue() {
			return this.value;
		}
	}
}
/*
package org.springframework.boot.context;
/**
public class ConfigurationWarningsApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	private static final Log logger = LogFactory.getLog(ConfigurationWarningsApplicationContextInitializer.class);
	@Override
	public void initialize(ConfigurableApplicationContext context) {
		context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks()));
	}
	/**
	 * Returns the checks that should be applied.
	 * @return the checks to apply
	 */
	protected Check[] getChecks() {
		return new Check[] { new ComponentScanPackageCheck() };
	}
	/**
	 * {@link BeanDefinitionRegistryPostProcessor} to report warnings.
	 */
	protected static final class ConfigurationWarningsPostProcessor
			implements PriorityOrdered, BeanDefinitionRegistryPostProcessor {
		private final Check[] checks;
		public ConfigurationWarningsPostProcessor(Check[] checks) {
			this.checks = checks;
		}
		@Override
		public int getOrder() {
			return Ordered.LOWEST_PRECEDENCE - 1;
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			for (Check check : this.checks) {
				String message = check.getWarning(registry);
				if (StringUtils.hasLength(message)) {
					warn(message);
				}
			}
		}
		private void warn(String message) {
			if (logger.isWarnEnabled()) {
				logger.warn(String.format('%n%n** WARNING ** : %s%n%n', message));
			}
		}
	}
	/**
	 * A single check that can be applied.
	 */
	@FunctionalInterface
	protected interface Check {
		/**
		 * Returns a warning if the check fails or {@code null} if there are no problems.
		 * @param registry the {@link BeanDefinitionRegistry}
		 * @return a warning message or {@code null}
		 */
		String getWarning(BeanDefinitionRegistry registry);
	}
	/**
	 * {@link Check} for {@code @ComponentScan} on problematic package.
	 */
	protected static class ComponentScanPackageCheck implements Check {
		private static final Set<String> PROBLEM_PACKAGES;
		static {
			Set<String> packages = new HashSet<>();
			packages.add('org.springframework');
			packages.add('org');
			PROBLEM_PACKAGES = Collections.unmodifiableSet(packages);
		}
		@Override
		public String getWarning(BeanDefinitionRegistry registry) {
			Set<String> scannedPackages = getComponentScanningPackages(registry);
			List<String> problematicPackages = getProblematicPackages(scannedPackages);
			if (problematicPackages.isEmpty()) {
				return null;
			}
			return 'Your ApplicationContext is unlikely to start due to a @ComponentScan of '
					+ StringUtils.collectionToDelimitedString(problematicPackages, ', ') + '.';
		}
		protected Set<String> getComponentScanningPackages(BeanDefinitionRegistry registry) {
			Set<String> packages = new LinkedHashSet<>();
			String[] names = registry.getBeanDefinitionNames();
			for (String name : names) {
				BeanDefinition definition = registry.getBeanDefinition(name);
				if (definition instanceof AnnotatedBeanDefinition annotatedDefinition) {
					addComponentScanningPackages(packages, annotatedDefinition.getMetadata());
				}
			}
			return packages;
		}
		private void addComponentScanningPackages(Set<String> packages, AnnotationMetadata metadata) {
			AnnotationAttributes attributes = AnnotationAttributes
				.fromMap(metadata.getAnnotationAttributes(ComponentScan.class.getName(), true));
			if (attributes != null) {
				addPackages(packages, attributes.getStringArray('value'));
				addPackages(packages, attributes.getStringArray('basePackages'));
				addClasses(packages, attributes.getStringArray('basePackageClasses'));
				if (packages.isEmpty()) {
					packages.add(ClassUtils.getPackageName(metadata.getClassName()));
				}
			}
		}
		private void addPackages(Set<String> packages, String[] values) {
			if (values != null) {
				Collections.addAll(packages, values);
			}
		}
		private void addClasses(Set<String> packages, String[] values) {
			if (values != null) {
				for (String value : values) {
					packages.add(ClassUtils.getPackageName(value));
				}
			}
		}
		private List<String> getProblematicPackages(Set<String> scannedPackages) {
			List<String> problematicPackages = new ArrayList<>();
			for (String scannedPackage : scannedPackages) {
				if (isProblematicPackage(scannedPackage)) {
					problematicPackages.add(getDisplayName(scannedPackage));
				}
			}
			return problematicPackages;
		}
		private boolean isProblematicPackage(String scannedPackage) {
			if (scannedPackage == null || scannedPackage.isEmpty()) {
				return true;
			}
			return PROBLEM_PACKAGES.contains(scannedPackage);
		}
		private String getDisplayName(String scannedPackage) {
			if (scannedPackage == null || scannedPackage.isEmpty()) {
				return 'the default package';
			}
			return '"' + scannedPackage + '"';
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironment {
	/**
	 * Property used override the imported locations.
	 */
	static final String LOCATION_PROPERTY = 'spring.config.location';
	/**
	 * Property used to provide additional locations to import.
	 */
	static final String ADDITIONAL_LOCATION_PROPERTY = 'spring.config.additional-location';
	/**
	 * Property used to provide additional locations to import.
	 */
	static final String IMPORT_PROPERTY = 'spring.config.import';
	/**
	 * Property used to determine what action to take when a
	 * {@code ConfigDataNotFoundAction} is thrown.
	 * @see ConfigDataNotFoundAction
	 */
	static final String ON_NOT_FOUND_PROPERTY = 'spring.config.on-not-found';
	/**
	 * Default search locations used if not {@link #LOCATION_PROPERTY} is found.
	 */
	static final ConfigDataLocation[] DEFAULT_SEARCH_LOCATIONS;
	static {
		List<ConfigDataLocation> locations = new ArrayList<>();
		locations.add(ConfigDataLocation.of('optional:classpath:/;optional:classpath:/config/'));
		locations.add(ConfigDataLocation.of('optional:file:./;optional:file:./config/;optional:file:./config/*/'));
		DEFAULT_SEARCH_LOCATIONS = locations.toArray(new ConfigDataLocation[0]);
	}
	private static final ConfigDataLocation[] EMPTY_LOCATIONS = new ConfigDataLocation[0];
	private static final Bindable<ConfigDataLocation[]> CONFIG_DATA_LOCATION_ARRAY = Bindable
		.of(ConfigDataLocation[].class);
	private static final Bindable<List<String>> STRING_LIST = Bindable.listOf(String.class);
	private static final BinderOption[] ALLOW_INACTIVE_BINDING = {};
	private static final BinderOption[] DENY_INACTIVE_BINDING = { BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE };
	private final DeferredLogFactory logFactory;
	private final Log logger;
	private final ConfigDataNotFoundAction notFoundAction;
	private final ConfigurableBootstrapContext bootstrapContext;
	private final ConfigurableEnvironment environment;
	private final ConfigDataLocationResolvers resolvers;
	private final Collection<String> additionalProfiles;
	private final ConfigDataEnvironmentUpdateListener environmentUpdateListener;
	private final ConfigDataLoaders loaders;
	private final ConfigDataEnvironmentContributors contributors;
	/**
	 * Create a new {@link ConfigDataEnvironment} instance.
	 * @param logFactory the deferred log factory
	 * @param bootstrapContext the bootstrap context
	 * @param environment the Spring {@link Environment}.
	 * @param resourceLoader {@link ResourceLoader} to load resource locations
	 * @param additionalProfiles any additional profiles to activate
	 * @param environmentUpdateListener optional
	 * {@link ConfigDataEnvironmentUpdateListener} that can be used to track
	 * {@link Environment} updates.
	 */
	ConfigDataEnvironment(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext,
			ConfigurableEnvironment environment, ResourceLoader resourceLoader, Collection<String> additionalProfiles,
			ConfigDataEnvironmentUpdateListener environmentUpdateListener) {
		Binder binder = Binder.get(environment);
		this.logFactory = logFactory;
		this.logger = logFactory.getLog(getClass());
		this.notFoundAction = binder.bind(ON_NOT_FOUND_PROPERTY, ConfigDataNotFoundAction.class)
			.orElse(ConfigDataNotFoundAction.FAIL);
		this.bootstrapContext = bootstrapContext;
		this.environment = environment;
		this.resolvers = createConfigDataLocationResolvers(logFactory, bootstrapContext, binder, resourceLoader);
		this.additionalProfiles = additionalProfiles;
		this.environmentUpdateListener = (environmentUpdateListener != null) ? environmentUpdateListener
				: ConfigDataEnvironmentUpdateListener.NONE;
		this.loaders = new ConfigDataLoaders(logFactory, bootstrapContext,
				SpringFactoriesLoader.forDefaultResourceLocation(resourceLoader.getClassLoader()));
		this.contributors = createContributors(binder);
	}
	protected ConfigDataLocationResolvers createConfigDataLocationResolvers(DeferredLogFactory logFactory,
			ConfigurableBootstrapContext bootstrapContext, Binder binder, ResourceLoader resourceLoader) {
		return new ConfigDataLocationResolvers(logFactory, bootstrapContext, binder, resourceLoader,
				SpringFactoriesLoader.forDefaultResourceLocation(resourceLoader.getClassLoader()));
	}
	private ConfigDataEnvironmentContributors createContributors(Binder binder) {
		this.logger.trace('Building config data environment contributors');
		MutablePropertySources propertySources = this.environment.getPropertySources();
		List<ConfigDataEnvironmentContributor> contributors = new ArrayList<>(propertySources.size() + 10);
		PropertySource<?> defaultPropertySource = null;
		for (PropertySource<?> propertySource : propertySources) {
			if (DefaultPropertiesPropertySource.hasMatchingName(propertySource)) {
				defaultPropertySource = propertySource;
			}
			else {
				this.logger.trace(LogMessage.format('Creating wrapped config data contributor for "%s"',
						propertySource.getName()));
				contributors.add(ConfigDataEnvironmentContributor.ofExisting(propertySource,
						this.environment.getConversionService()));
			}
		}
		contributors.addAll(getInitialImportContributors(binder));
		if (defaultPropertySource != null) {
			this.logger.trace('Creating wrapped config data contributor for default property source');
			contributors.add(ConfigDataEnvironmentContributor.ofExisting(defaultPropertySource,
					this.environment.getConversionService()));
		}
		return createContributors(contributors);
	}
	protected ConfigDataEnvironmentContributors createContributors(
			List<ConfigDataEnvironmentContributor> contributors) {
		return new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapContext, contributors,
				this.environment.getConversionService());
	}
	ConfigDataEnvironmentContributors getContributors() {
		return this.contributors;
	}
	private List<ConfigDataEnvironmentContributor> getInitialImportContributors(Binder binder) {
		List<ConfigDataEnvironmentContributor> initialContributors = new ArrayList<>();
		addInitialImportContributors(initialContributors, bindLocations(binder, IMPORT_PROPERTY, EMPTY_LOCATIONS));
		addInitialImportContributors(initialContributors,
				bindLocations(binder, ADDITIONAL_LOCATION_PROPERTY, EMPTY_LOCATIONS));
		addInitialImportContributors(initialContributors,
				bindLocations(binder, LOCATION_PROPERTY, DEFAULT_SEARCH_LOCATIONS));
		return initialContributors;
	}
	private ConfigDataLocation[] bindLocations(Binder binder, String propertyName, ConfigDataLocation[] other) {
		return binder.bind(propertyName, CONFIG_DATA_LOCATION_ARRAY).orElse(other);
	}
	private void addInitialImportContributors(List<ConfigDataEnvironmentContributor> initialContributors,
			ConfigDataLocation[] locations) {
		for (int i = locations.length - 1; i >= 0; i--) {
			initialContributors.add(createInitialImportContributor(locations[i]));
		}
	}
	private ConfigDataEnvironmentContributor createInitialImportContributor(ConfigDataLocation location) {
		this.logger.trace(LogMessage.format('Adding initial config data import from location "%s"', location));
		return ConfigDataEnvironmentContributor.ofInitialImport(location, this.environment.getConversionService());
	}
	/**
	 * Process all contributions and apply any newly imported property sources to the
	 * {@link Environment}.
	 */
	void processAndApply() {
		ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, this.notFoundAction, this.resolvers,
				this.loaders);
		registerBootstrapBinder(this.contributors, null, DENY_INACTIVE_BINDING);
		ConfigDataEnvironmentContributors contributors = processInitial(this.contributors, importer);
		ConfigDataActivationContext activationContext = createActivationContext(
				contributors.getBinder(null, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE));
		contributors = processWithoutProfiles(contributors, importer, activationContext);
		activationContext = withProfiles(contributors, activationContext);
		contributors = processWithProfiles(contributors, importer, activationContext);
		applyToEnvironment(contributors, activationContext, importer.getLoadedLocations(),
				importer.getOptionalLocations());
	}
	private ConfigDataEnvironmentContributors processInitial(ConfigDataEnvironmentContributors contributors,
			ConfigDataImporter importer) {
		this.logger.trace('Processing initial config data environment contributors without activation context');
		contributors = contributors.withProcessedImports(importer, null);
		registerBootstrapBinder(contributors, null, DENY_INACTIVE_BINDING);
		return contributors;
	}
	private ConfigDataActivationContext createActivationContext(Binder initialBinder) {
		this.logger.trace('Creating config data activation context from initial contributions');
		try {
			return new ConfigDataActivationContext(this.environment, initialBinder);
		}
		catch (BindException ex) {
			if (ex.getCause() instanceof InactiveConfigDataAccessException inactiveException) {
				throw inactiveException;
			}
			throw ex;
		}
	}
	private ConfigDataEnvironmentContributors processWithoutProfiles(ConfigDataEnvironmentContributors contributors,
			ConfigDataImporter importer, ConfigDataActivationContext activationContext) {
		this.logger.trace('Processing config data environment contributors with initial activation context');
		contributors = contributors.withProcessedImports(importer, activationContext);
		registerBootstrapBinder(contributors, activationContext, DENY_INACTIVE_BINDING);
		return contributors;
	}
	private ConfigDataActivationContext withProfiles(ConfigDataEnvironmentContributors contributors,
			ConfigDataActivationContext activationContext) {
		this.logger.trace('Deducing profiles from current config data environment contributors');
		Binder binder = contributors.getBinder(activationContext,
				(contributor) -> !contributor.hasConfigDataOption(ConfigData.Option.IGNORE_PROFILES),
				BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);
		try {
			Set<String> additionalProfiles = new LinkedHashSet<>(this.additionalProfiles);
			additionalProfiles.addAll(getIncludedProfiles(contributors, activationContext));
			Profiles profiles = new Profiles(this.environment, binder, additionalProfiles);
			return activationContext.withProfiles(profiles);
		}
		catch (BindException ex) {
			if (ex.getCause() instanceof InactiveConfigDataAccessException inactiveException) {
				throw inactiveException;
			}
			throw ex;
		}
	}
	private Collection<? extends String> getIncludedProfiles(ConfigDataEnvironmentContributors contributors,
			ConfigDataActivationContext activationContext) {
		PlaceholdersResolver placeholdersResolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				contributors, activationContext, null, true, this.environment.getConversionService());
		Set<String> result = new LinkedHashSet<>();
		for (ConfigDataEnvironmentContributor contributor : contributors) {
			ConfigurationPropertySource source = contributor.getConfigurationPropertySource();
			if (source != null && !contributor.hasConfigDataOption(ConfigData.Option.IGNORE_PROFILES)) {
				Binder binder = new Binder(Collections.singleton(source), placeholdersResolver);
				binder.bind(Profiles.INCLUDE_PROFILES, STRING_LIST).ifBound((includes) -> {
					if (!contributor.isActive(activationContext)) {
						InactiveConfigDataAccessException.throwIfPropertyFound(contributor, Profiles.INCLUDE_PROFILES);
						InactiveConfigDataAccessException.throwIfPropertyFound(contributor,
								Profiles.INCLUDE_PROFILES.append('[0]'));
					}
					result.addAll(includes);
				});
			}
		}
		return result;
	}
	private ConfigDataEnvironmentContributors processWithProfiles(ConfigDataEnvironmentContributors contributors,
			ConfigDataImporter importer, ConfigDataActivationContext activationContext) {
		this.logger.trace('Processing config data environment contributors with profile activation context');
		contributors = contributors.withProcessedImports(importer, activationContext);
		registerBootstrapBinder(contributors, activationContext, ALLOW_INACTIVE_BINDING);
		return contributors;
	}
	private void registerBootstrapBinder(ConfigDataEnvironmentContributors contributors,
			ConfigDataActivationContext activationContext, BinderOption... binderOptions) {
		this.bootstrapContext.register(Binder.class,
				InstanceSupplier.from(() -> contributors.getBinder(activationContext, binderOptions))
					.withScope(Scope.PROTOTYPE));
	}
	private void applyToEnvironment(ConfigDataEnvironmentContributors contributors,
			ConfigDataActivationContext activationContext, Set<ConfigDataLocation> loadedLocations,
			Set<ConfigDataLocation> optionalLocations) {
		checkForInvalidProperties(contributors);
		checkMandatoryLocations(contributors, activationContext, loadedLocations, optionalLocations);
		MutablePropertySources propertySources = this.environment.getPropertySources();
		applyContributor(contributors, activationContext, propertySources);
		DefaultPropertiesPropertySource.moveToEnd(propertySources);
		Profiles profiles = activationContext.getProfiles();
		this.logger.trace(LogMessage.format('Setting default profiles: %s', profiles.getDefault()));
		this.environment.setDefaultProfiles(StringUtils.toStringArray(profiles.getDefault()));
		this.logger.trace(LogMessage.format('Setting active profiles: %s', profiles.getActive()));
		this.environment.setActiveProfiles(StringUtils.toStringArray(profiles.getActive()));
		this.environmentUpdateListener.onSetProfiles(profiles);
	}
	private void applyContributor(ConfigDataEnvironmentContributors contributors,
			ConfigDataActivationContext activationContext, MutablePropertySources propertySources) {
		this.logger.trace('Applying config data environment contributions');
		for (ConfigDataEnvironmentContributor contributor : contributors) {
			PropertySource<?> propertySource = contributor.getPropertySource();
			if (contributor.getKind() == ConfigDataEnvironmentContributor.Kind.BOUND_IMPORT && propertySource != null) {
				if (!contributor.isActive(activationContext)) {
					this.logger
						.trace(LogMessage.format('Skipping inactive property source "%s"', propertySource.getName()));
				}
				else {
					this.logger
						.trace(LogMessage.format('Adding imported property source "%s"', propertySource.getName()));
					propertySources.addLast(propertySource);
					this.environmentUpdateListener.onPropertySourceAdded(propertySource, contributor.getLocation(),
							contributor.getResource());
				}
			}
		}
	}
	private void checkForInvalidProperties(ConfigDataEnvironmentContributors contributors) {
		for (ConfigDataEnvironmentContributor contributor : contributors) {
			InvalidConfigDataPropertyException.throwIfPropertyFound(contributor);
		}
	}
	private void checkMandatoryLocations(ConfigDataEnvironmentContributors contributors,
			ConfigDataActivationContext activationContext, Set<ConfigDataLocation> loadedLocations,
			Set<ConfigDataLocation> optionalLocations) {
		Set<ConfigDataLocation> mandatoryLocations = new LinkedHashSet<>();
		for (ConfigDataEnvironmentContributor contributor : contributors) {
			if (contributor.isActive(activationContext)) {
				mandatoryLocations.addAll(getMandatoryImports(contributor));
			}
		}
		for (ConfigDataEnvironmentContributor contributor : contributors) {
			if (contributor.getLocation() != null) {
				mandatoryLocations.remove(contributor.getLocation());
			}
		}
		mandatoryLocations.removeAll(loadedLocations);
		mandatoryLocations.removeAll(optionalLocations);
		if (!mandatoryLocations.isEmpty()) {
			for (ConfigDataLocation mandatoryLocation : mandatoryLocations) {
				this.notFoundAction.handle(this.logger, new ConfigDataLocationNotFoundException(mandatoryLocation));
			}
		}
	}
	private Set<ConfigDataLocation> getMandatoryImports(ConfigDataEnvironmentContributor contributor) {
		List<ConfigDataLocation> imports = contributor.getImports();
		Set<ConfigDataLocation> mandatoryLocations = new LinkedHashSet<>(imports.size());
		for (ConfigDataLocation location : imports) {
			if (!location.isOptional()) {
				mandatoryLocations.add(location);
			}
		}
		return mandatoryLocations;
	}
}
/*
package org.springframework.boot.context.config;
/**
public final class ConfigDataLocation implements OriginProvider {
	/**
	 * Prefix used to indicate that a {@link ConfigDataResource} is optional.
	 */
	public static final String OPTIONAL_PREFIX = 'optional:';
	private final boolean optional;
	private final String value;
	private final Origin origin;
	private ConfigDataLocation(boolean optional, String value, Origin origin) {
		this.value = value;
		this.optional = optional;
		this.origin = origin;
	}
	/**
	 * Return if the location is optional and should ignore
	 * {@link ConfigDataNotFoundException}.
	 * @return if the location is optional
	 */
	public boolean isOptional() {
		return this.optional;
	}
	/**
	 * Return the value of the location (always excluding any user specified
	 * {@code optional:} prefix).
	 * @return the location value
	 */
	public String getValue() {
		return this.value;
	}
	/**
	 * Return if {@link #getValue()} has the specified prefix.
	 * @param prefix the prefix to check
	 * @return if the value has the prefix
	 */
	public boolean hasPrefix(String prefix) {
		return this.value.startsWith(prefix);
	}
	/**
	 * Return {@link #getValue()} with the specified prefix removed. If the location does
	 * not have the given prefix then the {@link #getValue()} is returned unchanged.
	 * @param prefix the prefix to check
	 * @return the value with the prefix removed
	 */
	public String getNonPrefixedValue(String prefix) {
		if (hasPrefix(prefix)) {
			return this.value.substring(prefix.length());
		}
		return this.value;
	}
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	/**
	 * Return an array of {@link ConfigDataLocation} elements built by splitting this
	 * {@link ConfigDataLocation} around a delimiter of {@code ';'}.
	 * @return the split locations
	 * @since 2.4.7
	 */
	public ConfigDataLocation[] split() {
		return split(';');
	}
	/**
	 * Return an array of {@link ConfigDataLocation} elements built by splitting this
	 * {@link ConfigDataLocation} around the specified delimiter.
	 * @param delimiter the delimiter to split on
	 * @return the split locations
	 * @since 2.4.7
	 */
	public ConfigDataLocation[] split(String delimiter) {
		String[] values = StringUtils.delimitedListToStringArray(toString(), delimiter);
		ConfigDataLocation[] result = new ConfigDataLocation[values.length];
		for (int i = 0; i < values.length; i++) {
			result[i] = of(values[i]).withOrigin(getOrigin());
		}
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ConfigDataLocation other = (ConfigDataLocation) obj;
		return this.value.equals(other.value);
	}
	@Override
	public int hashCode() {
		return this.value.hashCode();
	}
	@Override
	public String toString() {
		return (!this.optional) ? this.value : OPTIONAL_PREFIX + this.value;
	}
	/**
	 * Create a new {@link ConfigDataLocation} with a specific {@link Origin}.
	 * @param origin the origin to set
	 * @return a new {@link ConfigDataLocation} instance.
	 */
	ConfigDataLocation withOrigin(Origin origin) {
		return new ConfigDataLocation(this.optional, this.value, origin);
	}
	/**
	 * Factory method to create a new {@link ConfigDataLocation} from a string.
	 * @param location the location string
	 * @return a {@link ConfigDataLocation} instance or {@code null} if no location was
	 * provided
	 */
	public static ConfigDataLocation of(String location) {
		boolean optional = location != null && location.startsWith(OPTIONAL_PREFIX);
		String value = (!optional) ? location : location.substring(OPTIONAL_PREFIX.length());
		if (!StringUtils.hasText(value)) {
			return null;
		}
		return new ConfigDataLocation(optional, value, null);
	}
}
/*
package org.springframework.boot.context.config;
/**
public class StandardConfigDataLocationResolver
		implements ConfigDataLocationResolver<StandardConfigDataResource>, Ordered {
	private static final String PREFIX = 'resource:';
	static final String CONFIG_NAME_PROPERTY = 'spring.config.name';
	static final String[] DEFAULT_CONFIG_NAMES = { 'application' };
	private static final Pattern URL_PREFIX = Pattern.compile('^([a-zA-Z][a-zA-Z0-9*]*?:)(.*$)');
	private static final Pattern EXTENSION_HINT_PATTERN = Pattern.compile('^(.*)\\[(\\.\\w+)](?!\\[)$');
	private static final String NO_PROFILE = null;
	private final Log logger;
	private final List<PropertySourceLoader> propertySourceLoaders;
	private final String[] configNames;
	private final LocationResourceLoader resourceLoader;
	/**
	 * Create a new {@link StandardConfigDataLocationResolver} instance.
	 * @param logFactory the factory for loggers to use
	 * @param binder a binder backed by the initial {@link Environment}
	 * @param resourceLoader a {@link ResourceLoader} used to load resources
	 */
	public StandardConfigDataLocationResolver(DeferredLogFactory logFactory, Binder binder,
			ResourceLoader resourceLoader) {
		this.logger = logFactory.getLog(StandardConfigDataLocationResolver.class);
		this.propertySourceLoaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class,
				getClass().getClassLoader());
		this.configNames = getConfigNames(binder);
		this.resourceLoader = new LocationResourceLoader(resourceLoader);
	}
	private String[] getConfigNames(Binder binder) {
		String[] configNames = binder.bind(CONFIG_NAME_PROPERTY, String[].class).orElse(DEFAULT_CONFIG_NAMES);
		for (String configName : configNames) {
			validateConfigName(configName);
		}
		return configNames;
	}
	private void validateConfigName(String name) {
		Assert.state(!name.contains('*'), () -> 'Config name "' + name + '" cannot contain "*"');
	}
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE;
	}
	@Override
	public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
		return true;
	}
	@Override
	public List<StandardConfigDataResource> resolve(ConfigDataLocationResolverContext context,
			ConfigDataLocation location) throws ConfigDataNotFoundException {
		return resolve(getReferences(context, location.split()));
	}
	private Set<StandardConfigDataReference> getReferences(ConfigDataLocationResolverContext context,
			ConfigDataLocation[] configDataLocations) {
		Set<StandardConfigDataReference> references = new LinkedHashSet<>();
		for (ConfigDataLocation configDataLocation : configDataLocations) {
			references.addAll(getReferences(context, configDataLocation));
		}
		return references;
	}
	private Set<StandardConfigDataReference> getReferences(ConfigDataLocationResolverContext context,
			ConfigDataLocation configDataLocation) {
		String resourceLocation = getResourceLocation(context, configDataLocation);
		try {
			if (isDirectory(resourceLocation)) {
				return getReferencesForDirectory(configDataLocation, resourceLocation, NO_PROFILE);
			}
			return getReferencesForFile(configDataLocation, resourceLocation, NO_PROFILE);
		}
		catch (RuntimeException ex) {
			throw new IllegalStateException('Unable to load config data from "' + configDataLocation + '"', ex);
		}
	}
	@Override
	public List<StandardConfigDataResource> resolveProfileSpecific(ConfigDataLocationResolverContext context,
			ConfigDataLocation location, Profiles profiles) {
		return resolve(getProfileSpecificReferences(context, location.split(), profiles));
	}
	private Set<StandardConfigDataReference> getProfileSpecificReferences(ConfigDataLocationResolverContext context,
			ConfigDataLocation[] configDataLocations, Profiles profiles) {
		Set<StandardConfigDataReference> references = new LinkedHashSet<>();
		for (String profile : profiles) {
			for (ConfigDataLocation configDataLocation : configDataLocations) {
				String resourceLocation = getResourceLocation(context, configDataLocation);
				references.addAll(getReferences(configDataLocation, resourceLocation, profile));
			}
		}
		return references;
	}
	private String getResourceLocation(ConfigDataLocationResolverContext context,
			ConfigDataLocation configDataLocation) {
		String resourceLocation = configDataLocation.getNonPrefixedValue(PREFIX);
		boolean isAbsolute = resourceLocation.startsWith('/') || URL_PREFIX.matcher(resourceLocation).matches();
		if (isAbsolute) {
			return resourceLocation;
		}
		ConfigDataResource parent = context.getParent();
		if (parent instanceof StandardConfigDataResource resource) {
			String parentResourceLocation = resource.getReference().getResourceLocation();
			String parentDirectory = parentResourceLocation.substring(0, parentResourceLocation.lastIndexOf('/') + 1);
			return parentDirectory + resourceLocation;
		}
		return resourceLocation;
	}
	private Set<StandardConfigDataReference> getReferences(ConfigDataLocation configDataLocation,
			String resourceLocation, String profile) {
		if (isDirectory(resourceLocation)) {
			return getReferencesForDirectory(configDataLocation, resourceLocation, profile);
		}
		return getReferencesForFile(configDataLocation, resourceLocation, profile);
	}
	private Set<StandardConfigDataReference> getReferencesForDirectory(ConfigDataLocation configDataLocation,
			String directory, String profile) {
		Set<StandardConfigDataReference> references = new LinkedHashSet<>();
		for (String name : this.configNames) {
			Deque<StandardConfigDataReference> referencesForName = getReferencesForConfigName(name, configDataLocation,
					directory, profile);
			references.addAll(referencesForName);
		}
		return references;
	}
	private Deque<StandardConfigDataReference> getReferencesForConfigName(String name,
			ConfigDataLocation configDataLocation, String directory, String profile) {
		Deque<StandardConfigDataReference> references = new ArrayDeque<>();
		for (PropertySourceLoader propertySourceLoader : this.propertySourceLoaders) {
			for (String extension : propertySourceLoader.getFileExtensions()) {
				StandardConfigDataReference reference = new StandardConfigDataReference(configDataLocation, directory,
						directory + name, profile, extension, propertySourceLoader);
				if (!references.contains(reference)) {
					references.addFirst(reference);
				}
			}
		}
		return references;
	}
	private Set<StandardConfigDataReference> getReferencesForFile(ConfigDataLocation configDataLocation, String file,
			String profile) {
		Matcher extensionHintMatcher = EXTENSION_HINT_PATTERN.matcher(file);
		boolean extensionHintLocation = extensionHintMatcher.matches();
		if (extensionHintLocation) {
			file = extensionHintMatcher.group(1) + extensionHintMatcher.group(2);
		}
		for (PropertySourceLoader propertySourceLoader : this.propertySourceLoaders) {
			String extension = getLoadableFileExtension(propertySourceLoader, file);
			if (extension != null) {
				String root = file.substring(0, file.length() - extension.length() - 1);
				StandardConfigDataReference reference = new StandardConfigDataReference(configDataLocation, null, root,
						profile, (!extensionHintLocation) ? extension : null, propertySourceLoader);
				return Collections.singleton(reference);
			}
		}
		if (configDataLocation.isOptional()) {
			return Collections.emptySet();
		}
		if (configDataLocation.hasPrefix(PREFIX) || configDataLocation.hasPrefix(ResourceUtils.FILE_URL_PREFIX)
				|| configDataLocation.hasPrefix(ResourceUtils.CLASSPATH_URL_PREFIX)
				|| configDataLocation.toString().indexOf(":") == -1) {
			throw new IllegalStateException('File extension is not known to any PropertySourceLoader. '
					+ 'If the location is meant to reference a directory, it must end in "/" or File.separator');
		}
		throw new IllegalStateException(
				'Incorrect ConfigDataLocationResolver chosen or file extension is not known to any PropertySourceLoader. '
						+ 'If the location is meant to reference a directory, it must end in "/" or File.separator. '
						+ 'The location is being resolved using the StandardConfigDataLocationResolver, '
						+ 'check the location prefix if a different resolver is expected');
	}
	private String getLoadableFileExtension(PropertySourceLoader loader, String file) {
		for (String fileExtension : loader.getFileExtensions()) {
			if (StringUtils.endsWithIgnoreCase(file, fileExtension)) {
				return fileExtension;
			}
		}
		return null;
	}
	private boolean isDirectory(String resourceLocation) {
		return resourceLocation.endsWith('/') || resourceLocation.endsWith(File.separator);
	}
	private List<StandardConfigDataResource> resolve(Set<StandardConfigDataReference> references) {
		List<StandardConfigDataResource> resolved = new ArrayList<>();
		for (StandardConfigDataReference reference : references) {
			resolved.addAll(resolve(reference));
		}
		if (resolved.isEmpty()) {
			resolved.addAll(resolveEmptyDirectories(references));
		}
		return resolved;
	}
	private Collection<StandardConfigDataResource> resolveEmptyDirectories(
			Set<StandardConfigDataReference> references) {
		Set<StandardConfigDataResource> empty = new LinkedHashSet<>();
		for (StandardConfigDataReference reference : references) {
			if (reference.getDirectory() != null) {
				empty.addAll(resolveEmptyDirectories(reference));
			}
		}
		return empty;
	}
	private Set<StandardConfigDataResource> resolveEmptyDirectories(StandardConfigDataReference reference) {
		if (!this.resourceLoader.isPattern(reference.getResourceLocation())) {
			return resolveNonPatternEmptyDirectories(reference);
		}
		return resolvePatternEmptyDirectories(reference);
	}
	private Set<StandardConfigDataResource> resolveNonPatternEmptyDirectories(StandardConfigDataReference reference) {
		Resource resource = this.resourceLoader.getResource(reference.getDirectory());
		return (resource instanceof ClassPathResource || !resource.exists()) ? Collections.emptySet()
				: Collections.singleton(new StandardConfigDataResource(reference, resource, true));
	}
	private Set<StandardConfigDataResource> resolvePatternEmptyDirectories(StandardConfigDataReference reference) {
		Resource[] subdirectories = this.resourceLoader.getResources(reference.getDirectory(), ResourceType.DIRECTORY);
		ConfigDataLocation location = reference.getConfigDataLocation();
		if (!location.isOptional() && ObjectUtils.isEmpty(subdirectories)) {
			String message = String.format('Config data location "%s" contains no subdirectories', location);
			throw new ConfigDataLocationNotFoundException(location, message, null);
		}
		return Arrays.stream(subdirectories)
			.filter(Resource::exists)
			.map((resource) -> new StandardConfigDataResource(reference, resource, true))
			.collect(Collectors.toCollection(LinkedHashSet::new));
	}
	private List<StandardConfigDataResource> resolve(StandardConfigDataReference reference) {
		if (!this.resourceLoader.isPattern(reference.getResourceLocation())) {
			return resolveNonPattern(reference);
		}
		return resolvePattern(reference);
	}
	private List<StandardConfigDataResource> resolveNonPattern(StandardConfigDataReference reference) {
		Resource resource = this.resourceLoader.getResource(reference.getResourceLocation());
		if (!resource.exists() && reference.isSkippable()) {
			logSkippingResource(reference);
			return Collections.emptyList();
		}
		return Collections.singletonList(createConfigResourceLocation(reference, resource));
	}
	private List<StandardConfigDataResource> resolvePattern(StandardConfigDataReference reference) {
		List<StandardConfigDataResource> resolved = new ArrayList<>();
		for (Resource resource : this.resourceLoader.getResources(reference.getResourceLocation(), ResourceType.FILE)) {
			if (!resource.exists() && reference.isSkippable()) {
				logSkippingResource(reference);
			}
			else {
				resolved.add(createConfigResourceLocation(reference, resource));
			}
		}
		return resolved;
	}
	private void logSkippingResource(StandardConfigDataReference reference) {
		this.logger.trace(LogMessage.format('Skipping missing resource %s', reference));
	}
	private StandardConfigDataResource createConfigResourceLocation(StandardConfigDataReference reference,
			Resource resource) {
		return new StandardConfigDataResource(reference, resource);
	}
}
/*
package org.springframework.boot.context.config;
/**
public class AnsiOutputApplicationListener
		implements ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {
	@Override
	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
		ConfigurableEnvironment environment = event.getEnvironment();
		Binder.get(environment)
			.bind('spring.output.ansi.enabled', AnsiOutput.Enabled.class)
			.ifBound(AnsiOutput::setEnabled);
		AnsiOutput.setConsoleAvailable(environment.getProperty('spring.output.ansi.console-available', Boolean.class));
	}
	@Override
	public int getOrder() {
		// Apply after EnvironmentPostProcessorApplicationListener
		return EnvironmentPostProcessorApplicationListener.DEFAULT_ORDER + 1;
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataActivationContext {
	private final CloudPlatform cloudPlatform;
	private final Profiles profiles;
	/**
	 * Create a new {@link ConfigDataActivationContext} instance before any profiles have
	 * been activated.
	 * @param environment the source environment
	 * @param binder a binder providing access to relevant config data contributions
	 */
	ConfigDataActivationContext(Environment environment, Binder binder) {
		this.cloudPlatform = deduceCloudPlatform(environment, binder);
		this.profiles = null;
	}
	/**
	 * Create a new {@link ConfigDataActivationContext} instance with the given
	 * {@link CloudPlatform} and {@link Profiles}.
	 * @param cloudPlatform the cloud platform
	 * @param profiles the profiles
	 */
	ConfigDataActivationContext(CloudPlatform cloudPlatform, Profiles profiles) {
		this.cloudPlatform = cloudPlatform;
		this.profiles = profiles;
	}
	private CloudPlatform deduceCloudPlatform(Environment environment, Binder binder) {
		for (CloudPlatform candidate : CloudPlatform.values()) {
			if (candidate.isEnforced(binder)) {
				return candidate;
			}
		}
		return CloudPlatform.getActive(environment);
	}
	/**
	 * Return a new {@link ConfigDataActivationContext} with specific profiles.
	 * @param profiles the profiles
	 * @return a new {@link ConfigDataActivationContext} with specific profiles
	 */
	ConfigDataActivationContext withProfiles(Profiles profiles) {
		return new ConfigDataActivationContext(this.cloudPlatform, profiles);
	}
	/**
	 * Return the active {@link CloudPlatform} or {@code null}.
	 * @return the active cloud platform
	 */
	CloudPlatform getCloudPlatform() {
		return this.cloudPlatform;
	}
	/**
	 * Return profile information if it is available.
	 * @return profile information or {@code null}
	 */
	Profiles getProfiles() {
		return this.profiles;
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this);
		creator.append('cloudPlatform', this.cloudPlatform);
		creator.append('profiles', this.profiles);
		return creator.toString();
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentContributor implements Iterable<ConfigDataEnvironmentContributor> {
	private static final ConfigData.Options EMPTY_LOCATION_OPTIONS = ConfigData.Options
		.of(ConfigData.Option.IGNORE_IMPORTS);
	private final ConfigDataLocation location;
	private final ConfigDataResource resource;
	private final boolean fromProfileSpecificImport;
	private final PropertySource<?> propertySource;
	private final ConfigurationPropertySource configurationPropertySource;
	private final ConfigDataProperties properties;
	private final ConfigData.Options configDataOptions;
	private final Map<ImportPhase, List<ConfigDataEnvironmentContributor>> children;
	private final Kind kind;
	private final ConversionService conversionService;
	/**
	 * Create a new {@link ConfigDataEnvironmentContributor} instance.
	 * @param kind the contributor kind
	 * @param location the location of this contributor
	 * @param resource the resource that contributed the data or {@code null}
	 * @param fromProfileSpecificImport if the contributor is from a profile specific
	 * import
	 * @param propertySource the property source for the data or {@code null}
	 * @param configurationPropertySource the configuration property source for the data
	 * or {@code null}
	 * @param properties the config data properties or {@code null}
	 * @param configDataOptions any config data options that should apply
	 * @param children the children of this contributor at each {@link ImportPhase}
	 * @param conversionService the conversion service to use
	 */
	ConfigDataEnvironmentContributor(Kind kind, ConfigDataLocation location, ConfigDataResource resource,
			boolean fromProfileSpecificImport, PropertySource<?> propertySource,
			ConfigurationPropertySource configurationPropertySource, ConfigDataProperties properties,
			ConfigData.Options configDataOptions, Map<ImportPhase, List<ConfigDataEnvironmentContributor>> children,
			ConversionService conversionService) {
		this.kind = kind;
		this.location = location;
		this.resource = resource;
		this.fromProfileSpecificImport = fromProfileSpecificImport;
		this.properties = properties;
		this.propertySource = propertySource;
		this.configurationPropertySource = configurationPropertySource;
		this.configDataOptions = (configDataOptions != null) ? configDataOptions : ConfigData.Options.NONE;
		this.children = (children != null) ? children : Collections.emptyMap();
		this.conversionService = conversionService;
	}
	/**
	 * Return the contributor kind.
	 * @return the kind of contributor
	 */
	Kind getKind() {
		return this.kind;
	}
	ConfigDataLocation getLocation() {
		return this.location;
	}
	/**
	 * Return if this contributor is currently active.
	 * @param activationContext the activation context
	 * @return if the contributor is active
	 */
	boolean isActive(ConfigDataActivationContext activationContext) {
		if (this.kind == Kind.UNBOUND_IMPORT) {
			return false;
		}
		return this.properties == null || this.properties.isActive(activationContext);
	}
	/**
	 * Return the resource that contributed this instance.
	 * @return the resource or {@code null}
	 */
	ConfigDataResource getResource() {
		return this.resource;
	}
	/**
	 * Return if the contributor is from a profile specific import.
	 * @return if the contributor is profile specific
	 */
	boolean isFromProfileSpecificImport() {
		return this.fromProfileSpecificImport;
	}
	/**
	 * Return the property source for this contributor.
	 * @return the property source or {@code null}
	 */
	PropertySource<?> getPropertySource() {
		return this.propertySource;
	}
	/**
	 * Return the configuration property source for this contributor.
	 * @return the configuration property source or {@code null}
	 */
	ConfigurationPropertySource getConfigurationPropertySource() {
		return this.configurationPropertySource;
	}
	/**
	 * Return if the contributor has a specific config data option.
	 * @param option the option to check
	 * @return {@code true} if the option is present
	 */
	boolean hasConfigDataOption(ConfigData.Option option) {
		return this.configDataOptions.contains(option);
	}
	ConfigDataEnvironmentContributor withoutConfigDataOption(ConfigData.Option option) {
		return new ConfigDataEnvironmentContributor(this.kind, this.location, this.resource,
				this.fromProfileSpecificImport, this.propertySource, this.configurationPropertySource, this.properties,
				this.configDataOptions.without(option), this.children, this.conversionService);
	}
	/**
	 * Return any imports requested by this contributor.
	 * @return the imports
	 */
	List<ConfigDataLocation> getImports() {
		return (this.properties != null) ? this.properties.getImports() : Collections.emptyList();
	}
	/**
	 * Return true if this contributor has imports that have not yet been processed in the
	 * given phase.
	 * @param importPhase the import phase
	 * @return if there are unprocessed imports
	 */
	boolean hasUnprocessedImports(ImportPhase importPhase) {
		if (getImports().isEmpty()) {
			return false;
		}
		return !this.children.containsKey(importPhase);
	}
	/**
	 * Return children of this contributor for the given phase.
	 * @param importPhase the import phase
	 * @return a list of children
	 */
	List<ConfigDataEnvironmentContributor> getChildren(ImportPhase importPhase) {
		return this.children.getOrDefault(importPhase, Collections.emptyList());
	}
	/**
	 * Returns a {@link Stream} that traverses this contributor and all its children in
	 * priority order.
	 * @return the stream
	 */
	Stream<ConfigDataEnvironmentContributor> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	/**
	 * Returns an {@link Iterator} that traverses this contributor and all its children in
	 * priority order.
	 * @return the iterator
	 * @see java.lang.Iterable#iterator()
	 */
	@Override
	public Iterator<ConfigDataEnvironmentContributor> iterator() {
		return new ContributorIterator();
	}
	/**
	 * Create a new {@link ConfigDataEnvironmentContributor} with bound
	 * {@link ConfigDataProperties}.
	 * @param contributors the contributors used for binding
	 * @param activationContext the activation context
	 * @return a new contributor instance
	 */
	ConfigDataEnvironmentContributor withBoundProperties(Iterable<ConfigDataEnvironmentContributor> contributors,
			ConfigDataActivationContext activationContext) {
		Iterable<ConfigurationPropertySource> sources = Collections.singleton(getConfigurationPropertySource());
		PlaceholdersResolver placeholdersResolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				contributors, activationContext, this, true, this.conversionService);
		Binder binder = new Binder(sources, placeholdersResolver, null, null, null);
		ConfigDataProperties properties = ConfigDataProperties.get(binder);
		if (properties != null && this.configDataOptions.contains(ConfigData.Option.IGNORE_IMPORTS)) {
			properties = properties.withoutImports();
		}
		return new ConfigDataEnvironmentContributor(Kind.BOUND_IMPORT, this.location, this.resource,
				this.fromProfileSpecificImport, this.propertySource, this.configurationPropertySource, properties,
				this.configDataOptions, null, this.conversionService);
	}
	/**
	 * Create a new {@link ConfigDataEnvironmentContributor} instance with a new set of
	 * children for the given phase.
	 * @param importPhase the import phase
	 * @param children the new children
	 * @return a new contributor instance
	 */
	ConfigDataEnvironmentContributor withChildren(ImportPhase importPhase,
			List<ConfigDataEnvironmentContributor> children) {
		Map<ImportPhase, List<ConfigDataEnvironmentContributor>> updatedChildren = new LinkedHashMap<>(this.children);
		updatedChildren.put(importPhase, children);
		if (importPhase == ImportPhase.AFTER_PROFILE_ACTIVATION) {
			moveProfileSpecific(updatedChildren);
		}
		return new ConfigDataEnvironmentContributor(this.kind, this.location, this.resource,
				this.fromProfileSpecificImport, this.propertySource, this.configurationPropertySource, this.properties,
				this.configDataOptions, updatedChildren, this.conversionService);
	}
	private void moveProfileSpecific(Map<ImportPhase, List<ConfigDataEnvironmentContributor>> children) {
		List<ConfigDataEnvironmentContributor> before = children.get(ImportPhase.BEFORE_PROFILE_ACTIVATION);
		if (!hasAnyProfileSpecificChildren(before)) {
			return;
		}
		List<ConfigDataEnvironmentContributor> updatedBefore = new ArrayList<>(before.size());
		List<ConfigDataEnvironmentContributor> updatedAfter = new ArrayList<>();
		for (ConfigDataEnvironmentContributor contributor : before) {
			updatedBefore.add(moveProfileSpecificChildren(contributor, updatedAfter));
		}
		updatedAfter.addAll(children.getOrDefault(ImportPhase.AFTER_PROFILE_ACTIVATION, Collections.emptyList()));
		children.put(ImportPhase.BEFORE_PROFILE_ACTIVATION, updatedBefore);
		children.put(ImportPhase.AFTER_PROFILE_ACTIVATION, updatedAfter);
	}
	private ConfigDataEnvironmentContributor moveProfileSpecificChildren(ConfigDataEnvironmentContributor contributor,
			List<ConfigDataEnvironmentContributor> removed) {
		for (ImportPhase importPhase : ImportPhase.values()) {
			List<ConfigDataEnvironmentContributor> children = contributor.getChildren(importPhase);
			List<ConfigDataEnvironmentContributor> updatedChildren = new ArrayList<>(children.size());
			for (ConfigDataEnvironmentContributor child : children) {
				if (child.hasConfigDataOption(ConfigData.Option.PROFILE_SPECIFIC)) {
					removed.add(child.withoutConfigDataOption(ConfigData.Option.PROFILE_SPECIFIC));
				}
				else {
					updatedChildren.add(child);
				}
			}
			contributor = contributor.withChildren(importPhase, updatedChildren);
		}
		return contributor;
	}
	private boolean hasAnyProfileSpecificChildren(List<ConfigDataEnvironmentContributor> contributors) {
		if (CollectionUtils.isEmpty(contributors)) {
			return false;
		}
		for (ConfigDataEnvironmentContributor contributor : contributors) {
			for (ImportPhase importPhase : ImportPhase.values()) {
				if (contributor.getChildren(importPhase)
					.stream()
					.anyMatch((child) -> child.hasConfigDataOption(ConfigData.Option.PROFILE_SPECIFIC))) {
					return true;
				}
			}
		}
		return false;
	}
	/**
	 * Create a new {@link ConfigDataEnvironmentContributor} instance where an existing
	 * child is replaced.
	 * @param existing the existing node that should be replaced
	 * @param replacement the replacement node that should be used instead
	 * @return a new {@link ConfigDataEnvironmentContributor} instance
	 */
	ConfigDataEnvironmentContributor withReplacement(ConfigDataEnvironmentContributor existing,
			ConfigDataEnvironmentContributor replacement) {
		if (this == existing) {
			return replacement;
		}
		Map<ImportPhase, List<ConfigDataEnvironmentContributor>> updatedChildren = new LinkedHashMap<>(
				this.children.size());
		this.children.forEach((importPhase, contributors) -> {
			List<ConfigDataEnvironmentContributor> updatedContributors = new ArrayList<>(contributors.size());
			for (ConfigDataEnvironmentContributor contributor : contributors) {
				updatedContributors.add(contributor.withReplacement(existing, replacement));
			}
			updatedChildren.put(importPhase, Collections.unmodifiableList(updatedContributors));
		});
		return new ConfigDataEnvironmentContributor(this.kind, this.location, this.resource,
				this.fromProfileSpecificImport, this.propertySource, this.configurationPropertySource, this.properties,
				this.configDataOptions, updatedChildren, this.conversionService);
	}
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		buildToString('', builder);
		return builder.toString();
	}
	private void buildToString(String prefix, StringBuilder builder) {
		builder.append(prefix);
		builder.append(this.kind);
		builder.append(' ');
		builder.append(this.location);
		builder.append(' ');
		builder.append(this.resource);
		builder.append(' ');
		builder.append(this.configDataOptions);
		builder.append('\n');
		for (ConfigDataEnvironmentContributor child : this.children.getOrDefault(ImportPhase.BEFORE_PROFILE_ACTIVATION,
				Collections.emptyList())) {
			child.buildToString(prefix + '    ', builder);
		}
		for (ConfigDataEnvironmentContributor child : this.children.getOrDefault(ImportPhase.AFTER_PROFILE_ACTIVATION,
				Collections.emptyList())) {
			child.buildToString(prefix + '    ', builder);
		}
	}
	/**
	 * Factory method to create a {@link Kind#ROOT root} contributor.
	 * @param contributors the immediate children of the root
	 * @param conversionService the conversion service to use
	 * @return a new {@link ConfigDataEnvironmentContributor} instance
	 */
	static ConfigDataEnvironmentContributor of(List<ConfigDataEnvironmentContributor> contributors,
			ConversionService conversionService) {
		Map<ImportPhase, List<ConfigDataEnvironmentContributor>> children = new LinkedHashMap<>();
		children.put(ImportPhase.BEFORE_PROFILE_ACTIVATION, Collections.unmodifiableList(contributors));
		return new ConfigDataEnvironmentContributor(Kind.ROOT, null, null, false, null, null, null, null, children,
				conversionService);
	}
	/**
	 * Factory method to create a {@link Kind#INITIAL_IMPORT initial import} contributor.
	 * This contributor is used to trigger initial imports of additional contributors. It
	 * does not contribute any properties itself.
	 * @param initialImport the initial import location (with placeholders resolved)
	 * @param conversionService the conversion service to use
	 * @return a new {@link ConfigDataEnvironmentContributor} instance
	 */
	static ConfigDataEnvironmentContributor ofInitialImport(ConfigDataLocation initialImport,
			ConversionService conversionService) {
		List<ConfigDataLocation> imports = Collections.singletonList(initialImport);
		ConfigDataProperties properties = new ConfigDataProperties(imports, null);
		return new ConfigDataEnvironmentContributor(Kind.INITIAL_IMPORT, null, null, false, null, null, properties,
				null, null, conversionService);
	}
	/**
	 * Factory method to create a contributor that wraps an {@link Kind#EXISTING existing}
	 * property source. The contributor provides access to existing properties, but
	 * doesn"t actively import any additional contributors.
	 * @param propertySource the property source to wrap
	 * @param conversionService the conversion service to use
	 * @return a new {@link ConfigDataEnvironmentContributor} instance
	 */
	static ConfigDataEnvironmentContributor ofExisting(PropertySource<?> propertySource,
			ConversionService conversionService) {
		return new ConfigDataEnvironmentContributor(Kind.EXISTING, null, null, false, propertySource,
				ConfigurationPropertySource.from(propertySource), null, null, null, conversionService);
	}
	/**
	 * Factory method to create an {@link Kind#UNBOUND_IMPORT unbound import} contributor.
	 * This contributor has been actively imported from another contributor and may itself
	 * import further contributors later.
	 * @param location the location of this contributor
	 * @param resource the config data resource
	 * @param profileSpecific if the contributor is from a profile specific import
	 * @param configData the config data
	 * @param propertySourceIndex the index of the property source that should be used
	 * @param conversionService the conversion service to use
	 * @return a new {@link ConfigDataEnvironmentContributor} instance
	 */
	static ConfigDataEnvironmentContributor ofUnboundImport(ConfigDataLocation location, ConfigDataResource resource,
			boolean profileSpecific, ConfigData configData, int propertySourceIndex,
			ConversionService conversionService) {
		PropertySource<?> propertySource = configData.getPropertySources().get(propertySourceIndex);
		ConfigData.Options options = configData.getOptions(propertySource);
		ConfigurationPropertySource configurationPropertySource = ConfigurationPropertySource.from(propertySource);
		return new ConfigDataEnvironmentContributor(Kind.UNBOUND_IMPORT, location, resource, profileSpecific,
				propertySource, configurationPropertySource, null, options, null, conversionService);
	}
	/**
	 * Factory method to create an {@link Kind#EMPTY_LOCATION empty location} contributor.
	 * @param location the location of this contributor
	 * @param profileSpecific if the contributor is from a profile specific import
	 * @param conversionService the conversion service to use
	 * @return a new {@link ConfigDataEnvironmentContributor} instance
	 */
	static ConfigDataEnvironmentContributor ofEmptyLocation(ConfigDataLocation location, boolean profileSpecific,
			ConversionService conversionService) {
		return new ConfigDataEnvironmentContributor(Kind.EMPTY_LOCATION, location, null, profileSpecific, null, null,
				null, EMPTY_LOCATION_OPTIONS, null, conversionService);
	}
	/**
	 * The various kinds of contributor.
	 */
	enum Kind {
		/**
		 * A root contributor used contain the initial set of children.
		 */
		ROOT,
		/**
		 * An initial import that needs to be processed.
		 */
		INITIAL_IMPORT,
		/**
		 * An existing property source that contributes properties but no imports.
		 */
		EXISTING,
		/**
		 * A contributor with {@link ConfigData} imported from another contributor but not
		 * yet bound.
		 */
		UNBOUND_IMPORT,
		/**
		 * A contributor with {@link ConfigData} imported from another contributor that
		 * has been.
		 */
		BOUND_IMPORT,
		/**
		 * A valid location that contained nothing to load.
		 */
		EMPTY_LOCATION
	}
	/**
	 * Import phases that can be used when obtaining imports.
	 */
	enum ImportPhase {
		/**
		 * The phase before profiles have been activated.
		 */
		BEFORE_PROFILE_ACTIVATION,
		/**
		 * The phase after profiles have been activated.
		 */
		AFTER_PROFILE_ACTIVATION;
		/**
		 * Return the {@link ImportPhase} based on the given activation context.
		 * @param activationContext the activation context
		 * @return the import phase
		 */
		static ImportPhase get(ConfigDataActivationContext activationContext) {
			if (activationContext != null && activationContext.getProfiles() != null) {
				return AFTER_PROFILE_ACTIVATION;
			}
			return BEFORE_PROFILE_ACTIVATION;
		}
	}
	/**
	 * Iterator that traverses the contributor tree.
	 */
	private final class ContributorIterator implements Iterator<ConfigDataEnvironmentContributor> {
		private ImportPhase phase;
		private Iterator<ConfigDataEnvironmentContributor> children;
		private Iterator<ConfigDataEnvironmentContributor> current;
		private ConfigDataEnvironmentContributor next;
		private ContributorIterator() {
			this.phase = ImportPhase.AFTER_PROFILE_ACTIVATION;
			this.children = getChildren(this.phase).iterator();
			this.current = Collections.emptyIterator();
		}
		@Override
		public boolean hasNext() {
			return fetchIfNecessary() != null;
		}
		@Override
		public ConfigDataEnvironmentContributor next() {
			ConfigDataEnvironmentContributor next = fetchIfNecessary();
			if (next == null) {
				throw new NoSuchElementException();
			}
			this.next = null;
			return next;
		}
		private ConfigDataEnvironmentContributor fetchIfNecessary() {
			if (this.next != null) {
				return this.next;
			}
			if (this.current.hasNext()) {
				this.next = this.current.next();
				return this.next;
			}
			if (this.children.hasNext()) {
				this.current = this.children.next().iterator();
				return fetchIfNecessary();
			}
			if (this.phase == ImportPhase.AFTER_PROFILE_ACTIVATION) {
				this.phase = ImportPhase.BEFORE_PROFILE_ACTIVATION;
				this.children = getChildren(this.phase).iterator();
				return fetchIfNecessary();
			}
			if (this.phase == ImportPhase.BEFORE_PROFILE_ACTIVATION) {
				this.phase = null;
				this.next = ConfigDataEnvironmentContributor.this;
				return this.next;
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
public interface ConfigDataLoader<R extends ConfigDataResource> {
	/**
	 * Returns if the specified resource can be loaded by this instance.
	 * @param context the loader context
	 * @param resource the resource to check.
	 * @return if the resource is supported by this loader
	 */
	default boolean isLoadable(ConfigDataLoaderContext context, R resource) {
		return true;
	}
	/**
	 * Load {@link ConfigData} for the given resource.
	 * @param context the loader context
	 * @param resource the resource to load
	 * @return the loaded config data or {@code null} if the location should be skipped
	 * @throws IOException on IO error
	 * @throws ConfigDataResourceNotFoundException if the resource cannot be found
	 */
	ConfigData load(ConfigDataLoaderContext context, R resource)
			throws IOException, ConfigDataResourceNotFoundException;
}
/*
package org.springframework.boot.context.config;
/**
public class ConfigTreeConfigDataLoader implements ConfigDataLoader<ConfigTreeConfigDataResource> {
	@Override
	public ConfigData load(ConfigDataLoaderContext context, ConfigTreeConfigDataResource resource)
			throws IOException, ConfigDataResourceNotFoundException {
		Path path = resource.getPath();
		ConfigDataResourceNotFoundException.throwIfDoesNotExist(resource, path);
		String name = 'Config tree "' + path + '"';
		ConfigTreePropertySource source = new ConfigTreePropertySource(name, path, Option.AUTO_TRIM_TRAILING_NEW_LINE);
		return new ConfigData(Collections.singletonList(source));
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLoaders {
	private final Log logger;
	@SuppressWarnings('rawtypes')
	private final List<ConfigDataLoader> loaders;
	private final List<Class<?>> resourceTypes;
	/**
	 * Create a new {@link ConfigDataLoaders} instance.
	 * @param logFactory the deferred log factory
	 * @param bootstrapContext the bootstrap context
	 * @param springFactoriesLoader the loader to use
	 */
	ConfigDataLoaders(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext,
			SpringFactoriesLoader springFactoriesLoader) {
		this.logger = logFactory.getLog(getClass());
		ArgumentResolver argumentResolver = ArgumentResolver.of(DeferredLogFactory.class, logFactory);
		argumentResolver = argumentResolver.and(ConfigurableBootstrapContext.class, bootstrapContext);
		argumentResolver = argumentResolver.and(BootstrapContext.class, bootstrapContext);
		argumentResolver = argumentResolver.and(BootstrapRegistry.class, bootstrapContext);
		argumentResolver = argumentResolver.andSupplied(Log.class, () -> {
			throw new IllegalArgumentException('Log types cannot be injected, please use DeferredLogFactory');
		});
		this.loaders = springFactoriesLoader.load(ConfigDataLoader.class, argumentResolver);
		this.resourceTypes = getResourceTypes(this.loaders);
	}
	@SuppressWarnings('rawtypes')
	private List<Class<?>> getResourceTypes(List<ConfigDataLoader> loaders) {
		List<Class<?>> resourceTypes = new ArrayList<>(loaders.size());
		for (ConfigDataLoader<?> loader : loaders) {
			resourceTypes.add(getResourceType(loader));
		}
		return Collections.unmodifiableList(resourceTypes);
	}
	private Class<?> getResourceType(ConfigDataLoader<?> loader) {
		return ResolvableType.forClass(loader.getClass()).as(ConfigDataLoader.class).resolveGeneric();
	}
	/**
	 * Load {@link ConfigData} using the first appropriate {@link ConfigDataLoader}.
	 * @param <R> the resource type
	 * @param context the loader context
	 * @param resource the resource to load
	 * @return the loaded {@link ConfigData}
	 * @throws IOException on IO error
	 */
	<R extends ConfigDataResource> ConfigData load(ConfigDataLoaderContext context, R resource) throws IOException {
		ConfigDataLoader<R> loader = getLoader(context, resource);
		this.logger.trace(LogMessage.of(() -> 'Loading ' + resource + ' using loader ' + loader.getClass().getName()));
		return loader.load(context, resource);
	}
	@SuppressWarnings('unchecked')
	private <R extends ConfigDataResource> ConfigDataLoader<R> getLoader(ConfigDataLoaderContext context, R resource) {
		ConfigDataLoader<R> result = null;
		for (int i = 0; i < this.loaders.size(); i++) {
			ConfigDataLoader<R> candidate = this.loaders.get(i);
			if (this.resourceTypes.get(i).isInstance(resource)) {
				if (candidate.isLoadable(context, resource)) {
					if (result != null) {
						throw new IllegalStateException('Multiple loaders found for resource "' + resource + '" ['
								+ candidate.getClass().getName() + ',' + result.getClass().getName() + ']');
					}
					result = candidate;
				}
			}
		}
		Assert.state(result != null, () -> 'No loader found for resource "' + resource + '"');
		return result;
	}
}
/*
package org.springframework.boot.context.config;
/**
public class Profiles implements Iterable<String> {
	/**
	 * Name of property to set to specify additionally included active profiles.
	 */
	public static final String INCLUDE_PROFILES_PROPERTY_NAME = 'spring.profiles.include';
	static final ConfigurationPropertyName INCLUDE_PROFILES = ConfigurationPropertyName
		.of(Profiles.INCLUDE_PROFILES_PROPERTY_NAME);
	private static final Bindable<MultiValueMap<String, String>> STRING_STRINGS_MAP = Bindable
		.of(ResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class));
	private static final Bindable<Set<String>> STRING_SET = Bindable.setOf(String.class);
	private final MultiValueMap<String, String> groups;
	private final List<String> activeProfiles;
	private final List<String> defaultProfiles;
	/**
	 * Create a new {@link Profiles} instance based on the {@link Environment} and
	 * {@link Binder}.
	 * @param environment the source environment
	 * @param binder the binder for profile properties
	 * @param additionalProfiles any additional active profiles
	 */
	Profiles(Environment environment, Binder binder, Collection<String> additionalProfiles) {
		this.groups = binder.bind('spring.profiles.group', STRING_STRINGS_MAP).orElseGet(LinkedMultiValueMap::new);
		this.activeProfiles = expandProfiles(getActivatedProfiles(environment, binder, additionalProfiles));
		this.defaultProfiles = expandProfiles(getDefaultProfiles(environment, binder));
	}
	private List<String> getActivatedProfiles(Environment environment, Binder binder,
			Collection<String> additionalProfiles) {
		return asUniqueItemList(getProfiles(environment, binder, Type.ACTIVE), additionalProfiles);
	}
	private List<String> getDefaultProfiles(Environment environment, Binder binder) {
		return asUniqueItemList(getProfiles(environment, binder, Type.DEFAULT));
	}
	private Collection<String> getProfiles(Environment environment, Binder binder, Type type) {
		String environmentPropertyValue = environment.getProperty(type.getName());
		Set<String> environmentPropertyProfiles = (!StringUtils.hasLength(environmentPropertyValue))
				? Collections.emptySet()
				: StringUtils.commaDelimitedListToSet(StringUtils.trimAllWhitespace(environmentPropertyValue));
		Set<String> environmentProfiles = new LinkedHashSet<>(Arrays.asList(type.get(environment)));
		BindResult<Set<String>> boundProfiles = binder.bind(type.getName(), STRING_SET);
		if (hasProgrammaticallySetProfiles(type, environmentPropertyValue, environmentPropertyProfiles,
				environmentProfiles)) {
			if (!type.isMergeWithEnvironmentProfiles() || !boundProfiles.isBound()) {
				return environmentProfiles;
			}
			return boundProfiles.map((bound) -> merge(environmentProfiles, bound)).get();
		}
		return boundProfiles.orElse(type.getDefaultValue());
	}
	private boolean hasProgrammaticallySetProfiles(Type type, String environmentPropertyValue,
			Set<String> environmentPropertyProfiles, Set<String> environmentProfiles) {
		if (!StringUtils.hasLength(environmentPropertyValue)) {
			return !type.getDefaultValue().equals(environmentProfiles);
		}
		if (type.getDefaultValue().equals(environmentProfiles)) {
			return false;
		}
		return !environmentPropertyProfiles.equals(environmentProfiles);
	}
	private Set<String> merge(Set<String> environmentProfiles, Set<String> bound) {
		Set<String> result = new LinkedHashSet<>(environmentProfiles);
		result.addAll(bound);
		return result;
	}
	private List<String> expandProfiles(List<String> profiles) {
		Deque<String> stack = new ArrayDeque<>();
		asReversedList(profiles).forEach(stack::push);
		Set<String> expandedProfiles = new LinkedHashSet<>();
		while (!stack.isEmpty()) {
			String current = stack.pop();
			if (expandedProfiles.add(current)) {
				asReversedList(this.groups.get(current)).forEach(stack::push);
			}
		}
		return asUniqueItemList(expandedProfiles);
	}
	private List<String> asReversedList(List<String> list) {
		if (CollectionUtils.isEmpty(list)) {
			return Collections.emptyList();
		}
		List<String> reversed = new ArrayList<>(list);
		Collections.reverse(reversed);
		return reversed;
	}
	private List<String> asUniqueItemList(Collection<String> profiles) {
		return asUniqueItemList(profiles, null);
	}
	private List<String> asUniqueItemList(Collection<String> profiles, Collection<String> additional) {
		LinkedHashSet<String> uniqueItems = new LinkedHashSet<>();
		if (!CollectionUtils.isEmpty(additional)) {
			uniqueItems.addAll(additional);
		}
		uniqueItems.addAll(profiles);
		return Collections.unmodifiableList(new ArrayList<>(uniqueItems));
	}
	/**
	 * Return an iterator for all {@link #getAccepted() accepted profiles}.
	 */
	@Override
	public Iterator<String> iterator() {
		return getAccepted().iterator();
	}
	/**
	 * Return the active profiles.
	 * @return the active profiles
	 */
	public List<String> getActive() {
		return this.activeProfiles;
	}
	/**
	 * Return the default profiles.
	 * @return the active profiles
	 */
	public List<String> getDefault() {
		return this.defaultProfiles;
	}
	/**
	 * Return the accepted profiles.
	 * @return the accepted profiles
	 */
	public List<String> getAccepted() {
		return (!this.activeProfiles.isEmpty()) ? this.activeProfiles : this.defaultProfiles;
	}
	/**
	 * Return if the given profile is active.
	 * @param profile the profile to test
	 * @return if the profile is active
	 */
	public boolean isAccepted(String profile) {
		return getAccepted().contains(profile);
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this);
		creator.append('active', getActive().toString());
		creator.append('default', getDefault().toString());
		creator.append('accepted', getAccepted().toString());
		return creator.toString();
	}
	/**
	 * A profiles type that can be obtained.
	 */
	private enum Type {
		ACTIVE(AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME, Environment::getActiveProfiles, true,
				Collections.emptySet()),
		DEFAULT(AbstractEnvironment.DEFAULT_PROFILES_PROPERTY_NAME, Environment::getDefaultProfiles, false,
				Collections.singleton('default'));
		private final Function<Environment, String[]> getter;
		private final boolean mergeWithEnvironmentProfiles;
		private final String name;
		private final Set<String> defaultValue;
		Type(String name, Function<Environment, String[]> getter, boolean mergeWithEnvironmentProfiles,
				Set<String> defaultValue) {
			this.name = name;
			this.getter = getter;
			this.mergeWithEnvironmentProfiles = mergeWithEnvironmentProfiles;
			this.defaultValue = defaultValue;
		}
		String getName() {
			return this.name;
		}
		String[] get(Environment environment) {
			return this.getter.apply(environment);
		}
		Set<String> getDefaultValue() {
			return this.defaultValue;
		}
		boolean isMergeWithEnvironmentProfiles() {
			return this.mergeWithEnvironmentProfiles;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
public interface ConfigDataLocationResolverContext {
	/**
	 * Provides access to a binder that can be used to obtain previously contributed
	 * values.
	 * @return a binder instance
	 */
	Binder getBinder();
	/**
	 * Provides access to the parent {@link ConfigDataResource} that triggered the resolve
	 * or {@code null} if there is no available parent.
	 * @return the parent location
	 */
	ConfigDataResource getParent();
	/**
	 * Provides access to the {@link ConfigurableBootstrapContext} shared across all
	 * {@link EnvironmentPostProcessor EnvironmentPostProcessors}.
	 * @return the bootstrap context
	 */
	ConfigurableBootstrapContext getBootstrapContext();
}
/*
package org.springframework.boot.context.config;
/**
public abstract class ConfigDataException extends RuntimeException {
	/**
	 * Create a new {@link ConfigDataException} instance.
	 * @param message the exception message
	 * @param cause the exception cause
	 */
	protected ConfigDataException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentContributorPlaceholdersResolver implements PlaceholdersResolver {
	private final Iterable<ConfigDataEnvironmentContributor> contributors;
	private final ConfigDataActivationContext activationContext;
	private final boolean failOnResolveFromInactiveContributor;
	private final PropertyPlaceholderHelper helper;
	private final ConfigDataEnvironmentContributor activeContributor;
	private final ConversionService conversionService;
	ConfigDataEnvironmentContributorPlaceholdersResolver(Iterable<ConfigDataEnvironmentContributor> contributors,
			ConfigDataActivationContext activationContext, ConfigDataEnvironmentContributor activeContributor,
			boolean failOnResolveFromInactiveContributor, ConversionService conversionService) {
		this.contributors = contributors;
		this.activationContext = activationContext;
		this.activeContributor = activeContributor;
		this.failOnResolveFromInactiveContributor = failOnResolveFromInactiveContributor;
		this.conversionService = conversionService;
		this.helper = new PropertyPlaceholderHelper(SystemPropertyUtils.'_PREFIX,
				SystemPropertyUtils.'_SUFFIX, SystemPropertyUtils.VALUE_SEPARATOR,
				SystemPropertyUtils.ESCAPE_CHARACTER, true);
	}
	@Override
	public Object resolvePlaceholders(Object value) {
		if (value instanceof String string) {
			return this.helper.replacePlaceholders(string, this::resolvePlaceholder);
		}
		return value;
	}
	private String resolvePlaceholder(String placeholder) {
		Object result = null;
		for (ConfigDataEnvironmentContributor contributor : this.contributors) {
			PropertySource<?> propertySource = contributor.getPropertySource();
			Object value = (propertySource != null) ? propertySource.getProperty(placeholder) : null;
			if (value != null && !isActive(contributor)) {
				if (this.failOnResolveFromInactiveContributor) {
					ConfigDataResource resource = contributor.getResource();
					Origin origin = OriginLookup.getOrigin(propertySource, placeholder);
					throw new InactiveConfigDataAccessException(propertySource, resource, placeholder, origin);
				}
				value = null;
			}
			result = (result != null) ? result : value;
		}
		return (result != null) ? convertValueIfNecessary(result) : null;
	}
	private boolean isActive(ConfigDataEnvironmentContributor contributor) {
		if (contributor == this.activeContributor) {
			return true;
		}
		if (contributor.getKind() != Kind.UNBOUND_IMPORT) {
			return contributor.isActive(this.activationContext);
		}
		return contributor.withBoundProperties(this.contributors, this.activationContext)
			.isActive(this.activationContext);
	}
	private String convertValueIfNecessary(Object value) {
		return (value instanceof String string) ? string : this.conversionService.convert(value, String.class);
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentContributors implements Iterable<ConfigDataEnvironmentContributor> {
	private static final Predicate<ConfigDataEnvironmentContributor> NO_CONTRIBUTOR_FILTER = (contributor) -> true;
	private final Log logger;
	private final ConfigDataEnvironmentContributor root;
	private final ConfigurableBootstrapContext bootstrapContext;
	private final ConversionService conversionService;
	/**
	 * Create a new {@link ConfigDataEnvironmentContributors} instance.
	 * @param logFactory the log factory
	 * @param bootstrapContext the bootstrap context
	 * @param contributors the initial set of contributors
	 * @param conversionService the conversion service to use
	 */
	ConfigDataEnvironmentContributors(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext,
			List<ConfigDataEnvironmentContributor> contributors, ConversionService conversionService) {
		this.logger = logFactory.getLog(getClass());
		this.bootstrapContext = bootstrapContext;
		this.root = ConfigDataEnvironmentContributor.of(contributors, conversionService);
		this.conversionService = conversionService;
	}
	private ConfigDataEnvironmentContributors(Log logger, ConfigurableBootstrapContext bootstrapContext,
			ConfigDataEnvironmentContributor root, ConversionService conversionService) {
		this.logger = logger;
		this.bootstrapContext = bootstrapContext;
		this.root = root;
		this.conversionService = conversionService;
	}
	/**
	 * Processes imports from all active contributors and return a new
	 * {@link ConfigDataEnvironmentContributors} instance.
	 * @param importer the importer used to import {@link ConfigData}
	 * @param activationContext the current activation context or {@code null} if the
	 * context has not yet been created
	 * @return a {@link ConfigDataEnvironmentContributors} instance with all relevant
	 * imports have been processed
	 */
	ConfigDataEnvironmentContributors withProcessedImports(ConfigDataImporter importer,
			ConfigDataActivationContext activationContext) {
		ImportPhase importPhase = ImportPhase.get(activationContext);
		this.logger.trace(LogMessage.format('Processing imports for phase %s. %s', importPhase,
				(activationContext != null) ? activationContext : 'no activation context'));
		ConfigDataEnvironmentContributors result = this;
		int processed = 0;
		while (true) {
			ConfigDataEnvironmentContributor contributor = getNextToProcess(result, activationContext, importPhase);
			if (contributor == null) {
				this.logger.trace(LogMessage.format('Processed imports for of %d contributors', processed));
				return result;
			}
			if (contributor.getKind() == Kind.UNBOUND_IMPORT) {
				ConfigDataEnvironmentContributor bound = contributor.withBoundProperties(result, activationContext);
				result = new ConfigDataEnvironmentContributors(this.logger, this.bootstrapContext,
						result.getRoot().withReplacement(contributor, bound), this.conversionService);
				continue;
			}
			ConfigDataLocationResolverContext locationResolverContext = new ContributorConfigDataLocationResolverContext(
					result, contributor, activationContext);
			ConfigDataLoaderContext loaderContext = new ContributorDataLoaderContext(this);
			List<ConfigDataLocation> imports = contributor.getImports();
			this.logger.trace(LogMessage.format('Processing imports %s', imports));
			Map<ConfigDataResolutionResult, ConfigData> imported = importer.resolveAndLoad(activationContext,
					locationResolverContext, loaderContext, imports);
			this.logger.trace(LogMessage.of(() -> getImportedMessage(imported.keySet())));
			ConfigDataEnvironmentContributor contributorAndChildren = contributor.withChildren(importPhase,
					asContributors(imported));
			result = new ConfigDataEnvironmentContributors(this.logger, this.bootstrapContext,
					result.getRoot().withReplacement(contributor, contributorAndChildren), this.conversionService);
			processed++;
		}
	}
	private CharSequence getImportedMessage(Set<ConfigDataResolutionResult> results) {
		if (results.isEmpty()) {
			return 'Nothing imported';
		}
		StringBuilder message = new StringBuilder();
		message.append('Imported ' + results.size() + ' resource' + ((results.size() != 1) ? 's ' : ' '));
		message.append(results.stream().map(ConfigDataResolutionResult::getResource).toList());
		return message;
	}
	protected final ConfigurableBootstrapContext getBootstrapContext() {
		return this.bootstrapContext;
	}
	private ConfigDataEnvironmentContributor getNextToProcess(ConfigDataEnvironmentContributors contributors,
			ConfigDataActivationContext activationContext, ImportPhase importPhase) {
		for (ConfigDataEnvironmentContributor contributor : contributors.getRoot()) {
			if (contributor.getKind() == Kind.UNBOUND_IMPORT
					|| isActiveWithUnprocessedImports(activationContext, importPhase, contributor)) {
				return contributor;
			}
		}
		return null;
	}
	private boolean isActiveWithUnprocessedImports(ConfigDataActivationContext activationContext,
			ImportPhase importPhase, ConfigDataEnvironmentContributor contributor) {
		return contributor.isActive(activationContext) && contributor.hasUnprocessedImports(importPhase);
	}
	private List<ConfigDataEnvironmentContributor> asContributors(
			Map<ConfigDataResolutionResult, ConfigData> imported) {
		List<ConfigDataEnvironmentContributor> contributors = new ArrayList<>(imported.size() * 5);
		imported.forEach((resolutionResult, data) -> {
			ConfigDataLocation location = resolutionResult.getLocation();
			ConfigDataResource resource = resolutionResult.getResource();
			boolean profileSpecific = resolutionResult.isProfileSpecific();
			if (data.getPropertySources().isEmpty()) {
				contributors.add(ConfigDataEnvironmentContributor.ofEmptyLocation(location, profileSpecific,
						this.conversionService));
			}
			else {
				for (int i = data.getPropertySources().size() - 1; i >= 0; i--) {
					contributors.add(ConfigDataEnvironmentContributor.ofUnboundImport(location, resource,
							profileSpecific, data, i, this.conversionService));
				}
			}
		});
		return Collections.unmodifiableList(contributors);
	}
	/**
	 * Returns the root contributor.
	 * @return the root contributor.
	 */
	ConfigDataEnvironmentContributor getRoot() {
		return this.root;
	}
	/**
	 * Return a {@link Binder} backed by the contributors.
	 * @param activationContext the activation context
	 * @param options binder options to apply
	 * @return a binder instance
	 */
	Binder getBinder(ConfigDataActivationContext activationContext, BinderOption... options) {
		return getBinder(activationContext, NO_CONTRIBUTOR_FILTER, options);
	}
	/**
	 * Return a {@link Binder} backed by the contributors.
	 * @param activationContext the activation context
	 * @param filter a filter used to limit the contributors
	 * @param options binder options to apply
	 * @return a binder instance
	 */
	Binder getBinder(ConfigDataActivationContext activationContext, Predicate<ConfigDataEnvironmentContributor> filter,
			BinderOption... options) {
		return getBinder(activationContext, filter, asBinderOptionsSet(options));
	}
	private Set<BinderOption> asBinderOptionsSet(BinderOption... options) {
		return ObjectUtils.isEmpty(options) ? EnumSet.noneOf(BinderOption.class)
				: EnumSet.copyOf(Arrays.asList(options));
	}
	private Binder getBinder(ConfigDataActivationContext activationContext,
			Predicate<ConfigDataEnvironmentContributor> filter, Set<BinderOption> options) {
		boolean failOnInactiveSource = options.contains(BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);
		Iterable<ConfigurationPropertySource> sources = () -> getBinderSources(
				filter.and((contributor) -> failOnInactiveSource || contributor.isActive(activationContext)));
		PlaceholdersResolver placeholdersResolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(this.root,
				activationContext, null, failOnInactiveSource, this.conversionService);
		BindHandler bindHandler = !failOnInactiveSource ? null : new InactiveSourceChecker(activationContext);
		return new Binder(sources, placeholdersResolver, null, null, bindHandler);
	}
	private Iterator<ConfigurationPropertySource> getBinderSources(Predicate<ConfigDataEnvironmentContributor> filter) {
		return this.root.stream()
			.filter(this::hasConfigurationPropertySource)
			.filter(filter)
			.map(ConfigDataEnvironmentContributor::getConfigurationPropertySource)
			.iterator();
	}
	private boolean hasConfigurationPropertySource(ConfigDataEnvironmentContributor contributor) {
		return contributor.getConfigurationPropertySource() != null;
	}
	@Override
	public Iterator<ConfigDataEnvironmentContributor> iterator() {
		return this.root.iterator();
	}
	/**
	 * {@link ConfigDataLocationResolverContext} for a contributor.
	 */
	private static class ContributorDataLoaderContext implements ConfigDataLoaderContext {
		private final ConfigDataEnvironmentContributors contributors;
		ContributorDataLoaderContext(ConfigDataEnvironmentContributors contributors) {
			this.contributors = contributors;
		}
		@Override
		public ConfigurableBootstrapContext getBootstrapContext() {
			return this.contributors.getBootstrapContext();
		}
	}
	/**
	 * {@link ConfigDataLocationResolverContext} for a contributor.
	 */
	private static class ContributorConfigDataLocationResolverContext implements ConfigDataLocationResolverContext {
		private final ConfigDataEnvironmentContributors contributors;
		private final ConfigDataEnvironmentContributor contributor;
		private final ConfigDataActivationContext activationContext;
		private volatile Binder binder;
		ContributorConfigDataLocationResolverContext(ConfigDataEnvironmentContributors contributors,
				ConfigDataEnvironmentContributor contributor, ConfigDataActivationContext activationContext) {
			this.contributors = contributors;
			this.contributor = contributor;
			this.activationContext = activationContext;
		}
		@Override
		public Binder getBinder() {
			Binder binder = this.binder;
			if (binder == null) {
				binder = this.contributors.getBinder(this.activationContext);
				this.binder = binder;
			}
			return binder;
		}
		@Override
		public ConfigDataResource getParent() {
			return this.contributor.getResource();
		}
		@Override
		public ConfigurableBootstrapContext getBootstrapContext() {
			return this.contributors.getBootstrapContext();
		}
	}
	private class InactiveSourceChecker implements BindHandler {
		private final ConfigDataActivationContext activationContext;
		InactiveSourceChecker(ConfigDataActivationContext activationContext) {
			this.activationContext = activationContext;
		}
		@Override
		public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context,
				Object result) {
			for (ConfigDataEnvironmentContributor contributor : ConfigDataEnvironmentContributors.this) {
				if (!contributor.isActive(this.activationContext)) {
					InactiveConfigDataAccessException.throwIfPropertyFound(contributor, name);
				}
			}
			return result;
		}
	}
	/**
	 * Binder options that can be used with
	 * {@link ConfigDataEnvironmentContributors#getBinder(ConfigDataActivationContext, BinderOption...)}.
	 */
	enum BinderOption {
		/**
		 * Throw an exception if an inactive contributor contains a bound value.
		 */
		FAIL_ON_BIND_TO_INACTIVE_SOURCE
	}
}
/*
package org.springframework.boot.context.config;
/**
public class InactiveConfigDataAccessException extends ConfigDataException {
	private final PropertySource<?> propertySource;
	private final ConfigDataResource location;
	private final String propertyName;
	private final Origin origin;
	/**
	 * Create a new {@link InactiveConfigDataAccessException} instance.
	 * @param propertySource the inactive property source
	 * @param location the {@link ConfigDataResource} of the property source or
	 * {@code null} if the source was not loaded from {@link ConfigData}.
	 * @param propertyName the name of the property
	 * @param origin the origin or the property or {@code null}
	 */
	InactiveConfigDataAccessException(PropertySource<?> propertySource, ConfigDataResource location,
			String propertyName, Origin origin) {
		super(getMessage(propertySource, location, propertyName, origin), null);
		this.propertySource = propertySource;
		this.location = location;
		this.propertyName = propertyName;
		this.origin = origin;
	}
	private static String getMessage(PropertySource<?> propertySource, ConfigDataResource location, String propertyName,
			Origin origin) {
		StringBuilder message = new StringBuilder('Inactive property source "');
		message.append(propertySource.getName());
		if (location != null) {
			message.append('" imported from location "');
			message.append(location);
		}
		message.append('" cannot contain property "');
		message.append(propertyName);
		message.append('"');
		if (origin != null) {
			message.append(' [origin: ');
			message.append(origin);
			message.append(']');
		}
		return message.toString();
	}
	/**
	 * Return the inactive property source that contained the property.
	 * @return the property source
	 */
	public PropertySource<?> getPropertySource() {
		return this.propertySource;
	}
	/**
	 * Return the {@link ConfigDataResource} of the property source or {@code null} if the
	 * source was not loaded from {@link ConfigData}.
	 * @return the config data location or {@code null}
	 */
	public ConfigDataResource getLocation() {
		return this.location;
	}
	/**
	 * Return the name of the property.
	 * @return the property name
	 */
	public String getPropertyName() {
		return this.propertyName;
	}
	/**
	 * Return the origin or the property or {@code null}.
	 * @return the property origin
	 */
	public Origin getOrigin() {
		return this.origin;
	}
	/**
	 * Throw an {@link InactiveConfigDataAccessException} if the given
	 * {@link ConfigDataEnvironmentContributor} contains the property.
	 * @param contributor the contributor to check
	 * @param name the name to check
	 */
	static void throwIfPropertyFound(ConfigDataEnvironmentContributor contributor, ConfigurationPropertyName name) {
		ConfigurationPropertySource source = contributor.getConfigurationPropertySource();
		ConfigurationProperty property = (source != null) ? source.getConfigurationProperty(name) : null;
		if (property != null) {
			PropertySource<?> propertySource = contributor.getPropertySource();
			ConfigDataResource location = contributor.getResource();
			throw new InactiveConfigDataAccessException(propertySource, location, name.toString(),
					property.getOrigin());
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataNotFoundFailureAnalyzer extends AbstractFailureAnalyzer<ConfigDataNotFoundException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, ConfigDataNotFoundException cause) {
		ConfigDataLocation location = getLocation(cause);
		Origin origin = Origin.from(location);
		String message = String.format('Config data %s does not exist', cause.getReferenceDescription());
		StringBuilder action = new StringBuilder('Check that the value ');
		if (location != null) {
			action.append(String.format('"%s" ', location));
		}
		if (origin != null) {
			action.append(String.format('at %s ', origin));
		}
		action.append('is correct');
		if (location != null && !location.isOptional()) {
			action.append(String.format(', or prefix it with "%s"', ConfigDataLocation.OPTIONAL_PREFIX));
		}
		return new FailureAnalysis(message, action.toString(), cause);
	}
	private ConfigDataLocation getLocation(ConfigDataNotFoundException cause) {
		if (cause instanceof ConfigDataLocationNotFoundException locationNotFoundException) {
			return locationNotFoundException.getLocation();
		}
		if (cause instanceof ConfigDataResourceNotFoundException resourceNotFoundException) {
			return resourceNotFoundException.getLocation();
		}
		return null;
	}
}
/*
package org.springframework.boot.context.config;
/**
public class ConfigDataLocationNotFoundException extends ConfigDataNotFoundException {
	private final ConfigDataLocation location;
	/**
	 * Create a new {@link ConfigDataLocationNotFoundException} instance.
	 * @param location the location that could not be found
	 */
	public ConfigDataLocationNotFoundException(ConfigDataLocation location) {
		this(location, null);
	}
	/**
	 * Create a new {@link ConfigDataLocationNotFoundException} instance.
	 * @param location the location that could not be found
	 * @param cause the exception cause
	 */
	public ConfigDataLocationNotFoundException(ConfigDataLocation location, Throwable cause) {
		this(location, getMessage(location), cause);
	}
	/**
	 * Create a new {@link ConfigDataLocationNotFoundException} instance.
	 * @param location the location that could not be found
	 * @param message the exception message
	 * @param cause the exception cause
	 * @since 2.4.7
	 */
	public ConfigDataLocationNotFoundException(ConfigDataLocation location, String message, Throwable cause) {
		super(message, cause);
		Assert.notNull(location, 'Location must not be null');
		this.location = location;
	}
	/**
	 * Return the location that could not be found.
	 * @return the location
	 */
	public ConfigDataLocation getLocation() {
		return this.location;
	}
	@Override
	public Origin getOrigin() {
		return Origin.from(this.location);
	}
	@Override
	public String getReferenceDescription() {
		return getReferenceDescription(this.location);
	}
	private static String getMessage(ConfigDataLocation location) {
		return String.format('Config data %s cannot be found', getReferenceDescription(location));
	}
	private static String getReferenceDescription(ConfigDataLocation location) {
		return String.format('location "%s"', location);
	}
}
/*
package org.springframework.boot.context.config;
/**
public class InvalidConfigDataPropertyException extends ConfigDataException {
	private static final Map<ConfigurationPropertyName, ConfigurationPropertyName> ERRORS;
	static {
		Map<ConfigurationPropertyName, ConfigurationPropertyName> errors = new LinkedHashMap<>();
		errors.put(ConfigurationPropertyName.of('spring.profiles'),
				ConfigurationPropertyName.of('spring.config.activate.on-profile'));
		errors.put(ConfigurationPropertyName.of('spring.profiles[0]'),
				ConfigurationPropertyName.of('spring.config.activate.on-profile'));
		ERRORS = Collections.unmodifiableMap(errors);
	}
	private static final Set<ConfigurationPropertyName> PROFILE_SPECIFIC_ERRORS;
	static {
		Set<ConfigurationPropertyName> errors = new LinkedHashSet<>();
		errors.add(Profiles.INCLUDE_PROFILES);
		errors.add(Profiles.INCLUDE_PROFILES.append('[0]'));
		errors.add(ConfigurationPropertyName.of(AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME));
		errors.add(ConfigurationPropertyName.of(AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME + '[0]'));
		errors.add(ConfigurationPropertyName.of(AbstractEnvironment.DEFAULT_PROFILES_PROPERTY_NAME));
		errors.add(ConfigurationPropertyName.of(AbstractEnvironment.DEFAULT_PROFILES_PROPERTY_NAME + '[0]'));
		PROFILE_SPECIFIC_ERRORS = Collections.unmodifiableSet(errors);
	}
	private final ConfigurationProperty property;
	private final ConfigurationPropertyName replacement;
	private final ConfigDataResource location;
	InvalidConfigDataPropertyException(ConfigurationProperty property, boolean profileSpecific,
			ConfigurationPropertyName replacement, ConfigDataResource location) {
		super(getMessage(property, profileSpecific, replacement, location), null);
		this.property = property;
		this.replacement = replacement;
		this.location = location;
	}
	/**
	 * Return source property that caused the exception.
	 * @return the invalid property
	 */
	public ConfigurationProperty getProperty() {
		return this.property;
	}
	/**
	 * Return the {@link ConfigDataResource} of the invalid property or {@code null} if
	 * the source was not loaded from {@link ConfigData}.
	 * @return the config data location or {@code null}
	 */
	public ConfigDataResource getLocation() {
		return this.location;
	}
	/**
	 * Return the replacement property that should be used instead or {@code null} if not
	 * replacement is available.
	 * @return the replacement property name
	 */
	public ConfigurationPropertyName getReplacement() {
		return this.replacement;
	}
	/**
	 * Throw an {@link InvalidConfigDataPropertyException} if the given
	 * {@link ConfigDataEnvironmentContributor} contains any invalid property.
	 * @param contributor the contributor to check
	 */
	static void throwIfPropertyFound(ConfigDataEnvironmentContributor contributor) {
		ConfigurationPropertySource propertySource = contributor.getConfigurationPropertySource();
		if (propertySource != null) {
			ERRORS.forEach((name, replacement) -> {
				ConfigurationProperty property = propertySource.getConfigurationProperty(name);
				if (property != null) {
					throw new InvalidConfigDataPropertyException(property, false, replacement,
							contributor.getResource());
				}
			});
			if (contributor.isFromProfileSpecificImport()
					&& !contributor.hasConfigDataOption(ConfigData.Option.IGNORE_PROFILES)) {
				PROFILE_SPECIFIC_ERRORS.forEach((name) -> {
					ConfigurationProperty property = propertySource.getConfigurationProperty(name);
					if (property != null) {
						throw new InvalidConfigDataPropertyException(property, true, null, contributor.getResource());
					}
				});
			}
		}
	}
	private static String getMessage(ConfigurationProperty property, boolean profileSpecific,
			ConfigurationPropertyName replacement, ConfigDataResource location) {
		StringBuilder message = new StringBuilder('Property "');
		message.append(property.getName());
		if (location != null) {
			message.append('" imported from location "');
			message.append(location);
		}
		message.append('" is invalid');
		if (profileSpecific) {
			message.append(' in a profile specific resource');
		}
		if (replacement != null) {
			message.append(' and should be replaced with "');
			message.append(replacement);
			message.append('"');
		}
		if (property.getOrigin() != null) {
			message.append(' [origin: ');
			message.append(property.getOrigin());
			message.append(']');
		}
		return message.toString();
	}
}
/*
package org.springframework.boot.context.config;
/**
public interface ConfigDataLocationResolver<R extends ConfigDataResource> {
	/**
	 * Returns if the specified location address can be resolved by this resolver.
	 * @param context the location resolver context
	 * @param location the location to check.
	 * @return if the location is supported by this resolver
	 */
	boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location);
	/**
	 * Resolve a {@link ConfigDataLocation} into one or more {@link ConfigDataResource}
	 * instances.
	 * @param context the location resolver context
	 * @param location the location that should be resolved
	 * @return a list of {@link ConfigDataResource resources} in ascending priority order.
	 * @throws ConfigDataLocationNotFoundException on a non-optional location that cannot
	 * be found
	 * @throws ConfigDataResourceNotFoundException if a resolved resource cannot be found
	 */
	List<R> resolve(ConfigDataLocationResolverContext context, ConfigDataLocation location)
			throws ConfigDataLocationNotFoundException, ConfigDataResourceNotFoundException;
	/**
	 * Resolve a {@link ConfigDataLocation} into one or more {@link ConfigDataResource}
	 * instances based on available profiles. This method is called once profiles have
	 * been deduced from the contributed values. By default this method returns an empty
	 * list.
	 * @param context the location resolver context
	 * @param location the location that should be resolved
	 * @param profiles profile information
	 * @return a list of resolved locations in ascending priority order.
	 * @throws ConfigDataLocationNotFoundException on a non-optional location that cannot
	 * be found
	 */
	default List<R> resolveProfileSpecific(ConfigDataLocationResolverContext context, ConfigDataLocation location,
			Profiles profiles) throws ConfigDataLocationNotFoundException {
		return Collections.emptyList();
	}
}
/*
package org.springframework.boot.context.config;
/**
public class ConfigTreeConfigDataResource extends ConfigDataResource {
	private final Path path;
	ConfigTreeConfigDataResource(String path) {
		Assert.notNull(path, 'Path must not be null');
		this.path = Paths.get(path).toAbsolutePath();
	}
	ConfigTreeConfigDataResource(Path path) {
		Assert.notNull(path, 'Path must not be null');
		this.path = path.toAbsolutePath();
	}
	Path getPath() {
		return this.path;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ConfigTreeConfigDataResource other = (ConfigTreeConfigDataResource) obj;
		return Objects.equals(this.path, other.path);
	}
	@Override
	public int hashCode() {
		return this.path.hashCode();
	}
	@Override
	public String toString() {
		return 'config tree [' + this.path + ']';
	}
}
/*
package org.springframework.boot.context.config;
/**
public interface ConfigDataEnvironmentUpdateListener extends EventListener {
	/**
	 * A {@link ConfigDataEnvironmentUpdateListener} that does nothing.
	 */
	ConfigDataEnvironmentUpdateListener NONE = new ConfigDataEnvironmentUpdateListener() {
	};
	/**
	 * Called when a new {@link PropertySource} is added to the {@link Environment}.
	 * @param propertySource the {@link PropertySource} that was added
	 * @param location the original {@link ConfigDataLocation} of the source.
	 * @param resource the {@link ConfigDataResource} of the source.
	 */
	default void onPropertySourceAdded(PropertySource<?> propertySource, ConfigDataLocation location,
			ConfigDataResource resource) {
	}
	/**
	 * Called when {@link Environment} profiles are set.
	 * @param profiles the profiles being set
	 */
	default void onSetProfiles(Profiles profiles) {
	}
}
/*
package org.springframework.boot.context.config;
/**
public class UnsupportedConfigDataLocationException extends ConfigDataException {
	private final ConfigDataLocation location;
	/**
	 * Create a new {@link UnsupportedConfigDataLocationException} instance.
	 * @param location the unsupported location
	 */
	UnsupportedConfigDataLocationException(ConfigDataLocation location) {
		super('Unsupported config data location "' + location + '"', null);
		this.location = location;
	}
	/**
	 * Return the unsupported location reference.
	 * @return the unsupported location reference
	 */
	public ConfigDataLocation getLocation() {
		return this.location;
	}
}
/*
package org.springframework.boot.context.config;
/**
public class StandardConfigDataLoader implements ConfigDataLoader<StandardConfigDataResource> {
	private static final PropertySourceOptions PROFILE_SPECIFIC = PropertySourceOptions.always(Option.PROFILE_SPECIFIC);
	private static final PropertySourceOptions NON_PROFILE_SPECIFIC = PropertySourceOptions.ALWAYS_NONE;
	@Override
	public ConfigData load(ConfigDataLoaderContext context, StandardConfigDataResource resource)
			throws IOException, ConfigDataNotFoundException {
		if (resource.isEmptyDirectory()) {
			return ConfigData.EMPTY;
		}
		ConfigDataResourceNotFoundException.throwIfDoesNotExist(resource, resource.getResource());
		StandardConfigDataReference reference = resource.getReference();
		Resource originTrackedResource = OriginTrackedResource.of(resource.getResource(),
				Origin.from(reference.getConfigDataLocation()));
		String name = String.format('Config resource "%s" via location "%s"', resource,
				reference.getConfigDataLocation());
		List<PropertySource<?>> propertySources = reference.getPropertySourceLoader().load(name, originTrackedResource);
		PropertySourceOptions options = (resource.getProfile() != null) ? PROFILE_SPECIFIC : NON_PROFILE_SPECIFIC;
		return new ConfigData(propertySources, options);
	}
}
/*
package org.springframework.boot.context.config;
/**
class StandardConfigDataReference {
	private final ConfigDataLocation configDataLocation;
	private final String resourceLocation;
	private final String directory;
	private final String profile;
	private final PropertySourceLoader propertySourceLoader;
	/**
	 * Create a new {@link StandardConfigDataReference} instance.
	 * @param configDataLocation the original location passed to the resolver
	 * @param directory the directory of the resource or {@code null} if the reference is
	 * to a file
	 * @param root the root of the resource location
	 * @param profile the profile being loaded
	 * @param extension the file extension for the resource
	 * @param propertySourceLoader the property source loader that should be used for this
	 * reference
	 */
	StandardConfigDataReference(ConfigDataLocation configDataLocation, String directory, String root, String profile,
			String extension, PropertySourceLoader propertySourceLoader) {
		this.configDataLocation = configDataLocation;
		String profileSuffix = (StringUtils.hasText(profile)) ? '-' + profile : '';
		this.resourceLocation = root + profileSuffix + ((extension != null) ? '.' + extension : '');
		this.directory = directory;
		this.profile = profile;
		this.propertySourceLoader = propertySourceLoader;
	}
	ConfigDataLocation getConfigDataLocation() {
		return this.configDataLocation;
	}
	String getResourceLocation() {
		return this.resourceLocation;
	}
	boolean isMandatoryDirectory() {
		return !this.configDataLocation.isOptional() && this.directory != null;
	}
	String getDirectory() {
		return this.directory;
	}
	String getProfile() {
		return this.profile;
	}
	boolean isSkippable() {
		return this.configDataLocation.isOptional() || this.directory != null || this.profile != null;
	}
	PropertySourceLoader getPropertySourceLoader() {
		return this.propertySourceLoader;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if ((obj == null) || (getClass() != obj.getClass())) {
			return false;
		}
		StandardConfigDataReference other = (StandardConfigDataReference) obj;
		return this.resourceLocation.equals(other.resourceLocation);
	}
	@Override
	public int hashCode() {
		return this.resourceLocation.hashCode();
	}
	@Override
	public String toString() {
		return this.resourceLocation;
	}
}
/*
package org.springframework.boot.context.config;
/**
public class ConfigDataEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
	/**
	 * The default order for the processor.
	 */
	public static final int ORDER = Ordered.HIGHEST_PRECEDENCE + 10;
	/**
	 * Property used to determine what action to take when a
	 * {@code ConfigDataLocationNotFoundException} is thrown.
	 * @see ConfigDataNotFoundAction
	 */
	public static final String ON_LOCATION_NOT_FOUND_PROPERTY = ConfigDataEnvironment.ON_NOT_FOUND_PROPERTY;
	private final DeferredLogFactory logFactory;
	private final Log logger;
	private final ConfigurableBootstrapContext bootstrapContext;
	private final ConfigDataEnvironmentUpdateListener environmentUpdateListener;
	public ConfigDataEnvironmentPostProcessor(DeferredLogFactory logFactory,
			ConfigurableBootstrapContext bootstrapContext) {
		this(logFactory, bootstrapContext, null);
	}
	private ConfigDataEnvironmentPostProcessor(DeferredLogFactory logFactory,
			ConfigurableBootstrapContext bootstrapContext,
			ConfigDataEnvironmentUpdateListener environmentUpdateListener) {
		this.logFactory = logFactory;
		this.logger = logFactory.getLog(getClass());
		this.bootstrapContext = bootstrapContext;
		this.environmentUpdateListener = environmentUpdateListener;
	}
	@Override
	public int getOrder() {
		return ORDER;
	}
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		postProcessEnvironment(environment, application.getResourceLoader(), application.getAdditionalProfiles());
	}
	void postProcessEnvironment(ConfigurableEnvironment environment, ResourceLoader resourceLoader,
			Collection<String> additionalProfiles) {
		this.logger.trace('Post-processing environment to add config data');
		resourceLoader = (resourceLoader != null) ? resourceLoader : new DefaultResourceLoader();
		getConfigDataEnvironment(environment, resourceLoader, additionalProfiles).processAndApply();
	}
	ConfigDataEnvironment getConfigDataEnvironment(ConfigurableEnvironment environment, ResourceLoader resourceLoader,
			Collection<String> additionalProfiles) {
		return new ConfigDataEnvironment(this.logFactory, this.bootstrapContext, environment, resourceLoader,
				additionalProfiles, this.environmentUpdateListener);
	}
	/**
	 * Apply {@link ConfigData} post-processing to an existing {@link Environment}. This
	 * method can be useful when working with an {@link Environment} that has been created
	 * directly and not necessarily as part of a {@link SpringApplication}.
	 * @param environment the environment to apply {@link ConfigData} to
	 */
	public static void applyTo(ConfigurableEnvironment environment) {
		applyTo(environment, null, null, Collections.emptyList());
	}
	/**
	 * Apply {@link ConfigData} post-processing to an existing {@link Environment}. This
	 * method can be useful when working with an {@link Environment} that has been created
	 * directly and not necessarily as part of a {@link SpringApplication}.
	 * @param environment the environment to apply {@link ConfigData} to
	 * @param resourceLoader the resource loader to use
	 * @param bootstrapContext the bootstrap context to use or {@code null} to use a
	 * throw-away context
	 * @param additionalProfiles any additional profiles that should be applied
	 */
	public static void applyTo(ConfigurableEnvironment environment, ResourceLoader resourceLoader,
			ConfigurableBootstrapContext bootstrapContext, String... additionalProfiles) {
		applyTo(environment, resourceLoader, bootstrapContext, Arrays.asList(additionalProfiles));
	}
	/**
	 * Apply {@link ConfigData} post-processing to an existing {@link Environment}. This
	 * method can be useful when working with an {@link Environment} that has been created
	 * directly and not necessarily as part of a {@link SpringApplication}.
	 * @param environment the environment to apply {@link ConfigData} to
	 * @param resourceLoader the resource loader to use
	 * @param bootstrapContext the bootstrap context to use or {@code null} to use a
	 * throw-away context
	 * @param additionalProfiles any additional profiles that should be applied
	 */
	public static void applyTo(ConfigurableEnvironment environment, ResourceLoader resourceLoader,
			ConfigurableBootstrapContext bootstrapContext, Collection<String> additionalProfiles) {
		DeferredLogFactory logFactory = Supplier::get;
		bootstrapContext = (bootstrapContext != null) ? bootstrapContext : new DefaultBootstrapContext();
		ConfigDataEnvironmentPostProcessor postProcessor = new ConfigDataEnvironmentPostProcessor(logFactory,
				bootstrapContext);
		postProcessor.postProcessEnvironment(environment, resourceLoader, additionalProfiles);
	}
	/**
	 * Apply {@link ConfigData} post-processing to an existing {@link Environment}. This
	 * method can be useful when working with an {@link Environment} that has been created
	 * directly and not necessarily as part of a {@link SpringApplication}.
	 * @param environment the environment to apply {@link ConfigData} to
	 * @param resourceLoader the resource loader to use
	 * @param bootstrapContext the bootstrap context to use or {@code null} to use a
	 * throw-away context
	 * @param additionalProfiles any additional profiles that should be applied
	 * @param environmentUpdateListener optional
	 * {@link ConfigDataEnvironmentUpdateListener} that can be used to track
	 * {@link Environment} updates.
	 */
	public static void applyTo(ConfigurableEnvironment environment, ResourceLoader resourceLoader,
			ConfigurableBootstrapContext bootstrapContext, Collection<String> additionalProfiles,
			ConfigDataEnvironmentUpdateListener environmentUpdateListener) {
		DeferredLogFactory logFactory = Supplier::get;
		bootstrapContext = (bootstrapContext != null) ? bootstrapContext : new DefaultBootstrapContext();
		ConfigDataEnvironmentPostProcessor postProcessor = new ConfigDataEnvironmentPostProcessor(logFactory,
				bootstrapContext, environmentUpdateListener);
		postProcessor.postProcessEnvironment(environment, resourceLoader, additionalProfiles);
	}
}
/*
package org.springframework.boot.context.config;
/**
public interface ConfigDataLoaderContext {
	/**
	 * Provides access to the {@link ConfigurableBootstrapContext} shared across all
	 * {@link EnvironmentPostProcessor EnvironmentPostProcessors}.
	 * @return the bootstrap context
	 */
	ConfigurableBootstrapContext getBootstrapContext();
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataProperties {
	private static final ConfigurationPropertyName NAME = ConfigurationPropertyName.of('spring.config');
	private static final Bindable<ConfigDataProperties> BINDABLE_PROPERTIES = Bindable.of(ConfigDataProperties.class);
	private final List<ConfigDataLocation> imports;
	private final Activate activate;
	/**
	 * Create a new {@link ConfigDataProperties} instance.
	 * @param imports the imports requested
	 * @param activate the activate properties
	 */
	ConfigDataProperties(@Name('import') List<ConfigDataLocation> imports, Activate activate) {
		this.imports = (imports != null) ? imports : Collections.emptyList();
		this.activate = activate;
	}
	/**
	 * Return any additional imports requested.
	 * @return the requested imports
	 */
	List<ConfigDataLocation> getImports() {
		return this.imports;
	}
	/**
	 * Return {@code true} if the properties indicate that the config data property source
	 * is active for the given activation context.
	 * @param activationContext the activation context
	 * @return {@code true} if the config data property source is active
	 */
	boolean isActive(ConfigDataActivationContext activationContext) {
		return this.activate == null || this.activate.isActive(activationContext);
	}
	/**
	 * Return a new variant of these properties without any imports.
	 * @return a new {@link ConfigDataProperties} instance
	 */
	ConfigDataProperties withoutImports() {
		return new ConfigDataProperties(null, this.activate);
	}
	/**
	 * Factory method used to create {@link ConfigDataProperties} from the given
	 * {@link Binder}.
	 * @param binder the binder used to bind the properties
	 * @return a {@link ConfigDataProperties} instance or {@code null}
	 */
	static ConfigDataProperties get(Binder binder) {
		return binder.bind(NAME, BINDABLE_PROPERTIES, new ConfigDataLocationBindHandler()).orElse(null);
	}
	/**
	 * Activate properties used to determine when a config data property source is active.
	 */
	static class Activate {
		private final CloudPlatform onCloudPlatform;
		private final String[] onProfile;
		/**
		 * Create a new {@link Activate} instance.
		 * @param onCloudPlatform the cloud platform required for activation
		 * @param onProfile the profile expression required for activation
		 */
		Activate(CloudPlatform onCloudPlatform, String[] onProfile) {
			this.onProfile = onProfile;
			this.onCloudPlatform = onCloudPlatform;
		}
		/**
		 * Return {@code true} if the properties indicate that the config data property
		 * source is active for the given activation context.
		 * @param activationContext the activation context
		 * @return {@code true} if the config data property source is active
		 */
		boolean isActive(ConfigDataActivationContext activationContext) {
			if (activationContext == null) {
				return false;
			}
			CloudPlatform cloudPlatform = activationContext.getCloudPlatform();
			boolean activate = isActive((cloudPlatform != null) ? cloudPlatform : CloudPlatform.NONE);
			activate = activate && isActive(activationContext.getProfiles());
			return activate;
		}
		private boolean isActive(CloudPlatform cloudPlatform) {
			return this.onCloudPlatform == null || this.onCloudPlatform == cloudPlatform;
		}
		private boolean isActive(Profiles profiles) {
			return ObjectUtils.isEmpty(this.onProfile)
					|| (profiles != null && matchesActiveProfiles(profiles::isAccepted));
		}
		private boolean matchesActiveProfiles(Predicate<String> activeProfiles) {
			return org.springframework.core.env.Profiles.of(this.onProfile).matches(activeProfiles);
		}
	}
}
/*
/**
package org.springframework.boot.context.config;
/*
package org.springframework.boot.context.config;
/**
public final class ConfigData {
	private final List<PropertySource<?>> propertySources;
	private final PropertySourceOptions propertySourceOptions;
	/**
	 * A {@link ConfigData} instance that contains no data.
	 */
	public static final ConfigData EMPTY = new ConfigData(Collections.emptySet());
	/**
	 * Create a new {@link ConfigData} instance with the same options applied to each
	 * source.
	 * @param propertySources the config data property sources in ascending priority
	 * order.
	 * @param options the config data options applied to each source
	 * @see #ConfigData(Collection, PropertySourceOptions)
	 */
	public ConfigData(Collection<? extends PropertySource<?>> propertySources, Option... options) {
		this(propertySources, PropertySourceOptions.always(Options.of(options)));
	}
	/**
	 * Create a new {@link ConfigData} instance with specific property source options.
	 * @param propertySources the config data property sources in ascending priority
	 * order.
	 * @param propertySourceOptions the property source options
	 * @since 2.4.5
	 */
	public ConfigData(Collection<? extends PropertySource<?>> propertySources,
			PropertySourceOptions propertySourceOptions) {
		Assert.notNull(propertySources, 'PropertySources must not be null');
		Assert.notNull(propertySourceOptions, 'PropertySourceOptions must not be null');
		this.propertySources = Collections.unmodifiableList(new ArrayList<>(propertySources));
		this.propertySourceOptions = propertySourceOptions;
	}
	/**
	 * Return the configuration data property sources in ascending priority order. If the
	 * same key is contained in more than one of the sources, then the later source will
	 * win.
	 * @return the config data property sources
	 */
	public List<PropertySource<?>> getPropertySources() {
		return this.propertySources;
	}
	/**
	 * Return the {@link Options config data options} that apply to the given source.
	 * @param propertySource the property source to check
	 * @return the options that apply
	 * @since 2.4.5
	 */
	public Options getOptions(PropertySource<?> propertySource) {
		Options options = this.propertySourceOptions.get(propertySource);
		return (options != null) ? options : Options.NONE;
	}
	/**
	 * Strategy interface used to supply {@link Options} for a given
	 * {@link PropertySource}.
	 *
	 * @since 2.4.5
	 */
	@FunctionalInterface
	public interface PropertySourceOptions {
		/**
		 * {@link PropertySourceOptions} instance that always returns
		 * {@link Options#NONE}.
		 * @since 2.4.6
		 */
		PropertySourceOptions ALWAYS_NONE = new AlwaysPropertySourceOptions(Options.NONE);
		/**
		 * Return the options that should apply for the given property source.
		 * @param propertySource the property source
		 * @return the options to apply
		 */
		Options get(PropertySource<?> propertySource);
		/**
		 * Create a new {@link PropertySourceOptions} instance that always returns the
		 * same options regardless of the property source.
		 * @param options the options to return
		 * @return a new {@link PropertySourceOptions} instance
		 */
		static PropertySourceOptions always(Option... options) {
			return always(Options.of(options));
		}
		/**
		 * Create a new {@link PropertySourceOptions} instance that always returns the
		 * same options regardless of the property source.
		 * @param options the options to return
		 * @return a new {@link PropertySourceOptions} instance
		 */
		static PropertySourceOptions always(Options options) {
			if (options == Options.NONE) {
				return ALWAYS_NONE;
			}
			return new AlwaysPropertySourceOptions(options);
		}
	}
	/**
	 * {@link PropertySourceOptions} that always returns the same result.
	 */
	private static class AlwaysPropertySourceOptions implements PropertySourceOptions {
		private final Options options;
		AlwaysPropertySourceOptions(Options options) {
			this.options = options;
		}
		@Override
		public Options get(PropertySource<?> propertySource) {
			return this.options;
		}
	}
	/**
	 * A set of {@link Option} flags.
	 *
	 * @since 2.4.5
	 */
	public static final class Options {
		/**
		 * No options.
		 */
		public static final Options NONE = new Options(Collections.emptySet());
		private final Set<Option> options;
		private Options(Set<Option> options) {
			this.options = Collections.unmodifiableSet(options);
		}
		Set<Option> asSet() {
			return this.options;
		}
		/**
		 * Returns if the given option is contained in this set.
		 * @param option the option to check
		 * @return {@code true} of the option is present
		 */
		public boolean contains(Option option) {
			return this.options.contains(option);
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			Options other = (Options) obj;
			return this.options.equals(other.options);
		}
		@Override
		public int hashCode() {
			return this.options.hashCode();
		}
		@Override
		public String toString() {
			return this.options.toString();
		}
		/**
		 * Create a new {@link Options} instance that contains the options in this set
		 * excluding the given option.
		 * @param option the option to exclude
		 * @return a new {@link Options} instance
		 */
		public Options without(Option option) {
			return copy((options) -> options.remove(option));
		}
		/**
		 * Create a new {@link Options} instance that contains the options in this set
		 * including the given option.
		 * @param option the option to include
		 * @return a new {@link Options} instance
		 */
		public Options with(Option option) {
			return copy((options) -> options.add(option));
		}
		private Options copy(Consumer<EnumSet<Option>> processor) {
			EnumSet<Option> options = EnumSet.copyOf(this.options);
			processor.accept(options);
			return new Options(options);
		}
		/**
		 * Create a new instance with the given {@link Option} values.
		 * @param options the options to include
		 * @return a new {@link Options} instance
		 */
		public static Options of(Option... options) {
			Assert.notNull(options, 'Options must not be null');
			if (options.length == 0) {
				return NONE;
			}
			return new Options(EnumSet.copyOf(Arrays.asList(options)));
		}
	}
	/**
	 * Option flags that can be applied.
	 */
	public enum Option {
		/**
		 * Ignore all imports properties from the source.
		 */
		IGNORE_IMPORTS,
		/**
		 * Ignore all profile activation and include properties.
		 * @since 2.4.3
		 */
		IGNORE_PROFILES,
		/**
		 * Indicates that the source is 'profile specific' and should be included after
		 * profile specific sibling imports.
		 * @since 2.4.5
		 */
		PROFILE_SPECIFIC
	}
}
/*
package org.springframework.boot.context.config;
/**
public class ConfigTreeConfigDataLocationResolver implements ConfigDataLocationResolver<ConfigTreeConfigDataResource> {
	private static final String PREFIX = 'configtree:';
	private final LocationResourceLoader resourceLoader;
	public ConfigTreeConfigDataLocationResolver(ResourceLoader resourceLoader) {
		this.resourceLoader = new LocationResourceLoader(resourceLoader);
	}
	@Override
	public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
		return location.hasPrefix(PREFIX);
	}
	@Override
	public List<ConfigTreeConfigDataResource> resolve(ConfigDataLocationResolverContext context,
			ConfigDataLocation location) {
		try {
			return resolve(location.getNonPrefixedValue(PREFIX));
		}
		catch (IOException ex) {
			throw new ConfigDataLocationNotFoundException(location, ex);
		}
	}
	private List<ConfigTreeConfigDataResource> resolve(String location) throws IOException {
		Assert.isTrue(location.endsWith('/'),
				() -> String.format('Config tree location "%s" must end with "/"', location));
		if (!this.resourceLoader.isPattern(location)) {
			return Collections.singletonList(new ConfigTreeConfigDataResource(location));
		}
		Resource[] resources = this.resourceLoader.getResources(location, ResourceType.DIRECTORY);
		List<ConfigTreeConfigDataResource> resolved = new ArrayList<>(resources.length);
		for (Resource resource : resources) {
			resolved.add(new ConfigTreeConfigDataResource(resource.getFile().toPath()));
		}
		return resolved;
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataImporter {
	private final Log logger;
	private final ConfigDataLocationResolvers resolvers;
	private final ConfigDataLoaders loaders;
	private final ConfigDataNotFoundAction notFoundAction;
	private final Set<ConfigDataResource> loaded = new HashSet<>();
	private final Set<ConfigDataLocation> loadedLocations = new HashSet<>();
	private final Set<ConfigDataLocation> optionalLocations = new HashSet<>();
	/**
	 * Create a new {@link ConfigDataImporter} instance.
	 * @param logFactory the log factory
	 * @param notFoundAction the action to take when a location cannot be found
	 * @param resolvers the config data location resolvers
	 * @param loaders the config data loaders
	 */
	ConfigDataImporter(DeferredLogFactory logFactory, ConfigDataNotFoundAction notFoundAction,
			ConfigDataLocationResolvers resolvers, ConfigDataLoaders loaders) {
		this.logger = logFactory.getLog(getClass());
		this.resolvers = resolvers;
		this.loaders = loaders;
		this.notFoundAction = notFoundAction;
	}
	/**
	 * Resolve and load the given list of locations, filtering any that have been
	 * previously loaded.
	 * @param activationContext the activation context
	 * @param locationResolverContext the location resolver context
	 * @param loaderContext the loader context
	 * @param locations the locations to resolve
	 * @return a map of the loaded locations and data
	 */
	Map<ConfigDataResolutionResult, ConfigData> resolveAndLoad(ConfigDataActivationContext activationContext,
			ConfigDataLocationResolverContext locationResolverContext, ConfigDataLoaderContext loaderContext,
			List<ConfigDataLocation> locations) {
		try {
			Profiles profiles = (activationContext != null) ? activationContext.getProfiles() : null;
			List<ConfigDataResolutionResult> resolved = resolve(locationResolverContext, profiles, locations);
			return load(loaderContext, resolved);
		}
		catch (IOException ex) {
			throw new IllegalStateException('IO error on loading imports from ' + locations, ex);
		}
	}
	private List<ConfigDataResolutionResult> resolve(ConfigDataLocationResolverContext locationResolverContext,
			Profiles profiles, List<ConfigDataLocation> locations) {
		List<ConfigDataResolutionResult> resolved = new ArrayList<>(locations.size());
		for (ConfigDataLocation location : locations) {
			resolved.addAll(resolve(locationResolverContext, profiles, location));
		}
		return Collections.unmodifiableList(resolved);
	}
	private List<ConfigDataResolutionResult> resolve(ConfigDataLocationResolverContext locationResolverContext,
			Profiles profiles, ConfigDataLocation location) {
		try {
			return this.resolvers.resolve(locationResolverContext, location, profiles);
		}
		catch (ConfigDataNotFoundException ex) {
			handle(ex, location, null);
			return Collections.emptyList();
		}
	}
	private Map<ConfigDataResolutionResult, ConfigData> load(ConfigDataLoaderContext loaderContext,
			List<ConfigDataResolutionResult> candidates) throws IOException {
		Map<ConfigDataResolutionResult, ConfigData> result = new LinkedHashMap<>();
		for (int i = candidates.size() - 1; i >= 0; i--) {
			ConfigDataResolutionResult candidate = candidates.get(i);
			ConfigDataLocation location = candidate.getLocation();
			ConfigDataResource resource = candidate.getResource();
			this.logger.trace(LogMessage.format('Considering resource %s from location %s', resource, location));
			if (resource.isOptional()) {
				this.optionalLocations.add(location);
			}
			if (this.loaded.contains(resource)) {
				this.logger
					.trace(LogMessage.format('Already loaded resource %s ignoring location %s', resource, location));
				this.loadedLocations.add(location);
			}
			else {
				try {
					ConfigData loaded = this.loaders.load(loaderContext, resource);
					if (loaded != null) {
						this.logger.trace(LogMessage.format('Loaded resource %s from location %s', resource, location));
						this.loaded.add(resource);
						this.loadedLocations.add(location);
						result.put(candidate, loaded);
					}
				}
				catch (ConfigDataNotFoundException ex) {
					handle(ex, location, resource);
				}
			}
		}
		return Collections.unmodifiableMap(result);
	}
	private void handle(ConfigDataNotFoundException ex, ConfigDataLocation location, ConfigDataResource resource) {
		if (ex instanceof ConfigDataResourceNotFoundException notFoundException) {
			ex = notFoundException.withLocation(location);
		}
		getNotFoundAction(location, resource).handle(this.logger, ex);
	}
	private ConfigDataNotFoundAction getNotFoundAction(ConfigDataLocation location, ConfigDataResource resource) {
		if (location.isOptional() || (resource != null && resource.isOptional())) {
			return ConfigDataNotFoundAction.IGNORE;
		}
		return this.notFoundAction;
	}
	Set<ConfigDataLocation> getLoadedLocations() {
		return this.loadedLocations;
	}
	Set<ConfigDataLocation> getOptionalLocations() {
		return this.optionalLocations;
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationRuntimeHints implements RuntimeHintsRegistrar {
	private static final Log logger = LogFactory.getLog(ConfigDataLocationRuntimeHints.class);
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		List<String> fileNames = getFileNames(classLoader);
		List<String> locations = getLocations(classLoader);
		List<String> extensions = getExtensions(classLoader);
		if (logger.isDebugEnabled()) {
			logger.debug('Registering application configuration hints for ' + fileNames + '(' + extensions + ') at '
					+ locations);
		}
		FilePatternResourceHintsRegistrar.forClassPathLocations(locations)
			.withFilePrefixes(fileNames)
			.withFileExtensions(extensions)
			.registerHints(hints.resources(), classLoader);
	}
	/**
	 * Get the application file names to consider.
	 * @param classLoader the classloader to use
	 * @return the configuration file names
	 */
	protected List<String> getFileNames(ClassLoader classLoader) {
		return Arrays.asList(StandardConfigDataLocationResolver.DEFAULT_CONFIG_NAMES);
	}
	/**
	 * Get the locations to consider. A location is a classpath location that may or may
	 * not use the standard {@code classpath:} prefix.
	 * @param classLoader the classloader to use
	 * @return the configuration file locations
	 */
	protected List<String> getLocations(ClassLoader classLoader) {
		List<String> classpathLocations = new ArrayList<>();
		for (ConfigDataLocation candidate : ConfigDataEnvironment.DEFAULT_SEARCH_LOCATIONS) {
			for (ConfigDataLocation configDataLocation : candidate.split()) {
				String location = configDataLocation.getValue();
				if (location.startsWith(ResourceUtils.CLASSPATH_URL_PREFIX)) {
					classpathLocations.add(location);
				}
			}
		}
		return classpathLocations;
	}
	/**
	 * Get the application file extensions to consider. A valid extension starts with a
	 * dot.
	 * @param classLoader the classloader to use
	 * @return the configuration file extensions
	 */
	protected List<String> getExtensions(ClassLoader classLoader) {
		List<String> extensions = new ArrayList<>();
		List<PropertySourceLoader> propertySourceLoaders = getSpringFactoriesLoader(classLoader)
			.load(PropertySourceLoader.class);
		for (PropertySourceLoader propertySourceLoader : propertySourceLoaders) {
			for (String fileExtension : propertySourceLoader.getFileExtensions()) {
				String candidate = '.' + fileExtension;
				if (!extensions.contains(candidate)) {
					extensions.add(candidate);
				}
			}
		}
		return extensions;
	}
	protected SpringFactoriesLoader getSpringFactoriesLoader(ClassLoader classLoader) {
		return SpringFactoriesLoader.forDefaultResourceLocation(classLoader);
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationResolvers {
	private final List<ConfigDataLocationResolver<?>> resolvers;
	/**
	 * Create a new {@link ConfigDataLocationResolvers} instance.
	 * @param logFactory a {@link DeferredLogFactory} used to inject {@link Log} instances
	 * @param bootstrapContext the bootstrap context
	 * @param binder a binder providing values from the initial {@link Environment}
	 * @param resourceLoader {@link ResourceLoader} to load resource locations
	 * @param springFactoriesLoader to load {@link ConfigDataLocationResolver} instances
	 */
	ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext,
			Binder binder, ResourceLoader resourceLoader, SpringFactoriesLoader springFactoriesLoader) {
		ArgumentResolver argumentResolver = ArgumentResolver.of(DeferredLogFactory.class, logFactory);
		argumentResolver = argumentResolver.and(Binder.class, binder);
		argumentResolver = argumentResolver.and(ResourceLoader.class, resourceLoader);
		argumentResolver = argumentResolver.and(ConfigurableBootstrapContext.class, bootstrapContext);
		argumentResolver = argumentResolver.and(BootstrapContext.class, bootstrapContext);
		argumentResolver = argumentResolver.and(BootstrapRegistry.class, bootstrapContext);
		argumentResolver = argumentResolver.andSupplied(Log.class, () -> {
			throw new IllegalArgumentException('Log types cannot be injected, please use DeferredLogFactory');
		});
		this.resolvers = reorder(springFactoriesLoader.load(ConfigDataLocationResolver.class, argumentResolver));
	}
	@SuppressWarnings('rawtypes')
	private List<ConfigDataLocationResolver<?>> reorder(List<ConfigDataLocationResolver> resolvers) {
		List<ConfigDataLocationResolver<?>> reordered = new ArrayList<>(resolvers.size());
		ConfigDataLocationResolver<?> standardConfigDataLocationResolver = null;
		for (ConfigDataLocationResolver<?> resolver : resolvers) {
			if (resolver instanceof StandardConfigDataLocationResolver) {
				standardConfigDataLocationResolver = resolver;
			}
			else {
				reordered.add(resolver);
			}
		}
		if (standardConfigDataLocationResolver != null) {
			reordered.add(standardConfigDataLocationResolver);
		}
		return Collections.unmodifiableList(reordered);
	}
	List<ConfigDataResolutionResult> resolve(ConfigDataLocationResolverContext context, ConfigDataLocation location,
			Profiles profiles) {
		if (location == null) {
			return Collections.emptyList();
		}
		for (ConfigDataLocationResolver<?> resolver : getResolvers()) {
			if (resolver.isResolvable(context, location)) {
				return resolve(resolver, context, location, profiles);
			}
		}
		throw new UnsupportedConfigDataLocationException(location);
	}
	private List<ConfigDataResolutionResult> resolve(ConfigDataLocationResolver<?> resolver,
			ConfigDataLocationResolverContext context, ConfigDataLocation location, Profiles profiles) {
		List<ConfigDataResolutionResult> resolved = resolve(location, false, () -> resolver.resolve(context, location));
		if (profiles == null) {
			return resolved;
		}
		List<ConfigDataResolutionResult> profileSpecific = resolve(location, true,
				() -> resolver.resolveProfileSpecific(context, location, profiles));
		return merge(resolved, profileSpecific);
	}
	private List<ConfigDataResolutionResult> resolve(ConfigDataLocation location, boolean profileSpecific,
			Supplier<List<? extends ConfigDataResource>> resolveAction) {
		List<ConfigDataResource> resources = nonNullList(resolveAction.get());
		List<ConfigDataResolutionResult> resolved = new ArrayList<>(resources.size());
		for (ConfigDataResource resource : resources) {
			resolved.add(new ConfigDataResolutionResult(location, resource, profileSpecific));
		}
		return resolved;
	}
	@SuppressWarnings('unchecked')
	private <T> List<T> nonNullList(List<? extends T> list) {
		return (list != null) ? (List<T>) list : Collections.emptyList();
	}
	private <T> List<T> merge(List<T> list1, List<T> list2) {
		List<T> merged = new ArrayList<>(list1.size() + list2.size());
		merged.addAll(list1);
		merged.addAll(list2);
		return merged;
	}
	/**
	 * Return the resolvers managed by this object.
	 * @return the resolvers
	 */
	List<ConfigDataLocationResolver<?>> getResolvers() {
		return this.resolvers;
	}
}
/*
package org.springframework.boot.context.config;
/**
public enum ConfigDataNotFoundAction {
	/**
	 * Throw the exception to fail startup.
	 */
	FAIL {
		@Override
		void handle(Log logger, ConfigDataNotFoundException ex) {
			throw ex;
		}
	},
	/**
	 * Ignore the exception and continue processing the remaining locations.
	 */
	IGNORE {
		@Override
		void handle(Log logger, ConfigDataNotFoundException ex) {
			logger.trace(LogMessage.format('Ignoring missing config data %s', ex.getReferenceDescription()));
		}
	};
	/**
	 * Handle the given exception.
	 * @param logger the logger used for output {@code ConfigDataLocation})
	 * @param ex the exception to handle
	 */
	abstract void handle(Log logger, ConfigDataNotFoundException ex);
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataPropertiesRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		BindableRuntimeHintsRegistrar.forTypes(ConfigDataProperties.class).registerHints(hints);
		hints.reflection()
			.registerMethod(ReflectionUtils.findMethod(ConfigDataLocation.class, 'of', String.class),
					ExecutableMode.INVOKE);
	}
}
/*
package org.springframework.boot.context.config;
/**
public class StandardConfigDataResource extends ConfigDataResource {
	private final StandardConfigDataReference reference;
	private final Resource resource;
	private final boolean emptyDirectory;
	/**
	 * Create a new {@link StandardConfigDataResource} instance.
	 * @param reference the resource reference
	 * @param resource the underlying resource
	 */
	StandardConfigDataResource(StandardConfigDataReference reference, Resource resource) {
		this(reference, resource, false);
	}
	/**
	 * Create a new {@link StandardConfigDataResource} instance.
	 * @param reference the resource reference
	 * @param resource the underlying resource
	 * @param emptyDirectory if the resource is an empty directory that we know exists
	 */
	StandardConfigDataResource(StandardConfigDataReference reference, Resource resource, boolean emptyDirectory) {
		Assert.notNull(reference, 'Reference must not be null');
		Assert.notNull(resource, 'Resource must not be null');
		this.reference = reference;
		this.resource = resource;
		this.emptyDirectory = emptyDirectory;
	}
	StandardConfigDataReference getReference() {
		return this.reference;
	}
	/**
	 * Return the underlying Spring {@link Resource} being loaded.
	 * @return the underlying resource
	 * @since 2.4.2
	 */
	public Resource getResource() {
		return this.resource;
	}
	/**
	 * Return the profile or {@code null} if the resource is not profile specific.
	 * @return the profile or {@code null}
	 * @since 2.4.6
	 */
	public String getProfile() {
		return this.reference.getProfile();
	}
	boolean isEmptyDirectory() {
		return this.emptyDirectory;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		StandardConfigDataResource other = (StandardConfigDataResource) obj;
		return (this.emptyDirectory == other.emptyDirectory) && isSameUnderlyingResource(this.resource, other.resource);
	}
	private boolean isSameUnderlyingResource(Resource ours, Resource other) {
		return ours.equals(other) || isSameFile(getUnderlyingFile(ours), getUnderlyingFile(other));
	}
	private boolean isSameFile(File ours, File other) {
		return (ours != null) && ours.equals(other);
	}
	@Override
	public int hashCode() {
		File underlyingFile = getUnderlyingFile(this.resource);
		return (underlyingFile != null) ? underlyingFile.hashCode() : this.resource.hashCode();
	}
	@Override
	public String toString() {
		if (this.resource instanceof FileSystemResource || this.resource instanceof FileUrlResource) {
			try {
				return 'file [' + this.resource.getFile() + ']';
			}
			catch (IOException ex) {
				// Ignore
			}
		}
		return this.resource.toString();
	}
	private File getUnderlyingFile(Resource resource) {
		try {
			if (resource instanceof ClassPathResource || resource instanceof FileSystemResource
					|| resource instanceof FileUrlResource) {
				return resource.getFile().getAbsoluteFile();
			}
		}
		catch (IOException ex) {
			// Ignore
		}
		return null;
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataResolutionResult {
	private final ConfigDataLocation location;
	private final ConfigDataResource resource;
	private final boolean profileSpecific;
	ConfigDataResolutionResult(ConfigDataLocation location, ConfigDataResource resource, boolean profileSpecific) {
		this.location = location;
		this.resource = resource;
		this.profileSpecific = profileSpecific;
	}
	ConfigDataLocation getLocation() {
		return this.location;
	}
	ConfigDataResource getResource() {
		return this.resource;
	}
	boolean isProfileSpecific() {
		return this.profileSpecific;
	}
}
/*
package org.springframework.boot.context.config;
/**
public class ConfigDataResourceNotFoundException extends ConfigDataNotFoundException {
	private final ConfigDataResource resource;
	private final ConfigDataLocation location;
	/**
	 * Create a new {@link ConfigDataResourceNotFoundException} instance.
	 * @param resource the resource that could not be found
	 */
	public ConfigDataResourceNotFoundException(ConfigDataResource resource) {
		this(resource, null);
	}
	/**
	 * Create a new {@link ConfigDataResourceNotFoundException} instance.
	 * @param resource the resource that could not be found
	 * @param cause the exception cause
	 */
	public ConfigDataResourceNotFoundException(ConfigDataResource resource, Throwable cause) {
		this(resource, null, cause);
	}
	private ConfigDataResourceNotFoundException(ConfigDataResource resource, ConfigDataLocation location,
			Throwable cause) {
		super(getMessage(resource, location), cause);
		Assert.notNull(resource, 'Resource must not be null');
		this.resource = resource;
		this.location = location;
	}
	/**
	 * Return the resource that could not be found.
	 * @return the resource
	 */
	public ConfigDataResource getResource() {
		return this.resource;
	}
	/**
	 * Return the original location that was resolved to determine the resource.
	 * @return the location or {@code null} if no location is available
	 */
	public ConfigDataLocation getLocation() {
		return this.location;
	}
	@Override
	public Origin getOrigin() {
		return Origin.from(this.location);
	}
	@Override
	public String getReferenceDescription() {
		return getReferenceDescription(this.resource, this.location);
	}
	/**
	 * Create a new {@link ConfigDataResourceNotFoundException} instance with a location.
	 * @param location the location to set
	 * @return a new {@link ConfigDataResourceNotFoundException} instance
	 */
	ConfigDataResourceNotFoundException withLocation(ConfigDataLocation location) {
		return new ConfigDataResourceNotFoundException(this.resource, location, getCause());
	}
	private static String getMessage(ConfigDataResource resource, ConfigDataLocation location) {
		return String.format('Config data %s cannot be found', getReferenceDescription(resource, location));
	}
	private static String getReferenceDescription(ConfigDataResource resource, ConfigDataLocation location) {
		String description = String.format('resource "%s"', resource);
		if (location != null) {
			description += String.format(' via location "%s"', location);
		}
		return description;
	}
	/**
	 * Throw a {@link ConfigDataNotFoundException} if the specified {@link Path} does not
	 * exist.
	 * @param resource the config data resource
	 * @param pathToCheck the path to check
	 */
	public static void throwIfDoesNotExist(ConfigDataResource resource, Path pathToCheck) {
		throwIfDoesNotExist(resource, Files.exists(pathToCheck));
	}
	/**
	 * Throw a {@link ConfigDataNotFoundException} if the specified {@link File} does not
	 * exist.
	 * @param resource the config data resource
	 * @param fileToCheck the file to check
	 */
	public static void throwIfDoesNotExist(ConfigDataResource resource, File fileToCheck) {
		throwIfDoesNotExist(resource, fileToCheck.exists());
	}
	/**
	 * Throw a {@link ConfigDataNotFoundException} if the specified {@link Resource} does
	 * not exist.
	 * @param resource the config data resource
	 * @param resourceToCheck the resource to check
	 */
	public static void throwIfDoesNotExist(ConfigDataResource resource, Resource resourceToCheck) {
		throwIfDoesNotExist(resource, resourceToCheck.exists());
	}
	private static void throwIfDoesNotExist(ConfigDataResource resource, boolean exists) {
		if (!exists) {
			throw new ConfigDataResourceNotFoundException(resource);
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class LocationResourceLoader {
	private static final Resource[] EMPTY_RESOURCES = {};
	private static final Comparator<File> FILE_PATH_COMPARATOR = Comparator.comparing(File::getAbsolutePath);
	private static final Comparator<File> FILE_NAME_COMPARATOR = Comparator.comparing(File::getName);
	private final ResourceLoader resourceLoader;
	/**
	 * Create a new {@link LocationResourceLoader} instance.
	 * @param resourceLoader the underlying resource loader
	 */
	LocationResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	/**
	 * Returns if the location contains a pattern.
	 * @param location the location to check
	 * @return if the location is a pattern
	 */
	boolean isPattern(String location) {
		return StringUtils.hasLength(location) && location.contains('*');
	}
	/**
	 * Get a single resource from a non-pattern location.
	 * @param location the location
	 * @return the resource
	 * @see #isPattern(String)
	 */
	Resource getResource(String location) {
		validateNonPattern(location);
		location = StringUtils.cleanPath(location);
		if (!ResourceUtils.isUrl(location)) {
			location = ResourceUtils.FILE_URL_PREFIX + location;
		}
		return this.resourceLoader.getResource(location);
	}
	private void validateNonPattern(String location) {
		Assert.state(!isPattern(location), () -> String.format('Location "%s" must not be a pattern', location));
	}
	/**
	 * Get a multiple resources from a location pattern.
	 * @param location the location pattern
	 * @param type the type of resource to return
	 * @return the resources
	 * @see #isPattern(String)
	 */
	Resource[] getResources(String location, ResourceType type) {
		validatePattern(location, type);
		String directoryPath = location.substring(0, location.indexOf('*/'));
		String fileName = location.substring(location.lastIndexOf('/') + 1);
		Resource resource = getResource(directoryPath);
		if (!resource.exists()) {
			return EMPTY_RESOURCES;
		}
		File file = getFile(location, resource);
		if (!file.isDirectory()) {
			return EMPTY_RESOURCES;
		}
		File[] subDirectories = file.listFiles(this::isVisibleDirectory);
		if (subDirectories == null) {
			return EMPTY_RESOURCES;
		}
		Arrays.sort(subDirectories, FILE_PATH_COMPARATOR);
		if (type == ResourceType.DIRECTORY) {
			return Arrays.stream(subDirectories).map(FileSystemResource::new).toArray(Resource[]::new);
		}
		List<Resource> resources = new ArrayList<>();
		FilenameFilter filter = (dir, name) -> name.equals(fileName);
		for (File subDirectory : subDirectories) {
			File[] files = subDirectory.listFiles(filter);
			if (files != null) {
				Arrays.sort(files, FILE_NAME_COMPARATOR);
				Arrays.stream(files).map(FileSystemResource::new).forEach(resources::add);
			}
		}
		return resources.toArray(EMPTY_RESOURCES);
	}
	private void validatePattern(String location, ResourceType type) {
		Assert.state(isPattern(location), () -> String.format('Location "%s" must be a pattern', location));
		Assert.state(!location.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX),
				() -> String.format('Location "%s" cannot use classpath wildcards', location));
		Assert.state(StringUtils.countOccurrencesOf(location, '*') == 1,
				() -> String.format('Location "%s" cannot contain multiple wildcards', location));
		String directoryPath = (type != ResourceType.DIRECTORY) ? location.substring(0, location.lastIndexOf('/') + 1)
				: location;
		Assert.state(directoryPath.endsWith('*/'), () -> String.format('Location "%s" must end with "*/"', location));
	}
	private File getFile(String patternLocation, Resource resource) {
		try {
			return resource.getFile();
		}
		catch (Exception ex) {
			throw new IllegalStateException(
					'Unable to load config data resource from pattern "' + patternLocation + '"', ex);
		}
	}
	private boolean isVisibleDirectory(File file) {
		return file.isDirectory() && !file.getName().startsWith('..');
	}
	/**
	 * Resource types that can be returned.
	 */
	enum ResourceType {
		/**
		 * Return file resources.
		 */
		FILE,
		/**
		 * Return directory resources.
		 */
		DIRECTORY
	}
}
/*
package org.springframework.boot.context.config;
/**
public abstract class ConfigDataResource {
	private final boolean optional;
	/**
	 * Create a new non-optional {@link ConfigDataResource} instance.
	 */
	public ConfigDataResource() {
		this(false);
	}
	/**
	 * Create a new {@link ConfigDataResource} instance.
	 * @param optional if the resource is optional
	 * @since 2.4.6
	 */
	protected ConfigDataResource(boolean optional) {
		this.optional = optional;
	}
	boolean isOptional() {
		return this.optional;
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationBindHandler extends AbstractBindHandler {
	@Override
	public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		if (result instanceof ConfigDataLocation location) {
			return withOrigin(context, location);
		}
		if (result instanceof List<?> list) {
			return list.stream()
				.filter(Objects::nonNull)
				.map((element) -> (element instanceof ConfigDataLocation location) ? withOrigin(context, location)
						: element)
				.collect(Collectors.toCollection(ArrayList::new));
		}
		if (result instanceof ConfigDataLocation[] unfilteredLocations) {
			return Arrays.stream(unfilteredLocations)
				.filter(Objects::nonNull)
				.map((element) -> withOrigin(context, element))
				.toArray(ConfigDataLocation[]::new);
		}
		return result;
	}
	private ConfigDataLocation withOrigin(BindContext context, ConfigDataLocation result) {
		if (result.getOrigin() != null) {
			return result;
		}
		Origin origin = Origin.from(context.getConfigurationProperty());
		return result.withOrigin(origin);
	}
}
/*
package org.springframework.boot.context.config;
/**
public abstract class ConfigDataNotFoundException extends ConfigDataException implements OriginProvider {
	/**
	 * Create a new {@link ConfigDataNotFoundException} instance.
	 * @param message the exception message
	 * @param cause the exception cause
	 */
	ConfigDataNotFoundException(String message, Throwable cause) {
		super(message, cause);
	}
	/**
	 * Return a description of actual referenced item that could not be found.
	 * @return a description of the referenced items
	 */
	public abstract String getReferenceDescription();
}
/*
package org.springframework.boot.context.properties;
/**
class NotConstructorBoundInjectionFailureAnalyzer
		extends AbstractInjectionFailureAnalyzer<NoSuchBeanDefinitionException> implements Ordered {
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchBeanDefinitionException cause, String description) {
		InjectionPoint injectionPoint = findInjectionPoint(rootFailure);
		if (isConstructorBindingConfigurationProperties(injectionPoint)) {
			String simpleName = injectionPoint.getMember().getDeclaringClass().getSimpleName();
			String action = 'Update your configuration so that ' + simpleName + ' is defined via @'
					+ ConfigurationPropertiesScan.class.getSimpleName() + ' or @'
					+ EnableConfigurationProperties.class.getSimpleName() + '.';
			return new FailureAnalysis(
					simpleName + ' is annotated with @' + ConstructorBinding.class.getSimpleName()
							+ ' but it is defined as a regular bean which caused dependency injection to fail.',
					action, cause);
		}
		return null;
	}
	private boolean isConstructorBindingConfigurationProperties(InjectionPoint injectionPoint) {
		return injectionPoint != null && injectionPoint.getMember() instanceof Constructor<?> constructor
				&& isConstructorBindingConfigurationProperties(constructor);
	}
	private boolean isConstructorBindingConfigurationProperties(Constructor<?> constructor) {
		Class<?> declaringClass = constructor.getDeclaringClass();
		BindMethod bindMethod = ConfigurationPropertiesBean.deduceBindMethod(declaringClass);
		return MergedAnnotations.from(declaringClass, SearchStrategy.TYPE_HIERARCHY)
			.isPresent(ConfigurationProperties.class) && bindMethod == BindMethod.VALUE_OBJECT;
	}
	private InjectionPoint findInjectionPoint(Throwable failure) {
		UnsatisfiedDependencyException unsatisfiedDependencyException = findCause(failure,
				UnsatisfiedDependencyException.class);
		if (unsatisfiedDependencyException == null) {
			return null;
		}
		return unsatisfiedDependencyException.getInjectionPoint();
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBinder {
	private static final String BEAN_NAME = 'org.springframework.boot.context.internalConfigurationPropertiesBinder';
	private static final String VALIDATOR_BEAN_NAME = EnableConfigurationProperties.VALIDATOR_BEAN_NAME;
	private final ApplicationContext applicationContext;
	private final PropertySources propertySources;
	private final Validator configurationPropertiesValidator;
	private final boolean jsr303Present;
	private volatile Binder binder;
	ConfigurationPropertiesBinder(ApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
		this.propertySources = new PropertySourcesDeducer(applicationContext).getPropertySources();
		this.configurationPropertiesValidator = getConfigurationPropertiesValidator(applicationContext);
		this.jsr303Present = ConfigurationPropertiesJsr303Validator.isJsr303Present(applicationContext);
	}
	BindResult<?> bind(ConfigurationPropertiesBean propertiesBean) {
		Bindable<?> target = propertiesBean.asBindTarget();
		ConfigurationProperties annotation = propertiesBean.getAnnotation();
		BindHandler bindHandler = getBindHandler(target, annotation);
		return getBinder().bind(annotation.prefix(), target, bindHandler);
	}
	Object bindOrCreate(ConfigurationPropertiesBean propertiesBean) {
		Bindable<?> target = propertiesBean.asBindTarget();
		ConfigurationProperties annotation = propertiesBean.getAnnotation();
		BindHandler bindHandler = getBindHandler(target, annotation);
		return getBinder().bindOrCreate(annotation.prefix(), target, bindHandler);
	}
	private Validator getConfigurationPropertiesValidator(ApplicationContext applicationContext) {
		if (applicationContext.containsBean(VALIDATOR_BEAN_NAME)) {
			return applicationContext.getBean(VALIDATOR_BEAN_NAME, Validator.class);
		}
		return null;
	}
	private <T> BindHandler getBindHandler(Bindable<T> target, ConfigurationProperties annotation) {
		List<Validator> validators = getValidators(target);
		BindHandler handler = getHandler();
		handler = new ConfigurationPropertiesBindHandler(handler);
		if (annotation.ignoreInvalidFields()) {
			handler = new IgnoreErrorsBindHandler(handler);
		}
		if (!annotation.ignoreUnknownFields()) {
			UnboundElementsSourceFilter filter = new UnboundElementsSourceFilter();
			handler = new NoUnboundElementsBindHandler(handler, filter);
		}
		if (!validators.isEmpty()) {
			handler = new ValidationBindHandler(handler, validators.toArray(new Validator[0]));
		}
		for (ConfigurationPropertiesBindHandlerAdvisor advisor : getBindHandlerAdvisors()) {
			handler = advisor.apply(handler);
		}
		return handler;
	}
	private IgnoreTopLevelConverterNotFoundBindHandler getHandler() {
		BoundConfigurationProperties bound = BoundConfigurationProperties.get(this.applicationContext);
		return (bound != null)
				? new IgnoreTopLevelConverterNotFoundBindHandler(new BoundPropertiesTrackingBindHandler(bound::add))
				: new IgnoreTopLevelConverterNotFoundBindHandler();
	}
	private List<Validator> getValidators(Bindable<?> target) {
		List<Validator> validators = new ArrayList<>(3);
		if (this.configurationPropertiesValidator != null) {
			validators.add(this.configurationPropertiesValidator);
		}
		if (this.jsr303Present && target.getAnnotation(Validated.class) != null) {
			validators.add(getJsr303Validator(target.getType().resolve()));
		}
		Validator selfValidator = getSelfValidator(target);
		if (selfValidator != null) {
			validators.add(selfValidator);
		}
		return validators;
	}
	private Validator getSelfValidator(Bindable<?> target) {
		if (target.getValue() != null) {
			Object value = target.getValue().get();
			return (value instanceof Validator validator) ? validator : null;
		}
		Class<?> type = target.getType().resolve();
		if (type != null && Validator.class.isAssignableFrom(type)) {
			return new SelfValidatingConstructorBoundBindableValidator(type);
		}
		return null;
	}
	private Validator getJsr303Validator(Class<?> type) {
		return new ConfigurationPropertiesJsr303Validator(this.applicationContext, type);
	}
	private List<ConfigurationPropertiesBindHandlerAdvisor> getBindHandlerAdvisors() {
		return this.applicationContext.getBeanProvider(ConfigurationPropertiesBindHandlerAdvisor.class)
			.orderedStream()
			.toList();
	}
	private Binder getBinder() {
		if (this.binder == null) {
			this.binder = new Binder(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(),
					getConversionServices(), getPropertyEditorInitializer(), null, null);
		}
		return this.binder;
	}
	private Iterable<ConfigurationPropertySource> getConfigurationPropertySources() {
		return ConfigurationPropertySources.from(this.propertySources);
	}
	private PropertySourcesPlaceholdersResolver getPropertySourcesPlaceholdersResolver() {
		return new PropertySourcesPlaceholdersResolver(this.propertySources);
	}
	private List<ConversionService> getConversionServices() {
		return new ConversionServiceDeducer(this.applicationContext).getConversionServices();
	}
	private Consumer<PropertyEditorRegistry> getPropertyEditorInitializer() {
		if (this.applicationContext instanceof ConfigurableApplicationContext configurableContext) {
			return configurableContext.getBeanFactory()::copyRegisteredEditorsTo;
		}
		return null;
	}
	static void register(BeanDefinitionRegistry registry) {
		if (!registry.containsBeanDefinition(BEAN_NAME)) {
			BeanDefinition definition = BeanDefinitionBuilder
				.rootBeanDefinition(ConfigurationPropertiesBinderFactory.class)
				.getBeanDefinition();
			definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
			registry.registerBeanDefinition(BEAN_NAME, definition);
		}
	}
	static ConfigurationPropertiesBinder get(BeanFactory beanFactory) {
		return beanFactory.getBean(BEAN_NAME, ConfigurationPropertiesBinder.class);
	}
	/**
	 * {@link BindHandler} to deal with
	 * {@link ConfigurationProperties @ConfigurationProperties} concerns.
	 */
	private static class ConfigurationPropertiesBindHandler extends AbstractBindHandler {
		ConfigurationPropertiesBindHandler(BindHandler handler) {
			super(handler);
		}
		@Override
		public <T> Bindable<T> onStart(ConfigurationPropertyName name, Bindable<T> target, BindContext context) {
			return isConfigurationProperties(target.getType().resolve())
					? target.withBindRestrictions(BindRestriction.NO_DIRECT_PROPERTY) : target;
		}
		private boolean isConfigurationProperties(Class<?> target) {
			return target != null && MergedAnnotations.from(target).isPresent(ConfigurationProperties.class);
		}
	}
	/**
	 * {@link FactoryBean} to create the {@link ConfigurationPropertiesBinder}.
	 */
	static class ConfigurationPropertiesBinderFactory
			implements FactoryBean<ConfigurationPropertiesBinder>, ApplicationContextAware {
		private ConfigurationPropertiesBinder binder;
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
			this.binder = (this.binder != null) ? this.binder : new ConfigurationPropertiesBinder(applicationContext);
		}
		@Override
		public Class<?> getObjectType() {
			return ConfigurationPropertiesBinder.class;
		}
		@Override
		public ConfigurationPropertiesBinder getObject() throws Exception {
			Assert.state(this.binder != null, 'Binder was not created due to missing setApplicationContext call');
			return this.binder;
		}
	}
	/**
	 * A {@code Validator} for a constructor-bound {@code Bindable} where the type being
	 * bound is itself a {@code Validator} implementation.
	 */
	static class SelfValidatingConstructorBoundBindableValidator implements Validator {
		private final Class<?> type;
		SelfValidatingConstructorBoundBindableValidator(Class<?> type) {
			this.type = type;
		}
		@Override
		public boolean supports(Class<?> candidate) {
			return candidate.isAssignableFrom(this.type);
		}
		@Override
		public void validate(Object target, Errors errors) {
			((Validator) target).validate(target, errors);
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
@Qualifier(ConfigurationPropertiesBinding.VALUE)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ConfigurationPropertiesBinding {
	/**
	 * Concrete value for the {@link Qualifier @Qualifier}.
	 */
	String VALUE = 'org.springframework.boot.context.properties.ConfigurationPropertiesBinding';
}
/*
package org.springframework.boot.context.properties;
/**
class EnableConfigurationPropertiesRegistrar implements ImportBeanDefinitionRegistrar {
	private static final String METHOD_VALIDATION_EXCLUDE_FILTER_BEAN_NAME = Conventions
		.getQualifiedAttributeName(EnableConfigurationPropertiesRegistrar.class, 'methodValidationExcludeFilter');
	@Override
	public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
		registerInfrastructureBeans(registry);
		registerMethodValidationExcludeFilter(registry);
		ConfigurationPropertiesBeanRegistrar beanRegistrar = new ConfigurationPropertiesBeanRegistrar(registry);
		getTypes(metadata).forEach(beanRegistrar::register);
	}
	private Set<Class<?>> getTypes(AnnotationMetadata metadata) {
		return metadata.getAnnotations()
			.stream(EnableConfigurationProperties.class)
			.flatMap((annotation) -> Arrays.stream(annotation.getClassArray(MergedAnnotation.VALUE)))
			.filter((type) -> void.class != type)
			.collect(Collectors.toSet());
	}
	static void registerInfrastructureBeans(BeanDefinitionRegistry registry) {
		ConfigurationPropertiesBindingPostProcessor.register(registry);
		BoundConfigurationProperties.register(registry);
	}
	static void registerMethodValidationExcludeFilter(BeanDefinitionRegistry registry) {
		if (!registry.containsBeanDefinition(METHOD_VALIDATION_EXCLUDE_FILTER_BEAN_NAME)) {
			BeanDefinition definition = BeanDefinitionBuilder
				.rootBeanDefinition(MethodValidationExcludeFilter.class, 'byAnnotation')
				.addConstructorArgValue(ConfigurationProperties.class)
				.setRole(BeanDefinition.ROLE_INFRASTRUCTURE)
				.getBeanDefinition();
			registry.registerBeanDefinition(METHOD_VALIDATION_EXCLUDE_FILTER_BEAN_NAME, definition);
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
public class ConfigurationPropertiesBindException extends BeanCreationException {
	private final ConfigurationPropertiesBean bean;
	ConfigurationPropertiesBindException(ConfigurationPropertiesBean bean, Exception cause) {
		super(bean.getName(), getMessage(bean), cause);
		this.bean = bean;
	}
	/**
	 * Return the bean type that was being bound.
	 * @return the bean type
	 */
	public Class<?> getBeanType() {
		return this.bean.getType();
	}
	/**
	 * Return the configuration properties annotation that triggered the binding.
	 * @return the configuration properties annotation
	 */
	public ConfigurationProperties getAnnotation() {
		return this.bean.getAnnotation();
	}
	private static String getMessage(ConfigurationPropertiesBean bean) {
		ConfigurationProperties annotation = bean.getAnnotation();
		StringBuilder message = new StringBuilder();
		message.append('Could not bind properties to "');
		message.append(ClassUtils.getShortName(bean.getType())).append('" : ');
		message.append('prefix=').append(annotation.prefix());
		message.append(', ignoreInvalidFields=').append(annotation.ignoreInvalidFields());
		message.append(', ignoreUnknownFields=').append(annotation.ignoreUnknownFields());
		return message.toString();
	}
}
/*
package org.springframework.boot.context.properties;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(EnableConfigurationPropertiesRegistrar.class)
public @interface EnableConfigurationProperties {
	/**
	 * The bean name of the configuration properties validator.
	 * @since 2.2.0
	 */
	String VALIDATOR_BEAN_NAME = 'configurationPropertiesValidator';
	/**
	 * Convenient way to quickly register
	 * {@link ConfigurationProperties @ConfigurationProperties} annotated beans with
	 * Spring. Standard Spring Beans will also be scanned regardless of this value.
	 * @return {@code @ConfigurationProperties} annotated beans to register
	 */
	Class<?>[] value() default {};
}
/*
package org.springframework.boot.context.properties;
/**
final class ConfigurationPropertiesCharSequenceToObjectConverter implements ConditionalGenericConverter {
	private static final TypeDescriptor STRING = TypeDescriptor.valueOf(String.class);
	private static final TypeDescriptor BYTE_ARRAY = TypeDescriptor.valueOf(byte[].class);
	private static final Set<ConvertiblePair> TYPES;
	private final ThreadLocal<Boolean> disable = new ThreadLocal<>();
	static {
		TYPES = Collections.singleton(new ConvertiblePair(CharSequence.class, Object.class));
	}
	private final ConversionService conversionService;
	ConfigurationPropertiesCharSequenceToObjectConverter(ConversionService conversionService) {
		this.conversionService = conversionService;
	}
	@Override
	public Set<ConvertiblePair> getConvertibleTypes() {
		return TYPES;
	}
	@Override
	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (sourceType.getType() == String.class || this.disable.get() == Boolean.TRUE) {
			return false;
		}
		this.disable.set(Boolean.TRUE);
		try {
			boolean canDirectlyConvertCharSequence = this.conversionService.canConvert(sourceType, targetType);
			if (canDirectlyConvertCharSequence && !isStringConversionBetter(sourceType, targetType)) {
				return false;
			}
			return this.conversionService.canConvert(STRING, targetType);
		}
		finally {
			this.disable.remove();
		}
	}
	/**
	 * Return if String based conversion is better based on the target type. This is
	 * required when ObjectTo... conversion produces incorrect results.
	 * @param sourceType the source type to test
	 * @param targetType the target type to test
	 * @return if string conversion is better
	 */
	private boolean isStringConversionBetter(TypeDescriptor sourceType, TypeDescriptor targetType) {
		if (this.conversionService instanceof ApplicationConversionService applicationConversionService) {
			if (applicationConversionService.isConvertViaObjectSourceType(sourceType, targetType)) {
				// If an ObjectTo... converter is being used then there might be a
				// better StringTo... version
				return true;
			}
		}
		// StringToArrayConverter / StringToCollectionConverter are better than
		// ObjectToArrayConverter / ObjectToCollectionConverter
		return (targetType.isArray() || targetType.isCollection()) && !targetType.equals(BYTE_ARRAY);
	}
	@Override
	public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		return this.conversionService.convert(source.toString(), STRING, targetType);
	}
}
/*
package org.springframework.boot.context.properties;
/**
final class BindMethodAttribute {
	static final String NAME = BindMethod.class.getName();
	private BindMethodAttribute() {
	}
	static BindMethod get(ApplicationContext applicationContext, String beanName) {
		return (applicationContext instanceof ConfigurableApplicationContext configurableApplicationContext)
				? get(configurableApplicationContext.getBeanFactory(), beanName) : null;
	}
	static BindMethod get(ConfigurableListableBeanFactory beanFactory, String beanName) {
		return (!beanFactory.containsBeanDefinition(beanName)) ? null : get(beanFactory.getBeanDefinition(beanName));
	}
	static BindMethod get(BeanDefinitionRegistry beanDefinitionRegistry, String beanName) {
		return (!beanDefinitionRegistry.containsBeanDefinition(beanName)) ? null
				: get(beanDefinitionRegistry.getBeanDefinition(beanName));
	}
	static BindMethod get(AttributeAccessor attributes) {
		return (BindMethod) attributes.getAttribute(NAME);
	}
	static void set(AttributeAccessor attributes, BindMethod bindMethod) {
		attributes.setAttribute(NAME, bindMethod);
	}
}
/*
package org.springframework.boot.context.properties;
/**
public final class ConfigurationPropertiesBean {
	private static final org.springframework.boot.context.properties.bind.BindMethod JAVA_BEAN_BIND_METHOD = //
			org.springframework.boot.context.properties.bind.BindMethod.JAVA_BEAN;
	private static final org.springframework.boot.context.properties.bind.BindMethod VALUE_OBJECT_BIND_METHOD = //
			org.springframework.boot.context.properties.bind.BindMethod.VALUE_OBJECT;
	private final String name;
	private final Object instance;
	private final Bindable<?> bindTarget;
	private ConfigurationPropertiesBean(String name, Object instance, Bindable<?> bindTarget) {
		this.name = name;
		this.instance = instance;
		this.bindTarget = bindTarget;
	}
	/**
	 * Return the name of the Spring bean.
	 * @return the bean name
	 */
	public String getName() {
		return this.name;
	}
	/**
	 * Return the actual Spring bean instance.
	 * @return the bean instance
	 */
	public Object getInstance() {
		return this.instance;
	}
	/**
	 * Return the bean type.
	 * @return the bean type
	 */
	Class<?> getType() {
		return this.bindTarget.getType().resolve();
	}
	/**
	 * Return the {@link ConfigurationProperties} annotation for the bean. The annotation
	 * may be defined on the bean itself or from the factory method that create the bean
	 * (usually a {@link Bean @Bean} method).
	 * @return the configuration properties annotation
	 */
	public ConfigurationProperties getAnnotation() {
		return this.bindTarget.getAnnotation(ConfigurationProperties.class);
	}
	/**
	 * Return a {@link Bindable} instance suitable that can be used as a target for the
	 * {@link Binder}.
	 * @return a bind target for use with the {@link Binder}
	 */
	public Bindable<?> asBindTarget() {
		return this.bindTarget;
	}
	/**
	 * Return all {@link ConfigurationProperties @ConfigurationProperties} beans contained
	 * in the given application context. Both directly annotated beans, as well as beans
	 * that have {@link ConfigurationProperties @ConfigurationProperties} annotated
	 * factory methods are included.
	 * @param applicationContext the source application context
	 * @return a map of all configuration properties beans keyed by the bean name
	 */
	public static Map<String, ConfigurationPropertiesBean> getAll(ApplicationContext applicationContext) {
		Assert.notNull(applicationContext, 'ApplicationContext must not be null');
		if (applicationContext instanceof ConfigurableApplicationContext configurableContext) {
			return getAll(configurableContext);
		}
		Map<String, ConfigurationPropertiesBean> propertiesBeans = new LinkedHashMap<>();
		applicationContext.getBeansWithAnnotation(ConfigurationProperties.class).forEach((name, instance) -> {
			ConfigurationPropertiesBean propertiesBean = get(applicationContext, instance, name);
			if (propertiesBean != null) {
				propertiesBeans.put(name, propertiesBean);
			}
		});
		return propertiesBeans;
	}
	private static Map<String, ConfigurationPropertiesBean> getAll(ConfigurableApplicationContext applicationContext) {
		Map<String, ConfigurationPropertiesBean> propertiesBeans = new LinkedHashMap<>();
		ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();
		Iterator<String> beanNames = beanFactory.getBeanNamesIterator();
		while (beanNames.hasNext()) {
			String beanName = beanNames.next();
			if (isConfigurationPropertiesBean(beanFactory, beanName)) {
				try {
					Object bean = beanFactory.getBean(beanName);
					ConfigurationPropertiesBean propertiesBean = get(applicationContext, bean, beanName);
					if (propertiesBean != null) {
						propertiesBeans.put(beanName, propertiesBean);
					}
				}
				catch (Exception ex) {
					// Ignore
				}
			}
		}
		return propertiesBeans;
	}
	private static boolean isConfigurationPropertiesBean(ConfigurableListableBeanFactory beanFactory, String beanName) {
		try {
			if (beanFactory.getBeanDefinition(beanName).isAbstract()) {
				return false;
			}
			if (beanFactory.findAnnotationOnBean(beanName, ConfigurationProperties.class) != null) {
				return true;
			}
			Method factoryMethod = findFactoryMethod(beanFactory, beanName);
			return findMergedAnnotation(factoryMethod, ConfigurationProperties.class).isPresent();
		}
		catch (NoSuchBeanDefinitionException ex) {
			return false;
		}
	}
	/**
	 * Return a {@link ConfigurationPropertiesBean @ConfigurationPropertiesBean} instance
	 * for the given bean details or {@code null} if the bean is not a
	 * {@link ConfigurationProperties @ConfigurationProperties} object. Annotations are
	 * considered both on the bean itself, as well as any factory method (for example a
	 * {@link Bean @Bean} method).
	 * @param applicationContext the source application context
	 * @param bean the bean to consider
	 * @param beanName the bean name
	 * @return a configuration properties bean or {@code null} if the neither the bean nor
	 * factory method are annotated with
	 * {@link ConfigurationProperties @ConfigurationProperties}
	 */
	public static ConfigurationPropertiesBean get(ApplicationContext applicationContext, Object bean, String beanName) {
		Method factoryMethod = findFactoryMethod(applicationContext, beanName);
		Bindable<Object> bindTarget = createBindTarget(bean, bean.getClass(), factoryMethod);
		if (bindTarget == null) {
			return null;
		}
		bindTarget = bindTarget.withBindMethod(BindMethodAttribute.get(applicationContext, beanName));
		if (bindTarget.getBindMethod() == null && factoryMethod != null) {
			bindTarget = bindTarget.withBindMethod(JAVA_BEAN_BIND_METHOD);
		}
		if (bindTarget.getBindMethod() != VALUE_OBJECT_BIND_METHOD) {
			bindTarget = bindTarget.withExistingValue(bean);
		}
		return create(beanName, bean, bindTarget);
	}
	private static Method findFactoryMethod(ApplicationContext applicationContext, String beanName) {
		if (applicationContext instanceof ConfigurableApplicationContext configurableContext) {
			return findFactoryMethod(configurableContext, beanName);
		}
		return null;
	}
	private static Method findFactoryMethod(ConfigurableApplicationContext applicationContext, String beanName) {
		return findFactoryMethod(applicationContext.getBeanFactory(), beanName);
	}
	private static Method findFactoryMethod(ConfigurableListableBeanFactory beanFactory, String beanName) {
		if (beanFactory.containsBeanDefinition(beanName)) {
			BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName);
			if (beanDefinition instanceof RootBeanDefinition rootBeanDefinition) {
				return rootBeanDefinition.getResolvedFactoryMethod();
			}
		}
		return null;
	}
	static ConfigurationPropertiesBean forValueObject(Class<?> beanType, String beanName) {
		Bindable<Object> bindTarget = createBindTarget(null, beanType, null);
		Assert.state(bindTarget != null && deduceBindMethod(bindTarget) == VALUE_OBJECT_BIND_METHOD,
				() -> 'Bean "' + beanName + '" is not a @ConfigurationProperties value object');
		return create(beanName, null, bindTarget.withBindMethod(VALUE_OBJECT_BIND_METHOD));
	}
	private static Bindable<Object> createBindTarget(Object bean, Class<?> beanType, Method factoryMethod) {
		ResolvableType type = (factoryMethod != null) ? ResolvableType.forMethodReturnType(factoryMethod)
				: ResolvableType.forClass(beanType);
		Annotation[] annotations = findAnnotations(bean, beanType, factoryMethod);
		return (annotations != null) ? Bindable.of(type).withAnnotations(annotations) : null;
	}
	private static Annotation[] findAnnotations(Object instance, Class<?> type, Method factory) {
		ConfigurationProperties annotation = findAnnotation(instance, type, factory, ConfigurationProperties.class);
		if (annotation == null) {
			return null;
		}
		Validated validated = findAnnotation(instance, type, factory, Validated.class);
		return (validated != null) ? new Annotation[] { annotation, validated } : new Annotation[] { annotation };
	}
	private static <A extends Annotation> A findAnnotation(Object instance, Class<?> type, Method factory,
			Class<A> annotationType) {
		MergedAnnotation<A> annotation = MergedAnnotation.missing();
		if (factory != null) {
			annotation = findMergedAnnotation(factory, annotationType);
		}
		if (!annotation.isPresent()) {
			annotation = findMergedAnnotation(type, annotationType);
		}
		if (!annotation.isPresent() && AopUtils.isAopProxy(instance)) {
			annotation = MergedAnnotations.from(AopUtils.getTargetClass(instance), SearchStrategy.TYPE_HIERARCHY)
				.get(annotationType);
		}
		return annotation.isPresent() ? annotation.synthesize() : null;
	}
	private static <A extends Annotation> MergedAnnotation<A> findMergedAnnotation(AnnotatedElement element,
			Class<A> annotationType) {
		return (element != null) ? MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY).get(annotationType)
				: MergedAnnotation.missing();
	}
	private static ConfigurationPropertiesBean create(String name, Object instance, Bindable<Object> bindTarget) {
		return (bindTarget != null) ? new ConfigurationPropertiesBean(name, instance, bindTarget) : null;
	}
	/**
	 * Deduce the {@code BindMethod} that should be used for the given type.
	 * @param type the source type
	 * @return the bind method to use
	 */
	static org.springframework.boot.context.properties.bind.BindMethod deduceBindMethod(Class<?> type) {
		return deduceBindMethod(BindConstructorProvider.DEFAULT.getBindConstructor(type, false));
	}
	/**
	 * Deduce the {@code BindMethod} that should be used for the given {@link Bindable}.
	 * @param bindable the source bindable
	 * @return the bind method to use
	 */
	static org.springframework.boot.context.properties.bind.BindMethod deduceBindMethod(Bindable<Object> bindable) {
		return deduceBindMethod(BindConstructorProvider.DEFAULT.getBindConstructor(bindable, false));
	}
	private static org.springframework.boot.context.properties.bind.BindMethod deduceBindMethod(
			Constructor<?> bindConstructor) {
		return (bindConstructor != null) ? VALUE_OBJECT_BIND_METHOD : JAVA_BEAN_BIND_METHOD;
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBeanFactoryInitializationAotProcessor implements BeanFactoryInitializationAotProcessor {
	@Override
	public ConfigurationPropertiesReflectionHintsContribution processAheadOfTime(
			ConfigurableListableBeanFactory beanFactory) {
		String[] beanNames = beanFactory.getBeanNamesForAnnotation(ConfigurationProperties.class);
		List<Bindable<?>> bindables = new ArrayList<>();
		for (String beanName : beanNames) {
			Class<?> beanType = beanFactory.getType(beanName, false);
			if (beanType != null) {
				BindMethod bindMethod = beanFactory.containsBeanDefinition(beanName)
						? (BindMethod) beanFactory.getBeanDefinition(beanName).getAttribute(BindMethod.class.getName())
						: null;
				bindables.add(Bindable.of(ClassUtils.getUserClass(beanType))
					.withBindMethod((bindMethod != null) ? bindMethod : BindMethod.JAVA_BEAN));
			}
		}
		return (!bindables.isEmpty()) ? new ConfigurationPropertiesReflectionHintsContribution(bindables) : null;
	}
	static final class ConfigurationPropertiesReflectionHintsContribution
			implements BeanFactoryInitializationAotContribution {
		private final List<Bindable<?>> bindables;
		private ConfigurationPropertiesReflectionHintsContribution(List<Bindable<?>> bindables) {
			this.bindables = bindables;
		}
		@Override
		public void applyTo(GenerationContext generationContext,
				BeanFactoryInitializationCode beanFactoryInitializationCode) {
			BindableRuntimeHintsRegistrar.forBindables(this.bindables)
				.registerHints(generationContext.getRuntimeHints());
		}
		Iterable<Bindable<?>> getBindables() {
			return this.bindables;
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
public class ConfigurationPropertiesBindingPostProcessor
		implements BeanPostProcessor, PriorityOrdered, ApplicationContextAware, InitializingBean {
	/**
	 * The bean name that this post-processor is registered with.
	 */
	public static final String BEAN_NAME = ConfigurationPropertiesBindingPostProcessor.class.getName();
	private ApplicationContext applicationContext;
	private BeanDefinitionRegistry registry;
	private ConfigurationPropertiesBinder binder;
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		// We can"t use constructor injection of the application context because
		// it causes eager factory bean initialization
		this.registry = (BeanDefinitionRegistry) this.applicationContext.getAutowireCapableBeanFactory();
		this.binder = ConfigurationPropertiesBinder.get(this.applicationContext);
	}
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE + 1;
	}
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (!hasBoundValueObject(beanName)) {
			bind(ConfigurationPropertiesBean.get(this.applicationContext, bean, beanName));
		}
		return bean;
	}
	private boolean hasBoundValueObject(String beanName) {
		return BindMethod.VALUE_OBJECT.equals(BindMethodAttribute.get(this.registry, beanName));
	}
	private void bind(ConfigurationPropertiesBean bean) {
		if (bean == null) {
			return;
		}
		Assert.state(bean.asBindTarget().getBindMethod() != BindMethod.VALUE_OBJECT,
				'Cannot bind @ConfigurationProperties for bean "' + bean.getName()
						+ '". Ensure that @ConstructorBinding has not been applied to regular bean');
		try {
			this.binder.bind(bean);
		}
		catch (Exception ex) {
			throw new ConfigurationPropertiesBindException(bean, ex);
		}
	}
	/**
	 * Register a {@link ConfigurationPropertiesBindingPostProcessor} bean if one is not
	 * already registered.
	 * @param registry the bean definition registry
	 * @since 2.2.0
	 */
	public static void register(BeanDefinitionRegistry registry) {
		Assert.notNull(registry, 'Registry must not be null');
		if (!registry.containsBeanDefinition(BEAN_NAME)) {
			BeanDefinition definition = BeanDefinitionBuilder
				.rootBeanDefinition(ConfigurationPropertiesBindingPostProcessor.class)
				.getBeanDefinition();
			definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
			registry.registerBeanDefinition(BEAN_NAME, definition);
		}
		ConfigurationPropertiesBinder.register(registry);
	}
}
/*
package org.springframework.boot.context.properties;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface ConfigurationProperties {
	/**
	 * The prefix of the properties that are valid to bind to this object. Synonym for
	 * {@link #prefix()}. A valid prefix is defined by one or more words separated with
	 * dots (e.g. {@code 'acme.system.feature'}).
	 * @return the prefix of the properties to bind
	 */
	@AliasFor('prefix')
	String value() default '';
	/**
	 * The prefix of the properties that are valid to bind to this object. Synonym for
	 * {@link #value()}. A valid prefix is defined by one or more words separated with
	 * dots (e.g. {@code 'acme.system.feature'}).
	 * @return the prefix of the properties to bind
	 */
	@AliasFor('value')
	String prefix() default '';
	/**
	 * Flag to indicate that when binding to this object invalid fields should be ignored.
	 * Invalid means invalid according to the binder that is used, and usually this means
	 * fields of the wrong type (or that cannot be coerced into the correct type).
	 * @return the flag value (default false)
	 */
	boolean ignoreInvalidFields() default false;
	/**
	 * Flag to indicate that when binding to this object unknown fields should be ignored.
	 * An unknown field could be a sign of a mistake in the Properties.
	 * @return the flag value (default true)
	 */
	boolean ignoreUnknownFields() default true;
}
/*
package org.springframework.boot.context.properties;
/**
public class BoundConfigurationProperties {
	private final Map<ConfigurationPropertyName, ConfigurationProperty> properties = new LinkedHashMap<>();
	/**
	 * The bean name that this class is registered with.
	 */
	private static final String BEAN_NAME = BoundConfigurationProperties.class.getName();
	void add(ConfigurationProperty configurationProperty) {
		this.properties.put(configurationProperty.getName(), configurationProperty);
	}
	/**
	 * Get the configuration property bound to the given name.
	 * @param name the property name
	 * @return the bound property or {@code null}
	 */
	public ConfigurationProperty get(ConfigurationPropertyName name) {
		return this.properties.get(name);
	}
	/**
	 * Get all bound properties.
	 * @return a map of all bound properties
	 */
	public Map<ConfigurationPropertyName, ConfigurationProperty> getAll() {
		return Collections.unmodifiableMap(this.properties);
	}
	/**
	 * Return the {@link BoundConfigurationProperties} from the given
	 * {@link ApplicationContext} if it is available.
	 * @param context the context to search
	 * @return a {@link BoundConfigurationProperties} or {@code null}
	 */
	public static BoundConfigurationProperties get(ApplicationContext context) {
		return (!context.containsBeanDefinition(BEAN_NAME)) ? null
				: context.getBean(BEAN_NAME, BoundConfigurationProperties.class);
	}
	static void register(BeanDefinitionRegistry registry) {
		Assert.notNull(registry, 'Registry must not be null');
		if (!registry.containsBeanDefinition(BEAN_NAME)) {
			BeanDefinition definition = BeanDefinitionBuilder.rootBeanDefinition(BoundConfigurationProperties.class)
				.setRole(BeanDefinition.ROLE_INFRASTRUCTURE)
				.getBeanDefinition();
			registry.registerBeanDefinition(BEAN_NAME, definition);
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
final class ConfigurationPropertiesJsr303Validator implements Validator {
	private static final String[] VALIDATOR_CLASSES = { 'jakarta.validation.Validator',
			'jakarta.validation.ValidatorFactory', 'jakarta.validation.bootstrap.GenericBootstrap' };
	private final Delegate delegate;
	private final Class<?> validatedType;
	ConfigurationPropertiesJsr303Validator(ApplicationContext applicationContext, Class<?> validatedType) {
		this.delegate = new Delegate(applicationContext);
		this.validatedType = validatedType;
	}
	@Override
	public boolean supports(Class<?> type) {
		return this.validatedType.equals(type) && this.delegate.supports(type);
	}
	@Override
	public void validate(Object target, Errors errors) {
		this.delegate.validate(target, errors);
	}
	static boolean isJsr303Present(ApplicationContext applicationContext) {
		ClassLoader classLoader = applicationContext.getClassLoader();
		for (String validatorClass : VALIDATOR_CLASSES) {
			if (!ClassUtils.isPresent(validatorClass, classLoader)) {
				return false;
			}
		}
		return true;
	}
	private static class Delegate extends LocalValidatorFactoryBean {
		Delegate(ApplicationContext applicationContext) {
			setApplicationContext(applicationContext);
			setMessageInterpolator(new MessageInterpolatorFactory(applicationContext).getObject());
			afterPropertiesSet();
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
@FunctionalInterface
public interface ConfigurationPropertiesBindHandlerAdvisor {
	/**
	 * Apply additional functionality to the source bind handler.
	 * @param bindHandler the source bind handler
	 * @return a replacement bind handler that delegates to the source and provides
	 * additional functionality
	 */
	BindHandler apply(BindHandler bindHandler);
}
/*
package org.springframework.boot.context.properties.bind;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Documented
public @interface Name {
	/**
	 * The name of the property to use for binding.
	 * @return the property name
	 */
	String value();
}
/*
package org.springframework.boot.context.properties.bind;
/**
interface DataObjectBinder {
	/**
	 * Return a bound instance or {@code null} if the {@link DataObjectBinder} does not
	 * support the specified {@link Bindable}.
	 * @param <T> the source type
	 * @param name the name being bound
	 * @param target the bindable to bind
	 * @param context the bind context
	 * @param propertyBinder property binder
	 * @return a bound instance or {@code null}
	 */
	<T> T bind(ConfigurationPropertyName name, Bindable<T> target, Context context,
			DataObjectPropertyBinder propertyBinder);
	/**
	 * Return a newly created instance or {@code null} if the {@link DataObjectBinder}
	 * does not support the specified {@link Bindable}.
	 * @param <T> the source type
	 * @param target the bindable to create
	 * @param context the bind context
	 * @return the created instance
	 */
	<T> T create(Bindable<T> target, Context context);
	/**
	 * Callback that can be used to add additional suppressed exceptions when an instance
	 * cannot be created.
	 * @param <T> the source type
	 * @param target the bindable that was being created
	 * @param context the bind context
	 * @param exception the exception about to be thrown
	 */
	default <T> void onUnableToCreateInstance(Bindable<T> target, Context context, RuntimeException exception) {
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
abstract class IndexedElementsBinder<T> extends AggregateBinder<T> {
	private static final String INDEX_ZERO = '[0]';
	IndexedElementsBinder(Context context) {
		super(context);
	}
	@Override
	protected boolean isAllowRecursiveBinding(ConfigurationPropertySource source) {
		return source == null || source instanceof IterableConfigurationPropertySource;
	}
	/**
	 * Bind indexed elements to the supplied collection.
	 * @param name the name of the property to bind
	 * @param target the target bindable
	 * @param elementBinder the binder to use for elements
	 * @param aggregateType the aggregate type, may be a collection or an array
	 * @param elementType the element type
	 * @param result the destination for results
	 */
	protected final void bindIndexed(ConfigurationPropertyName name, Bindable<?> target,
			AggregateElementBinder elementBinder, ResolvableType aggregateType, ResolvableType elementType,
			IndexedCollectionSupplier result) {
		for (ConfigurationPropertySource source : getContext().getSources()) {
			bindIndexed(source, name, target, elementBinder, result, aggregateType, elementType);
			if (result.wasSupplied() && result.get() != null) {
				return;
			}
		}
	}
	private void bindIndexed(ConfigurationPropertySource source, ConfigurationPropertyName root, Bindable<?> target,
			AggregateElementBinder elementBinder, IndexedCollectionSupplier collection, ResolvableType aggregateType,
			ResolvableType elementType) {
		ConfigurationProperty property = source.getConfigurationProperty(root);
		if (property != null) {
			getContext().setConfigurationProperty(property);
			bindValue(target, collection.get(), aggregateType, elementType, property.getValue());
		}
		else {
			bindIndexed(source, root, elementBinder, collection, elementType);
		}
	}
	private void bindValue(Bindable<?> target, Collection<Object> collection, ResolvableType aggregateType,
			ResolvableType elementType, Object value) {
		if (value == null || (value instanceof CharSequence charSequence && charSequence.isEmpty())) {
			return;
		}
		Object aggregate = convert(value, aggregateType, target.getAnnotations());
		ResolvableType collectionType = ResolvableType.forClassWithGenerics(collection.getClass(), elementType);
		Collection<Object> elements = convert(aggregate, collectionType);
		collection.addAll(elements);
	}
	private void bindIndexed(ConfigurationPropertySource source, ConfigurationPropertyName root,
			AggregateElementBinder elementBinder, IndexedCollectionSupplier collection, ResolvableType elementType) {
		MultiValueMap<String, ConfigurationPropertyName> knownIndexedChildren = getKnownIndexedChildren(source, root);
		for (int i = 0; i < Integer.MAX_VALUE; i++) {
			ConfigurationPropertyName name = root.append((i != 0) ? '[' + i + ']' : INDEX_ZERO);
			Object value = elementBinder.bind(name, Bindable.of(elementType), source);
			if (value == null) {
				break;
			}
			knownIndexedChildren.remove(name.getLastElement(Form.UNIFORM));
			collection.get().add(value);
		}
		assertNoUnboundChildren(source, knownIndexedChildren);
	}
	private MultiValueMap<String, ConfigurationPropertyName> getKnownIndexedChildren(ConfigurationPropertySource source,
			ConfigurationPropertyName root) {
		MultiValueMap<String, ConfigurationPropertyName> children = new LinkedMultiValueMap<>();
		if (!(source instanceof IterableConfigurationPropertySource iterableSource)) {
			return children;
		}
		for (ConfigurationPropertyName name : iterableSource.filter(root::isAncestorOf)) {
			ConfigurationPropertyName choppedName = name.chop(root.getNumberOfElements() + 1);
			if (choppedName.isLastElementIndexed()) {
				String key = choppedName.getLastElement(Form.UNIFORM);
				children.add(key, name);
			}
		}
		return children;
	}
	private void assertNoUnboundChildren(ConfigurationPropertySource source,
			MultiValueMap<String, ConfigurationPropertyName> children) {
		if (!children.isEmpty()) {
			throw new UnboundConfigurationPropertiesException(children.values()
				.stream()
				.flatMap(List::stream)
				.map(source::getConfigurationProperty)
				.collect(Collectors.toCollection(TreeSet::new)));
		}
	}
	private <C> C convert(Object value, ResolvableType type, Annotation... annotations) {
		value = getContext().getPlaceholdersResolver().resolvePlaceholders(value);
		return getContext().getConverter().convert(value, type, annotations);
	}
	/**
	 * {@link AggregateBinder.AggregateSupplier AggregateSupplier} for an indexed
	 * collection.
	 */
	protected static class IndexedCollectionSupplier extends AggregateSupplier<Collection<Object>> {
		public IndexedCollectionSupplier(Supplier<Collection<Object>> supplier) {
			super(supplier);
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
@FunctionalInterface
public interface BindConstructorProvider {
	/**
	 * Default {@link BindConstructorProvider} implementation that only returns a value
	 * when there"s a single constructor and when the bindable has no existing value.
	 */
	BindConstructorProvider DEFAULT = new DefaultBindConstructorProvider();
	/**
	 * Return the bind constructor to use for the given type, or {@code null} if
	 * constructor binding is not supported.
	 * @param type the type to check
	 * @param isNestedConstructorBinding if this binding is nested within a constructor
	 * binding
	 * @return the bind constructor or {@code null}
	 * @since 3.0.0
	 */
	default Constructor<?> getBindConstructor(Class<?> type, boolean isNestedConstructorBinding) {
		return getBindConstructor(Bindable.of(type), isNestedConstructorBinding);
	}
	/**
	 * Return the bind constructor to use for the given bindable, or {@code null} if
	 * constructor binding is not supported.
	 * @param bindable the bindable to check
	 * @param isNestedConstructorBinding if this binding is nested within a constructor
	 * binding
	 * @return the bind constructor or {@code null}
	 */
	Constructor<?> getBindConstructor(Bindable<?> bindable, boolean isNestedConstructorBinding);
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
public class ValidationErrors implements Iterable<ObjectError> {
	private final ConfigurationPropertyName name;
	private final Set<ConfigurationProperty> boundProperties;
	private final List<ObjectError> errors;
	ValidationErrors(ConfigurationPropertyName name, Set<ConfigurationProperty> boundProperties,
			List<ObjectError> errors) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(boundProperties, 'BoundProperties must not be null');
		Assert.notNull(errors, 'Errors must not be null');
		this.name = name;
		this.boundProperties = Collections.unmodifiableSet(boundProperties);
		this.errors = convertErrors(name, boundProperties, errors);
	}
	private List<ObjectError> convertErrors(ConfigurationPropertyName name, Set<ConfigurationProperty> boundProperties,
			List<ObjectError> errors) {
		List<ObjectError> converted = new ArrayList<>(errors.size());
		for (ObjectError error : errors) {
			converted.add(convertError(name, boundProperties, error));
		}
		return Collections.unmodifiableList(converted);
	}
	private ObjectError convertError(ConfigurationPropertyName name, Set<ConfigurationProperty> boundProperties,
			ObjectError error) {
		if (error instanceof FieldError fieldError) {
			return convertFieldError(name, boundProperties, fieldError);
		}
		return error;
	}
	private FieldError convertFieldError(ConfigurationPropertyName name, Set<ConfigurationProperty> boundProperties,
			FieldError error) {
		if (error instanceof OriginProvider) {
			return error;
		}
		return OriginTrackedFieldError.of(error, findFieldErrorOrigin(name, boundProperties, error));
	}
	private Origin findFieldErrorOrigin(ConfigurationPropertyName name, Set<ConfigurationProperty> boundProperties,
			FieldError error) {
		for (ConfigurationProperty boundProperty : boundProperties) {
			if (isForError(name, boundProperty.getName(), error)) {
				return Origin.from(boundProperty);
			}
		}
		return null;
	}
	private boolean isForError(ConfigurationPropertyName name, ConfigurationPropertyName boundPropertyName,
			FieldError error) {
		return name.isParentOf(boundPropertyName)
				&& boundPropertyName.getLastElement(Form.UNIFORM).equalsIgnoreCase(error.getField());
	}
	/**
	 * Return the name of the item that was being validated.
	 * @return the name of the item
	 */
	public ConfigurationPropertyName getName() {
		return this.name;
	}
	/**
	 * Return the properties that were bound before validation failed.
	 * @return the boundProperties
	 */
	public Set<ConfigurationProperty> getBoundProperties() {
		return this.boundProperties;
	}
	public boolean hasErrors() {
		return !this.errors.isEmpty();
	}
	/**
	 * Return the list of all validation errors.
	 * @return the errors
	 */
	public List<ObjectError> getAllErrors() {
		return this.errors;
	}
	@Override
	public Iterator<ObjectError> iterator() {
		return this.errors.iterator();
	}
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
public class BindValidationException extends RuntimeException {
	private final ValidationErrors validationErrors;
	BindValidationException(ValidationErrors validationErrors) {
		super(getMessage(validationErrors));
		Assert.notNull(validationErrors, 'ValidationErrors must not be null');
		this.validationErrors = validationErrors;
	}
	/**
	 * Return the validation errors that caused the exception.
	 * @return the validationErrors the validation errors
	 */
	public ValidationErrors getValidationErrors() {
		return this.validationErrors;
	}
	private static String getMessage(ValidationErrors errors) {
		StringBuilder message = new StringBuilder('Binding validation errors');
		if (errors != null) {
			message.append(' on ').append(errors.getName());
			errors.getAllErrors().forEach((error) -> message.append(String.format('%n   - %s', error)));
		}
		return message.toString();
	}
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
public class ValidationBindHandler extends AbstractBindHandler {
	private final Validator[] validators;
	private final Map<ConfigurationPropertyName, ResolvableType> boundTypes = new LinkedHashMap<>();
	private final Map<ConfigurationPropertyName, Object> boundResults = new LinkedHashMap<>();
	private final Set<ConfigurationProperty> boundProperties = new LinkedHashSet<>();
	private BindValidationException exception;
	public ValidationBindHandler(Validator... validators) {
		this.validators = validators;
	}
	public ValidationBindHandler(BindHandler parent, Validator... validators) {
		super(parent);
		this.validators = validators;
	}
	@Override
	public <T> Bindable<T> onStart(ConfigurationPropertyName name, Bindable<T> target, BindContext context) {
		this.boundTypes.put(name, target.getType());
		return super.onStart(name, target, context);
	}
	@Override
	public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		this.boundResults.put(name, result);
		if (context.getConfigurationProperty() != null) {
			this.boundProperties.add(context.getConfigurationProperty());
		}
		return super.onSuccess(name, target, context, result);
	}
	@Override
	public Object onFailure(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Exception error)
			throws Exception {
		Object result = super.onFailure(name, target, context, error);
		if (result != null) {
			clear();
			this.boundResults.put(name, result);
		}
		validate(name, target, context, result);
		return result;
	}
	private void clear() {
		this.boundTypes.clear();
		this.boundResults.clear();
		this.boundProperties.clear();
		this.exception = null;
	}
	@Override
	public void onFinish(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result)
			throws Exception {
		validate(name, target, context, result);
		super.onFinish(name, target, context, result);
	}
	private void validate(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		if (this.exception == null) {
			Object validationTarget = getValidationTarget(target, context, result);
			Class<?> validationType = target.getBoxedType().resolve();
			if (validationTarget != null) {
				validateAndPush(name, validationTarget, validationType);
			}
		}
		if (context.getDepth() == 0 && this.exception != null) {
			throw this.exception;
		}
	}
	private Object getValidationTarget(Bindable<?> target, BindContext context, Object result) {
		if (result != null) {
			return result;
		}
		if (context.getDepth() == 0 && target.getValue() != null) {
			return target.getValue().get();
		}
		return null;
	}
	private void validateAndPush(ConfigurationPropertyName name, Object target, Class<?> type) {
		ValidationResult result = null;
		for (Validator validator : this.validators) {
			if (validator.supports(type)) {
				result = (result != null) ? result : new ValidationResult(name, target);
				validator.validate(target, result);
			}
		}
		if (result != null && result.hasErrors()) {
			this.exception = new BindValidationException(result.getValidationErrors());
		}
	}
	/**
	 * {@link AbstractBindingResult} implementation backed by the bound properties.
	 */
	private class ValidationResult extends BeanPropertyBindingResult {
		private final ConfigurationPropertyName name;
		protected ValidationResult(ConfigurationPropertyName name, Object target) {
			super(target, null);
			this.name = name;
		}
		@Override
		public String getObjectName() {
			return this.name.toString();
		}
		@Override
		public Class<?> getFieldType(String field) {
			ResolvableType type = getBoundField(ValidationBindHandler.this.boundTypes, field);
			Class<?> resolved = (type != null) ? type.resolve() : null;
			if (resolved != null) {
				return resolved;
			}
			return super.getFieldType(field);
		}
		@Override
		protected Object getActualFieldValue(String field) {
			Object boundField = getBoundField(ValidationBindHandler.this.boundResults, field);
			if (boundField != null) {
				return boundField;
			}
			try {
				return super.getActualFieldValue(field);
			}
			catch (Exception ex) {
				if (isPropertyNotReadable(ex)) {
					return null;
				}
				throw ex;
			}
		}
		private boolean isPropertyNotReadable(Throwable ex) {
			while (ex != null) {
				if (ex instanceof NotReadablePropertyException) {
					return true;
				}
				ex = ex.getCause();
			}
			return false;
		}
		private <T> T getBoundField(Map<ConfigurationPropertyName, T> boundFields, String field) {
			try {
				ConfigurationPropertyName name = getName(field);
				T bound = boundFields.get(name);
				if (bound != null) {
					return bound;
				}
				if (name.hasIndexedElement()) {
					for (Map.Entry<ConfigurationPropertyName, T> entry : boundFields.entrySet()) {
						if (isFieldNameMatch(entry.getKey(), name)) {
							return entry.getValue();
						}
					}
				}
			}
			catch (Exception ex) {
				// Ignore
			}
			return null;
		}
		private boolean isFieldNameMatch(ConfigurationPropertyName name, ConfigurationPropertyName fieldName) {
			if (name.getNumberOfElements() != fieldName.getNumberOfElements()) {
				return false;
			}
			for (int i = 0; i < name.getNumberOfElements(); i++) {
				String element = name.getElement(i, Form.ORIGINAL);
				String fieldElement = fieldName.getElement(i, Form.ORIGINAL);
				if (!ObjectUtils.nullSafeEquals(element, fieldElement)) {
					return false;
				}
			}
			return true;
		}
		private ConfigurationPropertyName getName(String field) {
			return this.name.append(DataObjectPropertyName.toDashedForm(field));
		}
		ValidationErrors getValidationErrors() {
			Set<ConfigurationProperty> boundProperties = ValidationBindHandler.this.boundProperties.stream()
				.filter((property) -> this.name.isAncestorOf(property.getName()))
				.collect(Collectors.toCollection(LinkedHashSet::new));
			return new ValidationErrors(this.name, boundProperties, getAllErrors());
		}
	}
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
final class OriginTrackedFieldError extends FieldError implements OriginProvider {
	private final Origin origin;
	private OriginTrackedFieldError(FieldError fieldError, Origin origin) {
		super(fieldError.getObjectName(), fieldError.getField(), fieldError.getRejectedValue(),
				fieldError.isBindingFailure(), fieldError.getCodes(), fieldError.getArguments(),
				fieldError.getDefaultMessage());
		this.origin = origin;
	}
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	@Override
	public String toString() {
		if (this.origin == null) {
			return super.toString();
		}
		return super.toString() + '; origin ' + this.origin;
	}
	static FieldError of(FieldError fieldError, Origin origin) {
		if (fieldError == null || origin == null) {
			return fieldError;
		}
		return new OriginTrackedFieldError(fieldError, origin);
	}
}
/*
/**
package org.springframework.boot.context.properties.bind.validation;
/*
package org.springframework.boot.context.properties.bind;
/**
public class UnboundConfigurationPropertiesException extends RuntimeException {
	private final Set<ConfigurationProperty> unboundProperties;
	public UnboundConfigurationPropertiesException(Set<ConfigurationProperty> unboundProperties) {
		super(buildMessage(unboundProperties));
		this.unboundProperties = Collections.unmodifiableSet(unboundProperties);
	}
	public Set<ConfigurationProperty> getUnboundProperties() {
		return this.unboundProperties;
	}
	private static String buildMessage(Set<ConfigurationProperty> unboundProperties) {
		StringBuilder builder = new StringBuilder();
		builder.append('The elements [');
		String message = unboundProperties.stream().map((p) -> p.getName().toString()).collect(Collectors.joining(','));
		builder.append(message).append('] were left unbound.');
		return builder.toString();
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public interface BindHandler {
	/**
	 * Default no-op bind handler.
	 */
	BindHandler DEFAULT = new BindHandler() {
	};
	/**
	 * Called when binding of an element starts but before any result has been determined.
	 * @param <T> the bindable source type
	 * @param name the name of the element being bound
	 * @param target the item being bound
	 * @param context the bind context
	 * @return the actual item that should be used for binding (may be {@code null})
	 */
	default <T> Bindable<T> onStart(ConfigurationPropertyName name, Bindable<T> target, BindContext context) {
		return target;
	}
	/**
	 * Called when binding of an element ends with a successful result. Implementations
	 * may change the ultimately returned result or perform addition validation.
	 * @param name the name of the element being bound
	 * @param target the item being bound
	 * @param context the bind context
	 * @param result the bound result (never {@code null})
	 * @return the actual result that should be used (may be {@code null})
	 */
	default Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		return result;
	}
	/**
	 * Called when binding of an element ends with an unbound result and a newly created
	 * instance is about to be returned. Implementations may change the ultimately
	 * returned result or perform addition validation.
	 * @param name the name of the element being bound
	 * @param target the item being bound
	 * @param context the bind context
	 * @param result the newly created instance (never {@code null})
	 * @return the actual result that should be used (must not be {@code null})
	 * @since 2.2.2
	 */
	default Object onCreate(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		return result;
	}
	/**
	 * Called when binding fails for any reason (including failures from
	 * {@link #onSuccess} or {@link #onCreate} calls). Implementations may choose to
	 * swallow exceptions and return an alternative result.
	 * @param name the name of the element being bound
	 * @param target the item being bound
	 * @param context the bind context
	 * @param error the cause of the error (if the exception stands it may be re-thrown)
	 * @return the actual result that should be used (may be {@code null}).
	 * @throws Exception if the binding isn"t valid
	 */
	default Object onFailure(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Exception error)
			throws Exception {
		throw error;
	}
	/**
	 * Called when binding finishes with either bound or unbound result. This method will
	 * not be called when binding failed, even if a handler returns a result from
	 * {@link #onFailure}.
	 * @param name the name of the element being bound
	 * @param target the item being bound
	 * @param context the bind context
	 * @param result the bound result (may be {@code null})
	 * @throws Exception if the binding isn"t valid
	 */
	default void onFinish(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result)
			throws Exception {
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public final class BindResult<T> {
	private static final BindResult<?> UNBOUND = new BindResult<>(null);
	private final T value;
	private BindResult(T value) {
		this.value = value;
	}
	/**
	 * Return the object that was bound or throw a {@link NoSuchElementException} if no
	 * value was bound.
	 * @return the bound value (never {@code null})
	 * @throws NoSuchElementException if no value was bound
	 * @see #isBound()
	 */
	public T get() throws NoSuchElementException {
		if (this.value == null) {
			throw new NoSuchElementException('No value bound');
		}
		return this.value;
	}
	/**
	 * Returns {@code true} if a result was bound.
	 * @return if a result was bound
	 */
	public boolean isBound() {
		return (this.value != null);
	}
	/**
	 * Invoke the specified consumer with the bound value, or do nothing if no value has
	 * been bound.
	 * @param consumer block to execute if a value has been bound
	 */
	public void ifBound(Consumer<? super T> consumer) {
		Assert.notNull(consumer, 'Consumer must not be null');
		if (this.value != null) {
			consumer.accept(this.value);
		}
	}
	/**
	 * Apply the provided mapping function to the bound value, or return an updated
	 * unbound result if no value has been bound.
	 * @param <U> the type of the result of the mapping function
	 * @param mapper a mapping function to apply to the bound value. The mapper will not
	 * be invoked if no value has been bound.
	 * @return an {@code BindResult} describing the result of applying a mapping function
	 * to the value of this {@code BindResult}.
	 */
	public <U> BindResult<U> map(Function<? super T, ? extends U> mapper) {
		Assert.notNull(mapper, 'Mapper must not be null');
		return of((this.value != null) ? mapper.apply(this.value) : null);
	}
	/**
	 * Return the object that was bound, or {@code other} if no value has been bound.
	 * @param other the value to be returned if there is no bound value (may be
	 * {@code null})
	 * @return the value, if bound, otherwise {@code other}
	 */
	public T orElse(T other) {
		return (this.value != null) ? this.value : other;
	}
	/**
	 * Return the object that was bound, or the result of invoking {@code other} if no
	 * value has been bound.
	 * @param other a {@link Supplier} of the value to be returned if there is no bound
	 * value
	 * @return the value, if bound, otherwise the supplied {@code other}
	 */
	public T orElseGet(Supplier<? extends T> other) {
		return (this.value != null) ? this.value : other.get();
	}
	/**
	 * Return the object that was bound, or throw an exception to be created by the
	 * provided supplier if no value has been bound.
	 * @param <X> the type of the exception to be thrown
	 * @param exceptionSupplier the supplier which will return the exception to be thrown
	 * @return the present value
	 * @throws X if there is no value present
	 */
	public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {
		if (this.value == null) {
			throw exceptionSupplier.get();
		}
		return this.value;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return ObjectUtils.nullSafeEquals(this.value, ((BindResult<?>) obj).value);
	}
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHashCode(this.value);
	}
	@SuppressWarnings('unchecked')
	static <T> BindResult<T> of(T value) {
		if (value == null) {
			return (BindResult<T>) UNBOUND;
		}
		return new BindResult<>(value);
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public enum BindMethod {
	/**
	 * Java Bean using getter/setter binding.
	 */
	JAVA_BEAN,
	/**
	 * Value object using constructor binding.
	 */
	VALUE_OBJECT
}
/*
package org.springframework.boot.context.properties.bind;
/**
public class Binder {
	private static final Set<Class<?>> NON_BEAN_CLASSES = Collections
		.unmodifiableSet(new HashSet<>(Arrays.asList(Object.class, Class.class)));
	private final Iterable<ConfigurationPropertySource> sources;
	private final PlaceholdersResolver placeholdersResolver;
	private final BindConverter bindConverter;
	private final BindHandler defaultBindHandler;
	private final Map<BindMethod, List<DataObjectBinder>> dataObjectBinders;
	/**
	 * Create a new {@link Binder} instance for the specified sources. A
	 * {@link DefaultFormattingConversionService} will be used for all conversion.
	 * @param sources the sources used for binding
	 */
	public Binder(ConfigurationPropertySource... sources) {
		this((sources != null) ? Arrays.asList(sources) : null, null, null, null);
	}
	/**
	 * Create a new {@link Binder} instance for the specified sources. A
	 * {@link DefaultFormattingConversionService} will be used for all conversion.
	 * @param sources the sources used for binding
	 */
	public Binder(Iterable<ConfigurationPropertySource> sources) {
		this(sources, null, null, null);
	}
	/**
	 * Create a new {@link Binder} instance for the specified sources.
	 * @param sources the sources used for binding
	 * @param placeholdersResolver strategy to resolve any property placeholders
	 */
	public Binder(Iterable<ConfigurationPropertySource> sources, PlaceholdersResolver placeholdersResolver) {
		this(sources, placeholdersResolver, null, null);
	}
	/**
	 * Create a new {@link Binder} instance for the specified sources.
	 * @param sources the sources used for binding
	 * @param placeholdersResolver strategy to resolve any property placeholders
	 * @param conversionService the conversion service to convert values (or {@code null}
	 * to use {@link ApplicationConversionService})
	 */
	public Binder(Iterable<ConfigurationPropertySource> sources, PlaceholdersResolver placeholdersResolver,
			ConversionService conversionService) {
		this(sources, placeholdersResolver, conversionService, null);
	}
	/**
	 * Create a new {@link Binder} instance for the specified sources.
	 * @param sources the sources used for binding
	 * @param placeholdersResolver strategy to resolve any property placeholders
	 * @param conversionService the conversion service to convert values (or {@code null}
	 * to use {@link ApplicationConversionService})
	 * @param propertyEditorInitializer initializer used to configure the property editors
	 * that can convert values (or {@code null} if no initialization is required). Often
	 * used to call {@link ConfigurableListableBeanFactory#copyRegisteredEditorsTo}.
	 */
	public Binder(Iterable<ConfigurationPropertySource> sources, PlaceholdersResolver placeholdersResolver,
			ConversionService conversionService, Consumer<PropertyEditorRegistry> propertyEditorInitializer) {
		this(sources, placeholdersResolver, conversionService, propertyEditorInitializer, null);
	}
	/**
	 * Create a new {@link Binder} instance for the specified sources.
	 * @param sources the sources used for binding
	 * @param placeholdersResolver strategy to resolve any property placeholders
	 * @param conversionService the conversion service to convert values (or {@code null}
	 * to use {@link ApplicationConversionService})
	 * @param propertyEditorInitializer initializer used to configure the property editors
	 * that can convert values (or {@code null} if no initialization is required). Often
	 * used to call {@link ConfigurableListableBeanFactory#copyRegisteredEditorsTo}.
	 * @param defaultBindHandler the default bind handler to use if none is specified when
	 * binding
	 * @since 2.2.0
	 */
	public Binder(Iterable<ConfigurationPropertySource> sources, PlaceholdersResolver placeholdersResolver,
			ConversionService conversionService, Consumer<PropertyEditorRegistry> propertyEditorInitializer,
			BindHandler defaultBindHandler) {
		this(sources, placeholdersResolver, conversionService, propertyEditorInitializer, defaultBindHandler, null);
	}
	/**
	 * Create a new {@link Binder} instance for the specified sources.
	 * @param sources the sources used for binding
	 * @param placeholdersResolver strategy to resolve any property placeholders
	 * @param conversionService the conversion service to convert values (or {@code null}
	 * to use {@link ApplicationConversionService})
	 * @param propertyEditorInitializer initializer used to configure the property editors
	 * that can convert values (or {@code null} if no initialization is required). Often
	 * used to call {@link ConfigurableListableBeanFactory#copyRegisteredEditorsTo}.
	 * @param defaultBindHandler the default bind handler to use if none is specified when
	 * binding
	 * @param constructorProvider the constructor provider which provides the bind
	 * constructor to use when binding
	 * @since 2.2.1
	 */
	public Binder(Iterable<ConfigurationPropertySource> sources, PlaceholdersResolver placeholdersResolver,
			ConversionService conversionService, Consumer<PropertyEditorRegistry> propertyEditorInitializer,
			BindHandler defaultBindHandler, BindConstructorProvider constructorProvider) {
		this(sources, placeholdersResolver,
				(conversionService != null) ? Collections.singletonList(conversionService)
						: (List<ConversionService>) null,
				propertyEditorInitializer, defaultBindHandler, constructorProvider);
	}
	/**
	 * Create a new {@link Binder} instance for the specified sources.
	 * @param sources the sources used for binding
	 * @param placeholdersResolver strategy to resolve any property placeholders
	 * @param conversionServices the conversion services to convert values (or
	 * {@code null} to use {@link ApplicationConversionService})
	 * @param propertyEditorInitializer initializer used to configure the property editors
	 * that can convert values (or {@code null} if no initialization is required). Often
	 * used to call {@link ConfigurableListableBeanFactory#copyRegisteredEditorsTo}.
	 * @param defaultBindHandler the default bind handler to use if none is specified when
	 * binding
	 * @param constructorProvider the constructor provider which provides the bind
	 * constructor to use when binding
	 * @since 2.5.0
	 */
	public Binder(Iterable<ConfigurationPropertySource> sources, PlaceholdersResolver placeholdersResolver,
			List<ConversionService> conversionServices, Consumer<PropertyEditorRegistry> propertyEditorInitializer,
			BindHandler defaultBindHandler, BindConstructorProvider constructorProvider) {
		Assert.notNull(sources, 'Sources must not be null');
		for (ConfigurationPropertySource source : sources) {
			Assert.notNull(source, 'Sources must not contain null elements');
		}
		this.sources = sources;
		this.placeholdersResolver = (placeholdersResolver != null) ? placeholdersResolver : PlaceholdersResolver.NONE;
		this.bindConverter = BindConverter.get(conversionServices, propertyEditorInitializer);
		this.defaultBindHandler = (defaultBindHandler != null) ? defaultBindHandler : BindHandler.DEFAULT;
		if (constructorProvider == null) {
			constructorProvider = BindConstructorProvider.DEFAULT;
		}
		ValueObjectBinder valueObjectBinder = new ValueObjectBinder(constructorProvider);
		JavaBeanBinder javaBeanBinder = JavaBeanBinder.INSTANCE;
		Map<BindMethod, List<DataObjectBinder>> dataObjectBinders = new HashMap<>();
		dataObjectBinders.put(BindMethod.VALUE_OBJECT, List.of(valueObjectBinder));
		dataObjectBinders.put(BindMethod.JAVA_BEAN, List.of(javaBeanBinder));
		dataObjectBinders.put(null, List.of(valueObjectBinder, javaBeanBinder));
		this.dataObjectBinders = Collections.unmodifiableMap(dataObjectBinders);
	}
	/**
	 * Bind the specified target {@link Class} using this binder"s
	 * {@link ConfigurationPropertySource property sources}.
	 * @param name the configuration property name to bind
	 * @param target the target class
	 * @param <T> the bound type
	 * @return the binding result (never {@code null})
	 * @see #bind(ConfigurationPropertyName, Bindable, BindHandler)
	 */
	public <T> BindResult<T> bind(String name, Class<T> target) {
		return bind(name, Bindable.of(target));
	}
	/**
	 * Bind the specified target {@link Bindable} using this binder"s
	 * {@link ConfigurationPropertySource property sources}.
	 * @param name the configuration property name to bind
	 * @param target the target bindable
	 * @param <T> the bound type
	 * @return the binding result (never {@code null})
	 * @see #bind(ConfigurationPropertyName, Bindable, BindHandler)
	 */
	public <T> BindResult<T> bind(String name, Bindable<T> target) {
		return bind(ConfigurationPropertyName.of(name), target, null);
	}
	/**
	 * Bind the specified target {@link Bindable} using this binder"s
	 * {@link ConfigurationPropertySource property sources}.
	 * @param name the configuration property name to bind
	 * @param target the target bindable
	 * @param <T> the bound type
	 * @return the binding result (never {@code null})
	 * @see #bind(ConfigurationPropertyName, Bindable, BindHandler)
	 */
	public <T> BindResult<T> bind(ConfigurationPropertyName name, Bindable<T> target) {
		return bind(name, target, null);
	}
	/**
	 * Bind the specified target {@link Bindable} using this binder"s
	 * {@link ConfigurationPropertySource property sources}.
	 * @param name the configuration property name to bind
	 * @param target the target bindable
	 * @param handler the bind handler (may be {@code null})
	 * @param <T> the bound type
	 * @return the binding result (never {@code null})
	 */
	public <T> BindResult<T> bind(String name, Bindable<T> target, BindHandler handler) {
		return bind(ConfigurationPropertyName.of(name), target, handler);
	}
	/**
	 * Bind the specified target {@link Bindable} using this binder"s
	 * {@link ConfigurationPropertySource property sources}.
	 * @param name the configuration property name to bind
	 * @param target the target bindable
	 * @param handler the bind handler (may be {@code null})
	 * @param <T> the bound type
	 * @return the binding result (never {@code null})
	 */
	public <T> BindResult<T> bind(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler) {
		T bound = bind(name, target, handler, false);
		return BindResult.of(bound);
	}
	/**
	 * Bind the specified target {@link Class} using this binder"s
	 * {@link ConfigurationPropertySource property sources} or create a new instance of
	 * the specified target {@link Class} if the result of the binding is {@code null}.
	 * @param name the configuration property name to bind
	 * @param target the target class
	 * @param <T> the bound type
	 * @return the bound or created object
	 * @since 2.2.0
	 * @see #bind(ConfigurationPropertyName, Bindable, BindHandler)
	 */
	public <T> T bindOrCreate(String name, Class<T> target) {
		return bindOrCreate(name, Bindable.of(target));
	}
	/**
	 * Bind the specified target {@link Bindable} using this binder"s
	 * {@link ConfigurationPropertySource property sources} or create a new instance using
	 * the type of the {@link Bindable} if the result of the binding is {@code null}.
	 * @param name the configuration property name to bind
	 * @param target the target bindable
	 * @param <T> the bound type
	 * @return the bound or created object
	 * @since 2.2.0
	 * @see #bindOrCreate(ConfigurationPropertyName, Bindable, BindHandler)
	 */
	public <T> T bindOrCreate(String name, Bindable<T> target) {
		return bindOrCreate(ConfigurationPropertyName.of(name), target, null);
	}
	/**
	 * Bind the specified target {@link Bindable} using this binder"s
	 * {@link ConfigurationPropertySource property sources} or create a new instance using
	 * the type of the {@link Bindable} if the result of the binding is {@code null}.
	 * @param name the configuration property name to bind
	 * @param target the target bindable
	 * @param handler the bind handler
	 * @param <T> the bound type
	 * @return the bound or created object
	 * @since 2.2.0
	 * @see #bindOrCreate(ConfigurationPropertyName, Bindable, BindHandler)
	 */
	public <T> T bindOrCreate(String name, Bindable<T> target, BindHandler handler) {
		return bindOrCreate(ConfigurationPropertyName.of(name), target, handler);
	}
	/**
	 * Bind the specified target {@link Bindable} using this binder"s
	 * {@link ConfigurationPropertySource property sources} or create a new instance using
	 * the type of the {@link Bindable} if the result of the binding is {@code null}.
	 * @param name the configuration property name to bind
	 * @param target the target bindable
	 * @param handler the bind handler (may be {@code null})
	 * @param <T> the bound or created type
	 * @return the bound or created object
	 * @since 2.2.0
	 */
	public <T> T bindOrCreate(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler) {
		return bind(name, target, handler, true);
	}
	private <T> T bind(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler, boolean create) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(target, 'Target must not be null');
		handler = (handler != null) ? handler : this.defaultBindHandler;
		Context context = new Context();
		return bind(name, target, handler, context, false, create);
	}
	private <T> T bind(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler, Context context,
			boolean allowRecursiveBinding, boolean create) {
		try {
			Bindable<T> replacementTarget = handler.onStart(name, target, context);
			if (replacementTarget == null) {
				return handleBindResult(name, target, handler, context, null, create);
			}
			target = replacementTarget;
			Object bound = bindObject(name, target, handler, context, allowRecursiveBinding);
			return handleBindResult(name, target, handler, context, bound, create);
		}
		catch (Exception ex) {
			return handleBindError(name, target, handler, context, ex);
		}
	}
	private <T> T handleBindResult(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler,
			Context context, Object result, boolean create) throws Exception {
		if (result != null) {
			result = handler.onSuccess(name, target, context, result);
			result = context.getConverter().convert(result, target);
		}
		if (result == null && create) {
			result = fromDataObjectBinders(target.getBindMethod(),
					(dataObjectBinder) -> dataObjectBinder.create(target, context));
			result = handler.onCreate(name, target, context, result);
			result = context.getConverter().convert(result, target);
			if (result == null) {
				IllegalStateException ex = new IllegalStateException(
						'Unable to create instance for ' + target.getType());
				this.dataObjectBinders.get(target.getBindMethod())
					.forEach((dataObjectBinder) -> dataObjectBinder.onUnableToCreateInstance(target, context, ex));
				throw ex;
			}
		}
		handler.onFinish(name, target, context, result);
		return context.getConverter().convert(result, target);
	}
	private <T> T handleBindError(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler,
			Context context, Exception error) {
		try {
			Object result = handler.onFailure(name, target, context, error);
			return context.getConverter().convert(result, target);
		}
		catch (Exception ex) {
			if (ex instanceof BindException bindException) {
				throw bindException;
			}
			throw new BindException(name, target, context.getConfigurationProperty(), ex);
		}
	}
	private <T> Object bindObject(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler,
			Context context, boolean allowRecursiveBinding) {
		ConfigurationProperty property = findProperty(name, target, context);
		if (property == null && context.depth != 0 && containsNoDescendantOf(context.getSources(), name)) {
			return null;
		}
		AggregateBinder<?> aggregateBinder = getAggregateBinder(target, context);
		if (aggregateBinder != null) {
			return bindAggregate(name, target, handler, context, aggregateBinder);
		}
		if (property != null) {
			try {
				return bindProperty(target, context, property);
			}
			catch (ConverterNotFoundException ex) {
				// We might still be able to bind it using the recursive binders
				Object instance = bindDataObject(name, target, handler, context, allowRecursiveBinding);
				if (instance != null) {
					return instance;
				}
				throw ex;
			}
		}
		return bindDataObject(name, target, handler, context, allowRecursiveBinding);
	}
	private AggregateBinder<?> getAggregateBinder(Bindable<?> target, Context context) {
		Class<?> resolvedType = target.getType().resolve(Object.class);
		if (Map.class.isAssignableFrom(resolvedType)) {
			return new MapBinder(context);
		}
		if (Collection.class.isAssignableFrom(resolvedType)) {
			return new CollectionBinder(context);
		}
		if (target.getType().isArray()) {
			return new ArrayBinder(context);
		}
		return null;
	}
	private <T> Object bindAggregate(ConfigurationPropertyName name, Bindable<T> target, BindHandler handler,
			Context context, AggregateBinder<?> aggregateBinder) {
		AggregateElementBinder elementBinder = (itemName, itemTarget, source) -> {
			boolean allowRecursiveBinding = aggregateBinder.isAllowRecursiveBinding(source);
			Supplier<?> supplier = () -> bind(itemName, itemTarget, handler, context, allowRecursiveBinding, false);
			return context.withSource(source, supplier);
		};
		return context.withIncreasedDepth(() -> aggregateBinder.bind(name, target, elementBinder));
	}
	private <T> ConfigurationProperty findProperty(ConfigurationPropertyName name, Bindable<T> target,
			Context context) {
		if (name.isEmpty() || target.hasBindRestriction(BindRestriction.NO_DIRECT_PROPERTY)) {
			return null;
		}
		for (ConfigurationPropertySource source : context.getSources()) {
			ConfigurationProperty property = source.getConfigurationProperty(name);
			if (property != null) {
				return property;
			}
		}
		return null;
	}
	private <T> Object bindProperty(Bindable<T> target, Context context, ConfigurationProperty property) {
		context.setConfigurationProperty(property);
		Object result = property.getValue();
		result = this.placeholdersResolver.resolvePlaceholders(result);
		result = context.getConverter().convert(result, target);
		return result;
	}
	private Object bindDataObject(ConfigurationPropertyName name, Bindable<?> target, BindHandler handler,
			Context context, boolean allowRecursiveBinding) {
		if (isUnbindableBean(name, target, context)) {
			return null;
		}
		Class<?> type = target.getType().resolve(Object.class);
		BindMethod bindMethod = target.getBindMethod();
		if (!allowRecursiveBinding && context.isBindingDataObject(type)) {
			return null;
		}
		DataObjectPropertyBinder propertyBinder = (propertyName, propertyTarget) -> bind(name.append(propertyName),
				propertyTarget, handler, context, false, false);
		return context.withDataObject(type, () -> fromDataObjectBinders(bindMethod,
				(dataObjectBinder) -> dataObjectBinder.bind(name, target, context, propertyBinder)));
	}
	private Object fromDataObjectBinders(BindMethod bindMethod, Function<DataObjectBinder, Object> operation) {
		return this.dataObjectBinders.get(bindMethod)
			.stream()
			.map(operation)
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(null);
	}
	private boolean isUnbindableBean(ConfigurationPropertyName name, Bindable<?> target, Context context) {
		for (ConfigurationPropertySource source : context.getSources()) {
			if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {
				// We know there are properties to bind so we can"t bypass anything
				return false;
			}
		}
		Class<?> resolved = target.getType().resolve(Object.class);
		if (resolved.isPrimitive() || NON_BEAN_CLASSES.contains(resolved)) {
			return true;
		}
		return resolved.getName().startsWith('java.');
	}
	private boolean containsNoDescendantOf(Iterable<ConfigurationPropertySource> sources,
			ConfigurationPropertyName name) {
		for (ConfigurationPropertySource source : sources) {
			if (source.containsDescendantOf(name) != ConfigurationPropertyState.ABSENT) {
				return false;
			}
		}
		return true;
	}
	/**
	 * Create a new {@link Binder} instance from the specified environment.
	 * @param environment the environment source (must have attached
	 * {@link ConfigurationPropertySources})
	 * @return a {@link Binder} instance
	 */
	public static Binder get(Environment environment) {
		return get(environment, null);
	}
	/**
	 * Create a new {@link Binder} instance from the specified environment.
	 * @param environment the environment source (must have attached
	 * {@link ConfigurationPropertySources})
	 * @param defaultBindHandler the default bind handler to use if none is specified when
	 * binding
	 * @return a {@link Binder} instance
	 * @since 2.2.0
	 */
	public static Binder get(Environment environment, BindHandler defaultBindHandler) {
		Iterable<ConfigurationPropertySource> sources = ConfigurationPropertySources.get(environment);
		PropertySourcesPlaceholdersResolver placeholdersResolver = new PropertySourcesPlaceholdersResolver(environment);
		return new Binder(sources, placeholdersResolver, null, null, defaultBindHandler);
	}
	/**
	 * Context used when binding and the {@link BindContext} implementation.
	 */
	final class Context implements BindContext {
		private int depth;
		private final List<ConfigurationPropertySource> source = Arrays.asList((ConfigurationPropertySource) null);
		private int sourcePushCount;
		private final Deque<Class<?>> dataObjectBindings = new ArrayDeque<>();
		private final Deque<Class<?>> constructorBindings = new ArrayDeque<>();
		private ConfigurationProperty configurationProperty;
		private void increaseDepth() {
			this.depth++;
		}
		private void decreaseDepth() {
			this.depth--;
		}
		private <T> T withSource(ConfigurationPropertySource source, Supplier<T> supplier) {
			if (source == null) {
				return supplier.get();
			}
			this.source.set(0, source);
			this.sourcePushCount++;
			try {
				return supplier.get();
			}
			finally {
				this.sourcePushCount--;
			}
		}
		private <T> T withDataObject(Class<?> type, Supplier<T> supplier) {
			this.dataObjectBindings.push(type);
			try {
				return withIncreasedDepth(supplier);
			}
			finally {
				this.dataObjectBindings.pop();
			}
		}
		private boolean isBindingDataObject(Class<?> type) {
			return this.dataObjectBindings.contains(type);
		}
		private <T> T withIncreasedDepth(Supplier<T> supplier) {
			increaseDepth();
			try {
				return supplier.get();
			}
			finally {
				decreaseDepth();
			}
		}
		void setConfigurationProperty(ConfigurationProperty configurationProperty) {
			this.configurationProperty = configurationProperty;
		}
		void clearConfigurationProperty() {
			this.configurationProperty = null;
		}
		void pushConstructorBoundTypes(Class<?> value) {
			this.constructorBindings.push(value);
		}
		boolean isNestedConstructorBinding() {
			return !this.constructorBindings.isEmpty();
		}
		void popConstructorBoundTypes() {
			this.constructorBindings.pop();
		}
		PlaceholdersResolver getPlaceholdersResolver() {
			return Binder.this.placeholdersResolver;
		}
		BindConverter getConverter() {
			return Binder.this.bindConverter;
		}
		@Override
		public Binder getBinder() {
			return Binder.this;
		}
		@Override
		public int getDepth() {
			return this.depth;
		}
		@Override
		public Iterable<ConfigurationPropertySource> getSources() {
			if (this.sourcePushCount > 0) {
				return this.source;
			}
			return Binder.this.sources;
		}
		@Override
		public ConfigurationProperty getConfigurationProperty() {
			return this.configurationProperty;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
interface DataObjectPropertyBinder {
	/**
	 * Bind the given property.
	 * @param propertyName the property name (in lowercase dashed form, e.g.
	 * {@code first-name})
	 * @param target the target bindable
	 * @return the bound value or {@code null}
	 */
	Object bindProperty(String propertyName, Bindable<?> target);
}
/*
package org.springframework.boot.context.properties.bind;
/**
public abstract class AbstractBindHandler implements BindHandler {
	private final BindHandler parent;
	/**
	 * Create a new binding handler instance.
	 */
	public AbstractBindHandler() {
		this(BindHandler.DEFAULT);
	}
	/**
	 * Create a new binding handler instance with a specific parent.
	 * @param parent the parent handler
	 */
	public AbstractBindHandler(BindHandler parent) {
		Assert.notNull(parent, 'Parent must not be null');
		this.parent = parent;
	}
	@Override
	public <T> Bindable<T> onStart(ConfigurationPropertyName name, Bindable<T> target, BindContext context) {
		return this.parent.onStart(name, target, context);
	}
	@Override
	public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		return this.parent.onSuccess(name, target, context, result);
	}
	@Override
	public Object onFailure(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Exception error)
			throws Exception {
		return this.parent.onFailure(name, target, context, error);
	}
	@Override
	public void onFinish(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result)
			throws Exception {
		this.parent.onFinish(name, target, context, result);
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public abstract class DataObjectPropertyName {
	private DataObjectPropertyName() {
	}
	/**
	 * Return the specified Java Bean property name in dashed form.
	 * @param name the source name
	 * @return the dashed from
	 */
	public static String toDashedForm(String name) {
		StringBuilder result = new StringBuilder(name.length());
		boolean inIndex = false;
		for (int i = 0; i < name.length(); i++) {
			char ch = name.charAt(i);
			if (inIndex) {
				result.append(ch);
				if (ch == "]") {
					inIndex = false;
				}
			}
			else {
				if (ch == "[") {
					inIndex = true;
					result.append(ch);
				}
				else {
					ch = (ch != "_") ? ch : "-";
					if (Character.isUpperCase(ch) && !result.isEmpty() && result.charAt(result.length() - 1) != "-") {
						result.append("-");
					}
					result.append(Character.toLowerCase(ch));
				}
			}
		}
		return result.toString();
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public class PropertySourcesPlaceholdersResolver implements PlaceholdersResolver {
	private final Iterable<PropertySource<?>> sources;
	private final PropertyPlaceholderHelper helper;
	public PropertySourcesPlaceholdersResolver(Environment environment) {
		this(getSources(environment), null);
	}
	public PropertySourcesPlaceholdersResolver(Iterable<PropertySource<?>> sources) {
		this(sources, null);
	}
	public PropertySourcesPlaceholdersResolver(Iterable<PropertySource<?>> sources, PropertyPlaceholderHelper helper) {
		this.sources = sources;
		this.helper = (helper != null) ? helper
				: new PropertyPlaceholderHelper(SystemPropertyUtils.'_PREFIX,
						SystemPropertyUtils.'_SUFFIX, SystemPropertyUtils.VALUE_SEPARATOR,
						SystemPropertyUtils.ESCAPE_CHARACTER, true);
	}
	@Override
	public Object resolvePlaceholders(Object value) {
		if (value instanceof String string) {
			return this.helper.replacePlaceholders(string, this::resolvePlaceholder);
		}
		return value;
	}
	protected String resolvePlaceholder(String placeholder) {
		if (this.sources != null) {
			for (PropertySource<?> source : this.sources) {
				Object value = source.getProperty(placeholder);
				if (value != null) {
					return String.valueOf(value);
				}
			}
		}
		return null;
	}
	private static PropertySources getSources(Environment environment) {
		Assert.notNull(environment, 'Environment must not be null');
		Assert.isInstanceOf(ConfigurableEnvironment.class, environment,
				'Environment must be a ConfigurableEnvironment');
		return ((ConfigurableEnvironment) environment).getPropertySources();
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public final class Bindable<T> {
	private static final Annotation[] NO_ANNOTATIONS = {};
	private static final EnumSet<BindRestriction> NO_BIND_RESTRICTIONS = EnumSet.noneOf(BindRestriction.class);
	private final ResolvableType type;
	private final ResolvableType boxedType;
	private final Supplier<T> value;
	private final Annotation[] annotations;
	private final EnumSet<BindRestriction> bindRestrictions;
	private final BindMethod bindMethod;
	private Bindable(ResolvableType type, ResolvableType boxedType, Supplier<T> value, Annotation[] annotations,
			EnumSet<BindRestriction> bindRestrictions, BindMethod bindMethod) {
		this.type = type;
		this.boxedType = boxedType;
		this.value = value;
		this.annotations = annotations;
		this.bindRestrictions = bindRestrictions;
		this.bindMethod = bindMethod;
	}
	/**
	 * Return the type of the item to bind.
	 * @return the type being bound
	 */
	public ResolvableType getType() {
		return this.type;
	}
	/**
	 * Return the boxed type of the item to bind.
	 * @return the boxed type for the item being bound
	 */
	public ResolvableType getBoxedType() {
		return this.boxedType;
	}
	/**
	 * Return a supplier that provides the object value or {@code null}.
	 * @return the value or {@code null}
	 */
	public Supplier<T> getValue() {
		return this.value;
	}
	/**
	 * Return any associated annotations that could affect binding.
	 * @return the associated annotations
	 */
	public Annotation[] getAnnotations() {
		return this.annotations;
	}
	/**
	 * Return a single associated annotations that could affect binding.
	 * @param <A> the annotation type
	 * @param type annotation type
	 * @return the associated annotation or {@code null}
	 */
	@SuppressWarnings('unchecked')
	public <A extends Annotation> A getAnnotation(Class<A> type) {
		for (Annotation annotation : this.annotations) {
			if (type.isInstance(annotation)) {
				return (A) annotation;
			}
		}
		return null;
	}
	/**
	 * Returns {@code true} if the specified bind restriction has been added.
	 * @param bindRestriction the bind restriction to check
	 * @return if the bind restriction has been added
	 * @since 2.5.0
	 */
	public boolean hasBindRestriction(BindRestriction bindRestriction) {
		return this.bindRestrictions.contains(bindRestriction);
	}
	/**
	 * Returns the {@link BindMethod method} to be used to bind this bindable, or
	 * {@code null} if no specific binding method is required.
	 * @return the bind method or {@code null}
	 * @since 3.0.8
	 */
	public BindMethod getBindMethod() {
		return this.bindMethod;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		Bindable<?> other = (Bindable<?>) obj;
		boolean result = true;
		result = result && nullSafeEquals(this.type.resolve(), other.type.resolve());
		result = result && nullSafeEquals(this.annotations, other.annotations);
		result = result && nullSafeEquals(this.bindRestrictions, other.bindRestrictions);
		result = result && nullSafeEquals(this.bindMethod, other.bindMethod);
		return result;
	}
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHash(this.type, this.annotations, this.bindRestrictions, this.bindMethod);
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this);
		creator.append('type', this.type);
		creator.append('value', (this.value != null) ? 'provided' : 'none');
		creator.append('annotations', this.annotations);
		creator.append('bindMethod', this.bindMethod);
		return creator.toString();
	}
	private boolean nullSafeEquals(Object o1, Object o2) {
		return ObjectUtils.nullSafeEquals(o1, o2);
	}
	/**
	 * Create an updated {@link Bindable} instance with the specified annotations.
	 * @param annotations the annotations
	 * @return an updated {@link Bindable}
	 */
	public Bindable<T> withAnnotations(Annotation... annotations) {
		return new Bindable<>(this.type, this.boxedType, this.value,
				(annotations != null) ? annotations : NO_ANNOTATIONS, NO_BIND_RESTRICTIONS, this.bindMethod);
	}
	/**
	 * Create an updated {@link Bindable} instance with an existing value. Implies that
	 * Java Bean binding will be used.
	 * @param existingValue the existing value
	 * @return an updated {@link Bindable}
	 */
	public Bindable<T> withExistingValue(T existingValue) {
		Assert.isTrue(
				existingValue == null || this.type.isArray() || this.boxedType.resolve().isInstance(existingValue),
				() -> 'ExistingValue must be an instance of ' + this.type);
		Assert.state(this.bindMethod != BindMethod.VALUE_OBJECT,
				() -> 'An existing value cannot be provided when binding as a value object');
		Supplier<T> value = (existingValue != null) ? () -> existingValue : null;
		return new Bindable<>(this.type, this.boxedType, value, this.annotations, this.bindRestrictions,
				BindMethod.JAVA_BEAN);
	}
	/**
	 * Create an updated {@link Bindable} instance with a value supplier.
	 * @param suppliedValue the supplier for the value
	 * @return an updated {@link Bindable}
	 */
	public Bindable<T> withSuppliedValue(Supplier<T> suppliedValue) {
		return new Bindable<>(this.type, this.boxedType, suppliedValue, this.annotations, this.bindRestrictions,
				this.bindMethod);
	}
	/**
	 * Create an updated {@link Bindable} instance with additional bind restrictions.
	 * @param additionalRestrictions any additional restrictions to apply
	 * @return an updated {@link Bindable}
	 * @since 2.5.0
	 */
	public Bindable<T> withBindRestrictions(BindRestriction... additionalRestrictions) {
		EnumSet<BindRestriction> bindRestrictions = EnumSet.copyOf(this.bindRestrictions);
		bindRestrictions.addAll(Arrays.asList(additionalRestrictions));
		return new Bindable<>(this.type, this.boxedType, this.value, this.annotations, bindRestrictions,
				this.bindMethod);
	}
	/**
	 * Create an updated {@link Bindable} instance with a specific bind method. To use
	 * {@link BindMethod#VALUE_OBJECT value object binding}, the current instance must not
	 * have an existing or supplied value.
	 * @param bindMethod the method to use to bind the bindable
	 * @return an updated {@link Bindable}
	 * @since 3.0.8
	 */
	public Bindable<T> withBindMethod(BindMethod bindMethod) {
		Assert.state(bindMethod != BindMethod.VALUE_OBJECT || this.value == null,
				() -> 'Value object binding cannot be used with an existing or supplied value');
		return new Bindable<>(this.type, this.boxedType, this.value, this.annotations, this.bindRestrictions,
				bindMethod);
	}
	/**
	 * Create a new {@link Bindable} of the type of the specified instance with an
	 * existing value equal to the instance.
	 * @param <T> the source type
	 * @param instance the instance (must not be {@code null})
	 * @return a {@link Bindable} instance
	 * @see #of(ResolvableType)
	 * @see #withExistingValue(Object)
	 */
	@SuppressWarnings('unchecked')
	public static <T> Bindable<T> ofInstance(T instance) {
		Assert.notNull(instance, 'Instance must not be null');
		Class<T> type = (Class<T>) instance.getClass();
		return of(type).withExistingValue(instance);
	}
	/**
	 * Create a new {@link Bindable} of the specified type.
	 * @param <T> the source type
	 * @param type the type (must not be {@code null})
	 * @return a {@link Bindable} instance
	 * @see #of(ResolvableType)
	 */
	public static <T> Bindable<T> of(Class<T> type) {
		Assert.notNull(type, 'Type must not be null');
		return of(ResolvableType.forClass(type));
	}
	/**
	 * Create a new {@link Bindable} {@link List} of the specified element type.
	 * @param <E> the element type
	 * @param elementType the list element type
	 * @return a {@link Bindable} instance
	 */
	public static <E> Bindable<List<E>> listOf(Class<E> elementType) {
		return of(ResolvableType.forClassWithGenerics(List.class, elementType));
	}
	/**
	 * Create a new {@link Bindable} {@link Set} of the specified element type.
	 * @param <E> the element type
	 * @param elementType the set element type
	 * @return a {@link Bindable} instance
	 */
	public static <E> Bindable<Set<E>> setOf(Class<E> elementType) {
		return of(ResolvableType.forClassWithGenerics(Set.class, elementType));
	}
	/**
	 * Create a new {@link Bindable} {@link Map} of the specified key and value type.
	 * @param <K> the key type
	 * @param <V> the value type
	 * @param keyType the map key type
	 * @param valueType the map value type
	 * @return a {@link Bindable} instance
	 */
	public static <K, V> Bindable<Map<K, V>> mapOf(Class<K> keyType, Class<V> valueType) {
		return of(ResolvableType.forClassWithGenerics(Map.class, keyType, valueType));
	}
	/**
	 * Create a new {@link Bindable} of the specified type.
	 * @param <T> the source type
	 * @param type the type (must not be {@code null})
	 * @return a {@link Bindable} instance
	 * @see #of(Class)
	 */
	public static <T> Bindable<T> of(ResolvableType type) {
		Assert.notNull(type, 'Type must not be null');
		ResolvableType boxedType = box(type);
		return new Bindable<>(type, boxedType, null, NO_ANNOTATIONS, NO_BIND_RESTRICTIONS, null);
	}
	private static ResolvableType box(ResolvableType type) {
		Class<?> resolved = type.resolve();
		if (resolved != null && resolved.isPrimitive()) {
			Object array = Array.newInstance(resolved, 1);
			Class<?> wrapperType = Array.get(array, 0).getClass();
			return ResolvableType.forClass(wrapperType);
		}
		if (resolved != null && resolved.isArray()) {
			return ResolvableType.forArrayComponent(box(type.getComponentType()));
		}
		return type;
	}
	/**
	 * Restrictions that can be applied when binding values.
	 *
	 * @since 2.5.0
	 */
	public enum BindRestriction {
		/**
		 * Do not bind direct {@link ConfigurationProperty} matches.
		 */
		NO_DIRECT_PROPERTY
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
@FunctionalInterface
public interface PlaceholdersResolver {
	/**
	 * No-op {@link PropertyResolver}.
	 */
	PlaceholdersResolver NONE = (value) -> value;
	/**
	 * Called to resolve any placeholders in the given value.
	 * @param value the source value
	 * @return a value with placeholders resolved
	 */
	Object resolvePlaceholders(Object value);
}
/*
package org.springframework.boot.context.properties.bind.handler;
/**
public class IgnoreErrorsBindHandler extends AbstractBindHandler {
	public IgnoreErrorsBindHandler() {
	}
	public IgnoreErrorsBindHandler(BindHandler parent) {
		super(parent);
	}
	@Override
	public Object onFailure(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Exception error)
			throws Exception {
		return (target.getValue() != null) ? target.getValue().get() : null;
	}
}
/*
package org.springframework.boot.context.properties.bind.handler;
/**
public class IgnoreTopLevelConverterNotFoundBindHandler extends AbstractBindHandler {
	/**
	 * Create a new {@link IgnoreTopLevelConverterNotFoundBindHandler} instance.
	 */
	public IgnoreTopLevelConverterNotFoundBindHandler() {
	}
	/**
	 * Create a new {@link IgnoreTopLevelConverterNotFoundBindHandler} instance with a
	 * specific parent.
	 * @param parent the parent handler
	 */
	public IgnoreTopLevelConverterNotFoundBindHandler(BindHandler parent) {
		super(parent);
	}
	@Override
	public Object onFailure(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Exception error)
			throws Exception {
		if (context.getDepth() == 0 && error instanceof ConverterNotFoundException) {
			return null;
		}
		throw error;
	}
}
/*
package org.springframework.boot.context.properties.bind.handler;
/**
public class NoUnboundElementsBindHandler extends AbstractBindHandler {
	private final Set<ConfigurationPropertyName> boundNames = new HashSet<>();
	private final Set<ConfigurationPropertyName> attemptedNames = new HashSet<>();
	private final Function<ConfigurationPropertySource, Boolean> filter;
	NoUnboundElementsBindHandler() {
		this(BindHandler.DEFAULT, (configurationPropertySource) -> true);
	}
	public NoUnboundElementsBindHandler(BindHandler parent) {
		this(parent, (configurationPropertySource) -> true);
	}
	public NoUnboundElementsBindHandler(BindHandler parent, Function<ConfigurationPropertySource, Boolean> filter) {
		super(parent);
		this.filter = filter;
	}
	@Override
	public <T> Bindable<T> onStart(ConfigurationPropertyName name, Bindable<T> target, BindContext context) {
		this.attemptedNames.add(name);
		return super.onStart(name, target, context);
	}
	@Override
	public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		this.boundNames.add(name);
		return super.onSuccess(name, target, context, result);
	}
	@Override
	public Object onFailure(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Exception error)
			throws Exception {
		if (error instanceof UnboundConfigurationPropertiesException) {
			throw error;
		}
		return super.onFailure(name, target, context, error);
	}
	@Override
	public void onFinish(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result)
			throws Exception {
		if (context.getDepth() == 0) {
			checkNoUnboundElements(name, context);
		}
	}
	private void checkNoUnboundElements(ConfigurationPropertyName name, BindContext context) {
		Set<ConfigurationProperty> unbound = new TreeSet<>();
		for (ConfigurationPropertySource source : context.getSources()) {
			if (source instanceof IterableConfigurationPropertySource && this.filter.apply(source)) {
				collectUnbound(name, unbound, (IterableConfigurationPropertySource) source);
			}
		}
		if (!unbound.isEmpty()) {
			throw new UnboundConfigurationPropertiesException(unbound);
		}
	}
	private void collectUnbound(ConfigurationPropertyName name, Set<ConfigurationProperty> unbound,
			IterableConfigurationPropertySource source) {
		IterableConfigurationPropertySource filtered = source.filter((candidate) -> isUnbound(name, candidate));
		for (ConfigurationPropertyName unboundName : filtered) {
			try {
				unbound.add(
						source.filter((candidate) -> isUnbound(name, candidate)).getConfigurationProperty(unboundName));
			}
			catch (Exception ex) {
				// Ignore
			}
		}
	}
	private boolean isUnbound(ConfigurationPropertyName name, ConfigurationPropertyName candidate) {
		if (name.isAncestorOf(candidate)) {
			return !this.boundNames.contains(candidate) && !isOverriddenCollectionElement(candidate);
		}
		return false;
	}
	private boolean isOverriddenCollectionElement(ConfigurationPropertyName candidate) {
		int lastIndex = candidate.getNumberOfElements() - 1;
		if (candidate.isLastElementIndexed()) {
			ConfigurationPropertyName propertyName = candidate.chop(lastIndex);
			return this.boundNames.contains(propertyName);
		}
		Indexed indexed = getIndexed(candidate);
		if (indexed != null) {
			String zeroethProperty = indexed.getName() + '[0]';
			if (this.boundNames.contains(ConfigurationPropertyName.of(zeroethProperty))) {
				String nestedZeroethProperty = zeroethProperty + '.' + indexed.getNestedPropertyName();
				return isCandidateValidPropertyName(nestedZeroethProperty);
			}
		}
		return false;
	}
	private boolean isCandidateValidPropertyName(String nestedZeroethProperty) {
		return this.attemptedNames.contains(ConfigurationPropertyName.of(nestedZeroethProperty));
	}
	private Indexed getIndexed(ConfigurationPropertyName candidate) {
		for (int i = 0; i < candidate.getNumberOfElements(); i++) {
			if (candidate.isNumericIndex(i)) {
				return new Indexed(candidate.chop(i).toString(),
						candidate.getElement(i + 1, ConfigurationPropertyName.Form.UNIFORM));
			}
		}
		return null;
	}
	private static final class Indexed {
		private final String name;
		private final String nestedPropertyName;
		private Indexed(String name, String nestedPropertyName) {
			this.name = name;
			this.nestedPropertyName = nestedPropertyName;
		}
		String getName() {
			return this.name;
		}
		String getNestedPropertyName() {
			return this.nestedPropertyName;
		}
	}
}
/*
/**
package org.springframework.boot.context.properties.bind.handler;
/*
package org.springframework.boot.context.properties.bind;
/**
class ValueObjectBinder implements DataObjectBinder {
	private static final Log logger = LogFactory.getLog(ValueObjectBinder.class);
	private final BindConstructorProvider constructorProvider;
	ValueObjectBinder(BindConstructorProvider constructorProvider) {
		this.constructorProvider = constructorProvider;
	}
	@Override
	public <T> T bind(ConfigurationPropertyName name, Bindable<T> target, Binder.Context context,
			DataObjectPropertyBinder propertyBinder) {
		ValueObject<T> valueObject = ValueObject.get(target, this.constructorProvider, context, Discoverer.LENIENT);
		if (valueObject == null) {
			return null;
		}
		context.pushConstructorBoundTypes(target.getType().resolve());
		List<ConstructorParameter> parameters = valueObject.getConstructorParameters();
		List<Object> args = new ArrayList<>(parameters.size());
		boolean bound = false;
		for (ConstructorParameter parameter : parameters) {
			Object arg = parameter.bind(propertyBinder);
			bound = bound || arg != null;
			arg = (arg != null) ? arg : getDefaultValue(context, parameter);
			args.add(arg);
		}
		context.clearConfigurationProperty();
		context.popConstructorBoundTypes();
		return bound ? valueObject.instantiate(args) : null;
	}
	@Override
	public <T> T create(Bindable<T> target, Binder.Context context) {
		ValueObject<T> valueObject = ValueObject.get(target, this.constructorProvider, context, Discoverer.LENIENT);
		if (valueObject == null) {
			return null;
		}
		List<ConstructorParameter> parameters = valueObject.getConstructorParameters();
		List<Object> args = new ArrayList<>(parameters.size());
		for (ConstructorParameter parameter : parameters) {
			args.add(getDefaultValue(context, parameter));
		}
		return valueObject.instantiate(args);
	}
	@Override
	public <T> void onUnableToCreateInstance(Bindable<T> target, Context context, RuntimeException exception) {
		try {
			ValueObject.get(target, this.constructorProvider, context, Discoverer.STRICT);
		}
		catch (Exception ex) {
			exception.addSuppressed(ex);
		}
	}
	private <T> T getDefaultValue(Binder.Context context, ConstructorParameter parameter) {
		ResolvableType type = parameter.getType();
		Annotation[] annotations = parameter.getAnnotations();
		for (Annotation annotation : annotations) {
			if (annotation instanceof DefaultValue defaultValueAnnotation) {
				String[] defaultValue = defaultValueAnnotation.value();
				if (defaultValue.length == 0) {
					return getNewDefaultValueInstanceIfPossible(context, type);
				}
				return convertDefaultValue(context.getConverter(), defaultValue, type, annotations);
			}
		}
		return null;
	}
	private <T> T convertDefaultValue(BindConverter converter, String[] defaultValue, ResolvableType type,
			Annotation[] annotations) {
		try {
			return converter.convert(defaultValue, type, annotations);
		}
		catch (ConversionException ex) {
			// Try again in case ArrayToObjectConverter is not in play
			if (defaultValue.length == 1) {
				return converter.convert(defaultValue[0], type, annotations);
			}
			throw ex;
		}
	}
	@SuppressWarnings('unchecked')
	private <T> T getNewDefaultValueInstanceIfPossible(Binder.Context context, ResolvableType type) {
		Class<T> resolved = (Class<T>) type.resolve();
		Assert.state(resolved == null || isEmptyDefaultValueAllowed(resolved),
				() -> 'Parameter of type ' + type + ' must have a non-empty default value.');
		if (resolved != null) {
			if (Optional.class == resolved) {
				return (T) Optional.empty();
			}
			if (Collection.class.isAssignableFrom(resolved)) {
				return (T) CollectionFactory.createCollection(resolved, 0);
			}
			if (EnumMap.class.isAssignableFrom(resolved)) {
				Class<?> keyType = type.asMap().resolveGeneric(0);
				return (T) CollectionFactory.createMap(resolved, keyType, 0);
			}
			if (Map.class.isAssignableFrom(resolved)) {
				return (T) CollectionFactory.createMap(resolved, 0);
			}
			if (resolved.isArray()) {
				return (T) Array.newInstance(resolved.getComponentType(), 0);
			}
		}
		T instance = create(Bindable.of(type), context);
		if (instance != null) {
			return instance;
		}
		return (resolved != null) ? BeanUtils.instantiateClass(resolved) : null;
	}
	private boolean isEmptyDefaultValueAllowed(Class<?> type) {
		return (Optional.class == type || isAggregate(type))
				|| !(type.isPrimitive() || type.isEnum() || type.getName().startsWith('java.lang'));
	}
	private boolean isAggregate(Class<?> type) {
		return type.isArray() || Map.class.isAssignableFrom(type) || Collection.class.isAssignableFrom(type);
	}
	/**
	 * The value object being bound.
	 *
	 * @param <T> the value object type
	 */
	private abstract static class ValueObject<T> {
		private final Constructor<T> constructor;
		protected ValueObject(Constructor<T> constructor) {
			this.constructor = constructor;
		}
		T instantiate(List<Object> args) {
			return BeanUtils.instantiateClass(this.constructor, args.toArray());
		}
		abstract List<ConstructorParameter> getConstructorParameters();
		@SuppressWarnings('unchecked')
		static <T> ValueObject<T> get(Bindable<T> bindable, BindConstructorProvider constructorProvider,
				Binder.Context context, ParameterNameDiscoverer parameterNameDiscoverer) {
			Class<T> type = (Class<T>) bindable.getType().resolve();
			if (type == null || type.isEnum() || Modifier.isAbstract(type.getModifiers())) {
				return null;
			}
			Constructor<?> bindConstructor = constructorProvider.getBindConstructor(bindable,
					context.isNestedConstructorBinding());
			if (bindConstructor == null) {
				return null;
			}
			if (KotlinDetector.isKotlinType(type)) {
				return KotlinValueObject.get((Constructor<T>) bindConstructor, bindable.getType(),
						parameterNameDiscoverer);
			}
			return DefaultValueObject.get(bindConstructor, bindable.getType(), parameterNameDiscoverer);
		}
	}
	/**
	 * A {@link ValueObject} implementation that is aware of Kotlin specific constructs.
	 */
	private static final class KotlinValueObject<T> extends ValueObject<T> {
		private static final Annotation[] ANNOTATION_ARRAY = new Annotation[0];
		private final List<ConstructorParameter> constructorParameters;
		private KotlinValueObject(Constructor<T> primaryConstructor, KFunction<T> kotlinConstructor,
				ResolvableType type) {
			super(primaryConstructor);
			this.constructorParameters = parseConstructorParameters(kotlinConstructor, type);
		}
		private List<ConstructorParameter> parseConstructorParameters(KFunction<T> kotlinConstructor,
				ResolvableType type) {
			List<KParameter> parameters = kotlinConstructor.getParameters();
			List<ConstructorParameter> result = new ArrayList<>(parameters.size());
			for (KParameter parameter : parameters) {
				String name = getParameterName(parameter);
				ResolvableType parameterType = ResolvableType
					.forType(ReflectJvmMapping.getJavaType(parameter.getType()), type);
				Annotation[] annotations = parameter.getAnnotations().toArray(ANNOTATION_ARRAY);
				result.add(new ConstructorParameter(name, parameterType, annotations));
			}
			return Collections.unmodifiableList(result);
		}
		private String getParameterName(KParameter parameter) {
			return MergedAnnotations.from(parameter, parameter.getAnnotations().toArray(ANNOTATION_ARRAY))
				.get(Name.class)
				.getValue(MergedAnnotation.VALUE, String.class)
				.orElseGet(parameter::getName);
		}
		@Override
		List<ConstructorParameter> getConstructorParameters() {
			return this.constructorParameters;
		}
		static <T> ValueObject<T> get(Constructor<T> bindConstructor, ResolvableType type,
				ParameterNameDiscoverer parameterNameDiscoverer) {
			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(bindConstructor);
			if (kotlinConstructor != null) {
				return new KotlinValueObject<>(bindConstructor, kotlinConstructor, type);
			}
			return DefaultValueObject.get(bindConstructor, type, parameterNameDiscoverer);
		}
	}
	/**
	 * A default {@link ValueObject} implementation that uses only standard Java
	 * reflection calls.
	 */
	private static final class DefaultValueObject<T> extends ValueObject<T> {
		private final List<ConstructorParameter> constructorParameters;
		private DefaultValueObject(Constructor<T> constructor, List<ConstructorParameter> constructorParameters) {
			super(constructor);
			this.constructorParameters = constructorParameters;
		}
		@Override
		List<ConstructorParameter> getConstructorParameters() {
			return this.constructorParameters;
		}
		@SuppressWarnings('unchecked')
		static <T> ValueObject<T> get(Constructor<?> bindConstructor, ResolvableType type,
				ParameterNameDiscoverer parameterNameDiscoverer) {
			String[] names = parameterNameDiscoverer.getParameterNames(bindConstructor);
			if (names == null) {
				return null;
			}
			List<ConstructorParameter> constructorParameters = parseConstructorParameters(bindConstructor, type, names);
			return new DefaultValueObject<>((Constructor<T>) bindConstructor, constructorParameters);
		}
		private static List<ConstructorParameter> parseConstructorParameters(Constructor<?> constructor,
				ResolvableType type, String[] names) {
			Parameter[] parameters = constructor.getParameters();
			List<ConstructorParameter> result = new ArrayList<>(parameters.length);
			for (int i = 0; i < parameters.length; i++) {
				String name = MergedAnnotations.from(parameters[i])
					.get(Name.class)
					.getValue(MergedAnnotation.VALUE, String.class)
					.orElse(names[i]);
				ResolvableType parameterType = ResolvableType.forMethodParameter(new MethodParameter(constructor, i),
						type);
				Annotation[] annotations = parameters[i].getDeclaredAnnotations();
				result.add(new ConstructorParameter(name, parameterType, annotations));
			}
			return Collections.unmodifiableList(result);
		}
	}
	/**
	 * A constructor parameter being bound.
	 */
	private static class ConstructorParameter {
		private final String name;
		private final ResolvableType type;
		private final Annotation[] annotations;
		ConstructorParameter(String name, ResolvableType type, Annotation[] annotations) {
			this.name = DataObjectPropertyName.toDashedForm(name);
			this.type = type;
			this.annotations = annotations;
		}
		Object bind(DataObjectPropertyBinder propertyBinder) {
			return propertyBinder.bindProperty(this.name, Bindable.of(this.type).withAnnotations(this.annotations));
		}
		Annotation[] getAnnotations() {
			return this.annotations;
		}
		ResolvableType getType() {
			return this.type;
		}
	}
	/**
	 * {@link ParameterNameDiscoverer} used for value data object binding.
	 */
	static final class Discoverer implements ParameterNameDiscoverer {
		private static final ParameterNameDiscoverer DEFAULT_DELEGATE = new DefaultParameterNameDiscoverer();
		private static final ParameterNameDiscoverer LENIENT = new Discoverer(DEFAULT_DELEGATE, (message) -> {
		});
		private static final ParameterNameDiscoverer STRICT = new Discoverer(DEFAULT_DELEGATE, (message) -> {
			throw new IllegalStateException(message.toString());
		});
		private final ParameterNameDiscoverer delegate;
		private final Consumer<LogMessage> noParameterNamesHandler;
		private Discoverer(ParameterNameDiscoverer delegate, Consumer<LogMessage> noParameterNamesHandler) {
			this.delegate = delegate;
			this.noParameterNamesHandler = noParameterNamesHandler;
		}
		@Override
		public String[] getParameterNames(Method method) {
			throw new UnsupportedOperationException();
		}
		@Override
		public String[] getParameterNames(Constructor<?> constructor) {
			String[] names = this.delegate.getParameterNames(constructor);
			if (names != null) {
				return names;
			}
			LogMessage message = LogMessage.format(
					'Unable to use value object binding with constructor [%s] as parameter names cannot be discovered. '
							+ 'Ensure that the compiler uses the "-parameters" flag',
					constructor);
			this.noParameterNamesHandler.accept(message);
			logger.debug(message);
			return null;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class JavaBeanBinder implements DataObjectBinder {
	static final JavaBeanBinder INSTANCE = new JavaBeanBinder();
	@Override
	public <T> T bind(ConfigurationPropertyName name, Bindable<T> target, Context context,
			DataObjectPropertyBinder propertyBinder) {
		boolean hasKnownBindableProperties = target.getValue() != null && hasKnownBindableProperties(name, context);
		Bean<T> bean = Bean.get(target, hasKnownBindableProperties);
		if (bean == null) {
			return null;
		}
		BeanSupplier<T> beanSupplier = bean.getSupplier(target);
		boolean bound = bind(propertyBinder, bean, beanSupplier, context);
		return (bound ? beanSupplier.get() : null);
	}
	@Override
	@SuppressWarnings('unchecked')
	public <T> T create(Bindable<T> target, Context context) {
		Class<T> type = (Class<T>) target.getType().resolve();
		return (type != null) ? BeanUtils.instantiateClass(type) : null;
	}
	private boolean hasKnownBindableProperties(ConfigurationPropertyName name, Context context) {
		for (ConfigurationPropertySource source : context.getSources()) {
			if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {
				return true;
			}
		}
		return false;
	}
	private <T> boolean bind(DataObjectPropertyBinder propertyBinder, Bean<T> bean, BeanSupplier<T> beanSupplier,
			Context context) {
		boolean bound = false;
		for (BeanProperty beanProperty : bean.getProperties().values()) {
			bound |= bind(beanSupplier, propertyBinder, beanProperty);
			context.clearConfigurationProperty();
		}
		return bound;
	}
	private <T> boolean bind(BeanSupplier<T> beanSupplier, DataObjectPropertyBinder propertyBinder,
			BeanProperty property) {
		String propertyName = determinePropertyName(property);
		ResolvableType type = property.getType();
		Supplier<Object> value = property.getValue(beanSupplier);
		Annotation[] annotations = property.getAnnotations();
		Object bound = propertyBinder.bindProperty(propertyName,
				Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations));
		if (bound == null) {
			return false;
		}
		if (property.isSettable()) {
			property.setValue(beanSupplier, bound);
		}
		else if (value == null || !bound.equals(value.get())) {
			throw new IllegalStateException('No setter found for property: ' + property.getName());
		}
		return true;
	}
	private String determinePropertyName(BeanProperty property) {
		return Arrays.stream((property.getAnnotations() != null) ? property.getAnnotations() : new Annotation[0])
			.filter((annotation) -> annotation.annotationType() == Name.class)
			.findFirst()
			.map(Name.class::cast)
			.map(Name::value)
			.orElse(property.getName());
	}
	/**
	 * The properties of a bean that may be bound.
	 */
	static class BeanProperties {
		private final Map<String, BeanProperty> properties = new LinkedHashMap<>();
		private final ResolvableType type;
		private final Class<?> resolvedType;
		BeanProperties(ResolvableType type, Class<?> resolvedType) {
			this.type = type;
			this.resolvedType = resolvedType;
			addProperties(resolvedType);
		}
		private void addProperties(Class<?> type) {
			while (type != null && !Object.class.equals(type)) {
				Method[] declaredMethods = getSorted(type, this::getDeclaredMethods, Method::getName);
				Field[] declaredFields = getSorted(type, Class::getDeclaredFields, Field::getName);
				addProperties(declaredMethods, declaredFields);
				type = type.getSuperclass();
			}
		}
		private Method[] getDeclaredMethods(Class<?> type) {
			Method[] methods = type.getDeclaredMethods();
			Set<Method> result = new LinkedHashSet<>(methods.length);
			for (Method method : methods) {
				result.add(BridgeMethodResolver.findBridgedMethod(method));
			}
			return result.toArray(new Method[0]);
		}
		private <S, E> E[] getSorted(S source, Function<S, E[]> elements, Function<E, String> name) {
			E[] result = elements.apply(source);
			Arrays.sort(result, Comparator.comparing(name));
			return result;
		}
		protected void addProperties(Method[] declaredMethods, Field[] declaredFields) {
			for (int i = 0; i < declaredMethods.length; i++) {
				if (!isCandidate(declaredMethods[i])) {
					declaredMethods[i] = null;
				}
			}
			for (Method method : declaredMethods) {
				addMethodIfPossible(method, 'is', 0, BeanProperty::addGetter);
			}
			for (Method method : declaredMethods) {
				addMethodIfPossible(method, 'get', 0, BeanProperty::addGetter);
			}
			for (Method method : declaredMethods) {
				addMethodIfPossible(method, 'set', 1, BeanProperty::addSetter);
			}
			for (Field field : declaredFields) {
				addField(field);
			}
		}
		private boolean isCandidate(Method method) {
			int modifiers = method.getModifiers();
			return !Modifier.isPrivate(modifiers) && !Modifier.isProtected(modifiers) && !Modifier.isAbstract(modifiers)
					&& !Modifier.isStatic(modifiers) && !method.isBridge()
					&& !Object.class.equals(method.getDeclaringClass())
					&& !Class.class.equals(method.getDeclaringClass()) && method.getName().indexOf("$") == -1;
		}
		private void addMethodIfPossible(Method method, String prefix, int parameterCount,
				BiConsumer<BeanProperty, Method> consumer) {
			if (method != null && method.getParameterCount() == parameterCount && method.getName().startsWith(prefix)
					&& method.getName().length() > prefix.length()) {
				String propertyName = Introspector.decapitalize(method.getName().substring(prefix.length()));
				consumer.accept(this.properties.computeIfAbsent(propertyName, this::getBeanProperty), method);
			}
		}
		private BeanProperty getBeanProperty(String name) {
			return new BeanProperty(name, this.type);
		}
		private void addField(Field field) {
			BeanProperty property = this.properties.get(field.getName());
			if (property != null) {
				property.addField(field);
			}
		}
		protected final ResolvableType getType() {
			return this.type;
		}
		protected final Class<?> getResolvedType() {
			return this.resolvedType;
		}
		final Map<String, BeanProperty> getProperties() {
			return this.properties;
		}
		static BeanProperties of(Bindable<?> bindable) {
			ResolvableType type = bindable.getType();
			Class<?> resolvedType = type.resolve(Object.class);
			return new BeanProperties(type, resolvedType);
		}
	}
	/**
	 * The bean being bound.
	 *
	 * @param <T> the bean type
	 */
	static class Bean<T> extends BeanProperties {
		private static Bean<?> cached;
		Bean(ResolvableType type, Class<?> resolvedType) {
			super(type, resolvedType);
		}
		@SuppressWarnings('unchecked')
		BeanSupplier<T> getSupplier(Bindable<T> target) {
			return new BeanSupplier<>(() -> {
				T instance = null;
				if (target.getValue() != null) {
					instance = target.getValue().get();
				}
				if (instance == null) {
					instance = (T) BeanUtils.instantiateClass(getResolvedType());
				}
				return instance;
			});
		}
		@SuppressWarnings('unchecked')
		static <T> Bean<T> get(Bindable<T> bindable, boolean canCallGetValue) {
			ResolvableType type = bindable.getType();
			Class<?> resolvedType = type.resolve(Object.class);
			Supplier<T> value = bindable.getValue();
			T instance = null;
			if (canCallGetValue && value != null) {
				instance = value.get();
				resolvedType = (instance != null) ? instance.getClass() : resolvedType;
			}
			if (instance == null && !isInstantiable(resolvedType)) {
				return null;
			}
			Bean<?> bean = Bean.cached;
			if (bean == null || !bean.isOfType(type, resolvedType)) {
				bean = new Bean<>(type, resolvedType);
				cached = bean;
			}
			return (Bean<T>) bean;
		}
		private static boolean isInstantiable(Class<?> type) {
			if (type.isInterface()) {
				return false;
			}
			try {
				type.getDeclaredConstructor();
				return true;
			}
			catch (Exception ex) {
				return false;
			}
		}
		private boolean isOfType(ResolvableType type, Class<?> resolvedType) {
			if (getType().hasGenerics() || type.hasGenerics()) {
				return getType().equals(type);
			}
			return getResolvedType() != null && getResolvedType().equals(resolvedType);
		}
	}
	private static class BeanSupplier<T> implements Supplier<T> {
		private final Supplier<T> factory;
		private T instance;
		BeanSupplier(Supplier<T> factory) {
			this.factory = factory;
		}
		@Override
		public T get() {
			if (this.instance == null) {
				this.instance = this.factory.get();
			}
			return this.instance;
		}
	}
	/**
	 * A bean property being bound.
	 */
	static class BeanProperty {
		private final String name;
		private final ResolvableType declaringClassType;
		private Method getter;
		private Method setter;
		private Field field;
		BeanProperty(String name, ResolvableType declaringClassType) {
			this.name = DataObjectPropertyName.toDashedForm(name);
			this.declaringClassType = declaringClassType;
		}
		void addGetter(Method getter) {
			if (this.getter == null || this.getter.getName().startsWith('is')) {
				this.getter = getter;
			}
		}
		void addSetter(Method setter) {
			if (this.setter == null || isBetterSetter(setter)) {
				this.setter = setter;
			}
		}
		private boolean isBetterSetter(Method setter) {
			return this.getter != null && this.getter.getReturnType().equals(setter.getParameterTypes()[0]);
		}
		void addField(Field field) {
			if (this.field == null) {
				this.field = field;
			}
		}
		String getName() {
			return this.name;
		}
		ResolvableType getType() {
			if (this.setter != null) {
				MethodParameter methodParameter = new MethodParameter(this.setter, 0);
				return ResolvableType.forMethodParameter(methodParameter, this.declaringClassType);
			}
			MethodParameter methodParameter = new MethodParameter(this.getter, -1);
			return ResolvableType.forMethodParameter(methodParameter, this.declaringClassType);
		}
		Annotation[] getAnnotations() {
			try {
				return (this.field != null) ? this.field.getDeclaredAnnotations() : null;
			}
			catch (Exception ex) {
				return null;
			}
		}
		Supplier<Object> getValue(Supplier<?> instance) {
			if (this.getter == null) {
				return null;
			}
			return () -> {
				try {
					this.getter.setAccessible(true);
					return this.getter.invoke(instance.get());
				}
				catch (Exception ex) {
					if (isUninitializedKotlinProperty(ex)) {
						return null;
					}
					throw new IllegalStateException('Unable to get value for property ' + this.name, ex);
				}
			};
		}
		private boolean isUninitializedKotlinProperty(Exception ex) {
			return (ex instanceof InvocationTargetException invocationTargetException)
					&& 'kotlin.UninitializedPropertyAccessException'
						.equals(invocationTargetException.getTargetException().getClass().getName());
		}
		boolean isSettable() {
			return this.setter != null;
		}
		void setValue(Supplier<?> instance, Object value) {
			try {
				this.setter.setAccessible(true);
				this.setter.invoke(instance.get(), value);
			}
			catch (Exception ex) {
				throw new IllegalStateException('Unable to set value for property ' + this.name, ex);
			}
		}
		Method getGetter() {
			return this.getter;
		}
		Method getSetter() {
			return this.setter;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
final class BindConverter {
	private static BindConverter sharedInstance;
	private final List<ConversionService> delegates;
	private BindConverter(List<ConversionService> conversionServices,
			Consumer<PropertyEditorRegistry> propertyEditorInitializer) {
		List<ConversionService> delegates = new ArrayList<>();
		delegates.add(new TypeConverterConversionService(propertyEditorInitializer));
		boolean hasApplication = false;
		if (!CollectionUtils.isEmpty(conversionServices)) {
			for (ConversionService conversionService : conversionServices) {
				delegates.add(conversionService);
				hasApplication = hasApplication || conversionService instanceof ApplicationConversionService;
			}
		}
		if (!hasApplication) {
			delegates.add(ApplicationConversionService.getSharedInstance());
		}
		this.delegates = Collections.unmodifiableList(delegates);
	}
	boolean canConvert(Object source, ResolvableType targetType, Annotation... targetAnnotations) {
		return canConvert(TypeDescriptor.forObject(source),
				new ResolvableTypeDescriptor(targetType, targetAnnotations));
	}
	private boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {
		for (ConversionService service : this.delegates) {
			if (service.canConvert(sourceType, targetType)) {
				return true;
			}
		}
		return false;
	}
	<T> T convert(Object source, Bindable<T> target) {
		return convert(source, target.getType(), target.getAnnotations());
	}
	@SuppressWarnings('unchecked')
	<T> T convert(Object source, ResolvableType targetType, Annotation... targetAnnotations) {
		if (source == null) {
			return null;
		}
		return (T) convert(source, TypeDescriptor.forObject(source),
				new ResolvableTypeDescriptor(targetType, targetAnnotations));
	}
	private Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
		ConversionException failure = null;
		for (ConversionService delegate : this.delegates) {
			try {
				if (delegate.canConvert(sourceType, targetType)) {
					return delegate.convert(source, sourceType, targetType);
				}
			}
			catch (ConversionException ex) {
				if (failure == null && ex instanceof ConversionFailedException) {
					failure = ex;
				}
			}
		}
		throw (failure != null) ? failure : new ConverterNotFoundException(sourceType, targetType);
	}
	static BindConverter get(List<ConversionService> conversionServices,
			Consumer<PropertyEditorRegistry> propertyEditorInitializer) {
		boolean sharedApplicationConversionService = (conversionServices == null) || (conversionServices.size() == 1
				&& conversionServices.get(0) == ApplicationConversionService.getSharedInstance());
		if (propertyEditorInitializer == null && sharedApplicationConversionService) {
			return getSharedInstance();
		}
		return new BindConverter(conversionServices, propertyEditorInitializer);
	}
	private static BindConverter getSharedInstance() {
		if (sharedInstance == null) {
			sharedInstance = new BindConverter(null, null);
		}
		return sharedInstance;
	}
	/**
	 * A {@link TypeDescriptor} backed by a {@link ResolvableType}.
	 */
	private static class ResolvableTypeDescriptor extends TypeDescriptor {
		ResolvableTypeDescriptor(ResolvableType resolvableType, Annotation[] annotations) {
			super(resolvableType, null, annotations);
		}
	}
	/**
	 * A {@link ConversionService} implementation that delegates to a
	 * {@link SimpleTypeConverter}. Allows {@link PropertyEditor} based conversion for
	 * simple types, arrays and collections.
	 */
	private static class TypeConverterConversionService extends GenericConversionService {
		TypeConverterConversionService(Consumer<PropertyEditorRegistry> initializer) {
			ApplicationConversionService.addDelimitedStringConverters(this);
			addConverter(new TypeConverterConverter(initializer));
		}
		@Override
		public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {
			// Prefer conversion service to handle things like String to char[].
			if (targetType.isArray() && targetType.getElementTypeDescriptor().isPrimitive()) {
				return false;
			}
			return super.canConvert(sourceType, targetType);
		}
	}
	/**
	 * {@link ConditionalGenericConverter} that delegates to {@link SimpleTypeConverter}.
	 */
	private static class TypeConverterConverter implements ConditionalGenericConverter {
		private static final Set<Class<?>> EXCLUDED_EDITORS;
		static {
			Set<Class<?>> excluded = new HashSet<>();
			excluded.add(CustomNumberEditor.class);
			excluded.add(CustomBooleanEditor.class);
			excluded.add(FileEditor.class);
			EXCLUDED_EDITORS = Collections.unmodifiableSet(excluded);
		}
		private final Consumer<PropertyEditorRegistry> initializer;
		// SimpleTypeConverter is not thread-safe to use for conversion but we can use it
		// in a thread-safe way to check if conversion is possible.
		private final SimpleTypeConverter matchesOnlyTypeConverter;
		TypeConverterConverter(Consumer<PropertyEditorRegistry> initializer) {
			this.initializer = initializer;
			this.matchesOnlyTypeConverter = createTypeConverter();
		}
		@Override
		public Set<ConvertiblePair> getConvertibleTypes() {
			return Set.of(new ConvertiblePair(String.class, Object.class),
					new ConvertiblePair(String.class, Resource[].class),
					new ConvertiblePair(String.class, Collection.class));
		}
		@Override
		public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
			Class<?> type = targetType.getType();
			if (type == null || type == Object.class || Map.class.isAssignableFrom(type)) {
				return false;
			}
			if (Collection.class.isAssignableFrom(type)) {
				TypeDescriptor elementType = targetType.getElementTypeDescriptor();
				if (elementType == null || (!Resource.class.isAssignableFrom(elementType.getType()))) {
					return false;
				}
			}
			PropertyEditor editor = this.matchesOnlyTypeConverter.getDefaultEditor(type);
			if (editor == null) {
				editor = this.matchesOnlyTypeConverter.findCustomEditor(type, null);
			}
			if (editor == null && String.class != type) {
				editor = BeanUtils.findEditorByConvention(type);
			}
			return (editor != null && !EXCLUDED_EDITORS.contains(editor.getClass()));
		}
		@Override
		public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
			return createTypeConverter().convertIfNecessary(source, targetType.getType(), targetType);
		}
		private SimpleTypeConverter createTypeConverter() {
			SimpleTypeConverter typeConverter = new SimpleTypeConverter();
			if (this.initializer != null) {
				this.initializer.accept(typeConverter);
			}
			return typeConverter;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class DefaultBindConstructorProvider implements BindConstructorProvider {
	@Override
	public Constructor<?> getBindConstructor(Bindable<?> bindable, boolean isNestedConstructorBinding) {
		Constructors constructors = Constructors.getConstructors(bindable.getType().resolve(),
				isNestedConstructorBinding);
		if (constructors.getBind() != null && constructors.isDeducedBindConstructor()
				&& !constructors.isImmutableType()) {
			if (bindable.getValue() != null && bindable.getValue().get() != null) {
				return null;
			}
		}
		return constructors.getBind();
	}
	@Override
	public Constructor<?> getBindConstructor(Class<?> type, boolean isNestedConstructorBinding) {
		Constructors constructors = Constructors.getConstructors(type, isNestedConstructorBinding);
		return constructors.getBind();
	}
	/**
	 * Data holder for autowired and bind constructors.
	 */
	static final class Constructors {
		private static final Constructors NONE = new Constructors(false, null, false, false);
		private final boolean hasAutowired;
		private final Constructor<?> bind;
		private final boolean deducedBindConstructor;
		private final boolean immutableType;
		private Constructors(boolean hasAutowired, Constructor<?> bind, boolean deducedBindConstructor,
				boolean immutableType) {
			this.hasAutowired = hasAutowired;
			this.bind = bind;
			this.deducedBindConstructor = deducedBindConstructor;
			this.immutableType = immutableType;
		}
		boolean hasAutowired() {
			return this.hasAutowired;
		}
		Constructor<?> getBind() {
			return this.bind;
		}
		boolean isDeducedBindConstructor() {
			return this.deducedBindConstructor;
		}
		boolean isImmutableType() {
			return this.immutableType;
		}
		static Constructors getConstructors(Class<?> type, boolean isNestedConstructorBinding) {
			if (type == null) {
				return NONE;
			}
			boolean hasAutowiredConstructor = isAutowiredPresent(type);
			Constructor<?>[] candidates = getCandidateConstructors(type);
			MergedAnnotations[] candidateAnnotations = getAnnotations(candidates);
			boolean deducedBindConstructor = false;
			boolean immutableType = type.isRecord();
			Constructor<?> bind = getConstructorBindingAnnotated(type, candidates, candidateAnnotations);
			if (bind == null && !hasAutowiredConstructor) {
				bind = deduceBindConstructor(type, candidates);
				deducedBindConstructor = bind != null;
			}
			if (bind == null && !hasAutowiredConstructor && isKotlinType(type)) {
				bind = deduceKotlinBindConstructor(type);
				deducedBindConstructor = bind != null;
			}
			if (bind != null || isNestedConstructorBinding) {
				Assert.state(!hasAutowiredConstructor,
						() -> type.getName() + ' declares @ConstructorBinding and @Autowired constructor');
			}
			return new Constructors(hasAutowiredConstructor, bind, deducedBindConstructor, immutableType);
		}
		private static boolean isAutowiredPresent(Class<?> type) {
			if (Stream.of(type.getDeclaredConstructors())
				.map(MergedAnnotations::from)
				.anyMatch((annotations) -> annotations.isPresent(Autowired.class))) {
				return true;
			}
			Class<?> userClass = ClassUtils.getUserClass(type);
			return (userClass != type) && isAutowiredPresent(userClass);
		}
		private static Constructor<?>[] getCandidateConstructors(Class<?> type) {
			if (isInnerClass(type)) {
				return new Constructor<?>[0];
			}
			return Arrays.stream(type.getDeclaredConstructors())
				.filter(Constructors::isNonSynthetic)
				.toArray(Constructor[]::new);
		}
		private static boolean isInnerClass(Class<?> type) {
			try {
				return type.getDeclaredField('this$0').isSynthetic();
			}
			catch (NoSuchFieldException ex) {
				return false;
			}
		}
		private static boolean isNonSynthetic(Constructor<?> constructor) {
			return !constructor.isSynthetic();
		}
		private static MergedAnnotations[] getAnnotations(Constructor<?>[] candidates) {
			MergedAnnotations[] candidateAnnotations = new MergedAnnotations[candidates.length];
			for (int i = 0; i < candidates.length; i++) {
				candidateAnnotations[i] = MergedAnnotations.from(candidates[i], SearchStrategy.SUPERCLASS);
			}
			return candidateAnnotations;
		}
		private static Constructor<?> getConstructorBindingAnnotated(Class<?> type, Constructor<?>[] candidates,
				MergedAnnotations[] mergedAnnotations) {
			Constructor<?> result = null;
			for (int i = 0; i < candidates.length; i++) {
				if (mergedAnnotations[i].isPresent(ConstructorBinding.class)) {
					Assert.state(candidates[i].getParameterCount() > 0,
							() -> type.getName() + ' declares @ConstructorBinding on a no-args constructor');
					Assert.state(result == null,
							() -> type.getName() + ' has more than one @ConstructorBinding constructor');
					result = candidates[i];
				}
			}
			return result;
		}
		private static Constructor<?> deduceBindConstructor(Class<?> type, Constructor<?>[] candidates) {
			if (candidates.length == 1 && candidates[0].getParameterCount() > 0) {
				if (type.isMemberClass() && Modifier.isPrivate(candidates[0].getModifiers())) {
					return null;
				}
				return candidates[0];
			}
			Constructor<?> result = null;
			for (Constructor<?> candidate : candidates) {
				if (!Modifier.isPrivate(candidate.getModifiers())) {
					if (result != null) {
						return null;
					}
					result = candidate;
				}
			}
			return (result != null && result.getParameterCount() > 0) ? result : null;
		}
		private static boolean isKotlinType(Class<?> type) {
			return KotlinDetector.isKotlinPresent() && KotlinDetector.isKotlinType(type);
		}
		private static Constructor<?> deduceKotlinBindConstructor(Class<?> type) {
			Constructor<?> primaryConstructor = BeanUtils.findPrimaryConstructor(type);
			if (primaryConstructor != null && primaryConstructor.getParameterCount() > 0) {
				return primaryConstructor;
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
@Documented
public @interface Nested {
}
/*
package org.springframework.boot.context.properties.bind;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.PARAMETER, ElementType.RECORD_COMPONENT })
@Documented
public @interface DefaultValue {
	/**
	 * The default value of the property. Can be an array of values for collection or
	 * array-based properties.
	 * @return the default value of the property.
	 */
	String[] value() default {};
}
/*
package org.springframework.boot.context.properties.bind;
/**
@FunctionalInterface
interface AggregateElementBinder {
	/**
	 * Bind the given name to a target bindable.
	 * @param name the name to bind
	 * @param target the target bindable
	 * @return a bound object or {@code null}
	 */
	default Object bind(ConfigurationPropertyName name, Bindable<?> target) {
		return bind(name, target, null);
	}
	/**
	 * Bind the given name to a target bindable using optionally limited to a single
	 * source.
	 * @param name the name to bind
	 * @param target the target bindable
	 * @param source the source of the elements or {@code null} to use all sources
	 * @return a bound object or {@code null}
	 */
	Object bind(ConfigurationPropertyName name, Bindable<?> target, ConfigurationPropertySource source);
}
/*
package org.springframework.boot.context.properties.bind;
/**
class ArrayBinder extends IndexedElementsBinder<Object> {
	ArrayBinder(Context context) {
		super(context);
	}
	@Override
	protected Object bindAggregate(ConfigurationPropertyName name, Bindable<?> target,
			AggregateElementBinder elementBinder) {
		IndexedCollectionSupplier result = new IndexedCollectionSupplier(ArrayList::new);
		ResolvableType aggregateType = target.getType();
		ResolvableType elementType = target.getType().getComponentType();
		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);
		if (result.wasSupplied()) {
			List<Object> list = (List<Object>) result.get();
			Object array = Array.newInstance(elementType.resolve(), list.size());
			for (int i = 0; i < list.size(); i++) {
				Array.set(array, i, list.get(i));
			}
			return array;
		}
		return null;
	}
	@Override
	protected Object merge(Supplier<Object> existing, Object additional) {
		return additional;
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
@Target({ ElementType.CONSTRUCTOR, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ConstructorBinding {
}
/*
package org.springframework.boot.context.properties.bind;
/**
class CollectionBinder extends IndexedElementsBinder<Collection<Object>> {
	CollectionBinder(Context context) {
		super(context);
	}
	@Override
	protected Object bindAggregate(ConfigurationPropertyName name, Bindable<?> target,
			AggregateElementBinder elementBinder) {
		ResolvableType aggregateType = ResolvableType.forClassWithGenerics(List.class,
				target.getType().asCollection().getGenerics());
		ResolvableType elementType = target.getType().asCollection().getGeneric();
		IndexedCollectionSupplier result = new IndexedCollectionSupplier(
				() -> CollectionFactory.createCollection(List.class, elementType.resolve(), 0));
		bindIndexed(name, target, elementBinder, aggregateType, elementType, result);
		if (result.wasSupplied()) {
			return result.get();
		}
		return null;
	}
	@Override
	protected Collection<Object> merge(Supplier<Collection<Object>> existing, Collection<Object> additional) {
		Collection<Object> existingCollection = getExistingIfPossible(existing);
		if (existingCollection == null) {
			return additional;
		}
		try {
			existingCollection.clear();
			existingCollection.addAll(additional);
			return copyIfPossible(existingCollection);
		}
		catch (UnsupportedOperationException ex) {
			return createNewCollection(additional);
		}
	}
	private Collection<Object> getExistingIfPossible(Supplier<Collection<Object>> existing) {
		try {
			return existing.get();
		}
		catch (Exception ex) {
			return null;
		}
	}
	private Collection<Object> copyIfPossible(Collection<Object> collection) {
		try {
			return createNewCollection(collection);
		}
		catch (Exception ex) {
			return collection;
		}
	}
	private Collection<Object> createNewCollection(Collection<Object> collection) {
		Collection<Object> result = CollectionFactory.createCollection(collection.getClass(), collection.size());
		result.addAll(collection);
		return result;
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public class BindException extends RuntimeException implements OriginProvider {
	private final Bindable<?> target;
	private final ConfigurationProperty property;
	private final ConfigurationPropertyName name;
	BindException(ConfigurationPropertyName name, Bindable<?> target, ConfigurationProperty property, Throwable cause) {
		super(buildMessage(name, target), cause);
		this.name = name;
		this.target = target;
		this.property = property;
	}
	/**
	 * Return the name of the configuration property being bound.
	 * @return the configuration property name
	 */
	public ConfigurationPropertyName getName() {
		return this.name;
	}
	/**
	 * Return the target being bound.
	 * @return the bind target
	 */
	public Bindable<?> getTarget() {
		return this.target;
	}
	/**
	 * Return the configuration property name of the item that was being bound.
	 * @return the configuration property name
	 */
	public ConfigurationProperty getProperty() {
		return this.property;
	}
	@Override
	public Origin getOrigin() {
		return Origin.from(this.name);
	}
	private static String buildMessage(ConfigurationPropertyName name, Bindable<?> target) {
		StringBuilder message = new StringBuilder();
		message.append('Failed to bind properties');
		message.append((name != null) ? ' under "' + name + '"' : '');
		message.append(' to ').append(target.getType());
		return message.toString();
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public interface BindContext {
	/**
	 * Return the source binder that is performing the bind operation.
	 * @return the source binder
	 */
	Binder getBinder();
	/**
	 * Return the current depth of the binding. Root binding starts with a depth of
	 * {@code 0}. Each subsequent property binding increases the depth by {@code 1}.
	 * @return the depth of the current binding
	 */
	int getDepth();
	/**
	 * Return an {@link Iterable} of the {@link ConfigurationPropertySource sources} being
	 * used by the {@link Binder}.
	 * @return the sources
	 */
	Iterable<ConfigurationPropertySource> getSources();
	/**
	 * Return the {@link ConfigurationProperty} actually being bound or {@code null} if
	 * the property has not yet been determined.
	 * @return the configuration property (may be {@code null}).
	 */
	ConfigurationProperty getConfigurationProperty();
}
/*
/**
package org.springframework.boot.context.properties.bind;
/*
package org.springframework.boot.context.properties.bind;
/**
public class BoundPropertiesTrackingBindHandler extends AbstractBindHandler {
	private final Consumer<ConfigurationProperty> consumer;
	public BoundPropertiesTrackingBindHandler(Consumer<ConfigurationProperty> consumer) {
		Assert.notNull(consumer, 'Consumer must not be null');
		this.consumer = consumer;
	}
	@Override
	public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {
		if (context.getConfigurationProperty() != null && name.equals(context.getConfigurationProperty().getName())) {
			this.consumer.accept(context.getConfigurationProperty());
		}
		return super.onSuccess(name, target, context, result);
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class MapBinder extends AggregateBinder<Map<Object, Object>> {
	private static final Bindable<Map<String, String>> STRING_STRING_MAP = Bindable.mapOf(String.class, String.class);
	MapBinder(Context context) {
		super(context);
	}
	@Override
	protected boolean isAllowRecursiveBinding(ConfigurationPropertySource source) {
		return true;
	}
	@Override
	protected Object bindAggregate(ConfigurationPropertyName name, Bindable<?> target,
			AggregateElementBinder elementBinder) {
		Bindable<?> resolvedTarget = resolveTarget(target);
		boolean hasDescendants = hasDescendants(name);
		if (!hasDescendants && !ConfigurationPropertyName.EMPTY.equals(name)) {
			for (ConfigurationPropertySource source : getContext().getSources()) {
				ConfigurationProperty property = source.getConfigurationProperty(name);
				if (property != null) {
					getContext().setConfigurationProperty(property);
					Object result = getContext().getPlaceholdersResolver().resolvePlaceholders(property.getValue());
					return getContext().getConverter().convert(result, target);
				}
			}
		}
		Map<Object, Object> map = createMap(target);
		for (ConfigurationPropertySource source : getContext().getSources()) {
			if (!ConfigurationPropertyName.EMPTY.equals(name)) {
				source = source.filter(name::isAncestorOf);
			}
			new EntryBinder(name, resolvedTarget, elementBinder).bindEntries(source, map);
		}
		return map.isEmpty() ? null : map;
	}
	private Map<Object, Object> createMap(Bindable<?> target) {
		Class<?> mapType = (target.getValue() != null) ? Map.class : target.getType().resolve(Object.class);
		if (EnumMap.class.isAssignableFrom(mapType)) {
			Class<?> keyType = target.getType().asMap().resolveGeneric(0);
			return CollectionFactory.createMap(mapType, keyType, 0);
		}
		return CollectionFactory.createMap(mapType, 0);
	}
	private boolean hasDescendants(ConfigurationPropertyName name) {
		for (ConfigurationPropertySource source : getContext().getSources()) {
			if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {
				return true;
			}
		}
		return false;
	}
	private Bindable<?> resolveTarget(Bindable<?> target) {
		Class<?> type = target.getType().resolve(Object.class);
		if (Properties.class.isAssignableFrom(type)) {
			return STRING_STRING_MAP;
		}
		return target;
	}
	@Override
	protected Map<Object, Object> merge(Supplier<Map<Object, Object>> existing, Map<Object, Object> additional) {
		Map<Object, Object> existingMap = getExistingIfPossible(existing);
		if (existingMap == null) {
			return additional;
		}
		try {
			existingMap.putAll(additional);
			return copyIfPossible(existingMap);
		}
		catch (UnsupportedOperationException ex) {
			Map<Object, Object> result = createNewMap(additional.getClass(), existingMap);
			result.putAll(additional);
			return result;
		}
	}
	private Map<Object, Object> getExistingIfPossible(Supplier<Map<Object, Object>> existing) {
		try {
			return existing.get();
		}
		catch (Exception ex) {
			return null;
		}
	}
	private Map<Object, Object> copyIfPossible(Map<Object, Object> map) {
		try {
			return createNewMap(map.getClass(), map);
		}
		catch (Exception ex) {
			return map;
		}
	}
	private Map<Object, Object> createNewMap(Class<?> mapClass, Map<Object, Object> map) {
		Map<Object, Object> result = CollectionFactory.createMap(mapClass, map.size());
		result.putAll(map);
		return result;
	}
	private class EntryBinder {
		private final ConfigurationPropertyName root;
		private final AggregateElementBinder elementBinder;
		private final ResolvableType mapType;
		private final ResolvableType keyType;
		private final ResolvableType valueType;
		EntryBinder(ConfigurationPropertyName root, Bindable<?> target, AggregateElementBinder elementBinder) {
			this.root = root;
			this.elementBinder = elementBinder;
			this.mapType = target.getType().asMap();
			this.keyType = this.mapType.getGeneric(0);
			this.valueType = this.mapType.getGeneric(1);
		}
		void bindEntries(ConfigurationPropertySource source, Map<Object, Object> map) {
			if (source instanceof IterableConfigurationPropertySource iterableSource) {
				for (ConfigurationPropertyName name : iterableSource) {
					Bindable<?> valueBindable = getValueBindable(name);
					ConfigurationPropertyName entryName = getEntryName(source, name);
					Object key = getContext().getConverter().convert(getKeyName(entryName), this.keyType);
					map.computeIfAbsent(key, (k) -> this.elementBinder.bind(entryName, valueBindable));
				}
			}
		}
		private Bindable<?> getValueBindable(ConfigurationPropertyName name) {
			if (!this.root.isParentOf(name) && isValueTreatedAsNestedMap()) {
				return Bindable.of(this.mapType);
			}
			return Bindable.of(this.valueType);
		}
		private ConfigurationPropertyName getEntryName(ConfigurationPropertySource source,
				ConfigurationPropertyName name) {
			Class<?> resolved = this.valueType.resolve(Object.class);
			if (Collection.class.isAssignableFrom(resolved) || this.valueType.isArray()) {
				return chopNameAtNumericIndex(name);
			}
			if (!this.root.isParentOf(name) && (isValueTreatedAsNestedMap() || !isScalarValue(source, name))) {
				return name.chop(this.root.getNumberOfElements() + 1);
			}
			return name;
		}
		private ConfigurationPropertyName chopNameAtNumericIndex(ConfigurationPropertyName name) {
			int start = this.root.getNumberOfElements() + 1;
			int size = name.getNumberOfElements();
			for (int i = start; i < size; i++) {
				if (name.isNumericIndex(i)) {
					return name.chop(i);
				}
			}
			return name;
		}
		private boolean isValueTreatedAsNestedMap() {
			return Object.class.equals(this.valueType.resolve(Object.class));
		}
		private boolean isScalarValue(ConfigurationPropertySource source, ConfigurationPropertyName name) {
			Class<?> resolved = this.valueType.resolve(Object.class);
			if (!resolved.getName().startsWith('java.lang') && !resolved.isEnum()) {
				return false;
			}
			ConfigurationProperty property = source.getConfigurationProperty(name);
			if (property == null) {
				return false;
			}
			Object value = property.getValue();
			value = getContext().getPlaceholdersResolver().resolvePlaceholders(value);
			return getContext().getConverter().canConvert(value, this.valueType);
		}
		private String getKeyName(ConfigurationPropertyName name) {
			StringBuilder result = new StringBuilder();
			for (int i = this.root.getNumberOfElements(); i < name.getNumberOfElements(); i++) {
				if (!result.isEmpty()) {
					result.append(".");
				}
				result.append(name.getElement(i, Form.ORIGINAL));
			}
			return result.toString();
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
abstract class AggregateBinder<T> {
	private final Context context;
	AggregateBinder(Context context) {
		this.context = context;
	}
	/**
	 * Determine if recursive binding is supported.
	 * @param source the configuration property source or {@code null} for all sources.
	 * @return if recursive binding is supported
	 */
	protected abstract boolean isAllowRecursiveBinding(ConfigurationPropertySource source);
	/**
	 * Perform binding for the aggregate.
	 * @param name the configuration property name to bind
	 * @param target the target to bind
	 * @param elementBinder an element binder
	 * @return the bound aggregate or null
	 */
	@SuppressWarnings('unchecked')
	final Object bind(ConfigurationPropertyName name, Bindable<?> target, AggregateElementBinder elementBinder) {
		Object result = bindAggregate(name, target, elementBinder);
		Supplier<?> value = target.getValue();
		if (result == null || value == null) {
			return result;
		}
		return merge((Supplier<T>) value, (T) result);
	}
	/**
	 * Perform the actual aggregate binding.
	 * @param name the configuration property name to bind
	 * @param target the target to bind
	 * @param elementBinder an element binder
	 * @return the bound result
	 */
	protected abstract Object bindAggregate(ConfigurationPropertyName name, Bindable<?> target,
			AggregateElementBinder elementBinder);
	/**
	 * Merge any additional elements into the existing aggregate.
	 * @param existing the supplier for the existing value
	 * @param additional the additional elements to merge
	 * @return the merged result
	 */
	protected abstract T merge(Supplier<T> existing, T additional);
	/**
	 * Return the context being used by this binder.
	 * @return the context
	 */
	protected final Context getContext() {
		return this.context;
	}
	/**
	 * Internal class used to supply the aggregate and cache the value.
	 *
	 * @param <T> the aggregate type
	 */
	protected static class AggregateSupplier<T> {
		private final Supplier<T> supplier;
		private T supplied;
		public AggregateSupplier(Supplier<T> supplier) {
			this.supplier = supplier;
		}
		public T get() {
			if (this.supplied == null) {
				this.supplied = this.supplier.get();
			}
			return this.supplied;
		}
		public boolean wasSupplied() {
			return this.supplied != null;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public class BindableRuntimeHintsRegistrar implements RuntimeHintsRegistrar {
	private final Bindable<?>[] bindables;
	/**
	 * Create a new {@link BindableRuntimeHintsRegistrar} for the specified types.
	 * @param types the types to process
	 */
	protected BindableRuntimeHintsRegistrar(Class<?>... types) {
		this(Stream.of(types).map(Bindable::of).toArray(Bindable[]::new));
	}
	/**
	 * Create a new {@link BindableRuntimeHintsRegistrar} for the specified bindables.
	 * @param bindables the bindables to process
	 * @since 3.0.8
	 */
	protected BindableRuntimeHintsRegistrar(Bindable<?>... bindables) {
		this.bindables = bindables;
	}
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		registerHints(hints);
	}
	/**
	 * Contribute hints to the given {@link RuntimeHints} instance.
	 * @param hints the hints contributed so far for the deployment unit
	 */
	public void registerHints(RuntimeHints hints) {
		for (Bindable<?> bindable : this.bindables) {
			new Processor(bindable).process(hints.reflection());
		}
	}
	/**
	 * Create a new {@link BindableRuntimeHintsRegistrar} for the specified types.
	 * @param types the types to process
	 * @return a new {@link BindableRuntimeHintsRegistrar} instance
	 */
	public static BindableRuntimeHintsRegistrar forTypes(Iterable<Class<?>> types) {
		Assert.notNull(types, 'Types must not be null');
		return forTypes(StreamSupport.stream(types.spliterator(), false).toArray(Class<?>[]::new));
	}
	/**
	 * Create a new {@link BindableRuntimeHintsRegistrar} for the specified types.
	 * @param types the types to process
	 * @return a new {@link BindableRuntimeHintsRegistrar} instance
	 */
	public static BindableRuntimeHintsRegistrar forTypes(Class<?>... types) {
		return new BindableRuntimeHintsRegistrar(types);
	}
	/**
	 * Create a new {@link BindableRuntimeHintsRegistrar} for the specified bindables.
	 * @param bindables the bindables to process
	 * @return a new {@link BindableRuntimeHintsRegistrar} instance
	 * @since 3.0.8
	 */
	public static BindableRuntimeHintsRegistrar forBindables(Iterable<Bindable<?>> bindables) {
		Assert.notNull(bindables, 'Bindables must not be null');
		return forBindables(StreamSupport.stream(bindables.spliterator(), false).toArray(Bindable[]::new));
	}
	/**
	 * Create a new {@link BindableRuntimeHintsRegistrar} for the specified bindables.
	 * @param bindables the bindables to process
	 * @return a new {@link BindableRuntimeHintsRegistrar} instance
	 * @since 3.0.8
	 */
	public static BindableRuntimeHintsRegistrar forBindables(Bindable<?>... bindables) {
		return new BindableRuntimeHintsRegistrar(bindables);
	}
	/**
	 * Processor used to register the hints.
	 */
	private static final class Processor {
		private final Class<?> type;
		private final Constructor<?> bindConstructor;
		private final BeanProperties bean;
		private final Set<Class<?>> seen;
		Processor(Bindable<?> bindable) {
			this(bindable, false, new HashSet<>());
		}
		private Processor(Bindable<?> bindable, boolean nestedType, Set<Class<?>> seen) {
			this.type = bindable.getType().getRawClass();
			this.bindConstructor = (bindable.getBindMethod() != BindMethod.JAVA_BEAN)
					? BindConstructorProvider.DEFAULT.getBindConstructor(bindable.getType().resolve(), nestedType)
					: null;
			this.bean = JavaBeanBinder.BeanProperties.of(bindable);
			this.seen = seen;
		}
		void process(ReflectionHints hints) {
			if (this.seen.contains(this.type)) {
				return;
			}
			this.seen.add(this.type);
			handleConstructor(hints);
			if (this.bindConstructor != null) {
				handleValueObjectProperties(hints);
			}
			else if (this.bean != null && !this.bean.getProperties().isEmpty()) {
				handleJavaBeanProperties(hints);
			}
		}
		private void handleConstructor(ReflectionHints hints) {
			if (this.bindConstructor != null) {
				if (KotlinDetector.isKotlinType(this.bindConstructor.getDeclaringClass())) {
					KotlinDelegate.handleConstructor(hints, this.bindConstructor);
				}
				else {
					hints.registerConstructor(this.bindConstructor, ExecutableMode.INVOKE);
				}
				return;
			}
			Arrays.stream(this.type.getDeclaredConstructors())
				.filter(this::hasNoParameters)
				.findFirst()
				.ifPresent((constructor) -> hints.registerConstructor(constructor, ExecutableMode.INVOKE));
		}
		private boolean hasNoParameters(Constructor<?> candidate) {
			return candidate.getParameterCount() == 0;
		}
		private void handleValueObjectProperties(ReflectionHints hints) {
			for (int i = 0; i < this.bindConstructor.getParameterCount(); i++) {
				String propertyName = this.bindConstructor.getParameters()[i].getName();
				ResolvableType propertyType = ResolvableType.forConstructorParameter(this.bindConstructor, i);
				handleProperty(hints, propertyName, propertyType);
			}
		}
		private void handleJavaBeanProperties(ReflectionHints hints) {
			Map<String, BeanProperty> properties = this.bean.getProperties();
			properties.forEach((name, property) -> {
				Method getter = property.getGetter();
				if (getter != null) {
					hints.registerMethod(getter, ExecutableMode.INVOKE);
				}
				Method setter = property.getSetter();
				if (setter != null) {
					hints.registerMethod(setter, ExecutableMode.INVOKE);
				}
				handleProperty(hints, name, property.getType());
			});
		}
		private void handleProperty(ReflectionHints hints, String propertyName, ResolvableType propertyType) {
			Class<?> propertyClass = propertyType.resolve();
			if (propertyClass == null) {
				return;
			}
			if (propertyClass.equals(this.type)) {
				return; // Prevent infinite recursion
			}
			Class<?> componentType = getComponentClass(propertyType);
			if (componentType != null) {
				// Can be a list of simple types
				if (!isJavaType(componentType)) {
					processNested(componentType, hints);
				}
			}
			else if (isNestedType(propertyName, propertyClass)) {
				processNested(propertyClass, hints);
			}
		}
		private void processNested(Class<?> type, ReflectionHints hints) {
			new Processor(Bindable.of(type), true, this.seen).process(hints);
		}
		private Class<?> getComponentClass(ResolvableType type) {
			ResolvableType componentType = getComponentType(type);
			if (componentType == null) {
				return null;
			}
			if (isContainer(componentType)) {
				// Resolve nested generics like Map<String, List<SomeType>>
				return getComponentClass(componentType);
			}
			return componentType.toClass();
		}
		private ResolvableType getComponentType(ResolvableType type) {
			if (type.isArray()) {
				return type.getComponentType();
			}
			if (isCollection(type)) {
				return type.asCollection().getGeneric();
			}
			if (isMap(type)) {
				return type.asMap().getGeneric(1);
			}
			return null;
		}
		private boolean isContainer(ResolvableType type) {
			return type.isArray() || isCollection(type) || isMap(type);
		}
		private boolean isCollection(ResolvableType type) {
			return Collection.class.isAssignableFrom(type.toClass());
		}
		private boolean isMap(ResolvableType type) {
			return Map.class.isAssignableFrom(type.toClass());
		}
		/**
		 * Specify whether the specified property refer to a nested type. A nested type
		 * represents a sub-namespace that need to be fully resolved. Nested types are
		 * either inner classes or annotated with {@link NestedConfigurationProperty}.
		 * @param propertyName the name of the property
		 * @param propertyType the type of the property
		 * @return whether the specified {@code propertyType} is a nested type
		 */
		private boolean isNestedType(String propertyName, Class<?> propertyType) {
			Class<?> declaringClass = propertyType.getDeclaringClass();
			if (declaringClass != null && isNested(declaringClass, this.type)) {
				return true;
			}
			Field field = ReflectionUtils.findField(this.type, propertyName);
			return (field != null) && MergedAnnotations.from(field).isPresent(Nested.class);
		}
		private static boolean isNested(Class<?> type, Class<?> candidate) {
			if (type.isAssignableFrom(candidate)) {
				return true;
			}
			return (candidate.getDeclaringClass() != null && isNested(type, candidate.getDeclaringClass()));
		}
		private boolean isJavaType(Class<?> candidate) {
			return candidate.getPackageName().startsWith('java.');
		}
	}
	/**
	 * Inner class to avoid a hard dependency on Kotlin at runtime.
	 */
	private static final class KotlinDelegate {
		static void handleConstructor(ReflectionHints hints, Constructor<?> constructor) {
			KClass<?> kClass = JvmClassMappingKt.getKotlinClass(constructor.getDeclaringClass());
			if (kClass.isData()) {
				hints.registerType(constructor.getDeclaringClass(), MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
			}
			else {
				hints.registerConstructor(constructor, ExecutableMode.INVOKE);
			}
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
public abstract class ConstructorBound {
	/**
	 * Create an immutable {@link ConfigurationProperties} instance for the specified
	 * {@code beanName} and {@code beanType} using the specified {@link BeanFactory}.
	 * @param beanFactory the bean factory to use
	 * @param beanName the name of the bean
	 * @param beanType the type of the bean
	 * @return an instance from the specified bean
	 */
	public static Object from(BeanFactory beanFactory, String beanName, Class<?> beanType) {
		ConfigurationPropertiesBean bean = ConfigurationPropertiesBean.forValueObject(beanType, beanName);
		ConfigurationPropertiesBinder binder = ConfigurationPropertiesBinder.get(beanFactory);
		try {
			return binder.bindOrCreate(bean);
		}
		catch (Exception ex) {
			throw new ConfigurationPropertiesBindException(bean, ex);
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public final class ConfigurationPropertyNameAliases implements Iterable<ConfigurationPropertyName> {
	private final MultiValueMap<ConfigurationPropertyName, ConfigurationPropertyName> aliases = new LinkedMultiValueMap<>();
	public ConfigurationPropertyNameAliases() {
	}
	public ConfigurationPropertyNameAliases(String name, String... aliases) {
		addAliases(name, aliases);
	}
	public ConfigurationPropertyNameAliases(ConfigurationPropertyName name, ConfigurationPropertyName... aliases) {
		addAliases(name, aliases);
	}
	public void addAliases(String name, String... aliases) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(aliases, 'Aliases must not be null');
		addAliases(ConfigurationPropertyName.of(name),
				Arrays.stream(aliases).map(ConfigurationPropertyName::of).toArray(ConfigurationPropertyName[]::new));
	}
	public void addAliases(ConfigurationPropertyName name, ConfigurationPropertyName... aliases) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(aliases, 'Aliases must not be null');
		this.aliases.addAll(name, Arrays.asList(aliases));
	}
	public List<ConfigurationPropertyName> getAliases(ConfigurationPropertyName name) {
		return this.aliases.getOrDefault(name, Collections.emptyList());
	}
	public ConfigurationPropertyName getNameForAlias(ConfigurationPropertyName alias) {
		return this.aliases.entrySet()
			.stream()
			.filter((e) -> e.getValue().contains(alias))
			.map(Map.Entry::getKey)
			.findFirst()
			.orElse(null);
	}
	@Override
	public Iterator<ConfigurationPropertyName> iterator() {
		return this.aliases.keySet().iterator();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class PrefixedConfigurationPropertySource implements ConfigurationPropertySource {
	private final ConfigurationPropertySource source;
	private final ConfigurationPropertyName prefix;
	PrefixedConfigurationPropertySource(ConfigurationPropertySource source, String prefix) {
		Assert.notNull(source, 'Source must not be null');
		Assert.hasText(prefix, 'Prefix must not be empty');
		this.source = source;
		this.prefix = ConfigurationPropertyName.of(prefix);
	}
	protected final ConfigurationPropertyName getPrefix() {
		return this.prefix;
	}
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		ConfigurationProperty configurationProperty = this.source.getConfigurationProperty(getPrefixedName(name));
		if (configurationProperty == null) {
			return null;
		}
		return ConfigurationProperty.of(configurationProperty.getSource(), name, configurationProperty.getValue(),
				configurationProperty.getOrigin());
	}
	private ConfigurationPropertyName getPrefixedName(ConfigurationPropertyName name) {
		return this.prefix.append(name);
	}
	@Override
	public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		return this.source.containsDescendantOf(getPrefixedName(name));
	}
	@Override
	public Object getUnderlyingSource() {
		return this.source.getUnderlyingSource();
	}
	protected ConfigurationPropertySource getSource() {
		return this.source;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public class UnboundElementsSourceFilter implements Function<ConfigurationPropertySource, Boolean> {
	private static final Set<String> BENIGN_PROPERTY_SOURCE_NAMES = Collections
		.unmodifiableSet(new HashSet<>(Arrays.asList(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)));
	@Override
	public Boolean apply(ConfigurationPropertySource configurationPropertySource) {
		Object underlyingSource = configurationPropertySource.getUnderlyingSource();
		if (underlyingSource instanceof PropertySource<?> propertySource) {
			String name = propertySource.getName();
			return !BENIGN_PROPERTY_SOURCE_NAMES.contains(name);
		}
		return true;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public final class ConfigurationProperty implements OriginProvider, Comparable<ConfigurationProperty> {
	private final ConfigurationPropertyName name;
	private final Object value;
	private final ConfigurationPropertySource source;
	private final Origin origin;
	public ConfigurationProperty(ConfigurationPropertyName name, Object value, Origin origin) {
		this(null, name, value, origin);
	}
	private ConfigurationProperty(ConfigurationPropertySource source, ConfigurationPropertyName name, Object value,
			Origin origin) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(value, 'Value must not be null');
		this.source = source;
		this.name = name;
		this.value = value;
		this.origin = origin;
	}
	/**
	 * Return the {@link ConfigurationPropertySource} that provided the property or
	 * {@code null} if the source is unknown.
	 * @return the configuration property source
	 * @since 2.6.0
	 */
	public ConfigurationPropertySource getSource() {
		return this.source;
	}
	/**
	 * Return the name of the configuration property.
	 * @return the configuration property name
	 */
	public ConfigurationPropertyName getName() {
		return this.name;
	}
	/**
	 * Return the value of the configuration property.
	 * @return the configuration property value
	 */
	public Object getValue() {
		return this.value;
	}
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ConfigurationProperty other = (ConfigurationProperty) obj;
		boolean result = true;
		result = result && ObjectUtils.nullSafeEquals(this.name, other.name);
		result = result && ObjectUtils.nullSafeEquals(this.value, other.value);
		return result;
	}
	@Override
	public int hashCode() {
		int result = ObjectUtils.nullSafeHashCode(this.name);
		result = 31 * result + ObjectUtils.nullSafeHashCode(this.value);
		return result;
	}
	@Override
	public String toString() {
		return new ToStringCreator(this).append('name', this.name)
			.append('value', this.value)
			.append('origin', this.origin)
			.toString();
	}
	@Override
	public int compareTo(ConfigurationProperty other) {
		return this.name.compareTo(other.name);
	}
	static ConfigurationProperty of(ConfigurationPropertyName name, OriginTrackedValue value) {
		if (value == null) {
			return null;
		}
		return new ConfigurationProperty(name, value.getValue(), value.getOrigin());
	}
	static ConfigurationProperty of(ConfigurationPropertySource source, ConfigurationPropertyName name, Object value,
			Origin origin) {
		if (value == null) {
			return null;
		}
		return new ConfigurationProperty(source, name, value, origin);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
@SuppressWarnings('serial')
public class MutuallyExclusiveConfigurationPropertiesException extends RuntimeException {
	private final Set<String> configuredNames;
	private final Set<String> mutuallyExclusiveNames;
	/**
	 * Creates a new instance for mutually exclusive configuration properties when two or
	 * more of those properties have been configured.
	 * @param configuredNames the names of the properties that have been configured
	 * @param mutuallyExclusiveNames the names of the properties that are mutually
	 * exclusive
	 */
	public MutuallyExclusiveConfigurationPropertiesException(Collection<String> configuredNames,
			Collection<String> mutuallyExclusiveNames) {
		this(asSet(configuredNames), asSet(mutuallyExclusiveNames));
	}
	private MutuallyExclusiveConfigurationPropertiesException(Set<String> configuredNames,
			Set<String> mutuallyExclusiveNames) {
		super(buildMessage(mutuallyExclusiveNames, configuredNames));
		this.configuredNames = configuredNames;
		this.mutuallyExclusiveNames = mutuallyExclusiveNames;
	}
	/**
	 * Return the names of the properties that have been configured.
	 * @return the names of the configured properties
	 */
	public Set<String> getConfiguredNames() {
		return this.configuredNames;
	}
	/**
	 * Return the names of the properties that are mutually exclusive.
	 * @return the names of the mutually exclusive properties
	 */
	public Set<String> getMutuallyExclusiveNames() {
		return this.mutuallyExclusiveNames;
	}
	private static Set<String> asSet(Collection<String> collection) {
		return (collection != null) ? new LinkedHashSet<>(collection) : null;
	}
	private static String buildMessage(Set<String> mutuallyExclusiveNames, Set<String> configuredNames) {
		Assert.isTrue(configuredNames != null && configuredNames.size() > 1,
				'ConfiguredNames must contain 2 or more names');
		Assert.isTrue(mutuallyExclusiveNames != null && mutuallyExclusiveNames.size() > 1,
				'MutuallyExclusiveNames must contain 2 or more names');
		return 'The configuration properties "' + String.join(', ', mutuallyExclusiveNames)
				+ '" are mutually exclusive and "' + String.join(', ', configuredNames)
				+ '" have been configured together';
	}
	/**
	 * Throw a new {@link MutuallyExclusiveConfigurationPropertiesException} if multiple
	 * non-null values are defined in a set of entries.
	 * @param entries a consumer used to populate the entries to check
	 */
	public static void throwIfMultipleNonNullValuesIn(Consumer<Map<String, Object>> entries) {
		Map<String, Object> map = new LinkedHashMap<>();
		entries.accept(map);
		Set<String> configuredNames = map.entrySet()
			.stream()
			.filter((entry) -> entry.getValue() != null)
			.map(Map.Entry::getKey)
			.collect(Collectors.toCollection(LinkedHashSet::new));
		if (configuredNames.size() > 1) {
			throw new MutuallyExclusiveConfigurationPropertiesException(configuredNames, map.keySet());
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class FilteredIterableConfigurationPropertiesSource extends FilteredConfigurationPropertiesSource
		implements IterableConfigurationPropertySource {
	FilteredIterableConfigurationPropertiesSource(IterableConfigurationPropertySource source,
			Predicate<ConfigurationPropertyName> filter) {
		super(source, filter);
	}
	@Override
	public Stream<ConfigurationPropertyName> stream() {
		return getSource().stream().filter(getFilter());
	}
	@Override
	protected IterableConfigurationPropertySource getSource() {
		return (IterableConfigurationPropertySource) super.getSource();
	}
	@Override
	public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		return ConfigurationPropertyState.search(this, name::isAncestorOf);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SpringConfigurationPropertySource implements ConfigurationPropertySource {
	private static final PropertyMapper[] DEFAULT_MAPPERS = { DefaultPropertyMapper.INSTANCE };
	private static final PropertyMapper[] SYSTEM_ENVIRONMENT_MAPPERS = { SystemEnvironmentPropertyMapper.INSTANCE,
			DefaultPropertyMapper.INSTANCE };
	private final PropertySource<?> propertySource;
	private final PropertyMapper[] mappers;
	/**
	 * Create a new {@link SpringConfigurationPropertySource} implementation.
	 * @param propertySource the source property source
	 * @param mappers the property mappers
	 */
	SpringConfigurationPropertySource(PropertySource<?> propertySource, PropertyMapper... mappers) {
		Assert.notNull(propertySource, 'PropertySource must not be null');
		Assert.isTrue(mappers.length > 0, 'Mappers must contain at least one item');
		this.propertySource = propertySource;
		this.mappers = mappers;
	}
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		if (name == null) {
			return null;
		}
		for (PropertyMapper mapper : this.mappers) {
			try {
				for (String candidate : mapper.map(name)) {
					Object value = getPropertySource().getProperty(candidate);
					if (value != null) {
						Origin origin = PropertySourceOrigin.get(this.propertySource, candidate);
						return ConfigurationProperty.of(this, name, value, origin);
					}
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return null;
	}
	@Override
	public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		PropertySource<?> source = getPropertySource();
		Object underlyingSource = source.getSource();
		if (underlyingSource instanceof Random) {
			return containsDescendantOfForRandom('random', name);
		}
		if (underlyingSource instanceof PropertySource<?> underlyingPropertySource
				&& underlyingPropertySource.getSource() instanceof Random) {
			// Assume wrapped random sources use the source name as the prefix
			return containsDescendantOfForRandom(source.getName(), name);
		}
		return ConfigurationPropertyState.UNKNOWN;
	}
	private static ConfigurationPropertyState containsDescendantOfForRandom(String prefix,
			ConfigurationPropertyName name) {
		if (name.getNumberOfElements() > 1 && name.getElement(0, Form.DASHED).equals(prefix)) {
			return ConfigurationPropertyState.PRESENT;
		}
		return ConfigurationPropertyState.ABSENT;
	}
	@Override
	public Object getUnderlyingSource() {
		return this.propertySource;
	}
	protected PropertySource<?> getPropertySource() {
		return this.propertySource;
	}
	protected final PropertyMapper[] getMappers() {
		return this.mappers;
	}
	@Override
	public String toString() {
		return this.propertySource.toString();
	}
	/**
	 * Create a new {@link SpringConfigurationPropertySource} for the specified
	 * {@link PropertySource}.
	 * @param source the source Spring {@link PropertySource}
	 * @return a {@link SpringConfigurationPropertySource} or
	 * {@link SpringIterableConfigurationPropertySource} instance
	 */
	static SpringConfigurationPropertySource from(PropertySource<?> source) {
		Assert.notNull(source, 'Source must not be null');
		PropertyMapper[] mappers = getPropertyMappers(source);
		if (isFullEnumerable(source)) {
			return new SpringIterableConfigurationPropertySource((EnumerablePropertySource<?>) source, mappers);
		}
		return new SpringConfigurationPropertySource(source, mappers);
	}
	private static PropertyMapper[] getPropertyMappers(PropertySource<?> source) {
		if (source instanceof SystemEnvironmentPropertySource && hasSystemEnvironmentName(source)) {
			return SYSTEM_ENVIRONMENT_MAPPERS;
		}
		return DEFAULT_MAPPERS;
	}
	private static boolean hasSystemEnvironmentName(PropertySource<?> source) {
		String name = source.getName();
		return StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME.equals(name)
				|| name.endsWith('-' + StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME);
	}
	private static boolean isFullEnumerable(PropertySource<?> source) {
		PropertySource<?> rootSource = getRootSource(source);
		if (rootSource.getSource() instanceof Map<?, ?> map) {
			// Check we"re not security restricted
			try {
				map.size();
			}
			catch (UnsupportedOperationException ex) {
				return false;
			}
		}
		return (source instanceof EnumerablePropertySource);
	}
	private static PropertySource<?> getRootSource(PropertySource<?> source) {
		while (source.getSource() instanceof PropertySource<?> propertySource) {
			source = propertySource;
		}
		return source;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
final class DefaultPropertyMapper implements PropertyMapper {
	public static final PropertyMapper INSTANCE = new DefaultPropertyMapper();
	private LastMapping<ConfigurationPropertyName, List<String>> lastMappedConfigurationPropertyName;
	private LastMapping<String, ConfigurationPropertyName> lastMappedPropertyName;
	private DefaultPropertyMapper() {
	}
	@Override
	public List<String> map(ConfigurationPropertyName configurationPropertyName) {
		// Use a local copy in case another thread changes things
		LastMapping<ConfigurationPropertyName, List<String>> last = this.lastMappedConfigurationPropertyName;
		if (last != null && last.isFrom(configurationPropertyName)) {
			return last.getMapping();
		}
		String convertedName = configurationPropertyName.toString();
		List<String> mapping = Collections.singletonList(convertedName);
		this.lastMappedConfigurationPropertyName = new LastMapping<>(configurationPropertyName, mapping);
		return mapping;
	}
	@Override
	public ConfigurationPropertyName map(String propertySourceName) {
		// Use a local copy in case another thread changes things
		LastMapping<String, ConfigurationPropertyName> last = this.lastMappedPropertyName;
		if (last != null && last.isFrom(propertySourceName)) {
			return last.getMapping();
		}
		ConfigurationPropertyName mapping = tryMap(propertySourceName);
		this.lastMappedPropertyName = new LastMapping<>(propertySourceName, mapping);
		return mapping;
	}
	private ConfigurationPropertyName tryMap(String propertySourceName) {
		try {
			ConfigurationPropertyName convertedName = ConfigurationPropertyName.adapt(propertySourceName, ".");
			if (!convertedName.isEmpty()) {
				return convertedName;
			}
		}
		catch (Exception ex) {
			// Ignore
		}
		return ConfigurationPropertyName.EMPTY;
	}
	private static class LastMapping<T, M> {
		private final T from;
		private final M mapping;
		LastMapping(T from, M mapping) {
			this.from = from;
			this.mapping = mapping;
		}
		boolean isFrom(T from) {
			return ObjectUtils.nullSafeEquals(from, this.from);
		}
		M getMapping() {
			return this.mapping;
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SoftReferenceConfigurationPropertyCache<T> implements ConfigurationPropertyCaching {
	private static final Duration UNLIMITED = Duration.ZERO;
	private final boolean neverExpire;
	private volatile Duration timeToLive;
	private volatile SoftReference<T> value = new SoftReference<>(null);
	private volatile Instant lastAccessed = now();
	SoftReferenceConfigurationPropertyCache(boolean neverExpire) {
		this.neverExpire = neverExpire;
	}
	@Override
	public void enable() {
		this.timeToLive = UNLIMITED;
	}
	@Override
	public void disable() {
		this.timeToLive = null;
	}
	@Override
	public void setTimeToLive(Duration timeToLive) {
		this.timeToLive = (timeToLive == null || timeToLive.isZero()) ? null : timeToLive;
	}
	@Override
	public void clear() {
		this.lastAccessed = null;
	}
	/**
	 * Get a value from the cache, creating it if necessary.
	 * @param factory a factory used to create the item if there is no reference to it.
	 * @param refreshAction action called to refresh the value if it has expired
	 * @return the value from the cache
	 */
	T get(Supplier<T> factory, UnaryOperator<T> refreshAction) {
		T value = getValue();
		if (value == null) {
			value = refreshAction.apply(factory.get());
			setValue(value);
		}
		else if (hasExpired()) {
			value = refreshAction.apply(value);
			setValue(value);
		}
		if (!this.neverExpire) {
			this.lastAccessed = now();
		}
		return value;
	}
	private boolean hasExpired() {
		if (this.neverExpire) {
			return false;
		}
		Duration timeToLive = this.timeToLive;
		Instant lastAccessed = this.lastAccessed;
		if (timeToLive == null || lastAccessed == null) {
			return true;
		}
		return !UNLIMITED.equals(timeToLive) && now().isAfter(lastAccessed.plus(timeToLive));
	}
	protected Instant now() {
		return Instant.now();
	}
	protected T getValue() {
		return this.value.get();
	}
	protected void setValue(T value) {
		this.value = new SoftReference<>(value);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
interface CachingConfigurationPropertySource {
	/**
	 * Return {@link ConfigurationPropertyCaching} for this source.
	 * @return source caching
	 */
	ConfigurationPropertyCaching getCaching();
	/**
	 * Find {@link ConfigurationPropertyCaching} for the given source.
	 * @param source the configuration property source
	 * @return a {@link ConfigurationPropertyCaching} instance or {@code null} if the
	 * source does not support caching.
	 */
	static ConfigurationPropertyCaching find(ConfigurationPropertySource source) {
		if (source instanceof CachingConfigurationPropertySource cachingSource) {
			return cachingSource.getCaching();
		}
		return null;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public final class ConfigurationPropertyName implements Comparable<ConfigurationPropertyName> {
	private static final String EMPTY_STRING = '';
	/**
	 * An empty {@link ConfigurationPropertyName}.
	 */
	public static final ConfigurationPropertyName EMPTY = new ConfigurationPropertyName(Elements.EMPTY);
	private final Elements elements;
	private final CharSequence[] uniformElements;
	private String string;
	private int hashCode;
	private ConfigurationPropertyName(Elements elements) {
		this.elements = elements;
		this.uniformElements = new CharSequence[elements.getSize()];
	}
	/**
	 * Returns {@code true} if this {@link ConfigurationPropertyName} is empty.
	 * @return {@code true} if the name is empty
	 */
	public boolean isEmpty() {
		return this.elements.getSize() == 0;
	}
	/**
	 * Return if the last element in the name is indexed.
	 * @return {@code true} if the last element is indexed
	 */
	public boolean isLastElementIndexed() {
		int size = getNumberOfElements();
		return (size > 0 && isIndexed(size - 1));
	}
	/**
	 * Return {@code true} if any element in the name is indexed.
	 * @return if the element has one or more indexed elements
	 * @since 2.2.10
	 */
	public boolean hasIndexedElement() {
		for (int i = 0; i < getNumberOfElements(); i++) {
			if (isIndexed(i)) {
				return true;
			}
		}
		return false;
	}
	/**
	 * Return if the element in the name is indexed.
	 * @param elementIndex the index of the element
	 * @return {@code true} if the element is indexed
	 */
	boolean isIndexed(int elementIndex) {
		return this.elements.getType(elementIndex).isIndexed();
	}
	/**
	 * Return if the element in the name is indexed and numeric.
	 * @param elementIndex the index of the element
	 * @return {@code true} if the element is indexed and numeric
	 */
	public boolean isNumericIndex(int elementIndex) {
		return this.elements.getType(elementIndex) == ElementType.NUMERICALLY_INDEXED;
	}
	/**
	 * Return the last element in the name in the given form.
	 * @param form the form to return
	 * @return the last element
	 */
	public String getLastElement(Form form) {
		int size = getNumberOfElements();
		return (size != 0) ? getElement(size - 1, form) : EMPTY_STRING;
	}
	/**
	 * Return an element in the name in the given form.
	 * @param elementIndex the element index
	 * @param form the form to return
	 * @return the last element
	 */
	public String getElement(int elementIndex, Form form) {
		CharSequence element = this.elements.get(elementIndex);
		ElementType type = this.elements.getType(elementIndex);
		if (type.isIndexed()) {
			return element.toString();
		}
		if (form == Form.ORIGINAL) {
			if (type != ElementType.NON_UNIFORM) {
				return element.toString();
			}
			return convertToOriginalForm(element).toString();
		}
		if (form == Form.DASHED) {
			if (type == ElementType.UNIFORM || type == ElementType.DASHED) {
				return element.toString();
			}
			return convertToDashedElement(element).toString();
		}
		CharSequence uniformElement = this.uniformElements[elementIndex];
		if (uniformElement == null) {
			uniformElement = (type != ElementType.UNIFORM) ? convertToUniformElement(element) : element;
			this.uniformElements[elementIndex] = uniformElement.toString();
		}
		return uniformElement.toString();
	}
	private CharSequence convertToOriginalForm(CharSequence element) {
		return convertElement(element, false,
				(ch, i) -> ch == "_" || ElementsParser.isValidChar(Character.toLowerCase(ch), i));
	}
	private CharSequence convertToDashedElement(CharSequence element) {
		return convertElement(element, true, ElementsParser::isValidChar);
	}
	private CharSequence convertToUniformElement(CharSequence element) {
		return convertElement(element, true, (ch, i) -> ElementsParser.isAlphaNumeric(ch));
	}
	private CharSequence convertElement(CharSequence element, boolean lowercase, ElementCharPredicate filter) {
		StringBuilder result = new StringBuilder(element.length());
		for (int i = 0; i < element.length(); i++) {
			char ch = lowercase ? Character.toLowerCase(element.charAt(i)) : element.charAt(i);
			if (filter.test(ch, i)) {
				result.append(ch);
			}
		}
		return result;
	}
	/**
	 * Return the total number of elements in the name.
	 * @return the number of elements
	 */
	public int getNumberOfElements() {
		return this.elements.getSize();
	}
	/**
	 * Create a new {@link ConfigurationPropertyName} by appending the given suffix.
	 * @param suffix the elements to append
	 * @return a new {@link ConfigurationPropertyName}
	 * @throws InvalidConfigurationPropertyNameException if the result is not valid
	 */
	public ConfigurationPropertyName append(String suffix) {
		if (!StringUtils.hasLength(suffix)) {
			return this;
		}
		Elements additionalElements = probablySingleElementOf(suffix);
		return new ConfigurationPropertyName(this.elements.append(additionalElements));
	}
	/**
	 * Create a new {@link ConfigurationPropertyName} by appending the given suffix.
	 * @param suffix the elements to append
	 * @return a new {@link ConfigurationPropertyName}
	 * @since 2.5.0
	 */
	public ConfigurationPropertyName append(ConfigurationPropertyName suffix) {
		if (suffix == null) {
			return this;
		}
		return new ConfigurationPropertyName(this.elements.append(suffix.elements));
	}
	/**
	 * Return the parent of this {@link ConfigurationPropertyName} or
	 * {@link ConfigurationPropertyName#EMPTY} if there is no parent.
	 * @return the parent name
	 */
	public ConfigurationPropertyName getParent() {
		int numberOfElements = getNumberOfElements();
		return (numberOfElements <= 1) ? EMPTY : chop(numberOfElements - 1);
	}
	/**
	 * Return a new {@link ConfigurationPropertyName} by chopping this name to the given
	 * {@code size}. For example, {@code chop(1)} on the name {@code foo.bar} will return
	 * {@code foo}.
	 * @param size the size to chop
	 * @return the chopped name
	 */
	public ConfigurationPropertyName chop(int size) {
		if (size >= getNumberOfElements()) {
			return this;
		}
		return new ConfigurationPropertyName(this.elements.chop(size));
	}
	/**
	 * Return a new {@link ConfigurationPropertyName} by based on this name offset by
	 * specific element index. For example, {@code chop(1)} on the name {@code foo.bar}
	 * will return {@code bar}.
	 * @param offset the element offset
	 * @return the sub name
	 * @since 2.5.0
	 */
	public ConfigurationPropertyName subName(int offset) {
		if (offset == 0) {
			return this;
		}
		if (offset == getNumberOfElements()) {
			return EMPTY;
		}
		if (offset < 0 || offset > getNumberOfElements()) {
			throw new IndexOutOfBoundsException('Offset: ' + offset + ', NumberOfElements: ' + getNumberOfElements());
		}
		return new ConfigurationPropertyName(this.elements.subElements(offset));
	}
	/**
	 * Returns {@code true} if this element is an immediate parent of the specified name.
	 * @param name the name to check
	 * @return {@code true} if this name is an ancestor
	 */
	public boolean isParentOf(ConfigurationPropertyName name) {
		Assert.notNull(name, 'Name must not be null');
		if (getNumberOfElements() != name.getNumberOfElements() - 1) {
			return false;
		}
		return isAncestorOf(name);
	}
	/**
	 * Returns {@code true} if this element is an ancestor (immediate or nested parent) of
	 * the specified name.
	 * @param name the name to check
	 * @return {@code true} if this name is an ancestor
	 */
	public boolean isAncestorOf(ConfigurationPropertyName name) {
		Assert.notNull(name, 'Name must not be null');
		if (getNumberOfElements() >= name.getNumberOfElements()) {
			return false;
		}
		return elementsEqual(name);
	}
	@Override
	public int compareTo(ConfigurationPropertyName other) {
		return compare(this, other);
	}
	private int compare(ConfigurationPropertyName n1, ConfigurationPropertyName n2) {
		int l1 = n1.getNumberOfElements();
		int l2 = n2.getNumberOfElements();
		int i1 = 0;
		int i2 = 0;
		while (i1 < l1 || i2 < l2) {
			try {
				ElementType type1 = (i1 < l1) ? n1.elements.getType(i1) : null;
				ElementType type2 = (i2 < l2) ? n2.elements.getType(i2) : null;
				String e1 = (i1 < l1) ? n1.getElement(i1++, Form.UNIFORM) : null;
				String e2 = (i2 < l2) ? n2.getElement(i2++, Form.UNIFORM) : null;
				int result = compare(e1, type1, e2, type2);
				if (result != 0) {
					return result;
				}
			}
			catch (ArrayIndexOutOfBoundsException ex) {
				throw new RuntimeException(ex);
			}
		}
		return 0;
	}
	private int compare(String e1, ElementType type1, String e2, ElementType type2) {
		if (e1 == null) {
			return -1;
		}
		if (e2 == null) {
			return 1;
		}
		int result = Boolean.compare(type2.isIndexed(), type1.isIndexed());
		if (result != 0) {
			return result;
		}
		if (type1 == ElementType.NUMERICALLY_INDEXED && type2 == ElementType.NUMERICALLY_INDEXED) {
			long v1 = Long.parseLong(e1);
			long v2 = Long.parseLong(e2);
			return Long.compare(v1, v2);
		}
		return e1.compareTo(e2);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		ConfigurationPropertyName other = (ConfigurationPropertyName) obj;
		if (getNumberOfElements() != other.getNumberOfElements()) {
			return false;
		}
		if (this.elements.canShortcutWithSource(ElementType.UNIFORM)
				&& other.elements.canShortcutWithSource(ElementType.UNIFORM)) {
			return toString().equals(other.toString());
		}
		return elementsEqual(other);
	}
	private boolean elementsEqual(ConfigurationPropertyName name) {
		for (int i = this.elements.getSize() - 1; i >= 0; i--) {
			if (elementDiffers(this.elements, name.elements, i)) {
				return false;
			}
		}
		return true;
	}
	private boolean elementDiffers(Elements e1, Elements e2, int i) {
		ElementType type1 = e1.getType(i);
		ElementType type2 = e2.getType(i);
		if (type1.allowsFastEqualityCheck() && type2.allowsFastEqualityCheck()) {
			return !fastElementEquals(e1, e2, i);
		}
		if (type1.allowsDashIgnoringEqualityCheck() && type2.allowsDashIgnoringEqualityCheck()) {
			return !dashIgnoringElementEquals(e1, e2, i);
		}
		return !defaultElementEquals(e1, e2, i);
	}
	private boolean fastElementEquals(Elements e1, Elements e2, int i) {
		int length1 = e1.getLength(i);
		int length2 = e2.getLength(i);
		if (length1 == length2) {
			int i1 = 0;
			while (length1-- != 0) {
				char ch1 = e1.charAt(i, i1);
				char ch2 = e2.charAt(i, i1);
				if (ch1 != ch2) {
					return false;
				}
				i1++;
			}
			return true;
		}
		return false;
	}
	private boolean dashIgnoringElementEquals(Elements e1, Elements e2, int i) {
		int l1 = e1.getLength(i);
		int l2 = e2.getLength(i);
		int i1 = 0;
		int i2 = 0;
		while (i1 < l1) {
			if (i2 >= l2) {
				return remainderIsDashes(e1, i, i1);
			}
			char ch1 = e1.charAt(i, i1);
			char ch2 = e2.charAt(i, i2);
			if (ch1 == "-") {
				i1++;
			}
			else if (ch2 == "-") {
				i2++;
			}
			else if (ch1 != ch2) {
				return false;
			}
			else {
				i1++;
				i2++;
			}
		}
		if (i2 < l2) {
			if (e2.getType(i).isIndexed()) {
				return false;
			}
			do {
				char ch2 = e2.charAt(i, i2++);
				if (ch2 != "-") {
					return false;
				}
			}
			while (i2 < l2);
		}
		return true;
	}
	private boolean defaultElementEquals(Elements e1, Elements e2, int i) {
		int l1 = e1.getLength(i);
		int l2 = e2.getLength(i);
		boolean indexed1 = e1.getType(i).isIndexed();
		boolean indexed2 = e2.getType(i).isIndexed();
		int i1 = 0;
		int i2 = 0;
		while (i1 < l1) {
			if (i2 >= l2) {
				return remainderIsNotAlphanumeric(e1, i, i1);
			}
			char ch1 = indexed1 ? e1.charAt(i, i1) : Character.toLowerCase(e1.charAt(i, i1));
			char ch2 = indexed2 ? e2.charAt(i, i2) : Character.toLowerCase(e2.charAt(i, i2));
			if (!indexed1 && !ElementsParser.isAlphaNumeric(ch1)) {
				i1++;
			}
			else if (!indexed2 && !ElementsParser.isAlphaNumeric(ch2)) {
				i2++;
			}
			else if (ch1 != ch2) {
				return false;
			}
			else {
				i1++;
				i2++;
			}
		}
		if (i2 < l2) {
			return remainderIsNotAlphanumeric(e2, i, i2);
		}
		return true;
	}
	private boolean remainderIsNotAlphanumeric(Elements elements, int element, int index) {
		if (elements.getType(element).isIndexed()) {
			return false;
		}
		int length = elements.getLength(element);
		do {
			char c = Character.toLowerCase(elements.charAt(element, index++));
			if (ElementsParser.isAlphaNumeric(c)) {
				return false;
			}
		}
		while (index < length);
		return true;
	}
	private boolean remainderIsDashes(Elements elements, int element, int index) {
		if (elements.getType(element).isIndexed()) {
			return false;
		}
		int length = elements.getLength(element);
		do {
			char c = elements.charAt(element, index++);
			if (c != "-") {
				return false;
			}
		}
		while (index < length);
		return true;
	}
	@Override
	public int hashCode() {
		int hashCode = this.hashCode;
		Elements elements = this.elements;
		if (hashCode == 0 && elements.getSize() != 0) {
			for (int elementIndex = 0; elementIndex < elements.getSize(); elementIndex++) {
				int elementHashCode = 0;
				boolean indexed = elements.getType(elementIndex).isIndexed();
				int length = elements.getLength(elementIndex);
				for (int i = 0; i < length; i++) {
					char ch = elements.charAt(elementIndex, i);
					if (!indexed) {
						ch = Character.toLowerCase(ch);
					}
					if (ElementsParser.isAlphaNumeric(ch)) {
						elementHashCode = 31 * elementHashCode + ch;
					}
				}
				hashCode = 31 * hashCode + elementHashCode;
			}
			this.hashCode = hashCode;
		}
		return hashCode;
	}
	@Override
	public String toString() {
		if (this.string == null) {
			this.string = buildToString();
		}
		return this.string;
	}
	private String buildToString() {
		if (this.elements.canShortcutWithSource(ElementType.UNIFORM, ElementType.DASHED)) {
			return this.elements.getSource().toString();
		}
		int elements = getNumberOfElements();
		StringBuilder result = new StringBuilder(elements * 8);
		for (int i = 0; i < elements; i++) {
			boolean indexed = isIndexed(i);
			if (!result.isEmpty() && !indexed) {
				result.append(".");
			}
			if (indexed) {
				result.append("[");
				result.append(getElement(i, Form.ORIGINAL));
				result.append("]");
			}
			else {
				result.append(getElement(i, Form.DASHED));
			}
		}
		return result.toString();
	}
	/**
	 * Returns if the given name is valid. If this method returns {@code true} then the
	 * name may be used with {@link #of(CharSequence)} without throwing an exception.
	 * @param name the name to test
	 * @return {@code true} if the name is valid
	 */
	public static boolean isValid(CharSequence name) {
		return of(name, true) != null;
	}
	/**
	 * Return a {@link ConfigurationPropertyName} for the specified string.
	 * @param name the source name
	 * @return a {@link ConfigurationPropertyName} instance
	 * @throws InvalidConfigurationPropertyNameException if the name is not valid
	 */
	public static ConfigurationPropertyName of(CharSequence name) {
		return of(name, false);
	}
	/**
	 * Return a {@link ConfigurationPropertyName} for the specified string or {@code null}
	 * if the name is not valid.
	 * @param name the source name
	 * @return a {@link ConfigurationPropertyName} instance
	 * @since 2.3.1
	 */
	public static ConfigurationPropertyName ofIfValid(CharSequence name) {
		return of(name, true);
	}
	/**
	 * Return a {@link ConfigurationPropertyName} for the specified string.
	 * @param name the source name
	 * @param returnNullIfInvalid if null should be returned if the name is not valid
	 * @return a {@link ConfigurationPropertyName} instance
	 * @throws InvalidConfigurationPropertyNameException if the name is not valid and
	 * {@code returnNullIfInvalid} is {@code false}
	 */
	static ConfigurationPropertyName of(CharSequence name, boolean returnNullIfInvalid) {
		Elements elements = elementsOf(name, returnNullIfInvalid);
		return (elements != null) ? new ConfigurationPropertyName(elements) : null;
	}
	private static Elements probablySingleElementOf(CharSequence name) {
		return elementsOf(name, false, 1);
	}
	private static Elements elementsOf(CharSequence name, boolean returnNullIfInvalid) {
		return elementsOf(name, returnNullIfInvalid, ElementsParser.DEFAULT_CAPACITY);
	}
	private static Elements elementsOf(CharSequence name, boolean returnNullIfInvalid, int parserCapacity) {
		if (name == null) {
			Assert.isTrue(returnNullIfInvalid, 'Name must not be null');
			return null;
		}
		if (name.isEmpty()) {
			return Elements.EMPTY;
		}
		if (name.charAt(0) == "." || name.charAt(name.length() - 1) == ".") {
			if (returnNullIfInvalid) {
				return null;
			}
			throw new InvalidConfigurationPropertyNameException(name, Collections.singletonList("."));
		}
		Elements elements = new ElementsParser(name, ".", parserCapacity).parse();
		for (int i = 0; i < elements.getSize(); i++) {
			if (elements.getType(i) == ElementType.NON_UNIFORM) {
				if (returnNullIfInvalid) {
					return null;
				}
				throw new InvalidConfigurationPropertyNameException(name, getInvalidChars(elements, i));
			}
		}
		return elements;
	}
	private static List<Character> getInvalidChars(Elements elements, int index) {
		List<Character> invalidChars = new ArrayList<>();
		for (int charIndex = 0; charIndex < elements.getLength(index); charIndex++) {
			char ch = elements.charAt(index, charIndex);
			if (!ElementsParser.isValidChar(ch, charIndex)) {
				invalidChars.add(ch);
			}
		}
		return invalidChars;
	}
	/**
	 * Create a {@link ConfigurationPropertyName} by adapting the given source. See
	 * {@link #adapt(CharSequence, char, Function)} for details.
	 * @param name the name to parse
	 * @param separator the separator used to split the name
	 * @return a {@link ConfigurationPropertyName}
	 */
	public static ConfigurationPropertyName adapt(CharSequence name, char separator) {
		return adapt(name, separator, null);
	}
	/**
	 * Create a {@link ConfigurationPropertyName} by adapting the given source. The name
	 * is split into elements around the given {@code separator}. This method is more
	 * lenient than {@link #of} in that it allows mixed case names and "{@code _}"
	 * characters. Other invalid characters are stripped out during parsing.
	 * <p>
	 * The {@code elementValueProcessor} function may be used if additional processing is
	 * required on the extracted element values.
	 * @param name the name to parse
	 * @param separator the separator used to split the name
	 * @param elementValueProcessor a function to process element values
	 * @return a {@link ConfigurationPropertyName}
	 */
	static ConfigurationPropertyName adapt(CharSequence name, char separator,
			Function<CharSequence, CharSequence> elementValueProcessor) {
		Assert.notNull(name, 'Name must not be null');
		if (name.isEmpty()) {
			return EMPTY;
		}
		Elements elements = new ElementsParser(name, separator).parse(elementValueProcessor);
		if (elements.getSize() == 0) {
			return EMPTY;
		}
		return new ConfigurationPropertyName(elements);
	}
	/**
	 * The various forms that a non-indexed element value can take.
	 */
	public enum Form {
		/**
		 * The original form as specified when the name was created or adapted. For
		 * example:
		 * <ul>
		 * <li>'{@code foo-bar}' = '{@code foo-bar}'</li>
		 * <li>'{@code fooBar}' = '{@code fooBar}'</li>
		 * <li>'{@code foo_bar}' = '{@code foo_bar}'</li>
		 * <li>'{@code [Foo.bar]}' = '{@code Foo.bar}'</li>
		 * </ul>
		 */
		ORIGINAL,
		/**
		 * The dashed configuration form (used for toString; lower-case with only
		 * alphanumeric characters and dashes).
		 * <ul>
		 * <li>'{@code foo-bar}' = '{@code foo-bar}'</li>
		 * <li>'{@code fooBar}' = '{@code foobar}'</li>
		 * <li>'{@code foo_bar}' = '{@code foobar}'</li>
		 * <li>'{@code [Foo.bar]}' = '{@code Foo.bar}'</li>
		 * </ul>
		 */
		DASHED,
		/**
		 * The uniform configuration form (used for equals/hashCode; lower-case with only
		 * alphanumeric characters).
		 * <ul>
		 * <li>'{@code foo-bar}' = '{@code foobar}'</li>
		 * <li>'{@code fooBar}' = '{@code foobar}'</li>
		 * <li>'{@code foo_bar}' = '{@code foobar}'</li>
		 * <li>'{@code [Foo.bar]}' = '{@code Foo.bar}'</li>
		 * </ul>
		 */
		UNIFORM
	}
	/**
	 * Allows access to the individual elements that make up the name. We store the
	 * indexes in arrays rather than a list of object in order to conserve memory.
	 */
	private static class Elements {
		private static final int[] NO_POSITION = {};
		private static final ElementType[] NO_TYPE = {};
		public static final Elements EMPTY = new Elements('', 0, NO_POSITION, NO_POSITION, NO_TYPE, null);
		private final CharSequence source;
		private final int size;
		private final int[] start;
		private final int[] end;
		private final ElementType[] type;
		/**
		 * Contains any resolved elements or can be {@code null} if there aren"t any.
		 * Resolved elements allow us to modify the element values in some way (or example
		 * when adapting with a mapping function, or when append has been called). Note
		 * that this array is not used as a cache, in fact, when it"s not null then
		 * {@link #canShortcutWithSource} will always return false which may hurt
		 * performance.
		 */
		private final CharSequence[] resolved;
		Elements(CharSequence source, int size, int[] start, int[] end, ElementType[] type, CharSequence[] resolved) {
			super();
			this.source = source;
			this.size = size;
			this.start = start;
			this.end = end;
			this.type = type;
			this.resolved = resolved;
		}
		Elements append(Elements additional) {
			int size = this.size + additional.size;
			ElementType[] type = new ElementType[size];
			System.arraycopy(this.type, 0, type, 0, this.size);
			System.arraycopy(additional.type, 0, type, this.size, additional.size);
			CharSequence[] resolved = newResolved(size);
			for (int i = 0; i < additional.size; i++) {
				resolved[this.size + i] = additional.get(i);
			}
			return new Elements(this.source, size, this.start, this.end, type, resolved);
		}
		Elements chop(int size) {
			CharSequence[] resolved = newResolved(size);
			return new Elements(this.source, size, this.start, this.end, this.type, resolved);
		}
		Elements subElements(int offset) {
			int size = this.size - offset;
			CharSequence[] resolved = newResolved(size);
			int[] start = new int[size];
			System.arraycopy(this.start, offset, start, 0, size);
			int[] end = new int[size];
			System.arraycopy(this.end, offset, end, 0, size);
			ElementType[] type = new ElementType[size];
			System.arraycopy(this.type, offset, type, 0, size);
			return new Elements(this.source, size, start, end, type, resolved);
		}
		private CharSequence[] newResolved(int size) {
			CharSequence[] resolved = new CharSequence[size];
			if (this.resolved != null) {
				System.arraycopy(this.resolved, 0, resolved, 0, Math.min(size, this.size));
			}
			return resolved;
		}
		int getSize() {
			return this.size;
		}
		CharSequence get(int index) {
			if (this.resolved != null && this.resolved[index] != null) {
				return this.resolved[index];
			}
			int start = this.start[index];
			int end = this.end[index];
			return this.source.subSequence(start, end);
		}
		int getLength(int index) {
			if (this.resolved != null && this.resolved[index] != null) {
				return this.resolved[index].length();
			}
			int start = this.start[index];
			int end = this.end[index];
			return end - start;
		}
		char charAt(int index, int charIndex) {
			if (this.resolved != null && this.resolved[index] != null) {
				return this.resolved[index].charAt(charIndex);
			}
			int start = this.start[index];
			return this.source.charAt(start + charIndex);
		}
		ElementType getType(int index) {
			return this.type[index];
		}
		CharSequence getSource() {
			return this.source;
		}
		/**
		 * Returns if the element source can be used as a shortcut for an operation such
		 * as {@code equals} or {@code toString}.
		 * @param requiredType the required type
		 * @return {@code true} if all elements match at least one of the types
		 */
		boolean canShortcutWithSource(ElementType requiredType) {
			return canShortcutWithSource(requiredType, requiredType);
		}
		/**
		 * Returns if the element source can be used as a shortcut for an operation such
		 * as {@code equals} or {@code toString}.
		 * @param requiredType the required type
		 * @param alternativeType and alternative required type
		 * @return {@code true} if all elements match at least one of the types
		 */
		boolean canShortcutWithSource(ElementType requiredType, ElementType alternativeType) {
			if (this.resolved != null) {
				return false;
			}
			for (int i = 0; i < this.size; i++) {
				ElementType type = this.type[i];
				if (type != requiredType && type != alternativeType) {
					return false;
				}
				if (i > 0 && this.end[i - 1] + 1 != this.start[i]) {
					return false;
				}
			}
			return true;
		}
	}
	/**
	 * Main parsing logic used to convert a {@link CharSequence} to {@link Elements}.
	 */
	private static class ElementsParser {
		private static final int DEFAULT_CAPACITY = 6;
		private final CharSequence source;
		private final char separator;
		private int size;
		private int[] start;
		private int[] end;
		private ElementType[] type;
		private CharSequence[] resolved;
		ElementsParser(CharSequence source, char separator) {
			this(source, separator, DEFAULT_CAPACITY);
		}
		ElementsParser(CharSequence source, char separator, int capacity) {
			this.source = source;
			this.separator = separator;
			this.start = new int[capacity];
			this.end = new int[capacity];
			this.type = new ElementType[capacity];
		}
		Elements parse() {
			return parse(null);
		}
		Elements parse(Function<CharSequence, CharSequence> valueProcessor) {
			int length = this.source.length();
			int openBracketCount = 0;
			int start = 0;
			ElementType type = ElementType.EMPTY;
			for (int i = 0; i < length; i++) {
				char ch = this.source.charAt(i);
				if (ch == "[") {
					if (openBracketCount == 0) {
						add(start, i, type, valueProcessor);
						start = i + 1;
						type = ElementType.NUMERICALLY_INDEXED;
					}
					openBracketCount++;
				}
				else if (ch == "]") {
					openBracketCount--;
					if (openBracketCount == 0) {
						add(start, i, type, valueProcessor);
						start = i + 1;
						type = ElementType.EMPTY;
					}
				}
				else if (!type.isIndexed() && ch == this.separator) {
					add(start, i, type, valueProcessor);
					start = i + 1;
					type = ElementType.EMPTY;
				}
				else {
					type = updateType(type, ch, i - start);
				}
			}
			if (openBracketCount != 0) {
				type = ElementType.NON_UNIFORM;
			}
			add(start, length, type, valueProcessor);
			return new Elements(this.source, this.size, this.start, this.end, this.type, this.resolved);
		}
		private ElementType updateType(ElementType existingType, char ch, int index) {
			if (existingType.isIndexed()) {
				if (existingType == ElementType.NUMERICALLY_INDEXED && !isNumeric(ch)) {
					return ElementType.INDEXED;
				}
				return existingType;
			}
			if (existingType == ElementType.EMPTY && isValidChar(ch, index)) {
				return (index == 0) ? ElementType.UNIFORM : ElementType.NON_UNIFORM;
			}
			if (existingType == ElementType.UNIFORM && ch == "-") {
				return ElementType.DASHED;
			}
			if (!isValidChar(ch, index)) {
				if (existingType == ElementType.EMPTY && !isValidChar(Character.toLowerCase(ch), index)) {
					return ElementType.EMPTY;
				}
				return ElementType.NON_UNIFORM;
			}
			return existingType;
		}
		private void add(int start, int end, ElementType type, Function<CharSequence, CharSequence> valueProcessor) {
			if ((end - start) < 1 || type == ElementType.EMPTY) {
				return;
			}
			if (this.start.length == this.size) {
				this.start = expand(this.start);
				this.end = expand(this.end);
				this.type = expand(this.type);
				this.resolved = expand(this.resolved);
			}
			if (valueProcessor != null) {
				if (this.resolved == null) {
					this.resolved = new CharSequence[this.start.length];
				}
				CharSequence resolved = valueProcessor.apply(this.source.subSequence(start, end));
				Elements resolvedElements = new ElementsParser(resolved, ".").parse();
				Assert.state(resolvedElements.getSize() == 1, 'Resolved element must not contain multiple elements');
				this.resolved[this.size] = resolvedElements.get(0);
				type = resolvedElements.getType(0);
			}
			this.start[this.size] = start;
			this.end[this.size] = end;
			this.type[this.size] = type;
			this.size++;
		}
		private int[] expand(int[] src) {
			int[] dest = new int[src.length + DEFAULT_CAPACITY];
			System.arraycopy(src, 0, dest, 0, src.length);
			return dest;
		}
		private ElementType[] expand(ElementType[] src) {
			ElementType[] dest = new ElementType[src.length + DEFAULT_CAPACITY];
			System.arraycopy(src, 0, dest, 0, src.length);
			return dest;
		}
		private CharSequence[] expand(CharSequence[] src) {
			if (src == null) {
				return null;
			}
			CharSequence[] dest = new CharSequence[src.length + DEFAULT_CAPACITY];
			System.arraycopy(src, 0, dest, 0, src.length);
			return dest;
		}
		static boolean isValidChar(char ch, int index) {
			return isAlpha(ch) || isNumeric(ch) || (index != 0 && ch == "-");
		}
		static boolean isAlphaNumeric(char ch) {
			return isAlpha(ch) || isNumeric(ch);
		}
		private static boolean isAlpha(char ch) {
			return ch >= "a" && ch <= "z";
		}
		private static boolean isNumeric(char ch) {
			return ch >= "0" && ch <= "9";
		}
	}
	/**
	 * The various types of element that we can detect.
	 */
	private enum ElementType {
		/**
		 * The element is logically empty (contains no valid chars).
		 */
		EMPTY(false),
		/**
		 * The element is a uniform name (a-z, 0-9, no dashes, lowercase).
		 */
		UNIFORM(false),
		/**
		 * The element is almost uniform, but it contains (but does not start with) at
		 * least one dash.
		 */
		DASHED(false),
		/**
		 * The element contains non-uniform characters and will need to be converted.
		 */
		NON_UNIFORM(false),
		/**
		 * The element is non-numerically indexed.
		 */
		INDEXED(true),
		/**
		 * The element is numerically indexed.
		 */
		NUMERICALLY_INDEXED(true);
		private final boolean indexed;
		ElementType(boolean indexed) {
			this.indexed = indexed;
		}
		public boolean isIndexed() {
			return this.indexed;
		}
		public boolean allowsFastEqualityCheck() {
			return this == UNIFORM || this == NUMERICALLY_INDEXED;
		}
		public boolean allowsDashIgnoringEqualityCheck() {
			return allowsFastEqualityCheck() || this == DASHED;
		}
	}
	/**
	 * Predicate used to filter element chars.
	 */
	private interface ElementCharPredicate {
		boolean test(char ch, int index);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public class InvalidConfigurationPropertyNameException extends RuntimeException {
	private final CharSequence name;
	private final List<Character> invalidCharacters;
	public InvalidConfigurationPropertyNameException(CharSequence name, List<Character> invalidCharacters) {
		super('Configuration property name "' + name + '" is not valid');
		this.name = name;
		this.invalidCharacters = invalidCharacters;
	}
	public List<Character> getInvalidCharacters() {
		return this.invalidCharacters;
	}
	public CharSequence getName() {
		return this.name;
	}
	public static void throwIfHasInvalidChars(CharSequence name, List<Character> invalidCharacters) {
		if (!invalidCharacters.isEmpty()) {
			throw new InvalidConfigurationPropertyNameException(name, invalidCharacters);
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class PrefixedIterableConfigurationPropertySource extends PrefixedConfigurationPropertySource
		implements IterableConfigurationPropertySource {
	PrefixedIterableConfigurationPropertySource(IterableConfigurationPropertySource source, String prefix) {
		super(source, prefix);
	}
	@Override
	public Stream<ConfigurationPropertyName> stream() {
		return getSource().stream().map(this::stripPrefix);
	}
	private ConfigurationPropertyName stripPrefix(ConfigurationPropertyName name) {
		return (getPrefix().isAncestorOf(name)) ? name.subName(getPrefix().getNumberOfElements()) : name;
	}
	@Override
	protected IterableConfigurationPropertySource getSource() {
		return (IterableConfigurationPropertySource) super.getSource();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class AliasedIterableConfigurationPropertySource extends AliasedConfigurationPropertySource
		implements IterableConfigurationPropertySource {
	AliasedIterableConfigurationPropertySource(IterableConfigurationPropertySource source,
			ConfigurationPropertyNameAliases aliases) {
		super(source, aliases);
	}
	@Override
	public Stream<ConfigurationPropertyName> stream() {
		return getSource().stream().flatMap(this::addAliases);
	}
	private Stream<ConfigurationPropertyName> addAliases(ConfigurationPropertyName name) {
		Stream<ConfigurationPropertyName> names = Stream.of(name);
		List<ConfigurationPropertyName> aliases = getAliases().getAliases(name);
		if (CollectionUtils.isEmpty(aliases)) {
			return names;
		}
		return Stream.concat(names, aliases.stream());
	}
	@Override
	protected IterableConfigurationPropertySource getSource() {
		return (IterableConfigurationPropertySource) super.getSource();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
@FunctionalInterface
public interface ConfigurationPropertySource {
	/**
	 * Return a single {@link ConfigurationProperty} from the source or {@code null} if no
	 * property can be found.
	 * @param name the name of the property (must not be {@code null})
	 * @return the associated object or {@code null}.
	 */
	ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name);
	/**
	 * Returns if the source contains any descendants of the specified name. May return
	 * {@link ConfigurationPropertyState#PRESENT} or
	 * {@link ConfigurationPropertyState#ABSENT} if an answer can be determined or
	 * {@link ConfigurationPropertyState#UNKNOWN} if it"s not possible to determine a
	 * definitive answer.
	 * @param name the name to check
	 * @return if the source contains any descendants
	 */
	default ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		return ConfigurationPropertyState.UNKNOWN;
	}
	/**
	 * Return a filtered variant of this source, containing only names that match the
	 * given {@link Predicate}.
	 * @param filter the filter to match
	 * @return a filtered {@link ConfigurationPropertySource} instance
	 */
	default ConfigurationPropertySource filter(Predicate<ConfigurationPropertyName> filter) {
		return new FilteredConfigurationPropertiesSource(this, filter);
	}
	/**
	 * Return a variant of this source that supports name aliases.
	 * @param aliases a function that returns a stream of aliases for any given name
	 * @return a {@link ConfigurationPropertySource} instance supporting name aliases
	 */
	default ConfigurationPropertySource withAliases(ConfigurationPropertyNameAliases aliases) {
		return new AliasedConfigurationPropertySource(this, aliases);
	}
	/**
	 * Return a variant of this source that supports a prefix.
	 * @param prefix the prefix for properties in the source
	 * @return a {@link ConfigurationPropertySource} instance supporting a prefix
	 * @since 2.5.0
	 */
	default ConfigurationPropertySource withPrefix(String prefix) {
		return (StringUtils.hasText(prefix)) ? new PrefixedConfigurationPropertySource(this, prefix) : this;
	}
	/**
	 * Return the underlying source that is actually providing the properties.
	 * @return the underlying property source or {@code null}.
	 */
	default Object getUnderlyingSource() {
		return null;
	}
	/**
	 * Return a single new {@link ConfigurationPropertySource} adapted from the given
	 * Spring {@link PropertySource} or {@code null} if the source cannot be adapted.
	 * @param source the Spring property source to adapt
	 * @return an adapted source or {@code null} {@link SpringConfigurationPropertySource}
	 * @since 2.4.0
	 */
	static ConfigurationPropertySource from(PropertySource<?> source) {
		if (source instanceof ConfigurationPropertySourcesPropertySource) {
			return null;
		}
		return SpringConfigurationPropertySource.from(source);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public class MapConfigurationPropertySource implements IterableConfigurationPropertySource {
	private static final PropertyMapper[] DEFAULT_MAPPERS = { DefaultPropertyMapper.INSTANCE };
	private final Map<String, Object> source;
	private final IterableConfigurationPropertySource delegate;
	/**
	 * Create a new empty {@link MapConfigurationPropertySource} instance.
	 */
	public MapConfigurationPropertySource() {
		this(Collections.emptyMap());
	}
	/**
	 * Create a new {@link MapConfigurationPropertySource} instance with entries copies
	 * from the specified map.
	 * @param map the source map
	 */
	public MapConfigurationPropertySource(Map<?, ?> map) {
		this.source = new LinkedHashMap<>();
		MapPropertySource mapPropertySource = new MapPropertySource('source', this.source);
		this.delegate = new SpringIterableConfigurationPropertySource(mapPropertySource, DEFAULT_MAPPERS);
		putAll(map);
	}
	/**
	 * Add all entries from the specified map.
	 * @param map the source map
	 */
	public void putAll(Map<?, ?> map) {
		Assert.notNull(map, 'Map must not be null');
		assertNotReadOnlySystemAttributesMap(map);
		map.forEach(this::put);
	}
	/**
	 * Add an individual entry.
	 * @param name the name
	 * @param value the value
	 */
	public void put(Object name, Object value) {
		this.source.put((name != null) ? name.toString() : null, value);
	}
	@Override
	public Object getUnderlyingSource() {
		return this.source;
	}
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		return this.delegate.getConfigurationProperty(name);
	}
	@Override
	public Iterator<ConfigurationPropertyName> iterator() {
		return this.delegate.iterator();
	}
	@Override
	public Stream<ConfigurationPropertyName> stream() {
		return this.delegate.stream();
	}
	private void assertNotReadOnlySystemAttributesMap(Map<?, ?> map) {
		try {
			map.size();
		}
		catch (UnsupportedOperationException ex) {
			throw new IllegalArgumentException('Security restricted maps are not supported', ex);
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
final class SystemEnvironmentPropertyMapper implements PropertyMapper {
	public static final PropertyMapper INSTANCE = new SystemEnvironmentPropertyMapper();
	@Override
	public List<String> map(ConfigurationPropertyName configurationPropertyName) {
		String name = convertName(configurationPropertyName);
		String legacyName = convertLegacyName(configurationPropertyName);
		if (name.equals(legacyName)) {
			return Collections.singletonList(name);
		}
		return Arrays.asList(name, legacyName);
	}
	private String convertName(ConfigurationPropertyName name) {
		return convertName(name, name.getNumberOfElements());
	}
	private String convertName(ConfigurationPropertyName name, int numberOfElements) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < numberOfElements; i++) {
			if (!result.isEmpty()) {
				result.append("_");
			}
			result.append(name.getElement(i, Form.UNIFORM).toUpperCase(Locale.ENGLISH));
		}
		return result.toString();
	}
	private String convertLegacyName(ConfigurationPropertyName name) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < name.getNumberOfElements(); i++) {
			if (!result.isEmpty()) {
				result.append("_");
			}
			result.append(convertLegacyNameElement(name.getElement(i, Form.ORIGINAL)));
		}
		return result.toString();
	}
	private Object convertLegacyNameElement(String element) {
		return element.replace("-", "_").toUpperCase(Locale.ENGLISH);
	}
	@Override
	public ConfigurationPropertyName map(String propertySourceName) {
		return convertName(propertySourceName);
	}
	private ConfigurationPropertyName convertName(String propertySourceName) {
		try {
			return ConfigurationPropertyName.adapt(propertySourceName, "_", this::processElementValue);
		}
		catch (Exception ex) {
			return ConfigurationPropertyName.EMPTY;
		}
	}
	private CharSequence processElementValue(CharSequence value) {
		String result = value.toString().toLowerCase(Locale.ENGLISH);
		return isNumber(result) ? '[' + result + ']' : result;
	}
	private static boolean isNumber(String string) {
		return string.chars().allMatch(Character::isDigit);
	}
	@Override
	public BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> getAncestorOfCheck() {
		return this::isAncestorOf;
	}
	private boolean isAncestorOf(ConfigurationPropertyName name, ConfigurationPropertyName candidate) {
		return name.isAncestorOf(candidate) || isLegacyAncestorOf(name, candidate);
	}
	private boolean isLegacyAncestorOf(ConfigurationPropertyName name, ConfigurationPropertyName candidate) {
		if (!hasDashedEntries(name)) {
			return false;
		}
		ConfigurationPropertyName legacyCompatibleName = buildLegacyCompatibleName(name);
		return legacyCompatibleName != null && legacyCompatibleName.isAncestorOf(candidate);
	}
	private ConfigurationPropertyName buildLegacyCompatibleName(ConfigurationPropertyName name) {
		StringBuilder legacyCompatibleName = new StringBuilder();
		for (int i = 0; i < name.getNumberOfElements(); i++) {
			if (i != 0) {
				legacyCompatibleName.append(".");
			}
			legacyCompatibleName.append(name.getElement(i, Form.DASHED).replace("-", "."));
		}
		return ConfigurationPropertyName.ofIfValid(legacyCompatibleName);
	}
	boolean hasDashedEntries(ConfigurationPropertyName name) {
		for (int i = 0; i < name.getNumberOfElements(); i++) {
			if (name.getElement(i, Form.DASHED).indexOf("-") != -1) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SpringIterableConfigurationPropertySource extends SpringConfigurationPropertySource
		implements IterableConfigurationPropertySource, CachingConfigurationPropertySource {
	private final BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> ancestorOfCheck;
	private final SoftReferenceConfigurationPropertyCache<Mappings> cache;
	private volatile ConfigurationPropertyName[] configurationPropertyNames;
	SpringIterableConfigurationPropertySource(EnumerablePropertySource<?> propertySource, PropertyMapper... mappers) {
		super(propertySource, mappers);
		assertEnumerablePropertySource();
		this.ancestorOfCheck = getAncestorOfCheck(mappers);
		this.cache = new SoftReferenceConfigurationPropertyCache<>(isImmutablePropertySource());
	}
	private BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> getAncestorOfCheck(
			PropertyMapper[] mappers) {
		BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> ancestorOfCheck = mappers[0]
			.getAncestorOfCheck();
		for (int i = 1; i < mappers.length; i++) {
			ancestorOfCheck = ancestorOfCheck.or(mappers[i].getAncestorOfCheck());
		}
		return ancestorOfCheck;
	}
	private void assertEnumerablePropertySource() {
		if (getPropertySource() instanceof MapPropertySource mapSource) {
			try {
				mapSource.getSource().size();
			}
			catch (UnsupportedOperationException ex) {
				throw new IllegalArgumentException('PropertySource must be fully enumerable');
			}
		}
	}
	@Override
	public ConfigurationPropertyCaching getCaching() {
		return this.cache;
	}
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		if (name == null) {
			return null;
		}
		ConfigurationProperty configurationProperty = super.getConfigurationProperty(name);
		if (configurationProperty != null) {
			return configurationProperty;
		}
		for (String candidate : getMappings().getMapped(name)) {
			Object value = getPropertySource().getProperty(candidate);
			if (value != null) {
				Origin origin = PropertySourceOrigin.get(getPropertySource(), candidate);
				return ConfigurationProperty.of(this, name, value, origin);
			}
		}
		return null;
	}
	@Override
	public Stream<ConfigurationPropertyName> stream() {
		ConfigurationPropertyName[] names = getConfigurationPropertyNames();
		return Arrays.stream(names).filter(Objects::nonNull);
	}
	@Override
	public Iterator<ConfigurationPropertyName> iterator() {
		return new ConfigurationPropertyNamesIterator(getConfigurationPropertyNames());
	}
	@Override
	public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		ConfigurationPropertyState result = super.containsDescendantOf(name);
		if (result != ConfigurationPropertyState.UNKNOWN) {
			return result;
		}
		if (this.ancestorOfCheck == PropertyMapper.DEFAULT_ANCESTOR_OF_CHECK) {
			return getMappings().containsDescendantOf(name, this.ancestorOfCheck);
		}
		ConfigurationPropertyName[] candidates = getConfigurationPropertyNames();
		for (ConfigurationPropertyName candidate : candidates) {
			if (candidate != null && this.ancestorOfCheck.test(name, candidate)) {
				return ConfigurationPropertyState.PRESENT;
			}
		}
		return ConfigurationPropertyState.ABSENT;
	}
	private ConfigurationPropertyName[] getConfigurationPropertyNames() {
		if (!isImmutablePropertySource()) {
			return getMappings().getConfigurationPropertyNames(getPropertySource().getPropertyNames());
		}
		ConfigurationPropertyName[] configurationPropertyNames = this.configurationPropertyNames;
		if (configurationPropertyNames == null) {
			configurationPropertyNames = getMappings()
				.getConfigurationPropertyNames(getPropertySource().getPropertyNames());
			this.configurationPropertyNames = configurationPropertyNames;
		}
		return configurationPropertyNames;
	}
	private Mappings getMappings() {
		return this.cache.get(this::createMappings, this::updateMappings);
	}
	private Mappings createMappings() {
		return new Mappings(getMappers(), isImmutablePropertySource(),
				this.ancestorOfCheck == PropertyMapper.DEFAULT_ANCESTOR_OF_CHECK);
	}
	private Mappings updateMappings(Mappings mappings) {
		mappings.updateMappings(getPropertySource()::getPropertyNames);
		return mappings;
	}
	private boolean isImmutablePropertySource() {
		EnumerablePropertySource<?> source = getPropertySource();
		if (source instanceof OriginLookup<?> originLookup) {
			return originLookup.isImmutable();
		}
		if (StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME.equals(source.getName())) {
			return source.getSource() == System.getenv();
		}
		return false;
	}
	@Override
	protected EnumerablePropertySource<?> getPropertySource() {
		return (EnumerablePropertySource<?>) super.getPropertySource();
	}
	private static class Mappings {
		private static final ConfigurationPropertyName[] EMPTY_NAMES_ARRAY = {};
		private final PropertyMapper[] mappers;
		private final boolean immutable;
		private final boolean trackDescendants;
		private volatile Map<ConfigurationPropertyName, Set<String>> mappings;
		private volatile Map<String, ConfigurationPropertyName> reverseMappings;
		private volatile Map<ConfigurationPropertyName, Set<ConfigurationPropertyName>> descendants;
		private volatile ConfigurationPropertyName[] configurationPropertyNames;
		private volatile String[] lastUpdated;
		Mappings(PropertyMapper[] mappers, boolean immutable, boolean trackDescendants) {
			this.mappers = mappers;
			this.immutable = immutable;
			this.trackDescendants = trackDescendants;
		}
		void updateMappings(Supplier<String[]> propertyNames) {
			if (this.mappings == null || !this.immutable) {
				int count = 0;
				while (true) {
					try {
						updateMappings(propertyNames.get());
						return;
					}
					catch (ConcurrentModificationException ex) {
						if (count++ > 10) {
							throw ex;
						}
					}
				}
			}
		}
		private void updateMappings(String[] propertyNames) {
			String[] lastUpdated = this.lastUpdated;
			if (lastUpdated != null && Arrays.equals(lastUpdated, propertyNames)) {
				return;
			}
			int size = propertyNames.length;
			Map<ConfigurationPropertyName, Set<String>> mappings = cloneOrCreate(this.mappings, size);
			Map<String, ConfigurationPropertyName> reverseMappings = cloneOrCreate(this.reverseMappings, size);
			Map<ConfigurationPropertyName, Set<ConfigurationPropertyName>> descendants = cloneOrCreate(this.descendants,
					size);
			for (PropertyMapper propertyMapper : this.mappers) {
				for (String propertyName : propertyNames) {
					if (!reverseMappings.containsKey(propertyName)) {
						ConfigurationPropertyName configurationPropertyName = propertyMapper.map(propertyName);
						if (configurationPropertyName != null && !configurationPropertyName.isEmpty()) {
							add(mappings, configurationPropertyName, propertyName);
							reverseMappings.put(propertyName, configurationPropertyName);
							if (this.trackDescendants) {
								addParents(descendants, configurationPropertyName);
							}
						}
					}
				}
			}
			this.mappings = mappings;
			this.reverseMappings = reverseMappings;
			this.descendants = descendants;
			this.lastUpdated = this.immutable ? null : propertyNames;
			this.configurationPropertyNames = this.immutable
					? reverseMappings.values().toArray(new ConfigurationPropertyName[0]) : null;
		}
		private <K, V> Map<K, V> cloneOrCreate(Map<K, V> source, int size) {
			return (source != null) ? new LinkedHashMap<>(source) : new LinkedHashMap<>(size);
		}
		private void addParents(Map<ConfigurationPropertyName, Set<ConfigurationPropertyName>> descendants,
				ConfigurationPropertyName name) {
			ConfigurationPropertyName parent = name;
			while (!parent.isEmpty()) {
				add(descendants, parent, name);
				parent = parent.getParent();
			}
		}
		private <K, T> void add(Map<K, Set<T>> map, K key, T value) {
			map.computeIfAbsent(key, (k) -> new HashSet<>()).add(value);
		}
		Set<String> getMapped(ConfigurationPropertyName configurationPropertyName) {
			return this.mappings.getOrDefault(configurationPropertyName, Collections.emptySet());
		}
		ConfigurationPropertyName[] getConfigurationPropertyNames(String[] propertyNames) {
			ConfigurationPropertyName[] names = this.configurationPropertyNames;
			if (names != null) {
				return names;
			}
			Map<String, ConfigurationPropertyName> reverseMappings = this.reverseMappings;
			if (reverseMappings == null || reverseMappings.isEmpty()) {
				return EMPTY_NAMES_ARRAY;
			}
			names = new ConfigurationPropertyName[propertyNames.length];
			for (int i = 0; i < propertyNames.length; i++) {
				names[i] = reverseMappings.get(propertyNames[i]);
			}
			return names;
		}
		ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name,
				BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> ancestorOfCheck) {
			if (name.isEmpty() && !this.descendants.isEmpty()) {
				return ConfigurationPropertyState.PRESENT;
			}
			Set<ConfigurationPropertyName> candidates = this.descendants.getOrDefault(name, Collections.emptySet());
			for (ConfigurationPropertyName candidate : candidates) {
				if (ancestorOfCheck.test(name, candidate)) {
					return ConfigurationPropertyState.PRESENT;
				}
			}
			return ConfigurationPropertyState.ABSENT;
		}
	}
	/**
	 * ConfigurationPropertyNames iterator backed by an array.
	 */
	private static class ConfigurationPropertyNamesIterator implements Iterator<ConfigurationPropertyName> {
		private final ConfigurationPropertyName[] names;
		private int index = 0;
		ConfigurationPropertyNamesIterator(ConfigurationPropertyName[] names) {
			this.names = names;
		}
		@Override
		public boolean hasNext() {
			skipNulls();
			return this.index < this.names.length;
		}
		@Override
		public ConfigurationPropertyName next() {
			skipNulls();
			if (this.index >= this.names.length) {
				throw new NoSuchElementException();
			}
			return this.names[this.index++];
		}
		private void skipNulls() {
			while (this.index < this.names.length) {
				if (this.names[this.index] != null) {
					return;
				}
				this.index++;
			}
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourcesPropertySource extends PropertySource<Iterable<ConfigurationPropertySource>>
		implements OriginLookup<String> {
	ConfigurationPropertySourcesPropertySource(String name, Iterable<ConfigurationPropertySource> source) {
		super(name, source);
	}
	@Override
	public boolean containsProperty(String name) {
		return findConfigurationProperty(name) != null;
	}
	@Override
	public Object getProperty(String name) {
		ConfigurationProperty configurationProperty = findConfigurationProperty(name);
		return (configurationProperty != null) ? configurationProperty.getValue() : null;
	}
	@Override
	public Origin getOrigin(String name) {
		return Origin.from(findConfigurationProperty(name));
	}
	private ConfigurationProperty findConfigurationProperty(String name) {
		try {
			return findConfigurationProperty(ConfigurationPropertyName.of(name, true));
		}
		catch (Exception ex) {
			return null;
		}
	}
	ConfigurationProperty findConfigurationProperty(ConfigurationPropertyName name) {
		if (name == null) {
			return null;
		}
		for (ConfigurationPropertySource configurationPropertySource : getSource()) {
			ConfigurationProperty configurationProperty = configurationPropertySource.getConfigurationProperty(name);
			if (configurationProperty != null) {
				return configurationProperty;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class AliasedConfigurationPropertySource implements ConfigurationPropertySource {
	private final ConfigurationPropertySource source;
	private final ConfigurationPropertyNameAliases aliases;
	AliasedConfigurationPropertySource(ConfigurationPropertySource source, ConfigurationPropertyNameAliases aliases) {
		Assert.notNull(source, 'Source must not be null');
		Assert.notNull(aliases, 'Aliases must not be null');
		this.source = source;
		this.aliases = aliases;
	}
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		Assert.notNull(name, 'Name must not be null');
		ConfigurationProperty result = getSource().getConfigurationProperty(name);
		if (result == null) {
			ConfigurationPropertyName aliasedName = getAliases().getNameForAlias(name);
			result = getSource().getConfigurationProperty(aliasedName);
		}
		return result;
	}
	@Override
	public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		Assert.notNull(name, 'Name must not be null');
		ConfigurationPropertyState result = this.source.containsDescendantOf(name);
		if (result != ConfigurationPropertyState.ABSENT) {
			return result;
		}
		for (ConfigurationPropertyName alias : getAliases().getAliases(name)) {
			ConfigurationPropertyState aliasResult = this.source.containsDescendantOf(alias);
			if (aliasResult != ConfigurationPropertyState.ABSENT) {
				return aliasResult;
			}
		}
		for (ConfigurationPropertyName from : getAliases()) {
			for (ConfigurationPropertyName alias : getAliases().getAliases(from)) {
				if (name.isAncestorOf(alias)) {
					if (this.source.getConfigurationProperty(from) != null) {
						return ConfigurationPropertyState.PRESENT;
					}
				}
			}
		}
		return ConfigurationPropertyState.ABSENT;
	}
	@Override
	public Object getUnderlyingSource() {
		return this.source.getUnderlyingSource();
	}
	protected ConfigurationPropertySource getSource() {
		return this.source;
	}
	protected ConfigurationPropertyNameAliases getAliases() {
		return this.aliases;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class FilteredConfigurationPropertiesSource implements ConfigurationPropertySource {
	private final ConfigurationPropertySource source;
	private final Predicate<ConfigurationPropertyName> filter;
	FilteredConfigurationPropertiesSource(ConfigurationPropertySource source,
			Predicate<ConfigurationPropertyName> filter) {
		Assert.notNull(source, 'Source must not be null');
		Assert.notNull(filter, 'Filter must not be null');
		this.source = source;
		this.filter = filter;
	}
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		boolean filtered = getFilter().test(name);
		return filtered ? getSource().getConfigurationProperty(name) : null;
	}
	@Override
	public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		ConfigurationPropertyState result = this.source.containsDescendantOf(name);
		if (result == ConfigurationPropertyState.PRESENT) {
			// We can"t be sure a contained descendant won"t be filtered
			return ConfigurationPropertyState.UNKNOWN;
		}
		return result;
	}
	@Override
	public Object getUnderlyingSource() {
		return this.source.getUnderlyingSource();
	}
	protected ConfigurationPropertySource getSource() {
		return this.source;
	}
	protected Predicate<ConfigurationPropertyName> getFilter() {
		return this.filter;
	}
	@Override
	public String toString() {
		return this.source.toString() + ' (filtered)';
	}
}
/*
/**
package org.springframework.boot.context.properties.source;
/*
package org.springframework.boot.context.properties.source;
/**
class SpringConfigurationPropertySources implements Iterable<ConfigurationPropertySource> {
	private final Iterable<PropertySource<?>> sources;
	private final Map<PropertySource<?>, ConfigurationPropertySource> cache = new ConcurrentReferenceHashMap<>(16,
			ReferenceType.SOFT);
	SpringConfigurationPropertySources(Iterable<PropertySource<?>> sources) {
		Assert.notNull(sources, 'Sources must not be null');
		this.sources = sources;
	}
	boolean isUsingSources(Iterable<PropertySource<?>> sources) {
		return this.sources == sources;
	}
	@Override
	public Iterator<ConfigurationPropertySource> iterator() {
		return new SourcesIterator(this.sources.iterator(), this::adapt);
	}
	private ConfigurationPropertySource adapt(PropertySource<?> source) {
		ConfigurationPropertySource result = this.cache.get(source);
		// Most PropertySources test equality only using the source name, so we need to
		// check the actual source hasn"t also changed.
		if (result != null && result.getUnderlyingSource() == source) {
			return result;
		}
		result = SpringConfigurationPropertySource.from(source);
		if (source instanceof OriginLookup<?> originLookup) {
			result = result.withPrefix(originLookup.getPrefix());
		}
		this.cache.put(source, result);
		return result;
	}
	private static class SourcesIterator implements Iterator<ConfigurationPropertySource> {
		private final Deque<Iterator<PropertySource<?>>> iterators;
		private ConfigurationPropertySource next;
		private final Function<PropertySource<?>, ConfigurationPropertySource> adapter;
		SourcesIterator(Iterator<PropertySource<?>> iterator,
				Function<PropertySource<?>, ConfigurationPropertySource> adapter) {
			this.iterators = new ArrayDeque<>(4);
			this.iterators.push(iterator);
			this.adapter = adapter;
		}
		@Override
		public boolean hasNext() {
			return fetchNext() != null;
		}
		@Override
		public ConfigurationPropertySource next() {
			ConfigurationPropertySource next = fetchNext();
			if (next == null) {
				throw new NoSuchElementException();
			}
			this.next = null;
			return next;
		}
		private ConfigurationPropertySource fetchNext() {
			if (this.next == null) {
				if (this.iterators.isEmpty()) {
					return null;
				}
				if (!this.iterators.peek().hasNext()) {
					this.iterators.pop();
					return fetchNext();
				}
				PropertySource<?> candidate = this.iterators.peek().next();
				if (candidate.getSource() instanceof ConfigurableEnvironment configurableEnvironment) {
					push(configurableEnvironment);
					return fetchNext();
				}
				if (isIgnored(candidate)) {
					return fetchNext();
				}
				this.next = this.adapter.apply(candidate);
			}
			return this.next;
		}
		private void push(ConfigurableEnvironment environment) {
			this.iterators.push(environment.getPropertySources().iterator());
		}
		private boolean isIgnored(PropertySource<?> candidate) {
			return (candidate instanceof StubPropertySource
					|| candidate instanceof ConfigurationPropertySourcesPropertySource);
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public interface ConfigurationPropertyCaching {
	/**
	 * Enable caching with an unlimited time-to-live.
	 */
	void enable();
	/**
	 * Disable caching.
	 */
	void disable();
	/**
	 * Set amount of time that an item can live in the cache. Calling this method will
	 * also enable the cache.
	 * @param timeToLive the time to live value.
	 */
	void setTimeToLive(Duration timeToLive);
	/**
	 * Clear the cache and force it to be reloaded on next access.
	 */
	void clear();
	/**
	 * Get for all configuration property sources in the environment.
	 * @param environment the spring environment
	 * @return a caching instance that controls all sources in the environment
	 */
	static ConfigurationPropertyCaching get(Environment environment) {
		return get(environment, null);
	}
	/**
	 * Get for a specific configuration property source in the environment.
	 * @param environment the spring environment
	 * @param underlyingSource the
	 * {@link ConfigurationPropertySource#getUnderlyingSource() underlying source} that
	 * must match
	 * @return a caching instance that controls the matching source
	 */
	static ConfigurationPropertyCaching get(Environment environment, Object underlyingSource) {
		Iterable<ConfigurationPropertySource> sources = ConfigurationPropertySources.get(environment);
		return get(sources, underlyingSource);
	}
	/**
	 * Get for all specified configuration property sources.
	 * @param sources the configuration property sources
	 * @return a caching instance that controls the sources
	 */
	static ConfigurationPropertyCaching get(Iterable<ConfigurationPropertySource> sources) {
		return get(sources, null);
	}
	/**
	 * Get for a specific configuration property source in the specified configuration
	 * property sources.
	 * @param sources the configuration property sources
	 * @param underlyingSource the
	 * {@link ConfigurationPropertySource#getUnderlyingSource() underlying source} that
	 * must match
	 * @return a caching instance that controls the matching source
	 */
	static ConfigurationPropertyCaching get(Iterable<ConfigurationPropertySource> sources, Object underlyingSource) {
		Assert.notNull(sources, 'Sources must not be null');
		if (underlyingSource == null) {
			return new ConfigurationPropertySourcesCaching(sources);
		}
		for (ConfigurationPropertySource source : sources) {
			if (source.getUnderlyingSource() == underlyingSource) {
				ConfigurationPropertyCaching caching = CachingConfigurationPropertySource.find(source);
				if (caching != null) {
					return caching;
				}
			}
		}
		throw new IllegalStateException('Unable to find cache from configuration property sources');
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public final class ConfigurationPropertySources {
	/**
	 * The name of the {@link PropertySource} {@link #attach(Environment) adapter}.
	 */
	private static final String ATTACHED_PROPERTY_SOURCE_NAME = 'configurationProperties';
	private ConfigurationPropertySources() {
	}
	/**
	 * Create a new {@link PropertyResolver} that resolves property values against an
	 * underlying set of {@link PropertySources}. Provides an
	 * {@link ConfigurationPropertySource} aware and optimized alternative to
	 * {@link PropertySourcesPropertyResolver}.
	 * @param propertySources the set of {@link PropertySource} objects to use
	 * @return a {@link ConfigurablePropertyResolver} implementation
	 * @since 2.5.0
	 */
	public static ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {
		return new ConfigurationPropertySourcesPropertyResolver(propertySources);
	}
	/**
	 * Determines if the specific {@link PropertySource} is the
	 * {@link ConfigurationPropertySource} that was {@link #attach(Environment) attached}
	 * to the {@link Environment}.
	 * @param propertySource the property source to test
	 * @return {@code true} if this is the attached {@link ConfigurationPropertySource}
	 */
	public static boolean isAttachedConfigurationPropertySource(PropertySource<?> propertySource) {
		return ATTACHED_PROPERTY_SOURCE_NAME.equals(propertySource.getName());
	}
	/**
	 * Attach a {@link ConfigurationPropertySource} support to the specified
	 * {@link Environment}. Adapts each {@link PropertySource} managed by the environment
	 * to a {@link ConfigurationPropertySource} and allows classic
	 * {@link PropertySourcesPropertyResolver} calls to resolve using
	 * {@link ConfigurationPropertyName configuration property names}.
	 * <p>
	 * The attached resolver will dynamically track any additions or removals from the
	 * underlying {@link Environment} property sources.
	 * @param environment the source environment (must be an instance of
	 * {@link ConfigurableEnvironment})
	 * @see #get(Environment)
	 */
	public static void attach(Environment environment) {
		Assert.isInstanceOf(ConfigurableEnvironment.class, environment);
		MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();
		PropertySource<?> attached = getAttached(sources);
		if (!isUsingSources(attached, sources)) {
			attached = new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME,
					new SpringConfigurationPropertySources(sources));
		}
		sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);
		sources.addFirst(attached);
	}
	private static boolean isUsingSources(PropertySource<?> attached, MutablePropertySources sources) {
		return attached instanceof ConfigurationPropertySourcesPropertySource
				&& ((SpringConfigurationPropertySources) attached.getSource()).isUsingSources(sources);
	}
	static PropertySource<?> getAttached(MutablePropertySources sources) {
		return (sources != null) ? sources.get(ATTACHED_PROPERTY_SOURCE_NAME) : null;
	}
	/**
	 * Return a set of {@link ConfigurationPropertySource} instances that have previously
	 * been {@link #attach(Environment) attached} to the {@link Environment}.
	 * @param environment the source environment (must be an instance of
	 * {@link ConfigurableEnvironment})
	 * @return an iterable set of configuration property sources
	 * @throws IllegalStateException if not configuration property sources have been
	 * attached
	 */
	public static Iterable<ConfigurationPropertySource> get(Environment environment) {
		Assert.isInstanceOf(ConfigurableEnvironment.class, environment);
		MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();
		ConfigurationPropertySourcesPropertySource attached = (ConfigurationPropertySourcesPropertySource) sources
			.get(ATTACHED_PROPERTY_SOURCE_NAME);
		if (attached == null) {
			return from(sources);
		}
		return attached.getSource();
	}
	/**
	 * Return {@link Iterable} containing a single new {@link ConfigurationPropertySource}
	 * adapted from the given Spring {@link PropertySource}.
	 * @param source the Spring property source to adapt
	 * @return an {@link Iterable} containing a single newly adapted
	 * {@link SpringConfigurationPropertySource}
	 */
	public static Iterable<ConfigurationPropertySource> from(PropertySource<?> source) {
		return Collections.singleton(ConfigurationPropertySource.from(source));
	}
	/**
	 * Return {@link Iterable} containing new {@link ConfigurationPropertySource}
	 * instances adapted from the given Spring {@link PropertySource PropertySources}.
	 * <p>
	 * This method will flatten any nested property sources and will filter all
	 * {@link StubPropertySource stub property sources}. Updates to the underlying source,
	 * identified by changes in the sources returned by its iterator, will be
	 * automatically tracked. The underlying source should be thread safe, for example a
	 * {@link MutablePropertySources}
	 * @param sources the Spring property sources to adapt
	 * @return an {@link Iterable} containing newly adapted
	 * {@link SpringConfigurationPropertySource} instances
	 */
	public static Iterable<ConfigurationPropertySource> from(Iterable<PropertySource<?>> sources) {
		return new SpringConfigurationPropertySources(sources);
	}
	private static Stream<PropertySource<?>> streamPropertySources(PropertySources sources) {
		return sources.stream()
			.flatMap(ConfigurationPropertySources::flatten)
			.filter(ConfigurationPropertySources::isIncluded);
	}
	private static Stream<PropertySource<?>> flatten(PropertySource<?> source) {
		if (source.getSource() instanceof ConfigurableEnvironment configurableEnvironment) {
			return streamPropertySources(configurableEnvironment.getPropertySources());
		}
		return Stream.of(source);
	}
	private static boolean isIncluded(PropertySource<?> source) {
		return !(source instanceof StubPropertySource)
				&& !(source instanceof ConfigurationPropertySourcesPropertySource);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public interface IterableConfigurationPropertySource
		extends ConfigurationPropertySource, Iterable<ConfigurationPropertyName> {
	/**
	 * Return an iterator for the {@link ConfigurationPropertyName names} managed by this
	 * source.
	 * @return an iterator (never {@code null})
	 */
	@Override
	default Iterator<ConfigurationPropertyName> iterator() {
		return stream().iterator();
	}
	/**
	 * Returns a sequential {@code Stream} for the {@link ConfigurationPropertyName names}
	 * managed by this source.
	 * @return a stream of names (never {@code null})
	 */
	Stream<ConfigurationPropertyName> stream();
	@Override
	default ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		return ConfigurationPropertyState.search(this, name::isAncestorOf);
	}
	@Override
	default IterableConfigurationPropertySource filter(Predicate<ConfigurationPropertyName> filter) {
		return new FilteredIterableConfigurationPropertiesSource(this, filter);
	}
	@Override
	default IterableConfigurationPropertySource withAliases(ConfigurationPropertyNameAliases aliases) {
		return new AliasedIterableConfigurationPropertySource(this, aliases);
	}
	@Override
	default IterableConfigurationPropertySource withPrefix(String prefix) {
		return (StringUtils.hasText(prefix)) ? new PrefixedIterableConfigurationPropertySource(this, prefix) : this;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
@SuppressWarnings('serial')
public class InvalidConfigurationPropertyValueException extends RuntimeException {
	private final String name;
	private final Object value;
	private final String reason;
	/**
	 * Creates a new instance for the specified property {@code name} and {@code value},
	 * including a {@code reason} why the value is invalid.
	 * @param name the name of the property in canonical format
	 * @param value the value of the property, can be {@code null}
	 * @param reason a human-readable text that describes why the reason is invalid.
	 * Starts with an upper-case and ends with a dot. Several sentences and carriage
	 * returns are allowed.
	 */
	public InvalidConfigurationPropertyValueException(String name, Object value, String reason) {
		super('Property ' + name + ' with value "' + value + '" is invalid: ' + reason);
		Assert.notNull(name, 'Name must not be null');
		this.name = name;
		this.value = value;
		this.reason = reason;
	}
	/**
	 * Return the name of the property.
	 * @return the property name
	 */
	public String getName() {
		return this.name;
	}
	/**
	 * Return the invalid value, can be {@code null}.
	 * @return the invalid value
	 */
	public Object getValue() {
		return this.value;
	}
	/**
	 * Return the reason why the value is invalid.
	 * @return the reason
	 */
	public String getReason() {
		return this.reason;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourcesCaching implements ConfigurationPropertyCaching {
	private final Iterable<ConfigurationPropertySource> sources;
	ConfigurationPropertySourcesCaching(Iterable<ConfigurationPropertySource> sources) {
		this.sources = sources;
	}
	@Override
	public void enable() {
		forEach(ConfigurationPropertyCaching::enable);
	}
	@Override
	public void disable() {
		forEach(ConfigurationPropertyCaching::disable);
	}
	@Override
	public void setTimeToLive(Duration timeToLive) {
		forEach((caching) -> caching.setTimeToLive(timeToLive));
	}
	@Override
	public void clear() {
		forEach(ConfigurationPropertyCaching::clear);
	}
	private void forEach(Consumer<ConfigurationPropertyCaching> action) {
		if (this.sources != null) {
			for (ConfigurationPropertySource source : this.sources) {
				ConfigurationPropertyCaching caching = CachingConfigurationPropertySource.find(source);
				if (caching != null) {
					action.accept(caching);
				}
			}
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public enum ConfigurationPropertyState {
	/**
	 * The {@link ConfigurationPropertySource} has at least one matching
	 * {@link ConfigurationProperty}.
	 */
	PRESENT,
	/**
	 * The {@link ConfigurationPropertySource} has no matching
	 * {@link ConfigurationProperty ConfigurationProperties}.
	 */
	ABSENT,
	/**
	 * It"s not possible to determine if {@link ConfigurationPropertySource} has matching
	 * {@link ConfigurationProperty ConfigurationProperties} or not.
	 */
	UNKNOWN;
	/**
	 * Search the given iterable using a predicate to determine if content is
	 * {@link #PRESENT} or {@link #ABSENT}.
	 * @param <T> the data type
	 * @param source the source iterable to search
	 * @param predicate the predicate used to test for presence
	 * @return {@link #PRESENT} if the iterable contains a matching item, otherwise
	 * {@link #ABSENT}.
	 */
	static <T> ConfigurationPropertyState search(Iterable<T> source, Predicate<T> predicate) {
		Assert.notNull(source, 'Source must not be null');
		Assert.notNull(predicate, 'Predicate must not be null');
		for (T item : source) {
			if (predicate.test(item)) {
				return PRESENT;
			}
		}
		return ABSENT;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
interface PropertyMapper {
	/**
	 * The default ancestor of check.
	 */
	BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> DEFAULT_ANCESTOR_OF_CHECK = ConfigurationPropertyName::isAncestorOf;
	/**
	 * Provide mappings from a {@link ConfigurationPropertySource}
	 * {@link ConfigurationPropertyName}.
	 * @param configurationPropertyName the name to map
	 * @return the mapped names or an empty list
	 */
	List<String> map(ConfigurationPropertyName configurationPropertyName);
	/**
	 * Provide mappings from a {@link PropertySource} property name.
	 * @param propertySourceName the name to map
	 * @return the mapped configuration property name or
	 * {@link ConfigurationPropertyName#EMPTY}
	 */
	ConfigurationPropertyName map(String propertySourceName);
	/**
	 * Returns a {@link BiPredicate} that can be used to check if one name is an ancestor
	 * of another when considering the mapping rules.
	 * @return a predicate that can be used to check if one name is an ancestor of another
	 */
	default BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> getAncestorOfCheck() {
		return DEFAULT_ANCESTOR_OF_CHECK;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourcesPropertyResolver extends AbstractPropertyResolver {
	private final MutablePropertySources propertySources;
	private final DefaultResolver defaultResolver;
	ConfigurationPropertySourcesPropertyResolver(MutablePropertySources propertySources) {
		this.propertySources = propertySources;
		this.defaultResolver = new DefaultResolver(propertySources);
	}
	@Override
	public boolean containsProperty(String key) {
		ConfigurationPropertySourcesPropertySource attached = getAttached();
		if (attached != null) {
			ConfigurationPropertyName name = ConfigurationPropertyName.of(key, true);
			if (name != null) {
				try {
					return attached.findConfigurationProperty(name) != null;
				}
				catch (Exception ex) {
					// Ignore
				}
			}
		}
		return this.defaultResolver.containsProperty(key);
	}
	@Override
	public String getProperty(String key) {
		return getProperty(key, String.class, true);
	}
	@Override
	public <T> T getProperty(String key, Class<T> targetValueType) {
		return getProperty(key, targetValueType, true);
	}
	@Override
	protected String getPropertyAsRawString(String key) {
		return getProperty(key, String.class, false);
	}
	private <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {
		Object value = findPropertyValue(key);
		if (value == null) {
			return null;
		}
		if (resolveNestedPlaceholders && value instanceof String string) {
			value = resolveNestedPlaceholders(string);
		}
		return convertValueIfNecessary(value, targetValueType);
	}
	private Object findPropertyValue(String key) {
		ConfigurationPropertySourcesPropertySource attached = getAttached();
		if (attached != null) {
			ConfigurationPropertyName name = ConfigurationPropertyName.of(key, true);
			if (name != null) {
				try {
					ConfigurationProperty configurationProperty = attached.findConfigurationProperty(name);
					return (configurationProperty != null) ? configurationProperty.getValue() : null;
				}
				catch (Exception ex) {
					// Ignore
				}
			}
		}
		return this.defaultResolver.getProperty(key, Object.class, false);
	}
	private ConfigurationPropertySourcesPropertySource getAttached() {
		ConfigurationPropertySourcesPropertySource attached = (ConfigurationPropertySourcesPropertySource) ConfigurationPropertySources
			.getAttached(this.propertySources);
		Iterable<ConfigurationPropertySource> attachedSource = (attached != null) ? attached.getSource() : null;
		if ((attachedSource instanceof SpringConfigurationPropertySources springSource)
				&& springSource.isUsingSources(this.propertySources)) {
			return attached;
		}
		return null;
	}
	/**
	 * Default {@link PropertySourcesPropertyResolver} used if
	 * {@link ConfigurationPropertySources} is not attached.
	 */
	static class DefaultResolver extends PropertySourcesPropertyResolver {
		DefaultResolver(PropertySources propertySources) {
			super(propertySources);
		}
		@Override
		public <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {
			return super.getProperty(key, targetValueType, resolveNestedPlaceholders);
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesScanRegistrar implements ImportBeanDefinitionRegistrar {
	private final Environment environment;
	private final ResourceLoader resourceLoader;
	ConfigurationPropertiesScanRegistrar(Environment environment, ResourceLoader resourceLoader) {
		this.environment = environment;
		this.resourceLoader = resourceLoader;
	}
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		Set<String> packagesToScan = getPackagesToScan(importingClassMetadata);
		scan(registry, packagesToScan);
	}
	private Set<String> getPackagesToScan(AnnotationMetadata metadata) {
		AnnotationAttributes attributes = AnnotationAttributes
			.fromMap(metadata.getAnnotationAttributes(ConfigurationPropertiesScan.class.getName()));
		String[] basePackages = attributes.getStringArray('basePackages');
		Class<?>[] basePackageClasses = attributes.getClassArray('basePackageClasses');
		Set<String> packagesToScan = new LinkedHashSet<>(Arrays.asList(basePackages));
		for (Class<?> basePackageClass : basePackageClasses) {
			packagesToScan.add(ClassUtils.getPackageName(basePackageClass));
		}
		if (packagesToScan.isEmpty()) {
			packagesToScan.add(ClassUtils.getPackageName(metadata.getClassName()));
		}
		packagesToScan.removeIf((candidate) -> !StringUtils.hasText(candidate));
		return packagesToScan;
	}
	private void scan(BeanDefinitionRegistry registry, Set<String> packages) {
		ConfigurationPropertiesBeanRegistrar registrar = new ConfigurationPropertiesBeanRegistrar(registry);
		ClassPathScanningCandidateComponentProvider scanner = getScanner(registry);
		for (String basePackage : packages) {
			for (BeanDefinition candidate : scanner.findCandidateComponents(basePackage)) {
				register(registrar, candidate.getBeanClassName());
			}
		}
	}
	private ClassPathScanningCandidateComponentProvider getScanner(BeanDefinitionRegistry registry) {
		ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);
		scanner.setEnvironment(this.environment);
		scanner.setResourceLoader(this.resourceLoader);
		scanner.addIncludeFilter(new AnnotationTypeFilter(ConfigurationProperties.class));
		TypeExcludeFilter typeExcludeFilter = new TypeExcludeFilter();
		typeExcludeFilter.setBeanFactory((BeanFactory) registry);
		scanner.addExcludeFilter(typeExcludeFilter);
		return scanner;
	}
	private void register(ConfigurationPropertiesBeanRegistrar registrar, String className) throws LinkageError {
		try {
			register(registrar, ClassUtils.forName(className, null));
		}
		catch (ClassNotFoundException ex) {
			// Ignore
		}
	}
	private void register(ConfigurationPropertiesBeanRegistrar registrar, Class<?> type) {
		if (!isComponent(type)) {
			registrar.register(type);
		}
	}
	private boolean isComponent(Class<?> type) {
		return MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY).isPresent(Component.class);
	}
}
/*
package org.springframework.boot.context.properties;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(ConfigurationPropertiesScanRegistrar.class)
@EnableConfigurationProperties
public @interface ConfigurationPropertiesScan {
	/**
	 * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation
	 * declarations e.g.: {@code @ConfigurationPropertiesScan('org.my.pkg')} instead of
	 * {@code @ConfigurationPropertiesScan(basePackages='org.my.pkg')}.
	 * @return the base packages to scan
	 */
	@AliasFor('basePackages')
	String[] value() default {};
	/**
	 * Base packages to scan for configuration properties. {@link #value()} is an alias
	 * for (and mutually exclusive with) this attribute.
	 * <p>
	 * Use {@link #basePackageClasses()} for a type-safe alternative to String-based
	 * package names.
	 * @return the base packages to scan
	 */
	@AliasFor('value')
	String[] basePackages() default {};
	/**
	 * Type-safe alternative to {@link #basePackages()} for specifying the packages to
	 * scan for configuration properties. The package of each class specified will be
	 * scanned.
	 * <p>
	 * Consider creating a special no-op marker class or interface in each package that
	 * serves no purpose other than being referenced by this attribute.
	 * @return classes from the base packages to scan
	 */
	Class<?>[] basePackageClasses() default {};
}
/*
package org.springframework.boot.context.properties;
/**
final class ConfigurationPropertiesBeanRegistrar {
	private static final ScopeMetadataResolver scopeMetadataResolver = new AnnotationScopeMetadataResolver();
	private final BeanDefinitionRegistry registry;
	private final BeanFactory beanFactory;
	ConfigurationPropertiesBeanRegistrar(BeanDefinitionRegistry registry) {
		this.registry = registry;
		this.beanFactory = (BeanFactory) this.registry;
	}
	void register(Class<?> type) {
		MergedAnnotation<ConfigurationProperties> annotation = MergedAnnotations
			.from(type, SearchStrategy.TYPE_HIERARCHY)
			.get(ConfigurationProperties.class);
		register(type, annotation);
	}
	void register(Class<?> type, MergedAnnotation<ConfigurationProperties> annotation) {
		String name = getName(type, annotation);
		if (!containsBeanDefinition(name)) {
			registerBeanDefinition(name, type, annotation);
		}
	}
	private String getName(Class<?> type, MergedAnnotation<ConfigurationProperties> annotation) {
		String prefix = annotation.isPresent() ? annotation.getString('prefix') : '';
		return (StringUtils.hasText(prefix) ? prefix + '-' + type.getName() : type.getName());
	}
	private boolean containsBeanDefinition(String name) {
		return (this.beanFactory instanceof ListableBeanFactory listableBeanFactory
				&& listableBeanFactory.containsBeanDefinition(name));
	}
	private void registerBeanDefinition(String beanName, Class<?> type,
			MergedAnnotation<ConfigurationProperties> annotation) {
		Assert.state(annotation.isPresent(), () -> 'No ' + ConfigurationProperties.class.getSimpleName()
				+ ' annotation found on  "' + type.getName() + '".');
		BeanDefinitionReaderUtils.registerBeanDefinition(createBeanDefinition(beanName, type), this.registry);
	}
	private BeanDefinitionHolder createBeanDefinition(String beanName, Class<?> type) {
		AnnotatedGenericBeanDefinition definition = new AnnotatedGenericBeanDefinition(type);
		AnnotationConfigUtils.processCommonDefinitionAnnotations(definition);
		BindMethod bindMethod = ConfigurationPropertiesBean.deduceBindMethod(type);
		BindMethodAttribute.set(definition, bindMethod);
		if (bindMethod == BindMethod.VALUE_OBJECT) {
			definition.setInstanceSupplier(() -> ConstructorBound.from(this.beanFactory, beanName, type));
		}
		ScopeMetadata metadata = scopeMetadataResolver.resolveScopeMetadata(definition);
		definition.setScope(metadata.getScopeName());
		BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(definition, beanName);
		return applyScopedProxyMode(metadata, definitionHolder, this.registry);
	}
	static BeanDefinitionHolder applyScopedProxyMode(ScopeMetadata metadata, BeanDefinitionHolder definition,
			BeanDefinitionRegistry registry) {
		ScopedProxyMode mode = metadata.getScopedProxyMode();
		if (mode != ScopedProxyMode.NO) {
			return ScopedProxyUtils.createScopedProxy(definition, registry, mode == ScopedProxyMode.TARGET_CLASS);
		}
		return definition;
	}
}
/*
/**
package org.springframework.boot.context.properties;
/*
package org.springframework.boot.context.properties;
/**
public class IncompatibleConfigurationException extends RuntimeException {
	private final List<String> incompatibleKeys;
	public IncompatibleConfigurationException(String... incompatibleKeys) {
		super('The following configuration properties have incompatible values: ' + Arrays.toString(incompatibleKeys));
		this.incompatibleKeys = Arrays.asList(incompatibleKeys);
	}
	public Collection<String> getIncompatibleKeys() {
		return this.incompatibleKeys;
	}
}
/*
package org.springframework.boot.context.properties;
/**
class PropertySourcesDeducer {
	private static final Log logger = LogFactory.getLog(PropertySourcesDeducer.class);
	private final ApplicationContext applicationContext;
	PropertySourcesDeducer(ApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
	}
	PropertySources getPropertySources() {
		PropertySourcesPlaceholderConfigurer configurer = getSinglePropertySourcesPlaceholderConfigurer();
		if (configurer != null) {
			return configurer.getAppliedPropertySources();
		}
		MutablePropertySources sources = extractEnvironmentPropertySources();
		Assert.state(sources != null,
				'Unable to obtain PropertySources from PropertySourcesPlaceholderConfigurer or Environment');
		return sources;
	}
	private PropertySourcesPlaceholderConfigurer getSinglePropertySourcesPlaceholderConfigurer() {
		// Take care not to cause early instantiation of all FactoryBeans
		Map<String, PropertySourcesPlaceholderConfigurer> beans = this.applicationContext
			.getBeansOfType(PropertySourcesPlaceholderConfigurer.class, false, false);
		if (beans.size() == 1) {
			return beans.values().iterator().next();
		}
		if (beans.size() > 1 && logger.isWarnEnabled()) {
			logger.warn('Multiple PropertySourcesPlaceholderConfigurer beans registered ' + beans.keySet()
					+ ', falling back to Environment');
		}
		return null;
	}
	private MutablePropertySources extractEnvironmentPropertySources() {
		Environment environment = this.applicationContext.getEnvironment();
		if (environment instanceof ConfigurableEnvironment configurableEnvironment) {
			return configurableEnvironment.getPropertySources();
		}
		return null;
	}
}
/*
package org.springframework.boot.context.properties;
/**
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DeprecatedConfigurationProperty {
	/**
	 * The reason for the deprecation.
	 * @return the deprecation reason
	 */
	String reason() default '';
	/**
	 * The field that should be used instead (if any).
	 * @return the replacement field
	 */
	String replacement() default '';
	/**
	 * The version in which the property became deprecated.
	 * @return the version
	 */
	String since() default '';
}
/*
package org.springframework.boot.context.properties;
/**
class ConversionServiceDeducer {
	private final ApplicationContext applicationContext;
	ConversionServiceDeducer(ApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
	}
	List<ConversionService> getConversionServices() {
		if (hasUserDefinedConfigurationServiceBean()) {
			return Collections.singletonList(this.applicationContext
				.getBean(ConfigurableApplicationContext.CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
		}
		if (this.applicationContext instanceof ConfigurableApplicationContext configurableContext) {
			return getConversionServices(configurableContext);
		}
		return null;
	}
	private List<ConversionService> getConversionServices(ConfigurableApplicationContext applicationContext) {
		List<ConversionService> conversionServices = new ArrayList<>();
		ConverterBeans converterBeans = new ConverterBeans(applicationContext);
		if (!converterBeans.isEmpty()) {
			FormattingConversionService beansConverterService = new FormattingConversionService();
			DefaultConversionService.addCollectionConverters(beansConverterService);
			beansConverterService
				.addConverter(new ConfigurationPropertiesCharSequenceToObjectConverter(beansConverterService));
			converterBeans.addTo(beansConverterService);
			conversionServices.add(beansConverterService);
		}
		if (applicationContext.getBeanFactory().getConversionService() != null) {
			conversionServices.add(applicationContext.getBeanFactory().getConversionService());
		}
		if (!converterBeans.isEmpty()) {
			// Converters beans used to be added to a custom ApplicationConversionService
			// after the BeanFactory"s ConversionService. For backwards compatibility, we
			// add an ApplicationConversationService as a fallback in the same place in
			// the list.
			conversionServices.add(ApplicationConversionService.getSharedInstance());
		}
		return conversionServices;
	}
	private boolean hasUserDefinedConfigurationServiceBean() {
		String beanName = ConfigurableApplicationContext.CONVERSION_SERVICE_BEAN_NAME;
		return this.applicationContext.containsBean(beanName) && this.applicationContext.getAutowireCapableBeanFactory()
			.isTypeMatch(beanName, ConversionService.class);
	}
	private static class ConverterBeans {
		@SuppressWarnings('rawtypes')
		private final List<Converter> converters;
		private final List<GenericConverter> genericConverters;
		@SuppressWarnings('rawtypes')
		private final List<Formatter> formatters;
		ConverterBeans(ConfigurableApplicationContext applicationContext) {
			ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();
			this.converters = beans(Converter.class, ConfigurationPropertiesBinding.VALUE, beanFactory);
			this.genericConverters = beans(GenericConverter.class, ConfigurationPropertiesBinding.VALUE, beanFactory);
			this.formatters = beans(Formatter.class, ConfigurationPropertiesBinding.VALUE, beanFactory);
		}
		private <T> List<T> beans(Class<T> type, String qualifier, ListableBeanFactory beanFactory) {
			return new ArrayList<>(
					BeanFactoryAnnotationUtils.qualifiedBeansOfType(beanFactory, type, qualifier).values());
		}
		boolean isEmpty() {
			return this.converters.isEmpty() && this.genericConverters.isEmpty() && this.formatters.isEmpty();
		}
		void addTo(FormatterRegistry registry) {
			for (Converter<?, ?> converter : this.converters) {
				registry.addConverter(converter);
			}
			for (GenericConverter genericConverter : this.genericConverters) {
				registry.addConverter(genericConverter);
			}
			for (Formatter<?> formatter : this.formatters) {
				registry.addFormatter(formatter);
			}
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
@Target({ ElementType.FIELD, ElementType.RECORD_COMPONENT, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Nested
public @interface NestedConfigurationProperty {
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBeanRegistrationAotProcessor implements BeanRegistrationAotProcessor {
	@Override
	public BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean) {
		if (!isImmutableConfigurationPropertiesBeanDefinition(registeredBean.getMergedBeanDefinition())) {
			return null;
		}
		return BeanRegistrationAotContribution.withCustomCodeFragments(
				(codeFragments) -> new ConfigurationPropertiesBeanRegistrationCodeFragments(codeFragments,
						registeredBean));
	}
	private boolean isImmutableConfigurationPropertiesBeanDefinition(BeanDefinition beanDefinition) {
		return BindMethod.VALUE_OBJECT.equals(BindMethodAttribute.get(beanDefinition));
	}
	private static class ConfigurationPropertiesBeanRegistrationCodeFragments
			extends BeanRegistrationCodeFragmentsDecorator {
		private static final String REGISTERED_BEAN_PARAMETER_NAME = 'registeredBean';
		private final RegisteredBean registeredBean;
		ConfigurationPropertiesBeanRegistrationCodeFragments(BeanRegistrationCodeFragments codeFragments,
				RegisteredBean registeredBean) {
			super(codeFragments);
			this.registeredBean = registeredBean;
		}
		@Override
		public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext,
				BeanRegistrationCode beanRegistrationCode, RootBeanDefinition beanDefinition,
				Predicate<String> attributeFilter) {
			return super.generateSetBeanDefinitionPropertiesCode(generationContext, beanRegistrationCode,
					beanDefinition, attributeFilter.or(BindMethodAttribute.NAME::equals));
		}
		@Override
		public ClassName getTarget(RegisteredBean registeredBean) {
			return ClassName.get(this.registeredBean.getBeanClass());
		}
		@Override
		public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,
				BeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut) {
			GeneratedMethod generatedMethod = beanRegistrationCode.getMethods().add('getInstance', (method) -> {
				Class<?> beanClass = this.registeredBean.getBeanClass();
				method.addJavadoc('Get the bean instance for "$L".', this.registeredBean.getBeanName())
					.addModifiers(Modifier.PRIVATE, Modifier.STATIC)
					.returns(beanClass)
					.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER_NAME)
					.addStatement('$T beanFactory = registeredBean.getBeanFactory()', BeanFactory.class)
					.addStatement('$T beanName = registeredBean.getBeanName()', String.class)
					.addStatement('$T<?> beanClass = registeredBean.getBeanClass()', Class.class)
					.addStatement('return ($T) $T.from(beanFactory, beanName, beanClass)', beanClass,
							ConstructorBound.class);
			});
			return CodeBlock.of('$T.of($T::$L)', InstanceSupplier.class, beanRegistrationCode.getClassName(),
					generatedMethod.getName());
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class IncompatibleConfigurationFailureAnalyzer extends AbstractFailureAnalyzer<IncompatibleConfigurationException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, IncompatibleConfigurationException cause) {
		String action = String.format('Review the docs for %s and change the configured values.',
				String.join(', ', cause.getIncompatibleKeys()));
		return new FailureAnalysis(cause.getMessage(), action, cause);
	}
}
/*
package org.springframework.boot.context.properties;
/**
public final class PropertyMapper {
	private static final Predicate<?> ALWAYS = (t) -> true;
	private static final PropertyMapper INSTANCE = new PropertyMapper(null, null);
	private final PropertyMapper parent;
	private final SourceOperator sourceOperator;
	private PropertyMapper(PropertyMapper parent, SourceOperator sourceOperator) {
		this.parent = parent;
		this.sourceOperator = sourceOperator;
	}
	/**
	 * Return a new {@link PropertyMapper} instance that applies
	 * {@link Source#whenNonNull() whenNonNull} to every source.
	 * @return a new property mapper instance
	 */
	public PropertyMapper alwaysApplyingWhenNonNull() {
		return alwaysApplying(this::whenNonNull);
	}
	private <T> Source<T> whenNonNull(Source<T> source) {
		return source.whenNonNull();
	}
	/**
	 * Return a new {@link PropertyMapper} instance that applies the given
	 * {@link SourceOperator} to every source.
	 * @param operator the source operator to apply
	 * @return a new property mapper instance
	 */
	public PropertyMapper alwaysApplying(SourceOperator operator) {
		Assert.notNull(operator, 'Operator must not be null');
		return new PropertyMapper(this, operator);
	}
	/**
	 * Return a new {@link Source} from the specified value supplier that can be used to
	 * perform the mapping.
	 * @param <T> the source type
	 * @param supplier the value supplier
	 * @return a {@link Source} that can be used to complete the mapping
	 * @see #from(Object)
	 */
	public <T> Source<T> from(Supplier<T> supplier) {
		Assert.notNull(supplier, 'Supplier must not be null');
		Source<T> source = getSource(supplier);
		if (this.sourceOperator != null) {
			source = this.sourceOperator.apply(source);
		}
		return source;
	}
	/**
	 * Return a new {@link Source} from the specified value that can be used to perform
	 * the mapping.
	 * @param <T> the source type
	 * @param value the value
	 * @return a {@link Source} that can be used to complete the mapping
	 */
	public <T> Source<T> from(T value) {
		return from(() -> value);
	}
	@SuppressWarnings('unchecked')
	private <T> Source<T> getSource(Supplier<T> supplier) {
		if (this.parent != null) {
			return this.parent.from(supplier);
		}
		return new Source<>(SingletonSupplier.of(supplier), (Predicate<T>) ALWAYS);
	}
	/**
	 * Return the property mapper.
	 * @return the property mapper
	 */
	public static PropertyMapper get() {
		return INSTANCE;
	}
	/**
	 * An operation that can be applied to a {@link Source}.
	 */
	@FunctionalInterface
	public interface SourceOperator {
		/**
		 * Apply the operation to the given source.
		 * @param <T> the source type
		 * @param source the source to operate on
		 * @return the updated source
		 */
		<T> Source<T> apply(Source<T> source);
	}
	/**
	 * A source that is in the process of being mapped.
	 *
	 * @param <T> the source type
	 */
	public static final class Source<T> {
		private final Supplier<T> supplier;
		private final Predicate<T> predicate;
		private Source(Supplier<T> supplier, Predicate<T> predicate) {
			Assert.notNull(predicate, 'Predicate must not be null');
			this.supplier = supplier;
			this.predicate = predicate;
		}
		/**
		 * Return an adapted version of the source with {@link Integer} type.
		 * @param <R> the resulting type
		 * @param adapter an adapter to convert the current value to a number.
		 * @return a new adapted source instance
		 */
		public <R extends Number> Source<Integer> asInt(Function<T, R> adapter) {
			return as(adapter).as(Number::intValue);
		}
		/**
		 * Return an adapted version of the source changed through the given adapter
		 * function.
		 * @param <R> the resulting type
		 * @param adapter the adapter to apply
		 * @return a new adapted source instance
		 */
		public <R> Source<R> as(Function<T, R> adapter) {
			Assert.notNull(adapter, 'Adapter must not be null');
			Supplier<Boolean> test = () -> this.predicate.test(this.supplier.get());
			Predicate<R> predicate = (t) -> test.get();
			Supplier<R> supplier = () -> {
				if (test.get()) {
					return adapter.apply(this.supplier.get());
				}
				return null;
			};
			return new Source<>(supplier, predicate);
		}
		/**
		 * Return a filtered version of the source that won"t map non-null values or
		 * suppliers that throw a {@link NullPointerException}.
		 * @return a new filtered source instance
		 */
		public Source<T> whenNonNull() {
			return new Source<>(new NullPointerExceptionSafeSupplier<>(this.supplier), Objects::nonNull);
		}
		/**
		 * Return a filtered version of the source that will only map values that are
		 * {@code true}.
		 * @return a new filtered source instance
		 */
		public Source<T> whenTrue() {
			return when(Boolean.TRUE::equals);
		}
		/**
		 * Return a filtered version of the source that will only map values that are
		 * {@code false}.
		 * @return a new filtered source instance
		 */
		public Source<T> whenFalse() {
			return when(Boolean.FALSE::equals);
		}
		/**
		 * Return a filtered version of the source that will only map values that have a
		 * {@code toString()} containing actual text.
		 * @return a new filtered source instance
		 */
		public Source<T> whenHasText() {
			return when((value) -> StringUtils.hasText(Objects.toString(value, null)));
		}
		/**
		 * Return a filtered version of the source that will only map values equal to the
		 * specified {@code object}.
		 * @param object the object to match
		 * @return a new filtered source instance
		 */
		public Source<T> whenEqualTo(Object object) {
			return when(object::equals);
		}
		/**
		 * Return a filtered version of the source that will only map values that are an
		 * instance of the given type.
		 * @param <R> the target type
		 * @param target the target type to match
		 * @return a new filtered source instance
		 */
		public <R extends T> Source<R> whenInstanceOf(Class<R> target) {
			return when(target::isInstance).as(target::cast);
		}
		/**
		 * Return a filtered version of the source that won"t map values that match the
		 * given predicate.
		 * @param predicate the predicate used to filter values
		 * @return a new filtered source instance
		 */
		public Source<T> whenNot(Predicate<T> predicate) {
			Assert.notNull(predicate, 'Predicate must not be null');
			return when(predicate.negate());
		}
		/**
		 * Return a filtered version of the source that won"t map values that don"t match
		 * the given predicate.
		 * @param predicate the predicate used to filter values
		 * @return a new filtered source instance
		 */
		public Source<T> when(Predicate<T> predicate) {
			Assert.notNull(predicate, 'Predicate must not be null');
			return new Source<>(this.supplier, (this.predicate != null) ? this.predicate.and(predicate) : predicate);
		}
		/**
		 * Complete the mapping by passing any non-filtered value to the specified
		 * consumer. The method is designed to be used with mutable objects.
		 * @param consumer the consumer that should accept the value if it"s not been
		 * filtered
		 */
		public void to(Consumer<T> consumer) {
			Assert.notNull(consumer, 'Consumer must not be null');
			T value = this.supplier.get();
			if (this.predicate.test(value)) {
				consumer.accept(value);
			}
		}
		/**
		 * Complete the mapping for any non-filtered value by applying the given function
		 * to an existing instance and returning a new one. For filtered values, the
		 * {@code instance} parameter is returned unchanged. The method is designed to be
		 * used with immutable objects.
		 * @param <R> the result type
		 * @param instance the current instance
		 * @param mapper the mapping function
		 * @return a new mapped instance or the original instance
		 * @since 3.0.0
		 */
		public <R> R to(R instance, BiFunction<R, T, R> mapper) {
			Assert.notNull(instance, 'Instance must not be null');
			Assert.notNull(mapper, 'Mapper must not be null');
			T value = this.supplier.get();
			return (!this.predicate.test(value)) ? instance : mapper.apply(instance, value);
		}
		/**
		 * Complete the mapping by creating a new instance from the non-filtered value.
		 * @param <R> the resulting type
		 * @param factory the factory used to create the instance
		 * @return the instance
		 * @throws NoSuchElementException if the value has been filtered
		 */
		public <R> R toInstance(Function<T, R> factory) {
			Assert.notNull(factory, 'Factory must not be null');
			T value = this.supplier.get();
			if (!this.predicate.test(value)) {
				throw new NoSuchElementException('No value present');
			}
			return factory.apply(value);
		}
		/**
		 * Complete the mapping by calling the specified method when the value has not
		 * been filtered.
		 * @param runnable the method to call if the value has not been filtered
		 */
		public void toCall(Runnable runnable) {
			Assert.notNull(runnable, 'Runnable must not be null');
			T value = this.supplier.get();
			if (this.predicate.test(value)) {
				runnable.run();
			}
		}
	}
	/**
	 * Supplier that will catch and ignore any {@link NullPointerException}.
	 */
	private static class NullPointerExceptionSafeSupplier<T> implements Supplier<T> {
		private final Supplier<T> supplier;
		NullPointerExceptionSafeSupplier(Supplier<T> supplier) {
			this.supplier = supplier;
		}
		@Override
		public T get() {
			try {
				return this.supplier.get();
			}
			catch (NullPointerException ex) {
				return null;
			}
		}
	}
}
/*
package org.springframework.boot.context.logging;
/**
public class LoggingApplicationListener implements GenericApplicationListener {
	private static final ConfigurationPropertyName LOGGING_LEVEL = ConfigurationPropertyName.of('logging.level');
	private static final ConfigurationPropertyName LOGGING_GROUP = ConfigurationPropertyName.of('logging.group');
	private static final Bindable<Map<String, LogLevel>> STRING_LOGLEVEL_MAP = Bindable.mapOf(String.class,
			LogLevel.class);
	private static final Bindable<Map<String, List<String>>> STRING_STRINGS_MAP = Bindable
		.of(ResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class).asMap());
	/**
	 * The default order for the LoggingApplicationListener.
	 */
	public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 20;
	/**
	 * The name of the Spring property that contains a reference to the logging
	 * configuration to load.
	 */
	public static final String CONFIG_PROPERTY = 'logging.config';
	/**
	 * The name of the Spring property that controls the registration of a shutdown hook
	 * to shut down the logging system when the JVM exits.
	 * @see LoggingSystem#getShutdownHandler
	 */
	public static final String REGISTER_SHUTDOWN_HOOK_PROPERTY = 'logging.register-shutdown-hook';
	/**
	 * The name of the {@link LoggingSystem} bean.
	 */
	public static final String LOGGING_SYSTEM_BEAN_NAME = 'springBootLoggingSystem';
	/**
	 * The name of the {@link LogFile} bean.
	 * @since 2.2.0
	 */
	public static final String LOG_FILE_BEAN_NAME = 'springBootLogFile';
	/**
	 * The name of the {@link LoggerGroups} bean.
	 * @since 2.2.0
	 */
	public static final String LOGGER_GROUPS_BEAN_NAME = 'springBootLoggerGroups';
	/**
	 * The name of the {@link Lifecycle} bean used to handle cleanup.
	 */
	private static final String LOGGING_LIFECYCLE_BEAN_NAME = 'springBootLoggingLifecycle';
	private static final Map<String, List<String>> DEFAULT_GROUP_LOGGERS;
	static {
		MultiValueMap<String, String> loggers = new LinkedMultiValueMap<>();
		loggers.add('web', 'org.springframework.core.codec');
		loggers.add('web', 'org.springframework.http');
		loggers.add('web', 'org.springframework.web');
		loggers.add('web', 'org.springframework.boot.actuate.endpoint.web');
		loggers.add('web', 'org.springframework.boot.web.servlet.ServletContextInitializerBeans');
		loggers.add('sql', 'org.springframework.jdbc.core');
		loggers.add('sql', 'org.hibernate.SQL');
		loggers.add('sql', 'org.jooq.tools.LoggerListener');
		DEFAULT_GROUP_LOGGERS = Collections.unmodifiableMap(loggers);
	}
	private static final Map<LogLevel, List<String>> SPRING_BOOT_LOGGING_LOGGERS;
	static {
		MultiValueMap<LogLevel, String> loggers = new LinkedMultiValueMap<>();
		loggers.add(LogLevel.DEBUG, 'sql');
		loggers.add(LogLevel.DEBUG, 'web');
		loggers.add(LogLevel.DEBUG, 'org.springframework.boot');
		loggers.add(LogLevel.TRACE, 'org.springframework');
		loggers.add(LogLevel.TRACE, 'org.apache.tomcat');
		loggers.add(LogLevel.TRACE, 'org.apache.catalina');
		loggers.add(LogLevel.TRACE, 'org.eclipse.jetty');
		loggers.add(LogLevel.TRACE, 'org.hibernate.tool.hbm2ddl');
		SPRING_BOOT_LOGGING_LOGGERS = Collections.unmodifiableMap(loggers);
	}
	private static final Class<?>[] EVENT_TYPES = { ApplicationStartingEvent.class,
			ApplicationEnvironmentPreparedEvent.class, ApplicationPreparedEvent.class, ContextClosedEvent.class,
			ApplicationFailedEvent.class };
	private static final Class<?>[] SOURCE_TYPES = { SpringApplication.class, ApplicationContext.class };
	private static final AtomicBoolean shutdownHookRegistered = new AtomicBoolean();
	private final Log logger = LogFactory.getLog(getClass());
	private LoggingSystem loggingSystem;
	private LogFile logFile;
	private LoggerGroups loggerGroups;
	private int order = DEFAULT_ORDER;
	private boolean parseArgs = true;
	private LogLevel springBootLogging = null;
	@Override
	public boolean supportsEventType(ResolvableType resolvableType) {
		return isAssignableFrom(resolvableType.getRawClass(), EVENT_TYPES);
	}
	@Override
	public boolean supportsSourceType(Class<?> sourceType) {
		return isAssignableFrom(sourceType, SOURCE_TYPES);
	}
	private boolean isAssignableFrom(Class<?> type, Class<?>... supportedTypes) {
		if (type != null) {
			for (Class<?> supportedType : supportedTypes) {
				if (supportedType.isAssignableFrom(type)) {
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof ApplicationStartingEvent startingEvent) {
			onApplicationStartingEvent(startingEvent);
		}
		else if (event instanceof ApplicationEnvironmentPreparedEvent environmentPreparedEvent) {
			onApplicationEnvironmentPreparedEvent(environmentPreparedEvent);
		}
		else if (event instanceof ApplicationPreparedEvent preparedEvent) {
			onApplicationPreparedEvent(preparedEvent);
		}
		else if (event instanceof ContextClosedEvent contextClosedEvent) {
			onContextClosedEvent(contextClosedEvent);
		}
		else if (event instanceof ApplicationFailedEvent) {
			onApplicationFailedEvent();
		}
	}
	private void onApplicationStartingEvent(ApplicationStartingEvent event) {
		this.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());
		this.loggingSystem.beforeInitialize();
	}
	private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
		SpringApplication springApplication = event.getSpringApplication();
		if (this.loggingSystem == null) {
			this.loggingSystem = LoggingSystem.get(springApplication.getClassLoader());
		}
		initialize(event.getEnvironment(), springApplication.getClassLoader());
	}
	private void onApplicationPreparedEvent(ApplicationPreparedEvent event) {
		ConfigurableApplicationContext applicationContext = event.getApplicationContext();
		ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();
		if (!beanFactory.containsBean(LOGGING_SYSTEM_BEAN_NAME)) {
			beanFactory.registerSingleton(LOGGING_SYSTEM_BEAN_NAME, this.loggingSystem);
		}
		if (this.logFile != null && !beanFactory.containsBean(LOG_FILE_BEAN_NAME)) {
			beanFactory.registerSingleton(LOG_FILE_BEAN_NAME, this.logFile);
		}
		if (this.loggerGroups != null && !beanFactory.containsBean(LOGGER_GROUPS_BEAN_NAME)) {
			beanFactory.registerSingleton(LOGGER_GROUPS_BEAN_NAME, this.loggerGroups);
		}
		if (!beanFactory.containsBean(LOGGING_LIFECYCLE_BEAN_NAME) && applicationContext.getParent() == null) {
			beanFactory.registerSingleton(LOGGING_LIFECYCLE_BEAN_NAME, new Lifecycle());
		}
	}
	private void onContextClosedEvent(ContextClosedEvent event) {
		ApplicationContext applicationContext = event.getApplicationContext();
		if (applicationContext.getParent() != null || applicationContext.containsBean(LOGGING_LIFECYCLE_BEAN_NAME)) {
			return;
		}
		cleanupLoggingSystem();
	}
	void cleanupLoggingSystem() {
		if (this.loggingSystem != null) {
			this.loggingSystem.cleanUp();
		}
	}
	private void onApplicationFailedEvent() {
		cleanupLoggingSystem();
	}
	/**
	 * Initialize the logging system according to preferences expressed through the
	 * {@link Environment} and the classpath.
	 * @param environment the environment
	 * @param classLoader the classloader
	 */
	protected void initialize(ConfigurableEnvironment environment, ClassLoader classLoader) {
		getLoggingSystemProperties(environment).apply();
		this.logFile = LogFile.get(environment);
		if (this.logFile != null) {
			this.logFile.applyToSystemProperties();
		}
		this.loggerGroups = new LoggerGroups(DEFAULT_GROUP_LOGGERS);
		initializeEarlyLoggingLevel(environment);
		initializeSystem(environment, this.loggingSystem, this.logFile);
		initializeFinalLoggingLevels(environment, this.loggingSystem);
		registerShutdownHookIfNecessary(environment, this.loggingSystem);
	}
	private LoggingSystemProperties getLoggingSystemProperties(ConfigurableEnvironment environment) {
		return (this.loggingSystem != null) ? this.loggingSystem.getSystemProperties(environment)
				: new LoggingSystemProperties(environment);
	}
	private void initializeEarlyLoggingLevel(ConfigurableEnvironment environment) {
		if (this.parseArgs && this.springBootLogging == null) {
			if (isSet(environment, 'debug')) {
				this.springBootLogging = LogLevel.DEBUG;
			}
			if (isSet(environment, 'trace')) {
				this.springBootLogging = LogLevel.TRACE;
			}
		}
	}
	private boolean isSet(ConfigurableEnvironment environment, String property) {
		String value = environment.getProperty(property);
		return (value != null && !value.equals('false'));
	}
	private void initializeSystem(ConfigurableEnvironment environment, LoggingSystem system, LogFile logFile) {
		String logConfig = environment.getProperty(CONFIG_PROPERTY);
		if (StringUtils.hasLength(logConfig)) {
			logConfig = logConfig.strip();
		}
		try {
			LoggingInitializationContext initializationContext = new LoggingInitializationContext(environment);
			if (ignoreLogConfig(logConfig)) {
				system.initialize(initializationContext, null, logFile);
			}
			else {
				system.initialize(initializationContext, logConfig, logFile);
			}
		}
		catch (Throwable ex) {
			Throwable exceptionToReport = ex;
			while (exceptionToReport != null && !(exceptionToReport instanceof FileNotFoundException)) {
				exceptionToReport = exceptionToReport.getCause();
			}
			exceptionToReport = (exceptionToReport != null) ? exceptionToReport : ex;
			// NOTE: We can"t use the logger here to report the problem
			System.err.println('Logging system failed to initialize using configuration from "' + logConfig + '"');
			exceptionToReport.printStackTrace(System.err);
			throw new IllegalStateException(ex);
		}
	}
	private boolean ignoreLogConfig(String logConfig) {
		return !StringUtils.hasLength(logConfig) || logConfig.startsWith('-D');
	}
	private void initializeFinalLoggingLevels(ConfigurableEnvironment environment, LoggingSystem system) {
		bindLoggerGroups(environment);
		if (this.springBootLogging != null) {
			initializeSpringBootLogging(system, this.springBootLogging);
		}
		setLogLevels(system, environment);
	}
	private void bindLoggerGroups(ConfigurableEnvironment environment) {
		if (this.loggerGroups != null) {
			Binder binder = Binder.get(environment);
			binder.bind(LOGGING_GROUP, STRING_STRINGS_MAP).ifBound(this.loggerGroups::putAll);
		}
	}
	/**
	 * Initialize loggers based on the {@link #setSpringBootLogging(LogLevel)
	 * springBootLogging} setting. By default this implementation will pick an appropriate
	 * set of loggers to configure based on the level.
	 * @param system the logging system
	 * @param springBootLogging the spring boot logging level requested
	 * @since 2.2.0
	 */
	protected void initializeSpringBootLogging(LoggingSystem system, LogLevel springBootLogging) {
		BiConsumer<String, LogLevel> configurer = getLogLevelConfigurer(system);
		SPRING_BOOT_LOGGING_LOGGERS.getOrDefault(springBootLogging, Collections.emptyList())
			.forEach((name) -> configureLogLevel(name, springBootLogging, configurer));
	}
	/**
	 * Set logging levels based on relevant {@link Environment} properties.
	 * @param system the logging system
	 * @param environment the environment
	 * @since 2.2.0
	 */
	protected void setLogLevels(LoggingSystem system, ConfigurableEnvironment environment) {
		BiConsumer<String, LogLevel> customizer = getLogLevelConfigurer(system);
		Binder binder = Binder.get(environment);
		Map<String, LogLevel> levels = binder.bind(LOGGING_LEVEL, STRING_LOGLEVEL_MAP).orElseGet(Collections::emptyMap);
		levels.forEach((name, level) -> configureLogLevel(name, level, customizer));
	}
	private void configureLogLevel(String name, LogLevel level, BiConsumer<String, LogLevel> configurer) {
		if (this.loggerGroups != null) {
			LoggerGroup group = this.loggerGroups.get(name);
			if (group != null && group.hasMembers()) {
				group.configureLogLevel(level, configurer);
				return;
			}
		}
		configurer.accept(name, level);
	}
	private BiConsumer<String, LogLevel> getLogLevelConfigurer(LoggingSystem system) {
		return (name, level) -> {
			try {
				name = name.equalsIgnoreCase(LoggingSystem.ROOT_LOGGER_NAME) ? null : name;
				system.setLogLevel(name, level);
			}
			catch (RuntimeException ex) {
				this.logger.error(LogMessage.format('Cannot set level "%s" for "%s"', level, name));
			}
		};
	}
	private void registerShutdownHookIfNecessary(Environment environment, LoggingSystem loggingSystem) {
		if (environment.getProperty(REGISTER_SHUTDOWN_HOOK_PROPERTY, Boolean.class, true)) {
			Runnable shutdownHandler = loggingSystem.getShutdownHandler();
			if (shutdownHandler != null && shutdownHookRegistered.compareAndSet(false, true)) {
				registerShutdownHook(shutdownHandler);
			}
		}
	}
	void registerShutdownHook(Runnable shutdownHandler) {
		SpringApplication.getShutdownHandlers().add(shutdownHandler);
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Sets a custom logging level to be used for Spring Boot and related libraries.
	 * @param springBootLogging the logging level
	 */
	public void setSpringBootLogging(LogLevel springBootLogging) {
		this.springBootLogging = springBootLogging;
	}
	/**
	 * Sets if initialization arguments should be parsed for {@literal debug} and
	 * {@literal trace} properties (usually defined from {@literal --debug} or
	 * {@literal --trace} command line args). Defaults to {@code true}.
	 * @param parseArgs if arguments should be parsed
	 */
	public void setParseArgs(boolean parseArgs) {
		this.parseArgs = parseArgs;
	}
	private final class Lifecycle implements SmartLifecycle {
		private volatile boolean running;
		@Override
		public void start() {
			this.running = true;
		}
		@Override
		public void stop() {
			this.running = false;
			cleanupLoggingSystem();
		}
		@Override
		public boolean isRunning() {
			return this.running;
		}
		@Override
		public int getPhase() {
			// Shutdown late and always after WebServerStartStopLifecycle
			return Integer.MIN_VALUE + 1;
		}
	}
}
/*
/**
package org.springframework.boot.context.logging;
/*
package org