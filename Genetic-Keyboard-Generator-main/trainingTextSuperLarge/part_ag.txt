class ApplicationContextRunner extends
		AbstractApplicationContextRunner<ApplicationContextRunner, ConfigurableApplicationContext, AssertableApplicationContext> {
	/**
	 * Create a new {@link ApplicationContextRunner} instance using an
	 * {@link AnnotationConfigApplicationContext} as the underlying source.
	 */
	public ApplicationContextRunner() {
		this(AnnotationConfigApplicationContext::new);
	}
	/**
	 * Create a new {@link ApplicationContextRunner} instance using the specified
	 * {@code contextFactory} as the underlying source.
	 * @param contextFactory a supplier that returns a new instance on each call be added
	 * to the application context proxy
	 */
	public ApplicationContextRunner(Supplier<ConfigurableApplicationContext> contextFactory) {
		super(ApplicationContextRunner::new, contextFactory);
	}
	/**
	 * Create a new {@link ApplicationContextRunner} instance using the specified
	 * {@code contextFactory} as the underlying source.
	 * @param contextFactory a supplier that returns a new instance on each call
	 * @param additionalContextInterfaces any additional application context interfaces to
	 * be added to the application context proxy
	 * @since 3.4.0
	 */
	public ApplicationContextRunner(Supplier<ConfigurableApplicationContext> contextFactory,
			Class<?>... additionalContextInterfaces) {
		super(ApplicationContextRunner::new, contextFactory, additionalContextInterfaces);
	}
	private ApplicationContextRunner(RunnerConfiguration<ConfigurableApplicationContext> runnerConfiguration) {
		super(runnerConfiguration, ApplicationContextRunner::new);
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
@FunctionalInterface
public interface ContextConsumer<C extends ApplicationContext> {
	/**
	 * Performs this operation on the supplied {@code context}.
	 * @param context the application context to consume
	 * @throws Throwable any exception that might occur in assertions
	 */
	void accept(C context) throws Throwable;
	/**
	 * Returns a composed {@code ContextConsumer} that performs, in sequence, this
	 * operation followed by the {@code after} operation.
	 * @param after the operation to perform after this operation
	 * @return a composed {@code ContextConsumer} that performs in sequence this operation
	 * followed by the {@code after} operation
	 * @since 2.6.0
	 */
	default ContextConsumer<C> andThen(ContextConsumer<? super C> after) {
		Assert.notNull(after, 'After must not be null');
		return (context) -> {
			accept(context);
			after.accept(context);
		};
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
public abstract class AbstractApplicationContextRunner<SELF extends AbstractApplicationContextRunner<SELF, C, A>, C extends ConfigurableApplicationContext, A extends ApplicationContextAssertProvider<C>> {
	private static final Class<?>[] NO_ADDITIONAL_CONTEXT_INTERFACES = {};
	private final RunnerConfiguration<C> runnerConfiguration;
	private final Function<RunnerConfiguration<C>, SELF> instanceFactory;
	/**
	 * Create a new {@link AbstractApplicationContextRunner} instance.
	 * @param contextFactory the factory used to create the actual context
	 * @param instanceFactory the factory used to create new instance of the runner
	 * @since 2.6.0
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #AbstractApplicationContextRunner(Function, Supplier, Class...)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	protected AbstractApplicationContextRunner(Supplier<C> contextFactory,
			Function<RunnerConfiguration<C>, SELF> instanceFactory) {
		this(instanceFactory, contextFactory, NO_ADDITIONAL_CONTEXT_INTERFACES);
	}
	/**
	 * Create a new {@link AbstractApplicationContextRunner} instance.
	 * @param instanceFactory the factory used to create new instance of the runner
	 * @param contextFactory the factory used to create the actual context
	 * @param additionalContextInterfaces any additional application context interfaces to
	 * be added to the application context proxy
	 * @since 3.4.0
	 */
	protected AbstractApplicationContextRunner(Function<RunnerConfiguration<C>, SELF> instanceFactory,
			Supplier<C> contextFactory, Class<?>... additionalContextInterfaces) {
		Assert.notNull(instanceFactory, '"instanceFactory" must not be null');
		Assert.notNull(contextFactory, '"contextFactory" must not be null');
		this.instanceFactory = instanceFactory;
		this.runnerConfiguration = new RunnerConfiguration<>(contextFactory, additionalContextInterfaces);
	}
	/**
	 * Create a new {@link AbstractApplicationContextRunner} instance.
	 * @param configuration the configuration for the runner to use
	 * @param instanceFactory the factory used to create new instance of the runner
	 * @since 2.6.0
	 */
	protected AbstractApplicationContextRunner(RunnerConfiguration<C> configuration,
			Function<RunnerConfiguration<C>, SELF> instanceFactory) {
		Assert.notNull(configuration, 'RunnerConfiguration must not be null');
		Assert.notNull(instanceFactory, 'instanceFactory must not be null');
		this.runnerConfiguration = configuration;
		this.instanceFactory = instanceFactory;
	}
	/**
	 * Specify if bean definition overriding, by registering a definition with the same
	 * name as an existing definition, should be allowed.
	 * @param allowBeanDefinitionOverriding if bean overriding is allowed
	 * @return a new instance with the updated bean definition overriding policy
	 * @since 2.3.0
	 * @see DefaultListableBeanFactory#setAllowBeanDefinitionOverriding(boolean)
	 */
	public SELF withAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
		return newInstance(this.runnerConfiguration.withAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding));
	}
	/**
	 * Specify if circular references between beans should be allowed.
	 * @param allowCircularReferences if circular references between beans are allowed
	 * @return a new instance with the updated circular references policy
	 * @since 2.6.0
	 * @see AbstractAutowireCapableBeanFactory#setAllowCircularReferences(boolean)
	 */
	public SELF withAllowCircularReferences(boolean allowCircularReferences) {
		return newInstance(this.runnerConfiguration.withAllowCircularReferences(allowCircularReferences));
	}
	/**
	 * Add an {@link ApplicationContextInitializer} to be called when the context is
	 * created.
	 * @param initializer the initializer to add
	 * @return a new instance with the updated initializers
	 */
	public SELF withInitializer(ApplicationContextInitializer<? super C> initializer) {
		Assert.notNull(initializer, 'Initializer must not be null');
		return newInstance(this.runnerConfiguration.withInitializer(initializer));
	}
	/**
	 * Add the specified {@link Environment} property pairs. Key-value pairs can be
	 * specified with colon (':') or equals ('=') separators. Override matching keys that
	 * might have been specified previously.
	 * @param pairs the key-value pairs for properties that need to be added to the
	 * environment
	 * @return a new instance with the updated property values
	 * @see TestPropertyValues
	 * @see #withSystemProperties(String...)
	 */
	public SELF withPropertyValues(String... pairs) {
		return newInstance(this.runnerConfiguration.withPropertyValues(pairs));
	}
	/**
	 * Add the specified {@link System} property pairs. Key-value pairs can be specified
	 * with colon (':') or equals ('=') separators. System properties are added before the
	 * context is {@link #run(ContextConsumer) run} and restored when the context is
	 * closed.
	 * @param pairs the key-value pairs for properties that need to be added to the system
	 * @return a new instance with the updated system properties
	 * @see TestPropertyValues
	 * @see #withSystemProperties(String...)
	 */
	public SELF withSystemProperties(String... pairs) {
		return newInstance(this.runnerConfiguration.withSystemProperties(pairs));
	}
	/**
	 * Customize the {@link ClassLoader} that the {@link ApplicationContext} should use
	 * for resource loading and bean class loading.
	 * @param classLoader the classloader to use (or {@code null} to use the default)
	 * @return a new instance with the updated class loader
	 * @see FilteredClassLoader
	 */
	public SELF withClassLoader(ClassLoader classLoader) {
		return newInstance(this.runnerConfiguration.withClassLoader(classLoader));
	}
	/**
	 * Configure the {@link ConfigurableApplicationContext#setParent(ApplicationContext)
	 * parent} of the {@link ApplicationContext}.
	 * @param parent the parent
	 * @return a new instance with the updated parent
	 */
	public SELF withParent(ApplicationContext parent) {
		return newInstance(this.runnerConfiguration.withParent(parent));
	}
	/**
	 * Register the specified user bean with the {@link ApplicationContext}. The bean name
	 * is generated from the configured {@link BeanNameGenerator} on the underlying
	 * context.
	 * <p>
	 * Such beans are registered after regular {@linkplain #withUserConfiguration(Class[])
	 * user configurations} in the order of registration.
	 * @param type the type of the bean
	 * @param constructorArgs custom argument values to be fed into Spring"s constructor
	 * resolution algorithm, resolving either all arguments or just specific ones, with
	 * the rest to be resolved through regular autowiring (may be {@code null} or empty)
	 * @param <T> the type of the bean
	 * @return a new instance with the updated bean
	 */
	public <T> SELF withBean(Class<T> type, Object... constructorArgs) {
		return withBean(null, type, constructorArgs);
	}
	/**
	 * Register the specified user bean with the {@link ApplicationContext}.
	 * <p>
	 * Such beans are registered after regular {@linkplain #withUserConfiguration(Class[])
	 * user configurations} in the order of registration.
	 * @param name the bean name or {@code null} to use a generated name
	 * @param type the type of the bean
	 * @param constructorArgs custom argument values to be fed into Spring"s constructor
	 * resolution algorithm, resolving either all arguments or just specific ones, with
	 * the rest to be resolved through regular autowiring (may be {@code null} or empty)
	 * @param <T> the type of the bean
	 * @return a new instance with the updated bean
	 */
	public <T> SELF withBean(String name, Class<T> type, Object... constructorArgs) {
		return newInstance(this.runnerConfiguration.withBean(name, type, constructorArgs));
	}
	/**
	 * Register the specified user bean with the {@link ApplicationContext}. The bean name
	 * is generated from the configured {@link BeanNameGenerator} on the underlying
	 * context.
	 * <p>
	 * Such beans are registered after regular {@linkplain #withUserConfiguration(Class[])
	 * user configurations} in the order of registration.
	 * @param type the type of the bean
	 * @param supplier a supplier for the bean
	 * @param customizers one or more callbacks for customizing the factory"s
	 * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag
	 * @param <T> the type of the bean
	 * @return a new instance with the updated bean
	 */
	public <T> SELF withBean(Class<T> type, Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {
		return withBean(null, type, supplier, customizers);
	}
	/**
	 * Register the specified user bean with the {@link ApplicationContext}. The bean name
	 * is generated from the configured {@link BeanNameGenerator} on the underlying
	 * context.
	 * <p>
	 * Such beans are registered after regular {@linkplain #withUserConfiguration(Class[])
	 * user configurations} in the order of registration.
	 * @param name the bean name or {@code null} to use a generated name
	 * @param type the type of the bean
	 * @param supplier a supplier for the bean
	 * @param customizers one or more callbacks for customizing the factory"s
	 * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag
	 * @param <T> the type of the bean
	 * @return a new instance with the updated bean
	 */
	public <T> SELF withBean(String name, Class<T> type, Supplier<T> supplier,
			BeanDefinitionCustomizer... customizers) {
		return newInstance(this.runnerConfiguration.withBean(name, type, supplier, customizers));
	}
	/**
	 * Register the specified user configuration classes with the
	 * {@link ApplicationContext}.
	 * @param configurationClasses the user configuration classes to add
	 * @return a new instance with the updated configuration
	 */
	public SELF withUserConfiguration(Class<?>... configurationClasses) {
		return withConfiguration(UserConfigurations.of(configurationClasses));
	}
	/**
	 * Register the specified configuration classes with the {@link ApplicationContext}.
	 * @param configurations the configurations to add
	 * @return a new instance with the updated configuration
	 */
	public SELF withConfiguration(Configurations configurations) {
		Assert.notNull(configurations, 'Configurations must not be null');
		return newInstance(this.runnerConfiguration.withConfiguration(configurations));
	}
	/**
	 * Apply customization to this runner.
	 * @param customizer the customizer to call
	 * @return a new instance with the customizations applied
	 */
	@SuppressWarnings('unchecked')
	public SELF with(Function<SELF, SELF> customizer) {
		return customizer.apply((SELF) this);
	}
	private SELF newInstance(RunnerConfiguration<C> runnerConfiguration) {
		return this.instanceFactory.apply(runnerConfiguration);
	}
	/**
	 * Create and refresh a new {@link ApplicationContext} based on the current state of
	 * this loader. The context is consumed by the specified {@code consumer} and closed
	 * upon completion.
	 * @param consumer the consumer of the created {@link ApplicationContext}
	 * @return this instance
	 */
	@SuppressWarnings('unchecked')
	public SELF run(ContextConsumer<? super A> consumer) {
		withContextClassLoader(this.runnerConfiguration.classLoader, () -> this.runnerConfiguration.systemProperties
			.applyToSystemProperties(() -> consumeAssertableContext(true, consumer)));
		return (SELF) this;
	}
	/**
	 * Prepare a new {@link ApplicationContext} based on the current state of this loader.
	 * The context is consumed by the specified {@code consumer} and closed upon
	 * completion. Unlike {@link #run(ContextConsumer)}, this method does not refresh the
	 * consumed context.
	 * @param consumer the consumer of the created {@link ApplicationContext}
	 * @return this instance
	 * @since 3.0.0
	 */
	@SuppressWarnings('unchecked')
	public SELF prepare(ContextConsumer<? super A> consumer) {
		withContextClassLoader(this.runnerConfiguration.classLoader, () -> this.runnerConfiguration.systemProperties
			.applyToSystemProperties(() -> consumeAssertableContext(false, consumer)));
		return (SELF) this;
	}
	private void consumeAssertableContext(boolean refresh, ContextConsumer<? super A> consumer) {
		try (A context = createAssertableContext(refresh)) {
			accept(consumer, context);
		}
	}
	private void withContextClassLoader(ClassLoader classLoader, Runnable action) {
		if (classLoader == null) {
			action.run();
		}
		else {
			Thread currentThread = Thread.currentThread();
			ClassLoader previous = currentThread.getContextClassLoader();
			currentThread.setContextClassLoader(classLoader);
			try {
				action.run();
			}
			finally {
				currentThread.setContextClassLoader(previous);
			}
		}
	}
	@SuppressWarnings('unchecked')
	private A createAssertableContext(boolean refresh) {
		ResolvableType resolvableType = ResolvableType.forClass(AbstractApplicationContextRunner.class, getClass());
		Class<A> assertType = (Class<A>) resolvableType.resolveGeneric(1);
		Class<C> contextType = (Class<C>) resolvableType.resolveGeneric(2);
		return ApplicationContextAssertProvider.get(assertType, contextType, () -> createAndLoadContext(refresh),
				this.runnerConfiguration.additionalContextInterfaces);
	}
	private C createAndLoadContext(boolean refresh) {
		C context = this.runnerConfiguration.contextFactory.get();
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		if (beanFactory instanceof AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) {
			autowireCapableBeanFactory.setAllowCircularReferences(this.runnerConfiguration.allowCircularReferences);
			if (beanFactory instanceof DefaultListableBeanFactory listableBeanFactory) {
				listableBeanFactory
					.setAllowBeanDefinitionOverriding(this.runnerConfiguration.allowBeanDefinitionOverriding);
			}
		}
		try {
			configureContext(context, refresh);
			return context;
		}
		catch (RuntimeException ex) {
			context.close();
			throw ex;
		}
	}
	private void configureContext(C context, boolean refresh) {
		if (this.runnerConfiguration.parent != null) {
			context.setParent(this.runnerConfiguration.parent);
		}
		if (this.runnerConfiguration.classLoader != null) {
			Assert.isInstanceOf(DefaultResourceLoader.class, context);
			((DefaultResourceLoader) context).setClassLoader(this.runnerConfiguration.classLoader);
		}
		this.runnerConfiguration.environmentProperties.applyTo(context);
		this.runnerConfiguration.beanRegistrations.forEach((registration) -> registration.apply(context));
		this.runnerConfiguration.initializers.forEach((initializer) -> initializer.initialize(context));
		Class<?>[] classes = Configurations.getClasses(this.runnerConfiguration.configurations);
		if (classes.length > 0) {
			((AnnotationConfigRegistry) context).register(classes);
		}
		if (refresh) {
			context.refresh();
		}
	}
	private void accept(ContextConsumer<? super A> consumer, A context) {
		try {
			consumer.accept(context);
		}
		catch (Throwable ex) {
			rethrow(ex);
		}
	}
	@SuppressWarnings('unchecked')
	private <E extends Throwable> void rethrow(Throwable e) throws E {
		throw (E) e;
	}
	/**
	 * A Bean registration to be applied when the context loaded.
	 *
	 * @param <T> the bean type
	 */
	protected static final class BeanRegistration<T> {
		Consumer<GenericApplicationContext> registrar;
		public BeanRegistration(String name, Class<T> type, Object... constructorArgs) {
			this.registrar = (context) -> context.registerBean(name, type, constructorArgs);
		}
		public BeanRegistration(String name, Class<T> type, Supplier<T> supplier,
				BeanDefinitionCustomizer... customizers) {
			this.registrar = (context) -> context.registerBean(name, type, supplier, customizers);
		}
		public void apply(ConfigurableApplicationContext context) {
			Assert.isInstanceOf(GenericApplicationContext.class, context);
			this.registrar.accept(((GenericApplicationContext) context));
		}
	}
	protected static final class RunnerConfiguration<C extends ConfigurableApplicationContext> {
		private final Supplier<C> contextFactory;
		private final Class<?>[] additionalContextInterfaces;
		private boolean allowBeanDefinitionOverriding = false;
		private boolean allowCircularReferences = false;
		private List<ApplicationContextInitializer<? super C>> initializers = Collections.emptyList();
		private TestPropertyValues environmentProperties = TestPropertyValues.empty();
		private TestPropertyValues systemProperties = TestPropertyValues.empty();
		private ClassLoader classLoader;
		private ApplicationContext parent;
		private List<BeanRegistration<?>> beanRegistrations = Collections.emptyList();
		private List<Configurations> configurations = Collections.emptyList();
		private RunnerConfiguration(Supplier<C> contextFactory, Class<?>[] additionalContextInterfaces) {
			this.contextFactory = contextFactory;
			this.additionalContextInterfaces = additionalContextInterfaces;
		}
		private RunnerConfiguration(RunnerConfiguration<C> source) {
			this.contextFactory = source.contextFactory;
			this.additionalContextInterfaces = source.additionalContextInterfaces;
			this.allowBeanDefinitionOverriding = source.allowBeanDefinitionOverriding;
			this.allowCircularReferences = source.allowCircularReferences;
			this.initializers = source.initializers;
			this.environmentProperties = source.environmentProperties;
			this.systemProperties = source.systemProperties;
			this.classLoader = source.classLoader;
			this.parent = source.parent;
			this.beanRegistrations = source.beanRegistrations;
			this.configurations = source.configurations;
		}
		private RunnerConfiguration<C> withAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;
			return config;
		}
		private RunnerConfiguration<C> withAllowCircularReferences(boolean allowCircularReferences) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.allowCircularReferences = allowCircularReferences;
			return config;
		}
		private RunnerConfiguration<C> withInitializer(ApplicationContextInitializer<? super C> initializer) {
			Assert.notNull(initializer, 'Initializer must not be null');
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.initializers = add(config.initializers, initializer);
			return config;
		}
		private RunnerConfiguration<C> withPropertyValues(String... pairs) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.environmentProperties = config.environmentProperties.and(pairs);
			return config;
		}
		private RunnerConfiguration<C> withSystemProperties(String... pairs) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.systemProperties = config.systemProperties.and(pairs);
			return config;
		}
		private RunnerConfiguration<C> withClassLoader(ClassLoader classLoader) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.classLoader = classLoader;
			return config;
		}
		private RunnerConfiguration<C> withParent(ApplicationContext parent) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.parent = parent;
			return config;
		}
		private <T> RunnerConfiguration<C> withBean(String name, Class<T> type, Object... constructorArgs) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.beanRegistrations = add(config.beanRegistrations,
					new BeanRegistration<>(name, type, constructorArgs));
			return config;
		}
		private <T> RunnerConfiguration<C> withBean(String name, Class<T> type, Supplier<T> supplier,
				BeanDefinitionCustomizer... customizers) {
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.beanRegistrations = add(config.beanRegistrations,
					new BeanRegistration<>(name, type, supplier, customizers));
			return config;
		}
		private RunnerConfiguration<C> withConfiguration(Configurations configurations) {
			Assert.notNull(configurations, 'Configurations must not be null');
			RunnerConfiguration<C> config = new RunnerConfiguration<>(this);
			config.configurations = add(config.configurations, configurations);
			return config;
		}
		private static <T> List<T> add(List<T> list, T element) {
			List<T> result = new ArrayList<>(list);
			result.add(element);
			return result;
		}
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
public final class WebApplicationContextRunner extends
		AbstractApplicationContextRunner<WebApplicationContextRunner, ConfigurableWebApplicationContext, AssertableWebApplicationContext> {
	/**
	 * Create a new {@link WebApplicationContextRunner} instance using an
	 * {@link AnnotationConfigServletWebApplicationContext} with a
	 * {@link MockServletContext} as the underlying source.
	 * @see #withMockServletContext(Supplier)
	 */
	public WebApplicationContextRunner() {
		this(withMockServletContext(AnnotationConfigServletWebApplicationContext::new));
	}
	/**
	 * Create a new {@link WebApplicationContextRunner} instance using the specified
	 * {@code contextFactory} as the underlying source.
	 * @param contextFactory a supplier that returns a new instance on each call be added
	 * to the application context proxy
	 */
	public WebApplicationContextRunner(Supplier<ConfigurableWebApplicationContext> contextFactory) {
		super(WebApplicationContextRunner::new, contextFactory);
	}
	/**
	 * Create a new {@link WebApplicationContextRunner} instance using the specified
	 * {@code contextFactory} as the underlying source.
	 * @param contextFactory a supplier that returns a new instance on each call
	 * @param additionalContextInterfaces any additional application context interfaces to
	 * be added to the application context proxy
	 * @since 3.4.0
	 */
	public WebApplicationContextRunner(Supplier<ConfigurableWebApplicationContext> contextFactory,
			Class<?>... additionalContextInterfaces) {
		super(WebApplicationContextRunner::new, contextFactory, additionalContextInterfaces);
	}
	private WebApplicationContextRunner(RunnerConfiguration<ConfigurableWebApplicationContext> configuration) {
		super(configuration, WebApplicationContextRunner::new);
	}
	/**
	 * Decorate the specified {@code contextFactory} to set a {@link MockServletContext}
	 * on each newly created {@link WebApplicationContext}.
	 * @param contextFactory the context factory to decorate
	 * @return an updated supplier that will set the {@link MockServletContext}
	 */
	public static Supplier<ConfigurableWebApplicationContext> withMockServletContext(
			Supplier<ConfigurableWebApplicationContext> contextFactory) {
		return (contextFactory != null) ? () -> {
			ConfigurableWebApplicationContext context = contextFactory.get();
			context.setServletContext(new MockServletContext());
			return context;
		} : null;
	}
}
/*
package org.springframework.boot.test.context.runner;
/**
public final class ReactiveWebApplicationContextRunner extends
		AbstractApplicationContextRunner<ReactiveWebApplicationContextRunner, ConfigurableReactiveWebApplicationContext, AssertableReactiveWebApplicationContext> {
	/**
	 * Create a new {@link ReactiveWebApplicationContextRunner} instance using a
	 * {@link AnnotationConfigReactiveWebApplicationContext} as the underlying source.
	 */
	public ReactiveWebApplicationContextRunner() {
		this(AnnotationConfigReactiveWebApplicationContext::new);
	}
	/**
	 * Create a new {@link ApplicationContextRunner} instance using the specified
	 * {@code contextFactory} as the underlying source.
	 * @param contextFactory a supplier that returns a new instance on each call be added
	 * to the application context proxy
	 * @since 3.4.0
	 */
	public ReactiveWebApplicationContextRunner(Supplier<ConfigurableReactiveWebApplicationContext> contextFactory) {
		super(ReactiveWebApplicationContextRunner::new, contextFactory);
	}
	/**
	 * Create a new {@link ApplicationContextRunner} instance using the specified
	 * {@code contextFactory} as the underlying source.
	 * @param contextFactory a supplier that returns a new instance on each call
	 * @param additionalContextInterfaces any additional application context interfaces to
	 * be added to the application context proxy
	 * @since 3.4.0
	 */
	public ReactiveWebApplicationContextRunner(Supplier<ConfigurableReactiveWebApplicationContext> contextFactory,
			Class<?>... additionalContextInterfaces) {
		super(ReactiveWebApplicationContextRunner::new, contextFactory, additionalContextInterfaces);
	}
	private ReactiveWebApplicationContextRunner(
			RunnerConfiguration<ConfigurableReactiveWebApplicationContext> configuration) {
		super(configuration, ReactiveWebApplicationContextRunner::new);
	}
}
/*
/**
package org.springframework.boot.test.context.runner;
/*
package org.springframework.boot.test.context;
/**
public class SpringBootContextLoader extends AbstractContextLoader implements AotContextLoader {
	private static final Consumer<SpringApplication> ALREADY_CONFIGURED = (springApplication) -> {
	};
	@Override
	public ApplicationContext loadContext(MergedContextConfiguration mergedConfig) throws Exception {
		return loadContext(mergedConfig, Mode.STANDARD, null);
	}
	@Override
	public ApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig) throws Exception {
		return loadContext(mergedConfig, Mode.AOT_PROCESSING, null);
	}
	@Override
	public ApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,
			ApplicationContextInitializer<ConfigurableApplicationContext> initializer) throws Exception {
		return loadContext(mergedConfig, Mode.AOT_RUNTIME, initializer);
	}
	private ApplicationContext loadContext(MergedContextConfiguration mergedConfig, Mode mode,
			ApplicationContextInitializer<ConfigurableApplicationContext> initializer) throws Exception {
		assertHasClassesOrLocations(mergedConfig);
		SpringBootTestAnnotation annotation = SpringBootTestAnnotation.get(mergedConfig);
		String[] args = annotation.getArgs();
		UseMainMethod useMainMethod = annotation.getUseMainMethod();
		Method mainMethod = getMainMethod(mergedConfig, useMainMethod);
		if (mainMethod != null) {
			ContextLoaderHook hook = new ContextLoaderHook(mode, initializer,
					(application) -> configure(mergedConfig, application));
			return hook.runMain(() -> ReflectionUtils.invokeMethod(mainMethod, null, new Object[] { args }));
		}
		SpringApplication application = getSpringApplication();
		configure(mergedConfig, application);
		ContextLoaderHook hook = new ContextLoaderHook(mode, initializer, ALREADY_CONFIGURED);
		return hook.run(() -> application.run(args));
	}
	private void assertHasClassesOrLocations(MergedContextConfiguration mergedConfig) {
		boolean hasClasses = !ObjectUtils.isEmpty(mergedConfig.getClasses());
		boolean hasLocations = !ObjectUtils.isEmpty(mergedConfig.getLocations());
		Assert.state(hasClasses || hasLocations,
				() -> 'No configuration classes or locations found in @SpringApplicationConfiguration. '
						+ 'For default configuration detection to work you need Spring 4.0.3 or better (found '
						+ SpringVersion.getVersion() + ').');
	}
	private Method getMainMethod(MergedContextConfiguration mergedConfig, UseMainMethod useMainMethod) {
		if (useMainMethod == UseMainMethod.NEVER) {
			return null;
		}
		Assert.state(mergedConfig.getParent() == null,
				() -> 'UseMainMethod.%s cannot be used with @ContextHierarchy tests'.formatted(useMainMethod));
		Class<?> springBootConfiguration = Arrays.stream(mergedConfig.getClasses())
			.filter(this::isSpringBootConfiguration)
			.findFirst()
			.orElse(null);
		Assert.state(springBootConfiguration != null || useMainMethod == UseMainMethod.WHEN_AVAILABLE,
				'Cannot use main method as no @SpringBootConfiguration-annotated class is available');
		Method mainMethod = (springBootConfiguration != null)
				? ReflectionUtils.findMethod(springBootConfiguration, 'main', String[].class) : null;
		if (mainMethod == null && KotlinDetector.isKotlinPresent()) {
			try {
				Class<?> kotlinClass = ClassUtils.forName(springBootConfiguration.getName() + 'Kt',
						springBootConfiguration.getClassLoader());
				mainMethod = ReflectionUtils.findMethod(kotlinClass, 'main', String[].class);
			}
			catch (ClassNotFoundException ex) {
				// Ignore
			}
		}
		Assert.state(mainMethod != null || useMainMethod == UseMainMethod.WHEN_AVAILABLE,
				() -> 'Main method not found on "%s"'.formatted(springBootConfiguration.getName()));
		return mainMethod;
	}
	private boolean isSpringBootConfiguration(Class<?> candidate) {
		return MergedAnnotations.from(candidate, SearchStrategy.TYPE_HIERARCHY)
			.isPresent(SpringBootConfiguration.class);
	}
	private void configure(MergedContextConfiguration mergedConfig, SpringApplication application) {
		application.setMainApplicationClass(mergedConfig.getTestClass());
		application.addPrimarySources(Arrays.asList(mergedConfig.getClasses()));
		application.getSources().addAll(Arrays.asList(mergedConfig.getLocations()));
		List<ApplicationContextInitializer<?>> initializers = getInitializers(mergedConfig, application);
		if (mergedConfig instanceof WebMergedContextConfiguration) {
			application.setWebApplicationType(WebApplicationType.SERVLET);
			if (!isEmbeddedWebEnvironment(mergedConfig)) {
				new WebConfigurer().configure(mergedConfig, initializers);
			}
		}
		else if (mergedConfig instanceof ReactiveWebMergedContextConfiguration) {
			application.setWebApplicationType(WebApplicationType.REACTIVE);
		}
		else {
			application.setWebApplicationType(WebApplicationType.NONE);
		}
		application.setApplicationContextFactory(getApplicationContextFactory(mergedConfig));
		if (mergedConfig.getParent() != null) {
			application.setBannerMode(Banner.Mode.OFF);
		}
		application.setInitializers(initializers);
		ConfigurableEnvironment environment = getEnvironment();
		if (environment != null) {
			prepareEnvironment(mergedConfig, application, environment, false);
			application.setEnvironment(environment);
		}
		else {
			application.addListeners(new PrepareEnvironmentListener(mergedConfig));
		}
	}
	/**
	 * Return the {@link ApplicationContextFactory} that should be used for the test. By
	 * default this method will return a factory that will create an appropriate
	 * {@link ApplicationContext} for the {@link WebApplicationType}.
	 * @param mergedConfig the merged context configuration
	 * @return the application context factory to use
	 * @since 3.2.0
	 */
	protected ApplicationContextFactory getApplicationContextFactory(MergedContextConfiguration mergedConfig) {
		return (webApplicationType) -> {
			if (webApplicationType != WebApplicationType.NONE && !isEmbeddedWebEnvironment(mergedConfig)) {
				if (webApplicationType == WebApplicationType.REACTIVE) {
					return new GenericReactiveWebApplicationContext();
				}
				if (webApplicationType == WebApplicationType.SERVLET) {
					return new GenericWebApplicationContext();
				}
			}
			return ApplicationContextFactory.DEFAULT.create(webApplicationType);
		};
	}
	private void prepareEnvironment(MergedContextConfiguration mergedConfig, SpringApplication application,
			ConfigurableEnvironment environment, boolean applicationEnvironment) {
		setActiveProfiles(environment, mergedConfig.getActiveProfiles(), applicationEnvironment);
		ResourceLoader resourceLoader = (application.getResourceLoader() != null) ? application.getResourceLoader()
				: new DefaultResourceLoader(null);
		TestPropertySourceUtils.addPropertySourcesToEnvironment(environment, resourceLoader,
				mergedConfig.getPropertySourceDescriptors());
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(environment, getInlinedProperties(mergedConfig));
	}
	private void setActiveProfiles(ConfigurableEnvironment environment, String[] profiles,
			boolean applicationEnvironment) {
		if (ObjectUtils.isEmpty(profiles)) {
			return;
		}
		if (!applicationEnvironment) {
			environment.setActiveProfiles(profiles);
		}
		String[] pairs = new String[profiles.length];
		for (int i = 0; i < profiles.length; i++) {
			pairs[i] = 'spring.profiles.active[' + i + ']=' + profiles[i];
		}
		TestPropertyValues.of(pairs).applyTo(environment, Type.MAP, 'active-test-profiles');
	}
	/**
	 * Builds new {@link org.springframework.boot.SpringApplication} instance. This method
	 * is only called when a {@code main} method isn"t being used to create the
	 * {@link SpringApplication}.
	 * @return a {@link SpringApplication} instance
	 */
	protected SpringApplication getSpringApplication() {
		return new SpringApplication();
	}
	/**
	 * Returns the {@link ConfigurableEnvironment} instance that should be applied to
	 * {@link SpringApplication} or {@code null} to use the default. You can override this
	 * method if you need a custom environment.
	 * @return a {@link ConfigurableEnvironment} instance
	 */
	protected ConfigurableEnvironment getEnvironment() {
		return null;
	}
	protected String[] getInlinedProperties(MergedContextConfiguration mergedConfig) {
		ArrayList<String> properties = new ArrayList<>();
		// JMX bean names will clash if the same bean is used in multiple contexts
		properties.add('spring.jmx.enabled=false');
		properties.addAll(Arrays.asList(mergedConfig.getPropertySourceProperties()));
		return StringUtils.toStringArray(properties);
	}
	/**
	 * Return the {@link ApplicationContextInitializer initializers} that will be applied
	 * to the context. By default this method will adapt {@link ContextCustomizer context
	 * customizers}, add {@link SpringApplication#getInitializers() application
	 * initializers} and add
	 * {@link MergedContextConfiguration#getContextInitializerClasses() initializers
	 * specified on the test}.
	 * @param mergedConfig the source context configuration
	 * @param application the application instance
	 * @return the initializers to apply
	 * @since 2.0.0
	 */
	protected List<ApplicationContextInitializer<?>> getInitializers(MergedContextConfiguration mergedConfig,
			SpringApplication application) {
		List<ApplicationContextInitializer<?>> initializers = new ArrayList<>();
		for (ContextCustomizer contextCustomizer : mergedConfig.getContextCustomizers()) {
			initializers.add(new ContextCustomizerAdapter(contextCustomizer, mergedConfig));
		}
		initializers.addAll(application.getInitializers());
		for (Class<? extends ApplicationContextInitializer<?>> initializerClass : mergedConfig
			.getContextInitializerClasses()) {
			initializers.add(BeanUtils.instantiateClass(initializerClass));
		}
		if (mergedConfig.getParent() != null) {
			ApplicationContext parentApplicationContext = mergedConfig.getParentApplicationContext();
			initializers.add(new ParentContextApplicationContextInitializer(parentApplicationContext));
		}
		return initializers;
	}
	private boolean isEmbeddedWebEnvironment(MergedContextConfiguration mergedConfig) {
		return SpringBootTestAnnotation.get(mergedConfig).getWebEnvironment().isEmbedded();
	}
	@Override
	public void processContextConfiguration(ContextConfigurationAttributes configAttributes) {
		super.processContextConfiguration(configAttributes);
		if (!configAttributes.hasResources()) {
			Class<?>[] defaultConfigClasses = detectDefaultConfigurationClasses(configAttributes.getDeclaringClass());
			configAttributes.setClasses(defaultConfigClasses);
		}
	}
	/**
	 * Detect the default configuration classes for the supplied test class. By default
	 * simply delegates to
	 * {@link AnnotationConfigContextLoaderUtils#detectDefaultConfigurationClasses}.
	 * @param declaringClass the test class that declared {@code @ContextConfiguration}
	 * @return an array of default configuration classes, potentially empty but never
	 * {@code null}
	 * @see AnnotationConfigContextLoaderUtils
	 */
	protected Class<?>[] detectDefaultConfigurationClasses(Class<?> declaringClass) {
		return AnnotationConfigContextLoaderUtils.detectDefaultConfigurationClasses(declaringClass);
	}
	@Override
	protected String[] getResourceSuffixes() {
		return new String[] { '-context.xml', 'Context.groovy' };
	}
	@Override
	protected String getResourceSuffix() {
		throw new IllegalStateException();
	}
	/**
	 * Modes that the {@link SpringBootContextLoader} can operate.
	 */
	private enum Mode {
		/**
		 * Load for regular usage.
		 * @see SmartContextLoader#loadContext
		 */
		STANDARD,
		/**
		 * Load for AOT processing.
		 * @see AotContextLoader#loadContextForAotProcessing
		 */
		AOT_PROCESSING,
		/**
		 * Load for AOT runtime.
		 * @see AotContextLoader#loadContextForAotRuntime
		 */
		AOT_RUNTIME
	}
	/**
	 * Inner class to configure {@link WebMergedContextConfiguration}.
	 */
	private static final class WebConfigurer {
		void configure(MergedContextConfiguration mergedConfig, List<ApplicationContextInitializer<?>> initializers) {
			WebMergedContextConfiguration webMergedConfig = (WebMergedContextConfiguration) mergedConfig;
			addMockServletContext(initializers, webMergedConfig);
		}
		private void addMockServletContext(List<ApplicationContextInitializer<?>> initializers,
				WebMergedContextConfiguration webMergedConfig) {
			SpringBootMockServletContext servletContext = new SpringBootMockServletContext(
					webMergedConfig.getResourceBasePath());
			initializers.add(0, new DefensiveWebApplicationContextInitializer(
					new ServletContextApplicationContextInitializer(servletContext, true)));
		}
		/**
		 * Decorator for {@link ServletContextApplicationContextInitializer} that prevents
		 * a failure when the context type is not as was predicted when the initializer
		 * was registered. This can occur when spring.main.web-application-type is set to
		 * something other than servlet.
		 */
		private static final class DefensiveWebApplicationContextInitializer
				implements ApplicationContextInitializer<ConfigurableApplicationContext> {
			private final ServletContextApplicationContextInitializer delegate;
			private DefensiveWebApplicationContextInitializer(ServletContextApplicationContextInitializer delegate) {
				this.delegate = delegate;
			}
			@Override
			public void initialize(ConfigurableApplicationContext applicationContext) {
				if (applicationContext instanceof ConfigurableWebApplicationContext webApplicationContext) {
					this.delegate.initialize(webApplicationContext);
				}
			}
		}
	}
	/**
	 * Adapts a {@link ContextCustomizer} to a {@link ApplicationContextInitializer} so
	 * that it can be triggered through {@link SpringApplication}.
	 */
	private static class ContextCustomizerAdapter
			implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		private final ContextCustomizer contextCustomizer;
		private final MergedContextConfiguration mergedConfig;
		ContextCustomizerAdapter(ContextCustomizer contextCustomizer, MergedContextConfiguration mergedConfig) {
			this.contextCustomizer = contextCustomizer;
			this.mergedConfig = mergedConfig;
		}
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
			this.contextCustomizer.customizeContext(applicationContext, this.mergedConfig);
		}
	}
	/**
	 * {@link ApplicationContextInitializer} used to set the parent context.
	 */
	@Order(Ordered.HIGHEST_PRECEDENCE)
	private static class ParentContextApplicationContextInitializer
			implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		private final ApplicationContext parent;
		ParentContextApplicationContextInitializer(ApplicationContext parent) {
			this.parent = parent;
		}
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
			applicationContext.setParent(this.parent);
		}
	}
	/**
	 * {@link ApplicationListener} used to prepare the application created environment.
	 */
	private class PrepareEnvironmentListener
			implements ApplicationListener<ApplicationEnvironmentPreparedEvent>, PriorityOrdered {
		private final MergedContextConfiguration mergedConfig;
		PrepareEnvironmentListener(MergedContextConfiguration mergedConfig) {
			this.mergedConfig = mergedConfig;
		}
		@Override
		public int getOrder() {
			return Ordered.HIGHEST_PRECEDENCE;
		}
		@Override
		public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
			prepareEnvironment(this.mergedConfig, event.getSpringApplication(), event.getEnvironment(), true);
		}
	}
	/**
	 * {@link SpringApplicationHook} used to capture {@link ApplicationContext} instances
	 * and to trigger early exit for the {@link Mode#AOT_PROCESSING} mode.
	 */
	private static class ContextLoaderHook implements SpringApplicationHook {
		private final Mode mode;
		private final ApplicationContextInitializer<ConfigurableApplicationContext> initializer;
		private final Consumer<SpringApplication> configurer;
		private final List<ApplicationContext> contexts = Collections.synchronizedList(new ArrayList<>());
		private final List<ApplicationContext> failedContexts = Collections.synchronizedList(new ArrayList<>());
		ContextLoaderHook(Mode mode, ApplicationContextInitializer<ConfigurableApplicationContext> initializer,
				Consumer<SpringApplication> configurer) {
			this.mode = mode;
			this.initializer = initializer;
			this.configurer = configurer;
		}
		@Override
		public SpringApplicationRunListener getRunListener(SpringApplication application) {
			return new SpringApplicationRunListener() {
				@Override
				public void starting(ConfigurableBootstrapContext bootstrapContext) {
					ContextLoaderHook.this.configurer.accept(application);
					if (ContextLoaderHook.this.mode == Mode.AOT_RUNTIME) {
						application.addInitializers(
								(AotApplicationContextInitializer<?>) ContextLoaderHook.this.initializer::initialize);
					}
				}
				@Override
				public void contextLoaded(ConfigurableApplicationContext context) {
					ContextLoaderHook.this.contexts.add(context);
					if (ContextLoaderHook.this.mode == Mode.AOT_PROCESSING) {
						throw new AbandonedRunException(context);
					}
				}
				@Override
				public void failed(ConfigurableApplicationContext context, Throwable exception) {
					ContextLoaderHook.this.failedContexts.add(context);
				}
			};
		}
		private <T> ApplicationContext runMain(Runnable action) throws Exception {
			return run(() -> {
				action.run();
				return null;
			});
		}
		private ApplicationContext run(ThrowingSupplier<ConfigurableApplicationContext> action) throws Exception {
			try {
				ConfigurableApplicationContext context = SpringApplication.withHook(this, action);
				if (context != null) {
					return context;
				}
			}
			catch (AbandonedRunException ex) {
				// Ignore
			}
			catch (Exception ex) {
				if (this.failedContexts.size() == 1) {
					throw new ContextLoadException(this.failedContexts.get(0), ex);
				}
				throw ex;
			}
			List<ApplicationContext> rootContexts = this.contexts.stream()
				.filter((context) -> context.getParent() == null)
				.toList();
			Assert.state(!rootContexts.isEmpty(), 'No root application context located');
			Assert.state(rootContexts.size() == 1, 'No unique root application context located');
			return rootContexts.get(0);
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
public class ReactiveWebMergedContextConfiguration extends MergedContextConfiguration {
	public ReactiveWebMergedContextConfiguration(MergedContextConfiguration mergedConfig) {
		super(mergedConfig);
	}
}
/*
package org.springframework.boot.test.context;
/**
public final class AnnotatedClassFinder {
	private static final Map<String, Class<?>> cache = Collections.synchronizedMap(new Cache(40));
	private final Class<? extends Annotation> annotationType;
	private final ClassPathScanningCandidateComponentProvider scanner;
	/**
	 * Create a new instance with the {@code annotationType} to find.
	 * @param annotationType the annotation to find
	 */
	public AnnotatedClassFinder(Class<? extends Annotation> annotationType) {
		Assert.notNull(annotationType, 'AnnotationType must not be null');
		this.annotationType = annotationType;
		this.scanner = new ClassPathScanningCandidateComponentProvider(false);
		this.scanner.addIncludeFilter(new AnnotationTypeFilter(annotationType));
		this.scanner.setResourcePattern('*.class');
	}
	/**
	 * Find the first {@link Class} that is annotated with the target annotation, starting
	 * from the package defined by the given {@code source} up to the root.
	 * @param source the source class to use to initiate the search
	 * @return the first {@link Class} annotated with the target annotation within the
	 * hierarchy defined by the given {@code source} or {@code null} if none is found.
	 */
	public Class<?> findFromClass(Class<?> source) {
		Assert.notNull(source, 'Source must not be null');
		return findFromPackage(ClassUtils.getPackageName(source));
	}
	/**
	 * Find the first {@link Class} that is annotated with the target annotation, starting
	 * from the package defined by the given {@code source} up to the root.
	 * @param source the source package to use to initiate the search
	 * @return the first {@link Class} annotated with the target annotation within the
	 * hierarchy defined by the given {@code source} or {@code null} if none is found.
	 */
	public Class<?> findFromPackage(String source) {
		Assert.notNull(source, 'Source must not be null');
		Class<?> configuration = cache.get(source);
		if (configuration == null) {
			configuration = scanPackage(source);
			cache.put(source, configuration);
		}
		return configuration;
	}
	private Class<?> scanPackage(String source) {
		while (!source.isEmpty()) {
			Set<BeanDefinition> components = this.scanner.findCandidateComponents(source);
			if (!components.isEmpty()) {
				Assert.state(components.size() == 1, () -> 'Found multiple @' + this.annotationType.getSimpleName()
						+ ' annotated classes ' + components);
				return ClassUtils.resolveClassName(components.iterator().next().getBeanClassName(), null);
			}
			source = getParentPackage(source);
		}
		return null;
	}
	private String getParentPackage(String sourcePackage) {
		int lastDot = sourcePackage.lastIndexOf(".");
		return (lastDot != -1) ? sourcePackage.substring(0, lastDot) : '';
	}
	/**
	 * Cache implementation based on {@link LinkedHashMap}.
	 */
	private static class Cache extends LinkedHashMap<String, Class<?>> {
		private final int maxSize;
		Cache(int maxSize) {
			super(16, 0.75f, true);
			this.maxSize = maxSize;
		}
		@Override
		protected boolean removeEldestEntry(Map.Entry<String, Class<?>> eldest) {
			return size() > this.maxSize;
		}
	}
}
/*
package org.springframework.boot.test.context;
/**
class ImportsContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		if (AotDetector.useGeneratedArtifacts()) {
			return null;
		}
		AnnotationDescriptor<Import> descriptor = TestContextAnnotationUtils.findAnnotationDescriptor(testClass,
				Import.class);
		if (descriptor != null) {
			assertHasNoBeanMethods(descriptor.getRootDeclaringClass());
			return new ImportsContextCustomizer(descriptor.getRootDeclaringClass());
		}
		return null;
	}
	private void assertHasNoBeanMethods(Class<?> testClass) {
		ReflectionUtils.doWithMethods(testClass, this::assertHasNoBeanMethods);
	}
	private void assertHasNoBeanMethods(Method method) {
		Assert.state(!MergedAnnotations.from(method).isPresent(Bean.class),
				'Test classes cannot include @Bean methods');
	}
}
/*
/**
package org.springframework.boot.test.context;
/*
package org.springframework.boot.test.context;
/**
public class SpringBootTestAotProcessor extends TestAotProcessor {
	/**
	 * Create a new processor for the specified test classpath roots and general settings.
	 * @param classpathRoots the classpath roots to scan for test classes
	 * @param settings the general AOT processor settings
	 */
	public SpringBootTestAotProcessor(Set<Path> classpathRoots, Settings settings) {
		super(classpathRoots, settings);
	}
	public static void main(String[] args) {
		int requiredArgs = 6;
		Assert.isTrue(args.length >= requiredArgs,
				() -> 'Usage: %s <classpathRoots> <sourceOutput> <resourceOutput> <classOutput> <groupId> <artifactId>'
					.formatted(TestAotProcessor.class.getName()));
		Set<Path> classpathRoots = Arrays.stream(args[0].split(File.pathSeparator))
			.map(Paths::get)
			.collect(Collectors.toSet());
		Settings settings = Settings.builder()
			.sourceOutput(Paths.get(args[1]))
			.resourceOutput(Paths.get(args[2]))
			.classOutput(Paths.get(args[3]))
			.groupId(args[4])
			.artifactId(args[5])
			.build();
		new SpringBootTestAotProcessor(classpathRoots, settings).process();
	}
}
/*
package org.springframework.boot.test.web.htmlunit.webdriver;
/**
public class LocalHostWebConnectionHtmlUnitDriver extends WebConnectionHtmlUnitDriver {
	private final Environment environment;
	public LocalHostWebConnectionHtmlUnitDriver(Environment environment) {
		Assert.notNull(environment, 'Environment must not be null');
		this.environment = environment;
	}
	public LocalHostWebConnectionHtmlUnitDriver(Environment environment, boolean enableJavascript) {
		super(enableJavascript);
		Assert.notNull(environment, 'Environment must not be null');
		this.environment = environment;
	}
	public LocalHostWebConnectionHtmlUnitDriver(Environment environment, BrowserVersion browserVersion) {
		super(browserVersion);
		Assert.notNull(environment, 'Environment must not be null');
		this.environment = environment;
	}
	public LocalHostWebConnectionHtmlUnitDriver(Environment environment, Capabilities capabilities) {
		super(capabilities);
		Assert.notNull(environment, 'Environment must not be null');
		this.environment = environment;
	}
	@Override
	public void get(String url) {
		if (url.startsWith('/')) {
			String port = this.environment.getProperty('local.server.port', '8080');
			url = 'http://localhost:' + port + url;
		}
		super.get(url);
	}
}
/*
/**
package org.springframework.boot.test.web.htmlunit.webdriver;
/*
/**
package org.springframework.boot.test.web.htmlunit;
/*
package org.springframework.boot.test.web.htmlunit;
/**
public class LocalHostWebClient extends WebClient {
	private final Environment environment;
	public LocalHostWebClient(Environment environment) {
		Assert.notNull(environment, 'Environment must not be null');
		this.environment = environment;
	}
	@Override
	public <P extends Page> P getPage(String url) throws IOException, FailingHttpStatusCodeException {
		if (url.startsWith('/')) {
			String port = this.environment.getProperty('local.server.port', '8080');
			url = 'http://localhost:' + port + url;
		}
		return super.getPage(url);
	}
}
/*
package org.springframework.boot.test.web.server;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Value('${local.management.port}')
public @interface LocalManagementPort {
}
/*
package org.springframework.boot.test.web.server;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Value('${local.server.port}')
public @interface LocalServerPort {
}
/*
/**
package org.springframework.boot.test.web.server;
/*
package org.springframework.boot.test.web.reactor.netty;
/**
class DisableReactorResourceFactoryGlobalResourcesBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof ReactorResourceFactory reactorResourceFactory) {
			reactorResourceFactory.setUseGlobalResources(false);
		}
		return bean;
	}
}
/*
/**
package org.springframework.boot.test.web.reactor.netty;
/*
package org.springframework.boot.test.web.reactor.netty;
/**
class DisableReactorResourceFactoryGlobalResourcesContextCustomizerFactory implements ContextCustomizerFactory {
	String REACTOR_RESOURCE_FACTORY_CLASS = 'org.springframework.http.client.ReactorResourceFactory';
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		if (ClassUtils.isPresent(this.REACTOR_RESOURCE_FACTORY_CLASS, testClass.getClassLoader())) {
			return new DisableReactorResourceFactoryGlobalResourcesContextCustomizerCustomizer();
		}
		return null;
	}
	static final class DisableReactorResourceFactoryGlobalResourcesContextCustomizerCustomizer
			implements ContextCustomizer {
		private DisableReactorResourceFactoryGlobalResourcesContextCustomizerCustomizer() {
		}
		@Override
		public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
			context.getBeanFactory()
				.registerSingleton(DisableReactorResourceFactoryGlobalResourcesBeanPostProcessor.class.getName(),
						new DisableReactorResourceFactoryGlobalResourcesBeanPostProcessor());
		}
		@Override
		public boolean equals(Object obj) {
			return (obj instanceof DisableReactorResourceFactoryGlobalResourcesContextCustomizerCustomizer);
		}
		@Override
		public int hashCode() {
			return getClass().hashCode();
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class TestRestTemplateContextCustomizer implements ContextCustomizer {
	@Override
	public void customizeContext(ConfigurableApplicationContext context,
			MergedContextConfiguration mergedContextConfiguration) {
		if (AotDetector.useGeneratedArtifacts()) {
			return;
		}
		SpringBootTest springBootTest = TestContextAnnotationUtils
			.findMergedAnnotation(mergedContextConfiguration.getTestClass(), SpringBootTest.class);
		if (springBootTest.webEnvironment().isEmbedded()) {
			registerTestRestTemplate(context);
		}
	}
	private void registerTestRestTemplate(ConfigurableApplicationContext context) {
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		if (beanFactory instanceof BeanDefinitionRegistry registry) {
			registerTestRestTemplate(registry);
		}
	}
	private void registerTestRestTemplate(BeanDefinitionRegistry registry) {
		RootBeanDefinition definition = new RootBeanDefinition(TestRestTemplateRegistrar.class);
		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(TestRestTemplateRegistrar.class.getName(), definition);
	}
	@Override
	public boolean equals(Object obj) {
		return (obj != null) && (obj.getClass() == getClass());
	}
	@Override
	public int hashCode() {
		return getClass().hashCode();
	}
	/**
	 * {@link BeanDefinitionRegistryPostProcessor} that runs after the
	 * {@link ConfigurationClassPostProcessor} and add a {@link TestRestTemplateFactory}
	 * bean definition when a {@link TestRestTemplate} hasn"t already been registered.
	 */
	static class TestRestTemplateRegistrar implements BeanDefinitionRegistryPostProcessor, Ordered, BeanFactoryAware {
		private BeanFactory beanFactory;
		@Override
		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}
		@Override
		public int getOrder() {
			return Ordered.LOWEST_PRECEDENCE;
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			if (AotDetector.useGeneratedArtifacts()) {
				return;
			}
			if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors((ListableBeanFactory) this.beanFactory,
					TestRestTemplate.class, false, false).length == 0) {
				registry.registerBeanDefinition(TestRestTemplate.class.getName(),
						new RootBeanDefinition(TestRestTemplateFactory.class));
			}
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
	}
	/**
	 * {@link FactoryBean} used to create and configure a {@link TestRestTemplate}.
	 */
	public static class TestRestTemplateFactory implements FactoryBean<TestRestTemplate>, ApplicationContextAware {
		private static final HttpClientOption[] DEFAULT_OPTIONS = {};
		private static final HttpClientOption[] SSL_OPTIONS = { HttpClientOption.SSL };
		private TestRestTemplate template;
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
			RestTemplateBuilder builder = getRestTemplateBuilder(applicationContext);
			boolean sslEnabled = isSslEnabled(applicationContext);
			TestRestTemplate template = new TestRestTemplate(builder, null, null,
					sslEnabled ? SSL_OPTIONS : DEFAULT_OPTIONS);
			LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(applicationContext.getEnvironment(),
					sslEnabled ? 'https' : 'http');
			template.setUriTemplateHandler(handler);
			this.template = template;
		}
		private boolean isSslEnabled(ApplicationContext context) {
			try {
				AbstractServletWebServerFactory webServerFactory = context
					.getBean(AbstractServletWebServerFactory.class);
				return webServerFactory.getSsl() != null && webServerFactory.getSsl().isEnabled();
			}
			catch (NoSuchBeanDefinitionException ex) {
				return false;
			}
		}
		private RestTemplateBuilder getRestTemplateBuilder(ApplicationContext applicationContext) {
			try {
				return applicationContext.getBean(RestTemplateBuilder.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				return new RestTemplateBuilder();
			}
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
		@Override
		public Class<?> getObjectType() {
			return TestRestTemplate.class;
		}
		@Override
		public TestRestTemplate getObject() throws Exception {
			return this.template;
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
class TestRestTemplateContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		SpringBootTest springBootTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				SpringBootTest.class);
		return (springBootTest != null) ? new TestRestTemplateContextCustomizer() : null;
	}
}
/*
package org.springframework.boot.test.web.client;
/**
public class MockServerRestClientCustomizer implements RestClientCustomizer {
	private final Map<RestClient.Builder, RequestExpectationManager> expectationManagers = new ConcurrentHashMap<>();
	private final Map<RestClient.Builder, MockRestServiceServer> servers = new ConcurrentHashMap<>();
	private final Supplier<? extends RequestExpectationManager> expectationManagerSupplier;
	private boolean bufferContent = false;
	public MockServerRestClientCustomizer() {
		this(SimpleRequestExpectationManager::new);
	}
	/**
	 * Create a new {@link MockServerRestClientCustomizer} instance.
	 * @param expectationManager the expectation manager class to use
	 */
	public MockServerRestClientCustomizer(Class<? extends RequestExpectationManager> expectationManager) {
		this(() -> BeanUtils.instantiateClass(expectationManager));
		Assert.notNull(expectationManager, 'ExpectationManager must not be null');
	}
	/**
	 * Create a new {@link MockServerRestClientCustomizer} instance.
	 * @param expectationManagerSupplier a supplier that provides the
	 * {@link RequestExpectationManager} to use
	 * @since 3.0.0
	 */
	public MockServerRestClientCustomizer(Supplier<? extends RequestExpectationManager> expectationManagerSupplier) {
		Assert.notNull(expectationManagerSupplier, 'ExpectationManagerSupplier must not be null');
		this.expectationManagerSupplier = expectationManagerSupplier;
	}
	/**
	 * Set if the {@link BufferingClientHttpRequestFactory} wrapper should be used to
	 * buffer the input and output streams, and for example, allow multiple reads of the
	 * response body.
	 * @param bufferContent if request and response content should be buffered
	 * @since 3.1.0
	 */
	public void setBufferContent(boolean bufferContent) {
		this.bufferContent = bufferContent;
	}
	@Override
	public void customize(RestClient.Builder restClientBuilder) {
		RequestExpectationManager expectationManager = createExpectationManager();
		MockRestServiceServerBuilder serverBuilder = MockRestServiceServer.bindTo(restClientBuilder);
		if (this.bufferContent) {
			serverBuilder.bufferContent();
		}
		MockRestServiceServer server = serverBuilder.build(expectationManager);
		this.expectationManagers.put(restClientBuilder, expectationManager);
		this.servers.put(restClientBuilder, server);
	}
	protected RequestExpectationManager createExpectationManager() {
		return this.expectationManagerSupplier.get();
	}
	public MockRestServiceServer getServer() {
		Assert.state(!this.servers.isEmpty(), 'Unable to return a single MockRestServiceServer since '
				+ 'MockServerRestClientCustomizer has not been bound to a RestClient');
		Assert.state(this.servers.size() == 1, 'Unable to return a single MockRestServiceServer since '
				+ 'MockServerRestClientCustomizer has been bound to more than one RestClient');
		return this.servers.values().iterator().next();
	}
	public Map<RestClient.Builder, RequestExpectationManager> getExpectationManagers() {
		return this.expectationManagers;
	}
	public MockRestServiceServer getServer(RestClient.Builder restClientBuilder) {
		return this.servers.get(restClientBuilder);
	}
	public Map<RestClient.Builder, MockRestServiceServer> getServers() {
		return Collections.unmodifiableMap(this.servers);
	}
}
/*
package org.springframework.boot.test.web.client;
/**
public class MockServerRestTemplateCustomizer implements RestTemplateCustomizer {
	private final Map<RestTemplate, RequestExpectationManager> expectationManagers = new ConcurrentHashMap<>();
	private final Map<RestTemplate, MockRestServiceServer> servers = new ConcurrentHashMap<>();
	private final Supplier<? extends RequestExpectationManager> expectationManagerSupplier;
	private boolean detectRootUri = true;
	private boolean bufferContent = false;
	public MockServerRestTemplateCustomizer() {
		this(SimpleRequestExpectationManager::new);
	}
	/**
	 * Create a new {@link MockServerRestTemplateCustomizer} instance.
	 * @param expectationManager the expectation manager class to use
	 */
	public MockServerRestTemplateCustomizer(Class<? extends RequestExpectationManager> expectationManager) {
		this(() -> BeanUtils.instantiateClass(expectationManager));
		Assert.notNull(expectationManager, 'ExpectationManager must not be null');
	}
	/**
	 * Create a new {@link MockServerRestTemplateCustomizer} instance.
	 * @param expectationManagerSupplier a supplier that provides the
	 * {@link RequestExpectationManager} to use
	 * @since 3.0.0
	 */
	public MockServerRestTemplateCustomizer(Supplier<? extends RequestExpectationManager> expectationManagerSupplier) {
		Assert.notNull(expectationManagerSupplier, 'ExpectationManagerSupplier must not be null');
		this.expectationManagerSupplier = expectationManagerSupplier;
	}
	/**
	 * Set if root URIs from {@link RootUriRequestExpectationManager} should be detected
	 * and applied to the {@link MockRestServiceServer}.
	 * @param detectRootUri if root URIs should be detected
	 */
	public void setDetectRootUri(boolean detectRootUri) {
		this.detectRootUri = detectRootUri;
	}
	/**
	 * Set if the {@link BufferingClientHttpRequestFactory} wrapper should be used to
	 * buffer the input and output streams, and for example, allow multiple reads of the
	 * response body.
	 * @param bufferContent if request and response content should be buffered
	 * @since 3.1.0
	 */
	public void setBufferContent(boolean bufferContent) {
		this.bufferContent = bufferContent;
	}
	@Override
	public void customize(RestTemplate restTemplate) {
		RequestExpectationManager expectationManager = createExpectationManager();
		if (this.detectRootUri) {
			expectationManager = RootUriRequestExpectationManager.forRestTemplate(restTemplate, expectationManager);
		}
		MockRestServiceServerBuilder serverBuilder = MockRestServiceServer.bindTo(restTemplate);
		if (this.bufferContent) {
			serverBuilder.bufferContent();
		}
		MockRestServiceServer server = serverBuilder.build(expectationManager);
		this.expectationManagers.put(restTemplate, expectationManager);
		this.servers.put(restTemplate, server);
	}
	protected RequestExpectationManager createExpectationManager() {
		return this.expectationManagerSupplier.get();
	}
	public MockRestServiceServer getServer() {
		Assert.state(!this.servers.isEmpty(), 'Unable to return a single MockRestServiceServer since '
				+ 'MockServerRestTemplateCustomizer has not been bound to a RestTemplate');
		Assert.state(this.servers.size() == 1, 'Unable to return a single MockRestServiceServer since '
				+ 'MockServerRestTemplateCustomizer has been bound to more than one RestTemplate');
		return this.servers.values().iterator().next();
	}
	public Map<RestTemplate, RequestExpectationManager> getExpectationManagers() {
		return this.expectationManagers;
	}
	public MockRestServiceServer getServer(RestTemplate restTemplate) {
		return this.servers.get(restTemplate);
	}
	public Map<RestTemplate, MockRestServiceServer> getServers() {
		return Collections.unmodifiableMap(this.servers);
	}
}
/*
package org.springframework.boot.test.web.client;
/**
public class RootUriRequestExpectationManager implements RequestExpectationManager {
	private final String rootUri;
	private final RequestExpectationManager expectationManager;
	public RootUriRequestExpectationManager(String rootUri, RequestExpectationManager expectationManager) {
		Assert.notNull(rootUri, 'RootUri must not be null');
		Assert.notNull(expectationManager, 'ExpectationManager must not be null');
		this.rootUri = rootUri;
		this.expectationManager = expectationManager;
	}
	@Override
	public ResponseActions expectRequest(ExpectedCount count, RequestMatcher requestMatcher) {
		return this.expectationManager.expectRequest(count, requestMatcher);
	}
	@Override
	public ClientHttpResponse validateRequest(ClientHttpRequest request) throws IOException {
		String uri = request.getURI().toString();
		if (uri.startsWith(this.rootUri)) {
			request = replaceURI(request, uri.substring(this.rootUri.length()));
		}
		try {
			return this.expectationManager.validateRequest(request);
		}
		catch (AssertionError ex) {
			String message = ex.getMessage();
			String prefix = 'Request URI expected:</';
			if (message != null && message.startsWith(prefix)) {
				throw new AssertionError(
						'Request URI expected:<' + this.rootUri + message.substring(prefix.length() - 1));
			}
			throw ex;
		}
	}
	private ClientHttpRequest replaceURI(ClientHttpRequest request, String replacementUri) {
		URI uri;
		try {
			uri = new URI(replacementUri);
			if (request instanceof MockClientHttpRequest mockClientHttpRequest) {
				mockClientHttpRequest.setURI(uri);
				return mockClientHttpRequest;
			}
			return new ReplaceUriClientHttpRequest(uri, request);
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException(ex);
		}
	}
	@Override
	public void verify() {
		this.expectationManager.verify();
	}
	@Override
	public void verify(Duration timeout) {
		this.expectationManager.verify(timeout);
	}
	@Override
	public void reset() {
		this.expectationManager.reset();
	}
	/**
	 * Return a bound {@link MockRestServiceServer} for the given {@link RestTemplate},
	 * configured with {@link RootUriRequestExpectationManager} when possible.
	 * @param restTemplate the source REST template
	 * @return a configured {@link MockRestServiceServer}
	 */
	public static MockRestServiceServer bindTo(RestTemplate restTemplate) {
		return bindTo(restTemplate, new SimpleRequestExpectationManager());
	}
	/**
	 * Return a bound {@link MockRestServiceServer} for the given {@link RestTemplate},
	 * configured with {@link RootUriRequestExpectationManager} when possible.
	 * @param restTemplate the source REST template
	 * @param expectationManager the source {@link RequestExpectationManager}
	 * @return a configured {@link MockRestServiceServer}
	 */
	public static MockRestServiceServer bindTo(RestTemplate restTemplate,
			RequestExpectationManager expectationManager) {
		MockRestServiceServerBuilder builder = MockRestServiceServer.bindTo(restTemplate);
		return builder.build(forRestTemplate(restTemplate, expectationManager));
	}
	/**
	 * Return {@link RequestExpectationManager} to be used for binding with the specified
	 * {@link RestTemplate}. If the {@link RestTemplate} is using a
	 * {@link RootUriTemplateHandler} then a {@link RootUriRequestExpectationManager} is
	 * returned, otherwise the source manager is returned unchanged.
	 * @param restTemplate the source REST template
	 * @param expectationManager the source {@link RequestExpectationManager}
	 * @return a {@link RequestExpectationManager} to be bound to the template
	 */
	public static RequestExpectationManager forRestTemplate(RestTemplate restTemplate,
			RequestExpectationManager expectationManager) {
		Assert.notNull(restTemplate, 'RestTemplate must not be null');
		UriTemplateHandler templateHandler = restTemplate.getUriTemplateHandler();
		if (templateHandler instanceof RootUriTemplateHandler rootHandler) {
			return new RootUriRequestExpectationManager(rootHandler.getRootUri(), expectationManager);
		}
		return expectationManager;
	}
	/**
	 * {@link ClientHttpRequest} wrapper to replace the request URI.
	 */
	private static class ReplaceUriClientHttpRequest extends HttpRequestWrapper implements ClientHttpRequest {
		private final URI uri;
		ReplaceUriClientHttpRequest(URI uri, ClientHttpRequest request) {
			super(request);
			this.uri = uri;
		}
		@Override
		public URI getURI() {
			return this.uri;
		}
		@Override
		public OutputStream getBody() throws IOException {
			return getRequest().getBody();
		}
		@Override
		public ClientHttpResponse execute() throws IOException {
			return getRequest().execute();
		}
		@Override
		public ClientHttpRequest getRequest() {
			return (ClientHttpRequest) super.getRequest();
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
public class TestRestTemplate {
	private final RestTemplateBuilder builder;
	private final HttpClientOption[] httpClientOptions;
	private final RestTemplate restTemplate;
	/**
	 * Create a new {@link TestRestTemplate} instance.
	 * @param restTemplateBuilder builder used to configure underlying
	 * {@link RestTemplate}
	 * @since 1.4.1
	 */
	public TestRestTemplate(RestTemplateBuilder restTemplateBuilder) {
		this(restTemplateBuilder, null, null);
	}
	/**
	 * Create a new {@link TestRestTemplate} instance.
	 * @param httpClientOptions client options to use if the Apache HTTP Client is used
	 */
	public TestRestTemplate(HttpClientOption... httpClientOptions) {
		this(null, null, httpClientOptions);
	}
	/**
	 * Create a new {@link TestRestTemplate} instance with the specified credentials.
	 * @param username the username to use (or {@code null})
	 * @param password the password (or {@code null})
	 * @param httpClientOptions client options to use if the Apache HTTP Client is used
	 */
	public TestRestTemplate(String username, String password, HttpClientOption... httpClientOptions) {
		this(new RestTemplateBuilder(), username, password, httpClientOptions);
	}
	/**
	 * Create a new {@link TestRestTemplate} instance with the specified credentials.
	 * @param builder builder used to configure underlying {@link RestTemplate}
	 * @param username the username to use (or {@code null})
	 * @param password the password (or {@code null})
	 * @param httpClientOptions client options to use if the Apache HTTP Client is used
	 * @since 2.0.0
	 */
	public TestRestTemplate(RestTemplateBuilder builder, String username, String password,
			HttpClientOption... httpClientOptions) {
		Assert.notNull(builder, 'Builder must not be null');
		this.builder = builder;
		this.httpClientOptions = httpClientOptions;
		if (httpClientOptions != null) {
			ClientHttpRequestFactory requestFactory = builder.buildRequestFactory();
			if (requestFactory instanceof HttpComponentsClientHttpRequestFactory) {
				builder = builder.requestFactoryBuilder(
						(settings) -> new CustomHttpComponentsClientHttpRequestFactory(httpClientOptions, settings));
			}
		}
		if (username != null || password != null) {
			builder = builder.basicAuthentication(username, password);
		}
		this.restTemplate = builder.build();
		this.restTemplate.setErrorHandler(new NoOpResponseErrorHandler());
	}
	/**
	 * Configure the {@link UriTemplateHandler} to use to expand URI templates. By default
	 * the {@link DefaultUriBuilderFactory} is used which relies on Spring"s URI template
	 * support and exposes several useful properties that customize its behavior for
	 * encoding and for prepending a common base URL. An alternative implementation may be
	 * used to plug an external URI template library.
	 * @param handler the URI template handler to use
	 */
	public void setUriTemplateHandler(UriTemplateHandler handler) {
		this.restTemplate.setUriTemplateHandler(handler);
	}
	/**
	 * Returns the root URI applied by {@link RestTemplateBuilder#rootUri(String)} or
	 * {@code ''} if the root URI has not been applied.
	 * @return the root URI
	 */
	public String getRootUri() {
		UriTemplateHandler uriTemplateHandler = this.restTemplate.getUriTemplateHandler();
		if (uriTemplateHandler instanceof RootUriTemplateHandler rootHandler) {
			return rootHandler.getRootUri();
		}
		return '';
	}
	/**
	 * Retrieve a representation by doing a GET on the specified URL. The response (if
	 * any) is converted and returned.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * @param url the URL
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see RestTemplate#getForObject(String, Class, Object...)
	 */
	public <T> T getForObject(String url, Class<T> responseType, Object... urlVariables) {
		return this.restTemplate.getForObject(url, responseType, urlVariables);
	}
	/**
	 * Retrieve a representation by doing a GET on the URI template. The response (if any)
	 * is converted and returned.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * @param url the URL
	 * @param responseType the type of the return value
	 * @param urlVariables the map containing variables for the URI template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see RestTemplate#getForObject(String, Class, Object...)
	 */
	public <T> T getForObject(String url, Class<T> responseType, Map<String, ?> urlVariables) {
		return this.restTemplate.getForObject(url, responseType, urlVariables);
	}
	/**
	 * Retrieve a representation by doing a GET on the URL . The response (if any) is
	 * converted and returned.
	 * @param url the URL
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see RestTemplate#getForObject(java.net.URI, java.lang.Class)
	 */
	public <T> T getForObject(URI url, Class<T> responseType) {
		return this.restTemplate.getForObject(applyRootUriIfNecessary(url), responseType);
	}
	/**
	 * Retrieve an entity by doing a GET on the specified URL. The response is converted
	 * and stored in an {@link ResponseEntity}.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * @param url the URL
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the entity
	 * @see RestTemplate#getForEntity(java.lang.String, java.lang.Class,
	 * java.lang.Object[])
	 */
	public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... urlVariables) {
		return this.restTemplate.getForEntity(url, responseType, urlVariables);
	}
	/**
	 * Retrieve a representation by doing a GET on the URI template. The response is
	 * converted and stored in an {@link ResponseEntity}.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * @param url the URL
	 * @param responseType the type of the return value
	 * @param urlVariables the map containing variables for the URI template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see RestTemplate#getForEntity(java.lang.String, java.lang.Class, java.util.Map)
	 */
	public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> urlVariables) {
		return this.restTemplate.getForEntity(url, responseType, urlVariables);
	}
	/**
	 * Retrieve a representation by doing a GET on the URL . The response is converted and
	 * stored in an {@link ResponseEntity}.
	 * @param url the URL
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see RestTemplate#getForEntity(java.net.URI, java.lang.Class)
	 */
	public <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) {
		return this.restTemplate.getForEntity(applyRootUriIfNecessary(url), responseType);
	}
	/**
	 * Retrieve all headers of the resource specified by the URI template.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * @param url the URL
	 * @param urlVariables the variables to expand the template
	 * @return all HTTP headers of that resource
	 * @see RestTemplate#headForHeaders(java.lang.String, java.lang.Object[])
	 */
	public HttpHeaders headForHeaders(String url, Object... urlVariables) {
		return this.restTemplate.headForHeaders(url, urlVariables);
	}
	/**
	 * Retrieve all headers of the resource specified by the URI template.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * @param url the URL
	 * @param urlVariables the map containing variables for the URI template
	 * @return all HTTP headers of that resource
	 * @see RestTemplate#headForHeaders(java.lang.String, java.util.Map)
	 */
	public HttpHeaders headForHeaders(String url, Map<String, ?> urlVariables) {
		return this.restTemplate.headForHeaders(url, urlVariables);
	}
	/**
	 * Retrieve all headers of the resource specified by the URL.
	 * @param url the URL
	 * @return all HTTP headers of that resource
	 * @see RestTemplate#headForHeaders(java.net.URI)
	 */
	public HttpHeaders headForHeaders(URI url) {
		return this.restTemplate.headForHeaders(applyRootUriIfNecessary(url));
	}
	/**
	 * Create a new resource by POSTing the given object to the URI template, and returns
	 * the value of the {@code Location} header. This header typically indicates where the
	 * new resource is stored.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param urlVariables the variables to expand the template
	 * @return the value for the {@code Location} header
	 * @see HttpEntity
	 * @see RestTemplate#postForLocation(java.lang.String, java.lang.Object,
	 * java.lang.Object[])
	 */
	public URI postForLocation(String url, Object request, Object... urlVariables) {
		return this.restTemplate.postForLocation(url, request, urlVariables);
	}
	/**
	 * Create a new resource by POSTing the given object to the URI template, and returns
	 * the value of the {@code Location} header. This header typically indicates where the
	 * new resource is stored.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param urlVariables the variables to expand the template
	 * @return the value for the {@code Location} header
	 * @see HttpEntity
	 * @see RestTemplate#postForLocation(java.lang.String, java.lang.Object,
	 * java.util.Map)
	 */
	public URI postForLocation(String url, Object request, Map<String, ?> urlVariables) {
		return this.restTemplate.postForLocation(url, request, urlVariables);
	}
	/**
	 * Create a new resource by POSTing the given object to the URL, and returns the value
	 * of the {@code Location} header. This header typically indicates where the new
	 * resource is stored.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @return the value for the {@code Location} header
	 * @see HttpEntity
	 * @see RestTemplate#postForLocation(java.net.URI, java.lang.Object)
	 */
	public URI postForLocation(URI url, Object request) {
		return this.restTemplate.postForLocation(applyRootUriIfNecessary(url), request);
	}
	/**
	 * Create a new resource by POSTing the given object to the URI template, and returns
	 * the representation found in the response.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see HttpEntity
	 * @see RestTemplate#postForObject(java.lang.String, java.lang.Object,
	 * java.lang.Class, java.lang.Object[])
	 */
	public <T> T postForObject(String url, Object request, Class<T> responseType, Object... urlVariables) {
		return this.restTemplate.postForObject(url, request, responseType, urlVariables);
	}
	/**
	 * Create a new resource by POSTing the given object to the URI template, and returns
	 * the representation found in the response.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see HttpEntity
	 * @see RestTemplate#postForObject(java.lang.String, java.lang.Object,
	 * java.lang.Class, java.util.Map)
	 */
	public <T> T postForObject(String url, Object request, Class<T> responseType, Map<String, ?> urlVariables) {
		return this.restTemplate.postForObject(url, request, responseType, urlVariables);
	}
	/**
	 * Create a new resource by POSTing the given object to the URL, and returns the
	 * representation found in the response.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see HttpEntity
	 * @see RestTemplate#postForObject(java.net.URI, java.lang.Object, java.lang.Class)
	 */
	public <T> T postForObject(URI url, Object request, Class<T> responseType) {
		return this.restTemplate.postForObject(applyRootUriIfNecessary(url), request, responseType);
	}
	/**
	 * Create a new resource by POSTing the given object to the URI template, and returns
	 * the response as {@link ResponseEntity}.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param responseType the response type to return
	 * @param urlVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see HttpEntity
	 * @see RestTemplate#postForEntity(java.lang.String, java.lang.Object,
	 * java.lang.Class, java.lang.Object[])
	 */
	public <T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType,
			Object... urlVariables) {
		return this.restTemplate.postForEntity(url, request, responseType, urlVariables);
	}
	/**
	 * Create a new resource by POSTing the given object to the URI template, and returns
	 * the response as {@link HttpEntity}.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param responseType the response type to return
	 * @param urlVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see HttpEntity
	 * @see RestTemplate#postForEntity(java.lang.String, java.lang.Object,
	 * java.lang.Class, java.util.Map)
	 */
	public <T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType,
			Map<String, ?> urlVariables) {
		return this.restTemplate.postForEntity(url, request, responseType, urlVariables);
	}
	/**
	 * Create a new resource by POSTing the given object to the URL, and returns the
	 * response as {@link ResponseEntity}.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param responseType the response type to return
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @see HttpEntity
	 * @see RestTemplate#postForEntity(java.net.URI, java.lang.Object, java.lang.Class)
	 */
	public <T> ResponseEntity<T> postForEntity(URI url, Object request, Class<T> responseType) {
		return this.restTemplate.postForEntity(applyRootUriIfNecessary(url), request, responseType);
	}
	/**
	 * Create or update a resource by PUTting the given object to the URI.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * <p>
	 * If you need to assert the request result consider using the
	 * {@link TestRestTemplate#exchange exchange} method.
	 * @param url the URL
	 * @param request the Object to be PUT, may be {@code null}
	 * @param urlVariables the variables to expand the template
	 * @see HttpEntity
	 * @see RestTemplate#put(java.lang.String, java.lang.Object, java.lang.Object[])
	 */
	public void put(String url, Object request, Object... urlVariables) {
		this.restTemplate.put(url, request, urlVariables);
	}
	/**
	 * Creates a new resource by PUTting the given object to URI template.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * <p>
	 * If you need to assert the request result consider using the
	 * {@link TestRestTemplate#exchange exchange} method.
	 * @param url the URL
	 * @param request the Object to be PUT, may be {@code null}
	 * @param urlVariables the variables to expand the template
	 * @see HttpEntity
	 * @see RestTemplate#put(java.lang.String, java.lang.Object, java.util.Map)
	 */
	public void put(String url, Object request, Map<String, ?> urlVariables) {
		this.restTemplate.put(url, request, urlVariables);
	}
	/**
	 * Creates a new resource by PUTting the given object to URL.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * <p>
	 * If you need to assert the request result consider using the
	 * {@link TestRestTemplate#exchange exchange} method.
	 * @param url the URL
	 * @param request the Object to be PUT, may be {@code null}
	 * @see HttpEntity
	 * @see RestTemplate#put(java.net.URI, java.lang.Object)
	 */
	public void put(URI url, Object request) {
		this.restTemplate.put(applyRootUriIfNecessary(url), request);
	}
	/**
	 * Update a resource by PATCHing the given object to the URI template, and returns the
	 * representation found in the response.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be PATCHed, may be {@code null}
	 * @param responseType the type of the return value
	 * @param uriVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @since 1.4.4
	 * @see HttpEntity
	 */
	public <T> T patchForObject(String url, Object request, Class<T> responseType, Object... uriVariables) {
		return this.restTemplate.patchForObject(url, request, responseType, uriVariables);
	}
	/**
	 * Update a resource by PATCHing the given object to the URI template, and returns the
	 * representation found in the response.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be PATCHed, may be {@code null}
	 * @param responseType the type of the return value
	 * @param uriVariables the variables to expand the template
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @since 1.4.4
	 * @see HttpEntity
	 */
	public <T> T patchForObject(String url, Object request, Class<T> responseType, Map<String, ?> uriVariables) {
		return this.restTemplate.patchForObject(url, request, responseType, uriVariables);
	}
	/**
	 * Update a resource by PATCHing the given object to the URL, and returns the
	 * representation found in the response.
	 * <p>
	 * The {@code request} parameter can be a {@link HttpEntity} in order to add
	 * additional HTTP headers to the request.
	 * @param url the URL
	 * @param request the Object to be POSTed, may be {@code null}
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the converted object
	 * @since 1.4.4
	 * @see HttpEntity
	 */
	public <T> T patchForObject(URI url, Object request, Class<T> responseType) {
		return this.restTemplate.patchForObject(applyRootUriIfNecessary(url), request, responseType);
	}
	/**
	 * Delete the resources at the specified URI.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * <p>
	 * If you need to assert the request result consider using the
	 * {@link TestRestTemplate#exchange exchange} method.
	 * @param url the URL
	 * @param urlVariables the variables to expand in the template
	 * @see RestTemplate#delete(java.lang.String, java.lang.Object[])
	 */
	public void delete(String url, Object... urlVariables) {
		this.restTemplate.delete(url, urlVariables);
	}
	/**
	 * Delete the resources at the specified URI.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * <p>
	 * If you need to assert the request result consider using the
	 * {@link TestRestTemplate#exchange exchange} method.
	 * @param url the URL
	 * @param urlVariables the variables to expand the template
	 * @see RestTemplate#delete(java.lang.String, java.util.Map)
	 */
	public void delete(String url, Map<String, ?> urlVariables) {
		this.restTemplate.delete(url, urlVariables);
	}
	/**
	 * Delete the resources at the specified URL.
	 * <p>
	 * If you need to assert the request result consider using the
	 * {@link TestRestTemplate#exchange exchange} method.
	 * @param url the URL
	 * @see RestTemplate#delete(java.net.URI)
	 */
	public void delete(URI url) {
		this.restTemplate.delete(applyRootUriIfNecessary(url));
	}
	/**
	 * Return the value of the {@code Allow} header for the given URI.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * @param url the URL
	 * @param urlVariables the variables to expand in the template
	 * @return the value of the {@code Allow} header
	 * @see RestTemplate#optionsForAllow(java.lang.String, java.lang.Object[])
	 */
	public Set<HttpMethod> optionsForAllow(String url, Object... urlVariables) {
		return this.restTemplate.optionsForAllow(url, urlVariables);
	}
	/**
	 * Return the value of the {@code Allow} header for the given URI.
	 * <p>
	 * URI Template variables are expanded using the given map.
	 * @param url the URL
	 * @param urlVariables the variables to expand in the template
	 * @return the value of the {@code Allow} header
	 * @see RestTemplate#optionsForAllow(java.lang.String, java.util.Map)
	 */
	public Set<HttpMethod> optionsForAllow(String url, Map<String, ?> urlVariables) {
		return this.restTemplate.optionsForAllow(url, urlVariables);
	}
	/**
	 * Return the value of the {@code Allow} header for the given URL.
	 * @param url the URL
	 * @return the value of the {@code Allow} header
	 * @see RestTemplate#optionsForAllow(java.net.URI)
	 */
	public Set<HttpMethod> optionsForAllow(URI url) {
		return this.restTemplate.optionsForAllow(applyRootUriIfNecessary(url));
	}
	/**
	 * Execute the HTTP method to the given URI template, writing the given request entity
	 * to the request, and returns the response as {@link ResponseEntity}.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestEntity the entity (headers and/or body) to write to the request, may
	 * be {@code null}
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand in the template
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(java.lang.String, org.springframework.http.HttpMethod,
	 * org.springframework.http.HttpEntity, java.lang.Class, java.lang.Object[])
	 */
	public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity,
			Class<T> responseType, Object... urlVariables) {
		return this.restTemplate.exchange(url, method, requestEntity, responseType, urlVariables);
	}
	/**
	 * Execute the HTTP method to the given URI template, writing the given request entity
	 * to the request, and returns the response as {@link ResponseEntity}.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestEntity the entity (headers and/or body) to write to the request, may
	 * be {@code null}
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand in the template
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(java.lang.String, org.springframework.http.HttpMethod,
	 * org.springframework.http.HttpEntity, java.lang.Class, java.util.Map)
	 */
	public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity,
			Class<T> responseType, Map<String, ?> urlVariables) {
		return this.restTemplate.exchange(url, method, requestEntity, responseType, urlVariables);
	}
	/**
	 * Execute the HTTP method to the given URI template, writing the given request entity
	 * to the request, and returns the response as {@link ResponseEntity}.
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestEntity the entity (headers and/or body) to write to the request, may
	 * be {@code null}
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(java.net.URI, org.springframework.http.HttpMethod,
	 * org.springframework.http.HttpEntity, java.lang.Class)
	 */
	public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity,
			Class<T> responseType) {
		return this.restTemplate.exchange(applyRootUriIfNecessary(url), method, requestEntity, responseType);
	}
	/**
	 * Execute the HTTP method to the given URI template, writing the given request entity
	 * to the request, and returns the response as {@link ResponseEntity}. The given
	 * {@link ParameterizedTypeReference} is used to pass generic type information:
	 * <pre class='code'>
	 * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean = new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};
	 * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response = template.exchange(&quot;https://example.com&quot;,HttpMethod.GET, null, myBean);
	 * </pre>
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestEntity the entity (headers and/or body) to write to the request, may
	 * be {@code null}
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand in the template
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(java.lang.String, org.springframework.http.HttpMethod,
	 * org.springframework.http.HttpEntity,
	 * org.springframework.core.ParameterizedTypeReference, java.lang.Object[])
	 */
	public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity,
			ParameterizedTypeReference<T> responseType, Object... urlVariables) {
		return this.restTemplate.exchange(url, method, requestEntity, responseType, urlVariables);
	}
	/**
	 * Execute the HTTP method to the given URI template, writing the given request entity
	 * to the request, and returns the response as {@link ResponseEntity}. The given
	 * {@link ParameterizedTypeReference} is used to pass generic type information:
	 * <pre class='code'>
	 * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean = new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};
	 * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response = template.exchange(&quot;https://example.com&quot;,HttpMethod.GET, null, myBean);
	 * </pre>
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestEntity the entity (headers and/or body) to write to the request, may
	 * be {@code null}
	 * @param responseType the type of the return value
	 * @param urlVariables the variables to expand in the template
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(java.lang.String, org.springframework.http.HttpMethod,
	 * org.springframework.http.HttpEntity,
	 * org.springframework.core.ParameterizedTypeReference, java.util.Map)
	 */
	public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity,
			ParameterizedTypeReference<T> responseType, Map<String, ?> urlVariables) {
		return this.restTemplate.exchange(url, method, requestEntity, responseType, urlVariables);
	}
	/**
	 * Execute the HTTP method to the given URI template, writing the given request entity
	 * to the request, and returns the response as {@link ResponseEntity}. The given
	 * {@link ParameterizedTypeReference} is used to pass generic type information:
	 * <pre class='code'>
	 * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean = new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};
	 * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response = template.exchange(&quot;https://example.com&quot;,HttpMethod.GET, null, myBean);
	 * </pre>
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestEntity the entity (headers and/or body) to write to the request, may
	 * be {@code null}
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(java.net.URI, org.springframework.http.HttpMethod,
	 * org.springframework.http.HttpEntity,
	 * org.springframework.core.ParameterizedTypeReference)
	 */
	public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity,
			ParameterizedTypeReference<T> responseType) {
		return this.restTemplate.exchange(applyRootUriIfNecessary(url), method, requestEntity, responseType);
	}
	/**
	 * Execute the request specified in the given {@link RequestEntity} and return the
	 * response as {@link ResponseEntity}. Typically used in combination with the static
	 * builder methods on {@code RequestEntity}, for instance: <pre class='code'>
	 * MyRequest body = ...
	 * RequestEntity request = RequestEntity.post(new URI(&quot;https://example.com/foo&quot;)).accept(MediaType.APPLICATION_JSON).body(body);
	 * ResponseEntity&lt;MyResponse&gt; response = template.exchange(request, MyResponse.class);
	 * </pre>
	 * @param requestEntity the entity to write to the request
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(org.springframework.http.RequestEntity, java.lang.Class)
	 */
	public <T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, Class<T> responseType) {
		return this.restTemplate.exchange(createRequestEntityWithRootAppliedUri(requestEntity), responseType);
	}
	/**
	 * Execute the request specified in the given {@link RequestEntity} and return the
	 * response as {@link ResponseEntity}. The given {@link ParameterizedTypeReference} is
	 * used to pass generic type information: <pre class='code'>
	 * MyRequest body = ...
	 * RequestEntity request = RequestEntity.post(new URI(&quot;https://example.com/foo&quot;)).accept(MediaType.APPLICATION_JSON).body(body);
	 * ParameterizedTypeReference&lt;List&lt;MyResponse&gt;&gt; myBean = new ParameterizedTypeReference&lt;List&lt;MyResponse&gt;&gt;() {};
	 * ResponseEntity&lt;List&lt;MyResponse&gt;&gt; response = template.exchange(request, myBean);
	 * </pre>
	 * @param requestEntity the entity to write to the request
	 * @param responseType the type of the return value
	 * @param <T> the type of the return value
	 * @return the response as entity
	 * @see RestTemplate#exchange(org.springframework.http.RequestEntity,
	 * org.springframework.core.ParameterizedTypeReference)
	 */
	public <T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, ParameterizedTypeReference<T> responseType) {
		return this.restTemplate.exchange(createRequestEntityWithRootAppliedUri(requestEntity), responseType);
	}
	/**
	 * Execute the HTTP method to the given URI template, preparing the request with the
	 * {@link RequestCallback}, and reading the response with a {@link ResponseExtractor}.
	 * <p>
	 * URI Template variables are expanded using the given URI variables, if any.
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestCallback object that prepares the request
	 * @param responseExtractor object that extracts the return value from the response
	 * @param urlVariables the variables to expand in the template
	 * @param <T> the type of the return value
	 * @return an arbitrary object, as returned by the {@link ResponseExtractor}
	 * @see RestTemplate#execute(java.lang.String, org.springframework.http.HttpMethod,
	 * org.springframework.web.client.RequestCallback,
	 * org.springframework.web.client.ResponseExtractor, java.lang.Object[])
	 */
	public <T> T execute(String url, HttpMethod method, RequestCallback requestCallback,
			ResponseExtractor<T> responseExtractor, Object... urlVariables) {
		return this.restTemplate.execute(url, method, requestCallback, responseExtractor, urlVariables);
	}
	/**
	 * Execute the HTTP method to the given URI template, preparing the request with the
	 * {@link RequestCallback}, and reading the response with a {@link ResponseExtractor}.
	 * <p>
	 * URI Template variables are expanded using the given URI variables map.
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestCallback object that prepares the request
	 * @param responseExtractor object that extracts the return value from the response
	 * @param urlVariables the variables to expand in the template
	 * @param <T> the type of the return value
	 * @return an arbitrary object, as returned by the {@link ResponseExtractor}
	 * @see RestTemplate#execute(java.lang.String, org.springframework.http.HttpMethod,
	 * org.springframework.web.client.RequestCallback,
	 * org.springframework.web.client.ResponseExtractor, java.util.Map)
	 */
	public <T> T execute(String url, HttpMethod method, RequestCallback requestCallback,
			ResponseExtractor<T> responseExtractor, Map<String, ?> urlVariables) {
		return this.restTemplate.execute(url, method, requestCallback, responseExtractor, urlVariables);
	}
	/**
	 * Execute the HTTP method to the given URL, preparing the request with the
	 * {@link RequestCallback}, and reading the response with a {@link ResponseExtractor}.
	 * @param url the URL
	 * @param method the HTTP method (GET, POST, etc.)
	 * @param requestCallback object that prepares the request
	 * @param responseExtractor object that extracts the return value from the response
	 * @param <T> the type of the return value
	 * @return an arbitrary object, as returned by the {@link ResponseExtractor}
	 * @see RestTemplate#execute(java.net.URI, org.springframework.http.HttpMethod,
	 * org.springframework.web.client.RequestCallback,
	 * org.springframework.web.client.ResponseExtractor)
	 */
	public <T> T execute(URI url, HttpMethod method, RequestCallback requestCallback,
			ResponseExtractor<T> responseExtractor) {
		return this.restTemplate.execute(applyRootUriIfNecessary(url), method, requestCallback, responseExtractor);
	}
	/**
	 * Returns the underlying {@link RestTemplate} that is actually used to perform the
	 * REST operations.
	 * @return the restTemplate
	 */
	public RestTemplate getRestTemplate() {
		return this.restTemplate;
	}
	/**
	 * Creates a new {@code TestRestTemplate} with the same configuration as this one,
	 * except that it will send basic authorization headers using the given
	 * {@code username} and {@code password}. The request factory used is a new instance
	 * of the underlying {@link RestTemplate}"s request factory type (when possible).
	 * @param username the username
	 * @param password the password
	 * @return the new template
	 * @since 1.4.1
	 */
	public TestRestTemplate withBasicAuth(String username, String password) {
		TestRestTemplate template = new TestRestTemplate(this.builder, username, password, this.httpClientOptions);
		template.setUriTemplateHandler(getRestTemplate().getUriTemplateHandler());
		return template;
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private RequestEntity<?> createRequestEntityWithRootAppliedUri(RequestEntity<?> requestEntity) {
		return new RequestEntity(requestEntity.getBody(), requestEntity.getHeaders(), requestEntity.getMethod(),
				applyRootUriIfNecessary(resolveUri(requestEntity)), requestEntity.getType());
	}
	private URI applyRootUriIfNecessary(URI uri) {
		UriTemplateHandler uriTemplateHandler = this.restTemplate.getUriTemplateHandler();
		if ((uriTemplateHandler instanceof RootUriTemplateHandler rootHandler) && uri.toString().startsWith('/')) {
			return URI.create(rootHandler.getRootUri() + uri);
		}
		return uri;
	}
	private URI resolveUri(RequestEntity<?> entity) {
		if (entity instanceof UriTemplateRequestEntity<?> templatedUriEntity) {
			if (templatedUriEntity.getVars() != null) {
				return this.restTemplate.getUriTemplateHandler()
					.expand(templatedUriEntity.getUriTemplate(), templatedUriEntity.getVars());
			}
			else if (templatedUriEntity.getVarsMap() != null) {
				return this.restTemplate.getUriTemplateHandler()
					.expand(templatedUriEntity.getUriTemplate(), templatedUriEntity.getVarsMap());
			}
			throw new IllegalStateException(
					'No variables specified for URI template: ' + templatedUriEntity.getUriTemplate());
		}
		return entity.getUrl();
	}
	/**
	 * Options used to customize the Apache HTTP Client.
	 */
	public enum HttpClientOption {
		/**
		 * Enable cookies.
		 */
		ENABLE_COOKIES,
		/**
		 * Enable redirects.
		 */
		ENABLE_REDIRECTS,
		/**
		 * Use a {@link TlsSocketStrategy} that trusts self-signed certificates.
		 */
		SSL
	}
	/**
	 * {@link HttpComponentsClientHttpRequestFactory} to apply customizations.
	 */
	protected static class CustomHttpComponentsClientHttpRequestFactory extends HttpComponentsClientHttpRequestFactory {
		private final String cookieSpec;
		private final boolean enableRedirects;
		/**
		 * Create a new {@link CustomHttpComponentsClientHttpRequestFactory} instance.
		 * @param httpClientOptions the {@link HttpClient} options
		 * @param settings the settings to apply
		 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
		 * {@link #CustomHttpComponentsClientHttpRequestFactory(HttpClientOption[], ClientHttpRequestFactorySettings)}
		 */
		@Deprecated(since = '3.4.0', forRemoval = true)
		@SuppressWarnings('removal')
		public CustomHttpComponentsClientHttpRequestFactory(HttpClientOption[] httpClientOptions,
				org.springframework.boot.web.client.ClientHttpRequestFactorySettings settings) {
			this(httpClientOptions, new ClientHttpRequestFactorySettings(null, settings.connectTimeout(),
					settings.readTimeout(), settings.sslBundle()));
		}
		/**
		 * Create a new {@link CustomHttpComponentsClientHttpRequestFactory} instance.
		 * @param httpClientOptions the {@link HttpClient} options
		 * @param settings the settings to apply
		 */
		public CustomHttpComponentsClientHttpRequestFactory(HttpClientOption[] httpClientOptions,
				ClientHttpRequestFactorySettings settings) {
			Set<HttpClientOption> options = new HashSet<>(Arrays.asList(httpClientOptions));
			this.cookieSpec = (options.contains(HttpClientOption.ENABLE_COOKIES) ? StandardCookieSpec.STRICT
					: StandardCookieSpec.IGNORE);
			this.enableRedirects = options.contains(HttpClientOption.ENABLE_REDIRECTS);
			boolean ssl = options.contains(HttpClientOption.SSL);
			if (settings.readTimeout() != null || ssl) {
				setHttpClient(createHttpClient(settings.readTimeout(), ssl));
			}
			if (settings.connectTimeout() != null) {
				setConnectTimeout((int) settings.connectTimeout().toMillis());
			}
		}
		private HttpClient createHttpClient(Duration readTimeout, boolean ssl) {
			try {
				HttpClientBuilder builder = HttpClients.custom();
				builder.setConnectionManager(createConnectionManager(readTimeout, ssl));
				builder.setDefaultRequestConfig(createRequestConfig());
				return builder.build();
			}
			catch (Exception ex) {
				throw new IllegalStateException('Unable to create customized HttpClient', ex);
			}
		}
		private PoolingHttpClientConnectionManager createConnectionManager(Duration readTimeout, boolean ssl)
				throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException {
			PoolingHttpClientConnectionManagerBuilder builder = PoolingHttpClientConnectionManagerBuilder.create();
			if (ssl) {
				builder.setTlsSocketStrategy(createTlsSocketStrategy());
			}
			if (readTimeout != null) {
				SocketConfig socketConfig = SocketConfig.custom()
					.setSoTimeout((int) readTimeout.toMillis(), TimeUnit.MILLISECONDS)
					.build();
				builder.setDefaultSocketConfig(socketConfig);
			}
			return builder.build();
		}
		private TlsSocketStrategy createTlsSocketStrategy()
				throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
			SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy())
				.build();
			return new DefaultClientTlsStrategy(sslContext, new String[] { TLS.V_1_3.getId(), TLS.V_1_2.getId() }, null,
					null, null);
		}
		@Override
		protected HttpContext createHttpContext(HttpMethod httpMethod, URI uri) {
			HttpClientContext context = HttpClientContext.create();
			context.setRequestConfig(createRequestConfig());
			return context;
		}
		protected RequestConfig createRequestConfig() {
			RequestConfig.Builder builder = RequestConfig.custom();
			builder.setCookieSpec(this.cookieSpec);
			builder.setAuthenticationEnabled(false);
			builder.setRedirectsEnabled(this.enableRedirects);
			return builder.build();
		}
	}
	private static final class TrustSelfSignedStrategy implements TrustStrategy {
		@Override
		public boolean isTrusted(X509Certificate[] chain, String authType) {
			return chain.length == 1;
		}
	}
}
/*
package org.springframework.boot.test.web.client;
/**
public class LocalHostUriTemplateHandler extends RootUriTemplateHandler {
	private static final String PREFIX = 'server.servlet.';
	private final Environment environment;
	private final String scheme;
	/**
	 * Create a new {@code LocalHostUriTemplateHandler} that will generate {@code http}
	 * URIs using the given {@code environment} to determine the context path and port.
	 * @param environment the environment used to determine the port
	 */
	public LocalHostUriTemplateHandler(Environment environment) {
		this(environment, 'http');
	}
	/**
	 * Create a new {@code LocalHostUriTemplateHandler} that will generate URIs with the
	 * given {@code scheme} and use the given {@code environment} to determine the
	 * context-path and port.
	 * @param environment the environment used to determine the port
	 * @param scheme the scheme of the root uri
	 * @since 1.4.1
	 */
	public LocalHostUriTemplateHandler(Environment environment, String scheme) {
		this(environment, scheme, new DefaultUriBuilderFactory());
	}
	/**
	 * Create a new {@code LocalHostUriTemplateHandler} that will generate URIs with the
	 * given {@code scheme}, use the given {@code environment} to determine the
	 * context-path and port and delegate to the given template {@code handler}.
	 * @param environment the environment used to determine the port
	 * @param scheme the scheme of the root uri
	 * @param handler the delegate handler
	 * @since 2.0.3
	 */
	public LocalHostUriTemplateHandler(Environment environment, String scheme, UriTemplateHandler handler) {
		super(handler);
		Assert.notNull(environment, 'Environment must not be null');
		Assert.notNull(scheme, 'Scheme must not be null');
		this.environment = environment;
		this.scheme = scheme;
	}
	@Override
	public String getRootUri() {
		String port = this.environment.getProperty('local.server.port', '8080');
		String contextPath = this.environment.getProperty(PREFIX + 'context-path', '');
		return this.scheme + '://localhost:' + port + contextPath;
	}
}
/*
/**
package org.springframework.boot.test.web.client;
/*
package org.springframework.boot.test.web;
/**
class SpringBootTestRandomPortEnvironmentPostProcessor implements EnvironmentPostProcessor {
	private static final String MANAGEMENT_PORT_PROPERTY = 'management.server.port';
	private static final String SERVER_PORT_PROPERTY = 'server.port';
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		MapPropertySource source = (MapPropertySource) environment.getPropertySources()
			.get(TestPropertySourceUtils.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);
		if (source == null || isTestServerPortFixed(source, environment) || isTestManagementPortConfigured(source)) {
			return;
		}
		Integer managementPort = getPropertyAsInteger(environment, MANAGEMENT_PORT_PROPERTY, null);
		if (managementPort == null || managementPort.equals(-1) || managementPort.equals(0)) {
			return;
		}
		Integer serverPort = getPropertyAsInteger(environment, SERVER_PORT_PROPERTY, 8080);
		if (!managementPort.equals(serverPort)) {
			source.getSource().put(MANAGEMENT_PORT_PROPERTY, '0');
		}
		else {
			source.getSource().put(MANAGEMENT_PORT_PROPERTY, '');
		}
	}
	private boolean isTestServerPortFixed(MapPropertySource source, ConfigurableEnvironment environment) {
		return !Integer.valueOf(0).equals(getPropertyAsInteger(source, SERVER_PORT_PROPERTY, environment));
	}
	private boolean isTestManagementPortConfigured(PropertySource<?> source) {
		return source.getProperty(MANAGEMENT_PORT_PROPERTY) != null;
	}
	private Integer getPropertyAsInteger(ConfigurableEnvironment environment, String property, Integer defaultValue) {
		return environment.getPropertySources()
			.stream()
			.filter((source) -> !source.getName()
				.equals(TestPropertySourceUtils.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME))
			.map((source) -> getPropertyAsInteger(source, property, environment))
			.filter(Objects::nonNull)
			.findFirst()
			.orElse(defaultValue);
	}
	private Integer getPropertyAsInteger(PropertySource<?> source, String property,
			ConfigurableEnvironment environment) {
		Object value = source.getProperty(property);
		if (value == null) {
			return null;
		}
		if (ClassUtils.isAssignableValue(Integer.class, value)) {
			return (Integer) value;
		}
		try {
			return environment.getConversionService().convert(value, Integer.class);
		}
		catch (ConversionFailedException ex) {
			if (value instanceof String string) {
				return getResolvedValueIfPossible(environment, string);
			}
			throw ex;
		}
	}
	private Integer getResolvedValueIfPossible(ConfigurableEnvironment environment, String value) {
		String resolvedValue = environment.resolveRequiredPlaceholders(value);
		return environment.getConversionService().convert(resolvedValue, Integer.class);
	}
}
/*
/**
package org.springframework.boot.test.web;
/*
package org.springframework.boot.test.web.reactive.server;
/**
@FunctionalInterface
public interface WebTestClientBuilderCustomizer {
	/**
	 * Customize the given {@code builder}.
	 * @param builder the builder
	 */
	void customize(Builder builder);
}
/*
package org.springframework.boot.test.web.reactive.server;
/**
class WebTestClientContextCustomizerFactory implements ContextCustomizerFactory {
	private static final boolean webClientPresent;
	static {
		ClassLoader loader = WebTestClientContextCustomizerFactory.class.getClassLoader();
		webClientPresent = ClassUtils.isPresent('org.springframework.web.reactive.function.client.WebClient', loader);
	}
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		SpringBootTest springBootTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				SpringBootTest.class);
		return (springBootTest != null && webClientPresent) ? new WebTestClientContextCustomizer() : null;
	}
}
/*
/**
package org.springframework.boot.test.web.reactive.server;
/*
package org.springframework.boot.test.web.reactive.server;
/**
class WebTestClientContextCustomizer implements ContextCustomizer {
	@Override
	public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
		if (AotDetector.useGeneratedArtifacts()) {
			return;
		}
		SpringBootTest springBootTest = TestContextAnnotationUtils.findMergedAnnotation(mergedConfig.getTestClass(),
				SpringBootTest.class);
		if (springBootTest.webEnvironment().isEmbedded()) {
			registerWebTestClient(context);
		}
	}
	private void registerWebTestClient(ConfigurableApplicationContext context) {
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		if (beanFactory instanceof BeanDefinitionRegistry registry) {
			registerWebTestClient(registry);
		}
	}
	private void registerWebTestClient(BeanDefinitionRegistry registry) {
		RootBeanDefinition definition = new RootBeanDefinition(WebTestClientRegistrar.class);
		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(WebTestClientRegistrar.class.getName(), definition);
	}
	@Override
	public boolean equals(Object obj) {
		return (obj != null) && (obj.getClass() == getClass());
	}
	@Override
	public int hashCode() {
		return getClass().hashCode();
	}
	/**
	 * {@link BeanDefinitionRegistryPostProcessor} that runs after the
	 * {@link ConfigurationClassPostProcessor} and add a {@link WebTestClientFactory} bean
	 * definition when a {@link WebTestClient} hasn"t already been registered.
	 */
	static class WebTestClientRegistrar implements BeanDefinitionRegistryPostProcessor, Ordered, BeanFactoryAware {
		private BeanFactory beanFactory;
		@Override
		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}
		@Override
		public int getOrder() {
			return Ordered.LOWEST_PRECEDENCE;
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			if (AotDetector.useGeneratedArtifacts()) {
				return;
			}
			if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors((ListableBeanFactory) this.beanFactory,
					WebTestClient.class, false, false).length == 0) {
				registry.registerBeanDefinition(WebTestClient.class.getName(),
						new RootBeanDefinition(WebTestClientFactory.class));
			}
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
	}
	/**
	 * {@link FactoryBean} used to create and configure a {@link WebTestClient}.
	 */
	public static class WebTestClientFactory implements FactoryBean<WebTestClient>, ApplicationContextAware {
		private ApplicationContext applicationContext;
		private WebTestClient object;
		private static final String SERVLET_APPLICATION_CONTEXT_CLASS = 'org.springframework.web.context.WebApplicationContext';
		private static final String REACTIVE_APPLICATION_CONTEXT_CLASS = 'org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext';
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
			this.applicationContext = applicationContext;
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
		@Override
		public Class<?> getObjectType() {
			return WebTestClient.class;
		}
		@Override
		public WebTestClient getObject() throws Exception {
			if (this.object == null) {
				this.object = createWebTestClient();
			}
			return this.object;
		}
		private WebTestClient createWebTestClient() {
			boolean sslEnabled = isSslEnabled(this.applicationContext);
			String port = this.applicationContext.getEnvironment().getProperty('local.server.port', '8080');
			String baseUrl = getBaseUrl(sslEnabled, port);
			WebTestClient.Builder builder = WebTestClient.bindToServer();
			customizeWebTestClientBuilder(builder, this.applicationContext);
			customizeWebTestClientCodecs(builder, this.applicationContext);
			return builder.baseUrl(baseUrl).build();
		}
		private String getBaseUrl(boolean sslEnabled, String port) {
			String basePath = deduceBasePath();
			String pathSegment = (StringUtils.hasText(basePath)) ? basePath : '';
			return (sslEnabled ? 'https' : 'http') + '://localhost:' + port + pathSegment;
		}
		private String deduceBasePath() {
			WebApplicationType webApplicationType = deduceFromApplicationContext(this.applicationContext.getClass());
			if (webApplicationType == WebApplicationType.REACTIVE) {
				return this.applicationContext.getEnvironment().getProperty('spring.webflux.base-path');
			}
			else if (webApplicationType == WebApplicationType.SERVLET) {
				return ((WebApplicationContext) this.applicationContext).getServletContext().getContextPath();
			}
			return null;
		}
		static WebApplicationType deduceFromApplicationContext(Class<?> applicationContextClass) {
			if (isAssignable(SERVLET_APPLICATION_CONTEXT_CLASS, applicationContextClass)) {
				return WebApplicationType.SERVLET;
			}
			if (isAssignable(REACTIVE_APPLICATION_CONTEXT_CLASS, applicationContextClass)) {
				return WebApplicationType.REACTIVE;
			}
			return WebApplicationType.NONE;
		}
		private static boolean isAssignable(String target, Class<?> type) {
			try {
				return ClassUtils.resolveClassName(target, null).isAssignableFrom(type);
			}
			catch (Throwable ex) {
				return false;
			}
		}
		private boolean isSslEnabled(ApplicationContext context) {
			try {
				AbstractReactiveWebServerFactory webServerFactory = context
					.getBean(AbstractReactiveWebServerFactory.class);
				return webServerFactory.getSsl() != null && webServerFactory.getSsl().isEnabled();
			}
			catch (NoSuchBeanDefinitionException ex) {
				return false;
			}
		}
		private void customizeWebTestClientBuilder(WebTestClient.Builder clientBuilder, ApplicationContext context) {
			for (WebTestClientBuilderCustomizer customizer : context
				.getBeansOfType(WebTestClientBuilderCustomizer.class)
				.values()) {
				customizer.customize(clientBuilder);
			}
		}
		private void customizeWebTestClientCodecs(WebTestClient.Builder clientBuilder, ApplicationContext context) {
			Collection<CodecCustomizer> codecCustomizers = context.getBeansOfType(CodecCustomizer.class).values();
			if (!CollectionUtils.isEmpty(codecCustomizers)) {
				clientBuilder.exchangeStrategies(ExchangeStrategies.builder()
					.codecs((codecs) -> codecCustomizers
						.forEach((codecCustomizer) -> codecCustomizer.customize(codecs)))
					.build());
			}
		}
	}
}
/*
package org.springframework.boot.test.system;
/**
public interface CapturedOutput extends CharSequence {
	@Override
	default int length() {
		return toString().length();
	}
	@Override
	default char charAt(int index) {
		return toString().charAt(index);
	}
	@Override
	default CharSequence subSequence(int start, int end) {
		return toString().subSequence(start, end);
	}
	/**
	 * Return all content (both {@link System#out System.out} and {@link System#err
	 * System.err}) in the order that it was captured.
	 * @return all captured output
	 */
	String getAll();
	/**
	 * Return {@link System#out System.out} content in the order that it was captured.
	 * @return {@link System#out System.out} captured output
	 */
	String getOut();
	/**
	 * Return {@link System#err System.err} content in the order that it was captured.
	 * @return {@link System#err System.err} captured output
	 */
	String getErr();
}
/*
package org.springframework.boot.test.system;
/**
public class OutputCaptureRule implements TestRule, CapturedOutput {
	private final OutputCapture delegate = new OutputCapture();
	private final List<Matcher<? super String>> matchers = new ArrayList<>();
	@Override
	public Statement apply(Statement base, Description description) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				OutputCaptureRule.this.delegate.push();
				try {
					base.evaluate();
				}
				finally {
					try {
						if (!OutputCaptureRule.this.matchers.isEmpty()) {
							String output = OutputCaptureRule.this.delegate.toString();
							MatcherAssert.assertThat(output, allOf(OutputCaptureRule.this.matchers));
						}
					}
					finally {
						OutputCaptureRule.this.delegate.pop();
					}
				}
			}
		};
	}
	@Override
	public String getAll() {
		return this.delegate.getAll();
	}
	@Override
	public String getOut() {
		return this.delegate.getOut();
	}
	@Override
	public String getErr() {
		return this.delegate.getErr();
	}
	@Override
	public String toString() {
		return this.delegate.toString();
	}
	/**
	 * Verify that the output is matched by the supplied {@code matcher}. Verification is
	 * performed after the test method has executed.
	 * @param matcher the matcher
	 */
	public void expect(Matcher<? super String> matcher) {
		this.matchers.add(matcher);
	}
}
/*
/**
package org.springframework.boot.test.system;
/*
package org.springframework.boot.test.system;
/**
class OutputCapture implements CapturedOutput {
	private final Deque<SystemCapture> systemCaptures = new ArrayDeque<>();
	private AnsiOutputState ansiOutputState;
	private final AtomicReference<String> out = new AtomicReference<>(null);
	private final AtomicReference<String> err = new AtomicReference<>(null);
	private final AtomicReference<String> all = new AtomicReference<>(null);
	/**
	 * Push a new system capture session onto the stack.
	 */
	final void push() {
		if (this.systemCaptures.isEmpty()) {
			this.ansiOutputState = AnsiOutputState.saveAndDisable();
		}
		clearExisting();
		this.systemCaptures.addLast(new SystemCapture(this::clearExisting));
	}
	/**
	 * Pop the last system capture session from the stack.
	 */
	final void pop() {
		clearExisting();
		this.systemCaptures.removeLast().release();
		if (this.systemCaptures.isEmpty() && this.ansiOutputState != null) {
			this.ansiOutputState.restore();
			this.ansiOutputState = null;
		}
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj instanceof CharSequence) {
			return getAll().equals(obj.toString());
		}
		return false;
	}
	@Override
	public int hashCode() {
		return toString().hashCode();
	}
	@Override
	public String toString() {
		return getAll();
	}
	/**
	 * Return all content (both {@link System#out System.out} and {@link System#err
	 * System.err}) in the order that it was captured.
	 * @return all captured output
	 */
	@Override
	public String getAll() {
		return get(this.all, (type) -> true);
	}
	/**
	 * Return {@link System#out System.out} content in the order that it was captured.
	 * @return {@link System#out System.out} captured output
	 */
	@Override
	public String getOut() {
		return get(this.out, Type.OUT::equals);
	}
	/**
	 * Return {@link System#err System.err} content in the order that it was captured.
	 * @return {@link System#err System.err} captured output
	 */
	@Override
	public String getErr() {
		return get(this.err, Type.ERR::equals);
	}
	/**
	 * Resets the current capture session, clearing its captured output.
	 */
	void reset() {
		clearExisting();
		this.systemCaptures.peek().reset();
	}
	void clearExisting() {
		this.out.set(null);
		this.err.set(null);
		this.all.set(null);
	}
	private String get(AtomicReference<String> existing, Predicate<Type> filter) {
		Assert.state(!this.systemCaptures.isEmpty(),
				'No system captures found. Please check your output capture registration.');
		String result = existing.get();
		if (result == null) {
			result = build(filter);
			existing.compareAndSet(null, result);
		}
		return result;
	}
	String build(Predicate<Type> filter) {
		StringBuilder builder = new StringBuilder();
		for (SystemCapture systemCapture : this.systemCaptures) {
			systemCapture.append(builder, filter);
		}
		return builder.toString();
	}
	/**
	 * A capture session that captures {@link System#out System.out} and {@link System#out
	 * System.err}.
	 */
	private static class SystemCapture {
		private final Runnable onCapture;
		private final Object monitor = new Object();
		private final PrintStreamCapture out;
		private final PrintStreamCapture err;
		private final List<CapturedString> capturedStrings = new ArrayList<>();
		SystemCapture(Runnable onCapture) {
			this.onCapture = onCapture;
			this.out = new PrintStreamCapture(System.out, this::captureOut);
			this.err = new PrintStreamCapture(System.err, this::captureErr);
			System.setOut(this.out);
			System.setErr(this.err);
		}
		void release() {
			System.setOut(this.out.getParent());
			System.setErr(this.err.getParent());
		}
		private void captureOut(String string) {
			capture(new CapturedString(Type.OUT, string));
		}
		private void captureErr(String string) {
			capture(new CapturedString(Type.ERR, string));
		}
		private void capture(CapturedString e) {
			synchronized (this.monitor) {
				this.onCapture.run();
				this.capturedStrings.add(e);
			}
		}
		void append(StringBuilder builder, Predicate<Type> filter) {
			synchronized (this.monitor) {
				for (CapturedString stringCapture : this.capturedStrings) {
					if (filter.test(stringCapture.getType())) {
						builder.append(stringCapture);
					}
				}
			}
		}
		void reset() {
			synchronized (this.monitor) {
				this.capturedStrings.clear();
			}
		}
	}
	/**
	 * A {@link PrintStream} implementation that captures written strings.
	 */
	private static class PrintStreamCapture extends PrintStream {
		private final PrintStream parent;
		PrintStreamCapture(PrintStream parent, Consumer<String> copy) {
			super(new OutputStreamCapture(getSystemStream(parent), copy));
			this.parent = parent;
		}
		PrintStream getParent() {
			return this.parent;
		}
		private static PrintStream getSystemStream(PrintStream printStream) {
			while (printStream instanceof PrintStreamCapture printStreamCapture) {
				printStream = printStreamCapture.getParent();
			}
			return printStream;
		}
	}
	/**
	 * An {@link OutputStream} implementation that captures written strings.
	 */
	private static class OutputStreamCapture extends OutputStream {
		private final PrintStream systemStream;
		private final Consumer<String> copy;
		OutputStreamCapture(PrintStream systemStream, Consumer<String> copy) {
			this.systemStream = systemStream;
			this.copy = copy;
		}
		@Override
		public void write(int b) throws IOException {
			write(new byte[] { (byte) (b & 0xFF) });
		}
		@Override
		public void write(byte[] b, int off, int len) throws IOException {
			this.copy.accept(new String(b, off, len));
			this.systemStream.write(b, off, len);
		}
		@Override
		public void flush() throws IOException {
			this.systemStream.flush();
		}
	}
	/**
	 * A captured string that forms part of the full output.
	 */
	private static class CapturedString {
		private final Type type;
		private final String string;
		CapturedString(Type type, String string) {
			this.type = type;
			this.string = string;
		}
		Type getType() {
			return this.type;
		}
		@Override
		public String toString() {
			return this.string;
		}
	}
	/**
	 * Types of content that can be captured.
	 */
	enum Type {
		OUT, ERR
	}
	/**
	 * Save, disable and restore AnsiOutput without it needing to be on the classpath.
	 */
	private static class AnsiOutputState {
		private final Enabled saved;
		AnsiOutputState() {
			this.saved = AnsiOutput.getEnabled();
			AnsiOutput.setEnabled(Enabled.NEVER);
		}
		void restore() {
			AnsiOutput.setEnabled(this.saved);
		}
		static AnsiOutputState saveAndDisable() {
			if (!ClassUtils.isPresent('org.springframework.boot.ansi.AnsiOutput',
					OutputCapture.class.getClassLoader())) {
				return null;
			}
			return new AnsiOutputState();
		}
	}
}
/*
package org.springframework.boot.test.system;
/**
public class OutputCaptureExtension
		implements BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback, ParameterResolver {
	OutputCaptureExtension() {
		// Package private to prevent users from directly creating an instance.
	}
	@Override
	public void beforeAll(ExtensionContext context) throws Exception {
		getOutputCapture(context).push();
	}
	@Override
	public void afterAll(ExtensionContext context) throws Exception {
		getOutputCapture(context).pop();
	}
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		getOutputCapture(context).push();
	}
	@Override
	public void afterEach(ExtensionContext context) throws Exception {
		getOutputCapture(context).pop();
	}
	@Override
	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
			throws ParameterResolutionException {
		return CapturedOutput.class.equals(parameterContext.getParameter().getType());
	}
	@Override
	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
		return getOutputCapture(extensionContext);
	}
	private OutputCapture getOutputCapture(ExtensionContext context) {
		return getStore(context).getOrComputeIfAbsent(OutputCapture.class, (key) -> new OutputCapture(),
				OutputCapture.class);
	}
	private Store getStore(ExtensionContext context) {
		return context.getStore(Namespace.create(getClass()));
	}
}
/*
package org.springframework.boot.test.util;
/**
public final class TestPropertyValues {
	private static final TestPropertyValues EMPTY = new TestPropertyValues(Collections.emptyMap());
	private final Map<String, Object> properties;
	private TestPropertyValues(Map<String, Object> properties) {
		this.properties = Collections.unmodifiableMap(properties);
	}
	/**
	 * Return a new {@link TestPropertyValues} instance with additional entries.
	 * Name-value pairs can be specified with colon (':') or equals ('=') separators.
	 * @param pairs the property pairs to add
	 * @return a new {@link TestPropertyValues} instance
	 */
	public TestPropertyValues and(String... pairs) {
		return and(Arrays.stream(pairs), Pair::parse);
	}
	/**
	 * Return a new {@link TestPropertyValues} instance with additional entries.
	 * Name-value pairs can be specified with colon (':') or equals ('=') separators.
	 * @param pairs the property pairs to add
	 * @return a new {@link TestPropertyValues} instance
	 * @since 2.4.0
	 */
	public TestPropertyValues and(Iterable<String> pairs) {
		return (pairs != null) ? and(StreamSupport.stream(pairs.spliterator(), false)) : this;
	}
	/**
	 * Return a new {@link TestPropertyValues} instance with additional entries.
	 * Name-value pairs can be specified with colon (':') or equals ('=') separators.
	 * @param pairs the property pairs to add
	 * @return a new {@link TestPropertyValues} instance
	 * @since 2.4.0
	 */
	public TestPropertyValues and(Stream<String> pairs) {
		return (pairs != null) ? and(pairs, Pair::parse) : this;
	}
	/**
	 * Return a new {@link TestPropertyValues} instance with additional entries.
	 * @param map the map of properties that need to be added to the environment
	 * @return a new {@link TestPropertyValues} instance
	 * @since 2.4.0
	 */
	public TestPropertyValues and(Map<String, String> map) {
		return (map != null) ? and(map.entrySet().stream(), Pair::fromMapEntry) : this;
	}
	/**
	 * Return a new {@link TestPropertyValues} instance with additional entries.
	 * @param <T> the stream element type
	 * @param stream the elements that need to be added to the environment
	 * @param mapper a mapper function to convert an element from the stream into a
	 * {@link Pair}
	 * @return a new {@link TestPropertyValues} instance
	 * @since 2.4.0
	 */
	public <T> TestPropertyValues and(Stream<T> stream, Function<T, Pair> mapper) {
		if (stream == null) {
			return this;
		}
		Map<String, Object> properties = new LinkedHashMap<>(this.properties);
		stream.map(mapper).filter(Objects::nonNull).forEach((pair) -> pair.addTo(properties));
		return new TestPropertyValues(properties);
	}
	/**
	 * Add the properties from the underlying map to the environment owned by an
	 * {@link ApplicationContext}.
	 * @param context the context with an environment to modify
	 */
	public void applyTo(ConfigurableApplicationContext context) {
		applyTo(context.getEnvironment());
	}
	/**
	 * Add the properties from the underlying map to the environment. The default property
	 * source used is {@link MapPropertySource}.
	 * @param environment the environment that needs to be modified
	 */
	public void applyTo(ConfigurableEnvironment environment) {
		applyTo(environment, Type.MAP);
	}
	/**
	 * Add the properties from the underlying map to the environment using the specified
	 * property source type.
	 * @param environment the environment that needs to be modified
	 * @param type the type of {@link PropertySource} to be added. See {@link Type}
	 */
	public void applyTo(ConfigurableEnvironment environment, Type type) {
		applyTo(environment, type, type.applySuffix('test'));
	}
	/**
	 * Add the properties from the underlying map to the environment using the specified
	 * property source type and name.
	 * @param environment the environment that needs to be modified
	 * @param type the type of {@link PropertySource} to be added. See {@link Type}
	 * @param name the name for the property source
	 */
	public void applyTo(ConfigurableEnvironment environment, Type type, String name) {
		Assert.notNull(environment, 'Environment must not be null');
		Assert.notNull(type, 'Property source type must not be null');
		Assert.notNull(name, 'Property source name must not be null');
		MutablePropertySources sources = environment.getPropertySources();
		addToSources(sources, type, name);
		ConfigurationPropertySources.attach(environment);
	}
	/**
	 * Add the properties to the {@link System#getProperties() system properties} for the
	 * duration of the {@code action}, restoring previous values when it completes.
	 * @param action the action to take
	 * @since 3.0.0
	 */
	public void applyToSystemProperties(Runnable action) {
		applyToSystemProperties(() -> {
			action.run();
			return null;
		});
	}
	/**
	 * Add the properties to the {@link System#getProperties() system properties} for the
	 * duration of the {@code call}, restoring previous values when it completes.
	 * @param <T> the result type
	 * @param call the call to make
	 * @return the result of the call
	 */
	public <T> T applyToSystemProperties(Callable<T> call) {
		try (SystemPropertiesHandler handler = new SystemPropertiesHandler()) {
			return call.call();
		}
		catch (Exception ex) {
			rethrow(ex);
			throw new IllegalStateException('Original cause not rethrown', ex);
		}
	}
	@SuppressWarnings('unchecked')
	private <E extends Throwable> void rethrow(Throwable e) throws E {
		throw (E) e;
	}
	@SuppressWarnings('unchecked')
	private void addToSources(MutablePropertySources sources, Type type, String name) {
		if (sources.contains(name)) {
			PropertySource<?> propertySource = sources.get(name);
			if (propertySource.getClass() == type.getSourceClass()) {
				((Map<String, Object>) propertySource.getSource()).putAll(this.properties);
				return;
			}
		}
		Map<String, Object> source = new LinkedHashMap<>(this.properties);
		sources.addFirst((type.equals(Type.MAP) ? new MapPropertySource(name, source)
				: new SystemEnvironmentPropertySource(name, source)));
	}
	/**
	 * Return a new {@link TestPropertyValues} with the underlying map populated with the
	 * given property pairs. Name-value pairs can be specified with colon (':') or equals
	 * ('=') separators.
	 * @param pairs the name-value pairs for properties that need to be added to the
	 * environment
	 * @return the new instance
	 */
	public static TestPropertyValues of(String... pairs) {
		return of(Stream.of(pairs));
	}
	/**
	 * Return a new {@link TestPropertyValues} with the underlying map populated with the
	 * given property pairs. Name-value pairs can be specified with colon (':') or equals
	 * ('=') separators.
	 * @param pairs the name-value pairs for properties that need to be added to the
	 * environment
	 * @return the new instance
	 */
	public static TestPropertyValues of(Iterable<String> pairs) {
		return (pairs != null) ? of(StreamSupport.stream(pairs.spliterator(), false)) : empty();
	}
	/**
	 * Return a new {@link TestPropertyValues} with the underlying map populated with the
	 * given property pairs. Name-value pairs can be specified with colon (':') or equals
	 * ('=') separators.
	 * @param pairs the name-value pairs for properties that need to be added to the
	 * environment
	 * @return the new instance
	 */
	public static TestPropertyValues of(Stream<String> pairs) {
		return (pairs != null) ? of(pairs, Pair::parse) : empty();
	}
	/**
	 * Return a new {@link TestPropertyValues} with the underlying map populated with the
	 * given map entries.
	 * @param map the map of properties that need to be added to the environment
	 * @return the new instance
	 */
	public static TestPropertyValues of(Map<String, String> map) {
		return (map != null) ? of(map.entrySet().stream(), Pair::fromMapEntry) : empty();
	}
	/**
	 * Return a new {@link TestPropertyValues} with the underlying map populated with the
	 * given stream.
	 * @param <T> the stream element type
	 * @param stream the elements that need to be added to the environment
	 * @param mapper a mapper function to convert an element from the stream into a
	 * {@link Pair}
	 * @return the new instance
	 */
	public static <T> TestPropertyValues of(Stream<T> stream, Function<T, Pair> mapper) {
		return (stream != null) ? empty().and(stream, mapper) : empty();
	}
	/**
	 * Return an empty {@link TestPropertyValues} instance.
	 * @return an empty instance
	 */
	public static TestPropertyValues empty() {
		return EMPTY;
	}
	/**
	 * The type of property source.
	 */
	public enum Type {
		/**
		 * Used for {@link SystemEnvironmentPropertySource}.
		 */
		SYSTEM_ENVIRONMENT(SystemEnvironmentPropertySource.class,
				StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME),
		/**
		 * Used for {@link MapPropertySource}.
		 */
		MAP(MapPropertySource.class, null);
		private final Class<? extends MapPropertySource> sourceClass;
		private final String suffix;
		Type(Class<? extends MapPropertySource> sourceClass, String suffix) {
			this.sourceClass = sourceClass;
			this.suffix = suffix;
		}
		public Class<? extends MapPropertySource> getSourceClass() {
			return this.sourceClass;
		}
		protected String applySuffix(String name) {
			return (this.suffix != null) ? name + '-' + this.suffix : name;
		}
	}
	/**
	 * A single name value pair.
	 */
	public static final class Pair {
		private final String name;
		private final String value;
		private Pair(String name, String value) {
			Assert.hasLength(name, 'Name must not be empty');
			this.name = name;
			this.value = value;
		}
		public void addTo(Map<String, Object> properties) {
			properties.put(this.name, this.value);
		}
		public static Pair parse(String pair) {
			int index = getSeparatorIndex(pair);
			String name = (index > 0) ? pair.substring(0, index) : pair;
			String value = (index > 0) ? pair.substring(index + 1) : '';
			return of(name.trim(), value.trim());
		}
		private static int getSeparatorIndex(String pair) {
			int colonIndex = pair.indexOf(":");
			int equalIndex = pair.indexOf("=");
			if (colonIndex == -1) {
				return equalIndex;
			}
			if (equalIndex == -1) {
				return colonIndex;
			}
			return Math.min(colonIndex, equalIndex);
		}
		/**
		 * Factory method to create a {@link Pair} from a {@code Map.Entry}.
		 * @param entry the map entry
		 * @return the {@link Pair} instance or {@code null}
		 * @since 2.4.0
		 */
		public static Pair fromMapEntry(Map.Entry<String, String> entry) {
			return (entry != null) ? of(entry.getKey(), entry.getValue()) : null;
		}
		/**
		 * Factory method to create a {@link Pair} from a name and value.
		 * @param name the name
		 * @param value the value
		 * @return the {@link Pair} instance or {@code null}
		 * @since 2.4.0
		 */
		public static Pair of(String name, String value) {
			if (StringUtils.hasLength(name) || StringUtils.hasLength(value)) {
				return new Pair(name, value);
			}
			return null;
		}
	}
	/**
	 * Handler to apply and restore system properties.
	 */
	private class SystemPropertiesHandler implements Closeable {
		private final Map<String, String> previous;
		SystemPropertiesHandler() {
			this.previous = apply(TestPropertyValues.this.properties);
		}
		private Map<String, String> apply(Map<String, ?> properties) {
			Map<String, String> previous = new LinkedHashMap<>();
			properties.forEach((name, value) -> previous.put(name, setOrClear(name, (String) value)));
			return previous;
		}
		@Override
		public void close() {
			this.previous.forEach(this::setOrClear);
		}
		private String setOrClear(String name, String value) {
			Assert.notNull(name, 'Name must not be null');
			if (!StringUtils.hasLength(value)) {
				return (String) System.getProperties().remove(name);
			}
			return (String) System.getProperties().setProperty(name, value);
		}
	}
}
/*
package org.springframework.boot.test.util;
/**
public abstract class ApplicationContextTestUtils {
	/**
	 * Closes this {@link ApplicationContext} and its parent hierarchy if any.
	 * @param context the context to close (can be {@code null})
	 */
	public static void closeAll(ApplicationContext context) {
		if (context != null) {
			if (context instanceof ConfigurableApplicationContext configurableContext) {
				configurableContext.close();
			}
			closeAll(context.getParent());
		}
	}
}
/*
/**
package org.springframework.boot.test.util;
/*
package org.springframework.boot.test.json;
/**
public final class ObjectContent<T> implements AssertProvider<ObjectContentAssert<T>> {
	private final ResolvableType type;
	private final T object;
	/**
	 * Create a new {@link ObjectContent} instance.
	 * @param type the type under test (or {@code null} if not known)
	 * @param object the actual object content
	 */
	public ObjectContent(ResolvableType type, T object) {
		Assert.notNull(object, 'Object must not be null');
		this.type = type;
		this.object = object;
	}
	@Override
	public ObjectContentAssert<T> assertThat() {
		return new ObjectContentAssert<>(this.object);
	}
	/**
	 * Return the actual object content.
	 * @return the object content
	 */
	public T getObject() {
		return this.object;
	}
	@Override
	public String toString() {
		String createdFrom = (this.type != null) ? ' created from ' + this.type : '';
		return 'ObjectContent ' + this.object + createdFrom;
	}
}
/*
package org.springframework.boot.test.json;
/**
public class GsonTester<T> extends AbstractJsonMarshalTester<T> {
	private final Gson gson;
	/**
	 * Create a new uninitialized {@link GsonTester} instance.
	 * @param gson the Gson instance
	 */
	protected GsonTester(Gson gson) {
		Assert.notNull(gson, 'Gson must not be null');
		this.gson = gson;
	}
	/**
	 * Create a new {@link GsonTester} instance.
	 * @param resourceLoadClass the source class used to load resources
	 * @param type the type under test
	 * @param gson the Gson instance
	 * @see #initFields(Object, Gson)
	 */
	public GsonTester(Class<?> resourceLoadClass, ResolvableType type, Gson gson) {
		super(resourceLoadClass, type);
		Assert.notNull(gson, 'Gson must not be null');
		this.gson = gson;
	}
	@Override
	protected String writeObject(T value, ResolvableType type) throws IOException {
		return this.gson.toJson(value, type.getType());
	}
	@Override
	protected T readObject(Reader reader, ResolvableType type) throws IOException {
		return this.gson.fromJson(reader, type.getType());
	}
	/**
	 * Utility method to initialize {@link GsonTester} fields. See {@link GsonTester
	 * class-level documentation} for example usage.
	 * @param testInstance the test instance
	 * @param gson the Gson instance
	 */
	public static void initFields(Object testInstance, Gson gson) {
		new GsonFieldInitializer().initFields(testInstance, gson);
	}
	/**
	 * Utility method to initialize {@link GsonTester} fields. See {@link GsonTester
	 * class-level documentation} for example usage.
	 * @param testInstance the test instance
	 * @param gson an object factory to create the Gson instance
	 */
	public static void initFields(Object testInstance, ObjectFactory<Gson> gson) {
		new GsonFieldInitializer().initFields(testInstance, gson);
	}
	/**
	 * {@link FieldInitializer} for Gson.
	 */
	private static class GsonFieldInitializer extends FieldInitializer<Gson> {
		protected GsonFieldInitializer() {
			super(GsonTester.class);
		}
		@Override
		protected AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type,
				Gson marshaller) {
			return new GsonTester<>(resourceLoadClass, type, marshaller);
		}
	}
}
/*
package org.springframework.boot.test.json;
/**
class JsonLoader {
	private final Class<?> resourceLoadClass;
	private final Charset charset;
	JsonLoader(Class<?> resourceLoadClass, Charset charset) {
		this.resourceLoadClass = resourceLoadClass;
		this.charset = (charset != null) ? charset : StandardCharsets.UTF_8;
	}
	Class<?> getResourceLoadClass() {
		return this.resourceLoadClass;
	}
	String getJson(CharSequence source) {
		if (source == null) {
			return null;
		}
		if (source.toString().endsWith('.json')) {
			return getJson(new ClassPathResource(source.toString(), this.resourceLoadClass));
		}
		return source.toString();
	}
	String getJson(String path, Class<?> resourceLoadClass) {
		return getJson(new ClassPathResource(path, resourceLoadClass));
	}
	String getJson(byte[] source) {
		return getJson(new ByteArrayInputStream(source));
	}
	String getJson(File source) {
		try {
			return getJson(new FileInputStream(source));
		}
		catch (IOException ex) {
			throw new IllegalStateException('Unable to load JSON from ' + source, ex);
		}
	}
	String getJson(Resource source) {
		try {
			return getJson(source.getInputStream());
		}
		catch (IOException ex) {
			throw new IllegalStateException('Unable to load JSON from ' + source, ex);
		}
	}
	String getJson(InputStream source) {
		try {
			return FileCopyUtils.copyToString(new InputStreamReader(source, this.charset));
		}
		catch (IOException ex) {
			throw new IllegalStateException('Unable to load JSON from InputStream', ex);
		}
	}
}
/*
package org.springframework.boot.test.json;
/**
public class JsonContentAssert extends AbstractAssert<JsonContentAssert, CharSequence> {
	private final JsonLoader loader;
	private final Configuration configuration;
	/**
	 * Create a new {@link JsonContentAssert} instance that will load resources as UTF-8.
	 * @param resourceLoadClass the source class used to load resources
	 * @param json the actual JSON content
	 */
	public JsonContentAssert(Class<?> resourceLoadClass, CharSequence json) {
		this(resourceLoadClass, null, json);
	}
	/**
	 * Create a new {@link JsonContentAssert} instance that will load resources in the
	 * given {@code charset}.
	 * @param resourceLoadClass the source class used to load resources
	 * @param charset the charset of the JSON resources
	 * @param json the actual JSON content
	 * @since 1.4.1
	 */
	public JsonContentAssert(Class<?> resourceLoadClass, Charset charset, CharSequence json) {
		this(resourceLoadClass, charset, json, Configuration.defaultConfiguration());
	}
	/**
	 * Create a new {@link JsonContentAssert} instance that will load resources in the
	 * given {@code charset}.
	 * @param resourceLoadClass the source class used to load resources
	 * @param charset the charset of the JSON resources
	 * @param json the actual JSON content
	 * @param configuration the json-path configuration
	 */
	JsonContentAssert(Class<?> resourceLoadClass, Charset charset, CharSequence json, Configuration configuration) {
		super(json, JsonContentAssert.class);
		this.configuration = configuration;
		this.loader = new JsonLoader(resourceLoadClass, charset);
	}
	/**
	 * Overridden version of {@code isEqualTo} to perform JSON tests based on the object
	 * type.
	 * @see org.assertj.core.api.AbstractAssert#isEqualTo(java.lang.Object)
	 */
	@Override
	public JsonContentAssert isEqualTo(Object expected) {
		if (expected == null || expected instanceof CharSequence) {
			return isEqualToJson((CharSequence) expected);
		}
		if (expected instanceof byte[] bytes) {
			return isEqualToJson(bytes);
		}
		if (expected instanceof File file) {
			return isEqualToJson(file);
		}
		if (expected instanceof InputStream inputStream) {
			return isEqualToJson(inputStream);
		}
		if (expected instanceof Resource resource) {
			return isEqualToJson(resource);
		}
		failWithMessage('Unsupported type for JSON assert %s', expected.getClass());
		return null;
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#LENIENT leniently} equal
	 * to the specified JSON. The {@code expected} value can contain the JSON itself or,
	 * if it ends with {@code .json}, the name of a resource to be loaded using
	 * {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(CharSequence expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#LENIENT leniently} equal
	 * to the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(String path, Class<?> resourceLoadClass) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#LENIENT leniently} equal
	 * to the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(byte[] expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#LENIENT leniently} equal
	 * to the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(File expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#LENIENT leniently} equal
	 * to the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(InputStream expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#LENIENT leniently} equal
	 * to the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(Resource expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#STRICT strictly} equal to
	 * the specified JSON. The {@code expected} value can contain the JSON itself or, if
	 * it ends with {@code .json}, the name of a resource to be loaded using
	 * {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isStrictlyEqualToJson(CharSequence expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#STRICT strictly} equal to
	 * the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isStrictlyEqualToJson(String path, Class<?> resourceLoadClass) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#STRICT strictly} equal to
	 * the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isStrictlyEqualToJson(byte[] expected) {
		return assertNotFailed(compare(this.loader.getJson(expected), JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#STRICT strictly} equal to
	 * the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isStrictlyEqualToJson(File expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#STRICT strictly} equal to
	 * the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isStrictlyEqualToJson(InputStream expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is {@link JSONCompareMode#STRICT strictly} equal to
	 * the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isStrictlyEqualToJson(Resource expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON. The {@code expected}
	 * value can contain the JSON itself or, if it ends with {@code .json}, the name of a
	 * resource to be loaded using {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(CharSequence expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(String path, Class<?> resourceLoadClass, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotFailed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(byte[] expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(File expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(InputStream expected, JSONCompareMode compareMode) {
		return assertNotFailed(compare(this.loader.getJson(expected), compareMode));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(Resource expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON. The {@code expected}
	 * value can contain the JSON itself or, if it ends with {@code .json}, the name of a
	 * resource to be loaded using {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(CharSequence expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(String path, Class<?> resourceLoadClass, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotFailed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(byte[] expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(File expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(InputStream expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is equal to the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is not equal to the given one
	 */
	public JsonContentAssert isEqualToJson(Resource expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotFailed(compare(expectedJson, comparator));
	}
	/**
	 * Overridden version of {@code isNotEqualTo} to perform JSON tests based on the
	 * object type.
	 * @see org.assertj.core.api.AbstractAssert#isEqualTo(java.lang.Object)
	 */
	@Override
	public JsonContentAssert isNotEqualTo(Object expected) {
		if (expected == null || expected instanceof CharSequence) {
			return isNotEqualToJson((CharSequence) expected);
		}
		if (expected instanceof byte[] bytes) {
			return isNotEqualToJson(bytes);
		}
		if (expected instanceof File file) {
			return isNotEqualToJson(file);
		}
		if (expected instanceof InputStream inputStream) {
			return isNotEqualToJson(inputStream);
		}
		if (expected instanceof Resource resource) {
			return isNotEqualToJson(resource);
		}
		failWithMessage('Unsupported type for JSON assert %s', expected.getClass());
		return null;
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#LENIENT leniently}
	 * equal to the specified JSON. The {@code expected} value can contain the JSON itself
	 * or, if it ends with {@code .json}, the name of a resource to be loaded using
	 * {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(CharSequence expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#LENIENT leniently}
	 * equal to the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(String path, Class<?> resourceLoadClass) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#LENIENT leniently}
	 * equal to the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(byte[] expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#LENIENT leniently}
	 * equal to the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(File expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#LENIENT leniently}
	 * equal to the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(InputStream expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#LENIENT leniently}
	 * equal to the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(Resource expected) {
		return assertNotPassed(compare(this.loader.getJson(expected), JSONCompareMode.LENIENT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#STRICT strictly} equal
	 * to the specified JSON. The {@code expected} value can contain the JSON itself or,
	 * if it ends with {@code .json}, the name of a resource to be loaded using
	 * {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotStrictlyEqualToJson(CharSequence expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#STRICT strictly} equal
	 * to the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotStrictlyEqualToJson(String path, Class<?> resourceLoadClass) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#STRICT strictly} equal
	 * to the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotStrictlyEqualToJson(byte[] expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#STRICT strictly} equal
	 * to the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotStrictlyEqualToJson(File expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#STRICT strictly} equal
	 * to the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotStrictlyEqualToJson(InputStream expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is not {@link JSONCompareMode#STRICT strictly} equal
	 * to the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotStrictlyEqualToJson(Resource expected) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, JSONCompareMode.STRICT));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON. The
	 * {@code expected} value can contain the JSON itself or, if it ends with
	 * {@code .json}, the name of a resource to be loaded using {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(CharSequence expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(String path, Class<?> resourceLoadClass, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotPassed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(byte[] expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(File expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(InputStream expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @param compareMode the compare mode used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(Resource expected, JSONCompareMode compareMode) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, compareMode));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON. The
	 * {@code expected} value can contain the JSON itself or, if it ends with
	 * {@code .json}, the name of a resource to be loaded using {@code resourceLoadClass}.
	 * @param expected the expected JSON or the name of a resource containing the expected
	 * JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(CharSequence expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON resource.
	 * @param path the name of a resource containing the expected JSON
	 * @param resourceLoadClass the source class used to load the resource
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(String path, Class<?> resourceLoadClass, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(path, resourceLoadClass);
		return assertNotPassed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON bytes.
	 * @param expected the expected JSON bytes
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(byte[] expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON file.
	 * @param expected a file containing the expected JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(File expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON input stream.
	 * @param expected an input stream containing the expected JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(InputStream expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, comparator));
	}
	/**
	 * Verifies that the actual value is not equal to the specified JSON resource.
	 * @param expected a resource containing the expected JSON
	 * @param comparator the comparator used when checking
	 * @return {@code this} assertion object
	 * @throws AssertionError if the actual JSON value is equal to the given one
	 */
	public JsonContentAssert isNotEqualToJson(Resource expected, JSONComparator comparator) {
		String expectedJson = this.loader.getJson(expected);
		return assertNotPassed(compare(expectedJson, comparator));
	}
	/**
	 * Verify that the JSON path is present without checking if it has a value.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is missing
	 * @since 2.2.0
	 * @see #hasJsonPathValue(CharSequence, Object...)
	 */
	public JsonContentAssert hasJsonPath(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasPath();
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces a non-null result. If
	 * the JSON path expression is not {@linkplain JsonPath#isDefinite() definite}, this
	 * method verifies that the value at the given path is not <em>empty</em>.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is missing
	 */
	public JsonContentAssert hasJsonPathValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasValue(Object.class, 'an object');
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces a non-null string
	 * result.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is missing or not a string
	 */
	public JsonContentAssert hasJsonPathStringValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasValue(String.class, 'a string');
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces a non-null number
	 * result.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is missing or not a number
	 */
	public JsonContentAssert hasJsonPathNumberValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasValue(Number.class, 'a number');
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces a non-null boolean
	 * result.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is missing or not a boolean
	 */
	public JsonContentAssert hasJsonPathBooleanValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasValue(Boolean.class, 'a boolean');
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces a non-null array
	 * result.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is missing or not an array
	 */
	public JsonContentAssert hasJsonPathArrayValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasValue(List.class, 'an array');
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces a non-null map result.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is missing or not a map
	 */
	public JsonContentAssert hasJsonPathMapValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasValue(Map.class, 'a map');
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces an
	 * {@link ObjectUtils#isEmpty(Object) empty} result.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is not empty
	 */
	public JsonContentAssert hasEmptyJsonPathValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertHasEmptyValue();
		return this;
	}
	/**
	 * Verify that the JSON path is not present, even if it has a {@code null} value.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is not missing
	 * @since 2.2.0
	 * @see #doesNotHaveJsonPathValue(CharSequence, Object...)
	 */
	public JsonContentAssert doesNotHaveJsonPath(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertDoesNotHavePath();
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path produces no result. If the JSON
	 * path expression is not {@linkplain JsonPath#isDefinite() definite}, this method
	 * verifies that the value at the given path is <em>empty</em>.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is not missing
	 */
	public JsonContentAssert doesNotHaveJsonPathValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertDoesNotHaveValue();
		return this;
	}
	/**
	 * Verify that the actual value at the given JSON path does not produce an
	 * {@link ObjectUtils#isEmpty(Object) empty} result.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return {@code this} assertion object
	 * @throws AssertionError if the value at the given path is empty
	 */
	public JsonContentAssert doesNotHaveEmptyJsonPathValue(CharSequence expression, Object... args) {
		new JsonPathValue(expression, args).assertDoesNotHaveEmptyValue();
		return this;
	}
	/**
	 * Extract the value at the given JSON path for further object assertions.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return a new assertion object whose object under test is the extracted item
	 * @throws AssertionError if the path is not valid
	 */
	public AbstractObjectAssert<?, Object> extractingJsonPathValue(CharSequence expression, Object... args) {
		return Assertions.assertThat(new JsonPathValue(expression, args).getValue(false));
	}
	/**
	 * Extract the string value at the given JSON path for further object assertions.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return a new assertion object whose object under test is the extracted item
	 * @throws AssertionError if the path is not valid or does not result in a string
	 */
	public AbstractCharSequenceAssert<?, String> extractingJsonPathStringValue(CharSequence expression,
			Object... args) {
		return Assertions.assertThat(extractingJsonPathValue(expression, args, String.class, 'a string'));
	}
	/**
	 * Extract the number value at the given JSON path for further object assertions.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return a new assertion object whose object under test is the extracted item
	 * @throws AssertionError if the path is not valid or does not result in a number
	 */
	public AbstractObjectAssert<?, Number> extractingJsonPathNumberValue(CharSequence expression, Object... args) {
		return Assertions.assertThat(extractingJsonPathValue(expression, args, Number.class, 'a number'));
	}
	/**
	 * Extract the boolean value at the given JSON path for further object assertions.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @return a new assertion object whose object under test is the extracted item
	 * @throws AssertionError if the path is not valid or does not result in a boolean
	 */
	public AbstractBooleanAssert<?> extractingJsonPathBooleanValue(CharSequence expression, Object... args) {
		return Assertions.assertThat(extractingJsonPathValue(expression, args, Boolean.class, 'a boolean'));
	}
	/**
	 * Extract the array value at the given JSON path for further object assertions.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @param <E> element type
	 * @return a new assertion object whose object under test is the extracted item
	 * @throws AssertionError if the path is not valid or does not result in an array
	 */
	@SuppressWarnings('unchecked')
	public <E> ListAssert<E> extractingJsonPathArrayValue(CharSequence expression, Object... args) {
		return Assertions.assertThat(extractingJsonPathValue(expression, args, List.class, 'an array'));
	}
	/**
	 * Extract the map value at the given JSON path for further object assertions.
	 * @param expression the {@link JsonPath} expression
	 * @param args arguments to parameterize the {@code JsonPath} expression with, using
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @param <K> key type
	 * @param <V> value type
	 * @return a new assertion object whose object under test is the extracted item
	 * @throws AssertionError if the path is not valid or does not result in a map
	 */
	@SuppressWarnings('unchecked')
	public <K, V> MapAssert<K, V> extractingJsonPathMapValue(CharSequence expression, Object... args) {
		return Assertions.assertThat(extractingJsonPathValue(expression, args, Map.class, 'a map'));
	}
	@SuppressWarnings('unchecked')
	private <T> T extractingJsonPathValue(CharSequence expression, Object[] args, Class<T> type,
			String expectedDescription) {
		JsonPathValue value = new JsonPathValue(expression, args);
		if (value.getValue(false) != null) {
			value.assertHasValue(type, expectedDescription);
		}
		return (T) value.getValue(false);
	}
	private JSONCompareResult compare(CharSequence expectedJson, JSONCompareMode compareMode) {
		if (this.actual == null) {
			return compareForNull(expectedJson);
		}
		try {
			return JSONCompare.compareJSON((expectedJson != null) ? expectedJson.toString() : null,
					this.actual.toString(), compareMode);
		}
		catch (Exception ex) {
			if (ex instanceof RuntimeException runtimeException) {
				throw runtimeException;
			}
			throw new IllegalStateException(ex);
		}
	}
	private JSONCompareResult compare(CharSequence expectedJson, JSONComparator comparator) {
		if (this.actual == null) {
			return compareForNull(expectedJson);
		}
		try {
			return JSONCompare.compareJSON((expectedJson != null) ? expectedJson.toString() : null,
					this.actual.toString(), comparator);
		}
		catch (Exception ex) {
			if (ex instanceof RuntimeException runtimeException) {
				throw runtimeException;
			}
			throw new IllegalStateException(ex);
		}
	}
	private JSONCompareResult compareForNull(CharSequence expectedJson) {
		JSONCompareResult result = new JSONCompareResult();
		result.passed();
		if (expectedJson != null) {
			result.fail('Expected null JSON');
		}
		return result;
	}
	private JsonContentAssert assertNotFailed(JSONCompareResult result) {
		if (result.failed()) {
			failWithMessage('JSON Comparison failure: %s', result.getMessage());
		}
		return this;
	}
	private JsonContentAssert assertNotPassed(JSONCompareResult result) {
		if (result.passed()) {
			failWithMessage('JSON Comparison failure: %s', result.getMessage());
		}
		return this;
	}
	/**
	 * A {@link JsonPath} value.
	 */
	private class JsonPathValue {
		private final String expression;
		private final JsonPath jsonPath;
		JsonPathValue(CharSequence expression, Object... args) {
			org.springframework.util.Assert.hasText((expression != null) ? expression.toString() : null,
					'expression must not be null or empty');
			this.expression = String.format(expression.toString(), args);
			this.jsonPath = JsonPath.compile(this.expression);
		}
		void assertHasEmptyValue() {
			if (ObjectUtils.isEmpty(getValue(false)) || isIndefiniteAndEmpty()) {
				return;
			}
			failWithMessage(getExpectedValueMessage('an empty value'));
		}
		void assertDoesNotHaveEmptyValue() {
			if (!ObjectUtils.isEmpty(getValue(false))) {
				return;
			}
			failWithMessage(getExpectedValueMessage('a non-empty value'));
		}
		void assertHasPath() {
			try {
				read();
			}
			catch (PathNotFoundException ex) {
				failWithMessage('No JSON path \'%s\' found', this.expression);
			}
		}
		void assertDoesNotHavePath() {
			try {
				read();
				failWithMessage('Expecting no JSON path \'%s\'', this.expression);
			}
			catch (PathNotFoundException ex) {
				// Ignore
			}
		}
		void assertHasValue(Class<?> type, String expectedDescription) {
			Object value = getValue(true);
			if (value == null || isIndefiniteAndEmpty()) {
				failWithNoValueMessage();
			}
			if (type != null && !type.isInstance(value)) {
				failWithMessage(getExpectedValueMessage(expectedDescription));
			}
		}
		void assertDoesNotHaveValue() {
			if (getValue(false) == null || isIndefiniteAndEmpty()) {
				return;
			}
			failWithMessage(getExpectedValueMessage('no value'));
		}
		private boolean isIndefiniteAndEmpty() {
			return !isDefinite() && isEmpty();
		}
		private boolean isDefinite() {
			return this.jsonPath.isDefinite();
		}
		private boolean isEmpty() {
			return ObjectUtils.isEmpty(getValue(false));
		}
		Object getValue(boolean required) {
			try {
				return read();
			}
			catch (Exception ex) {
				if (required) {
					failWithNoValueMessage();
				}
				return null;
			}
		}
		private void failWithNoValueMessage() {
			failWithMessage('No value at JSON path \'%s\'', this.expression);
		}
		private Object read() {
			CharSequence json = JsonContentAssert.this.actual;
			return this.jsonPath.read((json != null) ? json.toString() : null, JsonContentAssert.this.configuration);
		}
		private String getExpectedValueMessage(String expectedDescription) {
			return String.format('Expected %s at JSON path \'%s\' but found: %s', expectedDescription, this.expression,
					ObjectUtils.nullSafeToString(StringUtils.quoteIfString(getValue(false))));
		}
	}
}
/*
package org.springframework.boot.test.json;
/**
public class ObjectContentAssert<A> extends AbstractObjectAssert<ObjectContentAssert<A>, A> {
	protected ObjectContentAssert(A actual) {
		super(actual, ObjectContentAssert.class);
	}
	/**
	 * Verifies that the actual value is an array, and returns an array assertion, to
	 * allow chaining of array-specific assertions from this call.
	 * @return an array assertion object
	 */
	public AbstractObjectArrayAssert<?, Object> asArray() {
		Objects.instance().assertIsInstanceOf(this.info, this.actual, Object[].class);
		return Assertions.assertThat((Object[]) this.actual);
	}
	/**
	 * Verifies that the actual value is a map, and returns a map assertion, to allow
	 * chaining of map-specific assertions from this call.
	 * @return a map assertion object
	 */
	@SuppressWarnings('unchecked')
	public AbstractMapAssert<?, ?, Object, Object> asMap() {
		Objects.instance().assertIsInstanceOf(this.info, this.actual, Map.class);
		return Assertions.assertThat((Map<Object, Object>) this.actual);
	}
}
/*
package org.springframework.boot.test.json;
/**
class DuplicateJsonObjectContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		return new DuplicateJsonObjectContextCustomizer();
	}
	private static final class DuplicateJsonObjectContextCustomizer implements ContextCustomizer {
		private final Log logger = LogFactory.getLog(DuplicateJsonObjectContextCustomizer.class);
		@Override
		public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
			List<URL> jsonObjects = findJsonObjects();
			if (jsonObjects.size() > 1) {
				logDuplicateJsonObjectsWarning(jsonObjects);
			}
		}
		private List<URL> findJsonObjects() {
			try {
				Enumeration<URL> resources = getClass().getClassLoader().getResources('org/json/JSONObject.class');
				return Collections.list(resources);
			}
			catch (Exception ex) {
				// Continue
			}
			return Collections.emptyList();
		}
		private void logDuplicateJsonObjectsWarning(List<URL> jsonObjects) {
			StringBuilder message = new StringBuilder(
					String.format('%n%nFound multiple occurrences of org.json.JSONObject on the class path:%n%n'));
			for (URL jsonObject : jsonObjects) {
				message.append(String.format('\t%s%n', jsonObject));
			}
			message.append(
					String.format('%nYou may wish to exclude one of them to ensure predictable runtime behavior%n'));
			this.logger.warn(message);
		}
		@Override
		public boolean equals(Object obj) {
			return (obj != null) && (getClass() == obj.getClass());
		}
		@Override
		public int hashCode() {
			return getClass().hashCode();
		}
	}
}
/*
package org.springframework.boot.test.json;
/**
public class JacksonTester<T> extends AbstractJsonMarshalTester<T> {
	private final ObjectMapper objectMapper;
	private Class<?> view;
	/**
	 * Create a new {@link JacksonTester} instance.
	 * @param objectMapper the Jackson object mapper
	 */
	protected JacksonTester(ObjectMapper objectMapper) {
		Assert.notNull(objectMapper, 'ObjectMapper must not be null');
		this.objectMapper = objectMapper;
	}
	/**
	 * Create a new {@link JacksonTester} instance.
	 * @param resourceLoadClass the source class used to load resources
	 * @param type the type under test
	 * @param objectMapper the Jackson object mapper
	 */
	public JacksonTester(Class<?> resourceLoadClass, ResolvableType type, ObjectMapper objectMapper) {
		this(resourceLoadClass, type, objectMapper, null);
	}
	public JacksonTester(Class<?> resourceLoadClass, ResolvableType type, ObjectMapper objectMapper, Class<?> view) {
		super(resourceLoadClass, type);
		Assert.notNull(objectMapper, 'ObjectMapper must not be null');
		this.objectMapper = objectMapper;
		this.view = view;
	}
	@Override
	protected JsonContent<T> getJsonContent(String json) {
		Configuration configuration = Configuration.builder()
			.jsonProvider(new JacksonJsonProvider(this.objectMapper))
			.mappingProvider(new JacksonMappingProvider(this.objectMapper))
			.build();
		return new JsonContent<>(getResourceLoadClass(), getType(), json, configuration);
	}
	@Override
	protected T readObject(InputStream inputStream, ResolvableType type) throws IOException {
		return getObjectReader(type).readValue(inputStream);
	}
	@Override
	protected T readObject(Reader reader, ResolvableType type) throws IOException {
		return getObjectReader(type).readValue(reader);
	}
	private ObjectReader getObjectReader(ResolvableType type) {
		ObjectReader objectReader = this.objectMapper.readerFor(getType(type));
		if (this.view != null) {
			return objectReader.withView(this.view);
		}
		return objectReader;
	}
	@Override
	protected String writeObject(T value, ResolvableType type) throws IOException {
		return getObjectWriter(type).writeValueAsString(value);
	}
	private ObjectWriter getObjectWriter(ResolvableType type) {
		ObjectWriter objectWriter = this.objectMapper.writerFor(getType(type));
		if (this.view != null) {
			return objectWriter.withView(this.view);
		}
		return objectWriter;
	}
	private JavaType getType(ResolvableType type) {
		return this.objectMapper.constructType(type.getType());
	}
	/**
	 * Utility method to initialize {@link JacksonTester} fields. See {@link JacksonTester
	 * class-level documentation} for example usage.
	 * @param testInstance the test instance
	 * @param objectMapper the object mapper
	 * @see #initFields(Object, ObjectMapper)
	 */
	public static void initFields(Object testInstance, ObjectMapper objectMapper) {
		new JacksonFieldInitializer().initFields(testInstance, objectMapper);
	}
	/**
	 * Utility method to initialize {@link JacksonTester} fields. See {@link JacksonTester
	 * class-level documentation} for example usage.
	 * @param testInstance the test instance
	 * @param objectMapperFactory a factory to create the object mapper
	 * @see #initFields(Object, ObjectMapper)
	 */
	public static void initFields(Object testInstance, ObjectFactory<ObjectMapper> objectMapperFactory) {
		new JacksonFieldInitializer().initFields(testInstance, objectMapperFactory);
	}
	/**
	 * Returns a new instance of {@link JacksonTester} with the view that should be used
	 * for json serialization/deserialization.
	 * @param view the view class
	 * @return the new instance
	 */
	public JacksonTester<T> forView(Class<?> view) {
		return new JacksonTester<>(getResourceLoadClass(), getType(), this.objectMapper, view);
	}
	/**
	 * {@link FieldInitializer} for Jackson.
	 */
	private static class JacksonFieldInitializer extends FieldInitializer<ObjectMapper> {
		protected JacksonFieldInitializer() {
			super(JacksonTester.class);
		}
		@Override
		protected AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type,
				ObjectMapper marshaller) {
			return new JacksonTester<>(resourceLoadClass, type, marshaller);
		}
	}
}
/*
package org.springframework.boot.test.json;
/**
public abstract class AbstractJsonMarshalTester<T> {
	private Class<?> resourceLoadClass;
	private ResolvableType type;
	/**
	 * Create a new uninitialized {@link AbstractJsonMarshalTester} instance.
	 */
	protected AbstractJsonMarshalTester() {
	}
	/**
	 * Create a new {@link AbstractJsonMarshalTester} instance.
	 * @param resourceLoadClass the source class used when loading relative classpath
	 * resources
	 * @param type the type under test
	 */
	public AbstractJsonMarshalTester(Class<?> resourceLoadClass, ResolvableType type) {
		Assert.notNull(resourceLoadClass, 'ResourceLoadClass must not be null');
		Assert.notNull(type, 'Type must not be null');
		initialize(resourceLoadClass, type);
	}
	/**
	 * Initialize the marshal tester for use.
	 * @param resourceLoadClass the source class used when loading relative classpath
	 * resources
	 * @param type the type under test
	 */
	protected final void initialize(Class<?> resourceLoadClass, ResolvableType type) {
		if (this.resourceLoadClass == null && this.type == null) {
			this.resourceLoadClass = resourceLoadClass;
			this.type = type;
		}
	}
	/**
	 * Return the type under test.
	 * @return the type under test
	 */
	protected final ResolvableType getType() {
		return this.type;
	}
	/**
	 * Return class used to load relative resources.
	 * @return the resource load class
	 */
	protected final Class<?> getResourceLoadClass() {
		return this.resourceLoadClass;
	}
	/**
	 * Return {@link JsonContent} from writing the specific value.
	 * @param value the value to write
	 * @return the {@link JsonContent}
	 * @throws IOException on write error
	 */
	public JsonContent<T> write(T value) throws IOException {
		verify();
		Assert.notNull(value, 'Value must not be null');
		String json = writeObject(value, this.type);
		return getJsonContent(json);
	}
	/**
	 * Factory method used to get a {@link JsonContent} instance from a source JSON
	 * string.
	 * @param json the source JSON
	 * @return a new {@link JsonContent} instance
	 * @since 2.1.5
	 */
	protected JsonContent<T> getJsonContent(String json) {
		return new JsonContent<>(getResourceLoadClass(), getType(), json);
	}
	/**
	 * Return the object created from parsing the specific JSON bytes.
	 * @param jsonBytes the source JSON bytes
	 * @return the resulting object
	 * @throws IOException on parse error
	 */
	public T parseObject(byte[] jsonBytes) throws IOException {
		verify();
		return parse(jsonBytes).getObject();
	}
	/**
	 * Return {@link ObjectContent} from parsing the specific JSON bytes.
	 * @param jsonBytes the source JSON bytes
	 * @return the {@link ObjectContent}
	 * @throws IOException on parse error
	 */
	public ObjectContent<T> parse(byte[] jsonBytes) throws IOException {
		verify();
		Assert.notNull(jsonBytes, 'JsonBytes must not be null');
		return read(new ByteArrayResource(jsonBytes));
	}
	/**
	 * Return the object created from parsing the specific JSON String.
	 * @param jsonString the source JSON string
	 * @return the resulting object
	 * @throws IOException on parse error
	 */
	public T parseObject(String jsonString) throws IOException {
		verify();
		return parse(jsonString).getObject();
	}
	/**
	 * Return {@link ObjectContent} from parsing the specific JSON String.
	 * @param jsonString the source JSON string
	 * @return the {@link ObjectContent}
	 * @throws IOException on parse error
	 */
	public ObjectContent<T> parse(String jsonString) throws IOException {
		verify();
		Assert.notNull(jsonString, 'JsonString must not be null');
		return read(new StringReader(jsonString));
	}
	/**
	 * Return the object created from reading from the specified classpath resource.
	 * @param resourcePath the source resource path. May be a full path or a path relative
	 * to the {@code resourceLoadClass} passed to the constructor
	 * @return the resulting object
	 * @throws IOException on read error
	 */
	public T readObject(String resourcePath) throws IOException {
		verify();
		return read(resourcePath).getObject();
	}
	/**
	 * Return {@link ObjectContent} from reading from the specified classpath resource.
	 * @param resourcePath the source resource path. May be a full path or a path relative
	 * to the {@code resourceLoadClass} passed to the constructor
	 * @return the {@link ObjectContent}
	 * @throws IOException on read error
	 */
	public ObjectContent<T> read(String resourcePath) throws IOException {
		verify();
		Assert.notNull(resourcePath, 'ResourcePath must not be null');
		return read(new ClassPathResource(resourcePath, this.resourceLoadClass));
	}
	/**
	 * Return the object created from reading from the specified file.
	 * @param file the source file
	 * @return the resulting object
	 * @throws IOException on read error
	 */
	public T readObject(File file) throws IOException {
		verify();
		return read(file).getObject();
	}
	/**
	 * Return {@link ObjectContent} from reading from the specified file.
	 * @param file the source file
	 * @return the {@link ObjectContent}
	 * @throws IOException on read error
	 */
	public ObjectContent<T> read(File file) throws IOException {
		verify();
		Assert.notNull(file, 'File must not be null');
		return read(new FileSystemResource(file));
	}
	/**
	 * Return the object created from reading from the specified input stream.
	 * @param inputStream the source input stream
	 * @return the resulting object
	 * @throws IOException on read error
	 */
	public T readObject(InputStream inputStream) throws IOException {
		verify();
		return read(inputStream).getObject();
	}
	/**
	 * Return {@link ObjectContent} from reading from the specified input stream.
	 * @param inputStream the source input stream
	 * @return the {@link ObjectContent}
	 * @throws IOException on read error
	 */
	public ObjectContent<T> read(InputStream inputStream) throws IOException {
		verify();
		Assert.notNull(inputStream, 'InputStream must not be null');
		return read(new InputStreamResource(inputStream));
	}
	/**
	 * Return the object created from reading from the specified resource.
	 * @param resource the source resource
	 * @return the resulting object
	 * @throws IOException on read error
	 */
	public T readObject(Resource resource) throws IOException {
		verify();
		return read(resource).getObject();
	}
	/**
	 * Return {@link ObjectContent} from reading from the specified resource.
	 * @param resource the source resource
	 * @return the {@link ObjectContent}
	 * @throws IOException on read error
	 */
	public ObjectContent<T> read(Resource resource) throws IOException {
		verify();
		Assert.notNull(resource, 'Resource must not be null');
		InputStream inputStream = resource.getInputStream();
		T object = readObject(inputStream, this.type);
		closeQuietly(inputStream);
		return new ObjectContent<>(this.type, object);
	}
	/**
	 * Return the object created from reading from the specified reader.
	 * @param reader the source reader
	 * @return the resulting object
	 * @throws IOException on read error
	 */
	public T readObject(Reader reader) throws IOException {
		verify();
		return read(reader).getObject();
	}
	/**
	 * Return {@link ObjectContent} from reading from the specified reader.
	 * @param reader the source reader
	 * @return the {@link ObjectContent}
	 * @throws IOException on read error
	 */
	public ObjectContent<T> read(Reader reader) throws IOException {
		verify();
		Assert.notNull(reader, 'Reader must not be null');
		T object = readObject(reader, this.type);
		closeQuietly(reader);
		return new ObjectContent<>(this.type, object);
	}
	private void closeQuietly(Closeable closeable) {
		try {
			closeable.close();
		}
		catch (IOException ex) {
			// Ignore
		}
	}
	private void verify() {
		Assert.state(this.resourceLoadClass != null, 'Uninitialized JsonMarshalTester (ResourceLoadClass is null)');
		Assert.state(this.type != null, 'Uninitialized JsonMarshalTester (Type is null)');
	}
	/**
	 * Write the specified object to a JSON string.
	 * @param value the source value (never {@code null})
	 * @param type the resulting type (never {@code null})
	 * @return the JSON string
	 * @throws IOException on write error
	 */
	protected abstract String writeObject(T value, ResolvableType type) throws IOException;
	/**
	 * Read from the specified input stream to create an object of the specified type. The
	 * default implementation delegates to {@link #readObject(Reader, ResolvableType)}.
	 * @param inputStream the source input stream (never {@code null})
	 * @param type the resulting type (never {@code null})
	 * @return the resulting object
	 * @throws IOException on read error
	 */
	protected T readObject(InputStream inputStream, ResolvableType type) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
		return readObject(reader, type);
	}
	/**
	 * Read from the specified reader to create an object of the specified type.
	 * @param reader the source reader (never {@code null})
	 * @param type the resulting type (never {@code null})
	 * @return the resulting object
	 * @throws IOException on read error
	 */
	protected abstract T readObject(Reader reader, ResolvableType type) throws IOException;
	/**
	 * Utility class used to support field initialization. Used by subclasses to support
	 * {@code initFields}.
	 *
	 * @param <M> the marshaller type
	 */
	protected abstract static class FieldInitializer<M> {
		private final Class<?> testerClass;
		@SuppressWarnings('rawtypes')
		protected FieldInitializer(Class<? extends AbstractJsonMarshalTester> testerClass) {
			Assert.notNull(testerClass, 'TesterClass must not be null');
			this.testerClass = testerClass;
		}
		public void initFields(Object testInstance, M marshaller) {
			Assert.notNull(testInstance, 'TestInstance must not be null');
			Assert.notNull(marshaller, 'Marshaller must not be null');
			initFields(testInstance, () -> marshaller);
		}
		public void initFields(Object testInstance, final ObjectFactory<M> marshaller) {
			Assert.notNull(testInstance, 'TestInstance must not be null');
			Assert.notNull(marshaller, 'Marshaller must not be null');
			ReflectionUtils.doWithFields(testInstance.getClass(),
					(field) -> doWithField(field, testInstance, marshaller));
		}
		protected void doWithField(Field field, Object test, ObjectFactory<M> marshaller) {
			if (this.testerClass.isAssignableFrom(field.getType())) {
				ReflectionUtils.makeAccessible(field);
				Object existingValue = ReflectionUtils.getField(field, test);
				if (existingValue == null) {
					setupField(field, test, marshaller);
				}
			}
		}
		private void setupField(Field field, Object test, ObjectFactory<M> marshaller) {
			ResolvableType type = ResolvableType.forField(field).getGeneric();
			ReflectionUtils.setField(field, test, createTester(test.getClass(), type, marshaller.getObject()));
		}
		protected abstract AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass,
				ResolvableType type, M marshaller);
	}
}
/*
package org.springframework.boot.test.json;
/**
				.isEqualTo('Spring');
public class BasicJsonTester {
	private JsonLoader loader;
	/**
	 * Create a new uninitialized {@link BasicJsonTester} instance.
	 */
	protected BasicJsonTester() {
	}
	/**
	 * Create a new {@link BasicJsonTester} instance that will load resources as UTF-8.
	 * @param resourceLoadClass the source class used to load resources
	 */
	public BasicJsonTester(Class<?> resourceLoadClass) {
		this(resourceLoadClass, null);
	}
	/**
	 * Create a new {@link BasicJsonTester} instance.
	 * @param resourceLoadClass the source class used to load resources
	 * @param charset the charset used to load resources
	 * @since 1.4.1
	 */
	public BasicJsonTester(Class<?> resourceLoadClass, Charset charset) {
		Assert.notNull(resourceLoadClass, 'ResourceLoadClass must not be null');
		this.loader = new JsonLoader(resourceLoadClass, charset);
	}
	/**
	 * Initialize the marshal tester for use, configuring it to load JSON resources as
	 * UTF-8.
	 * @param resourceLoadClass the source class used when loading relative classpath
	 * resources
	 */
	protected final void initialize(Class<?> resourceLoadClass) {
		initialize(resourceLoadClass, null);
	}
	/**
	 * Initialize the marshal tester for use.
	 * @param resourceLoadClass the source class used when loading relative classpath
	 * resources
	 * @param charset the charset used when loading relative classpath resources
	 * @since 1.4.1
	 */
	protected final void initialize(Class<?> resourceLoadClass, Charset charset) {
		if (this.loader == null) {
			this.loader = new JsonLoader(resourceLoadClass, charset);
		}
	}
	/**
	 * Create JSON content from the specified String source. The source can contain the
	 * JSON itself or, if it ends with {@code .json}, the name of a resource to be loaded
	 * using {@code resourceLoadClass}.
	 * @param source the JSON content or a {@code .json} resource name
	 * @return the JSON content
	 */
	public JsonContent<Object> from(CharSequence source) {
		verify();
		return getJsonContent(this.loader.getJson(source));
	}
	/**
	 * Create JSON content from the specified resource path.
	 * @param path the path of the resource to load
	 * @param resourceLoadClass the source class used to load the resource
	 * @return the JSON content
	 */
	public JsonContent<Object> from(String path, Class<?> resourceLoadClass) {
		verify();
		return getJsonContent(this.loader.getJson(path, resourceLoadClass));
	}
	/**
	 * Create JSON content from the specified JSON bytes.
	 * @param source the bytes of JSON
	 * @return the JSON content
	 */
	public JsonContent<Object> from(byte[] source) {
		verify();
		return getJsonContent(this.loader.getJson(source));
	}
	/**
	 * Create JSON content from the specified JSON file.
	 * @param source the file containing JSON
	 * @return the JSON content
	 */
	public JsonContent<Object> from(File source) {
		verify();
		return getJsonContent(this.loader.getJson(source));
	}
	/**
	 * Create JSON content from the specified JSON input stream.
	 * @param source the input stream containing JSON
	 * @return the JSON content
	 */
	public JsonContent<Object> from(InputStream source) {
		verify();
		return getJsonContent(this.loader.getJson(source));
	}
	/**
	 * Create JSON content from the specified JSON resource.
	 * @param source the resource containing JSON
	 * @return the JSON content
	 */
	public JsonContent<Object> from(Resource source) {
		verify();
		return getJsonContent(this.loader.getJson(source));
	}
	private void verify() {
		Assert.state(this.loader != null, 'Uninitialized BasicJsonTester');
	}
	private JsonContent<Object> getJsonContent(String json) {
		return new JsonContent<>(this.loader.getResourceLoadClass(), null, json);
	}
}
/*
package org.springframework.boot.test.json;
/**
public final class JsonContent<T> implements AssertProvider<JsonContentAssert> {
	private final Class<?> resourceLoadClass;
	private final ResolvableType type;
	private final String json;
	private final Configuration configuration;
	/**
	 * Create a new {@link JsonContent} instance.
	 * @param resourceLoadClass the source class used to load resources
	 * @param type the type under test (or {@code null} if not known)
	 * @param json the actual JSON content
	 */
	public JsonContent(Class<?> resourceLoadClass, ResolvableType type, String json) {
		this(resourceLoadClass, type, json, Configuration.defaultConfiguration());
	}
	/**
	 * Create a new {@link JsonContent} instance.
	 * @param resourceLoadClass the source class used to load resources
	 * @param type the type under test (or {@code null} if not known)
	 * @param json the actual JSON content
	 * @param configuration the JsonPath configuration
	 */
	JsonContent(Class<?> resourceLoadClass, ResolvableType type, String json, Configuration configuration) {
		Assert.notNull(resourceLoadClass, 'ResourceLoadClass must not be null');
		Assert.notNull(json, 'JSON must not be null');
		Assert.notNull(configuration, 'Configuration must not be null');
		this.resourceLoadClass = resourceLoadClass;
		this.type = type;
		this.json = json;
		this.configuration = configuration;
	}
	/**
	 * Use AssertJ"s {@link org.assertj.core.api.Assertions#assertThat assertThat}
	 * instead.
	 * @deprecated to prevent accidental use. Prefer standard AssertJ
	 * {@code assertThat(context)...} calls instead.
	 */
	@Override
	@Deprecated(since = '1.5.7', forRemoval = false)
	public JsonContentAssert assertThat() {
		return new JsonContentAssert(this.resourceLoadClass, null, this.json, this.configuration);
	}
	/**
	 * Return the actual JSON content string.
	 * @return the JSON content
	 */
	public String getJson() {
		return this.json;
	}
	@Override
	public String toString() {
		String createdFrom = (this.type != null) ? ' created from ' + this.type : '';
		return 'JsonContent ' + this.json + createdFrom;
	}
}
/*
/**
package org.springframework.boot.test.json;
/*
package org.springframework.boot.test.json;
/**
public class JsonbTester<T> extends AbstractJsonMarshalTester<T> {
	private final Jsonb jsonb;
	/**
	 * Create a new uninitialized {@link JsonbTester} instance.
	 * @param jsonb the Jsonb instance
	 */
	protected JsonbTester(Jsonb jsonb) {
		Assert.notNull(jsonb, 'Jsonb must not be null');
		this.jsonb = jsonb;
	}
	/**
	 * Create a new {@link JsonbTester} instance.
	 * @param resourceLoadClass the source class used to load resources
	 * @param type the type under test
	 * @param jsonb the Jsonb instance
	 * @see #initFields(Object, Jsonb)
	 */
	public JsonbTester(Class<?> resourceLoadClass, ResolvableType type, Jsonb jsonb) {
		super(resourceLoadClass, type);
		Assert.notNull(jsonb, 'Jsonb must not be null');
		this.jsonb = jsonb;
	}
	@Override
	protected String writeObject(T value, ResolvableType type) throws IOException {
		return this.jsonb.toJson(value, type.getType());
	}
	@Override
	protected T readObject(Reader reader, ResolvableType type) throws IOException {
		return this.jsonb.fromJson(reader, type.getType());
	}
	/**
	 * Utility method to initialize {@link JsonbTester} fields. See {@link JsonbTester
	 * class-level documentation} for example usage.
	 * @param testInstance the test instance
	 * @param jsonb the Jsonb instance
	 */
	public static void initFields(Object testInstance, Jsonb jsonb) {
		new JsonbFieldInitializer().initFields(testInstance, jsonb);
	}
	/**
	 * Utility method to initialize {@link JsonbTester} fields. See {@link JsonbTester
	 * class-level documentation} for example usage.
	 * @param testInstance the test instance
	 * @param jsonb an object factory to create the Jsonb instance
	 */
	public static void initFields(Object testInstance, ObjectFactory<Jsonb> jsonb) {
		new JsonbTester.JsonbFieldInitializer().initFields(testInstance, jsonb);
	}
	/**
	 * {@link FieldInitializer} for Jsonb.
	 */
	private static class JsonbFieldInitializer extends FieldInitializer<Jsonb> {
		protected JsonbFieldInitializer() {
			super(JsonbTester.class);
		}
		@Override
		protected AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type,
				Jsonb marshaller) {
			return new JsonbTester<>(resourceLoadClass, type, marshaller);
		}
	}
}
/*
package org.springframework.boot.test.mock.web;
/**
public class SpringBootMockServletContext extends MockServletContext {
	private static final String[] SPRING_BOOT_RESOURCE_LOCATIONS = new String[] { 'classpath:META-INF/resources',
			'classpath:resources', 'classpath:static', 'classpath:public' };
	private final ResourceLoader resourceLoader;
	private File emptyRootDirectory;
	public SpringBootMockServletContext(String resourceBasePath) {
		this(resourceBasePath, new FileSystemResourceLoader());
	}
	public SpringBootMockServletContext(String resourceBasePath, ResourceLoader resourceLoader) {
		super(resourceBasePath, resourceLoader);
		this.resourceLoader = resourceLoader;
	}
	@Override
	protected String getResourceLocation(String path) {
		if (!path.startsWith('/')) {
			path = '/' + path;
		}
		String resourceLocation = getResourceBasePathLocation(path);
		if (exists(resourceLocation)) {
			return resourceLocation;
		}
		for (String prefix : SPRING_BOOT_RESOURCE_LOCATIONS) {
			resourceLocation = prefix + path;
			if (exists(resourceLocation)) {
				return resourceLocation;
			}
		}
		return super.getResourceLocation(path);
	}
	protected final String getResourceBasePathLocation(String path) {
		return super.getResourceLocation(path);
	}
	private boolean exists(String resourceLocation) {
		try {
			Resource resource = this.resourceLoader.getResource(resourceLocation);
			return resource.exists();
		}
		catch (Exception ex) {
			return false;
		}
	}
	@Override
	public URL getResource(String path) throws MalformedURLException {
		URL resource = super.getResource(path);
		if (resource == null && '/'.equals(path)) {
			// Liquibase assumes that '/' always exists, if we don"t have a directory
			// use a temporary location.
			try {
				if (this.emptyRootDirectory == null) {
					synchronized (this) {
						File tempDirectory = Files.createTempDirectory('spr-servlet').toFile();
						tempDirectory.deleteOnExit();
						this.emptyRootDirectory = tempDirectory;
					}
				}
				return this.emptyRootDirectory.toURI().toURL();
			}
			catch (IOException ex) {
				// Ignore
			}
		}
		return resource;
	}
}
/*
/**
package org.springframework.boot.test.mock.web;
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@Target({ ElementType.TYPE, ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(MockBeans.class)
public @interface MockBean {
	/**
	 * The name of the bean to register or replace. If not specified the name will either
	 * be generated or, if the mock replaces an existing bean, the existing name will be
	 * used.
	 * @return the name of the bean
	 */
	String name() default '';
	/**
	 * The classes to mock. This is an alias of {@link #classes()} which can be used for
	 * brevity if no other attributes are defined. See {@link #classes()} for details.
	 * @return the classes to mock
	 */
	@AliasFor('classes')
	Class<?>[] value() default {};
	/**
	 * The classes to mock. Each class specified here will result in a mock being created
	 * and registered with the application context. Classes can be omitted when the
	 * annotation is used on a field.
	 * <p>
	 * When {@code @MockBean} also defines a {@code name} this attribute can only contain
	 * a single value.
	 * <p>
	 * If this is the only specified attribute consider using the {@code value} alias
	 * instead.
	 * @return the classes to mock
	 */
	@AliasFor('value')
	Class<?>[] classes() default {};
	/**
	 * Any extra interfaces that should also be declared on the mock. See
	 * {@link MockSettings#extraInterfaces(Class...)} for details.
	 * @return any extra interfaces
	 */
	Class<?>[] extraInterfaces() default {};
	/**
	 * The {@link Answers} type to use on the mock.
	 * @return the answer type
	 */
	Answers answer() default Answers.RETURNS_DEFAULTS;
	/**
	 * If the generated mock is serializable. See {@link MockSettings#serializable()} for
	 * details.
	 * @return if the mock is serializable
	 */
	boolean serializable() default false;
	/**
	 * The reset mode to apply to the mock bean. The default is {@link MockReset#AFTER}
	 * meaning that mocks are automatically reset after each test method is invoked.
	 * @return the reset mode
	 */
	MockReset reset() default MockReset.AFTER;
}
/*
package org.springframework.boot.test.mock.mockito;
/**
class MockitoBeans implements Iterable<Object> {
	private final List<Object> beans = new ArrayList<>();
	void add(Object bean) {
		this.beans.add(bean);
	}
	@Override
	public Iterator<Object> iterator() {
		return this.beans.iterator();
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class DefinitionsParser {
	private final Set<Definition> definitions;
	private final Map<Definition, Field> definitionFields;
	DefinitionsParser() {
		this(Collections.emptySet());
	}
	DefinitionsParser(Collection<? extends Definition> existing) {
		this.definitions = new LinkedHashSet<>();
		this.definitionFields = new LinkedHashMap<>();
		if (existing != null) {
			this.definitions.addAll(existing);
		}
	}
	void parse(Class<?> source) {
		parseElement(source, null);
		ReflectionUtils.doWithFields(source, (element) -> parseElement(element, source));
	}
	private void parseElement(AnnotatedElement element, Class<?> source) {
		MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.SUPERCLASS);
		annotations.stream(MockBean.class)
			.map(MergedAnnotation::synthesize)
			.forEach((annotation) -> parseMockBeanAnnotation(annotation, element, source));
		annotations.stream(SpyBean.class)
			.map(MergedAnnotation::synthesize)
			.forEach((annotation) -> parseSpyBeanAnnotation(annotation, element, source));
	}
	private void parseMockBeanAnnotation(MockBean annotation, AnnotatedElement element, Class<?> source) {
		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value(), source);
		Assert.state(!typesToMock.isEmpty(), () -> 'Unable to deduce type to mock from ' + element);
		if (StringUtils.hasLength(annotation.name())) {
			Assert.state(typesToMock.size() == 1, 'The name attribute can only be used when mocking a single class');
		}
		for (ResolvableType typeToMock : typesToMock) {
			MockDefinition definition = new MockDefinition(annotation.name(), typeToMock, annotation.extraInterfaces(),
					annotation.answer(), annotation.serializable(), annotation.reset(),
					QualifierDefinition.forElement(element));
			addDefinition(element, definition, 'mock');
		}
	}
	private void parseSpyBeanAnnotation(SpyBean annotation, AnnotatedElement element, Class<?> source) {
		Set<ResolvableType> typesToSpy = getOrDeduceTypes(element, annotation.value(), source);
		Assert.state(!typesToSpy.isEmpty(), () -> 'Unable to deduce type to spy from ' + element);
		if (StringUtils.hasLength(annotation.name())) {
			Assert.state(typesToSpy.size() == 1, 'The name attribute can only be used when spying a single class');
		}
		for (ResolvableType typeToSpy : typesToSpy) {
			SpyDefinition definition = new SpyDefinition(annotation.name(), typeToSpy, annotation.reset(),
					annotation.proxyTargetAware(), QualifierDefinition.forElement(element));
			addDefinition(element, definition, 'spy');
		}
	}
	private void addDefinition(AnnotatedElement element, Definition definition, String type) {
		boolean isNewDefinition = this.definitions.add(definition);
		Assert.state(isNewDefinition, () -> 'Duplicate ' + type + ' definition ' + definition);
		if (element instanceof Field field) {
			this.definitionFields.put(definition, field);
		}
	}
	private Set<ResolvableType> getOrDeduceTypes(AnnotatedElement element, Class<?>[] value, Class<?> source) {
		Set<ResolvableType> types = new LinkedHashSet<>();
		for (Class<?> type : value) {
			types.add(ResolvableType.forClass(type));
		}
		if (types.isEmpty() && element instanceof Field field) {
			types.add((field.getGenericType() instanceof TypeVariable) ? ResolvableType.forField(field, source)
					: ResolvableType.forField(field));
		}
		return types;
	}
	Set<Definition> getDefinitions() {
		return Collections.unmodifiableSet(this.definitions);
	}
	Field getField(Definition definition) {
		return this.definitionFields.get(definition);
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@Target({ ElementType.TYPE, ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(SpyBeans.class)
public @interface SpyBean {
	/**
	 * The name of the bean to spy. If not specified the name will either be generated or,
	 * if the spy is for an existing bean, the existing name will be used.
	 * @return the name of the bean
	 */
	String name() default '';
	/**
	 * The classes to spy. This is an alias of {@link #classes()} which can be used for
	 * brevity if no other attributes are defined. See {@link #classes()} for details.
	 * @return the classes to spy
	 */
	@AliasFor('classes')
	Class<?>[] value() default {};
	/**
	 * The classes to spy. Each class specified here will result in a spy being applied.
	 * Classes can be omitted when the annotation is used on a field.
	 * <p>
	 * When {@code @SpyBean} also defines a {@code name} this attribute can only contain a
	 * single value.
	 * <p>
	 * If this is the only specified attribute consider using the {@code value} alias
	 * instead.
	 * @return the classes to spy
	 */
	@AliasFor('value')
	Class<?>[] classes() default {};
	/**
	 * The reset mode to apply to the spied bean. The default is {@link MockReset#AFTER}
	 * meaning that spies are automatically reset after each test method is invoked.
	 * @return the reset mode
	 */
	MockReset reset() default MockReset.AFTER;
	/**
	 * Indicates that Mockito methods such as {@link Mockito#verify(Object) verify(mock)}
	 * should use the {@code target} of AOP advised beans, rather than the proxy itself.
	 * If set to {@code false} you may need to use the result of
	 * {@link org.springframework.test.util.AopTestUtils#getUltimateTargetObject(Object)
	 * AopTestUtils.getUltimateTargetObject(...)} when calling Mockito methods.
	 * @return {@code true} if the target of AOP advised beans is used or {@code false} if
	 * the proxy is used directly
	 */
	boolean proxyTargetAware() default true;
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public enum MockReset {
	/**
	 * Reset the mock before the test method runs.
	 */
	BEFORE,
	/**
	 * Reset the mock after the test method runs.
	 */
	AFTER,
	/**
	 * Don"t reset the mock.
	 */
	NONE;
	/**
	 * Create {@link MockSettings settings} to be used with mocks where reset should occur
	 * before each test method runs.
	 * @return mock settings
	 */
	public static MockSettings before() {
		return withSettings(BEFORE);
	}
	/**
	 * Create {@link MockSettings settings} to be used with mocks where reset should occur
	 * after each test method runs.
	 * @return mock settings
	 */
	public static MockSettings after() {
		return withSettings(AFTER);
	}
	/**
	 * Create {@link MockSettings settings} to be used with mocks where a specific reset
	 * should occur.
	 * @param reset the reset type
	 * @return mock settings
	 */
	public static MockSettings withSettings(MockReset reset) {
		return apply(reset, Mockito.withSettings());
	}
	/**
	 * Apply {@link MockReset} to existing {@link MockSettings settings}.
	 * @param reset the reset type
	 * @param settings the settings
	 * @return the configured settings
	 */
	public static MockSettings apply(MockReset reset, MockSettings settings) {
		Assert.notNull(settings, 'Settings must not be null');
		if (reset != null && reset != NONE) {
			settings.invocationListeners(new ResetInvocationListener(reset));
		}
		return settings;
	}
	/**
	 * Get the {@link MockReset} associated with the given mock.
	 * @param mock the source mock
	 * @return the reset type (never {@code null})
	 */
	static MockReset get(Object mock) {
		MockReset reset = MockReset.NONE;
		MockingDetails mockingDetails = Mockito.mockingDetails(mock);
		if (mockingDetails.isMock()) {
			MockCreationSettings<?> settings = mockingDetails.getMockCreationSettings();
			List<InvocationListener> listeners = settings.getInvocationListeners();
			for (Object listener : listeners) {
				if (listener instanceof ResetInvocationListener resetInvocationListener) {
					reset = resetInvocationListener.getReset();
				}
			}
		}
		return reset;
	}
	/**
	 * Dummy {@link InvocationListener} used to hold the {@link MockReset} value.
	 */
	private static class ResetInvocationListener implements InvocationListener {
		private final MockReset reset;
		ResetInvocationListener(MockReset reset) {
			this.reset = reset;
		}
		MockReset getReset() {
			return this.reset;
		}
		@Override
		public void reportInvocation(MethodInvocationReport methodInvocationReport) {
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface MockBeans {
	/**
	 * Return the contained {@link MockBean @MockBean} annotations.
	 * @return the mock beans
	 */
	MockBean[] value();
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class SpyDefinition extends Definition {
	private static final int MULTIPLIER = 31;
	private final ResolvableType typeToSpy;
	SpyDefinition(String name, ResolvableType typeToSpy, MockReset reset, boolean proxyTargetAware,
			QualifierDefinition qualifier) {
		super(name, reset, proxyTargetAware, qualifier);
		Assert.notNull(typeToSpy, 'TypeToSpy must not be null');
		this.typeToSpy = typeToSpy;
	}
	ResolvableType getTypeToSpy() {
		return this.typeToSpy;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		SpyDefinition other = (SpyDefinition) obj;
		boolean result = super.equals(obj);
		result = result && ObjectUtils.nullSafeEquals(this.typeToSpy, other.typeToSpy);
		return result;
	}
	@Override
	public int hashCode() {
		int result = super.hashCode();
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.typeToSpy);
		return result;
	}
	@Override
	public String toString() {
		return new ToStringCreator(this).append('name', getName())
			.append('typeToSpy', this.typeToSpy)
			.append('reset', getReset())
			.toString();
	}
	<T> T createSpy(Object instance) {
		return createSpy(getName(), instance);
	}
	@SuppressWarnings('unchecked')
	<T> T createSpy(String name, Object instance) {
		Assert.notNull(instance, 'Instance must not be null');
		Assert.isInstanceOf(this.typeToSpy.resolve(), instance);
		if (Mockito.mockingDetails(instance).isSpy()) {
			return (T) instance;
		}
		MockSettings settings = MockReset.withSettings(getReset());
		if (StringUtils.hasLength(name)) {
			settings.name(name);
		}
		if (isProxyTargetAware()) {
			settings.verificationStartedListeners(new SpringAopBypassingVerificationStartedListener());
		}
		Class<?> toSpy;
		if (Proxy.isProxyClass(instance.getClass())) {
			settings.defaultAnswer(AdditionalAnswers.delegatesTo(instance));
			toSpy = this.typeToSpy.toClass();
		}
		else {
			settings.defaultAnswer(Mockito.CALLS_REAL_METHODS);
			settings.spiedInstance(instance);
			toSpy = instance.getClass();
		}
		return (T) mock(toSpy, settings);
	}
	/**
	 * A {@link VerificationStartedListener} that bypasses any proxy created by Spring AOP
	 * when the verification of a spy starts.
	 */
	private static final class SpringAopBypassingVerificationStartedListener implements VerificationStartedListener {
		@Override
		public void onVerificationStarted(VerificationStartedEvent event) {
			event.setMock(AopTestUtils.getUltimateTargetObject(event.getMock()));
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface SpyBeans {
	/**
	 * Return the contained {@link SpyBean @SpyBean} annotations.
	 * @return the spy beans
	 */
	SpyBean[] value();
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class ResetMocksTestExecutionListener extends AbstractTestExecutionListener {
	private static final boolean MOCKITO_IS_PRESENT = ClassUtils.isPresent('org.mockito.MockSettings',
			ResetMocksTestExecutionListener.class.getClassLoader());
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 100;
	}
	@Override
	public void beforeTestMethod(TestContext testContext) throws Exception {
		if (MOCKITO_IS_PRESENT && !NativeDetector.inNativeImage()) {
			resetMocks(testContext.getApplicationContext(), MockReset.BEFORE);
		}
	}
	@Override
	public void afterTestMethod(TestContext testContext) throws Exception {
		if (MOCKITO_IS_PRESENT && !NativeDetector.inNativeImage()) {
			resetMocks(testContext.getApplicationContext(), MockReset.AFTER);
		}
	}
	private void resetMocks(ApplicationContext applicationContext, MockReset reset) {
		if (applicationContext instanceof ConfigurableApplicationContext configurableContext) {
			resetMocks(configurableContext, reset);
		}
	}
	private void resetMocks(ConfigurableApplicationContext applicationContext, MockReset reset) {
		ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();
		String[] names = beanFactory.getBeanDefinitionNames();
		Set<String> instantiatedSingletons = new HashSet<>(Arrays.asList(beanFactory.getSingletonNames()));
		for (String name : names) {
			BeanDefinition definition = beanFactory.getBeanDefinition(name);
			if (definition.isSingleton() && instantiatedSingletons.contains(name)) {
				Object bean = getBean(beanFactory, name);
				if (bean != null && reset.equals(MockReset.get(bean))) {
					Mockito.reset(bean);
				}
			}
		}
		try {
			MockitoBeans mockedBeans = beanFactory.getBean(MockitoBeans.class);
			for (Object mockedBean : mockedBeans) {
				if (reset.equals(MockReset.get(mockedBean))) {
					Mockito.reset(mockedBean);
				}
			}
		}
		catch (NoSuchBeanDefinitionException ex) {
			// Continue
		}
		if (applicationContext.getParent() != null) {
			resetMocks(applicationContext.getParent(), reset);
		}
	}
	private Object getBean(ConfigurableListableBeanFactory beanFactory, String name) {
		try {
			if (isStandardBeanOrSingletonFactoryBean(beanFactory, name)) {
				return beanFactory.getBean(name);
			}
		}
		catch (Exception ex) {
			// Continue
		}
		return beanFactory.getSingleton(name);
	}
	private boolean isStandardBeanOrSingletonFactoryBean(ConfigurableListableBeanFactory beanFactory, String name) {
		String factoryBeanName = BeanFactory.FACTORY_BEAN_PREFIX + name;
		if (beanFactory.containsBean(factoryBeanName)) {
			FactoryBean<?> factoryBean = (FactoryBean<?>) beanFactory.getBean(factoryBeanName);
			return factoryBean.isSingleton();
		}
		return true;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0')
public class MockitoPostProcessor implements InstantiationAwareBeanPostProcessor, BeanClassLoaderAware,
		BeanFactoryAware, BeanFactoryPostProcessor, Ordered {
	private static final String BEAN_NAME = MockitoPostProcessor.class.getName();
	private static final String CONFIGURATION_CLASS_ATTRIBUTE = Conventions
		.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, 'configurationClass');
	private static final BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();
	private final Set<Definition> definitions;
	private ClassLoader classLoader;
	private BeanFactory beanFactory;
	private final MockitoBeans mockitoBeans = new MockitoBeans();
	private final Map<Definition, String> beanNameRegistry = new HashMap<>();
	private final Map<Field, String> fieldRegistry = new HashMap<>();
	private final Map<String, SpyDefinition> spies = new HashMap<>();
	/**
	 * Create a new {@link MockitoPostProcessor} instance with the given initial
	 * definitions.
	 * @param definitions the initial definitions
	 */
	public MockitoPostProcessor(Set<Definition> definitions) {
		this.definitions = definitions;
	}
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		Assert.isInstanceOf(ConfigurableListableBeanFactory.class, beanFactory,
				'Mock beans can only be used with a ConfigurableListableBeanFactory');
		this.beanFactory = beanFactory;
	}
	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		Assert.isInstanceOf(BeanDefinitionRegistry.class, beanFactory,
				'@MockBean can only be used on bean factories that implement BeanDefinitionRegistry');
		postProcessBeanFactory(beanFactory, (BeanDefinitionRegistry) beanFactory);
	}
	private void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry) {
		beanFactory.registerSingleton(MockitoBeans.class.getName(), this.mockitoBeans);
		DefinitionsParser parser = new DefinitionsParser(this.definitions);
		for (Class<?> configurationClass : getConfigurationClasses(beanFactory)) {
			parser.parse(configurationClass);
		}
		Set<Definition> definitions = parser.getDefinitions();
		for (Definition definition : definitions) {
			Field field = parser.getField(definition);
			register(beanFactory, registry, definition, field);
		}
	}
	private Set<Class<?>> getConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
		Set<Class<?>> configurationClasses = new LinkedHashSet<>();
		for (BeanDefinition beanDefinition : getConfigurationBeanDefinitions(beanFactory).values()) {
			configurationClasses.add(ClassUtils.resolveClassName(beanDefinition.getBeanClassName(), this.classLoader));
		}
		return configurationClasses;
	}
	private Map<String, BeanDefinition> getConfigurationBeanDefinitions(ConfigurableListableBeanFactory beanFactory) {
		Map<String, BeanDefinition> definitions = new LinkedHashMap<>();
		for (String beanName : beanFactory.getBeanDefinitionNames()) {
			BeanDefinition definition = beanFactory.getBeanDefinition(beanName);
			if (definition.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE) != null) {
				definitions.put(beanName, definition);
			}
		}
		return definitions;
	}
	private void register(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry,
			Definition definition, Field field) {
		if (definition instanceof MockDefinition mockDefinition) {
			registerMock(beanFactory, registry, mockDefinition, field);
		}
		else if (definition instanceof SpyDefinition spyDefinition) {
			registerSpy(beanFactory, registry, spyDefinition, field);
		}
	}
	private void registerMock(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry,
			MockDefinition definition, Field field) {
		RootBeanDefinition beanDefinition = createBeanDefinition(definition);
		String beanName = getBeanName(beanFactory, registry, definition, beanDefinition);
		String transformedBeanName = BeanFactoryUtils.transformedBeanName(beanName);
		if (registry.containsBeanDefinition(transformedBeanName)) {
			BeanDefinition existing = registry.getBeanDefinition(transformedBeanName);
			copyBeanDefinitionDetails(existing, beanDefinition);
			registry.removeBeanDefinition(transformedBeanName);
		}
		registry.registerBeanDefinition(transformedBeanName, beanDefinition);
		Object mock = definition.createMock(beanName + ' bean');
		beanFactory.registerSingleton(transformedBeanName, mock);
		this.mockitoBeans.add(mock);
		this.beanNameRegistry.put(definition, beanName);
		if (field != null) {
			this.fieldRegistry.put(field, beanName);
		}
	}
	private RootBeanDefinition createBeanDefinition(MockDefinition mockDefinition) {
		RootBeanDefinition definition = new RootBeanDefinition(mockDefinition.getTypeToMock().resolve());
		definition.setTargetType(mockDefinition.getTypeToMock());
		if (mockDefinition.getQualifier() != null) {
			mockDefinition.getQualifier().applyTo(definition);
		}
		return definition;
	}
	private String getBeanName(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry,
			MockDefinition mockDefinition, RootBeanDefinition beanDefinition) {
		if (StringUtils.hasLength(mockDefinition.getName())) {
			return mockDefinition.getName();
		}
		Set<String> existingBeans = getExistingBeans(beanFactory, mockDefinition.getTypeToMock(),
				mockDefinition.getQualifier());
		if (existingBeans.isEmpty()) {
			return MockitoPostProcessor.beanNameGenerator.generateBeanName(beanDefinition, registry);
		}
		if (existingBeans.size() == 1) {
			return existingBeans.iterator().next();
		}
		String primaryCandidate = determinePrimaryCandidate(registry, existingBeans, mockDefinition.getTypeToMock());
		if (primaryCandidate != null) {
			return primaryCandidate;
		}
		throw new IllegalStateException('Unable to register mock bean ' + mockDefinition.getTypeToMock()
				+ ' expected a single matching bean to replace but found ' + existingBeans);
	}
	private void copyBeanDefinitionDetails(BeanDefinition from, RootBeanDefinition to) {
		to.setPrimary(from.isPrimary());
	}
	private void registerSpy(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry,
			SpyDefinition spyDefinition, Field field) {
		Set<String> existingBeans = getExistingBeans(beanFactory, spyDefinition.getTypeToSpy(),
				spyDefinition.getQualifier());
		if (ObjectUtils.isEmpty(existingBeans)) {
			createSpy(registry, spyDefinition, field);
		}
		else {
			registerSpies(registry, spyDefinition, field, existingBeans);
		}
	}
	private Set<String> getExistingBeans(ConfigurableListableBeanFactory beanFactory, ResolvableType type,
			QualifierDefinition qualifier) {
		Set<String> candidates = new TreeSet<>();
		for (String candidate : getExistingBeans(beanFactory, type)) {
			if (qualifier == null || qualifier.matches(beanFactory, candidate)) {
				candidates.add(candidate);
			}
		}
		return candidates;
	}
	private Set<String> getExistingBeans(ConfigurableListableBeanFactory beanFactory, ResolvableType resolvableType) {
		Set<String> beans = new LinkedHashSet<>(
				Arrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));
		Class<?> type = resolvableType.resolve(Object.class);
		for (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {
			beanName = BeanFactoryUtils.transformedBeanName(beanName);
			Class<?> producedType = beanFactory.getType(beanName, false);
			if (type.equals(producedType)) {
				beans.add(beanName);
			}
		}
		beans.removeIf(this::isScopedTarget);
		return beans;
	}
	private boolean isScopedTarget(String beanName) {
		try {
			return ScopedProxyUtils.isScopedTarget(beanName);
		}
		catch (Throwable ex) {
			return false;
		}
	}
	private void createSpy(BeanDefinitionRegistry registry, SpyDefinition spyDefinition, Field field) {
		RootBeanDefinition beanDefinition = new RootBeanDefinition(spyDefinition.getTypeToSpy().resolve());
		String beanName = MockitoPostProcessor.beanNameGenerator.generateBeanName(beanDefinition, registry);
		registry.registerBeanDefinition(beanName, beanDefinition);
		registerSpy(spyDefinition, field, beanName);
	}
	private void registerSpies(BeanDefinitionRegistry registry, SpyDefinition spyDefinition, Field field,
			Collection<String> existingBeans) {
		try {
			String beanName = determineBeanName(existingBeans, spyDefinition, registry);
			registerSpy(spyDefinition, field, beanName);
		}
		catch (RuntimeException ex) {
			throw new IllegalStateException('Unable to register spy bean ' + spyDefinition.getTypeToSpy(), ex);
		}
	}
	private String determineBeanName(Collection<String> existingBeans, SpyDefinition definition,
			BeanDefinitionRegistry registry) {
		if (StringUtils.hasText(definition.getName())) {
			return definition.getName();
		}
		if (existingBeans.size() == 1) {
			return existingBeans.iterator().next();
		}
		return determinePrimaryCandidate(registry, existingBeans, definition.getTypeToSpy());
	}
	private String determinePrimaryCandidate(BeanDefinitionRegistry registry, Collection<String> candidateBeanNames,
			ResolvableType type) {
		String primaryBeanName = null;
		for (String candidateBeanName : candidateBeanNames) {
			BeanDefinition beanDefinition = registry.getBeanDefinition(candidateBeanName);
			if (beanDefinition.isPrimary()) {
				if (primaryBeanName != null) {
					throw new NoUniqueBeanDefinitionException(type.resolve(), candidateBeanNames.size(),
							'more than one "primary" bean found among candidates: '
									+ Collections.singletonList(candidateBeanNames));
				}
				primaryBeanName = candidateBeanName;
			}
		}
		return primaryBeanName;
	}
	private void registerSpy(SpyDefinition definition, Field field, String beanName) {
		this.spies.put(beanName, definition);
		this.beanNameRegistry.put(definition, beanName);
		if (field != null) {
			this.fieldRegistry.put(field, beanName);
		}
	}
	protected final Object createSpyIfNecessary(Object bean, String beanName) throws BeansException {
		SpyDefinition definition = this.spies.get(beanName);
		if (definition != null) {
			bean = definition.createSpy(beanName, bean);
		}
		return bean;
	}
	@Override
	public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)
			throws BeansException {
		ReflectionUtils.doWithFields(bean.getClass(), (field) -> postProcessField(bean, field));
		return pvs;
	}
	private void postProcessField(Object bean, Field field) {
		String beanName = this.fieldRegistry.get(field);
		if (StringUtils.hasText(beanName)) {
			inject(field, bean, beanName);
		}
	}
	void inject(Field field, Object target, Definition definition) {
		String beanName = this.beanNameRegistry.get(definition);
		Assert.state(StringUtils.hasLength(beanName), () -> 'No bean found for definition ' + definition);
		inject(field, target, beanName);
	}
	private void inject(Field field, Object target, String beanName) {
		try {
			field.setAccessible(true);
			Object existingValue = ReflectionUtils.getField(field, target);
			Object bean = this.beanFactory.getBean(beanName, field.getType());
			if (existingValue == bean) {
				return;
			}
			Assert.state(existingValue == null, () -> 'The existing value "' + existingValue + '" of field "' + field
					+ '" is not the same as the new value "' + bean + '"');
			ReflectionUtils.setField(field, target, bean);
		}
		catch (Throwable ex) {
			throw new BeanCreationException('Could not inject field: ' + field, ex);
		}
	}
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 10;
	}
	/**
	 * Register the processor with a {@link BeanDefinitionRegistry}. Not required when
	 * using the {@link SpringRunner} as registration is automatic.
	 * @param registry the bean definition registry
	 */
	public static void register(BeanDefinitionRegistry registry) {
		register(registry, null);
	}
	/**
	 * Register the processor with a {@link BeanDefinitionRegistry}. Not required when
	 * using the {@link SpringRunner} as registration is automatic.
	 * @param registry the bean definition registry
	 * @param definitions the initial mock/spy definitions
	 */
	public static void register(BeanDefinitionRegistry registry, Set<Definition> definitions) {
		register(registry, MockitoPostProcessor.class, definitions);
	}
	/**
	 * Register the processor with a {@link BeanDefinitionRegistry}. Not required when
	 * using the {@link SpringRunner} as registration is automatic.
	 * @param registry the bean definition registry
	 * @param postProcessor the post processor class to register
	 * @param definitions the initial mock/spy definitions
	 */
	@SuppressWarnings('unchecked')
	public static void register(BeanDefinitionRegistry registry, Class<? extends MockitoPostProcessor> postProcessor,
			Set<Definition> definitions) {
		SpyPostProcessor.register(registry);
		BeanDefinition definition = getOrAddBeanDefinition(registry, postProcessor);
		ValueHolder constructorArg = definition.getConstructorArgumentValues().getIndexedArgumentValue(0, Set.class);
		Set<Definition> existing = (Set<Definition>) constructorArg.getValue();
		if (definitions != null) {
			existing.addAll(definitions);
		}
	}
	private static BeanDefinition getOrAddBeanDefinition(BeanDefinitionRegistry registry,
			Class<? extends MockitoPostProcessor> postProcessor) {
		if (!registry.containsBeanDefinition(BEAN_NAME)) {
			RootBeanDefinition definition = new RootBeanDefinition(postProcessor);
			definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
			ConstructorArgumentValues constructorArguments = definition.getConstructorArgumentValues();
			constructorArguments.addIndexedArgumentValue(0, new LinkedHashSet<>());
			registry.registerBeanDefinition(BEAN_NAME, definition);
			return definition;
		}
		return registry.getBeanDefinition(BEAN_NAME);
	}
	/**
	 * {@link BeanPostProcessor} to handle {@link SpyBean} definitions. Registered as a
	 * separate processor so that it can be ordered above AOP post processors.
	 */
	static class SpyPostProcessor implements SmartInstantiationAwareBeanPostProcessor, PriorityOrdered {
		private static final String BEAN_NAME = SpyPostProcessor.class.getName();
		private final Map<String, Object> earlySpyReferences = new ConcurrentHashMap<>(16);
		private final MockitoPostProcessor mockitoPostProcessor;
		SpyPostProcessor(MockitoPostProcessor mockitoPostProcessor) {
			this.mockitoPostProcessor = mockitoPostProcessor;
		}
		@Override
		public int getOrder() {
			return Ordered.HIGHEST_PRECEDENCE;
		}
		@Override
		public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
			if (bean instanceof FactoryBean) {
				return bean;
			}
			this.earlySpyReferences.put(getCacheKey(bean, beanName), bean);
			return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName);
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			if (bean instanceof FactoryBean) {
				return bean;
			}
			if (this.earlySpyReferences.remove(getCacheKey(bean, beanName)) != bean) {
				return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName);
			}
			return bean;
		}
		private String getCacheKey(Object bean, String beanName) {
			return StringUtils.hasLength(beanName) ? beanName : bean.getClass().getName();
		}
		static void register(BeanDefinitionRegistry registry) {
			if (!registry.containsBeanDefinition(BEAN_NAME)) {
				RootBeanDefinition definition = new RootBeanDefinition(SpyPostProcessor.class);
				definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				ConstructorArgumentValues constructorArguments = definition.getConstructorArgumentValues();
				constructorArguments.addIndexedArgumentValue(0,
						new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME));
				registry.registerBeanDefinition(BEAN_NAME, definition);
			}
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
abstract class Definition {
	private static final int MULTIPLIER = 31;
	private final String name;
	private final MockReset reset;
	private final boolean proxyTargetAware;
	private final QualifierDefinition qualifier;
	Definition(String name, MockReset reset, boolean proxyTargetAware, QualifierDefinition qualifier) {
		this.name = name;
		this.reset = (reset != null) ? reset : MockReset.AFTER;
		this.proxyTargetAware = proxyTargetAware;
		this.qualifier = qualifier;
	}
	/**
	 * Return the name for bean.
	 * @return the name or {@code null}
	 */
	String getName() {
		return this.name;
	}
	/**
	 * Return the mock reset mode.
	 * @return the reset mode
	 */
	MockReset getReset() {
		return this.reset;
	}
	/**
	 * Return if AOP advised beans should be proxy target aware.
	 * @return if proxy target aware
	 */
	boolean isProxyTargetAware() {
		return this.proxyTargetAware;
	}
	/**
	 * Return the qualifier or {@code null}.
	 * @return the qualifier
	 */
	QualifierDefinition getQualifier() {
		return this.qualifier;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || !getClass().isAssignableFrom(obj.getClass())) {
			return false;
		}
		Definition other = (Definition) obj;
		boolean result = true;
		result = result && ObjectUtils.nullSafeEquals(this.name, other.name);
		result = result && ObjectUtils.nullSafeEquals(this.reset, other.reset);
		result = result && ObjectUtils.nullSafeEquals(this.proxyTargetAware, other.proxyTargetAware);
		result = result && ObjectUtils.nullSafeEquals(this.qualifier, other.qualifier);
		return result;
	}
	@Override
	public int hashCode() {
		int result = 1;
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.name);
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.reset);
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.proxyTargetAware);
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.qualifier);
		return result;
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class MockitoTestExecutionListener extends AbstractTestExecutionListener {
	private static final String MOCKS_ATTRIBUTE_NAME = MockitoTestExecutionListener.class.getName() + '.mocks';
	@Override
	public final int getOrder() {
		return 1950;
	}
	@Override
	public void prepareTestInstance(TestContext testContext) throws Exception {
		closeMocks(testContext);
		initMocks(testContext);
		injectFields(testContext);
	}
	@Override
	public void beforeTestMethod(TestContext testContext) throws Exception {
		if (Boolean.TRUE.equals(
				testContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))) {
			closeMocks(testContext);
			initMocks(testContext);
			reinjectFields(testContext);
		}
	}
	@Override
	public void afterTestMethod(TestContext testContext) throws Exception {
		closeMocks(testContext);
	}
	@Override
	public void afterTestClass(TestContext testContext) throws Exception {
		closeMocks(testContext);
	}
	private void initMocks(TestContext testContext) {
		if (hasMockitoAnnotations(testContext)) {
			testContext.setAttribute(MOCKS_ATTRIBUTE_NAME, MockitoAnnotations.openMocks(testContext.getTestInstance()));
		}
	}
	private void closeMocks(TestContext testContext) throws Exception {
		Object mocks = testContext.getAttribute(MOCKS_ATTRIBUTE_NAME);
		if (mocks instanceof AutoCloseable closeable) {
			closeable.close();
		}
	}
	private boolean hasMockitoAnnotations(TestContext testContext) {
		MockitoAnnotationCollection collector = new MockitoAnnotationCollection();
		ReflectionUtils.doWithFields(testContext.getTestClass(), collector);
		return collector.hasAnnotations();
	}
	private void injectFields(TestContext testContext) {
		postProcessFields(testContext, (mockitoField, postProcessor) -> postProcessor.inject(mockitoField.field,
				mockitoField.target, mockitoField.definition));
	}
	private void reinjectFields(final TestContext testContext) {
		postProcessFields(testContext, (mockitoField, postProcessor) -> {
			ReflectionUtils.makeAccessible(mockitoField.field);
			ReflectionUtils.setField(mockitoField.field, testContext.getTestInstance(), null);
			postProcessor.inject(mockitoField.field, mockitoField.target, mockitoField.definition);
		});
	}
	private void postProcessFields(TestContext testContext, BiConsumer<MockitoField, MockitoPostProcessor> consumer) {
		DefinitionsParser parser = new DefinitionsParser();
		parser.parse(testContext.getTestClass());
		if (!parser.getDefinitions().isEmpty()) {
			MockitoPostProcessor postProcessor = testContext.getApplicationContext()
				.getBean(MockitoPostProcessor.class);
			for (Definition definition : parser.getDefinitions()) {
				Field field = parser.getField(definition);
				if (field != null) {
					consumer.accept(new MockitoField(field, testContext.getTestInstance(), definition), postProcessor);
				}
			}
		}
	}
	/**
	 * {@link FieldCallback} to collect Mockito annotations.
	 */
	private static final class MockitoAnnotationCollection implements FieldCallback {
		private final Set<Annotation> annotations = new LinkedHashSet<>();
		@Override
		public void doWith(Field field) throws IllegalArgumentException {
			for (Annotation annotation : field.getDeclaredAnnotations()) {
				if (annotation.annotationType().getName().startsWith('org.mockito')) {
					this.annotations.add(annotation);
				}
			}
		}
		boolean hasAnnotations() {
			return !this.annotations.isEmpty();
		}
	}
	private static final class MockitoField {
		private final Field field;
		private final Object target;
		private final Definition definition;
		private MockitoField(Field field, Object instance, Definition definition) {
			this.field = field;
			this.target = instance;
			this.definition = definition;
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public class SpringBootMockResolver implements MockResolver {
	@Override
	public Object resolve(Object instance) {
		return getUltimateTargetObject(instance);
	}
	@SuppressWarnings('unchecked')
	private static <T> T getUltimateTargetObject(Object candidate) {
		Assert.notNull(candidate, 'Candidate must not be null');
		try {
			if (AopUtils.isAopProxy(candidate) && candidate instanceof Advised advised) {
				TargetSource targetSource = advised.getTargetSource();
				if (targetSource.isStatic()) {
					Object target = targetSource.getTarget();
					if (target != null) {
						return getUltimateTargetObject(target);
					}
				}
			}
		}
		catch (Throwable ex) {
			throw new IllegalStateException('Failed to unwrap proxied object', ex);
		}
		return (T) candidate;
	}
}
/*
/**
package org.springframework.boot.test.mock.mockito;
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockitoContextCustomizer implements ContextCustomizer {
	private final Set<Definition> definitions;
	MockitoContextCustomizer(Set<? extends Definition> definitions) {
		this.definitions = new LinkedHashSet<>(definitions);
	}
	@Override
	public void customizeContext(ConfigurableApplicationContext context,
			MergedContextConfiguration mergedContextConfiguration) {
		if (context instanceof BeanDefinitionRegistry registry) {
			MockitoPostProcessor.register(registry, this.definitions);
		}
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		MockitoContextCustomizer other = (MockitoContextCustomizer) obj;
		return this.definitions.equals(other.definitions);
	}
	@Override
	public int hashCode() {
		return this.definitions.hashCode();
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockDefinition extends Definition {
	private static final int MULTIPLIER = 31;
	private final ResolvableType typeToMock;
	private final Set<Class<?>> extraInterfaces;
	private final Answers answer;
	private final boolean serializable;
	MockDefinition(String name, ResolvableType typeToMock, Class<?>[] extraInterfaces, Answers answer,
			boolean serializable, MockReset reset, QualifierDefinition qualifier) {
		super(name, reset, false, qualifier);
		Assert.notNull(typeToMock, 'TypeToMock must not be null');
		this.typeToMock = typeToMock;
		this.extraInterfaces = asClassSet(extraInterfaces);
		this.answer = (answer != null) ? answer : Answers.RETURNS_DEFAULTS;
		this.serializable = serializable;
	}
	private Set<Class<?>> asClassSet(Class<?>[] classes) {
		Set<Class<?>> classSet = new LinkedHashSet<>();
		if (classes != null) {
			classSet.addAll(Arrays.asList(classes));
		}
		return Collections.unmodifiableSet(classSet);
	}
	/**
	 * Return the type that should be mocked.
	 * @return the type to mock; never {@code null}
	 */
	ResolvableType getTypeToMock() {
		return this.typeToMock;
	}
	/**
	 * Return the extra interfaces.
	 * @return the extra interfaces or an empty set
	 */
	Set<Class<?>> getExtraInterfaces() {
		return this.extraInterfaces;
	}
	/**
	 * Return the answers mode.
	 * @return the answers mode; never {@code null}
	 */
	Answers getAnswer() {
		return this.answer;
	}
	/**
	 * Return if the mock is serializable.
	 * @return if the mock is serializable
	 */
	boolean isSerializable() {
		return this.serializable;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		MockDefinition other = (MockDefinition) obj;
		boolean result = super.equals(obj);
		result = result && ObjectUtils.nullSafeEquals(this.typeToMock, other.typeToMock);
		result = result && ObjectUtils.nullSafeEquals(this.extraInterfaces, other.extraInterfaces);
		result = result && ObjectUtils.nullSafeEquals(this.answer, other.answer);
		result = result && this.serializable == other.serializable;
		return result;
	}
	@Override
	public int hashCode() {
		int result = super.hashCode();
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.typeToMock);
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.extraInterfaces);
		result = MULTIPLIER * result + ObjectUtils.nullSafeHashCode(this.answer);
		result = MULTIPLIER * result + Boolean.hashCode(this.serializable);
		return result;
	}
	@Override
	public String toString() {
		return new ToStringCreator(this).append('name', getName())
			.append('typeToMock', this.typeToMock)
			.append('extraInterfaces', this.extraInterfaces)
			.append('answer', this.answer)
			.append('serializable', this.serializable)
			.append('reset', getReset())
			.toString();
	}
	<T> T createMock() {
		return createMock(getName());
	}
	@SuppressWarnings('unchecked')
	<T> T createMock(String name) {
		MockSettings settings = MockReset.withSettings(getReset());
		if (StringUtils.hasLength(name)) {
			settings.name(name);
		}
		if (!this.extraInterfaces.isEmpty()) {
			settings.extraInterfaces(ClassUtils.toClassArray(this.extraInterfaces));
		}
		settings.defaultAnswer(this.answer);
		if (this.serializable) {
			settings.serializable();
		}
		return (T) mock(this.typeToMock.resolve(), settings);
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class MockitoContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		// We gather the explicit mock definitions here since they form part of the
		// MergedContextConfiguration key. Different mocks need to have a different key.
		DefinitionsParser parser = new DefinitionsParser();
		parseDefinitions(testClass, parser);
		return new MockitoContextCustomizer(parser.getDefinitions());
	}
	private void parseDefinitions(Class<?> testClass, DefinitionsParser parser) {
		parser.parse(testClass);
		if (TestContextAnnotationUtils.searchEnclosingClass(testClass)) {
			parseDefinitions(testClass.getEnclosingClass(), parser);
		}
	}
}
/*
package org.springframework.boot.test.mock.mockito;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class QualifierDefinition {
	private final Field field;
	private final DependencyDescriptor descriptor;
	private final Set<Annotation> annotations;
	QualifierDefinition(Field field, Set<Annotation> annotations) {
		// We can"t use the field or descriptor as part of the context key
		// but we can assume that if two fields have the same qualifiers then
		// it"s safe for Spring to use either for qualifier logic
		this.field = field;
		this.descriptor = new DependencyDescriptor(field, true);
		this.annotations = annotations;
	}
	boolean matches(ConfigurableListableBeanFactory beanFactory, String beanName) {
		return beanFactory.isAutowireCandidate(beanName, this.descriptor);
	}
	void applyTo(RootBeanDefinition definition) {
		definition.setQualifiedElement(this.field);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || !getClass().isAssignableFrom(obj.getClass())) {
			return false;
		}
		QualifierDefinition other = (QualifierDefinition) obj;
		return this.annotations.equals(other.annotations);
	}
	@Override
	public int hashCode() {
		return this.annotations.hashCode();
	}
	static QualifierDefinition forElement(AnnotatedElement element) {
		if (element != null && element instanceof Field field) {
			Set<Annotation> annotations = getQualifierAnnotations(field);
			if (!annotations.isEmpty()) {
				return new QualifierDefinition(field, annotations);
			}
		}
		return null;
	}
	private static Set<Annotation> getQualifierAnnotations(Field field) {
		// Assume that any annotations other than @MockBean/@SpyBean are qualifiers
		Annotation[] candidates = field.getDeclaredAnnotations();
		Set<Annotation> annotations = new HashSet<>(candidates.length);
		for (Annotation candidate : candidates) {
			if (!isMockOrSpyAnnotation(candidate.annotationType())) {
				annotations.add(candidate);
			}
		}
		return annotations;
	}
	private static boolean isMockOrSpyAnnotation(Class<? extends Annotation> type) {
		if (type.equals(MockBean.class) || type.equals(SpyBean.class)) {
			return true;
		}
		MergedAnnotations metaAnnotations = MergedAnnotations.from(type);
		return metaAnnotations.isPresent(MockBean.class) || metaAnnotations.isPresent(SpyBean.class);
	}
}
/*
package org.springframework.boot.test.rsocket.server;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Value('${local.rsocket.server.port}')
public @interface LocalRSocketServerPort {
}
/*
/**
package org.springframework.boot.test.rsocket.server;
/*
package org.springframework.boot.test.graphql.tester;
/**
class HttpGraphQlTesterContextCustomizerFactory implements ContextCustomizerFactory {
	private static final String HTTPGRAPHQLTESTER_CLASS = 'org.springframework.graphql.test.tester.HttpGraphQlTester';
	private static final String WEBTESTCLIENT_CLASS = 'org.springframework.test.web.reactive.server.WebTestClient';
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		SpringBootTest springBootTest = TestContextAnnotationUtils.findMergedAnnotation(testClass,
				SpringBootTest.class);
		return (springBootTest != null && isGraphQlTesterPresent()) ? new HttpGraphQlTesterContextCustomizer() : null;
	}
	private boolean isGraphQlTesterPresent() {
		return ClassUtils.isPresent(WEBTESTCLIENT_CLASS, getClass().getClassLoader())
				&& ClassUtils.isPresent(HTTPGRAPHQLTESTER_CLASS, getClass().getClassLoader());
	}
}
/*
package org.springframework.boot.test.graphql.tester;
/**
class HttpGraphQlTesterContextCustomizer implements ContextCustomizer {
	@Override
	public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
		if (AotDetector.useGeneratedArtifacts()) {
			return;
		}
		SpringBootTest springBootTest = TestContextAnnotationUtils.findMergedAnnotation(mergedConfig.getTestClass(),
				SpringBootTest.class);
		if (springBootTest.webEnvironment().isEmbedded()) {
			registerHttpGraphQlTester(context);
		}
	}
	private void registerHttpGraphQlTester(ConfigurableApplicationContext context) {
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		if (beanFactory instanceof BeanDefinitionRegistry beanDefinitionRegistry) {
			registerHttpGraphQlTester(beanDefinitionRegistry);
		}
	}
	private void registerHttpGraphQlTester(BeanDefinitionRegistry registry) {
		RootBeanDefinition definition = new RootBeanDefinition(HttpGraphQlTesterRegistrar.class);
		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(HttpGraphQlTesterRegistrar.class.getName(), definition);
	}
	@Override
	public boolean equals(Object obj) {
		return (obj != null) && (obj.getClass() == getClass());
	}
	@Override
	public int hashCode() {
		return getClass().hashCode();
	}
	static class HttpGraphQlTesterRegistrar implements BeanDefinitionRegistryPostProcessor, Ordered, BeanFactoryAware {
		private BeanFactory beanFactory;
		@Override
		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			if (AotDetector.useGeneratedArtifacts()) {
				return;
			}
			if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors((ListableBeanFactory) this.beanFactory,
					HttpGraphQlTester.class, false, false).length == 0) {
				registry.registerBeanDefinition(HttpGraphQlTester.class.getName(),
						new RootBeanDefinition(HttpGraphQlTesterFactory.class));
			}
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
		@Override
		public int getOrder() {
			return Ordered.LOWEST_PRECEDENCE - 1;
		}
	}
	public static class HttpGraphQlTesterFactory implements FactoryBean<HttpGraphQlTester>, ApplicationContextAware {
		private static final String SERVLET_APPLICATION_CONTEXT_CLASS = 'org.springframework.web.context.WebApplicationContext';
		private static final String REACTIVE_APPLICATION_CONTEXT_CLASS = 'org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext';
		private ApplicationContext applicationContext;
		private HttpGraphQlTester object;
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
			this.applicationContext = applicationContext;
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
		@Override
		public Class<?> getObjectType() {
			return HttpGraphQlTester.class;
		}
		@Override
		public HttpGraphQlTester getObject() throws Exception {
			if (this.object == null) {
				this.object = createGraphQlTester();
			}
			return this.object;
		}
		private HttpGraphQlTester createGraphQlTester() {
			WebTestClient webTestClient = this.applicationContext.getBean(WebTestClient.class);
			boolean sslEnabled = isSslEnabled(this.applicationContext);
			String port = this.applicationContext.getEnvironment().getProperty('local.server.port', '8080');
			WebTestClient mutatedWebClient = webTestClient.mutate().baseUrl(getBaseUrl(sslEnabled, port)).build();
			return HttpGraphQlTester.create(mutatedWebClient);
		}
		private String getBaseUrl(boolean sslEnabled, String port) {
			String basePath = deduceBasePath();
			return (sslEnabled ? 'https' : 'http') + '://localhost:' + port + basePath;
		}
		private String deduceBasePath() {
			return deduceServerBasePath() + findConfiguredGraphQlPath();
		}
		private String findConfiguredGraphQlPath() {
			String configuredPath = this.applicationContext.getEnvironment().getProperty('spring.graphql.path');
			return StringUtils.hasText(configuredPath) ? configuredPath : '/graphql';
		}
		private String deduceServerBasePath() {
			String serverBasePath = '';
			WebApplicationType webApplicationType = deduceFromApplicationContext(this.applicationContext.getClass());
			if (webApplicationType == WebApplicationType.REACTIVE) {
				serverBasePath = this.applicationContext.getEnvironment().getProperty('spring.webflux.base-path');
			}
			else if (webApplicationType == WebApplicationType.SERVLET) {
				serverBasePath = ((WebApplicationContext) this.applicationContext).getServletContext().getContextPath();
			}
			return (serverBasePath != null) ? serverBasePath : '';
		}
		static WebApplicationType deduceFromApplicationContext(Class<?> applicationContextClass) {
			if (isAssignable(SERVLET_APPLICATION_CONTEXT_CLASS, applicationContextClass)) {
				return WebApplicationType.SERVLET;
			}
			if (isAssignable(REACTIVE_APPLICATION_CONTEXT_CLASS, applicationContextClass)) {
				return WebApplicationType.REACTIVE;
			}
			return WebApplicationType.NONE;
		}
		private static boolean isAssignable(String target, Class<?> type) {
			try {
				return ClassUtils.resolveClassName(target, null).isAssignableFrom(type);
			}
			catch (Throwable ex) {
				return false;
			}
		}
		private boolean isSslEnabled(ApplicationContext context) {
			try {
				AbstractConfigurableWebServerFactory webServerFactory = context
					.getBean(AbstractConfigurableWebServerFactory.class);
				return webServerFactory.getSsl() != null && webServerFactory.getSsl().isEnabled();
			}
			catch (NoSuchBeanDefinitionException ex) {
				return false;
			}
		}
	}
}
/*
/**
package org.springframework.boot.test.graphql.tester;
/*
package org.springframework.boot.actuate.autoconfigure.ssl;
/**
class SslHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(SslHealthContributorAutoConfiguration.class, SslAutoConfiguration.class))
		.withPropertyValues('server.ssl.bundle=ssltest',
				'spring.ssl.bundle.jks.ssltest.keystore.location=classpath:test.jks');
	@Test
	void beansShouldNotBeConfigured() {
		this.contextRunner.withPropertyValues('management.health.ssl.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(HealthIndicator.class)
				.doesNotHaveBean(SslInfo.class));
	}
	@Test
	void beansShouldBeConfigured() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(SslHealthIndicator.class);
			assertThat(context).hasSingleBean(SslInfo.class);
			Health health = context.getBean(SslHealthIndicator.class).health();
			assertThat(health.getStatus()).isSameAs(Status.OUT_OF_SERVICE);
			assertDetailsKeys(health);
			List<CertificateChainInfo> invalidChains = getInvalidChains(health);
			assertThat(invalidChains).hasSize(1);
			assertThat(invalidChains).first().isInstanceOf(CertificateChainInfo.class);
		});
	}
	@Test
	void beansShouldBeConfiguredWithWarningThreshold() {
		this.contextRunner.withPropertyValues('management.health.ssl.certificate-validity-warning-threshold=1d')
			.run((context) -> {
				assertThat(context).hasSingleBean(SslHealthIndicator.class);
				assertThat(context).hasSingleBean(SslInfo.class);
				assertThat(context).hasSingleBean(SslHealthIndicatorProperties.class);
				assertThat(context.getBean(SslHealthIndicatorProperties.class).getCertificateValidityWarningThreshold())
					.isEqualTo(Duration.ofDays(1));
				Health health = context.getBean(SslHealthIndicator.class).health();
				assertThat(health.getStatus()).isSameAs(Status.OUT_OF_SERVICE);
				assertDetailsKeys(health);
				List<CertificateChainInfo> invalidChains = getInvalidChains(health);
				assertThat(invalidChains).hasSize(1);
				assertThat(invalidChains).first().isInstanceOf(CertificateChainInfo.class);
			});
	}
	@Test
	void customBeansShouldBeConfigured() {
		this.contextRunner.withUserConfiguration(CustomSslInfoConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(SslHealthIndicator.class);
			assertThat(context.getBean(SslHealthIndicator.class))
				.isSameAs(context.getBean(CustomSslHealthIndicator.class));
			assertThat(context).hasSingleBean(SslInfo.class);
			assertThat(context.getBean(SslInfo.class)).isSameAs(context.getBean('customSslInfo'));
			Health health = context.getBean(SslHealthIndicator.class).health();
			assertThat(health.getStatus()).isSameAs(Status.OUT_OF_SERVICE);
			assertDetailsKeys(health);
			List<CertificateChainInfo> invalidChains = getInvalidChains(health);
			assertThat(invalidChains).hasSize(1);
			assertThat(invalidChains).first().isInstanceOf(CertificateChainInfo.class);
		});
	}
	private static void assertDetailsKeys(Health health) {
		assertThat(health.getDetails()).containsOnlyKeys('validChains', 'invalidChains');
	}
	@SuppressWarnings('unchecked')
	private static List<CertificateChainInfo> getInvalidChains(Health health) {
		return (List<CertificateChainInfo>) health.getDetails().get('invalidChains');
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSslInfoConfiguration {
		@Bean
		SslHealthIndicator sslHealthIndicator(SslInfo sslInfo) {
			return new CustomSslHealthIndicator(sslInfo);
		}
		@Bean
		SslInfo customSslInfo(SslBundles sslBundles) {
			return new SslInfo(sslBundles, Duration.ofDays(7));
		}
		static class CustomSslHealthIndicator extends SslHealthIndicator {
			CustomSslHealthIndicator(SslInfo sslInfo) {
				super(sslInfo);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class CompositePropagationFactoryTests {
	@Test
	void supportsJoin() {
		Propagation.Factory supported = Mockito.mock(Propagation.Factory.class);
		given(supported.supportsJoin()).willReturn(true);
		given(supported.get()).willReturn(new DummyPropagation('a'));
		Propagation.Factory unsupported = Mockito.mock(Propagation.Factory.class);
		given(unsupported.supportsJoin()).willReturn(false);
		given(unsupported.get()).willReturn(new DummyPropagation('a'));
		CompositePropagationFactory factory = new CompositePropagationFactory(List.of(supported), List.of(unsupported));
		assertThat(factory.supportsJoin()).isFalse();
	}
	@Test
	void requires128BitTraceId() {
		Propagation.Factory required = Mockito.mock(Propagation.Factory.class);
		given(required.requires128BitTraceId()).willReturn(true);
		given(required.get()).willReturn(new DummyPropagation('a'));
		Propagation.Factory notRequired = Mockito.mock(Propagation.Factory.class);
		given(notRequired.requires128BitTraceId()).willReturn(false);
		given(notRequired.get()).willReturn(new DummyPropagation('a'));
		CompositePropagationFactory factory = new CompositePropagationFactory(List.of(required), List.of(notRequired));
		assertThat(factory.requires128BitTraceId()).isTrue();
	}
	@Nested
	class CompositePropagationTests {
		@Test
		void keys() {
			CompositePropagationFactory factory = new CompositePropagationFactory(List.of(field('a')),
					List.of(field('b')));
			Propagation<String> propagation = factory.get();
			assertThat(propagation.keys()).containsExactly('a', 'b');
		}
		@Test
		void inject() {
			CompositePropagationFactory factory = new CompositePropagationFactory(List.of(field('a'), field('b')),
					List.of(field('c')));
			Propagation<String> propagation = factory.get();
			TraceContext context = context();
			Map<String, String> request = new HashMap<>();
			propagation.injector(new MapSetter()).inject(context, request);
			assertThat(request).containsOnly(entry('a', 'a-value'), entry('b', 'b-value'));
		}
		@Test
		void extractorWhenDelegateExtractsReturnsExtraction() {
			CompositePropagationFactory factory = new CompositePropagationFactory(Collections.emptyList(),
					List.of(field('a'), field('b')));
			Propagation<String> propagation = factory.get();
			Map<String, String> request = Map.of('a', 'a-value', 'b', 'b-value');
			TraceContextOrSamplingFlags context = propagation.extractor(new MapGetter()).extract(request);
			assertThat(context.context().extra()).containsExactly('a');
		}
		@Test
		void extractorWhenWhenNoExtractorMatchesReturnsEmptyContext() {
			CompositePropagationFactory factory = new CompositePropagationFactory(Collections.emptyList(),
					Collections.emptyList());
			Propagation<String> propagation = factory.get();
			Map<String, String> request = Collections.emptyMap();
			TraceContextOrSamplingFlags context = propagation.extractor(new MapGetter()).extract(request);
			assertThat(context.context()).isNull();
		}
		private static TraceContext context() {
			return TraceContext.newBuilder().traceId(1).spanId(2).build();
		}
		private static DummyPropagation field(String field) {
			return new DummyPropagation(field);
		}
	}
	private static final class MapSetter implements Propagation.Setter<Map<String, String>, String> {
		@Override
		public void put(Map<String, String> request, String key, String value) {
			request.put(key, value);
		}
	}
	private static final class MapGetter implements Propagation.Getter<Map<String, String>, String> {
		@Override
		public String get(Map<String, String> request, String key) {
			return request.get(key);
		}
	}
	private static final class DummyPropagation extends Propagation.Factory implements Propagation<String> {
		private final String field;
		private DummyPropagation(String field) {
			this.field = field;
		}
		@Override
		public Propagation<String> get() {
			return this;
		}
		@Override
		public List<String> keys() {
			return List.of(this.field);
		}
		@Override
		public <R> TraceContext.Injector<R> injector(Propagation.Setter<R, String> setter) {
			return (traceContext, request) -> setter.put(request, this.field, this.field + '-value');
		}
		@Override
		public <R> TraceContext.Extractor<R> extractor(Propagation.Getter<R, String> getter) {
			return (request) -> {
				TraceContext context = TraceContext.newBuilder().traceId(1).spanId(2).addExtra(this.field).build();
				return TraceContextOrSamplingFlags.create(context);
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class SpanExportersTests {
	@Test
	void ofList() {
		SpanExporter spanExporter1 = mock(SpanExporter.class);
		SpanExporter spanExporter2 = mock(SpanExporter.class);
		SpanExporters spanExporters = SpanExporters.of(List.of(spanExporter1, spanExporter2));
		assertThat(spanExporters).containsExactly(spanExporter1, spanExporter2);
		assertThat(spanExporters.list()).containsExactly(spanExporter1, spanExporter2);
	}
	@Test
	void ofArray() {
		SpanExporter spanExporter1 = mock(SpanExporter.class);
		SpanExporter spanExporter2 = mock(SpanExporter.class);
		SpanExporters spanExporters = SpanExporters.of(spanExporter1, spanExporter2);
		assertThat(spanExporters).containsExactly(spanExporter1, spanExporter2);
		assertThat(spanExporters.list()).containsExactly(spanExporter1, spanExporter2);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@ForkedClassPath
class BaggagePropagationIntegrationTests {
	private static final String COUNTRY_CODE = 'country-code';
	private static final String BUSINESS_PROCESS = 'bp';
	@BeforeEach
	@AfterEach
	void setup() {
		MDC.clear();
	}
	@ParameterizedTest
	@EnumSource(AutoConfig.class)
	void shouldSetEntriesToMdcFromSpanWithBaggage(AutoConfig autoConfig) {
		autoConfig.get().run((context) -> {
			Tracer tracer = tracer(context);
			Span span = createSpan(tracer);
			BaggageManager baggageManager = baggageManager(context);
			assertThatTracingContextIsInitialized(autoConfig);
			try (Tracer.SpanInScope scope = tracer.withSpan(span.start())) {
				assertMdcValue('traceId', span.context().traceId());
				try (BaggageInScope fo = baggageManager.createBaggageInScope(span.context(), COUNTRY_CODE, 'FO');
						BaggageInScope alm = baggageManager.createBaggageInScope(span.context(), BUSINESS_PROCESS,
								'ALM')) {
					assertMdcValue(COUNTRY_CODE, 'FO');
					assertMdcValue(BUSINESS_PROCESS, 'ALM');
				}
			}
			finally {
				span.end();
			}
			assertThatMdcContainsUnsetTraceId(autoConfig);
			assertUnsetMdc(COUNTRY_CODE);
			assertUnsetMdc(BUSINESS_PROCESS);
		});
	}
	@ParameterizedTest
	@EnumSource(AutoConfig.class)
	void shouldRemoveEntriesFromMdcForNullSpan(AutoConfig autoConfig) {
		autoConfig.get().run((context) -> {
			Tracer tracer = tracer(context);
			Span span = createSpan(tracer);
			BaggageManager baggageManager = baggageManager(context);
			assertThatTracingContextIsInitialized(autoConfig);
			try (Tracer.SpanInScope scope = tracer.withSpan(span.start())) {
				assertMdcValue('traceId', span.context().traceId());
				try (BaggageInScope fo = baggageManager.createBaggageInScope(span.context(), COUNTRY_CODE, 'FO')) {
					assertMdcValue(COUNTRY_CODE, 'FO');
					try (Tracer.SpanInScope scope2 = tracer.withSpan(null)) {
						assertThatMdcContainsUnsetTraceId(autoConfig);
						assertUnsetMdc(COUNTRY_CODE);
					}
					assertMdcValue('traceId', span.context().traceId());
					assertMdcValue(COUNTRY_CODE, 'FO');
				}
			}
			finally {
				span.end();
			}
			assertThatMdcContainsUnsetTraceId(autoConfig);
			assertUnsetMdc(COUNTRY_CODE);
		});
	}
	private Span createSpan(Tracer tracer) {
		return tracer.nextSpan().name('span');
	}
	private Tracer tracer(ApplicationContext context) {
		return context.getBean(Tracer.class);
	}
	private BaggageManager baggageManager(ApplicationContext context) {
		return context.getBean(BaggageManager.class);
	}
	private void assertThatTracingContextIsInitialized(AutoConfig autoConfig) {
		if (autoConfig.isOtel()) {
			assertThat(Context.current()).isEqualTo(Context.root());
		}
	}
	private void assertThatMdcContainsUnsetTraceId(AutoConfig autoConfig) {
		boolean eitherOtelOrBrave = autoConfig.isOtel() || autoConfig.isBrave();
		assertThat(eitherOtelOrBrave).isTrue();
		if (autoConfig.isOtel()) {
			ThrowingConsumer<String> isNull = (traceId) -> assertThat(traceId).isNull();
			ThrowingConsumer<String> isZero = (traceId) -> assertThat(traceId)
				.isEqualTo('00000000000000000000000000000000');
			assertThat(MDC.get('traceId')).satisfiesAnyOf(isNull, isZero);
		}
		if (autoConfig.isBrave()) {
			assertThat(MDC.get('traceId')).isNull();
		}
	}
	private void assertUnsetMdc(String key) {
		assertThat(MDC.get(key)).as('MDC[%s]', key).isNull();
	}
	private void assertMdcValue(String key, String expected) {
		assertThat(MDC.get(key)).as('MDC[%s]', key).isEqualTo(expected);
	}
	enum AutoConfig implements Supplier<ApplicationContextRunner> {
		BRAVE_DEFAULT {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner()
					.withConfiguration(AutoConfigurations.of(BraveAutoConfiguration.class))
					.withPropertyValues('management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		OTEL_DEFAULT {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner().withInitializer(new OtelApplicationContextInitializer())
					.withConfiguration(AutoConfigurations.of(OpenTelemetryAutoConfiguration.class,
							org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryTracingAutoConfiguration.class))
					.withPropertyValues('management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		BRAVE_W3C {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner()
					.withConfiguration(AutoConfigurations.of(BraveAutoConfiguration.class))
					.withPropertyValues('management.tracing.propagation.type=W3C',
							'management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		OTEL_W3C {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner().withInitializer(new OtelApplicationContextInitializer())
					.withConfiguration(AutoConfigurations.of(OpenTelemetryAutoConfiguration.class,
							org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryTracingAutoConfiguration.class))
					.withPropertyValues('management.tracing.propagation.type=W3C',
							'management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		BRAVE_B3 {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner()
					.withConfiguration(AutoConfigurations.of(BraveAutoConfiguration.class))
					.withPropertyValues('management.tracing.propagation.type=B3',
							'management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		BRAVE_B3_MULTI {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner()
					.withConfiguration(AutoConfigurations.of(BraveAutoConfiguration.class))
					.withPropertyValues('management.tracing.propagation.type=B3_MULTI',
							'management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		OTEL_B3 {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner().withInitializer(new OtelApplicationContextInitializer())
					.withConfiguration(AutoConfigurations.of(OpenTelemetryAutoConfiguration.class,
							org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryTracingAutoConfiguration.class))
					.withPropertyValues('management.tracing.propagation.type=B3',
							'management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		OTEL_B3_MULTI {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner().withInitializer(new OtelApplicationContextInitializer())
					.withConfiguration(AutoConfigurations.of(OpenTelemetryAutoConfiguration.class,
							org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryTracingAutoConfiguration.class))
					.withPropertyValues('management.tracing.propagation.type=B3_MULTI',
							'management.tracing.baggage.remote-fields=x-vcap-request-id,country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		},
		BRAVE_LOCAL_FIELDS {
			@Override
			public ApplicationContextRunner get() {
				return new ApplicationContextRunner()
					.withConfiguration(AutoConfigurations.of(BraveAutoConfiguration.class))
					.withPropertyValues('management.tracing.baggage.local-fields=country-code,bp',
							'management.tracing.baggage.correlation.fields=country-code,bp');
			}
		};
		boolean isOtel() {
			return name().startsWith('OTEL_');
		}
		boolean isBrave() {
			return name().startsWith('BRAVE_');
		}
	}
	static class OtelApplicationContextInitializer
			implements ApplicationContextInitializer<ConfigurableApplicationContext> {
		@Override
		public void initialize(ConfigurableApplicationContext applicationContext) {
			applicationContext.addApplicationListener(new OpenTelemetryEventPublisherBeansApplicationListener());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@ForkedClassPath
class OpenTelemetryEventPublishingContextWrapperBeansTestExecutionListenerIntegrationTests {
	private final ContextStorage parent = mock(ContextStorage.class);
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void wrapperIsInstalled() throws Exception {
		Class<?> wrappersClass = Class.forName('io.opentelemetry.context.ContextStorageWrappers');
		Method getWrappersMethod = wrappersClass.getDeclaredMethod('getWrappers');
		getWrappersMethod.setAccessible(true);
		List<Function> wrappers = (List<Function>) getWrappersMethod.invoke(null);
		assertThat(wrappers).anyMatch((function) -> function.apply(this.parent) instanceof Storage);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class BraveAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(BraveAutoConfiguration.class));
	@Test
	void shouldSupplyDefaultBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(BraveAutoConfiguration.class);
			assertThat(context).hasSingleBean(Tracing.class);
			assertThat(context).hasSingleBean(Tracer.class);
			assertThat(context).hasSingleBean(CurrentTraceContext.class);
			assertThat(context).hasSingleBean(Factory.class);
			assertThat(context).hasSingleBean(Sampler.class);
			assertThat(context).hasSingleBean(BraveTracer.class);
			assertThat(context).hasSingleBean(Propagation.Factory.class);
			assertThat(context).hasSingleBean(BaggagePropagation.FactoryBuilder.class);
			assertThat(context).hasSingleBean(BraveTracer.class);
			assertThat(context).hasSingleBean(CompositeSpanHandler.class);
			assertThat(context).hasSingleBean(SpanCustomizer.class);
			assertThat(context).hasSingleBean(BraveSpanCustomizer.class);
		});
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasBean('customTracing');
			assertThat(context).hasSingleBean(Tracing.class);
			assertThat(context).hasBean('customTracer');
			assertThat(context).hasSingleBean(Tracer.class);
			assertThat(context).hasBean('customCurrentTraceContext');
			assertThat(context).hasSingleBean(CurrentTraceContext.class);
			assertThat(context).hasBean('customFactory');
			assertThat(context).hasSingleBean(Factory.class);
			assertThat(context).hasBean('customSampler');
			assertThat(context).hasSingleBean(Sampler.class);
			assertThat(context).hasBean('customMicrometerTracer');
			assertThat(context).hasSingleBean(io.micrometer.tracing.Tracer.class);
			assertThat(context).hasBean('customBraveBaggageManager');
			assertThat(context).hasSingleBean(BraveBaggageManager.class);
			assertThat(context).hasBean('customCompositeSpanHandler');
			assertThat(context).hasSingleBean(CompositeSpanHandler.class);
			assertThat(context).hasBean('customSpanCustomizer');
			assertThat(context).hasSingleBean(SpanCustomizer.class);
			assertThat(context).hasBean('customMicrometerSpanCustomizer');
			assertThat(context).hasSingleBean(io.micrometer.tracing.SpanCustomizer.class);
		});
	}
	@Test
	void shouldSupplyMicrometerBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(BraveTracer.class));
	}
	@Test
	void shouldNotSupplyBeansIfBraveIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('brave'))
			.run((context) -> assertThat(context).doesNotHaveBean(BraveAutoConfiguration.class));
	}
	@Test
	void shouldNotSupplyBeansIfMicrometerIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer'))
			.run((context) -> assertThat(context).doesNotHaveBean(BraveAutoConfiguration.class));
	}
	@Test
	void shouldSupplyW3CPropagationFactoryByDefault() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasBean('propagationFactory');
			Factory factory = context.getBean(Factory.class);
			Stream<Class<?>> injectors = getInjectors(factory).stream().map(Object::getClass);
			assertThat(injectors).containsExactly(W3CPropagation.class);
			assertThat(context).hasSingleBean(BaggagePropagation.FactoryBuilder.class);
		});
	}
	@Test
	void shouldSupplyB3PropagationFactoryViaProperty() {
		this.contextRunner.withPropertyValues('management.tracing.propagation.type=B3').run((context) -> {
			assertThat(context).hasBean('propagationFactory');
			Factory factory = context.getBean(Factory.class);
			List<Factory> injectors = getInjectors(factory);
			assertThat(injectors).extracting(Factory::toString).containsExactly('B3Propagation');
			assertThat(context).hasSingleBean(BaggagePropagation.FactoryBuilder.class);
		});
	}
	@Test
	void shouldUseB3SingleWithParentWhenPropagationTypeIsB3() {
		this.contextRunner
			.withPropertyValues('management.tracing.propagation.type=B3', 'management.tracing.sampling.probability=1.0')
			.run((context) -> {
				Propagation<String> propagation = context.getBean(Factory.class).get();
				Tracer tracer = context.getBean(Tracing.class).tracer();
				Span child;
				Span parent = tracer.nextSpan().name('parent');
				try (Tracer.SpanInScope ignored = tracer.withSpanInScope(parent.start())) {
					child = tracer.nextSpan().name('child');
					child.start().finish();
				}
				finally {
					parent.finish();
				}
				Map<String, String> map = new HashMap<>();
				TraceContext childContext = child.context();
				propagation.injector(this::injectToMap).inject(childContext, map);
				assertThat(map).containsExactly(Map.entry('b3', '%s-%s-1-%s'.formatted(childContext.traceIdString(),
						childContext.spanIdString(), childContext.parentIdString())));
			});
	}
	@Test
	void shouldNotSupplyCorrelationScopeDecoratorIfBaggageDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean('correlationScopeDecorator'));
	}
	@Test
	void shouldSupplyW3CWithoutBaggageByDefaultIfBaggageDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.enabled=false').run((context) -> {
			assertThat(context).hasBean('propagationFactory');
			Factory factory = context.getBean(Factory.class);
			Stream<Class<?>> injectors = getInjectors(factory).stream().map(Object::getClass);
			assertThat(injectors).containsExactly(W3CPropagation.class);
			assertThat(context).doesNotHaveBean(BaggagePropagation.FactoryBuilder.class);
		});
	}
	@Test
	void shouldSupplyB3WithoutBaggageIfBaggageDisabledAndB3Picked() {
		this.contextRunner
			.withPropertyValues('management.tracing.baggage.enabled=false', 'management.tracing.propagation.type=B3')
			.run((context) -> {
				assertThat(context).hasBean('propagationFactory');
				Factory factory = context.getBean(Factory.class);
				List<Factory> injectors = getInjectors(factory);
				assertThat(injectors).extracting(Factory::toString).containsExactly('B3Propagation');
				assertThat(context).doesNotHaveBean(BaggagePropagation.FactoryBuilder.class);
			});
	}
	@Test
	void shouldNotApplyCorrelationFieldsIfBaggageCorrelationDisabled() {
		this.contextRunner
			.withPropertyValues('management.tracing.baggage.correlation.enabled=false',
					'management.tracing.baggage.correlation.fields=alpha,bravo')
			.run((context) -> {
				ScopeDecorator scopeDecorator = context.getBean(ScopeDecorator.class);
				assertThat(scopeDecorator)
					.extracting('fields', InstanceOfAssertFactories.array(SingleCorrelationField[].class))
					.hasSize(2);
			});
	}
	@Test
	void shouldApplyCorrelationFieldsIfBaggageCorrelationEnabled() {
		this.contextRunner
			.withPropertyValues('management.tracing.baggage.correlation.enabled=true',
					'management.tracing.baggage.correlation.fields=alpha,bravo')
			.run((context) -> {
				ScopeDecorator scopeDecorator = context.getBean(ScopeDecorator.class);
				assertThat(scopeDecorator)
					.extracting('fields', InstanceOfAssertFactories.array(SingleCorrelationField[].class))
					.hasSize(4);
			});
	}
	@Test
	void shouldSupplyMdcCorrelationScopeDecoratorIfBaggageCorrelationDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.correlation.enabled=false')
			.run((context) -> assertThat(context).hasBean('mdcCorrelationScopeDecoratorBuilder'));
	}
	@Test
	void shouldHave128BitTraceId() {
		this.contextRunner.run((context) -> {
			Tracing tracing = context.getBean(Tracing.class);
			Span span = tracing.tracer().nextSpan();
			assertThat(span.context().traceIdString()).hasSize(32);
		});
	}
	@Test
	void shouldNotSupportJoinedSpansByDefault() {
		this.contextRunner.run((context) -> {
			Tracing tracing = context.getBean(Tracing.class);
			Span parentSpan = tracing.tracer().nextSpan();
			Span childSpan = tracing.tracer().joinSpan(parentSpan.context());
			assertThat(childSpan.context().traceIdString()).isEqualTo(parentSpan.context().traceIdString());
			assertThat(childSpan.context().spanIdString()).isNotEqualTo(parentSpan.context().spanIdString());
			assertThat(childSpan.context().parentIdString()).isEqualTo(parentSpan.context().spanIdString());
			assertThat(parentSpan.context().parentIdString()).isNull();
		});
	}
	@Test
	void shouldSupportJoinedSpansIfB3UsedAndBackendSupportsIt() {
		this.contextRunner
			.withPropertyValues('management.tracing.propagation.type=B3',
					'management.tracing.brave.span-joining-supported=true')
			.run((context) -> {
				Tracing tracing = context.getBean(Tracing.class);
				Span parentSpan = tracing.tracer().nextSpan();
				Span childSpan = tracing.tracer().joinSpan(parentSpan.context());
				assertThat(childSpan.context().traceIdString()).isEqualTo(parentSpan.context().traceIdString());
				assertThat(childSpan.context().spanIdString()).isEqualTo(parentSpan.context().spanIdString());
				assertThat(childSpan.context().parentIdString()).isNull();
				assertThat(parentSpan.context().parentIdString()).isNull();
			});
	}
	@Test
	void shouldFailIfSupportJoinedSpansIsEnabledAndW3cIsChosenAsType() {
		this.contextRunner
			.withPropertyValues('management.tracing.propagation.type=W3C',
					'management.tracing.brave.span-joining-supported=true')
			.run((context) -> assertThatException().isThrownBy(() -> context.getBean(Tracing.class))
				.havingRootCause()
				.isExactlyInstanceOf(IncompatibleConfigurationException.class)
				.withMessage('The following configuration properties have incompatible values: '
						+ '[management.tracing.propagation.type, management.tracing.brave.span-joining-supported]'));
	}
	@Test
	void shouldFailIfSupportJoinedSpansIsEnabledAndW3cIsChosenAsConsume() {
		this.contextRunner.withPropertyValues('management.tracing.propagation.produce=B3',
				'management.tracing.propagation.consume=W3C', 'management.tracing.brave.span-joining-supported=true')
			.run((context) -> assertThatException().isThrownBy(() -> context.getBean(Tracing.class))
				.havingRootCause()
				.isExactlyInstanceOf(IncompatibleConfigurationException.class)
				.withMessage('The following configuration properties have incompatible values: '
						+ '[management.tracing.propagation.consume, management.tracing.brave.span-joining-supported]'));
	}
	@Test
	void shouldFailIfSupportJoinedSpansIsEnabledAndW3cIsChosenAsProduce() {
		this.contextRunner.withPropertyValues('management.tracing.propagation.consume=B3',
				'management.tracing.propagation.produce=W3C', 'management.tracing.brave.span-joining-supported=true')
			.run((context) -> assertThatException().isThrownBy(() -> context.getBean(Tracing.class))
				.havingRootCause()
				.isExactlyInstanceOf(IncompatibleConfigurationException.class)
				.withMessage('The following configuration properties have incompatible values: '
						+ '[management.tracing.propagation.produce, management.tracing.brave.span-joining-supported]'));
	}
	@Test
	@SuppressWarnings('rawtypes')
	void compositeSpanHandlerShouldBeFirstSpanHandler() {
		this.contextRunner.withUserConfiguration(SpanHandlerConfiguration.class).run((context) -> {
			Tracing tracing = context.getBean(Tracing.class);
			assertThat(tracing).extracting('tracer.spanHandler.delegate.handlers')
				.asInstanceOf(InstanceOfAssertFactories.array(SpanHandler[].class))
				.extracting((handler) -> (Class) handler.getClass())
				.containsExactly(CompositeSpanHandler.class, AdditionalSpanHandler.class);
		});
	}
	@Test
	void compositeSpanHandlerUsesFilterPredicateAndReportersInOrder() {
		this.contextRunner.withUserConfiguration(CompositeSpanHandlerComponentsConfiguration.class).run((context) -> {
			CompositeSpanHandlerComponentsConfiguration components = context
				.getBean(CompositeSpanHandlerComponentsConfiguration.class);
			CompositeSpanHandler composite = context.getBean(CompositeSpanHandler.class);
			assertThat(composite).extracting('spanFilters')
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.containsExactly(components.filter1, components.filter2);
			assertThat(composite).extracting('filters')
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.containsExactly(components.predicate2, components.predicate1);
			assertThat(composite).extracting('reporters')
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.containsExactly(components.reporter1, components.reporter3, components.reporter2);
		});
	}
	@Test
	void shouldDisablePropagationIfTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.enabled=false').run((context) -> {
			assertThat(context).hasSingleBean(Factory.class);
			Factory factory = context.getBean(Factory.class);
			Propagation<String> propagation = factory.get();
			assertThat(propagation.keys()).isEmpty();
		});
	}
	@Test
	void shouldConfigureTaggedFields() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.tag-fields=t1').run((context) -> {
			BraveTracer braveTracer = context.getBean(BraveTracer.class);
			assertThat(braveTracer).extracting('braveBaggageManager.tagFields')
				.asInstanceOf(InstanceOfAssertFactories.list(String.class))
				.containsExactly('t1');
		});
	}
	@Test
	void keysAreSetInBaggage() {
		this.contextRunner
			.withConfiguration(
					AutoConfigurations.of(ObservationAutoConfiguration.class, MicrometerTracingAutoConfiguration.class))
			.withPropertyValues('management.tracing.baggage.remote-fields=f1,f2')
			.run((context) -> {
				BraveTracer braveTracer = context.getBean(BraveTracer.class);
				ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
				Observation observation = Observation.start('o1', observationRegistry)
					.lowCardinalityKeyValue('f1', 'v1')
					.highCardinalityKeyValue('f2', 'v2');
				Map<String, String> baggage = braveTracer.getAllBaggage();
				assertThat(baggage).isEmpty();
				try (Scope ignore = observation.openScope()) {
					baggage = braveTracer.getAllBaggage();
					assertThat(baggage).containsAllEntriesOf(Map.of('f1', 'v1', 'f2', 'v2'));
				}
				baggage = braveTracer.getAllBaggage();
				assertThat(baggage).isEmpty();
			});
	}
	private void injectToMap(Map<String, String> map, String key, String value) {
		map.put(key, value);
	}
	private List<Factory> getInjectors(Factory factory) {
		assertThat(factory).as('factory').isNotNull();
		if (factory instanceof CompositePropagationFactory compositePropagationFactory) {
			return compositePropagationFactory.getInjectors().toList();
		}
		Assertions.fail('Expected CompositePropagationFactory, found %s'.formatted(factory.getClass()));
		throw new AssertionError('Unreachable');
	}
	@Configuration(proxyBeanMethods = false)
	static class CompositeSpanHandlerComponentsConfiguration {
		private final SpanFilter filter1 = mock(SpanFilter.class);
		private final SpanFilter filter2 = mock(SpanFilter.class);
		private final SpanExportingPredicate predicate1 = mock(SpanExportingPredicate.class);
		private final SpanExportingPredicate predicate2 = mock(SpanExportingPredicate.class);
		private final SpanReporter reporter1 = mock(SpanReporter.class);
		private final SpanReporter reporter2 = mock(SpanReporter.class);
		private final SpanReporter reporter3 = mock(SpanReporter.class);
		@Bean
		@Order(1)
		SpanFilter filter1() {
			return this.filter1;
		}
		@Bean
		@Order(2)
		SpanFilter filter2() {
			return this.filter2;
		}
		@Bean
		@Order(2)
		SpanExportingPredicate predicate1() {
			return this.predicate1;
		}
		@Bean
		@Order(1)
		SpanExportingPredicate predicate2() {
			return this.predicate2;
		}
		@Bean
		@Order(1)
		SpanReporter reporter1() {
			return this.reporter1;
		}
		@Bean
		@Order(3)
		SpanReporter reporter2() {
			return this.reporter2;
		}
		@Bean
		@Order(2)
		SpanReporter reporter3() {
			return this.reporter3;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SpanHandlerConfiguration {
		@Bean
		SpanHandler additionalSpanHandler() {
			return new AdditionalSpanHandler();
		}
		static class AdditionalSpanHandler extends SpanHandler {
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		Tracing customTracing() {
			return mock(Tracing.class);
		}
		@Bean
		Tracer customTracer() {
			return mock(Tracer.class);
		}
		@Bean
		CurrentTraceContext customCurrentTraceContext() {
			return mock(CurrentTraceContext.class);
		}
		@Bean
		Factory customFactory() {
			return mock(Factory.class);
		}
		@Bean
		Sampler customSampler() {
			return mock(Sampler.class);
		}
		@Bean
		io.micrometer.tracing.Tracer customMicrometerTracer() {
			return mock(io.micrometer.tracing.Tracer.class);
		}
		@Bean
		BraveBaggageManager customBraveBaggageManager() {
			return mock(BraveBaggageManager.class);
		}
		@Bean
		CompositeSpanHandler customCompositeSpanHandler() {
			return new CompositeSpanHandler(Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
		}
		@Bean
		SpanCustomizer customSpanCustomizer() {
			return mock(SpanCustomizer.class);
		}
		@Bean
		io.micrometer.tracing.SpanCustomizer customMicrometerSpanCustomizer() {
			return mock(io.micrometer.tracing.SpanCustomizer.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class SpanProcessorsTests {
	@Test
	void ofList() {
		SpanProcessor spanProcessor1 = mock(SpanProcessor.class);
		SpanProcessor spanProcessor2 = mock(SpanProcessor.class);
		SpanProcessors spanProcessors = SpanProcessors.of(List.of(spanProcessor1, spanProcessor2));
		assertThat(spanProcessors).containsExactly(spanProcessor1, spanProcessor2);
		assertThat(spanProcessors.list()).containsExactly(spanProcessor1, spanProcessor2);
	}
	@Test
	void ofArray() {
		SpanProcessor spanProcessor1 = mock(SpanProcessor.class);
		SpanProcessor spanProcessor2 = mock(SpanProcessor.class);
		SpanProcessors spanProcessors = SpanProcessors.of(spanProcessor1, spanProcessor2);
		assertThat(spanProcessors).containsExactly(spanProcessor1, spanProcessor2);
		assertThat(spanProcessors.list()).containsExactly(spanProcessor1, spanProcessor2);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class ZipkinConfigurationsBraveConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DefaultEncodingConfiguration.class, BraveConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AsyncZipkinSpanHandler.class));
	}
	@Test
	void shouldNotSupplySpanHandlerIfReporterIsMissing() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(AsyncZipkinSpanHandler.class));
	}
	@Test
	void shouldNotSupplyIfZipkinReporterBraveIsNotOnClasspath() {
		// Note: Technically, Brave can work without zipkin-reporter. For example,
		// WavefrontSpanHandler doesn"t require this to operate. If we remove this
		// dependency enforcement when WavefrontSpanHandler is in use, we can resolve
		// micrometer-metrics/tracing#509. We also need this for any configuration that
		// uses senders defined in the Spring Boot source tree, such as HttpSender.
		this.contextRunner.withClassLoader(new FilteredClassLoader('zipkin2.reporter.brave'))
			.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(AsyncZipkinSpanHandler.class));
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class, CustomConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('customAsyncZipkinSpanHandler');
				assertThat(context).hasSingleBean(AsyncZipkinSpanHandler.class);
			});
	}
	@Test
	void shouldSupplyAsyncZipkinSpanHandlerWithCustomSpanHandler() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class, CustomSpanHandlerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('customSpanHandler');
				assertThat(context).hasSingleBean(AsyncZipkinSpanHandler.class);
			});
	}
	@Test
	void shouldNotSupplyAsyncZipkinSpanHandlerIfGlobalTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.enabled=false')
			.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(AsyncZipkinSpanHandler.class));
	}
	@Test
	void shouldNotSupplyAsyncZipkinSpanHandlerIfZipkinTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.zipkin.tracing.export.enabled=false')
			.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(AsyncZipkinSpanHandler.class));
	}
	@Test
	void shouldUseCustomEncoderBean() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class, CustomEncoderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(AsyncZipkinSpanHandler.class);
				assertThat(context.getBean(AsyncZipkinSpanHandler.class)).extracting('spanReporter.encoder')
					.isInstanceOf(CustomMutableSpanEncoder.class)
					.extracting('encoding')
					.isEqualTo(Encoding.JSON);
			});
	}
	@Test
	void shouldUseCustomEncodingBean() {
		this.contextRunner
			.withUserConfiguration(SenderConfiguration.class, CustomEncodingConfiguration.class,
					CustomEncoderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(AsyncZipkinSpanHandler.class);
				assertThat(context.getBean(AsyncZipkinSpanHandler.class)).extracting('encoding')
					.isEqualTo(Encoding.PROTO3);
			});
	}
	@Test
	void shouldUseDefaultThrowableTagBean() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class).run((context) -> {
			@SuppressWarnings('unchecked')
			BytesEncoder<MutableSpan> encoder = context.getBean(BytesEncoder.class);
			MutableSpan span = createTestSpan();
			// default tag key name is 'error', and doesn"t overwrite
			assertThat(new String(encoder.encode(span), StandardCharsets.UTF_8)).isEqualTo(
					'{\'traceId\':\'0000000000000001\',\'id\':\'0000000000000001\',\'tags\':{\'error\':\'true\'}}');
		});
	}
	@Test
	void shouldUseCustomThrowableTagBean() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class, CustomThrowableTagConfiguration.class)
			.run((context) -> {
				@SuppressWarnings('unchecked')
				BytesEncoder<MutableSpan> encoder = context.getBean(BytesEncoder.class);
				MutableSpan span = createTestSpan();
				// The custom throwable parser doesn"t use the key 'error' we can see both
				assertThat(new String(encoder.encode(span), StandardCharsets.UTF_8)).isEqualTo(
						'{\'traceId\':\'0000000000000001\',\'id\':\'0000000000000001\',\'tags\':{\'error\':\'true\',\'exception\':\'ice cream\'}}');
			});
	}
	private MutableSpan createTestSpan() {
		MutableSpan span = new MutableSpan();
		span.traceId('1');
		span.id('1');
		span.tag('error', 'true');
		span.error(new RuntimeException('ice cream'));
		return span;
	}
	@Configuration(proxyBeanMethods = false)
	private static final class SenderConfiguration {
		@Bean
		BytesMessageSender sender(Encoding encoding) {
			return new NoopSender(encoding);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		AsyncZipkinSpanHandler customAsyncZipkinSpanHandler() {
			return AsyncZipkinSpanHandler.create(new NoopSender(Encoding.JSON));
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomThrowableTagConfiguration {
		@Bean
		Tag<Throwable> throwableTag() {
			return new Tag<>('exception') {
				@Override
				protected String parseValue(Throwable throwable, TraceContext traceContext) {
					return throwable.getMessage();
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomSpanHandlerConfiguration {
		@Bean
		SpanHandler customSpanHandler() {
			return mock(SpanHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomEncodingConfiguration {
		@Bean
		Encoding encoding() {
			return Encoding.PROTO3;
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomEncoderConfiguration {
		@Bean
		BytesEncoder<MutableSpan> encoder(Encoding encoding) {
			return new CustomMutableSpanEncoder(encoding);
		}
	}
	private record CustomMutableSpanEncoder(Encoding encoding) implements BytesEncoder<MutableSpan> {
		@Override
		public int sizeInBytes(MutableSpan span) {
			throw new UnsupportedOperationException();
		}
		@Override
		public byte[] encode(MutableSpan span) {
			throw new UnsupportedOperationException();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class ZipkinAutoConfigurationIntegrationTests {
	@Test
	void zipkinsUseOfRestTemplateDoesNotCauseACycle() {
		configure(new WebApplicationContextRunner())
			.withConfiguration(AutoConfigurations.of(RestTemplateAutoConfiguration.class))
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void zipkinsUseOfWebClientDoesNotCauseACycle() {
		configure(new ReactiveWebApplicationContextRunner())
			.withConfiguration(AutoConfigurations.of(WebClientAutoConfiguration.class))
			.run((context) -> assertThat(context).hasNotFailed());
	}
	<SELF extends AbstractApplicationContextRunner<SELF, C, A>, C extends ConfigurableApplicationContext, A extends ApplicationContextAssertProvider<C>> AbstractApplicationContextRunner<SELF, C, A> configure(
			AbstractApplicationContextRunner<SELF, ?, ?> runner) {
		return runner
			.withConfiguration(AutoConfigurations.of(MicrometerTracingAutoConfiguration.class,
					ObservationAutoConfiguration.class, BraveAutoConfiguration.class, ZipkinAutoConfiguration.class,
					HttpClientObservationsAutoConfiguration.class, MetricsAutoConfiguration.class,
					SimpleMetricsExportAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(URLConnectionSender.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class ZipkinConfigurationsOpenTelemetryConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DefaultEncodingConfiguration.class, OpenTelemetryConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class, CustomEncoderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ZipkinSpanExporter.class);
				assertThat(context).hasBean('customSpanEncoder');
			});
	}
	@Test
	void shouldNotSupplyZipkinSpanExporterIfSenderIsMissing() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(ZipkinSpanExporter.class);
			assertThat(context).hasBean('spanBytesEncoder');
		});
	}
	@Test
	void shouldNotSupplyZipkinSpanExporterIfNotOnClasspath() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.opentelemetry.exporter.zipkin'))
			.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(ZipkinSpanExporter.class);
				assertThat(context).doesNotHaveBean('spanBytesEncoder');
			});
	}
	@Test
	void shouldBackOffIfZipkinIsNotOnClasspath() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('zipkin2.Span'))
			.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(ZipkinSpanExporter.class);
				assertThat(context).doesNotHaveBean('spanBytesEncoder');
			});
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasBean('customZipkinSpanExporter');
			assertThat(context).hasSingleBean(ZipkinSpanExporter.class);
		});
	}
	@Test
	void shouldNotSupplyZipkinSpanExporterIfGlobalTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.enabled=false')
			.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ZipkinSpanExporter.class));
	}
	@Test
	void shouldNotSupplyZipkinSpanExporterIfZipkinTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.zipkin.tracing.export.enabled=false')
			.withUserConfiguration(SenderConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ZipkinSpanExporter.class));
	}
	@Test
	void shouldUseCustomEncoderBean() {
		this.contextRunner.withUserConfiguration(SenderConfiguration.class, CustomEncoderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ZipkinSpanExporter.class);
				assertThat(context).hasBean('customSpanEncoder');
				assertThat(context.getBean(ZipkinSpanExporter.class)).extracting('encoder')
					.isInstanceOf(CustomSpanEncoder.class)
					.extracting('encoding')
					.isEqualTo(Encoding.JSON);
			});
	}
	@Test
	void shouldUseCustomEncodingBean() {
		this.contextRunner
			.withUserConfiguration(SenderConfiguration.class, CustomEncodingConfiguration.class,
					CustomEncoderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ZipkinSpanExporter.class);
				assertThat(context).hasBean('customSpanEncoder');
				assertThat(context.getBean(ZipkinSpanExporter.class)).extracting('encoder')
					.isInstanceOf(CustomSpanEncoder.class)
					.extracting('encoding')
					.isEqualTo(Encoding.PROTO3);
			});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomEncodingConfiguration {
		@Bean
		Encoding encoding() {
			return Encoding.PROTO3;
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class SenderConfiguration {
		@Bean
		BytesMessageSender sender(Encoding encoding) {
			return new NoopSender(encoding);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		ZipkinSpanExporter customZipkinSpanExporter() {
			return ZipkinSpanExporter.builder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomEncoderConfiguration {
		@Bean
		BytesEncoder<Span> customSpanEncoder(Encoding encoding) {
			return new CustomSpanEncoder(encoding);
		}
	}
	record CustomSpanEncoder(Encoding encoding) implements BytesEncoder<Span> {
		@Override
		public int sizeInBytes(Span span) {
			throw new UnsupportedOperationException();
		}
		@Override
		public byte[] encode(Span span) {
			throw new UnsupportedOperationException();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class TestHttpEndpointSupplier implements HttpEndpointSupplier {
	private final String url;
	private final AtomicInteger suffix = new AtomicInteger();
	TestHttpEndpointSupplier(String url) {
		this.url = url;
	}
	@Override
	public String get() {
		return this.url + '/' + this.suffix.incrementAndGet();
	}
	@Override
	public void close() {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
class NoopSender extends BytesMessageSender.Base {
	NoopSender(Encoding encoding) {
		super(encoding);
	}
	@Override
	public int messageMaxBytes() {
		return 1024;
	}
	@Override
	public void send(List<byte[]> encodedSpans) {
	}
	@Override
	public void close() throws IOException {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@TestConfiguration(proxyBeanMethods = false)
class DefaultEncodingConfiguration {
	@Bean
	@ConditionalOnMissingBean
	Encoding zipkinReporterEncoding() {
		return Encoding.JSON;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class ZipkinRestTemplateSenderTests extends ZipkinHttpSenderTests {
	private static final String ZIPKIN_URL = 'http://localhost:9411/api/v2/spans';
	private RestTemplate restTemplate;
	private MockRestServiceServer mockServer;
	@Override
	BytesMessageSender createSender() {
		this.restTemplate = new RestTemplate();
		this.mockServer = MockRestServiceServer.createServer(this.restTemplate);
		return createSender(Encoding.JSON);
	}
	BytesMessageSender createSender(Encoding encoding) {
		return createSender(HttpEndpointSuppliers.constantFactory(), encoding);
	}
	BytesMessageSender createSender(HttpEndpointSupplier.Factory endpointSupplierFactory, Encoding encoding) {
		return new ZipkinRestTemplateSender(encoding, endpointSupplierFactory, ZIPKIN_URL, this.restTemplate);
	}
	@AfterEach
	@Override
	void afterEach() throws IOException {
		super.afterEach();
		this.mockServer.verify();
	}
	@Test
	void sendShouldSendSpansToZipkin() throws IOException {
		this.mockServer.expect(requestTo(ZIPKIN_URL))
			.andExpect(method(HttpMethod.POST))
			.andExpect(content().contentType('application/json'))
			.andExpect(content().string('[span1,span2]'))
			.andRespond(withStatus(HttpStatus.ACCEPTED));
		this.sender.send(List.of(toByteArray('span1'), toByteArray('span2')));
	}
	@Test
	void sendShouldSendSpansToZipkinInProto3() throws IOException {
		this.mockServer.expect(requestTo(ZIPKIN_URL))
			.andExpect(method(HttpMethod.POST))
			.andExpect(content().contentType('application/x-protobuf'))
			.andExpect(content().string('span1span2'))
			.andRespond(withStatus(HttpStatus.ACCEPTED));
		try (BytesMessageSender sender = createSender(Encoding.PROTO3)) {
			sender.send(List.of(toByteArray('span1'), toByteArray('span2')));
		}
	}
	@Test
	void sendUsesDynamicEndpoint() throws Exception {
		this.mockServer.expect(requestTo(ZIPKIN_URL + '/1')).andRespond(withStatus(HttpStatus.ACCEPTED));
		this.mockServer.expect(requestTo(ZIPKIN_URL + '/2')).andRespond(withStatus(HttpStatus.ACCEPTED));
		try (HttpEndpointSupplier httpEndpointSupplier = new TestHttpEndpointSupplier(ZIPKIN_URL)) {
			try (BytesMessageSender sender = createSender((endpoint) -> httpEndpointSupplier, Encoding.JSON)) {
				sender.send(Collections.emptyList());
				sender.send(Collections.emptyList());
			}
		}
	}
	@Test
	void sendShouldHandleHttpFailures() {
		this.mockServer.expect(requestTo(ZIPKIN_URL))
			.andExpect(method(HttpMethod.POST))
			.andRespond(withStatus(HttpStatus.INTERNAL_SERVER_ERROR));
		assertThatException().isThrownBy(() -> this.sender.send(Collections.emptyList()))
			.withMessageContaining('500 Internal Server Error');
	}
	@Test
	void sendShouldCompressData() throws IOException {
		String uncompressed = 'a'.repeat(10000);
		// This is gzip compressed 10000 times "a"
		byte[] compressed = Base64.getDecoder()
			.decode('H4sIAAAAAAAA/+3BMQ0AAAwDIKFLj/k3UR8NcA8AAAAAAAAAAAADUsAZfeASJwAA');
		this.mockServer.expect(requestTo(ZIPKIN_URL))
			.andExpect(method(HttpMethod.POST))
			.andExpect(header('Content-Encoding', 'gzip'))
			.andExpect(content().contentType('application/json'))
			.andExpect(content().bytes(compressed))
			.andRespond(withStatus(HttpStatus.ACCEPTED));
		this.sender.send(List.of(toByteArray(uncompressed)));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class ZipkinWebClientSenderTests extends ZipkinHttpSenderTests {
	private static final Duration TIMEOUT = Duration.ofSeconds(30);
	private static ClearableDispatcher dispatcher;
	private static MockWebServer mockBackEnd;
	private static String ZIPKIN_URL;
	@BeforeAll
	static void beforeAll() throws IOException {
		dispatcher = new ClearableDispatcher();
		mockBackEnd = new MockWebServer();
		mockBackEnd.setDispatcher(dispatcher);
		mockBackEnd.start();
		ZIPKIN_URL = mockBackEnd.url('/api/v2/spans').toString();
	}
	@AfterAll
	static void afterAll() throws IOException {
		mockBackEnd.shutdown();
	}
	@Override
	@BeforeEach
	void beforeEach() {
		super.beforeEach();
		clearResponses();
		clearRequests();
	}
	@Override
	BytesMessageSender createSender() {
		return createSender(Encoding.JSON, TIMEOUT);
	}
	ZipkinWebClientSender createSender(Encoding encoding, Duration timeout) {
		return createSender(HttpEndpointSuppliers.constantFactory(), encoding, timeout);
	}
	ZipkinWebClientSender createSender(HttpEndpointSupplier.Factory endpointSupplierFactory, Encoding encoding,
			Duration timeout) {
		WebClient webClient = WebClient.builder().build();
		return new ZipkinWebClientSender(encoding, endpointSupplierFactory, ZIPKIN_URL, webClient, timeout);
	}
	@Test
	void sendShouldSendSpansToZipkin() throws IOException, InterruptedException {
		mockBackEnd.enqueue(new MockResponse());
		List<byte[]> encodedSpans = List.of(toByteArray('span1'), toByteArray('span2'));
		this.sender.send(encodedSpans);
		requestAssertions((request) -> {
			assertThat(request.getMethod()).isEqualTo('POST');
			assertThat(request.getHeader('Content-Type')).isEqualTo('application/json');
			assertThat(request.getBody().readUtf8()).isEqualTo('[span1,span2]');
		});
	}
	@Test
	void sendShouldSendSpansToZipkinInProto3() throws IOException, InterruptedException {
		mockBackEnd.enqueue(new MockResponse());
		List<byte[]> encodedSpans = List.of(toByteArray('span1'), toByteArray('span2'));
		try (BytesMessageSender sender = createSender(Encoding.PROTO3, TIMEOUT)) {
			sender.send(encodedSpans);
		}
		requestAssertions((request) -> {
			assertThat(request.getMethod()).isEqualTo('POST');
			assertThat(request.getHeader('Content-Type')).isEqualTo('application/x-protobuf');
			assertThat(request.getBody().readUtf8()).isEqualTo('span1span2');
		});
	}
	@Test
	void sendUsesDynamicEndpoint() throws Exception {
		mockBackEnd.enqueue(new MockResponse());
		mockBackEnd.enqueue(new MockResponse());
		try (HttpEndpointSupplier httpEndpointSupplier = new TestHttpEndpointSupplier(ZIPKIN_URL)) {
			try (BytesMessageSender sender = createSender((endpoint) -> httpEndpointSupplier, Encoding.JSON, TIMEOUT)) {
				sender.send(Collections.emptyList());
				sender.send(Collections.emptyList());
			}
			assertThat(mockBackEnd.takeRequest().getPath()).endsWith('/1');
			assertThat(mockBackEnd.takeRequest().getPath()).endsWith('/2');
		}
	}
	@Test
	void sendShouldHandleHttpFailures() throws InterruptedException {
		mockBackEnd.enqueue(new MockResponse().setResponseCode(500));
		assertThatException().isThrownBy(() -> this.sender.send(Collections.emptyList()))
			.withMessageContaining('500 Internal Server Error');
		requestAssertions((request) -> assertThat(request.getMethod()).isEqualTo('POST'));
	}
	@Test
	void sendShouldCompressData() throws IOException, InterruptedException {
		String uncompressed = 'a'.repeat(10000);
		// This is gzip compressed 10000 times "a"
		byte[] compressed = Base64.getDecoder()
			.decode('H4sIAAAAAAAA/+3BMQ0AAAwDIKFLj/k3UR8NcA8AAAAAAAAAAAADUsAZfeASJwAA');
		mockBackEnd.enqueue(new MockResponse());
		this.sender.send(List.of(toByteArray(uncompressed)));
		requestAssertions((request) -> {
			assertThat(request.getMethod()).isEqualTo('POST');
			assertThat(request.getHeader('Content-Type')).isEqualTo('application/json');
			assertThat(request.getHeader('Content-Encoding')).isEqualTo('gzip');
			assertThat(request.getBody().readByteArray()).isEqualTo(compressed);
		});
	}
	@Test
	void shouldTimeout() throws IOException {
		try (BytesMessageSender sender = createSender(Encoding.JSON, Duration.ofMillis(1))) {
			MockResponse response = new MockResponse().setResponseCode(200).setHeadersDelay(100, TimeUnit.MILLISECONDS);
			mockBackEnd.enqueue(response);
			assertThatException().isThrownBy(() -> sender.send(Collections.emptyList()))
				.withCauseInstanceOf(TimeoutException.class);
		}
	}
	private void requestAssertions(Consumer<RecordedRequest> assertions) throws InterruptedException {
		RecordedRequest request = mockBackEnd.takeRequest();
		assertThat(request).satisfies(assertions);
	}
	private static void clearRequests() {
		RecordedRequest request;
		do {
			try {
				request = mockBackEnd.takeRequest(0, TimeUnit.SECONDS);
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
				throw new RuntimeException(ex);
			}
		}
		while (request != null);
	}
	private static void clearResponses() {
		dispatcher.clear();
	}
	private static final class ClearableDispatcher extends QueueDispatcher {
		void clear() {
			getResponseQueue().clear();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class ZipkinConfigurationsSenderConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DefaultEncodingConfiguration.class, SenderConfiguration.class));
	private final ReactiveWebApplicationContextRunner reactiveContextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DefaultEncodingConfiguration.class, SenderConfiguration.class));
	private final WebApplicationContextRunner servletContextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DefaultEncodingConfiguration.class, SenderConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(BytesMessageSender.class);
			assertThat(context).hasSingleBean(URLConnectionSender.class);
			assertThat(context).doesNotHaveBean(ZipkinRestTemplateSender.class);
		});
	}
	@Test
	void shouldUseHttpClientIfUrlSenderIsNotAvailable() {
		this.contextRunner.withUserConfiguration(HttpClientConfiguration.class)
			.withClassLoader(new FilteredClassLoader('zipkin2.reporter.urlconnection', 'org.springframework.web.client',
					'org.springframework.web.reactive.function.client'))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(URLConnectionSender.class);
				assertThat(context).hasSingleBean(BytesMessageSender.class);
				assertThat(context).hasSingleBean(ZipkinHttpClientSender.class);
				then(context.getBean(ZipkinHttpClientBuilderCustomizer.class)).should()
					.customize(ArgumentMatchers.any());
			});
	}
	@Test
	void shouldPreferWebClientSenderIfWebApplicationIsReactiveAndUrlSenderIsNotAvailable() {
		this.reactiveContextRunner.withUserConfiguration(RestTemplateConfiguration.class, WebClientConfiguration.class)
			.withClassLoader(new FilteredClassLoader('zipkin2.reporter.urlconnection'))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(URLConnectionSender.class);
				assertThat(context).hasSingleBean(BytesMessageSender.class);
				assertThat(context).hasSingleBean(ZipkinWebClientSender.class);
				then(context.getBean(ZipkinWebClientBuilderCustomizer.class)).should()
					.customize(ArgumentMatchers.any());
			});
	}
	@Test
	void shouldPreferWebClientSenderIfWebApplicationIsServletAndUrlSenderIsNotAvailable() {
		this.servletContextRunner.withUserConfiguration(RestTemplateConfiguration.class, WebClientConfiguration.class)
			.withClassLoader(new FilteredClassLoader('zipkin2.reporter.urlconnection'))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(URLConnectionSender.class);
				assertThat(context).hasSingleBean(BytesMessageSender.class);
				assertThat(context).hasSingleBean(ZipkinWebClientSender.class);
			});
	}
	@Test
	void shouldPreferWebClientInNonWebApplicationAndUrlConnectionSenderIsNotAvailable() {
		this.contextRunner.withUserConfiguration(RestTemplateConfiguration.class, WebClientConfiguration.class)
			.withClassLoader(new FilteredClassLoader('zipkin2.reporter.urlconnection'))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(URLConnectionSender.class);
				assertThat(context).hasSingleBean(BytesMessageSender.class);
				assertThat(context).hasSingleBean(ZipkinWebClientSender.class);
			});
	}
	@Test
	void willUseRestTemplateInNonWebApplicationIfUrlConnectionSenderAndWebClientAreNotAvailable() {
		this.contextRunner.withUserConfiguration(RestTemplateConfiguration.class)
			.withClassLoader(new FilteredClassLoader(URLConnectionSender.class, WebClient.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(URLConnectionSender.class);
				assertThat(context).hasSingleBean(BytesMessageSender.class);
				assertThat(context).hasSingleBean(ZipkinRestTemplateSender.class);
			});
	}
	@Test
	void willUseRestTemplateInServletWebApplicationIfUrlConnectionSenderAndWebClientNotAvailable() {
		this.servletContextRunner.withUserConfiguration(RestTemplateConfiguration.class)
			.withClassLoader(new FilteredClassLoader(URLConnectionSender.class, WebClient.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(URLConnectionSender.class);
				assertThat(context).hasSingleBean(BytesMessageSender.class);
				assertThat(context).hasSingleBean(ZipkinRestTemplateSender.class);
			});
	}
	@Test
	void willUseRestTemplateInReactiveWebApplicationIfUrlConnectionSenderAndWebClientAreNotAvailable() {
		this.reactiveContextRunner.withUserConfiguration(RestTemplateConfiguration.class)
			.withClassLoader(new FilteredClassLoader(URLConnectionSender.class, WebClient.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(URLConnectionSender.class);
				assertThat(context).hasSingleBean(BytesMessageSender.class);
				assertThat(context).hasSingleBean(ZipkinRestTemplateSender.class);
			});
	}
	@Test
	void shouldNotUseWebClientSenderIfNoBuilderIsAvailable() {
		this.reactiveContextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(ZipkinWebClientSender.class);
			assertThat(context).hasSingleBean(BytesMessageSender.class);
			assertThat(context).hasSingleBean(URLConnectionSender.class);
		});
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasBean('customSender');
			assertThat(context).hasSingleBean(BytesMessageSender.class);
		});
	}
	@Test
	void shouldApplyZipkinRestTemplateBuilderCustomizers() throws IOException {
		try (MockWebServer mockWebServer = new MockWebServer()) {
			mockWebServer.enqueue(new MockResponse().setResponseCode(204));
			this.reactiveContextRunner
				.withPropertyValues('management.zipkin.tracing.endpoint=' + mockWebServer.url('/'))
				.withUserConfiguration(RestTemplateConfiguration.class)
				.withClassLoader(new FilteredClassLoader(URLConnectionSender.class, WebClient.class))
				.run((context) -> {
					assertThat(context).hasSingleBean(ZipkinRestTemplateSender.class);
					ZipkinRestTemplateSender sender = context.getBean(ZipkinRestTemplateSender.class);
					sender.send(List.of('spans'.getBytes(StandardCharsets.UTF_8)));
					RecordedRequest recordedRequest = mockWebServer.takeRequest(1, TimeUnit.SECONDS);
					assertThat(recordedRequest).isNotNull();
					assertThat(recordedRequest.getHeaders().get('x-dummy')).isEqualTo('dummy');
				});
		}
	}
	@Test
	void shouldUseCustomHttpEndpointSupplierFactory() {
		this.contextRunner.withUserConfiguration(CustomHttpEndpointSupplierFactoryConfiguration.class)
			.run((context) -> assertThat(context.getBean(URLConnectionSender.class))
				.extracting('delegate.endpointSupplier')
				.isInstanceOf(CustomHttpEndpointSupplier.class));
	}
	@Test
	void shouldUseCustomHttpEndpointSupplierFactoryWhenReactive() {
		this.reactiveContextRunner.withUserConfiguration(WebClientConfiguration.class)
			.withClassLoader(new FilteredClassLoader(URLConnectionSender.class))
			.withUserConfiguration(CustomHttpEndpointSupplierFactoryConfiguration.class)
			.run((context) -> assertThat(context.getBean(ZipkinWebClientSender.class)).extracting('endpointSupplier')
				.isInstanceOf(CustomHttpEndpointSupplier.class));
	}
	@Test
	void shouldUseCustomHttpEndpointSupplierFactoryWhenRestTemplate() {
		this.contextRunner.withUserConfiguration(RestTemplateConfiguration.class)
			.withClassLoader(new FilteredClassLoader(URLConnectionSender.class, WebClient.class))
			.withUserConfiguration(CustomHttpEndpointSupplierFactoryConfiguration.class)
			.run((context) -> assertThat(context.getBean(ZipkinRestTemplateSender.class)).extracting('endpointSupplier')
				.isInstanceOf(CustomHttpEndpointSupplier.class));
	}
	@Configuration(proxyBeanMethods = false)
	private static final class RestTemplateConfiguration {
		@Bean
		ZipkinRestTemplateBuilderCustomizer zipkinRestTemplateBuilderCustomizer() {
			return new DummyZipkinRestTemplateBuilderCustomizer();
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class WebClientConfiguration {
		@Bean
		ZipkinWebClientBuilderCustomizer webClientBuilder() {
			return mock(ZipkinWebClientBuilderCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class HttpClientConfiguration {
		@Bean
		ZipkinHttpClientBuilderCustomizer httpClientBuilderCustomizer() {
			return mock(ZipkinHttpClientBuilderCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		BytesMessageSender customSender() {
			return mock(BytesMessageSender.class);
		}
	}
	private static final class DummyZipkinRestTemplateBuilderCustomizer implements ZipkinRestTemplateBuilderCustomizer {
		@Override
		public RestTemplateBuilder customize(RestTemplateBuilder restTemplateBuilder) {
			return restTemplateBuilder.defaultHeader('x-dummy', 'dummy');
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomHttpEndpointSupplierFactoryConfiguration {
		@Bean
		HttpEndpointSupplier.Factory httpEndpointSupplier() {
			return new CustomHttpEndpointSupplierFactory();
		}
	}
	private static final class CustomHttpEndpointSupplierFactory implements HttpEndpointSupplier.Factory {
		@Override
		public HttpEndpointSupplier create(String endpoint) {
			return new CustomHttpEndpointSupplier(endpoint);
		}
	}
	private record CustomHttpEndpointSupplier(String endpoint) implements HttpEndpointSupplier {
		@Override
		public String get() {
			return this.endpoint;
		}
		@Override
		public void close() {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class ZipkinAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ZipkinAutoConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(Encoding.class)
			.hasSingleBean(PropertiesZipkinConnectionDetails.class));
	}
	@Test
	void shouldNotSupplyBeansIfZipkinReporterIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('zipkin2.reporter'))
			.run((context) -> assertThat(context).doesNotHaveBean(Encoding.class));
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasBean('customEncoding');
			assertThat(context).hasSingleBean(Encoding.class);
		});
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesZipkinConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner
			.withBean(ZipkinConnectionDetails.class, () -> new FixedZipkinConnectionDetails('http://localhost'))
			.run((context) -> assertThat(context).hasSingleBean(ZipkinConnectionDetails.class)
				.doesNotHaveBean(PropertiesZipkinConnectionDetails.class));
	}
	@Test
	void shouldWorkWithoutSenders() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader('zipkin2.reporter.urlconnection', 'org.springframework.web.client',
					'org.springframework.web.reactive.function.client'))
			.run((context) -> assertThat(context).hasNotFailed());
	}
	private static final class FixedZipkinConnectionDetails implements ZipkinConnectionDetails {
		private final String spanEndpoint;
		private FixedZipkinConnectionDetails(String spanEndpoint) {
			this.spanEndpoint = spanEndpoint;
		}
		@Override
		public String getSpanEndpoint() {
			return this.spanEndpoint;
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		Encoding customEncoding() {
			return Encoding.PROTO3;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@ClassPathExclusions('spring-web-*.jar')
class ZipkinHttpClientSenderTests extends ZipkinHttpSenderTests {
	private MockWebServer mockBackEnd;
	private String zipkinUrl;
	@Override
	@BeforeEach
	void beforeEach() {
		this.mockBackEnd = new MockWebServer();
		try {
			this.mockBackEnd.start();
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
		this.zipkinUrl = this.mockBackEnd.url('/api/v2/spans').toString();
		super.beforeEach();
	}
	@Override
	void afterEach() throws IOException {
		super.afterEach();
		this.mockBackEnd.shutdown();
	}
	@Override
	BytesMessageSender createSender() {
		return createSender(Encoding.JSON, Duration.ofSeconds(10));
	}
	ZipkinHttpClientSender createSender(Encoding encoding, Duration timeout) {
		return createSender(HttpEndpointSuppliers.constantFactory(), encoding, timeout);
	}
	ZipkinHttpClientSender createSender(HttpEndpointSupplier.Factory endpointSupplierFactory, Encoding encoding,
			Duration timeout) {
		HttpClient httpClient = HttpClient.newBuilder().connectTimeout(timeout).build();
		return new ZipkinHttpClientSender(encoding, endpointSupplierFactory, this.zipkinUrl, httpClient, timeout);
	}
	@Test
	void sendShouldSendSpansToZipkin() throws IOException, InterruptedException {
		this.mockBackEnd.enqueue(new MockResponse());
		List<byte[]> encodedSpans = List.of(toByteArray('span1'), toByteArray('span2'));
		this.sender.send(encodedSpans);
		requestAssertions((request) -> {
			assertThat(request.getMethod()).isEqualTo('POST');
			assertThat(request.getHeader('Content-Type')).isEqualTo('application/json');
			assertThat(request.getBody().readUtf8()).isEqualTo('[span1,span2]');
		});
	}
	@Test
	void sendShouldSendSpansToZipkinInProto3() throws IOException, InterruptedException {
		this.mockBackEnd.enqueue(new MockResponse());
		List<byte[]> encodedSpans = List.of(toByteArray('span1'), toByteArray('span2'));
		try (BytesMessageSender sender = createSender(Encoding.PROTO3, Duration.ofSeconds(10))) {
			sender.send(encodedSpans);
		}
		requestAssertions((request) -> {
			assertThat(request.getMethod()).isEqualTo('POST');
			assertThat(request.getHeader('Content-Type')).isEqualTo('application/x-protobuf');
			assertThat(request.getBody().readUtf8()).isEqualTo('span1span2');
		});
	}
	@Test
	void sendUsesDynamicEndpoint() throws Exception {
		this.mockBackEnd.enqueue(new MockResponse());
		this.mockBackEnd.enqueue(new MockResponse());
		try (TestHttpEndpointSupplier httpEndpointSupplier = new TestHttpEndpointSupplier(this.zipkinUrl)) {
			try (BytesMessageSender sender = createSender((endpoint) -> httpEndpointSupplier, Encoding.JSON,
					Duration.ofSeconds(10))) {
				sender.send(Collections.emptyList());
				sender.send(Collections.emptyList());
			}
			assertThat(this.mockBackEnd.takeRequest().getPath()).endsWith('/1');
			assertThat(this.mockBackEnd.takeRequest().getPath()).endsWith('/2');
		}
	}
	@Test
	void sendShouldHandleHttpFailures() throws InterruptedException {
		this.mockBackEnd.enqueue(new MockResponse().setResponseCode(500));
		assertThatException().isThrownBy(() -> this.sender.send(Collections.emptyList()))
			.withMessageContaining('Expected HTTP status 2xx, got 500');
		requestAssertions((request) -> assertThat(request.getMethod()).isEqualTo('POST'));
	}
	@Test
	void sendShouldCompressData() throws IOException, InterruptedException {
		String uncompressed = 'a'.repeat(10000);
		// This is gzip compressed 10000 times "a"
		byte[] compressed = Base64.getDecoder()
			.decode('H4sIAAAAAAAA/+3BMQ0AAAwDIKFLj/k3UR8NcA8AAAAAAAAAAAADUsAZfeASJwAA');
		this.mockBackEnd.enqueue(new MockResponse());
		this.sender.send(List.of(toByteArray(uncompressed)));
		requestAssertions((request) -> {
			assertThat(request.getMethod()).isEqualTo('POST');
			assertThat(request.getHeader('Content-Type')).isEqualTo('application/json');
			assertThat(request.getHeader('Content-Encoding')).isEqualTo('gzip');
			assertThat(request.getBody().readByteArray()).isEqualTo(compressed);
		});
	}
	@Test
	void shouldTimeout() throws IOException {
		try (BytesMessageSender sender = createSender(Encoding.JSON, Duration.ofMillis(1))) {
			MockResponse response = new MockResponse().setResponseCode(200).setHeadersDelay(100, TimeUnit.MILLISECONDS);
			this.mockBackEnd.enqueue(response);
			assertThatIOException().isThrownBy(() -> sender.send(Collections.emptyList()))
				.withMessageContaining('timed out');
		}
	}
	private void requestAssertions(Consumer<RecordedRequest> assertions) throws InterruptedException {
		RecordedRequest request = this.mockBackEnd.takeRequest();
		assertThat(request).satisfies(assertions);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
abstract class ZipkinHttpSenderTests {
	protected BytesMessageSender sender;
	abstract BytesMessageSender createSender();
	@BeforeEach
	void beforeEach() {
		this.sender = createSender();
	}
	@AfterEach
	void afterEach() throws IOException {
		this.sender.close();
	}
	@Test
	void sendShouldThrowIfCloseWasCalled() throws IOException {
		this.sender.close();
		assertThatExceptionOfType(ClosedSenderException.class)
			.isThrownBy(() -> this.sender.send(Collections.emptyList()));
	}
	protected byte[] toByteArray(String input) {
		return input.getBytes(StandardCharsets.UTF_8);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class OnEnabledTracingConditionTests {
	@Test
	void shouldMatchIfNoPropertyIsSet() {
		OnEnabledTracingCondition condition = new OnEnabledTracingCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(mockConditionContext(), mockMetadata(''));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage()).isEqualTo('@ConditionalOnEnabledTracing tracing is enabled by default');
	}
	@Test
	void shouldNotMatchIfGlobalPropertyIsFalse() {
		OnEnabledTracingCondition condition = new OnEnabledTracingCondition();
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(Map.of('management.tracing.enabled', 'false')), mockMetadata(''));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage()).isEqualTo('@ConditionalOnEnabledTracing management.tracing.enabled is false');
	}
	@Test
	void shouldMatchIfGlobalPropertyIsTrue() {
		OnEnabledTracingCondition condition = new OnEnabledTracingCondition();
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(Map.of('management.tracing.enabled', 'true')), mockMetadata(''));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage()).isEqualTo('@ConditionalOnEnabledTracing management.tracing.enabled is true');
	}
	@Test
	void shouldNotMatchIfExporterPropertyIsFalse() {
		OnEnabledTracingCondition condition = new OnEnabledTracingCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(
				mockConditionContext(Map.of('management.zipkin.tracing.export.enabled', 'false')),
				mockMetadata('zipkin'));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledTracing management.zipkin.tracing.export.enabled is false');
	}
	@Test
	void shouldMatchIfExporterPropertyIsTrue() {
		OnEnabledTracingCondition condition = new OnEnabledTracingCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(
				mockConditionContext(Map.of('management.zipkin.tracing.export.enabled', 'true')),
				mockMetadata('zipkin'));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledTracing management.zipkin.tracing.export.enabled is true');
	}
	@Test
	void exporterPropertyShouldOverrideGlobalPropertyIfTrue() {
		OnEnabledTracingCondition condition = new OnEnabledTracingCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(mockConditionContext(
				Map.of('management.tracing.enabled', 'false', 'management.zipkin.tracing.export.enabled', 'true')),
				mockMetadata('zipkin'));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledTracing management.zipkin.tracing.export.enabled is true');
	}
	@Test
	void exporterPropertyShouldOverrideGlobalPropertyIfFalse() {
		OnEnabledTracingCondition condition = new OnEnabledTracingCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(mockConditionContext(
				Map.of('management.tracing.enabled', 'true', 'management.zipkin.tracing.export.enabled', 'false')),
				mockMetadata('zipkin'));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledTracing management.zipkin.tracing.export.enabled is false');
	}
	private ConditionContext mockConditionContext() {
		return mockConditionContext(Collections.emptyMap());
	}
	private ConditionContext mockConditionContext(Map<String, String> properties) {
		ConditionContext context = mock(ConditionContext.class);
		MockEnvironment environment = new MockEnvironment();
		properties.forEach(environment::setProperty);
		given(context.getEnvironment()).willReturn(environment);
		return context;
	}
	private AnnotatedTypeMetadata mockMetadata(String exporter) {
		AnnotatedTypeMetadata metadata = mock(AnnotatedTypeMetadata.class);
		given(metadata.getAnnotationAttributes(ConditionalOnEnabledTracing.class.getName()))
			.willReturn(Map.of('value', exporter));
		return metadata;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.prometheus;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class LazyTracingSpanContextSupplierTests {
	private final Tracer tracer = mock(Tracer.class);
	private final ObjectProvider<Tracer> objectProvider = new ObjectProvider<>() {
		@Override
		public Tracer getObject() throws BeansException {
			return LazyTracingSpanContextSupplierTests.this.tracer;
		}
		@Override
		public Tracer getObject(Object... args) throws BeansException {
			return LazyTracingSpanContextSupplierTests.this.tracer;
		}
		@Override
		public Tracer getIfAvailable() throws BeansException {
			return LazyTracingSpanContextSupplierTests.this.tracer;
		}
		@Override
		public Tracer getIfUnique() throws BeansException {
			return LazyTracingSpanContextSupplierTests.this.tracer;
		}
	};
	private final org.springframework.boot.actuate.autoconfigure.tracing.prometheus.PrometheusSimpleclientExemplarsAutoConfiguration.LazyTracingSpanContextSupplier spanContextSupplier = new org.springframework.boot.actuate.autoconfigure.tracing.prometheus.PrometheusSimpleclientExemplarsAutoConfiguration.LazyTracingSpanContextSupplier(
			this.objectProvider);
	@Test
	void whenCurrentSpanIsNullThenSpanIdIsNull() {
		assertThat(this.spanContextSupplier.getSpanId()).isNull();
	}
	@Test
	void whenCurrentSpanIsNullThenTraceIdIsNull() {
		assertThat(this.spanContextSupplier.getTraceId()).isNull();
	}
	@Test
	void whenCurrentSpanIsNullThenSampledIsFalse() {
		assertThat(this.spanContextSupplier.isSampled()).isFalse();
	}
	@Test
	void whenCurrentSpanHasSpanIdThenSpanIdIsFromSpan() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.spanId()).willReturn('span-id');
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContextSupplier.getSpanId()).isEqualTo('span-id');
	}
	@Test
	void whenCurrentSpanHasTraceIdThenTraceIdIsFromSpan() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.traceId()).willReturn('trace-id');
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContextSupplier.getTraceId()).isEqualTo('trace-id');
	}
	@Test
	void whenCurrentSpanHasNoSpanIdThenSpanIdIsNull() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContextSupplier.getSpanId()).isNull();
	}
	@Test
	void whenCurrentSpanHasNoTraceIdThenTraceIdIsNull() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContextSupplier.getTraceId()).isNull();
	}
	@Test
	void whenCurrentSpanIsSampledThenSampledIsTrue() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.sampled()).willReturn(true);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContextSupplier.isSampled()).isTrue();
	}
	@Test
	void whenCurrentSpanIsNotSampledThenSampledIsFalse() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.sampled()).willReturn(false);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContextSupplier.isSampled()).isFalse();
	}
	@Test
	void whenCurrentSpanHasDeferredSamplingThenSampledIsFalse() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.sampled()).willReturn(null);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContextSupplier.isSampled()).isFalse();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.prometheus;
/**
class PrometheusExemplarsAutoConfigurationTests {
	private static final Pattern BUCKET_TRACE_INFO_PATTERN = Pattern.compile(
			'^test_observation_seconds_bucket\\{error=\'none\',le=\'.+\'} 1 # \\{span_id=\'(\\p{XDigit}+)\',trace_id=\'(\\p{XDigit}+)\'} .+$');
	private static final Pattern COUNT_TRACE_INFO_PATTERN = Pattern.compile(
			'^test_observation_seconds_count\\{error=\'none\'} 1 # \\{span_id=\'(\\p{XDigit}+)\',trace_id=\'(\\p{XDigit}+)\'} .+$');
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('management.tracing.sampling.probability=1.0',
				'management.metrics.distribution.percentiles-histogram.all=true')
		.with(MetricsRun.limitedTo(PrometheusMetricsExportAutoConfiguration.class))
		.withConfiguration(
				AutoConfigurations.of(PrometheusExemplarsAutoConfiguration.class, ObservationAutoConfiguration.class,
						BraveAutoConfiguration.class, MicrometerTracingAutoConfiguration.class));
	@Test
	void shouldNotSupplyBeansIfPrometheusSupportIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.prometheus.metrics.tracer'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanContext.class));
	}
	@Test
	void shouldNotSupplyBeansIfMicrometerTracingIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.tracing'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanContext.class));
	}
	@Test
	void shouldSupplyCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SpanContext.class)
				.getBean(SpanContext.class)
				.isSameAs(CustomConfiguration.SPAN_CONTEXT));
	}
	@Test
	void prometheusOpenMetricsOutputWithoutExemplarsOnHistogramCount() {
		this.contextRunner.withPropertyValues(
				'management.prometheus.metrics.export.properties.io.prometheus.exporter.exemplarsOnAllMetricTypes=false')
			.run((context) -> {
				assertThat(context).hasSingleBean(SpanContext.class);
				ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
				Observation.start('test.observation', observationRegistry).stop();
				PrometheusMeterRegistry prometheusMeterRegistry = context.getBean(PrometheusMeterRegistry.class);
				String openMetricsOutput = prometheusMeterRegistry.scrape(OpenMetricsTextFormatWriter.CONTENT_TYPE);
				assertThat(openMetricsOutput).contains('test_observation_seconds_bucket');
				assertThat(openMetricsOutput).containsOnlyOnce('test_observation_seconds_count');
				assertThat(StringUtils.countOccurrencesOf(openMetricsOutput, 'span_id')).isEqualTo(1);
				assertThat(StringUtils.countOccurrencesOf(openMetricsOutput, 'trace_id')).isEqualTo(1);
				Optional<TraceInfo> bucketTraceInfo = openMetricsOutput.lines()
					.filter((line) -> line.contains('test_observation_seconds_bucket') && line.contains('span_id'))
					.map(BUCKET_TRACE_INFO_PATTERN::matcher)
					.flatMap(Matcher::results)
					.map((matchResult) -> new TraceInfo(matchResult.group(2), matchResult.group(1)))
					.findFirst();
				assertThat(bucketTraceInfo).isNotEmpty();
			});
	}
	@Test
	void prometheusOpenMetricsOutputShouldContainExemplars() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(SpanContext.class);
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('test.observation', observationRegistry).stop();
			PrometheusMeterRegistry prometheusMeterRegistry = context.getBean(PrometheusMeterRegistry.class);
			String openMetricsOutput = prometheusMeterRegistry.scrape(OpenMetricsTextFormatWriter.CONTENT_TYPE);
			assertThat(openMetricsOutput).contains('test_observation_seconds_bucket');
			assertThat(openMetricsOutput).containsOnlyOnce('test_observation_seconds_count');
			assertThat(StringUtils.countOccurrencesOf(openMetricsOutput, 'span_id')).isEqualTo(2);
			assertThat(StringUtils.countOccurrencesOf(openMetricsOutput, 'trace_id')).isEqualTo(2);
			Optional<TraceInfo> bucketTraceInfo = openMetricsOutput.lines()
				.filter((line) -> line.contains('test_observation_seconds_bucket') && line.contains('span_id'))
				.map(BUCKET_TRACE_INFO_PATTERN::matcher)
				.flatMap(Matcher::results)
				.map((matchResult) -> new TraceInfo(matchResult.group(2), matchResult.group(1)))
				.findFirst();
			Optional<TraceInfo> counterTraceInfo = openMetricsOutput.lines()
				.filter((line) -> line.contains('test_observation_seconds_count') && line.contains('span_id'))
				.map(COUNT_TRACE_INFO_PATTERN::matcher)
				.flatMap(Matcher::results)
				.map((matchResult) -> new TraceInfo(matchResult.group(2), matchResult.group(1)))
				.findFirst();
			assertThat(bucketTraceInfo).isNotEmpty().contains(counterTraceInfo.orElse(null));
		});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		static final SpanContext SPAN_CONTEXT = mock(SpanContext.class);
		@Bean
		SpanContext customSpanContext() {
			return SPAN_CONTEXT;
		}
	}
	private record TraceInfo(String traceId, String spanId) {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.prometheus;
/**
@SuppressWarnings('removal')
class PrometheusSimpleclientExemplarsAutoConfigurationTests {
	private static final Pattern BUCKET_TRACE_INFO_PATTERN = Pattern.compile(
			'^test_observation_seconds_bucket\\{error=\'none\',le=\'.+\'} 1.0 # \\{span_id=\'(\\p{XDigit}+)\',trace_id=\'(\\p{XDigit}+)\'} .+$');
	private static final Pattern COUNTER_TRACE_INFO_PATTERN = Pattern.compile(
			'^test_observation_seconds_count\\{error=\'none\'} 1.0 # \\{span_id=\'(\\p{XDigit}+)\',trace_id=\'(\\p{XDigit}+)\'} .+$');
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('management.tracing.sampling.probability=1.0',
				'management.metrics.distribution.percentiles-histogram.all=true')
		.with(MetricsRun.limitedTo())
		.withConfiguration(AutoConfigurations.of(PrometheusSimpleclientMetricsExportAutoConfiguration.class,
				PrometheusSimpleclientExemplarsAutoConfiguration.class, ObservationAutoConfiguration.class,
				BraveAutoConfiguration.class, MicrometerTracingAutoConfiguration.class));
	@Test
	void shouldNotSupplyBeansIfPrometheusSupportIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.prometheus.client.exemplars'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanContextSupplier.class));
	}
	@Test
	void shouldNotSupplyBeansIfMicrometerTracingIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.tracing'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanContextSupplier.class));
	}
	@Test
	void shouldSupplyCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SpanContextSupplier.class)
				.getBean(SpanContextSupplier.class)
				.isSameAs(CustomConfiguration.SUPPLIER));
	}
	@Test
	@SuppressWarnings('deprecation')
	void prometheusOpenMetricsOutputShouldContainExemplars() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(SpanContextSupplier.class);
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('test.observation', observationRegistry).stop();
			io.micrometer.prometheus.PrometheusMeterRegistry prometheusMeterRegistry = context
				.getBean(io.micrometer.prometheus.PrometheusMeterRegistry.class);
			String openMetricsOutput = prometheusMeterRegistry.scrape(TextFormat.CONTENT_TYPE_OPENMETRICS_100);
			assertThat(openMetricsOutput).contains('test_observation_seconds_bucket');
			assertThat(openMetricsOutput).containsOnlyOnce('test_observation_seconds_count');
			assertThat(StringUtils.countOccurrencesOf(openMetricsOutput, 'span_id')).isEqualTo(2);
			assertThat(StringUtils.countOccurrencesOf(openMetricsOutput, 'trace_id')).isEqualTo(2);
			Optional<TraceInfo> bucketTraceInfo = openMetricsOutput.lines()
				.filter((line) -> line.contains('test_observation_seconds_bucket') && line.contains('span_id'))
				.map(BUCKET_TRACE_INFO_PATTERN::matcher)
				.flatMap(Matcher::results)
				.map((matchResult) -> new TraceInfo(matchResult.group(2), matchResult.group(1)))
				.findFirst();
			Optional<TraceInfo> counterTraceInfo = openMetricsOutput.lines()
				.filter((line) -> line.contains('test_observation_seconds_count') && line.contains('span_id'))
				.map(COUNTER_TRACE_INFO_PATTERN::matcher)
				.flatMap(Matcher::results)
				.map((matchResult) -> new TraceInfo(matchResult.group(2), matchResult.group(1)))
				.findFirst();
			assertThat(bucketTraceInfo).isNotEmpty().contains(counterTraceInfo.orElse(null));
		});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		static final SpanContextSupplier SUPPLIER = mock(SpanContextSupplier.class);
		@Bean
		SpanContextSupplier customSpanContextSupplier() {
			return SUPPLIER;
		}
	}
	private record TraceInfo(String traceId, String spanId) {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.prometheus;
/**
class LazyTracingSpanContextTests {
	private final Tracer tracer = mock(Tracer.class);
	private final ObjectProvider<Tracer> objectProvider = new ObjectProvider<>() {
		@Override
		public Tracer getObject() throws BeansException {
			return LazyTracingSpanContextTests.this.tracer;
		}
		@Override
		public Tracer getObject(Object... args) throws BeansException {
			return LazyTracingSpanContextTests.this.tracer;
		}
		@Override
		public Tracer getIfAvailable() throws BeansException {
			return LazyTracingSpanContextTests.this.tracer;
		}
		@Override
		public Tracer getIfUnique() throws BeansException {
			return LazyTracingSpanContextTests.this.tracer;
		}
	};
	private final LazyTracingSpanContext spanContext = new LazyTracingSpanContext(this.objectProvider);
	@Test
	void whenCurrentSpanIsNullThenSpanIdIsNull() {
		assertThat(this.spanContext.getCurrentSpanId()).isNull();
	}
	@Test
	void whenCurrentSpanIsNullThenTraceIdIsNull() {
		assertThat(this.spanContext.getCurrentTraceId()).isNull();
	}
	@Test
	void whenCurrentSpanIsNullThenSampledIsFalse() {
		assertThat(this.spanContext.isCurrentSpanSampled()).isFalse();
	}
	@Test
	void whenCurrentSpanHasSpanIdThenSpanIdIsFromSpan() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.spanId()).willReturn('span-id');
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContext.getCurrentSpanId()).isEqualTo('span-id');
	}
	@Test
	void whenCurrentSpanHasTraceIdThenTraceIdIsFromSpan() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.traceId()).willReturn('trace-id');
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContext.getCurrentTraceId()).isEqualTo('trace-id');
	}
	@Test
	void whenCurrentSpanHasNoSpanIdThenSpanIdIsNull() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContext.getCurrentSpanId()).isNull();
	}
	@Test
	void whenCurrentSpanHasNoTraceIdThenTraceIdIsNull() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContext.getCurrentTraceId()).isNull();
	}
	@Test
	void whenCurrentSpanIsSampledThenSampledIsTrue() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.sampled()).willReturn(true);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContext.isCurrentSpanSampled()).isTrue();
	}
	@Test
	void whenCurrentSpanIsNotSampledThenSampledIsFalse() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.sampled()).willReturn(false);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContext.isCurrentSpanSampled()).isFalse();
	}
	@Test
	void whenCurrentSpanHasDeferredSamplingThenSampledIsFalse() {
		Span span = mock(Span.class);
		given(this.tracer.currentSpan()).willReturn(span);
		TraceContext traceContext = mock(TraceContext.class);
		given(traceContext.sampled()).willReturn(null);
		given(span.context()).willReturn(traceContext);
		assertThat(this.spanContext.isCurrentSpanSampled()).isFalse();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class LocalBaggageFieldsTests {
	@Test
	void extractFromBuilder() {
		FactoryBuilder builder = createBuilder();
		builder.add(BaggagePropagationConfig.SingleBaggageField.remote(BaggageField.create('remote-field-1')));
		builder.add(BaggagePropagationConfig.SingleBaggageField.remote(BaggageField.create('remote-field-2')));
		builder.add(BaggagePropagationConfig.SingleBaggageField.local(BaggageField.create('local-field-1')));
		builder.add(BaggagePropagationConfig.SingleBaggageField.local(BaggageField.create('local-field-2')));
		LocalBaggageFields fields = LocalBaggageFields.extractFrom(builder);
		assertThat(fields.asList()).containsExactlyInAnyOrder('local-field-1', 'local-field-2');
	}
	@Test
	void empty() {
		assertThat(LocalBaggageFields.empty().asList()).isEmpty();
	}
	private static FactoryBuilder createBuilder() {
		return BaggagePropagation.newFactoryBuilder(new Factory() {
			@Override
			public Propagation<String> get() {
				return null;
			}
		});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class TracingPropertiesTests {
	@Test
	void propagationTypeShouldOverrideProduceTypes() {
		TracingProperties.Propagation propagation = new TracingProperties.Propagation();
		propagation.setProduce(List.of(TracingProperties.Propagation.PropagationType.W3C));
		propagation.setType(List.of(TracingProperties.Propagation.PropagationType.B3));
		assertThat(propagation.getEffectiveProducedTypes())
			.containsExactly(TracingProperties.Propagation.PropagationType.B3);
	}
	@Test
	void propagationTypeShouldOverrideConsumeTypes() {
		TracingProperties.Propagation propagation = new TracingProperties.Propagation();
		propagation.setConsume(List.of(TracingProperties.Propagation.PropagationType.W3C));
		propagation.setType(List.of(TracingProperties.Propagation.PropagationType.B3));
		assertThat(propagation.getEffectiveConsumedTypes())
			.containsExactly(TracingProperties.Propagation.PropagationType.B3);
	}
	@Test
	void getEffectiveConsumeTypes() {
		TracingProperties.Propagation propagation = new TracingProperties.Propagation();
		propagation.setConsume(List.of(TracingProperties.Propagation.PropagationType.W3C));
		assertThat(propagation.getEffectiveConsumedTypes())
			.containsExactly(TracingProperties.Propagation.PropagationType.W3C);
	}
	@Test
	void getEffectiveProduceTypes() {
		TracingProperties.Propagation propagation = new TracingProperties.Propagation();
		propagation.setProduce(List.of(TracingProperties.Propagation.PropagationType.W3C));
		assertThat(propagation.getEffectiveProducedTypes())
			.containsExactly(TracingProperties.Propagation.PropagationType.W3C);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
class OtlpTracingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(OtlpTracingAutoConfiguration.class));
	private final ApplicationContextRunner tracingDisabledContextRunner = this.contextRunner
		.withPropertyValues('management.tracing.enabled=false');
	@Test
	void shouldNotSupplyBeansIfPropertyIsNotSet() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(OtlpHttpSpanExporter.class));
	}
	@Test
	void shouldNotSupplyBeansIfGrpcTransportIsEnabledButPropertyIsNotSet() {
		this.contextRunner.withPropertyValues('management.otlp.tracing.transport=grpc')
			.run((context) -> assertThat(context).doesNotHaveBean(OtlpGrpcSpanExporter.class));
	}
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.withPropertyValues('management.otlp.tracing.endpoint=http://localhost:4318/v1/traces')
			.run((context) -> assertThat(context).hasSingleBean(OtlpHttpSpanExporter.class)
				.hasSingleBean(SpanExporter.class));
	}
	@Test
	void shouldSupplyBeansIfGrpcTransportIsEnabled() {
		this.contextRunner
			.withPropertyValues('management.otlp.tracing.endpoint=http://localhost:4317/v1/traces',
					'management.otlp.tracing.transport=grpc')
			.run((context) -> assertThat(context).hasSingleBean(OtlpGrpcSpanExporter.class)
				.hasSingleBean(SpanExporter.class));
	}
	@Test
	void shouldNotSupplyBeansIfGlobalTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(SpanExporter.class));
	}
	@Test
	void shouldNotSupplyBeansIfOtlpTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.otlp.tracing.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(SpanExporter.class));
	}
	@Test
	void shouldNotSupplyBeansIfTracingBridgeIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.tracing'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanExporter.class));
	}
	@Test
	void shouldNotSupplyBeansIfOtelSdkIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.opentelemetry.sdk'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanExporter.class));
	}
	@Test
	void shouldNotSupplyBeansIfOtelApiIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.opentelemetry.api'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanExporter.class));
	}
	@Test
	void shouldNotSupplyBeansIfExporterIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.opentelemetry.exporter'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpanExporter.class));
	}
	@Test
	void shouldBackOffWhenCustomHttpExporterIsDefined() {
		this.contextRunner.withUserConfiguration(CustomHttpExporterConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customOtlpHttpSpanExporter')
				.hasSingleBean(SpanExporter.class));
	}
	@Test
	void shouldBackOffWhenCustomGrpcExporterIsDefined() {
		this.contextRunner.withUserConfiguration(CustomGrpcExporterConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customOtlpGrpcSpanExporter')
				.hasSingleBean(SpanExporter.class));
	}
	@Test
	void shouldNotSupplyOtlpHttpSpanExporterIfTracingIsDisabled() {
		this.tracingDisabledContextRunner
			.withPropertyValues('management.otlp.tracing.endpoint=http://localhost:4318/v1/traces')
			.run((context) -> assertThat(context).doesNotHaveBean(OtlpHttpSpanExporter.class));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.withPropertyValues('management.otlp.tracing.endpoint=http://localhost:4318/v1/traces')
			.run((context) -> assertThat(context).hasSingleBean(PropertiesOtlpTracingConnectionDetails.class));
	}
	@Test
	void testConnectionFactoryWithOverridesWhenUsingCustomConnectionDetails() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(OtlpTracingConnectionDetails.class)
				.doesNotHaveBean(PropertiesOtlpTracingConnectionDetails.class);
			OtlpHttpSpanExporter otlpHttpSpanExporter = context.getBean(OtlpHttpSpanExporter.class);
			assertThat(otlpHttpSpanExporter).extracting('delegate.httpSender.url')
				.isEqualTo(HttpUrl.get('http://localhost:12345/v1/traces'));
		});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomHttpExporterConfiguration {
		@Bean
		OtlpHttpSpanExporter customOtlpHttpSpanExporter() {
			return OtlpHttpSpanExporter.builder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomGrpcExporterConfiguration {
		@Bean
		OtlpGrpcSpanExporter customOtlpGrpcSpanExporter() {
			return OtlpGrpcSpanExporter.builder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		OtlpTracingConnectionDetails otlpTracingConnectionDetails() {
			return (transport) -> 'http://localhost:12345/v1/traces';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
class OtlpTracingAutoConfigurationIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('management.tracing.sampling.probability=1.0')
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class,
				MicrometerTracingAutoConfiguration.class, OpenTelemetryAutoConfiguration.class,
				org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryTracingAutoConfiguration.class,
				OtlpTracingAutoConfiguration.class));
	private final MockWebServer mockWebServer = new MockWebServer();
	private final MockGrpcServer mockGrpcServer = new MockGrpcServer();
	@BeforeEach
	void startServers() throws Exception {
		this.mockWebServer.start();
		this.mockGrpcServer.start();
	}
	@AfterEach
	void stopServers() throws Exception {
		this.mockWebServer.close();
		this.mockGrpcServer.close();
	}
	@Test
	void httpSpanExporterShouldUseProtobufAndNoCompressionByDefault() {
		this.mockWebServer.enqueue(new MockResponse());
		this.contextRunner
			.withPropertyValues('management.otlp.tracing.endpoint=http://localhost:%d/v1/traces'
				.formatted(this.mockWebServer.getPort()), 'management.otlp.tracing.headers.custom=42')
			.run((context) -> {
				context.getBean(Tracer.class).nextSpan().name('test').end();
				assertThat(context.getBean(OtlpHttpSpanExporter.class).flush())
					.isSameAs(CompletableResultCode.ofSuccess());
				RecordedRequest request = this.mockWebServer.takeRequest(10, TimeUnit.SECONDS);
				assertThat(request).isNotNull();
				assertThat(request.getRequestLine()).contains('/v1/traces');
				assertThat(request.getHeader('Content-Type')).isEqualTo('application/x-protobuf');
				assertThat(request.getHeader('custom')).isEqualTo('42');
				assertThat(request.getBodySize()).isPositive();
				try (Buffer body = request.getBody()) {
					assertThat(body.readString(StandardCharsets.UTF_8)).contains('org.springframework.boot');
				}
			});
	}
	@Test
	void httpSpanExporterCanBeConfiguredToUseGzipCompression() {
		this.mockWebServer.enqueue(new MockResponse());
		this.contextRunner
			.withPropertyValues('management.otlp.tracing.compression=gzip',
					'management.otlp.tracing.endpoint=http://localhost:%d/test'.formatted(this.mockWebServer.getPort()))
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpHttpSpanExporter.class).hasSingleBean(SpanExporter.class);
				context.getBean(Tracer.class).nextSpan().name('test').end();
				assertThat(context.getBean(OtlpHttpSpanExporter.class).flush())
					.isSameAs(CompletableResultCode.ofSuccess());
				RecordedRequest request = this.mockWebServer.takeRequest(10, TimeUnit.SECONDS);
				assertThat(request).isNotNull();
				assertThat(request.getRequestLine()).contains('/test');
				assertThat(request.getHeader('Content-Type')).isEqualTo('application/x-protobuf');
				assertThat(request.getHeader('Content-Encoding')).isEqualTo('gzip');
				assertThat(request.getBodySize()).isPositive();
				try (Buffer uncompressed = new Buffer(); Buffer body = request.getBody()) {
					uncompressed.writeAll(new GzipSource(body));
					assertThat(uncompressed.readString(StandardCharsets.UTF_8)).contains('org.springframework.boot');
				}
			});
	}
	@Test
	void grpcSpanExporterShouldExportSpans() {
		this.contextRunner
			.withPropertyValues(
					'management.otlp.tracing.endpoint=http://localhost:%d'.formatted(this.mockGrpcServer.getPort()),
					'management.otlp.tracing.headers.custom=42', 'management.otlp.tracing.transport=grpc')
			.run((context) -> {
				context.getBean(Tracer.class).nextSpan().name('test').end();
				assertThat(context.getBean(OtlpGrpcSpanExporter.class).flush())
					.isSameAs(CompletableResultCode.ofSuccess());
				RecordedGrpcRequest request = this.mockGrpcServer.takeRequest(10, TimeUnit.SECONDS);
				assertThat(request).isNotNull();
				assertThat(request.headers().get('Content-Type')).isEqualTo('application/grpc');
				assertThat(request.headers().get('custom')).isEqualTo('42');
				assertThat(request.bodyAsString()).contains('org.springframework.boot');
			});
	}
	static class MockGrpcServer {
		private final Server server = createServer();
		private final BlockingQueue<RecordedGrpcRequest> recordedRequests = new LinkedBlockingQueue<>();
		void start() throws Exception {
			this.server.start();
		}
		void close() throws Exception {
			this.server.stop();
		}
		int getPort() {
			return this.server.getURI().getPort();
		}
		RecordedGrpcRequest takeRequest(int timeout, TimeUnit unit) throws InterruptedException {
			return this.recordedRequests.poll(timeout, unit);
		}
		void recordRequest(RecordedGrpcRequest request) {
			this.recordedRequests.add(request);
		}
		private Server createServer() {
			Server server = new Server();
			server.addConnector(createConnector(server));
			server.setHandler(new GrpcHandler());
			return server;
		}
		private ServerConnector createConnector(Server server) {
			ServerConnector connector = new ServerConnector(server,
					new HTTP2CServerConnectionFactory(new HttpConfiguration()));
			connector.setPort(0);
			return connector;
		}
		class GrpcHandler extends Handler.Abstract {
			@Override
			public boolean handle(Request request, Response response, Callback callback) throws Exception {
				try (InputStream in = Content.Source.asInputStream(request)) {
					recordRequest(new RecordedGrpcRequest(request.getHeaders(), in.readAllBytes()));
				}
				response.getHeaders().add('Content-Type', 'application/grpc');
				response.getHeaders().add('Grpc-Status', '0');
				callback.succeeded();
				return true;
			}
		}
		record RecordedGrpcRequest(HttpFields headers, byte[] body) {
			String bodyAsString() {
				return new String(this.body, StandardCharsets.UTF_8);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.wavefront;
/**
class WavefrontTracingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(WavefrontAutoConfiguration.class, WavefrontTracingAutoConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.withUserConfiguration(WavefrontSenderConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ApplicationTags.class);
			assertThat(context).hasSingleBean(WavefrontSpanHandler.class);
			assertThat(context).hasSingleBean(SpanMetrics.class);
			assertThat(context).hasSingleBean(WavefrontBraveSpanHandler.class);
			assertThat(context).hasSingleBean(WavefrontOtelSpanExporter.class);
		});
	}
	@Test
	void shouldNotSupplyBeansIfWavefrontSenderIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(WavefrontSender.class)).run((context) -> {
			assertThat(context).doesNotHaveBean(ApplicationTags.class);
			assertThat(context).doesNotHaveBean(WavefrontSpanHandler.class);
			assertThat(context).doesNotHaveBean(SpanMetrics.class);
			assertThat(context).doesNotHaveBean(WavefrontBraveSpanHandler.class);
			assertThat(context).doesNotHaveBean(WavefrontOtelSpanExporter.class);
		});
	}
	@Test
	void shouldNotSupplyBeansIfMicrometerReporterWavefrontIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.tracing.reporter.wavefront'))
			.withUserConfiguration(WavefrontSenderConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(WavefrontSpanHandler.class);
				assertThat(context).doesNotHaveBean(SpanMetrics.class);
				assertThat(context).doesNotHaveBean(WavefrontBraveSpanHandler.class);
				assertThat(context).doesNotHaveBean(WavefrontOtelSpanExporter.class);
			});
	}
	@Test
	void shouldNotSupplyBeansIfGlobalTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.enabled=false')
			.withUserConfiguration(WavefrontSenderConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(WavefrontSpanHandler.class);
				assertThat(context).doesNotHaveBean(WavefrontBraveSpanHandler.class);
				assertThat(context).doesNotHaveBean(WavefrontOtelSpanExporter.class);
			});
	}
	@Test
	void shouldNotSupplyBeansIfWavefrontTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.wavefront.tracing.export.enabled=false')
			.withUserConfiguration(WavefrontSenderConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(WavefrontSpanHandler.class);
				assertThat(context).doesNotHaveBean(WavefrontBraveSpanHandler.class);
				assertThat(context).doesNotHaveBean(WavefrontOtelSpanExporter.class);
			});
	}
	@Test
	void shouldSupplyMeterRegistrySpanMetricsIfMeterRegistryIsAvailable() {
		this.contextRunner.withUserConfiguration(WavefrontSenderConfiguration.class, MeterRegistryConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SpanMetrics.class);
				assertThat(context).hasSingleBean(MeterRegistrySpanMetrics.class);
			});
	}
	@Test
	void shouldNotSupplyWavefrontBraveSpanHandlerIfBraveIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('brave'))
			.withUserConfiguration(WavefrontSenderConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(WavefrontBraveSpanHandler.class));
	}
	@Test
	void shouldNotSupplyWavefrontOtelSpanExporterIfOtelIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.opentelemetry.sdk.trace'))
			.withUserConfiguration(WavefrontSenderConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(WavefrontOtelSpanExporter.class));
	}
	@Test
	void shouldHaveADefaultApplicationNameAndServiceName() {
		this.contextRunner.withUserConfiguration(WavefrontSenderConfiguration.class).run((context) -> {
			ApplicationTags applicationTags = context.getBean(ApplicationTags.class);
			assertThat(applicationTags.getApplication()).isEqualTo('unnamed_application');
			assertThat(applicationTags.getService()).isEqualTo('unnamed_service');
			assertThat(applicationTags.getCluster()).isNull();
			assertThat(applicationTags.getShard()).isNull();
		});
	}
	@Test
	void shouldUseSpringApplicationNameForServiceName() {
		this.contextRunner.withUserConfiguration(WavefrontSenderConfiguration.class)
			.withPropertyValues('spring.application.name=super-service')
			.run((context) -> {
				ApplicationTags applicationTags = context.getBean(ApplicationTags.class);
				assertThat(applicationTags.getApplication()).isEqualTo('unnamed_application');
				assertThat(applicationTags.getService()).isEqualTo('super-service');
			});
	}
	@Test
	void shouldHonorConfigProperties() {
		this.contextRunner.withUserConfiguration(WavefrontSenderConfiguration.class)
			.withPropertyValues('spring.application.name=ignored',
					'management.wavefront.application.name=super-application',
					'management.wavefront.application.service-name=super-service',
					'management.wavefront.application.cluster-name=super-cluster',
					'management.wavefront.application.shard-name=super-shard')
			.run((context) -> {
				ApplicationTags applicationTags = context.getBean(ApplicationTags.class);
				assertThat(applicationTags.getApplication()).isEqualTo('super-application');
				assertThat(applicationTags.getService()).isEqualTo('super-service');
				assertThat(applicationTags.getCluster()).isEqualTo('super-cluster');
				assertThat(applicationTags.getShard()).isEqualTo('super-shard');
			});
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(WavefrontSenderConfiguration.class, CustomConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('customApplicationTags');
				assertThat(context).hasSingleBean(ApplicationTags.class);
				assertThat(context).hasBean('customWavefrontSpanHandler');
				assertThat(context).hasSingleBean(WavefrontSpanHandler.class);
				assertThat(context).hasBean('customSpanMetrics');
				assertThat(context).hasSingleBean(SpanMetrics.class);
				assertThat(context).hasBean('customWavefrontBraveSpanHandler');
				assertThat(context).hasSingleBean(WavefrontBraveSpanHandler.class);
				assertThat(context).hasBean('customWavefrontOtelSpanExporter');
				assertThat(context).hasSingleBean(WavefrontOtelSpanExporter.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		ApplicationTags customApplicationTags() {
			return mock(ApplicationTags.class);
		}
		@Bean
		WavefrontSpanHandler customWavefrontSpanHandler() {
			return mock(WavefrontSpanHandler.class);
		}
		@Bean
		SpanMetrics customSpanMetrics() {
			return mock(SpanMetrics.class);
		}
		@Bean
		WavefrontBraveSpanHandler customWavefrontBraveSpanHandler() {
			return mock(WavefrontBraveSpanHandler.class);
		}
		@Bean
		WavefrontOtelSpanExporter customWavefrontOtelSpanExporter() {
			return mock(WavefrontOtelSpanExporter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class WavefrontSenderConfiguration {
		@Bean
		WavefrontSender wavefrontSender() {
			return mock(WavefrontSender.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class MeterRegistryConfiguration {
		@Bean
		MeterRegistry meterRegistry() {
			return new SimpleMeterRegistry();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.wavefront;
/**
class MeterRegistrySpanMetricsTests {
	private SimpleMeterRegistry meterRegistry;
	private MeterRegistrySpanMetrics sut;
	@BeforeEach
	void setUp() {
		this.meterRegistry = new SimpleMeterRegistry();
		this.sut = new MeterRegistrySpanMetrics(this.meterRegistry);
	}
	@Test
	void reportDroppedShouldIncreaseCounter() {
		this.sut.reportDropped();
		assertThat(getCounterValue('wavefront.reporter.spans.dropped')).isOne();
		this.sut.reportDropped();
		assertThat(getCounterValue('wavefront.reporter.spans.dropped')).isEqualTo(2);
	}
	@Test
	void reportReceivedShouldIncreaseCounter() {
		this.sut.reportReceived();
		assertThat(getCounterValue('wavefront.reporter.spans.received')).isOne();
		this.sut.reportReceived();
		assertThat(getCounterValue('wavefront.reporter.spans.received')).isEqualTo(2);
	}
	@Test
	void reportErrorsShouldIncreaseCounter() {
		this.sut.reportErrors();
		assertThat(getCounterValue('wavefront.reporter.errors')).isOne();
		this.sut.reportErrors();
		assertThat(getCounterValue('wavefront.reporter.errors')).isEqualTo(2);
	}
	@Test
	void registerQueueSizeShouldCreateGauge() {
		BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(2);
		this.sut.registerQueueSize(queue);
		assertThat(getGaugeValue('wavefront.reporter.queue.size')).isZero();
		queue.offer(1);
		assertThat(getGaugeValue('wavefront.reporter.queue.size')).isOne();
	}
	@Test
	void registerQueueRemainingCapacityShouldCreateGauge() {
		BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(2);
		this.sut.registerQueueRemainingCapacity(queue);
		assertThat(getGaugeValue('wavefront.reporter.queue.remaining_capacity')).isEqualTo(2);
		queue.offer(1);
		assertThat(getGaugeValue('wavefront.reporter.queue.remaining_capacity')).isOne();
	}
	private double getGaugeValue(String name) {
		Gauge gauge = this.meterRegistry.find(name).gauge();
		assertThat(gauge).withFailMessage('Gauge "%s" not found', name).isNotNull();
		return gauge.value();
	}
	private double getCounterValue(String name) {
		Counter counter = this.meterRegistry.find(name).counter();
		assertThat(counter).withFailMessage('Counter "%s" not found', name).isNotNull();
		return counter.count();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class NoopTracerAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(NoopTracerAutoConfiguration.class));
	@Test
	void shouldSupplyNoopTracer() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Tracer.class);
			Tracer tracer = context.getBean(Tracer.class);
			assertThat(tracer).isEqualTo(Tracer.NOOP);
		});
	}
	@Test
	void shouldBackOffOnCustomTracer() {
		this.contextRunner.withUserConfiguration(CustomTracerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Tracer.class);
			assertThat(context).hasBean('customTracer');
			Tracer tracer = context.getBean(Tracer.class);
			assertThat(tracer).isNotEqualTo(Tracer.NOOP);
		});
	}
	@Test
	void shouldBackOffIfMicrometerTracingIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.tracing'))
			.run((context) -> assertThat(context).doesNotHaveBean(Tracer.class));
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomTracerConfiguration {
		@Bean
		Tracer customTracer() {
			return mock(Tracer.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class CompositeTextMapPropagatorTests {
	private ContextKeyRegistry contextKeyRegistry;
	@BeforeEach
	void setUp() {
		this.contextKeyRegistry = new ContextKeyRegistry();
	}
	@Test
	void collectsAllFields() {
		CompositeTextMapPropagator propagator = new CompositeTextMapPropagator(List.of(field('a')), List.of(field('b')),
				field('c'));
		assertThat(propagator.fields()).containsExactly('a', 'b', 'c');
	}
	@Test
	void injectAllFields() {
		CompositeTextMapPropagator propagator = new CompositeTextMapPropagator(List.of(field('a'), field('b')),
				Collections.emptyList(), null);
		TextMapSetter<Object> setter = setter();
		Object carrier = carrier();
		propagator.inject(context(), carrier, setter);
		InOrder inOrder = Mockito.inOrder(setter);
		inOrder.verify(setter).set(carrier, 'a', 'a-value');
		inOrder.verify(setter).set(carrier, 'b', 'b-value');
	}
	@Test
	void extractWithoutBaggagePropagator() {
		CompositeTextMapPropagator propagator = new CompositeTextMapPropagator(Collections.emptyList(),
				List.of(field('a'), field('b')), null);
		Context context = context();
		Map<String, String> carrier = Map.of('a', 'a-value', 'b', 'b-value');
		context = propagator.extract(context, carrier, new MapTextMapGetter());
		Object a = context.get(getObjectContextKey('a'));
		assertThat(a).isEqualTo('a-value');
		Object b = context.get(getObjectContextKey('b'));
		assertThat(b).isNull();
	}
	@Test
	void extractWithBaggagePropagator() {
		CompositeTextMapPropagator propagator = new CompositeTextMapPropagator(Collections.emptyList(),
				List.of(field('a'), field('b')), field('c'));
		Context context = context();
		Map<String, String> carrier = Map.of('a', 'a-value', 'b', 'b-value', 'c', 'c-value');
		context = propagator.extract(context, carrier, new MapTextMapGetter());
		Object c = context.get(getObjectContextKey('c'));
		assertThat(c).isEqualTo('c-value');
	}
	@Test
	void createMapsInjectorsAndExtractors() {
		Propagation properties = new Propagation();
		properties.setProduce(List.of(PropagationType.W3C));
		properties.setConsume(List.of(PropagationType.B3));
		CompositeTextMapPropagator propagator = (CompositeTextMapPropagator) CompositeTextMapPropagator
			.create(properties, null);
		assertThat(propagator.getInjectors()).hasExactlyElementsOfTypes(W3CTraceContextPropagator.class);
		assertThat(propagator.getExtractors()).hasExactlyElementsOfTypes(B3Propagator.class);
	}
	private DummyTextMapPropagator field(String field) {
		return new DummyTextMapPropagator(field, this.contextKeyRegistry);
	}
	private ContextKey<Object> getObjectContextKey(String name) {
		return this.contextKeyRegistry.get(name);
	}
	@SuppressWarnings('unchecked')
	private static <T> TextMapSetter<T> setter() {
		return Mockito.mock(TextMapSetter.class);
	}
	private static Object carrier() {
		return new Object();
	}
	private static Context context() {
		return Context.current();
	}
	private static final class ContextKeyRegistry {
		private final Map<String, ContextKey<Object>> contextKeys = new HashMap<>();
		private ContextKey<Object> get(String name) {
			return this.contextKeys.computeIfAbsent(name, (ignore) -> ContextKey.named(name));
		}
	}
	private static final class MapTextMapGetter implements TextMapGetter<Map<String, String>> {
		@Override
		public Iterable<String> keys(Map<String, String> carrier) {
			return carrier.keySet();
		}
		@Override
		public String get(Map<String, String> carrier, String key) {
			if (carrier == null) {
				return null;
			}
			return carrier.get(key);
		}
	}
	private static final class DummyTextMapPropagator implements TextMapPropagator {
		private final String field;
		private final ContextKeyRegistry contextKeyRegistry;
		private DummyTextMapPropagator(String field, ContextKeyRegistry contextKeyRegistry) {
			this.field = field;
			this.contextKeyRegistry = contextKeyRegistry;
		}
		@Override
		public Collection<String> fields() {
			return List.of(this.field);
		}
		@Override
		public <C> void inject(Context context, C carrier, TextMapSetter<C> setter) {
			setter.set(carrier, this.field, this.field + '-value');
		}
		@Override
		public <C> Context extract(Context context, C carrier, TextMapGetter<C> getter) {
			String value = getter.get(carrier, this.field);
			if (value != null) {
				return context.with(this.contextKeyRegistry.get(this.field), value);
			}
			return context;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class LogCorrelationEnvironmentPostProcessorTests {
	private final ConfigurableEnvironment environment = new StandardEnvironment();
	private final SpringApplication application = new SpringApplication();
	private final LogCorrelationEnvironmentPostProcessor postProcessor = new LogCorrelationEnvironmentPostProcessor();
	@Test
	void getExpectCorrelationIdPropertyWhenMicrometerTracingPresentReturnsTrue() {
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		assertThat(this.environment.getProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, Boolean.class, false))
			.isTrue();
	}
	@Test
	@ClassPathExclusions('micrometer-tracing-*.jar')
	void getExpectCorrelationIdPropertyWhenMicrometerTracingMissingReturnsFalse() {
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		assertThat(this.environment.getProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, Boolean.class, false))
			.isFalse();
	}
	@Test
	void getExpectCorrelationIdPropertyWhenTracingDisabledReturnsFalse() {
		TestPropertyValues.of('management.tracing.enabled=false').applyTo(this.environment);
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		assertThat(this.environment.getProperty(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY, Boolean.class, false))
			.isFalse();
	}
	@Test
	void postProcessEnvironmentAddsEnumerablePropertySource() {
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		PropertySource<?> propertySource = this.environment.getPropertySources().get('logCorrelation');
		assertThat(propertySource).isInstanceOf(EnumerablePropertySource.class);
		assertThat(((EnumerablePropertySource<?>) propertySource).getPropertyNames())
			.containsExactly(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class OpenTelemetryTracingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(
				org.springframework.boot.actuate.autoconfigure.opentelemetry.OpenTelemetryAutoConfiguration.class,
				OpenTelemetryTracingAutoConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(OtelTracer.class);
			assertThat(context).hasSingleBean(EventPublisher.class);
			assertThat(context).hasSingleBean(OtelCurrentTraceContext.class);
			assertThat(context).hasSingleBean(SdkTracerProvider.class);
			assertThat(context).hasSingleBean(ContextPropagators.class);
			assertThat(context).hasSingleBean(Sampler.class);
			assertThat(context).hasSingleBean(Tracer.class);
			assertThat(context).hasSingleBean(Slf4JEventListener.class);
			assertThat(context).hasSingleBean(Slf4JBaggageEventListener.class);
			assertThat(context).hasSingleBean(SpanProcessor.class);
			assertThat(context).hasSingleBean(OtelPropagator.class);
			assertThat(context).hasSingleBean(TextMapPropagator.class);
			assertThat(context).hasSingleBean(OtelSpanCustomizer.class);
			assertThat(context).hasSingleBean(SpanProcessors.class);
			assertThat(context).hasSingleBean(SpanExporters.class);
		});
	}
	@Test
	void samplerIsParentBased() {
		this.contextRunner.run((context) -> {
			Sampler sampler = context.getBean(Sampler.class);
			assertThat(sampler).isNotNull();
			assertThat(sampler.getDescription()).startsWith('ParentBased{');
		});
	}
	@ParameterizedTest
	@ValueSource(strings = { 'io.micrometer.tracing.otel', 'io.opentelemetry.sdk', 'io.opentelemetry.api' })
	void shouldNotSupplyBeansIfDependencyIsMissing(String packageName) {
		this.contextRunner.withClassLoader(new FilteredClassLoader(packageName)).run((context) -> {
			assertThat(context).doesNotHaveBean(OtelTracer.class);
			assertThat(context).doesNotHaveBean(EventPublisher.class);
			assertThat(context).doesNotHaveBean(OtelCurrentTraceContext.class);
			assertThat(context).doesNotHaveBean(SdkTracerProvider.class);
			assertThat(context).doesNotHaveBean(ContextPropagators.class);
			assertThat(context).doesNotHaveBean(Sampler.class);
			assertThat(context).doesNotHaveBean(Tracer.class);
			assertThat(context).doesNotHaveBean(Slf4JEventListener.class);
			assertThat(context).doesNotHaveBean(Slf4JBaggageEventListener.class);
			assertThat(context).doesNotHaveBean(SpanProcessor.class);
			assertThat(context).doesNotHaveBean(OtelPropagator.class);
			assertThat(context).doesNotHaveBean(TextMapPropagator.class);
			assertThat(context).doesNotHaveBean(OtelSpanCustomizer.class);
			assertThat(context).doesNotHaveBean(SpanProcessors.class);
			assertThat(context).doesNotHaveBean(SpanExporters.class);
		});
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasBean('customMicrometerTracer');
			assertThat(context).hasSingleBean(io.micrometer.tracing.Tracer.class);
			assertThat(context).hasBean('customEventPublisher');
			assertThat(context).hasSingleBean(EventPublisher.class);
			assertThat(context).hasBean('customOtelCurrentTraceContext');
			assertThat(context).hasSingleBean(OtelCurrentTraceContext.class);
			assertThat(context).hasBean('customSdkTracerProvider');
			assertThat(context).hasSingleBean(SdkTracerProvider.class);
			assertThat(context).hasBean('customContextPropagators');
			assertThat(context).hasSingleBean(ContextPropagators.class);
			assertThat(context).hasBean('customSampler');
			assertThat(context).hasSingleBean(Sampler.class);
			assertThat(context).hasBean('customTracer');
			assertThat(context).hasSingleBean(Tracer.class);
			assertThat(context).hasBean('customSlf4jEventListener');
			assertThat(context).hasSingleBean(Slf4JEventListener.class);
			assertThat(context).hasBean('customSlf4jBaggageEventListener');
			assertThat(context).hasSingleBean(Slf4JBaggageEventListener.class);
			assertThat(context).hasBean('customOtelPropagator');
			assertThat(context).hasSingleBean(OtelPropagator.class);
			assertThat(context).hasBean('customSpanCustomizer');
			assertThat(context).hasSingleBean(SpanCustomizer.class);
			assertThat(context).hasBean('customSpanProcessors');
			assertThat(context).hasSingleBean(SpanProcessors.class);
			assertThat(context).hasBean('customSpanExporters');
			assertThat(context).hasSingleBean(SpanExporters.class);
		});
	}
	@Test
	void shouldSetupDefaultResourceAttributes() {
		this.contextRunner
			.withConfiguration(
					AutoConfigurations.of(ObservationAutoConfiguration.class, MicrometerTracingAutoConfiguration.class))
			.withUserConfiguration(InMemoryRecordingSpanExporterConfiguration.class)
			.withPropertyValues('management.tracing.sampling.probability=1.0')
			.run((context) -> {
				context.getBean(io.micrometer.tracing.Tracer.class).nextSpan().name('test').end();
				InMemoryRecordingSpanExporter exporter = context.getBean(InMemoryRecordingSpanExporter.class);
				exporter.await(Duration.ofSeconds(10));
				SpanData spanData = exporter.getExportedSpans().get(0);
				Map<AttributeKey<?>, Object> expectedAttributes = Resource.getDefault()
					.merge(Resource.create(Attributes.of(AttributeKey.stringKey('service.name'), 'unknown_service')))
					.getAttributes()
					.asMap();
				assertThat(spanData.getResource().getAttributes().asMap()).isEqualTo(expectedAttributes);
			});
	}
	@Test
	void shouldAllowMultipleSpanProcessors() {
		this.contextRunner.withUserConfiguration(AdditionalSpanProcessorConfiguration.class).run((context) -> {
			assertThat(context.getBeansOfType(SpanProcessor.class)).hasSize(2);
			assertThat(context).hasBean('customSpanProcessor');
			SpanProcessors spanProcessors = context.getBean(SpanProcessors.class);
			assertThat(spanProcessors).hasSize(2);
		});
	}
	@Test
	void shouldAllowMultipleSpanExporters() {
		this.contextRunner.withUserConfiguration(MultipleSpanExporterConfiguration.class).run((context) -> {
			assertThat(context.getBeansOfType(SpanExporter.class)).hasSize(2);
			assertThat(context).hasBean('spanExporter1');
			assertThat(context).hasBean('spanExporter2');
			SpanExporters spanExporters = context.getBean(SpanExporters.class);
			assertThat(spanExporters).hasSize(2);
		});
	}
	@Test
	void shouldAllowMultipleTextMapPropagators() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context.getBeansOfType(TextMapPropagator.class)).hasSize(2);
			assertThat(context).hasBean('customTextMapPropagator');
		});
	}
	@Test
	void shouldNotSupplySlf4jBaggageEventListenerWhenBaggageCorrelationDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.correlation.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(Slf4JBaggageEventListener.class));
	}
	@Test
	void shouldNotSupplySlf4JBaggageEventListenerWhenBaggageDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(Slf4JBaggageEventListener.class));
	}
	@Test
	void shouldSupplyB3PropagationIfPropagationPropertySet() {
		this.contextRunner.withPropertyValues('management.tracing.propagation.type=B3').run((context) -> {
			TextMapPropagator propagator = context.getBean(TextMapPropagator.class);
			List<TextMapPropagator> injectors = getInjectors(propagator);
			assertThat(injectors).hasExactlyElementsOfTypes(B3Propagator.class, BaggageTextMapPropagator.class);
		});
	}
	@Test
	void shouldSupplyB3PropagationIfPropagationPropertySetAndBaggageDisabled() {
		this.contextRunner
			.withPropertyValues('management.tracing.propagation.type=B3', 'management.tracing.baggage.enabled=false')
			.run((context) -> {
				TextMapPropagator propagator = context.getBean(TextMapPropagator.class);
				List<TextMapPropagator> injectors = getInjectors(propagator);
				assertThat(injectors).hasExactlyElementsOfTypes(B3Propagator.class);
			});
	}
	@Test
	void shouldSupplyW3CPropagationWithBaggageByDefault() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.remote-fields=foo').run((context) -> {
			TextMapPropagator propagator = context.getBean(TextMapPropagator.class);
			List<TextMapPropagator> injectors = getInjectors(propagator);
			List<String> fields = new ArrayList<>();
			for (TextMapPropagator injector : injectors) {
				fields.addAll(injector.fields());
			}
			assertThat(fields).containsExactly('traceparent', 'tracestate', 'baggage', 'foo');
		});
	}
	@Test
	void shouldSupplyW3CPropagationWithoutBaggageWhenDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.baggage.enabled=false').run((context) -> {
			TextMapPropagator propagator = context.getBean(TextMapPropagator.class);
			List<TextMapPropagator> injectors = getInjectors(propagator);
			assertThat(injectors).hasExactlyElementsOfTypes(W3CTraceContextPropagator.class);
		});
	}
	@Test
	void shouldConfigureRemoteAndTaggedFields() {
		this.contextRunner
			.withPropertyValues('management.tracing.baggage.remote-fields=r1',
					'management.tracing.baggage.tag-fields=t1')
			.run((context) -> {
				CompositeTextMapPropagator propagator = context.getBean(CompositeTextMapPropagator.class);
				assertThat(propagator).extracting('baggagePropagator.baggageManager.remoteFields')
					.asInstanceOf(InstanceOfAssertFactories.list(String.class))
					.containsExactly('r1');
				assertThat(propagator).extracting('baggagePropagator.baggageManager.tagFields')
					.asInstanceOf(InstanceOfAssertFactories.list(String.class))
					.containsExactly('t1');
			});
	}
	@Test
	void shouldCustomizeSdkTracerProvider() {
		this.contextRunner.withUserConfiguration(SdkTracerProviderCustomizationConfiguration.class).run((context) -> {
			SdkTracerProvider tracerProvider = context.getBean(SdkTracerProvider.class);
			assertThat(tracerProvider.getSpanLimits().getMaxNumberOfEvents()).isEqualTo(42);
			assertThat(tracerProvider.getSampler()).isEqualTo(Sampler.alwaysOn());
		});
	}
	@Test
	void defaultSpanProcessorShouldUseMeterProviderIfAvailable() {
		this.contextRunner.withUserConfiguration(MeterProviderConfiguration.class).run((context) -> {
			MeterProvider meterProvider = context.getBean(MeterProvider.class);
			assertThat(Mockito.mockingDetails(meterProvider).isMock()).isTrue();
			then(meterProvider).should().meterBuilder(anyString());
		});
	}
	@Test
	void shouldDisablePropagationIfTracingIsDisabled() {
		this.contextRunner.withPropertyValues('management.tracing.enabled=false').run((context) -> {
			assertThat(context).hasSingleBean(TextMapPropagator.class);
			TextMapPropagator propagator = context.getBean(TextMapPropagator.class);
			assertThat(propagator.fields()).isEmpty();
		});
	}
	@Test // gh-41439
	@ForkedClassPath
	void shouldPublishEventsWhenContextStorageIsInitializedEarly() {
		this.contextRunner.withInitializer(this::initializeOpenTelemetry)
			.withUserConfiguration(OtelEventListener.class)
			.run((context) -> {
				OtelEventListener listener = context.getBean(OtelEventListener.class);
				io.micrometer.tracing.Tracer micrometerTracer = context.getBean(io.micrometer.tracing.Tracer.class);
				io.micrometer.tracing.Span span = micrometerTracer.nextSpan().name('test');
				try (SpanInScope scoped = micrometerTracer.withSpan(span.start())) {
					assertThat(listener.events).isNotEmpty();
				}
				finally {
					span.end();
				}
			});
	}
	@Test
	@SuppressWarnings('removal')
	void shouldUseReplacementForDeprecatedVersion() {
		Class<?>[] classes = Configurations.getClasses(AutoConfigurations.of(OpenTelemetryAutoConfiguration.class));
		assertThat(classes).containsExactly(OpenTelemetryTracingAutoConfiguration.class);
	}
	private void initializeOpenTelemetry(ConfigurableApplicationContext context) {
		context.addApplicationListener(new OpenTelemetryEventPublisherBeansApplicationListener());
		Span.current();
	}
	private List<TextMapPropagator> getInjectors(TextMapPropagator propagator) {
		assertThat(propagator).as('propagator').isNotNull();
		if (propagator instanceof CompositeTextMapPropagator compositePropagator) {
			return compositePropagator.getInjectors().stream().toList();
		}
		fail('Expected CompositeTextMapPropagator, found %s'.formatted(propagator.getClass()));
		throw new AssertionError('Unreachable');
	}
	@Configuration(proxyBeanMethods = false)
	private static final class MeterProviderConfiguration {
		@Bean
		MeterProvider meterProvider() {
			MeterProvider mock = mock(MeterProvider.class);
			given(mock.meterBuilder(anyString()))
				.willAnswer((invocation) -> MeterProvider.noop().meterBuilder(invocation.getArgument(0, String.class)));
			return mock;
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class AdditionalSpanProcessorConfiguration {
		@Bean
		SpanProcessor customSpanProcessor() {
			return mock(SpanProcessor.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class MultipleSpanExporterConfiguration {
		@Bean
		SpanExporter spanExporter1() {
			return new DummySpanExporter();
		}
		@Bean
		SpanExporter spanExporter2() {
			return new DummySpanExporter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		SpanProcessors customSpanProcessors() {
			return SpanProcessors.of(mock(SpanProcessor.class));
		}
		@Bean
		SpanExporters customSpanExporters() {
			return SpanExporters.of(new DummySpanExporter());
		}
		@Bean
		io.micrometer.tracing.Tracer customMicrometerTracer() {
			return mock(io.micrometer.tracing.Tracer.class);
		}
		@Bean
		EventPublisher customEventPublisher() {
			return mock(EventPublisher.class);
		}
		@Bean
		OtelCurrentTraceContext customOtelCurrentTraceContext() {
			return mock(OtelCurrentTraceContext.class);
		}
		@Bean
		SdkTracerProvider customSdkTracerProvider() {
			return SdkTracerProvider.builder().build();
		}
		@Bean
		ContextPropagators customContextPropagators() {
			return mock(ContextPropagators.class);
		}
		@Bean
		Sampler customSampler() {
			return mock(Sampler.class);
		}
		@Bean
		SpanProcessor customSpanProcessor() {
			return mock(SpanProcessor.class);
		}
		@Bean
		Tracer customTracer() {
			return mock(Tracer.class);
		}
		@Bean
		Slf4JEventListener customSlf4jEventListener() {
			return new Slf4JEventListener();
		}
		@Bean
		Slf4JBaggageEventListener customSlf4jBaggageEventListener() {
			return new Slf4JBaggageEventListener(List.of('alpha'));
		}
		@Bean
		OtelPropagator customOtelPropagator(ContextPropagators propagators, Tracer tracer) {
			return new OtelPropagator(propagators, tracer);
		}
		@Bean
		TextMapPropagator customTextMapPropagator() {
			return mock(TextMapPropagator.class);
		}
		@Bean
		SpanCustomizer customSpanCustomizer() {
			return mock(SpanCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class SdkTracerProviderCustomizationConfiguration {
		@Bean
		@Order(1)
		SdkTracerProviderBuilderCustomizer sdkTracerProviderBuilderCustomizerOne() {
			return (builder) -> {
				SpanLimits spanLimits = SpanLimits.builder().setMaxNumberOfEvents(42).build();
				builder.setSpanLimits(spanLimits);
			};
		}
		@Bean
		@Order(0)
		SdkTracerProviderBuilderCustomizer sdkTracerProviderBuilderCustomizerTwo() {
			return (builder) -> {
				SpanLimits spanLimits = SpanLimits.builder().setMaxNumberOfEvents(21).build();
				builder.setSpanLimits(spanLimits).setSampler(Sampler.alwaysOn());
			};
		}
	}
	private static final class DummySpanExporter implements SpanExporter {
		@Override
		public CompletableResultCode export(Collection<SpanData> spans) {
			return CompletableResultCode.ofSuccess();
		}
		@Override
		public CompletableResultCode flush() {
			return CompletableResultCode.ofSuccess();
		}
		@Override
		public CompletableResultCode shutdown() {
			return CompletableResultCode.ofSuccess();
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class InMemoryRecordingSpanExporterConfiguration {
		@Bean
		InMemoryRecordingSpanExporter spanExporter() {
			return new InMemoryRecordingSpanExporter();
		}
	}
	private static final class InMemoryRecordingSpanExporter implements SpanExporter {
		private final List<SpanData> exportedSpans = new ArrayList<>();
		private final CountDownLatch latch = new CountDownLatch(1);
		@Override
		public CompletableResultCode export(Collection<SpanData> spans) {
			this.exportedSpans.addAll(spans);
			this.latch.countDown();
			return CompletableResultCode.ofSuccess();
		}
		@Override
		public CompletableResultCode flush() {
			return CompletableResultCode.ofSuccess();
		}
		@Override
		public CompletableResultCode shutdown() {
			this.exportedSpans.clear();
			return CompletableResultCode.ofSuccess();
		}
		List<SpanData> getExportedSpans() {
			return this.exportedSpans;
		}
		void await(Duration timeout) throws InterruptedException, TimeoutException {
			if (!this.latch.await(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
				throw new TimeoutException('Waiting for exporting spans timed out (%s)'.formatted(timeout));
			}
		}
	}
	static class OtelEventListener implements EventListener {
		private final List<Object> events = new ArrayList<>();
		@Override
		public void onEvent(Object event) {
			this.events.add(event);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class MicrometerTracingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('management.observations.annotations.enabled=true')
		.withConfiguration(AutoConfigurations.of(MicrometerTracingAutoConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.withUserConfiguration(TracerConfiguration.class, PropagatorConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(DefaultTracingObservationHandler.class);
				assertThat(context).hasSingleBean(PropagatingReceiverTracingObservationHandler.class);
				assertThat(context).hasSingleBean(PropagatingSenderTracingObservationHandler.class);
				assertThat(context).hasSingleBean(DefaultNewSpanParser.class);
				assertThat(context).hasSingleBean(ImperativeMethodInvocationProcessor.class);
				assertThat(context).hasSingleBean(SpanAspect.class);
				assertThat(context).hasSingleBean(SpanTagAnnotationHandler.class);
			});
	}
	@Test
	@SuppressWarnings('rawtypes')
	void shouldSupplyBeansInCorrectOrder() {
		this.contextRunner.withUserConfiguration(TracerConfiguration.class, PropagatorConfiguration.class)
			.run((context) -> {
				List<TracingObservationHandler> tracingObservationHandlers = context
					.getBeanProvider(TracingObservationHandler.class)
					.orderedStream()
					.toList();
				assertThat(tracingObservationHandlers).hasSize(3);
				assertThat(tracingObservationHandlers.get(0))
					.isInstanceOf(PropagatingReceiverTracingObservationHandler.class);
				assertThat(tracingObservationHandlers.get(1))
					.isInstanceOf(PropagatingSenderTracingObservationHandler.class);
				assertThat(tracingObservationHandlers.get(2)).isInstanceOf(DefaultTracingObservationHandler.class);
			});
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(TracerConfiguration.class, CustomConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('customDefaultTracingObservationHandler');
				assertThat(context).hasSingleBean(DefaultTracingObservationHandler.class);
				assertThat(context).hasBean('customPropagatingReceiverTracingObservationHandler');
				assertThat(context).hasSingleBean(PropagatingReceiverTracingObservationHandler.class);
				assertThat(context).hasBean('customPropagatingSenderTracingObservationHandler');
				assertThat(context).hasSingleBean(PropagatingSenderTracingObservationHandler.class);
				assertThat(context).hasBean('customDefaultNewSpanParser');
				assertThat(context).hasSingleBean(DefaultNewSpanParser.class);
				assertThat(context).hasBean('customImperativeMethodInvocationProcessor');
				assertThat(context).hasSingleBean(ImperativeMethodInvocationProcessor.class);
				assertThat(context).hasBean('customSpanAspect');
				assertThat(context).hasSingleBean(SpanAspect.class);
				assertThat(context).hasBean('customSpanTagAnnotationHandler');
				assertThat(context).hasSingleBean(SpanTagAnnotationHandler.class);
			});
	}
	@Test
	void shouldNotSupplyBeansIfMicrometerIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer')).run((context) -> {
			assertThat(context).doesNotHaveBean(DefaultTracingObservationHandler.class);
			assertThat(context).doesNotHaveBean(PropagatingReceiverTracingObservationHandler.class);
			assertThat(context).doesNotHaveBean(PropagatingSenderTracingObservationHandler.class);
			assertThat(context).doesNotHaveBean(DefaultNewSpanParser.class);
			assertThat(context).doesNotHaveBean(ImperativeMethodInvocationProcessor.class);
			assertThat(context).doesNotHaveBean(SpanAspect.class);
		});
	}
	@Test
	void shouldNotSupplyBeansIfTracerIsMissing() {
		this.contextRunner.withUserConfiguration(PropagatorConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(DefaultTracingObservationHandler.class);
			assertThat(context).doesNotHaveBean(PropagatingReceiverTracingObservationHandler.class);
			assertThat(context).doesNotHaveBean(PropagatingSenderTracingObservationHandler.class);
			assertThat(context).doesNotHaveBean(DefaultNewSpanParser.class);
			assertThat(context).doesNotHaveBean(ImperativeMethodInvocationProcessor.class);
			assertThat(context).doesNotHaveBean(SpanAspect.class);
		});
	}
	@Test
	void shouldNotSupplyAspectBeansIfPropertyIsDisabled() {
		this.contextRunner.withUserConfiguration(TracerConfiguration.class, PropagatorConfiguration.class)
			.withPropertyValues('management.observations.annotations.enabled=false')
			.run((context) -> {
				assertThat(context).doesNotHaveBean(DefaultNewSpanParser.class);
				assertThat(context).doesNotHaveBean(ImperativeMethodInvocationProcessor.class);
				assertThat(context).doesNotHaveBean(SpanAspect.class);
			});
	}
	@Test
	void shouldSupplyAspectBeansIfLegacyPropertyIsEnabled() {
		new ApplicationContextRunner().withPropertyValues('micrometer.observations.annotations.enabled=true')
			.withConfiguration(AutoConfigurations.of(MicrometerTracingAutoConfiguration.class))
			.withUserConfiguration(TracerConfiguration.class, PropagatorConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(DefaultNewSpanParser.class);
				assertThat(context).hasSingleBean(ImperativeMethodInvocationProcessor.class);
				assertThat(context).hasSingleBean(SpanAspect.class);
			});
	}
	@Test
	void shouldNotSupplyBeansIfAspectjIsMissing() {
		this.contextRunner.withUserConfiguration(TracerConfiguration.class)
			.withClassLoader(new FilteredClassLoader(Advice.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(DefaultNewSpanParser.class);
				assertThat(context).doesNotHaveBean(ImperativeMethodInvocationProcessor.class);
				assertThat(context).doesNotHaveBean(SpanAspect.class);
			});
	}
	@Test
	void shouldNotSupplyBeansIfPropagatorIsMissing() {
		this.contextRunner.withUserConfiguration(TracerConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(PropagatingSenderTracingObservationHandler.class);
			assertThat(context).doesNotHaveBean(PropagatingReceiverTracingObservationHandler.class);
			assertThat(context).hasSingleBean(DefaultNewSpanParser.class);
			assertThat(context).hasSingleBean(ImperativeMethodInvocationProcessor.class);
			assertThat(context).hasSingleBean(SpanAspect.class);
		});
	}
	@Test
	void shouldConfigureSpanTagAnnotationHandler() {
		this.contextRunner.withUserConfiguration(TracerConfiguration.class, SpanTagAnnotationHandlerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(DefaultNewSpanParser.class);
				assertThat(context).hasSingleBean(SpanAspect.class);
				assertThat(context.getBean(ImperativeMethodInvocationProcessor.class)).hasFieldOrPropertyWithValue(
						'spanTagAnnotationHandler', context.getBean(SpanTagAnnotationHandler.class));
			});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class TracerConfiguration {
		@Bean
		Tracer tracer() {
			return mock(Tracer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class PropagatorConfiguration {
		@Bean
		Propagator propagator() {
			return mock(Propagator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomConfiguration {
		@Bean
		DefaultTracingObservationHandler customDefaultTracingObservationHandler() {
			return mock(DefaultTracingObservationHandler.class);
		}
		@Bean
		PropagatingReceiverTracingObservationHandler<?> customPropagatingReceiverTracingObservationHandler() {
			return mock(PropagatingReceiverTracingObservationHandler.class);
		}
		@Bean
		PropagatingSenderTracingObservationHandler<?> customPropagatingSenderTracingObservationHandler() {
			return mock(PropagatingSenderTracingObservationHandler.class);
		}
		@Bean
		DefaultNewSpanParser customDefaultNewSpanParser() {
			return new DefaultNewSpanParser();
		}
		@Bean
		ImperativeMethodInvocationProcessor customImperativeMethodInvocationProcessor(NewSpanParser newSpanParser,
				Tracer tracer) {
			return new ImperativeMethodInvocationProcessor(newSpanParser, tracer);
		}
		@Bean
		SpanAspect customSpanAspect(MethodInvocationProcessor methodInvocationProcessor) {
			return new SpanAspect(methodInvocationProcessor);
		}
		@Bean
		SpanTagAnnotationHandler customSpanTagAnnotationHandler() {
			return new SpanTagAnnotationHandler((aClass) -> mock(ValueResolver.class),
					(aClass) -> mock(ValueExpressionResolver.class));
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class SpanTagAnnotationHandlerConfiguration {
		@Bean
		SpanTagAnnotationHandler spanTagAnnotationHandler() {
			return new SpanTagAnnotationHandler((valueResolverClass) -> null, (valueExpressionResolverClass) -> null);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.scheduling;
/**
class ScheduledTasksObservabilityAutoConfigurationTests {
	private final ApplicationContextRunner runner = new ApplicationContextRunner().withConfiguration(AutoConfigurations
		.of(ObservationAutoConfiguration.class, ScheduledTasksObservabilityAutoConfiguration.class));
	@Test
	void shouldProvideObservabilitySchedulingConfigurer() {
		this.runner.run((context) -> assertThat(context).hasSingleBean(ObservabilitySchedulingConfigurer.class));
	}
	@Test
	void observabilitySchedulingConfigurerShouldConfigureObservationRegistry() {
		ObservationRegistry observationRegistry = ObservationRegistry.create();
		ObservabilitySchedulingConfigurer configurer = new ObservabilitySchedulingConfigurer(observationRegistry);
		ScheduledTaskRegistrar registrar = new ScheduledTaskRegistrar();
		configurer.configureTasks(registrar);
		assertThat(registrar.getObservationRegistry()).isEqualTo(observationRegistry);
	}
	@Test
	void isRegisteredInAutoConfigurationsFile() {
		List<String> configurations = ImportCandidates.load(AutoConfiguration.class, null).getCandidates();
		assertThat(configurations).contains(ScheduledTasksObservabilityAutoConfiguration.class.getName());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.scheduling;
/**
class ScheduledTasksEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ScheduledTasksEndpointAutoConfiguration.class));
	@Test
	void endpointIsAutoConfigured() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=scheduledtasks')
			.run((context) -> assertThat(context).hasSingleBean(ScheduledTasksEndpoint.class));
	}
	@Test
	void endpointNotAutoConfiguredWhenNotExposed() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ScheduledTasksEndpoint.class));
	}
	@Test
	void endpointCanBeDisabled() {
		this.contextRunner.withPropertyValues('management.endpoint.scheduledtasks.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ScheduledTasksEndpoint.class));
	}
	@Test
	void endpointBacksOffWhenUserProvidedEndpointIsPresent() {
		this.contextRunner.withUserConfiguration(CustomEndpointConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ScheduledTasksEndpoint.class)
				.hasBean('customEndpoint'));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomEndpointConfiguration {
		@Bean
		CustomEndpoint customEndpoint() {
			return new CustomEndpoint();
		}
	}
	private static final class CustomEndpoint extends ScheduledTasksEndpoint {
		private CustomEndpoint() {
			super(Collections.emptyList());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.jdbc;
/**
class DataSourceHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
				HealthContributorAutoConfiguration.class, DataSourceHealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> {
			context.getBean(DataSourceHealthIndicator.class);
			assertThat(context).hasSingleBean(DataSourceHealthIndicator.class);
		});
	}
	@Test
	void runWhenMultipleDataSourceBeansShouldCreateCompositeIndicator() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, DataSourceConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(CompositeHealthContributor.class);
				CompositeHealthContributor contributor = context.getBean(CompositeHealthContributor.class);
				String[] names = contributor.stream().map(NamedContributor::getName).toArray(String[]::new);
				assertThat(names).containsExactlyInAnyOrder('dataSource', 'testDataSource');
			});
	}
	@Test
	void runWithRoutingAndEmbeddedDataSourceShouldIncludeRoutingDataSource() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, RoutingDataSourceConfig.class)
			.run((context) -> {
				CompositeHealthContributor composite = context.getBean(CompositeHealthContributor.class);
				assertThat(composite.getContributor('dataSource')).isInstanceOf(DataSourceHealthIndicator.class);
				assertThat(composite.getContributor('routingDataSource'))
					.isInstanceOf(RoutingDataSourceHealthContributor.class);
			});
	}
	@Test
	void runWithProxyBeanPostProcessorRoutingAndEmbeddedDataSourceShouldIncludeRoutingDataSource() {
		this.contextRunner
			.withUserConfiguration(ProxyDataSourceBeanPostProcessor.class, EmbeddedDataSourceConfiguration.class,
					RoutingDataSourceConfig.class)
			.run((context) -> {
				CompositeHealthContributor composite = context.getBean(CompositeHealthContributor.class);
				assertThat(composite.getContributor('dataSource')).isInstanceOf(DataSourceHealthIndicator.class);
				assertThat(composite.getContributor('routingDataSource'))
					.isInstanceOf(RoutingDataSourceHealthContributor.class);
			});
	}
	@Test
	void runWithRoutingAndEmbeddedDataSourceShouldNotIncludeRoutingDataSourceWhenIgnored() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, RoutingDataSourceConfig.class)
			.withPropertyValues('management.health.db.ignore-routing-datasources:true')
			.run((context) -> {
				assertThat(context).doesNotHaveBean(CompositeHealthContributor.class);
				assertThat(context).hasSingleBean(DataSourceHealthIndicator.class);
				assertThat(context).doesNotHaveBean(RoutingDataSourceHealthContributor.class);
			});
	}
	@Test
	void runWithProxyBeanPostProcessorAndRoutingAndEmbeddedDataSourceShouldNotIncludeRoutingDataSourceWhenIgnored() {
		this.contextRunner
			.withUserConfiguration(ProxyDataSourceBeanPostProcessor.class, EmbeddedDataSourceConfiguration.class,
					RoutingDataSourceConfig.class)
			.withPropertyValues('management.health.db.ignore-routing-datasources:true')
			.run((context) -> {
				assertThat(context).doesNotHaveBean(CompositeHealthContributor.class);
				assertThat(context).hasSingleBean(DataSourceHealthIndicator.class);
				assertThat(context).doesNotHaveBean(RoutingDataSourceHealthContributor.class);
			});
	}
	@Test
	void runWithOnlyRoutingDataSourceShouldIncludeRoutingDataSourceWithComposedIndicators() {
		this.contextRunner.withUserConfiguration(RoutingDataSourceConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(RoutingDataSourceHealthContributor.class);
			RoutingDataSourceHealthContributor routingHealthContributor = context
				.getBean(RoutingDataSourceHealthContributor.class);
			assertThat(routingHealthContributor.getContributor('one')).isInstanceOf(DataSourceHealthIndicator.class);
			assertThat(routingHealthContributor.getContributor('two')).isInstanceOf(DataSourceHealthIndicator.class);
			assertThat(routingHealthContributor.iterator()).toIterable()
				.extracting('name')
				.containsExactlyInAnyOrder('one', 'two');
		});
	}
	@Test
	void runWithProxyBeanPostProcessorAndRoutingDataSourceShouldIncludeRoutingDataSourceWithComposedIndicators() {
		this.contextRunner.withUserConfiguration(ProxyDataSourceBeanPostProcessor.class, RoutingDataSourceConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RoutingDataSourceHealthContributor.class);
				RoutingDataSourceHealthContributor routingHealthContributor = context
					.getBean(RoutingDataSourceHealthContributor.class);
				assertThat(routingHealthContributor.getContributor('one'))
					.isInstanceOf(DataSourceHealthIndicator.class);
				assertThat(routingHealthContributor.getContributor('two'))
					.isInstanceOf(DataSourceHealthIndicator.class);
				assertThat(routingHealthContributor.iterator()).toIterable()
					.extracting('name')
					.containsExactlyInAnyOrder('one', 'two');
			});
	}
	@Test
	void runWithOnlyRoutingDataSourceShouldCrashWhenIgnored() {
		this.contextRunner.withUserConfiguration(RoutingDataSourceConfig.class)
			.withPropertyValues('management.health.db.ignore-routing-datasources:true')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.hasRootCauseInstanceOf(IllegalArgumentException.class));
	}
	@Test
	void runWithProxyBeanPostProcessorAndOnlyRoutingDataSourceShouldCrashWhenIgnored() {
		this.contextRunner.withUserConfiguration(ProxyDataSourceBeanPostProcessor.class, RoutingDataSourceConfig.class)
			.withPropertyValues('management.health.db.ignore-routing-datasources:true')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.hasRootCauseInstanceOf(IllegalArgumentException.class));
	}
	@Test
	void runWithValidationQueryPropertyShouldUseCustomQuery() {
		this.contextRunner
			.withUserConfiguration(DataSourceConfig.class, DataSourcePoolMetadataProvidersConfiguration.class)
			.withPropertyValues('spring.datasource.test.validation-query:SELECT from FOOBAR')
			.run((context) -> {
				assertThat(context).hasSingleBean(DataSourceHealthIndicator.class);
				DataSourceHealthIndicator indicator = context.getBean(DataSourceHealthIndicator.class);
				assertThat(indicator.getQuery()).isEqualTo('SELECT from FOOBAR');
			});
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('management.health.db.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(DataSourceHealthIndicator.class)
				.doesNotHaveBean(CompositeHealthContributor.class));
	}
	@Test
	void runWhenDataSourceHasNullRoutingKeyShouldProduceUnnamedComposedIndicator() {
		this.contextRunner.withUserConfiguration(NullKeyRoutingDataSourceConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(RoutingDataSourceHealthContributor.class);
			RoutingDataSourceHealthContributor routingHealthContributor = context
				.getBean(RoutingDataSourceHealthContributor.class);
			assertThat(routingHealthContributor.getContributor('unnamed'))
				.isInstanceOf(DataSourceHealthIndicator.class);
			assertThat(routingHealthContributor.getContributor('one')).isInstanceOf(DataSourceHealthIndicator.class);
			assertThat(routingHealthContributor.iterator()).toIterable()
				.extracting('name')
				.containsExactlyInAnyOrder('unnamed', 'one');
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class DataSourceConfig {
		@Bean
		@ConfigurationProperties(prefix = 'spring.datasource.test')
		DataSource testDataSource() {
			return DataSourceBuilder.create()
				.type(org.apache.tomcat.jdbc.pool.DataSource.class)
				.driverClassName('org.hsqldb.jdbc.JDBCDriver')
				.url('jdbc:hsqldb:mem:test')
				.username('sa')
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RoutingDataSourceConfig {
		@Bean
		AbstractRoutingDataSource routingDataSource() throws SQLException {
			Map<Object, DataSource> dataSources = new HashMap<>();
			dataSources.put('one', mock(DataSource.class));
			dataSources.put('two', mock(DataSource.class));
			AbstractRoutingDataSource routingDataSource = mock(AbstractRoutingDataSource.class);
			given(routingDataSource.isWrapperFor(AbstractRoutingDataSource.class)).willReturn(true);
			given(routingDataSource.unwrap(AbstractRoutingDataSource.class)).willReturn(routingDataSource);
			given(routingDataSource.getResolvedDataSources()).willReturn(dataSources);
			return routingDataSource;
		}
	}
	static class ProxyDataSourceBeanPostProcessor implements BeanPostProcessor {
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
			if (bean instanceof DataSource dataSource) {
				return proxyDataSource(dataSource);
			}
			return bean;
		}
		private static DataSource proxyDataSource(DataSource dataSource) {
			try {
				DataSource mock = mock(DataSource.class);
				given(mock.isWrapperFor(AbstractRoutingDataSource.class))
					.willReturn(dataSource instanceof AbstractRoutingDataSource);
				given(mock.unwrap(AbstractRoutingDataSource.class)).willAnswer((invocation) -> dataSource);
				return mock;
			}
			catch (SQLException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NullKeyRoutingDataSourceConfig {
		@Bean
		AbstractRoutingDataSource routingDataSource() throws Exception {
			Map<Object, DataSource> dataSources = new HashMap<>();
			dataSources.put(null, mock(DataSource.class));
			dataSources.put('one', mock(DataSource.class));
			AbstractRoutingDataSource routingDataSource = mock(AbstractRoutingDataSource.class);
			given(routingDataSource.isWrapperFor(AbstractRoutingDataSource.class)).willReturn(true);
			given(routingDataSource.unwrap(AbstractRoutingDataSource.class)).willReturn(routingDataSource);
			given(routingDataSource.getResolvedDataSources()).willReturn(dataSources);
			return routingDataSource;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.jms;
/**
class JmsHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ArtemisAutoConfiguration.class,
				JmsHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(JmsHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.jms.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(LdapHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.context.properties;
/**
class ConfigurationPropertiesReportEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ConfigurationPropertiesReportEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withUserConfiguration(Config.class)
			.withPropertyValues('management.endpoints.web.exposure.include=configprops')
			.run(validateTestProperties('******', '******'));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.configprops.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ConfigurationPropertiesReportEndpoint.class));
	}
	@Test
	@SuppressWarnings('unchecked')
	void rolesCanBeConfiguredViaTheEnvironment() {
		this.contextRunner.withUserConfiguration(Config.class)
			.withPropertyValues('management.endpoint.configprops.roles: test')
			.withPropertyValues('management.endpoints.web.exposure.include=configprops')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConfigurationPropertiesReportEndpointWebExtension.class);
				ConfigurationPropertiesReportEndpointWebExtension endpoint = context
					.getBean(ConfigurationPropertiesReportEndpointWebExtension.class);
				Set<String> roles = (Set<String>) ReflectionTestUtils.getField(endpoint, 'roles');
				assertThat(roles).contains('test');
			});
	}
	@Test
	void showValuesCanBeConfiguredViaTheEnvironment() {
		this.contextRunner.withUserConfiguration(Config.class)
			.withPropertyValues('management.endpoint.configprops.show-values: WHEN_AUTHORIZED')
			.withPropertyValues('management.endpoints.web.exposure.include=configprops')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConfigurationPropertiesReportEndpoint.class);
				assertThat(context).hasSingleBean(ConfigurationPropertiesReportEndpointWebExtension.class);
				ConfigurationPropertiesReportEndpointWebExtension webExtension = context
					.getBean(ConfigurationPropertiesReportEndpointWebExtension.class);
				ConfigurationPropertiesReportEndpoint endpoint = context
					.getBean(ConfigurationPropertiesReportEndpoint.class);
				Show showValuesWebExtension = (Show) ReflectionTestUtils.getField(webExtension, 'showValues');
				assertThat(showValuesWebExtension).isEqualTo(Show.WHEN_AUTHORIZED);
				Show showValues = (Show) ReflectionTestUtils.getField(endpoint, 'showValues');
				assertThat(showValues).isEqualTo(Show.WHEN_AUTHORIZED);
			});
	}
	@Test
	void customSanitizingFunctionsAreAppliedInOrder() {
		this.contextRunner.withPropertyValues('management.endpoint.configprops.show-values: ALWAYS')
			.withUserConfiguration(Config.class, SanitizingFunctionConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=configprops', 'test.my-test-property=abc')
			.run(validateTestProperties('$$$111$$$', '$$$222$$$'));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(ConfigurationPropertiesReportEndpoint.class));
	}
	private ContextConsumer<AssertableApplicationContext> validateTestProperties(String dbPassword,
			String myTestProperty) {
		return (context) -> {
			assertThat(context).hasSingleBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesReportEndpoint endpoint = context
				.getBean(ConfigurationPropertiesReportEndpoint.class);
			ConfigurationPropertiesDescriptor properties = endpoint.configurationProperties();
			Map<String, Object> nestedProperties = properties.getContexts()
				.get(context.getId())
				.getBeans()
				.get('testProperties')
				.getProperties();
			assertThat(nestedProperties).isNotNull();
			assertThat(nestedProperties).containsEntry('dbPassword', dbPassword);
			assertThat(nestedProperties).containsEntry('myTestProperty', myTestProperty);
		};
	}
	@Test
	void runWhenOnlyExposedOverJmxShouldHaveEndpointBeanWithoutWebExtension() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=info', 'spring.jmx.enabled=true',
					'management.endpoints.jmx.exposure.include=configprops')
			.run((context) -> assertThat(context).hasSingleBean(ConfigurationPropertiesReportEndpoint.class)
				.doesNotHaveBean(ConfigurationPropertiesReportEndpointWebExtension.class));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class Config {
		@Bean
		TestProperties testProperties() {
			return new TestProperties();
		}
	}
	@ConfigurationProperties('test')
	public static class TestProperties {
		private String dbPassword = '123456';
		private String myTestProperty = '654321';
		public String getDbPassword() {
			return this.dbPassword;
		}
		public void setDbPassword(String dbPassword) {
			this.dbPassword = dbPassword;
		}
		public String getMyTestProperty() {
			return this.myTestProperty;
		}
		public void setMyTestProperty(String myTestProperty) {
			this.myTestProperty = myTestProperty;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SanitizingFunctionConfiguration {
		@Bean
		@Order(0)
		SanitizingFunction firstSanitizingFunction() {
			return (data) -> {
				if (data.getKey().contains('Password')) {
					return data.withValue('$$$111$$$');
				}
				return data;
			};
		}
		@Bean
		@Order(1)
		SanitizingFunction secondSanitizingFunction() {
			return (data) -> {
				if (data.getKey().contains('Password') || data.getKey().contains('test')) {
					return data.withValue('$$$222$$$');
				}
				return data;
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.context;
/**
class ShutdownEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ShutdownEndpointAutoConfiguration.class));
	@Test
	@SuppressWarnings('unchecked')
	void runShouldHaveEndpointBeanThatIsNotDisposable() {
		this.contextRunner.withPropertyValues('management.endpoint.shutdown.enabled:true')
			.withPropertyValues('management.endpoints.web.exposure.include=shutdown')
			.run((context) -> {
				assertThat(context).hasSingleBean(ShutdownEndpoint.class);
				ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
				Map<String, Object> disposableBeans = (Map<String, Object>) ReflectionTestUtils.getField(beanFactory,
						'disposableBeans');
				assertThat(disposableBeans).isEmpty();
			});
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.shutdown.enabled:true')
			.run((context) -> assertThat(context).doesNotHaveBean(ShutdownEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.shutdown.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ShutdownEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.quartz;
/**
class QuartzEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(QuartzEndpointAutoConfiguration.class));
	@Test
	void endpointIsAutoConfigured() {
		this.contextRunner.withBean(Scheduler.class, () -> mock(Scheduler.class))
			.withPropertyValues('management.endpoints.web.exposure.include=quartz')
			.run((context) -> assertThat(context).hasSingleBean(QuartzEndpoint.class));
	}
	@Test
	void endpointIsNotAutoConfiguredIfSchedulerIsNotAvailable() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=quartz')
			.run((context) -> assertThat(context).doesNotHaveBean(QuartzEndpoint.class));
	}
	@Test
	void endpointNotAutoConfiguredWhenNotExposed() {
		this.contextRunner.withBean(Scheduler.class, () -> mock(Scheduler.class))
			.run((context) -> assertThat(context).doesNotHaveBean(QuartzEndpoint.class));
	}
	@Test
	void endpointCanBeDisabled() {
		this.contextRunner.withBean(Scheduler.class, () -> mock(Scheduler.class))
			.withPropertyValues('management.endpoint.quartz.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(QuartzEndpoint.class));
	}
	@Test
	void endpointBacksOffWhenUserProvidedEndpointIsPresent() {
		this.contextRunner.withUserConfiguration(CustomEndpointConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(QuartzEndpoint.class).hasBean('customEndpoint'));
	}
	@Test
	void runWhenOnlyExposedOverJmxShouldHaveEndpointBeanWithoutWebExtension() {
		this.contextRunner.withBean(Scheduler.class, () -> mock(Scheduler.class))
			.withPropertyValues('management.endpoints.web.exposure.include=info', 'spring.jmx.enabled=true',
					'management.endpoints.jmx.exposure.include=quartz')
			.run((context) -> assertThat(context).hasSingleBean(QuartzEndpoint.class)
				.doesNotHaveBean(QuartzEndpointWebExtension.class));
	}
	@Test
	@SuppressWarnings('unchecked')
	void rolesCanBeConfiguredViaTheEnvironment() {
		this.contextRunner.withBean(Scheduler.class, () -> mock(Scheduler.class))
			.withPropertyValues('management.endpoint.quartz.roles: test')
			.withPropertyValues('management.endpoints.web.exposure.include=quartz')
			.withSystemProperties('dbPassword=123456', 'apiKey=123456')
			.run((context) -> {
				assertThat(context).hasSingleBean(QuartzEndpointWebExtension.class);
				QuartzEndpointWebExtension endpoint = context.getBean(QuartzEndpointWebExtension.class);
				Set<String> roles = (Set<String>) ReflectionTestUtils.getField(endpoint, 'roles');
				assertThat(roles).contains('test');
			});
	}
	@Test
	void showValuesCanBeConfiguredViaTheEnvironment() {
		this.contextRunner.withBean(Scheduler.class, () -> mock(Scheduler.class))
			.withPropertyValues('management.endpoint.quartz.show-values: WHEN_AUTHORIZED')
			.withPropertyValues('management.endpoints.web.exposure.include=quartz')
			.withSystemProperties('dbPassword=123456', 'apiKey=123456')
			.run((context) -> {
				assertThat(context).hasSingleBean(QuartzEndpointWebExtension.class);
				assertThat(context.getBean(QuartzEndpointWebExtension.class)).extracting('showValues')
					.isEqualTo(Show.WHEN_AUTHORIZED);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomEndpointConfiguration {
		@Bean
		CustomEndpoint customEndpoint() {
			return new CustomEndpoint();
		}
	}
	private static final class CustomEndpoint extends QuartzEndpoint {
		private CustomEndpoint() {
			super(mock(Scheduler.class), Collections.emptyList());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cache;
/**
class CachesEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CachesEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withBean(CacheManager.class, () -> mock(CacheManager.class))
			.withPropertyValues('management.endpoints.web.exposure.include=caches')
			.run((context) -> assertThat(context).hasSingleBean(CachesEndpoint.class));
	}
	@Test
	void runWithoutCacheManagerShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=caches')
			.run((context) -> assertThat(context).hasSingleBean(CachesEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.withBean(CacheManager.class, () -> mock(CacheManager.class))
			.run((context) -> assertThat(context).doesNotHaveBean(CachesEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.caches.enabled:false')
			.withPropertyValues('management.endpoints.web.exposure.include=*')
			.withBean(CacheManager.class, () -> mock(CacheManager.class))
			.run((context) -> assertThat(context).doesNotHaveBean(CachesEndpoint.class));
	}
	@Test
	void runWhenOnlyExposedOverJmxShouldHaveEndpointBeanWithoutWebExtension() {
		this.contextRunner.withBean(CacheManager.class, () -> mock(CacheManager.class))
			.withPropertyValues('management.endpoints.web.exposure.include=info', 'spring.jmx.enabled=true',
					'management.endpoints.jmx.exposure.include=caches')
			.run((context) -> assertThat(context).hasSingleBean(CachesEndpoint.class)
				.doesNotHaveBean(CachesEndpointWebExtension.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.exchanges;
/**
class HttpExchangesEndpointAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(HttpExchangesAutoConfiguration.class, HttpExchangesEndpointAutoConfiguration.class));
	@Test
	void runWhenRepositoryBeanAvailableShouldHaveEndpointBean() {
		this.contextRunner.withUserConfiguration(HttpExchangeRepositoryConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=httpexchanges')
			.run((context) -> assertThat(context).hasSingleBean(HttpExchangesEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.withUserConfiguration(HttpExchangeRepositoryConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(HttpExchangesEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withUserConfiguration(HttpExchangeRepositoryConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=httpexchanges')
			.withPropertyValues('management.endpoint.httpexchanges.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(HttpExchangesEndpoint.class));
	}
	@Test
	void endpointBacksOffWhenRepositoryIsNotAvailable() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=httpexchanges')
			.run((context) -> assertThat(context).doesNotHaveBean(HttpExchangesEndpoint.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class HttpExchangeRepositoryConfiguration {
		@Bean
		InMemoryHttpExchangeRepository customHttpExchangeRepository() {
			return new InMemoryHttpExchangeRepository();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.exchanges;
/**
class HttpExchangesAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HttpExchangesAutoConfiguration.class));
	@Test
	void autoConfigurationIsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(HttpExchangesAutoConfiguration.class));
	}
	@Test
	void autoConfigurationIsEnabledWhenHttpExchangeRepositoryBeanPresent() {
		this.contextRunner.withUserConfiguration(CustomHttpExchangesRepositoryConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(HttpExchangesFilter.class);
			assertThat(context).hasSingleBean(HttpExchangeRepository.class);
			assertThat(context.getBean(HttpExchangeRepository.class)).isInstanceOf(CustomHttpExchangesRepository.class);
		});
	}
	@Test
	void usesUserProvidedWebFilterWhenReactiveContext() {
		new ReactiveWebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(HttpExchangesAutoConfiguration.class))
			.withUserConfiguration(CustomHttpExchangesRepositoryConfiguration.class)
			.withUserConfiguration(CustomWebFilterConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(HttpExchangesWebFilter.class);
				assertThat(context.getBean(HttpExchangesWebFilter.class))
					.isInstanceOf(CustomHttpExchangesWebFilter.class);
			});
	}
	@Test
	void configuresServletFilter() {
		this.contextRunner.withUserConfiguration(CustomHttpExchangesRepositoryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(HttpExchangesFilter.class));
	}
	@Test
	void usesUserProvidedServletFilter() {
		this.contextRunner.withUserConfiguration(CustomHttpExchangesRepositoryConfiguration.class)
			.withUserConfiguration(CustomFilterConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(HttpExchangesFilter.class);
				assertThat(context.getBean(HttpExchangesFilter.class)).isInstanceOf(CustomHttpExchangesFilter.class);
			});
	}
	@Test
	void backsOffWhenNotRecording() {
		this.contextRunner.withUserConfiguration(CustomHttpExchangesRepositoryConfiguration.class)
			.withPropertyValues('management.httpexchanges.recording.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(InMemoryHttpExchangeRepository.class)
				.doesNotHaveBean(HttpExchangesFilter.class));
	}
	static class CustomHttpExchangesRepository implements HttpExchangeRepository {
		@Override
		public List<HttpExchange> findAll() {
			return null;
		}
		@Override
		public void add(HttpExchange exchange) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHttpExchangesRepositoryConfiguration {
		@Bean
		CustomHttpExchangesRepository customRepository() {
			return new CustomHttpExchangesRepository();
		}
	}
	private static final class CustomHttpExchangesWebFilter extends HttpExchangesWebFilter {
		private CustomHttpExchangesWebFilter(HttpExchangeRepository repository, Set<Include> includes) {
			super(repository, includes);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebFilterConfiguration {
		@Bean
		CustomHttpExchangesWebFilter customWebFilter(HttpExchangeRepository repository,
				HttpExchangesProperties properties) {
			return new CustomHttpExchangesWebFilter(repository, properties.getRecording().getInclude());
		}
	}
	private static final class CustomHttpExchangesFilter extends HttpExchangesFilter {
		private CustomHttpExchangesFilter(HttpExchangeRepository repository, Set<Include> includes) {
			super(repository, includes);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomFilterConfiguration {
		@Bean
		CustomHttpExchangesFilter customWebFilter(HttpExchangeRepository repository, Set<Include> includes) {
			return new CustomHttpExchangesFilter(repository, includes);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
class ManagementContextConfigurationImportSelectorTests {
	@Test
	void selectImportsShouldOrderResult() {
		String[] imports = new TestManagementContextConfigurationsImportSelector(C.class, A.class, D.class, B.class)
			.selectImports(AnnotationMetadata.introspect(EnableChildContext.class));
		assertThat(imports).containsExactly(A.class.getName(), B.class.getName(), C.class.getName(), D.class.getName());
	}
	@Test
	void selectImportsFiltersChildOnlyConfigurationWhenUsingSameContext() {
		String[] imports = new TestManagementContextConfigurationsImportSelector(ChildOnly.class, SameOnly.class,
				A.class)
			.selectImports(AnnotationMetadata.introspect(EnableSameContext.class));
		assertThat(imports).containsExactlyInAnyOrder(SameOnly.class.getName(), A.class.getName());
	}
	@Test
	void selectImportsFiltersSameOnlyConfigurationWhenUsingChildContext() {
		String[] imports = new TestManagementContextConfigurationsImportSelector(ChildOnly.class, SameOnly.class,
				A.class)
			.selectImports(AnnotationMetadata.introspect(EnableChildContext.class));
		assertThat(imports).containsExactlyInAnyOrder(ChildOnly.class.getName(), A.class.getName());
	}
	@Test
	void selectImportsLoadsFromResources() {
		String[] imports = new ManagementContextConfigurationImportSelector()
			.selectImports(AnnotationMetadata.introspect(EnableChildContext.class));
		Set<String> expected = new HashSet<>();
		ImportCandidates
			.load(ManagementContextConfiguration.class,
					ManagementContextConfigurationImportSelectorTests.class.getClassLoader())
			.forEach(expected::add);
		// Remove JerseySameManagementContextConfiguration, as it specifies
		// ManagementContextType.SAME and we asked for ManagementContextType.CHILD
		expected.remove(
				'org.springframework.boot.actuate.autoconfigure.web.jersey.JerseySameManagementContextConfiguration');
		assertThat(imports).containsExactlyInAnyOrderElementsOf(expected);
	}
	private static final class TestManagementContextConfigurationsImportSelector
			extends ManagementContextConfigurationImportSelector {
		private final List<String> factoryNames;
		private TestManagementContextConfigurationsImportSelector(Class<?>... classes) {
			this.factoryNames = Stream.of(classes).map(Class::getName).toList();
		}
		@Override
		protected List<String> loadFactoryNames() {
			return this.factoryNames;
		}
	}
	@Order(1)
	static class A {
	}
	@Order(2)
	static class B {
	}
	@Order(3)
	static class C {
	}
	static class D {
	}
	@ManagementContextConfiguration(ManagementContextType.CHILD)
	static class ChildOnly {
	}
	@ManagementContextConfiguration(ManagementContextType.SAME)
	static class SameOnly {
	}
	@EnableManagementContext(ManagementContextType.CHILD)
	static class EnableChildContext {
	}
	@EnableManagementContext(ManagementContextType.SAME)
	static class EnableSameContext {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
class ManagementServerPropertiesTests {
	@Test
	void defaultPortIsNull() {
		ManagementServerProperties properties = new ManagementServerProperties();
		assertThat(properties.getPort()).isNull();
	}
	@Test
	void definedPort() {
		ManagementServerProperties properties = new ManagementServerProperties();
		properties.setPort(123);
		assertThat(properties.getPort()).isEqualTo(123);
	}
	@Test
	void defaultBasePathIsEmptyString() {
		ManagementServerProperties properties = new ManagementServerProperties();
		assertThat(properties.getBasePath()).isEmpty();
	}
	@Test
	void definedBasePath() {
		ManagementServerProperties properties = new ManagementServerProperties();
		properties.setBasePath('/foo');
		assertThat(properties.getBasePath()).isEqualTo('/foo');
	}
	@Test
	void trailingSlashOfBasePathIsRemoved() {
		ManagementServerProperties properties = new ManagementServerProperties();
		properties.setBasePath('/foo/');
		assertThat(properties.getBasePath()).isEqualTo('/foo');
	}
	@Test
	void slashOfBasePathIsDefaultValue() {
		ManagementServerProperties properties = new ManagementServerProperties();
		properties.setBasePath('/');
		assertThat(properties.getBasePath()).isEmpty();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@ExtendWith(OutputCaptureExtension.class)
class ManagementContextAutoConfigurationTests {
	@Test
	void childManagementContextShouldStartForEmbeddedServer(CapturedOutput output) {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
					WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class));
		contextRunner.withPropertyValues('server.port=0', 'management.server.port=0')
			.run((context) -> assertThat(output).satisfies(numberOfOccurrences('Tomcat started on port', 2)));
	}
	@Test
	void childManagementContextShouldNotStartWithoutEmbeddedServer(CapturedOutput output) {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
					WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class));
		contextRunner.withPropertyValues('server.port=0', 'management.server.port=0').run((context) -> {
			assertThat(context).hasNotFailed();
			assertThat(output).doesNotContain('Tomcat started');
		});
	}
	@Test
	void childManagementContextShouldRestartWhenParentIsStoppedThenStarted(CapturedOutput output) {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
					WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class));
		contextRunner.withPropertyValues('server.port=0', 'management.server.port=0').run((context) -> {
			assertThat(output).satisfies(numberOfOccurrences('Tomcat started on port', 2));
			context.getSourceApplicationContext().stop();
			context.getSourceApplicationContext().start();
			assertThat(output).satisfies(numberOfOccurrences('Tomcat started on port', 4));
		});
	}
	@Test
	void givenSamePortManagementServerWhenManagementServerAddressIsConfiguredThenContextRefreshFails() {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
					WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class,
					DispatcherServletAutoConfiguration.class));
		contextRunner.withPropertyValues('server.port=0', 'management.server.address=127.0.0.1')
			.run((context) -> assertThat(context).getFailure()
				.hasMessageStartingWith('Management-specific server address cannot be configured'));
	}
	private <T extends CharSequence> Consumer<T> numberOfOccurrences(String substring, int expectedCount) {
		return (charSequence) -> {
			int count = StringUtils.countOccurrencesOf(charSequence.toString(), substring);
			assertThat(count).isEqualTo(expectedCount);
		};
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@ExtendWith(OutputCaptureExtension.class)
@DirtiesUrlFactories
class ChildManagementContextInitializerAotTests {
	@Test
	@CompileWithForkedClassLoader
	@SuppressWarnings('unchecked')
	void aotContributedInitializerStartsManagementContext(CapturedOutput output) {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
					WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class));
		contextRunner.withPropertyValues('server.port=0', 'management.server.port=0').prepare((context) -> {
			TestGenerationContext generationContext = new TestGenerationContext(TestTarget.class);
			ClassName className = new ApplicationContextAotGenerator().processAheadOfTime(
					(GenericApplicationContext) context.getSourceApplicationContext(), generationContext);
			generationContext.writeGeneratedContent();
			TestCompiler compiler = TestCompiler.forSystem();
			compiler.with(generationContext).compile((compiled) -> {
				ServletWebServerApplicationContext freshApplicationContext = new ServletWebServerApplicationContext();
				TestPropertyValues.of('server.port=0', 'management.server.port=0').applyTo(freshApplicationContext);
				ApplicationContextInitializer<GenericApplicationContext> initializer = compiled
					.getInstance(ApplicationContextInitializer.class, className.toString());
				initializer.initialize(freshApplicationContext);
				assertThat(output).satisfies(numberOfOccurrences('Tomcat started on port', 0));
				TestPropertyValues.of(AotDetector.AOT_ENABLED + '=true')
					.applyToSystemProperties(freshApplicationContext::refresh);
				assertThat(output).satisfies(numberOfOccurrences('Tomcat started on port', 2));
			});
		});
	}
	private <T extends CharSequence> Consumer<T> numberOfOccurrences(String substring, int expectedCount) {
		return (charSequence) -> {
			int count = StringUtils.countOccurrencesOf(charSequence.toString(), substring);
			assertThat(count).isEqualTo(expectedCount);
		};
	}
	static class TestTarget {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web;
/**
class ManagementContextConfigurationTests {
	@Test
	void proxyBeanMethodsIsEnabledByDefault() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(DefaultManagementContextConfiguration.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', true);
	}
	@Test
	void proxyBeanMethodsCanBeDisabled() {
		AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(
				NoBeanMethodProxyingManagementContextConfiguration.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', false);
	}
	@ManagementContextConfiguration
	static class DefaultManagementContextConfiguration {
	}
	@ManagementContextConfiguration(proxyBeanMethods = false)
	static class NoBeanMethodProxyingManagementContextConfiguration {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.jersey;
/**
@ClassPathExclusions('spring-webmvc-*')
class JerseyChildManagementContextConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withUserConfiguration(JerseyChildManagementContextConfiguration.class);
	@Test
	void autoConfigurationIsConditionalOnServletWebApplication() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(JerseySameManagementContextConfiguration.class));
		contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(JerseySameManagementContextConfiguration.class));
	}
	@Test
	void autoConfigurationIsConditionalOnClassResourceConfig() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(ResourceConfig.class))
			.run((context) -> assertThat(context).doesNotHaveBean(JerseySameManagementContextConfiguration.class));
	}
	@Test
	void jerseyApplicationPathIsAutoConfigured() {
		this.contextRunner.run((context) -> {
			JerseyApplicationPath bean = context.getBean(JerseyApplicationPath.class);
			assertThat(bean.getPath()).isEqualTo('/');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void servletRegistrationBeanIsAutoConfigured() {
		this.contextRunner.run((context) -> {
			ServletRegistrationBean<ServletContainer> bean = context.getBean(ServletRegistrationBean.class);
			assertThat(bean.getUrlMappings()).containsExactly('/*');
		});
	}
	@Test
	void resourceConfigCustomizerBeanIsNotRequired() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ResourceConfig.class));
	}
	@Test
	void resourceConfigIsCustomizedWithResourceConfigCustomizerBean() {
		this.contextRunner.withUserConfiguration(CustomizerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ResourceConfig.class);
			ResourceConfig config = context.getBean(ResourceConfig.class);
			ManagementContextResourceConfigCustomizer customizer = context
				.getBean(ManagementContextResourceConfigCustomizer.class);
			then(customizer).should().customize(config);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		ManagementContextResourceConfigCustomizer resourceConfigCustomizer() {
			return mock(ManagementContextResourceConfigCustomizer.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.jersey;
/**
@ClassPathExclusions('spring-webmvc-*')
class JerseySameManagementContextConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JerseySameManagementContextConfiguration.class));
	@Test
	void autoConfigurationIsConditionalOnServletWebApplication() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(JerseySameManagementContextConfiguration.class));
		contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(JerseySameManagementContextConfiguration.class));
	}
	@Test
	void autoConfigurationIsConditionalOnClassResourceConfig() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(ResourceConfig.class))
			.run((context) -> assertThat(context).doesNotHaveBean(JerseySameManagementContextConfiguration.class));
	}
	@Test
	void jerseyApplicationPathIsAutoConfiguredWhenNeeded() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(DefaultJerseyApplicationPath.class));
	}
	@Test
	void jerseyApplicationPathIsConditionalOnMissingBean() {
		this.contextRunner.withUserConfiguration(ConfigWithJerseyApplicationPath.class).run((context) -> {
			assertThat(context).hasSingleBean(JerseyApplicationPath.class);
			assertThat(context).hasBean('testJerseyApplicationPath');
		});
	}
	@Test
	void existingResourceConfigBeanShouldNotAutoConfigureRelatedBeans() {
		this.contextRunner.withUserConfiguration(ConfigWithResourceConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(ResourceConfig.class);
			assertThat(context).doesNotHaveBean(JerseyApplicationPath.class);
			assertThat(context).doesNotHaveBean(ServletRegistrationBean.class);
			assertThat(context).hasBean('customResourceConfig');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void servletRegistrationBeanIsAutoConfiguredWhenNeeded() {
		this.contextRunner.withPropertyValues('spring.jersey.application-path=/jersey').run((context) -> {
			ServletRegistrationBean<ServletContainer> bean = context.getBean(ServletRegistrationBean.class);
			assertThat(bean.getUrlMappings()).containsExactly('/jersey/*');
		});
	}
	@Test
	void resourceConfigIsCustomizedWithResourceConfigCustomizerBean() {
		this.contextRunner.withUserConfiguration(CustomizerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ResourceConfig.class);
			ResourceConfig config = context.getBean(ResourceConfig.class);
			ManagementContextResourceConfigCustomizer customizer = context
				.getBean(ManagementContextResourceConfigCustomizer.class);
			then(customizer).should().customize(config);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigWithJerseyApplicationPath {
		@Bean
		JerseyApplicationPath testJerseyApplicationPath() {
			return mock(JerseyApplicationPath.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigWithResourceConfig {
		@Bean
		ResourceConfig customResourceConfig() {
			return new ResourceConfig();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		ManagementContextResourceConfigCustomizer resourceConfigCustomizer() {
			return mock(ManagementContextResourceConfigCustomizer.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.mappings;
/**
class MappingsEndpointAutoConfigurationTests {
	@Test
	void whenEndpointIsUnavailableThenEndpointAndDescriptionProvidersAreNotCreated() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(MappingsEndpointAutoConfiguration.class,
					JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
					WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
					EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
					WebMvcEndpointManagementContextConfiguration.class, PropertyPlaceholderAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(MappingsEndpoint.class);
				assertThat(context).doesNotHaveBean(MappingDescriptionProvider.class);
			});
	}
	@Test
	void whenEndpointIsAvailableThenEndpointAndDescriptionProvidersAreCreated() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(MappingsEndpointAutoConfiguration.class,
					JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
					WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
					EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
					WebMvcEndpointManagementContextConfiguration.class, PropertyPlaceholderAutoConfiguration.class))
			.withPropertyValues('management.endpoints.web.exposure.include=mappings')
			.run((context) -> {
				assertThat(context).hasSingleBean(MappingsEndpoint.class);
				assertThat(context.getBeansOfType(MappingDescriptionProvider.class)).hasSize(3);
			});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
class ManagementErrorEndpointTests {
	private final ErrorAttributes errorAttributes = new DefaultErrorAttributes();
	private final ErrorProperties errorProperties = new ErrorProperties();
	private final MockHttpServletRequest request = new MockHttpServletRequest();
	@BeforeEach
	void setUp() {
		this.request.setAttribute('jakarta.servlet.error.exception', new RuntimeException('test exception'));
	}
	@Test
	void errorResponseNeverDetails() {
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(new MockHttpServletRequest()));
		assertThat(response).doesNotContainKey('message');
		assertThat(response).doesNotContainKey('trace');
	}
	@Test
	void errorResponseAlwaysDetails() {
		this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeAttribute.ALWAYS);
		this.errorProperties.setIncludeMessage(ErrorProperties.IncludeAttribute.ALWAYS);
		this.request.addParameter('trace', 'false');
		this.request.addParameter('message', 'false');
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(this.request));
		assertThat(response).containsEntry('message', 'test exception');
		assertThat(response).hasEntrySatisfying('trace',
				(value) -> assertThat(value).asString().startsWith('java.lang.RuntimeException: test exception'));
	}
	@Test
	void errorResponseParamsAbsent() {
		this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeAttribute.ON_PARAM);
		this.errorProperties.setIncludeMessage(ErrorProperties.IncludeAttribute.ON_PARAM);
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(this.request));
		assertThat(response).doesNotContainKey('message');
		assertThat(response).doesNotContainKey('trace');
	}
	@Test
	void errorResponseParamsTrue() {
		this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeAttribute.ON_PARAM);
		this.errorProperties.setIncludeMessage(ErrorProperties.IncludeAttribute.ON_PARAM);
		this.request.addParameter('trace', 'true');
		this.request.addParameter('message', 'true');
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(this.request));
		assertThat(response).containsEntry('message', 'test exception');
		assertThat(response).hasEntrySatisfying('trace',
				(value) -> assertThat(value).asString().startsWith('java.lang.RuntimeException: test exception'));
	}
	@Test
	void errorResponseParamsFalse() {
		this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeAttribute.ON_PARAM);
		this.errorProperties.setIncludeMessage(ErrorProperties.IncludeAttribute.ON_PARAM);
		this.request.addParameter('trace', 'false');
		this.request.addParameter('message', 'false');
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(this.request));
		assertThat(response).doesNotContainKey('message');
		assertThat(response).doesNotContainKey('trace');
	}
	@Test
	void errorResponseWithCustomErrorAttributesUsingDeprecatedApi() {
		ErrorAttributes attributes = new ErrorAttributes() {
			@Override
			public Map<String, Object> getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
				return Collections.singletonMap('message', 'An error occurred');
			}
			@Override
			public Throwable getError(WebRequest webRequest) {
				return null;
			}
		};
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(attributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(new MockHttpServletRequest()));
		assertThat(response).containsExactly(entry('message', 'An error occurred'));
	}
	@Test
	void errorResponseWithDefaultErrorAttributesSubclassUsingDelegation() {
		ErrorAttributes attributes = new DefaultErrorAttributes() {
			@Override
			public Map<String, Object> getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
				Map<String, Object> response = super.getErrorAttributes(webRequest, options);
				response.put('error', 'custom error');
				response.put('custom', 'value');
				response.remove('path');
				return response;
			}
		};
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(attributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(new MockHttpServletRequest()));
		assertThat(response).containsEntry('error', 'custom error');
		assertThat(response).containsEntry('custom', 'value');
		assertThat(response).doesNotContainKey('path');
		assertThat(response).containsKey('timestamp');
	}
	@Test
	void errorResponseWithDefaultErrorAttributesSubclassWithoutDelegation() {
		ErrorAttributes attributes = new DefaultErrorAttributes() {
			@Override
			public Map<String, Object> getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
				return Collections.singletonMap('error', 'custom error');
			}
		};
		ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(attributes, this.errorProperties);
		Map<String, Object> response = endpoint.invoke(new ServletWebRequest(new MockHttpServletRequest()));
		assertThat(response).containsExactly(entry('error', 'custom error'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
class CompositeHandlerExceptionResolverTests {
	private AnnotationConfigApplicationContext context;
	private final MockHttpServletRequest request = new MockHttpServletRequest();
	private final MockHttpServletResponse response = new MockHttpServletResponse();
	@Test
	void resolverShouldDelegateToOtherResolversInContext() {
		load(TestConfiguration.class);
		CompositeHandlerExceptionResolver resolver = (CompositeHandlerExceptionResolver) this.context
			.getBean(DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME);
		ModelAndView resolved = resolver.resolveException(this.request, this.response, null,
				new HttpRequestMethodNotSupportedException('POST'));
		assertThat(resolved.getViewName()).isEqualTo('test-view');
	}
	@Test
	void resolverShouldAddDefaultResolverIfNonePresent() {
		load(BaseConfiguration.class);
		CompositeHandlerExceptionResolver resolver = (CompositeHandlerExceptionResolver) this.context
			.getBean(DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME);
		HttpRequestMethodNotSupportedException exception = new HttpRequestMethodNotSupportedException('POST');
		ModelAndView resolved = resolver.resolveException(this.request, this.response, null, exception);
		assertThat(resolved).isNotNull();
		assertThat(resolved.isEmpty()).isTrue();
	}
	private void load(Class<?>... configs) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(configs);
		context.refresh();
		this.context = context;
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean(name = DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME)
		CompositeHandlerExceptionResolver compositeHandlerExceptionResolver() {
			return new CompositeHandlerExceptionResolver();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class TestConfiguration {
		@Bean
		HandlerExceptionResolver testResolver() {
			return new TestHandlerExceptionResolver();
		}
	}
	static class TestHandlerExceptionResolver implements HandlerExceptionResolver {
		@Override
		public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
				Exception ex) {
			return new ModelAndView('test-view');
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
public class MockServletWebServerFactory extends AbstractServletWebServerFactory {
	private MockServletWebServer webServer;
	@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		this.webServer = spy(new MockServletWebServer(mergeInitializers(initializers), getPort()));
		return this.webServer;
	}
	public MockServletWebServer getWebServer() {
		return this.webServer;
	}
	public ServletContext getServletContext() {
		return (getWebServer() != null) ? getWebServer().getServletContext() : null;
	}
	public RegisteredServlet getRegisteredServlet(int index) {
		return (getWebServer() != null) ? getWebServer().getRegisteredServlet(index) : null;
	}
	public RegisteredFilter getRegisteredFilter(int index) {
		return (getWebServer() != null) ? getWebServer().getRegisteredFilters(index) : null;
	}
	static class MockServletWebServer extends org.springframework.boot.testsupport.web.servlet.MockServletWebServer
			implements WebServer {
		MockServletWebServer(ServletContextInitializer[] initializers, int port) {
			super(Arrays.stream(initializers)
				.map((initializer) -> (Initializer) initializer::onStartup)
				.toArray(Initializer[]::new), port);
		}
		@Override
		public void start() {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
class WebMvcEndpointChildContextConfigurationIntegrationTests {
	private final WebApplicationContextRunner runner = new WebApplicationContextRunner(
			AnnotationConfigServletWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class,
				ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class))
		.withUserConfiguration(SucceedingEndpoint.class, FailingEndpoint.class, FailingControllerEndpoint.class)
		.withInitializer(new ServerPortInfoApplicationContextInitializer())
		.withPropertyValues('server.port=0', 'management.server.port=0', 'management.endpoints.web.exposure.include=*',
				'server.error.include-exception=true', 'server.error.include-message=always',
				'server.error.include-binding-errors=always');
	@TempDir
	Path temp;
	@Test // gh-17938
	void errorEndpointIsUsedWithEndpoint() {
		this.runner.run(withWebTestClient((client) -> {
			Map<String, ?> body = client.get()
				.uri('actuator/fail')
				.accept(MediaType.APPLICATION_JSON)
				.exchangeToMono(toResponseBody())
				.block();
			assertThat(body).hasEntrySatisfying('exception',
					(value) -> assertThat(value).asString().contains('IllegalStateException'));
			assertThat(body).hasEntrySatisfying('message',
					(value) -> assertThat(value).asString().contains('Epic Fail'));
		}));
	}
	@Test
	void errorPageAndErrorControllerIncludeDetails() {
		this.runner.withPropertyValues('server.error.include-stacktrace=always', 'server.error.include-message=always')
			.run(withWebTestClient((client) -> {
				Map<String, ?> body = client.get()
					.uri('actuator/fail')
					.accept(MediaType.APPLICATION_JSON)
					.exchangeToMono(toResponseBody())
					.block();
				assertThat(body).hasEntrySatisfying('message',
						(value) -> assertThat(value).asString().contains('Epic Fail'));
				assertThat(body).hasEntrySatisfying('trace',
						(value) -> assertThat(value).asString().contains('java.lang.IllegalStateException: Epic Fail'));
			}));
	}
	@Test
	void errorEndpointIsUsedWithRestControllerEndpoint() {
		this.runner.run(withWebTestClient((client) -> {
			Map<String, ?> body = client.get()
				.uri('actuator/failController')
				.accept(MediaType.APPLICATION_JSON)
				.exchangeToMono(toResponseBody())
				.block();
			assertThat(body).hasEntrySatisfying('exception',
					(value) -> assertThat(value).asString().contains('IllegalStateException'));
			assertThat(body).hasEntrySatisfying('message',
					(value) -> assertThat(value).asString().contains('Epic Fail'));
		}));
	}
	@Test
	void errorEndpointIsUsedWithRestControllerEndpointOnBindingError() {
		this.runner.run(withWebTestClient((client) -> {
			Map<String, ?> body = client.post()
				.uri('actuator/failController')
				.bodyValue(Collections.singletonMap('content', ''))
				.accept(MediaType.APPLICATION_JSON)
				.exchangeToMono(toResponseBody())
				.block();
			assertThat(body).hasEntrySatisfying('exception',
					(value) -> assertThat(value).asString().contains('MethodArgumentNotValidException'));
			assertThat(body).hasEntrySatisfying('message',
					(value) -> assertThat(value).asString().contains('Validation failed'));
			assertThat(body).hasEntrySatisfying('errors',
					(value) -> assertThat(value).asInstanceOf(InstanceOfAssertFactories.LIST).isNotEmpty());
		}));
	}
	@Test
	void whenManagementServerBasePathIsConfiguredThenEndpointsAreBeneathThatPath() {
		this.runner.withPropertyValues('management.server.base-path:/manage').run(withWebTestClient((client) -> {
			String body = client.get()
				.uri('manage/actuator/success')
				.accept(MediaType.APPLICATION_JSON)
				.exchangeToMono((response) -> response.bodyToMono(String.class))
				.block();
			assertThat(body).isEqualTo('Success');
		}));
	}
	@Test // gh-32941
	void whenManagementServerPortLoadedFromConfigTree() {
		this.runner.withInitializer(this::addConfigTreePropertySource)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	private void addConfigTreePropertySource(ConfigurableApplicationContext applicationContext) {
		try {
			applicationContext.getEnvironment()
				.setConversionService((ConfigurableConversionService) ApplicationConversionService.getSharedInstance());
			Path configtree = this.temp.resolve('configtree');
			Path file = configtree.resolve('management/server/port');
			file.toFile().getParentFile().mkdirs();
			FileCopyUtils.copy('0'.getBytes(StandardCharsets.UTF_8), file.toFile());
			ConfigTreePropertySource source = new ConfigTreePropertySource('configtree', configtree);
			applicationContext.getEnvironment().getPropertySources().addFirst(source);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private ContextConsumer<AssertableWebApplicationContext> withWebTestClient(Consumer<WebClient> webClient) {
		return (context) -> {
			String port = context.getEnvironment().getProperty('local.management.port');
			WebClient client = WebClient.create('http://localhost:' + port);
			webClient.accept(client);
		};
	}
	private Function<ClientResponse, ? extends Mono<Map<String, ?>>> toResponseBody() {
		return ((clientResponse) -> clientResponse.bodyToMono(new ParameterizedTypeReference<Map<String, ?>>() {
		}));
	}
	@Endpoint(id = 'fail')
	static class FailingEndpoint {
		@ReadOperation
		String fail() {
			throw new IllegalStateException('Epic Fail');
		}
	}
	@Endpoint(id = 'success')
	static class SucceedingEndpoint {
		@ReadOperation
		String fail() {
			return 'Success';
		}
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'failController')
	@SuppressWarnings('removal')
	static class FailingControllerEndpoint {
		@GetMapping
		String fail() {
			throw new IllegalStateException('Epic Fail');
		}
		@PostMapping(produces = 'application/json')
		@ResponseBody
		String bodyValidation(@Valid @RequestBody TestBody body) {
			return body.getContent();
		}
	}
	public static class TestBody {
		@NotEmpty
		private String content;
		public String getContent() {
			return this.content;
		}
		public void setContent(String content) {
			this.content = content;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
class WebMvcEndpointChildContextConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withAllowBeanDefinitionOverriding(true);
	@Test
	void contextShouldConfigureRequestContextFilter() {
		this.contextRunner.withUserConfiguration(WebMvcEndpointChildContextConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(OrderedRequestContextFilter.class));
	}
	@Test
	void contextShouldNotConfigureRequestContextFilterWhenPresent() {
		this.contextRunner.withUserConfiguration(ExistingConfig.class, WebMvcEndpointChildContextConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RequestContextFilter.class);
				assertThat(context).hasBean('testRequestContextFilter');
			});
	}
	@Test
	void contextShouldNotConfigureRequestContextFilterWhenRequestContextListenerPresent() {
		this.contextRunner
			.withUserConfiguration(RequestContextListenerConfig.class, WebMvcEndpointChildContextConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RequestContextListener.class);
				assertThat(context).doesNotHaveBean(OrderedRequestContextFilter.class);
			});
	}
	@Test
	void contextShouldConfigureDispatcherServletPathWithRootPath() {
		this.contextRunner.withUserConfiguration(WebMvcEndpointChildContextConfiguration.class)
			.run((context) -> assertThat(context.getBean(DispatcherServletPath.class).getPath()).isEqualTo('/'));
	}
	@Configuration(proxyBeanMethods = false)
	static class ExistingConfig {
		@Bean
		RequestContextFilter testRequestContextFilter() {
			return new RequestContextFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RequestContextListenerConfig {
		@Bean
		RequestContextListener testRequestContextListener() {
			return new RequestContextListener();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.reactive;
/**
class ReactiveManagementChildContextConfigurationIntegrationTests {
	private final ReactiveWebApplicationContextRunner runner = new ReactiveWebApplicationContextRunner(
			AnnotationConfigReactiveWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class,
				ReactiveWebServerFactoryAutoConfiguration.class, ReactiveManagementContextAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class, HttpHandlerAutoConfiguration.class,
				WebFluxAutoConfiguration.class))
		.withUserConfiguration(SucceedingEndpoint.class)
		.withInitializer(new ServerPortInfoApplicationContextInitializer())
		.withPropertyValues('server.port=0', 'management.server.port=0', 'management.endpoints.web.exposure.include=*');
	@TempDir
	Path temp;
	@Test
	void endpointsAreBeneathActuatorByDefault() {
		this.runner.withPropertyValues('management.server.port:0').run(withWebTestClient((client) -> {
			String body = client.get()
				.uri('actuator/success')
				.accept(MediaType.APPLICATION_JSON)
				.exchangeToMono((response) -> response.bodyToMono(String.class))
				.block();
			assertThat(body).isEqualTo('Success');
		}));
	}
	@Test
	void whenManagementServerBasePathIsConfiguredThenEndpointsAreBeneathThatPath() {
		this.runner.withPropertyValues('management.server.port:0', 'management.server.base-path:/manage')
			.run(withWebTestClient((client) -> {
				String body = client.get()
					.uri('manage/actuator/success')
					.accept(MediaType.APPLICATION_JSON)
					.exchangeToMono((response) -> response.bodyToMono(String.class))
					.block();
				assertThat(body).isEqualTo('Success');
			}));
	}
	@Test // gh-32941
	void whenManagementServerPortLoadedFromConfigTree() {
		this.runner.withInitializer(this::addConfigTreePropertySource)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	private void addConfigTreePropertySource(ConfigurableApplicationContext applicationContext) {
		try {
			applicationContext.getEnvironment()
				.setConversionService((ConfigurableConversionService) ApplicationConversionService.getSharedInstance());
			Path configtree = this.temp.resolve('configtree');
			Path file = configtree.resolve('management/server/port');
			file.toFile().getParentFile().mkdirs();
			FileCopyUtils.copy('0'.getBytes(StandardCharsets.UTF_8), file.toFile());
			ConfigTreePropertySource source = new ConfigTreePropertySource('configtree', configtree);
			applicationContext.getEnvironment().getPropertySources().addFirst(source);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private ContextConsumer<AssertableReactiveWebApplicationContext> withWebTestClient(Consumer<WebClient> webClient) {
		return (context) -> {
			String port = context.getEnvironment().getProperty('local.management.port');
			WebClient client = WebClient.create('http://localhost:' + port);
			webClient.accept(client);
		};
	}
	@Endpoint(id = 'success')
	static class SucceedingEndpoint {
		@ReadOperation
		String fail() {
			return 'Success';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integration;
/**
class IntegrationGraphEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JmxAutoConfiguration.class, IntegrationAutoConfiguration.class,
				IntegrationGraphEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=integrationgraph')
			.run((context) -> assertThat(context).hasSingleBean(IntegrationGraphEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.integrationgraph.enabled:false').run((context) -> {
			assertThat(context).doesNotHaveBean(IntegrationGraphEndpoint.class);
			assertThat(context).doesNotHaveBean(IntegrationGraphServer.class);
		});
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(IntegrationGraphEndpoint.class);
			assertThat(context).doesNotHaveBean(IntegrationGraphServer.class);
		});
	}
	@Test
	void runWhenSpringIntegrationIsNotEnabledShouldNotHaveEndpointBean() {
		ApplicationContextRunner noSpringIntegrationRunner = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(IntegrationGraphEndpointAutoConfiguration.class));
		noSpringIntegrationRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(IntegrationGraphEndpoint.class);
			assertThat(context).doesNotHaveBean(IntegrationGraphServer.class);
		});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@ExtendWith(MockitoExtension.class)
class AutoConfiguredHealthEndpointGroupTests {
	@Mock
	private StatusAggregator statusAggregator;
	@Mock
	private HttpCodeStatusMapper httpCodeStatusMapper;
	@Mock
	private SecurityContext securityContext;
	@Mock
	private Principal principal;
	@Test
	void isMemberWhenMemberPredicateMatchesAcceptsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> name.startsWith('a'),
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.ALWAYS, Collections.emptySet(), null);
		assertThat(group.isMember('albert')).isTrue();
		assertThat(group.isMember('arnold')).isTrue();
	}
	@Test
	void isMemberWhenMemberPredicateRejectsReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> name.startsWith('a'),
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.ALWAYS, Collections.emptySet(), null);
		assertThat(group.isMember('bert')).isFalse();
		assertThat(group.isMember('ernie')).isFalse();
	}
	@Test
	void showDetailsWhenShowDetailsIsNeverReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.NEVER, Collections.emptySet(), null);
		assertThat(group.showDetails(SecurityContext.NONE)).isFalse();
	}
	@Test
	void showDetailsWhenShowDetailsIsAlwaysReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.ALWAYS, Collections.emptySet(), null);
		assertThat(group.showDetails(SecurityContext.NONE)).isTrue();
	}
	@Test
	void showDetailsWhenShowDetailsIsWhenAuthorizedAndPrincipalIsNullReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.WHEN_AUTHORIZED, Collections.emptySet(),
				null);
		given(this.securityContext.getPrincipal()).willReturn(null);
		assertThat(group.showDetails(this.securityContext)).isFalse();
	}
	@Test
	void showDetailsWhenShowDetailsIsWhenAuthorizedAndRolesAreEmptyReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.WHEN_AUTHORIZED, Collections.emptySet(),
				null);
		given(this.securityContext.getPrincipal()).willReturn(this.principal);
		assertThat(group.showDetails(this.securityContext)).isTrue();
	}
	@Test
	void showDetailsWhenShowDetailsIsWhenAuthorizedAndUseIsInRoleReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.WHEN_AUTHORIZED,
				Arrays.asList('admin', 'root', 'bossmode'), null);
		given(this.securityContext.getPrincipal()).willReturn(this.principal);
		given(this.securityContext.isUserInRole('admin')).willReturn(false);
		given(this.securityContext.isUserInRole('root')).willReturn(true);
		assertThat(group.showDetails(this.securityContext)).isTrue();
	}
	@Test
	void showDetailsWhenShowDetailsIsWhenAuthorizedAndUserIsNotInRoleReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.WHEN_AUTHORIZED,
				Arrays.asList('admin', 'root', 'bossmode'), null);
		given(this.securityContext.getPrincipal()).willReturn(this.principal);
		assertThat(group.showDetails(this.securityContext)).isFalse();
	}
	@Test
	void showDetailsWhenShowDetailsIsWhenAuthorizedAndUserHasRightAuthorityReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.WHEN_AUTHORIZED,
				Arrays.asList('admin', 'root', 'bossmode'), null);
		Authentication principal = mock(Authentication.class);
		given(principal.getAuthorities())
			.willAnswer((invocation) -> Collections.singleton(new SimpleGrantedAuthority('admin')));
		given(this.securityContext.getPrincipal()).willReturn(principal);
		assertThat(group.showDetails(this.securityContext)).isTrue();
	}
	@Test
	void showDetailsWhenShowDetailsIsWhenAuthorizedAndUserDoesNotHaveRightAuthoritiesReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.WHEN_AUTHORIZED,
				Arrays.asList('admin', 'rot', 'bossmode'), null);
		Authentication principal = mock(Authentication.class);
		given(principal.getAuthorities())
			.willAnswer((invocation) -> Collections.singleton(new SimpleGrantedAuthority('other')));
		given(this.securityContext.getPrincipal()).willReturn(principal);
		assertThat(group.showDetails(this.securityContext)).isFalse();
	}
	@Test
	void showComponentsWhenShowComponentsIsNullDelegatesToShowDetails() {
		AutoConfiguredHealthEndpointGroup alwaysGroup = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.ALWAYS, Collections.emptySet(), null);
		assertThat(alwaysGroup.showComponents(SecurityContext.NONE)).isTrue();
		AutoConfiguredHealthEndpointGroup neverGroup = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.NEVER, Collections.emptySet(), null);
		assertThat(neverGroup.showComponents(SecurityContext.NONE)).isFalse();
	}
	@Test
	void showComponentsWhenShowComponentsIsNeverReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.NEVER, Show.ALWAYS, Collections.emptySet(),
				null);
		assertThat(group.showComponents(SecurityContext.NONE)).isFalse();
	}
	@Test
	void showComponentsWhenShowComponentsIsAlwaysReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.ALWAYS, Show.NEVER, Collections.emptySet(),
				null);
		assertThat(group.showComponents(SecurityContext.NONE)).isTrue();
	}
	@Test
	void showComponentsWhenShowComponentsIsWhenAuthorizedAndPrincipalIsNullReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.WHEN_AUTHORIZED, Show.NEVER,
				Collections.emptySet(), null);
		given(this.securityContext.getPrincipal()).willReturn(null);
		assertThat(group.showComponents(this.securityContext)).isFalse();
	}
	@Test
	void showComponentsWhenShowComponentsIsWhenAuthorizedAndRolesAreEmptyReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.WHEN_AUTHORIZED, Show.NEVER,
				Collections.emptySet(), null);
		given(this.securityContext.getPrincipal()).willReturn(this.principal);
		assertThat(group.showComponents(this.securityContext)).isTrue();
	}
	@Test
	void showComponentsWhenShowComponentsIsWhenAuthorizedAndUseIsInRoleReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.WHEN_AUTHORIZED, Show.NEVER,
				Arrays.asList('admin', 'root', 'bossmode'), null);
		given(this.securityContext.getPrincipal()).willReturn(this.principal);
		given(this.securityContext.isUserInRole('admin')).willReturn(false);
		given(this.securityContext.isUserInRole('root')).willReturn(true);
		assertThat(group.showComponents(this.securityContext)).isTrue();
	}
	@Test
	void showComponentsWhenShowComponentsIsWhenAuthorizedAndUserIsNotInRoleReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.WHEN_AUTHORIZED, Show.NEVER,
				Arrays.asList('admin', 'rot', 'bossmode'), null);
		given(this.securityContext.getPrincipal()).willReturn(this.principal);
		assertThat(group.showComponents(this.securityContext)).isFalse();
	}
	@Test
	void showComponentsWhenShowComponentsIsWhenAuthorizedAndUserHasRightAuthoritiesReturnsTrue() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.WHEN_AUTHORIZED, Show.NEVER,
				Arrays.asList('admin', 'root', 'bossmode'), null);
		Authentication principal = mock(Authentication.class);
		given(principal.getAuthorities())
			.willAnswer((invocation) -> Collections.singleton(new SimpleGrantedAuthority('admin')));
		given(this.securityContext.getPrincipal()).willReturn(principal);
		assertThat(group.showComponents(this.securityContext)).isTrue();
	}
	@Test
	void showComponentsWhenShowComponentsIsWhenAuthorizedAndUserDoesNotHaveRightAuthoritiesReturnsFalse() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, Show.WHEN_AUTHORIZED, Show.NEVER,
				Arrays.asList('admin', 'rot', 'bossmode'), null);
		Authentication principal = mock(Authentication.class);
		given(principal.getAuthorities())
			.willAnswer((invocation) -> Collections.singleton(new SimpleGrantedAuthority('other')));
		given(this.securityContext.getPrincipal()).willReturn(principal);
		assertThat(group.showComponents(this.securityContext)).isFalse();
	}
	@Test
	void getStatusAggregatorReturnsStatusAggregator() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.ALWAYS, Collections.emptySet(), null);
		assertThat(group.getStatusAggregator()).isSameAs(this.statusAggregator);
	}
	@Test
	void getHttpCodeStatusMapperReturnsHttpCodeStatusMapper() {
		AutoConfiguredHealthEndpointGroup group = new AutoConfiguredHealthEndpointGroup((name) -> true,
				this.statusAggregator, this.httpCodeStatusMapper, null, Show.ALWAYS, Collections.emptySet(), null);
		assertThat(group.getHttpCodeStatusMapper()).isSameAs(this.httpCodeStatusMapper);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class NoSuchHealthContributorFailureAnalyzerTests {
	private final ApplicationContextRunner runner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class));
	@Test
	void analyzesMissingRequiredConfiguration() throws Throwable {
		FailureAnalysis analysis = new NoSuchHealthContributorFailureAnalyzer().analyze(createFailure());
		assertThat(analysis).isNotNull();
		assertThat(analysis.getDescription())
			.isEqualTo('Included health contributor "dummy" in group "readiness" does not exist');
		assertThat(analysis.getAction()).isEqualTo('Update your application to correct the invalid configuration.\n'
				+ 'You can also set "management.endpoint.health.validate-group-membership" to false to disable the validation.');
	}
	private Throwable createFailure() throws Throwable {
		AtomicReference<Throwable> failure = new AtomicReference<>();
		this.runner.withPropertyValues('management.endpoint.health.group.readiness.include=dummy').run((context) -> {
			assertThat(context).hasFailed();
			failure.set(context.getStartupFailure());
		});
		Throwable throwable = failure.get();
		if (throwable instanceof NoSuchHealthContributorException) {
			return throwable;
		}
		throw throwable;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class CompositeHealthContributorConfigurationTests
		extends AbstractCompositeHealthContributorConfigurationTests<HealthContributor, TestHealthIndicator> {
	@Override
	protected AbstractCompositeHealthContributorConfiguration<HealthContributor, TestHealthIndicator, TestBean> newComposite() {
		return new TestCompositeHealthContributorConfiguration();
	}
	static class TestCompositeHealthContributorConfiguration
			extends CompositeHealthContributorConfiguration<TestHealthIndicator, TestBean> {
		TestCompositeHealthContributorConfiguration() {
			super(TestHealthIndicator::new);
		}
	}
	static class TestHealthIndicator extends AbstractHealthIndicator {
		TestHealthIndicator(TestBean testBean) {
		}
		@Override
		protected void doHealthCheck(Builder builder) throws Exception {
			builder.up();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class AutoConfiguredReactiveHealthContributorRegistryTests {
	@Test
	void createWhenContributorsClashesWithGroupNameThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new AutoConfiguredReactiveHealthContributorRegistry(
					Collections.singletonMap('boot', mock(ReactiveHealthContributor.class)),
					Arrays.asList('spring', 'boot')))
			.withMessage('ReactiveHealthContributor with name \'boot\' clashes with group');
	}
	@Test
	void registerContributorWithGroupNameThrowsException() {
		ReactiveHealthContributorRegistry registry = new AutoConfiguredReactiveHealthContributorRegistry(
				Collections.emptyMap(), Arrays.asList('spring', 'boot'));
		assertThatIllegalStateException()
			.isThrownBy(() -> registry.registerContributor('spring', mock(ReactiveHealthContributor.class)))
			.withMessage('ReactiveHealthContributor with name \'spring\' clashes with group');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class IncludeExcludeGroupMemberPredicateTests {
	@Test
	void testWhenEmptyIncludeAndExcludeAcceptsAll() {
		Predicate<String> predicate = new IncludeExcludeGroupMemberPredicate(null, null);
		assertThat(predicate).accepts('a', 'b', 'c');
	}
	@Test
	void testWhenStarIncludeAndEmptyExcludeAcceptsAll() {
		Predicate<String> predicate = include('*').exclude();
		assertThat(predicate).accepts('a', 'b', 'c');
	}
	@Test
	void testWhenEmptyIncludeAndNonEmptyExcludeAcceptsAllButExclude() {
		Predicate<String> predicate = new IncludeExcludeGroupMemberPredicate(null, Collections.singleton('c'));
		assertThat(predicate).accepts('a', 'b');
	}
	@Test
	void testWhenStarIncludeAndSpecificExcludeDoesNotAcceptExclude() {
		Predicate<String> predicate = include('*').exclude('c');
		assertThat(predicate).accepts('a', 'b').rejects('c');
	}
	@Test
	void testWhenSpecificIncludeAcceptsOnlyIncluded() {
		Predicate<String> predicate = include('a', 'b').exclude();
		assertThat(predicate).accepts('a', 'b').rejects('c');
	}
	@Test
	void testWhenSpecifiedIncludeAndSpecifiedExcludeAcceptsAsExpected() {
		Predicate<String> predicate = include('a', 'b', 'c').exclude('c');
		assertThat(predicate).accepts('a', 'b').rejects('c', 'd');
	}
	@Test
	void testWhenSpecifiedIncludeAndStarExcludeRejectsAll() {
		Predicate<String> predicate = include('a', 'b', 'c').exclude('*');
		assertThat(predicate).rejects('a', 'b', 'c', 'd');
	}
	@Test
	void testWhenCamelCaseIncludeAcceptsOnlyIncluded() {
		Predicate<String> predicate = include('myEndpoint').exclude();
		assertThat(predicate).accepts('myEndpoint').rejects('d');
	}
	@Test
	void testWhenHyphenCaseIncludeAcceptsOnlyIncluded() {
		Predicate<String> predicate = include('my-endpoint').exclude();
		assertThat(predicate).accepts('my-endpoint').rejects('d');
	}
	@Test
	void testWhenExtraWhitespaceAcceptsTrimmedVersion() {
		Predicate<String> predicate = include('  myEndpoint  ').exclude();
		assertThat(predicate).accepts('myEndpoint').rejects('d');
	}
	@Test
	void testWhenSpecifiedIncludeWithSlash() {
		Predicate<String> predicate = include('test/a').exclude();
		assertThat(predicate).accepts('test/a').rejects('test').rejects('test/b');
	}
	@Test
	void specifiedIncludeShouldIncludeNested() {
		Predicate<String> predicate = include('test').exclude();
		assertThat(predicate).accepts('test/a/d').accepts('test/b').rejects('foo');
	}
	@Test
	void specifiedIncludeShouldNotIncludeExcludedNested() {
		Predicate<String> predicate = include('test').exclude('test/b');
		assertThat(predicate).accepts('test/a').rejects('test/b').rejects('foo');
	}
	@Test // gh-29251
	void specifiedExcludeShouldExcludeNestedChildren() {
		Predicate<String> predicate = include('*').exclude('test');
		assertThat(predicate).rejects('test').rejects('test/a').rejects('test/a').accepts('other');
	}
	private Builder include(String... include) {
		return new Builder(include);
	}
	private static class Builder {
		private final String[] include;
		Builder(String[] include) {
			this.include = include;
		}
		Predicate<String> exclude(String... exclude) {
			return new IncludeExcludeGroupMemberPredicate(asSet(this.include), asSet(exclude));
		}
		private Set<String> asSet(String[] names) {
			return (names != null) ? new LinkedHashSet<>(Arrays.asList(names)) : null;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class HealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HealthContributorAutoConfiguration.class));
	@Test
	void runWhenNoOtherIndicatorsCreatesPingHealthIndicator() {
		this.contextRunner.run((context) -> assertThat(context).getBean(HealthIndicator.class)
			.isInstanceOf(PingHealthIndicator.class));
	}
	@Test
	void runWhenHasDefinedIndicatorCreatesPingHealthIndicator() {
		this.contextRunner.withUserConfiguration(CustomHealthIndicatorConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(PingHealthIndicator.class)
				.hasSingleBean(CustomHealthIndicator.class));
	}
	@Test
	void runWhenHasDefaultsDisabledDoesNotCreatePingHealthIndicator() {
		this.contextRunner.withUserConfiguration(CustomHealthIndicatorConfiguration.class)
			.withPropertyValues('management.health.defaults.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(HealthIndicator.class));
	}
	@Test
	void runWhenHasDefaultsDisabledAndPingIndicatorEnabledCreatesPingHealthIndicator() {
		this.contextRunner.withUserConfiguration(CustomHealthIndicatorConfiguration.class)
			.withPropertyValues('management.health.defaults.enabled:false', 'management.health.ping.enabled:true')
			.run((context) -> assertThat(context).hasSingleBean(PingHealthIndicator.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHealthIndicatorConfiguration {
		@Bean
		@ConditionalOnEnabledHealthIndicator('custom')
		HealthIndicator customHealthIndicator() {
			return new CustomHealthIndicator();
		}
	}
	static class CustomHealthIndicator implements HealthIndicator {
		@Override
		public Health health() {
			return Health.down().build();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class AutoConfiguredHealthEndpointGroupsTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(AutoConfiguredHealthEndpointGroupsTestConfiguration.class));
	@Test
	void getPrimaryGroupMatchesAllMembers() {
		this.contextRunner.run((context) -> {
			HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
			HealthEndpointGroup primary = groups.getPrimary();
			assertThat(primary.isMember('a')).isTrue();
			assertThat(primary.isMember('b')).isTrue();
			assertThat(primary.isMember('C')).isTrue();
		});
	}
	@Test
	void getNamesReturnsGroupNames() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.b.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				assertThat(groups.getNames()).containsExactlyInAnyOrder('a', 'b');
			});
	}
	@Test
	void getGroupWhenGroupExistsReturnsGroup() {
		this.contextRunner.withPropertyValues('management.endpoint.health.group.a.include=*').run((context) -> {
			HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
			HealthEndpointGroup group = groups.get('a');
			assertThat(group).isNotNull();
		});
	}
	@Test
	void getGroupWhenGroupDoesNotExistReturnsNull() {
		this.contextRunner.withPropertyValues('management.endpoint.health.group.a.include=*').run((context) -> {
			HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
			HealthEndpointGroup group = groups.get('b');
			assertThat(group).isNull();
		});
	}
	@Test
	void createWhenNoDefinedBeansAdaptsProperties() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.show-components=always',
					'management.endpoint.health.show-details=never', 'management.endpoint.health.status.order=up,down',
					'management.endpoint.health.status.http-mapping.down=200')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				assertThat(primary.showComponents(SecurityContext.NONE)).isTrue();
				assertThat(primary.showDetails(SecurityContext.NONE)).isFalse();
				assertThat(primary.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN))
					.isEqualTo(Status.UP);
				assertThat(primary.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(200);
			});
	}
	@Test
	void createWhenHasStatusAggregatorBeanReturnsInstanceWithAggregatorUsedForAllGroups() {
		this.contextRunner.withUserConfiguration(CustomStatusAggregatorConfiguration.class)
			.withPropertyValues('management.endpoint.health.status.order=up,down',
					'management.endpoint.health.group.a.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				assertThat(primary.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UNKNOWN);
				assertThat(groupA.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UNKNOWN);
			});
	}
	@Test
	void createWhenHasStatusAggregatorBeanAndGroupSpecificPropertyReturnsInstanceThatUsesBeanOnlyForUnconfiguredGroups() {
		this.contextRunner.withUserConfiguration(CustomStatusAggregatorConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.order=up,down',
					'management.endpoint.health.group.b.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UNKNOWN);
				assertThat(groupA.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UP);
				assertThat(groupB.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UNKNOWN);
			});
	}
	@Test
	void createWhenHasStatusAggregatorPropertyReturnsInstanceWithPropertyUsedForAllGroups() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.status.order=up,down',
					'management.endpoint.health.group.a.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				assertThat(primary.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN))
					.isEqualTo(Status.UP);
				assertThat(groupA.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN))
					.isEqualTo(Status.UP);
			});
	}
	@Test
	void createWhenHasStatusAggregatorPropertyAndGroupSpecificPropertyReturnsInstanceWithPropertyUsedForExpectedGroups() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.status.order=up,down',
					'management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.order=unknown,up,down',
					'management.endpoint.health.group.b.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UP);
				assertThat(groupA.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UNKNOWN);
				assertThat(groupB.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UP);
			});
	}
	@Test
	void createWhenHasStatusAggregatorPropertyAndGroupQualifiedBeanReturnsInstanceWithBeanUsedForExpectedGroups() {
		this.contextRunner.withUserConfiguration(CustomStatusAggregatorGroupAConfiguration.class)
			.withPropertyValues('management.endpoint.health.status.order=up,down',
					'management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.order=up,down',
					'management.endpoint.health.group.b.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UP);
				assertThat(groupA.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UNKNOWN);
				assertThat(groupB.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UP);
			});
	}
	@Test
	void createWhenHasGroupSpecificStatusAggregatorPropertyAndGroupQualifiedBeanReturnsInstanceWithBeanUsedForExpectedGroups() {
		this.contextRunner.withUserConfiguration(CustomStatusAggregatorGroupAConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.order=up,down',
					'management.endpoint.health.group.b.include=*',
					'management.endpoint.health.group.b.status.order=up,down')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.DOWN);
				assertThat(groupA.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UNKNOWN);
				assertThat(groupB.getStatusAggregator().getAggregateStatus(Status.UP, Status.DOWN, Status.UNKNOWN))
					.isEqualTo(Status.UP);
			});
	}
	@Test
	void createWhenHasHttpCodeStatusMapperBeanReturnsInstanceWithMapperUsedForAllGroups() {
		this.contextRunner.withUserConfiguration(CustomHttpCodeStatusMapperConfiguration.class)
			.withPropertyValues('management.endpoint.health.status.http-mapping.down=201',
					'management.endpoint.health.group.a.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				assertThat(primary.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(200);
				assertThat(groupA.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(200);
			});
	}
	@Test
	void createWhenHasHttpCodeStatusMapperBeanAndGroupSpecificPropertyReturnsInstanceThatUsesBeanOnlyForUnconfiguredGroups() {
		this.contextRunner.withUserConfiguration(CustomHttpCodeStatusMapperConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.http-mapping.down=201',
					'management.endpoint.health.group.b.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(200);
				assertThat(groupA.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
				assertThat(groupB.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(200);
			});
	}
	@Test
	void createWhenHasHttpCodeStatusMapperPropertyReturnsInstanceWithPropertyUsedForAllGroups() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.status.http-mapping.down=201',
					'management.endpoint.health.group.a.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				assertThat(primary.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
				assertThat(groupA.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
			});
	}
	@Test
	void createWhenHasHttpCodeStatusMapperPropertyAndGroupSpecificPropertyReturnsInstanceWithPropertyUsedForExpectedGroups() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.status.http-mapping.down=201',
					'management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.http-mapping.down=202',
					'management.endpoint.health.group.b.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
				assertThat(groupA.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(202);
				assertThat(groupB.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
			});
	}
	@Test
	void createWhenHasHttpCodeStatusMapperPropertyAndGroupQualifiedBeanReturnsInstanceWithBeanUsedForExpectedGroups() {
		this.contextRunner.withUserConfiguration(CustomHttpCodeStatusMapperGroupAConfiguration.class)
			.withPropertyValues('management.endpoint.health.status.http-mapping.down=201',
					'management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.http-mapping.down=201',
					'management.endpoint.health.group.b.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
				assertThat(groupA.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(200);
				assertThat(groupB.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
			});
	}
	@Test
	void createWhenHasGroupSpecificHttpCodeStatusMapperPropertyAndGroupQualifiedBeanReturnsInstanceWithBeanUsedForExpectedGroups() {
		this.contextRunner.withUserConfiguration(CustomHttpCodeStatusMapperGroupAConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.a.include=*',
					'management.endpoint.health.group.a.status.http-mapping.down=201',
					'management.endpoint.health.group.b.include=*',
					'management.endpoint.health.group.b.status.http-mapping.down=201')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup primary = groups.getPrimary();
				HealthEndpointGroup groupA = groups.get('a');
				HealthEndpointGroup groupB = groups.get('b');
				assertThat(primary.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(503);
				assertThat(groupA.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(200);
				assertThat(groupB.getHttpCodeStatusMapper().getStatusCode(Status.DOWN)).isEqualTo(201);
			});
	}
	@Test
	void createWhenGroupWithNoShowDetailsOverrideInheritsShowDetails() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.show-details=always',
					'management.endpoint.health.group.a.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				HealthEndpointGroup groupA = groups.get('a');
				assertThat(groupA.showDetails(SecurityContext.NONE)).isTrue();
			});
	}
	@Test
	void getAdditionalPathsReturnsAllAdditionalPaths() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.group.a.additional-path=server:/a',
					'management.endpoint.health.group.b.additional-path=server:/b',
					'management.endpoint.health.group.c.additional-path=management:/c',
					'management.endpoint.health.group.d.additional-path=management:/d')
			.run((context) -> {
				AdditionalPathsMapper additionalPathsMapper = context.getBean(AdditionalPathsMapper.class);
				assertThat(additionalPathsMapper.getAdditionalPaths(HealthEndpoint.ID, WebServerNamespace.SERVER))
					.containsExactlyInAnyOrder('/a', '/b');
				assertThat(additionalPathsMapper.getAdditionalPaths(HealthEndpoint.ID, WebServerNamespace.MANAGEMENT))
					.containsExactlyInAnyOrder('/c', '/d');
				assertThat(additionalPathsMapper.getAdditionalPaths(EndpointId.of('other'), WebServerNamespace.SERVER))
					.isNull();
			});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(HealthEndpointProperties.class)
	static class AutoConfiguredHealthEndpointGroupsTestConfiguration {
		@Bean
		AutoConfiguredHealthEndpointGroups healthEndpointGroups(ConfigurableApplicationContext applicationContext,
				HealthEndpointProperties properties) {
			return new AutoConfiguredHealthEndpointGroups(applicationContext, properties);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomStatusAggregatorConfiguration {
		@Bean
		@Primary
		StatusAggregator statusAggregator() {
			return new SimpleStatusAggregator(Status.UNKNOWN, Status.UP, Status.DOWN);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomStatusAggregatorGroupAConfiguration {
		@Bean
		@Qualifier('a')
		StatusAggregator statusAggregator() {
			return new SimpleStatusAggregator(Status.UNKNOWN, Status.UP, Status.DOWN);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHttpCodeStatusMapperConfiguration {
		@Bean
		@Primary
		HttpCodeStatusMapper httpCodeStatusMapper() {
			return new SimpleHttpCodeStatusMapper(Collections.singletonMap(Status.DOWN.getCode(), 200));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHttpCodeStatusMapperGroupAConfiguration {
		@Bean
		@Qualifier('a')
		HttpCodeStatusMapper httpCodeStatusMapper() {
			return new SimpleHttpCodeStatusMapper(Collections.singletonMap(Status.DOWN.getCode(), 200));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
abstract class AbstractCompositeHealthContributorConfigurationTests<C, I extends C> {
	private final Class<?> indicatorType;
	AbstractCompositeHealthContributorConfigurationTests() {
		ResolvableType type = ResolvableType.forClass(AbstractCompositeHealthContributorConfigurationTests.class,
				getClass());
		this.indicatorType = type.resolveGeneric(1);
	}
	@Test
	void createContributorWhenBeansIsEmptyThrowsException() {
		Map<String, TestBean> beans = Collections.emptyMap();
		assertThatIllegalArgumentException().isThrownBy(() -> newComposite().createContributor(beans))
			.withMessage('Beans must not be empty');
	}
	@Test
	void createContributorWhenBeansHasSingleElementCreatesIndicator() {
		Map<String, TestBean> beans = Collections.singletonMap('test', new TestBean());
		C contributor = newComposite().createContributor(beans);
		assertThat(contributor).isInstanceOf(this.indicatorType);
	}
	@Test
	void createContributorWhenBeansHasMultipleElementsCreatesComposite() {
		Map<String, TestBean> beans = new LinkedHashMap<>();
		beans.put('test1', new TestBean());
		beans.put('test2', new TestBean());
		C contributor = newComposite().createContributor(beans);
		assertThat(contributor).isNotInstanceOf(this.indicatorType);
		assertThat(ClassUtils.getShortName(contributor.getClass())).startsWith('Composite');
	}
	protected abstract AbstractCompositeHealthContributorConfiguration<C, I, TestBean> newComposite();
	static class TestBean {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class CompositeReactiveHealthContributorConfigurationTests extends
		AbstractCompositeHealthContributorConfigurationTests<ReactiveHealthContributor, TestReactiveHealthIndicator> {
	@Override
	protected AbstractCompositeHealthContributorConfiguration<ReactiveHealthContributor, TestReactiveHealthIndicator, TestBean> newComposite() {
		return new TestCompositeReactiveHealthContributorConfiguration();
	}
	static class TestCompositeReactiveHealthContributorConfiguration
			extends CompositeReactiveHealthContributorConfiguration<TestReactiveHealthIndicator, TestBean> {
		TestCompositeReactiveHealthContributorConfiguration() {
			super(TestReactiveHealthIndicator::new);
		}
	}
	static class TestReactiveHealthIndicator extends AbstractReactiveHealthIndicator {
		TestReactiveHealthIndicator(TestBean testBean) {
		}
		@Override
		protected Mono<Health> doHealthCheck(Builder builder) {
			return Mono.just(builder.up().build());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class AutoConfiguredHealthContributorRegistryTests {
	@Test
	void createWhenContributorsClashesWithGroupNameThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new AutoConfiguredHealthContributorRegistry(
					Collections.singletonMap('boot', mock(HealthContributor.class)), Arrays.asList('spring', 'boot')))
			.withMessage('HealthContributor with name \'boot\' clashes with group');
	}
	@Test
	void registerContributorWithGroupNameThrowsException() {
		HealthContributorRegistry registry = new AutoConfiguredHealthContributorRegistry(Collections.emptyMap(),
				Arrays.asList('spring', 'boot'));
		assertThatIllegalStateException()
			.isThrownBy(() -> registry.registerContributor('spring', mock(HealthContributor.class)))
			.withMessage('HealthContributor with name \'spring\' clashes with group');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class HealthEndpointAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withUserConfiguration(HealthIndicatorsConfiguration.class)
		.withConfiguration(
				AutoConfigurations.of(HealthContributorAutoConfiguration.class, HealthEndpointAutoConfiguration.class));
	private final ReactiveWebApplicationContextRunner reactiveContextRunner = new ReactiveWebApplicationContextRunner()
		.withUserConfiguration(HealthIndicatorsConfiguration.class)
		.withConfiguration(
				AutoConfigurations.of(HealthContributorAutoConfiguration.class, HealthEndpointAutoConfiguration.class,
						WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class));
	@Test
	void runWhenHealthEndpointIsDisabledDoesNotCreateBeans() {
		this.contextRunner.withPropertyValues('management.endpoint.health.enabled=false').run((context) -> {
			assertThat(context).doesNotHaveBean(StatusAggregator.class);
			assertThat(context).doesNotHaveBean(HttpCodeStatusMapper.class);
			assertThat(context).doesNotHaveBean(HealthEndpointGroups.class);
			assertThat(context).doesNotHaveBean(HealthContributorRegistry.class);
			assertThat(context).doesNotHaveBean(HealthEndpoint.class);
			assertThat(context).doesNotHaveBean(ReactiveHealthContributorRegistry.class);
			assertThat(context).doesNotHaveBean(HealthEndpointWebExtension.class);
			assertThat(context).doesNotHaveBean(ReactiveHealthEndpointWebExtension.class);
		});
	}
	@Test
	void runCreatesStatusAggregatorFromProperties() {
		this.contextRunner.withPropertyValues('management.endpoint.health.status.order=up,down').run((context) -> {
			StatusAggregator aggregator = context.getBean(StatusAggregator.class);
			assertThat(aggregator.getAggregateStatus(Status.UP, Status.DOWN)).isEqualTo(Status.UP);
		});
	}
	@Test
	void runWhenHasStatusAggregatorBeanIgnoresProperties() {
		this.contextRunner.withUserConfiguration(StatusAggregatorConfiguration.class)
			.withPropertyValues('management.endpoint.health.status.order=up,down')
			.run((context) -> {
				StatusAggregator aggregator = context.getBean(StatusAggregator.class);
				assertThat(aggregator.getAggregateStatus(Status.UP, Status.DOWN)).isEqualTo(Status.UNKNOWN);
			});
	}
	@Test
	void runCreatesHttpCodeStatusMapperFromProperties() {
		this.contextRunner.withPropertyValues('management.endpoint.health.status.http-mapping.up=123')
			.run((context) -> {
				HttpCodeStatusMapper mapper = context.getBean(HttpCodeStatusMapper.class);
				assertThat(mapper.getStatusCode(Status.UP)).isEqualTo(123);
			});
	}
	@Test
	void runWhenHasHttpCodeStatusMapperBeanIgnoresProperties() {
		this.contextRunner.withUserConfiguration(HttpCodeStatusMapperConfiguration.class)
			.withPropertyValues('management.endpoint.health.status.http-mapping.up=123')
			.run((context) -> {
				HttpCodeStatusMapper mapper = context.getBean(HttpCodeStatusMapper.class);
				assertThat(mapper.getStatusCode(Status.UP)).isEqualTo(456);
			});
	}
	@Test
	void runCreatesHealthEndpointGroups() {
		this.contextRunner.withPropertyValues('management.endpoint.health.group.ready.include=*').run((context) -> {
			HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
			assertThat(groups).isInstanceOf(AutoConfiguredHealthEndpointGroups.class);
			assertThat(groups.getNames()).containsOnly('ready');
		});
	}
	@Test
	void runFailsWhenHealthEndpointGroupIncludesContributorThatDoesNotExist() {
		this.contextRunner.withUserConfiguration(CompositeHealthIndicatorConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.ready.include=composite/b/c,nope')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).isInstanceOf(NoSuchHealthContributorException.class)
					.hasMessage('Included health contributor "nope" in group "ready" does not exist');
			});
	}
	@Test
	void runFailsWhenHealthEndpointGroupExcludesContributorThatDoesNotExist() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.group.ready.exclude=composite/b/d',
					'management.endpoint.health.group.ready.include=*')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).isInstanceOf(NoSuchHealthContributorException.class)
					.hasMessage('Excluded health contributor "composite/b/d" in group "ready" does not exist');
			});
	}
	@Test
	void runCreatesHealthEndpointGroupThatIncludesContributorThatDoesNotExistWhenValidationIsDisabled() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.validate-group-membership=false',
					'management.endpoint.health.group.ready.include=nope')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				assertThat(groups).isInstanceOf(AutoConfiguredHealthEndpointGroups.class);
				assertThat(groups.getNames()).containsOnly('ready');
			});
	}
	@Test
	void runWhenHasHealthEndpointGroupsBeanDoesNotCreateAdditionalHealthEndpointGroups() {
		this.contextRunner.withUserConfiguration(HealthEndpointGroupsConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.ready.include=*')
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				assertThat(groups.getNames()).containsOnly('mock');
			});
	}
	@Test
	void runCreatesHealthContributorRegistryContainingHealthBeans() {
		this.contextRunner.run((context) -> {
			HealthContributorRegistry registry = context.getBean(HealthContributorRegistry.class);
			Object[] names = registry.stream().map(NamedContributor::getName).toArray();
			assertThat(names).containsExactlyInAnyOrder('simple', 'additional', 'ping', 'reactive');
		});
	}
	@Test
	void runWhenNoReactorCreatesHealthContributorRegistryContainingHealthBeans() {
		ClassLoader classLoader = new FilteredClassLoader(Mono.class, Flux.class);
		this.contextRunner.withClassLoader(classLoader).run((context) -> {
			HealthContributorRegistry registry = context.getBean(HealthContributorRegistry.class);
			Object[] names = registry.stream().map(NamedContributor::getName).toArray();
			assertThat(names).containsExactlyInAnyOrder('simple', 'additional', 'ping');
		});
	}
	@Test
	void runWhenHasHealthContributorRegistryBeanDoesNotCreateAdditionalRegistry() {
		this.contextRunner.withUserConfiguration(HealthContributorRegistryConfiguration.class).run((context) -> {
			HealthContributorRegistry registry = context.getBean(HealthContributorRegistry.class);
			Object[] names = registry.stream().map(NamedContributor::getName).toArray();
			assertThat(names).isEmpty();
		});
	}
	@Test
	void runCreatesHealthEndpoint() {
		this.contextRunner.withPropertyValues('management.endpoint.health.show-details=always').run((context) -> {
			HealthEndpoint endpoint = context.getBean(HealthEndpoint.class);
			Health health = (Health) endpoint.healthForPath('simple');
			assertThat(health.getDetails()).containsEntry('counter', 42);
		});
	}
	@Test
	void runWhenHasHealthEndpointBeanDoesNotCreateAdditionalHealthEndpoint() {
		this.contextRunner.withUserConfiguration(HealthEndpointConfiguration.class).run((context) -> {
			HealthEndpoint endpoint = context.getBean(HealthEndpoint.class);
			assertThat(endpoint.health()).isNull();
		});
	}
	@Test
	void runCreatesReactiveHealthContributorRegistryContainingAdaptedBeans() {
		this.reactiveContextRunner.run((context) -> {
			ReactiveHealthContributorRegistry registry = context.getBean(ReactiveHealthContributorRegistry.class);
			Object[] names = registry.stream().map(NamedContributor::getName).toArray();
			assertThat(names).containsExactlyInAnyOrder('simple', 'additional', 'reactive', 'ping');
		});
	}
	@Test
	void runWhenHasReactiveHealthContributorRegistryBeanDoesNotCreateAdditionalReactiveHealthContributorRegistry() {
		this.reactiveContextRunner.withUserConfiguration(ReactiveHealthContributorRegistryConfiguration.class)
			.run((context) -> {
				ReactiveHealthContributorRegistry registry = context.getBean(ReactiveHealthContributorRegistry.class);
				Object[] names = registry.stream().map(NamedContributor::getName).toArray();
				assertThat(names).isEmpty();
			});
	}
	@Test
	void runCreatesHealthEndpointWebExtension() {
		this.contextRunner.run((context) -> {
			HealthEndpointWebExtension webExtension = context.getBean(HealthEndpointWebExtension.class);
			WebEndpointResponse<HealthComponent> response = webExtension.health(ApiVersion.V3,
					WebServerNamespace.SERVER, SecurityContext.NONE, true, 'simple');
			Health health = (Health) response.getBody();
			assertThat(response.getStatus()).isEqualTo(200);
			assertThat(health.getDetails()).containsEntry('counter', 42);
		});
	}
	@Test
	void runWhenHasHealthEndpointWebExtensionBeanDoesNotCreateExtraHealthEndpointWebExtension() {
		this.contextRunner.withUserConfiguration(HealthEndpointWebExtensionConfiguration.class).run((context) -> {
			HealthEndpointWebExtension webExtension = context.getBean(HealthEndpointWebExtension.class);
			WebEndpointResponse<HealthComponent> response = webExtension.health(ApiVersion.V3,
					WebServerNamespace.SERVER, SecurityContext.NONE, true, 'simple');
			assertThat(response).isNull();
		});
	}
	@Test
	void runCreatesReactiveHealthEndpointWebExtension() {
		this.reactiveContextRunner.run((context) -> {
			ReactiveHealthEndpointWebExtension webExtension = context.getBean(ReactiveHealthEndpointWebExtension.class);
			Mono<WebEndpointResponse<? extends HealthComponent>> response = webExtension.health(ApiVersion.V3,
					WebServerNamespace.SERVER, SecurityContext.NONE, true, 'simple');
			Health health = (Health) (response.block().getBody());
			assertThat(health.getDetails()).containsEntry('counter', 42);
		});
	}
	@Test
	void runWhenHasReactiveHealthEndpointWebExtensionBeanDoesNotCreateExtraReactiveHealthEndpointWebExtension() {
		this.reactiveContextRunner.withUserConfiguration(ReactiveHealthEndpointWebExtensionConfiguration.class)
			.run((context) -> {
				ReactiveHealthEndpointWebExtension webExtension = context
					.getBean(ReactiveHealthEndpointWebExtension.class);
				Mono<WebEndpointResponse<? extends HealthComponent>> response = webExtension.health(ApiVersion.V3,
						WebServerNamespace.SERVER, SecurityContext.NONE, true, 'simple');
				assertThat(response).isNull();
			});
	}
	@Test
	void runWhenHasHealthEndpointGroupsPostProcessorPerformsProcessing() {
		this.contextRunner.withPropertyValues('management.endpoint.health.group.ready.include=*')
			.withUserConfiguration(HealthEndpointGroupsConfiguration.class, TestHealthEndpointGroupsPostProcessor.class)
			.run((context) -> {
				HealthEndpointGroups groups = context.getBean(HealthEndpointGroups.class);
				assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> groups.get('test'))
					.withMessage('postprocessed');
			});
	}
	@Test
	void runWithIndicatorsInParentContextFindsIndicators() {
		new ApplicationContextRunner().withUserConfiguration(HealthIndicatorsConfiguration.class)
			.run((parent) -> new WebApplicationContextRunner()
				.withConfiguration(AutoConfigurations.of(HealthContributorAutoConfiguration.class,
						HealthEndpointAutoConfiguration.class))
				.withParent(parent)
				.run((context) -> {
					HealthComponent health = context.getBean(HealthEndpoint.class).health();
					Map<String, HealthComponent> components = ((SystemHealth) health).getComponents();
					assertThat(components).containsKeys('additional', 'ping', 'simple');
				}));
	}
	@Test
	void runWithReactiveContextAndIndicatorsInParentContextFindsIndicators() {
		new ApplicationContextRunner().withUserConfiguration(HealthIndicatorsConfiguration.class)
			.run((parent) -> new ReactiveWebApplicationContextRunner()
				.withConfiguration(AutoConfigurations.of(HealthContributorAutoConfiguration.class,
						HealthEndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
						EndpointAutoConfiguration.class))
				.withParent(parent)
				.run((context) -> {
					HealthComponent health = context.getBean(HealthEndpoint.class).health();
					Map<String, HealthComponent> components = ((SystemHealth) health).getComponents();
					assertThat(components).containsKeys('additional', 'ping', 'simple');
				}));
	}
	@Test
	void additionalHealthEndpointsPathsTolerateHealthEndpointThatIsNotWebExposed() {
		this.contextRunner
			.withConfiguration(AutoConfigurations.of(DispatcherServletAutoConfiguration.class,
					EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class))
			.withPropertyValues('management.endpoints.web.exposure.exclude=*',
					'management.endpoints.cloudfoundry.exposure.include=*', 'spring.main.cloud-platform=cloud_foundry')
			.run((context) -> {
				assertThat(context).hasSingleBean(MvcAdditionalHealthEndpointPathsConfiguration.class);
				assertThat(context).hasNotFailed();
			});
	}
	@Test
	void additionalJerseyHealthEndpointsPathsTolerateHealthEndpointThatIsNotWebExposed() {
		this.contextRunner
			.withConfiguration(
					AutoConfigurations.of(EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(DispatcherServlet.class))
			.withPropertyValues('management.endpoints.web.exposure.exclude=*',
					'management.endpoints.cloudfoundry.exposure.include=*', 'spring.main.cloud-platform=cloud_foundry')
			.withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO))
			.run((context) -> {
				assertThat(context).hasSingleBean(JerseyAdditionalHealthEndpointPathsConfiguration.class);
				assertThat(context).hasNotFailed();
			});
	}
	@Test
	void additionalReactiveHealthEndpointsPathsTolerateHealthEndpointThatIsNotWebExposed() {
		this.reactiveContextRunner
			.withConfiguration(
					AutoConfigurations.of(EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class))
			.withPropertyValues('management.endpoints.web.exposure.exclude=*',
					'management.endpoints.cloudfoundry.exposure.include=*', 'spring.main.cloud-platform=cloud_foundry')
			.run((context) -> {
				assertThat(context).hasSingleBean(WebFluxAdditionalHealthEndpointPathsConfiguration.class);
				assertThat(context).hasNotFailed();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class HealthIndicatorsConfiguration {
		@Bean
		HealthIndicator simpleHealthIndicator() {
			return () -> Health.up().withDetail('counter', 42).build();
		}
		@Bean
		HealthIndicator additionalHealthIndicator() {
			return () -> Health.up().build();
		}
		@Bean
		ReactiveHealthIndicator reactiveHealthIndicator() {
			return () -> Mono.just(Health.up().build());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CompositeHealthIndicatorConfiguration {
		@Bean
		CompositeHealthContributor compositeHealthIndicator() {
			return CompositeHealthContributor.fromMap(Map.of('a', (HealthIndicator) () -> Health.up().build(), 'b',
					CompositeHealthContributor.fromMap(Map.of('c', (HealthIndicator) () -> Health.up().build()))));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class StatusAggregatorConfiguration {
		@Bean
		StatusAggregator statusAggregator() {
			return (statuses) -> Status.UNKNOWN;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HttpCodeStatusMapperConfiguration {
		@Bean
		HttpCodeStatusMapper httpCodeStatusMapper() {
			return (status) -> 456;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HealthEndpointGroupsConfiguration {
		@Bean
		HealthEndpointGroups healthEndpointGroups() {
			HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
			given(groups.getNames()).willReturn(Collections.singleton('mock'));
			return groups;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HealthContributorRegistryConfiguration {
		@Bean
		HealthContributorRegistry healthContributorRegistry() {
			return new DefaultHealthContributorRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HealthEndpointConfiguration {
		@Bean
		HealthEndpoint healthEndpoint() {
			return mock(HealthEndpoint.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveHealthContributorRegistryConfiguration {
		@Bean
		ReactiveHealthContributorRegistry reactiveHealthContributorRegistry() {
			return new DefaultReactiveHealthContributorRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HealthEndpointWebExtensionConfiguration {
		@Bean
		HealthEndpointWebExtension healthEndpointWebExtension() {
			return mock(HealthEndpointWebExtension.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveHealthEndpointWebExtensionConfiguration {
		@Bean
		ReactiveHealthEndpointWebExtension reactiveHealthEndpointWebExtension() {
			return mock(ReactiveHealthEndpointWebExtension.class);
		}
	}
	static class TestHealthEndpointGroupsPostProcessor implements HealthEndpointGroupsPostProcessor {
		@Override
		public HealthEndpointGroups postProcessHealthEndpointGroups(HealthEndpointGroups groups) {
			given(groups.get('test')).willThrow(new RuntimeException('postprocessed'));
			return groups;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.statsd;
/**
class StatsdPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<StatsdProperties, StatsdPropertiesConfigAdapter> {
	protected StatsdPropertiesConfigAdapterTests() {
		super(StatsdPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesEnabledIsSetAdapterEnabledReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setEnabled(false);
		assertThat(new StatsdPropertiesConfigAdapter(properties).enabled()).isEqualTo(properties.isEnabled());
	}
	@Test
	void whenPropertiesFlavorIsSetAdapterFlavorReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setFlavor(StatsdFlavor.ETSY);
		assertThat(new StatsdPropertiesConfigAdapter(properties).flavor()).isEqualTo(properties.getFlavor());
	}
	@Test
	void whenPropertiesHostIsSetAdapterHostReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setHost('my-host');
		assertThat(new StatsdPropertiesConfigAdapter(properties).host()).isEqualTo(properties.getHost());
	}
	@Test
	void whenPropertiesPortIsSetAdapterPortReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setPort(1234);
		assertThat(new StatsdPropertiesConfigAdapter(properties).port()).isEqualTo(properties.getPort());
	}
	@Test
	void whenPropertiesProtocolIsSetAdapterProtocolReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setProtocol(StatsdProtocol.TCP);
		assertThat(new StatsdPropertiesConfigAdapter(properties).protocol()).isEqualTo(properties.getProtocol());
	}
	@Test
	void whenPropertiesMaxPacketLengthIsSetAdapterMaxPacketLengthReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setMaxPacketLength(1234);
		assertThat(new StatsdPropertiesConfigAdapter(properties).maxPacketLength())
			.isEqualTo(properties.getMaxPacketLength());
	}
	@Test
	void whenPropertiesPollingFrequencyIsSetAdapterPollingFrequencyReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setPollingFrequency(Duration.ofSeconds(1));
		assertThat(new StatsdPropertiesConfigAdapter(properties).pollingFrequency())
			.isEqualTo(properties.getPollingFrequency());
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setStep(Duration.ofSeconds(1));
		assertThat(new StatsdPropertiesConfigAdapter(properties).step()).isEqualTo(properties.getStep());
	}
	@Test
	void whenPropertiesPublishUnchangedMetersIsSetAdapterPublishUnchangedMetersReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setPublishUnchangedMeters(false);
		assertThat(new StatsdPropertiesConfigAdapter(properties).publishUnchangedMeters())
			.isEqualTo(properties.isPublishUnchangedMeters());
	}
	@Test
	void whenPropertiesBufferedIsSetAdapterBufferedReturnsIt() {
		StatsdProperties properties = new StatsdProperties();
		properties.setBuffered(false);
		assertThat(new StatsdPropertiesConfigAdapter(properties).buffered()).isEqualTo(properties.isBuffered());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.statsd;
/**
class StatsdMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(StatsdMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(StatsdMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigMeterRegistryAndMetrics() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(StatsdMeterRegistry.class)
				.hasSingleBean(StatsdConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(StatsdMeterRegistry.class)
				.doesNotHaveBean(StatsdConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withPropertyValues('management.statsd.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(StatsdMeterRegistry.class)
				.doesNotHaveBean(StatsdConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(StatsdMeterRegistry.class)
				.hasSingleBean(StatsdConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(StatsdMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(StatsdConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			StatsdMeterRegistry registry = context.getBean(StatsdMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		StatsdConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		StatsdMeterRegistry customRegistry(StatsdConfig config, Clock clock) {
			return new StatsdMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.statsd;
/**
class StatsdPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		StatsdProperties properties = new StatsdProperties();
		StatsdConfig config = StatsdConfig.DEFAULT;
		assertThat(properties.isEnabled()).isEqualTo(config.enabled());
		assertThat(properties.getFlavor()).isEqualTo(config.flavor());
		assertThat(properties.getHost()).isEqualTo(config.host());
		assertThat(properties.getPort()).isEqualTo(config.port());
		assertThat(properties.getProtocol()).isEqualTo(config.protocol());
		assertThat(properties.getMaxPacketLength()).isEqualTo(config.maxPacketLength());
		assertThat(properties.getPollingFrequency()).isEqualTo(config.pollingFrequency());
		assertThat(properties.getStep()).isEqualTo(config.step());
		assertThat(properties.isPublishUnchangedMeters()).isEqualTo(config.publishUnchangedMeters());
		assertThat(properties.isBuffered()).isEqualTo(config.buffered());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.jmx;
/**
class JmxPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<JmxProperties, JmxPropertiesConfigAdapter> {
	JmxPropertiesConfigAdapterTests() {
		super(JmxPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		JmxProperties properties = new JmxProperties();
		properties.setStep(Duration.ofMinutes(15));
		assertThat(new JmxPropertiesConfigAdapter(properties).step()).isEqualTo(Duration.ofMinutes(15));
	}
	@Test
	void whenPropertiesDomainIsSetAdapterDomainReturnsIt() {
		JmxProperties properties = new JmxProperties();
		properties.setDomain('abc');
		assertThat(new JmxPropertiesConfigAdapter(properties).domain()).isEqualTo('abc');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.jmx;
/**
class JmxPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		JmxProperties properties = new JmxProperties();
		JmxConfig config = JmxConfig.DEFAULT;
		assertThat(properties.getDomain()).isEqualTo(config.domain());
		assertThat(properties.getStep()).isEqualTo(config.step());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.jmx;
/**
class JmxMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JmxMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(JmxMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JmxMeterRegistry.class).hasSingleBean(JmxConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(JmxMeterRegistry.class)
				.doesNotHaveBean(JmxConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.jmx.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(JmxMeterRegistry.class)
				.doesNotHaveBean(JmxConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JmxMeterRegistry.class)
				.hasSingleBean(JmxConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JmxMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(JmxConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			JmxMeterRegistry registry = context.getBean(JmxMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		JmxConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		JmxMeterRegistry customRegistry(JmxConfig config, Clock clock) {
			return new JmxMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.graphite;
/**
class GraphitePropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		GraphiteProperties properties = new GraphiteProperties();
		GraphiteConfig config = GraphiteConfig.DEFAULT;
		assertThat(properties.isEnabled()).isEqualTo(config.enabled());
		assertThat(properties.getStep()).isEqualTo(config.step());
		assertThat(properties.getRateUnits()).isEqualTo(config.rateUnits());
		assertThat(properties.getDurationUnits()).isEqualTo(config.durationUnits());
		assertThat(properties.getHost()).isEqualTo(config.host());
		assertThat(properties.getPort()).isEqualTo(config.port());
		assertThat(properties.getProtocol()).isEqualTo(config.protocol());
		assertThat(properties.getGraphiteTagsEnabled()).isEqualTo(config.graphiteTagsEnabled());
		assertThat(properties.getTagsAsPrefix()).isEqualTo(config.tagsAsPrefix());
	}
	@Test
	void graphiteTagsAreDisabledIfTagsAsPrefixIsSet() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setTagsAsPrefix(new String[] { 'app' });
		assertThat(properties.getGraphiteTagsEnabled()).isFalse();
	}
	@Test
	void graphiteTagsCanBeEnabledEvenIfTagsAsPrefixIsSet() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setGraphiteTagsEnabled(true);
		properties.setTagsAsPrefix(new String[] { 'app' });
		assertThat(properties.getGraphiteTagsEnabled()).isTrue();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.graphite;
/**
class GraphitePropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<GraphiteProperties, GraphitePropertiesConfigAdapter> {
	GraphitePropertiesConfigAdapterTests() {
		super(GraphitePropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesEnabledIsSetAdapterEnabledReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setEnabled(false);
		assertThat(new GraphitePropertiesConfigAdapter(properties).enabled()).isFalse();
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setStep(Duration.ofMinutes(15));
		assertThat(new GraphitePropertiesConfigAdapter(properties).step()).isEqualTo(Duration.ofMinutes(15));
	}
	@Test
	void whenPropertiesRateUnitsIsSetAdapterRateUnitsReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setRateUnits(TimeUnit.MINUTES);
		assertThat(new GraphitePropertiesConfigAdapter(properties).rateUnits()).isEqualTo(TimeUnit.MINUTES);
	}
	@Test
	void whenPropertiesDurationUnitsIsSetAdapterDurationUnitsReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setDurationUnits(TimeUnit.MINUTES);
		assertThat(new GraphitePropertiesConfigAdapter(properties).durationUnits()).isEqualTo(TimeUnit.MINUTES);
	}
	@Test
	void whenPropertiesHostIsSetAdapterHostReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setHost('node');
		assertThat(new GraphitePropertiesConfigAdapter(properties).host()).isEqualTo('node');
	}
	@Test
	void whenPropertiesPortIsSetAdapterPortReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setPort(4242);
		assertThat(new GraphitePropertiesConfigAdapter(properties).port()).isEqualTo(4242);
	}
	@Test
	void whenPropertiesProtocolIsSetAdapterProtocolReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setProtocol(GraphiteProtocol.UDP);
		assertThat(new GraphitePropertiesConfigAdapter(properties).protocol()).isEqualTo(GraphiteProtocol.UDP);
	}
	@Test
	void whenPropertiesGraphiteTagsEnabledIsSetAdapterGraphiteTagsEnabledReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setGraphiteTagsEnabled(true);
		assertThat(new GraphitePropertiesConfigAdapter(properties).graphiteTagsEnabled()).isTrue();
	}
	@Test
	void whenPropertiesTagsAsPrefixIsSetAdapterTagsAsPrefixReturnsIt() {
		GraphiteProperties properties = new GraphiteProperties();
		properties.setTagsAsPrefix(new String[] { 'worker' });
		assertThat(new GraphitePropertiesConfigAdapter(properties).tagsAsPrefix()).isEqualTo(new String[] { 'worker' });
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.graphite;
/**
class GraphiteMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(GraphiteMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(GraphiteMeterRegistry.class));
	}
	@Test
	void autoConfiguresUseTagsAsPrefix() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.graphite.metrics.export.tags-as-prefix=app')
			.run((context) -> {
				assertThat(context).hasSingleBean(GraphiteMeterRegistry.class);
				GraphiteMeterRegistry registry = context.getBean(GraphiteMeterRegistry.class);
				registry.counter('test.count', Tags.of('app', 'myapp'));
				assertThat(registry.getDropwizardRegistry().getMeters()).containsOnlyKeys('myapp.testCount');
			});
	}
	@Test
	void autoConfiguresWithTagsAsPrefixCanBeDisabled() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.graphite.metrics.export.tags-as-prefix=app',
					'management.graphite.metrics.export.graphite-tags-enabled=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(GraphiteMeterRegistry.class);
				GraphiteMeterRegistry registry = context.getBean(GraphiteMeterRegistry.class);
				registry.counter('test.count', Tags.of('app', 'myapp'));
				assertThat(registry.getDropwizardRegistry().getMeters()).containsOnlyKeys('test.count;app=myapp');
			});
	}
	@Test
	void autoConfiguresItsConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(GraphiteMeterRegistry.class)
				.hasSingleBean(GraphiteConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(GraphiteMeterRegistry.class)
				.doesNotHaveBean(GraphiteConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.graphite.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(GraphiteMeterRegistry.class)
				.doesNotHaveBean(GraphiteConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(GraphiteMeterRegistry.class)
				.hasSingleBean(GraphiteConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(GraphiteMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(GraphiteConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			GraphiteMeterRegistry registry = context.getBean(GraphiteMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		GraphiteConfig customConfig() {
			return (key) -> {
				if ('Graphite.apiKey'.equals(key)) {
					return '12345';
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		GraphiteMeterRegistry customRegistry(GraphiteConfig config, Clock clock) {
			return new GraphiteMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export;
/**
class ConditionalOnEnabledMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple());
	@Test
	void exporterIsEnabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasBean('simpleMeterRegistry'));
	}
	@Test
	void exporterCanBeSpecificallyDisabled() {
		this.contextRunner.withPropertyValues('management.simple.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean('simpleMeterRegistry'));
	}
	@Test
	void exporterCanBeGloballyDisabled() {
		this.contextRunner.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean('simpleMeterRegistry'));
	}
	@Test
	void exporterCanBeGloballyDisabledWithSpecificOverride() {
		this.contextRunner
			.withPropertyValues('management.defaults.metrics.export.enabled=false',
					'management.simple.metrics.export.enabled=true')
			.run((context) -> assertThat(context).hasBean('simpleMeterRegistry'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.ganglia;
/**
class GangliaPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<GangliaProperties, GangliaPropertiesConfigAdapter> {
	GangliaPropertiesConfigAdapterTests() {
		super(GangliaPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesEnabledIsSetAdapterEnabledReturnsIt() {
		GangliaProperties properties = new GangliaProperties();
		properties.setEnabled(false);
		assertThat(new GangliaPropertiesConfigAdapter(properties).enabled()).isFalse();
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		GangliaProperties properties = new GangliaProperties();
		properties.setStep(Duration.ofMinutes(15));
		assertThat(new GangliaPropertiesConfigAdapter(properties).step()).isEqualTo(Duration.ofMinutes(15));
	}
	@Test
	void whenPropertiesDurationUnitsIsSetAdapterDurationUnitsReturnsIt() {
		GangliaProperties properties = new GangliaProperties();
		properties.setDurationUnits(TimeUnit.MINUTES);
		assertThat(new GangliaPropertiesConfigAdapter(properties).durationUnits()).isEqualTo(TimeUnit.MINUTES);
	}
	@Test
	void whenPropertiesAddressingModeIsSetAdapterAddressingModeReturnsIt() {
		GangliaProperties properties = new GangliaProperties();
		properties.setAddressingMode(UDPAddressingMode.UNICAST);
		assertThat(new GangliaPropertiesConfigAdapter(properties).addressingMode())
			.isEqualTo(UDPAddressingMode.UNICAST);
	}
	@Test
	void whenPropertiesTimeToLiveIsSetAdapterTtlReturnsIt() {
		GangliaProperties properties = new GangliaProperties();
		properties.setTimeToLive(2);
		assertThat(new GangliaPropertiesConfigAdapter(properties).ttl()).isEqualTo(2);
	}
	@Test
	void whenPropertiesHostIsSetAdapterHostReturnsIt() {
		GangliaProperties properties = new GangliaProperties();
		properties.setHost('node');
		assertThat(new GangliaPropertiesConfigAdapter(properties).host()).isEqualTo('node');
	}
	@Test
	void whenPropertiesPortIsSetAdapterPortReturnsIt() {
		GangliaProperties properties = new GangliaProperties();
		properties.setPort(4242);
		assertThat(new GangliaPropertiesConfigAdapter(properties).port()).isEqualTo(4242);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.ganglia;
/**
class GangliaPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		GangliaProperties properties = new GangliaProperties();
		GangliaConfig config = GangliaConfig.DEFAULT;
		assertThat(properties.isEnabled()).isEqualTo(config.enabled());
		assertThat(properties.getStep()).isEqualTo(config.step());
		assertThat(properties.getDurationUnits()).isEqualTo(config.durationUnits());
		assertThat(properties.getAddressingMode()).isEqualTo(config.addressingMode());
		assertThat(properties.getTimeToLive()).isEqualTo(config.ttl());
		assertThat(properties.getHost()).isEqualTo(config.host());
		assertThat(properties.getPort()).isEqualTo(config.port());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.ganglia;
/**
class GangliaMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(GangliaMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(GangliaMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(GangliaMeterRegistry.class)
				.hasSingleBean(GangliaConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(GangliaMeterRegistry.class)
				.doesNotHaveBean(GangliaConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.ganglia.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(GangliaMeterRegistry.class)
				.doesNotHaveBean(GangliaConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(GangliaMeterRegistry.class)
				.hasSingleBean(GangliaConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(GangliaMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(GangliaConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			GangliaMeterRegistry registry = context.getBean(GangliaMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		GangliaConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		GangliaMeterRegistry customRegistry(GangliaConfig config, Clock clock) {
			return new GangliaMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.elastic;
/**
class ElasticPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		ElasticProperties properties = new ElasticProperties();
		ElasticConfig config = ElasticConfig.DEFAULT;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getHost()).isEqualTo(config.host());
		assertThat(properties.getIndex()).isEqualTo(config.index());
		assertThat(properties.getIndexDateFormat()).isEqualTo(config.indexDateFormat());
		assertThat(properties.getIndexDateSeparator()).isEqualTo(config.indexDateSeparator());
		assertThat(properties.getPassword()).isEqualTo(config.password());
		assertThat(properties.getTimestampFieldName()).isEqualTo(config.timestampFieldName());
		assertThat(properties.getUserName()).isEqualTo(config.userName());
		assertThat(properties.isAutoCreateIndex()).isEqualTo(config.autoCreateIndex());
		assertThat(properties.getPipeline()).isEqualTo(config.pipeline());
		assertThat(properties.getApiKeyCredentials()).isEqualTo(config.apiKeyCredentials());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.elastic;
/**
class ElasticMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ElasticMeterRegistry.class));
	}
	@Test
	void autoConfiguresConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ElasticMeterRegistry.class)
				.hasSingleBean(ElasticConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(ElasticMeterRegistry.class)
				.doesNotHaveBean(ElasticConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.elastic.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(ElasticMeterRegistry.class)
				.doesNotHaveBean(ElasticConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ElasticMeterRegistry.class)
				.hasSingleBean(ElasticConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ElasticMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(ElasticConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			ElasticMeterRegistry registry = context.getBean(ElasticMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Test
	void apiKeyCredentialsIsMutuallyExclusiveWithUserName() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.elastic.metrics.export.api-key-credentials:secret',
					'management.elastic.metrics.export.user-name:alice')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.rootCause()
				.isInstanceOf(MutuallyExclusiveConfigurationPropertiesException.class));
	}
	@Test
	void apiKeyCredentialsIsMutuallyExclusiveWithPassword() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.elastic.metrics.export.api-key-credentials:secret',
					'management.elastic.metrics.export.password:secret')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.rootCause()
				.isInstanceOf(MutuallyExclusiveConfigurationPropertiesException.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		ElasticConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		ElasticMeterRegistry customRegistry(ElasticConfig config, Clock clock) {
			return new ElasticMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.elastic;
/**
class ElasticPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<ElasticProperties, ElasticPropertiesConfigAdapter> {
	ElasticPropertiesConfigAdapterTests() {
		super(ElasticPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesHostsIsSetAdapterHostsReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setHost('https://elastic.example.com');
		assertThat(new ElasticPropertiesConfigAdapter(properties).host()).isEqualTo('https://elastic.example.com');
	}
	@Test
	void whenPropertiesIndexIsSetAdapterIndexReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setIndex('test-metrics');
		assertThat(new ElasticPropertiesConfigAdapter(properties).index()).isEqualTo('test-metrics');
	}
	@Test
	void whenPropertiesIndexDateFormatIsSetAdapterIndexDateFormatReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setIndexDateFormat('yyyy');
		assertThat(new ElasticPropertiesConfigAdapter(properties).indexDateFormat()).isEqualTo('yyyy');
	}
	@Test
	void whenPropertiesIndexDateSeparatorIsSetAdapterIndexDateSeparatorReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setIndexDateSeparator('*');
		assertThat(new ElasticPropertiesConfigAdapter(properties).indexDateSeparator()).isEqualTo('*');
	}
	@Test
	void whenPropertiesTimestampFieldNameIsSetAdapterTimestampFieldNameReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setTimestampFieldName('@test');
		assertThat(new ElasticPropertiesConfigAdapter(properties).timestampFieldName()).isEqualTo('@test');
	}
	@Test
	void whenPropertiesAutoCreateIndexIsSetAdapterAutoCreateIndexReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setAutoCreateIndex(false);
		assertThat(new ElasticPropertiesConfigAdapter(properties).autoCreateIndex()).isFalse();
	}
	@Test
	void whenPropertiesUserNameIsSetAdapterUserNameReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setUserName('alice');
		assertThat(new ElasticPropertiesConfigAdapter(properties).userName()).isEqualTo('alice');
	}
	@Test
	void whenPropertiesPasswordIsSetAdapterPasswordReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setPassword('secret');
		assertThat(new ElasticPropertiesConfigAdapter(properties).password()).isEqualTo('secret');
	}
	@Test
	void whenPropertiesPipelineIsSetAdapterPipelineReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setPipeline('testPipeline');
		assertThat(new ElasticPropertiesConfigAdapter(properties).pipeline()).isEqualTo('testPipeline');
	}
	@Test
	void whenPropertiesApiKeyCredentialsIsSetAdapterPipelineReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setApiKeyCredentials('secret');
		assertThat(new ElasticPropertiesConfigAdapter(properties).apiKeyCredentials()).isEqualTo('secret');
	}
	@Test
	void whenPropertiesEnableSourceIsSetAdapterEnableSourceReturnsIt() {
		ElasticProperties properties = new ElasticProperties();
		properties.setEnableSource(true);
		assertThat(new ElasticPropertiesConfigAdapter(properties).enableSource()).isTrue();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class PushRegistryPropertiesTests {
	@SuppressWarnings('deprecation')
	protected void assertStepRegistryDefaultValues(PushRegistryProperties properties, PushRegistryConfig config) {
		assertThat(properties.getStep()).isEqualTo(config.step());
		assertThat(properties.isEnabled()).isEqualTo(config.enabled());
		assertThat(properties.getConnectTimeout()).isEqualTo(config.connectTimeout());
		assertThat(properties.getReadTimeout()).isEqualTo(config.readTimeout());
		assertThat(properties.getBatchSize()).isEqualTo(config.batchSize());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class PushRegistryPropertiesConfigAdapterTests<P extends PushRegistryProperties, A extends PushRegistryPropertiesConfigAdapter<P>>
		extends AbstractPropertiesConfigAdapterTests<P, PropertiesConfigAdapter<P>> {
	protected PushRegistryPropertiesConfigAdapterTests(Class<A> adapter) {
		super(adapter);
	}
	protected abstract P createProperties();
	protected abstract A createConfigAdapter(P properties);
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		P properties = createProperties();
		properties.setStep(Duration.ofSeconds(42));
		assertThat(createConfigAdapter(properties).step()).hasSeconds(42);
	}
	@Test
	void whenPropertiesEnabledIsSetAdapterEnabledReturnsIt() {
		P properties = createProperties();
		properties.setEnabled(false);
		assertThat(createConfigAdapter(properties).enabled()).isFalse();
	}
	@Test
	protected void whenPropertiesBatchSizeIsSetAdapterBatchSizeReturnsIt() {
		P properties = createProperties();
		properties.setBatchSize(10042);
		assertThat(createConfigAdapter(properties).batchSize()).isEqualTo(10042);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class StepRegistryPropertiesTests extends PushRegistryPropertiesTests {
	protected void assertStepRegistryDefaultValues(StepRegistryProperties properties, StepRegistryConfig config) {
		super.assertStepRegistryDefaultValues(properties, config);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class AbstractPropertiesConfigAdapterTests<P, A extends PropertiesConfigAdapter<P>> {
	private final Class<? extends A> adapter;
	protected AbstractPropertiesConfigAdapterTests(Class<? extends A> adapter) {
		this.adapter = adapter;
	}
	@Test
	protected void adapterOverridesAllConfigMethods() {
		adapterOverridesAllConfigMethodsExcept();
	}
	protected final void adapterOverridesAllConfigMethodsExcept(String... nonConfigMethods) {
		Class<?> config = findImplementedConfig();
		Set<String> expectedConfigMethodNames = Arrays.stream(config.getDeclaredMethods())
			.filter(Method::isDefault)
			.filter(this::hasNoParameters)
			.filter(this::isNotValidationMethod)
			.filter(this::isNotDeprecated)
			.map(Method::getName)
			.collect(Collectors.toCollection(TreeSet::new));
		expectedConfigMethodNames.removeAll(Arrays.asList(nonConfigMethods));
		Set<String> actualConfigMethodNames = new TreeSet<>();
		Class<?> currentClass = this.adapter;
		while (!Object.class.equals(currentClass)) {
			actualConfigMethodNames.addAll(Arrays.stream(currentClass.getDeclaredMethods())
				.map(Method::getName)
				.filter(expectedConfigMethodNames::contains)
				.toList());
			currentClass = currentClass.getSuperclass();
		}
		assertThat(actualConfigMethodNames).containsExactlyInAnyOrderElementsOf(expectedConfigMethodNames);
	}
	private Class<?> findImplementedConfig() {
		Class<?>[] interfaces = this.adapter.getInterfaces();
		if (interfaces.length == 1) {
			return interfaces[0];
		}
		throw new IllegalStateException(this.adapter + ' is not a config implementation');
	}
	private boolean isNotDeprecated(Method method) {
		return !AnnotatedElementUtils.hasAnnotation(method, Deprecated.class);
	}
	private boolean hasNoParameters(Method method) {
		return method.getParameterCount() == 0;
	}
	private boolean isNotValidationMethod(Method method) {
		return !Validated.class.equals(method.getReturnType());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class StepRegistryPropertiesConfigAdapterTests<P extends StepRegistryProperties, A extends StepRegistryPropertiesConfigAdapter<P>>
		extends PushRegistryPropertiesConfigAdapterTests<P, A> {
	protected StepRegistryPropertiesConfigAdapterTests(Class<A> adapter) {
		super(adapter);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
class PrometheusPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<PrometheusProperties, PrometheusPropertiesConfigAdapter> {
	PrometheusPropertiesConfigAdapterTests() {
		super(PrometheusPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesDescriptionsIsSetAdapterDescriptionsReturnsIt() {
		PrometheusProperties properties = new PrometheusProperties();
		properties.setDescriptions(false);
		assertThat(new PrometheusPropertiesConfigAdapter(properties).descriptions()).isFalse();
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		PrometheusProperties properties = new PrometheusProperties();
		properties.setStep(Duration.ofSeconds(30));
		assertThat(new PrometheusPropertiesConfigAdapter(properties).step()).isEqualTo(Duration.ofSeconds(30));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
class PrometheusPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		PrometheusProperties properties = new PrometheusProperties();
		io.micrometer.prometheusmetrics.PrometheusConfig config = io.micrometer.prometheusmetrics.PrometheusConfig.DEFAULT;
		assertThat(properties.isDescriptions()).isEqualTo(config.descriptions());
		assertThat(properties.getStep()).isEqualTo(config.step());
	}
	@SuppressWarnings('deprecation')
	@Test
	void defaultValuesAreConsistentWithSimpleclient() {
		PrometheusProperties properties = new PrometheusProperties();
		io.micrometer.prometheus.PrometheusConfig config = io.micrometer.prometheus.PrometheusConfig.DEFAULT;
		assertThat(properties.isDescriptions()).isEqualTo(config.descriptions());
		assertThat(PrometheusSimpleclientPropertiesConfigAdapter.mapToMicrometerHistogramFlavor(properties))
			.isEqualTo(config.histogramFlavor());
		assertThat(properties.getStep()).isEqualTo(config.step());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
@SuppressWarnings({ 'removal', 'deprecation' })
@ExtendWith(OutputCaptureExtension.class)
class DualPrometheusMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(PrometheusSimpleclientMetricsExportAutoConfiguration.class,
				PrometheusMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context)
			.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
			.doesNotHaveBean(io.micrometer.prometheus.PrometheusMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigPrometheusRegistryAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.doesNotHaveBean(CollectorRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusConfig.class)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.doesNotHaveBean(PrometheusRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.prometheus.metrics.export.enabled=false')
			.run((context) -> assertThat(context)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.doesNotHaveBean(CollectorRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusConfig.class)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.doesNotHaveBean(PrometheusRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class)
				.hasBean('customConfig')
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class)
				.hasBean('otherCustomConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class)
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class)
				.hasBean('otherCustomRegistry'));
	}
	@Test
	void allowsCustomCollectorRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomCollectorRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasBean('customCollectorRegistry')
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class)
				.hasBean('customPrometheusRegistry')
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void autoConfiguresExemplarSamplerIfSpanContextSupplierIsPresent() {
		this.contextRunner.withUserConfiguration(ExemplarsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SpanContextSupplier.class)
				.hasSingleBean(ExemplarSampler.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class));
	}
	@Test
	void allowsCustomExemplarSamplerToBeUsed() {
		this.contextRunner.withUserConfiguration(ExemplarsConfiguration.class)
			.withBean('customExemplarSampler', ExemplarSampler.class, () -> mock(ExemplarSampler.class))
			.run((context) -> assertThat(context).hasSingleBean(ExemplarSampler.class)
				.getBean(ExemplarSampler.class)
				.isSameAs(context.getBean('customExemplarSampler')));
	}
	@Test
	void exemplarSamplerIsNotAutoConfiguredIfSpanContextSupplierIsMissing() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(SpanContextSupplier.class)
				.doesNotHaveBean(ExemplarSampler.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class));
	}
	@Test
	void addsScrapeEndpointToManagementContext() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=prometheus')
			.run((context) -> assertThat(context).hasSingleBean(PrometheusScrapeEndpoint.class)
				.doesNotHaveBean(PrometheusSimpleclientScrapeEndpoint.class));
	}
	@Test
	void scrapeEndpointNotAddedToManagementContextWhenNotExposed() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusSimpleclientScrapeEndpoint.class)
				.doesNotHaveBean(PrometheusScrapeEndpoint.class));
	}
	@Test
	void scrapeEndpointCanBeDisabled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.endpoints.web.exposure.include=prometheus',
					'management.endpoint.prometheus.enabled=false')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusSimpleclientScrapeEndpoint.class)
				.doesNotHaveBean(PrometheusScrapeEndpoint.class));
	}
	@Test
	void allowsCustomScrapeEndpointToBeUsed() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(CustomEndpointConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customEndpoint')
				.hasSingleBean(PrometheusSimpleclientScrapeEndpoint.class));
	}
	@Test
	void allowsCustomSecondScrapeEndpointToBeUsed() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(CustomSecondEndpointConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customSecondEndpoint')
				.hasSingleBean(PrometheusSimpleclientScrapeEndpoint.class)
				.hasSingleBean(SecondPrometheusScrapeEndpoint.class)
				.hasSingleBean(PrometheusScrapeEndpoint.class));
	}
	@Test
	void pushGatewayIsNotConfiguredWhenEnabledFlagIsNotSet() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusPushGatewayManager.class));
	}
	@Test
	void withPushGatewayEnabled(CapturedOutput output) {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> {
				assertThat(output).doesNotContain('Invalid PushGateway base url');
				hasGatewayURL(context, 'http://localhost:9091/metrics/');
			});
	}
	@Test
	void withPushGatewayNoBasicAuth() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true')
			.withUserConfiguration(BaseConfiguration.class)
			.run(hasHttpConnectionFactory((httpConnectionFactory) -> assertThat(httpConnectionFactory)
				.isInstanceOf(DefaultHttpConnectionFactory.class)));
	}
	@Test
	void withCustomPushGatewayURL() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true',
					'management.prometheus.metrics.export.pushgateway.base-url=https://example.com:8080')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> hasGatewayURL(context, 'https://example.com:8080/metrics/'));
	}
	@Test
	void withPushGatewayBasicAuth() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true',
					'management.prometheus.metrics.export.pushgateway.username=admin',
					'management.prometheus.metrics.export.pushgateway.password=secret')
			.withUserConfiguration(BaseConfiguration.class)
			.run(hasHttpConnectionFactory((httpConnectionFactory) -> assertThat(httpConnectionFactory)
				.isInstanceOf(BasicAuthHttpConnectionFactory.class)));
	}
	private void hasGatewayURL(AssertableApplicationContext context, String url) {
		assertThat(getPushGateway(context)).hasFieldOrPropertyWithValue('gatewayBaseURL', url);
	}
	private ContextConsumer<AssertableApplicationContext> hasHttpConnectionFactory(
			ThrowingConsumer<HttpConnectionFactory> httpConnectionFactory) {
		return (context) -> {
			PushGateway pushGateway = getPushGateway(context);
			httpConnectionFactory
				.accept((HttpConnectionFactory) ReflectionTestUtils.getField(pushGateway, 'connectionFactory'));
		};
	}
	private PushGateway getPushGateway(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(PrometheusPushGatewayManager.class);
		PrometheusPushGatewayManager gatewayManager = context.getBean(PrometheusPushGatewayManager.class);
		return (PushGateway) ReflectionTestUtils.getField(gatewayManager, 'pushGateway');
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		io.micrometer.prometheus.PrometheusConfig customConfig() {
			return (key) -> null;
		}
		@Bean
		io.micrometer.prometheusmetrics.PrometheusConfig otherCustomConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		io.micrometer.prometheus.PrometheusMeterRegistry customRegistry(
				io.micrometer.prometheus.PrometheusConfig config, CollectorRegistry collectorRegistry, Clock clock) {
			return new io.micrometer.prometheus.PrometheusMeterRegistry(config, collectorRegistry, clock);
		}
		@Bean
		io.micrometer.prometheusmetrics.PrometheusMeterRegistry otherCustomRegistry(
				io.micrometer.prometheusmetrics.PrometheusConfig config, PrometheusRegistry prometheusRegistry,
				Clock clock) {
			return new io.micrometer.prometheusmetrics.PrometheusMeterRegistry(config, prometheusRegistry, clock);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomCollectorRegistryConfiguration {
		@Bean
		CollectorRegistry customCollectorRegistry() {
			return new CollectorRegistry();
		}
		@Bean
		PrometheusRegistry customPrometheusRegistry() {
			return new PrometheusRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomEndpointConfiguration {
		@Bean
		PrometheusSimpleclientScrapeEndpoint customEndpoint(CollectorRegistry collectorRegistry) {
			return new PrometheusSimpleclientScrapeEndpoint(collectorRegistry);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomSecondEndpointConfiguration {
		@Bean
		PrometheusScrapeEndpoint prometheusScrapeEndpoint(PrometheusRegistry prometheusRegistry,
				PrometheusConfig prometheusConfig) {
			return new PrometheusScrapeEndpoint(prometheusRegistry, prometheusConfig.prometheusProperties());
		}
		@Bean
		SecondPrometheusScrapeEndpoint customSecondEndpoint(CollectorRegistry collectorRegistry) {
			return new SecondPrometheusScrapeEndpoint(collectorRegistry);
		}
		@WebEndpoint(id = 'prometheussc')
		static class SecondPrometheusScrapeEndpoint extends PrometheusSimpleclientScrapeEndpoint {
			SecondPrometheusScrapeEndpoint(CollectorRegistry collectorRegistry) {
				super(collectorRegistry);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class ExemplarsConfiguration {
		@Bean
		SpanContextSupplier spanContextSupplier() {
			return new SpanContextSupplier() {
				@Override
				public String getTraceId() {
					return null;
				}
				@Override
				public String getSpanId() {
					return null;
				}
				@Override
				public boolean isSampled() {
					return false;
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class PrometheusSimpleclientPropertiesConfigAdapterTests extends
		AbstractPropertiesConfigAdapterTests<PrometheusProperties, PrometheusSimpleclientPropertiesConfigAdapter> {
	PrometheusSimpleclientPropertiesConfigAdapterTests() {
		super(PrometheusSimpleclientPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesDescriptionsIsSetAdapterDescriptionsReturnsIt() {
		PrometheusProperties properties = new PrometheusProperties();
		properties.setDescriptions(false);
		assertThat(new PrometheusSimpleclientPropertiesConfigAdapter(properties).descriptions()).isFalse();
	}
	@Test
	void whenPropertiesHistogramFlavorIsSetAdapterHistogramFlavorReturnsIt() {
		PrometheusProperties properties = new PrometheusProperties();
		properties.setHistogramFlavor(HistogramFlavor.VictoriaMetrics);
		assertThat(new PrometheusSimpleclientPropertiesConfigAdapter(properties).histogramFlavor())
			.isEqualTo(io.micrometer.prometheus.HistogramFlavor.VictoriaMetrics);
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		PrometheusProperties properties = new PrometheusProperties();
		properties.setStep(Duration.ofSeconds(30));
		assertThat(new PrometheusSimpleclientPropertiesConfigAdapter(properties).step())
			.isEqualTo(Duration.ofSeconds(30));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
@SuppressWarnings({ 'removal', 'deprecation' })
@ExtendWith(OutputCaptureExtension.class)
class PrometheusSimpleclientMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader('io.micrometer.prometheusmetrics.', 'io.prometheus.metrics'))
		.withConfiguration(AutoConfigurations.of(PrometheusSimpleclientMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context)
			.doesNotHaveBean(io.micrometer.prometheus.PrometheusMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigCollectorRegistryAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.doesNotHaveBean(CollectorRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.prometheus.metrics.export.enabled=false')
			.run((context) -> assertThat(context)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.doesNotHaveBean(CollectorRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheus.PrometheusConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class));
	}
	@Test
	void allowsCustomCollectorRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomCollectorRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class)
				.hasBean('customCollectorRegistry')
				.hasSingleBean(CollectorRegistry.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusConfig.class));
	}
	@Test
	void autoConfiguresExemplarSamplerIfSpanContextSupplierIsPresent() {
		this.contextRunner.withUserConfiguration(ExemplarsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SpanContextSupplier.class)
				.hasSingleBean(ExemplarSampler.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class));
	}
	@Test
	void allowsCustomExemplarSamplerToBeUsed() {
		this.contextRunner.withUserConfiguration(ExemplarsConfiguration.class)
			.withBean('customExemplarSampler', ExemplarSampler.class, () -> mock(ExemplarSampler.class))
			.run((context) -> assertThat(context).hasSingleBean(ExemplarSampler.class)
				.getBean(ExemplarSampler.class)
				.isSameAs(context.getBean('customExemplarSampler')));
	}
	@Test
	void exemplarSamplerIsNotAutoConfiguredIfSpanContextSupplierIsMissing() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(SpanContextSupplier.class)
				.doesNotHaveBean(ExemplarSampler.class)
				.hasSingleBean(io.micrometer.prometheus.PrometheusMeterRegistry.class));
	}
	@Test
	void addsScrapeEndpointToManagementContext() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=prometheus')
			.run((context) -> assertThat(context).hasSingleBean(PrometheusSimpleclientScrapeEndpoint.class));
	}
	@Test
	void scrapeEndpointNotAddedToManagementContextWhenNotExposed() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusSimpleclientScrapeEndpoint.class));
	}
	@Test
	void scrapeEndpointCanBeDisabled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.endpoints.web.exposure.include=prometheus',
					'management.endpoint.prometheus.enabled=false')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusSimpleclientScrapeEndpoint.class));
	}
	@Test
	void allowsCustomScrapeEndpointToBeUsed() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(CustomEndpointConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customEndpoint')
				.hasSingleBean(PrometheusSimpleclientScrapeEndpoint.class));
	}
	@Test
	void pushGatewayIsNotConfiguredWhenEnabledFlagIsNotSet() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusPushGatewayManager.class));
	}
	@Test
	void withPushGatewayEnabled(CapturedOutput output) {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> {
				assertThat(output).doesNotContain('Invalid PushGateway base url');
				hasGatewayURL(context, 'http://localhost:9091/metrics/');
			});
	}
	@Test
	void withPushGatewayNoBasicAuth() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true')
			.withUserConfiguration(BaseConfiguration.class)
			.run(hasHttpConnectionFactory((httpConnectionFactory) -> assertThat(httpConnectionFactory)
				.isInstanceOf(DefaultHttpConnectionFactory.class)));
	}
	@Test
	void withCustomPushGatewayURL() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true',
					'management.prometheus.metrics.export.pushgateway.base-url=https://example.com:8080')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> hasGatewayURL(context, 'https://example.com:8080/metrics/'));
	}
	@Test
	void withPushGatewayBasicAuth() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.prometheus.metrics.export.pushgateway.enabled=true',
					'management.prometheus.metrics.export.pushgateway.username=admin',
					'management.prometheus.metrics.export.pushgateway.password=secret')
			.withUserConfiguration(BaseConfiguration.class)
			.run(hasHttpConnectionFactory((httpConnectionFactory) -> assertThat(httpConnectionFactory)
				.isInstanceOf(BasicAuthHttpConnectionFactory.class)));
	}
	private void hasGatewayURL(AssertableApplicationContext context, String url) {
		assertThat(getPushGateway(context)).hasFieldOrPropertyWithValue('gatewayBaseURL', url);
	}
	private ContextConsumer<AssertableApplicationContext> hasHttpConnectionFactory(
			ThrowingConsumer<HttpConnectionFactory> httpConnectionFactory) {
		return (context) -> {
			PushGateway pushGateway = getPushGateway(context);
			httpConnectionFactory
				.accept((HttpConnectionFactory) ReflectionTestUtils.getField(pushGateway, 'connectionFactory'));
		};
	}
	private PushGateway getPushGateway(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(PrometheusPushGatewayManager.class);
		PrometheusPushGatewayManager gatewayManager = context.getBean(PrometheusPushGatewayManager.class);
		return (PushGateway) ReflectionTestUtils.getField(gatewayManager, 'pushGateway');
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		io.micrometer.prometheus.PrometheusConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		io.micrometer.prometheus.PrometheusMeterRegistry customRegistry(
				io.micrometer.prometheus.PrometheusConfig config, CollectorRegistry collectorRegistry, Clock clock) {
			return new io.micrometer.prometheus.PrometheusMeterRegistry(config, collectorRegistry, clock);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomCollectorRegistryConfiguration {
		@Bean
		CollectorRegistry customCollectorRegistry() {
			return new CollectorRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomEndpointConfiguration {
		@Bean
		PrometheusSimpleclientScrapeEndpoint customEndpoint(CollectorRegistry collectorRegistry) {
			return new PrometheusSimpleclientScrapeEndpoint(collectorRegistry);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class ExemplarsConfiguration {
		@Bean
		SpanContextSupplier spanContextSupplier() {
			return new SpanContextSupplier() {
				@Override
				public String getTraceId() {
					return null;
				}
				@Override
				public String getSpanId() {
					return null;
				}
				@Override
				public boolean isSampled() {
					return false;
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
class PrometheusMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader('io.micrometer.prometheus.', 'io.prometheus.client'))
		.withConfiguration(AutoConfigurations.of(PrometheusMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context)
			.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigCollectorRegistryAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.doesNotHaveBean(PrometheusRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.prometheus.metrics.export.enabled=false')
			.run((context) -> assertThat(context)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.doesNotHaveBean(PrometheusRegistry.class)
				.doesNotHaveBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void allowsCustomCollectorRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomPrometheusRegistryConfiguration.class)
			.run((context) -> assertThat(context)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusMeterRegistry.class)
				.hasBean('customPrometheusRegistry')
				.hasSingleBean(PrometheusRegistry.class)
				.hasSingleBean(io.micrometer.prometheusmetrics.PrometheusConfig.class));
	}
	@Test
	void autoConfiguresPrometheusMeterRegistryIfSpanContextIsPresent() {
		this.contextRunner.withUserConfiguration(ExemplarsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SpanContext.class)
				.hasSingleBean(PrometheusMeterRegistry.class));
	}
	@Test
	void addsScrapeEndpointToManagementContext() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=prometheus')
			.run((context) -> assertThat(context).hasSingleBean(PrometheusScrapeEndpoint.class));
	}
	@Test
	void scrapeEndpointNotAddedToManagementContextWhenNotExposed() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusScrapeEndpoint.class));
	}
	@Test
	void scrapeEndpointCanBeDisabled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withPropertyValues('management.endpoints.web.exposure.include=prometheus',
					'management.endpoint.prometheus.enabled=false')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusScrapeEndpoint.class));
	}
	@Test
	void allowsCustomScrapeEndpointToBeUsed() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class))
			.withUserConfiguration(CustomEndpointConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customEndpoint')
				.hasSingleBean(PrometheusScrapeEndpoint.class));
	}
	@Test
	void pushGatewayIsNotConfiguredWhenEnabledFlagIsNotSet() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(PrometheusPushGatewayManager.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		io.micrometer.prometheusmetrics.PrometheusConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		io.micrometer.prometheusmetrics.PrometheusMeterRegistry customRegistry(
				io.micrometer.prometheusmetrics.PrometheusConfig config, PrometheusRegistry prometheusRegistry,
				Clock clock) {
			return new io.micrometer.prometheusmetrics.PrometheusMeterRegistry(config, prometheusRegistry, clock);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomPrometheusRegistryConfiguration {
		@Bean
		PrometheusRegistry customPrometheusRegistry() {
			return new PrometheusRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomEndpointConfiguration {
		@Bean
		PrometheusScrapeEndpoint customEndpoint(PrometheusRegistry prometheusRegistry,
				PrometheusConfig prometheusConfig) {
			return new PrometheusScrapeEndpoint(prometheusRegistry, prometheusConfig.prometheusProperties());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class ExemplarsConfiguration {
		@Bean
		SpanContext spanContext() {
			return new SpanContext() {
				@Override
				public String getCurrentTraceId() {
					return null;
				}
				@Override
				public String getCurrentSpanId() {
					return null;
				}
				@Override
				public boolean isCurrentSpanSampled() {
					return false;
				}
				@Override
				public void markCurrentSpanAsExemplar() {
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.dynatrace;
/**
class DynatracePropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		DynatraceProperties properties = new DynatraceProperties();
		DynatraceConfig config = (key) -> null;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getV1().getTechnologyType()).isEqualTo(config.technologyType());
		assertThat(properties.getV2().isUseDynatraceSummaryInstruments())
			.isEqualTo(config.useDynatraceSummaryInstruments());
		assertThat(properties.getV2().isExportMeterMetadata()).isEqualTo(config.exportMeterMetadata());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.dynatrace;
/**
class DynatraceMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DynatraceMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(DynatraceMeterRegistry.class));
	}
	@Test
	void failsWithADeviceIdWithoutAUri() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.dynatrace.metrics.export.v1.device-id:dev-1')
			.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void autoConfiguresConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.with(v1MandatoryProperties())
			.run((context) -> assertThat(context).hasSingleBean(DynatraceMeterRegistry.class)
				.hasSingleBean(DynatraceConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(DynatraceMeterRegistry.class)
				.doesNotHaveBean(DynatraceConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.dynatrace.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(DynatraceMeterRegistry.class)
				.doesNotHaveBean(DynatraceConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(DynatraceMeterRegistry.class)
				.hasSingleBean(DynatraceConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.with(v1MandatoryProperties())
			.run((context) -> assertThat(context).hasSingleBean(DynatraceMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(DynatraceConfig.class));
	}
	@Test
	void stopsMeterRegistryForV1ApiWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.with(v1MandatoryProperties())
			.run((context) -> {
				DynatraceMeterRegistry registry = context.getBean(DynatraceMeterRegistry.class);
				assertThat(registry.isClosed()).isFalse();
				context.close();
				assertThat(registry.isClosed()).isTrue();
			});
	}
	@Test
	void stopsMeterRegistryForV2ApiWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			DynatraceMeterRegistry registry = context.getBean(DynatraceMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	private Function<ApplicationContextRunner, ApplicationContextRunner> v1MandatoryProperties() {
		return (runner) -> runner.withPropertyValues(
				'management.dynatrace.metrics.export.uri=https://dynatrace.example.com',
				'management.dynatrace.metrics.export.api-token=abcde',
				'management.dynatrace.metrics.export.device-id=test');
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		DynatraceConfig customConfig() {
			return (key) -> switch (key) {
				case 'dynatrace.uri' -> 'https://dynatrace.example.com';
				case 'dynatrace.apiToken' -> 'abcde';
				case 'dynatrace.deviceId' -> 'test';
				default -> null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		DynatraceMeterRegistry customRegistry(DynatraceConfig config, Clock clock) {
			return new DynatraceMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.dynatrace;
/**
class DynatracePropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<DynatraceProperties, DynatracePropertiesConfigAdapter> {
	DynatracePropertiesConfigAdapterTests() {
		super(DynatracePropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.setUri('https://dynatrace.example.com');
		assertThat(new DynatracePropertiesConfigAdapter(properties).uri()).isEqualTo('https://dynatrace.example.com');
	}
	@Test
	void whenPropertiesApiTokenIsSetAdapterApiTokenReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.setApiToken('123ABC');
		assertThat(new DynatracePropertiesConfigAdapter(properties).apiToken()).isEqualTo('123ABC');
	}
	@Test
	void whenPropertiesV1DeviceIdIsSetAdapterDeviceIdReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.getV1().setDeviceId('dev-1');
		assertThat(new DynatracePropertiesConfigAdapter(properties).deviceId()).isEqualTo('dev-1');
	}
	@Test
	void whenPropertiesV1TechnologyTypeIsSetAdapterTechnologyTypeReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.getV1().setTechnologyType('tech-1');
		assertThat(new DynatracePropertiesConfigAdapter(properties).technologyType()).isEqualTo('tech-1');
	}
	@Test
	void whenPropertiesV1GroupIsSetAdapterGroupReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.getV1().setGroup('group-1');
		assertThat(new DynatracePropertiesConfigAdapter(properties).group()).isEqualTo('group-1');
	}
	@Test
	void whenV1DeviceIdIsSetThenAdapterApiVersionIsV1() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.getV1().setDeviceId('dev-1');
		assertThat(new DynatracePropertiesConfigAdapter(properties).apiVersion()).isSameAs(DynatraceApiVersion.V1);
	}
	@Test
	void whenDeviceIdIsNotSetThenAdapterApiVersionIsV2() {
		DynatraceProperties properties = new DynatraceProperties();
		assertThat(new DynatracePropertiesConfigAdapter(properties).apiVersion()).isSameAs(DynatraceApiVersion.V2);
	}
	@Test
	void whenPropertiesMetricKeyPrefixIsSetAdapterMetricKeyPrefixReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.getV2().setMetricKeyPrefix('my.prefix');
		assertThat(new DynatracePropertiesConfigAdapter(properties).metricKeyPrefix()).isEqualTo('my.prefix');
	}
	@Test
	void whenPropertiesEnrichWithOneAgentMetadataIsSetAdapterEnrichWithOneAgentMetadataReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.getV2().setEnrichWithDynatraceMetadata(true);
		assertThat(new DynatracePropertiesConfigAdapter(properties).enrichWithDynatraceMetadata()).isTrue();
	}
	@Test
	void whenPropertiesUseDynatraceInstrumentsIsSetAdapterUseDynatraceInstrumentsReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		properties.getV2().setUseDynatraceSummaryInstruments(false);
		assertThat(new DynatracePropertiesConfigAdapter(properties).useDynatraceSummaryInstruments()).isFalse();
	}
	@Test
	void whenPropertiesDefaultDimensionsIsSetAdapterDefaultDimensionsReturnsIt() {
		DynatraceProperties properties = new DynatraceProperties();
		HashMap<String, String> defaultDimensions = new HashMap<>();
		defaultDimensions.put('dim1', 'value1');
		defaultDimensions.put('dim2', 'value2');
		properties.getV2().setDefaultDimensions(defaultDimensions);
		assertThat(new DynatracePropertiesConfigAdapter(properties).defaultDimensions())
			.containsExactlyEntriesOf(defaultDimensions);
	}
	@Test
	void defaultValues() {
		DynatraceProperties properties = new DynatraceProperties();
		assertThat(properties.getApiToken()).isNull();
		assertThat(properties.getUri()).isNull();
		assertThat(properties.getV1().getDeviceId()).isNull();
		assertThat(properties.getV1().getTechnologyType()).isEqualTo('java');
		assertThat(properties.getV1().getGroup()).isNull();
		assertThat(properties.getV2().getMetricKeyPrefix()).isNull();
		assertThat(properties.getV2().isEnrichWithDynatraceMetadata()).isTrue();
		assertThat(properties.getV2().getDefaultDimensions()).isNull();
		assertThat(properties.getV2().isUseDynatraceSummaryInstruments()).isTrue();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/**
class OtlpMetricsPropertiesConfigAdapterTests {
	private OtlpMetricsProperties properties;
	private OpenTelemetryProperties openTelemetryProperties;
	private MockEnvironment environment;
	private OtlpMetricsConnectionDetails connectionDetails;
	@BeforeEach
	void setUp() {
		this.properties = new OtlpMetricsProperties();
		this.openTelemetryProperties = new OpenTelemetryProperties();
		this.environment = new MockEnvironment();
		this.connectionDetails = new PropertiesOtlpMetricsConnectionDetails(this.properties);
	}
	@Test
	void whenPropertiesUrlIsSetAdapterUrlReturnsIt() {
		this.properties.setUrl('http://another-url:4318/v1/metrics');
		assertThat(createAdapter().url()).isEqualTo('http://another-url:4318/v1/metrics');
	}
	@Test
	void whenPropertiesAggregationTemporalityIsNotSetAdapterAggregationTemporalityReturnsCumulative() {
		assertThat(createAdapter().aggregationTemporality()).isSameAs(AggregationTemporality.CUMULATIVE);
	}
	@Test
	void whenPropertiesAggregationTemporalityIsSetAdapterAggregationTemporalityReturnsIt() {
		this.properties.setAggregationTemporality(AggregationTemporality.DELTA);
		assertThat(createAdapter().aggregationTemporality()).isSameAs(AggregationTemporality.DELTA);
	}
	@Test
	@SuppressWarnings('removal')
	void whenPropertiesResourceAttributesIsSetAdapterResourceAttributesReturnsIt() {
		this.properties.setResourceAttributes(Map.of('service.name', 'boot-service'));
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.name', 'boot-service');
	}
	@Test
	void whenPropertiesHeadersIsSetAdapterHeadersReturnsIt() {
		this.properties.setHeaders(Map.of('header', 'value'));
		assertThat(createAdapter().headers()).containsEntry('header', 'value');
	}
	@Test
	void whenPropertiesHistogramFlavorIsNotSetAdapterHistogramFlavorReturnsExplicitBucketHistogram() {
		assertThat(createAdapter().histogramFlavor()).isSameAs(HistogramFlavor.EXPLICIT_BUCKET_HISTOGRAM);
	}
	@Test
	void whenPropertiesHistogramFlavorIsSetAdapterHistogramFlavorReturnsIt() {
		this.properties.setHistogramFlavor(HistogramFlavor.BASE2_EXPONENTIAL_BUCKET_HISTOGRAM);
		assertThat(createAdapter().histogramFlavor()).isSameAs(HistogramFlavor.BASE2_EXPONENTIAL_BUCKET_HISTOGRAM);
	}
	@Test
	void whenPropertiesMaxScaleIsNotSetAdapterMaxScaleReturns20() {
		assertThat(createAdapter().maxScale()).isEqualTo(20);
	}
	@Test
	void whenPropertiesMaxScaleIsSetAdapterMaxScaleReturnsIt() {
		this.properties.setMaxScale(5);
		assertThat(createAdapter().maxScale()).isEqualTo(5);
	}
	@Test
	void whenPropertiesMaxBucketCountIsNotSetAdapterMaxBucketCountReturns160() {
		assertThat(createAdapter().maxBucketCount()).isEqualTo(160);
	}
	@Test
	void whenPropertiesMaxBucketCountIsSetAdapterMaxBucketCountReturnsIt() {
		this.properties.setMaxBucketCount(6);
		assertThat(createAdapter().maxBucketCount()).isEqualTo(6);
	}
	@Test
	void whenPropertiesBaseTimeUnitIsNotSetAdapterBaseTimeUnitReturnsMillis() {
		assertThat(createAdapter().baseTimeUnit()).isSameAs(TimeUnit.MILLISECONDS);
	}
	@Test
	void whenPropertiesBaseTimeUnitIsSetAdapterBaseTimeUnitReturnsIt() {
		this.properties.setBaseTimeUnit(TimeUnit.SECONDS);
		assertThat(createAdapter().baseTimeUnit()).isSameAs(TimeUnit.SECONDS);
	}
	@Test
	@SuppressWarnings('removal')
	void openTelemetryPropertiesShouldOverrideOtlpPropertiesIfNotEmpty() {
		this.properties.setResourceAttributes(Map.of('a', 'alpha'));
		this.openTelemetryProperties.setResourceAttributes(Map.of('b', 'beta'));
		assertThat(createAdapter().resourceAttributes()).contains(entry('b', 'beta'));
		assertThat(createAdapter().resourceAttributes()).doesNotContain(entry('a', 'alpha'));
	}
	@Test
	@SuppressWarnings('removal')
	void openTelemetryPropertiesShouldNotOverrideOtlpPropertiesIfEmpty() {
		this.properties.setResourceAttributes(Map.of('a', 'alpha'));
		this.openTelemetryProperties.setResourceAttributes(Collections.emptyMap());
		assertThat(createAdapter().resourceAttributes()).contains(entry('a', 'alpha'));
	}
	@Test
	@SuppressWarnings('removal')
	void serviceNameOverridesApplicationName() {
		this.environment.setProperty('spring.application.name', 'alpha');
		this.properties.setResourceAttributes(Map.of('service.name', 'beta'));
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.name', 'beta');
	}
	@Test
	void serviceNameOverridesApplicationNameWhenUsingOtelProperties() {
		this.environment.setProperty('spring.application.name', 'alpha');
		this.openTelemetryProperties.setResourceAttributes(Map.of('service.name', 'beta'));
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.name', 'beta');
	}
	@Test
	void shouldUseApplicationNameIfServiceNameIsNotSet() {
		this.environment.setProperty('spring.application.name', 'alpha');
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.name', 'alpha');
	}
	@Test
	void shouldUseDefaultApplicationNameIfApplicationNameIsNotSet() {
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.name', 'unknown_service');
	}
	@Test
	@SuppressWarnings('removal')
	void serviceGroupOverridesApplicationGroup() {
		this.environment.setProperty('spring.application.group', 'alpha');
		this.properties.setResourceAttributes(Map.of('service.group', 'beta'));
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.group', 'beta');
	}
	@Test
	void serviceGroupOverridesApplicationGroupWhenUsingOtelProperties() {
		this.environment.setProperty('spring.application.group', 'alpha');
		this.openTelemetryProperties.setResourceAttributes(Map.of('service.group', 'beta'));
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.group', 'beta');
	}
	@Test
	void shouldUseApplicationGroupIfServiceGroupIsNotSet() {
		this.environment.setProperty('spring.application.group', 'alpha');
		assertThat(createAdapter().resourceAttributes()).containsEntry('service.group', 'alpha');
	}
	@Test
	void shouldUseDefaultApplicationGroupIfApplicationGroupIsNotSet() {
		assertThat(createAdapter().resourceAttributes()).doesNotContainKey('service.group');
	}
	private OtlpMetricsPropertiesConfigAdapter createAdapter() {
		return new OtlpMetricsPropertiesConfigAdapter(this.properties, this.openTelemetryProperties,
				this.connectionDetails, this.environment);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/**
class OtlpMetricsPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		OtlpMetricsProperties properties = new OtlpMetricsProperties();
		OtlpConfig config = OtlpConfig.DEFAULT;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getUrl()).isEqualTo(config.url());
		assertThat(properties.getAggregationTemporality()).isSameAs(config.aggregationTemporality());
		assertThat(properties.getHistogramFlavor()).isSameAs(config.histogramFlavor());
		assertThat(properties.getMaxScale()).isEqualTo(config.maxScale());
		assertThat(properties.getMaxBucketCount()).isEqualTo(config.maxBucketCount());
		assertThat(properties.getBaseTimeUnit()).isSameAs(config.baseTimeUnit());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/**
class OtlpMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(OtlpMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(OtlpMeterRegistry.class));
	}
	@Test
	void autoConfiguresConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(OtlpMeterRegistry.class)
				.hasSingleBean(OtlpConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(OtlpMeterRegistry.class)
				.doesNotHaveBean(OtlpConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.otlp.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(OtlpMeterRegistry.class)
				.doesNotHaveBean(OtlpConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(OtlpMeterRegistry.class)
				.hasSingleBean(OtlpConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsPlatformThreadsToBeUsed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(OtlpMeterRegistry.class);
			OtlpMeterRegistry registry = context.getBean(OtlpMeterRegistry.class);
			assertThat(registry).extracting('scheduledExecutorService')
				.satisfies((executor) -> ScheduledExecutorServiceAssert.assertThat((ScheduledExecutorService) executor)
					.usesPlatformThreads());
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void allowsVirtualThreadsToBeUsed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('spring.threads.virtual.enabled=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpMeterRegistry.class);
				OtlpMeterRegistry registry = context.getBean(OtlpMeterRegistry.class);
				assertThat(registry).extracting('scheduledExecutorService')
					.satisfies(
							(executor) -> ScheduledExecutorServiceAssert.assertThat((ScheduledExecutorService) executor)
								.usesVirtualThreads());
			});
	}
	@Test
	void allowsRegistryToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(OtlpMeterRegistry.class)
				.hasSingleBean(OtlpConfig.class)
				.hasBean('customRegistry'));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(PropertiesOtlpMetricsConnectionDetails.class));
	}
	@Test
	void testConnectionFactoryWithOverridesWhenUsingCustomConnectionDetails() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class, ConnectionDetailsConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpMetricsConnectionDetails.class)
					.doesNotHaveBean(PropertiesOtlpMetricsConnectionDetails.class);
				OtlpConfig config = context.getBean(OtlpConfig.class);
				assertThat(config.url()).isEqualTo('http://localhost:12345/v1/metrics');
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock customClock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		OtlpConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		OtlpMeterRegistry customRegistry(OtlpConfig config, Clock clock) {
			return new OtlpMeterRegistry(config, clock);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		OtlpMetricsConnectionDetails otlpConnectionDetails() {
			return () -> 'http://localhost:12345/v1/metrics';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.influx;
/**
class InfluxPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		InfluxProperties properties = new InfluxProperties();
		InfluxConfig config = InfluxConfig.DEFAULT;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getDb()).isEqualTo(config.db());
		assertThat(properties.getConsistency()).isEqualTo(config.consistency());
		assertThat(properties.getUserName()).isEqualTo(config.userName());
		assertThat(properties.getPassword()).isEqualTo(config.password());
		assertThat(properties.getRetentionPolicy()).isEqualTo(config.retentionPolicy());
		assertThat(properties.getRetentionDuration()).isEqualTo(config.retentionDuration());
		assertThat(properties.getRetentionReplicationFactor()).isEqualTo(config.retentionReplicationFactor());
		assertThat(properties.getRetentionShardDuration()).isEqualTo(config.retentionShardDuration());
		assertThat(properties.getUri()).isEqualTo(config.uri());
		assertThat(properties.isCompressed()).isEqualTo(config.compressed());
		assertThat(properties.isAutoCreateDb()).isEqualTo(config.autoCreateDb());
		assertThat(properties.getOrg()).isEqualTo(config.org());
		assertThat(properties.getToken()).isEqualTo(config.token());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.influx;
/**
class InfluxMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(InfluxMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(InfluxMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(InfluxMeterRegistry.class)
				.hasSingleBean(InfluxConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(InfluxMeterRegistry.class)
				.doesNotHaveBean(InfluxConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.influx.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(InfluxMeterRegistry.class)
				.doesNotHaveBean(InfluxConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(InfluxMeterRegistry.class)
				.hasSingleBean(InfluxConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(InfluxMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(InfluxConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			InfluxMeterRegistry registry = context.getBean(InfluxMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		InfluxConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		InfluxMeterRegistry customRegistry(InfluxConfig config, Clock clock) {
			return new InfluxMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.influx;
/**
class InfluxPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<InfluxProperties, InfluxPropertiesConfigAdapter> {
	InfluxPropertiesConfigAdapterTests() {
		super(InfluxPropertiesConfigAdapter.class);
	}
	@Test
	void adaptInfluxV1BasicConfig() {
		InfluxProperties properties = new InfluxProperties();
		properties.setDb('test-db');
		properties.setUri('https://influx.example.com:8086');
		properties.setUserName('user');
		properties.setPassword('secret');
		InfluxPropertiesConfigAdapter adapter = new InfluxPropertiesConfigAdapter(properties);
		assertThat(adapter.apiVersion()).isEqualTo(InfluxApiVersion.V1);
		assertThat(adapter.db()).isEqualTo('test-db');
		assertThat(adapter.uri()).isEqualTo('https://influx.example.com:8086');
		assertThat(adapter.userName()).isEqualTo('user');
		assertThat(adapter.password()).isEqualTo('secret');
	}
	@Test
	void adaptInfluxV2BasicConfig() {
		InfluxProperties properties = new InfluxProperties();
		properties.setOrg('test-org');
		properties.setBucket('test-bucket');
		properties.setUri('https://influx.example.com:8086');
		properties.setToken('token');
		InfluxPropertiesConfigAdapter adapter = new InfluxPropertiesConfigAdapter(properties);
		assertThat(adapter.apiVersion()).isEqualTo(InfluxApiVersion.V2);
		assertThat(adapter.org()).isEqualTo('test-org');
		assertThat(adapter.bucket()).isEqualTo('test-bucket');
		assertThat(adapter.uri()).isEqualTo('https://influx.example.com:8086');
		assertThat(adapter.token()).isEqualTo('token');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.newrelic;
/**
class NewRelicMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(NewRelicMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(NewRelicMeterRegistry.class));
	}
	@Test
	void failsWithoutAnApiKey() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.account-id=12345')
			.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void failsWithoutAnAccountId() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde')
			.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void failsToAutoConfigureWithoutEventType() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=12345',
					'management.newrelic.metrics.export.event-type=')
			.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void autoConfiguresWithEventTypeOverridden() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=12345',
					'management.newrelic.metrics.export.event-type=wxyz')
			.run((context) -> assertThat(context).hasSingleBean(NewRelicMeterRegistry.class)
				.hasSingleBean(Clock.class)
				.hasSingleBean(NewRelicConfig.class));
	}
	@Test
	void autoConfiguresWithMeterNameEventTypeEnabledAndWithoutEventType() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=12345',
					'management.newrelic.metrics.export.event-type=',
					'management.newrelic.metrics.export.meter-name-event-type-enabled=true')
			.run((context) -> assertThat(context).hasSingleBean(NewRelicMeterRegistry.class)
				.hasSingleBean(Clock.class)
				.hasSingleBean(NewRelicConfig.class));
	}
	@Test
	void autoConfiguresWithAccountIdAndApiKey() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=12345')
			.run((context) -> assertThat(context).hasSingleBean(NewRelicMeterRegistry.class)
				.hasSingleBean(Clock.class)
				.hasSingleBean(NewRelicConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(NewRelicMeterRegistry.class)
				.doesNotHaveBean(NewRelicConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(NewRelicMeterRegistry.class)
				.doesNotHaveBean(NewRelicConfig.class));
	}
	@Test
	void allowsConfigToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=12345')
			.run((context) -> assertThat(context).hasSingleBean(NewRelicConfig.class).hasBean('customConfig'));
	}
	@Test
	void allowsRegistryToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=12345')
			.run((context) -> assertThat(context).hasSingleBean(NewRelicMeterRegistry.class).hasBean('customRegistry'));
	}
	@Test
	void allowsClientProviderToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomClientProviderConfiguration.class)
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=12345')
			.run((context) -> {
				assertThat(context).hasSingleBean(NewRelicMeterRegistry.class);
				assertThat(context.getBean(NewRelicMeterRegistry.class)).hasFieldOrPropertyWithValue('clientProvider',
						context.getBean('customClientProvider'));
			});
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner
			.withPropertyValues('management.newrelic.metrics.export.api-key=abcde',
					'management.newrelic.metrics.export.account-id=abcde')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> {
				NewRelicMeterRegistry registry = context.getBean(NewRelicMeterRegistry.class);
				assertThat(registry.isClosed()).isFalse();
				context.close();
				assertThat(registry.isClosed()).isTrue();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock customClock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		NewRelicConfig customConfig() {
			return (key) -> {
				if ('newrelic.accountId'.equals(key)) {
					return 'abcde';
				}
				if ('newrelic.apiKey'.equals(key)) {
					return '12345';
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		NewRelicMeterRegistry customRegistry(NewRelicConfig config, Clock clock) {
			return new NewRelicMeterRegistry(config, clock);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomClientProviderConfiguration {
		@Bean
		NewRelicClientProvider customClientProvider() {
			return mock(NewRelicClientProvider.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.newrelic;
/**
class NewRelicPropertiesConfigAdapterTests
		extends StepRegistryPropertiesConfigAdapterTests<NewRelicProperties, NewRelicPropertiesConfigAdapter> {
	NewRelicPropertiesConfigAdapterTests() {
		super(NewRelicPropertiesConfigAdapter.class);
	}
	@Override
	protected NewRelicProperties createProperties() {
		return new NewRelicProperties();
	}
	@Override
	protected NewRelicPropertiesConfigAdapter createConfigAdapter(NewRelicProperties properties) {
		return new NewRelicPropertiesConfigAdapter(properties);
	}
	@Test
	void whenPropertiesMeterNameEventTypeEnabledIsSetAdapterMeterNameEventTypeEnabledReturnsIt() {
		NewRelicProperties properties = createProperties();
		properties.setMeterNameEventTypeEnabled(true);
		assertThat(createConfigAdapter(properties).meterNameEventTypeEnabled()).isEqualTo(true);
	}
	@Test
	void whenPropertiesEventTypeIsSetAdapterEventTypeReturnsIt() {
		NewRelicProperties properties = createProperties();
		properties.setEventType('foo');
		assertThat(createConfigAdapter(properties).eventType()).isEqualTo('foo');
	}
	@Test
	void whenPropertiesClientProviderTypeIsSetAdapterClientProviderTypeReturnsIt() {
		NewRelicProperties properties = createProperties();
		properties.setClientProviderType(ClientProviderType.INSIGHTS_AGENT);
		assertThat(createConfigAdapter(properties).clientProviderType()).isEqualTo(ClientProviderType.INSIGHTS_AGENT);
	}
	@Test
	void whenPropertiesApiKeyIsSetAdapterApiKeyReturnsIt() {
		NewRelicProperties properties = createProperties();
		properties.setApiKey('my-key');
		assertThat(createConfigAdapter(properties).apiKey()).isEqualTo('my-key');
	}
	@Test
	void whenPropertiesAccountIdIsSetAdapterAccountIdReturnsIt() {
		NewRelicProperties properties = createProperties();
		properties.setAccountId('A38');
		assertThat(createConfigAdapter(properties).accountId()).isEqualTo('A38');
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		NewRelicProperties properties = createProperties();
		properties.setUri('https://example.newrelic.com');
		assertThat(createConfigAdapter(properties).uri()).isEqualTo('https://example.newrelic.com');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.newrelic;
/**
class NewRelicPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		NewRelicProperties properties = new NewRelicProperties();
		NewRelicConfig config = (key) -> null;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getClientProviderType()).isEqualTo(config.clientProviderType());
		// apiKey and account are mandatory
		assertThat(properties.getUri()).isEqualTo(config.uri());
		assertThat(properties.isMeterNameEventTypeEnabled()).isEqualTo(config.meterNameEventTypeEnabled());
	}
	@Test
	void eventTypeDefaultValueIsOverridden() {
		NewRelicProperties properties = new NewRelicProperties();
		NewRelicConfig config = (key) -> null;
		assertThat(properties.getEventType()).isNotEqualTo(config.eventType());
		assertThat(properties.getEventType()).isEqualTo('SpringBootSample');
		assertThat(config.eventType()).isEqualTo('MicrometerSample');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.signalfx;
/**
class SignalFxPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		SignalFxProperties properties = new SignalFxProperties();
		SignalFxConfig config = (key) -> null;
		assertStepRegistryDefaultValues(properties, config);
		// access token is mandatory
		assertThat(properties.getUri()).isEqualTo(config.uri());
		// source has no static default value
		// Not publishing cumulative or delta histograms implies that the default
		// histogram type should be published.
		assertThat(config.publishCumulativeHistogram()).isFalse();
		assertThat(config.publishDeltaHistogram()).isFalse();
		assertThat(properties.getPublishedHistogramType()).isEqualTo(HistogramType.DEFAULT);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.signalfx;
/**
class SignalFxPropertiesConfigAdapterTests
		extends StepRegistryPropertiesConfigAdapterTests<SignalFxProperties, SignalFxPropertiesConfigAdapter> {
	protected SignalFxPropertiesConfigAdapterTests() {
		super(SignalFxPropertiesConfigAdapter.class);
	}
	@Override
	protected SignalFxProperties createProperties() {
		SignalFxProperties signalFxProperties = new SignalFxProperties();
		signalFxProperties.setAccessToken('ABC');
		return signalFxProperties;
	}
	@Override
	protected SignalFxPropertiesConfigAdapter createConfigAdapter(SignalFxProperties properties) {
		return new SignalFxPropertiesConfigAdapter(properties);
	}
	@Test
	void whenPropertiesAccessTokenIsSetAdapterAccessTokenReturnsIt() {
		SignalFxProperties properties = createProperties();
		assertThat(createConfigAdapter(properties).accessToken()).isEqualTo('ABC');
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		SignalFxProperties properties = createProperties();
		properties.setUri('https://example.signalfx.com');
		assertThat(createConfigAdapter(properties).uri()).isEqualTo('https://example.signalfx.com');
	}
	@Test
	void whenPropertiesSourceIsSetAdapterSourceReturnsIt() {
		SignalFxProperties properties = createProperties();
		properties.setSource('DESKTOP-GA5');
		assertThat(createConfigAdapter(properties).source()).isEqualTo('DESKTOP-GA5');
	}
	@Test
	void whenPropertiesPublishHistogramTypeIsCumulativeAdapterPublishCumulativeHistogramReturnsIt() {
		SignalFxProperties properties = createProperties();
		properties.setPublishedHistogramType(HistogramType.CUMULATIVE);
		assertThat(createConfigAdapter(properties).publishCumulativeHistogram()).isTrue();
		assertThat(createConfigAdapter(properties).publishDeltaHistogram()).isFalse();
	}
	@Test
	void whenPropertiesPublishHistogramTypeIsDeltaAdapterPublishDeltaHistogramReturnsIt() {
		SignalFxProperties properties = createProperties();
		properties.setPublishedHistogramType(HistogramType.DELTA);
		assertThat(createConfigAdapter(properties).publishDeltaHistogram()).isTrue();
		assertThat(createConfigAdapter(properties).publishCumulativeHistogram()).isFalse();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.signalfx;
/**
class SignalFxMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SignalFxMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(SignalFxMeterRegistry.class));
	}
	@Test
	void failsWithoutAnAccessToken() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void autoConfiguresWithAnAccessToken() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.signalfx.metrics.export.access-token=abcde')
			.run((context) -> assertThat(context).hasSingleBean(SignalFxMeterRegistry.class)
				.hasSingleBean(Clock.class)
				.hasSingleBean(SignalFxConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(SignalFxMeterRegistry.class)
				.doesNotHaveBean(SignalFxConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.signalfx.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(SignalFxMeterRegistry.class)
				.doesNotHaveBean(SignalFxConfig.class));
	}
	@Test
	void allowsConfigToBeCustomized() {
		this.contextRunner.withPropertyValues('management.signalfx.metrics.export.access-token=abcde')
			.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Clock.class)
				.hasSingleBean(SignalFxMeterRegistry.class)
				.hasSingleBean(SignalFxConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsRegistryToBeCustomized() {
		this.contextRunner.withPropertyValues('management.signalfx.metrics.export.access-token=abcde')
			.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Clock.class)
				.hasSingleBean(SignalFxConfig.class)
				.hasSingleBean(SignalFxMeterRegistry.class)
				.hasBean('customRegistry'));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withPropertyValues('management.signalfx.metrics.export.access-token=abcde')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> {
				SignalFxMeterRegistry registry = context.getBean(SignalFxMeterRegistry.class);
				assertThat(registry.isClosed()).isFalse();
				context.close();
				assertThat(registry.isClosed()).isTrue();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock customClock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		SignalFxConfig customConfig() {
			return (key) -> {
				if ('signalfx.accessToken'.equals(key)) {
					return 'abcde';
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		SignalFxMeterRegistry customRegistry(SignalFxConfig config, Clock clock) {
			return new SignalFxMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.wavefront;
/**
class WavefrontPropertiesConfigAdapterTests extends
		PushRegistryPropertiesConfigAdapterTests<WavefrontProperties.Metrics.Export, WavefrontPropertiesConfigAdapter> {
	protected WavefrontPropertiesConfigAdapterTests() {
		super(WavefrontPropertiesConfigAdapter.class);
	}
	@Override
	protected WavefrontProperties.Metrics.Export createProperties() {
		return new WavefrontProperties.Metrics.Export();
	}
	@Override
	protected WavefrontPropertiesConfigAdapter createConfigAdapter(WavefrontProperties.Metrics.Export export) {
		WavefrontProperties properties = new WavefrontProperties();
		properties.getMetrics().setExport(export);
		return new WavefrontPropertiesConfigAdapter(properties);
	}
	@Test
	void whenPropertiesGlobalPrefixIsSetAdapterGlobalPrefixReturnsIt() {
		Export properties = createProperties();
		properties.setGlobalPrefix('test');
		assertThat(createConfigAdapter(properties).globalPrefix()).isEqualTo('test');
	}
	@Override
	protected void whenPropertiesBatchSizeIsSetAdapterBatchSizeReturnsIt() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.getSender().setBatchSize(10042);
		assertThat(new WavefrontPropertiesConfigAdapter(properties).batchSize()).isEqualTo(10042);
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setUri(URI.create('https://example.wavefront.com'));
		assertThat(new WavefrontPropertiesConfigAdapter(properties).uri()).isEqualTo('https://example.wavefront.com');
	}
	@Test
	void whenPropertiesApiTokenIsSetAdapterApiTokenReturnsIt() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setApiToken('my-token');
		assertThat(new WavefrontPropertiesConfigAdapter(properties).apiToken()).isEqualTo('my-token');
	}
	@Test
	void whenPropertiesSourceIsSetAdapterSourceReturnsIt() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setSource('DESKTOP-GA5');
		assertThat(new WavefrontPropertiesConfigAdapter(properties).source()).isEqualTo('DESKTOP-GA5');
	}
	@Test
	void whenPropertiesReportMinuteDistributionIsSetAdapterReportMinuteDistributionReturnsIt() {
		Export properties = createProperties();
		properties.setReportMinuteDistribution(false);
		assertThat(createConfigAdapter(properties).reportMinuteDistribution()).isFalse();
	}
	@Test
	void whenPropertiesReportHourDistributionIsSetAdapterReportHourDistributionReturnsIt() {
		Export properties = createProperties();
		properties.setReportHourDistribution(true);
		assertThat(createConfigAdapter(properties).reportHourDistribution()).isTrue();
	}
	@Test
	void whenPropertiesReportDayDistributionIsSetAdapterReportDayDistributionReturnsIt() {
		Export properties = createProperties();
		properties.setReportDayDistribution(true);
		assertThat(createConfigAdapter(properties).reportDayDistribution()).isTrue();
	}
	@ParameterizedTest
	@CsvSource(textBlock = '''
			null,					WAVEFRONT_API_TOKEN
			NO_TOKEN,				NO_TOKEN
			WAVEFRONT_API_TOKEN,	WAVEFRONT_API_TOKEN
			CSP_API_TOKEN,			CSP_API_TOKEN
			CSP_CLIENT_CREDENTIALS,	CSP_CLIENT_CREDENTIALS
			''')
	void whenTokenTypeIsSetAdapterReturnsIt(String property, String wavefront) {
		TokenType propertyTokenType = property.equals('null') ? null : TokenType.valueOf(property);
		Type wavefrontTokenType = Type.valueOf(wavefront);
		WavefrontProperties properties = new WavefrontProperties();
		properties.setApiTokenType(propertyTokenType);
		assertThat(new WavefrontPropertiesConfigAdapter(properties).apiTokenType()).isEqualTo(wavefrontTokenType);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.wavefront;
/**
class WavefrontMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(WavefrontAutoConfiguration.class, WavefrontMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(WavefrontMeterRegistry.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.wavefront.api-token=abcde',
					'management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(WavefrontMeterRegistry.class)
				.doesNotHaveBean(WavefrontConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.wavefront.api-token=abcde',
					'management.wavefront.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(WavefrontMeterRegistry.class)
				.doesNotHaveBean(WavefrontConfig.class));
	}
	@Test
	void allowsConfigToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Clock.class)
				.hasSingleBean(WavefrontMeterRegistry.class)
				.hasSingleBean(WavefrontConfig.class)
				.hasSingleBean(WavefrontSender.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsRegistryToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.withPropertyValues('management.wavefront.api-token=abcde')
			.run((context) -> assertThat(context).hasSingleBean(Clock.class)
				.hasSingleBean(WavefrontConfig.class)
				.hasSingleBean(WavefrontMeterRegistry.class)
				.hasBean('customRegistry'));
	}
	@Test
	void exportsApplicationTagsInWavefrontRegistryWhenApplicationTagsBean() {
		ApplicationTags.Builder builder = new ApplicationTags.Builder('super-application', 'super-service');
		builder.cluster('super-cluster');
		builder.shard('super-shard');
		builder.customTags(Map.of('custom-key', 'custom-val'));
		this.contextRunner.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class))
			.withUserConfiguration(BaseConfiguration.class)
			.withBean(ApplicationTags.class, builder::build)
			.run((context) -> {
				WavefrontMeterRegistry registry = context.getBean(WavefrontMeterRegistry.class);
				registry.counter('my.counter', 'env', 'qa');
				assertThat(registry.find('my.counter')
					.tags('env', 'qa')
					.tags('application', 'super-application')
					.tags('service', 'super-service')
					.tags('cluster', 'super-cluster')
					.tags('shard', 'super-shard')
					.tags('custom-key', 'custom-val')
					.counter()).isNotNull();
			});
	}
	@Test
	void exportsApplicationTagsInWavefrontRegistryWhenInProperties() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class))
			.withPropertyValues('management.wavefront.application.service-name=super-service',
					'management.wavefront.application.name=super-application',
					'management.wavefront.application.cluster-name=super-cluster',
					'management.wavefront.application.shard-name=super-shard')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> {
				WavefrontMeterRegistry registry = context.getBean(WavefrontMeterRegistry.class);
				registry.counter('my.counter', 'env', 'qa');
				assertThat(registry.find('my.counter')
					.tags('env', 'qa')
					.tags('application', 'super-application')
					.tags('service', 'super-service')
					.tags('cluster', 'super-cluster')
					.tags('shard', 'super-shard')
					.counter()).isNotNull();
			});
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.wavefront.api-token=abcde')
			.run((context) -> {
				WavefrontMeterRegistry registry = context.getBean(WavefrontMeterRegistry.class);
				assertThat(registry.isClosed()).isFalse();
				context.close();
				assertThat(registry.isClosed()).isTrue();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		WavefrontSender customWavefrontSender() {
			return mock(WavefrontSender.class);
		}
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		WavefrontConfig customConfig() {
			return new WavefrontConfig() {
				@Override
				public String get(String key) {
					return null;
				}
				@Override
				public String uri() {
					return WavefrontConfig.DEFAULT_DIRECT.uri();
				}
				@Override
				public String apiToken() {
					return 'abc-def';
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomSenderConfiguration {
		@Bean
		WavefrontSender customSender() {
			return mock(WavefrontSender.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		WavefrontMeterRegistry customRegistry(WavefrontConfig config, Clock clock) {
			return new WavefrontMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.atlas;
/**
class AtlasMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(AtlasMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(AtlasMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AtlasMeterRegistry.class)
				.hasSingleBean(AtlasConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(AtlasMeterRegistry.class)
				.doesNotHaveBean(AtlasConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.atlas.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(AtlasMeterRegistry.class)
				.doesNotHaveBean(AtlasConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AtlasMeterRegistry.class)
				.hasSingleBean(AtlasConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AtlasMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(AtlasConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			AtlasMeterRegistry registry = context.getBean(AtlasMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		AtlasConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		AtlasMeterRegistry customRegistry(AtlasConfig config, Clock clock) {
			return new AtlasMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.atlas;
/**
class AtlasPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		AtlasProperties properties = new AtlasProperties();
		AtlasConfig config = (key) -> null;
		assertThat(properties.getStep()).isEqualTo(config.step());
		assertThat(properties.isEnabled()).isEqualTo(config.enabled());
		assertThat(properties.getConnectTimeout()).isEqualTo(config.connectTimeout());
		assertThat(properties.getReadTimeout()).isEqualTo(config.readTimeout());
		assertThat(properties.getNumThreads()).isEqualTo(config.numThreads());
		assertThat(properties.getBatchSize()).isEqualTo(config.batchSize());
		assertThat(properties.getUri()).isEqualTo(config.uri());
		assertThat(properties.getMeterTimeToLive()).isEqualTo(config.meterTTL());
		assertThat(properties.isLwcEnabled()).isEqualTo(config.lwcEnabled());
		assertThat(properties.getLwcStep()).isEqualTo(config.lwcStep());
		assertThat(properties.isLwcIgnorePublishStep()).isEqualTo(config.lwcIgnorePublishStep());
		assertThat(properties.getConfigRefreshFrequency()).isEqualTo(config.configRefreshFrequency());
		assertThat(properties.getConfigTimeToLive()).isEqualTo(config.configTTL());
		assertThat(properties.getConfigUri()).isEqualTo(config.configUri());
		assertThat(properties.getEvalUri()).isEqualTo(config.evalUri());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.atlas;
/**
class AtlasPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<AtlasProperties, AtlasPropertiesConfigAdapter> {
	AtlasPropertiesConfigAdapterTests() {
		super(AtlasPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setStep(Duration.ofMinutes(15));
		assertThat(new AtlasPropertiesConfigAdapter(properties).step()).isEqualTo(Duration.ofMinutes(15));
	}
	@Test
	void whenPropertiesEnabledIsSetAdapterEnabledReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setEnabled(false);
		assertThat(new AtlasPropertiesConfigAdapter(properties).enabled()).isFalse();
	}
	@Test
	void whenPropertiesConnectTimeoutIsSetAdapterConnectTimeoutReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setConnectTimeout(Duration.ofSeconds(12));
		assertThat(new AtlasPropertiesConfigAdapter(properties).connectTimeout()).isEqualTo(Duration.ofSeconds(12));
	}
	@Test
	void whenPropertiesReadTimeoutIsSetAdapterReadTimeoutReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setReadTimeout(Duration.ofSeconds(42));
		assertThat(new AtlasPropertiesConfigAdapter(properties).readTimeout()).isEqualTo(Duration.ofSeconds(42));
	}
	@Test
	void whenPropertiesNumThreadsIsSetAdapterNumThreadsReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setNumThreads(8);
		assertThat(new AtlasPropertiesConfigAdapter(properties).numThreads()).isEqualTo(8);
	}
	@Test
	void whenPropertiesBatchSizeIsSetAdapterBatchSizeReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setBatchSize(10042);
		assertThat(new AtlasPropertiesConfigAdapter(properties).batchSize()).isEqualTo(10042);
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setUri('https://atlas.example.com');
		assertThat(new AtlasPropertiesConfigAdapter(properties).uri()).isEqualTo('https://atlas.example.com');
	}
	@Test
	void whenPropertiesLwcEnabledIsSetAdapterLwcEnabledReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setLwcEnabled(true);
		assertThat(new AtlasPropertiesConfigAdapter(properties).lwcEnabled()).isTrue();
	}
	@Test
	void whenPropertiesConfigRefreshFrequencyIsSetAdapterConfigRefreshFrequencyReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setConfigRefreshFrequency(Duration.ofMinutes(5));
		assertThat(new AtlasPropertiesConfigAdapter(properties).configRefreshFrequency())
			.isEqualTo(Duration.ofMinutes(5));
	}
	@Test
	void whenPropertiesConfigTimeToLiveIsSetAdapterConfigTTLReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setConfigTimeToLive(Duration.ofMinutes(6));
		assertThat(new AtlasPropertiesConfigAdapter(properties).configTTL()).isEqualTo(Duration.ofMinutes(6));
	}
	@Test
	void whenPropertiesConfigUriIsSetAdapterConfigUriReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setConfigUri('https://atlas.example.com/config');
		assertThat(new AtlasPropertiesConfigAdapter(properties).configUri())
			.isEqualTo('https://atlas.example.com/config');
	}
	@Test
	void whenPropertiesEvalUriIsSetAdapterEvalUriReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setEvalUri('https://atlas.example.com/evaluate');
		assertThat(new AtlasPropertiesConfigAdapter(properties).evalUri())
			.isEqualTo('https://atlas.example.com/evaluate');
	}
	@Test
	void whenPropertiesLwcStepIsSetAdapterLwcStepReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setLwcStep(Duration.ofSeconds(30));
		assertThat(new AtlasPropertiesConfigAdapter(properties).lwcStep()).isEqualTo(Duration.ofSeconds(30));
	}
	@Test
	void whenPropertiesLwcIgnorePublishStepIsSetAdapterLwcIgnorePublishStepReturnsIt() {
		AtlasProperties properties = new AtlasProperties();
		properties.setLwcIgnorePublishStep(false);
		assertThat(new AtlasPropertiesConfigAdapter(properties).lwcIgnorePublishStep()).isFalse();
	}
	@Test
	@Override
	protected void adapterOverridesAllConfigMethods() {
		adapterOverridesAllConfigMethodsExcept('autoStart', 'commonTags', 'debugRegistry', 'publisher', 'rollupPolicy',
				'validTagCharacters');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.stackdriver;
/**
class StackdriverPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		StackdriverProperties properties = new StackdriverProperties();
		StackdriverConfig config = (key) -> null;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getResourceType()).isEqualTo(config.resourceType());
		assertThat(properties.isUseSemanticMetricTypes()).isEqualTo(config.useSemanticMetricTypes());
		assertThat(properties.getMetricTypePrefix()).isEqualTo(config.metricTypePrefix());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.stackdriver;
/**
class StackdriverPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<StackdriverProperties, StackdriverPropertiesConfigAdapter> {
	StackdriverPropertiesConfigAdapterTests() {
		super(StackdriverPropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesProjectIdIsSetAdapterProjectIdReturnsIt() {
		StackdriverProperties properties = new StackdriverProperties();
		properties.setProjectId('my-gcp-project-id');
		assertThat(new StackdriverPropertiesConfigAdapter(properties).projectId()).isEqualTo('my-gcp-project-id');
	}
	@Test
	void whenPropertiesResourceTypeIsSetAdapterResourceTypeReturnsIt() {
		StackdriverProperties properties = new StackdriverProperties();
		properties.setResourceType('my-resource-type');
		assertThat(new StackdriverPropertiesConfigAdapter(properties).resourceType()).isEqualTo('my-resource-type');
	}
	@Test
	void whenPropertiesResourceLabelsAreSetAdapterResourceLabelsReturnsThem() {
		final Map<String, String> labels = new HashMap<>();
		labels.put('labelOne', 'valueOne');
		labels.put('labelTwo', 'valueTwo');
		StackdriverProperties properties = new StackdriverProperties();
		properties.setResourceLabels(labels);
		assertThat(new StackdriverPropertiesConfigAdapter(properties).resourceLabels())
			.containsExactlyInAnyOrderEntriesOf(labels);
	}
	@Test
	void whenPropertiesUseSemanticMetricTypesIsSetAdapterUseSemanticMetricTypesReturnsIt() {
		StackdriverProperties properties = new StackdriverProperties();
		properties.setUseSemanticMetricTypes(true);
		assertThat(new StackdriverPropertiesConfigAdapter(properties).useSemanticMetricTypes()).isTrue();
	}
	@Test
	void whenPropertiesMetricTypePrefixIsSetAdapterMetricTypePrefixReturnsIt() {
		StackdriverProperties properties = new StackdriverProperties();
		properties.setMetricTypePrefix('external.googleapis.com/prometheus');
		assertThat(new StackdriverPropertiesConfigAdapter(properties).metricTypePrefix())
			.isEqualTo('external.googleapis.com/prometheus');
	}
	@Test
	@Override
	protected void adapterOverridesAllConfigMethods() {
		adapterOverridesAllConfigMethodsExcept('credentials');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.stackdriver;
/**
class StackdriverMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(StackdriverMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(StackdriverMeterRegistry.class));
	}
	@Test
	void failsWithoutAProjectId() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void autoConfiguresConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.stackdriver.metrics.export.project-id=test-project')
			.run((context) -> assertThat(context).hasSingleBean(StackdriverMeterRegistry.class)
				.hasSingleBean(StackdriverConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(StackdriverMeterRegistry.class)
				.doesNotHaveBean(StackdriverConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.stackdriver.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(StackdriverMeterRegistry.class)
				.doesNotHaveBean(StackdriverConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(StackdriverMeterRegistry.class)
				.hasSingleBean(StackdriverConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.withPropertyValues('management.stackdriver.metrics.export.project-id=test-project')
			.run((context) -> assertThat(context).hasSingleBean(StackdriverMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(StackdriverConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.stackdriver.metrics.export.project-id=test-project')
			.run((context) -> {
				StackdriverMeterRegistry registry = context.getBean(StackdriverMeterRegistry.class);
				assertThat(registry.isClosed()).isFalse();
				context.close();
				assertThat(registry.isClosed()).isTrue();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		StackdriverConfig customConfig() {
			return (key) -> {
				if ('stackdriver.projectId'.equals(key)) {
					return 'test-project';
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		StackdriverMeterRegistry customRegistry(StackdriverConfig config, Clock clock) {
			return new StackdriverMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.humio;
/**
class HumioPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		HumioProperties properties = new HumioProperties();
		HumioConfig config = (key) -> null;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getApiToken()).isEqualTo(config.apiToken());
		assertThat(properties.getTags()).isEmpty();
		assertThat(config.tags()).isNull();
		assertThat(properties.getUri()).isEqualTo(config.uri());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.humio;
/**
class HumioPropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<HumioProperties, HumioPropertiesConfigAdapter> {
	HumioPropertiesConfigAdapterTests() {
		super(HumioPropertiesConfigAdapter.class);
	}
	@Test
	void whenApiTokenIsSetAdapterApiTokenReturnsIt() {
		HumioProperties properties = new HumioProperties();
		properties.setApiToken('ABC123');
		assertThat(new HumioPropertiesConfigAdapter(properties).apiToken()).isEqualTo('ABC123');
	}
	@Test
	void whenPropertiesTagsIsSetAdapterTagsReturnsIt() {
		HumioProperties properties = new HumioProperties();
		properties.setTags(Collections.singletonMap('name', 'test'));
		assertThat(new HumioPropertiesConfigAdapter(properties).tags())
			.isEqualTo(Collections.singletonMap('name', 'test'));
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		HumioProperties properties = new HumioProperties();
		properties.setUri('https://humio.example.com');
		assertThat(new HumioPropertiesConfigAdapter(properties).uri()).isEqualTo('https://humio.example.com');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.humio;
/**
class HumioMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HumioMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(HumioMeterRegistry.class));
	}
	@Test
	void autoConfiguresConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(HumioMeterRegistry.class)
				.hasSingleBean(HumioConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(HumioMeterRegistry.class)
				.doesNotHaveBean(HumioConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.humio.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(HumioMeterRegistry.class)
				.doesNotHaveBean(HumioConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(HumioMeterRegistry.class)
				.hasSingleBean(HumioConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(HumioMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(HumioConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			HumioMeterRegistry registry = context.getBean(HumioMeterRegistry.class);
			new JvmMemoryMetrics().bindTo(registry);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		HumioConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		HumioMeterRegistry customRegistry(HumioConfig config, Clock clock) {
			return new HumioMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.appoptics;
/**
class AppOpticsPropertiesConfigAdapterTests
		extends StepRegistryPropertiesConfigAdapterTests<AppOpticsProperties, AppOpticsPropertiesConfigAdapter> {
	AppOpticsPropertiesConfigAdapterTests() {
		super(AppOpticsPropertiesConfigAdapter.class);
	}
	@Override
	protected AppOpticsProperties createProperties() {
		return new AppOpticsProperties();
	}
	@Override
	protected AppOpticsPropertiesConfigAdapter createConfigAdapter(AppOpticsProperties properties) {
		return new AppOpticsPropertiesConfigAdapter(properties);
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		AppOpticsProperties properties = createProperties();
		properties.setUri('https://appoptics.example.com/v1/measurements');
		assertThat(createConfigAdapter(properties).uri()).isEqualTo('https://appoptics.example.com/v1/measurements');
	}
	@Test
	void whenPropertiesApiTokenIsSetAdapterApiTokenReturnsIt() {
		AppOpticsProperties properties = createProperties();
		properties.setApiToken('ABC123');
		assertThat(createConfigAdapter(properties).apiToken()).isEqualTo('ABC123');
	}
	@Test
	void whenPropertiesHostTagIsSetAdapterHostTagReturnsIt() {
		AppOpticsProperties properties = createProperties();
		properties.setHostTag('node');
		assertThat(createConfigAdapter(properties).hostTag()).isEqualTo('node');
	}
	@Test
	void whenPropertiesFloorTimesIsSetAdapterFloorTimesReturnsIt() {
		AppOpticsProperties properties = createProperties();
		properties.setFloorTimes(true);
		assertThat(createConfigAdapter(properties).floorTimes()).isTrue();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.appoptics;
/**
class AppOpticsPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		AppOpticsProperties properties = new AppOpticsProperties();
		AppOpticsConfig config = (key) -> null;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getUri()).isEqualToIgnoringWhitespace(config.uri());
		assertThat(properties.getHostTag()).isEqualToIgnoringWhitespace(config.hostTag());
		assertThat(properties.isFloorTimes()).isEqualTo(config.floorTimes());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.appoptics;
/**
class AppOpticsMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(AppOpticsMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(AppOpticsMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigAndMeterRegistry() {
		this.contextRunner.withPropertyValues('management.appoptics.metrics.export.api-token=abcde')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AppOpticsMeterRegistry.class)
				.hasSingleBean(AppOpticsConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(AppOpticsMeterRegistry.class)
				.doesNotHaveBean(AppOpticsConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.appoptics.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(AppOpticsMeterRegistry.class)
				.doesNotHaveBean(AppOpticsConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AppOpticsMeterRegistry.class)
				.hasSingleBean(AppOpticsConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withPropertyValues('management.appoptics.metrics.export.api-token=abcde')
			.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AppOpticsMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(AppOpticsConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withPropertyValues('management.appoptics.metrics.export.api-token=abcde')
			.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> {
				AppOpticsMeterRegistry registry = context.getBean(AppOpticsMeterRegistry.class);
				assertThat(registry.isClosed()).isFalse();
				context.close();
				assertThat(registry.isClosed()).isTrue();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		AppOpticsConfig customConfig() {
			return (key) -> 'appoptics.apiToken'.equals(key) ? 'abcde' : null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		AppOpticsMeterRegistry customRegistry(AppOpticsConfig config, Clock clock) {
			return new AppOpticsMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.simple;
/**
class SimpleMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SimpleMetricsExportAutoConfiguration.class));
	@Test
	void autoConfiguresConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SimpleMeterRegistry.class)
				.hasSingleBean(Clock.class)
				.hasSingleBean(SimpleConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(SimpleMeterRegistry.class)
				.doesNotHaveBean(SimpleConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.simple.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(SimpleMeterRegistry.class)
				.doesNotHaveBean(SimpleConfig.class));
	}
	@Test
	void allowsConfigToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SimpleConfig.class).hasBean('customConfig'));
	}
	@Test
	void backsOffEntirelyWithCustomMeterRegistry() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(MeterRegistry.class)
				.hasBean('customRegistry')
				.doesNotHaveBean(SimpleConfig.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		SimpleConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		MeterRegistry customRegistry() {
			return mock(MeterRegistry.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.simple;
/**
class SimplePropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		SimpleProperties properties = new SimpleProperties();
		SimpleConfig config = SimpleConfig.DEFAULT;
		assertThat(properties.getStep()).isEqualTo(config.step());
		assertThat(properties.getMode()).isEqualTo(config.mode());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.simple;
/**
class SimplePropertiesConfigAdapterTests
		extends AbstractPropertiesConfigAdapterTests<SimpleProperties, SimplePropertiesConfigAdapter> {
	SimplePropertiesConfigAdapterTests() {
		super(SimplePropertiesConfigAdapter.class);
	}
	@Test
	void whenPropertiesStepIsSetAdapterStepReturnsIt() {
		SimpleProperties properties = new SimpleProperties();
		properties.setStep(Duration.ofSeconds(30));
		assertThat(new SimplePropertiesConfigAdapter(properties).step()).isEqualTo(Duration.ofSeconds(30));
	}
	@Test
	void whenPropertiesModeIsSetAdapterModeReturnsIt() {
		SimpleProperties properties = new SimpleProperties();
		properties.setMode(CountingMode.STEP);
		assertThat(new SimplePropertiesConfigAdapter(properties).mode()).isEqualTo(CountingMode.STEP);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.datadog;
/**
class DatadogPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		DatadogProperties properties = new DatadogProperties();
		DatadogConfig config = (key) -> null;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.isDescriptions()).isEqualTo(config.descriptions());
		assertThat(properties.getHostTag()).isEqualTo(config.hostTag());
		assertThat(properties.getUri()).isEqualTo(config.uri());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.datadog;
/**
class DatadogMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DatadogMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(DatadogMeterRegistry.class));
	}
	@Test
	void failsWithoutAnApiKey() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void autoConfiguresConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.datadog.metrics.export.api-key=abcde')
			.run((context) -> assertThat(context).hasSingleBean(DatadogMeterRegistry.class)
				.hasSingleBean(DatadogConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(DatadogMeterRegistry.class)
				.doesNotHaveBean(DatadogConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.datadog.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(DatadogMeterRegistry.class)
				.doesNotHaveBean(DatadogConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(DatadogMeterRegistry.class)
				.hasSingleBean(DatadogConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.withPropertyValues('management.datadog.metrics.export.api-key=abcde')
			.run((context) -> assertThat(context).hasSingleBean(DatadogMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(DatadogConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.datadog.metrics.export.api-key=abcde')
			.run((context) -> {
				DatadogMeterRegistry registry = context.getBean(DatadogMeterRegistry.class);
				assertThat(registry.isClosed()).isFalse();
				context.close();
				assertThat(registry.isClosed()).isTrue();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		DatadogConfig customConfig() {
			return (key) -> {
				if ('datadog.apiKey'.equals(key)) {
					return '12345';
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		DatadogMeterRegistry customRegistry(DatadogConfig config, Clock clock) {
			return new DatadogMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.datadog;
/**
class DatadogPropertiesConfigAdapterTests
		extends StepRegistryPropertiesConfigAdapterTests<DatadogProperties, DatadogPropertiesConfigAdapter> {
	DatadogPropertiesConfigAdapterTests() {
		super(DatadogPropertiesConfigAdapter.class);
	}
	@Override
	protected DatadogProperties createProperties() {
		return new DatadogProperties();
	}
	@Override
	protected DatadogPropertiesConfigAdapter createConfigAdapter(DatadogProperties properties) {
		return new DatadogPropertiesConfigAdapter(properties);
	}
	@Test
	void whenPropertiesApiKeyIsSetAdapterApiKeyReturnsIt() {
		DatadogProperties properties = createProperties();
		properties.setApiKey('my-api-key');
		assertThat(createConfigAdapter(properties).apiKey()).isEqualTo('my-api-key');
	}
	@Test
	void whenPropertiesApplicationKeyIsSetAdapterApplicationKeyReturnsIt() {
		DatadogProperties properties = createProperties();
		properties.setApplicationKey('my-application-key');
		assertThat(createConfigAdapter(properties).applicationKey()).isEqualTo('my-application-key');
	}
	@Test
	void whenPropertiesDescriptionsIsSetAdapterDescriptionsReturnsIt() {
		DatadogProperties properties = createProperties();
		properties.setDescriptions(false);
		assertThat(createConfigAdapter(properties).descriptions()).isEqualTo(false);
	}
	@Test
	void whenPropertiesHostTagIsSetAdapterHostTagReturnsIt() {
		DatadogProperties properties = createProperties();
		properties.setHostTag('waldo');
		assertThat(createConfigAdapter(properties).hostTag()).isEqualTo('waldo');
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		DatadogProperties properties = createProperties();
		properties.setUri('https://app.example.com/api/v1/series');
		assertThat(createConfigAdapter(properties).uri()).isEqualTo('https://app.example.com/api/v1/series');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.kairos;
/**
class KairosPropertiesTests extends StepRegistryPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		KairosProperties properties = new KairosProperties();
		KairosConfig config = KairosConfig.DEFAULT;
		assertStepRegistryDefaultValues(properties, config);
		assertThat(properties.getUri()).isEqualToIgnoringWhitespace(config.uri());
		assertThat(properties.getUserName()).isEqualToIgnoringWhitespace(config.userName());
		assertThat(properties.getPassword()).isEqualToIgnoringWhitespace(config.password());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.kairos;
/**
class KairosPropertiesConfigAdapterTests
		extends StepRegistryPropertiesConfigAdapterTests<KairosProperties, KairosPropertiesConfigAdapter> {
	KairosPropertiesConfigAdapterTests() {
		super(KairosPropertiesConfigAdapter.class);
	}
	@Override
	protected KairosProperties createProperties() {
		return new KairosProperties();
	}
	@Override
	protected KairosPropertiesConfigAdapter createConfigAdapter(KairosProperties properties) {
		return new KairosPropertiesConfigAdapter(properties);
	}
	@Test
	void whenPropertiesUriIsSetAdapterUriReturnsIt() {
		KairosProperties properties = createProperties();
		properties.setUri('https://kairos.example.com:8080/api/v1/datapoints');
		assertThat(createConfigAdapter(properties).uri())
			.isEqualTo('https://kairos.example.com:8080/api/v1/datapoints');
	}
	@Test
	void whenPropertiesUserNameIsSetAdapterUserNameReturnsIt() {
		KairosProperties properties = createProperties();
		properties.setUserName('alice');
		assertThat(createConfigAdapter(properties).userName()).isEqualTo('alice');
	}
	@Test
	void whenPropertiesPasswordIsSetAdapterPasswordReturnsIt() {
		KairosProperties properties = createProperties();
		properties.setPassword('secret');
		assertThat(createConfigAdapter(properties).password()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.kairos;
/**
class KairosMetricsExportAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(KairosMetricsExportAutoConfiguration.class));
	@Test
	void backsOffWithoutAClock() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(KairosMeterRegistry.class));
	}
	@Test
	void autoConfiguresItsConfigAndMeterRegistry() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(KairosMeterRegistry.class)
				.hasSingleBean(KairosConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithDefaultsEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.defaults.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(KairosMeterRegistry.class)
				.doesNotHaveBean(KairosConfig.class));
	}
	@Test
	void autoConfigurationCanBeDisabledWithSpecificEnabledProperty() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.withPropertyValues('management.kairos.metrics.export.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(KairosMeterRegistry.class)
				.doesNotHaveBean(KairosConfig.class));
	}
	@Test
	void allowsCustomConfigToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomConfigConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(KairosMeterRegistry.class)
				.hasSingleBean(KairosConfig.class)
				.hasBean('customConfig'));
	}
	@Test
	void allowsCustomRegistryToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(KairosMeterRegistry.class)
				.hasBean('customRegistry')
				.hasSingleBean(KairosConfig.class));
	}
	@Test
	void stopsMeterRegistryWhenContextIsClosed() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {
			KairosMeterRegistry registry = context.getBean(KairosMeterRegistry.class);
			assertThat(registry.isClosed()).isFalse();
			context.close();
			assertThat(registry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		Clock clock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomConfigConfiguration {
		@Bean
		KairosConfig customConfig() {
			return (key) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class CustomRegistryConfiguration {
		@Bean
		KairosMeterRegistry customRegistry(KairosConfig config, Clock clock) {
			return new KairosMeterRegistry(config, clock);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@ExtendWith(MockitoExtension.class)
class MeterRegistryPostProcessorTests {
	private final MetricsProperties properties = new MetricsProperties();
	private final List<MeterRegistryCustomizer<?>> customizers = new ArrayList<>();
	private final List<MeterFilter> filters = new ArrayList<>();
	private final List<MeterBinder> binders = new ArrayList<>();
	@Mock
	private MeterRegistryCustomizer<MeterRegistry> mockCustomizer;
	@Mock
	private MeterFilter mockFilter;
	@Mock
	private MeterBinder mockBinder;
	@Mock
	private MeterRegistry mockRegistry;
	@Mock
	private Config mockConfig;
	MeterRegistryPostProcessorTests() {
		this.properties.setUseGlobalRegistry(false);
	}
	@Test
	void postProcessAndInitializeWhenUserDefinedCompositeAppliesCustomizer() {
		this.customizers.add(this.mockCustomizer);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(
				CompositeMeterRegistries.ONLY_USER_DEFINED, createObjectProvider(this.properties),
				createObjectProvider(this.customizers), createObjectProvider(this.filters),
				createObjectProvider(this.binders));
		CompositeMeterRegistry composite = new CompositeMeterRegistry();
		postProcessAndInitialize(processor, composite);
		then(this.mockCustomizer).should().customize(composite);
	}
	@Test
	void postProcessAndInitializeWhenAutoConfiguredCompositeAppliesCustomizer() {
		this.customizers.add(this.mockCustomizer);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.AUTO_CONFIGURED,
				createObjectProvider(this.properties), createObjectProvider(this.customizers), null,
				createObjectProvider(this.binders));
		AutoConfiguredCompositeMeterRegistry composite = new AutoConfiguredCompositeMeterRegistry(Clock.SYSTEM,
				Collections.emptyList());
		postProcessAndInitialize(processor, composite);
		then(this.mockCustomizer).should().customize(composite);
	}
	@Test
	void postProcessAndInitializeAppliesCustomizer() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		this.customizers.add(this.mockCustomizer);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.NONE,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), createObjectProvider(this.binders));
		postProcessAndInitialize(processor, this.mockRegistry);
		then(this.mockCustomizer).should().customize(this.mockRegistry);
	}
	@Test
	void postProcessAndInitializeAppliesFilter() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		this.filters.add(this.mockFilter);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.NONE,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), createObjectProvider(this.binders));
		postProcessAndInitialize(processor, this.mockRegistry);
		then(this.mockConfig).should().meterFilter(this.mockFilter);
	}
	@Test
	void postProcessAndInitializeBindsTo() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		this.binders.add(this.mockBinder);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.NONE,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), createObjectProvider(this.binders));
		postProcessAndInitialize(processor, this.mockRegistry);
		then(this.mockBinder).should().bindTo(this.mockRegistry);
	}
	@Test
	void whenUserDefinedCompositeThenPostProcessAndInitializeCompositeBindsTo() {
		this.binders.add(this.mockBinder);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(
				CompositeMeterRegistries.ONLY_USER_DEFINED, createObjectProvider(this.properties),
				createObjectProvider(this.customizers), createObjectProvider(this.filters),
				createObjectProvider(this.binders));
		CompositeMeterRegistry composite = new CompositeMeterRegistry();
		postProcessAndInitialize(processor, composite);
		then(this.mockBinder).should().bindTo(composite);
	}
	@Test
	void whenUserDefinedCompositeThenPostProcessAndInitializeStandardRegistryDoesNotBindTo() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(
				CompositeMeterRegistries.ONLY_USER_DEFINED, createObjectProvider(this.properties),
				createObjectProvider(this.customizers), createObjectProvider(this.filters), null);
		postProcessAndInitialize(processor, this.mockRegistry);
		then(this.mockBinder).shouldHaveNoInteractions();
	}
	@Test
	void whenAutoConfiguredCompositeThenPostProcessAndInitializeAutoConfiguredCompositeBindsTo() {
		this.binders.add(this.mockBinder);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.AUTO_CONFIGURED,
				createObjectProvider(this.properties), createObjectProvider(this.customizers), null,
				createObjectProvider(this.binders));
		AutoConfiguredCompositeMeterRegistry composite = new AutoConfiguredCompositeMeterRegistry(Clock.SYSTEM,
				Collections.emptyList());
		postProcessAndInitialize(processor, composite);
		then(this.mockBinder).should().bindTo(composite);
	}
	@Test
	void whenAutoConfiguredCompositeThenPostProcessAndInitializeCompositeDoesNotBindTo() {
		this.binders.add(this.mockBinder);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.AUTO_CONFIGURED,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), null);
		CompositeMeterRegistry composite = new CompositeMeterRegistry();
		postProcessAndInitialize(processor, composite);
		then(this.mockBinder).shouldHaveNoInteractions();
	}
	@Test
	void whenAutoConfiguredCompositeThenPostProcessAndInitializeStandardRegistryDoesNotBindTo() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.AUTO_CONFIGURED,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), null);
		postProcessAndInitialize(processor, this.mockRegistry);
		then(this.mockBinder).shouldHaveNoInteractions();
	}
	@Test
	void postProcessAndInitializeIsOrderedCustomizerThenFilterThenBindTo() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		this.customizers.add(this.mockCustomizer);
		this.filters.add(this.mockFilter);
		this.binders.add(this.mockBinder);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.NONE,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), createObjectProvider(this.binders));
		postProcessAndInitialize(processor, this.mockRegistry);
		InOrder ordered = inOrder(this.mockBinder, this.mockConfig, this.mockCustomizer);
		then(this.mockCustomizer).should(ordered).customize(this.mockRegistry);
		then(this.mockConfig).should(ordered).meterFilter(this.mockFilter);
		then(this.mockBinder).should(ordered).bindTo(this.mockRegistry);
	}
	@Test
	void postProcessAndInitializeWhenUseGlobalRegistryTrueAddsToGlobalRegistry() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		this.properties.setUseGlobalRegistry(true);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.NONE,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), createObjectProvider(this.binders));
		try {
			postProcessAndInitialize(processor, this.mockRegistry);
			assertThat(Metrics.globalRegistry.getRegistries()).contains(this.mockRegistry);
		}
		finally {
			Metrics.removeRegistry(this.mockRegistry);
		}
	}
	@Test
	void postProcessAndInitializeWhenUseGlobalRegistryFalseDoesNotAddToGlobalRegistry() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.NONE,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), createObjectProvider(this.binders));
		postProcessAndInitialize(processor, this.mockRegistry);
		assertThat(Metrics.globalRegistry.getRegistries()).doesNotContain(this.mockRegistry);
	}
	@Test
	void postProcessDoesNotBindToUntilSingletonsInitialized() {
		given(this.mockRegistry.config()).willReturn(this.mockConfig);
		this.binders.add(this.mockBinder);
		MeterRegistryPostProcessor processor = new MeterRegistryPostProcessor(CompositeMeterRegistries.NONE,
				createObjectProvider(this.properties), createObjectProvider(this.customizers),
				createObjectProvider(this.filters), createObjectProvider(this.binders));
		processor.postProcessAfterInitialization(this.mockRegistry, 'meterRegistry');
		then(this.mockBinder).shouldHaveNoInteractions();
		processor.afterSingletonsInstantiated();
		then(this.mockBinder).should().bindTo(this.mockRegistry);
	}
	private void postProcessAndInitialize(MeterRegistryPostProcessor processor, MeterRegistry registry) {
		processor.postProcessAfterInitialization(registry, 'meterRegistry');
		processor.afterSingletonsInstantiated();
	}
	@SuppressWarnings('unchecked')
	private <T> ObjectProvider<T> createObjectProvider(List<T> objects) {
		ObjectProvider<T> objectProvider = mock(ObjectProvider.class);
		given(objectProvider.orderedStream()).willReturn(objects.stream());
		return objectProvider;
	}
	@SuppressWarnings('unchecked')
	private <T> ObjectProvider<T> createObjectProvider(T object) {
		ObjectProvider<T> objectProvider = mock(ObjectProvider.class);
		given(objectProvider.getObject()).willReturn(object);
		return objectProvider;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.jdbc;
/**
class DataSourcePoolMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.datasource.generate-unique-name=true')
		.with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(DataSourcePoolMetricsAutoConfiguration.class))
		.withUserConfiguration(BaseConfiguration.class);
	@Test
	void autoConfiguredDataSourceIsInstrumented() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				context.getBean(DataSource.class).getConnection().getMetaData();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('jdbc.connections.max').tags('name', 'dataSource').meter();
			});
	}
	@Test
	void dataSourceInstrumentationCanBeDisabled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('management.metrics.enable.jdbc=false')
			.run((context) -> {
				context.getBean(DataSource.class).getConnection().getMetaData();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('jdbc.connections.max').tags('name', 'dataSource').meter()).isNull();
			});
	}
	@Test
	void allDataSourcesCanBeInstrumented() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withUserConfiguration(TwoDataSourcesConfiguration.class)
			.run((context) -> {
				context.getBean('firstDataSource', DataSource.class).getConnection().getMetaData();
				context.getBean('secondOne', DataSource.class).getConnection().getMetaData();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('jdbc.connections.max').tags('name', 'first').meter();
				registry.get('jdbc.connections.max').tags('name', 'secondOne').meter();
			});
	}
	@Test
	void allDataSourcesCanBeInstrumentedWithLazyInitialization() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withInitializer(
					(context) -> context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()))
			.withUserConfiguration(TwoDataSourcesConfiguration.class)
			.run((context) -> {
				context.getBean('firstDataSource', DataSource.class).getConnection().getMetaData();
				context.getBean('secondOne', DataSource.class).getConnection().getMetaData();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('jdbc.connections.max').tags('name', 'first').meter();
				registry.get('jdbc.connections.max').tags('name', 'secondOne').meter();
			});
	}
	@Test
	void autoConfiguredHikariDataSourceIsInstrumented() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				context.getBean(DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hikaricp.connections').meter();
			});
	}
	@Test
	void autoConfiguredHikariDataSourceIsInstrumentedWhenUsingDataSourceInitialization() {
		this.contextRunner.withPropertyValues('spring.sql.init.schema:db/create-custom-schema.sql')
			.withConfiguration(
					AutoConfigurations.of(DataSourceAutoConfiguration.class, SqlInitializationAutoConfiguration.class))
			.run((context) -> {
				context.getBean(DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hikaricp.connections').meter();
			});
	}
	@Test
	void hikariCanBeInstrumentedAfterThePoolHasBeenSealed() {
		this.contextRunner.withUserConfiguration(HikariSealingConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasNotFailed();
				context.getBean(DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('hikaricp.connections').meter()).isNotNull();
			});
	}
	@Test
	void hikariDataSourceInstrumentationCanBeDisabled() {
		this.contextRunner.withPropertyValues('management.metrics.enable.hikaricp=false')
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				context.getBean(DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('hikaricp.connections').meter()).isNull();
			});
	}
	@Test
	void allHikariDataSourcesCanBeInstrumented() {
		this.contextRunner.withUserConfiguration(TwoHikariDataSourcesConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				context.getBean('firstDataSource', DataSource.class).getConnection();
				context.getBean('secondOne', DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hikaricp.connections').tags('pool', 'firstDataSource').meter();
				registry.get('hikaricp.connections').tags('pool', 'secondOne').meter();
			});
	}
	@Test
	void someHikariDataSourcesCanBeInstrumented() {
		this.contextRunner.withUserConfiguration(MixedDataSourcesConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				context.getBean('firstDataSource', DataSource.class).getConnection();
				context.getBean('secondOne', DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.get('hikaricp.connections').meter().getId().getTags())
					.containsExactly(Tag.of('pool', 'firstDataSource'));
			});
	}
	@Test
	void allHikariDataSourcesCanBeInstrumentedWhenUsingLazyInitialization() {
		this.contextRunner.withUserConfiguration(TwoHikariDataSourcesConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withInitializer(
					(context) -> context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()))
			.run((context) -> {
				context.getBean('firstDataSource', DataSource.class).getConnection();
				context.getBean('secondOne', DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hikaricp.connections').tags('pool', 'firstDataSource').meter();
				registry.get('hikaricp.connections').tags('pool', 'secondOne').meter();
			});
	}
	@Test
	void hikariProxiedDataSourceCanBeInstrumented() {
		this.contextRunner.withUserConfiguration(ProxiedHikariDataSourcesConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				context.getBean('proxiedDataSource', DataSource.class).getConnection();
				context.getBean('delegateDataSource', DataSource.class).getConnection();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hikaricp.connections').tags('pool', 'firstDataSource').meter();
				registry.get('hikaricp.connections').tags('pool', 'secondOne').meter();
			});
	}
	@Test
	void hikariDataSourceIsInstrumentedWithoutMetadataProvider() {
		this.contextRunner.withUserConfiguration(OneHikariDataSourceConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(DataSourcePoolMetadataProvider.class);
			context.getBean('hikariDataSource', DataSource.class).getConnection();
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry.get('hikaricp.connections').meter().getId().getTags())
				.containsExactly(Tag.of('pool', 'hikariDataSource'));
		});
	}
	private static HikariDataSource createHikariDataSource(String poolName) {
		String url = 'jdbc:hsqldb:mem:test-' + UUID.randomUUID();
		HikariDataSource hikariDataSource = DataSourceBuilder.create().url(url).type(HikariDataSource.class).build();
		hikariDataSource.setPoolName(poolName);
		return hikariDataSource;
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		SimpleMeterRegistry simpleMeterRegistry() {
			return new SimpleMeterRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TwoDataSourcesConfiguration {
		@Bean
		DataSource firstDataSource() {
			return createDataSource();
		}
		@Bean
		DataSource secondOne() {
			return createDataSource();
		}
		private DataSource createDataSource() {
			String url = 'jdbc:hsqldb:mem:test-' + UUID.randomUUID();
			return DataSourceBuilder.create().url(url).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TwoHikariDataSourcesConfiguration {
		@Bean
		DataSource firstDataSource() {
			return createHikariDataSource('firstDataSource');
		}
		@Bean
		DataSource secondOne() {
			return createHikariDataSource('secondOne');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ProxiedHikariDataSourcesConfiguration {
		@Bean
		DataSource proxiedDataSource() {
			return (DataSource) new ProxyFactory(createHikariDataSource('firstDataSource')).getProxy();
		}
		@Bean
		DataSource delegateDataSource() {
			return new DelegatingDataSource(createHikariDataSource('secondOne'));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OneHikariDataSourceConfiguration {
		@Bean
		DataSource hikariDataSource() {
			return createHikariDataSource('hikariDataSource');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MixedDataSourcesConfiguration {
		@Bean
		DataSource firstDataSource() {
			return createHikariDataSource('firstDataSource');
		}
		@Bean
		DataSource secondOne() {
			return createTomcatDataSource();
		}
		private HikariDataSource createHikariDataSource(String poolName) {
			String url = 'jdbc:hsqldb:mem:test-' + UUID.randomUUID();
			HikariDataSource hikariDataSource = DataSourceBuilder.create()
				.url(url)
				.type(HikariDataSource.class)
				.build();
			hikariDataSource.setPoolName(poolName);
			return hikariDataSource;
		}
		private org.apache.tomcat.jdbc.pool.DataSource createTomcatDataSource() {
			String url = 'jdbc:hsqldb:mem:test-' + UUID.randomUUID();
			return DataSourceBuilder.create().url(url).type(org.apache.tomcat.jdbc.pool.DataSource.class).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HikariSealingConfiguration {
		@Bean
		static HikariSealer hikariSealer() {
			return new HikariSealer();
		}
		static class HikariSealer implements BeanPostProcessor, PriorityOrdered {
			@Override
			public int getOrder() {
				return Ordered.HIGHEST_PRECEDENCE;
			}
			@Override
			public Object postProcessAfterInitialization(Object bean, String beanName) {
				if (bean instanceof HikariDataSource dataSource) {
					try {
						dataSource.getConnection().close();
					}
					catch (SQLException ex) {
						throw new IllegalStateException(ex);
					}
				}
				return bean;
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.task;
/**
class TaskExecutorMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(TaskExecutorMetricsAutoConfiguration.class));
	@Test
	void taskExecutorUsingAutoConfigurationIsInstrumented() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				Collection<FunctionCounter> meters = registry.get('executor.completed').functionCounters();
				assertThat(meters).singleElement()
					.satisfies(
							(meter) -> assertThat(meter.getId().getTag('name')).isEqualTo('applicationTaskExecutor'));
				assertThatExceptionOfType(MeterNotFoundException.class)
					.isThrownBy(() -> registry.get('executor').timer());
			});
	}
	@Test
	void taskExecutorIsInstrumentedWhenUsingLazyInitialization() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.withBean(LazyInitializationBeanFactoryPostProcessor.class)
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				Collection<FunctionCounter> meters = registry.get('executor.completed').functionCounters();
				assertThat(meters).singleElement()
					.satisfies(
							(meter) -> assertThat(meter.getId().getTag('name')).isEqualTo('applicationTaskExecutor'));
				assertThatExceptionOfType(MeterNotFoundException.class)
					.isThrownBy(() -> registry.get('executor').timer());
			});
	}
	@Test
	void taskExecutorsWithCustomNamesAreInstrumented() {
		this.contextRunner.withBean('firstTaskExecutor', Executor.class, ThreadPoolTaskExecutor::new)
			.withBean('customName', ThreadPoolTaskExecutor.class, ThreadPoolTaskExecutor::new)
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				Collection<FunctionCounter> meters = registry.get('executor.completed').functionCounters();
				assertThat(meters).map((meter) -> meter.getId().getTag('name'))
					.containsExactlyInAnyOrder('firstTaskExecutor', 'customName');
			});
	}
	@Test
	void threadPoolTaskExecutorWithNoTaskExecutorIsIgnored() {
		ThreadPoolTaskExecutor unavailableTaskExecutor = mock(ThreadPoolTaskExecutor.class);
		given(unavailableTaskExecutor.getThreadPoolExecutor()).willThrow(new IllegalStateException('Test'));
		this.contextRunner.withBean('firstTaskExecutor', ThreadPoolTaskExecutor.class, ThreadPoolTaskExecutor::new)
			.withBean('customName', ThreadPoolTaskExecutor.class, () -> unavailableTaskExecutor)
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				Collection<FunctionCounter> meters = registry.get('executor.completed').functionCounters();
				assertThat(meters).singleElement()
					.satisfies((meter) -> assertThat(meter.getId().getTag('name')).isEqualTo('firstTaskExecutor'));
			});
	}
	@Test
	void taskExecutorInstrumentationCanBeDisabled() {
		this.contextRunner.withPropertyValues('management.metrics.enable.executor=false')
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(
						registry.find('executor.completed').tags('name', 'applicationTaskExecutor').functionCounter())
					.isNull();
			});
	}
	@Test
	void taskSchedulerUsingAutoConfigurationIsInstrumented() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class))
			.withUserConfiguration(SchedulingTestConfiguration.class)
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				Collection<FunctionCounter> meters = registry.get('executor.completed').functionCounters();
				assertThat(meters).singleElement()
					.satisfies((meter) -> assertThat(meter.getId().getTag('name')).isEqualTo('taskScheduler'));
				assertThatExceptionOfType(MeterNotFoundException.class)
					.isThrownBy(() -> registry.get('executor').timer());
			});
	}
	@Test
	void taskSchedulersWithCustomNamesAreInstrumented() {
		this.contextRunner.withBean('firstTaskScheduler', Executor.class, ThreadPoolTaskScheduler::new)
			.withBean('customName', ThreadPoolTaskScheduler.class, ThreadPoolTaskScheduler::new)
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				Collection<FunctionCounter> meters = registry.get('executor.completed').functionCounters();
				assertThat(meters).map((meter) -> meter.getId().getTag('name'))
					.containsExactlyInAnyOrder('firstTaskScheduler', 'customName');
			});
	}
	@Test
	void threadPoolTaskSchedulerWithNoTaskExecutorIsIgnored() {
		ThreadPoolTaskScheduler unavailableTaskExecutor = mock(ThreadPoolTaskScheduler.class);
		given(unavailableTaskExecutor.getScheduledThreadPoolExecutor()).willThrow(new IllegalStateException('Test'));
		this.contextRunner.withBean('firstTaskScheduler', ThreadPoolTaskScheduler.class, ThreadPoolTaskScheduler::new)
			.withBean('customName', ThreadPoolTaskScheduler.class, () -> unavailableTaskExecutor)
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				Collection<FunctionCounter> meters = registry.get('executor.completed').functionCounters();
				assertThat(meters).singleElement()
					.satisfies((meter) -> assertThat(meter.getId().getTag('name')).isEqualTo('firstTaskScheduler'));
			});
	}
	@Test
	void taskSchedulerInstrumentationCanBeDisabled() {
		this.contextRunner.withPropertyValues('management.metrics.enable.executor=false')
			.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class))
			.withUserConfiguration(SchedulingTestConfiguration.class)
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('executor.completed').tags('name', 'taskScheduler').functionCounter())
					.isNull();
			});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableScheduling
	static class SchedulingTestConfiguration {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class MeterValueTests {
	@Test
	void getValueForDistributionSummaryWhenFromNumberShouldReturnDoubleValue() {
		MeterValue meterValue = MeterValue.valueOf(123.42);
		assertThat(meterValue.getValue(Type.DISTRIBUTION_SUMMARY)).isEqualTo(123.42);
	}
	@Test
	void getValueForDistributionSummaryWhenFromNumberStringShouldReturnDoubleValue() {
		MeterValue meterValue = MeterValue.valueOf('123.42');
		assertThat(meterValue.getValue(Type.DISTRIBUTION_SUMMARY)).isEqualTo(123.42);
	}
	@Test
	void getValueForDistributionSummaryWhenFromDurationStringShouldReturnNull() {
		MeterValue meterValue = MeterValue.valueOf('123ms');
		assertThat(meterValue.getValue(Type.DISTRIBUTION_SUMMARY)).isNull();
	}
	@Test
	void getValueForTimerWhenFromNumberShouldReturnMsToNanosValue() {
		MeterValue meterValue = MeterValue.valueOf(123d);
		assertThat(meterValue.getValue(Type.TIMER)).isEqualTo(123000000);
	}
	@Test
	void getValueForTimerWhenFromNumberStringShouldMsToNanosValue() {
		MeterValue meterValue = MeterValue.valueOf('123');
		assertThat(meterValue.getValue(Type.TIMER)).isEqualTo(123000000);
	}
	@Test
	void getValueForTimerWhenFromDurationStringShouldReturnDurationNanos() {
		MeterValue meterValue = MeterValue.valueOf('123ms');
		assertThat(meterValue.getValue(Type.TIMER)).isEqualTo(123000000);
	}
	@Test
	void getValueForOthersShouldReturnNull() {
		MeterValue meterValue = MeterValue.valueOf('123');
		assertThat(meterValue.getValue(Type.COUNTER)).isNull();
		assertThat(meterValue.getValue(Type.GAUGE)).isNull();
		assertThat(meterValue.getValue(Type.LONG_TASK_TIMER)).isNull();
		assertThat(meterValue.getValue(Type.OTHER)).isNull();
	}
	@Test
	void valueOfShouldWorkInBinder() {
		MockEnvironment environment = new MockEnvironment();
		TestPropertyValues.of('duration=10ms', 'number=20.42').applyTo(environment);
		assertThat(Binder.get(environment).bind('duration', Bindable.of(MeterValue.class)).get().getValue(Type.TIMER))
			.isEqualTo(10000000);
		assertThat(Binder.get(environment)
			.bind('number', Bindable.of(MeterValue.class))
			.get()
			.getValue(Type.DISTRIBUTION_SUMMARY)).isEqualTo(20.42);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.cache;
/**
class CacheMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withUserConfiguration(CachingConfiguration.class)
		.withConfiguration(AutoConfigurations.of(CacheAutoConfiguration.class, CacheMetricsAutoConfiguration.class));
	@Test
	void autoConfiguredCache2kIsInstrumented() {
		this.contextRunner.withPropertyValues('spring.cache.type=cache2k', 'spring.cache.cache-names=cache1,cache2')
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('cache.gets').tags('name', 'cache1').tags('cache.manager', 'cacheManager').meter();
				registry.get('cache.gets').tags('name', 'cache2').tags('cache.manager', 'cacheManager').meter();
			});
	}
	@Test
	void autoConfiguredCacheManagerIsInstrumented() {
		this.contextRunner
			.withPropertyValues('spring.cache.type=caffeine', 'spring.cache.cache-names=cache1,cache2',
					'spring.cache.caffeine.spec=recordStats')
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('cache.gets').tags('name', 'cache1').tags('cache.manager', 'cacheManager').meter();
				registry.get('cache.gets').tags('name', 'cache2').tags('cache.manager', 'cacheManager').meter();
			});
	}
	@Test
	void autoConfiguredNonSupportedCacheManagerIsIgnored() {
		this.contextRunner.withPropertyValues('spring.cache.type=simple', 'spring.cache.cache-names=cache1,cache2')
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('cache.gets')
					.tags('name', 'cache1')
					.tags('cache.manager', 'cacheManager')
					.meter()).isNull();
				assertThat(registry.find('cache.gets')
					.tags('name', 'cache2')
					.tags('cache.manager', 'cacheManager')
					.meter()).isNull();
			});
	}
	@Test
	void cacheInstrumentationCanBeDisabled() {
		this.contextRunner
			.withPropertyValues('management.metrics.enable.cache=false', 'spring.cache.type=caffeine',
					'spring.cache.cache-names=cache1')
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('cache.requests')
					.tags('name', 'cache1')
					.tags('cache.manager', 'cacheManager')
					.meter()).isNull();
			});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CachingConfiguration {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.web;
/**
@RestController
public class TestController {
	@GetMapping('test0')
	public String test0() {
		return 'test0';
	}
	@GetMapping('test1')
	public String test1() {
		return 'test1';
	}
	@GetMapping('test2')
	public String test2() {
		return 'test2';
	}
	@Timed
	@GetMapping('test3')
	public String test3() {
		return 'test3';
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.web.jetty;
/**
class JettyMetricsAutoConfigurationTests {
	@Test
	void autoConfiguresThreadPoolMetricsWithEmbeddedServletJetty() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				assertThat(context).hasSingleBean(JettyServerThreadPoolMetricsBinder.class);
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.threads.config.min').meter()).isNotNull();
			});
	}
	@Test
	void autoConfiguresThreadPoolMetricsWithEmbeddedReactiveJetty() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ReactiveWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.threads.config.min').meter()).isNotNull();
			});
	}
	@Test
	void allowsCustomJettyServerThreadPoolMetricsBinderToBeUsed() {
		new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class))
			.withUserConfiguration(CustomJettyServerThreadPoolMetricsBinder.class, MeterRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JettyServerThreadPoolMetricsBinder.class)
				.hasBean('customJettyServerThreadPoolMetricsBinder'));
	}
	@Test
	void autoConfiguresConnectionMetricsWithEmbeddedServletJetty() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				assertThat(context).hasSingleBean(JettyConnectionMetricsBinder.class);
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.connections.messages.in').meter()).isNotNull();
			});
	}
	@Test
	void autoConfiguresConnectionMetricsWithEmbeddedReactiveJetty() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ReactiveWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.connections.messages.in').meter()).isNotNull();
			});
	}
	@Test
	void allowsCustomJettyConnectionMetricsBinderToBeUsed() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, CustomJettyConnectionMetricsBinder.class,
					MeterRegistryConfiguration.class)
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				assertThat(context).hasSingleBean(JettyConnectionMetricsBinder.class)
					.hasBean('customJettyConnectionMetricsBinder');
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.connections.messages.in')
					.tag('custom-tag-name', 'custom-tag-value')
					.meter()).isNotNull();
			});
	}
	@Test
	void autoConfiguresSslHandshakeMetricsWithEmbeddedServletJetty() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.withPropertyValues('server.ssl.enabled: true', 'server.ssl.key-store: src/test/resources/test.jks',
					'server.ssl.key-store-password: secret', 'server.ssl.key-password: password')
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				assertThat(context).hasSingleBean(JettySslHandshakeMetricsBinder.class);
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.ssl.handshakes').meter()).isNotNull();
			});
	}
	@Test
	void autoConfiguresSslHandshakeMetricsWithEmbeddedReactiveJetty() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ReactiveWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.withPropertyValues('server.ssl.enabled: true', 'server.ssl.key-store: src/test/resources/test.jks',
					'server.ssl.key-store-password: secret', 'server.ssl.key-password: password')
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.ssl.handshakes').meter()).isNotNull();
			});
	}
	@Test
	void allowsCustomJettySslHandshakeMetricsBinderToBeUsed() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, CustomJettySslHandshakeMetricsBinder.class,
					MeterRegistryConfiguration.class)
			.withPropertyValues('server.ssl.enabled: true', 'server.ssl.key-store: src/test/resources/test.jks',
					'server.ssl.key-store-password: secret', 'server.ssl.key-password: password')
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				assertThat(context).hasSingleBean(JettySslHandshakeMetricsBinder.class)
					.hasBean('customJettySslHandshakeMetricsBinder');
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('jetty.ssl.handshakes').tag('custom-tag-name', 'custom-tag-value').meter())
					.isNotNull();
			});
		new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class))
			.withUserConfiguration(CustomJettySslHandshakeMetricsBinder.class, MeterRegistryConfiguration.class)
			.withPropertyValues('server.ssl.enabled: true', 'server.ssl.key-store: src/test/resources/test.jks',
					'server.ssl.key-store-password: secret', 'server.ssl.key-password: password')
			.run((context) -> assertThat(context).hasSingleBean(JettySslHandshakeMetricsBinder.class)
				.hasBean('customJettySslHandshakeMetricsBinder'));
	}
	@Test
	void doesNotAutoConfigureSslHandshakeMetricsWhenSslEnabledPropertyNotSpecified() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(JettySslHandshakeMetricsBinder.class));
	}
	@Test
	void doesNotAutoConfigureSslHandshakeMetricsWhenSslEnabledPropertySetToFalse() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JettyMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.withPropertyValues('server.ssl.enabled: false')
			.run((context) -> assertThat(context).doesNotHaveBean(JettySslHandshakeMetricsBinder.class));
	}
	private ApplicationStartedEvent createApplicationStartedEvent(ConfigurableApplicationContext context) {
		return new ApplicationStartedEvent(new SpringApplication(), null, context, null);
	}
	@Configuration(proxyBeanMethods = false)
	static class MeterRegistryConfiguration {
		@Bean
		SimpleMeterRegistry meterRegistry() {
			return new SimpleMeterRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ServletWebServerConfiguration {
		@Bean
		JettyServletWebServerFactory jettyFactory() {
			return new JettyServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveWebServerConfiguration {
		@Bean
		JettyReactiveWebServerFactory jettyFactory() {
			return new JettyReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler() {
			return mock(HttpHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJettyServerThreadPoolMetricsBinder {
		@Bean
		JettyServerThreadPoolMetricsBinder customJettyServerThreadPoolMetricsBinder(MeterRegistry meterRegistry) {
			return new JettyServerThreadPoolMetricsBinder(meterRegistry);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJettyConnectionMetricsBinder {
		@Bean
		JettyConnectionMetricsBinder customJettyConnectionMetricsBinder(MeterRegistry meterRegistry) {
			return new JettyConnectionMetricsBinder(meterRegistry, Tags.of('custom-tag-name', 'custom-tag-value'));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJettySslHandshakeMetricsBinder {
		@Bean
		JettySslHandshakeMetricsBinder customJettySslHandshakeMetricsBinder(MeterRegistry meterRegistry) {
			return new JettySslHandshakeMetricsBinder(meterRegistry, Tags.of('custom-tag-name', 'custom-tag-value'));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.web.tomcat;
/**
class TomcatMetricsAutoConfigurationTests {
	@Test
	void autoConfiguresTomcatMetricsWithEmbeddedServletTomcat() {
		resetTomcatState();
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(TomcatMetricsAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.withPropertyValues('server.tomcat.mbeanregistry.enabled=true')
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				assertThat(context).hasSingleBean(TomcatMetricsBinder.class);
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('tomcat.sessions.active.max').meter()).isNotNull();
				assertThat(registry.find('tomcat.threads.current').meter()).isNotNull();
			});
	}
	@Test
	void autoConfiguresTomcatMetricsWithEmbeddedReactiveTomcat() {
		resetTomcatState();
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(TomcatMetricsAutoConfiguration.class,
					ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(ReactiveWebServerConfiguration.class, MeterRegistryConfiguration.class)
			.withPropertyValues('server.tomcat.mbeanregistry.enabled=true')
			.run((context) -> {
				context.publishEvent(createApplicationStartedEvent(context.getSourceApplicationContext()));
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('tomcat.sessions.active.max').meter()).isNotNull();
				assertThat(registry.find('tomcat.threads.current').meter()).isNotNull();
			});
	}
	@Test
	void autoConfiguresTomcatMetricsWithStandaloneTomcat() {
		new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(TomcatMetricsAutoConfiguration.class))
			.withUserConfiguration(MeterRegistryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(TomcatMetricsBinder.class));
	}
	@Test
	void allowsCustomTomcatMetricsBinderToBeUsed() {
		new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(TomcatMetricsAutoConfiguration.class))
			.withUserConfiguration(MeterRegistryConfiguration.class, CustomTomcatMetricsBinder.class)
			.run((context) -> assertThat(context).hasSingleBean(TomcatMetricsBinder.class)
				.hasBean('customTomcatMetricsBinder'));
	}
	@Test
	void allowsCustomTomcatMetricsToBeUsed() {
		new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(TomcatMetricsAutoConfiguration.class))
			.withUserConfiguration(MeterRegistryConfiguration.class, CustomTomcatMetrics.class)
			.run((context) -> assertThat(context).doesNotHaveBean(TomcatMetricsBinder.class)
				.hasBean('customTomcatMetrics'));
	}
	private ApplicationStartedEvent createApplicationStartedEvent(ConfigurableApplicationContext context) {
		return new ApplicationStartedEvent(new SpringApplication(), null, context, null);
	}
	private void resetTomcatState() {
		ReflectionTestUtils.setField(Registry.class, 'registry', null);
		AtomicInteger containerCounter = (AtomicInteger) ReflectionTestUtils.getField(TomcatWebServer.class,
				'containerCounter');
		containerCounter.set(-1);
	}
	@Configuration(proxyBeanMethods = false)
	static class MeterRegistryConfiguration {
		@Bean
		SimpleMeterRegistry meterRegistry() {
			return new SimpleMeterRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ServletWebServerConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcatFactory() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveWebServerConfiguration {
		@Bean
		TomcatReactiveWebServerFactory tomcatFactory() {
			return new TomcatReactiveWebServerFactory(0);
		}
		@Bean
		HttpHandler httpHandler() {
			return mock(HttpHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTomcatMetrics {
		@Bean
		TomcatMetrics customTomcatMetrics() {
			return new TomcatMetrics(null, Collections.emptyList());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTomcatMetricsBinder {
		@Bean
		TomcatMetricsBinder customTomcatMetricsBinder(MeterRegistry meterRegistry) {
			return new TomcatMetricsBinder(meterRegistry);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.integration;
/**
class IntegrationMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(IntegrationAutoConfiguration.class,
				IntegrationGraphEndpointAutoConfiguration.class, IntegrationMetricsAutoConfiguration.class))
		.with(MetricsRun.simple())
		.withPropertyValues('management.metrics.tags.someTag=someValue');
	@Test
	void integrationMetersAreInstrumented() {
		this.contextRunner.run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			Gauge gauge = registry.get('spring.integration.channels').tag('someTag', 'someValue').gauge();
			assertThat(gauge).isNotNull().extracting(Gauge::value).isEqualTo(2.0);
		});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class MetricsAutoConfigurationIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple());
	@Test
	void propertyBasedMeterFilteringIsAutoConfigured() {
		this.contextRunner.withPropertyValues('management.metrics.enable.my.org=false').run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			registry.timer('my.org.timer');
			assertThat(registry.find('my.org.timer').timer()).isNull();
		});
	}
	@Test
	void propertyBasedCommonTagsIsAutoConfigured() {
		this.contextRunner
			.withPropertyValues('management.metrics.tags.region=test', 'management.metrics.tags.origin=local')
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.counter('my.counter', 'env', 'qa');
				assertThat(registry.find('my.counter')
					.tags('env', 'qa')
					.tags('region', 'test')
					.tags('origin', 'local')
					.counter()).isNotNull();
			});
	}
	@Test
	void simpleMeterRegistryIsUsedAsAFallback() {
		this.contextRunner
			.run((context) -> assertThat(context.getBean(MeterRegistry.class)).isInstanceOf(SimpleMeterRegistry.class));
	}
	@Test
	void emptyCompositeIsCreatedWhenNoMeterRegistriesAreAutoConfigured() {
		new ApplicationContextRunner().with(MetricsRun.limitedTo()).run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry).isInstanceOf(CompositeMeterRegistry.class);
			assertThat(((CompositeMeterRegistry) registry).getRegistries()).isEmpty();
		});
	}
	@Test
	void noCompositeIsCreatedWhenASingleMeterRegistryIsAutoConfigured() {
		new ApplicationContextRunner().with(MetricsRun.limitedTo(GraphiteMetricsExportAutoConfiguration.class))
			.run((context) -> assertThat(context.getBean(MeterRegistry.class))
				.isInstanceOf(GraphiteMeterRegistry.class));
	}
	@Test
	void noCompositeIsCreatedWithMultipleRegistriesAndOneThatIsPrimary() {
		new ApplicationContextRunner()
			.with(MetricsRun.limitedTo(GraphiteMetricsExportAutoConfiguration.class,
					JmxMetricsExportAutoConfiguration.class))
			.withUserConfiguration(PrimaryMeterRegistryConfiguration.class)
			.run((context) -> assertThat(context.getBean(MeterRegistry.class)).isInstanceOf(SimpleMeterRegistry.class));
	}
	@Test
	void compositeCreatedWithMultipleRegistries() {
		new ApplicationContextRunner()
			.with(MetricsRun.limitedTo(GraphiteMetricsExportAutoConfiguration.class,
					JmxMetricsExportAutoConfiguration.class))
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry).isInstanceOf(CompositeMeterRegistry.class);
				assertThat(((CompositeMeterRegistry) registry).getRegistries())
					.hasAtLeastOneElementOfType(GraphiteMeterRegistry.class)
					.hasAtLeastOneElementOfType(JmxMeterRegistry.class);
			});
	}
	@Test
	void autoConfiguredCompositeDoesNotHaveMeterFiltersApplied() {
		new ApplicationContextRunner()
			.with(MetricsRun.limitedTo(GraphiteMetricsExportAutoConfiguration.class,
					JmxMetricsExportAutoConfiguration.class))
			.run((context) -> {
				MeterRegistry composite = context.getBean(MeterRegistry.class);
				assertThat(composite).extracting('filters', InstanceOfAssertFactories.ARRAY).isEmpty();
				assertThat(composite).isInstanceOf(CompositeMeterRegistry.class);
				Set<MeterRegistry> registries = ((CompositeMeterRegistry) composite).getRegistries();
				assertThat(registries).hasSize(2);
				assertThat(registries).hasAtLeastOneElementOfType(GraphiteMeterRegistry.class)
					.hasAtLeastOneElementOfType(JmxMeterRegistry.class);
				assertThat(registries).allSatisfy(
						(registry) -> assertThat(registry).extracting('filters', InstanceOfAssertFactories.ARRAY)
							.hasSize(1));
			});
	}
	@Test
	void userConfiguredCompositeHasMeterFiltersApplied() {
		new ApplicationContextRunner().with(MetricsRun.limitedTo())
			.withUserConfiguration(CompositeMeterRegistryConfiguration.class)
			.run((context) -> {
				MeterRegistry composite = context.getBean(MeterRegistry.class);
				assertThat(composite).extracting('filters', InstanceOfAssertFactories.ARRAY).hasSize(1);
				assertThat(composite).isInstanceOf(CompositeMeterRegistry.class);
				Set<MeterRegistry> registries = ((CompositeMeterRegistry) composite).getRegistries();
				assertThat(registries).hasSize(2);
				assertThat(registries).hasOnlyElementsOfTypes(SimpleMeterRegistry.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class PrimaryMeterRegistryConfiguration {
		@Primary
		@Bean
		MeterRegistry simpleMeterRegistry() {
			return new SimpleMeterRegistry(SimpleConfig.DEFAULT, new MockClock());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CompositeMeterRegistryConfiguration {
		@Bean
		CompositeMeterRegistry compositeMeterRegistry() {
			return new CompositeMeterRegistry(new MockClock(),
					Arrays.asList(new SimpleMeterRegistry(), new SimpleMeterRegistry()));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class SystemMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(SystemMetricsAutoConfiguration.class));
	@Test
	void autoConfiguresUptimeMetrics() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(UptimeMetrics.class));
	}
	@Test
	void allowsCustomUptimeMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomUptimeMetricsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(UptimeMetrics.class).hasBean('customUptimeMetrics'));
	}
	@Test
	void autoConfiguresProcessorMetrics() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ProcessorMetrics.class));
	}
	@Test
	void allowsCustomProcessorMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomProcessorMetricsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ProcessorMetrics.class)
				.hasBean('customProcessorMetrics'));
	}
	@Test
	void autoConfiguresFileDescriptorMetrics() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(FileDescriptorMetrics.class));
	}
	@Test
	void allowsCustomFileDescriptorMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomFileDescriptorMetricsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(FileDescriptorMetrics.class)
				.hasBean('customFileDescriptorMetrics'));
	}
	@Test
	void autoConfiguresDiskSpaceMetrics() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(DiskSpaceMetricsBinder.class));
	}
	@Test
	void allowsCustomDiskSpaceMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomDiskSpaceMetricsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(DiskSpaceMetricsBinder.class)
				.hasBean('customDiskSpaceMetrics'));
	}
	@Test
	void diskSpaceMetricsUsesDefaultPath() {
		this.contextRunner.run((context) -> assertThat(context).hasBean('diskSpaceMetrics')
			.getBean(DiskSpaceMetricsBinder.class)
			.hasFieldOrPropertyWithValue('paths', Collections.singletonList(new File('.'))));
	}
	@Test
	void allowsDiskSpaceMetricsPathToBeConfiguredWithSinglePath() {
		this.contextRunner.withPropertyValues('management.metrics.system.diskspace.paths:..')
			.run((context) -> assertThat(context).hasBean('diskSpaceMetrics')
				.getBean(DiskSpaceMetricsBinder.class)
				.hasFieldOrPropertyWithValue('paths', Collections.singletonList(new File('..'))));
	}
	@Test
	void allowsDiskSpaceMetricsPathToBeConfiguredWithMultiplePaths() {
		this.contextRunner.withPropertyValues('management.metrics.system.diskspace.paths:.,..')
			.run((context) -> assertThat(context).hasBean('diskSpaceMetrics')
				.getBean(DiskSpaceMetricsBinder.class)
				.hasFieldOrPropertyWithValue('paths', Arrays.asList(new File('.'), new File('..'))));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomUptimeMetricsConfiguration {
		@Bean
		UptimeMetrics customUptimeMetrics() {
			return new UptimeMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomProcessorMetricsConfiguration {
		@Bean
		ProcessorMetrics customProcessorMetrics() {
			return new ProcessorMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomFileDescriptorMetricsConfiguration {
		@Bean
		FileDescriptorMetrics customFileDescriptorMetrics() {
			return new FileDescriptorMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDiskSpaceMetricsConfiguration {
		@Bean
		DiskSpaceMetricsBinder customDiskSpaceMetrics() {
			return new DiskSpaceMetricsBinder(Collections.singletonList(new File(System.getProperty('user.dir'))),
					Tags.empty());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.test;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, classes = MetricsIntegrationTests.MetricsApp.class,
		properties = 'management.metrics.use-global-registry=false')
class MetricsIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Autowired
	private RestTemplate external;
	@Autowired
	private TestRestTemplate loopback;
	@Autowired
	private MeterRegistry registry;
	@BeforeEach
	void setUp() {
		this.registry.clear();
	}
	@SuppressWarnings('unchecked')
	@Test
	void restTemplateIsInstrumented() {
		MockRestServiceServer server = MockRestServiceServer.bindTo(this.external).build();
		server.expect(once(), requestTo('/api/external'))
			.andExpect(method(HttpMethod.GET))
			.andRespond(withSuccess('{\'message\': \'hello\'}', MediaType.APPLICATION_JSON));
		assertThat(this.external.getForObject('/api/external', Map.class)).containsKey('message');
		assertThat(this.registry.get('http.client.requests').timer().count()).isOne();
	}
	@Test
	void requestMappingIsInstrumented() {
		this.loopback.getForObject('/api/people', Set.class);
		waitAtMost(Duration.ofSeconds(5))
			.untilAsserted(() -> assertThat(this.registry.get('http.server.requests').timer().count()).isOne());
	}
	@Test
	void automaticallyRegisteredBinders() {
		assertThat(this.context.getBeansOfType(MeterBinder.class).values())
			.hasAtLeastOneElementOfType(LogbackMetrics.class)
			.hasAtLeastOneElementOfType(JvmMemoryMetrics.class);
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void metricsFilterRegisteredForAsyncDispatches() {
		Map<String, FilterRegistrationBean> filterRegistrations = this.context
			.getBeansOfType(FilterRegistrationBean.class);
		assertThat(filterRegistrations).containsKey('webMvcObservationFilter');
		FilterRegistrationBean registration = filterRegistrations.get('webMvcObservationFilter');
		assertThat(registration.getFilter()).isInstanceOf(ServerHttpObservationFilter.class);
		assertThat((Set<DispatcherType>) ReflectionTestUtils.getField(registration, 'dispatcherTypes'))
			.containsExactlyInAnyOrder(DispatcherType.REQUEST, DispatcherType.ASYNC);
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ MetricsAutoConfiguration.class, ObservationAutoConfiguration.class,
			JvmMetricsAutoConfiguration.class, LogbackMetricsAutoConfiguration.class,
			SystemMetricsAutoConfiguration.class, RabbitMetricsAutoConfiguration.class,
			CacheMetricsAutoConfiguration.class, DataSourcePoolMetricsAutoConfiguration.class,
			HibernateMetricsAutoConfiguration.class, HttpClientObservationsAutoConfiguration.class,
			WebFluxObservationAutoConfiguration.class, WebMvcObservationAutoConfiguration.class,
			JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			RestTemplateAutoConfiguration.class, WebMvcAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class })
	@Import(PersonController.class)
	static class MetricsApp {
		@Primary
		@Bean
		MeterRegistry registry() {
			return new SimpleMeterRegistry(SimpleConfig.DEFAULT, new MockClock());
		}
		@Bean
		RestTemplate restTemplate(RestTemplateBuilder restTemplateBuilder) {
			return restTemplateBuilder.build();
		}
		@Bean
		CyclicBarrier cyclicBarrier() {
			return new CyclicBarrier(2);
		}
	}
	@RestController
	static class PersonController {
		@GetMapping('/api/people')
		Set<String> personName() {
			return Collections.singleton('Jon');
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.test;
/**
public final class MetricsRun {
	private static final Set<Class<?>> EXPORT_AUTO_CONFIGURATIONS;
	static {
		Set<Class<?>> implementations = new LinkedHashSet<>();
		implementations.add(AtlasMetricsExportAutoConfiguration.class);
		implementations.add(DatadogMetricsExportAutoConfiguration.class);
		implementations.add(GangliaMetricsExportAutoConfiguration.class);
		implementations.add(GraphiteMetricsExportAutoConfiguration.class);
		implementations.add(InfluxMetricsExportAutoConfiguration.class);
		implementations.add(JmxMetricsExportAutoConfiguration.class);
		implementations.add(NewRelicMetricsExportAutoConfiguration.class);
		implementations.add(OtlpMetricsExportAutoConfiguration.class);
		implementations.add(PrometheusMetricsExportAutoConfiguration.class);
		implementations.add(SimpleMetricsExportAutoConfiguration.class);
		implementations.add(SignalFxMetricsExportAutoConfiguration.class);
		implementations.add(StatsdMetricsExportAutoConfiguration.class);
		EXPORT_AUTO_CONFIGURATIONS = Collections.unmodifiableSet(implementations);
	}
	private static final AutoConfigurations AUTO_CONFIGURATIONS = AutoConfigurations.of(MetricsAutoConfiguration.class,
			CompositeMeterRegistryAutoConfiguration.class);
	private MetricsRun() {
	}
	/**
	 * Return a function that configures the run to be limited to the {@code simple}
	 * implementation.
	 * @return the function to apply
	 */
	public static <T extends AbstractApplicationContextRunner<?, ?, ?>> Function<T, T> simple() {
		return limitedTo(SimpleMetricsExportAutoConfiguration.class);
	}
	/**
	 * Return a function that configures the run to be limited to the specified
	 * implementations.
	 * @param exportAutoConfigurations the export auto-configurations to include
	 * @return the function to apply
	 */
	public static <T extends AbstractApplicationContextRunner<?, ?, ?>> Function<T, T> limitedTo(
			Class<?>... exportAutoConfigurations) {
		return (contextRunner) -> apply(contextRunner, exportAutoConfigurations);
	}
	@SuppressWarnings('unchecked')
	private static <T extends AbstractApplicationContextRunner<?, ?, ?>> T apply(T contextRunner,
			Class<?>[] exportAutoConfigurations) {
		for (Class<?> configuration : exportAutoConfigurations) {
			Assert.state(EXPORT_AUTO_CONFIGURATIONS.contains(configuration),
					() -> 'Unknown export auto-configuration ' + configuration.getName());
		}
		return (T) contextRunner.withPropertyValues('management.metrics.use-global-registry=false')
			.withConfiguration(AUTO_CONFIGURATIONS)
			.withConfiguration(AutoConfigurations.of(exportAutoConfigurations));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.jersey;
/**
class JerseyServerMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(JerseyServerMetricsAutoConfiguration.class));
	private final WebApplicationContextRunner webContextRunner = new WebApplicationContextRunner(
			AnnotationConfigServletWebServerApplicationContext::new)
		.withConfiguration(
				AutoConfigurations.of(JerseyAutoConfiguration.class, JerseyServerMetricsAutoConfiguration.class,
						ServletWebServerFactoryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class,
						ObservationAutoConfiguration.class, MetricsAutoConfiguration.class))
		.withUserConfiguration(ResourceConfiguration.class)
		.withPropertyValues('server.port:0');
	@Test
	void shouldOnlyBeActiveInWebApplicationContext() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ResourceConfigCustomizer.class));
	}
	@Test
	void shouldProvideAllNecessaryBeans() {
		this.webContextRunner.run((context) -> assertThat(context).hasBean('jerseyMetricsUriTagFilter')
			.hasSingleBean(ResourceConfigCustomizer.class));
	}
	@Test
	void httpRequestsAreTimed() {
		this.webContextRunner.run((context) -> {
			doRequest(context);
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			Timer timer = registry.get('http.server.requests').tag('uri', '/users/{id}').timer();
			assertThat(timer.count()).isOne();
		});
	}
	@Test
	void noHttpRequestsTimedWhenJerseyInstrumentationMissingFromClasspath() {
		this.webContextRunner.withClassLoader(new FilteredClassLoader(ObservationApplicationEventListener.class))
			.run((context) -> {
				doRequest(context);
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('http.server.requests').timer()).isNull();
			});
	}
	private static void doRequest(AssertableWebApplicationContext context) {
		int port = context.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class)
			.getWebServer()
			.getPort();
		RestTemplate restTemplate = new RestTemplate();
		restTemplate.getForEntity(URI.create('http://localhost:' + port + '/users/3'), String.class);
	}
	@Configuration(proxyBeanMethods = false)
	static class ResourceConfiguration {
		@Bean
		ResourceConfig resourceConfig() {
			return new ResourceConfig().register(new TestResource());
		}
		@Path('/users')
		public static class TestResource {
			@GET
			@Path('/{id}')
			public String getUser(@PathParam('id') String id) {
				return id;
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class Log4J2MetricsWithSlf4jLoggerContextAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(Log4J2MetricsAutoConfiguration.class));
	@Test
	void backsOffWhenLoggerContextIsBackedBySlf4j() {
		assertThat(LogManager.getContext()).isInstanceOf(SLF4JLoggerContext.class);
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(Log4j2Metrics.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.data;
/**
class MetricsRepositoryMethodInvocationListenerBeanPostProcessorTests {
	private final MetricsRepositoryMethodInvocationListener listener = mock(
			MetricsRepositoryMethodInvocationListener.class);
	private final MetricsRepositoryMethodInvocationListenerBeanPostProcessor postProcessor = new MetricsRepositoryMethodInvocationListenerBeanPostProcessor(
			SingletonSupplier.of(this.listener));
	@Test
	@SuppressWarnings('rawtypes')
	void postProcessBeforeInitializationWhenRepositoryFactoryBeanSupportAddsListener() {
		RepositoryFactoryBeanSupport bean = mock(RepositoryFactoryBeanSupport.class);
		Object result = this.postProcessor.postProcessBeforeInitialization(bean, 'name');
		assertThat(result).isSameAs(bean);
		ArgumentCaptor<RepositoryFactoryCustomizer> customizer = ArgumentCaptor
			.forClass(RepositoryFactoryCustomizer.class);
		then(bean).should().addRepositoryFactoryCustomizer(customizer.capture());
		RepositoryFactorySupport repositoryFactory = mock(RepositoryFactorySupport.class);
		customizer.getValue().customize(repositoryFactory);
		then(repositoryFactory).should().addInvocationListener(this.listener);
	}
	@Test
	void postProcessBeforeInitializationWhenOtherBeanDoesNothing() {
		Object bean = new Object();
		Object result = this.postProcessor.postProcessBeforeInitialization(bean, 'name');
		assertThat(result).isSameAs(bean);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.data;
/**
class RepositoryMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(RepositoryMetricsAutoConfiguration.class));
	@Test
	void backsOffWhenMeterRegistryIsMissing() {
		new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(RepositoryMetricsAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(RepositoryTagsProvider.class));
	}
	@Test
	void definesTagsProviderAndListenerWhenMeterRegistryIsPresent() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(DefaultRepositoryTagsProvider.class);
			assertThat(context).hasSingleBean(MetricsRepositoryMethodInvocationListener.class);
			assertThat(context).hasSingleBean(MetricsRepositoryMethodInvocationListenerBeanPostProcessor.class);
		});
	}
	@Test
	void tagsProviderBacksOff() {
		this.contextRunner.withUserConfiguration(TagsProviderConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(DefaultRepositoryTagsProvider.class);
			assertThat(context).hasSingleBean(TestRepositoryTagsProvider.class);
		});
	}
	@Test
	void metricsRepositoryMethodInvocationListenerBacksOff() {
		this.contextRunner.withUserConfiguration(MetricsRepositoryMethodInvocationListenerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(MetricsRepositoryMethodInvocationListener.class);
				assertThat(context).hasSingleBean(TestMetricsRepositoryMethodInvocationListener.class);
			});
	}
	@Test
	void metricNameCanBeConfigured() {
		this.contextRunner.withPropertyValues('management.metrics.data.repository.metric-name=datarepo')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context, ExampleRepository.class);
				Timer timer = registry.get('datarepo').timer();
				assertThat(timer).isNotNull();
			});
	}
	@Test
	void autoTimeRequestsCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('management.metrics.data.repository.autotime.enabled=true',
					'management.metrics.data.repository.autotime.percentiles=0.5,0.7')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context, ExampleRepository.class);
				Timer timer = registry.get('spring.data.repository.invocations').timer();
				HistogramSnapshot snapshot = timer.takeSnapshot();
				assertThat(snapshot.percentileValues()).hasSize(2);
				assertThat(snapshot.percentileValues()[0].percentile()).isEqualTo(0.5);
				assertThat(snapshot.percentileValues()[1].percentile()).isEqualTo(0.7);
			});
	}
	@Test
	void timerWorksWithTimedAnnotationsWhenAutoTimeRequestsIsFalse() {
		this.contextRunner.withPropertyValues('management.metrics.data.repository.autotime.enabled=false')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context, ExampleAnnotatedRepository.class);
				Collection<Meter> meters = registry.get('spring.data.repository.invocations').meters();
				assertThat(meters).hasSize(1);
				Meter meter = meters.iterator().next();
				assertThat(meter.getId().getTag('method')).isEqualTo('count');
			});
	}
	@Test
	void doesNotTriggerEarlyInitializationThatPreventsMeterBindersFromBindingMeters() {
		this.contextRunner.withUserConfiguration(MeterBinderConfiguration.class)
			.run((context) -> assertThat(context.getBean(MeterRegistry.class).find('binder.test').counter())
				.isNotNull());
	}
	private MeterRegistry getInitializedMeterRegistry(AssertableApplicationContext context,
			Class<?> repositoryInterface) {
		MetricsRepositoryMethodInvocationListener listener = context
			.getBean(MetricsRepositoryMethodInvocationListener.class);
		ReflectionUtils.doWithLocalMethods(repositoryInterface, (method) -> {
			RepositoryMethodInvocationResult result = mock(RepositoryMethodInvocationResult.class);
			given(result.getState()).willReturn(State.SUCCESS);
			RepositoryMethodInvocation invocation = new RepositoryMethodInvocation(repositoryInterface, method, result,
					10);
			listener.afterInvocation(invocation);
		});
		return context.getBean(MeterRegistry.class);
	}
	@Configuration(proxyBeanMethods = false)
	static class TagsProviderConfiguration {
		@Bean
		TestRepositoryTagsProvider tagsProvider() {
			return new TestRepositoryTagsProvider();
		}
	}
	private static final class TestRepositoryTagsProvider implements RepositoryTagsProvider {
		@Override
		public Iterable<Tag> repositoryTags(RepositoryMethodInvocation invocation) {
			return Collections.emptyList();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MeterBinderConfiguration {
		@Bean
		MeterBinder meterBinder() {
			return (registry) -> registry.counter('binder.test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MetricsRepositoryMethodInvocationListenerConfiguration {
		@Bean
		MetricsRepositoryMethodInvocationListener metricsRepositoryMethodInvocationListener(
				ObjectFactory<MeterRegistry> registry, RepositoryTagsProvider tagsProvider) {
			return new TestMetricsRepositoryMethodInvocationListener(registry::getObject, tagsProvider);
		}
	}
	static class TestMetricsRepositoryMethodInvocationListener extends MetricsRepositoryMethodInvocationListener {
		TestMetricsRepositoryMethodInvocationListener(Supplier<MeterRegistry> registrySupplier,
				RepositoryTagsProvider tagsProvider) {
			super(registrySupplier, tagsProvider, 'test', AutoTimer.DISABLED);
		}
	}
	interface ExampleRepository extends Repository<Example, Long> {
		long count();
	}
	interface ExampleAnnotatedRepository extends Repository<Example, Long> {
		@Timed
		long count();
		long delete();
	}
	static class Example {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.data;
/**
class RepositoryMetricsAutoConfigurationIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(
				AutoConfigurations.of(HibernateJpaAutoConfiguration.class, JpaRepositoriesAutoConfiguration.class,
						PropertyPlaceholderAutoConfiguration.class, RepositoryMetricsAutoConfiguration.class))
		.withUserConfiguration(EmbeddedDataSourceConfiguration.class, TestConfig.class);
	@Test
	void repositoryMethodCallRecordsMetrics() {
		this.contextRunner.run((context) -> {
			context.getBean(CityRepository.class).count();
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry.get('spring.data.repository.invocations')
				.tag('repository', 'CityRepository')
				.timer()
				.count()).isOne();
		});
	}
	@Test
	void doesNotPreventMeterBindersFromDependingUponSpringDataRepositories() {
		this.contextRunner.withUserConfiguration(SpringDataRepositoryMeterBinderConfiguration.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigurationPackage
	static class TestConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class SpringDataRepositoryMeterBinderConfiguration {
		@Bean
		MeterBinder meterBinder(CityRepository repository) {
			return (registry) -> Gauge.builder('city.count', repository::count);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.data.city;
@Entity
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	@Column(nullable = false)
	private String name;
	@Column(nullable = false)
	private String state;
	@Column(nullable = false)
	private String country;
	@Column(nullable = false)
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.data.city;
public interface CityRepository extends JpaRepository<City, Long> {
	@Override
	Page<City> findAll(Pageable pageable);
	Page<City> findByNameLikeAndCountryLikeAllIgnoringCase(String name, String country, Pageable pageable);
	City findByNameAndCountryAllIgnoringCase(String name, String country);
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class JvmMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(JvmMetricsAutoConfiguration.class));
	@Test
	void autoConfiguresJvmMetrics() {
		this.contextRunner.run(assertMetricsBeans());
	}
	@Test
	void allowsCustomJvmGcMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomJvmGcMetricsConfiguration.class)
			.run(assertMetricsBeans().andThen((context) -> assertThat(context).hasBean('customJvmGcMetrics')));
	}
	@Test
	void allowsCustomJvmHeapPressureMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomJvmHeapPressureMetricsConfiguration.class)
			.run(assertMetricsBeans()
				.andThen((context) -> assertThat(context).hasBean('customJvmHeapPressureMetrics')));
	}
	@Test
	void allowsCustomJvmMemoryMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomJvmMemoryMetricsConfiguration.class)
			.run(assertMetricsBeans().andThen((context) -> assertThat(context).hasBean('customJvmMemoryMetrics')));
	}
	@Test
	void allowsCustomJvmThreadMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomJvmThreadMetricsConfiguration.class)
			.run(assertMetricsBeans().andThen((context) -> assertThat(context).hasBean('customJvmThreadMetrics')));
	}
	@Test
	void allowsCustomClassLoaderMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomClassLoaderMetricsConfiguration.class)
			.run(assertMetricsBeans().andThen((context) -> assertThat(context).hasBean('customClassLoaderMetrics')));
	}
	@Test
	void allowsCustomJvmInfoMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomJvmInfoMetricsConfiguration.class)
			.run(assertMetricsBeans().andThen((context) -> assertThat(context).hasBean('customJvmInfoMetrics')));
	}
	@Test
	void allowsCustomJvmCompilationMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomJvmCompilationMetricsConfiguration.class)
			.run(assertMetricsBeans().andThen((context) -> assertThat(context).hasBean('customJvmCompilationMetrics')));
	}
	private ContextConsumer<AssertableApplicationContext> assertMetricsBeans() {
		return (context) -> assertThat(context).hasSingleBean(JvmGcMetrics.class)
			.hasSingleBean(JvmHeapPressureMetrics.class)
			.hasSingleBean(JvmMemoryMetrics.class)
			.hasSingleBean(JvmThreadMetrics.class)
			.hasSingleBean(ClassLoaderMetrics.class)
			.hasSingleBean(JvmInfoMetrics.class)
			.hasSingleBean(JvmCompilationMetrics.class);
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJvmGcMetricsConfiguration {
		@Bean
		JvmGcMetrics customJvmGcMetrics() {
			return new JvmGcMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJvmHeapPressureMetricsConfiguration {
		@Bean
		JvmHeapPressureMetrics customJvmHeapPressureMetrics() {
			return new JvmHeapPressureMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJvmMemoryMetricsConfiguration {
		@Bean
		JvmMemoryMetrics customJvmMemoryMetrics() {
			return new JvmMemoryMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJvmThreadMetricsConfiguration {
		@Bean
		JvmThreadMetrics customJvmThreadMetrics() {
			return new JvmThreadMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomClassLoaderMetricsConfiguration {
		@Bean
		ClassLoaderMetrics customClassLoaderMetrics() {
			return new ClassLoaderMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJvmInfoMetricsConfiguration {
		@Bean
		JvmInfoMetrics customJvmInfoMetrics() {
			return new JvmInfoMetrics();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJvmCompilationMetricsConfiguration {
		@Bean
		JvmCompilationMetrics customJvmCompilationMetrics() {
			return new JvmCompilationMetrics();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class MeterRegistryCustomizerTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.with(MetricsRun.limitedTo(AtlasMetricsExportAutoConfiguration.class,
				PrometheusMetricsExportAutoConfiguration.class))
		.withConfiguration(AutoConfigurations.of(JvmMetricsAutoConfiguration.class));
	@Test
	void commonTagsAreAppliedToAutoConfiguredBinders() {
		this.contextRunner.withUserConfiguration(MeterRegistryCustomizerConfiguration.class).run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			registry.get('jvm.memory.used').tags('region', 'us-east-1').gauge();
		});
	}
	@Test
	void commonTagsAreAppliedBeforeRegistryIsInjectableElsewhere() {
		this.contextRunner.withUserConfiguration(MeterRegistryCustomizerConfiguration.class).run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			registry.get('my.thing').tags('region', 'us-east-1').gauge();
		});
	}
	@Test
	void customizersCanBeAppliedToSpecificRegistryTypes() {
		this.contextRunner.withUserConfiguration(MeterRegistryCustomizerConfiguration.class).run((context) -> {
			MeterRegistry prometheus = context.getBean(PrometheusMeterRegistry.class);
			prometheus.get('jvm.memory.used').tags('job', 'myjob').gauge();
			MeterRegistry atlas = context.getBean(AtlasMeterRegistry.class);
			assertThat(atlas.find('jvm.memory.used').tags('job', 'myjob').gauge()).isNull();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class MeterRegistryCustomizerConfiguration {
		@Bean
		MeterRegistryCustomizer<MeterRegistry> commonTags() {
			return (registry) -> registry.config().commonTags('region', 'us-east-1');
		}
		@Bean
		MeterRegistryCustomizer<PrometheusMeterRegistry> prometheusOnlyCommonTags() {
			return (registry) -> registry.config().commonTags('job', 'myjob');
		}
		@Bean
		MyThing myThing(MeterRegistry registry) {
			registry.gauge('my.thing', 0);
			return new MyThing();
		}
		class MyThing {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class PropertiesMeterFilterTests {
	@Test
	void createWhenPropertiesIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new PropertiesMeterFilter(null))
			.withMessageContaining('Properties must not be null');
	}
	@Test
	void acceptWhenHasNoEnabledPropertiesShouldReturnNeutral() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties());
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.NEUTRAL);
	}
	@Test
	void acceptWhenHasNoMatchingEnabledPropertyShouldReturnNeutral() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('enable.something.else=false'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.NEUTRAL);
	}
	@Test
	void acceptWhenHasEnableFalseShouldReturnDeny() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('enable.spring.boot=false'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.DENY);
	}
	@Test
	void acceptWhenHasEnableTrueShouldReturnNeutral() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('enable.spring.boot=true'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.NEUTRAL);
	}
	@Test
	void acceptWhenHasHigherEnableFalseShouldReturnDeny() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('enable.spring=false'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.DENY);
	}
	@Test
	void acceptWhenHasHigherEnableTrueShouldReturnNeutral() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('enable.spring=true'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.NEUTRAL);
	}
	@Test
	void acceptWhenHasHigherEnableFalseExactEnableTrueShouldReturnNeutral() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('enable.spring=false', 'enable.spring.boot=true'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.NEUTRAL);
	}
	@Test
	void acceptWhenHasHigherEnableTrueExactEnableFalseShouldReturnDeny() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('enable.spring=true', 'enable.spring.boot=false'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.DENY);
	}
	@Test
	void acceptWhenHasAllEnableFalseShouldReturnDeny() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('enable.all=false'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.DENY);
	}
	@Test
	void acceptWhenHasAllEnableFalseButHigherEnableTrueShouldReturnNeutral() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('enable.all=false', 'enable.spring=true'));
		assertThat(filter.accept(createMeterId('spring.boot'))).isEqualTo(MeterFilterReply.NEUTRAL);
	}
	@Test
	void configureWhenHasHistogramTrueShouldSetPercentilesHistogramToTrue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles-histogram.spring.boot=true'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.isPercentileHistogram()).isTrue();
	}
	@Test
	void configureWhenHasHistogramFalseShouldSetPercentilesHistogramToFalse() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles-histogram.spring.boot=false'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.isPercentileHistogram()).isFalse();
	}
	@Test
	void configureWhenHasHigherHistogramTrueShouldSetPercentilesHistogramToTrue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles-histogram.spring=true'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.isPercentileHistogram()).isTrue();
	}
	@Test
	void configureWhenHasHigherHistogramFalseShouldSetPercentilesHistogramToFalse() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles-histogram.spring=false'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.isPercentileHistogram()).isFalse();
	}
	@Test
	void configureWhenHasHigherHistogramTrueAndLowerFalseShouldSetPercentilesHistogramToFalse() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles-histogram.spring=true',
						'distribution.percentiles-histogram.spring.boot=false'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.isPercentileHistogram()).isFalse();
	}
	@Test
	void configureWhenHasHigherHistogramFalseAndLowerTrueShouldSetPercentilesHistogramToFalse() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles-histogram.spring=false',
						'distribution.percentiles-histogram.spring.boot=true'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.isPercentileHistogram()).isTrue();
	}
	@Test
	void configureWhenAllHistogramTrueSetPercentilesHistogramToTrue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles-histogram.all=true'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.isPercentileHistogram()).isTrue();
	}
	@Test
	void configureWhenHasPercentilesShouldSetPercentilesToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles.spring.boot=0.2,0.4,0.8'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getPercentiles())
			.containsExactly(0.2, 0.4, 0.8);
	}
	@Test
	void configureWhenHasHigherPercentilesShouldSetPercentilesToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles.spring=0.2,0.4,0.8'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getPercentiles())
			.containsExactly(0.2, 0.4, 0.8);
	}
	@Test
	void configureWhenHasHigherPercentilesAndLowerShouldSetPercentilesToLower() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties(
				'distribution.percentiles.spring=0.2,0.4,0.8', 'distribution.percentiles.spring.boot=0.85,0.9,0.95'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getPercentiles())
			.containsExactly(0.85, 0.9, 0.95);
	}
	@Test
	void configureWhenAllPercentilesSetShouldSetPercentilesToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.percentiles.all=0.2,0.4,0.8'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getPercentiles())
			.containsExactly(0.2, 0.4, 0.8);
	}
	@Test
	void configureWhenHasSloShouldSetSloToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.slo.spring.boot=1,2,3'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getServiceLevelObjectiveBoundaries()).containsExactly(1000000, 2000000, 3000000);
	}
	@Test
	void configureWhenHasHigherSloShouldSetPercentilesToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('distribution.slo.spring=1,2,3'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getServiceLevelObjectiveBoundaries()).containsExactly(1000000, 2000000, 3000000);
	}
	@Test
	void configureWhenHasHigherSloAndLowerShouldSetSloToLower() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.slo.spring=1,2,3', 'distribution.slo.spring.boot=4,5,6'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getServiceLevelObjectiveBoundaries()).containsExactly(4000000, 5000000, 6000000);
	}
	@Test
	void configureWhenHasMinimumExpectedValueShouldSetMinimumExpectedToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.minimum-expected-value.spring.boot=10'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getMinimumExpectedValueAsDouble()).isEqualTo(Duration.ofMillis(10).toNanos());
	}
	@Test
	void configureWhenHasHigherMinimumExpectedValueShouldSetMinimumExpectedValueToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.minimum-expected-value.spring=10'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getMinimumExpectedValueAsDouble()).isEqualTo(Duration.ofMillis(10).toNanos());
	}
	@Test
	void configureWhenHasHigherMinimumExpectedValueAndLowerShouldSetMinimumExpectedValueToLower() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties(
				'distribution.minimum-expected-value.spring=10', 'distribution.minimum-expected-value.spring.boot=50'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getMinimumExpectedValueAsDouble()).isEqualTo(Duration.ofMillis(50).toNanos());
	}
	@Test
	void configureWhenHasMaximumExpectedValueShouldSetMaximumExpectedToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.maximum-expected-value.spring.boot=5000'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getMaximumExpectedValueAsDouble()).isEqualTo(Duration.ofMillis(5000).toNanos());
	}
	@Test
	void configureWhenHasHigherMaximumExpectedValueShouldSetMaximumExpectedValueToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.maximum-expected-value.spring=5000'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getMaximumExpectedValueAsDouble()).isEqualTo(Duration.ofMillis(5000).toNanos());
	}
	@Test
	void configureWhenHasHigherMaximumExpectedValueAndLowerShouldSetMaximumExpectedValueToLower() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.maximum-expected-value.spring=5000',
						'distribution.maximum-expected-value.spring.boot=10000'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT)
			.getMaximumExpectedValueAsDouble()).isEqualTo(Duration.ofMillis(10000).toNanos());
	}
	@Test
	void configureWhenHasExpiryShouldSetExpiryToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.expiry[spring.boot]=5ms'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getExpiry())
			.isEqualTo(Duration.ofMillis(5));
	}
	@Test
	void configureWhenHasHigherExpiryShouldSetExpiryToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('distribution.expiry.spring=5ms'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getExpiry())
			.isEqualTo(Duration.ofMillis(5));
	}
	@Test
	void configureWhenHasHigherExpiryAndLowerShouldSetExpiryToLower() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.expiry.spring=5ms', 'distribution.expiry[spring.boot]=10ms'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getExpiry())
			.isEqualTo(Duration.ofMillis(10));
	}
	@Test
	void configureWhenAllExpirySetShouldSetExpiryToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('distribution.expiry.all=5ms'));
		assertThat(filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getExpiry())
			.isEqualTo(Duration.ofMillis(5));
	}
	@Test
	void configureWhenHasBufferLengthShouldSetBufferLengthToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.buffer-length.spring.boot=3'));
		assertThat(
				filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getBufferLength())
			.isEqualTo(3);
	}
	@Test
	void configureWhenHasHigherBufferLengthShouldSetBufferLengthToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.buffer-length.spring=3'));
		assertThat(
				filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getBufferLength())
			.isEqualTo(3);
	}
	@Test
	void configureWhenHasHigherBufferLengthAndLowerShouldSetBufferLengthToLower() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(
				createProperties('distribution.buffer-length.spring=2', 'distribution.buffer-length.spring.boot=3'));
		assertThat(
				filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getBufferLength())
			.isEqualTo(3);
	}
	@Test
	void configureWhenAllBufferLengthSetShouldSetBufferLengthToValue() {
		PropertiesMeterFilter filter = new PropertiesMeterFilter(createProperties('distribution.buffer-length.all=3'));
		assertThat(
				filter.configure(createMeterId('spring.boot'), DistributionStatisticConfig.DEFAULT).getBufferLength())
			.isEqualTo(3);
	}
	private Id createMeterId(String name) {
		Meter.Type meterType = Type.TIMER;
		return createMeterId(name, meterType);
	}
	private Id createMeterId(String name, Meter.Type meterType) {
		TestMeterRegistry registry = new TestMeterRegistry();
		return Meter.builder(name, meterType, Collections.emptyList()).register(registry).getId();
	}
	private MetricsProperties createProperties(String... properties) {
		MockEnvironment environment = new MockEnvironment();
		TestPropertyValues.of(properties).applyTo(environment);
		Binder binder = Binder.get(environment);
		return binder.bind('', Bindable.of(MetricsProperties.class)).orElseGet(MetricsProperties::new);
	}
	static class TestMeterRegistry extends SimpleMeterRegistry {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class MetricsAutoConfigurationMeterRegistryPostProcessorIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.with(MetricsRun.limitedTo(AtlasMetricsExportAutoConfiguration.class,
				PrometheusMetricsExportAutoConfiguration.class))
		.withConfiguration(AutoConfigurations.of(JvmMetricsAutoConfiguration.class));
	@Test
	void binderMetricsAreSearchableFromTheComposite() {
		this.contextRunner.run((context) -> {
			CompositeMeterRegistry composite = context.getBean(CompositeMeterRegistry.class);
			composite.get('jvm.memory.used').gauge();
			context.getBeansOfType(MeterRegistry.class)
				.forEach((name, registry) -> registry.get('jvm.memory.used').gauge());
		});
	}
	@Test
	void customizersAreAppliedBeforeBindersAreCreated() {
		new ApplicationContextRunner()
			.withConfiguration(
					AutoConfigurations.of(MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class))
			.withUserConfiguration(TestConfiguration.class)
			.run((context) -> {
			});
	}
	@Test
	void counterIsIncrementedOncePerEventWithoutCompositeMeterRegistry() {
		new ApplicationContextRunner().with(MetricsRun.limitedTo(JmxMetricsExportAutoConfiguration.class))
			.withConfiguration(AutoConfigurations.of(LogbackMetricsAutoConfiguration.class))
			.run((context) -> {
				Logger logger = ((LoggerContext) LoggerFactory.getILoggerFactory()).getLogger('test-logger');
				logger.error('Error.');
				Map<String, MeterRegistry> registriesByName = context.getBeansOfType(MeterRegistry.class);
				assertThat(registriesByName).hasSize(1);
				MeterRegistry registry = registriesByName.values().iterator().next();
				assertThat(registry.get('logback.events').tag('level', 'error').counter().count()).isOne();
			});
	}
	@Test
	void counterIsIncrementedOncePerEventWithCompositeMeterRegistry() {
		new ApplicationContextRunner()
			.with(MetricsRun.limitedTo(JmxMetricsExportAutoConfiguration.class,
					PrometheusMetricsExportAutoConfiguration.class))
			.withConfiguration(AutoConfigurations.of(LogbackMetricsAutoConfiguration.class))
			.run((context) -> {
				Logger logger = ((LoggerContext) LoggerFactory.getILoggerFactory()).getLogger('test-logger');
				logger.error('Error.');
				Map<String, MeterRegistry> registriesByName = context.getBeansOfType(MeterRegistry.class);
				assertThat(registriesByName).hasSize(3);
				registriesByName.forEach((name,
						registry) -> assertThat(registry.get('logback.events').tag('level', 'error').counter().count())
							.isOne());
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		MeterBinder testBinder(Alpha thing) {
			return (registry) -> {
			};
		}
		@Bean
		MeterRegistryCustomizer<?> testCustomizer() {
			return (registry) -> registry.config().commonTags('testTag', 'testValue');
		}
		@Bean
		Alpha alpha() {
			return new Alpha();
		}
		@Bean
		Bravo bravo(Alpha alpha) {
			return new Bravo(alpha);
		}
		@Bean
		static BeanPostProcessor testPostProcessor(ApplicationContext context) {
			return new BeanPostProcessor() {
				@Override
				public Object postProcessAfterInitialization(Object bean, String beanName) {
					if (bean instanceof Bravo) {
						MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
						meterRegistry.gauge('test', 1);
						System.out.println(meterRegistry.find('test').gauge().getId().getTags());
					}
					return bean;
				}
			};
		}
	}
	static class Alpha {
	}
	static class Bravo {
		Bravo(Alpha alpha) {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.amqp;
/**
class RabbitMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(RabbitAutoConfiguration.class, RabbitMetricsAutoConfiguration.class));
	@Test
	void autoConfiguredConnectionFactoryIsInstrumented() {
		this.contextRunner.run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			registry.get('rabbitmq.connections').meter();
		});
	}
	@Test
	void abstractConnectionFactoryDefinedAsAConnectionFactoryIsInstrumented() {
		this.contextRunner.withUserConfiguration(ConnectionFactoryConfiguration.class).run((context) -> {
			assertThat(context).hasBean('customConnectionFactory');
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			registry.get('rabbitmq.connections').meter();
		});
	}
	@Test
	void rabbitmqNativeConnectionFactoryInstrumentationCanBeDisabled() {
		this.contextRunner.withPropertyValues('management.metrics.enable.rabbitmq=false').run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry.find('rabbitmq.connections').meter()).isNull();
		});
	}
	@Configuration
	static class ConnectionFactoryConfiguration {
		@Bean
		ConnectionFactory customConnectionFactory() {
			return new CachingConnectionFactory();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@ConfigureClasspathToPreferLog4j2
class LogbackMetricsAutoConfigurationWithLog4j2AndLogbackTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class,
				SimpleMetricsExportAutoConfiguration.class, LogbackMetricsAutoConfiguration.class));
	@Test
	void doesNotConfigureLogbackMetrics() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(LogbackMetrics.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class CompositeMeterRegistryAutoConfigurationTests {
	private static final String COMPOSITE_NAME = 'compositeMeterRegistry';
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(BaseConfig.class)
		.withConfiguration(AutoConfigurations.of(CompositeMeterRegistryAutoConfiguration.class));
	@Test
	void registerWhenHasNoMeterRegistryShouldRegisterEmptyNoOpComposite() {
		this.contextRunner.withUserConfiguration(NoMeterRegistryConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(MeterRegistry.class);
			CompositeMeterRegistry registry = context.getBean('noOpMeterRegistry', CompositeMeterRegistry.class);
			assertThat(registry.getRegistries()).isEmpty();
		});
	}
	@Test
	void registerWhenHasSingleMeterRegistryShouldDoNothing() {
		this.contextRunner.withUserConfiguration(SingleMeterRegistryConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(MeterRegistry.class);
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry).isInstanceOf(TestMeterRegistry.class);
		});
	}
	@Test
	void registerWhenHasMultipleMeterRegistriesShouldAddPrimaryComposite() {
		this.contextRunner.withUserConfiguration(MultipleMeterRegistriesConfig.class).run((context) -> {
			assertThat(context.getBeansOfType(MeterRegistry.class)).hasSize(3)
				.containsKeys('meterRegistryOne', 'meterRegistryTwo', COMPOSITE_NAME);
			MeterRegistry primary = context.getBean(MeterRegistry.class);
			assertThat(primary).isInstanceOf(CompositeMeterRegistry.class);
			assertThat(((CompositeMeterRegistry) primary).getRegistries()).hasSize(2);
			assertThat(primary.config().clock()).isNotNull();
		});
	}
	@Test
	void registerWhenHasMultipleRegistriesAndOneIsPrimaryShouldDoNothing() {
		this.contextRunner.withUserConfiguration(MultipleMeterRegistriesWithOnePrimaryConfig.class).run((context) -> {
			assertThat(context.getBeansOfType(MeterRegistry.class)).hasSize(2)
				.containsKeys('meterRegistryOne', 'meterRegistryTwo');
			MeterRegistry primary = context.getBean(MeterRegistry.class);
			assertThat(primary).isInstanceOf(TestMeterRegistry.class);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfig {
		@Bean
		@ConditionalOnMissingBean
		Clock micrometerClock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NoMeterRegistryConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class SingleMeterRegistryConfig {
		@Bean
		MeterRegistry meterRegistry() {
			return new TestMeterRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleMeterRegistriesConfig {
		@Bean
		MeterRegistry meterRegistryOne() {
			return new TestMeterRegistry();
		}
		@Bean
		MeterRegistry meterRegistryTwo() {
			return new SimpleMeterRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleMeterRegistriesWithOnePrimaryConfig {
		@Bean
		@Primary
		MeterRegistry meterRegistryOne() {
			return new TestMeterRegistry();
		}
		@Bean
		MeterRegistry meterRegistryTwo() {
			return new SimpleMeterRegistry();
		}
	}
	static class TestMeterRegistry extends SimpleMeterRegistry {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.redis;
/**
class LettuceMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LettuceMetricsAutoConfiguration.class));
	@Test
	void whenThereIsAMeterRegistryThenCommandLatencyRecorderIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.run((context) -> {
				ClientResources clientResources = context.getBean(LettuceConnectionFactory.class).getClientResources();
				assertThat(clientResources.commandLatencyRecorder())
					.isInstanceOf(MicrometerCommandLatencyRecorder.class);
			});
	}
	@Test
	void autoConfiguredMicrometerOptionsUsesLettucesDefaults() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.run((context) -> {
				MicrometerOptions micrometerOptions = context.getBean(MicrometerOptions.class);
				assertThat(micrometerOptions.isEnabled()).isTrue();
				assertThat(micrometerOptions.isHistogram()).isFalse();
				assertThat(micrometerOptions.localDistinction()).isFalse();
				assertThat(micrometerOptions.maxLatency()).isEqualTo(MicrometerOptions.DEFAULT_MAX_LATENCY);
				assertThat(micrometerOptions.minLatency()).isEqualTo(MicrometerOptions.DEFAULT_MIN_LATENCY);
			});
	}
	@Test
	void whenUserDefinesAMicrometerOptionsBeanThenCommandLatencyRecorderUsesIt() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withUserConfiguration(CustomMicrometerOptionsConfiguration.class)
			.run((context) -> {
				ClientResources clientResources = context.getBean(LettuceConnectionFactory.class).getClientResources();
				assertThat(clientResources.commandLatencyRecorder())
					.isInstanceOf(MicrometerCommandLatencyRecorder.class);
				assertThat(clientResources.commandLatencyRecorder()).hasFieldOrPropertyWithValue('options',
						context.getBean('customMicrometerOptions'));
			});
	}
	@Test
	void whenThereIsNoMeterRegistryThenClientResourcesCustomizationBacksOff() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class)).run((context) -> {
			ClientResources clientResources = context.getBean(LettuceConnectionFactory.class).getClientResources();
			assertThat(clientResources.commandLatencyRecorder())
				.isNotInstanceOf(MicrometerCommandLatencyRecorder.class);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomMicrometerOptionsConfiguration {
		@Bean
		MicrometerOptions customMicrometerOptions() {
			return MicrometerOptions.create();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.startup;
/**
class StartupTimeMetricsListenerAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(StartupTimeMetricsListenerAutoConfiguration.class));
	@Test
	void startupTimeMetricsAreRecorded() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(StartupTimeMetricsListener.class);
			SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
			context.publishEvent(new ApplicationStartedEvent(new SpringApplication(), null,
					context.getSourceApplicationContext(), Duration.ofMillis(1500)));
			TimeGauge startedTimeGage = registry.find('application.started.time').timeGauge();
			assertThat(startedTimeGage).isNotNull();
			assertThat(startedTimeGage.value(TimeUnit.MILLISECONDS)).isEqualTo(1500L);
			context.publishEvent(new ApplicationReadyEvent(new SpringApplication(), null,
					context.getSourceApplicationContext(), Duration.ofMillis(2000)));
			TimeGauge readyTimeGage = registry.find('application.ready.time').timeGauge();
			assertThat(readyTimeGage).isNotNull();
			assertThat(readyTimeGage.value(TimeUnit.MILLISECONDS)).isEqualTo(2000L);
		});
	}
	@Test
	void startupTimeMetricsCanBeDisabled() {
		this.contextRunner
			.withPropertyValues('management.metrics.enable.application.started.time:false',
					'management.metrics.enable.application.ready.time:false')
			.run((context) -> {
				context.publishEvent(new ApplicationStartedEvent(new SpringApplication(), null,
						context.getSourceApplicationContext(), Duration.ofMillis(2500)));
				context.publishEvent(new ApplicationReadyEvent(new SpringApplication(), null,
						context.getSourceApplicationContext(), Duration.ofMillis(3000)));
				SimpleMeterRegistry registry = context.getBean(SimpleMeterRegistry.class);
				assertThat(registry.find('application.started.time').timeGauge()).isNull();
				assertThat(registry.find('application.ready.time').timeGauge()).isNull();
			});
	}
	@Test
	void customStartupTimeMetricsAreRespected() {
		this.contextRunner
			.withBean('customStartupTimeMetrics', StartupTimeMetricsListener.class,
					() -> mock(StartupTimeMetricsListener.class))
			.run((context) -> assertThat(context).hasSingleBean(StartupTimeMetricsListener.class)
				.hasBean('customStartupTimeMetrics'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class ServiceLevelObjectiveBoundaryTests {
	@Test
	void getValueForTimerWhenFromLongShouldReturnMsToNanosValue() {
		ServiceLevelObjectiveBoundary slo = ServiceLevelObjectiveBoundary.valueOf(123L);
		assertThat(slo.getValue(Type.TIMER)).isEqualTo(123000000);
	}
	@Test
	void getValueForTimerWhenFromNumberStringShouldMsToNanosValue() {
		ServiceLevelObjectiveBoundary slo = ServiceLevelObjectiveBoundary.valueOf('123');
		assertThat(slo.getValue(Type.TIMER)).isEqualTo(123000000);
	}
	@Test
	void getValueForTimerWhenFromMillisecondDurationStringShouldReturnDurationNanos() {
		ServiceLevelObjectiveBoundary slo = ServiceLevelObjectiveBoundary.valueOf('123ms');
		assertThat(slo.getValue(Type.TIMER)).isEqualTo(123000000);
	}
	@Test
	void getValueForTimerWhenFromDaysDurationStringShouldReturnDurationNanos() {
		ServiceLevelObjectiveBoundary slo = ServiceLevelObjectiveBoundary.valueOf('1d');
		assertThat(slo.getValue(Type.TIMER)).isEqualTo(Duration.ofDays(1).toNanos());
	}
	@Test
	void getValueForDistributionSummaryWhenFromDoubleShouldReturnDoubleValue() {
		ServiceLevelObjectiveBoundary slo = ServiceLevelObjectiveBoundary.valueOf(123.42);
		assertThat(slo.getValue(Type.DISTRIBUTION_SUMMARY)).isEqualTo(123.42);
	}
	@Test
	void getValueForDistributionSummaryWhenFromStringShouldReturnDoubleValue() {
		ServiceLevelObjectiveBoundary slo = ServiceLevelObjectiveBoundary.valueOf('123.42');
		assertThat(slo.getValue(Type.DISTRIBUTION_SUMMARY)).isEqualTo(123.42);
	}
	@Test
	void getValueForDistributionSummaryWhenFromDurationShouldReturnNull() {
		ServiceLevelObjectiveBoundary slo = ServiceLevelObjectiveBoundary.valueOf('123ms');
		assertThat(slo.getValue(Type.DISTRIBUTION_SUMMARY)).isNull();
	}
	@Test
	void shouldRegisterRuntimeHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new ServiceLevelObjectiveBoundary.ServiceLevelObjectiveBoundaryHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		ReflectionUtils.doWithLocalMethods(ServiceLevelObjectiveBoundary.class, (method) -> {
			if ('valueOf'.equals(method.getName())) {
				assertThat(RuntimeHintsPredicates.reflection().onMethod(method)).accepts(runtimeHints);
			}
		});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.r2dbc;
/**
class ConnectionPoolMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.r2dbc.generate-unique-name=true')
		.with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(ConnectionPoolMetricsAutoConfiguration.class))
		.withUserConfiguration(BaseConfiguration.class);
	@Test
	void autoConfiguredDataSourceIsInstrumented() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class)).run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry.find('r2dbc.pool.acquired').gauges()).hasSize(1);
		});
	}
	@Test
	void autoConfiguredDataSourceExposedAsConnectionFactoryTypeIsInstrumented() {
		this.contextRunner
			.withPropertyValues(
					'spring.r2dbc.url:r2dbc:pool:h2:mem:///name?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
			.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('r2dbc.pool.acquired').gauges()).hasSize(1);
			});
	}
	@Test
	void connectionPoolInstrumentationCanBeDisabled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withPropertyValues('management.metrics.enable.r2dbc=false')
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('r2dbc.pool.acquired').gauge()).isNull();
			});
	}
	@Test
	void connectionPoolExposedAsConnectionFactoryTypeIsInstrumented() {
		this.contextRunner.withUserConfiguration(ConnectionFactoryConfiguration.class).run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry.find('r2dbc.pool.acquired').gauges()).extracting(Meter::getId)
				.extracting((id) -> id.getTag('name'))
				.containsExactly('testConnectionPool');
		});
	}
	@Test
	void wrappedConnectionPoolExposedAsConnectionFactoryTypeIsInstrumented() {
		this.contextRunner.withUserConfiguration(WrappedConnectionPoolConfiguration.class).run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry.find('r2dbc.pool.acquired').gauges()).extracting(Meter::getId)
				.extracting((id) -> id.getTag('name'))
				.containsExactly('wrappedConnectionPool');
		});
	}
	@Test
	void allConnectionPoolsCanBeInstrumented() {
		this.contextRunner.withUserConfiguration(TwoConnectionPoolsConfiguration.class).run((context) -> {
			MeterRegistry registry = context.getBean(MeterRegistry.class);
			assertThat(registry.find('r2dbc.pool.acquired').gauges()).extracting(Meter::getId)
				.extracting((id) -> id.getTag('name'))
				.containsExactlyInAnyOrder('firstPool', 'secondPool');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		SimpleMeterRegistry registry() {
			return new SimpleMeterRegistry();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionFactoryConfiguration {
		@Bean
		ConnectionFactory testConnectionPool() {
			return new ConnectionPool(
					ConnectionPoolConfiguration.builder(H2ConnectionFactory.inMemory('db-' + UUID.randomUUID(), 'sa',
							'', Collections.singletonMap(H2ConnectionOption.DB_CLOSE_DELAY, '-1')))
						.build());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WrappedConnectionPoolConfiguration {
		@Bean
		ConnectionFactory wrappedConnectionPool() {
			return new Wrapper(new ConnectionPool(
					ConnectionPoolConfiguration.builder(H2ConnectionFactory.inMemory('db-' + UUID.randomUUID(), 'sa',
							'', Collections.singletonMap(H2ConnectionOption.DB_CLOSE_DELAY, '-1')))
						.build()));
		}
		static class Wrapper implements ConnectionFactory, Wrapped<ConnectionFactory> {
			private final ConnectionFactory delegate;
			Wrapper(ConnectionFactory delegate) {
				this.delegate = delegate;
			}
			@Override
			public ConnectionFactory unwrap() {
				return this.delegate;
			}
			@Override
			public Publisher<? extends Connection> create() {
				return this.delegate.create();
			}
			@Override
			public ConnectionFactoryMetadata getMetadata() {
				return this.delegate.getMetadata();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TwoConnectionPoolsConfiguration {
		@Bean
		CloseableConnectionFactory connectionFactory() {
			return H2ConnectionFactory.inMemory('db-' + UUID.randomUUID(), 'sa', '',
					Collections.singletonMap(H2ConnectionOption.DB_CLOSE_DELAY, '-1'));
		}
		@Bean
		ConnectionPool firstPool(ConnectionFactory connectionFactory) {
			return new ConnectionPool(ConnectionPoolConfiguration.builder(connectionFactory).build());
		}
		@Bean
		ConnectionPool secondPool(ConnectionFactory connectionFactory) {
			return new ConnectionPool(ConnectionPoolConfiguration.builder(connectionFactory).build());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class ValidationFailureAnalyzerTests {
	@Test
	void analyzesMissingRequiredConfiguration() {
		FailureAnalysis analysis = new ValidationFailureAnalyzer()
			.analyze(createFailure(MissingAccountIdAndApiKeyConfiguration.class));
		assertThat(analysis).isNotNull();
		assertThat(analysis.getCause().getMessage()).contains('management.newrelic.metrics.export.apiKey was "null"');
		assertThat(analysis.getDescription()).isEqualTo(String.format('Invalid Micrometer configuration detected:%n%n'
				+ '  - management.newrelic.metrics.export.apiKey was "null" but it is required when publishing to Insights API%n'
				+ '  - management.newrelic.metrics.export.accountId was "null" but it is required when publishing to Insights API'));
	}
	private Exception createFailure(Class<?> configuration) {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(configuration)) {
			fail('Expected failure did not occur');
			return null;
		}
		catch (Exception ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(NewRelicProperties.class)
	static class MissingAccountIdAndApiKeyConfiguration {
		@Bean
		NewRelicMeterRegistry meterRegistry(NewRelicProperties newRelicProperties) {
			return new NewRelicMeterRegistry(new NewRelicPropertiesConfigAdapter(newRelicProperties), Clock.SYSTEM);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@ConfigureClasspathToPreferLog4j2
class Log4J2MetricsWithLog4jLoggerContextAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(Log4J2MetricsAutoConfiguration.class));
	@Test
	void autoConfiguresLog4J2Metrics() {
		assertThat(LogManager.getContext().getClass().getName())
			.isEqualTo('org.apache.logging.log4j.core.LoggerContext');
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(Log4j2Metrics.class));
	}
	@Test
	void allowsCustomLog4J2MetricsToBeUsed() {
		assertThat(LogManager.getContext().getClass().getName())
			.isEqualTo('org.apache.logging.log4j.core.LoggerContext');
		this.contextRunner.withUserConfiguration(CustomLog4J2MetricsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Log4j2Metrics.class).hasBean('customLog4J2Metrics'));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomLog4J2MetricsConfiguration {
		@Bean
		Log4j2Metrics customLog4J2Metrics() {
			return new Log4j2Metrics();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class MetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class));
	@Test
	void autoConfiguresAClock() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(Clock.class));
	}
	@Test
	void allowsACustomClockToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomClockConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Clock.class).hasBean('customClock'));
	}
	@SuppressWarnings('unchecked')
	@Test
	void configuresMeterRegistries() {
		this.contextRunner.withUserConfiguration(MeterRegistryConfiguration.class).run((context) -> {
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			MeterFilter[] filters = (MeterFilter[]) ReflectionTestUtils.getField(meterRegistry, 'filters');
			assertThat(filters).hasSize(3);
			assertThat(filters[0].accept((Meter.Id) null)).isEqualTo(MeterFilterReply.DENY);
			assertThat(filters[1]).isInstanceOf(PropertiesMeterFilter.class);
			assertThat(filters[2].accept((Meter.Id) null)).isEqualTo(MeterFilterReply.ACCEPT);
			then((MeterBinder) context.getBean('meterBinder')).should().bindTo(meterRegistry);
			then(context.getBean(MeterRegistryCustomizer.class)).should().customize(meterRegistry);
		});
	}
	@Test
	void shouldSupplyMeterRegistryCloser() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MeterRegistryCloser.class));
	}
	@Test
	void meterRegistryCloserShouldCloseRegistryOnShutdown() {
		this.contextRunner.withUserConfiguration(MeterRegistryConfiguration.class).run((context) -> {
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.isClosed()).isFalse();
			context.close();
			assertThat(meterRegistry.isClosed()).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomClockConfiguration {
		@Bean
		Clock customClock() {
			return Clock.SYSTEM;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MeterRegistryConfiguration {
		@Bean
		MeterRegistry meterRegistry() {
			return new SimpleMeterRegistry();
		}
		@Bean
		@SuppressWarnings('rawtypes')
		MeterRegistryCustomizer meterRegistryCustomizer() {
			return mock(MeterRegistryCustomizer.class);
		}
		@Bean
		MeterBinder meterBinder() {
			return mock(MeterBinder.class);
		}
		@Bean
		@Order(1)
		MeterFilter acceptMeterFilter() {
			return MeterFilter.accept();
		}
		@Bean
		@Order(-1)
		MeterFilter denyMeterFilter() {
			return MeterFilter.deny();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class KafkaMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(KafkaMetricsAutoConfiguration.class));
	@Test
	void whenThereIsAMeterRegistryThenMetricsListenersAreAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(KafkaAutoConfiguration.class))
			.run((context) -> {
				assertThat(((DefaultKafkaProducerFactory<?, ?>) context.getBean(DefaultKafkaProducerFactory.class))
					.getListeners()).hasSize(1).hasOnlyElementsOfTypes(MicrometerProducerListener.class);
				assertThat(((DefaultKafkaConsumerFactory<?, ?>) context.getBean(DefaultKafkaConsumerFactory.class))
					.getListeners()).hasSize(1).hasOnlyElementsOfTypes(MicrometerConsumerListener.class);
			});
	}
	@Test
	void whenThereIsNoMeterRegistryThenListenerCustomizationBacksOff() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(KafkaAutoConfiguration.class)).run((context) -> {
			assertThat(((DefaultKafkaProducerFactory<?, ?>) context.getBean(DefaultKafkaProducerFactory.class))
				.getListeners()).isEmpty();
			assertThat(((DefaultKafkaConsumerFactory<?, ?>) context.getBean(DefaultKafkaConsumerFactory.class))
				.getListeners()).isEmpty();
		});
	}
	@Test
	void whenKafkaStreamsIsEnabledAndThereIsAMeterRegistryThenMetricsListenersAreAdded() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(KafkaAutoConfiguration.class))
			.withUserConfiguration(EnableKafkaStreamsConfiguration.class)
			.withPropertyValues('spring.application.name=my-test-app')
			.with(MetricsRun.simple())
			.run((context) -> {
				StreamsBuilderFactoryBean streamsBuilderFactoryBean = context.getBean(StreamsBuilderFactoryBean.class);
				assertThat(streamsBuilderFactoryBean.getListeners()).hasSize(1)
					.hasOnlyElementsOfTypes(KafkaStreamsMicrometerListener.class);
			});
	}
	@Test
	void whenKafkaStreamsIsEnabledAndThereIsNoMeterRegistryThenListenerCustomizationBacksOff() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(KafkaAutoConfiguration.class))
			.withUserConfiguration(EnableKafkaStreamsConfiguration.class)
			.withPropertyValues('spring.application.name=my-test-app')
			.run((context) -> {
				StreamsBuilderFactoryBean streamsBuilderFactoryBean = context.getBean(StreamsBuilderFactoryBean.class);
				assertThat(streamsBuilderFactoryBean.getListeners()).isEmpty();
			});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableKafkaStreams
	static class EnableKafkaStreamsConfiguration {
		@Bean
		KTable<?, ?> table(StreamsBuilder builder) {
			KStream<Object, Object> stream = builder.stream(Pattern.compile('test'));
			return stream.groupByKey().count(Materialized.as('store'));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.mongo;
/**
class MongoMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MongoMetricsAutoConfiguration.class));
	@Test
	void whenThereIsAMeterRegistryThenMetricsCommandListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(MongoMetricsCommandListener.class);
				assertThat(getActualMongoClientSettingsUsedToConstructClient(context))
					.extracting(MongoClientSettings::getCommandListeners)
					.asInstanceOf(InstanceOfAssertFactories.LIST)
					.containsExactly(context.getBean(MongoMetricsCommandListener.class));
				assertThat(getMongoCommandTagsProviderUsedToConstructListener(context))
					.isInstanceOf(DefaultMongoCommandTagsProvider.class);
			});
	}
	@Test
	void whenThereIsAMeterRegistryThenMetricsConnectionPoolListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(MongoMetricsConnectionPoolListener.class);
				assertThat(getConnectionPoolListenersFromClient(context))
					.containsExactly(context.getBean(MongoMetricsConnectionPoolListener.class));
				assertThat(getMongoConnectionPoolTagsProviderUsedToConstructListener(context))
					.isInstanceOf(DefaultMongoConnectionPoolTagsProvider.class);
			});
	}
	@Test
	void whenThereIsNoMeterRegistryThenNoMetricsCommandListenerIsAdded() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.run(assertThatMetricsCommandListenerNotAdded());
	}
	@Test
	void whenThereIsNoMeterRegistryThenNoMetricsConnectionPoolListenerIsAdded() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.run(assertThatMetricsConnectionPoolListenerNotAdded());
	}
	@Test
	void whenThereIsACustomMetricsCommandTagsProviderItIsUsed() {
		final MongoCommandTagsProvider customTagsProvider = mock(MongoCommandTagsProvider.class);
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withBean('customMongoCommandTagsProvider', MongoCommandTagsProvider.class, () -> customTagsProvider)
			.run((context) -> assertThat(getMongoCommandTagsProviderUsedToConstructListener(context))
				.isSameAs(customTagsProvider));
	}
	@Test
	void whenThereIsACustomMetricsConnectionPoolTagsProviderItIsUsed() {
		final MongoConnectionPoolTagsProvider customTagsProvider = mock(MongoConnectionPoolTagsProvider.class);
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withBean('customMongoConnectionPoolTagsProvider', MongoConnectionPoolTagsProvider.class,
					() -> customTagsProvider)
			.run((context) -> assertThat(getMongoConnectionPoolTagsProviderUsedToConstructListener(context))
				.isSameAs(customTagsProvider));
	}
	@Test
	void whenThereIsNoMongoClientSettingsOnClasspathThenNoMetricsCommandListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(MongoClientSettings.class))
			.run(assertThatMetricsCommandListenerNotAdded());
	}
	@Test
	void whenThereIsNoMongoClientSettingsOnClasspathThenNoMetricsConnectionPoolListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(MongoClientSettings.class))
			.run(assertThatMetricsConnectionPoolListenerNotAdded());
	}
	@Test
	void whenThereIsNoMongoMetricsCommandListenerOnClasspathThenNoMetricsCommandListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(MongoMetricsCommandListener.class))
			.run(assertThatMetricsCommandListenerNotAdded());
	}
	@Test
	void whenThereIsNoMongoMetricsConnectionPoolListenerOnClasspathThenNoMetricsConnectionPoolListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(MongoMetricsConnectionPoolListener.class))
			.run(assertThatMetricsConnectionPoolListenerNotAdded());
	}
	@Test
	void whenMetricsCommandListenerEnabledPropertyFalseThenNoMetricsCommandListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withPropertyValues('management.metrics.mongo.command.enabled:false')
			.run(assertThatMetricsCommandListenerNotAdded());
	}
	@Test
	void whenMetricsConnectionPoolListenerEnabledPropertyFalseThenNoMetricsConnectionPoolListenerIsAdded() {
		this.contextRunner.with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class))
			.withPropertyValues('management.metrics.mongo.connectionpool.enabled:false')
			.run(assertThatMetricsConnectionPoolListenerNotAdded());
	}
	private ContextConsumer<AssertableApplicationContext> assertThatMetricsCommandListenerNotAdded() {
		return (context) -> {
			assertThat(context).doesNotHaveBean(MongoMetricsCommandListener.class);
			assertThat(getActualMongoClientSettingsUsedToConstructClient(context))
				.extracting(MongoClientSettings::getCommandListeners)
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.isEmpty();
		};
	}
	private ContextConsumer<AssertableApplicationContext> assertThatMetricsConnectionPoolListenerNotAdded() {
		return (context) -> {
			assertThat(context).doesNotHaveBean(MongoMetricsConnectionPoolListener.class);
			assertThat(getConnectionPoolListenersFromClient(context)).isEmpty();
		};
	}
	private MongoClientSettings getActualMongoClientSettingsUsedToConstructClient(
			final AssertableApplicationContext context) {
		final MongoClientImpl mongoClient = (MongoClientImpl) context.getBean(MongoClient.class);
		return mongoClient.getSettings();
	}
	private List<ConnectionPoolListener> getConnectionPoolListenersFromClient(
			final AssertableApplicationContext context) {
		MongoClientSettings mongoClientSettings = getActualMongoClientSettingsUsedToConstructClient(context);
		ConnectionPoolSettings connectionPoolSettings = mongoClientSettings.getConnectionPoolSettings();
		return connectionPoolSettings.getConnectionPoolListeners();
	}
	private MongoCommandTagsProvider getMongoCommandTagsProviderUsedToConstructListener(
			final AssertableApplicationContext context) {
		MongoMetricsCommandListener listener = context.getBean(MongoMetricsCommandListener.class);
		return (MongoCommandTagsProvider) ReflectionTestUtils.getField(listener, 'tagsProvider');
	}
	private MongoConnectionPoolTagsProvider getMongoConnectionPoolTagsProviderUsedToConstructListener(
			final AssertableApplicationContext context) {
		MongoMetricsConnectionPoolListener listener = context.getBean(MongoMetricsConnectionPoolListener.class);
		return (MongoConnectionPoolTagsProvider) ReflectionTestUtils.getField(listener, 'tagsProvider');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.orm.jpa;
/**
class HibernateMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class,
				HibernateMetricsAutoConfiguration.class))
		.withUserConfiguration(BaseConfiguration.class);
	@Test
	void autoConfiguredEntityManagerFactoryWithStatsIsInstrumented() {
		this.contextRunner.withPropertyValues('spring.jpa.properties.hibernate.generate_statistics:true')
			.run((context) -> {
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hibernate.statements').tags('entityManagerFactory', 'entityManagerFactory').meter();
			});
	}
	@Test
	void autoConfiguredEntityManagerFactoryWithoutStatsIsNotInstrumented() {
		this.contextRunner.withPropertyValues('spring.jpa.properties.hibernate.generate_statistics:false')
			.run((context) -> {
				context.getBean(EntityManagerFactory.class).unwrap(SessionFactory.class);
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('hibernate.statements').meter()).isNull();
			});
	}
	@Test
	void entityManagerFactoryInstrumentationCanBeDisabled() {
		this.contextRunner
			.withPropertyValues('management.metrics.enable.hibernate=false',
					'spring.jpa.properties.hibernate.generate_statistics:true')
			.run((context) -> {
				context.getBean(EntityManagerFactory.class).unwrap(SessionFactory.class);
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('hibernate.statements').meter()).isNull();
			});
	}
	@Test
	void allEntityManagerFactoriesCanBeInstrumented() {
		this.contextRunner.withPropertyValues('spring.jpa.properties.hibernate.generate_statistics:true')
			.withUserConfiguration(TwoEntityManagerFactoriesConfiguration.class)
			.run((context) -> {
				context.getBean('firstEntityManagerFactory', EntityManagerFactory.class).unwrap(SessionFactory.class);
				context.getBean('secondOne', EntityManagerFactory.class).unwrap(SessionFactory.class);
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hibernate.statements').tags('entityManagerFactory', 'first').meter();
				registry.get('hibernate.statements').tags('entityManagerFactory', 'secondOne').meter();
			});
	}
	@Test
	void entityManagerFactoryInstrumentationIsDisabledIfNotHibernateSessionFactory() {
		this.contextRunner.withPropertyValues('spring.jpa.properties.hibernate.generate_statistics:true')
			.withUserConfiguration(NonHibernateEntityManagerFactoryConfiguration.class)
			.run((context) -> {
				// ensure EntityManagerFactory is not a Hibernate SessionFactory
				assertThatExceptionOfType(PersistenceException.class)
					.isThrownBy(() -> context.getBean(EntityManagerFactory.class).unwrap(SessionFactory.class));
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('hibernate.statements').meter()).isNull();
			});
	}
	@Test
	void entityManagerFactoryInstrumentationIsDisabledIfHibernateIsNotAvailable() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(SessionFactory.class))
			.withUserConfiguration(NonHibernateEntityManagerFactoryConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(HibernateMetricsAutoConfiguration.class);
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				assertThat(registry.find('hibernate.statements').meter()).isNull();
			});
	}
	@Test
	void entityManagerFactoryInstrumentationDoesNotDeadlockWithDeferredInitialization() {
		this.contextRunner
			.withPropertyValues('spring.jpa.properties.hibernate.generate_statistics:true',
					'spring.sql.init.schema-locations:city-schema.sql', 'spring.sql.init.data-locations=city-data.sql')
			.withConfiguration(AutoConfigurations.of(SqlInitializationAutoConfiguration.class))
			.withBean(EntityManagerFactoryBuilderCustomizer.class,
					() -> (builder) -> builder.setBootstrapExecutor(new SimpleAsyncTaskExecutor()))
			.run((context) -> {
				JdbcTemplate jdbcTemplate = new JdbcTemplate(context.getBean(DataSource.class));
				assertThat(jdbcTemplate.queryForObject('SELECT COUNT(*) from CITY', Integer.class)).isOne();
				MeterRegistry registry = context.getBean(MeterRegistry.class);
				registry.get('hibernate.statements').tags('entityManagerFactory', 'entityManagerFactory').meter();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		SimpleMeterRegistry simpleMeterRegistry() {
			return new SimpleMeterRegistry();
		}
	}
	@Entity
	static class MyEntity {
		@Id
		@GeneratedValue
		private Long id;
	}
	@Configuration(proxyBeanMethods = false)
	static class TwoEntityManagerFactoriesConfiguration {
		private static final Class<?>[] PACKAGE_CLASSES = new Class<?>[] { MyEntity.class };
		@Primary
		@Bean
		LocalContainerEntityManagerFactoryBean firstEntityManagerFactory(DataSource ds) {
			return createSessionFactory(ds);
		}
		@Bean
		LocalContainerEntityManagerFactoryBean secondOne(DataSource ds) {
			return createSessionFactory(ds);
		}
		private LocalContainerEntityManagerFactoryBean createSessionFactory(DataSource ds) {
			Map<String, String> jpaProperties = new HashMap<>();
			jpaProperties.put('hibernate.generate_statistics', 'true');
			return new EntityManagerFactoryBuilder(new HibernateJpaVendorAdapter(), jpaProperties, null).dataSource(ds)
				.packages(PACKAGE_CLASSES)
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonHibernateEntityManagerFactoryConfiguration {
		@Bean
		EntityManagerFactory entityManagerFactory() {
			EntityManagerFactory mockedFactory = mock(EntityManagerFactory.class);
			// enforces JPA contract
			given(mockedFactory.unwrap(ArgumentMatchers.<Class<SessionFactory>>any()))
				.willThrow(PersistenceException.class);
			return mockedFactory;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class LogbackMetricsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(LogbackMetricsAutoConfiguration.class));
	@Test
	void autoConfiguresLogbackMetrics() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(LogbackMetrics.class));
	}
	@Test
	void allowsCustomLogbackMetricsToBeUsed() {
		this.contextRunner.withUserConfiguration(CustomLogbackMetricsConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(LogbackMetrics.class).hasBean('customLogbackMetrics'));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomLogbackMetricsConfiguration {
		@Bean
		LogbackMetrics customLogbackMetrics() {
			return new LogbackMetrics();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class MetricsAspectsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withPropertyValues('management.observations.annotations.enabled=true')
		.withConfiguration(AutoConfigurations.of(MetricsAspectsAutoConfiguration.class));
	@Test
	void shouldNotConfigureAspectsByDefault() {
		new ApplicationContextRunner().with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MetricsAspectsAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(CountedAspect.class);
				assertThat(context).doesNotHaveBean(TimedAspect.class);
			});
	}
	@Test
	void shouldConfigureAspectsWithLegacyProperty() {
		new ApplicationContextRunner().with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(MetricsAspectsAutoConfiguration.class))
			.withPropertyValues('micrometer.observations.annotations.enabled=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(CountedAspect.class);
				assertThat(context).hasSingleBean(TimedAspect.class);
			});
	}
	@Test
	void shouldConfigureAspects() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(CountedAspect.class);
			assertThat(context).hasSingleBean(TimedAspect.class);
		});
	}
	@Test
	void shouldConfigureMeterTagAnnotationHandler() {
		this.contextRunner.withUserConfiguration(MeterTagAnnotationHandlerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CountedAspect.class);
			assertThat(ReflectionTestUtils.getField(context.getBean(TimedAspect.class), 'meterTagAnnotationHandler'))
				.isSameAs(context.getBean(MeterTagAnnotationHandler.class));
		});
	}
	@Test
	void shouldNotConfigureAspectsIfMicrometerIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(MeterRegistry.class)).run((context) -> {
			assertThat(context).doesNotHaveBean(CountedAspect.class);
			assertThat(context).doesNotHaveBean(TimedAspect.class);
		});
	}
	@Test
	void shouldNotConfigureAspectsIfAspectjIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(Advice.class)).run((context) -> {
			assertThat(context).doesNotHaveBean(CountedAspect.class);
			assertThat(context).doesNotHaveBean(TimedAspect.class);
		});
	}
	@Test
	void shouldNotConfigureAspectsIfMeterRegistryBeanIsMissing() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(MetricsAspectsAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(MeterRegistry.class);
				assertThat(context).doesNotHaveBean(CountedAspect.class);
				assertThat(context).doesNotHaveBean(TimedAspect.class);
			});
	}
	@Test
	void shouldBackOffIfAspectBeansExist() {
		this.contextRunner.withUserConfiguration(CustomAspectsConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CountedAspect.class).hasBean('customCountedAspect');
			assertThat(context).hasSingleBean(TimedAspect.class).hasBean('customTimedAspect');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAspectsConfiguration {
		@Bean
		CountedAspect customCountedAspect(MeterRegistry registry) {
			return new CountedAspect(registry);
		}
		@Bean
		TimedAspect customTimedAspect(MeterRegistry registry) {
			return new TimedAspect(registry);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MeterTagAnnotationHandlerConfiguration {
		@Bean
		MeterTagAnnotationHandler meterTagAnnotationHandler() {
			return new MeterTagAnnotationHandler(null, null);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cassandra;
/**
class CassandraHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CassandraHealthContributorAutoConfiguration.class,
				HealthContributorAutoConfiguration.class));
	@Test
	void runWithoutCqlSessionOrCassandraOperationsShouldNotCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean('cassandraHealthContributor')
			.doesNotHaveBean(CassandraDriverHealthIndicator.class));
	}
	@Test
	void runWithCqlSessionOnlyShouldCreateDriverIndicator() {
		this.contextRunner.withBean(CqlSession.class, () -> mock(CqlSession.class))
			.run((context) -> assertThat(context).hasSingleBean(CassandraDriverHealthIndicator.class));
	}
	@Test
	void runWithCqlSessionAndSpringDataAbsentShouldCreateDriverIndicator() {
		this.contextRunner.withBean(CqlSession.class, () -> mock(CqlSession.class))
			.withClassLoader(new FilteredClassLoader('org.springframework.data'))
			.run((context) -> assertThat(context).hasSingleBean(CassandraDriverHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withBean(CqlSession.class, () -> mock(CqlSession.class))
			.withBean(CassandraOperations.class, () -> mock(CassandraOperations.class))
			.withPropertyValues('management.health.cassandra.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean('cassandraHealthContributor')
				.doesNotHaveBean(CassandraDriverHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cassandra;
/**
class CassandraReactiveHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CassandraReactiveHealthContributorAutoConfiguration.class,
				CassandraHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runWithoutCqlSessionOrReactiveCassandraOperationsShouldNotCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean('cassandraHealthContributor')
			.doesNotHaveBean(CassandraDriverReactiveHealthIndicator.class));
	}
	@Test
	void runWithCqlSessionOnlyShouldCreateDriverIndicator() {
		this.contextRunner.withBean(CqlSession.class, () -> mock(CqlSession.class))
			.run((context) -> assertThat(context).hasBean('cassandraHealthContributor')
				.hasSingleBean(CassandraDriverReactiveHealthIndicator.class));
	}
	@Test
	void runWithCqlSessionAndReactiveCassandraOperationsShouldCreateDriverIndicator() {
		this.contextRunner.withBean(CqlSession.class, () -> mock(CqlSession.class))
			.withBean(ReactiveCassandraOperations.class, () -> mock(ReactiveCassandraOperations.class))
			.withBean(CassandraOperations.class, () -> mock(CassandraOperations.class))
			.run((context) -> assertThat(context).hasBean('cassandraHealthContributor')
				.hasSingleBean(CassandraDriverReactiveHealthIndicator.class)
				.doesNotHaveBean(CassandraDriverHealthIndicator.class));
	}
	@Test
	void runWithCqlSessionAndSpringDataAbsentShouldCreateDriverIndicator() {
		this.contextRunner.withBean(CqlSession.class, () -> mock(CqlSession.class))
			.withClassLoader(new FilteredClassLoader('org.springframework.data'))
			.run((context) -> assertThat(context).hasBean('cassandraHealthContributor')
				.hasSingleBean(CassandraDriverReactiveHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withBean(CqlSession.class, () -> mock(CqlSession.class))
			.withBean(ReactiveCassandraOperations.class, () -> mock(ReactiveCassandraOperations.class))
			.withPropertyValues('management.health.cassandra.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean('cassandraHealthContributor'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.audit;
/**
class AuditEventsEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(AuditAutoConfiguration.class, AuditEventsEndpointAutoConfiguration.class));
	@Test
	void runWhenRepositoryBeanAvailableShouldHaveEndpointBean() {
		this.contextRunner.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=auditevents')
			.run((context) -> assertThat(context).hasSingleBean(AuditEventsEndpoint.class));
	}
	@Test
	void endpointBacksOffWhenRepositoryNotAvailable() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=auditevents')
			.run((context) -> assertThat(context).doesNotHaveBean(AuditEventsEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(AuditEventsEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpoint() {
		this.contextRunner.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class)
			.withPropertyValues('management.endpoint.auditevents.enabled:false')
			.withPropertyValues('management.endpoints.web.exposure.include=*')
			.run((context) -> assertThat(context).doesNotHaveBean(AuditEventsEndpoint.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAuditEventRepositoryConfiguration {
		@Bean
		InMemoryAuditEventRepository testAuditEventRepository() {
			return new InMemoryAuditEventRepository();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.audit;
/**
class AuditAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(AuditAutoConfiguration.class));
	@Test
	void autoConfigurationIsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(AuditAutoConfiguration.class));
	}
	@Test
	void autoConfigurationIsEnabledWhenAuditEventRepositoryBeanPresent() {
		this.contextRunner.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class).run((context) -> {
			assertThat(context.getBean(AuditEventRepository.class)).isNotNull();
			assertThat(context.getBean(AuthenticationAuditListener.class)).isNotNull();
			assertThat(context.getBean(AuthorizationAuditListener.class)).isNotNull();
		});
	}
	@Test
	void ownAuthenticationAuditListener() {
		this.contextRunner.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class)
			.withUserConfiguration(CustomAuthenticationAuditListenerConfiguration.class)
			.run((context) -> assertThat(context.getBean(AbstractAuthenticationAuditListener.class))
				.isInstanceOf(TestAuthenticationAuditListener.class));
	}
	@Test
	void ownAuthorizationAuditListener() {
		this.contextRunner.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class)
			.withUserConfiguration(CustomAuthorizationAuditListenerConfiguration.class)
			.run((context) -> assertThat(context.getBean(AbstractAuthorizationAuditListener.class))
				.isInstanceOf(TestAuthorizationAuditListener.class));
	}
	@Test
	void ownAuditListener() {
		this.contextRunner.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class)
			.withUserConfiguration(CustomAuditListenerConfiguration.class)
			.run((context) -> assertThat(context.getBean(AbstractAuditListener.class))
				.isInstanceOf(TestAuditListener.class));
	}
	@Test
	void backsOffWhenDisabled() {
		this.contextRunner.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class)
			.withPropertyValues('management.auditevents.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(AuditListener.class)
				.doesNotHaveBean(AuthenticationAuditListener.class)
				.doesNotHaveBean(AuthorizationAuditListener.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAuditEventRepositoryConfiguration {
		@Bean
		TestAuditEventRepository testAuditEventRepository() {
			return new TestAuditEventRepository();
		}
	}
	static class TestAuditEventRepository extends InMemoryAuditEventRepository {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAuthenticationAuditListenerConfiguration {
		@Bean
		TestAuthenticationAuditListener authenticationAuditListener() {
			return new TestAuthenticationAuditListener();
		}
	}
	static class TestAuthenticationAuditListener extends AbstractAuthenticationAuditListener {
		@Override
		public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
		}
		@Override
		public void onApplicationEvent(AbstractAuthenticationEvent event) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAuthorizationAuditListenerConfiguration {
		@Bean
		TestAuthorizationAuditListener authorizationAuditListener() {
			return new TestAuthorizationAuditListener();
		}
	}
	static class TestAuthorizationAuditListener extends AbstractAuthorizationAuditListener {
		@Override
		public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
		}
		@Override
		public void onApplicationEvent(AuthorizationEvent event) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAuditListenerConfiguration {
		@Bean
		TestAuditListener testAuditListener() {
			return new TestAuditListener();
		}
	}
	static class TestAuditListener extends AbstractAuditListener {
		@Override
		protected void onAuditEvent(AuditEvent event) {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class AvailabilityProbesHealthEndpointGroupsPostProcessorTests {
	private final AvailabilityProbesHealthEndpointGroupsPostProcessor postProcessor = new AvailabilityProbesHealthEndpointGroupsPostProcessor(
			new MockEnvironment());
	@Test
	void postProcessHealthEndpointGroupsWhenGroupsAlreadyContainedReturnsOriginal() {
		HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
		Set<String> names = new LinkedHashSet<>();
		names.add('test');
		names.add('readiness');
		names.add('liveness');
		given(groups.getNames()).willReturn(names);
		assertThat(this.postProcessor.postProcessHealthEndpointGroups(groups))
			.isInstanceOf(AvailabilityProbesHealthEndpointGroups.class);
	}
	@Test
	void postProcessHealthEndpointGroupsWhenGroupContainsOneReturnsPostProcessed() {
		HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
		Set<String> names = new LinkedHashSet<>();
		names.add('test');
		names.add('readiness');
		given(groups.getNames()).willReturn(names);
		assertThat(this.postProcessor.postProcessHealthEndpointGroups(groups))
			.isInstanceOf(AvailabilityProbesHealthEndpointGroups.class);
	}
	@Test
	void postProcessHealthEndpointGroupsWhenGroupsContainsNoneReturnsProcessed() {
		HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
		Set<String> names = new LinkedHashSet<>();
		names.add('test');
		names.add('spring');
		names.add('boot');
		given(groups.getNames()).willReturn(names);
		assertThat(this.postProcessor.postProcessHealthEndpointGroups(groups))
			.isInstanceOf(AvailabilityProbesHealthEndpointGroups.class);
	}
	@Test
	void postProcessHealthEndpointGroupsWhenAdditionalPathPropertyIsTrue() {
		HealthEndpointGroups postProcessed = getPostProcessed('true');
		HealthEndpointGroup liveness = postProcessed.get('liveness');
		HealthEndpointGroup readiness = postProcessed.get('readiness');
		assertThat(liveness.getAdditionalPath()).hasToString('server:/livez');
		assertThat(readiness.getAdditionalPath()).hasToString('server:/readyz');
	}
	@Test
	void postProcessHealthEndpointGroupsWhenGroupsAlreadyContainedAndAdditionalPathPropertyIsTrue() {
		HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
		Set<String> names = new LinkedHashSet<>();
		names.add('test');
		names.add('readiness');
		names.add('liveness');
		given(groups.getNames()).willReturn(names);
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('management.endpoint.health.probes.add-additional-paths', 'true');
		AvailabilityProbesHealthEndpointGroupsPostProcessor postProcessor = new AvailabilityProbesHealthEndpointGroupsPostProcessor(
				environment);
		HealthEndpointGroups postProcessed = postProcessor.postProcessHealthEndpointGroups(groups);
		HealthEndpointGroup liveness = postProcessed.get('liveness');
		HealthEndpointGroup readiness = postProcessed.get('readiness');
		assertThat(liveness.getAdditionalPath()).hasToString('server:/livez');
		assertThat(readiness.getAdditionalPath()).hasToString('server:/readyz');
	}
	private HealthEndpointGroups getPostProcessed(String value) {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('management.endpoint.health.probes.add-additional-paths', value);
		AvailabilityProbesHealthEndpointGroupsPostProcessor postProcessor = new AvailabilityProbesHealthEndpointGroupsPostProcessor(
				environment);
		HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
		return postProcessor.postProcessHealthEndpointGroups(groups);
	}
	@Test
	void postProcessHealthEndpointGroupsWhenAdditionalPathPropertyIsFalse() {
		HealthEndpointGroups postProcessed = getPostProcessed('false');
		HealthEndpointGroup liveness = postProcessed.get('liveness');
		HealthEndpointGroup readiness = postProcessed.get('readiness');
		assertThat(liveness.getAdditionalPath()).isNull();
		assertThat(readiness.getAdditionalPath()).isNull();
	}
	@Test
	void postProcessHealthEndpointGroupsWhenAdditionalPathPropertyIsNull() {
		HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
		HealthEndpointGroups postProcessed = this.postProcessor.postProcessHealthEndpointGroups(groups);
		HealthEndpointGroup liveness = postProcessed.get('liveness');
		HealthEndpointGroup readiness = postProcessed.get('readiness');
		assertThat(liveness.getAdditionalPath()).isNull();
		assertThat(readiness.getAdditionalPath()).isNull();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class DelegatingAvailabilityProbesHealthEndpointGroupTests {
	private DelegatingAvailabilityProbesHealthEndpointGroup group;
	private HttpCodeStatusMapper mapper;
	private StatusAggregator aggregator;
	@BeforeEach
	void setup() {
		HealthEndpointGroup delegate = mock(HealthEndpointGroup.class);
		this.mapper = mock(HttpCodeStatusMapper.class);
		this.aggregator = mock(StatusAggregator.class);
		given(delegate.getHttpCodeStatusMapper()).willReturn(this.mapper);
		given(delegate.getStatusAggregator()).willReturn(this.aggregator);
		given(delegate.showComponents(any())).willReturn(true);
		given(delegate.showDetails(any())).willReturn(false);
		given(delegate.isMember('test')).willReturn(true);
		this.group = new DelegatingAvailabilityProbesHealthEndpointGroup(delegate,
				AdditionalHealthEndpointPath.from('server:test'));
	}
	@Test
	void groupDelegatesToDelegate() {
		assertThat(this.group.getHttpCodeStatusMapper()).isEqualTo(this.mapper);
		assertThat(this.group.getStatusAggregator()).isEqualTo(this.aggregator);
		assertThat(this.group.isMember('test')).isTrue();
		assertThat(this.group.showDetails(null)).isFalse();
		assertThat(this.group.showComponents(null)).isTrue();
		assertThat(this.group.getAdditionalPath().getValue()).isEqualTo('test');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class AvailabilityProbesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ApplicationAvailabilityAutoConfiguration.class,
				AvailabilityHealthContributorAutoConfiguration.class, AvailabilityProbesAutoConfiguration.class));
	@Test
	void probesWhenNotKubernetesAddsNoBeans() {
		this.contextRunner.run(this::doesNotHaveProbeBeans);
	}
	@Test
	void probesWhenKubernetesAddsBeans() {
		this.contextRunner.withPropertyValues('spring.main.cloud-platform=kubernetes').run(this::hasProbesBeans);
	}
	@Test
	void probesWhenCloudFoundryAddsBeans() {
		this.contextRunner.withPropertyValues('spring.main.cloud-platform=cloud_foundry').run(this::hasProbesBeans);
	}
	@Test
	void probesWhenPropertyEnabledAddsBeans() {
		this.contextRunner.withPropertyValues('management.endpoint.health.probes.enabled=true')
			.run(this::hasProbesBeans);
	}
	@Test
	void probesWhenKubernetesAndPropertyDisabledAddsNotBeans() {
		this.contextRunner
			.withPropertyValues('spring.main.cloud-platform=kubernetes',
					'management.endpoint.health.probes.enabled=false')
			.run(this::doesNotHaveProbeBeans);
	}
	private void hasProbesBeans(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(ApplicationAvailability.class)
			.hasSingleBean(LivenessStateHealthIndicator.class)
			.hasBean('livenessStateHealthIndicator')
			.hasSingleBean(ReadinessStateHealthIndicator.class)
			.hasBean('readinessStateHealthIndicator')
			.hasSingleBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class);
	}
	private void doesNotHaveProbeBeans(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(ApplicationAvailability.class)
			.doesNotHaveBean(LivenessStateHealthIndicator.class)
			.doesNotHaveBean(ReadinessStateHealthIndicator.class)
			.doesNotHaveBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class AvailabilityProbesHealthEndpointGroupTests {
	private final AvailabilityProbesHealthEndpointGroup group = new AvailabilityProbesHealthEndpointGroup(null, 'a',
			'b');
	@Test
	void isMemberWhenMemberReturnsTrue() {
		assertThat(this.group.isMember('a')).isTrue();
		assertThat(this.group.isMember('b')).isTrue();
	}
	@Test
	void isMemberWhenNotMemberReturnsFalse() {
		assertThat(this.group.isMember('c')).isFalse();
	}
	@Test
	void showComponentsReturnsFalse() {
		assertThat(this.group.showComponents(mock(SecurityContext.class))).isFalse();
	}
	@Test
	void showDetailsReturnsFalse() {
		assertThat(this.group.showDetails(mock(SecurityContext.class))).isFalse();
	}
	@Test
	void getStatusAggregatorReturnsDefaultStatusAggregator() {
		assertThat(this.group.getStatusAggregator()).isEqualTo(StatusAggregator.getDefault());
	}
	@Test
	void getHttpCodeStatusMapperReturnsDefaultHttpCodeStatusMapper() {
		assertThat(this.group.getHttpCodeStatusMapper()).isEqualTo(HttpCodeStatusMapper.DEFAULT);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class AvailabilityProbesHealthEndpointGroupsTests {
	private HealthEndpointGroups delegate;
	private HealthEndpointGroup group;
	@BeforeEach
	void setup() {
		this.delegate = mock(HealthEndpointGroups.class);
		this.group = mock(HealthEndpointGroup.class);
	}
	@Test
	void createWhenGroupsIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new AvailabilityProbesHealthEndpointGroups(null, false))
			.withMessage('Groups must not be null');
	}
	@Test
	void getPrimaryDelegatesToGroups() {
		given(this.delegate.getPrimary()).willReturn(this.group);
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, false);
		assertThat(availabilityProbes.getPrimary()).isEqualTo(this.group);
	}
	@Test
	void getNamesIncludesAvailabilityProbeGroups() {
		given(this.delegate.getNames()).willReturn(Collections.singleton('test'));
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, false);
		assertThat(availabilityProbes.getNames()).containsExactly('test', 'liveness', 'readiness');
	}
	@Test
	void getWhenProbeInDelegateReturnsOriginalGroup() {
		HealthEndpointGroup group = mock(HealthEndpointGroup.class);
		HttpCodeStatusMapper mapper = mock(HttpCodeStatusMapper.class);
		given(group.getHttpCodeStatusMapper()).willReturn(mapper);
		given(this.delegate.get('liveness')).willReturn(group);
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, false);
		assertThat(availabilityProbes.get('liveness')).isEqualTo(group);
		assertThat(group.getHttpCodeStatusMapper()).isEqualTo(mapper);
	}
	@Test
	void getWhenProbeInDelegateAndExistingAdditionalPathReturnsOriginalGroup() {
		HealthEndpointGroup group = mock(HealthEndpointGroup.class);
		given(group.getAdditionalPath()).willReturn(AdditionalHealthEndpointPath.from('server:test'));
		given(this.delegate.get('liveness')).willReturn(group);
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, true);
		HealthEndpointGroup liveness = availabilityProbes.get('liveness');
		assertThat(liveness).isEqualTo(group);
		assertThat(liveness.getAdditionalPath().getValue()).isEqualTo('test');
	}
	@Test
	void getWhenProbeInDelegateAndAdditionalPathReturnsGroupWithAdditionalPath() {
		given(this.delegate.get('liveness')).willReturn(this.group);
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, true);
		assertThat(availabilityProbes.get('liveness').getAdditionalPath().getValue()).isEqualTo('/livez');
	}
	@Test
	void getWhenProbeNotInDelegateReturnsProbeGroup() {
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, false);
		assertThat(availabilityProbes.get('liveness')).isInstanceOf(AvailabilityProbesHealthEndpointGroup.class);
	}
	@Test
	void getWhenNotProbeAndNotInDelegateReturnsNull() {
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, false);
		assertThat(availabilityProbes.get('mygroup')).isNull();
	}
	@Test
	void getLivenessProbeHasOnlyLivenessStateAsMember() {
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, false);
		HealthEndpointGroup probeGroup = availabilityProbes.get('liveness');
		assertThat(probeGroup.isMember('livenessState')).isTrue();
		assertThat(probeGroup.isMember('readinessState')).isFalse();
	}
	@Test
	void getReadinessProbeHasOnlyReadinessStateAsMember() {
		HealthEndpointGroups availabilityProbes = new AvailabilityProbesHealthEndpointGroups(this.delegate, false);
		HealthEndpointGroup probeGroup = availabilityProbes.get('readiness');
		assertThat(probeGroup.isMember('livenessState')).isFalse();
		assertThat(probeGroup.isMember('readinessState')).isTrue();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class AvailabilityHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ApplicationAvailabilityAutoConfiguration.class,
				AvailabilityHealthContributorAutoConfiguration.class));
	@Test
	void probesWhenNotKubernetesAddsNoBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class)
			.doesNotHaveBean(LivenessStateHealthIndicator.class)
			.doesNotHaveBean(ReadinessStateHealthIndicator.class));
	}
	@Test
	void livenessIndicatorWhenPropertyEnabledAddsBeans() {
		this.contextRunner.withPropertyValues('management.health.livenessState.enabled=true')
			.run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class)
				.hasSingleBean(LivenessStateHealthIndicator.class)
				.doesNotHaveBean(ReadinessStateHealthIndicator.class));
	}
	@Test
	void readinessIndicatorWhenPropertyEnabledAddsBeans() {
		this.contextRunner.withPropertyValues('management.health.readinessState.enabled=true')
			.run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class)
				.hasSingleBean(ReadinessStateHealthIndicator.class)
				.doesNotHaveBean(LivenessStateHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.mail;
/**
class MailHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MailSenderAutoConfiguration.class,
				MailHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class))
		.withPropertyValues('spring.mail.host:smtp.example.com');
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MailHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.mail.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(MailHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
class SecurityRequestMatchersManagementContextConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SecurityRequestMatchersManagementContextConfiguration.class));
	@Test
	void configurationConditionalOnWebApplication() {
		new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(SecurityRequestMatchersManagementContextConfiguration.class))
			.withUserConfiguration(TestMvcConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(RequestMatcherProvider.class));
	}
	@Test
	void configurationConditionalOnRequestMatcherClass() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader('org.springframework.security.web.util.matcher.RequestMatcher'))
			.run((context) -> assertThat(context).doesNotHaveBean(RequestMatcherProvider.class));
	}
	@Test
	void registersRequestMatcherProviderIfMvcPresent() {
		this.contextRunner.withUserConfiguration(TestMvcConfiguration.class).run((context) -> {
			AntPathRequestMatcherProvider matcherProvider = context.getBean(AntPathRequestMatcherProvider.class);
			RequestMatcher requestMatcher = matcherProvider.getRequestMatcher('/example');
			assertThat(requestMatcher).extracting('pattern').isEqualTo('/custom/example');
		});
	}
	@Test
	void registersRequestMatcherForJerseyProviderIfJerseyPresentAndMvcAbsent() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.springframework.web.servlet.DispatcherServlet'))
			.withUserConfiguration(TestJerseyConfiguration.class)
			.run((context) -> {
				AntPathRequestMatcherProvider matcherProvider = context.getBean(AntPathRequestMatcherProvider.class);
				RequestMatcher requestMatcher = matcherProvider.getRequestMatcher('/example');
				assertThat(requestMatcher).extracting('pattern').isEqualTo('/admin/example');
			});
	}
	@Test
	void mvcRequestMatcherProviderConditionalOnDispatcherServletClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.springframework.web.servlet.DispatcherServlet'))
			.run((context) -> assertThat(context).doesNotHaveBean(AntPathRequestMatcherProvider.class));
	}
	@Test
	void mvcRequestMatcherProviderConditionalOnDispatcherServletPathBean() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(SecurityRequestMatchersManagementContextConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(AntPathRequestMatcherProvider.class));
	}
	@Test
	void jerseyRequestMatcherProviderConditionalOnResourceConfigClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.glassfish.jersey.server.ResourceConfig'))
			.run((context) -> assertThat(context).doesNotHaveBean(AntPathRequestMatcherProvider.class));
	}
	@Test
	void jerseyRequestMatcherProviderConditionalOnJerseyApplicationPathBean() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(SecurityRequestMatchersManagementContextConfiguration.class))
			.withClassLoader(new FilteredClassLoader('org.springframework.web.servlet.DispatcherServlet'))
			.run((context) -> assertThat(context).doesNotHaveBean(AntPathRequestMatcherProvider.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class TestMvcConfiguration {
		@Bean
		DispatcherServletPath dispatcherServletPath() {
			return () -> '/custom';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestJerseyConfiguration {
		@Bean
		JerseyApplicationPath jerseyApplicationPath() {
			return () -> '/admin';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
class ManagementWebSecurityAutoConfigurationTests {
	private static final String MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN = 'managementSecurityFilterChain';
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(contextSupplier(),
			WebServerApplicationContext.class)
		.withConfiguration(AutoConfigurations.of(HealthContributorAutoConfiguration.class,
				HealthEndpointAutoConfiguration.class, InfoEndpointAutoConfiguration.class,
				EnvironmentEndpointAutoConfiguration.class, EndpointAutoConfiguration.class,
				WebMvcAutoConfiguration.class, WebEndpointAutoConfiguration.class, SecurityAutoConfiguration.class,
				ManagementWebSecurityAutoConfiguration.class));
	private static Supplier<ConfigurableWebApplicationContext> contextSupplier() {
		return WebApplicationContextRunner.withMockServletContext(MockWebServerApplicationContext::new);
	}
	@Test
	void permitAllForHealth() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasBean(MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN);
			HttpStatus status = getResponseStatus(context, '/actuator/health');
			assertThat(status).isEqualTo(HttpStatus.OK);
		});
	}
	@Test
	void securesEverythingElse() {
		this.contextRunner.run((context) -> {
			HttpStatus status = getResponseStatus(context, '/actuator');
			assertThat(status).isEqualTo(HttpStatus.UNAUTHORIZED);
			status = getResponseStatus(context, '/foo');
			assertThat(status).isEqualTo(HttpStatus.UNAUTHORIZED);
		});
	}
	@Test
	void autoConfigIsConditionalOnSecurityFilterChainClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class)).run((context) -> {
			assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class);
			HttpStatus status = getResponseStatus(context, '/actuator/health');
			assertThat(status).isEqualTo(HttpStatus.UNAUTHORIZED);
		});
	}
	@Test
	void usesMatchersBasedOffConfiguredActuatorBasePath() {
		this.contextRunner.withPropertyValues('management.endpoints.web.base-path=/').run((context) -> {
			HttpStatus status = getResponseStatus(context, '/health');
			assertThat(status).isEqualTo(HttpStatus.OK);
		});
	}
	@Test
	void backOffIfCustomSecurityIsAdded() {
		this.contextRunner.withUserConfiguration(CustomSecurityConfiguration.class).run((context) -> {
			HttpStatus status = getResponseStatus(context, '/actuator/health');
			assertThat(status).isEqualTo(HttpStatus.UNAUTHORIZED);
			status = getResponseStatus(context, '/foo');
			assertThat(status).isEqualTo(HttpStatus.OK);
		});
	}
	@Test
	void backsOffIfSecurityFilterChainBeanIsPresent() {
		this.contextRunner.withUserConfiguration(TestSecurityFilterChainConfig.class).run((context) -> {
			assertThat(context.getBeansOfType(SecurityFilterChain.class)).hasSize(1);
			assertThat(context.containsBean('testSecurityFilterChain')).isTrue();
		});
	}
	@Test
	void backOffIfOAuth2ResourceServerAutoConfigurationPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(OAuth2ResourceServerAutoConfiguration.class))
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://authserver')
			.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class)
				.doesNotHaveBean(MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN));
	}
	@Test
	void backOffIfSaml2RelyingPartyAutoConfigurationPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class))
			.withPropertyValues(
					'spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.url=https://simplesaml-for-spring-saml/SSOService.php',
					'spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.sign-request=false',
					'spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php',
					'spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.verification.credentials[0].certificate-location=classpath:saml/certificate-location')
			.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class)
				.doesNotHaveBean(MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN));
	}
	@Test
	void backOffIfRemoteDevToolsSecurityFilterChainIsPresent() {
		this.contextRunner.withUserConfiguration(TestRemoteDevToolsSecurityFilterChainConfig.class).run((context) -> {
			SecurityFilterChain testSecurityFilterChain = context.getBean('testSecurityFilterChain',
					SecurityFilterChain.class);
			SecurityFilterChain testRemoteDevToolsSecurityFilterChain = context
				.getBean('testRemoteDevToolsSecurityFilterChain', SecurityFilterChain.class);
			List<SecurityFilterChain> orderedSecurityFilterChains = context.getBeanProvider(SecurityFilterChain.class)
				.orderedStream()
				.toList();
			assertThat(orderedSecurityFilterChains).containsExactly(testRemoteDevToolsSecurityFilterChain,
					testSecurityFilterChain);
			assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class);
		});
	}
	@Test
	void withAdditionalPathsOnSamePort() {
		this.contextRunner
			.withPropertyValues('management.endpoint.health.group.test1.include=*',
					'management.endpoint.health.group.test2.include=*',
					'management.endpoint.health.group.test1.additional-path=server:/check1',
					'management.endpoint.health.group.test2.additional-path=management:/check2')
			.run((context) -> {
				assertThat(getResponseStatus(context, '/check1')).isEqualTo(HttpStatus.OK);
				assertThat(getResponseStatus(context, '/check2')).isEqualTo(HttpStatus.UNAUTHORIZED);
				assertThat(getResponseStatus(context, '/actuator/health')).isEqualTo(HttpStatus.OK);
			});
	}
	@Test
	void withAdditionalPathsOnDifferentPort() {
		this.contextRunner.withPropertyValues('management.endpoint.health.group.test1.include=*',
				'management.endpoint.health.group.test2.include=*',
				'management.endpoint.health.group.test1.additional-path=server:/check1',
				'management.endpoint.health.group.test2.additional-path=management:/check2', 'management.server.port=0')
			.run((context) -> {
				assertThat(getResponseStatus(context, '/check1')).isEqualTo(HttpStatus.OK);
				assertThat(getResponseStatus(context, '/check2')).isEqualTo(HttpStatus.UNAUTHORIZED);
				assertThat(getResponseStatus(context, '/actuator/health')).isEqualTo(HttpStatus.UNAUTHORIZED);
			});
	}
	private HttpStatus getResponseStatus(AssertableWebApplicationContext context, String path)
			throws IOException, jakarta.servlet.ServletException {
		FilterChainProxy filterChainProxy = context.getBean(FilterChainProxy.class);
		MockServletContext servletContext = new MockServletContext();
		MockHttpServletResponse response = new MockHttpServletResponse();
		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
		MockHttpServletRequest request = new MockHttpServletRequest(servletContext);
		request.setServletPath(path);
		request.setMethod('GET');
		filterChainProxy.doFilter(request, response, new MockFilterChain());
		return HttpStatus.valueOf(response.getStatus());
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSecurityConfiguration {
		@Bean
		SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> {
				requests.requestMatchers(new AntPathRequestMatcher('/foo')).permitAll();
				requests.anyRequest().authenticated();
			});
			http.formLogin(withDefaults());
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestSecurityFilterChainConfig {
		@Bean
		SecurityFilterChain testSecurityFilterChain(HttpSecurity http) throws Exception {
			return http.securityMatcher('/**')
				.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated())
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestRemoteDevToolsSecurityFilterChainConfig extends TestSecurityFilterChainConfig {
		@Bean
		@Order(SecurityProperties.BASIC_AUTH_ORDER - 1)
		SecurityFilterChain testRemoteDevToolsSecurityFilterChain(HttpSecurity http) throws Exception {
			http.securityMatcher(new AntPathRequestMatcher('/**'));
			http.authorizeHttpRequests((requests) -> requests.anyRequest().anonymous());
			http.csrf((csrf) -> csrf.disable());
			return http.build();
		}
	}
	static class MockWebServerApplicationContext extends AnnotationConfigServletWebApplicationContext
			implements WebServerApplicationContext {
		@Override
		public WebServer getWebServer() {
			return null;
		}
		@Override
		public String getServerNamespace() {
			return 'server';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
abstract class AbstractEndpointRequestIntegrationTests {
	@Test
	void toEndpointShouldMatch() {
		getContextRunner().run((context) -> {
			WebTestClient webTestClient = getWebTestClient(context);
			webTestClient.get().uri('/actuator/e1').exchange().expectStatus().isOk();
		});
	}
	@Test
	void toAllEndpointsShouldMatch() {
		getContextRunner().withPropertyValues('spring.security.user.password=password').run((context) -> {
			WebTestClient webTestClient = getWebTestClient(context);
			webTestClient.get().uri('/actuator/e2').exchange().expectStatus().isUnauthorized();
			webTestClient.get()
				.uri('/actuator/e2')
				.header('Authorization', getBasicAuth())
				.exchange()
				.expectStatus()
				.isOk();
		});
	}
	@Test
	void toLinksShouldMatch() {
		getContextRunner().run((context) -> {
			WebTestClient webTestClient = getWebTestClient(context);
			webTestClient.get().uri('/actuator').exchange().expectStatus().isOk();
			webTestClient.get()
				.uri('/actuator/')
				.exchange()
				.expectStatus()
				.isEqualTo(expectedStatusWithTrailingSlash());
		});
	}
	protected HttpStatus expectedStatusWithTrailingSlash() {
		return HttpStatus.NOT_FOUND;
	}
	protected final WebApplicationContextRunner getContextRunner() {
		return createContextRunner().withPropertyValues('management.endpoints.web.exposure.include=*')
			.withUserConfiguration(BaseConfiguration.class, SecurityConfiguration.class)
			.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, SecurityAutoConfiguration.class,
					EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
					ManagementContextAutoConfiguration.class));
	}
	protected abstract WebApplicationContextRunner createContextRunner();
	protected WebTestClient getWebTestClient(AssertableWebApplicationContext context) {
		int port = context.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class)
			.getWebServer()
			.getPort();
		return WebTestClient.bindToServer()
			.baseUrl('http://localhost:' + port)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		TestEndpoint1 endpoint1() {
			return new TestEndpoint1();
		}
		@Bean
		TestEndpoint2 endpoint2() {
			return new TestEndpoint2();
		}
		@Bean
		TestEndpoint3 endpoint3() {
			return new TestEndpoint3();
		}
		@Bean
		TestServletEndpoint servletEndpoint() {
			return new TestServletEndpoint();
		}
	}
	@Endpoint(id = 'e1')
	static class TestEndpoint1 {
		@ReadOperation
		Object getAll() {
			return 'endpoint 1';
		}
	}
	@Endpoint(id = 'e2')
	static class TestEndpoint2 {
		@ReadOperation
		Object getAll() {
			return 'endpoint 2';
		}
	}
	@Endpoint(id = 'e3')
	static class TestEndpoint3 {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint(id = 'se1')
	@SuppressWarnings({ 'deprecation', 'removal' })
	static class TestServletEndpoint
			implements Supplier<org.springframework.boot.actuate.endpoint.web.EndpointServlet> {
		@Override
		public org.springframework.boot.actuate.endpoint.web.EndpointServlet get() {
			return new org.springframework.boot.actuate.endpoint.web.EndpointServlet(ExampleServlet.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		InMemoryUserDetailsManager userDetailsManager() {
			return new InMemoryUserDetailsManager(
					User.withUsername('user').password('{noop}password').roles('admin').build());
		}
		@Bean
		SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> {
				requests.requestMatchers(EndpointRequest.toLinks()).permitAll();
				requests.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll();
				requests.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated();
				requests.anyRequest().hasRole('ADMIN');
			});
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
	static class ExampleServlet extends HttpServlet {
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
class EndpointRequestTests {
	@Test
	void toAnyEndpointShouldMatchEndpointPath() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher, '/actuator').matches('/actuator/foo');
		assertMatcher(matcher, '/actuator').matches('/actuator/foo/zoo/');
		assertMatcher(matcher, '/actuator').matches('/actuator/bar');
		assertMatcher(matcher, '/actuator').matches('/actuator/bar/baz');
		assertMatcher(matcher, '/actuator').matches('/actuator');
	}
	@Test
	void toAnyEndpointShouldMatchEndpointPathWithTrailingSlash() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher, '/actuator').matches('/actuator/foo/');
		assertMatcher(matcher, '/actuator').matches('/actuator/bar/');
		assertMatcher(matcher, '/actuator').matches('/actuator/');
	}
	@Test
	void toAnyEndpointWhenBasePathIsEmptyShouldNotMatchLinks() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, '');
		assertMatcher.doesNotMatch('/');
		assertMatcher.matches('/foo');
		assertMatcher.matches('/bar');
	}
	@Test
	void toAnyEndpointShouldNotMatchOtherPath() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher).doesNotMatch('/actuator/baz');
	}
	@Test
	void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher, '/actuator').matches('/actuator/foo');
		assertMatcher(matcher, '/actuator').matches('/actuator/bar');
		assertMatcher(matcher, '/actuator').matches('/actuator');
		assertMatcher(matcher, '/actuator').doesNotMatch('/actuator/baz');
	}
	@Test
	void toEndpointClassShouldMatchEndpointPath() {
		RequestMatcher matcher = EndpointRequest.to(FooEndpoint.class);
		assertMatcher(matcher).matches('/actuator/foo');
	}
	@Test
	void toEndpointClassShouldNotMatchOtherPath() {
		RequestMatcher matcher = EndpointRequest.to(FooEndpoint.class);
		assertMatcher(matcher).doesNotMatch('/actuator/bar');
		assertMatcher(matcher).doesNotMatch('/actuator');
	}
	@Test
	void toEndpointIdShouldMatchEndpointPath() {
		RequestMatcher matcher = EndpointRequest.to('foo');
		assertMatcher(matcher).matches('/actuator/foo');
	}
	@Test
	void toEndpointIdShouldNotMatchOtherPath() {
		RequestMatcher matcher = EndpointRequest.to('foo');
		assertMatcher(matcher).doesNotMatch('/actuator/bar');
		assertMatcher(matcher).doesNotMatch('/actuator');
	}
	@Test
	void toLinksShouldOnlyMatchLinks() {
		RequestMatcher matcher = EndpointRequest.toLinks();
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).doesNotMatch('/actuator/bar');
		assertMatcher(matcher).matches('/actuator');
		assertMatcher(matcher).matches('/actuator/');
	}
	@Test
	void toLinksWhenBasePathEmptyShouldNotMatch() {
		RequestMatcher matcher = EndpointRequest.toLinks();
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, '');
		assertMatcher.doesNotMatch('/actuator/foo');
		assertMatcher.doesNotMatch('/actuator/bar');
		assertMatcher.doesNotMatch('/');
	}
	@Test
	void excludeByClassShouldNotMatchExcluded() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excluding(FooEndpoint.class, BazServletEndpoint.class);
		List<ExposableEndpoint<?>> endpoints = new ArrayList<>();
		endpoints.add(mockEndpoint(EndpointId.of('foo'), 'foo'));
		endpoints.add(mockEndpoint(EndpointId.of('bar'), 'bar'));
		endpoints.add(mockEndpoint(EndpointId.of('baz'), 'baz'));
		PathMappedEndpoints pathMappedEndpoints = new PathMappedEndpoints('/actuator', () -> endpoints);
		assertMatcher(matcher, pathMappedEndpoints).doesNotMatch('/actuator/foo');
		assertMatcher(matcher, pathMappedEndpoints).doesNotMatch('/actuator/baz');
		assertMatcher(matcher).matches('/actuator/bar');
		assertMatcher(matcher).matches('/actuator');
	}
	@Test
	void excludeByClassShouldNotMatchLinksIfExcluded() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excludingLinks().excluding(FooEndpoint.class);
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).doesNotMatch('/actuator');
	}
	@Test
	void excludeByIdShouldNotMatchExcluded() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excluding('foo');
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).matches('/actuator/bar');
		assertMatcher(matcher).matches('/actuator');
	}
	@Test
	void excludeByIdShouldNotMatchLinksIfExcluded() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excludingLinks().excluding('foo');
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).doesNotMatch('/actuator');
	}
	@Test
	void excludeLinksShouldNotMatchBasePath() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excludingLinks();
		assertMatcher(matcher).doesNotMatch('/actuator');
		assertMatcher(matcher).matches('/actuator/foo');
		assertMatcher(matcher).matches('/actuator/bar');
	}
	@Test
	void excludeLinksShouldNotMatchBasePathIfEmptyAndExcluded() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excludingLinks();
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, '');
		assertMatcher.doesNotMatch('/');
		assertMatcher.matches('/foo');
		assertMatcher.matches('/bar');
	}
	@Test
	void endpointRequestMatcherShouldUseCustomRequestMatcherProvider() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		RequestMatcher mockRequestMatcher = (request) -> false;
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, mockPathMappedEndpoints(''),
				(pattern) -> mockRequestMatcher, null);
		assertMatcher.doesNotMatch('/foo');
		assertMatcher.doesNotMatch('/bar');
	}
	@Test
	void linksRequestMatcherShouldUseCustomRequestMatcherProvider() {
		RequestMatcher matcher = EndpointRequest.toLinks();
		RequestMatcher mockRequestMatcher = (request) -> false;
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, mockPathMappedEndpoints('/actuator'),
				(pattern) -> mockRequestMatcher, null);
		assertMatcher.doesNotMatch('/actuator');
	}
	@Test
	void noEndpointPathsBeansShouldNeverMatch() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch('/actuator/foo');
		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch('/actuator/bar');
	}
	@Test
	void toStringWhenIncludedEndpoints() {
		RequestMatcher matcher = EndpointRequest.to('foo', 'bar');
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[foo, bar], excludes=[], includeLinks=false');
	}
	@Test
	void toStringWhenEmptyIncludedEndpoints() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[*], excludes=[], includeLinks=true');
	}
	@Test
	void toStringWhenIncludedEndpointsClasses() {
		RequestMatcher matcher = EndpointRequest.to(FooEndpoint.class).excluding('bar');
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[foo], excludes=[bar], includeLinks=false');
	}
	@Test
	void toStringWhenIncludedExcludedEndpoints() {
		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excluding('bar').excludingLinks();
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[*], excludes=[bar], includeLinks=false');
	}
	@Test
	void toStringWhenToAdditionalPaths() {
		RequestMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, 'test');
		assertThat(matcher)
			.hasToString('AdditionalPathsEndpointRequestMatcher endpoints=[test], webServerNamespace=server');
	}
	@Test
	void toAnyEndpointWhenEndpointPathMappedToRootIsExcludedShouldNotMatchRoot() {
		EndpointRequestMatcher matcher = EndpointRequest.toAnyEndpoint().excluding('root');
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('', () -> List
			.of(mockEndpoint(EndpointId.of('root'), '/'), mockEndpoint(EndpointId.of('alpha'), 'alpha'))));
		assertMatcher.doesNotMatch('/');
		assertMatcher.matches('/alpha');
		assertMatcher.matches('/alpha/sub');
	}
	@Test
	void toEndpointWhenEndpointPathMappedToRootShouldMatchRoot() {
		EndpointRequestMatcher matcher = EndpointRequest.to('root');
		RequestMatcherAssert assertMatcher = assertMatcher(matcher,
				new PathMappedEndpoints('', () -> List.of(mockEndpoint(EndpointId.of('root'), '/'))));
		assertMatcher.matches('/');
	}
	@Test
	void toAdditionalPathsWithEndpointClassShouldMatchAdditionalPath() {
		AdditionalPathsEndpointRequestMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER,
				FooEndpoint.class);
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))));
		assertMatcher.matches('/additional');
	}
	@Test
	void toAdditionalPathsWithEndpointIdShouldMatchAdditionalPath() {
		AdditionalPathsEndpointRequestMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER,
				'foo');
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))));
		assertMatcher.matches('/additional');
	}
	@Test
	void toAdditionalPathsWithEndpointClassShouldNotMatchOtherPaths() {
		AdditionalPathsEndpointRequestMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER,
				FooEndpoint.class);
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))));
		assertMatcher.doesNotMatch('/foo');
		assertMatcher.doesNotMatch('/bar');
	}
	@Test
	void toAdditionalPathsWithEndpointClassShouldNotMatchOtherNamespace() {
		AdditionalPathsEndpointRequestMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER,
				FooEndpoint.class);
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))),
				null, WebServerNamespace.MANAGEMENT);
		assertMatcher.doesNotMatch('/additional');
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher) {
		return assertMatcher(matcher, mockPathMappedEndpoints('/actuator'));
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String basePath) {
		return assertMatcher(matcher, mockPathMappedEndpoints(basePath), null, null);
	}
	private PathMappedEndpoints mockPathMappedEndpoints(String basePath) {
		List<ExposableEndpoint<?>> endpoints = new ArrayList<>();
		endpoints.add(mockEndpoint(EndpointId.of('foo'), 'foo'));
		endpoints.add(mockEndpoint(EndpointId.of('bar'), 'bar'));
		return new PathMappedEndpoints(basePath, () -> endpoints);
	}
	private TestEndpoint mockEndpoint(EndpointId id, String rootPath) {
		return mockEndpoint(id, rootPath, WebServerNamespace.SERVER);
	}
	private TestEndpoint mockEndpoint(EndpointId id, String rootPath, WebServerNamespace webServerNamespace,
			String... additionalPaths) {
		TestEndpoint endpoint = mock(TestEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(id);
		given(endpoint.getRootPath()).willReturn(rootPath);
		given(endpoint.getAdditionalPaths(webServerNamespace)).willReturn(Arrays.asList(additionalPaths));
		return endpoint;
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints) {
		return assertMatcher(matcher, pathMappedEndpoints, null, null);
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints,
			RequestMatcherProvider matcherProvider, WebServerNamespace webServerNamespace) {
		StaticWebApplicationContext context = (webServerNamespace != null)
				? new NamedStaticWebApplicationContext(webServerNamespace) : new StaticWebApplicationContext();
		context.registerBean(WebEndpointProperties.class);
		if (pathMappedEndpoints != null) {
			context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints);
			WebEndpointProperties properties = context.getBean(WebEndpointProperties.class);
			if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) {
				properties.setBasePath(pathMappedEndpoints.getBasePath());
			}
		}
		if (matcherProvider != null) {
			context.registerBean(RequestMatcherProvider.class, () -> matcherProvider);
		}
		return assertThat(new RequestMatcherAssert(context, matcher));
	}
	static class NamedStaticWebApplicationContext extends StaticWebApplicationContext
			implements WebServerApplicationContext {
		private final WebServerNamespace webServerNamespace;
		NamedStaticWebApplicationContext(WebServerNamespace webServerNamespace) {
			this.webServerNamespace = webServerNamespace;
		}
		@Override
		public WebServer getWebServer() {
			return null;
		}
		@Override
		public String getServerNamespace() {
			return this.webServerNamespace.getValue();
		}
	}
	static class RequestMatcherAssert implements AssertDelegateTarget {
		private final WebApplicationContext context;
		private final RequestMatcher matcher;
		RequestMatcherAssert(WebApplicationContext context, RequestMatcher matcher) {
			this.context = context;
			this.matcher = matcher;
		}
		void matches(String servletPath) {
			matches(mockRequest(servletPath));
		}
		private void matches(HttpServletRequest request) {
			assertThat(this.matcher.matches(request)).as('Matches ' + getRequestPath(request)).isTrue();
		}
		void doesNotMatch(String servletPath) {
			doesNotMatch(mockRequest(servletPath));
		}
		private void doesNotMatch(HttpServletRequest request) {
			assertThat(this.matcher.matches(request)).as('Does not match ' + getRequestPath(request)).isFalse();
		}
		private MockHttpServletRequest mockRequest(String servletPath) {
			MockServletContext servletContext = new MockServletContext();
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
			MockHttpServletRequest request = new MockHttpServletRequest(servletContext);
			if (servletPath != null) {
				request.setServletPath(servletPath);
			}
			return request;
		}
		private String getRequestPath(HttpServletRequest request) {
			String url = request.getServletPath();
			if (request.getPathInfo() != null) {
				url += request.getPathInfo();
			}
			return url;
		}
	}
	@Endpoint(id = 'foo')
	static class FooEndpoint {
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint(id = 'baz')
	@SuppressWarnings('removal')
	static class BazServletEndpoint {
	}
	interface TestEndpoint extends ExposableEndpoint<Operation>, PathMappedEndpoint {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
class JerseyEndpointRequestIntegrationTests extends AbstractEndpointRequestIntegrationTests {
	@Test
	void toLinksWhenApplicationPathSetShouldMatch() {
		getContextRunner().withPropertyValues('spring.jersey.application-path=/admin').run((context) -> {
			WebTestClient webTestClient = getWebTestClient(context);
			webTestClient.get()
				.uri('/admin/actuator/')
				.exchange()
				.expectStatus()
				.isEqualTo(expectedStatusWithTrailingSlash());
			webTestClient.get().uri('/admin/actuator').exchange().expectStatus().isOk();
		});
	}
	@Test
	void toEndpointWhenApplicationPathSetShouldMatch() {
		getContextRunner().withPropertyValues('spring.jersey.application-path=/admin').run((context) -> {
			WebTestClient webTestClient = getWebTestClient(context);
			webTestClient.get().uri('/admin/actuator/e1').exchange().expectStatus().isOk();
		});
	}
	@Test
	void toAnyEndpointWhenApplicationPathSetShouldMatch() {
		getContextRunner()
			.withPropertyValues('spring.jersey.application-path=/admin', 'spring.security.user.password=password')
			.run((context) -> {
				WebTestClient webTestClient = getWebTestClient(context);
				webTestClient.get().uri('/admin/actuator/e2').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/admin/actuator/e2')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
			});
	}
	@Test
	void toAnyEndpointShouldMatchServletEndpoint() {
		getContextRunner()
			.withPropertyValues('spring.security.user.password=password',
					'management.endpoints.web.exposure.include=se1')
			.run((context) -> {
				WebTestClient webTestClient = getWebTestClient(context);
				webTestClient.get().uri('/actuator/se1').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/actuator/se1')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
				webTestClient.get().uri('/actuator/se1/list').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/actuator/se1/list')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
			});
	}
	@Test
	void toAnyEndpointWhenApplicationPathSetShouldMatchServletEndpoint() {
		getContextRunner()
			.withPropertyValues('spring.jersey.application-path=/admin', 'spring.security.user.password=password',
					'management.endpoints.web.exposure.include=se1')
			.run((context) -> {
				WebTestClient webTestClient = getWebTestClient(context);
				webTestClient.get().uri('/admin/actuator/se1').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/admin/actuator/se1')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
				webTestClient.get().uri('/admin/actuator/se1/list').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/admin/actuator/se1/list')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
			});
	}
	@Override
	protected HttpStatus expectedStatusWithTrailingSlash() {
		return HttpStatus.OK;
	}
	@Override
	protected WebApplicationContextRunner createContextRunner() {
		return new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader('org.springframework.web.servlet.DispatcherServlet'))
			.withUserConfiguration(JerseyEndpointConfiguration.class)
			.withConfiguration(AutoConfigurations.of(JerseyAutoConfiguration.class));
	}
	@Configuration
	@EnableConfigurationProperties(WebEndpointProperties.class)
	static class JerseyEndpointConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		ResourceConfig resourceConfig() {
			return new ResourceConfig();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
class MvcEndpointRequestIntegrationTests extends AbstractEndpointRequestIntegrationTests {
	@Test
	void toLinksWhenServletPathSetShouldMatch() {
		getContextRunner().withPropertyValues('spring.mvc.servlet.path=/admin').run((context) -> {
			WebTestClient webTestClient = getWebTestClient(context);
			webTestClient.get().uri('/admin/actuator/').exchange().expectStatus().isNotFound();
			webTestClient.get().uri('/admin/actuator').exchange().expectStatus().isOk();
		});
	}
	@Test
	void toEndpointWhenServletPathSetShouldMatch() {
		getContextRunner().withPropertyValues('spring.mvc.servlet.path=/admin').run((context) -> {
			WebTestClient webTestClient = getWebTestClient(context);
			webTestClient.get().uri('/admin/actuator/e1').exchange().expectStatus().isOk();
		});
	}
	@Test
	void toAnyEndpointWhenServletPathSetShouldMatch() {
		getContextRunner()
			.withPropertyValues('spring.mvc.servlet.path=/admin', 'spring.security.user.password=password')
			.run((context) -> {
				WebTestClient webTestClient = getWebTestClient(context);
				webTestClient.get().uri('/admin/actuator/e2').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/admin/actuator/e2')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
			});
	}
	@Test
	void toAnyEndpointShouldMatchServletEndpoint() {
		getContextRunner()
			.withPropertyValues('spring.security.user.password=password',
					'management.endpoints.web.exposure.include=se1')
			.run((context) -> {
				WebTestClient webTestClient = getWebTestClient(context);
				webTestClient.get().uri('/actuator/se1').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/actuator/se1')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
				webTestClient.get().uri('/actuator/se1/list').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/actuator/se1/list')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
			});
	}
	@Test
	void toAnyEndpointWhenServletPathSetShouldMatchServletEndpoint() {
		getContextRunner()
			.withPropertyValues('spring.mvc.servlet.path=/admin', 'spring.security.user.password=password',
					'management.endpoints.web.exposure.include=se1')
			.run((context) -> {
				WebTestClient webTestClient = getWebTestClient(context);
				webTestClient.get().uri('/admin/actuator/se1').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/admin/actuator/se1')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
				webTestClient.get().uri('/admin/actuator/se1/list').exchange().expectStatus().isUnauthorized();
				webTestClient.get()
					.uri('/admin/actuator/se1/list')
					.header('Authorization', getBasicAuth())
					.exchange()
					.expectStatus()
					.isOk();
			});
	}
	@Override
	protected WebApplicationContextRunner createContextRunner() {
		return new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withUserConfiguration(WebMvcEndpointConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DispatcherServletAutoConfiguration.class,
					HttpMessageConvertersAutoConfiguration.class, WebMvcAutoConfiguration.class));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WebEndpointProperties.class)
	static class WebMvcEndpointConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.reactive;
/**
class EndpointRequestTests {
	@Test
	void toAnyEndpointShouldMatchEndpointPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher).matches('/actuator/foo');
		assertMatcher(matcher).matches('/actuator/bar');
		assertMatcher(matcher).matches('/actuator');
	}
	@Test
	void toAnyEndpointShouldMatchEndpointPathWithTrailingSlash() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher).matches('/actuator/foo/');
		assertMatcher(matcher).matches('/actuator/bar/');
		assertMatcher(matcher).matches('/actuator/');
	}
	@Test
	void toAnyEndpointWhenBasePathIsEmptyShouldNotMatchLinks() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint();
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, '');
		assertMatcher.doesNotMatch('/');
		assertMatcher.matches('/foo');
		assertMatcher.matches('/bar');
	}
	@Test
	void toAnyEndpointShouldNotMatchOtherPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher).doesNotMatch('/actuator/baz');
	}
	@Test
	void toEndpointClassShouldMatchEndpointPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.to(FooEndpoint.class);
		assertMatcher(matcher).matches('/actuator/foo');
		assertMatcher(matcher).matches('/actuator/foo/');
	}
	@Test
	void toEndpointClassShouldNotMatchOtherPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.to(FooEndpoint.class);
		assertMatcher(matcher).doesNotMatch('/actuator/bar');
		assertMatcher(matcher).doesNotMatch('/actuator/bar/');
	}
	@Test
	void toEndpointIdShouldMatchEndpointPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.to('foo');
		assertMatcher(matcher).matches('/actuator/foo');
		assertMatcher(matcher).matches('/actuator/foo/');
	}
	@Test
	void toEndpointIdShouldNotMatchOtherPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.to('foo');
		assertMatcher(matcher).doesNotMatch('/actuator/bar');
		assertMatcher(matcher).doesNotMatch('/actuator/bar/');
	}
	@Test
	void toLinksShouldOnlyMatchLinks() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toLinks();
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).doesNotMatch('/actuator/bar');
		assertMatcher(matcher).matches('/actuator');
		assertMatcher(matcher).matches('/actuator/');
	}
	@Test
	void toLinksWhenBasePathEmptyShouldNotMatch() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toLinks();
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, '');
		assertMatcher.doesNotMatch('/actuator/foo');
		assertMatcher.doesNotMatch('/actuator/bar');
		assertMatcher.doesNotMatch('/');
	}
	@Test
	void excludeByClassShouldNotMatchExcluded() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint()
			.excluding(FooEndpoint.class, BazServletEndpoint.class);
		List<ExposableEndpoint<?>> endpoints = new ArrayList<>();
		endpoints.add(mockEndpoint(EndpointId.of('foo'), 'foo'));
		endpoints.add(mockEndpoint(EndpointId.of('bar'), 'bar'));
		endpoints.add(mockEndpoint(EndpointId.of('baz'), 'baz'));
		PathMappedEndpoints pathMappedEndpoints = new PathMappedEndpoints('/actuator', () -> endpoints);
		assertMatcher(matcher, pathMappedEndpoints).doesNotMatch('/actuator/foo');
		assertMatcher(matcher, pathMappedEndpoints).doesNotMatch('/actuator/foo/');
		assertMatcher(matcher, pathMappedEndpoints).doesNotMatch('/actuator/baz');
		assertMatcher(matcher, pathMappedEndpoints).doesNotMatch('/actuator/baz/');
		assertMatcher(matcher).matches('/actuator/bar');
		assertMatcher(matcher).matches('/actuator/bar/');
		assertMatcher(matcher).matches('/actuator');
		assertMatcher(matcher).matches('/actuator/');
	}
	@Test
	void excludeByClassShouldNotMatchLinksIfExcluded() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint()
			.excludingLinks()
			.excluding(FooEndpoint.class);
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).doesNotMatch('/actuator/foo/');
		assertMatcher(matcher).doesNotMatch('/actuator');
		assertMatcher(matcher).doesNotMatch('/actuator/');
	}
	@Test
	void excludeByIdShouldNotMatchExcluded() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excluding('foo');
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).doesNotMatch('/actuator/foo/');
		assertMatcher(matcher).matches('/actuator/bar');
		assertMatcher(matcher).matches('/actuator/bar/');
		assertMatcher(matcher).matches('/actuator');
		assertMatcher(matcher).matches('/actuator/');
	}
	@Test
	void excludeByIdShouldNotMatchLinksIfExcluded() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excludingLinks().excluding('foo');
		assertMatcher(matcher).doesNotMatch('/actuator/foo');
		assertMatcher(matcher).doesNotMatch('/actuator/foo/');
		assertMatcher(matcher).doesNotMatch('/actuator');
		assertMatcher(matcher).doesNotMatch('/actuator/');
	}
	@Test
	void excludeLinksShouldNotMatchBasePath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excludingLinks();
		assertMatcher(matcher).doesNotMatch('/actuator');
		assertMatcher(matcher).doesNotMatch('/actuator/');
		assertMatcher(matcher).matches('/actuator/foo');
		assertMatcher(matcher).matches('/actuator/foo/');
		assertMatcher(matcher).matches('/actuator/bar');
		assertMatcher(matcher).matches('/actuator/bar/');
	}
	@Test
	void excludeLinksShouldNotMatchBasePathIfEmptyAndExcluded() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excludingLinks();
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, '');
		assertMatcher.doesNotMatch('/');
		assertMatcher.matches('/foo');
		assertMatcher.matches('/foo/');
		assertMatcher.matches('/bar');
		assertMatcher.matches('/bar/');
	}
	@Test
	void noEndpointPathsBeansShouldNeverMatch() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch('/actuator/foo');
		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch('/actuator/foo/');
		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch('/actuator/bar');
		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch('/actuator/bar/');
	}
	@Test
	void toStringWhenIncludedEndpoints() {
		ServerWebExchangeMatcher matcher = EndpointRequest.to('foo', 'bar');
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[foo, bar], excludes=[], includeLinks=false');
	}
	@Test
	void toStringWhenEmptyIncludedEndpoints() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint();
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[*], excludes=[], includeLinks=true');
	}
	@Test
	void toStringWhenIncludedEndpointsClasses() {
		ServerWebExchangeMatcher matcher = EndpointRequest.to(FooEndpoint.class).excluding('bar');
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[foo], excludes=[bar], includeLinks=false');
	}
	@Test
	void toStringWhenIncludedExcludedEndpoints() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excluding('bar').excludingLinks();
		assertThat(matcher).hasToString('EndpointRequestMatcher includes=[*], excludes=[bar], includeLinks=false');
	}
	@Test
	void toStringWhenToAdditionalPaths() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, 'test');
		assertThat(matcher)
			.hasToString('AdditionalPathsEndpointServerWebExchangeMatcher endpoints=[test], webServerNamespace=server');
	}
	@Test
	void toAnyEndpointWhenEndpointPathMappedToRootIsExcludedShouldNotMatchRoot() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excluding('root');
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('/', () -> List
			.of(mockEndpoint(EndpointId.of('root'), '/'), mockEndpoint(EndpointId.of('alpha'), 'alpha'))));
		assertMatcher.doesNotMatch('/');
		assertMatcher.matches('/alpha');
		assertMatcher.matches('/alpha/sub');
	}
	@Test
	void toEndpointWhenEndpointPathMappedToRootShouldMatchRoot() {
		ServerWebExchangeMatcher matcher = EndpointRequest.to('root');
		RequestMatcherAssert assertMatcher = assertMatcher(matcher,
				new PathMappedEndpoints('/', () -> List.of(mockEndpoint(EndpointId.of('root'), '/'))));
		assertMatcher.matches('/');
	}
	@Test
	void toAdditionalPathsWithEndpointClassShouldMatchAdditionalPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER,
				FooEndpoint.class);
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))));
		assertMatcher.matches('/additional');
	}
	@Test
	void toAdditionalPathsWithEndpointIdShouldMatchAdditionalPath() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, 'foo');
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))));
		assertMatcher.matches('/additional');
	}
	@Test
	void toAdditionalPathsWithEndpointClassShouldNotMatchOtherPaths() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER,
				FooEndpoint.class);
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))));
		assertMatcher.doesNotMatch('/foo');
		assertMatcher.doesNotMatch('/bar');
	}
	@Test
	void toAdditionalPathsWithEndpointClassShouldNotMatchOtherNamespace() {
		ServerWebExchangeMatcher matcher = EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER,
				FooEndpoint.class);
		RequestMatcherAssert assertMatcher = assertMatcher(matcher, new PathMappedEndpoints('',
				() -> List.of(mockEndpoint(EndpointId.of('foo'), 'test', WebServerNamespace.SERVER, '/additional'))),
				WebServerNamespace.MANAGEMENT);
		assertMatcher.doesNotMatch('/additional');
	}
	private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher) {
		return assertMatcher(matcher, mockPathMappedEndpoints('/actuator'));
	}
	private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher, String basePath) {
		return assertMatcher(matcher, mockPathMappedEndpoints(basePath));
	}
	private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher,
			PathMappedEndpoints pathMappedEndpoints) {
		return assertMatcher(matcher, pathMappedEndpoints, null);
	}
	private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher,
			PathMappedEndpoints pathMappedEndpoints, WebServerNamespace namespace) {
		StaticApplicationContext context = new StaticApplicationContext();
		if (namespace != null && !WebServerNamespace.SERVER.equals(namespace)) {
			StaticApplicationContext parentContext = new StaticApplicationContext();
			parentContext.setId('app');
			context.setParent(parentContext);
			context.setId(parentContext.getId() + ':' + namespace);
		}
		context.registerBean(WebEndpointProperties.class);
		if (pathMappedEndpoints != null) {
			context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints);
			WebEndpointProperties properties = context.getBean(WebEndpointProperties.class);
			if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) {
				properties.setBasePath(pathMappedEndpoints.getBasePath());
			}
		}
		return assertThat(new RequestMatcherAssert(context, matcher));
	}
	private PathMappedEndpoints mockPathMappedEndpoints(String basePath) {
		List<ExposableEndpoint<?>> endpoints = new ArrayList<>();
		endpoints.add(mockEndpoint(EndpointId.of('foo'), 'foo'));
		endpoints.add(mockEndpoint(EndpointId.of('bar'), 'bar'));
		return new PathMappedEndpoints(basePath, () -> endpoints);
	}
	private TestEndpoint mockEndpoint(EndpointId id, String rootPath) {
		return mockEndpoint(id, rootPath, WebServerNamespace.SERVER);
	}
	private TestEndpoint mockEndpoint(EndpointId id, String rootPath, WebServerNamespace webServerNamespace,
			String... additionalPaths) {
		TestEndpoint endpoint = mock(TestEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(id);
		given(endpoint.getRootPath()).willReturn(rootPath);
		given(endpoint.getAdditionalPaths(webServerNamespace)).willReturn(Arrays.asList(additionalPaths));
		return endpoint;
	}
	static class RequestMatcherAssert implements AssertDelegateTarget {
		private final StaticApplicationContext context;
		private final ServerWebExchangeMatcher matcher;
		RequestMatcherAssert(StaticApplicationContext context, ServerWebExchangeMatcher matcher) {
			this.context = context;
			this.matcher = matcher;
		}
		void matches(String path) {
			ServerWebExchange exchange = webHandler().createExchange(MockServerHttpRequest.get(path).build(),
					new MockServerHttpResponse());
			matches(exchange);
		}
		private void matches(ServerWebExchange exchange) {
			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30)).isMatch())
				.as('Matches ' + getRequestPath(exchange))
				.isTrue();
		}
		void doesNotMatch(String path) {
			ServerWebExchange exchange = webHandler().createExchange(MockServerHttpRequest.get(path).build(),
					new MockServerHttpResponse());
			doesNotMatch(exchange);
		}
		private void doesNotMatch(ServerWebExchange exchange) {
			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30)).isMatch())
				.as('Does not match ' + getRequestPath(exchange))
				.isFalse();
		}
		private TestHttpWebHandlerAdapter webHandler() {
			TestHttpWebHandlerAdapter adapter = new TestHttpWebHandlerAdapter(mock(WebHandler.class));
			adapter.setApplicationContext(this.context);
			return adapter;
		}
		private String getRequestPath(ServerWebExchange exchange) {
			return exchange.getRequest().getPath().toString();
		}
	}
	static class TestHttpWebHandlerAdapter extends HttpWebHandlerAdapter {
		TestHttpWebHandlerAdapter(WebHandler delegate) {
			super(delegate);
		}
		@Override
		protected ServerWebExchange createExchange(ServerHttpRequest request, ServerHttpResponse response) {
			return super.createExchange(request, response);
		}
	}
	@Endpoint(id = 'foo')
	static class FooEndpoint {
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint(id = 'baz')
	@SuppressWarnings('removal')
	static class BazServletEndpoint {
	}
	interface TestEndpoint extends ExposableEndpoint<Operation>, PathMappedEndpoint {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.reactive;
/**
class ReactiveManagementWebSecurityAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HealthContributorAutoConfiguration.class,
				HealthEndpointAutoConfiguration.class, InfoEndpointAutoConfiguration.class,
				WebFluxAutoConfiguration.class, EnvironmentEndpointAutoConfiguration.class,
				EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
				ReactiveSecurityAutoConfiguration.class, ReactiveManagementWebSecurityAutoConfiguration.class));
	@Test
	void permitAllForHealth() {
		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class)
			.run((context) -> assertThat(getAuthenticateHeader(context, '/actuator/health')).isNull());
	}
	@Test
	void withAdditionalPathsOnSamePort() {
		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.test1.include=*',
					'management.endpoint.health.group.test2.include=*',
					'management.endpoint.health.group.test1.additional-path=server:/check1',
					'management.endpoint.health.group.test2.additional-path=management:/check2')
			.run((context) -> {
				assertThat(getAuthenticateHeader(context, '/check1')).isNull();
				assertThat(getAuthenticateHeader(context, '/check2').get(0)).contains('Basic realm=');
				assertThat(getAuthenticateHeader(context, '/actuator/health')).isNull();
			});
	}
	@Test
	void withAdditionalPathsOnDifferentPort() {
		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class)
			.withPropertyValues('management.endpoint.health.group.test1.include=*',
					'management.endpoint.health.group.test2.include=*',
					'management.endpoint.health.group.test1.additional-path=server:/check1',
					'management.endpoint.health.group.test2.additional-path=management:/check2',
					'management.server.port=0')
			.run((context) -> {
				assertThat(getAuthenticateHeader(context, '/check1')).isNull();
				assertThat(getAuthenticateHeader(context, '/check2').get(0)).contains('Basic realm=');
				assertThat(getAuthenticateHeader(context, '/actuator/health').get(0)).contains('Basic realm=');
			});
	}
	@Test
	void securesEverythingElse() {
		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class).run((context) -> {
			assertThat(getAuthenticateHeader(context, '/actuator').get(0)).contains('Basic realm=');
			assertThat(getAuthenticateHeader(context, '/foo').toString()).contains('Basic realm=');
		});
	}
	@Test
	void noExistingAuthenticationManagerOrUserDetailsService() {
		this.contextRunner.run((context) -> {
			assertThat(getAuthenticateHeader(context, '/actuator/health')).isNull();
			assertThat(getAuthenticateHeader(context, '/actuator').get(0)).contains('Basic realm=');
			assertThat(getAuthenticateHeader(context, '/foo').toString()).contains('Basic realm=');
		});
	}
	@Test
	void usesMatchersBasedOffConfiguredActuatorBasePath() {
		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class)
			.withPropertyValues('management.endpoints.web.base-path=/')
			.run((context) -> {
				assertThat(getAuthenticateHeader(context, '/health')).isNull();
				assertThat(getAuthenticateHeader(context, '/foo').get(0)).contains('Basic realm=');
			});
	}
	@Test
	void backsOffIfCustomSecurityIsAdded() {
		this.contextRunner.withUserConfiguration(CustomSecurityConfiguration.class).run((context) -> {
			assertThat(getLocationHeader(context, '/actuator/health').toString()).contains('/login');
			assertThat(getLocationHeader(context, '/foo')).isNull();
		});
	}
	@Test
	void backOffIfReactiveOAuth2ResourceServerAutoConfigurationPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ReactiveOAuth2ResourceServerAutoConfiguration.class))
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://authserver')
			.run((context) -> assertThat(context)
				.doesNotHaveBean(ReactiveManagementWebSecurityAutoConfiguration.class));
	}
	@Test
	void backsOffWhenWebFilterChainProxyBeanPresent() {
		this.contextRunner.withUserConfiguration(WebFilterChainProxyConfiguration.class).run((context) -> {
			assertThat(getLocationHeader(context, '/actuator/health').toString()).contains('/login');
			assertThat(getLocationHeader(context, '/foo').toString()).contains('/login');
		});
	}
	private List<String> getAuthenticateHeader(AssertableReactiveWebApplicationContext context, String path) {
		ServerWebExchange exchange = performFilter(context, path);
		return exchange.getResponse().getHeaders().get(HttpHeaders.WWW_AUTHENTICATE);
	}
	private ServerWebExchange performFilter(AssertableReactiveWebApplicationContext context, String path) {
		ServerWebExchange exchange = webHandler(context).createExchange(MockServerHttpRequest.get(path).build(),
				new MockServerHttpResponse());
		WebFilterChainProxy proxy = context.getBean(WebFilterChainProxy.class);
		proxy.filter(exchange, (serverWebExchange) -> Mono.empty()).block(Duration.ofSeconds(30));
		return exchange;
	}
	private URI getLocationHeader(AssertableReactiveWebApplicationContext context, String path) {
		ServerWebExchange exchange = performFilter(context, path);
		return exchange.getResponse().getHeaders().getLocation();
	}
	private TestHttpWebHandlerAdapter webHandler(AssertableReactiveWebApplicationContext context) {
		TestHttpWebHandlerAdapter adapter = new TestHttpWebHandlerAdapter(mock(WebHandler.class));
		adapter.setApplicationContext(context);
		return adapter;
	}
	static class TestHttpWebHandlerAdapter extends HttpWebHandlerAdapter {
		TestHttpWebHandlerAdapter(WebHandler delegate) {
			super(delegate);
		}
		@Override
		protected ServerWebExchange createExchange(ServerHttpRequest request, ServerHttpResponse response) {
			return super.createExchange(request, response);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDetailsServiceConfiguration {
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			return new MapReactiveUserDetailsService(
					User.withUsername('alice').password('secret').roles('admin').build());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSecurityConfiguration {
		@Bean
		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
			http.authorizeExchange((exchanges) -> {
				exchanges.pathMatchers('/foo').permitAll();
				exchanges.anyExchange().authenticated();
			});
			http.formLogin(withDefaults());
			return http.build();
		}
		@Bean
		ReactiveAuthenticationManager authenticationManager() {
			return mock(ReactiveAuthenticationManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebFilterChainProxyConfiguration {
		@Bean
		ReactiveAuthenticationManager authenticationManager() {
			return mock(ReactiveAuthenticationManager.class);
		}
		@Bean
		WebFilterChainProxy webFilterChainProxy(ServerHttpSecurity http) {
			return new WebFilterChainProxy(getFilterChains(http));
		}
		@Bean
		TestServerHttpSecurity http(ReactiveAuthenticationManager authenticationManager) {
			TestServerHttpSecurity httpSecurity = new TestServerHttpSecurity();
			httpSecurity.authenticationManager(authenticationManager);
			return httpSecurity;
		}
		private List<SecurityWebFilterChain> getFilterChains(ServerHttpSecurity http) {
			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated());
			http.formLogin(withDefaults());
			return Collections.singletonList(http.build());
		}
		static class TestServerHttpSecurity extends ServerHttpSecurity implements ApplicationContextAware {
			@Override
			public void setApplicationContext(ApplicationContext applicationContext) {
				super.setApplicationContext(applicationContext);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.couchbase;
/**
class CouchbaseHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(Cluster.class, () -> mock(Cluster.class))
		.withConfiguration(AutoConfigurations.of(CouchbaseHealthContributorAutoConfiguration.class,
				HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(CouchbaseHealthIndicator.class)
			.doesNotHaveBean(CouchbaseReactiveHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.couchbase.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(CouchbaseHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.couchbase;
/**
class CouchbaseReactiveHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(Cluster.class, () -> mock(Cluster.class))
		.withConfiguration(AutoConfigurations.of(CouchbaseReactiveHealthContributorAutoConfiguration.class,
				HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(CouchbaseReactiveHealthIndicator.class)
			.hasBean('couchbaseHealthContributor'));
	}
	@Test
	void runWithRegularIndicatorShouldOnlyCreateReactiveIndicator() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(CouchbaseHealthContributorAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(CouchbaseReactiveHealthIndicator.class)
				.hasBean('couchbaseHealthContributor')
				.doesNotHaveBean(CouchbaseHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.couchbase.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(CouchbaseReactiveHealthIndicator.class)
				.doesNotHaveBean('couchbaseHealthContributor'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.session;
/**
class SessionsEndpointAutoConfigurationTests {
	@Nested
	class ServletSessionEndpointConfigurationTests {
		private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(SessionsEndpointAutoConfiguration.class))
			.withUserConfiguration(IndexedSessionRepositoryConfiguration.class);
		@Test
		void runShouldHaveEndpointBean() {
			this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=sessions')
				.run((context) -> assertThat(context).hasSingleBean(SessionsEndpoint.class));
		}
		@Test
		void runWhenNoIndexedSessionRepositoryShouldHaveEndpointBean() {
			new WebApplicationContextRunner()
				.withConfiguration(AutoConfigurations.of(SessionsEndpointAutoConfiguration.class))
				.withUserConfiguration(SessionRepositoryConfiguration.class)
				.withPropertyValues('management.endpoints.web.exposure.include=sessions')
				.run((context) -> assertThat(context).hasSingleBean(SessionsEndpoint.class));
		}
		@Test
		void runWhenNotExposedShouldNotHaveEndpointBean() {
			this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(SessionsEndpoint.class));
		}
		@Test
		void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
			this.contextRunner.withPropertyValues('management.endpoint.sessions.enabled:false')
				.run((context) -> assertThat(context).doesNotHaveBean(SessionsEndpoint.class));
		}
		@Configuration(proxyBeanMethods = false)
		static class IndexedSessionRepositoryConfiguration {
			@Bean
			FindByIndexNameSessionRepository<?> sessionRepository() {
				return mock(FindByIndexNameSessionRepository.class);
			}
		}
		@Configuration(proxyBeanMethods = false)
		static class SessionRepositoryConfiguration {
			@Bean
			SessionRepository<?> sessionRepository() {
				return mock(SessionRepository.class);
			}
		}
	}
	@Nested
	class ReactiveSessionEndpointConfigurationTests {
		private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(SessionsEndpointAutoConfiguration.class))
			.withUserConfiguration(ReactiveSessionRepositoryConfiguration.class,
					ReactiveIndexedSessionRepositoryConfiguration.class);
		@Test
		void runShouldHaveEndpointBean() {
			this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=sessions')
				.run((context) -> assertThat(context).hasSingleBean(ReactiveSessionsEndpoint.class));
		}
		@Test
		void runWhenNoIndexedSessionRepositoryShouldHaveEndpointBean() {
			new ReactiveWebApplicationContextRunner()
				.withConfiguration(AutoConfigurations.of(SessionsEndpointAutoConfiguration.class))
				.withUserConfiguration(ReactiveSessionRepositoryConfiguration.class)
				.withPropertyValues('management.endpoints.web.exposure.include=sessions')
				.run((context) -> assertThat(context).hasSingleBean(ReactiveSessionsEndpoint.class));
		}
		@Test
		void runWhenNotExposedShouldNotHaveEndpointBean() {
			this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ReactiveSessionsEndpoint.class));
		}
		@Test
		void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
			this.contextRunner.withPropertyValues('management.endpoint.sessions.enabled:false')
				.run((context) -> assertThat(context).doesNotHaveBean(ReactiveSessionsEndpoint.class));
		}
		@Configuration(proxyBeanMethods = false)
		static class ReactiveIndexedSessionRepositoryConfiguration {
			@Bean
			ReactiveFindByIndexNameSessionRepository<?> indexedSessionRepository() {
				return mock(ReactiveFindByIndexNameSessionRepository.class);
			}
		}
		@Configuration(proxyBeanMethods = false)
		static class ReactiveSessionRepositoryConfiguration {
			@Bean
			ReactiveSessionRepository<?> sessionRepository() {
				return mock(ReactiveSessionRepository.class);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
class TokenTests {
	@Test
	void invalidJwtShouldThrowException() {
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class).isThrownBy(() -> new Token('invalid-token'))
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void invalidJwtClaimsShouldThrowException() {
		String header = '{\'alg\': \'RS256\', \'kid\': \'key-id\', \'typ\': \'JWT\'}';
		String claims = 'invalid-claims';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(() -> new Token(Base64.getEncoder().encodeToString(header.getBytes()) + '.'
					+ Base64.getEncoder().encodeToString(claims.getBytes())))
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void invalidJwtHeaderShouldThrowException() {
		String header = 'invalid-header';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\'}';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(() -> new Token(Base64.getEncoder().encodeToString(header.getBytes()) + '.'
					+ Base64.getEncoder().encodeToString(claims.getBytes())))
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void emptyJwtSignatureShouldThrowException() {
		String token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ0b3B0YWwu'
				+ 'Y29tIiwiZXhwIjoxNDI2NDIwODAwLCJhd2Vzb21lIjp0cnVlfQ.';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class).isThrownBy(() -> new Token(token))
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void validJwt() {
		String header = '{\'alg\': \'RS256\',  \'kid\': \'key-id\', \'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\'}';
		String content = Base64.getEncoder().encodeToString(header.getBytes()) + '.'
				+ Base64.getEncoder().encodeToString(claims.getBytes());
		String signature = Base64.getEncoder().encodeToString('signature'.getBytes());
		Token token = new Token(content + '.' + signature);
		assertThat(token.getExpiry()).isEqualTo(2147483647);
		assertThat(token.getIssuer()).isEqualTo('http://localhost:8080/uaa/oauth/token');
		assertThat(token.getSignatureAlgorithm()).isEqualTo('RS256');
		assertThat(token.getKeyId()).isEqualTo('key-id');
		assertThat(token.getContent()).isEqualTo(content.getBytes());
		assertThat(token.getSignature()).isEqualTo(Base64.getDecoder().decode(signature));
	}
	@Test
	void getSignatureAlgorithmWhenAlgIsNullShouldThrowException() {
		String header = '{\'kid\': \'key-id\',  \'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\'}';
		Token token = createToken(header, claims);
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class).isThrownBy(token::getSignatureAlgorithm)
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void getIssuerWhenIssIsNullShouldThrowException() {
		String header = '{\'alg\': \'RS256\', \'kid\': \'key-id\', \'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647}';
		Token token = createToken(header, claims);
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class).isThrownBy(token::getIssuer)
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void getKidWhenKidIsNullShouldThrowException() {
		String header = '{\'alg\': \'RS256\', \'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647}';
		Token token = createToken(header, claims);
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class).isThrownBy(token::getKeyId)
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void getExpiryWhenExpIsNullShouldThrowException() {
		String header = '{\'alg\': \'RS256\',  \'kid\': \'key-id\', \'typ\': \'JWT\'}';
		String claims = '{\'iss\': \'http://localhost:8080/uaa/oauth/token\'}';
		Token token = createToken(header, claims);
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class).isThrownBy(token::getExpiry)
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	private Token createToken(String header, String claims) {
		Token token = new Token(Base64.getEncoder().encodeToString(header.getBytes()) + '.'
				+ Base64.getEncoder().encodeToString(claims.getBytes()) + '.'
				+ Base64.getEncoder().encodeToString('signature'.getBytes()));
		return token;
	}
	private Consumer<CloudFoundryAuthorizationException> reasonRequirement(Reason reason) {
		return (ex) -> assertThat(ex.getReason()).isEqualTo(reason);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
class AccessLevelTests {
	@Test
	void accessToHealthEndpointShouldNotBeRestricted() {
		assertThat(AccessLevel.RESTRICTED.isAccessAllowed('health')).isTrue();
		assertThat(AccessLevel.FULL.isAccessAllowed('health')).isTrue();
	}
	@Test
	void accessToInfoEndpointShouldNotBeRestricted() {
		assertThat(AccessLevel.RESTRICTED.isAccessAllowed('info')).isTrue();
		assertThat(AccessLevel.FULL.isAccessAllowed('info')).isTrue();
	}
	@Test
	void accessToDiscoveryEndpointShouldNotBeRestricted() {
		assertThat(AccessLevel.RESTRICTED.isAccessAllowed('')).isTrue();
		assertThat(AccessLevel.FULL.isAccessAllowed('')).isTrue();
	}
	@Test
	void accessToAnyOtherEndpointShouldBeRestricted() {
		assertThat(AccessLevel.RESTRICTED.isAccessAllowed('env')).isFalse();
		assertThat(AccessLevel.FULL.isAccessAllowed('')).isTrue();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
class CloudFoundryWebEndpointDiscovererTests {
	@Test
	void getEndpointsShouldAddCloudFoundryHealthExtension() {
		load(TestConfiguration.class, (discoverer) -> {
			Collection<ExposableWebEndpoint> endpoints = discoverer.getEndpoints();
			assertThat(endpoints).hasSize(2);
			for (ExposableWebEndpoint endpoint : endpoints) {
				if (endpoint.getEndpointId().equals(EndpointId.of('health'))) {
					WebOperation operation = findMainReadOperation(endpoint);
					assertThat(operation
						.invoke(new InvocationContext(mock(SecurityContext.class), Collections.emptyMap())))
						.isEqualTo('cf');
				}
			}
		});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new CloudFoundryWebEndpointDiscovererRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection()
			.onType(CloudFoundryEndpointFilter.class)
			.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(runtimeHints);
	}
	private WebOperation findMainReadOperation(ExposableWebEndpoint endpoint) {
		for (WebOperation operation : endpoint.getOperations()) {
			if (operation.getRequestPredicate().getPath().equals('health')) {
				return operation;
			}
		}
		throw new IllegalStateException('No main read operation found from ' + endpoint.getOperations());
	}
	private void load(Class<?> configuration, Consumer<CloudFoundryWebEndpointDiscoverer> consumer) {
		load((id) -> null, EndpointId::toString, configuration, consumer);
	}
	private void load(Function<EndpointId, Long> timeToLive, PathMapper endpointPathMapper, Class<?> configuration,
			Consumer<CloudFoundryWebEndpointDiscoverer> consumer) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(configuration)) {
			ConversionServiceParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper(
					DefaultConversionService.getSharedInstance());
			EndpointMediaTypes mediaTypes = new EndpointMediaTypes(Collections.singletonList('application/json'),
					Collections.singletonList('application/json'));
			CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer(context,
					parameterMapper, mediaTypes, Collections.singletonList(endpointPathMapper),
					Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)), Collections.emptyList(),
					Collections.emptyList());
			consumer.accept(discoverer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}
		@Bean
		TestEndpointWebExtension testEndpointWebExtension() {
			return new TestEndpointWebExtension();
		}
		@Bean
		HealthEndpoint healthEndpoint() {
			HealthContributorRegistry registry = mock(HealthContributorRegistry.class);
			HealthEndpointGroups groups = mock(HealthEndpointGroups.class);
			return new HealthEndpoint(registry, groups, null);
		}
		@Bean
		HealthEndpointWebExtension healthEndpointWebExtension() {
			return new HealthEndpointWebExtension();
		}
		@Bean
		TestHealthEndpointCloudFoundryExtension testHealthEndpointCloudFoundryExtension() {
			return new TestHealthEndpointCloudFoundryExtension();
		}
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@EndpointWebExtension(endpoint = TestEndpoint.class)
	static class TestEndpointWebExtension {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@EndpointWebExtension(endpoint = HealthEndpoint.class)
	static class HealthEndpointWebExtension {
		@ReadOperation
		Object getAll() {
			return null;
		}
	}
	@EndpointCloudFoundryExtension(endpoint = HealthEndpoint.class)
	static class TestHealthEndpointCloudFoundryExtension {
		@ReadOperation
		Object getAll() {
			return 'cf';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
class CloudFoundryEndpointFilterTests {
	private final CloudFoundryEndpointFilter filter = new CloudFoundryEndpointFilter();
	@Test
	void matchIfDiscovererCloudFoundryShouldReturnFalse() {
		DiscoveredEndpoint<?> endpoint = mock(DiscoveredEndpoint.class);
		given(endpoint.wasDiscoveredBy(CloudFoundryWebEndpointDiscoverer.class)).willReturn(true);
		assertThat(this.filter.match(endpoint)).isTrue();
	}
	@Test
	void matchIfDiscovererNotCloudFoundryShouldReturnFalse() {
		DiscoveredEndpoint<?> endpoint = mock(DiscoveredEndpoint.class);
		given(endpoint.wasDiscoveredBy(CloudFoundryWebEndpointDiscoverer.class)).willReturn(false);
		assertThat(this.filter.match(endpoint)).isFalse();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundryInfoEndpointWebExtensionTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withPropertyValues('VCAP_APPLICATION={}')
		.withConfiguration(AutoConfigurations.of(SecurityAutoConfiguration.class, WebMvcAutoConfiguration.class,
				JacksonAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
				RestTemplateAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				ServletManagementContextAutoConfiguration.class, EndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, ProjectInfoAutoConfiguration.class,
				InfoContributorAutoConfiguration.class, InfoEndpointAutoConfiguration.class,
				HealthEndpointAutoConfiguration.class, CloudFoundryActuatorAutoConfiguration.class));
	@Test
	@SuppressWarnings('unchecked')
	void gitFullDetailsAlwaysPresent() {
		this.contextRunner.run((context) -> {
			CloudFoundryInfoEndpointWebExtension extension = context
				.getBean(CloudFoundryInfoEndpointWebExtension.class);
			Map<String, Object> git = (Map<String, Object>) extension.info().get('git');
			Map<String, Object> commit = (Map<String, Object>) git.get('commit');
			assertThat(commit).hasSize(4);
		});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundryWebEndpointServletHandlerMappingTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new CloudFoundryWebEndpointServletHandlerMappingRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onMethod(CloudFoundryLinksHandler.class, 'links'))
			.accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(Link.class)).accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
@ExtendWith(MockitoExtension.class)
class CloudFoundrySecurityInterceptorTests {
	@Mock
	private TokenValidator tokenValidator;
	@Mock
	private CloudFoundrySecurityService securityService;
	private CloudFoundrySecurityInterceptor interceptor;
	private MockHttpServletRequest request;
	@BeforeEach
	void setup() {
		this.interceptor = new CloudFoundrySecurityInterceptor(this.tokenValidator, this.securityService, 'my-app-id');
		this.request = new MockHttpServletRequest();
	}
	@Test
	void preHandleWhenRequestIsPreFlightShouldReturnTrue() {
		this.request.setMethod('OPTIONS');
		this.request.addHeader(HttpHeaders.ORIGIN, 'https://example.com');
		this.request.addHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET');
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('test'));
		assertThat(response.getStatus()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void preHandleWhenTokenIsMissingShouldReturnFalse() {
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('test'));
		assertThat(response.getStatus()).isEqualTo(Reason.MISSING_AUTHORIZATION.getStatus());
	}
	@Test
	void preHandleWhenTokenIsNotBearerShouldReturnFalse() {
		this.request.addHeader('Authorization', mockAccessToken());
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('test'));
		assertThat(response.getStatus()).isEqualTo(Reason.MISSING_AUTHORIZATION.getStatus());
	}
	@Test
	void preHandleWhenApplicationIdIsNullShouldReturnFalse() {
		this.interceptor = new CloudFoundrySecurityInterceptor(this.tokenValidator, this.securityService, null);
		this.request.addHeader('Authorization', 'bearer ' + mockAccessToken());
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('test'));
		assertThat(response.getStatus()).isEqualTo(Reason.SERVICE_UNAVAILABLE.getStatus());
	}
	@Test
	void preHandleWhenCloudFoundrySecurityServiceIsNullShouldReturnFalse() {
		this.interceptor = new CloudFoundrySecurityInterceptor(this.tokenValidator, null, 'my-app-id');
		this.request.addHeader('Authorization', 'bearer ' + mockAccessToken());
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('test'));
		assertThat(response.getStatus()).isEqualTo(Reason.SERVICE_UNAVAILABLE.getStatus());
	}
	@Test
	void preHandleWhenAccessIsNotAllowedShouldReturnFalse() {
		String accessToken = mockAccessToken();
		this.request.addHeader('Authorization', 'bearer ' + accessToken);
		given(this.securityService.getAccessLevel(accessToken, 'my-app-id')).willReturn(AccessLevel.RESTRICTED);
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('test'));
		assertThat(response.getStatus()).isEqualTo(Reason.ACCESS_DENIED.getStatus());
	}
	@Test
	void preHandleSuccessfulWithFullAccess() {
		String accessToken = mockAccessToken();
		this.request.addHeader('Authorization', 'Bearer ' + accessToken);
		given(this.securityService.getAccessLevel(accessToken, 'my-app-id')).willReturn(AccessLevel.FULL);
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('test'));
		then(this.tokenValidator).should().validate(assertArg((token) -> assertThat(token).hasToString(accessToken)));
		assertThat(response.getStatus()).isEqualTo(HttpStatus.OK);
		assertThat(this.request.getAttribute('cloudFoundryAccessLevel')).isEqualTo(AccessLevel.FULL);
	}
	@Test
	void preHandleSuccessfulWithRestrictedAccess() {
		String accessToken = mockAccessToken();
		this.request.addHeader('Authorization', 'Bearer ' + accessToken);
		given(this.securityService.getAccessLevel(accessToken, 'my-app-id')).willReturn(AccessLevel.RESTRICTED);
		SecurityResponse response = this.interceptor.preHandle(this.request, EndpointId.of('info'));
		then(this.tokenValidator).should().validate(assertArg((token) -> assertThat(token).hasToString(accessToken)));
		assertThat(response.getStatus()).isEqualTo(HttpStatus.OK);
		assertThat(this.request.getAttribute('cloudFoundryAccessLevel')).isEqualTo(AccessLevel.RESTRICTED);
	}
	private String mockAccessToken() {
		return 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ0b3B0YWwu'
				+ 'Y29tIiwiZXhwIjoxNDI2NDIwODAwLCJhd2Vzb21lIjp0cnVlfQ.'
				+ Base64.getEncoder().encodeToString('signature'.getBytes());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundryMvcWebEndpointIntegrationTests {
	private final TokenValidator tokenValidator = mock(TokenValidator.class);
	private final CloudFoundrySecurityService securityService = mock(CloudFoundrySecurityService.class);
	@Test
	void operationWithSecurityInterceptorForbidden() {
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(AccessLevel.RESTRICTED);
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/cfApplication/test')
					.accept(MediaType.APPLICATION_JSON)
					.header('Authorization', 'bearer ' + mockAccessToken())
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.FORBIDDEN));
	}
	@Test
	void operationWithSecurityInterceptorSuccess() {
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(AccessLevel.FULL);
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/cfApplication/test')
					.accept(MediaType.APPLICATION_JSON)
					.header('Authorization', 'bearer ' + mockAccessToken())
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.OK));
	}
	@Test
	void responseToOptionsRequestIncludesCorsHeaders() {
		load(TestEndpointConfiguration.class,
				(client) -> client.options()
					.uri('/cfApplication/test')
					.accept(MediaType.APPLICATION_JSON)
					.header('Access-Control-Request-Method', 'POST')
					.header('Origin', 'https://example.com')
					.exchange()
					.expectStatus()
					.isOk()
					.expectHeader()
					.valueEquals('Access-Control-Allow-Origin', 'https://example.com')
					.expectHeader()
					.valueEquals('Access-Control-Allow-Methods', 'GET,POST'));
	}
	@Test
	void linksToOtherEndpointsWithFullAccess() {
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(AccessLevel.FULL);
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/cfApplication')
					.accept(MediaType.APPLICATION_JSON)
					.header('Authorization', 'bearer ' + mockAccessToken())
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('_links.length()')
					.isEqualTo(5)
					.jsonPath('_links.self.href')
					.isNotEmpty()
					.jsonPath('_links.self.templated')
					.isEqualTo(false)
					.jsonPath('_links.info.href')
					.isNotEmpty()
					.jsonPath('_links.info.templated')
					.isEqualTo(false)
					.jsonPath('_links.env.href')
					.isNotEmpty()
					.jsonPath('_links.env.templated')
					.isEqualTo(false)
					.jsonPath('_links.test.href')
					.isNotEmpty()
					.jsonPath('_links.test.templated')
					.isEqualTo(false)
					.jsonPath('_links.test-part.href')
					.isNotEmpty()
					.jsonPath('_links.test-part.templated')
					.isEqualTo(true));
	}
	@Test
	void linksToOtherEndpointsForbidden() {
		CloudFoundryAuthorizationException exception = new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN,
				'invalid-token');
		willThrow(exception).given(this.tokenValidator).validate(any());
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/cfApplication')
					.accept(MediaType.APPLICATION_JSON)
					.header('Authorization', 'bearer ' + mockAccessToken())
					.exchange()
					.expectStatus()
					.isUnauthorized());
	}
	@Test
	void linksToOtherEndpointsWithRestrictedAccess() {
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(AccessLevel.RESTRICTED);
		load(TestEndpointConfiguration.class,
				(client) -> client.get()
					.uri('/cfApplication')
					.accept(MediaType.APPLICATION_JSON)
					.header('Authorization', 'bearer ' + mockAccessToken())
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('_links.length()')
					.isEqualTo(2)
					.jsonPath('_links.self.href')
					.isNotEmpty()
					.jsonPath('_links.self.templated')
					.isEqualTo(false)
					.jsonPath('_links.info.href')
					.isNotEmpty()
					.jsonPath('_links.info.templated')
					.isEqualTo(false)
					.jsonPath('_links.env')
					.doesNotExist()
					.jsonPath('_links.test')
					.doesNotExist()
					.jsonPath('_links.test-part')
					.doesNotExist());
	}
	private void load(Class<?> configuration, Consumer<WebTestClient> clientConsumer) {
		BiConsumer<ApplicationContext, WebTestClient> consumer = (context, client) -> clientConsumer.accept(client);
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withUserConfiguration(configuration, CloudFoundryMvcConfiguration.class)
			.withBean(TokenValidator.class, () -> this.tokenValidator)
			.withBean(CloudFoundrySecurityService.class, () -> this.securityService)
			.run((context) -> consumer.accept(context, WebTestClient.bindToServer()
				.baseUrl('http://localhost:' + getPort(
						(AnnotationConfigServletWebServerApplicationContext) context.getSourceApplicationContext()))
				.responseTimeout(Duration.ofMinutes(5))
				.build()));
	}
	private int getPort(AnnotationConfigServletWebServerApplicationContext context) {
		return context.getWebServer().getPort();
	}
	private String mockAccessToken() {
		return 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ0b3B0YWwu'
				+ 'Y29tIiwiZXhwIjoxNDI2NDIwODAwLCJhd2Vzb21lIjp0cnVlfQ.'
				+ Base64.getEncoder().encodeToString('signature'.getBytes());
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class CloudFoundryMvcConfiguration {
		@Bean
		CloudFoundrySecurityInterceptor interceptor(TokenValidator tokenValidator,
				CloudFoundrySecurityService securityService) {
			return new CloudFoundrySecurityInterceptor(tokenValidator, securityService, 'app-id');
		}
		@Bean
		EndpointMediaTypes EndpointMediaTypes() {
			return new EndpointMediaTypes(Collections.singletonList('application/json'),
					Collections.singletonList('application/json'));
		}
		@Bean
		CloudFoundryWebEndpointServletHandlerMapping cloudFoundryWebEndpointServletHandlerMapping(
				WebEndpointDiscoverer webEndpointDiscoverer, EndpointMediaTypes endpointMediaTypes,
				CloudFoundrySecurityInterceptor interceptor) {
			CorsConfiguration corsConfiguration = new CorsConfiguration();
			corsConfiguration.setAllowedOrigins(Arrays.asList('https://example.com'));
			corsConfiguration.setAllowedMethods(Arrays.asList('GET', 'POST'));
			Collection<ExposableWebEndpoint> webEndpoints = webEndpointDiscoverer.getEndpoints();
			List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>(webEndpoints);
			return new CloudFoundryWebEndpointServletHandlerMapping(new EndpointMapping('/cfApplication'), webEndpoints,
					endpointMediaTypes, corsConfiguration, interceptor, allEndpoints);
		}
		@Bean
		WebEndpointDiscoverer webEndpointDiscoverer(ApplicationContext applicationContext,
				EndpointMediaTypes endpointMediaTypes) {
			ParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper(
					DefaultConversionService.getSharedInstance());
			return new WebEndpointDiscoverer(applicationContext, parameterMapper, endpointMediaTypes, null, null,
					Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
		}
		@Bean
		EndpointDelegate endpointDelegate() {
			return mock(EndpointDelegate.class);
		}
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		private final EndpointDelegate endpointDelegate;
		TestEndpoint(EndpointDelegate endpointDelegate) {
			this.endpointDelegate = endpointDelegate;
		}
		@ReadOperation
		Map<String, Object> readAll() {
			return Collections.singletonMap('All', true);
		}
		@ReadOperation
		Map<String, Object> readPart(@Selector String part) {
			return Collections.singletonMap('part', part);
		}
		@WriteOperation
		void write(String foo, String bar) {
			this.endpointDelegate.write(foo, bar);
		}
	}
	@Endpoint(id = 'env')
	static class TestEnvEndpoint {
		@ReadOperation
		Map<String, Object> readAll() {
			return Collections.singletonMap('All', true);
		}
	}
	@Endpoint(id = 'info')
	static class TestInfoEndpoint {
		@ReadOperation
		Map<String, Object> readAll() {
			return Collections.singletonMap('All', true);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CloudFoundryMvcConfiguration.class)
	static class TestEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint(EndpointDelegate endpointDelegate) {
			return new TestEndpoint(endpointDelegate);
		}
		@Bean
		TestInfoEndpoint testInfoEnvEndpoint() {
			return new TestInfoEndpoint();
		}
		@Bean
		TestEnvEndpoint testEnvEndpoint() {
			return new TestEnvEndpoint();
		}
	}
	interface EndpointDelegate {
		void write();
		void write(String foo, String bar);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundrySecurityServiceTests {
	private static final String CLOUD_CONTROLLER = 'https://my-cloud-controller.com';
	private static final String CLOUD_CONTROLLER_PERMISSIONS = CLOUD_CONTROLLER + '/v2/apps/my-app-id/permissions';
	private static final String UAA_URL = 'https://my-uaa.com';
	private CloudFoundrySecurityService securityService;
	private MockRestServiceServer server;
	@BeforeEach
	void setup() {
		MockServerRestTemplateCustomizer mockServerCustomizer = new MockServerRestTemplateCustomizer();
		RestTemplateBuilder builder = new RestTemplateBuilder(mockServerCustomizer);
		this.securityService = new CloudFoundrySecurityService(builder, CLOUD_CONTROLLER, false);
		this.server = mockServerCustomizer.getServer();
	}
	@Test
	void skipSslValidationWhenTrue() {
		RestTemplateBuilder builder = new RestTemplateBuilder();
		this.securityService = new CloudFoundrySecurityService(builder, CLOUD_CONTROLLER, true);
		RestTemplate restTemplate = (RestTemplate) ReflectionTestUtils.getField(this.securityService, 'restTemplate');
		assertThat(restTemplate.getRequestFactory()).isInstanceOf(SkipSslVerificationHttpRequestFactory.class);
	}
	@Test
	void doNotSkipSslValidationWhenFalse() {
		RestTemplateBuilder builder = new RestTemplateBuilder();
		this.securityService = new CloudFoundrySecurityService(builder, CLOUD_CONTROLLER, false);
		RestTemplate restTemplate = (RestTemplate) ReflectionTestUtils.getField(this.securityService, 'restTemplate');
		assertThat(restTemplate.getRequestFactory()).isNotInstanceOf(SkipSslVerificationHttpRequestFactory.class);
	}
	@Test
	void getAccessLevelWhenSpaceDeveloperShouldReturnFull() {
		String responseBody = '{\'read_sensitive_data\': true,\'read_basic_data\': true}';
		this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))
			.andExpect(header('Authorization', 'bearer my-access-token'))
			.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));
		AccessLevel accessLevel = this.securityService.getAccessLevel('my-access-token', 'my-app-id');
		this.server.verify();
		assertThat(accessLevel).isEqualTo(AccessLevel.FULL);
	}
	@Test
	void getAccessLevelWhenNotSpaceDeveloperShouldReturnRestricted() {
		String responseBody = '{\'read_sensitive_data\': false,\'read_basic_data\': true}';
		this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))
			.andExpect(header('Authorization', 'bearer my-access-token'))
			.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));
		AccessLevel accessLevel = this.securityService.getAccessLevel('my-access-token', 'my-app-id');
		this.server.verify();
		assertThat(accessLevel).isEqualTo(AccessLevel.RESTRICTED);
	}
	@Test
	void getAccessLevelWhenTokenIsNotValidShouldThrowException() {
		this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))
			.andExpect(header('Authorization', 'bearer my-access-token'))
			.andRespond(withUnauthorizedRequest());
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(() -> this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.satisfies(reasonRequirement(Reason.INVALID_TOKEN));
	}
	@Test
	void getAccessLevelWhenForbiddenShouldThrowException() {
		this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))
			.andExpect(header('Authorization', 'bearer my-access-token'))
			.andRespond(withStatus(HttpStatus.FORBIDDEN));
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(() -> this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.satisfies(reasonRequirement(Reason.ACCESS_DENIED));
	}
	@Test
	void getAccessLevelWhenCloudControllerIsNotReachableThrowsException() {
		this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))
			.andExpect(header('Authorization', 'bearer my-access-token'))
			.andRespond(withServerError());
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(() -> this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.satisfies(reasonRequirement(Reason.SERVICE_UNAVAILABLE));
	}
	@Test
	void fetchTokenKeysWhenSuccessfulShouldReturnListOfKeysFromUAA() {
		this.server.expect(requestTo(CLOUD_CONTROLLER + '/info'))
			.andRespond(withSuccess('{\'token_endpoint\':\'https://my-uaa.com\'}', MediaType.APPLICATION_JSON));
		String tokenKeyValue = '''
				-----BEGIN PUBLIC KEY-----
				MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0m59l2u9iDnMbrXHfqkO
				rn2dVQ3vfBJqcDuFUK03d+1PZGbVlNCqnkpIJ8syFppW8ljnWweP7+LiWpRoz0I7
				fYb3d8TjhV86Y997Fl4DBrxgM6KTJOuE/uxnoDhZQ14LgOU2ckXjOzOdTsnGMKQB
				LCl0vpcXBtFLMaSbpv1ozi8h7DJyVZ6EnFQZUWGdgTMhDrmqevfx95U/16c5WBDO
				kqwIn7Glry9n9Suxygbf8g5AzpWcusZgDLIIZ7JTUldBb8qU2a0Dl4mvLZOn4wPo
				jfj9Cw2QICsc5+Pwf21fP+hzf+1WSRHbnYv8uanRO0gZ8ekGaghM/2H6gqJbo2nI
				JwIDAQAB
				-----END PUBLIC KEY-----''';
		String responseBody = '{\'keys\' : [ {\'kid\':\'test-key\',\'value\' : \'' + tokenKeyValue.replace('\n', '\\n')
				+ '\'} ]}';
		this.server.expect(requestTo(UAA_URL + '/token_keys'))
			.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));
		Map<String, String> tokenKeys = this.securityService.fetchTokenKeys();
		this.server.verify();
		assertThat(tokenKeys).containsEntry('test-key', tokenKeyValue);
	}
	@Test
	void fetchTokenKeysWhenNoKeysReturnedFromUAA() {
		this.server.expect(requestTo(CLOUD_CONTROLLER + '/info'))
			.andRespond(withSuccess('{\'token_endpoint\':\'' + UAA_URL + '\'}', MediaType.APPLICATION_JSON));
		String responseBody = '{\'keys\': []}';
		this.server.expect(requestTo(UAA_URL + '/token_keys'))
			.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));
		Map<String, String> tokenKeys = this.securityService.fetchTokenKeys();
		this.server.verify();
		assertThat(tokenKeys).isEmpty();
	}
	@Test
	void fetchTokenKeysWhenUnsuccessfulShouldThrowException() {
		this.server.expect(requestTo(CLOUD_CONTROLLER + '/info'))
			.andRespond(withSuccess('{\'token_endpoint\':\'' + UAA_URL + '\'}', MediaType.APPLICATION_JSON));
		this.server.expect(requestTo(UAA_URL + '/token_keys')).andRespond(withServerError());
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(() -> this.securityService.fetchTokenKeys())
			.satisfies(reasonRequirement(Reason.SERVICE_UNAVAILABLE));
	}
	@Test
	void getUaaUrlShouldCallCloudControllerInfoOnlyOnce() {
		this.server.expect(requestTo(CLOUD_CONTROLLER + '/info'))
			.andRespond(withSuccess('{\'token_endpoint\':\'' + UAA_URL + '\'}', MediaType.APPLICATION_JSON));
		String uaaUrl = this.securityService.getUaaUrl();
		this.server.verify();
		assertThat(uaaUrl).isEqualTo(UAA_URL);
		// Second call should not need to hit server
		uaaUrl = this.securityService.getUaaUrl();
		assertThat(uaaUrl).isEqualTo(UAA_URL);
	}
	@Test
	void getUaaUrlWhenCloudControllerUrlIsNotReachableShouldThrowException() {
		this.server.expect(requestTo(CLOUD_CONTROLLER + '/info')).andRespond(withServerError());
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(() -> this.securityService.getUaaUrl())
			.satisfies(reasonRequirement(Reason.SERVICE_UNAVAILABLE));
	}
	private Consumer<CloudFoundryAuthorizationException> reasonRequirement(Reason reason) {
		return (ex) -> assertThat(ex.getReason()).isEqualTo(reason);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
@ExtendWith(MockitoExtension.class)
class TokenValidatorTests {
	private static final byte[] DOT = '.'.getBytes();
	@Mock
	private CloudFoundrySecurityService securityService;
	private TokenValidator tokenValidator;
	private static final String VALID_KEY = '''
			-----BEGIN PUBLIC KEY-----
			MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0m59l2u9iDnMbrXHfqkO
			rn2dVQ3vfBJqcDuFUK03d+1PZGbVlNCqnkpIJ8syFppW8ljnWweP7+LiWpRoz0I7
			fYb3d8TjhV86Y997Fl4DBrxgM6KTJOuE/uxnoDhZQ14LgOU2ckXjOzOdTsnGMKQB
			LCl0vpcXBtFLMaSbpv1ozi8h7DJyVZ6EnFQZUWGdgTMhDrmqevfx95U/16c5WBDO
			kqwIn7Glry9n9Suxygbf8g5AzpWcusZgDLIIZ7JTUldBb8qU2a0Dl4mvLZOn4wPo
			jfj9Cw2QICsc5+Pwf21fP+hzf+1WSRHbnYv8uanRO0gZ8ekGaghM/2H6gqJbo2nI
			JwIDAQAB
			-----END PUBLIC KEY-----''';
	private static final String INVALID_KEY = '''
			-----BEGIN PUBLIC KEY-----
			MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxzYuc22QSst/dS7geYYK
			5l5kLxU0tayNdixkEQ17ix+CUcUbKIsnyftZxaCYT46rQtXgCaYRdJcbB3hmyrOa
			vkhTpX79xJZnQmfuamMbZBqitvscxW9zRR9tBUL6vdi/0rpoUwPMEh8+Bw7CgYR0
			FK0DhWYBNDfe9HKcyZEv3max8Cdq18htxjEsdYO0iwzhtKRXomBWTdhD5ykd/fAC
			VTr4+KEY+IeLvubHVmLUhbE5NgWXxrRpGasDqzKhCTmsa2Ysf712rl57SlH0Wz/M
			r3F7aM9YpErzeYLrl0GhQr9BVJxOvXcVd4kmY+XkiCcrkyS1cnghnllh+LCwQu1s
			YwIDAQAB
			-----END PUBLIC KEY-----''';
	private static final Map<String, String> INVALID_KEYS = Collections.singletonMap('invalid-key', INVALID_KEY);
	private static final Map<String, String> VALID_KEYS = Collections.singletonMap('valid-key', VALID_KEY);
	@BeforeEach
	void setup() {
		this.tokenValidator = new TokenValidator(this.securityService);
	}
	@Test
	void validateTokenWhenKidValidationFailsTwiceShouldThrowException() {
		ReflectionTestUtils.setField(this.tokenValidator, 'tokenKeys', INVALID_KEYS);
		given(this.securityService.fetchTokenKeys()).willReturn(INVALID_KEYS);
		String header = '{\'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(
					() -> this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.satisfies(reasonRequirement(Reason.INVALID_KEY_ID));
	}
	@Test
	void validateTokenWhenKidValidationSucceedsInTheSecondAttempt() throws Exception {
		ReflectionTestUtils.setField(this.tokenValidator, 'tokenKeys', INVALID_KEYS);
		given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);
		given(this.securityService.getUaaUrl()).willReturn('http://localhost:8080/uaa');
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes())));
		then(this.securityService).should().fetchTokenKeys();
	}
	@Test
	void validateTokenShouldFetchTokenKeysIfNull() throws Exception {
		given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);
		given(this.securityService.getUaaUrl()).willReturn('http://localhost:8080/uaa');
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes())));
		then(this.securityService).should().fetchTokenKeys();
	}
	@Test
	void validateTokenWhenValidShouldNotFetchTokenKeys() throws Exception {
		ReflectionTestUtils.setField(this.tokenValidator, 'tokenKeys', VALID_KEYS);
		given(this.securityService.getUaaUrl()).willReturn('http://localhost:8080/uaa');
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes())));
		then(this.securityService).should(never()).fetchTokenKeys();
	}
	@Test
	void validateTokenWhenSignatureInvalidShouldThrowException() {
		ReflectionTestUtils.setField(this.tokenValidator, 'tokenKeys',
				Collections.singletonMap('valid-key', INVALID_KEY));
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(
					() -> this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.satisfies(reasonRequirement(Reason.INVALID_SIGNATURE));
	}
	@Test
	void validateTokenWhenTokenAlgorithmIsNotRS256ShouldThrowException() {
		String header = '{ \'alg\': \'HS256\',  \'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(
					() -> this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.satisfies(reasonRequirement(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM));
	}
	@Test
	void validateTokenWhenExpiredShouldThrowException() {
		given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);
		given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\', \'typ\': \'JWT\'}';
		String claims = '{ \'jti\': \'0236399c350c47f3ae77e67a75e75e7d\', \'exp\': 1477509977, \'scope\': [\'actuator.read\']}';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(
					() -> this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.satisfies(reasonRequirement(Reason.TOKEN_EXPIRED));
	}
	@Test
	void validateTokenWhenIssuerIsNotValidShouldThrowException() {
		given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);
		given(this.securityService.getUaaUrl()).willReturn('https://other-uaa.com');
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\', \'typ\': \'JWT\', \'scope\': [\'actuator.read\']}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\'}';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(
					() -> this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.satisfies(reasonRequirement(Reason.INVALID_ISSUER));
	}
	@Test
	void validateTokenWhenAudienceIsNotValidShouldThrowException() {
		given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);
		given(this.securityService.getUaaUrl()).willReturn('http://localhost:8080/uaa');
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\', \'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'foo.bar\']}';
		assertThatExceptionOfType(CloudFoundryAuthorizationException.class)
			.isThrownBy(
					() -> this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.satisfies(reasonRequirement(Reason.INVALID_AUDIENCE));
	}
	private String getSignedToken(byte[] header, byte[] claims) throws Exception {
		PrivateKey privateKey = getPrivateKey();
		Signature signature = Signature.getInstance('SHA256WithRSA');
		signature.initSign(privateKey);
		byte[] content = dotConcat(Base64.getUrlEncoder().encode(header), Base64.getEncoder().encode(claims));
		signature.update(content);
		byte[] crypto = signature.sign();
		byte[] token = dotConcat(Base64.getUrlEncoder().encode(header), Base64.getUrlEncoder().encode(claims),
				Base64.getUrlEncoder().encode(crypto));
		return new String(token, StandardCharsets.UTF_8);
	}
	private PrivateKey getPrivateKey() throws InvalidKeySpecException, NoSuchAlgorithmException {
		String signingKey = '''
				-----BEGIN PRIVATE KEY-----
				MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDSbn2Xa72IOcxu
				tcd+qQ6ufZ1VDe98EmpwO4VQrTd37U9kZtWU0KqeSkgnyzIWmlbyWOdbB4/v4uJa
				lGjPQjt9hvd3xOOFXzpj33sWXgMGvGAzopMk64T+7GegOFlDXguA5TZyReM7M51O
				ycYwpAEsKXS+lxcG0UsxpJum/WjOLyHsMnJVnoScVBlRYZ2BMyEOuap69/H3lT/X
				pzlYEM6SrAifsaWvL2f1K7HKBt/yDkDOlZy6xmAMsghnslNSV0FvypTZrQOXia8t
				k6fjA+iN+P0LDZAgKxzn4/B/bV8/6HN/7VZJEdudi/y5qdE7SBnx6QZqCEz/YfqC
				olujacgnAgMBAAECggEAc9X2tJ/OWWrXqinOg160gkELloJxTi8lAFsDbAGuAwpT
				JcWl1KF5CmGBjsY/8ElNi2J9GJL1HOwcBhikCVNARD1DhF6RkB13mvquWwWtTMvt
				eP8JWM19DIc+E+hw2rCuTGngqs7l4vTqpzBTNPtS2eiIJ1IsjsgvSEiAlk/wnW48
				11cf6SQMQcT3HNTWrS+yLycEuWKb6Khh8RpD9D+i8w2+IspWz5lTP7BrKCUNsLOx
				6+5T52HcaZ9z3wMnDqfqIKWl3h8M+q+HFQ4EN5BPWYV4fF7EOx7+Qf2fKDFPoTjC
				VTWzDRNAA1xPqwdF7IdPVOXCdaUJDOhHeXZGaTNSwQKBgQDxb9UiR/Jh1R3muL7I
				neIt1gXa0O+SK7NWYl4DkArYo7V81ztxI8r+xKEeu5zRZZkpaJHxOnd3VfADascw
				UfALvxGxN2z42lE6zdhrmxZ3ma+akQFsv7NyXcBT00sdW+xmOiCaAj0cgxNOXiV3
				sYOwUy3SqUIPO2obpb+KC5ALHwKBgQDfH+NSQ/jn89oVZ3lzUORa+Z+aL1TGsgzs
				p7IG0MTEYiR9/AExYUwJab0M4PDXhumeoACMfkCFALNVhpch2nXZv7X5445yRgfD
				ONY4WknecuA0rfCLTruNWnQ3RR+BXmd9jD/5igd9hEIawz3V+jCHvAtzI8/CZIBt
				AArBs5kp+QKBgQCdxwN1n6baIDemK10iJWtFoPO6h4fH8h8EeMwPb/ZmlLVpnA4Q
				Zd+mlkDkoJ5eiRKKaPfWuOqRZeuvj/wTq7g/NOIO+bWQ+rrSvuqLh5IrHpgPXmub
				8bsHJhUlspMH4KagN6ROgOAG3fGj6Qp7KdpxRCpR3KJ66czxvGNrhxre6QKBgB+s
				MCGiYnfSprd5G8VhyziazKwfYeJerfT+DQhopDXYVKPJnQW8cQW5C8wDNkzx6sHI
				pqtK1K/MnKhcVaHJmAcT7qoNQlA4Xqu4qrgPIQNBvU/dDRNJVthG6c5aspEzrG8m
				9IHgtRV9K8EOy/1O6YqrB9kNUVWf3JccdWpvqyNJAoGAORzJiQCOk4egbdcozDTo
				4Tg4qk/03qpTy5k64DxkX1nJHu8V/hsKwq9Af7Fj/iHy2Av54BLPlBaGPwMi2bzB
				gYjmUomvx/fqOTQks9Rc4PIMB43p6Rdj0sh+52SKPDR2eHbwsmpuQUXnAs20BPPI
				J/OOn5zOs8yf26os0q3+JUM=
				-----END PRIVATE KEY-----''';
		String privateKey = signingKey.replace('-----BEGIN PRIVATE KEY-----\n', '');
		privateKey = privateKey.replace('-----END PRIVATE KEY-----', '');
		privateKey = privateKey.replace('\n', '');
		byte[] pkcs8EncodedBytes = Base64.getDecoder().decode(privateKey);
		PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes);
		KeyFactory keyFactory = KeyFactory.getInstance('RSA');
		return keyFactory.generatePrivate(keySpec);
	}
	private byte[] dotConcat(byte[]... bytes) throws IOException {
		ByteArrayOutputStream result = new ByteArrayOutputStream();
		for (int i = 0; i < bytes.length; i++) {
			if (i > 0) {
				StreamUtils.copy(DOT, result);
			}
			StreamUtils.copy(bytes[i], result);
		}
		return result.toByteArray();
	}
	private Consumer<CloudFoundryAuthorizationException> reasonRequirement(Reason reason) {
		return (ex) -> assertThat(ex.getReason()).isEqualTo(reason);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class SkipSslVerificationHttpRequestFactoryTests {
	private WebServer webServer;
	@AfterEach
	void shutdownContainer() {
		if (this.webServer != null) {
			this.webServer.stop();
		}
	}
	@Test
	void restCallToSelfSignedServerShouldNotThrowSslException() {
		String httpsUrl = getHttpsUrl();
		SkipSslVerificationHttpRequestFactory requestFactory = new SkipSslVerificationHttpRequestFactory();
		RestTemplate restTemplate = new RestTemplate(requestFactory);
		RestTemplate otherRestTemplate = new RestTemplate();
		ResponseEntity<String> responseEntity = restTemplate.getForEntity(httpsUrl, String.class);
		assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThatExceptionOfType(ResourceAccessException.class)
			.isThrownBy(() -> otherRestTemplate.getForEntity(httpsUrl, String.class))
			.withCauseInstanceOf(SSLHandshakeException.class);
	}
	private String getHttpsUrl() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
		factory.setSsl(getSsl('password', 'classpath:test.jks'));
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(), '/hello'));
		this.webServer.start();
		return 'https://localhost:' + this.webServer.getPort() + '/hello';
	}
	private Ssl getSsl(String keyPassword, String keyStore) {
		Ssl ssl = new Ssl();
		ssl.setEnabled(true);
		ssl.setKeyPassword(keyPassword);
		ssl.setKeyStore(keyStore);
		ssl.setKeyStorePassword('secret');
		return ssl;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundryActuatorAutoConfigurationTests {
	private static final String V3_JSON = ApiVersion.V3.getProducedMimeType().toString();
	private static final String BASE_PATH = '/cloudfoundryapplication';
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SecurityAutoConfiguration.class, WebMvcAutoConfiguration.class,
				JacksonAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
				RestTemplateAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				ServletManagementContextAutoConfiguration.class, EndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, CloudFoundryActuatorAutoConfiguration.class));
	@Test
	void cloudFoundryPlatformActive() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context);
				EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils.getField(handlerMapping,
						'endpointMapping');
				assertThat(endpointMapping.getPath()).isEqualTo('/cloudfoundryapplication');
				CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils.getField(handlerMapping,
						'corsConfiguration');
				assertThat(corsConfiguration.getAllowedOrigins()).contains('*');
				assertThat(corsConfiguration.getAllowedMethods())
					.containsAll(Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name()));
				assertThat(corsConfiguration.getAllowedHeaders())
					.containsAll(Arrays.asList('Authorization', 'X-Cf-App-Instance', 'Content-Type'));
			});
	}
	@Test
	void cloudfoundryapplicationProducesActuatorMediaType() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				MockMvcTester mvc = MockMvcTester.from(context);
				assertThat(mvc.get().uri('/cloudfoundryapplication')).hasHeader('Content-Type', V3_JSON);
			});
	}
	@Test
	void cloudFoundryPlatformActiveSetsApplicationId() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context);
				Object interceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				String applicationId = (String) ReflectionTestUtils.getField(interceptor, 'applicationId');
				assertThat(applicationId).isEqualTo('my-app-id');
			});
	}
	@Test
	void cloudFoundryPlatformActiveSetsCloudControllerUrl() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context);
				Object interceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor,
						'cloudFoundrySecurityService');
				String cloudControllerUrl = (String) ReflectionTestUtils.getField(interceptorSecurityService,
						'cloudControllerUrl');
				assertThat(cloudControllerUrl).isEqualTo('https://my-cloud-controller.com');
			});
	}
	@Test
	void skipSslValidation() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com',
					'management.cloudfoundry.skip-ssl-validation:true')
			.run((context) -> {
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context);
				Object interceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor,
						'cloudFoundrySecurityService');
				RestTemplate restTemplate = (RestTemplate) ReflectionTestUtils.getField(interceptorSecurityService,
						'restTemplate');
				assertThat(restTemplate.getRequestFactory()).isInstanceOf(SkipSslVerificationHttpRequestFactory.class);
			});
	}
	@Test
	void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() {
		this.contextRunner.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id')
			.run((context) -> {
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context);
				Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				Object interceptorSecurityService = ReflectionTestUtils.getField(securityInterceptor,
						'cloudFoundrySecurityService');
				assertThat(interceptorSecurityService).isNull();
			});
	}
	@Test
	void cloudFoundryPathsIgnoredBySpringSecurity() {
		this.contextRunner.withBean(TestEndpoint.class, TestEndpoint::new)
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id')
			.run((context) -> {
				SecurityFilterChain chain = getSecurityFilterChain(context);
				assertThat(chain.getFilters()).isEmpty();
				MockHttpServletRequest request = new MockHttpServletRequest();
				testCloudFoundrySecurity(request, BASE_PATH, chain);
				testCloudFoundrySecurity(request, BASE_PATH + '/', chain);
				testCloudFoundrySecurity(request, BASE_PATH + '/test', chain);
				testCloudFoundrySecurity(request, BASE_PATH + '/test/a', chain);
				request.setServletPath(BASE_PATH + '/other-path');
				assertThat(chain.matches(request)).isFalse();
				request.setServletPath('/some-other-path');
				assertThat(chain.matches(request)).isFalse();
			});
	}
	private SecurityFilterChain getSecurityFilterChain(AssertableWebApplicationContext context) {
		Filter springSecurityFilterChain = context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class);
		FilterChainProxy filterChainProxy = getFilterChainProxy(springSecurityFilterChain);
		SecurityFilterChain securityFilterChain = filterChainProxy.getFilterChains().get(0);
		return securityFilterChain;
	}
	private FilterChainProxy getFilterChainProxy(Filter filter) {
		if (filter instanceof FilterChainProxy filterChainProxy) {
			return filterChainProxy;
		}
		if (filter instanceof CompositeFilter) {
			List<?> filters = (List<?>) ReflectionTestUtils.getField(filter, 'filters');
			return (FilterChainProxy) filters.stream()
				.filter(FilterChainProxy.class::isInstance)
				.findFirst()
				.orElseThrow();
		}
		throw new IllegalStateException('No FilterChainProxy found');
	}
	private static void testCloudFoundrySecurity(MockHttpServletRequest request, String servletPath,
			SecurityFilterChain chain) {
		request.setServletPath(servletPath);
		assertThat(chain.matches(request)).isTrue();
	}
	@Test
	void cloudFoundryPlatformInactive() {
		this.contextRunner.withPropertyValues()
			.run((context) -> assertThat(context.containsBean('cloudFoundryWebEndpointServletHandlerMapping'))
				.isFalse());
	}
	@Test
	void cloudFoundryManagementEndpointsDisabled() {
		this.contextRunner.withPropertyValues('VCAP_APPLICATION=---', 'management.cloudfoundry.enabled:false')
			.run((context) -> assertThat(context.containsBean('cloudFoundryEndpointHandlerMapping')).isFalse());
	}
	@Test
	void allEndpointsAvailableUnderCloudFoundryWithoutExposeAllOnWeb() {
		this.contextRunner.withBean(TestEndpoint.class, TestEndpoint::new)
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context);
				Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints();
				assertThat(endpoints.stream()
					.filter((candidate) -> EndpointId.of('test').equals(candidate.getEndpointId()))
					.findFirst()).isNotEmpty();
			});
	}
	@Test
	void endpointPathCustomizationIsNotApplied() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com',
					'management.endpoints.web.path-mapping.test=custom')
			.withBean(TestEndpoint.class, TestEndpoint::new)
			.run((context) -> {
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context);
				Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints();
				ExposableWebEndpoint endpoint = endpoints.stream()
					.filter((candidate) -> EndpointId.of('test').equals(candidate.getEndpointId()))
					.findFirst()
					.get();
				Collection<WebOperation> operations = endpoint.getOperations();
				assertThat(operations).hasSize(1);
				assertThat(operations.iterator().next().getRequestPredicate().getPath()).isEqualTo('test');
			});
	}
	@Test
	void healthEndpointInvokerShouldBeCloudFoundryWebExtension() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.withConfiguration(AutoConfigurations.of(HealthContributorAutoConfiguration.class,
					HealthEndpointAutoConfiguration.class))
			.run((context) -> {
				Collection<ExposableWebEndpoint> endpoints = context
					.getBean('cloudFoundryWebEndpointServletHandlerMapping',
							CloudFoundryWebEndpointServletHandlerMapping.class)
					.getEndpoints();
				ExposableWebEndpoint endpoint = endpoints.iterator().next();
				assertThat(endpoint.getOperations()).hasSize(2);
				WebOperation webOperation = findOperationWithRequestPath(endpoint, 'health');
				assertThat(webOperation).extracting('invoker.target')
					.isInstanceOf(CloudFoundryHealthEndpointWebExtension.class);
			});
	}
	private CloudFoundryWebEndpointServletHandlerMapping getHandlerMapping(ApplicationContext context) {
		return context.getBean('cloudFoundryWebEndpointServletHandlerMapping',
				CloudFoundryWebEndpointServletHandlerMapping.class);
	}
	private WebOperation findOperationWithRequestPath(ExposableWebEndpoint endpoint, String requestPath) {
		for (WebOperation operation : endpoint.getOperations()) {
			WebOperationRequestPredicate predicate = operation.getRequestPredicate();
			if (predicate.getPath().equals(requestPath) && predicate.getProduces().contains(V3_JSON)) {
				return operation;
			}
		}
		throw new IllegalStateException(
				'No operation found with request path ' + requestPath + ' from ' + endpoint.getOperations());
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		@ReadOperation
		String hello() {
			return 'hello world';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundryHealthEndpointWebExtensionTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withPropertyValues('VCAP_APPLICATION={}')
		.withConfiguration(AutoConfigurations.of(SecurityAutoConfiguration.class, WebMvcAutoConfiguration.class,
				JacksonAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
				RestTemplateAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				ServletManagementContextAutoConfiguration.class, EndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, HealthContributorAutoConfiguration.class,
				HealthEndpointAutoConfiguration.class, CloudFoundryActuatorAutoConfiguration.class))
		.withUserConfiguration(TestHealthIndicator.class);
	@Test
	void healthComponentsAlwaysPresent() {
		this.contextRunner.run((context) -> {
			CloudFoundryHealthEndpointWebExtension extension = context
				.getBean(CloudFoundryHealthEndpointWebExtension.class);
			HealthComponent body = extension.health(ApiVersion.V3).getBody();
			HealthComponent health = ((CompositeHealth) body).getComponents().entrySet().iterator().next().getValue();
			assertThat(((Health) health).getDetails()).containsEntry('spring', 'boot');
		});
	}
	private static final class TestHealthIndicator implements HealthIndicator {
		@Override
		public Health health() {
			return Health.up().withDetail('spring', 'boot').build();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
class CloudFoundryAuthorizationExceptionTests {
	@Test
	void statusCodeForInvalidTokenReasonShouldBe401() {
		assertThat(createException(Reason.INVALID_TOKEN).getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void statusCodeForInvalidIssuerReasonShouldBe401() {
		assertThat(createException(Reason.INVALID_ISSUER).getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void statusCodeForInvalidAudienceReasonShouldBe401() {
		assertThat(createException(Reason.INVALID_AUDIENCE).getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void statusCodeForInvalidSignatureReasonShouldBe401() {
		assertThat(createException(Reason.INVALID_SIGNATURE).getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void statusCodeForMissingAuthorizationReasonShouldBe401() {
		assertThat(createException(Reason.MISSING_AUTHORIZATION).getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void statusCodeForUnsupportedSignatureAlgorithmReasonShouldBe401() {
		assertThat(createException(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM).getStatusCode())
			.isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void statusCodeForTokenExpiredReasonShouldBe401() {
		assertThat(createException(Reason.TOKEN_EXPIRED).getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void statusCodeForAccessDeniedReasonShouldBe403() {
		assertThat(createException(Reason.ACCESS_DENIED).getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void statusCodeForServiceUnavailableReasonShouldBe503() {
		assertThat(createException(Reason.SERVICE_UNAVAILABLE).getStatusCode())
			.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE);
	}
	private CloudFoundryAuthorizationException createException(Reason reason) {
		return new CloudFoundryAuthorizationException(reason, 'message');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class CloudFoundryReactiveHealthEndpointWebExtensionTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withPropertyValues('VCAP_APPLICATION={}')
		.withConfiguration(AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class,
				WebFluxAutoConfiguration.class, JacksonAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
				ReactiveCloudFoundryActuatorAutoConfigurationTests.WebClientCustomizerConfig.class,
				WebClientAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
				HealthContributorAutoConfiguration.class, HealthEndpointAutoConfiguration.class,
				ReactiveCloudFoundryActuatorAutoConfiguration.class))
		.withUserConfiguration(TestHealthIndicator.class, UserDetailsServiceConfiguration.class);
	@Test
	void healthComponentsAlwaysPresent() {
		this.contextRunner.run((context) -> {
			CloudFoundryReactiveHealthEndpointWebExtension extension = context
				.getBean(CloudFoundryReactiveHealthEndpointWebExtension.class);
			HealthComponent body = extension.health(ApiVersion.V3).block(Duration.ofSeconds(30)).getBody();
			HealthComponent health = ((CompositeHealth) body).getComponents().entrySet().iterator().next().getValue();
			assertThat(((Health) health).getDetails()).containsEntry('spring', 'boot');
		});
	}
	private static final class TestHealthIndicator implements HealthIndicator {
		@Override
		public Health health() {
			return Health.up().withDetail('spring', 'boot').build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDetailsServiceConfiguration {
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			return new MapReactiveUserDetailsService(
					User.withUsername('alice').password('secret').roles('admin').build());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
@ExtendWith(MockitoExtension.class)
class ReactiveCloudFoundrySecurityInterceptorTests {
	@Mock
	private ReactiveTokenValidator tokenValidator;
	@Mock
	private ReactiveCloudFoundrySecurityService securityService;
	private CloudFoundrySecurityInterceptor interceptor;
	@BeforeEach
	void setup() {
		this.interceptor = new CloudFoundrySecurityInterceptor(this.tokenValidator, this.securityService, 'my-app-id');
	}
	@Test
	void preHandleWhenRequestIsPreFlightShouldBeOk() {
		MockServerWebExchange request = MockServerWebExchange.from(MockServerHttpRequest.options('/a')
			.header(HttpHeaders.ORIGIN, 'https://example.com')
			.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
			.build());
		StepVerifier.create(this.interceptor.preHandle(request, '/a'))
			.consumeNextWith((response) -> assertThat(response.getStatus()).isEqualTo(HttpStatus.OK))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void preHandleWhenTokenIsMissingShouldReturnMissingAuthorization() {
		MockServerWebExchange request = MockServerWebExchange.from(MockServerHttpRequest.get('/a').build());
		StepVerifier.create(this.interceptor.preHandle(request, '/a'))
			.consumeNextWith(
					(response) -> assertThat(response.getStatus()).isEqualTo(Reason.MISSING_AUTHORIZATION.getStatus()))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void preHandleWhenTokenIsNotBearerShouldReturnMissingAuthorization() {
		MockServerWebExchange request = MockServerWebExchange
			.from(MockServerHttpRequest.get('/a').header(HttpHeaders.AUTHORIZATION, mockAccessToken()).build());
		StepVerifier.create(this.interceptor.preHandle(request, '/a'))
			.consumeNextWith(
					(response) -> assertThat(response.getStatus()).isEqualTo(Reason.MISSING_AUTHORIZATION.getStatus()))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void preHandleWhenApplicationIdIsNullShouldReturnError() {
		this.interceptor = new CloudFoundrySecurityInterceptor(this.tokenValidator, this.securityService, null);
		MockServerWebExchange request = MockServerWebExchange.from(MockServerHttpRequest.get('/a')
			.header(HttpHeaders.AUTHORIZATION, 'bearer ' + mockAccessToken())
			.build());
		StepVerifier.create(this.interceptor.preHandle(request, '/a'))
			.consumeErrorWith((ex) -> assertThat(((CloudFoundryAuthorizationException) ex).getReason())
				.isEqualTo(Reason.SERVICE_UNAVAILABLE))
			.verify();
	}
	@Test
	void preHandleWhenCloudFoundrySecurityServiceIsNullShouldReturnError() {
		this.interceptor = new CloudFoundrySecurityInterceptor(this.tokenValidator, null, 'my-app-id');
		MockServerWebExchange request = MockServerWebExchange
			.from(MockServerHttpRequest.get('/a').header(HttpHeaders.AUTHORIZATION, mockAccessToken()).build());
		StepVerifier.create(this.interceptor.preHandle(request, '/a'))
			.consumeErrorWith((ex) -> assertThat(((CloudFoundryAuthorizationException) ex).getReason())
				.isEqualTo(Reason.SERVICE_UNAVAILABLE))
			.verify();
	}
	@Test
	void preHandleWhenAccessIsNotAllowedShouldReturnAccessDenied() {
		given(this.securityService.getAccessLevel(mockAccessToken(), 'my-app-id'))
			.willReturn(Mono.just(AccessLevel.RESTRICTED));
		given(this.tokenValidator.validate(any())).willReturn(Mono.empty());
		MockServerWebExchange request = MockServerWebExchange.from(MockServerHttpRequest.get('/a')
			.header(HttpHeaders.AUTHORIZATION, 'bearer ' + mockAccessToken())
			.build());
		StepVerifier.create(this.interceptor.preHandle(request, '/a'))
			.consumeNextWith((response) -> assertThat(response.getStatus()).isEqualTo(Reason.ACCESS_DENIED.getStatus()))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
	@Test
	void preHandleSuccessfulWithFullAccess() {
		String accessToken = mockAccessToken();
		given(this.securityService.getAccessLevel(accessToken, 'my-app-id')).willReturn(Mono.just(AccessLevel.FULL));
		given(this.tokenValidator.validate(any())).willReturn(Mono.empty());
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get('/a')
			.header(HttpHeaders.AUTHORIZATION, 'bearer ' + mockAccessToken())
			.build());
		StepVerifier.create(this.interceptor.preHandle(exchange, '/a')).consumeNextWith((response) -> {
			assertThat(response.getStatus()).isEqualTo(HttpStatus.OK);
			assertThat((AccessLevel) exchange.getAttribute('cloudFoundryAccessLevel')).isEqualTo(AccessLevel.FULL);
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void preHandleSuccessfulWithRestrictedAccess() {
		String accessToken = mockAccessToken();
		given(this.securityService.getAccessLevel(accessToken, 'my-app-id'))
			.willReturn(Mono.just(AccessLevel.RESTRICTED));
		given(this.tokenValidator.validate(any())).willReturn(Mono.empty());
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get('/info')
			.header(HttpHeaders.AUTHORIZATION, 'bearer ' + mockAccessToken())
			.build());
		StepVerifier.create(this.interceptor.preHandle(exchange, 'info')).consumeNextWith((response) -> {
			assertThat(response.getStatus()).isEqualTo(HttpStatus.OK);
			assertThat((AccessLevel) exchange.getAttribute('cloudFoundryAccessLevel'))
				.isEqualTo(AccessLevel.RESTRICTED);
		}).expectComplete().verify(Duration.ofSeconds(30));
	}
	private String mockAccessToken() {
		return 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ0b3B0YWwu'
				+ 'Y29tIiwiZXhwIjoxNDI2NDIwODAwLCJhd2Vzb21lIjp0cnVlfQ.'
				+ Base64.getEncoder().encodeToString('signature'.getBytes());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class ReactiveCloudFoundryActuatorAutoConfigurationTests {
	private static final String V2_JSON = ApiVersion.V2.getProducedMimeType().toString();
	private static final String V3_JSON = ApiVersion.V3.getProducedMimeType().toString();
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class, WebFluxAutoConfiguration.class,
						JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
						PropertyPlaceholderAutoConfiguration.class, WebClientCustomizerConfig.class,
						WebClientAutoConfiguration.class, ManagementContextAutoConfiguration.class,
						EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
						HealthContributorAutoConfiguration.class, HealthEndpointAutoConfiguration.class,
						InfoContributorAutoConfiguration.class, InfoEndpointAutoConfiguration.class,
						ProjectInfoAutoConfiguration.class, ReactiveCloudFoundryActuatorAutoConfiguration.class))
		.withUserConfiguration(UserDetailsServiceConfiguration.class);
	private static final String BASE_PATH = '/cloudfoundryapplication';
	@AfterEach
	void close() {
		HttpResources.reset();
	}
	@Test
	void cloudFoundryPlatformActive() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context);
				EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils.getField(handlerMapping,
						'endpointMapping');
				assertThat(endpointMapping.getPath()).isEqualTo('/cloudfoundryapplication');
				CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils.getField(handlerMapping,
						'corsConfiguration');
				assertThat(corsConfiguration.getAllowedOrigins()).contains('*');
				assertThat(corsConfiguration.getAllowedMethods())
					.containsAll(Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name()));
				assertThat(corsConfiguration.getAllowedHeaders())
					.containsAll(Arrays.asList('Authorization', 'X-Cf-App-Instance', 'Content-Type'));
			});
	}
	@Test
	void cloudfoundryapplicationProducesActuatorMediaType() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				WebTestClient webTestClient = WebTestClient.bindToApplicationContext(context).build();
				webTestClient.get().uri('/cloudfoundryapplication').header('Content-Type', V2_JSON + ';charset=UTF-8');
			});
	}
	@Test
	void cloudFoundryPlatformActiveSetsApplicationId() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context);
				Object interceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				String applicationId = (String) ReflectionTestUtils.getField(interceptor, 'applicationId');
				assertThat(applicationId).isEqualTo('my-app-id');
			});
	}
	@Test
	void cloudFoundryPlatformActiveSetsCloudControllerUrl() {
		this.contextRunner
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context);
				Object interceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor,
						'cloudFoundrySecurityService');
				String cloudControllerUrl = (String) ReflectionTestUtils.getField(interceptorSecurityService,
						'cloudControllerUrl');
				assertThat(cloudControllerUrl).isEqualTo('https://my-cloud-controller.com');
			});
	}
	@Test
	void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() {
		this.contextRunner.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = context.getBean(
						'cloudFoundryWebFluxEndpointHandlerMapping', CloudFoundryWebFluxEndpointHandlerMapping.class);
				Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				Object interceptorSecurityService = ReflectionTestUtils.getField(securityInterceptor,
						'cloudFoundrySecurityService');
				assertThat(interceptorSecurityService).isNull();
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void cloudFoundryPathsIgnoredBySpringSecurity() {
		this.contextRunner.withBean(TestEndpoint.class, TestEndpoint::new)
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				WebFilterChainProxy chainProxy = context.getBean(WebFilterChainProxy.class);
				List<SecurityWebFilterChain> filters = (List<SecurityWebFilterChain>) ReflectionTestUtils
					.getField(chainProxy, 'filters');
				Boolean cfBaseRequestMatches = getMatches(filters, BASE_PATH);
				Boolean cfBaseWithTrailingSlashRequestMatches = getMatches(filters, BASE_PATH + '/');
				Boolean cfRequestMatches = getMatches(filters, BASE_PATH + '/test');
				Boolean cfRequestWithAdditionalPathMatches = getMatches(filters, BASE_PATH + '/test/a');
				Boolean otherCfRequestMatches = getMatches(filters, BASE_PATH + '/other-path');
				Boolean otherRequestMatches = getMatches(filters, '/some-other-path');
				assertThat(cfBaseRequestMatches).isTrue();
				assertThat(cfBaseWithTrailingSlashRequestMatches).isTrue();
				assertThat(cfRequestMatches).isTrue();
				assertThat(cfRequestWithAdditionalPathMatches).isTrue();
				assertThat(otherCfRequestMatches).isFalse();
				assertThat(otherRequestMatches).isFalse();
				otherRequestMatches = filters.get(1)
					.matches(MockServerWebExchange.from(MockServerHttpRequest.get('/some-other-path').build()))
					.block(Duration.ofSeconds(30));
				assertThat(otherRequestMatches).isTrue();
			});
	}
	private static Boolean getMatches(List<SecurityWebFilterChain> filters, String urlTemplate) {
		return filters.get(0)
			.matches(MockServerWebExchange.from(MockServerHttpRequest.get(urlTemplate).build()))
			.block(Duration.ofSeconds(30));
	}
	@Test
	void cloudFoundryPlatformInactive() {
		this.contextRunner
			.run((context) -> assertThat(context.containsBean('cloudFoundryWebFluxEndpointHandlerMapping')).isFalse());
	}
	@Test
	void cloudFoundryManagementEndpointsDisabled() {
		this.contextRunner.withPropertyValues('VCAP_APPLICATION=---', 'management.cloudfoundry.enabled:false')
			.run((context) -> assertThat(context.containsBean('cloudFoundryWebFluxEndpointHandlerMapping')).isFalse());
	}
	@Test
	void allEndpointsAvailableUnderCloudFoundryWithoutEnablingWebIncludes() {
		this.contextRunner.withBean(TestEndpoint.class, TestEndpoint::new)
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context);
				Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints();
				List<EndpointId> endpointIds = endpoints.stream().map(ExposableWebEndpoint::getEndpointId).toList();
				assertThat(endpointIds).contains(EndpointId.of('test'));
			});
	}
	@Test
	void endpointPathCustomizationIsNotApplied() {
		this.contextRunner.withBean(TestEndpoint.class, TestEndpoint::new)
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context);
				Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints();
				ExposableWebEndpoint endpoint = endpoints.stream()
					.filter((candidate) -> EndpointId.of('test').equals(candidate.getEndpointId()))
					.findFirst()
					.get();
				assertThat(endpoint.getOperations()).hasSize(1);
				WebOperation operation = endpoint.getOperations().iterator().next();
				assertThat(operation.getRequestPredicate().getPath()).isEqualTo('test');
			});
	}
	@Test
	void healthEndpointInvokerShouldBeCloudFoundryWebExtension() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class))
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				Collection<ExposableWebEndpoint> endpoints = getHandlerMapping(context).getEndpoints();
				ExposableWebEndpoint endpoint = endpoints.iterator().next();
				assertThat(endpoint.getOperations()).hasSize(2);
				WebOperation webOperation = findOperationWithRequestPath(endpoint, 'health');
				assertThat(webOperation).extracting('invoker')
					.extracting('target')
					.isInstanceOf(CloudFoundryReactiveHealthEndpointWebExtension.class);
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void gitFullDetailsAlwaysPresent() {
		this.contextRunner.withPropertyValues('VCAP_APPLICATION:---').run((context) -> {
			CloudFoundryInfoEndpointWebExtension extension = context
				.getBean(CloudFoundryInfoEndpointWebExtension.class);
			Map<String, Object> git = (Map<String, Object>) extension.info().get('git');
			Map<String, Object> commit = (Map<String, Object>) git.get('commit');
			assertThat(commit).hasSize(4);
		});
	}
	@Test
	void skipSslValidation() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class))
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com',
					'management.cloudfoundry.skip-ssl-validation:true')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context);
				Object interceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor,
						'cloudFoundrySecurityService');
				WebClient webClient = (WebClient) ReflectionTestUtils.getField(interceptorSecurityService, 'webClient');
				webClient.get()
					.uri('https://self-signed.badssl.com/')
					.retrieve()
					.toBodilessEntity()
					.block(Duration.ofSeconds(30));
			});
	}
	@Test
	void sslValidationNotSkippedByDefault() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class))
			.withPropertyValues('VCAP_APPLICATION:---', 'vcap.application.application_id:my-app-id',
					'vcap.application.cf_api:https://my-cloud-controller.com')
			.run((context) -> {
				CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context);
				Object interceptor = ReflectionTestUtils.getField(handlerMapping, 'securityInterceptor');
				Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor,
						'cloudFoundrySecurityService');
				WebClient webClient = (WebClient) ReflectionTestUtils.getField(interceptorSecurityService, 'webClient');
				assertThatExceptionOfType(RuntimeException.class)
					.isThrownBy(() -> webClient.get()
						.uri('https://self-signed.badssl.com/')
						.retrieve()
						.toBodilessEntity()
						.block(Duration.ofSeconds(30)))
					.withCauseInstanceOf(SSLException.class);
			});
	}
	private CloudFoundryWebFluxEndpointHandlerMapping getHandlerMapping(ApplicationContext context) {
		return context.getBean('cloudFoundryWebFluxEndpointHandlerMapping',
				CloudFoundryWebFluxEndpointHandlerMapping.class);
	}
	private WebOperation findOperationWithRequestPath(ExposableWebEndpoint endpoint, String requestPath) {
		for (WebOperation operation : endpoint.getOperations()) {
			WebOperationRequestPredicate predicate = operation.getRequestPredicate();
			if (predicate.getPath().equals(requestPath) && predicate.getProduces().contains(V3_JSON)) {
				return operation;
			}
		}
		throw new IllegalStateException(
				'No operation found with request path ' + requestPath + ' from ' + endpoint.getOperations());
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		@ReadOperation
		String hello() {
			return 'hello world';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebClientCustomizerConfig {
		@Bean
		WebClientCustomizer webClientCustomizer() {
			return mock(WebClientCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDetailsServiceConfiguration {
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			return new MapReactiveUserDetailsService(
					User.withUsername('alice').password('secret').roles('admin').build());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class ReactiveCloudFoundrySecurityServiceTests {
	private static final String CLOUD_CONTROLLER = '/my-cloud-controller.com';
	private static final String CLOUD_CONTROLLER_PERMISSIONS = CLOUD_CONTROLLER + '/v2/apps/my-app-id/permissions';
	private static final String UAA_URL = 'https://my-cloud-controller.com/uaa';
	private ReactiveCloudFoundrySecurityService securityService;
	private MockWebServer server;
	@BeforeEach
	void setup() {
		this.server = new MockWebServer();
		WebClient.Builder builder = WebClient.builder().baseUrl(this.server.url('/').toString());
		this.securityService = new ReactiveCloudFoundrySecurityService(builder, CLOUD_CONTROLLER, false);
	}
	@AfterEach
	void shutdown() throws Exception {
		this.server.shutdown();
	}
	@Test
	void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception {
		String responseBody = '{\'read_sensitive_data\': true,\'read_basic_data\': true}';
		prepareResponse((response) -> response.setBody(responseBody).setHeader('Content-Type', 'application/json'));
		StepVerifier.create(this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.consumeNextWith((accessLevel) -> assertThat(accessLevel).isEqualTo(AccessLevel.FULL))
			.expectComplete()
			.verify();
		expectRequest((request) -> {
			assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)).isEqualTo('bearer my-access-token');
			assertThat(request.getPath()).isEqualTo(CLOUD_CONTROLLER_PERMISSIONS);
		});
	}
	@Test
	void getAccessLevelWhenNotSpaceDeveloperShouldReturnRestricted() throws Exception {
		String responseBody = '{\'read_sensitive_data\': false,\'read_basic_data\': true}';
		prepareResponse((response) -> response.setBody(responseBody).setHeader('Content-Type', 'application/json'));
		StepVerifier.create(this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.consumeNextWith((accessLevel) -> assertThat(accessLevel).isEqualTo(AccessLevel.RESTRICTED))
			.expectComplete()
			.verify();
		expectRequest((request) -> {
			assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)).isEqualTo('bearer my-access-token');
			assertThat(request.getPath()).isEqualTo(CLOUD_CONTROLLER_PERMISSIONS);
		});
	}
	@Test
	void getAccessLevelWhenTokenIsNotValidShouldThrowException() throws Exception {
		prepareResponse((response) -> response.setResponseCode(401));
		StepVerifier.create(this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.consumeErrorWith((throwable) -> {
				assertThat(throwable).isInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) throwable).getReason())
					.isEqualTo(Reason.INVALID_TOKEN);
			})
			.verify();
		expectRequest((request) -> {
			assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)).isEqualTo('bearer my-access-token');
			assertThat(request.getPath()).isEqualTo(CLOUD_CONTROLLER_PERMISSIONS);
		});
	}
	@Test
	void getAccessLevelWhenForbiddenShouldThrowException() throws Exception {
		prepareResponse((response) -> response.setResponseCode(403));
		StepVerifier.create(this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.consumeErrorWith((throwable) -> {
				assertThat(throwable).isInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) throwable).getReason())
					.isEqualTo(Reason.ACCESS_DENIED);
			})
			.verify();
		expectRequest((request) -> {
			assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)).isEqualTo('bearer my-access-token');
			assertThat(request.getPath()).isEqualTo(CLOUD_CONTROLLER_PERMISSIONS);
		});
	}
	@Test
	void getAccessLevelWhenCloudControllerIsNotReachableThrowsException() throws Exception {
		prepareResponse((response) -> response.setResponseCode(500));
		StepVerifier.create(this.securityService.getAccessLevel('my-access-token', 'my-app-id'))
			.consumeErrorWith((throwable) -> {
				assertThat(throwable).isInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) throwable).getReason())
					.isEqualTo(Reason.SERVICE_UNAVAILABLE);
			})
			.verify();
		expectRequest((request) -> {
			assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)).isEqualTo('bearer my-access-token');
			assertThat(request.getPath()).isEqualTo(CLOUD_CONTROLLER_PERMISSIONS);
		});
	}
	@Test
	void fetchTokenKeysWhenSuccessfulShouldReturnListOfKeysFromUAA() throws Exception {
		String tokenKeyValue = '''
				-----BEGIN PUBLIC KEY-----
				MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0m59l2u9iDnMbrXHfqkO
				rn2dVQ3vfBJqcDuFUK03d+1PZGbVlNCqnkpIJ8syFppW8ljnWweP7+LiWpRoz0I7
				fYb3d8TjhV86Y997Fl4DBrxgM6KTJOuE/uxnoDhZQ14LgOU2ckXjOzOdTsnGMKQB
				LCl0vpcXBtFLMaSbpv1ozi8h7DJyVZ6EnFQZUWGdgTMhDrmqevfx95U/16c5WBDO
				kqwIn7Glry9n9Suxygbf8g5AzpWcusZgDLIIZ7JTUldBb8qU2a0Dl4mvLZOn4wPo
				jfj9Cw2QICsc5+Pwf21fP+hzf+1WSRHbnYv8uanRO0gZ8ekGaghM/2H6gqJbo2nI
				JwIDAQAB
				-----END PUBLIC KEY-----''';
		prepareResponse((response) -> {
			response.setBody('{\'token_endpoint\':\'/my-uaa.com\'}');
			response.setHeader('Content-Type', 'application/json');
		});
		String responseBody = '{\'keys\' : [ {\'kid\':\'test-key\',\'value\' : \'' + tokenKeyValue.replace('\n', '\\n')
				+ '\'} ]}';
		prepareResponse((response) -> {
			response.setBody(responseBody);
			response.setHeader('Content-Type', 'application/json');
		});
		StepVerifier.create(this.securityService.fetchTokenKeys())
			.consumeNextWith((tokenKeys) -> assertThat(tokenKeys.get('test-key')).isEqualTo(tokenKeyValue))
			.expectComplete()
			.verify();
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo('/my-cloud-controller.com/info'));
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo('/my-uaa.com/token_keys'));
	}
	@Test
	void fetchTokenKeysWhenNoKeysReturnedFromUAA() throws Exception {
		prepareResponse((response) -> {
			response.setBody('{\'token_endpoint\':\'/my-uaa.com\'}');
			response.setHeader('Content-Type', 'application/json');
		});
		String responseBody = '{\'keys\': []}';
		prepareResponse((response) -> {
			response.setBody(responseBody);
			response.setHeader('Content-Type', 'application/json');
		});
		StepVerifier.create(this.securityService.fetchTokenKeys())
			.consumeNextWith((tokenKeys) -> assertThat(tokenKeys).isEmpty())
			.expectComplete()
			.verify();
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo('/my-cloud-controller.com/info'));
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo('/my-uaa.com/token_keys'));
	}
	@Test
	void fetchTokenKeysWhenUnsuccessfulShouldThrowException() throws Exception {
		prepareResponse((response) -> {
			response.setBody('{\'token_endpoint\':\'/my-uaa.com\'}');
			response.setHeader('Content-Type', 'application/json');
		});
		prepareResponse((response) -> response.setResponseCode(500));
		StepVerifier.create(this.securityService.fetchTokenKeys())
			.consumeErrorWith((throwable) -> assertThat(((CloudFoundryAuthorizationException) throwable).getReason())
				.isEqualTo(Reason.SERVICE_UNAVAILABLE))
			.verify();
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo('/my-cloud-controller.com/info'));
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo('/my-uaa.com/token_keys'));
	}
	@Test
	void getUaaUrlShouldCallCloudControllerInfoOnlyOnce() throws Exception {
		prepareResponse((response) -> {
			response.setBody('{\'token_endpoint\':\'' + UAA_URL + '\'}');
			response.setHeader('Content-Type', 'application/json');
		});
		StepVerifier.create(this.securityService.getUaaUrl())
			.consumeNextWith((uaaUrl) -> assertThat(uaaUrl).isEqualTo(UAA_URL))
			.expectComplete()
			.verify();
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo(CLOUD_CONTROLLER + '/info'));
		expectRequestCount(1);
	}
	@Test
	void getUaaUrlWhenCloudControllerUrlIsNotReachableShouldThrowException() throws Exception {
		prepareResponse((response) -> response.setResponseCode(500));
		StepVerifier.create(this.securityService.getUaaUrl()).consumeErrorWith((throwable) -> {
			assertThat(throwable).isInstanceOf(CloudFoundryAuthorizationException.class);
			assertThat(((CloudFoundryAuthorizationException) throwable).getReason())
				.isEqualTo(Reason.SERVICE_UNAVAILABLE);
		}).verify();
		expectRequest((request) -> assertThat(request.getPath()).isEqualTo(CLOUD_CONTROLLER + '/info'));
	}
	private void prepareResponse(Consumer<MockResponse> consumer) {
		MockResponse response = new MockResponse();
		consumer.accept(response);
		this.server.enqueue(response);
	}
	private void expectRequest(Consumer<RecordedRequest> consumer) throws InterruptedException {
		consumer.accept(this.server.takeRequest());
	}
	private void expectRequestCount(int count) {
		assertThat(count).isEqualTo(this.server.getRequestCount());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
@ExtendWith(MockitoExtension.class)
class ReactiveTokenValidatorTests {
	private static final byte[] DOT = '.'.getBytes();
	@Mock
	private ReactiveCloudFoundrySecurityService securityService;
	private ReactiveTokenValidator tokenValidator;
	private static final String VALID_KEY = '''
			-----BEGIN PUBLIC KEY-----
			MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0m59l2u9iDnMbrXHfqkO
			rn2dVQ3vfBJqcDuFUK03d+1PZGbVlNCqnkpIJ8syFppW8ljnWweP7+LiWpRoz0I7
			fYb3d8TjhV86Y997Fl4DBrxgM6KTJOuE/uxnoDhZQ14LgOU2ckXjOzOdTsnGMKQB
			LCl0vpcXBtFLMaSbpv1ozi8h7DJyVZ6EnFQZUWGdgTMhDrmqevfx95U/16c5WBDO
			kqwIn7Glry9n9Suxygbf8g5AzpWcusZgDLIIZ7JTUldBb8qU2a0Dl4mvLZOn4wPo
			jfj9Cw2QICsc5+Pwf21fP+hzf+1WSRHbnYv8uanRO0gZ8ekGaghM/2H6gqJbo2nI
			JwIDAQAB
			-----END PUBLIC KEY-----''';
	private static final String INVALID_KEY = '''
			-----BEGIN PUBLIC KEY-----
			MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxzYuc22QSst/dS7geYYK
			5l5kLxU0tayNdixkEQ17ix+CUcUbKIsnyftZxaCYT46rQtXgCaYRdJcbB3hmyrOa
			vkhTpX79xJZnQmfuamMbZBqitvscxW9zRR9tBUL6vdi/0rpoUwPMEh8+Bw7CgYR0
			FK0DhWYBNDfe9HKcyZEv3max8Cdq18htxjEsdYO0iwzhtKRXomBWTdhD5ykd/fAC
			VTr4+KEY+IeLvubHVmLUhbE5NgWXxrRpGasDqzKhCTmsa2Ysf712rl57SlH0Wz/M
			r3F7aM9YpErzeYLrl0GhQr9BVJxOvXcVd4kmY+XkiCcrkyS1cnghnllh+LCwQu1s
			YwIDAQAB
			-----END PUBLIC KEY-----''';
	private static final Map<String, String> INVALID_KEYS = new ConcurrentHashMap<>();
	private static final Map<String, String> VALID_KEYS = new ConcurrentHashMap<>();
	@BeforeEach
	void setup() {
		VALID_KEYS.put('valid-key', VALID_KEY);
		INVALID_KEYS.put('invalid-key', INVALID_KEY);
		this.tokenValidator = new ReactiveTokenValidator(this.securityService);
	}
	@Test
	void validateTokenWhenKidValidationFailsTwiceShouldThrowException() throws Exception {
		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));
		ReflectionTestUtils.setField(this.tokenValidator, 'cachedTokenKeys', VALID_KEYS);
		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{\'alg\': \'RS256\',  \'kid\': \'invalid-key\',\'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.consumeErrorWith((ex) -> {
				assertThat(ex).isExactlyInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) ex).getReason()).isEqualTo(Reason.INVALID_KEY_ID);
			})
			.verify();
		assertThat(this.tokenValidator).hasFieldOrPropertyWithValue('cachedTokenKeys', VALID_KEYS);
		fetchTokenKeys.assertWasSubscribed();
	}
	@Test
	void validateTokenWhenKidValidationSucceedsInTheSecondAttempt() throws Exception {
		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));
		ReflectionTestUtils.setField(this.tokenValidator, 'cachedTokenKeys', INVALID_KEYS);
		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{\'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		assertThat(this.tokenValidator).hasFieldOrPropertyWithValue('cachedTokenKeys', VALID_KEYS);
		fetchTokenKeys.assertWasSubscribed();
	}
	@Test
	void validateTokenWhenCacheIsEmptyShouldFetchTokenKeys() throws Exception {
		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));
		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{\'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		assertThat(this.tokenValidator).hasFieldOrPropertyWithValue('cachedTokenKeys', VALID_KEYS);
		fetchTokenKeys.assertWasSubscribed();
	}
	@Test
	void validateTokenWhenCacheEmptyAndInvalidKeyShouldThrowException() throws Exception {
		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.of(Mono.just(VALID_KEYS));
		given(this.securityService.fetchTokenKeys()).willReturn(fetchTokenKeys.mono());
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{\'alg\': \'RS256\',  \'kid\': \'invalid-key\',\'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.consumeErrorWith((ex) -> {
				assertThat(ex).isExactlyInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) ex).getReason()).isEqualTo(Reason.INVALID_KEY_ID);
			})
			.verify();
		assertThat(this.tokenValidator).hasFieldOrPropertyWithValue('cachedTokenKeys', VALID_KEYS);
		fetchTokenKeys.assertWasSubscribed();
	}
	@Test
	void validateTokenWhenCacheValidShouldNotFetchTokenKeys() throws Exception {
		PublisherProbe<Map<String, String>> fetchTokenKeys = PublisherProbe.empty();
		ReflectionTestUtils.setField(this.tokenValidator, 'cachedTokenKeys', VALID_KEYS);
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{\'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{\'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		fetchTokenKeys.assertWasNotSubscribed();
	}
	@Test
	void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception {
		Map<String, String> KEYS = Collections.singletonMap('valid-key', INVALID_KEY);
		given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(KEYS));
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\',\'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.consumeErrorWith((ex) -> {
				assertThat(ex).isExactlyInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) ex).getReason()).isEqualTo(Reason.INVALID_SIGNATURE);
			})
			.verify();
	}
	@Test
	void validateTokenWhenTokenAlgorithmIsNotRS256ShouldThrowException() throws Exception {
		given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{ \'alg\': \'HS256\',  \'kid\': \'valid-key\', \'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.consumeErrorWith((ex) -> {
				assertThat(ex).isExactlyInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) ex).getReason())
					.isEqualTo(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM);
			})
			.verify();
	}
	@Test
	void validateTokenWhenExpiredShouldThrowException() throws Exception {
		given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\', \'typ\': \'JWT\'}';
		String claims = '{ \'jti\': \'0236399c350c47f3ae77e67a75e75e7d\', \'exp\': 1477509977, \'scope\': [\'actuator.read\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.consumeErrorWith((ex) -> {
				assertThat(ex).isExactlyInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) ex).getReason()).isEqualTo(Reason.TOKEN_EXPIRED);
			})
			.verify();
	}
	@Test
	void validateTokenWhenIssuerIsNotValidShouldThrowException() throws Exception {
		given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('https://other-uaa.com'));
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\', \'typ\': \'JWT\', \'scope\': [\'actuator.read\']}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'foo.bar\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.consumeErrorWith((ex) -> {
				assertThat(ex).isExactlyInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) ex).getReason()).isEqualTo(Reason.INVALID_ISSUER);
			})
			.verify();
	}
	@Test
	void validateTokenWhenAudienceIsNotValidShouldThrowException() throws Exception {
		given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));
		given(this.securityService.getUaaUrl()).willReturn(Mono.just('http://localhost:8080/uaa'));
		String header = '{ \'alg\': \'RS256\',  \'kid\': \'valid-key\', \'typ\': \'JWT\'}';
		String claims = '{ \'exp\': 2147483647, \'iss\': \'http://localhost:8080/uaa/oauth/token\', \'scope\': [\'foo.bar\']}';
		StepVerifier
			.create(this.tokenValidator.validate(new Token(getSignedToken(header.getBytes(), claims.getBytes()))))
			.consumeErrorWith((ex) -> {
				assertThat(ex).isExactlyInstanceOf(CloudFoundryAuthorizationException.class);
				assertThat(((CloudFoundryAuthorizationException) ex).getReason()).isEqualTo(Reason.INVALID_AUDIENCE);
			})
			.verify();
	}
	private String getSignedToken(byte[] header, byte[] claims) throws Exception {
		PrivateKey privateKey = getPrivateKey();
		Signature signature = Signature.getInstance('SHA256WithRSA');
		signature.initSign(privateKey);
		byte[] content = dotConcat(Base64.getUrlEncoder().encode(header), Base64.getEncoder().encode(claims));
		signature.update(content);
		byte[] crypto = signature.sign();
		byte[] token = dotConcat(Base64.getUrlEncoder().encode(header), Base64.getUrlEncoder().encode(claims),
				Base64.getUrlEncoder().encode(crypto));
		return new String(token, StandardCharsets.UTF_8);
	}
	private PrivateKey getPrivateKey() throws InvalidKeySpecException, NoSuchAlgorithmException {
		String signingKey = '''
				-----BEGIN PRIVATE KEY-----
				MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDSbn2Xa72IOcxu
				tcd+qQ6ufZ1VDe98EmpwO4VQrTd37U9kZtWU0KqeSkgnyzIWmlbyWOdbB4/v4uJa
				lGjPQjt9hvd3xOOFXzpj33sWXgMGvGAzopMk64T+7GegOFlDXguA5TZyReM7M51O
				ycYwpAEsKXS+lxcG0UsxpJum/WjOLyHsMnJVnoScVBlRYZ2BMyEOuap69/H3lT/X
				pzlYEM6SrAifsaWvL2f1K7HKBt/yDkDOlZy6xmAMsghnslNSV0FvypTZrQOXia8t
				k6fjA+iN+P0LDZAgKxzn4/B/bV8/6HN/7VZJEdudi/y5qdE7SBnx6QZqCEz/YfqC
				olujacgnAgMBAAECggEAc9X2tJ/OWWrXqinOg160gkELloJxTi8lAFsDbAGuAwpT
				JcWl1KF5CmGBjsY/8ElNi2J9GJL1HOwcBhikCVNARD1DhF6RkB13mvquWwWtTMvt
				eP8JWM19DIc+E+hw2rCuTGngqs7l4vTqpzBTNPtS2eiIJ1IsjsgvSEiAlk/wnW48
				11cf6SQMQcT3HNTWrS+yLycEuWKb6Khh8RpD9D+i8w2+IspWz5lTP7BrKCUNsLOx
				6+5T52HcaZ9z3wMnDqfqIKWl3h8M+q+HFQ4EN5BPWYV4fF7EOx7+Qf2fKDFPoTjC
				VTWzDRNAA1xPqwdF7IdPVOXCdaUJDOhHeXZGaTNSwQKBgQDxb9UiR/Jh1R3muL7I
				neIt1gXa0O+SK7NWYl4DkArYo7V81ztxI8r+xKEeu5zRZZkpaJHxOnd3VfADascw
				UfALvxGxN2z42lE6zdhrmxZ3ma+akQFsv7NyXcBT00sdW+xmOiCaAj0cgxNOXiV3
				sYOwUy3SqUIPO2obpb+KC5ALHwKBgQDfH+NSQ/jn89oVZ3lzUORa+Z+aL1TGsgzs
				p7IG0MTEYiR9/AExYUwJab0M4PDXhumeoACMfkCFALNVhpch2nXZv7X5445yRgfD
				ONY4WknecuA0rfCLTruNWnQ3RR+BXmd9jD/5igd9hEIawz3V+jCHvAtzI8/CZIBt
				AArBs5kp+QKBgQCdxwN1n6baIDemK10iJWtFoPO6h4fH8h8EeMwPb/ZmlLVpnA4Q
				Zd+mlkDkoJ5eiRKKaPfWuOqRZeuvj/wTq7g/NOIO+bWQ+rrSvuqLh5IrHpgPXmub
				8bsHJhUlspMH4KagN6ROgOAG3fGj6Qp7KdpxRCpR3KJ66czxvGNrhxre6QKBgB+s
				MCGiYnfSprd5G8VhyziazKwfYeJerfT+DQhopDXYVKPJnQW8cQW5C8wDNkzx6sHI
				pqtK1K/MnKhcVaHJmAcT7qoNQlA4Xqu4qrgPIQNBvU/dDRNJVthG6c5aspEzrG8m
				9IHgtRV9K8EOy/1O6YqrB9kNUVWf3JccdWpvqyNJAoGAORzJiQCOk4egbdcozDTo
				4Tg4qk/03qpTy5k64DxkX1nJHu8V/hsKwq9Af7Fj/iHy2Av54BLPlBaGPwMi2bzB
				gYjmUomvx/fqOTQks9Rc4PIMB43p6Rdj0sh+52SKPDR2eHbwsmpuQUXnAs20BPPI
				J/OOn5zOs8yf26os0q3+JUM=
				-----END PRIVATE KEY-----''';
		String privateKey = signingKey.replace('-----BEGIN PRIVATE KEY-----\n', '');
		privateKey = privateKey.replace('-----END PRIVATE KEY-----', '');
		privateKey = privateKey.replace('\n', '');
		byte[] pkcs8EncodedBytes = Base64.getDecoder().decode(privateKey);
		PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes);
		KeyFactory keyFactory = KeyFactory.getInstance('RSA');
		return keyFactory.generatePrivate(keySpec);
	}
	private byte[] dotConcat(byte[]... bytes) throws IOException {
		ByteArrayOutputStream result = new ByteArrayOutputStream();
		for (int i = 0; i < bytes.length; i++) {
			if (i > 0) {
				StreamUtils.copy(DOT, result);
			}
			StreamUtils.copy(bytes[i], result);
		}
		return result.toByteArray();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class CloudFoundryWebFluxEndpointHandlerMappingTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new CloudFoundryWebFluxEndpointHandlerMappingRuntimeHints().registerHints(runtimeHints,
				getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onMethod(CloudFoundryLinksHandler.class, 'links'))
			.accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(Link.class)).accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class CloudFoundryWebFluxEndpointIntegrationTests {
	private final ReactiveTokenValidator tokenValidator = mock(ReactiveTokenValidator.class);
	private final ReactiveCloudFoundrySecurityService securityService = mock(ReactiveCloudFoundrySecurityService.class);
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner(
			AnnotationConfigReactiveWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(WebFluxAutoConfiguration.class, HttpHandlerAutoConfiguration.class,
				ReactiveWebServerFactoryAutoConfiguration.class))
		.withUserConfiguration(TestEndpointConfiguration.class)
		.withBean(ReactiveTokenValidator.class, () -> this.tokenValidator)
		.withBean(ReactiveCloudFoundrySecurityService.class, () -> this.securityService)
		.withPropertyValues('server.port=0');
	@Test
	void operationWithSecurityInterceptorForbidden() {
		given(this.tokenValidator.validate(any())).willReturn(Mono.empty());
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(Mono.just(AccessLevel.RESTRICTED));
		this.contextRunner.run(withWebTestClient((client) -> client.get()
			.uri('/cfApplication/test')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', 'bearer ' + mockAccessToken())
			.exchange()
			.expectStatus()
			.isEqualTo(HttpStatus.FORBIDDEN)));
	}
	@Test
	void operationWithSecurityInterceptorSuccess() {
		given(this.tokenValidator.validate(any())).willReturn(Mono.empty());
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(Mono.just(AccessLevel.FULL));
		this.contextRunner.run(withWebTestClient((client) -> client.get()
			.uri('/cfApplication/test')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', 'bearer ' + mockAccessToken())
			.exchange()
			.expectStatus()
			.isEqualTo(HttpStatus.OK)));
	}
	@Test
	void responseToOptionsRequestIncludesCorsHeaders() {
		this.contextRunner.run(withWebTestClient((client) -> client.options()
			.uri('/cfApplication/test')
			.accept(MediaType.APPLICATION_JSON)
			.header('Access-Control-Request-Method', 'POST')
			.header('Origin', 'https://example.com')
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.valueEquals('Access-Control-Allow-Origin', 'https://example.com')
			.expectHeader()
			.valueEquals('Access-Control-Allow-Methods', 'GET,POST')));
	}
	@Test
	void linksToOtherEndpointsWithFullAccess() {
		given(this.tokenValidator.validate(any())).willReturn(Mono.empty());
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(Mono.just(AccessLevel.FULL));
		this.contextRunner.run(withWebTestClient((client) -> client.get()
			.uri('/cfApplication')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', 'bearer ' + mockAccessToken())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('_links.length()')
			.isEqualTo(5)
			.jsonPath('_links.self.href')
			.isNotEmpty()
			.jsonPath('_links.self.templated')
			.isEqualTo(false)
			.jsonPath('_links.info.href')
			.isNotEmpty()
			.jsonPath('_links.info.templated')
			.isEqualTo(false)
			.jsonPath('_links.env.href')
			.isNotEmpty()
			.jsonPath('_links.env.templated')
			.isEqualTo(false)
			.jsonPath('_links.test.href')
			.isNotEmpty()
			.jsonPath('_links.test.templated')
			.isEqualTo(false)
			.jsonPath('_links.test-part.href')
			.isNotEmpty()
			.jsonPath('_links.test-part.templated')
			.isEqualTo(true)));
	}
	@Test
	void linksToOtherEndpointsForbidden() {
		CloudFoundryAuthorizationException exception = new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN,
				'invalid-token');
		willThrow(exception).given(this.tokenValidator).validate(any());
		this.contextRunner.run(withWebTestClient((client) -> client.get()
			.uri('/cfApplication')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', 'bearer ' + mockAccessToken())
			.exchange()
			.expectStatus()
			.isUnauthorized()));
	}
	@Test
	void linksToOtherEndpointsWithRestrictedAccess() {
		given(this.tokenValidator.validate(any())).willReturn(Mono.empty());
		given(this.securityService.getAccessLevel(any(), eq('app-id'))).willReturn(Mono.just(AccessLevel.RESTRICTED));
		this.contextRunner.run(withWebTestClient((client) -> client.get()
			.uri('/cfApplication')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', 'bearer ' + mockAccessToken())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('_links.length()')
			.isEqualTo(2)
			.jsonPath('_links.self.href')
			.isNotEmpty()
			.jsonPath('_links.self.templated')
			.isEqualTo(false)
			.jsonPath('_links.info.href')
			.isNotEmpty()
			.jsonPath('_links.info.templated')
			.isEqualTo(false)
			.jsonPath('_links.env')
			.doesNotExist()
			.jsonPath('_links.test')
			.doesNotExist()
			.jsonPath('_links.test-part')
			.doesNotExist()));
	}
	private ContextConsumer<AssertableReactiveWebApplicationContext> withWebTestClient(
			Consumer<WebTestClient> clientConsumer) {
		return (context) -> {
			int port = ((AnnotationConfigReactiveWebServerApplicationContext) context.getSourceApplicationContext())
				.getWebServer()
				.getPort();
			clientConsumer.accept(WebTestClient.bindToServer()
				.baseUrl('http://localhost:' + port)
				.responseTimeout(Duration.ofMinutes(5))
				.build());
		};
	}
	private String mockAccessToken() {
		return 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ0b3B0YWwu'
				+ 'Y29tIiwiZXhwIjoxNDI2NDIwODAwLCJhd2Vzb21lIjp0cnVlfQ.'
				+ Base64.getEncoder().encodeToString('signature'.getBytes());
	}
	@Configuration(proxyBeanMethods = false)
	static class CloudFoundryReactiveConfiguration {
		@Bean
		CloudFoundrySecurityInterceptor interceptor(ReactiveTokenValidator tokenValidator,
				ReactiveCloudFoundrySecurityService securityService) {
			return new CloudFoundrySecurityInterceptor(tokenValidator, securityService, 'app-id');
		}
		@Bean
		EndpointMediaTypes EndpointMediaTypes() {
			return new EndpointMediaTypes(Collections.singletonList('application/json'),
					Collections.singletonList('application/json'));
		}
		@Bean
		CloudFoundryWebFluxEndpointHandlerMapping cloudFoundryWebEndpointServletHandlerMapping(
				WebEndpointDiscoverer webEndpointDiscoverer, EndpointMediaTypes endpointMediaTypes,
				CloudFoundrySecurityInterceptor interceptor) {
			CorsConfiguration corsConfiguration = new CorsConfiguration();
			corsConfiguration.setAllowedOrigins(Arrays.asList('https://example.com'));
			corsConfiguration.setAllowedMethods(Arrays.asList('GET', 'POST'));
			Collection<ExposableWebEndpoint> webEndpoints = webEndpointDiscoverer.getEndpoints();
			List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>(webEndpoints);
			return new CloudFoundryWebFluxEndpointHandlerMapping(new EndpointMapping('/cfApplication'), webEndpoints,
					endpointMediaTypes, corsConfiguration, interceptor, allEndpoints);
		}
		@Bean
		WebEndpointDiscoverer webEndpointDiscoverer(ApplicationContext applicationContext,
				EndpointMediaTypes endpointMediaTypes) {
			ParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper(
					DefaultConversionService.getSharedInstance());
			return new WebEndpointDiscoverer(applicationContext, parameterMapper, endpointMediaTypes, null, null,
					Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
		}
		@Bean
		EndpointDelegate endpointDelegate() {
			return mock(EndpointDelegate.class);
		}
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		private final EndpointDelegate endpointDelegate;
		TestEndpoint(EndpointDelegate endpointDelegate) {
			this.endpointDelegate = endpointDelegate;
		}
		@ReadOperation
		Map<String, Object> readAll() {
			return Collections.singletonMap('All', true);
		}
		@ReadOperation
		Map<String, Object> readPart(@Selector String part) {
			return Collections.singletonMap('part', part);
		}
		@WriteOperation
		void write(String foo, String bar) {
			this.endpointDelegate.write(foo, bar);
		}
	}
	@Endpoint(id = 'env')
	static class TestEnvEndpoint {
		@ReadOperation
		Map<String, Object> readAll() {
			return Collections.singletonMap('All', true);
		}
	}
	@Endpoint(id = 'info')
	static class TestInfoEndpoint {
		@ReadOperation
		Map<String, Object> readAll() {
			return Collections.singletonMap('All', true);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CloudFoundryReactiveConfiguration.class)
	static class TestEndpointConfiguration {
		@Bean
		TestEndpoint testEndpoint(EndpointDelegate endpointDelegate) {
			return new TestEndpoint(endpointDelegate);
		}
		@Bean
		TestInfoEndpoint testInfoEnvEndpoint() {
			return new TestInfoEndpoint();
		}
		@Bean
		TestEnvEndpoint testEnvEndpoint() {
			return new TestEnvEndpoint();
		}
	}
	interface EndpointDelegate {
		void write();
		void write(String foo, String bar);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.data.elasticsearch;
/**
class ElasticsearchReactiveHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticsearchDataAutoConfiguration.class,
				ReactiveElasticsearchClientAutoConfiguration.class, ElasticsearchRestClientAutoConfiguration.class,
				ElasticsearchReactiveHealthContributorAutoConfiguration.class,
				HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(ElasticsearchReactiveHealthIndicator.class)
				.hasBean('elasticsearchHealthContributor'));
	}
	@Test
	void runWithRegularIndicatorShouldOnlyCreateReactiveIndicator() {
		this.contextRunner
			.withConfiguration(AutoConfigurations.of(ElasticsearchRestHealthContributorAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(ElasticsearchReactiveHealthIndicator.class)
				.hasBean('elasticsearchHealthContributor')
				.doesNotHaveBean(ElasticsearchRestClientHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.elasticsearch.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ElasticsearchReactiveHealthIndicator.class)
				.doesNotHaveBean('elasticsearchHealthContributor'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.data.redis;
/**
class RedisReactiveHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class,
				RedisReactiveHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(RedisReactiveHealthIndicator.class)
			.hasBean('redisHealthContributor'));
	}
	@Test
	void runWithRegularIndicatorShouldOnlyCreateReactiveIndicator() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisHealthContributorAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(RedisReactiveHealthIndicator.class)
				.hasBean('redisHealthContributor')
				.doesNotHaveBean(RedisHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.redis.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(RedisReactiveHealthIndicator.class)
				.doesNotHaveBean('redisHealthContributor'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.data.redis;
/**
@ClassPathExclusions({ 'reactor-core*.jar', 'lettuce-core*.jar' })
class RedisHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class,
				RedisHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(RedisHealthIndicator.class)
			.doesNotHaveBean(RedisReactiveHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.redis.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(RedisHealthIndicator.class)
				.doesNotHaveBean(RedisReactiveHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.data.mongo;
/**
class MongoReactiveHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
				MongoReactiveAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class,
				MongoReactiveHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MongoReactiveHealthIndicator.class)
			.hasBean('mongoHealthContributor'));
	}
	@Test
	void runWithRegularIndicatorShouldOnlyCreateReactiveIndicator() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(MongoHealthContributorAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(MongoReactiveHealthIndicator.class)
				.hasBean('mongoHealthContributor')
				.doesNotHaveBean(MongoHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.mongo.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(MongoReactiveHealthIndicator.class)
				.doesNotHaveBean('mongoHealthContributor'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.data.mongo;
/**
class MongoHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
				MongoHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MongoHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.mongo.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(MongoHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/**
class OtlpLoggingAutoConfigurationIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.application.name=otlp-logs-test',
				'management.otlp.logging.headers.Authorization=Bearer my-token')
		.withConfiguration(AutoConfigurations.of(OpenTelemetryAutoConfiguration.class,
				OpenTelemetryLoggingAutoConfiguration.class, OtlpLoggingAutoConfiguration.class));
	private final MockWebServer mockWebServer = new MockWebServer();
	@BeforeEach
	void setUp() throws IOException {
		this.mockWebServer.start();
	}
	@AfterEach
	void tearDown() throws IOException {
		this.mockWebServer.close();
	}
	@Test
	void httpLogRecordExporterShouldUseProtobufAndNoCompressionByDefault() {
		this.mockWebServer.enqueue(new MockResponse());
		this.contextRunner
			.withPropertyValues('management.otlp.logging.endpoint=http://localhost:%d/v1/logs'
				.formatted(this.mockWebServer.getPort()))
			.run((context) -> {
				logMessage(context);
				RecordedRequest request = this.mockWebServer.takeRequest(10, TimeUnit.SECONDS);
				assertThat(request).isNotNull();
				assertThat(request.getRequestLine()).contains('/v1/logs');
				assertThat(request.getHeader('Content-Type')).isEqualTo('application/x-protobuf');
				assertThat(request.getHeader('Content-Encoding')).isNull();
				assertThat(request.getBodySize()).isPositive();
				try (Buffer body = request.getBody()) {
					assertLogMessage(body);
				}
			});
	}
	@Test
	void httpLogRecordExporterCanBeConfiguredToUseGzipCompression() {
		this.mockWebServer.enqueue(new MockResponse());
		this.contextRunner
			.withPropertyValues('management.otlp.logging.endpoint=http://localhost:%d/v1/logs'
				.formatted(this.mockWebServer.getPort()), 'management.otlp.logging.compression=gzip')
			.run((context) -> {
				logMessage(context);
				RecordedRequest request = this.mockWebServer.takeRequest(10, TimeUnit.SECONDS);
				assertThat(request).isNotNull();
				assertThat(request.getRequestLine()).contains('/v1/logs');
				assertThat(request.getHeader('Content-Type')).isEqualTo('application/x-protobuf');
				assertThat(request.getHeader('Content-Encoding')).isEqualTo('gzip');
				assertThat(request.getBodySize()).isPositive();
				try (Buffer uncompressed = new Buffer(); Buffer body = request.getBody()) {
					uncompressed.writeAll(new GzipSource(body));
					assertLogMessage(uncompressed);
				}
			});
	}
	private static void logMessage(ApplicationContext context) {
		SdkLoggerProvider loggerProvider = context.getBean(SdkLoggerProvider.class);
		loggerProvider.get('test')
			.logRecordBuilder()
			.setSeverity(Severity.INFO)
			.setSeverityText('INFO')
			.setBody('Hello')
			.setTimestamp(Instant.now())
			.emit();
	}
	private static void assertLogMessage(Buffer body) {
		String string = body.readString(StandardCharsets.UTF_8);
		assertThat(string).contains('otlp-logs-test');
		assertThat(string).contains('test');
		assertThat(string).contains('INFO');
		assertThat(string).contains('Hello');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/**
class OtlpLoggingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(OtlpLoggingAutoConfiguration.class));
	@Test
	void shouldNotSupplyBeansIfPropertyIsNotSet() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(OtlpLoggingConnectionDetails.class);
			assertThat(context).doesNotHaveBean(OtlpHttpLogRecordExporter.class);
		});
	}
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.withPropertyValues('management.otlp.logging.endpoint=http://localhost:4318/v1/logs')
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpLoggingConnectionDetails.class);
				OtlpLoggingConnectionDetails connectionDetails = context.getBean(OtlpLoggingConnectionDetails.class);
				assertThat(connectionDetails.getUrl(Transport.HTTP)).isEqualTo('http://localhost:4318/v1/logs');
				assertThat(context).hasSingleBean(OtlpHttpLogRecordExporter.class)
					.hasSingleBean(LogRecordExporter.class);
			});
	}
	@ParameterizedTest
	@ValueSource(strings = { 'io.opentelemetry.sdk.logs', 'io.opentelemetry.api',
			'io.opentelemetry.exporter.otlp.http.logs' })
	void shouldNotSupplyBeansIfDependencyIsMissing(String packageName) {
		this.contextRunner.withClassLoader(new FilteredClassLoader(packageName)).run((context) -> {
			assertThat(context).doesNotHaveBean(OtlpLoggingConnectionDetails.class);
			assertThat(context).doesNotHaveBean(OtlpHttpLogRecordExporter.class);
		});
	}
	@Test
	void shouldBackOffWhenLoggingExportPropertyIsNotEnabled() {
		this.contextRunner
			.withPropertyValues('management.logging.export.enabled=false',
					'management.otlp.logging.endpoint=http://localhost:4318/v1/logs')
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpLoggingConnectionDetails.class);
				assertThat(context).doesNotHaveBean(LogRecordExporter.class);
			});
	}
	@Test
	void shouldBackOffWhenOtlpLoggingExportPropertyIsNotEnabled() {
		this.contextRunner
			.withPropertyValues('management.otlp.logging.export.enabled=false',
					'management.otlp.logging.endpoint=http://localhost:4318/v1/logs')
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpLoggingConnectionDetails.class);
				assertThat(context).doesNotHaveBean(LogRecordExporter.class);
			});
	}
	@Test
	void shouldBackOffWhenCustomHttpExporterIsDefined() {
		this.contextRunner.withUserConfiguration(CustomHttpExporterConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customOtlpHttpLogRecordExporter')
				.hasSingleBean(LogRecordExporter.class));
	}
	@Test
	void shouldBackOffWhenCustomGrpcExporterIsDefined() {
		this.contextRunner.withUserConfiguration(CustomGrpcExporterConfiguration.class)
			.run((context) -> assertThat(context).hasBean('customOtlpGrpcLogRecordExporter')
				.hasSingleBean(LogRecordExporter.class));
	}
	@Test
	void shouldBackOffWhenCustomOtlpLoggingConnectionDetailsIsDefined() {
		this.contextRunner.withUserConfiguration(CustomOtlpLoggingConnectionDetails.class).run((context) -> {
			assertThat(context).hasSingleBean(OtlpLoggingConnectionDetails.class)
				.doesNotHaveBean(PropertiesOtlpLoggingConnectionDetails.class);
			OtlpHttpLogRecordExporter otlpHttpLogRecordExporter = context.getBean(OtlpHttpLogRecordExporter.class);
			assertThat(otlpHttpLogRecordExporter).extracting('delegate.httpSender.url')
				.isEqualTo(HttpUrl.get('https://otel.example.com/v1/logs'));
		});
	}
	@Test
	void shouldUseHttpExporterIfTransportIsNotSet() {
		this.contextRunner.withPropertyValues('management.otlp.logging.endpoint=http://localhost:4318/v1/logs')
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpHttpLogRecordExporter.class)
					.hasSingleBean(LogRecordExporter.class);
				assertThat(context).doesNotHaveBean(OtlpGrpcLogRecordExporter.class);
			});
	}
	@Test
	void shouldUseHttpExporterIfTransportIsSetToHttp() {
		this.contextRunner
			.withPropertyValues('management.otlp.logging.endpoint=http://localhost:4318/v1/logs',
					'management.otlp.logging.transport=http')
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpHttpLogRecordExporter.class)
					.hasSingleBean(LogRecordExporter.class);
				assertThat(context).doesNotHaveBean(OtlpGrpcLogRecordExporter.class);
			});
	}
	@Test
	void shouldUseGrpcExporterIfTransportIsSetToGrpc() {
		this.contextRunner
			.withPropertyValues('management.otlp.logging.endpoint=http://localhost:4318/v1/logs',
					'management.otlp.logging.transport=grpc')
			.run((context) -> {
				assertThat(context).hasSingleBean(OtlpGrpcLogRecordExporter.class)
					.hasSingleBean(LogRecordExporter.class);
				assertThat(context).doesNotHaveBean(OtlpHttpLogRecordExporter.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	public static class CustomHttpExporterConfiguration {
		@Bean
		public OtlpHttpLogRecordExporter customOtlpHttpLogRecordExporter() {
			return OtlpHttpLogRecordExporter.builder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	public static class CustomGrpcExporterConfiguration {
		@Bean
		public OtlpGrpcLogRecordExporter customOtlpGrpcLogRecordExporter() {
			return OtlpGrpcLogRecordExporter.builder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	public static class CustomOtlpLoggingConnectionDetails {
		@Bean
		public OtlpLoggingConnectionDetails customOtlpLoggingConnectionDetails() {
			return (transport) -> 'https://otel.example.com/v1/logs';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
class OpenTelemetryLoggingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner;
	OpenTelemetryLoggingAutoConfigurationTests() {
		this.contextRunner = new ApplicationContextRunner().withConfiguration(AutoConfigurations
			.of(OpenTelemetryAutoConfiguration.class, OpenTelemetryLoggingAutoConfiguration.class));
	}
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(BatchLogRecordProcessor.class);
			assertThat(context).hasSingleBean(SdkLoggerProvider.class);
		});
	}
	@ParameterizedTest
	@ValueSource(strings = { 'io.opentelemetry.sdk.logs', 'io.opentelemetry.api' })
	void shouldNotSupplyBeansIfDependencyIsMissing(String packageName) {
		this.contextRunner.withClassLoader(new FilteredClassLoader(packageName)).run((context) -> {
			assertThat(context).doesNotHaveBean(BatchLogRecordProcessor.class);
			assertThat(context).doesNotHaveBean(SdkLoggerProvider.class);
		});
	}
	@Test
	void shouldBackOffOnCustomBeans() {
		this.contextRunner.withUserConfiguration(CustomConfig.class).run((context) -> {
			assertThat(context).hasBean('customBatchLogRecordProcessor').hasSingleBean(BatchLogRecordProcessor.class);
			assertThat(context.getBeansOfType(LogRecordProcessor.class)).hasSize(1);
			assertThat(context).hasBean('customSdkLoggerProvider').hasSingleBean(SdkLoggerProvider.class);
		});
	}
	@Test
	void shouldAllowMultipleLogRecordExporters() {
		this.contextRunner.withUserConfiguration(MultipleLogRecordExportersConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(BatchLogRecordProcessor.class);
			assertThat(context.getBeansOfType(LogRecordExporter.class)).hasSize(2);
			assertThat(context).hasBean('customLogRecordExporter1');
			assertThat(context).hasBean('customLogRecordExporter2');
		});
	}
	@Test
	void shouldAllowMultipleLogRecordProcessorsInAdditionToBatchLogRecordProcessor() {
		this.contextRunner.withUserConfiguration(MultipleLogRecordProcessorsConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(BatchLogRecordProcessor.class);
			assertThat(context).hasSingleBean(SdkLoggerProvider.class);
			assertThat(context.getBeansOfType(LogRecordProcessor.class)).hasSize(3);
			assertThat(context).hasBean('batchLogRecordProcessor');
			assertThat(context).hasBean('customLogRecordProcessor1');
			assertThat(context).hasBean('customLogRecordProcessor2');
		});
	}
	@Test
	void shouldAllowMultipleSdkLoggerProviderBuilderCustomizers() {
		this.contextRunner.withUserConfiguration(MultipleSdkLoggerProviderBuilderCustomizersConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SdkLoggerProvider.class);
				assertThat(context.getBeansOfType(SdkLoggerProviderBuilderCustomizer.class)).hasSize(2);
				assertThat(context).hasBean('customSdkLoggerProviderBuilderCustomizer1');
				assertThat(context).hasBean('customSdkLoggerProviderBuilderCustomizer2');
				assertThat(context
					.getBean('customSdkLoggerProviderBuilderCustomizer1', NoopSdkLoggerProviderBuilderCustomizer.class)
					.called()).isEqualTo(1);
				assertThat(context
					.getBean('customSdkLoggerProviderBuilderCustomizer2', NoopSdkLoggerProviderBuilderCustomizer.class)
					.called()).isEqualTo(1);
			});
	}
	@Configuration(proxyBeanMethods = false)
	public static class CustomConfig {
		@Bean
		public BatchLogRecordProcessor customBatchLogRecordProcessor() {
			return BatchLogRecordProcessor.builder(new NoopLogRecordExporter()).build();
		}
		@Bean
		public SdkLoggerProvider customSdkLoggerProvider() {
			return SdkLoggerProvider.builder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	public static class MultipleLogRecordExportersConfig {
		@Bean
		public LogRecordExporter customLogRecordExporter1() {
			return new NoopLogRecordExporter();
		}
		@Bean
		public LogRecordExporter customLogRecordExporter2() {
			return new NoopLogRecordExporter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	public static class MultipleLogRecordProcessorsConfig {
		@Bean
		public LogRecordProcessor customLogRecordProcessor1() {
			return new NoopLogRecordProcessor();
		}
		@Bean
		public LogRecordProcessor customLogRecordProcessor2() {
			return new NoopLogRecordProcessor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	public static class MultipleSdkLoggerProviderBuilderCustomizersConfig {
		@Bean
		public SdkLoggerProviderBuilderCustomizer customSdkLoggerProviderBuilderCustomizer1() {
			return new NoopSdkLoggerProviderBuilderCustomizer();
		}
		@Bean
		public SdkLoggerProviderBuilderCustomizer customSdkLoggerProviderBuilderCustomizer2() {
			return new NoopSdkLoggerProviderBuilderCustomizer();
		}
	}
	static class NoopLogRecordExporter implements LogRecordExporter {
		@Override
		public CompletableResultCode export(Collection<LogRecordData> logs) {
			return CompletableResultCode.ofSuccess();
		}
		@Override
		public CompletableResultCode flush() {
			return CompletableResultCode.ofSuccess();
		}
		@Override
		public CompletableResultCode shutdown() {
			return CompletableResultCode.ofSuccess();
		}
	}
	static class NoopLogRecordProcessor implements LogRecordProcessor {
		@Override
		public void onEmit(Context context, ReadWriteLogRecord logRecord) {
		}
	}
	static class NoopSdkLoggerProviderBuilderCustomizer implements SdkLoggerProviderBuilderCustomizer {
		final AtomicInteger called = new AtomicInteger(0);
		@Override
		public void customize(SdkLoggerProviderBuilder builder) {
			this.called.incrementAndGet();
		}
		int called() {
			return this.called.get();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
class OnEnabledLoggingExportConditionTests {
	@Test
	void shouldMatchIfNoPropertyIsSet() {
		OnEnabledLoggingExportCondition condition = new OnEnabledLoggingExportCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(mockConditionContext(), mockMetadata(''));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage()).isEqualTo('@ConditionalOnEnabledLoggingExport is enabled by default');
	}
	@Test
	void shouldNotMatchIfGlobalPropertyIsFalse() {
		OnEnabledLoggingExportCondition condition = new OnEnabledLoggingExportCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(
				mockConditionContext(Map.of('management.logging.export.enabled', 'false')), mockMetadata(''));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledLoggingExport management.logging.export.enabled is false');
	}
	@Test
	void shouldMatchIfGlobalPropertyIsTrue() {
		OnEnabledLoggingExportCondition condition = new OnEnabledLoggingExportCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(
				mockConditionContext(Map.of('management.logging.export.enabled', 'true')), mockMetadata(''));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledLoggingExport management.logging.export.enabled is true');
	}
	@Test
	void shouldNotMatchIfExporterPropertyIsFalse() {
		OnEnabledLoggingExportCondition condition = new OnEnabledLoggingExportCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(
				mockConditionContext(Map.of('management.otlp.logging.export.enabled', 'false')), mockMetadata('otlp'));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledLoggingExport management.otlp.logging.export.enabled is false');
	}
	@Test
	void shouldMatchIfExporterPropertyIsTrue() {
		OnEnabledLoggingExportCondition condition = new OnEnabledLoggingExportCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(
				mockConditionContext(Map.of('management.otlp.logging.export.enabled', 'true')), mockMetadata('otlp'));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledLoggingExport management.otlp.logging.export.enabled is true');
	}
	@Test
	void exporterPropertyShouldOverrideGlobalPropertyIfTrue() {
		OnEnabledLoggingExportCondition condition = new OnEnabledLoggingExportCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(mockConditionContext(
				Map.of('management.logging.enabled', 'false', 'management.otlp.logging.export.enabled', 'true')),
				mockMetadata('otlp'));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledLoggingExport management.otlp.logging.export.enabled is true');
	}
	@Test
	void exporterPropertyShouldOverrideGlobalPropertyIfFalse() {
		OnEnabledLoggingExportCondition condition = new OnEnabledLoggingExportCondition();
		ConditionOutcome outcome = condition.getMatchOutcome(mockConditionContext(
				Map.of('management.logging.enabled', 'true', 'management.otlp.logging.export.enabled', 'false')),
				mockMetadata('otlp'));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage())
			.isEqualTo('@ConditionalOnEnabledLoggingExport management.otlp.logging.export.enabled is false');
	}
	private ConditionContext mockConditionContext() {
		return mockConditionContext(Collections.emptyMap());
	}
	private ConditionContext mockConditionContext(Map<String, String> properties) {
		ConditionContext context = mock(ConditionContext.class);
		MockEnvironment environment = new MockEnvironment();
		properties.forEach(environment::setProperty);
		given(context.getEnvironment()).willReturn(environment);
		return context;
	}
	private AnnotatedTypeMetadata mockMetadata(String exporter) {
		AnnotatedTypeMetadata metadata = mock(AnnotatedTypeMetadata.class);
		given(metadata.getAnnotationAttributes(ConditionalOnEnabledLoggingExport.class.getName()))
			.willReturn(Map.of('value', exporter));
		return metadata;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
class LoggersEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LoggersEndpointAutoConfiguration.class))
		.withUserConfiguration(LoggingConfiguration.class);
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=loggers')
			.run((context) -> assertThat(context).hasSingleBean(LoggersEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.loggers.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(LoggersEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(LoggersEndpoint.class));
	}
	@Test
	void runWithNoneLoggingSystemShouldNotHaveEndpointBean() {
		this.contextRunner.withSystemProperties('org.springframework.boot.logging.LoggingSystem=none')
			.run((context) -> assertThat(context).doesNotHaveBean(LoggersEndpoint.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class LoggingConfiguration {
		@Bean
		LoggingSystem loggingSystem() {
			return mock(LoggingSystem.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
class LogFileWebEndpointAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LogFileWebEndpointAutoConfiguration.class));
	@Test
	void runWithOnlyExposedShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=logfile')
			.run((context) -> assertThat(context).doesNotHaveBean(LogFileWebEndpoint.class));
	}
	@Test
	void runWhenLoggingFileIsSetAndNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('logging.file.name:test.log')
			.run((context) -> assertThat(context).doesNotHaveBean(LogFileWebEndpoint.class));
	}
	@Test
	void runWhenLoggingFileIsSetAndExposedShouldHaveEndpointBean() {
		this.contextRunner
			.withPropertyValues('logging.file.name:test.log', 'management.endpoints.web.exposure.include=logfile')
			.run((context) -> assertThat(context).hasSingleBean(LogFileWebEndpoint.class));
	}
	@Test
	void runWhenLoggingPathIsSetAndNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('logging.file.path:test/logs')
			.run((context) -> assertThat(context).doesNotHaveBean(LogFileWebEndpoint.class));
	}
	@Test
	void runWhenLoggingPathIsSetAndExposedShouldHaveEndpointBean() {
		this.contextRunner
			.withPropertyValues('logging.file.path:test/logs', 'management.endpoints.web.exposure.include=logfile')
			.run((context) -> assertThat(context).hasSingleBean(LogFileWebEndpoint.class));
	}
	@Test
	void logFileWebEndpointIsAutoConfiguredWhenExternalFileIsSet() {
		this.contextRunner
			.withPropertyValues('management.endpoint.logfile.external-file:external.log',
					'management.endpoints.web.exposure.include=logfile')
			.run((context) -> assertThat(context).hasSingleBean(LogFileWebEndpoint.class));
	}
	@Test
	void logFileWebEndpointCanBeDisabled() {
		this.contextRunner.withPropertyValues('logging.file.name:test.log', 'management.endpoint.logfile.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(LogFileWebEndpoint.class));
	}
	@Test
	void logFileWebEndpointUsesConfiguredExternalFile(@TempDir Path temp) throws IOException {
		File file = new File(temp.toFile(), 'logfile');
		FileCopyUtils.copy('--TEST--'.getBytes(), file);
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=logfile',
					'management.endpoint.logfile.external-file:' + file.getAbsolutePath())
			.run((context) -> {
				assertThat(context).hasSingleBean(LogFileWebEndpoint.class);
				LogFileWebEndpoint endpoint = context.getBean(LogFileWebEndpoint.class);
				Resource resource = endpoint.logFile();
				assertThat(resource).isNotNull();
				assertThat(contentOf(resource.getFile())).isEqualTo('--TEST--');
			});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.opentelemetry;
/**
class OpenTelemetryAutoConfigurationTests {
	private final ApplicationContextRunner runner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(OpenTelemetryAutoConfiguration.class));
	@Test
	void isRegisteredInAutoConfigurationImports() {
		assertThat(ImportCandidates.load(AutoConfiguration.class, null).getCandidates())
			.contains(OpenTelemetryAutoConfiguration.class.getName());
	}
	@Test
	void shouldProvideBeans() {
		this.runner.run((context) -> {
			assertThat(context).hasSingleBean(OpenTelemetrySdk.class);
			assertThat(context).hasSingleBean(Resource.class);
		});
	}
	@Test
	void shouldBackOffIfOpenTelemetryIsNotOnClasspath() {
		this.runner.withClassLoader(new FilteredClassLoader('io.opentelemetry')).run((context) -> {
			assertThat(context).doesNotHaveBean(OpenTelemetrySdk.class);
			assertThat(context).doesNotHaveBean(Resource.class);
		});
	}
	@Test
	void backsOffOnUserSuppliedBeans() {
		this.runner.withUserConfiguration(UserConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(OpenTelemetry.class);
			assertThat(context).hasBean('customOpenTelemetry');
			assertThat(context).hasSingleBean(Resource.class);
			assertThat(context).hasBean('customResource');
		});
	}
	@Test
	void shouldApplySpringApplicationNameToResource() {
		this.runner.withPropertyValues('spring.application.name=my-application').run((context) -> {
			Resource resource = context.getBean(Resource.class);
			assertThat(resource.getAttributes().asMap())
				.contains(entry(AttributeKey.stringKey('service.name'), 'my-application'));
		});
	}
	@Test
	void shouldApplySpringApplicationGroupToResource() {
		this.runner.withPropertyValues('spring.application.group=my-group').run((context) -> {
			Resource resource = context.getBean(Resource.class);
			assertThat(resource.getAttributes().asMap())
				.contains(entry(AttributeKey.stringKey('service.group'), 'my-group'));
		});
	}
	@Test
	void shouldNotApplySpringApplicationGroupIfNotSet() {
		this.runner.run((context) -> {
			Resource resource = context.getBean(Resource.class);
			assertThat(resource.getAttributes().asMap()).doesNotContainKey(AttributeKey.stringKey('service.group'));
		});
	}
	@Test
	void shouldFallbackToDefaultApplicationNameIfSpringApplicationNameIsNotSet() {
		this.runner.run((context) -> {
			Resource resource = context.getBean(Resource.class);
			assertThat(resource.getAttributes().asMap())
				.contains(entry(AttributeKey.stringKey('service.name'), 'unknown_service'));
		});
	}
	@Test
	void shouldApplyResourceAttributesFromProperties() {
		this.runner.withPropertyValues('management.opentelemetry.resource-attributes.region=us-west').run((context) -> {
			Resource resource = context.getBean(Resource.class);
			assertThat(resource.getAttributes().asMap()).contains(entry(AttributeKey.stringKey('region'), 'us-west'));
		});
	}
	@Test
	void shouldRegisterSdkTracerProviderIfAvailable() {
		this.runner.withBean(SdkTracerProvider.class, () -> SdkTracerProvider.builder().build()).run((context) -> {
			OpenTelemetry openTelemetry = context.getBean(OpenTelemetry.class);
			assertThat(openTelemetry.getTracerProvider()).isNotNull();
		});
	}
	@Test
	void shouldRegisterContextPropagatorsIfAvailable() {
		this.runner.withBean(ContextPropagators.class, ContextPropagators::noop).run((context) -> {
			OpenTelemetry openTelemetry = context.getBean(OpenTelemetry.class);
			assertThat(openTelemetry.getPropagators()).isNotNull();
		});
	}
	@Test
	void shouldRegisterSdkLoggerProviderIfAvailable() {
		this.runner.withBean(SdkLoggerProvider.class, () -> SdkLoggerProvider.builder().build()).run((context) -> {
			OpenTelemetry openTelemetry = context.getBean(OpenTelemetry.class);
			assertThat(openTelemetry.getLogsBridge()).isNotNull();
		});
	}
	@Test
	void shouldRegisterSdkMeterProviderIfAvailable() {
		this.runner.withBean(SdkMeterProvider.class, () -> SdkMeterProvider.builder().build()).run((context) -> {
			OpenTelemetry openTelemetry = context.getBean(OpenTelemetry.class);
			assertThat(openTelemetry.getMeterProvider()).isNotNull();
		});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class UserConfiguration {
		@Bean
		OpenTelemetry customOpenTelemetry() {
			return mock(OpenTelemetry.class);
		}
		@Bean
		Resource customResource() {
			return Resource.getDefault();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.opentelemetry;
/**
class OpenTelemetryPropertiesTests {
	private final ApplicationContextRunner runner = new ApplicationContextRunner().withPropertyValues(
			'management.opentelemetry.resource-attributes.a=alpha',
			'management.opentelemetry.resource-attributes.b=beta');
	@Test
	@ClassPathExclusions('opentelemetry-sdk-*')
	void shouldNotDependOnOpenTelemetrySdk() {
		this.runner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			OpenTelemetryProperties properties = context.getBean(OpenTelemetryProperties.class);
			assertThat(properties.getResourceAttributes()).containsOnly(entry('a', 'alpha'), entry('b', 'beta'));
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(OpenTelemetryProperties.class)
	private static final class TestConfiguration {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.hazelcast;
/**
class HazelcastHealthContributorAutoConfigurationIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HazelcastHealthContributorAutoConfiguration.class,
				HazelcastAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void hazelcastUp() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(HazelcastInstance.class).hasSingleBean(HazelcastHealthIndicator.class);
			HazelcastInstance hazelcast = context.getBean(HazelcastInstance.class);
			Health health = context.getBean(HazelcastHealthIndicator.class).health();
			assertThat(health.getStatus()).isEqualTo(Status.UP);
			assertThat(health.getDetails()).containsOnlyKeys('name', 'uuid')
				.containsEntry('name', hazelcast.getName())
				.containsEntry('uuid', hazelcast.getLocalEndpoint().getUuid().toString());
		});
	}
	@Test
	void hazelcastDown() {
		this.contextRunner.run((context) -> {
			context.getBean(HazelcastInstance.class).shutdown();
			assertThat(context).hasSingleBean(HazelcastHealthIndicator.class);
			Health health = context.getBean(HazelcastHealthIndicator.class).health();
			assertThat(health.getStatus()).isEqualTo(Status.DOWN);
		});
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.hazelcast;
/**
class HazelcastHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class,
				HazelcastHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(HazelcastHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.hazelcast.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(HazelcastHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
class InfoContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(InfoContributorAutoConfiguration.class));
	@Test
	void envContributor() {
		this.contextRunner.withPropertyValues('management.info.env.enabled=true')
			.run((context) -> assertThat(context).hasSingleBean(EnvironmentInfoContributor.class));
	}
	@Test
	void defaultInfoContributorsEnabled() {
		this.contextRunner.run(
				(context) -> assertThat(context).doesNotHaveBean(InfoContributor.class).doesNotHaveBean(SslInfo.class));
	}
	@Test
	void defaultInfoContributorsEnabledWithPrerequisitesInPlace() {
		this.contextRunner.withUserConfiguration(GitPropertiesConfiguration.class, BuildPropertiesConfiguration.class)
			.run((context) -> assertThat(context.getBeansOfType(InfoContributor.class)).hasSize(2)
				.satisfies((contributors) -> assertThat(contributors.values())
					.hasOnlyElementsOfTypes(BuildInfoContributor.class, GitInfoContributor.class)));
	}
	@Test
	void defaultInfoContributorsDisabledWithPrerequisitesInPlace() {
		this.contextRunner.withUserConfiguration(GitPropertiesConfiguration.class, BuildPropertiesConfiguration.class)
			.withPropertyValues('management.info.defaults.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(InfoContributor.class));
	}
	@Test
	void defaultInfoContributorsDisabledWithCustomOne() {
		this.contextRunner.withUserConfiguration(CustomInfoContributorConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(InfoContributor.class);
			assertThat(context.getBean(InfoContributor.class)).isSameAs(context.getBean('customInfoContributor'));
		});
	}
	@SuppressWarnings('unchecked')
	@Test
	void gitPropertiesDefaultMode() {
		this.contextRunner.withUserConfiguration(GitPropertiesConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(GitInfoContributor.class);
			Map<String, Object> content = invokeContributor(context.getBean(GitInfoContributor.class));
			Object git = content.get('git');
			assertThat(git).isInstanceOf(Map.class);
			Map<String, Object> gitInfo = (Map<String, Object>) git;
			assertThat(gitInfo).containsOnlyKeys('branch', 'commit');
		});
	}
	@SuppressWarnings('unchecked')
	@Test
	void gitPropertiesFullMode() {
		this.contextRunner.withPropertyValues('management.info.git.mode=full')
			.withUserConfiguration(GitPropertiesConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(GitInfoContributor.class);
				Map<String, Object> content = invokeContributor(context.getBean(GitInfoContributor.class));
				Object git = content.get('git');
				assertThat(git).isInstanceOf(Map.class);
				Map<String, Object> gitInfo = (Map<String, Object>) git;
				assertThat(gitInfo).containsOnlyKeys('branch', 'commit', 'foo');
				assertThat(gitInfo).containsEntry('foo', 'bar');
			});
	}
	@Test
	void customGitInfoContributor() {
		this.contextRunner.withUserConfiguration(CustomGitInfoContributorConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(GitInfoContributor.class);
			assertThat(context.getBean(GitInfoContributor.class)).isSameAs(context.getBean('customGitInfoContributor'));
		});
	}
	@SuppressWarnings('unchecked')
	@Test
	void buildProperties() {
		this.contextRunner.withUserConfiguration(BuildPropertiesConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(BuildInfoContributor.class);
			Map<String, Object> content = invokeContributor(context.getBean(BuildInfoContributor.class));
			Object build = content.get('build');
			assertThat(build).isInstanceOf(Map.class);
			Map<String, Object> buildInfo = (Map<String, Object>) build;
			assertThat(buildInfo).containsOnlyKeys('group', 'artifact', 'foo');
			assertThat(buildInfo).containsEntry('foo', 'bar');
		});
	}
	@Test
	void customBuildInfoContributor() {
		this.contextRunner.withUserConfiguration(CustomBuildInfoContributorConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(BuildInfoContributor.class);
			assertThat(context.getBean(BuildInfoContributor.class))
				.isSameAs(context.getBean('customBuildInfoContributor'));
		});
	}
	@Test
	void javaInfoContributor() {
		this.contextRunner.withPropertyValues('management.info.java.enabled=true').run((context) -> {
			assertThat(context).hasSingleBean(JavaInfoContributor.class);
			Map<String, Object> content = invokeContributor(context.getBean(JavaInfoContributor.class));
			assertThat(content).containsKey('java');
			assertThat(content.get('java')).isInstanceOf(JavaInfo.class);
		});
	}
	@Test
	void osInfoContributor() {
		this.contextRunner.withPropertyValues('management.info.os.enabled=true').run((context) -> {
			assertThat(context).hasSingleBean(OsInfoContributor.class);
			Map<String, Object> content = invokeContributor(context.getBean(OsInfoContributor.class));
			assertThat(content).containsKey('os');
			assertThat(content.get('os')).isInstanceOf(OsInfo.class);
		});
	}
	@Test
	void processInfoContributor() {
		this.contextRunner.withPropertyValues('management.info.process.enabled=true').run((context) -> {
			assertThat(context).hasSingleBean(ProcessInfoContributor.class);
			Map<String, Object> content = invokeContributor(context.getBean(ProcessInfoContributor.class));
			assertThat(content).containsKey('process');
			assertThat(content.get('process')).isInstanceOf(ProcessInfo.class);
		});
	}
	@Test
	void sslInfoContributor() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(SslAutoConfiguration.class))
			.withPropertyValues('management.info.ssl.enabled=true', 'server.ssl.bundle=ssltest',
					'spring.ssl.bundle.jks.ssltest.keystore.location=classpath:test.jks')
			.run((context) -> {
				assertThat(context).hasSingleBean(SslInfoContributor.class);
				assertThat(context).hasSingleBean(SslInfo.class);
				Map<String, Object> content = invokeContributor(context.getBean(SslInfoContributor.class));
				assertThat(content).containsKey('ssl');
				assertThat(content.get('ssl')).isInstanceOf(SslInfo.class);
			});
	}
	@Test
	void sslInfoContributorWithWarningThreshold() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(SslAutoConfiguration.class))
			.withPropertyValues('management.info.ssl.enabled=true', 'server.ssl.bundle=ssltest',
					'spring.ssl.bundle.jks.ssltest.keystore.location=classpath:test.jks',
					'management.health.ssl.certificate-validity-warning-threshold=1d')
			.run((context) -> {
				assertThat(context).hasSingleBean(SslInfoContributor.class);
				assertThat(context).hasSingleBean(SslInfo.class);
				assertThat(context).hasSingleBean(SslHealthIndicatorProperties.class);
				assertThat(context.getBean(SslHealthIndicatorProperties.class).getCertificateValidityWarningThreshold())
					.isEqualTo(Duration.ofDays(1));
				Map<String, Object> content = invokeContributor(context.getBean(SslInfoContributor.class));
				assertThat(content).containsKey('ssl');
				assertThat(content.get('ssl')).isInstanceOf(SslInfo.class);
			});
	}
	@Test
	void customSslInfo() {
		this.contextRunner.withUserConfiguration(CustomSslInfoConfiguration.class)
			.withConfiguration(AutoConfigurations.of(SslAutoConfiguration.class))
			.withPropertyValues('management.info.ssl.enabled=true', 'server.ssl.bundle=ssltest',
					'spring.ssl.bundle.jks.ssltest.keystore.location=classpath:test.jks')
			.run((context) -> {
				assertThat(context).hasSingleBean(SslInfoContributor.class);
				assertThat(context).hasSingleBean(SslInfo.class);
				assertThat(context.getBean(SslInfo.class)).isSameAs(context.getBean('customSslInfo'));
				Map<String, Object> content = invokeContributor(context.getBean(SslInfoContributor.class));
				assertThat(content).containsKey('ssl');
				assertThat(content.get('ssl')).isInstanceOf(SslInfo.class);
			});
	}
	private Map<String, Object> invokeContributor(InfoContributor contributor) {
		Info.Builder builder = new Info.Builder();
		contributor.contribute(builder);
		return builder.build().getDetails();
	}
	@Configuration(proxyBeanMethods = false)
	static class GitPropertiesConfiguration {
		@Bean
		GitProperties gitProperties() {
			Properties properties = new Properties();
			properties.put('branch', 'master');
			properties.put('commit.id', 'abcdefg');
			properties.put('foo', 'bar');
			return new GitProperties(properties);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BuildPropertiesConfiguration {
		@Bean
		BuildProperties buildProperties() {
			Properties properties = new Properties();
			properties.put('group', 'com.example');
			properties.put('artifact', 'demo');
			properties.put('foo', 'bar');
			return new BuildProperties(properties);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomInfoContributorConfiguration {
		@Bean
		InfoContributor customInfoContributor() {
			return (builder) -> {
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomGitInfoContributorConfiguration {
		@Bean
		GitInfoContributor customGitInfoContributor() {
			return new GitInfoContributor(new GitProperties(new Properties()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomBuildInfoContributorConfiguration {
		@Bean
		BuildInfoContributor customBuildInfoContributor() {
			return new BuildInfoContributor(new BuildProperties(new Properties()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSslInfoConfiguration {
		@Bean
		SslInfo customSslInfo(SslBundles sslBundles) {
			return new SslInfo(sslBundles, Duration.ofDays(7));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
class InfoEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(InfoEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=info')
			.run((context) -> assertThat(context).hasSingleBean(InfoEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(InfoEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.info.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(InfoEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.system;
/**
class DiskSpaceHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DiskSpaceHealthContributorAutoConfiguration.class,
				HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(DiskSpaceHealthIndicator.class));
	}
	@Test
	void thresholdMustBePositive() {
		this.contextRunner.withPropertyValues('management.health.diskspace.threshold=-10MB')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.rootCause()
				.hasMessage('threshold must be greater than or equal to 0'));
	}
	@Test
	void thresholdCanBeCustomized() {
		this.contextRunner.withPropertyValues('management.health.diskspace.threshold=20MB').run((context) -> {
			assertThat(context).hasSingleBean(DiskSpaceHealthIndicator.class);
			assertThat(context.getBean(DiskSpaceHealthIndicator.class)).hasFieldOrPropertyWithValue('threshold',
					DataSize.ofMegabytes(20));
		});
	}
	@Test
	void runWhenPathDoesNotExistShouldCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.diskspace.path=does/not/exist')
			.run((context) -> assertThat(context).hasSingleBean(DiskSpaceHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.diskspace.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(DiskSpaceHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.neo4j;
/**
class Neo4jHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HealthContributorAutoConfiguration.class,
				Neo4jHealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateHealthIndicator() {
		this.contextRunner.withUserConfiguration(Neo4jConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Neo4jReactiveHealthIndicator.class)
				.doesNotHaveBean(Neo4jHealthIndicator.class));
	}
	@Test
	void runWithoutReactorShouldCreateHealthIndicator() {
		this.contextRunner.withUserConfiguration(Neo4jConfiguration.class)
			.withClassLoader(new FilteredClassLoader(Flux.class))
			.run((context) -> assertThat(context).hasSingleBean(Neo4jHealthIndicator.class)
				.doesNotHaveBean(Neo4jReactiveHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withUserConfiguration(Neo4jConfiguration.class)
			.withPropertyValues('management.health.neo4j.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(Neo4jHealthIndicator.class)
				.doesNotHaveBean(Neo4jReactiveHealthIndicator.class));
	}
	@Test
	void defaultIndicatorCanBeReplaced() {
		this.contextRunner.withUserConfiguration(Neo4jConfiguration.class, CustomIndicatorConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('neo4jHealthIndicator');
				Health health = context.getBean('neo4jHealthIndicator', HealthIndicator.class).health();
				assertThat(health.getDetails()).containsOnly(entry('test', true));
			});
	}
	@Test
	void shouldRequireDriverBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(Neo4jHealthIndicator.class)
			.doesNotHaveBean(Neo4jReactiveHealthIndicator.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class Neo4jConfiguration {
		@Bean
		Driver driver() {
			return mock(Driver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomIndicatorConfiguration {
		@Bean
		HealthIndicator neo4jHealthIndicator() {
			return new AbstractHealthIndicator() {
				@Override
				protected void doHealthCheck(Health.Builder builder) {
					builder.up().withDetail('test', true);
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.amqp;
/**
class RabbitHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RabbitAutoConfiguration.class,
				RabbitHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(RabbitHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.rabbit.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(RabbitHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.amqp;
/**
class RabbitMetricsAutoConfigurationMeterBinderCycleIntegrationTests {
	@Test
	void doesNotFormCycle() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(TestConfig.class);
		context.getBean(TestService.class);
		context.close();
	}
	@Configuration
	@Import({ TestService.class, RabbitAutoConfiguration.class, MetricsAutoConfiguration.class,
			SimpleMetricsExportAutoConfiguration.class, RabbitMetricsAutoConfiguration.class })
	static class TestConfig {
	}
	static class TestService implements MeterBinder {
		TestService(RabbitTemplate rabbitTemplate) {
		}
		@Override
		public void bindTo(MeterRegistry registry) {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.jmx;
/**
class JmxEndpointAutoConfigurationTests {
	private static final ContextConsumer<ConfigurableApplicationContext> NO_OPERATION = (context) -> {
	};
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(EndpointAutoConfiguration.class, JmxAutoConfiguration.class,
				JmxEndpointAutoConfiguration.class))
		.withUserConfiguration(TestEndpoint.class);
	private final MBeanServer mBeanServer = mock(MBeanServer.class);
	@Test
	void jmxEndpointWithoutJmxSupportNotAutoConfigured() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(MBeanServer.class)
			.doesNotHaveBean(JmxEndpointDiscoverer.class)
			.doesNotHaveBean(JmxEndpointExporter.class));
	}
	@Test
	void jmxEndpointWithJmxSupportAutoConfigured() {
		this.contextRunner.withPropertyValues('spring.jmx.enabled=true')
			.with(mockMBeanServer())
			.run((context) -> assertThat(context).hasSingleBean(JmxEndpointDiscoverer.class)
				.hasSingleBean(JmxEndpointExporter.class));
	}
	@Test
	void jmxEndpointWithCustomEndpointObjectNameFactory() {
		EndpointObjectNameFactory factory = mock(EndpointObjectNameFactory.class);
		this.contextRunner
			.withPropertyValues('spring.jmx.enabled=true', 'management.endpoints.jmx.exposure.include=test')
			.with(mockMBeanServer())
			.withBean(EndpointObjectNameFactory.class, () -> factory)
			.run((context) -> then(factory).should()
				.getObjectName(assertArg((jmxEndpoint) -> assertThat(jmxEndpoint.getEndpointId().toLowerCaseString())
					.isEqualTo('test'))));
	}
	@Test
	void jmxEndpointWithContextHierarchyGeneratesUniqueNamesForEachEndpoint() throws Exception {
		given(this.mBeanServer.queryNames(any(), any()))
			.willReturn(new HashSet<>(Arrays.asList(new ObjectName('test:test=test'))));
		ArgumentCaptor<ObjectName> objectName = ArgumentCaptor.forClass(ObjectName.class);
		ApplicationContextRunner jmxEnabledContextRunner = this.contextRunner
			.withPropertyValues('spring.jmx.enabled=true', 'management.endpoints.jmx.exposure.include=test');
		jmxEnabledContextRunner.with(mockMBeanServer()).run((parent) -> {
			jmxEnabledContextRunner.withParent(parent).run(NO_OPERATION);
			jmxEnabledContextRunner.withParent(parent).run(NO_OPERATION);
		});
		then(this.mBeanServer).should(times(3)).registerMBean(any(Object.class), objectName.capture());
		Set<ObjectName> uniqueValues = new HashSet<>(objectName.getAllValues());
		assertThat(uniqueValues).hasSize(3);
		assertThat(uniqueValues).allMatch((name) -> name.getDomain().equals('org.springframework.boot'));
		assertThat(uniqueValues).allMatch((name) -> name.getKeyProperty('type').equals('Endpoint'));
		assertThat(uniqueValues).allMatch((name) -> name.getKeyProperty('name').equals('Test'));
		assertThat(uniqueValues).allMatch((name) -> name.getKeyProperty('context') != null);
	}
	private Function<ApplicationContextRunner, ApplicationContextRunner> mockMBeanServer() {
		return (ctxRunner) -> ctxRunner.withBean('mbeanServer', MBeanServer.class, () -> this.mBeanServer);
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
		@ReadOperation
		String hello() {
			return 'hello world';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.jmx;
/**
class DefaultEndpointObjectNameFactoryTests {
	private final JmxEndpointProperties properties = new JmxEndpointProperties();
	private final JmxProperties jmxProperties = new JmxProperties();
	private final MBeanServer mBeanServer = mock(MBeanServer.class);
	private String contextId;
	@Test
	void generateObjectName() {
		ObjectName objectName = generateObjectName(endpoint(EndpointId.of('test')));
		assertThat(objectName).hasToString('org.springframework.boot:type=Endpoint,name=Test');
	}
	@Test
	void generateObjectNameWithCapitalizedId() {
		ObjectName objectName = generateObjectName(endpoint(EndpointId.of('testEndpoint')));
		assertThat(objectName).hasToString('org.springframework.boot:type=Endpoint,name=TestEndpoint');
	}
	@Test
	void generateObjectNameWithCustomDomain() {
		this.properties.setDomain('com.example.acme');
		ObjectName objectName = generateObjectName(endpoint(EndpointId.of('test')));
		assertThat(objectName).hasToString('com.example.acme:type=Endpoint,name=Test');
	}
	@Test
	void generateObjectNameWithUniqueNames() {
		this.jmxProperties.setUniqueNames(true);
		assertUniqueObjectName();
	}
	private void assertUniqueObjectName() {
		ExposableJmxEndpoint endpoint = endpoint(EndpointId.of('test'));
		String id = ObjectUtils.getIdentityHexString(endpoint);
		ObjectName objectName = generateObjectName(endpoint);
		assertThat(objectName).hasToString('org.springframework.boot:type=Endpoint,name=Test,identity=' + id);
	}
	@Test
	void generateObjectNameWithStaticNames() {
		this.properties.getStaticNames().setProperty('counter', '42');
		this.properties.getStaticNames().setProperty('foo', 'bar');
		ObjectName objectName = generateObjectName(endpoint(EndpointId.of('test')));
		assertThat(objectName.getKeyProperty('counter')).isEqualTo('42');
		assertThat(objectName.getKeyProperty('foo')).isEqualTo('bar');
		assertThat(objectName.toString()).startsWith('org.springframework.boot:type=Endpoint,name=Test,');
	}
	@Test
	void generateObjectNameWithDuplicate() throws MalformedObjectNameException {
		this.contextId = 'testContext';
		given(this.mBeanServer.queryNames(new ObjectName('org.springframework.boot:type=Endpoint,name=Test,*'), null))
			.willReturn(Collections.singleton(new ObjectName('org.springframework.boot:type=Endpoint,name=Test')));
		ObjectName objectName = generateObjectName(endpoint(EndpointId.of('test')));
		assertThat(objectName).hasToString('org.springframework.boot:type=Endpoint,name=Test,context=testContext');
	}
	private ObjectName generateObjectName(ExposableJmxEndpoint endpoint) {
		try {
			return new DefaultEndpointObjectNameFactory(this.properties, this.jmxProperties, this.mBeanServer,
					this.contextId)
				.getObjectName(endpoint);
		}
		catch (MalformedObjectNameException ex) {
			throw new AssertionError('Invalid object name', ex);
		}
	}
	private ExposableJmxEndpoint endpoint(EndpointId id) {
		ExposableJmxEndpoint endpoint = mock(ExposableJmxEndpoint.class);
		given(endpoint.getEndpointId()).willReturn(id);
		return endpoint;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
@SuppressWarnings('removal')
class ServletEndpointManagementContextConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withUserConfiguration(TestConfig.class);
	@Test
	void contextShouldContainServletEndpointRegistrar() {
		FilteredClassLoader classLoader = new FilteredClassLoader(ResourceConfig.class);
		this.contextRunner.withClassLoader(classLoader).run((context) -> {
			assertThat(context).hasSingleBean(ServletEndpointRegistrar.class);
			ServletEndpointRegistrar bean = context.getBean(ServletEndpointRegistrar.class);
			assertThat(bean).hasFieldOrPropertyWithValue('basePath', '/test/actuator');
		});
	}
	@Test
	void contextWhenJerseyShouldContainServletEndpointRegistrar() {
		FilteredClassLoader classLoader = new FilteredClassLoader(DispatcherServlet.class);
		this.contextRunner.withClassLoader(classLoader).run((context) -> {
			assertThat(context).hasSingleBean(ServletEndpointRegistrar.class);
			ServletEndpointRegistrar bean = context.getBean(ServletEndpointRegistrar.class);
			assertThat(bean).hasFieldOrPropertyWithValue('basePath', '/jersey/actuator');
		});
	}
	@Test
	void contextWhenNoServletBasedShouldNotContainServletEndpointRegistrar() {
		new ApplicationContextRunner().withUserConfiguration(TestConfig.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ServletEndpointRegistrar.class));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ServletEndpointManagementContextConfiguration.class)
	@EnableConfigurationProperties(WebEndpointProperties.class)
	static class TestConfig {
		@Bean
		ServletEndpointsSupplier servletEndpointsSupplier() {
			return Collections::emptyList;
		}
		@Bean
		DispatcherServletPath dispatcherServletPath() {
			return () -> '/test';
		}
		@Bean
		JerseyApplicationPath jerseyApplicationPath() {
			return () -> '/jersey';
		}
		@Bean
		EndpointAccessResolver endpointAccessResolver() {
			return (endpointId, defaultAccess) -> Access.UNRESTRICTED;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
class WebEndpointAutoConfigurationTests {
	private static final String V2_JSON = ApiVersion.V2.getProducedMimeType().toString();
	private static final String V3_JSON = ApiVersion.V3.getProducedMimeType().toString();
	private static final AutoConfigurations CONFIGURATIONS = AutoConfigurations.of(EndpointAutoConfiguration.class,
			WebEndpointAutoConfiguration.class);
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(CONFIGURATIONS);
	@Test
	void webApplicationConfiguresEndpointMediaTypes() {
		this.contextRunner.run((context) -> {
			EndpointMediaTypes endpointMediaTypes = context.getBean(EndpointMediaTypes.class);
			assertThat(endpointMediaTypes.getConsumed()).containsExactly(V3_JSON, V2_JSON, 'application/json');
		});
	}
	@Test
	void webApplicationConfiguresPathMapper() {
		this.contextRunner.withPropertyValues('management.endpoints.web.path-mapping.health=healthcheck')
			.run((context) -> {
				assertThat(context).hasSingleBean(PathMapper.class);
				String pathMapping = context.getBean(PathMapper.class).getRootPath(EndpointId.of('health'));
				assertThat(pathMapping).isEqualTo('healthcheck');
			});
	}
	@Test
	void webApplicationSupportCustomPathMatcher() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.web.path-mapping.testanotherone=foo')
			.withUserConfiguration(TestPathMatcher.class, TestOneEndpoint.class, TestAnotherOneEndpoint.class,
					TestTwoEndpoint.class)
			.run((context) -> {
				WebEndpointDiscoverer discoverer = context.getBean(WebEndpointDiscoverer.class);
				Collection<ExposableWebEndpoint> endpoints = discoverer.getEndpoints();
				ExposableWebEndpoint[] webEndpoints = endpoints.toArray(new ExposableWebEndpoint[0]);
				List<String> paths = Arrays.stream(webEndpoints).map(PathMappedEndpoint::getRootPath).toList();
				assertThat(paths).containsOnly('1/testone', 'foo', 'testtwo');
			});
	}
	@Test
	@SuppressWarnings('removal')
	void webApplicationConfiguresEndpointDiscoverer() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(
					org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointDiscoverer.class);
			assertThat(context).hasSingleBean(WebEndpointDiscoverer.class);
		});
	}
	@Test
	void webApplicationConfiguresExposeExcludePropertyEndpointFilter() {
		this.contextRunner.run((context) -> assertThat(context).getBeans(IncludeExcludeEndpointFilter.class)
			.containsKeys('webExposeExcludePropertyEndpointFilter', 'controllerExposeExcludePropertyEndpointFilter'));
	}
	@Test
	@SuppressWarnings('removal')
	void contextShouldConfigureServletEndpointDiscoverer() {
		this.contextRunner.run((context) -> assertThat(context)
			.hasSingleBean(org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointDiscoverer.class));
	}
	@Test
	@SuppressWarnings('removal')
	void contextWhenNotServletShouldNotConfigureServletEndpointDiscoverer() {
		new ApplicationContextRunner().withConfiguration(CONFIGURATIONS)
			.run((context) -> assertThat(context).doesNotHaveBean(
					org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointDiscoverer.class));
	}
	@Component
	static class TestPathMatcher implements PathMapper {
		@Override
		public String getRootPath(EndpointId endpointId) {
			if (endpointId.toString().endsWith('one')) {
				return '1/' + endpointId;
			}
			return null;
		}
	}
	@Component
	@Endpoint(id = 'testone')
	static class TestOneEndpoint {
		@ReadOperation
		String read() {
			return 'read';
		}
	}
	@Component
	@Endpoint(id = 'testanotherone')
	static class TestAnotherOneEndpoint {
		@ReadOperation
		String read() {
			return 'read';
		}
	}
	@Component
	@Endpoint(id = 'testtwo')
	static class TestTwoEndpoint {
		@ReadOperation
		String read() {
			return 'read';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.jersey;
/**
class JerseyWebEndpointManagementContextConfigurationTests {
	private final WebApplicationContextRunner runner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(WebEndpointAutoConfiguration.class,
				JerseyWebEndpointManagementContextConfiguration.class))
		.withBean(WebEndpointsSupplier.class, () -> Collections::emptyList)
		.withBean(EndpointAccessResolver.class, () -> (endpointId, defaultAccess) -> Access.UNRESTRICTED);
	@Test
	void jerseyWebEndpointsResourcesRegistrarForEndpointsIsAutoConfigured() {
		this.runner.run((context) -> assertThat(context).hasSingleBean(JerseyWebEndpointsResourcesRegistrar.class));
	}
	@Test
	void autoConfigurationIsConditionalOnServletWebApplication() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(JerseySameManagementContextConfiguration.class));
		contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(JerseySameManagementContextConfiguration.class));
	}
	@Test
	void autoConfigurationIsConditionalOnClassResourceConfig() {
		this.runner.withClassLoader(new FilteredClassLoader(ResourceConfig.class))
			.run((context) -> assertThat(context).doesNotHaveBean(JerseySameManagementContextConfiguration.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.jersey;
/**
class JerseyWebEndpointIntegrationTests {
	@Test
	void whenJerseyIsConfiguredToUseAFilterThenResourceRegistrationSucceeds() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(
					AutoConfigurations.of(JerseySameManagementContextConfiguration.class, JerseyAutoConfiguration.class,
							ServletWebServerFactoryAutoConfiguration.class, EndpointAutoConfiguration.class,
							WebEndpointAutoConfiguration.class, JerseyWebEndpointManagementContextConfiguration.class))
			.withUserConfiguration(ResourceConfigConfiguration.class)
			.withClassLoader(new FilteredClassLoader(DispatcherServlet.class))
			.withPropertyValues('spring.jersey.type=filter', 'server.port=0')
			.run((context) -> {
				assertThat(context).hasNotFailed();
				Set<Resource> resources = context.getBean(ResourceConfig.class).getResources();
				assertThat(resources).hasSize(1);
				Resource resource = resources.iterator().next();
				assertThat(resource.getPath()).isEqualTo('/actuator');
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class ResourceConfigConfiguration {
		@Bean
		ResourceConfig resourceConfig() {
			return new ResourceConfig();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
@ExtendWith(RestDocumentationExtension.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.main.web-application-type=reactive')
class MappingsEndpointReactiveDocumentationTests extends AbstractEndpointDocumentationTests {
	@LocalServerPort
	private int port;
	private WebTestClient client;
	@BeforeEach
	void webTestClient(RestDocumentationContextProvider restDocumentation) {
		this.client = WebTestClient.bindToServer()
			.filter(documentationConfiguration(restDocumentation).snippets().withDefaults())
			.baseUrl('http://localhost:' + this.port)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	@Test
	void mappings() {
		List<FieldDescriptor> requestMappingConditions = List.of(
				requestMappingConditionField('').description('Details of the request mapping conditions.').optional(),
				requestMappingConditionField('.consumes').description('Details of the consumes condition'),
				requestMappingConditionField('.consumes.[].mediaType').description('Consumed media type.'),
				requestMappingConditionField('.consumes.[].negated').description('Whether the media type is negated.'),
				requestMappingConditionField('.headers').description('Details of the headers condition.'),
				requestMappingConditionField('.headers.[].name').description('Name of the header.'),
				requestMappingConditionField('.headers.[].value').description('Required value of the header, if any.'),
				requestMappingConditionField('.headers.[].negated').description('Whether the value is negated.'),
				requestMappingConditionField('.methods').description('HTTP methods that are handled.'),
				requestMappingConditionField('.params').description('Details of the params condition.'),
				requestMappingConditionField('.params.[].name').description('Name of the parameter.'),
				requestMappingConditionField('.params.[].value')
					.description('Required value of the parameter, if any.'),
				requestMappingConditionField('.params.[].negated').description('Whether the value is negated.'),
				requestMappingConditionField('.patterns')
					.description('Patterns identifying the paths handled by the mapping.'),
				requestMappingConditionField('.produces').description('Details of the produces condition.'),
				requestMappingConditionField('.produces.[].mediaType').description('Produced media type.'),
				requestMappingConditionField('.produces.[].negated').description('Whether the media type is negated.'));
		List<FieldDescriptor> handlerMethod = List.of(
				fieldWithPath('*.[].details.handlerMethod').optional()
					.type(JsonFieldType.OBJECT)
					.description('Details of the method, if any, that will handle requests to this mapping.'),
				fieldWithPath('*.[].details.handlerMethod.className').type(JsonFieldType.STRING)
					.description('Fully qualified name of the class of the method.'),
				fieldWithPath('*.[].details.handlerMethod.name').type(JsonFieldType.STRING)
					.description('Name of the method.'),
				fieldWithPath('*.[].details.handlerMethod.descriptor').type(JsonFieldType.STRING)
					.description('Descriptor of the method as specified in the Java Language Specification.'));
		List<FieldDescriptor> handlerFunction = List.of(
				fieldWithPath('*.[].details.handlerFunction').optional()
					.type(JsonFieldType.OBJECT)
					.description('Details of the function, if any, that will handle requests to this mapping.'),
				fieldWithPath('*.[].details.handlerFunction.className').type(JsonFieldType.STRING)
					.description('Fully qualified name of the class of the function.'));
		List<FieldDescriptor> dispatcherHandlerFields = new ArrayList<>(List.of(
				fieldWithPath('*')
					.description('Dispatcher handler mappings, if any, keyed by dispatcher handler bean name.'),
				fieldWithPath('*.[].details').optional()
					.type(JsonFieldType.OBJECT)
					.description('Additional implementation-specific details about the mapping. Optional.'),
				fieldWithPath('*.[].handler').description('Handler for the mapping.'),
				fieldWithPath('*.[].predicate').description('Predicate for the mapping.')));
		dispatcherHandlerFields.addAll(requestMappingConditions);
		dispatcherHandlerFields.addAll(handlerMethod);
		dispatcherHandlerFields.addAll(handlerFunction);
		this.client.get()
			.uri('/actuator/mappings')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.consumeWith(document('mappings', responseFields(
					beneathPath('contexts.*.mappings.dispatcherHandlers').withSubsectionId('dispatcher-handlers'),
					dispatcherHandlerFields)));
	}
	private FieldDescriptor requestMappingConditionField(String path) {
		return fieldWithPath('*.[].details.requestMappingConditions' + path);
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		NettyReactiveWebServerFactory netty() {
			return new NettyReactiveWebServerFactory(0);
		}
		@Bean
		DispatcherHandlersMappingDescriptionProvider dispatcherHandlersMappingDescriptionProvider() {
			return new DispatcherHandlersMappingDescriptionProvider();
		}
		@Bean
		MappingsEndpoint mappingsEndpoint(Collection<MappingDescriptionProvider> descriptionProviders,
				ConfigurableApplicationContext context) {
			return new MappingsEndpoint(descriptionProviders, context);
		}
		@Bean
		RouterFunction<ServerResponse> exampleRouter() {
			return route(GET('/foo'), (request) -> ServerResponse.ok().build());
		}
		@Bean
		ExampleController exampleController() {
			return new ExampleController();
		}
	}
	@RestController
	static class ExampleController {
		@PostMapping(path = '/', consumes = { MediaType.APPLICATION_JSON_VALUE, '!application/xml' },
				produces = MediaType.TEXT_PLAIN_VALUE, headers = 'X-Custom=Foo', params = 'a!=alpha')
		String example() {
			return 'Hello World';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class LiquibaseEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void liquibase() {
		FieldDescriptor changeSetsField = fieldWithPath('contexts.*.liquibaseBeans.*.changeSets')
			.description('Change sets made by the Liquibase beans, keyed by bean name.');
		assertThat(this.mvc.get().uri('/actuator/liquibase')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('liquibase',
					responseFields(fieldWithPath('contexts').description('Application contexts keyed by id'),
							changeSetsField)
						.andWithPrefix('contexts.*.liquibaseBeans.*.changeSets[].', getChangeSetFieldDescriptors())
						.and(parentIdField())));
	}
	private List<FieldDescriptor> getChangeSetFieldDescriptors() {
		return List.of(fieldWithPath('author').description('Author of the change set.'),
				fieldWithPath('changeLog').description('Change log that contains the change set.'),
				fieldWithPath('comments').description('Comments on the change set.'),
				fieldWithPath('contexts').description('Contexts of the change set.'),
				fieldWithPath('dateExecuted').description('Timestamp of when the change set was executed.'),
				fieldWithPath('deploymentId').description('ID of the deployment that ran the change set.'),
				fieldWithPath('description').description('Description of the change set.'),
				fieldWithPath('execType')
					.description('Execution type of the change set (' + describeEnumValues(ExecType.class) + ').'),
				fieldWithPath('id').description('ID of the change set.'),
				fieldWithPath('labels').description('Labels associated with the change set.'),
				fieldWithPath('checksum').description('Checksum of the change set.'),
				fieldWithPath('orderExecuted').description('Order of the execution of the change set.'),
				fieldWithPath('tag').description('Tag associated with the change set, if any.')
					.optional()
					.type(JsonFieldType.STRING));
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ BaseDocumentationConfiguration.class, EmbeddedDataSourceConfiguration.class,
			LiquibaseAutoConfiguration.class })
	static class TestConfiguration {
		@Bean
		LiquibaseEndpoint endpoint(ApplicationContext context) {
			return new LiquibaseEndpoint(context);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class HttpExchangesEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@MockitoBean
	private HttpExchangeRepository repository;
	@Test
	void httpExchanges() {
		RecordableHttpRequest request = mock(RecordableHttpRequest.class);
		given(request.getUri()).willReturn(URI.create('https://api.example.com'));
		given(request.getMethod()).willReturn('GET');
		given(request.getHeaders())
			.willReturn(Collections.singletonMap(HttpHeaders.ACCEPT, List.of('application/json')));
		RecordableHttpResponse response = mock(RecordableHttpResponse.class);
		given(response.getStatus()).willReturn(200);
		given(response.getHeaders())
			.willReturn(Collections.singletonMap(HttpHeaders.CONTENT_TYPE, List.of('application/json')));
		Principal principal = mock(Principal.class);
		given(principal.getName()).willReturn('alice');
		Instant instant = Instant.parse('2022-12-22T13:43:41.00Z');
		Clock start = Clock.fixed(instant, ZoneId.systemDefault());
		Clock end = Clock.offset(start, Duration.ofMillis(23));
		HttpExchange exchange = HttpExchange.start(start, request)
			.finish(end, response, () -> principal, () -> UUID.randomUUID().toString(), EnumSet.allOf(Include.class));
		given(this.repository.findAll()).willReturn(List.of(exchange));
		assertThat(this.mvc.get().uri('/actuator/httpexchanges')).hasStatusOk()
			.apply(document('httpexchanges', responseFields(
					fieldWithPath('exchanges').description('An array of HTTP request-response exchanges.'),
					fieldWithPath('exchanges.[].timestamp').description('Timestamp of when the exchange occurred.'),
					fieldWithPath('exchanges.[].principal').description('Principal of the exchange, if any.')
						.optional(),
					fieldWithPath('exchanges.[].principal.name').description('Name of the principal.').optional(),
					fieldWithPath('exchanges.[].request.method').description('HTTP method of the request.'),
					fieldWithPath('exchanges.[].request.remoteAddress')
						.description('Remote address from which the request was received, if known.')
						.optional()
						.type(JsonFieldType.STRING),
					fieldWithPath('exchanges.[].request.uri').description('URI of the request.'),
					fieldWithPath('exchanges.[].request.headers')
						.description('Headers of the request, keyed by header name.'),
					fieldWithPath('exchanges.[].request.headers.*.[]').description('Values of the header'),
					fieldWithPath('exchanges.[].response.status').description('Status of the response'),
					fieldWithPath('exchanges.[].response.headers')
						.description('Headers of the response, keyed by header name.'),
					fieldWithPath('exchanges.[].response.headers.*.[]').description('Values of the header'),
					fieldWithPath('exchanges.[].session').description('Session associated with the exchange, if any.')
						.optional(),
					fieldWithPath('exchanges.[].session.id').description('ID of the session.'),
					fieldWithPath('exchanges.[].timeTaken').description('Time taken to handle the exchange.'))));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		HttpExchangesEndpoint httpExchangesEndpoint(HttpExchangeRepository repository) {
			return new HttpExchangesEndpoint(repository);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
@ExtendWith(RestDocumentationExtension.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MappingsEndpointServletDocumentationTests extends AbstractEndpointDocumentationTests {
	@LocalServerPort
	private int port;
	private WebTestClient client;
	@BeforeEach
	void webTestClient(RestDocumentationContextProvider restDocumentation) {
		this.client = WebTestClient.bindToServer()
			.filter(documentationConfiguration(restDocumentation))
			.baseUrl('http://localhost:' + this.port)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	@Test
	void mappings() {
		ResponseFieldsSnippet commonResponseFields = responseFields(
				fieldWithPath('contexts').description('Application contexts keyed by id.'),
				fieldWithPath('contexts.*.mappings').description('Mappings in the context, keyed by mapping type.'),
				subsectionWithPath('contexts.*.mappings.dispatcherServlets')
					.description('Dispatcher servlet mappings, if any.'),
				subsectionWithPath('contexts.*.mappings.servletFilters')
					.description('Servlet filter mappings, if any.'),
				subsectionWithPath('contexts.*.mappings.servlets').description('Servlet mappings, if any.'),
				subsectionWithPath('contexts.*.mappings.dispatcherHandlers')
					.description('Dispatcher handler mappings, if any.')
					.optional()
					.type(JsonFieldType.OBJECT),
				parentIdField());
		List<FieldDescriptor> dispatcherServletFields = new ArrayList<>(List.of(
				fieldWithPath('*')
					.description('Dispatcher servlet mappings, if any, keyed by dispatcher servlet bean name.'),
				fieldWithPath('*.[].details').optional()
					.type(JsonFieldType.OBJECT)
					.description('Additional implementation-specific details about the mapping. Optional.'),
				fieldWithPath('*.[].handler').description('Handler for the mapping.'),
				fieldWithPath('*.[].predicate').description('Predicate for the mapping.')));
		List<FieldDescriptor> requestMappingConditions = List.of(
				requestMappingConditionField('').description('Details of the request mapping conditions.').optional(),
				requestMappingConditionField('.consumes').description('Details of the consumes condition'),
				requestMappingConditionField('.consumes.[].mediaType').description('Consumed media type.'),
				requestMappingConditionField('.consumes.[].negated').description('Whether the media type is negated.'),
				requestMappingConditionField('.headers').description('Details of the headers condition.'),
				requestMappingConditionField('.headers.[].name').description('Name of the header.'),
				requestMappingConditionField('.headers.[].value').description('Required value of the header, if any.'),
				requestMappingConditionField('.headers.[].negated').description('Whether the value is negated.'),
				requestMappingConditionField('.methods').description('HTTP methods that are handled.'),
				requestMappingConditionField('.params').description('Details of the params condition.'),
				requestMappingConditionField('.params.[].name').description('Name of the parameter.'),
				requestMappingConditionField('.params.[].value')
					.description('Required value of the parameter, if any.'),
				requestMappingConditionField('.params.[].negated').description('Whether the value is negated.'),
				requestMappingConditionField('.patterns')
					.description('Patterns identifying the paths handled by the mapping.'),
				requestMappingConditionField('.produces').description('Details of the produces condition.'),
				requestMappingConditionField('.produces.[].mediaType').description('Produced media type.'),
				requestMappingConditionField('.produces.[].negated').description('Whether the media type is negated.'));
		List<FieldDescriptor> handlerMethod = List.of(
				fieldWithPath('*.[].details.handlerMethod').optional()
					.type(JsonFieldType.OBJECT)
					.description('Details of the method, if any, that will handle requests to this mapping.'),
				fieldWithPath('*.[].details.handlerMethod.className')
					.description('Fully qualified name of the class of the method.'),
				fieldWithPath('*.[].details.handlerMethod.name').description('Name of the method.'),
				fieldWithPath('*.[].details.handlerMethod.descriptor')
					.description('Descriptor of the method as specified in the Java Language Specification.'));
		dispatcherServletFields.addAll(handlerMethod);
		dispatcherServletFields.addAll(requestMappingConditions);
		this.client.get()
			.uri('/actuator/mappings')
			.exchange()
			.expectBody()
			.consumeWith(document('mappings', commonResponseFields,
					responseFields(beneathPath('contexts.*.mappings.dispatcherServlets')
						.withSubsectionId('dispatcher-servlets'), dispatcherServletFields),
					responseFields(
							beneathPath('contexts.*.mappings.servletFilters').withSubsectionId('servlet-filters'),
							fieldWithPath('[].servletNameMappings')
								.description('Names of the servlets to which the filter is mapped.'),
							fieldWithPath('[].urlPatternMappings')
								.description('URL pattern to which the filter is mapped.'),
							fieldWithPath('[].name').description('Name of the filter.'),
							fieldWithPath('[].className').description('Class name of the filter')),
					responseFields(beneathPath('contexts.*.mappings.servlets').withSubsectionId('servlets'),
							fieldWithPath('[].mappings').description('Mappings of the servlet.'),
							fieldWithPath('[].name').description('Name of the servlet.'),
							fieldWithPath('[].className').description('Class name of the servlet'))));
	}
	private FieldDescriptor requestMappingConditionField(String path) {
		return fieldWithPath('*.[].details.requestMappingConditions' + path);
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		DispatcherServletsMappingDescriptionProvider dispatcherServletsMappingDescriptionProvider() {
			return new DispatcherServletsMappingDescriptionProvider();
		}
		@Bean
		ServletsMappingDescriptionProvider servletsMappingDescriptionProvider() {
			return new ServletsMappingDescriptionProvider();
		}
		@Bean
		FiltersMappingDescriptionProvider filtersMappingDescriptionProvider() {
			return new FiltersMappingDescriptionProvider();
		}
		@Bean
		MappingsEndpoint mappingsEndpoint(Collection<MappingDescriptionProvider> descriptionProviders,
				ConfigurableApplicationContext context) {
			return new MappingsEndpoint(descriptionProviders, context);
		}
		@Bean
		ExampleController exampleController() {
			return new ExampleController();
		}
	}
	@RestController
	static class ExampleController {
		@PostMapping(path = '/', consumes = { MediaType.APPLICATION_JSON_VALUE, '!application/xml' },
				produces = MediaType.TEXT_PLAIN_VALUE, headers = 'X-Custom=Foo', params = 'a!=alpha')
		String example() {
			return 'Hello World';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class InfoEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void info() {
		assertThat(this.mvc.get().uri('/actuator/info')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('info',
					responseFields(beneathPath('git'),
							fieldWithPath('branch').description('Name of the Git branch, if any.'),
							fieldWithPath('commit').description('Details of the Git commit, if any.'),
							fieldWithPath('commit.time').description('Timestamp of the commit, if any.')
								.type(JsonFieldType.VARIES),
							fieldWithPath('commit.id').description('ID of the commit, if any.')),
					responseFields(beneathPath('build'),
							fieldWithPath('artifact').description('Artifact ID of the application, if any.').optional(),
							fieldWithPath('group').description('Group ID of the application, if any.').optional(),
							fieldWithPath('name').description('Name of the application, if any.')
								.type(JsonFieldType.STRING)
								.optional(),
							fieldWithPath('version').description('Version of the application, if any.').optional(),
							fieldWithPath('time').description('Timestamp of when the application was built, if any.')
								.type(JsonFieldType.VARIES)
								.optional())));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		InfoEndpoint endpoint(List<InfoContributor> infoContributors) {
			return new InfoEndpoint(infoContributors);
		}
		@Bean
		GitInfoContributor gitInfoContributor() {
			Properties properties = new Properties();
			properties.put('branch', 'main');
			properties.put('commit.id', 'df027cf1ec5aeba2d4fedd7b8c42b88dc5ce38e5');
			properties.put('commit.id.abbrev', 'df027cf');
			properties.put('commit.time', Long.toString(Instant.now().getEpochSecond()));
			GitProperties gitProperties = new GitProperties(properties);
			return new GitInfoContributor(gitProperties);
		}
		@Bean
		BuildInfoContributor buildInfoContributor() {
			Properties properties = new Properties();
			properties.put('group', 'com.example');
			properties.put('artifact', 'application');
			properties.put('version', '1.0.3');
			BuildProperties buildProperties = new BuildProperties(properties);
			return new BuildInfoContributor(buildProperties);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class AuditEventsEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@MockitoBean
	private AuditEventRepository repository;
	@Test
	void allAuditEvents() {
		String queryTimestamp = '2017-11-07T09:37Z';
		given(this.repository.find(any(), any(), any()))
			.willReturn(List.of(new AuditEvent('alice', 'logout', Collections.emptyMap())));
		assertThat(this.mvc.get().uri('/actuator/auditevents').param('after', queryTimestamp)).hasStatusOk()
			.apply(document('auditevents/all',
					responseFields(fieldWithPath('events').description('An array of audit events.'),
							fieldWithPath('events.[].timestamp')
								.description('The timestamp of when the event occurred.'),
							fieldWithPath('events.[].principal').description('The principal that triggered the event.'),
							fieldWithPath('events.[].type').description('The type of the event.'))));
	}
	@Test
	void filteredAuditEvents() {
		OffsetDateTime now = OffsetDateTime.now();
		String queryTimestamp = DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(now);
		given(this.repository.find('alice', now.toInstant(), 'logout'))
			.willReturn(List.of(new AuditEvent('alice', 'logout', Collections.emptyMap())));
		assertThat(this.mvc.get()
			.uri('/actuator/auditevents')
			.param('principal', 'alice')
			.param('after', queryTimestamp)
			.param('type', 'logout'))
			.hasStatusOk()
			.apply(document('auditevents/filtered',
					queryParameters(
							parameterWithName('after').description(
									'Restricts the events to those that occurred after the given time. Optional.'),
							parameterWithName('principal')
								.description('Restricts the events to those with the given principal. Optional.'),
							parameterWithName('type')
								.description('Restricts the events to those with the given type. Optional.'))));
		then(this.repository).should().find('alice', now.toInstant(), 'logout');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		AuditEventsEndpoint auditEventsEndpoint(AuditEventRepository repository) {
			return new AuditEventsEndpoint(repository);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class ThreadDumpEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void jsonThreadDump() {
		ReentrantLock lock = new ReentrantLock();
		CountDownLatch latch = new CountDownLatch(1);
		new Thread(() -> {
			try {
				lock.lock();
				try {
					latch.await();
				}
				finally {
					lock.unlock();
				}
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}).start();
		assertThat(this.mvc.get().uri('/actuator/threaddump').accept(MediaType.APPLICATION_JSON)).hasStatusOk()
			.apply(MockMvcRestDocumentation
				.document('threaddump/json', preprocessResponse(limit('threads')), responseFields(
						fieldWithPath('threads').description('JVM"s threads.'),
						fieldWithPath('threads.[].blockedCount')
							.description('Total number of times that the thread has been blocked.'),
						fieldWithPath('threads.[].blockedTime')
							.description('Time in milliseconds that the thread has spent '
									+ 'blocked. -1 if thread contention ' + 'monitoring is disabled.'),
						fieldWithPath('threads.[].daemon')
							.description(
									'Whether the thread is a daemon ' + 'thread. Only available on Java 9 or later.')
							.optional()
							.type(JsonFieldType.BOOLEAN),
						fieldWithPath('threads.[].inNative')
							.description('Whether the thread is executing native code.'),
						fieldWithPath('threads.[].lockName')
							.description('Description of the object on which the ' + 'thread is blocked, if any.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].lockInfo')
							.description('Object for which the thread is blocked waiting.')
							.optional()
							.type(JsonFieldType.OBJECT),
						fieldWithPath('threads.[].lockInfo.className')
							.description('Fully qualified class name of the lock object.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].lockInfo.identityHashCode')
							.description('Identity hash code of the lock object.')
							.optional()
							.type(JsonFieldType.NUMBER),
						fieldWithPath('threads.[].lockedMonitors')
							.description('Monitors locked by this thread, if any'),
						fieldWithPath('threads.[].lockedMonitors.[].className')
							.description('Class name of the lock object.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].lockedMonitors.[].identityHashCode')
							.description('Identity hash code of the lock object.')
							.optional()
							.type(JsonFieldType.NUMBER),
						fieldWithPath('threads.[].lockedMonitors.[].lockedStackDepth')
							.description('Stack depth where the monitor was locked.')
							.optional()
							.type(JsonFieldType.NUMBER),
						subsectionWithPath('threads.[].lockedMonitors.[].lockedStackFrame')
							.description('Stack frame that locked the monitor.')
							.optional()
							.type(JsonFieldType.OBJECT),
						fieldWithPath('threads.[].lockedSynchronizers')
							.description('Synchronizers locked by this thread.'),
						fieldWithPath('threads.[].lockedSynchronizers.[].className')
							.description('Class name of the locked synchronizer.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].lockedSynchronizers.[].identityHashCode')
							.description('Identity hash code of the locked synchronizer.')
							.optional()
							.type(JsonFieldType.NUMBER),
						fieldWithPath('threads.[].lockOwnerId')
							.description('ID of the thread that owns the object on which '
									+ 'the thread is blocked. `-1` if the ' + 'thread is not blocked.'),
						fieldWithPath('threads.[].lockOwnerName')
							.description('Name of the thread that owns the '
									+ 'object on which the thread is blocked, if any.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].priority')
							.description('Priority of the thread. Only ' + 'available on Java 9 or later.')
							.optional()
							.type(JsonFieldType.NUMBER),
						fieldWithPath('threads.[].stackTrace').description('Stack trace of the thread.'),
						fieldWithPath('threads.[].stackTrace.[].classLoaderName')
							.description('Name of the class loader of the ' + 'class that contains the execution '
									+ 'point identified by this entry, if ' + 'any. Only available on Java 9 or later.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].stackTrace.[].className').description(
								'Name of the class that contains the ' + 'execution point identified by this entry.'),
						fieldWithPath('threads.[].stackTrace.[].fileName')
							.description('Name of the source file that ' + 'contains the execution point '
									+ 'identified by this entry, if any.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].stackTrace.[].lineNumber').description('Line number of the execution '
								+ 'point identified by this entry. ' + 'Negative if unknown.'),
						fieldWithPath('threads.[].stackTrace.[].methodName').description('Name of the method.'),
						fieldWithPath('threads.[].stackTrace.[].moduleName')
							.description('Name of the module that contains ' + 'the execution point identified by '
									+ 'this entry, if any. Only available ' + 'on Java 9 or later.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].stackTrace.[].moduleVersion')
							.description('Version of the module that ' + 'contains the execution point '
									+ 'identified by this entry, if any. ' + 'Only available on Java 9 or later.')
							.optional()
							.type(JsonFieldType.STRING),
						fieldWithPath('threads.[].stackTrace.[].nativeMethod')
							.description('Whether the execution point is a native method.'),
						fieldWithPath('threads.[].suspended').description('Whether the thread is suspended.'),
						fieldWithPath('threads.[].threadId').description('ID of the thread.'),
						fieldWithPath('threads.[].threadName').description('Name of the thread.'),
						fieldWithPath('threads.[].threadState')
							.description('State of the thread (' + describeEnumValues(Thread.State.class) + ').'),
						fieldWithPath('threads.[].waitedCount')
							.description('Total number of times that the thread has waited' + ' for notification.'),
						fieldWithPath('threads.[].waitedTime')
							.description('Time in milliseconds that the thread has spent '
									+ 'waiting. -1 if thread contention ' + 'monitoring is disabled'))));
		latch.countDown();
	}
	@Test
	void textThreadDump() {
		assertThat(this.mvc.get().uri('/actuator/threaddump').accept(MediaType.TEXT_PLAIN)).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('threaddump/text',
					preprocessResponse(new ContentModifyingOperationPreprocessor((bytes, mediaType) -> {
						String content = new String(bytes, StandardCharsets.UTF_8);
						int mainThreadIndex = content.indexOf('\'main\' - Thread');
						String truncatedContent = (mainThreadIndex >= 0) ? content.substring(0, mainThreadIndex)
								: content;
						return truncatedContent.getBytes();
					}))));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		ThreadDumpEndpoint endpoint() {
			return new ThreadDumpEndpoint();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
@TestPropertySource(properties = 'management.endpoint.shutdown.access=unrestricted')
class ShutdownEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void shutdown() {
		assertThat(this.mvc.post().uri('/actuator/shutdown')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('shutdown', responseFields(
					fieldWithPath('message').description('Message describing the result of the request.'))));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		ShutdownEndpoint endpoint() {
			ShutdownEndpoint endpoint = new ShutdownEndpoint();
			endpoint.setApplicationContext(new AnnotationConfigApplicationContext());
			return endpoint;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class IntegrationGraphEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void graph() {
		assertThat(this.mvc.get().uri('/actuator/integrationgraph')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('integrationgraph/graph'));
	}
	@Test
	void rebuild() {
		assertThat(this.mvc.post().uri('/actuator/integrationgraph')).hasStatus(HttpStatus.NO_CONTENT)
			.apply(MockMvcRestDocumentation.document('integrationgraph/rebuild'));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableIntegration
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		IntegrationGraphServer integrationGraphServer() {
			return new IntegrationGraphServer();
		}
		@Bean
		IntegrationGraphEndpoint endpoint(IntegrationGraphServer integrationGraphServer) {
			return new IntegrationGraphEndpoint(integrationGraphServer);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class SbomEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void sbom() {
		assertThat(this.mvc.get().uri('/actuator/sbom')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('sbom',
					responseFields(fieldWithPath('ids').description('An array of available SBOM ids.'))));
	}
	@Test
	void sboms() {
		assertThat(this.mvc.get().uri('/actuator/sbom/application')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('sbom/id'));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		SbomProperties sbomProperties() {
			SbomProperties properties = new SbomProperties();
			properties.getApplication().setLocation('classpath:sbom/cyclonedx.json');
			return properties;
		}
		@Bean
		SbomEndpoint endpoint(SbomProperties properties, ResourceLoader resourceLoader) {
			return new SbomEndpoint(properties, resourceLoader);
		}
		@Bean
		SbomEndpointWebExtension sbomEndpointWebExtension(SbomEndpoint endpoint, SbomProperties properties) {
			return new SbomEndpointWebExtension(endpoint, properties);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class QuartzEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	private static final TimeZone timeZone = TimeZone.getTimeZone('Europe/Paris');
	private static final JobDetail jobOne = JobBuilder.newJob(DelegatingJob.class)
		.withIdentity('jobOne', 'samples')
		.withDescription('A sample job')
		.usingJobData('user', 'admin')
		.usingJobData('password', 'secret')
		.build();
	private static final JobDetail jobTwo = JobBuilder.newJob(Job.class).withIdentity('jobTwo', 'samples').build();
	private static final JobDetail jobThree = JobBuilder.newJob(Job.class).withIdentity('jobThree', 'tests').build();
	private static final CronTrigger cronTrigger = TriggerBuilder.newTrigger()
		.forJob(jobOne)
		.withPriority(3)
		.withDescription('3AM on weekdays')
		.withIdentity('3am-weekdays', 'samples')
		.withSchedule(CronScheduleBuilder.atHourAndMinuteOnGivenDaysOfWeek(3, 0, 1, 2, 3, 4, 5).inTimeZone(timeZone))
		.build();
	private static final SimpleTrigger simpleTrigger = TriggerBuilder.newTrigger()
		.forJob(jobOne)
		.withPriority(7)
		.withDescription('Once a day')
		.withIdentity('every-day', 'samples')
		.withSchedule(SimpleScheduleBuilder.repeatHourlyForever(24))
		.build();
	private static final CalendarIntervalTrigger calendarIntervalTrigger = TriggerBuilder.newTrigger()
		.forJob(jobTwo)
		.withDescription('Once a week')
		.withIdentity('once-a-week', 'samples')
		.withSchedule(
				CalendarIntervalScheduleBuilder.calendarIntervalSchedule().withIntervalInWeeks(1).inTimeZone(timeZone))
		.build();
	private static final DailyTimeIntervalTrigger dailyTimeIntervalTrigger = TriggerBuilder.newTrigger()
		.forJob(jobThree)
		.withDescription('Every hour between 9AM and 6PM on Tuesday and Thursday')
		.withIdentity('every-hour-tue-thu')
		.withSchedule(DailyTimeIntervalScheduleBuilder.dailyTimeIntervalSchedule()
			.onDaysOfTheWeek(Calendar.TUESDAY, Calendar.THURSDAY)
			.startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0))
			.endingDailyAt(TimeOfDay.hourAndMinuteOfDay(18, 0))
			.withInterval(1, IntervalUnit.HOUR))
		.build();
	private static final List<FieldDescriptor> triggerSummary = List.of(previousFireTime(''), nextFireTime(''),
			priority(''));
	private static final List<FieldDescriptor> cronTriggerSummary = List.of(
			fieldWithPath('expression').description('Cron expression to use.'),
			fieldWithPath('timeZone').type(JsonFieldType.STRING)
				.optional()
				.description('Time zone for which the expression will be resolved, if any.'));
	private static final List<FieldDescriptor> simpleTriggerSummary = Collections
		.singletonList(fieldWithPath('interval').description('Interval, in milliseconds, between two executions.'));
	private static final List<FieldDescriptor> dailyTimeIntervalTriggerSummary = Arrays
		.asList(fieldWithPath('interval').description(
				'Interval, in milliseconds, added to the fire time in order to calculate the time of the next trigger repeat.'),
				fieldWithPath('daysOfWeek').type(JsonFieldType.ARRAY)
					.description('An array of days of the week upon which to fire.'),
				fieldWithPath('startTimeOfDay').type(JsonFieldType.STRING)
					.description('Time of day to start firing at the given interval, if any.'),
				fieldWithPath('endTimeOfDay').type(JsonFieldType.STRING)
					.description('Time of day to complete firing at the given interval, if any.'));
	private static final List<FieldDescriptor> calendarIntervalTriggerSummary = Arrays
		.asList(fieldWithPath('interval').description(
				'Interval, in milliseconds, added to the fire time in order to calculate the time of the next trigger repeat.'),
				fieldWithPath('timeZone').type(JsonFieldType.STRING)
					.description('Time zone within which time calculations will be performed, if any.'));
	private static final List<FieldDescriptor> customTriggerSummary = List
		.of(fieldWithPath('trigger').description('A toString representation of the custom trigger instance.'));
	private static final FieldDescriptor[] commonCronDetails = new FieldDescriptor[] {
			fieldWithPath('group').description('Name of the group.'),
			fieldWithPath('name').description('Name of the trigger.'),
			fieldWithPath('description').description('Description of the trigger, if any.'),
			fieldWithPath('state')
				.description('State of the trigger (' + describeEnumValues(TriggerState.class) + ').'),
			fieldWithPath('type').description(
					'Type of the trigger (`calendarInterval`, `cron`, `custom`, `dailyTimeInterval`, `simple`). '
							+ 'Determines the key of the object containing type-specific details.'),
			fieldWithPath('calendarName').description('Name of the Calendar associated with this Trigger, if any.'),
			startTime(''), endTime(''), previousFireTime(''), nextFireTime(''), priority(''),
			fieldWithPath('finalFireTime').optional()
				.type(JsonFieldType.STRING)
				.description('Last time at which the Trigger will fire, if any.'),
			fieldWithPath('data').optional()
				.type(JsonFieldType.OBJECT)
				.description('Job data map keyed by name, if any.') };
	@MockitoBean
	private Scheduler scheduler;
	@Test
	void quartzReport() throws Exception {
		mockJobs(jobOne, jobTwo, jobThree);
		mockTriggers(cronTrigger, simpleTrigger, calendarIntervalTrigger, dailyTimeIntervalTrigger);
		assertThat(this.mvc.get().uri('/actuator/quartz')).hasStatusOk()
			.apply(document('quartz/report',
					responseFields(fieldWithPath('jobs.groups').description('An array of job group names.'),
							fieldWithPath('triggers.groups').description('An array of trigger group names.'))));
	}
	@Test
	void quartzJobs() throws Exception {
		mockJobs(jobOne, jobTwo, jobThree);
		assertThat(this.mvc.get().uri('/actuator/quartz/jobs')).hasStatusOk()
			.apply(document('quartz/jobs',
					responseFields(fieldWithPath('groups').description('Job groups keyed by name.'),
							fieldWithPath('groups.*.jobs').description('An array of job names.'))));
	}
	@Test
	void quartzTriggers() throws Exception {
		mockTriggers(cronTrigger, simpleTrigger, calendarIntervalTrigger, dailyTimeIntervalTrigger);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers')).hasStatusOk()
			.apply(document('quartz/triggers',
					responseFields(fieldWithPath('groups').description('Trigger groups keyed by name.'),
							fieldWithPath('groups.*.paused').description('Whether this trigger group is paused.'),
							fieldWithPath('groups.*.triggers').description('An array of trigger names.'))));
	}
	@Test
	void quartzJobGroup() throws Exception {
		mockJobs(jobOne, jobTwo, jobThree);
		assertThat(this.mvc.get().uri('/actuator/quartz/jobs/samples')).hasStatusOk()
			.apply(document('quartz/job-group', responseFields(fieldWithPath('group').description('Name of the group.'),
					fieldWithPath('jobs').description('Job details keyed by name.'),
					fieldWithPath('jobs.*.className').description('Fully qualified name of the job implementation.'))));
	}
	@Test
	void quartzTriggerGroup() throws Exception {
		CronTrigger cron = cronTrigger.getTriggerBuilder()
			.startAt(fromUtc('2020-11-30T17:00:00Z'))
			.endAt(fromUtc('2020-12-30T03:00:00Z'))
			.withIdentity('3am-week', 'tests')
			.build();
		setPreviousNextFireTime(cron, '2020-12-04T03:00:00Z', '2020-12-07T03:00:00Z');
		SimpleTrigger simple = simpleTrigger.getTriggerBuilder().withIdentity('every-day', 'tests').build();
		setPreviousNextFireTime(simple, null, '2020-12-04T12:00:00Z');
		CalendarIntervalTrigger calendarInterval = calendarIntervalTrigger.getTriggerBuilder()
			.withIdentity('once-a-week', 'tests')
			.startAt(fromUtc('2019-07-10T14:00:00Z'))
			.endAt(fromUtc('2023-01-01T12:00:00Z'))
			.build();
		setPreviousNextFireTime(calendarInterval, '2020-12-02T14:00:00Z', '2020-12-08T14:00:00Z');
		DailyTimeIntervalTrigger tueThuTrigger = dailyTimeIntervalTrigger.getTriggerBuilder()
			.withIdentity('tue-thu', 'tests')
			.build();
		Trigger customTrigger = mock(Trigger.class);
		given(customTrigger.getKey()).willReturn(TriggerKey.triggerKey('once-a-year-custom', 'tests'));
		given(customTrigger.toString()).willReturn('com.example.CustomTrigger@fdsfsd');
		given(customTrigger.getPriority()).willReturn(10);
		given(customTrigger.getPreviousFireTime()).willReturn(fromUtc('2020-07-14T16:00:00Z'));
		given(customTrigger.getNextFireTime()).willReturn(fromUtc('2021-07-14T16:00:00Z'));
		mockTriggers(cron, simple, calendarInterval, tueThuTrigger, customTrigger);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers/tests')).hasStatusOk()
			.apply(document('quartz/trigger-group',
					responseFields(fieldWithPath('group').description('Name of the group.'),
							fieldWithPath('paused').description('Whether the group is paused.'),
							fieldWithPath('triggers.cron').description('Cron triggers keyed by name, if any.'),
							fieldWithPath('triggers.simple').description('Simple triggers keyed by name, if any.'),
							fieldWithPath('triggers.dailyTimeInterval')
								.description('Daily time interval triggers keyed by name, if any.'),
							fieldWithPath('triggers.calendarInterval')
								.description('Calendar interval triggers keyed by name, if any.'),
							fieldWithPath('triggers.custom').description('Any other triggers keyed by name, if any.'))
						.andWithPrefix('triggers.cron.*.', concat(triggerSummary, cronTriggerSummary))
						.andWithPrefix('triggers.simple.*.', concat(triggerSummary, simpleTriggerSummary))
						.andWithPrefix('triggers.dailyTimeInterval.*.',
								concat(triggerSummary, dailyTimeIntervalTriggerSummary))
						.andWithPrefix('triggers.calendarInterval.*.',
								concat(triggerSummary, calendarIntervalTriggerSummary))
						.andWithPrefix('triggers.custom.*.', concat(triggerSummary, customTriggerSummary))));
	}
	@Test
	void quartzJob() throws Exception {
		mockJobs(jobOne);
		CronTrigger firstTrigger = cronTrigger.getTriggerBuilder().build();
		setPreviousNextFireTime(firstTrigger, null, '2020-12-07T03:00:00Z');
		SimpleTrigger secondTrigger = simpleTrigger.getTriggerBuilder().build();
		setPreviousNextFireTime(secondTrigger, '2020-12-04T03:00:00Z', '2020-12-04T12:00:00Z');
		mockTriggers(firstTrigger, secondTrigger);
		given(this.scheduler.getTriggersOfJob(jobOne.getKey()))
			.willAnswer((invocation) -> List.of(firstTrigger, secondTrigger));
		assertThat(this.mvc.get().uri('/actuator/quartz/jobs/samples/jobOne')).hasStatusOk()
			.apply(document('quartz/job-details', responseFields(
					fieldWithPath('group').description('Name of the group.'),
					fieldWithPath('name').description('Name of the job.'),
					fieldWithPath('description').description('Description of the job, if any.'),
					fieldWithPath('className').description('Fully qualified name of the job implementation.'),
					fieldWithPath('durable').description('Whether the job should remain stored after it is orphaned.'),
					fieldWithPath('requestRecovery').description(
							'Whether the job should be re-executed if a "recovery" or "fail-over" situation is encountered.'),
					fieldWithPath('data.*').description('Job data map as key/value pairs, if any.'),
					fieldWithPath('triggers').description('An array of triggers associated to the job, if any.'),
					fieldWithPath('triggers.[].group').description('Name of the trigger group.'),
					fieldWithPath('triggers.[].name').description('Name of the trigger.'),
					previousFireTime('triggers.[].'), nextFireTime('triggers.[].'), priority('triggers.[].'))));
	}
	@Test
	void quartzTriggerCommon() throws Exception {
		setupTriggerDetails(cronTrigger.getTriggerBuilder(), TriggerState.NORMAL);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers/samples/example')).hasStatusOk()
			.apply(document('quartz/trigger-details-common', responseFields(commonCronDetails).and(subsectionWithPath(
					'calendarInterval')
				.description(
						'Calendar time interval trigger details, if any. Present when `type` is `calendarInterval`.')
				.optional()
				.type(JsonFieldType.OBJECT),
					subsectionWithPath('custom')
						.description('Custom trigger details, if any. Present when `type` is `custom`.')
						.optional()
						.type(JsonFieldType.OBJECT),
					subsectionWithPath('cron')
						.description('Cron trigger details, if any. Present when `type` is `cron`.')
						.optional()
						.type(JsonFieldType.OBJECT),
					subsectionWithPath('dailyTimeInterval').description(
							'Daily time interval trigger details, if any. Present when `type` is `dailyTimeInterval`.')
						.optional()
						.type(JsonFieldType.OBJECT),
					subsectionWithPath('simple')
						.description('Simple trigger details, if any. Present when `type` is `simple`.')
						.optional()
						.type(JsonFieldType.OBJECT))));
	}
	@Test
	void quartzTriggerCron() throws Exception {
		setupTriggerDetails(cronTrigger.getTriggerBuilder(), TriggerState.NORMAL);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers/samples/example')).hasStatusOk()
			.apply(document('quartz/trigger-details-cron',
					relaxedResponseFields(fieldWithPath('cron').description('Cron trigger specific details.'))
						.andWithPrefix('cron.', cronTriggerSummary)));
	}
	@Test
	void quartzTriggerSimple() throws Exception {
		setupTriggerDetails(simpleTrigger.getTriggerBuilder(), TriggerState.NORMAL);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers/samples/example')).hasStatusOk()
			.apply(document('quartz/trigger-details-simple',
					relaxedResponseFields(fieldWithPath('simple').description('Simple trigger specific details.'))
						.andWithPrefix('simple.', simpleTriggerSummary)
						.and(repeatCount('simple.'), timesTriggered('simple.'))));
	}
	@Test
	void quartzTriggerCalendarInterval() throws Exception {
		setupTriggerDetails(calendarIntervalTrigger.getTriggerBuilder(), TriggerState.NORMAL);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers/samples/example')).hasStatusOk()
			.apply(document('quartz/trigger-details-calendar-interval',
					relaxedResponseFields(fieldWithPath('calendarInterval')
						.description('Calendar interval trigger specific details.'))
						.andWithPrefix('calendarInterval.', calendarIntervalTriggerSummary)
						.and(timesTriggered('calendarInterval.'),
								fieldWithPath('calendarInterval.preserveHourOfDayAcrossDaylightSavings').description(
										'Whether to fire the trigger at the same time of day, regardless of daylight '
												+ 'saving time transitions.'),
								fieldWithPath('calendarInterval.skipDayIfHourDoesNotExist').description(
										'Whether to skip if the hour of the day does not exist on a given day.'))));
	}
	@Test
	void quartzTriggerDailyTimeInterval() throws Exception {
		setupTriggerDetails(dailyTimeIntervalTrigger.getTriggerBuilder(), TriggerState.PAUSED);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers/samples/example')).hasStatusOk()
			.apply(document('quartz/trigger-details-daily-time-interval',
					relaxedResponseFields(fieldWithPath('dailyTimeInterval')
						.description('Daily time interval trigger specific details.'))
						.andWithPrefix('dailyTimeInterval.', dailyTimeIntervalTriggerSummary)
						.and(repeatCount('dailyTimeInterval.'), timesTriggered('dailyTimeInterval.'))));
	}
	@Test
	void quartzTriggerCustom() throws Exception {
		Trigger trigger = mock(Trigger.class);
		given(trigger.getKey()).willReturn(TriggerKey.triggerKey('example', 'samples'));
		given(trigger.getDescription()).willReturn('Example trigger.');
		given(trigger.toString()).willReturn('com.example.CustomTrigger@fdsfsd');
		given(trigger.getPriority()).willReturn(10);
		given(trigger.getStartTime()).willReturn(fromUtc('2020-11-30T17:00:00Z'));
		given(trigger.getEndTime()).willReturn(fromUtc('2020-12-30T03:00:00Z'));
		given(trigger.getCalendarName()).willReturn('bankHolidays');
		given(trigger.getPreviousFireTime()).willReturn(fromUtc('2020-12-04T03:00:00Z'));
		given(trigger.getNextFireTime()).willReturn(fromUtc('2020-12-07T03:00:00Z'));
		given(this.scheduler.getTriggerState(trigger.getKey())).willReturn(TriggerState.NORMAL);
		mockTriggers(trigger);
		assertThat(this.mvc.get().uri('/actuator/quartz/triggers/samples/example')).hasStatusOk()
			.apply(document('quartz/trigger-details-custom',
					relaxedResponseFields(fieldWithPath('custom').description('Custom trigger specific details.'))
						.andWithPrefix('custom.', customTriggerSummary)));
	}
	private <T extends Trigger> void setupTriggerDetails(TriggerBuilder<T> builder, TriggerState state)
			throws SchedulerException {
		T trigger = builder.withIdentity('example', 'samples')
			.withDescription('Example trigger')
			.startAt(fromUtc('2020-11-30T17:00:00Z'))
			.modifiedByCalendar('bankHolidays')
			.endAt(fromUtc('2020-12-30T03:00:00Z'))
			.build();
		setPreviousNextFireTime(trigger, '2020-12-04T03:00:00Z', '2020-12-07T03:00:00Z');
		given(this.scheduler.getTriggerState(trigger.getKey())).willReturn(state);
		mockTriggers(trigger);
	}
	private static FieldDescriptor startTime(String prefix) {
		return fieldWithPath(prefix + 'startTime').description('Time at which the Trigger should take effect, if any.');
	}
	private static FieldDescriptor endTime(String prefix) {
		return fieldWithPath(prefix + 'endTime').description(
				'Time at which the Trigger should quit repeating, regardless of any remaining repeats, if any.');
	}
	private static FieldDescriptor previousFireTime(String prefix) {
		return fieldWithPath(prefix + 'previousFireTime').optional()
			.type(JsonFieldType.STRING)
			.description('Last time the trigger fired, if any.');
	}
	private static FieldDescriptor nextFireTime(String prefix) {
		return fieldWithPath(prefix + 'nextFireTime').optional()
			.type(JsonFieldType.STRING)
			.description('Next time at which the Trigger is scheduled to fire, if any.');
	}
	private static FieldDescriptor priority(String prefix) {
		return fieldWithPath(prefix + 'priority')
			.description('Priority to use if two triggers have the same scheduled fire time.');
	}
	private static FieldDescriptor repeatCount(String prefix) {
		return fieldWithPath(prefix + 'repeatCount')
			.description('Number of times the trigger should repeat, or -1 to repeat indefinitely.');
	}
	private static FieldDescriptor timesTriggered(String prefix) {
		return fieldWithPath(prefix + 'timesTriggered').description('Number of times the trigger has already fired.');
	}
	private static List<FieldDescriptor> concat(List<FieldDescriptor> initial, List<FieldDescriptor> additionalFields) {
		List<FieldDescriptor> result = new ArrayList<>(initial);
		result.addAll(additionalFields);
		return result;
	}
	private void mockJobs(JobDetail... jobs) throws SchedulerException {
		MultiValueMap<String, JobKey> jobKeys = new LinkedMultiValueMap<>();
		for (JobDetail jobDetail : jobs) {
			JobKey key = jobDetail.getKey();
			given(this.scheduler.getJobDetail(key)).willReturn(jobDetail);
			jobKeys.add(key.getGroup(), key);
		}
		given(this.scheduler.getJobGroupNames()).willReturn(new ArrayList<>(jobKeys.keySet()));
		for (Entry<String, List<JobKey>> entry : jobKeys.entrySet()) {
			given(this.scheduler.getJobKeys(GroupMatcher.jobGroupEquals(entry.getKey())))
				.willReturn(new LinkedHashSet<>(entry.getValue()));
		}
	}
	private void mockTriggers(Trigger... triggers) throws SchedulerException {
		MultiValueMap<String, TriggerKey> triggerKeys = new LinkedMultiValueMap<>();
		for (Trigger trigger : triggers) {
			TriggerKey key = trigger.getKey();
			given(this.scheduler.getTrigger(key)).willReturn(trigger);
			triggerKeys.add(key.getGroup(), key);
		}
		given(this.scheduler.getTriggerGroupNames()).willReturn(new ArrayList<>(triggerKeys.keySet()));
		for (Entry<String, List<TriggerKey>> entry : triggerKeys.entrySet()) {
			given(this.scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(entry.getKey())))
				.willReturn(new LinkedHashSet<>(entry.getValue()));
		}
	}
	private <T extends Trigger> void setPreviousNextFireTime(T trigger, String previousFireTime, String nextFireTime) {
		OperableTrigger operableTrigger = (OperableTrigger) trigger;
		if (previousFireTime != null) {
			operableTrigger.setPreviousFireTime(fromUtc(previousFireTime));
		}
		if (nextFireTime != null) {
			operableTrigger.setNextFireTime(fromUtc(nextFireTime));
		}
	}
	private static Date fromUtc(String utcTime) {
		return Date.from(Instant.parse(utcTime));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		QuartzEndpoint endpoint(Scheduler scheduler) {
			return new QuartzEndpoint(scheduler, Collections.emptyList());
		}
		@Bean
		QuartzEndpointWebExtension endpointWebExtension(QuartzEndpoint endpoint) {
			return new QuartzEndpointWebExtension(endpoint, Show.ALWAYS, Collections.emptySet());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class ConfigurationPropertiesReportEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void configProps() {
		assertThat(this.mvc.get().uri('/actuator/configprops')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('configprops/all',
					preprocessResponse(limit('contexts', getApplicationContext().getId(), 'beans')),
					responseFields(fieldWithPath('contexts').description('Application contexts keyed by id.'),
							fieldWithPath('contexts.*.beans.*')
								.description('`@ConfigurationProperties` beans keyed by bean name.'),
							fieldWithPath('contexts.*.beans.*.prefix')
								.description('Prefix applied to the names of the bean"s properties.'),
							subsectionWithPath('contexts.*.beans.*.properties')
								.description('Properties of the bean as name-value pairs.'),
							subsectionWithPath('contexts.*.beans.*.inputs').description(
									'Origin and value of the configuration property used when binding to this bean.'),
							parentIdField())));
	}
	@Test
	void configPropsFilterByPrefix() {
		assertThat(this.mvc.get().uri('/actuator/configprops/spring.jackson')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('configprops/prefixed',
					preprocessResponse(limit('contexts', getApplicationContext().getId(), 'beans')),
					responseFields(fieldWithPath('contexts').description('Application contexts keyed by id.'),
							fieldWithPath('contexts.*.beans.*')
								.description('`@ConfigurationProperties` beans keyed by bean name.'),
							fieldWithPath('contexts.*.beans.*.prefix')
								.description('Prefix applied to the names of the bean"s properties.'),
							subsectionWithPath('contexts.*.beans.*.properties')
								.description('Properties of the bean as name-value pairs.'),
							subsectionWithPath('contexts.*.beans.*.inputs').description(
									'Origin and value of the configuration property used when binding to this bean.'),
							parentIdField())));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		ConfigurationPropertiesReportEndpoint endpoint() {
			return new ConfigurationPropertiesReportEndpoint(Collections.emptyList(), Show.ALWAYS);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
@ExtendWith(RestDocumentationExtension.class)
@SpringBootTest
public abstract class MockMvcEndpointDocumentationTests extends AbstractEndpointDocumentationTests {
	protected MockMvcTester mvc;
	@Autowired
	private WebApplicationContext applicationContext;
	@BeforeEach
	void setup(RestDocumentationContextProvider restDocumentation) {
		this.mvc = MockMvcTester.from(this.applicationContext,
				(builder) -> builder
					.apply(MockMvcRestDocumentation.documentationConfiguration(restDocumentation).uris())
					.build());
	}
	protected WebApplicationContext getApplicationContext() {
		return this.applicationContext;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class FlywayEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void flyway() {
		assertThat(this.mvc.get().uri('/actuator/flyway')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('flyway',
					responseFields(fieldWithPath('contexts').description('Application contexts keyed by id'),
							fieldWithPath('contexts.*.flywayBeans.*.migrations')
								.description('Migrations performed by the Flyway instance, keyed by Flyway bean name.'))
						.andWithPrefix('contexts.*.flywayBeans.*.migrations.[].', migrationFieldDescriptors())
						.and(parentIdField())));
	}
	private List<FieldDescriptor> migrationFieldDescriptors() {
		return List.of(fieldWithPath('checksum').description('Checksum of the migration, if any.').optional(),
				fieldWithPath('description').description('Description of the migration, if any.').optional(),
				fieldWithPath('executionTime').description('Execution time in milliseconds of an applied migration.')
					.optional(),
				fieldWithPath('installedBy').description('User that installed the applied migration, if any.')
					.optional(),
				fieldWithPath('installedOn')
					.description('Timestamp of when the applied migration was installed, if any.')
					.optional(),
				fieldWithPath('installedRank')
					.description('Rank of the applied migration, if any. Later migrations have higher ranks.')
					.optional(),
				fieldWithPath('script').description('Name of the script used to execute the migration, if any.')
					.optional(),
				fieldWithPath('state')
					.description('State of the migration. (' + describeEnumValues(MigrationState.class) + ')'),
				fieldWithPath('type').description('Type of the migration.'),
				fieldWithPath('version').description('Version of the database after applying the migration, if any.')
					.optional());
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	@ImportAutoConfiguration(FlywayAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		DataSource dataSource() {
			return new EmbeddedDatabaseBuilder().generateUniqueName(true)
				.setType(EmbeddedDatabaseConnection.get(getClass().getClassLoader()).getType())
				.build();
		}
		@Bean
		FlywayEndpoint endpoint(ApplicationContext context) {
			return new FlywayEndpoint(context);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class HeapDumpWebEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void heapDump() {
		assertThat(this.mvc.get().uri('/actuator/heapdump')).hasStatusOk()
			.apply(document('heapdump', new CurlRequestSnippet(CliDocumentation.multiLineFormat()) {
				@Override
				protected Map<String, Object> createModel(Operation operation) {
					Map<String, Object> model = super.createModel(operation);
					model.put('options', '-O');
					return model;
				}
			}));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		HeapDumpWebEndpoint endpoint() {
			return new HeapDumpWebEndpoint() {
				@Override
				protected HeapDumper createHeapDumper() {
					return (live) -> {
						File file = Files.createTempFile('heap-', '.hprof').toFile();
						FileCopyUtils.copy('<<binary content>>', new FileWriter(file));
						return file;
					};
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class LogFileWebEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void logFile() {
		assertThat(this.mvc.get().uri('/actuator/logfile')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('logfile/entire'));
	}
	@Test
	void logFileRange() {
		assertThat(this.mvc.get().uri('/actuator/logfile').header('Range', 'bytes=0-1023'))
			.hasStatus(HttpStatus.PARTIAL_CONTENT)
			.apply(MockMvcRestDocumentation.document('logfile/range'));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		LogFileWebEndpoint endpoint() {
			MockEnvironment environment = new MockEnvironment();
			environment.setProperty('logging.file.name',
					'src/test/resources/org/springframework/boot/actuate/autoconfigure/endpoint/web/documentation/sample.log');
			return new LogFileWebEndpoint(LogFile.get(environment), null);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class BeansEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void beans() {
		List<FieldDescriptor> beanFields = List.of(fieldWithPath('aliases').description('Names of any aliases.'),
				fieldWithPath('scope').description('Scope of the bean.'),
				fieldWithPath('type').description('Fully qualified type of the bean.'),
				fieldWithPath('resource').description('Resource in which the bean was defined, if any.')
					.optional()
					.type(JsonFieldType.STRING),
				fieldWithPath('dependencies').description('Names of any dependencies.'));
		ResponseFieldsSnippet responseFields = responseFields(
				fieldWithPath('contexts').description('Application contexts keyed by id.'), parentIdField(),
				fieldWithPath('contexts.*.beans').description('Beans in the application context keyed by name.'))
			.andWithPrefix('contexts.*.beans.*.', beanFields);
		assertThat(this.mvc.get().uri('/actuator/beans')).hasStatusOk()
			.apply(document('beans',
					preprocessResponse(
							limit(this::isIndependentBean, 'contexts', getApplicationContext().getId(), 'beans')),
					responseFields));
	}
	private boolean isIndependentBean(Entry<String, Map<String, Object>> bean) {
		return CollectionUtils.isEmpty((Collection<?>) bean.getValue().get('aliases'))
				&& CollectionUtils.isEmpty((Collection<?>) bean.getValue().get('dependencies'));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		BeansEndpoint beansEndpoint(ConfigurableApplicationContext context) {
			return new BeansEndpoint(context);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class HealthEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	private static final List<FieldDescriptor> componentFields = List.of(
			fieldWithPath('status').description('Status of a specific part of the application'),
			subsectionWithPath('details').description('Details of the health of a specific part of the application.'));
	@Test
	void health() {
		FieldDescriptor status = fieldWithPath('status').description('Overall status of the application.');
		FieldDescriptor components = fieldWithPath('components').description('The components that make up the health.');
		FieldDescriptor componentStatus = fieldWithPath('components.*.status')
			.description('Status of a specific part of the application.');
		FieldDescriptor nestedComponents = subsectionWithPath('components.*.components')
			.description('The nested components that make up the health.')
			.optional();
		FieldDescriptor componentDetails = subsectionWithPath('components.*.details')
			.description('Details of the health of a specific part of the application. '
					+ 'Presence is controlled by `management.endpoint.health.show-details`.')
			.optional();
		assertThat(this.mvc.get().uri('/actuator/health').accept(MediaType.APPLICATION_JSON)).hasStatusOk()
			.apply(document('health',
					responseFields(status, components, componentStatus, nestedComponents, componentDetails)));
	}
	@Test
	void healthComponent() {
		assertThat(this.mvc.get().uri('/actuator/health/db').accept(MediaType.APPLICATION_JSON)).hasStatusOk()
			.apply(document('health/component', responseFields(componentFields)));
	}
	@Test
	void healthComponentInstance() {
		assertThat(this.mvc.get().uri('/actuator/health/broker/us1').accept(MediaType.APPLICATION_JSON)).hasStatusOk()
			.apply(document('health/instance', responseFields(componentFields)));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		HealthEndpoint healthEndpoint(Map<String, HealthContributor> healthContributors) {
			HealthContributorRegistry registry = new DefaultHealthContributorRegistry(healthContributors);
			HealthEndpointGroup primary = new TestHealthEndpointGroup();
			HealthEndpointGroups groups = HealthEndpointGroups.of(primary, Collections.emptyMap());
			return new HealthEndpoint(registry, groups, null);
		}
		@Bean
		DiskSpaceHealthIndicator diskSpaceHealthIndicator() {
			return new DiskSpaceHealthIndicator(new File('.'), DataSize.ofMegabytes(10));
		}
		@Bean
		DataSourceHealthIndicator dbHealthIndicator(DataSource dataSource) {
			return new DataSourceHealthIndicator(dataSource);
		}
		@Bean
		CompositeHealthContributor brokerHealthContributor() {
			Map<String, HealthIndicator> indicators = new LinkedHashMap<>();
			indicators.put('us1', () -> Health.up().withDetail('version', '1.0.2').build());
			indicators.put('us2', () -> Health.up().withDetail('version', '1.0.4').build());
			return CompositeHealthContributor.fromMap(indicators);
		}
	}
	private static final class TestHealthEndpointGroup implements HealthEndpointGroup {
		private final StatusAggregator statusAggregator = new SimpleStatusAggregator();
		private final HttpCodeStatusMapper httpCodeStatusMapper = new SimpleHttpCodeStatusMapper();
		@Override
		public boolean isMember(String name) {
			return true;
		}
		@Override
		public boolean showComponents(SecurityContext securityContext) {
			return true;
		}
		@Override
		public boolean showDetails(SecurityContext securityContext) {
			return true;
		}
		@Override
		public StatusAggregator getStatusAggregator() {
			return this.statusAggregator;
		}
		@Override
		public HttpCodeStatusMapper getHttpCodeStatusMapper() {
			return this.httpCodeStatusMapper;
		}
		@Override
		public AdditionalHealthEndpointPath getAdditionalPath() {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class CachesEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	private static final List<FieldDescriptor> levelFields = List.of(fieldWithPath('name').description('Cache name.'),
			fieldWithPath('cacheManager').description('Cache manager name.'),
			fieldWithPath('target').description('Fully qualified name of the native cache.'));
	private static final List<ParameterDescriptor> queryParameters = Collections
		.singletonList(parameterWithName('cacheManager')
			.description('Name of the cacheManager to qualify the cache. May be omitted if the cache name is unique.')
			.optional());
	@Test
	void allCaches() {
		assertThat(this.mvc.get().uri('/actuator/caches')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('caches/all',
					responseFields(fieldWithPath('cacheManagers').description('Cache managers keyed by id.'),
							fieldWithPath('cacheManagers.*.caches')
								.description('Caches in the application context keyed by name.'))
						.andWithPrefix('cacheManagers.*.caches.*.',
								fieldWithPath('target').description('Fully qualified name of the native cache.'))));
	}
	@Test
	void namedCache() {
		assertThat(this.mvc.get().uri('/actuator/caches/cities')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('caches/named', queryParameters(queryParameters),
					responseFields(levelFields)));
	}
	@Test
	void evictAllCaches() {
		assertThat(this.mvc.delete().uri('/actuator/caches')).hasStatus(HttpStatus.NO_CONTENT)
			.apply(MockMvcRestDocumentation.document('caches/evict-all'));
	}
	@Test
	void evictNamedCache() {
		assertThat(this.mvc.delete().uri('/actuator/caches/countries?cacheManager=anotherCacheManager'))
			.hasStatus(HttpStatus.NO_CONTENT)
			.apply(MockMvcRestDocumentation.document('caches/evict-named', queryParameters(queryParameters)));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		CachesEndpoint endpoint() {
			Map<String, CacheManager> cacheManagers = new HashMap<>();
			cacheManagers.put('cacheManager', new ConcurrentMapCacheManager('countries', 'cities'));
			cacheManagers.put('anotherCacheManager', new ConcurrentMapCacheManager('countries'));
			return new CachesEndpoint(cacheManagers);
		}
		@Bean
		CachesEndpointWebExtension endpointWebExtension(CachesEndpoint endpoint) {
			return new CachesEndpointWebExtension(endpoint);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
@TestPropertySource(
		properties = 'spring.config.location=classpath:/org/springframework/boot/actuate/autoconfigure/endpoint/web/documentation/')
class EnvironmentEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	private static final FieldDescriptor activeProfiles = fieldWithPath('activeProfiles')
		.description('Names of the active profiles, if any.');
	private static final FieldDescriptor defaultProfiles = fieldWithPath('defaultProfiles')
		.description('Names of the default profiles, if any.');
	private static final FieldDescriptor propertySources = fieldWithPath('propertySources')
		.description('Property sources in order of precedence.');
	private static final FieldDescriptor propertySourceName = fieldWithPath('propertySources.[].name')
		.description('Name of the property source.');
	@Test
	void env() {
		assertThat(this.mvc.get().uri('/actuator/env')).hasStatusOk()
			.apply(document('env/all',
					preprocessResponse(
							replacePattern(Pattern.compile(
									'org/springframework/boot/actuate/autoconfigure/endpoint/web/documentation/'), ''),
							filterProperties()),
					responseFields(activeProfiles, defaultProfiles, propertySources, propertySourceName,
							fieldWithPath('propertySources.[].properties')
								.description('Properties in the property source keyed by property name.'),
							fieldWithPath('propertySources.[].properties.*.value')
								.description('Value of the property.'),
							fieldWithPath('propertySources.[].properties.*.origin')
								.description('Origin of the property, if any.')
								.optional())));
	}
	@Test
	void singlePropertyFromEnv() {
		assertThat(this.mvc.get().uri('/actuator/env/com.example.cache.max-size')).hasStatusOk()
			.apply(document('env/single',
					preprocessResponse(replacePattern(Pattern
						.compile('org/springframework/boot/actuate/autoconfigure/endpoint/web/documentation/'), '')),
					responseFields(
							fieldWithPath('property').description('Property from the environment, if found.')
								.optional(),
							fieldWithPath('property.source').description('Name of the source of the property.'),
							fieldWithPath('property.value').description('Value of the property.'), activeProfiles,
							defaultProfiles, propertySources, propertySourceName,
							fieldWithPath('propertySources.[].property')
								.description('Property in the property source, if any.')
								.optional(),
							fieldWithPath('propertySources.[].property.value').description('Value of the property.'),
							fieldWithPath('propertySources.[].property.origin')
								.description('Origin of the property, if any.')
								.optional())));
	}
	private OperationPreprocessor filterProperties() {
		return new ContentModifyingOperationPreprocessor(this::filterProperties);
	}
	@SuppressWarnings('unchecked')
	private byte[] filterProperties(byte[] content, MediaType mediaType) {
		ObjectMapper objectMapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
		try {
			Map<String, Object> payload = objectMapper.readValue(content, Map.class);
			List<Map<String, Object>> propertySources = (List<Map<String, Object>>) payload.get('propertySources');
			for (Map<String, Object> propertySource : propertySources) {
				Map<String, String> properties = (Map<String, String>) propertySource.get('properties');
				Set<String> filteredKeys = properties.keySet()
					.stream()
					.filter(this::retainKey)
					.limit(3)
					.collect(Collectors.toSet());
				properties.keySet().retainAll(filteredKeys);
			}
			return objectMapper.writeValueAsBytes(payload);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private boolean retainKey(String key) {
		return key.startsWith('java.') || key.equals('JAVA_HOME') || key.startsWith('com.example.');
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		EnvironmentEndpoint endpoint(ConfigurableEnvironment environment) {
			return new EnvironmentEndpoint(new AbstractEnvironment() {
				@Override
				protected void customizePropertySources(MutablePropertySources propertySources) {
					environment.getPropertySources()
						.stream()
						.filter(this::includedPropertySource)
						.forEach(propertySources::addLast);
				}
				private boolean includedPropertySource(PropertySource<?> propertySource) {
					return propertySource instanceof EnumerablePropertySource
							&& !'Inlined Test Properties'.equals(propertySource.getName());
				}
			}, Collections.emptyList(), Show.ALWAYS);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class ScheduledTasksEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void scheduledTasks() {
		assertThat(this.mvc.get().uri('/actuator/scheduledtasks')).hasStatusOk()
			.apply(document('scheduled-tasks',
					preprocessResponse(replacePattern(
							Pattern.compile('org.*\\.ScheduledTasksEndpointDocumentationTests\\$TestConfiguration'),
							'com.example.Processor')),
					responseFields(fieldWithPath('cron').description('Cron tasks, if any.'),
							targetFieldWithPrefix('cron.[].'),
							nextExecutionWithPrefix('cron.[].').description('Time of the next scheduled execution.'),
							fieldWithPath('cron.[].expression').description('Cron expression.'),
							fieldWithPath('fixedDelay').description('Fixed delay tasks, if any.'),
							targetFieldWithPrefix('fixedDelay.[].'), initialDelayWithPrefix('fixedDelay.[].'),
							nextExecutionWithPrefix('fixedDelay.[].'),
							fieldWithPath('fixedDelay.[].interval')
								.description('Interval, in milliseconds, between the end of the last'
										+ ' execution and the start of the next.'),
							fieldWithPath('fixedRate').description('Fixed rate tasks, if any.'),
							targetFieldWithPrefix('fixedRate.[].'),
							fieldWithPath('fixedRate.[].interval')
								.description('Interval, in milliseconds, between the start of each execution.'),
							initialDelayWithPrefix('fixedRate.[].'), nextExecutionWithPrefix('fixedRate.[].'),
							fieldWithPath('custom').description('Tasks with custom triggers, if any.'),
							targetFieldWithPrefix('custom.[].'),
							fieldWithPath('custom.[].trigger').description('Trigger for the task.'))
						.andWithPrefix('*.[].',
								fieldWithPath('lastExecution').description('Last execution of this task, if any.')
									.optional()
									.type(JsonFieldType.OBJECT))
						.andWithPrefix('*.[].lastExecution.', lastExecution())));
	}
	private FieldDescriptor targetFieldWithPrefix(String prefix) {
		return fieldWithPath(prefix + 'runnable.target').description('Target that will be executed.');
	}
	private FieldDescriptor initialDelayWithPrefix(String prefix) {
		return fieldWithPath(prefix + 'initialDelay').description('Delay, in milliseconds, before first execution.');
	}
	private FieldDescriptor nextExecutionWithPrefix(String prefix) {
		return fieldWithPath(prefix + 'nextExecution.time')
			.description('Time of the next scheduled execution, if known.')
			.type(JsonFieldType.STRING)
			.optional();
	}
	private FieldDescriptor[] lastExecution() {
		return new FieldDescriptor[] {
				fieldWithPath('status').description('Status of the last execution (STARTED, SUCCESS, ERROR).')
					.type(JsonFieldType.STRING),
				fieldWithPath('time').description('Time of the last execution.').type(JsonFieldType.STRING),
				fieldWithPath('exception.type').description('Exception type thrown by the task, if any.')
					.type(JsonFieldType.STRING)
					.optional(),
				fieldWithPath('exception.message').description('Message of the exception thrown by the task, if any.')
					.type(JsonFieldType.STRING)
					.optional() };
	}
	@Configuration(proxyBeanMethods = false)
	@EnableScheduling
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		ScheduledTasksEndpoint endpoint(Collection<ScheduledTaskHolder> holders) {
			return new ScheduledTasksEndpoint(holders);
		}
		@Scheduled(cron = '0 0 0/3 1/1 * ?')
		void processOrders() {
		}
		@Scheduled(fixedDelay = 5000, initialDelay = 0)
		void purge() {
		}
		@Scheduled(fixedRate = 3000, initialDelay = 10000)
		void retrieveIssues() {
		}
		@Bean
		SchedulingConfigurer schedulingConfigurer() {
			return (registrar) -> {
				registrar.setTaskScheduler(new TestTaskScheduler());
				registrar.addTriggerTask(new CustomTriggeredRunnable(), new CustomTrigger());
			};
		}
		static class CustomTrigger implements Trigger {
			@Override
			public Instant nextExecution(TriggerContext triggerContext) {
				return Instant.now();
			}
		}
		static class CustomTriggeredRunnable implements Runnable {
			@Override
			public void run() {
				throw new IllegalStateException('Failed while running custom task');
			}
		}
		static class TestTaskScheduler extends SimpleAsyncTaskScheduler {
			TestTaskScheduler() {
				setThreadNamePrefix('test-');
				// do not log task errors
				setErrorHandler((throwable) -> {
				});
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class MetricsEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void metricNames() {
		assertThat(this.mvc.get().uri('/actuator/metrics')).hasStatusOk()
			.apply(document('metrics/names',
					responseFields(fieldWithPath('names').description('Names of the known metrics.'))));
	}
	@Test
	void metric() {
		assertThat(this.mvc.get().uri('/actuator/metrics/jvm.memory.max')).hasStatusOk()
			.apply(document('metrics/metric',
					responseFields(fieldWithPath('name').description('Name of the metric'),
							fieldWithPath('description').description('Description of the metric'),
							fieldWithPath('baseUnit').description('Base unit of the metric'),
							fieldWithPath('measurements').description('Measurements of the metric'),
							fieldWithPath('measurements[].statistic').description(
									'Statistic of the measurement. (' + describeEnumValues(Statistic.class) + ').'),
							fieldWithPath('measurements[].value').description('Value of the measurement.'),
							fieldWithPath('availableTags').description('Tags that are available for drill-down.'),
							fieldWithPath('availableTags[].tag').description('Name of the tag.'),
							fieldWithPath('availableTags[].values').description('Possible values of the tag.'))));
	}
	@Test
	void metricWithTags() {
		assertThat(this.mvc.get()
			.uri('/actuator/metrics/jvm.memory.max')
			.param('tag', 'area:nonheap')
			.param('tag', 'id:Compressed Class Space')).hasStatusOk()
			.apply(document('metrics/metric-with-tags', queryParameters(
					parameterWithName('tag').description('A tag to use for drill-down in the form `name:value`.'))));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		MetricsEndpoint endpoint() {
			SimpleMeterRegistry registry = new SimpleMeterRegistry();
			new JvmMemoryMetrics().bindTo(registry);
			return new MetricsEndpoint(registry);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class PrometheusSimpleclientScrapeEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void prometheus() {
		assertThat(this.mvc.get().uri('/actuator/prometheus')).hasStatusOk()
			.apply(document('prometheus-simpleclient/all'));
	}
	@Test
	void prometheusOpenmetrics() {
		assertThat(this.mvc.get().uri('/actuator/prometheus').accept(TextFormat.CONTENT_TYPE_OPENMETRICS_100))
			.satisfies((result) -> {
				assertThat(result).hasStatusOk()
					.headers()
					.hasValue('Content-Type', 'application/openmetrics-text;version=1.0.0;charset=utf-8');
				assertThat(result).apply(document('prometheus-simpleclient/openmetrics'));
			});
	}
	@Test
	void filteredPrometheus() {
		assertThat(this.mvc.get()
			.uri('/actuator/prometheus')
			.param('includedNames', 'jvm_memory_used_bytes,jvm_memory_committed_bytes'))
			.hasStatusOk()
			.apply(document('prometheus-simpleclient/names',
					queryParameters(parameterWithName('includedNames')
						.description('Restricts the samples to those that match the names. Optional.')
						.optional())));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		@SuppressWarnings({ 'removal', 'deprecation' })
		org.springframework.boot.actuate.metrics.export.prometheus.PrometheusSimpleclientScrapeEndpoint endpoint() {
			CollectorRegistry collectorRegistry = new CollectorRegistry(true);
			io.micrometer.prometheus.PrometheusMeterRegistry meterRegistry = new io.micrometer.prometheus.PrometheusMeterRegistry(
					(key) -> null, collectorRegistry, Clock.SYSTEM);
			new JvmMemoryMetrics().bindTo(meterRegistry);
			return new org.springframework.boot.actuate.metrics.export.prometheus.PrometheusSimpleclientScrapeEndpoint(
					collectorRegistry);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class PrometheusScrapeEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void prometheus() {
		assertThat(this.mvc.get().uri('/actuator/prometheus')).hasStatusOk().apply(document('prometheus/all'));
	}
	@Test
	void prometheusOpenmetrics() {
		assertThat(this.mvc.get().uri('/actuator/prometheus').accept(TextFormat.CONTENT_TYPE_OPENMETRICS_100))
			.satisfies((result) -> {
				assertThat(result).hasStatusOk()
					.headers()
					.hasValue('Content-Type', 'application/openmetrics-text;version=1.0.0;charset=utf-8');
				assertThat(result).apply(document('prometheus/openmetrics'));
			});
	}
	@Test
	void filteredPrometheus() {
		assertThat(this.mvc.get()
			.uri('/actuator/prometheus')
			.param('includedNames', 'jvm_memory_used_bytes,jvm_memory_committed_bytes'))
			.hasStatusOk()
			.apply(document('prometheus/names',
					queryParameters(parameterWithName('includedNames')
						.description('Restricts the samples to those that match the names. Optional.')
						.optional())));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		PrometheusScrapeEndpoint endpoint() {
			PrometheusRegistry prometheusRegistry = new PrometheusRegistry();
			PrometheusMeterRegistry meterRegistry = new PrometheusMeterRegistry((key) -> null, prometheusRegistry,
					Clock.SYSTEM);
			new JvmMemoryMetrics().bindTo(meterRegistry);
			return new PrometheusScrapeEndpoint(prometheusRegistry, new Properties());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class LoggersEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	private static final List<FieldDescriptor> levelFields = List.of(
			fieldWithPath('configuredLevel').description('Configured level of the logger, if any.').optional(),
			fieldWithPath('effectiveLevel').description('Effective level of the logger.'));
	private static final List<FieldDescriptor> groupLevelFields = List
		.of(fieldWithPath('configuredLevel').description('Configured level of the logger group, if any.')
			.type(JsonFieldType.STRING)
			.optional(), fieldWithPath('members').description('Loggers that are part of this group'));
	@MockitoBean
	private LoggingSystem loggingSystem;
	@Autowired
	private LoggerGroups loggerGroups;
	@Test
	void allLoggers() {
		given(this.loggingSystem.getSupportedLogLevels()).willReturn(EnumSet.allOf(LogLevel.class));
		given(this.loggingSystem.getLoggerConfigurations())
			.willReturn(List.of(new LoggerConfiguration('ROOT', LogLevel.INFO, LogLevel.INFO),
					new LoggerConfiguration('com.example', LogLevel.DEBUG, LogLevel.DEBUG)));
		assertThat(this.mvc.get().uri('/actuator/loggers')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('loggers/all',
					responseFields(fieldWithPath('levels').description('Levels support by the logging system.'),
							fieldWithPath('loggers').description('Loggers keyed by name.'),
							fieldWithPath('groups').description('Logger groups keyed by name'))
						.andWithPrefix('loggers.*.', levelFields)
						.andWithPrefix('groups.*.', groupLevelFields)));
	}
	@Test
	void logger() {
		given(this.loggingSystem.getLoggerConfiguration('com.example'))
			.willReturn(new LoggerConfiguration('com.example', LogLevel.INFO, LogLevel.INFO));
		assertThat(this.mvc.get().uri('/actuator/loggers/com.example')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('loggers/single', responseFields(levelFields)));
	}
	@Test
	void loggerGroups() {
		this.loggerGroups.get('test').configureLogLevel(LogLevel.INFO, (member, level) -> {
		});
		assertThat(this.mvc.get().uri('/actuator/loggers/test')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('loggers/group', responseFields(groupLevelFields)));
		resetLogger();
	}
	@Test
	void setLogLevel() {
		assertThat(this.mvc.post()
			.uri('/actuator/loggers/com.example')
			.content('{\'configuredLevel\':\'debug\'}')
			.contentType(MediaType.APPLICATION_JSON))
			.hasStatus(HttpStatus.NO_CONTENT)
			.apply(MockMvcRestDocumentation.document('loggers/set',
					requestFields(fieldWithPath('configuredLevel')
						.description('Level for the logger. May be omitted to clear the level.')
						.optional())));
		then(this.loggingSystem).should().setLogLevel('com.example', LogLevel.DEBUG);
	}
	@Test
	void setLogLevelOfLoggerGroup() {
		assertThat(this.mvc.post()
			.uri('/actuator/loggers/test')
			.content('{\'configuredLevel\':\'debug\'}')
			.contentType(MediaType.APPLICATION_JSON))
			.hasStatus(HttpStatus.NO_CONTENT)
			.apply(MockMvcRestDocumentation.document('loggers/setGroup',
					requestFields(fieldWithPath('configuredLevel')
						.description('Level for the logger group. May be omitted to clear the level of the loggers.')
						.optional())));
		then(this.loggingSystem).should().setLogLevel('test.member1', LogLevel.DEBUG);
		then(this.loggingSystem).should().setLogLevel('test.member2', LogLevel.DEBUG);
		resetLogger();
	}
	private void resetLogger() {
		this.loggerGroups.get('test').configureLogLevel(LogLevel.INFO, (a, b) -> {
		});
	}
	@Test
	void clearLogLevel() {
		assertThat(this.mvc.post()
			.uri('/actuator/loggers/com.example')
			.content('{}')
			.contentType(MediaType.APPLICATION_JSON)).hasStatus(HttpStatus.NO_CONTENT)
			.apply(MockMvcRestDocumentation.document('loggers/clear'));
		then(this.loggingSystem).should().setLogLevel('com.example', null);
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		LoggersEndpoint endpoint(LoggingSystem loggingSystem, LoggerGroups groups) {
			groups.putAll(getLoggerGroups());
			groups.get('test').configureLogLevel(LogLevel.INFO, (member, level) -> {
			});
			return new LoggersEndpoint(loggingSystem, groups);
		}
		private Map<String, List<String>> getLoggerGroups() {
			return Collections.singletonMap('test', List.of('test.member1', 'test.member2'));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class ConditionsReportEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@Test
	void conditions() {
		List<FieldDescriptor> positiveMatchFields = List.of(
				fieldWithPath('').description('Classes and methods with conditions that were matched.'),
				fieldWithPath('.*.[].condition').description('Name of the condition.'),
				fieldWithPath('.*.[].message').description('Details of why the condition was matched.'));
		List<FieldDescriptor> negativeMatchFields = List.of(
				fieldWithPath('').description('Classes and methods with conditions that were not matched.'),
				fieldWithPath('.*.notMatched').description('Conditions that were matched.'),
				fieldWithPath('.*.notMatched.[].condition').description('Name of the condition.'),
				fieldWithPath('.*.notMatched.[].message').description('Details of why the condition was not matched.'),
				fieldWithPath('.*.matched').description('Conditions that were matched.'),
				fieldWithPath('.*.matched.[].condition').description('Name of the condition.')
					.type(JsonFieldType.STRING)
					.optional(),
				fieldWithPath('.*.matched.[].message').description('Details of why the condition was matched.')
					.type(JsonFieldType.STRING)
					.optional());
		FieldDescriptor unconditionalClassesField = fieldWithPath('contexts.*.unconditionalClasses')
			.description('Names of unconditional auto-configuration classes if any.');
		assertThat(this.mvc.get().uri('/actuator/conditions')).hasStatusOk()
			.apply(MockMvcRestDocumentation.document('conditions',
					preprocessResponse(limit('contexts', getApplicationContext().getId(), 'positiveMatches'),
							limit('contexts', getApplicationContext().getId(), 'negativeMatches')),
					responseFields(fieldWithPath('contexts').description('Application contexts keyed by id.'))
						.andWithPrefix('contexts.*.positiveMatches', positiveMatchFields)
						.andWithPrefix('contexts.*.negativeMatches', negativeMatchFields)
						.and(unconditionalClassesField, parentIdField())));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		ConditionsReportEndpoint autoConfigurationReportEndpoint(ConfigurableApplicationContext context) {
			ConditionEvaluationReport conditionEvaluationReport = ConditionEvaluationReport
				.get(context.getBeanFactory());
			conditionEvaluationReport
				.recordEvaluationCandidates(List.of(PropertyPlaceholderAutoConfiguration.class.getName()));
			return new ConditionsReportEndpoint(context);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
class StartupEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	@BeforeEach
	void appendSampleStartupSteps(@Autowired BufferingApplicationStartup applicationStartup) {
		StartupStep starting = applicationStartup.start('spring.boot.application.starting');
		starting.tag('mainApplicationClass', 'com.example.startup.StartupApplication');
		StartupStep instantiate = applicationStartup.start('spring.beans.instantiate');
		instantiate.tag('beanName', 'homeController');
		instantiate.end();
		starting.end();
	}
	@Test
	void startupSnapshot() {
		assertThat(this.mvc.get().uri('/actuator/startup')).hasStatusOk()
			.apply(document('startup-snapshot', PayloadDocumentation.responseFields(responseFields())));
	}
	@Test
	void startup() {
		assertThat(this.mvc.post().uri('/actuator/startup')).hasStatusOk()
			.apply(document('startup', PayloadDocumentation.responseFields(responseFields())));
	}
	private FieldDescriptor[] responseFields() {
		return new FieldDescriptor[] {
				fieldWithPath('springBootVersion').type(JsonFieldType.STRING)
					.description('Spring Boot version for this application.')
					.optional(),
				fieldWithPath('timeline.startTime').description('Start time of the application.'),
				fieldWithPath('timeline.events')
					.description('An array of steps collected during application startup so far.'),
				fieldWithPath('timeline.events.[].startTime').description('The timestamp of the start of this event.'),
				fieldWithPath('timeline.events.[].endTime').description('The timestamp of the end of this event.'),
				fieldWithPath('timeline.events.[].duration').description('The precise duration of this event.'),
				fieldWithPath('timeline.events.[].startupStep.name').description('The name of the StartupStep.'),
				fieldWithPath('timeline.events.[].startupStep.id').description('The id of this StartupStep.'),
				fieldWithPath('timeline.events.[].startupStep.parentId')
					.description('The parent id for this StartupStep.')
					.optional(),
				fieldWithPath('timeline.events.[].startupStep.tags')
					.description('An array of key/value pairs with additional step info.'),
				fieldWithPath('timeline.events.[].startupStep.tags[].key')
					.description('The key of the StartupStep Tag.'),
				fieldWithPath('timeline.events.[].startupStep.tags[].value')
					.description('The value of the StartupStep Tag.') };
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		StartupEndpoint startupEndpoint(BufferingApplicationStartup startup) {
			return new StartupEndpoint(startup);
		}
		@Bean
		BufferingApplicationStartup bufferingApplicationStartup() {
			return new BufferingApplicationStartup(16);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
@TestPropertySource(properties = { 'management.endpoints.web.exposure.include=*' })
public abstract class AbstractEndpointDocumentationTests {
	protected static String describeEnumValues(Class<? extends Enum<?>> enumType) {
		return StringUtils.collectionToDelimitedString(
				Stream.of(enumType.getEnumConstants()).map((constant) -> '`' + constant.name() + '`').toList(), ', ');
	}
	protected OperationPreprocessor limit(String... keys) {
		return limit((candidate) -> true, keys);
	}
	@SuppressWarnings('unchecked')
	protected <T> OperationPreprocessor limit(Predicate<T> filter, String... keys) {
		return new ContentModifyingOperationPreprocessor((content, mediaType) -> {
			ObjectMapper objectMapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
			try {
				Map<String, Object> payload = objectMapper.readValue(content, Map.class);
				Object target = payload;
				Map<Object, Object> parent = null;
				for (String key : keys) {
					if (!(target instanceof Map)) {
						throw new IllegalStateException();
					}
					parent = (Map<Object, Object>) target;
					target = parent.get(key);
				}
				if (target instanceof Map) {
					parent.put(keys[keys.length - 1], select((Map<String, Object>) target, filter));
				}
				else {
					parent.put(keys[keys.length - 1], select((List<Object>) target, filter));
				}
				return objectMapper.writeValueAsBytes(payload);
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		});
	}
	protected FieldDescriptor parentIdField() {
		return fieldWithPath('contexts.*.parentId').description('Id of the parent application context, if any.')
			.optional()
			.type(JsonFieldType.STRING);
	}
	@SuppressWarnings('unchecked')
	private <T> Map<String, Object> select(Map<String, Object> candidates, Predicate<T> filter) {
		Map<String, Object> selected = new HashMap<>();
		candidates.entrySet()
			.stream()
			.filter((candidate) -> filter.test((T) candidate))
			.limit(3)
			.forEach((entry) -> selected.put(entry.getKey(), entry.getValue()));
		return selected;
	}
	@SuppressWarnings('unchecked')
	private <T> List<Object> select(List<Object> candidates, Predicate<T> filter) {
		return candidates.stream().filter((candidate) -> filter.test((T) candidate)).limit(3).toList();
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class, EndpointAutoConfiguration.class,
			WebEndpointAutoConfiguration.class, WebMvcEndpointManagementContextConfiguration.class,
			WebFluxEndpointManagementContextConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
			WebFluxAutoConfiguration.class, HttpHandlerAutoConfiguration.class,
			JacksonEndpointAutoConfiguration.class })
	static class BaseDocumentationConfiguration {
		@Bean
		static BeanPostProcessor endpointObjectMapperBeanPostProcessor() {
			return new BeanPostProcessor() {
				@Override
				public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
					if (bean instanceof EndpointObjectMapper) {
						return (EndpointObjectMapper) () -> ((EndpointObjectMapper) bean).get()
							.enable(SerializationFeature.INDENT_OUTPUT);
					}
					return bean;
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation;
/**
@TestPropertySource(properties = 'spring.jackson.serialization.write-dates-as-timestamps=false')
class SessionsEndpointDocumentationTests extends MockMvcEndpointDocumentationTests {
	private static final Session sessionOne = createSession(Instant.now().minusSeconds(60 * 60 * 12),
			Instant.now().minusSeconds(45));
	private static final Session sessionTwo = createSession('4db5efcc-99cb-4d05-a52c-b49acfbb7ea9',
			Instant.now().minusSeconds(60 * 60 * 5), Instant.now().minusSeconds(37));
	private static final Session sessionThree = createSession(Instant.now().minusSeconds(60 * 60 * 2),
			Instant.now().minusSeconds(12));
	private static final List<FieldDescriptor> sessionFields = List.of(
			fieldWithPath('id').description('ID of the session.'),
			fieldWithPath('attributeNames').description('Names of the attributes stored in the session.'),
			fieldWithPath('creationTime').description('Timestamp of when the session was created.'),
			fieldWithPath('lastAccessedTime').description('Timestamp of when the session was last accessed.'),
			fieldWithPath('maxInactiveInterval')
				.description('Maximum permitted period of inactivity, in seconds, before the session will expire.'),
			fieldWithPath('expired').description('Whether the session has expired.'));
	@MockitoBean
	private FindByIndexNameSessionRepository<Session> sessionRepository;
	@Test
	void sessionsForUsername() {
		Map<String, Session> sessions = new HashMap<>();
		sessions.put(sessionOne.getId(), sessionOne);
		sessions.put(sessionTwo.getId(), sessionTwo);
		sessions.put(sessionThree.getId(), sessionThree);
		given(this.sessionRepository.findByPrincipalName('alice')).willReturn(sessions);
		assertThat(this.mvc.get().uri('/actuator/sessions').param('username', 'alice')).hasStatusOk()
			.apply(document('sessions/username',
					responseFields(fieldWithPath('sessions').description('Sessions for the given username.'))
						.andWithPrefix('sessions.[].', sessionFields),
					queryParameters(parameterWithName('username').description('Name of the user.'))));
	}
	@Test
	void sessionWithId() {
		given(this.sessionRepository.findById(sessionTwo.getId())).willReturn(sessionTwo);
		assertThat(this.mvc.get().uri('/actuator/sessions/{id}', sessionTwo.getId())).hasStatusOk()
			.apply(document('sessions/id', responseFields(sessionFields)));
	}
	@Test
	void deleteASession() {
		assertThat(this.mvc.delete().uri('/actuator/sessions/{id}', sessionTwo.getId()))
			.hasStatus(HttpStatus.NO_CONTENT)
			.apply(document('sessions/delete'));
		then(this.sessionRepository).should().deleteById(sessionTwo.getId());
	}
	private static MapSession createSession(Instant creationTime, Instant lastAccessedTime) {
		return createSession(UUID.randomUUID().toString(), creationTime, lastAccessedTime);
	}
	private static MapSession createSession(String id, Instant creationTime, Instant lastAccessedTime) {
		MapSession session = new MapSession(id);
		session.setCreationTime(creationTime);
		session.setLastAccessedTime(lastAccessedTime);
		return session;
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseDocumentationConfiguration.class)
	static class TestConfiguration {
		@Bean
		SessionsEndpoint endpoint(FindByIndexNameSessionRepository<?> sessionRepository) {
			return new SessionsEndpoint(sessionRepository, sessionRepository);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
class WebEndpointPropertiesTests {
	@Test
	void defaultBasePathShouldBeApplication() {
		WebEndpointProperties properties = new WebEndpointProperties();
		assertThat(properties.getBasePath()).isEqualTo('/actuator');
	}
	@Test
	void basePathShouldBeCleaned() {
		WebEndpointProperties properties = new WebEndpointProperties();
		properties.setBasePath('/');
		assertThat(properties.getBasePath()).isEmpty();
		properties.setBasePath('/actuator/');
		assertThat(properties.getBasePath()).isEqualTo('/actuator');
	}
	@Test
	void basePathMustStartWithSlash() {
		WebEndpointProperties properties = new WebEndpointProperties();
		assertThatIllegalArgumentException().isThrownBy(() -> properties.setBasePath('admin'))
			.withMessageContaining('Base path must start with "/" or be empty');
	}
	@Test
	void basePathCanBeEmpty() {
		WebEndpointProperties properties = new WebEndpointProperties();
		properties.setBasePath('');
		assertThat(properties.getBasePath()).isEmpty();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
class MappingWebEndpointPathMapperTests {
	@Test
	void defaultConfiguration() {
		MappingWebEndpointPathMapper mapper = new MappingWebEndpointPathMapper(Collections.emptyMap());
		assertThat(PathMapper.getRootPath(Collections.singletonList(mapper), EndpointId.of('test'))).isEqualTo('test');
	}
	@Test
	void userConfiguration() {
		MappingWebEndpointPathMapper mapper = new MappingWebEndpointPathMapper(
				Collections.singletonMap('test', 'custom'));
		assertThat(PathMapper.getRootPath(Collections.singletonList(mapper), EndpointId.of('test')))
			.isEqualTo('custom');
	}
	@Test
	void mixedCaseDefaultConfiguration() {
		MappingWebEndpointPathMapper mapper = new MappingWebEndpointPathMapper(Collections.emptyMap());
		assertThat(PathMapper.getRootPath(Collections.singletonList(mapper), EndpointId.of('testEndpoint')))
			.isEqualTo('testEndpoint');
	}
	@Test
	void mixedCaseUserConfiguration() {
		MappingWebEndpointPathMapper mapper = new MappingWebEndpointPathMapper(
				Collections.singletonMap('test-endpoint', 'custom'));
		assertThat(PathMapper.getRootPath(Collections.singletonList(mapper), EndpointId.of('testEndpoint')))
			.isEqualTo('custom');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint;
/**
class PropertiesEndpointAccessResolverTests {
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void whenNoPropertiesAreConfiguredThenAccessForReturnsEndpointsDefaultAccess() {
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.READ_ONLY);
	}
	@Test
	void whenDefaultAccessForAllEndpointsIsConfiguredThenAccessForReturnsDefaultForAllEndpoints() {
		this.environment.withProperty('management.endpoints.access.default', Access.UNRESTRICTED.name());
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.UNRESTRICTED);
	}
	@Test
	void whenAccessForEndpointIsConfiguredThenAccessForReturnsIt() {
		this.environment.withProperty('management.endpoint.test.access', Access.UNRESTRICTED.name());
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.UNRESTRICTED);
	}
	@Test
	void whenAccessForEndpointAndDefaultAccessForAllEndpointsAreConfiguredAccessForReturnsAccessForEndpoint() {
		this.environment.withProperty('management.endpoint.test.access', Access.NONE.name())
			.withProperty('management.endpoints.access.default', Access.UNRESTRICTED.name());
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.NONE);
	}
	@Test
	void whenAllEndpointsAreDisabledByDefaultAccessForReturnsNone() {
		this.environment.withProperty('management.endpoints.enabled-by-default', 'false');
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.NONE);
	}
	@Test
	void whenAllEndpointsAreEnabledByDefaultAccessForReturnsUnrestricted() {
		this.environment.withProperty('management.endpoints.enabled-by-default', 'true');
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.UNRESTRICTED);
	}
	@Test
	void whenEndpointIsDisabledAccessForReturnsNone() {
		this.environment.withProperty('management.endpoint.test.enabled', 'false');
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.NONE);
	}
	@Test
	void whenEndpointIsEnabledAccessForReturnsUnrestricted() {
		this.environment.withProperty('management.endpoint.test.enabled', 'true');
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.UNRESTRICTED);
	}
	@Test
	void whenEnabledByDefaultAndDefaultAccessAreBothConfiguredResolverCreationThrows() {
		this.environment.withProperty('management.endpoints.enabled-by-default', 'true')
			.withProperty('management.endpoints.access.default', Access.READ_ONLY.name());
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class)
			.isThrownBy(this::accessResolver);
	}
	@Test
	void whenEndpointEnabledAndAccessAreBothConfiguredAccessForThrows() {
		this.environment.withProperty('management.endpoint.test.enabled', 'true')
			.withProperty('management.endpoint.test.access', Access.READ_ONLY.name());
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class)
			.isThrownBy(() -> accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY));
	}
	@Test
	void whenAllEndpointsAreEnabledByDefaultAndAccessIsLimitedToReadOnlyAccessForReturnsReadOnly() {
		this.environment.withProperty('management.endpoints.enabled-by-default', 'true')
			.withProperty('management.endpoints.access.max-permitted', Access.READ_ONLY.name());
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.READ_ONLY);
	}
	@Test
	void whenAllEndpointsHaveUnrestrictedDefaultAccessAndAccessIsLimitedToReadOnlyAccessForReturnsReadOnly() {
		this.environment.withProperty('management.endpoints.access.default', Access.UNRESTRICTED.name())
			.withProperty('management.endpoints.access.max-permitted', Access.READ_ONLY.name());
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.READ_ONLY);
	}
	@Test
	void whenEndpointsIsEnabledAndAccessIsLimitedToNoneAccessForReturnsNone() {
		this.environment.withProperty('management.endpoint.test.enabled', 'true')
			.withProperty('management.endpoints.access.max-permitted', Access.NONE.name());
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.NONE);
	}
	@Test
	void whenEndpointsHasUnrestrictedAccessAndAccessIsLimitedToNoneAccessForReturnsNone() {
		this.environment.withProperty('management.endpoint.test.access', Access.UNRESTRICTED.name())
			.withProperty('management.endpoints.access.max-permitted', Access.NONE.name());
		assertThat(accessResolver().accessFor(EndpointId.of('test'), Access.READ_ONLY)).isEqualTo(Access.NONE);
	}
	private PropertiesEndpointAccessResolver accessResolver() {
		return new PropertiesEndpointAccessResolver(this.environment);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint;
/**
class EndpointIdTimeToLivePropertyFunctionTests {
	private final MockEnvironment environment = new MockEnvironment();
	private final Function<EndpointId, Long> timeToLive = new EndpointIdTimeToLivePropertyFunction(this.environment);
	@Test
	void defaultConfiguration() {
		Long result = this.timeToLive.apply(EndpointId.of('test'));
		assertThat(result).isNull();
	}
	@Test
	void userConfiguration() {
		this.environment.setProperty('management.endpoint.test.cache.time-to-live', '500');
		Long result = this.timeToLive.apply(EndpointId.of('test'));
		assertThat(result).isEqualTo(500L);
	}
	@Test
	void mixedCaseUserConfiguration() {
		this.environment.setProperty('management.endpoint.another-test.cache.time-to-live', '500');
		Long result = this.timeToLive.apply(EndpointId.of('anotherTest'));
		assertThat(result).isEqualTo(500L);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.condition;
/**
class ConditionalOnAvailableEndpointTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(AllEndpointsConfiguration.class)
		.withInitializer(
				(context) -> context.getEnvironment().setConversionService(new ApplicationConversionService()));
	@Test
	void outcomeShouldMatchDefaults() {
		this.contextRunner.run((context) -> assertThat(context).hasBean('health')
			.doesNotHaveBean('spring')
			.doesNotHaveBean('test')
			.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWithEnabledByDefaultSetToFalseShouldNotMatchAnything() {
		this.contextRunner.withPropertyValues('management.endpoints.enabled-by-default=false')
			.run((context) -> assertThat(context).doesNotHaveBean('info')
				.doesNotHaveBean('health')
				.doesNotHaveBean('spring')
				.doesNotHaveBean('test')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeAllWebShouldMatchEnabledEndpoints() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*')
			.run((context) -> assertThat(context).hasBean('info')
				.hasBean('health')
				.hasBean('test')
				.hasBean('spring')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeAllWebAndDisablingEndpointShouldMatchEnabledEndpoints() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*', 'management.endpoint.test.enabled=false',
					'management.endpoint.health.enabled=false')
			.run((context) -> assertThat(context).hasBean('info')
				.doesNotHaveBean('health')
				.doesNotHaveBean('test')
				.hasBean('spring')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeAllWebAndEnablingEndpointDisabledByDefaultShouldMatchAll() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoint.shutdown.enabled=true')
			.run((context) -> assertThat(context).hasBean('info')
				.hasBean('health')
				.hasBean('test')
				.hasBean('spring')
				.hasBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeAllJmxButJmxDisabledShouldMatchDefaults() {
		this.contextRunner.withPropertyValues('management.endpoints.jmx.exposure.include=*')
			.run((context) -> assertThat(context).hasBean('health')
				.doesNotHaveBean('spring')
				.doesNotHaveBean('test')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeAllJmxAndJmxEnabledShouldMatchEnabledEndpoints() {
		this.contextRunner.withPropertyValues('management.endpoints.jmx.exposure.include=*', 'spring.jmx.enabled=true')
			.run((context) -> assertThat(context).hasBean('info')
				.hasBean('health')
				.hasBean('test')
				.hasBean('spring')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeAllJmxAndJmxEnabledAndEnablingEndpointDisabledByDefaultShouldMatchAll() {
		this.contextRunner
			.withPropertyValues('management.endpoints.jmx.exposure.include=*', 'spring.jmx.enabled=true',
					'management.endpoint.shutdown.enabled=true')
			.run((context) -> assertThat(context).hasBean('health')
				.hasBean('test')
				.hasBean('spring')
				.hasBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeAllWebAndExcludeMatchesShouldNotMatch() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.web.exposure.exclude=spring,info')
			.run((context) -> assertThat(context).hasBean('health')
				.hasBean('test')
				.doesNotHaveBean('info')
				.doesNotHaveBean('spring')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeMatchesAndExcludeMatchesShouldNotMatch() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=info,health,spring,test',
					'management.endpoints.web.exposure.exclude=spring,info')
			.run((context) -> assertThat(context).hasBean('health')
				.hasBean('test')
				.doesNotHaveBean('info')
				.doesNotHaveBean('spring')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeMatchesShouldMatchEnabledEndpoints() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=spring')
			.run((context) -> assertThat(context).hasBean('spring')
				.doesNotHaveBean('health')
				.doesNotHaveBean('info')
				.doesNotHaveBean('test')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeMatchOnDisabledEndpointShouldNotMatch() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=shutdown')
			.run((context) -> assertThat(context).doesNotHaveBean('spring')
				.doesNotHaveBean('health')
				.doesNotHaveBean('info')
				.doesNotHaveBean('test')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeMatchOnEnabledEndpointShouldNotMatch() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=shutdown',
					'management.endpoint.shutdown.enabled=true')
			.run((context) -> assertThat(context).doesNotHaveBean('spring')
				.doesNotHaveBean('health')
				.doesNotHaveBean('info')
				.doesNotHaveBean('test')
				.hasBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeMatchesWithCaseShouldMatch() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=sPRing')
			.run((context) -> assertThat(context).hasBean('spring')
				.doesNotHaveBean('health')
				.doesNotHaveBean('info')
				.doesNotHaveBean('test')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeMatchesAndExcludeAllShouldNotMatch() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=info,health,spring,test',
					'management.endpoints.web.exposure.exclude=*')
			.run((context) -> assertThat(context).doesNotHaveBean('health')
				.doesNotHaveBean('info')
				.doesNotHaveBean('spring')
				.doesNotHaveBean('test')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWhenIncludeMatchesShouldMatchWithExtensionsAndComponents() {
		this.contextRunner.withUserConfiguration(ComponentEnabledIfEndpointIsExposedConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=spring')
			.run((context) -> assertThat(context).hasBean('spring')
				.hasBean('springComponent')
				.hasBean('springExtension')
				.doesNotHaveBean('info')
				.doesNotHaveBean('health')
				.doesNotHaveBean('test')
				.doesNotHaveBean('shutdown'));
	}
	@Test
	void outcomeWithNoEndpointReferenceShouldFail() {
		this.contextRunner.withUserConfiguration(ComponentWithNoEndpointReferenceConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=*')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure().getCause().getMessage())
					.contains('No endpoint is specified and the return type of the @Bean method '
							+ 'is neither an @Endpoint, nor an @EndpointExtension');
			});
	}
	@Test
	void outcomeOnCloudFoundryShouldMatchAll() {
		this.contextRunner.withPropertyValues('VCAP_APPLICATION:---')
			.run((context) -> assertThat(context).hasBean('info').hasBean('health').hasBean('spring').hasBean('test'));
	}
	@Test // gh-21044
	void outcomeWhenIncludeAllShouldMatchDashedEndpoint() {
		this.contextRunner.withUserConfiguration(DashedEndpointConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=*')
			.run((context) -> assertThat(context).hasSingleBean(DashedEndpoint.class));
	}
	@Test // gh-21044
	void outcomeWhenIncludeDashedShouldMatchDashedEndpoint() {
		this.contextRunner.withUserConfiguration(DashedEndpointConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=test-dashed')
			.run((context) -> assertThat(context).hasSingleBean(DashedEndpoint.class));
	}
	@Test
	void outcomeWhenEndpointNotExposedOnSpecifiedTechnology() {
		this.contextRunner.withUserConfiguration(ExposureEndpointConfiguration.class)
			.withPropertyValues('spring.jmx.enabled=true', 'management.endpoints.jmx.exposure.include=test',
					'management.endpoints.web.exposure.exclude=test')
			.run((context) -> assertThat(context).doesNotHaveBean('unexposed'));
	}
	@Test
	void whenBothAccessAndEnabledAreConfiguredThenThrows() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoint.shutdown.enabled=true', 'management.endpoint.shutdown.access=none')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.rootCause()
				.isInstanceOf(MutuallyExclusiveConfigurationPropertiesException.class));
	}
	@Test
	void whenBothDefaultAccessAndDefaultEnabledAreConfiguredThenThrows() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.enabled-by-default=true', 'management.endpoints.access.default=none')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.rootCause()
				.isInstanceOf(MutuallyExclusiveConfigurationPropertiesException.class));
	}
	@Test
	void whenDisabledAndAccessibleByDefaultEndpointIsNotAvailable() {
		this.contextRunner.withUserConfiguration(DisabledButAccessibleEndpointConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=*')
			.run((context) -> assertThat(context).doesNotHaveBean(DisabledButAccessibleEndpoint.class));
	}
	@Test
	void whenDisabledAndAccessibleByDefaultEndpointCanBeAvailable() {
		this.contextRunner.withUserConfiguration(DisabledButAccessibleEndpointConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=unrestricted')
			.run((context) -> assertThat(context).hasSingleBean(DisabledButAccessibleEndpoint.class));
	}
	@Endpoint(id = 'health')
	static class HealthEndpoint {
	}
	@Endpoint(id = 'info')
	static class InfoEndpoint {
	}
	@Endpoint(id = 'spring')
	static class SpringEndpoint {
	}
	@Endpoint(id = 'test')
	static class TestEndpoint {
	}
	@Endpoint(id = 'shutdown', defaultAccess = Access.NONE)
	static class ShutdownEndpoint {
	}
	@Endpoint(id = 'test-dashed')
	static class DashedEndpoint {
	}
	@Endpoint(id = 'disabledbutaccessible', enableByDefault = false)
	static class DisabledButAccessibleEndpoint {
	}
	@EndpointExtension(endpoint = SpringEndpoint.class, filter = TestFilter.class)
	static class SpringEndpointExtension {
	}
	static class TestFilter implements EndpointFilter<ExposableEndpoint<?>> {
		@Override
		public boolean match(ExposableEndpoint<?> endpoint) {
			return true;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AllEndpointsConfiguration {
		@Bean
		@ConditionalOnAvailableEndpoint
		HealthEndpoint health() {
			return new HealthEndpoint();
		}
		@Bean
		@ConditionalOnAvailableEndpoint
		InfoEndpoint info() {
			return new InfoEndpoint();
		}
		@Bean
		@ConditionalOnAvailableEndpoint
		SpringEndpoint spring() {
			return new SpringEndpoint();
		}
		@Bean
		@ConditionalOnAvailableEndpoint
		TestEndpoint test() {
			return new TestEndpoint();
		}
		@Bean
		@ConditionalOnAvailableEndpoint
		ShutdownEndpoint shutdown() {
			return new ShutdownEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ComponentEnabledIfEndpointIsExposedConfiguration {
		@Bean
		@ConditionalOnAvailableEndpoint(SpringEndpoint.class)
		String springComponent() {
			return 'springComponent';
		}
		@Bean
		@ConditionalOnAvailableEndpoint
		SpringEndpointExtension springExtension() {
			return new SpringEndpointExtension();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ComponentWithNoEndpointReferenceConfiguration {
		@Bean
		@ConditionalOnAvailableEndpoint
		String springcomp() {
			return 'springcomp';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DashedEndpointConfiguration {
		@Bean
		@ConditionalOnAvailableEndpoint
		DashedEndpoint dashedEndpoint() {
			return new DashedEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExposureEndpointConfiguration {
		@Bean
		@ConditionalOnAvailableEndpoint(endpoint = TestEndpoint.class, exposure = EndpointExposure.WEB)
		String unexposed() {
			return 'unexposed';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DisabledButAccessibleEndpointConfiguration {
		@Bean
		@ConditionalOnAvailableEndpoint
		DisabledButAccessibleEndpoint disabledButAccessible() {
			return new DisabledButAccessibleEndpoint();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint;
/**
class EndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(EndpointAutoConfiguration.class));
	@Test
	void mapShouldUseConfigurationConverter() {
		this.contextRunner.withUserConfiguration(ConverterConfiguration.class).run((context) -> {
			ParameterValueMapper parameterValueMapper = context.getBean(ParameterValueMapper.class);
			Object paramValue = parameterValueMapper.mapParameterValue(new TestOperationParameter(Person.class),
					'John Smith');
			assertThat(paramValue).isInstanceOf(Person.class);
			Person person = (Person) paramValue;
			assertThat(person.firstName).isEqualTo('John');
			assertThat(person.lastName).isEqualTo('Smith');
		});
	}
	@Test
	void mapWhenConfigurationConverterIsNotQualifiedShouldNotConvert() {
		assertThatExceptionOfType(ParameterMappingException.class).isThrownBy(() -> {
			this.contextRunner.withUserConfiguration(NonQualifiedConverterConfiguration.class).run((context) -> {
				ParameterValueMapper parameterValueMapper = context.getBean(ParameterValueMapper.class);
				parameterValueMapper.mapParameterValue(new TestOperationParameter(Person.class), 'John Smith');
			});
		}).withCauseInstanceOf(ConverterNotFoundException.class);
	}
	@Test
	void mapShouldUseGenericConfigurationConverter() {
		this.contextRunner.withUserConfiguration(GenericConverterConfiguration.class).run((context) -> {
			ParameterValueMapper parameterValueMapper = context.getBean(ParameterValueMapper.class);
			Object paramValue = parameterValueMapper.mapParameterValue(new TestOperationParameter(Person.class),
					'John Smith');
			assertThat(paramValue).isInstanceOf(Person.class);
			Person person = (Person) paramValue;
			assertThat(person.firstName).isEqualTo('John');
			assertThat(person.lastName).isEqualTo('Smith');
		});
	}
	@Test
	void mapWhenGenericConfigurationConverterIsNotQualifiedShouldNotConvert() {
		assertThatExceptionOfType(ParameterMappingException.class).isThrownBy(() -> {
			this.contextRunner.withUserConfiguration(NonQualifiedGenericConverterConfiguration.class).run((context) -> {
				ParameterValueMapper parameterValueMapper = context.getBean(ParameterValueMapper.class);
				parameterValueMapper.mapParameterValue(new TestOperationParameter(Person.class), 'John Smith');
			});
		}).withCauseInstanceOf(ConverterNotFoundException.class);
	}
	static class PersonConverter implements Converter<String, Person> {
		@Override
		public Person convert(String source) {
			String[] content = StringUtils.split(source, ' ');
			return new Person(content[0], content[1]);
		}
	}
	static class GenericPersonConverter implements GenericConverter {
		@Override
		public Set<ConvertiblePair> getConvertibleTypes() {
			return Collections.singleton(new ConvertiblePair(String.class, Person.class));
		}
		@Override
		public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
			String[] content = StringUtils.split((String) source, ' ');
			return new Person(content[0], content[1]);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConverterConfiguration {
		@Bean
		@EndpointConverter
		Converter<String, Person> personConverter() {
			return new PersonConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonQualifiedConverterConfiguration {
		@Bean
		Converter<String, Person> personConverter() {
			return new PersonConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class GenericConverterConfiguration {
		@Bean
		@EndpointConverter
		GenericConverter genericPersonConverter() {
			return new GenericPersonConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonQualifiedGenericConverterConfiguration {
		@Bean
		GenericConverter genericPersonConverter() {
			return new GenericPersonConverter();
		}
	}
	static class Person {
		private final String firstName;
		private final String lastName;
		Person(String firstName, String lastName) {
			this.firstName = firstName;
			this.lastName = lastName;
		}
	}
	private static class TestOperationParameter implements OperationParameter {
		private final Class<?> type;
		TestOperationParameter(Class<?> type) {
			this.type = type;
		}
		@Override
		public String getName() {
			return 'test';
		}
		@Override
		public Class<?> getType() {
			return this.type;
		}
		@Override
		public boolean isMandatory() {
			return false;
		}
		@Override
		public <T extends Annotation> T getAnnotation(Class<T> annotation) {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.jackson;
/**
class JacksonEndpointAutoConfigurationTests {
	private final ApplicationContextRunner runner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonEndpointAutoConfiguration.class));
	@Test
	void endpointObjectMapperWhenNoProperty() {
		this.runner.run((context) -> assertThat(context).hasSingleBean(EndpointObjectMapper.class));
	}
	@Test
	void endpointObjectMapperWhenPropertyTrue() {
		this.runner.withPropertyValues('management.endpoints.jackson.isolated-object-mapper=true')
			.run((context) -> assertThat(context).hasSingleBean(EndpointObjectMapper.class));
	}
	@Test
	void endpointObjectMapperWhenPropertyFalse() {
		this.runner.withPropertyValues('management.endpoints.jackson.isolated-object-mapper=false')
			.run((context) -> assertThat(context).doesNotHaveBean(EndpointObjectMapper.class));
	}
	@Test
	void endpointObjectMapperDoesNotSerializeDatesAsTimestamps() {
		this.runner.run((context) -> {
			ObjectMapper objectMapper = context.getBean(EndpointObjectMapper.class).get();
			Instant now = Instant.now();
			String json = objectMapper.writeValueAsString(Map.of('timestamp', now));
			assertThat(json).contains(DateTimeFormatter.ISO_INSTANT.format(now));
		});
	}
	@Test
	void endpointObjectMapperDoesNotSerializeDurationsAsTimestamps() {
		this.runner.run((context) -> {
			ObjectMapper objectMapper = context.getBean(EndpointObjectMapper.class).get();
			Duration duration = Duration.ofSeconds(42);
			String json = objectMapper.writeValueAsString(Map.of('duration', duration));
			assertThat(json).contains(duration.toString());
		});
	}
	@Test
	void endpointObjectMapperDoesNotSerializeNullValues() {
		this.runner.run((context) -> {
			ObjectMapper objectMapper = context.getBean(EndpointObjectMapper.class).get();
			HashMap<String, String> map = new HashMap<>();
			map.put('key', null);
			String json = objectMapper.writeValueAsString(map);
			assertThat(json).isEqualTo('{}');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class TestEndpointMapperConfiguration {
		@Bean
		TestEndpointObjectMapper testEndpointObjectMapper() {
			return new TestEndpointObjectMapper();
		}
	}
	static class TestEndpointObjectMapper implements EndpointObjectMapper {
		@Override
		public ObjectMapper get() {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.expose;
/**
@ExtendWith(MockitoExtension.class)
class IncludeExcludeEndpointFilterTests {
	private IncludeExcludeEndpointFilter<?> filter;
	@Test
	void createWhenEndpointTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new IncludeExcludeEndpointFilter<>(null, new MockEnvironment(), 'foo'))
			.withMessageContaining('EndpointType must not be null');
	}
	@Test
	void createWhenEnvironmentIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new IncludeExcludeEndpointFilter<>(ExposableEndpoint.class, null, 'foo'))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void createWhenPrefixIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new IncludeExcludeEndpointFilter<>(ExposableEndpoint.class, new MockEnvironment(), null))
			.withMessageContaining('Prefix must not be empty');
	}
	@Test
	void createWhenPrefixIsEmptyShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new IncludeExcludeEndpointFilter<>(ExposableEndpoint.class, new MockEnvironment(), ''))
			.withMessageContaining('Prefix must not be empty');
	}
	@Test
	void matchWhenExposeIsEmptyAndExcludeIsEmptyAndInDefaultShouldMatch() {
		setupFilter('', '');
		assertThat(match(EndpointId.of('def'))).isTrue();
	}
	@Test
	void matchWhenExposeIsEmptyAndExcludeIsEmptyAndNotInDefaultShouldNotMatch() {
		setupFilter('', '');
		assertThat(match(EndpointId.of('bar'))).isFalse();
	}
	@Test
	void matchWhenExposeMatchesAndExcludeIsEmptyShouldMatch() {
		setupFilter('bar', '');
		assertThat(match(EndpointId.of('bar'))).isTrue();
	}
	@Test
	void matchWhenExposeDoesNotMatchAndExcludeIsEmptyShouldNotMatch() {
		setupFilter('bar', '');
		assertThat(match(EndpointId.of('baz'))).isFalse();
	}
	@Test
	void matchWhenExposeMatchesAndExcludeMatchesShouldNotMatch() {
		setupFilter('bar,baz', 'baz');
		assertThat(match(EndpointId.of('baz'))).isFalse();
	}
	@Test
	void matchWhenExposeMatchesAndExcludeDoesNotMatchShouldMatch() {
		setupFilter('bar,baz', 'buz');
		assertThat(match(EndpointId.of('baz'))).isTrue();
	}
	@Test
	void matchWhenExposeMatchesWithDifferentCaseShouldMatch() {
		setupFilter('bar', '');
		assertThat(match(EndpointId.of('bAr'))).isTrue();
	}
	@Test
	void matchWhenDiscovererDoesNotMatchShouldMatch() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('foo.include', 'bar');
		environment.setProperty('foo.exclude', '');
		this.filter = new IncludeExcludeEndpointFilter<>(DifferentTestExposableWebEndpoint.class, environment, 'foo');
		assertThat(match()).isTrue();
	}
	@Test
	void matchWhenIncludeIsAsteriskShouldMatchAll() {
		setupFilter('*', 'buz');
		assertThat(match(EndpointId.of('bar'))).isTrue();
		assertThat(match(EndpointId.of('baz'))).isTrue();
		assertThat(match(EndpointId.of('buz'))).isFalse();
	}
	@Test
	void matchWhenExcludeIsAsteriskShouldMatchNone() {
		setupFilter('bar,baz,buz', '*');
		assertThat(match(EndpointId.of('bar'))).isFalse();
		assertThat(match(EndpointId.of('baz'))).isFalse();
		assertThat(match(EndpointId.of('buz'))).isFalse();
	}
	@Test
	void matchWhenMixedCaseShouldMatch() {
		setupFilter('foo-bar', '');
		assertThat(match(EndpointId.of('fooBar'))).isTrue();
	}
	@Test // gh-20997
	void matchWhenDashInName() {
		setupFilter('bus-refresh', '');
		assertThat(match(EndpointId.of('bus-refresh'))).isTrue();
	}
	private void setupFilter(String include, String exclude) {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('foo.include', include);
		environment.setProperty('foo.exclude', exclude);
		this.filter = new IncludeExcludeEndpointFilter<>(TestExposableWebEndpoint.class, environment, 'foo', 'def');
	}
	private boolean match() {
		return match(null);
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private boolean match(EndpointId id) {
		ExposableEndpoint<?> endpoint = mock(TestExposableWebEndpoint.class);
		if (id != null) {
			given(endpoint.getEndpointId()).willReturn(id);
		}
		return ((EndpointFilter) this.filter).match(endpoint);
	}
	abstract static class TestExposableWebEndpoint implements ExposableWebEndpoint {
	}
	abstract static class DifferentTestExposableWebEndpoint implements ExposableWebEndpoint {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class JerseyEndpointAccessIntegrationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
			AnnotationConfigServletWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, JerseyAutoConfiguration.class,
				EndpointAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				BeansEndpointAutoConfiguration.class))
		.withClassLoader(new FilteredClassLoader(DispatcherServlet.class))
		.withUserConfiguration(CustomServletEndpoint.class)
		.withPropertyValues('server.port:0');
	@Test
	void accessIsUnrestrictedByDefault() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*').run((context) -> {
			WebTestClient client = createClient(context);
			assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
			assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
			assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isTrue();
		});
	}
	@Test
	void accessCanBeReadOnlyByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=READ_ONLY')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	@Test
	void accessCanBeNoneByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=NONE')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	@Test
	void accessForOneEndpointCanOverrideTheDefaultAccess() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=NONE', 'management.endpoint.customservlet.access=READ_ONLY')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	@Test
	void accessCanBeCappedAtReadOnly() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=UNRESTRICTED',
					'management.endpoints.access.max-permitted=READ_ONLY')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	@Test
	void accessCanBeCappedAtNone() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*',
				'management.endpoints.access.default=UNRESTRICTED', 'management.endpoints.access.max-permitted=NONE')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	private WebTestClient createClient(AssertableWebApplicationContext context) {
		int port = context.getSourceApplicationContext(ServletWebServerApplicationContext.class)
			.getWebServer()
			.getPort();
		ExchangeStrategies exchangeStrategies = ExchangeStrategies.builder()
			.codecs((configurer) -> configurer.defaultCodecs().maxInMemorySize(-1))
			.build();
		return WebTestClient.bindToServer()
			.baseUrl('http://localhost:' + port)
			.exchangeStrategies(exchangeStrategies)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	private boolean isAccessible(WebTestClient client, HttpMethod method, String path) {
		path = '/actuator/' + path;
		EntityExchangeResult<byte[]> result = client.method(method).uri(path).exchange().expectBody().returnResult();
		if (result.getStatus() == HttpStatus.OK) {
			return true;
		}
		if (result.getStatus() == HttpStatus.NOT_FOUND || result.getStatus() == HttpStatus.METHOD_NOT_ALLOWED) {
			return false;
		}
		throw new IllegalStateException(
				String.format('Unexpected %s HTTP status for endpoint %s', result.getStatus(), path));
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint(id = 'customservlet')
	@SuppressWarnings({ 'deprecation', 'removal' })
	static class CustomServletEndpoint
			implements Supplier<org.springframework.boot.actuate.endpoint.web.EndpointServlet> {
		@Override
		public org.springframework.boot.actuate.endpoint.web.EndpointServlet get() {
			return new org.springframework.boot.actuate.endpoint.web.EndpointServlet(new HttpServlet() {
				@Override
				protected void doGet(HttpServletRequest req, HttpServletResponse resp)
						throws ServletException, IOException {
				}
				@Override
				protected void doPost(HttpServletRequest req, HttpServletResponse resp)
						throws ServletException, IOException {
				}
			});
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebFluxEndpointAccessIntegrationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner(
			AnnotationConfigReactiveWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class,
				HttpHandlerAutoConfiguration.class, JacksonAutoConfiguration.class, CodecsAutoConfiguration.class,
				WebFluxAutoConfiguration.class, EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
				ManagementContextAutoConfiguration.class, ReactiveManagementContextAutoConfiguration.class))
		.withConfiguration(AutoConfigurations.of(EndpointAutoConfigurationClasses.ALL))
		.withUserConfiguration(CustomWebFluxEndpoint.class)
		.withPropertyValues('server.port:0');
	@Test
	void accessIsUnrestrictedByDefault() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*').run((context) -> {
			WebTestClient client = createClient(context);
			assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
			assertThat(isAccessible(client, HttpMethod.GET, 'customwebflux')).isTrue();
			assertThat(isAccessible(client, HttpMethod.POST, 'customwebflux')).isTrue();
		});
	}
	@Test
	void accessCanBeReadOnlyByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=READ_ONLY')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
				assertThat(isAccessible(client, HttpMethod.GET, 'customwebflux')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customwebflux')).isFalse();
			});
	}
	@Test
	void accessCanBeNoneByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=NONE')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customwebflux')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'customwebflux')).isFalse();
			});
	}
	@Test
	void accessForOneEndpointCanOverrideTheDefaultAccess() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=NONE', 'management.endpoint.customwebflux.access=UNRESTRICTED')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customwebflux')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customwebflux')).isTrue();
			});
	}
	@Test
	void accessCanBeCappedAtReadOnly() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=UNRESTRICTED',
					'management.endpoints.access.max-permitted=READ_ONLY')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
				assertThat(isAccessible(client, HttpMethod.GET, 'customwebflux')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customwebflux')).isFalse();
			});
	}
	@Test
	void accessCanBeCappedAtNone() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*',
				'management.endpoints.access.default=UNRESTRICTED', 'management.endpoints.access.max-permitted=NONE')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customwebflux')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'customwebflux')).isFalse();
			});
	}
	private WebTestClient createClient(AssertableReactiveWebApplicationContext context) {
		int port = context.getSourceApplicationContext(ReactiveWebServerApplicationContext.class)
			.getWebServer()
			.getPort();
		ExchangeStrategies exchangeStrategies = ExchangeStrategies.builder()
			.codecs((configurer) -> configurer.defaultCodecs().maxInMemorySize(-1))
			.build();
		return WebTestClient.bindToServer()
			.baseUrl('http://localhost:' + port)
			.exchangeStrategies(exchangeStrategies)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	private boolean isAccessible(WebTestClient client, HttpMethod method, String path) {
		path = '/actuator/' + path;
		EntityExchangeResult<byte[]> result = client.method(method).uri(path).exchange().expectBody().returnResult();
		if (result.getStatus() == HttpStatus.OK) {
			return true;
		}
		if (result.getStatus() == HttpStatus.NOT_FOUND || result.getStatus() == HttpStatus.METHOD_NOT_ALLOWED) {
			return false;
		}
		throw new IllegalStateException(
				String.format('Unexpected %s HTTP status for endpoint %s', result.getStatus(), path));
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'customwebflux')
	@SuppressWarnings('removal')
	static class CustomWebFluxEndpoint {
		@GetMapping('/')
		String get() {
			return 'get';
		}
		@PostMapping('/')
		String post() {
			return 'post';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class JerseyHealthEndpointAdditionalPathIntegrationTests extends
		AbstractHealthEndpointAdditionalPathIntegrationTests<WebApplicationContextRunner, ConfigurableWebApplicationContext, AssertableWebApplicationContext> {
	JerseyHealthEndpointAdditionalPathIntegrationTests() {
		super(new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, JerseyAutoConfiguration.class,
					EndpointAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class,
					WebEndpointAutoConfiguration.class, JerseyAutoConfiguration.class,
					ManagementContextAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
					HealthEndpointAutoConfiguration.class, DiskSpaceHealthContributorAutoConfiguration.class))
			.withInitializer(new ServerPortInfoApplicationContextInitializer())
			.withClassLoader(new FilteredClassLoader(DispatcherServlet.class))
			.withPropertyValues('server.port=0'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebEndpointsAutoConfigurationIntegrationTests {
	@Test
	void healthEndpointWebExtensionIsAutoConfigured() {
		servletWebRunner().run((context) -> context.getBean(WebEndpointTestApplication.class));
		servletWebRunner().run((context) -> assertThat(context).hasSingleBean(HealthEndpointWebExtension.class));
	}
	@Test
	@ClassPathExclusions({ 'spring-security-oauth2-client-*.jar', 'spring-security-oauth2-resource-server-*.jar' })
	void healthEndpointReactiveWebExtensionIsAutoConfigured() {
		reactiveWebRunner()
			.run((context) -> assertThat(context).hasSingleBean(ReactiveHealthEndpointWebExtension.class));
	}
	private WebApplicationContextRunner servletWebRunner() {
		return new WebApplicationContextRunner()
			.withConfiguration(UserConfigurations.of(WebEndpointTestApplication.class))
			.withPropertyValues('management.tracing.enabled=false', 'management.defaults.metrics.export.enabled=false');
	}
	private ReactiveWebApplicationContextRunner reactiveWebRunner() {
		return new ReactiveWebApplicationContextRunner()
			.withConfiguration(UserConfigurations.of(WebEndpointTestApplication.class))
			.withPropertyValues('management.tracing.enabled=false', 'management.defaults.metrics.export.enabled=false');
	}
	@EnableAutoConfiguration(exclude = { FlywayAutoConfiguration.class, LiquibaseAutoConfiguration.class,
			CassandraAutoConfiguration.class, CassandraDataAutoConfiguration.class, Neo4jDataAutoConfiguration.class,
			Neo4jRepositoriesAutoConfiguration.class, MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
			MongoReactiveAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class,
			RepositoryRestMvcAutoConfiguration.class, HazelcastAutoConfiguration.class,
			ElasticsearchDataAutoConfiguration.class, RedisAutoConfiguration.class,
			RedisRepositoriesAutoConfiguration.class, BraveAutoConfiguration.class,
			OpenTelemetryTracingAutoConfiguration.class })
	@SpringBootConfiguration
	static class WebEndpointTestApplication {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebFluxEndpointIntegrationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, CodecsAutoConfiguration.class,
				WebFluxAutoConfiguration.class, HttpHandlerAutoConfiguration.class, EndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				ReactiveManagementContextAutoConfiguration.class, BeansEndpointAutoConfiguration.class))
		.withUserConfiguration(EndpointsConfiguration.class);
	@Test
	void linksAreProvidedToAllEndpointTypes() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include:*').run((context) -> {
			WebTestClient client = createWebTestClient(context);
			client.get()
				.uri('/actuator')
				.exchange()
				.expectStatus()
				.isOk()
				.expectBody()
				.jsonPath('_links.beans')
				.isNotEmpty()
				.jsonPath('_links.restcontroller')
				.isNotEmpty()
				.jsonPath('_links.controller')
				.isNotEmpty();
		});
	}
	@Test
	void linksPageIsNotAvailableWhenDisabled() {
		this.contextRunner.withPropertyValues('management.endpoints.web.discovery.enabled=false').run((context) -> {
			WebTestClient client = createWebTestClient(context);
			client.get().uri('/actuator').exchange().expectStatus().isNotFound();
		});
	}
	@Test
	void endpointObjectMapperCanBeApplied() {
		this.contextRunner.withUserConfiguration(EndpointObjectMapperConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include:*')
			.run((context) -> {
				WebTestClient client = createWebTestClient(context);
				client.get()
					.uri('/actuator/beans')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.consumeWith((result) -> {
						String json = new String(result.getResponseBody(), StandardCharsets.UTF_8);
						assertThat(json).contains('\'scope\':\'notelgnis\'');
					});
			});
	}
	private WebTestClient createWebTestClient(ApplicationContext context) {
		return WebTestClient.bindToApplicationContext(context)
			.configureClient()
			.baseUrl('https://spring.example.org')
			.build();
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpoint(id = 'controller')
	@SuppressWarnings('removal')
	static class TestControllerEndpoint {
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'restcontroller')
	@SuppressWarnings('removal')
	static class TestRestControllerEndpoint {
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointsConfiguration {
		@Bean
		TestControllerEndpoint testControllerEndpoint() {
			return new TestControllerEndpoint();
		}
		@Bean
		TestRestControllerEndpoint testRestControllerEndpoint() {
			return new TestRestControllerEndpoint();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebMvcEndpointExposureIntegrationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
			AnnotationConfigServletWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class, JacksonAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class, WebMvcAutoConfiguration.class,
				EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
				ManagementContextAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
				ManagementContextAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
				HttpExchangesAutoConfiguration.class, HealthContributorAutoConfiguration.class))
		.withConfiguration(AutoConfigurations.of(EndpointAutoConfigurationClasses.ALL))
		.withUserConfiguration(CustomMvcEndpoint.class, CustomServletEndpoint.class,
				HttpExchangeRepositoryConfiguration.class, AuditEventRepositoryConfiguration.class)
		.withPropertyValues('server.port:0');
	@Test
	void webEndpointsAreDisabledByDefault() {
		this.contextRunner.run((context) -> {
			WebTestClient client = createClient(context);
			assertThat(isExposed(client, HttpMethod.GET, 'beans')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'conditions')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'configprops')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'custommvc')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'customservlet')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'env')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'health')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'info')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'mappings')).isFalse();
			assertThat(isExposed(client, HttpMethod.POST, 'shutdown')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'threaddump')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'httpexchanges')).isFalse();
		});
	}
	@Test
	void webEndpointsCanBeExposed() {
		WebApplicationContextRunner contextRunner = this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*');
		contextRunner.run((context) -> {
			WebTestClient client = createClient(context);
			assertThat(isExposed(client, HttpMethod.GET, 'beans')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'conditions')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'configprops')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'custommvc')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'customservlet')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'env')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'health')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'info')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'mappings')).isTrue();
			assertThat(isExposed(client, HttpMethod.POST, 'shutdown')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'threaddump')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'httpexchanges')).isTrue();
		});
	}
	@Test
	void singleWebEndpointCanBeExposed() {
		WebApplicationContextRunner contextRunner = this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=beans');
		contextRunner.run((context) -> {
			WebTestClient client = createClient(context);
			assertThat(isExposed(client, HttpMethod.GET, 'beans')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'conditions')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'configprops')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'custommvc')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'customservlet')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'env')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'health')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'info')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'mappings')).isFalse();
			assertThat(isExposed(client, HttpMethod.POST, 'shutdown')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'threaddump')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'httpexchanges')).isFalse();
		});
	}
	@Test
	void singleWebEndpointCanBeExcluded() {
		WebApplicationContextRunner contextRunner = this.contextRunner.withPropertyValues(
				'management.endpoints.web.exposure.include=*', 'management.endpoints.web.exposure.exclude=shutdown');
		contextRunner.run((context) -> {
			WebTestClient client = createClient(context);
			assertThat(isExposed(client, HttpMethod.GET, 'beans')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'conditions')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'configprops')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'custommvc')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'customservlet')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'env')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'health')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'info')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'mappings')).isTrue();
			assertThat(isExposed(client, HttpMethod.POST, 'shutdown')).isFalse();
			assertThat(isExposed(client, HttpMethod.GET, 'threaddump')).isTrue();
			assertThat(isExposed(client, HttpMethod.GET, 'httpexchanges')).isTrue();
		});
	}
	private WebTestClient createClient(AssertableWebApplicationContext context) {
		int port = context.getSourceApplicationContext(ServletWebServerApplicationContext.class)
			.getWebServer()
			.getPort();
		ExchangeStrategies exchangeStrategies = ExchangeStrategies.builder()
			.codecs((configurer) -> configurer.defaultCodecs().maxInMemorySize(-1))
			.build();
		return WebTestClient.bindToServer()
			.baseUrl('http://localhost:' + port)
			.exchangeStrategies(exchangeStrategies)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	private boolean isExposed(WebTestClient client, HttpMethod method, String path) {
		path = '/actuator/' + path;
		EntityExchangeResult<byte[]> result = client.method(method).uri(path).exchange().expectBody().returnResult();
		if (result.getStatus() == HttpStatus.OK) {
			return true;
		}
		if (result.getStatus() == HttpStatus.NOT_FOUND) {
			return false;
		}
		throw new IllegalStateException(
				String.format('Unexpected %s HTTP status for endpoint %s', result.getStatus(), path));
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'custommvc')
	@SuppressWarnings('removal')
	static class CustomMvcEndpoint {
		@GetMapping('/')
		String main() {
			return 'test';
		}
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint(id = 'customservlet')
	@SuppressWarnings({ 'deprecation', 'removal' })
	static class CustomServletEndpoint
			implements Supplier<org.springframework.boot.actuate.endpoint.web.EndpointServlet> {
		@Override
		public org.springframework.boot.actuate.endpoint.web.EndpointServlet get() {
			return new org.springframework.boot.actuate.endpoint.web.EndpointServlet(new HttpServlet() {
				@Override
				protected void doGet(HttpServletRequest req, HttpServletResponse resp)
						throws ServletException, IOException {
				}
			});
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HttpExchangeRepositoryConfiguration {
		@Bean
		InMemoryHttpExchangeRepository httpExchangeRepository() {
			return new InMemoryHttpExchangeRepository();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AuditEventRepositoryConfiguration {
		@Bean
		InMemoryAuditEventRepository auditEventRepository() {
			return new InMemoryAuditEventRepository();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebMvcEndpointCorsIntegrationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class, WebMvcAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class, EndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				ServletManagementContextAutoConfiguration.class, BeansEndpointAutoConfiguration.class))
		.withPropertyValues('management.endpoints.web.exposure.include:*');
	@Test
	void corsIsDisabledByDefault() {
		this.contextRunner.run(withMockMvc((mvc) -> assertThat(mvc.options()
			.uri('/actuator/beans')
			.header('Origin', 'foo.example.com')
			.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET'))
			.doesNotContainHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN)));
	}
	@Test
	void settingAllowedOriginsEnablesCors() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com')
			.run(withMockMvc((mvc) -> {
				assertThat(mvc.options()
					.uri('/actuator/beans')
					.header('Origin', 'bar.example.com')
					.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')).hasStatus(HttpStatus.FORBIDDEN);
				performAcceptedCorsRequest(mvc);
			}));
	}
	@Test
	void settingAllowedOriginPatternsEnablesCors() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origin-patterns:*.example.com',
					'management.endpoints.web.cors.allow-credentials:true')
			.run(withMockMvc((mvc) -> {
				assertThat(mvc.options()
					.uri('/actuator/beans')
					.header('Origin', 'bar.example.org')
					.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')).hasStatus(HttpStatus.FORBIDDEN);
				performAcceptedCorsRequest(mvc);
			}));
	}
	@Test
	void maxAgeDefaultsTo30Minutes() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com')
			.run(withMockMvc((mvc) -> {
				MvcTestResult result = performAcceptedCorsRequest(mvc);
				assertThat(result).hasHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, '1800');
			}));
	}
	@Test
	void maxAgeCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com',
					'management.endpoints.web.cors.max-age: 2400')
			.run(withMockMvc((mvc) -> {
				MvcTestResult result = performAcceptedCorsRequest(mvc);
				assertThat(result).hasHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, '2400');
			}));
	}
	@Test
	void requestsWithDisallowedHeadersAreRejected() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com')
			.run(withMockMvc((mvc) -> assertThat(mvc.options()
				.uri('/actuator/beans')
				.header('Origin', 'foo.example.com')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS, 'Alpha')).hasStatus(HttpStatus.FORBIDDEN)));
	}
	@Test
	void allowedHeadersCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com',
					'management.endpoints.web.cors.allowed-headers:Alpha,Bravo')
			.run(withMockMvc((mvc) -> assertThat(mvc.options()
				.uri('/actuator/beans')
				.header('Origin', 'foo.example.com')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS, 'Alpha')).hasStatusOk()
				.headers()
				.hasValue(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, 'Alpha')));
	}
	@Test
	void requestsWithDisallowedMethodsAreRejected() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com')
			.run(withMockMvc((mvc) -> assertThat(mvc.options()
				.uri('/actuator/beans')
				.header(HttpHeaders.ORIGIN, 'foo.example.com')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'PATCH')).hasStatus(HttpStatus.FORBIDDEN)));
	}
	@Test
	void allowedMethodsCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com',
					'management.endpoints.web.cors.allowed-methods:GET,HEAD')
			.run(withMockMvc((mvc) -> assertThat(mvc.options()
				.uri('/actuator/beans')
				.header(HttpHeaders.ORIGIN, 'foo.example.com')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'HEAD')).hasStatusOk()
				.headers()
				.hasValue(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, 'GET,HEAD')));
	}
	@Test
	void credentialsCanBeAllowed() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com',
					'management.endpoints.web.cors.allow-credentials:true')
			.run(withMockMvc((mvc) -> {
				MvcTestResult result = performAcceptedCorsRequest(mvc);
				assertThat(result).hasHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, 'true');
			}));
	}
	@Test
	void credentialsCanBeDisabled() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:foo.example.com',
					'management.endpoints.web.cors.allow-credentials:false')
			.run(withMockMvc((mvc) -> {
				MvcTestResult result = performAcceptedCorsRequest(mvc);
				assertThat(result).doesNotContainHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS);
			}));
	}
	private ContextConsumer<WebApplicationContext> withMockMvc(ThrowingConsumer<MockMvcTester> mvc) {
		return (context) -> mvc.accept(MockMvcTester.from(context));
	}
	private MvcTestResult performAcceptedCorsRequest(MockMvcTester mvc) {
		return performAcceptedCorsRequest(mvc, '/actuator/beans');
	}
	private MvcTestResult performAcceptedCorsRequest(MockMvcTester mvc, String url) {
		MvcTestResult result = mvc.options()
			.uri(url)
			.header(HttpHeaders.ORIGIN, 'foo.example.com')
			.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
			.exchange();
		assertThat(result).hasStatusOk().hasHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, 'foo.example.com');
		return result;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
@Configuration
class EndpointObjectMapperConfiguration {
	@Bean
	EndpointObjectMapper endpointObjectMapper() {
		SimpleModule module = new SimpleModule();
		module.addSerializer(String.class, new ReverseStringSerializer());
		ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json().modules(module).build();
		return () -> objectMapper;
	}
	static class ReverseStringSerializer extends StdScalarSerializer<Object> {
		ReverseStringSerializer() {
			super(String.class, false);
		}
		@Override
		public boolean isEmpty(SerializerProvider prov, Object value) {
			return ((String) value).isEmpty();
		}
		@Override
		public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
			serialize(value, gen);
		}
		@Override
		public final void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,
				TypeSerializer typeSer) throws IOException {
			serialize(value, gen);
		}
		private void serialize(Object value, JsonGenerator gen) throws IOException {
			StringBuilder builder = new StringBuilder((String) value);
			gen.writeString(builder.reverse().toString());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebMvcEndpointIntegrationTests {
	private AnnotationConfigServletWebApplicationContext context;
	@AfterEach
	void close() {
		TestSecurityContextHolder.clearContext();
		this.context.close();
	}
	@Test
	void webMvcEndpointHandlerMappingIsConfiguredWithPathPatternParser() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(DefaultConfiguration.class);
		this.context.setServletContext(new MockServletContext());
		this.context.refresh();
		WebMvcEndpointHandlerMapping handlerMapping = this.context.getBean(WebMvcEndpointHandlerMapping.class);
		assertThat(handlerMapping.getPatternParser()).isInstanceOf(PathPatternParser.class);
	}
	@Test
	void endpointsAreSecureByDefault() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(SecureConfiguration.class);
		MockMvcTester mvc = createSecureMockMvcTester();
		assertThat(mvc.get().uri('/actuator/beans').accept(MediaType.APPLICATION_JSON))
			.hasStatus(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void endpointsAreSecureByDefaultWithCustomBasePath() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(SecureConfiguration.class);
		TestPropertyValues.of('management.endpoints.web.base-path:/management').applyTo(this.context);
		MockMvcTester mvc = createSecureMockMvcTester();
		assertThat(mvc.get().uri('/management/beans').accept(MediaType.APPLICATION_JSON))
			.hasStatus(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void endpointsAreSecureWithActuatorRoleWithCustomBasePath() {
		TestSecurityContextHolder.getContext()
			.setAuthentication(new TestingAuthenticationToken('user', 'N/A', 'ROLE_ACTUATOR'));
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(SecureConfiguration.class);
		TestPropertyValues
			.of('management.endpoints.web.base-path:/management', 'management.endpoints.web.exposure.include=*')
			.applyTo(this.context);
		MockMvcTester mvc = createSecureMockMvcTester();
		assertThat(mvc.get().uri('/management/beans')).hasStatusOk();
	}
	@Test
	void linksAreProvidedToAllEndpointTypes() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(DefaultConfiguration.class, EndpointsConfiguration.class);
		TestPropertyValues.of('management.endpoints.web.exposure.include=*').applyTo(this.context);
		MockMvcTester mvc = doCreateMockMvcTester();
		assertThat(mvc.get().uri('/actuator').accept('*/*')).hasStatusOk()
			.bodyJson()
			.extractingPath('_links')
			.asMap()
			.containsKeys('beans', 'servlet', 'restcontroller', 'controller');
	}
	@Test
	void linksPageIsNotAvailableWhenDisabled() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(DefaultConfiguration.class, EndpointsConfiguration.class);
		TestPropertyValues.of('management.endpoints.web.discovery.enabled=false').applyTo(this.context);
		MockMvcTester mvc = doCreateMockMvcTester();
		assertThat(mvc.get().uri('/actuator').accept('*/*')).hasStatus(HttpStatus.NOT_FOUND);
	}
	@Test
	void endpointObjectMapperCanBeApplied() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(EndpointObjectMapperConfiguration.class, DefaultConfiguration.class);
		TestPropertyValues.of('management.endpoints.web.exposure.include=*').applyTo(this.context);
		MockMvcTester mvc = doCreateMockMvcTester();
		assertThat(mvc.get().uri('/actuator/beans')).hasStatusOk().bodyText().contains('\'scope\':\'notelgnis\'');
	}
	private MockMvcTester createSecureMockMvcTester() {
		return doCreateMockMvcTester(springSecurity());
	}
	private MockMvcTester doCreateMockMvcTester(MockMvcConfigurer... configurers) {
		this.context.setServletContext(new MockServletContext());
		this.context.refresh();
		return MockMvcTester.from(this.context, (builder) -> {
			for (MockMvcConfigurer configurer : configurers) {
				builder.apply(configurer);
			}
			return builder.build();
		});
	}
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
			ServletManagementContextAutoConfiguration.class, AuditAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class, WebMvcAutoConfiguration.class,
			ManagementContextAutoConfiguration.class, AuditAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, BeansEndpointAutoConfiguration.class })
	static class DefaultConfiguration {
	}
	@Import(SecureConfiguration.class)
	@ImportAutoConfiguration({ HypermediaAutoConfiguration.class })
	static class SpringHateoasConfiguration {
	}
	@Import(SecureConfiguration.class)
	@ImportAutoConfiguration({ HypermediaAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class })
	static class SpringDataRestConfiguration {
	}
	@Import(DefaultConfiguration.class)
	@ImportAutoConfiguration({ SecurityAutoConfiguration.class })
	static class SecureConfiguration {
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint(id = 'servlet')
	@SuppressWarnings({ 'deprecation', 'removal' })
	static class TestServletEndpoint
			implements Supplier<org.springframework.boot.actuate.endpoint.web.EndpointServlet> {
		@Override
		public org.springframework.boot.actuate.endpoint.web.EndpointServlet get() {
			return new org.springframework.boot.actuate.endpoint.web.EndpointServlet(new HttpServlet() {
			});
		}
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpoint(id = 'controller')
	@SuppressWarnings('removal')
	static class TestControllerEndpoint {
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'restcontroller')
	@SuppressWarnings('removal')
	static class TestRestControllerEndpoint {
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointsConfiguration {
		@Bean
		TestServletEndpoint testServletEndpoint() {
			return new TestServletEndpoint();
		}
		@Bean
		TestControllerEndpoint testControllerEndpoint() {
			return new TestControllerEndpoint();
		}
		@Bean
		TestRestControllerEndpoint testRestControllerEndpoint() {
			return new TestRestControllerEndpoint();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class JmxEndpointAccessIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JmxAutoConfiguration.class, EndpointAutoConfiguration.class,
				JmxEndpointAutoConfiguration.class, HealthContributorAutoConfiguration.class,
				HttpExchangesAutoConfiguration.class))
		.withUserConfiguration(CustomJmxEndpoint.class)
		.withPropertyValues('spring.jmx.enabled=true')
		.withConfiguration(AutoConfigurations.of(EndpointAutoConfigurationClasses.ALL));
	@Test
	void accessIsUnrestrictedByDefault() {
		this.contextRunner.withPropertyValues('management.endpoints.jmx.exposure.include=*').run((context) -> {
			MBeanServer mBeanServer = context.getBean(MBeanServer.class);
			assertThat(hasOperation(mBeanServer, 'beans', 'beans')).isTrue();
			assertThat(hasOperation(mBeanServer, 'customjmx', 'read')).isTrue();
			assertThat(hasOperation(mBeanServer, 'customjmx', 'write')).isTrue();
			assertThat(hasOperation(mBeanServer, 'customjmx', 'delete')).isTrue();
		});
	}
	@Test
	void accessCanBeReadOnlyByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.jmx.exposure.include=*',
					'management.endpoints.access.default=READ_ONLY')
			.run((context) -> {
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				assertThat(hasOperation(mBeanServer, 'beans', 'beans')).isTrue();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'read')).isTrue();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'write')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'delete')).isFalse();
			});
	}
	@Test
	void accessCanBeNoneByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.jmx.exposure.include=*',
					'management.endpoints.access.default=NONE')
			.run((context) -> {
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				assertThat(hasOperation(mBeanServer, 'beans', 'beans')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'read')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'write')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'delete')).isFalse();
			});
	}
	@Test
	void accessForOneEndpointCanOverrideTheDefaultAccess() {
		this.contextRunner
			.withPropertyValues('management.endpoints.jmx.exposure.include=*',
					'management.endpoints.access.default=NONE', 'management.endpoint.customjmx.access=UNRESTRICTED')
			.run((context) -> {
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				assertThat(hasOperation(mBeanServer, 'beans', 'beans')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'read')).isTrue();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'write')).isTrue();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'delete')).isTrue();
			});
	}
	@Test
	void accessCanBeCappedAtReadOnly() {
		this.contextRunner
			.withPropertyValues('management.endpoints.jmx.exposure.include=*',
					'management.endpoints.access.default=UNRESTRICTED',
					'management.endpoints.access.max-permitted=READ_ONLY')
			.run((context) -> {
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				assertThat(hasOperation(mBeanServer, 'beans', 'beans')).isTrue();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'read')).isTrue();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'write')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'delete')).isFalse();
			});
	}
	@Test
	void accessCanBeCappedAtNone() {
		this.contextRunner.withPropertyValues('management.endpoints.jmx.exposure.include=*',
				'management.endpoints.access.default=UNRESTRICTED', 'management.endpoints.access.max-permitted=NONE')
			.run((context) -> {
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				assertThat(hasOperation(mBeanServer, 'beans', 'beans')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'read')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'write')).isFalse();
				assertThat(hasOperation(mBeanServer, 'customjmx', 'delete')).isFalse();
			});
	}
	private ObjectName getDefaultObjectName(String endpointId) {
		return getObjectName('org.springframework.boot', endpointId);
	}
	private ObjectName getObjectName(String domain, String endpointId) {
		try {
			return new ObjectName(
					String.format('%s:type=Endpoint,name=%s', domain, StringUtils.capitalize(endpointId)));
		}
		catch (MalformedObjectNameException ex) {
			throw new IllegalStateException('Invalid object name', ex);
		}
	}
	private boolean hasOperation(MBeanServer mbeanServer, String endpoint, String operationName) {
		try {
			for (MBeanOperationInfo operation : mbeanServer.getMBeanInfo(getDefaultObjectName(endpoint))
				.getOperations()) {
				if (operation.getName().equals(operationName)) {
					return true;
				}
			}
		}
		catch (Exception ex) {
			// Continue
		}
		return false;
	}
	@JmxEndpoint(id = 'customjmx')
	static class CustomJmxEndpoint {
		@ReadOperation
		String read() {
			return 'read';
		}
		@WriteOperation
		String write() {
			return 'write';
		}
		@DeleteOperation
		String delete() {
			return 'delete';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebFluxHealthEndpointAdditionalPathIntegrationTests extends
		AbstractHealthEndpointAdditionalPathIntegrationTests<ReactiveWebApplicationContextRunner, ConfigurableReactiveWebApplicationContext, AssertableReactiveWebApplicationContext> {
	WebFluxHealthEndpointAdditionalPathIntegrationTests() {
		super(new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, CodecsAutoConfiguration.class,
					WebFluxAutoConfiguration.class, HttpHandlerAutoConfiguration.class, EndpointAutoConfiguration.class,
					HealthEndpointAutoConfiguration.class, DiskSpaceHealthContributorAutoConfiguration.class,
					WebEndpointAutoConfiguration.class, ManagementContextAutoConfiguration.class,
					ReactiveWebServerFactoryAutoConfiguration.class, ReactiveManagementContextAutoConfiguration.class,
					BeansEndpointAutoConfiguration.class))
			.withInitializer(new ServerPortInfoApplicationContextInitializer())
			.withPropertyValues('server.port=0'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class JerseyEndpointIntegrationTests {
	@Test
	void linksAreProvidedToAllEndpointTypes() {
		testJerseyEndpoints(new Class<?>[] { EndpointsConfiguration.class, ResourceConfigConfiguration.class });
	}
	@Test
	void linksPageIsNotAvailableWhenDisabled() {
		getContextRunner(new Class<?>[] { EndpointsConfiguration.class, ResourceConfigConfiguration.class })
			.withPropertyValues('management.endpoints.web.discovery.enabled:false')
			.run((context) -> {
				int port = context.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class)
					.getWebServer()
					.getPort();
				WebTestClient client = WebTestClient.bindToServer()
					.baseUrl('http://localhost:' + port)
					.responseTimeout(Duration.ofMinutes(5))
					.build();
				client.get().uri('/actuator').exchange().expectStatus().isNotFound();
			});
	}
	@Test
	void actuatorEndpointsWhenUserProvidedResourceConfigBeanNotAvailable() {
		testJerseyEndpoints(new Class<?>[] { EndpointsConfiguration.class });
	}
	@Test
	void actuatorEndpointsWhenSecurityAvailable() {
		WebApplicationContextRunner contextRunner = getContextRunner(
				new Class<?>[] { EndpointsConfiguration.class, ResourceConfigConfiguration.class },
				getAutoconfigurations(SecurityAutoConfiguration.class, ManagementWebSecurityAutoConfiguration.class));
		contextRunner.run((context) -> {
			int port = context.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class)
				.getWebServer()
				.getPort();
			WebTestClient client = WebTestClient.bindToServer()
				.baseUrl('http://localhost:' + port)
				.responseTimeout(Duration.ofMinutes(5))
				.build();
			client.get().uri('/actuator').exchange().expectStatus().isUnauthorized();
		});
	}
	@Test
	void endpointObjectMapperCanBeApplied() {
		WebApplicationContextRunner contextRunner = getContextRunner(new Class<?>[] { EndpointsConfiguration.class,
				ResourceConfigConfiguration.class, EndpointObjectMapperConfiguration.class });
		contextRunner.run((context) -> {
			int port = context.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class)
				.getWebServer()
				.getPort();
			WebTestClient client = WebTestClient.bindToServer()
				.baseUrl('http://localhost:' + port)
				.responseTimeout(Duration.ofMinutes(5))
				.build();
			client.get().uri('/actuator/beans').exchange().expectStatus().isOk().expectBody().consumeWith((result) -> {
				String json = new String(result.getResponseBody(), StandardCharsets.UTF_8);
				assertThat(json).contains('\'scope\':\'notelgnis\'');
			});
		});
	}
	protected void testJerseyEndpoints(Class<?>[] userConfigurations) {
		getContextRunner(userConfigurations).run((context) -> {
			int port = context.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class)
				.getWebServer()
				.getPort();
			WebTestClient client = WebTestClient.bindToServer()
				.baseUrl('http://localhost:' + port)
				.responseTimeout(Duration.ofMinutes(5))
				.build();
			client.get()
				.uri('/actuator')
				.exchange()
				.expectStatus()
				.isOk()
				.expectBody()
				.jsonPath('_links.beans')
				.isNotEmpty()
				.jsonPath('_links.restcontroller')
				.doesNotExist()
				.jsonPath('_links.controller')
				.doesNotExist();
		});
	}
	WebApplicationContextRunner getContextRunner(Class<?>[] userConfigurations,
			Class<?>... additionalAutoConfigurations) {
		FilteredClassLoader classLoader = new FilteredClassLoader(DispatcherServlet.class);
		return new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(classLoader)
			.withConfiguration(AutoConfigurations.of(getAutoconfigurations(additionalAutoConfigurations)))
			.withUserConfiguration(userConfigurations)
			.withPropertyValues('management.endpoints.web.exposure.include:*', 'server.port:0');
	}
	private Class<?>[] getAutoconfigurations(Class<?>... additional) {
		List<Class<?>> autoconfigurations = new ArrayList<>(Arrays.asList(JacksonAutoConfiguration.class,
				JerseyAutoConfiguration.class, EndpointAutoConfiguration.class,
				ServletWebServerFactoryAutoConfiguration.class, WebEndpointAutoConfiguration.class,
				ManagementContextAutoConfiguration.class, BeansEndpointAutoConfiguration.class));
		autoconfigurations.addAll(Arrays.asList(additional));
		return autoconfigurations.toArray(new Class<?>[0]);
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpoint(id = 'controller')
	@SuppressWarnings('removal')
	static class TestControllerEndpoint {
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'restcontroller')
	@SuppressWarnings('removal')
	static class TestRestControllerEndpoint {
	}
	@Configuration(proxyBeanMethods = false)
	static class EndpointsConfiguration {
		@Bean
		TestControllerEndpoint testControllerEndpoint() {
			return new TestControllerEndpoint();
		}
		@Bean
		TestRestControllerEndpoint testRestControllerEndpoint() {
			return new TestRestControllerEndpoint();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ResourceConfigConfiguration {
		@Bean
		ResourceConfig testResourceConfig() {
			return new ResourceConfig();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
final class EndpointAutoConfigurationClasses {
	static final Class<?>[] ALL;
	static {
		List<Class<?>> all = new ArrayList<>();
		all.add(AuditEventsEndpointAutoConfiguration.class);
		all.add(BeansEndpointAutoConfiguration.class);
		all.add(ConditionsReportEndpointAutoConfiguration.class);
		all.add(ConfigurationPropertiesReportEndpointAutoConfiguration.class);
		all.add(ShutdownEndpointAutoConfiguration.class);
		all.add(EnvironmentEndpointAutoConfiguration.class);
		all.add(HealthEndpointAutoConfiguration.class);
		all.add(InfoEndpointAutoConfiguration.class);
		all.add(ThreadDumpEndpointAutoConfiguration.class);
		all.add(HttpExchangesEndpointAutoConfiguration.class);
		all.add(MappingsEndpointAutoConfiguration.class);
		ALL = ClassUtils.toClassArray(all);
	}
	private EndpointAutoConfigurationClasses() {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
@SuppressWarnings('removal')
class ControllerEndpointWebFluxIntegrationTests {
	private AnnotationConfigReactiveWebApplicationContext context;
	@AfterEach
	void close() {
		TestSecurityContextHolder.clearContext();
		this.context.close();
	}
	@Test
	void endpointsCanBeAccessed() {
		TestSecurityContextHolder.getContext()
			.setAuthentication(new TestingAuthenticationToken('user', 'N/A', 'ROLE_ACTUATOR'));
		this.context = new AnnotationConfigReactiveWebApplicationContext();
		this.context.register(DefaultConfiguration.class, ExampleController.class);
		TestPropertyValues.of('management.endpoints.web.exposure.include=*').applyTo(this.context);
		this.context.refresh();
		WebTestClient webClient = WebTestClient.bindToApplicationContext(this.context).build();
		webClient.get().uri('/actuator/example').exchange().expectStatus().isOk();
	}
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
			ReactiveManagementContextAutoConfiguration.class, AuditAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class, WebFluxAutoConfiguration.class,
			ManagementContextAutoConfiguration.class, BeansEndpointAutoConfiguration.class })
	static class DefaultConfiguration {
	}
	@RestControllerEndpoint(id = 'example')
	static class ExampleController {
		@GetMapping('/')
		String example() {
			return 'Example';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class JmxEndpointIntegrationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JmxAutoConfiguration.class, EndpointAutoConfiguration.class,
				JmxEndpointAutoConfiguration.class, HealthContributorAutoConfiguration.class,
				HttpExchangesAutoConfiguration.class))
		.withUserConfiguration(HttpExchangeRepositoryConfiguration.class, AuditEventRepositoryConfiguration.class)
		.withPropertyValues('spring.jmx.enabled=true')
		.withConfiguration(AutoConfigurations.of(EndpointAutoConfigurationClasses.ALL));
	@Test
	void jmxEndpointsExposeHealthByDefault() {
		this.contextRunner.run((context) -> {
			MBeanServer mBeanServer = context.getBean(MBeanServer.class);
			checkEndpointMBeans(mBeanServer, new String[] { 'health' }, new String[] { 'beans', 'conditions',
					'configprops', 'env', 'info', 'mappings', 'threaddump', 'httpexchanges', 'shutdown' });
		});
	}
	@Test
	void jmxEndpointsAreExposedWhenLazyInitializationIsEnabled() {
		this.contextRunner.withPropertyValues('management.endpoints.jmx.exposure.include:*')
			.withBean(LazyInitializationBeanFactoryPostProcessor.class, LazyInitializationBeanFactoryPostProcessor::new)
			.run((context) -> {
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				checkEndpointMBeans(mBeanServer, new String[] { 'beans', 'conditions', 'configprops', 'env', 'health',
						'info', 'mappings', 'threaddump', 'httpexchanges' }, new String[] { 'shutdown' });
			});
	}
	@Test
	void jmxEndpointsCanBeExcluded() {
		this.contextRunner.withPropertyValues('management.endpoints.jmx.exposure.exclude:*').run((context) -> {
			MBeanServer mBeanServer = context.getBean(MBeanServer.class);
			checkEndpointMBeans(mBeanServer, new String[0], new String[] { 'beans', 'conditions', 'configprops', 'env',
					'health', 'mappings', 'shutdown', 'threaddump', 'httpexchanges' });
		});
	}
	@Test
	void singleJmxEndpointCanBeExposed() {
		this.contextRunner.withPropertyValues('management.endpoints.jmx.exposure.include=beans').run((context) -> {
			MBeanServer mBeanServer = context.getBean(MBeanServer.class);
			checkEndpointMBeans(mBeanServer, new String[] { 'beans' }, new String[] { 'conditions', 'configprops',
					'env', 'health', 'mappings', 'shutdown', 'threaddump', 'httpexchanges' });
		});
	}
	private void checkEndpointMBeans(MBeanServer mBeanServer, String[] enabledEndpoints, String[] disabledEndpoints) {
		for (String enabledEndpoint : enabledEndpoints) {
			assertThat(isRegistered(mBeanServer, getDefaultObjectName(enabledEndpoint)))
				.as(String.format('Endpoint %s', enabledEndpoint))
				.isTrue();
		}
		for (String disabledEndpoint : disabledEndpoints) {
			assertThat(isRegistered(mBeanServer, getDefaultObjectName(disabledEndpoint)))
				.as(String.format('Endpoint %s', disabledEndpoint))
				.isFalse();
		}
	}
	private boolean isRegistered(MBeanServer mBeanServer, ObjectName objectName) {
		try {
			getMBeanInfo(mBeanServer, objectName);
			return true;
		}
		catch (InstanceNotFoundException ex) {
			return false;
		}
	}
	private MBeanInfo getMBeanInfo(MBeanServer mBeanServer, ObjectName objectName) throws InstanceNotFoundException {
		try {
			return mBeanServer.getMBeanInfo(objectName);
		}
		catch (ReflectionException | IntrospectionException ex) {
			throw new IllegalStateException('Failed to retrieve MBeanInfo for ObjectName ' + objectName, ex);
		}
	}
	private ObjectName getDefaultObjectName(String endpointId) {
		return getObjectName('org.springframework.boot', endpointId);
	}
	private ObjectName getObjectName(String domain, String endpointId) {
		try {
			return new ObjectName(
					String.format('%s:type=Endpoint,name=%s', domain, StringUtils.capitalize(endpointId)));
		}
		catch (MalformedObjectNameException ex) {
			throw new IllegalStateException('Invalid object name', ex);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HttpExchangeRepositoryConfiguration {
		@Bean
		InMemoryHttpExchangeRepository httpExchangeRepository() {
			return new InMemoryHttpExchangeRepository();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AuditEventRepositoryConfiguration {
		@Bean
		InMemoryAuditEventRepository auditEventRepository() {
			return new InMemoryAuditEventRepository();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class ControllerEndpointWebMvcIntegrationTests {
	private AnnotationConfigServletWebApplicationContext context;
	@AfterEach
	void close() {
		TestSecurityContextHolder.clearContext();
		this.context.close();
	}
	@Test
	void endpointsAreSecureByDefault() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(SecureConfiguration.class, ExampleController.class);
		MockMvcTester mvc = createSecureMockMvcTester();
		assertThat(mvc.get().uri('/actuator/example').accept(MediaType.APPLICATION_JSON))
			.hasStatus(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void endpointsCanBeAccessed() {
		TestSecurityContextHolder.getContext()
			.setAuthentication(new TestingAuthenticationToken('user', 'N/A', 'ROLE_ACTUATOR'));
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(SecureConfiguration.class, ExampleController.class);
		TestPropertyValues
			.of('management.endpoints.web.base-path:/management', 'management.endpoints.web.exposure.include=*')
			.applyTo(this.context);
		MockMvcTester mvc = createSecureMockMvcTester();
		assertThat(mvc.get().uri('/management/example')).hasStatusOk();
	}
	private MockMvcTester createSecureMockMvcTester() {
		return doCreateMockMvcTester(springSecurity());
	}
	private MockMvcTester doCreateMockMvcTester(MockMvcConfigurer... configurers) {
		this.context.setServletContext(new MockServletContext());
		this.context.refresh();
		return MockMvcTester.from(this.context, (builder) -> {
			for (MockMvcConfigurer configurer : configurers) {
				builder.apply(configurer);
			}
			return builder.build();
		});
	}
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
			ServletManagementContextAutoConfiguration.class, AuditAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class, WebMvcAutoConfiguration.class,
			ManagementContextAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			BeansEndpointAutoConfiguration.class })
	static class DefaultConfiguration {
	}
	@Import(DefaultConfiguration.class)
	@ImportAutoConfiguration({ SecurityAutoConfiguration.class })
	static class SecureConfiguration {
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'example')
	@SuppressWarnings('removal')
	static class ExampleController {
		@GetMapping('/')
		String example() {
			return 'Example';
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
abstract class AbstractHealthEndpointAdditionalPathIntegrationTests<T extends AbstractApplicationContextRunner<T, C, A>, C extends ConfigurableApplicationContext, A extends ApplicationContextAssertProvider<C>> {
	private final T runner;
	AbstractHealthEndpointAdditionalPathIntegrationTests(T runner) {
		this.runner = runner;
	}
	@Test
	void groupIsAvailableAtAdditionalPath() {
		this.runner
			.withPropertyValues('management.endpoint.health.group.live.include=diskSpace',
					'management.endpoint.health.group.live.additional-path=server:/healthz',
					'management.endpoint.health.group.live.show-components=always')
			.run(withWebTestClient(this::testResponse, 'local.server.port'));
	}
	@Test
	void multipleGroupsAreAvailableAtAdditionalPaths() {
		this.runner
			.withPropertyValues('management.endpoint.health.group.one.include=diskSpace',
					'management.endpoint.health.group.two.include=diskSpace',
					'management.endpoint.health.group.one.additional-path=server:/alpha',
					'management.endpoint.health.group.two.additional-path=server:/bravo',
					'management.endpoint.health.group.one.show-components=always',
					'management.endpoint.health.group.two.show-components=always')
			.run(withWebTestClient((client) -> testResponses(client, '/alpha', '/bravo'), 'local.server.port'));
	}
	@Test
	void groupIsAvailableAtAdditionalPathWithoutSlash() {
		this.runner
			.withPropertyValues('management.endpoint.health.group.live.include=diskSpace',
					'management.endpoint.health.group.live.additional-path=server:healthz',
					'management.endpoint.health.group.live.show-components=always')
			.run(withWebTestClient(this::testResponse, 'local.server.port'));
	}
	@Test
	void groupIsAvailableAtAdditionalPathOnManagementPort() {
		this.runner
			.withPropertyValues('management.endpoint.health.group.live.include=diskSpace', 'management.server.port=0',
					'management.endpoint.health.group.live.additional-path=management:healthz',
					'management.endpoint.health.group.live.show-components=always')
			.run(withWebTestClient(this::testResponse, 'local.management.port'));
	}
	@Test
	void groupIsAvailableAtAdditionalPathOnServerPortWithDifferentManagementPort() {
		this.runner
			.withPropertyValues('management.endpoint.health.group.live.include=diskSpace', 'management.server.port=0',
					'management.endpoint.health.group.live.additional-path=server:healthz',
					'management.endpoint.health.group.live.show-components=always')
			.run(withWebTestClient(this::testResponse, 'local.server.port'));
	}
	@Test
	void groupsAreNotConfiguredWhenHealthEndpointIsNotExposed() {
		this.runner
			.withPropertyValues('spring.jmx.enabled=true', 'management.endpoints.web.exposure.exclude=health',
					'management.server.port=0', 'management.endpoint.health.group.live.include=diskSpace',
					'management.endpoint.health.group.live.additional-path=server:healthz',
					'management.endpoint.health.group.live.show-components=always')
			.run(withWebTestClient((client) -> client.get()
				.uri('/healthz')
				.accept(MediaType.APPLICATION_JSON)
				.exchange()
				.expectStatus()
				.isNotFound(), 'local.server.port'));
	}
	@Test
	void groupsAreNotConfiguredWhenHealthEndpointIsNotExposedAndCloudFoundryPlatform() {
		this.runner.withPropertyValues('spring.jmx.enabled=true', 'management.endpoints.web.exposure.exclude=health',
				'spring.main.cloud-platform=cloud_foundry', 'management.endpoint.health.group.live.include=diskSpace',
				'management.endpoint.health.group.live.additional-path=server:healthz',
				'management.endpoint.health.group.live.show-components=always')
			.run(withWebTestClient((client) -> client.get()
				.uri('/healthz')
				.accept(MediaType.APPLICATION_JSON)
				.exchange()
				.expectStatus()
				.isNotFound(), 'local.server.port'));
	}
	@Test
	void groupsAreNotConfiguredWhenHealthEndpointIsNotExposedWithDifferentManagementPortAndCloudFoundryPlatform() {
		this.runner
			.withPropertyValues('spring.jmx.enabled=true', 'management.endpoints.web.exposure.exclude=health',
					'spring.main.cloud-platform=cloud_foundry', 'management.server.port=0',
					'management.endpoint.health.group.live.include=diskSpace',
					'management.endpoint.health.group.live.additional-path=server:healthz',
					'management.endpoint.health.group.live.show-components=always')
			.run(withWebTestClient((client) -> client.get()
				.uri('/healthz')
				.accept(MediaType.APPLICATION_JSON)
				.exchange()
				.expectStatus()
				.isNotFound(), 'local.server.port'));
	}
	private void testResponse(WebTestClient client) {
		testResponses(client, '/healthz');
	}
	private void testResponses(WebTestClient client, String... paths) {
		for (String path : paths) {
			assertThatNoException().as(path)
				.isThrownBy(() -> client.get()
					.uri(path)
					.accept(MediaType.APPLICATION_JSON)
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('status')
					.isEqualTo('UP')
					.jsonPath('components.diskSpace')
					.exists());
		}
	}
	private ContextConsumer<A> withWebTestClient(Consumer<WebTestClient> consumer, String property) {
		return (context) -> {
			String port = context.getEnvironment().getProperty(property);
			WebTestClient client = WebTestClient.bindToServer().baseUrl('http://localhost:' + port).build();
			consumer.accept(client);
		};
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebMvcEndpointAccessIntegrationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
			AnnotationConfigServletWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class, JacksonAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class, WebMvcAutoConfiguration.class,
				EndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
				ManagementContextAutoConfiguration.class, ServletManagementContextAutoConfiguration.class,
				HealthContributorAutoConfiguration.class))
		.withConfiguration(AutoConfigurations.of(EndpointAutoConfigurationClasses.ALL))
		.withUserConfiguration(CustomMvcEndpoint.class, CustomServletEndpoint.class)
		.withPropertyValues('server.port:0');
	@Test
	void accessIsUnrestrictedByDefault() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*').run((context) -> {
			WebTestClient client = createClient(context);
			assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
			assertThat(isAccessible(client, HttpMethod.GET, 'custommvc')).isTrue();
			assertThat(isAccessible(client, HttpMethod.POST, 'custommvc')).isTrue();
			assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
			assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isTrue();
		});
	}
	@Test
	void accessCanBeReadOnlyByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=READ_ONLY')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
				assertThat(isAccessible(client, HttpMethod.GET, 'custommvc')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'custommvc')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	@Test
	void accessCanBeNoneByDefault() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=NONE')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'custommvc')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'custommvc')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	@Test
	void accessForOneEndpointCanOverrideTheDefaultAccess() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=READ_ONLY',
					'management.endpoint.customservlet.access=UNRESTRICTED')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
				assertThat(isAccessible(client, HttpMethod.GET, 'custommvc')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'custommvc')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isTrue();
			});
	}
	@Test
	void accessCanBeCappedAtReadOnly() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=*',
					'management.endpoints.access.default=UNRESTRICTED',
					'management.endpoints.access.max-permitted=READ_ONLY')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isTrue();
				assertThat(isAccessible(client, HttpMethod.GET, 'custommvc')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'custommvc')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isTrue();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	@Test
	void accessCanBeCappedAtNone() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*',
				'management.endpoints.access.default=UNRESTRICTED', 'management.endpoints.access.max-permitted=NONE')
			.run((context) -> {
				WebTestClient client = createClient(context);
				assertThat(isAccessible(client, HttpMethod.GET, 'beans')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'custommvc')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'custommvc')).isFalse();
				assertThat(isAccessible(client, HttpMethod.GET, 'customservlet')).isFalse();
				assertThat(isAccessible(client, HttpMethod.POST, 'customservlet')).isFalse();
			});
	}
	private WebTestClient createClient(AssertableWebApplicationContext context) {
		int port = context.getSourceApplicationContext(ServletWebServerApplicationContext.class)
			.getWebServer()
			.getPort();
		ExchangeStrategies exchangeStrategies = ExchangeStrategies.builder()
			.codecs((configurer) -> configurer.defaultCodecs().maxInMemorySize(-1))
			.build();
		return WebTestClient.bindToServer()
			.baseUrl('http://localhost:' + port)
			.exchangeStrategies(exchangeStrategies)
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	private boolean isAccessible(WebTestClient client, HttpMethod method, String path) {
		path = '/actuator/' + path;
		EntityExchangeResult<byte[]> result = client.method(method).uri(path).exchange().expectBody().returnResult();
		if (result.getStatus() == HttpStatus.OK) {
			return true;
		}
		if (result.getStatus() == HttpStatus.NOT_FOUND || result.getStatus() == HttpStatus.METHOD_NOT_ALLOWED) {
			return false;
		}
		throw new IllegalStateException(
				String.format('Unexpected %s HTTP status for endpoint %s', result.getStatus(), path));
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint(id = 'custommvc')
	@SuppressWarnings('removal')
	static class CustomMvcEndpoint {
		@GetMapping('/')
		String get() {
			return 'get';
		}
		@PostMapping('/')
		String post() {
			return 'post';
		}
	}
	@org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpoint(id = 'customservlet')
	@SuppressWarnings({ 'deprecation', 'removal' })
	static class CustomServletEndpoint
			implements Supplier<org.springframework.boot.actuate.endpoint.web.EndpointServlet> {
		@Override
		public org.springframework.boot.actuate.endpoint.web.EndpointServlet get() {
			return new org.springframework.boot.actuate.endpoint.web.EndpointServlet(new HttpServlet() {
				@Override
				protected void doGet(HttpServletRequest req, HttpServletResponse resp)
						throws ServletException, IOException {
				}
				@Override
				protected void doPost(HttpServletRequest req, HttpServletResponse resp)
						throws ServletException, IOException {
				}
			});
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebFluxEndpointCorsIntegrationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, CodecsAutoConfiguration.class,
				WebFluxAutoConfiguration.class, HttpHandlerAutoConfiguration.class, EndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, ManagementContextAutoConfiguration.class,
				ReactiveManagementContextAutoConfiguration.class, BeansEndpointAutoConfiguration.class))
		.withPropertyValues('management.endpoints.web.exposure.include:*');
	@Test
	void corsIsDisabledByDefault() {
		this.contextRunner.run(withWebTestClient((webTestClient) -> webTestClient.options()
			.uri('/actuator/beans')
			.header('Origin', 'spring.example.org')
			.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
			.exchange()
			.expectHeader()
			.doesNotExist(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN)));
	}
	@Test
	void settingAllowedOriginsEnablesCors() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org')
			.run(withWebTestClient((webTestClient) -> {
				webTestClient.options()
					.uri('/actuator/beans')
					.header('Origin', 'test.example.org')
					.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
					.exchange()
					.expectStatus()
					.isForbidden();
				performAcceptedCorsRequest(webTestClient, '/actuator/beans');
			}));
	}
	@Test
	void settingAllowedOriginPatternsEnablesCors() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origin-patterns:*.example.org',
					'management.endpoints.web.cors.allow-credentials:true')
			.run(withWebTestClient((webTestClient) -> {
				webTestClient.options()
					.uri('/actuator/beans')
					.header('Origin', 'spring.example.com')
					.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
					.exchange()
					.expectStatus()
					.isForbidden();
				performAcceptedCorsRequest(webTestClient, '/actuator/beans');
			}));
	}
	@Test
	void maxAgeDefaultsTo30Minutes() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org')
			.run(withWebTestClient(
					(webTestClient) -> performAcceptedCorsRequest(webTestClient, '/actuator/beans').expectHeader()
						.valueEquals(HttpHeaders.ACCESS_CONTROL_MAX_AGE, '1800')));
	}
	@Test
	void maxAgeCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org',
					'management.endpoints.web.cors.max-age: 2400')
			.run(withWebTestClient(
					(webTestClient) -> performAcceptedCorsRequest(webTestClient, '/actuator/beans').expectHeader()
						.valueEquals(HttpHeaders.ACCESS_CONTROL_MAX_AGE, '2400')));
	}
	@Test
	void requestsWithDisallowedHeadersAreRejected() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org')
			.run(withWebTestClient((webTestClient) -> webTestClient.options()
				.uri('/actuator/beans')
				.header('Origin', 'spring.example.org')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS, 'Alpha')
				.exchange()
				.expectStatus()
				.isForbidden()));
	}
	@Test
	void allowedHeadersCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org',
					'management.endpoints.web.cors.allowed-headers:Alpha,Bravo')
			.run(withWebTestClient((webTestClient) -> webTestClient.options()
				.uri('/actuator/beans')
				.header('Origin', 'spring.example.org')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS, 'Alpha')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.valueEquals(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, 'Alpha')));
	}
	@Test
	void requestsWithDisallowedMethodsAreRejected() {
		this.contextRunner.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org')
			.run(withWebTestClient((webTestClient) -> webTestClient.options()
				.uri('/actuator/beans')
				.header('Origin', 'spring.example.org')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'PATCH')
				.exchange()
				.expectStatus()
				.isForbidden()));
	}
	@Test
	void allowedMethodsCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org',
					'management.endpoints.web.cors.allowed-methods:GET,HEAD')
			.run(withWebTestClient((webTestClient) -> webTestClient.options()
				.uri('/actuator/beans')
				.header('Origin', 'spring.example.org')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'HEAD')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.valueEquals(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, 'GET,HEAD')));
	}
	@Test
	void credentialsCanBeAllowed() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org',
					'management.endpoints.web.cors.allow-credentials:true')
			.run(withWebTestClient(
					(webTestClient) -> performAcceptedCorsRequest(webTestClient, '/actuator/beans').expectHeader()
						.valueEquals(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, 'true')));
	}
	@Test
	void credentialsCanBeDisabled() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.cors.allowed-origins:spring.example.org',
					'management.endpoints.web.cors.allow-credentials:false')
			.run(withWebTestClient(
					(webTestClient) -> performAcceptedCorsRequest(webTestClient, '/actuator/beans').expectHeader()
						.doesNotExist(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS)));
	}
	private ContextConsumer<ReactiveWebApplicationContext> withWebTestClient(Consumer<WebTestClient> webTestClient) {
		return (context) -> webTestClient.accept(WebTestClient.bindToApplicationContext(context)
			.configureClient()
			.baseUrl('https://spring.example.org')
			.build());
	}
	private WebTestClient.ResponseSpec performAcceptedCorsRequest(WebTestClient webTestClient, String url) {
		return webTestClient.options()
			.uri(url)
			.header(HttpHeaders.ORIGIN, 'spring.example.org')
			.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'GET')
			.exchange()
			.expectHeader()
			.valueEquals(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, 'spring.example.org')
			.expectStatus()
			.isOk();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integrationtest;
/**
class WebMvcHealthEndpointAdditionalPathIntegrationTests extends
		AbstractHealthEndpointAdditionalPathIntegrationTests<WebApplicationContextRunner, ConfigurableWebApplicationContext, AssertableWebApplicationContext> {
	WebMvcHealthEndpointAdditionalPathIntegrationTests() {
		super(new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class,
					HttpMessageConvertersAutoConfiguration.class, ManagementContextAutoConfiguration.class,
					ServletWebServerFactoryAutoConfiguration.class, WebMvcAutoConfiguration.class,
					ServletManagementContextAutoConfiguration.class, WebEndpointAutoConfiguration.class,
					EndpointAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
					HealthEndpointAutoConfiguration.class, DiskSpaceHealthContributorAutoConfiguration.class))
			.withInitializer(new ServerPortInfoApplicationContextInitializer())
			.withPropertyValues('server.port=0'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.elasticsearch;
/**
class ElasticsearchRestHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticsearchRestClientAutoConfiguration.class,
				ElasticsearchRestHealthContributorAutoConfiguration.class, HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(ElasticsearchRestClientHealthIndicator.class)
				.hasBean('elasticsearchHealthContributor'));
	}
	@Test
	void runWithoutRestClientShouldNotCreateIndicator() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(RestClient.class))
			.run((context) -> assertThat(context).doesNotHaveBean(ElasticsearchRestClientHealthIndicator.class)
				.doesNotHaveBean('elasticsearchHealthContributor'));
	}
	@Test
	void runWithRestClientShouldCreateIndicator() {
		this.contextRunner.withUserConfiguration(CustomRestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ElasticsearchRestClientHealthIndicator.class)
				.hasBean('elasticsearchHealthContributor'));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.elasticsearch.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ElasticsearchRestClientHealthIndicator.class)
				.doesNotHaveBean('elasticsearchHealthContributor'));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRestClientConfiguration {
		@Bean
		RestClient customRestClient(RestClientBuilder builder) {
			return builder.build();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.condition;
/**
class ConditionsReportEndpointTests {
	@Test
	void invoke() {
		new ApplicationContextRunner().withUserConfiguration(Config.class).run((context) -> {
			ContextConditionsDescriptor report = context.getBean(ConditionsReportEndpoint.class)
				.conditions()
				.getContexts()
				.get(context.getId());
			assertThat(report.getPositiveMatches()).isEmpty();
			assertThat(report.getNegativeMatches()).containsKey('a');
			assertThat(report.getUnconditionalClasses()).contains('b');
			assertThat(report.getExclusions()).contains('com.foo.Bar');
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class Config {
		private final ConfigurableApplicationContext context;
		Config(ConfigurableApplicationContext context) {
			this.context = context;
		}
		@PostConstruct
		void setupAutoConfigurationReport() {
			ConditionEvaluationReport report = ConditionEvaluationReport.get(this.context.getBeanFactory());
			report.recordEvaluationCandidates(Arrays.asList('a', 'b'));
			report.recordConditionEvaluation('a', mock(Condition.class), mock(ConditionOutcome.class));
			report.recordExclusions(Collections.singletonList('com.foo.Bar'));
		}
		@Bean
		ConditionsReportEndpoint endpoint() {
			return new ConditionsReportEndpoint(this.context);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.condition;
/**
class ConditionsReportEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ConditionsReportEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=conditions')
			.run((context) -> assertThat(context).hasSingleBean(ConditionsReportEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ConditionsReportEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.conditions.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ConditionsReportEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.startup;
/**
class StartupEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(StartupEndpointAutoConfiguration.class));
	@Test
	void runShouldNotHaveStartupEndpoint() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(StartupEndpoint.class));
	}
	@Test
	void runWhenMissingAppStartupShouldNotHaveStartupEndpoint() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=startup')
			.run((context) -> assertThat(context).doesNotHaveBean(StartupEndpoint.class));
	}
	@Test
	void runShouldHaveStartupEndpoint() {
		new ApplicationContextRunner(() -> {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			context.setApplicationStartup(new BufferingApplicationStartup(1));
			return context;
		}).withConfiguration(AutoConfigurations.of(StartupEndpointAutoConfiguration.class))
			.withPropertyValues('management.endpoints.web.exposure.include=startup')
			.run((context) -> assertThat(context).hasSingleBean(StartupEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.wavefront;
/**
class WavefrontAutoConfigurationTests {
	ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(WavefrontAutoConfiguration.class));
	@Test
	void wavefrontApplicationTagsWhenHasUserBeanBacksOff() {
		this.contextRunner.withUserConfiguration(TestApplicationTagsConfiguration.class).run((context) -> {
			ApplicationTags tags = context.getBean(ApplicationTags.class);
			assertThat(tags.getApplication()).isEqualTo('test-application');
			assertThat(tags.getService()).isEqualTo('test-service');
		});
	}
	@Test
	void wavefrontApplicationTagsMapsProperties() {
		List<String> properties = new ArrayList<>();
		properties.add('management.wavefront.application.name=test-application');
		properties.add('management.wavefront.application.service-name=test-service');
		properties.add('management.wavefront.application.cluster-name=test-cluster');
		properties.add('management.wavefront.application.shard-name=test-shard');
		properties.add('management.wavefront.application.custom-tags.foo=FOO');
		properties.add('management.wavefront.application.custom-tags.bar=BAR');
		this.contextRunner.withPropertyValues(properties.toArray(String[]::new)).run((context) -> {
			ApplicationTags tags = context.getBean(ApplicationTags.class);
			assertThat(tags.getApplication()).isEqualTo('test-application');
			assertThat(tags.getService()).isEqualTo('test-service');
			assertThat(tags.getCluster()).isEqualTo('test-cluster');
			assertThat(tags.getShard()).isEqualTo('test-shard');
			assertThat(tags.getCustomTags()).hasSize(2).containsEntry('foo', 'FOO').containsEntry('bar', 'BAR');
		});
	}
	@Test
	void wavefrontApplicationTagsWhenNoPropertiesUsesDefaults() {
		this.contextRunner.withPropertyValues('spring.application.name=spring-app').run((context) -> {
			ApplicationTags tags = context.getBean(ApplicationTags.class);
			assertThat(tags.getApplication()).isEqualTo('unnamed_application');
			assertThat(tags.getService()).isEqualTo('spring-app');
			assertThat(tags.getCluster()).isNull();
			assertThat(tags.getShard()).isNull();
			assertThat(tags.getCustomTags()).isEmpty();
		});
	}
	@Test
	void wavefrontApplicationTagsWhenHasNoServiceNamePropertyAndNoSpringApplicationNameUsesDefault() {
		this.contextRunner.run((context) -> {
			ApplicationTags tags = context.getBean(ApplicationTags.class);
			assertThat(tags.getService()).isEqualTo('unnamed_service');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class TestApplicationTagsConfiguration {
		@Bean
		ApplicationTags applicationTags() {
			return new ApplicationTags.Builder('test-application', 'test-service').build();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.wavefront;
/**
class WavefrontPropertiesTests {
	@Test
	void apiTokenIsOptionalWhenUsingProxy() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setUri(URI.create('proxy://localhost:2878'));
		properties.setApiToken(null);
		assertThat(properties.getApiTokenOrThrow()).isNull();
		assertThat(properties.getEffectiveUri()).isEqualTo(URI.create('http://localhost:2878'));
	}
	@Test
	void apiTokenIsMandatoryWhenNotUsingProxy() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setUri(URI.create('http://localhost:2878'));
		properties.setApiToken(null);
		assertThat(properties.getEffectiveUri()).isEqualTo(URI.create('http://localhost:2878'));
		assertThatExceptionOfType(InvalidConfigurationPropertyValueException.class)
			.isThrownBy(properties::getApiTokenOrThrow)
			.withMessageContaining('management.wavefront.api-token');
	}
	@Test
	void shouldNotFailIfTokenTypeIsSetToNoToken() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setUri(URI.create('http://localhost:2878'));
		properties.setApiTokenType(TokenType.NO_TOKEN);
		properties.setApiToken(null);
		assertThat(properties.getApiTokenOrThrow()).isNull();
	}
	@Test
	void wavefrontApiTokenTypeWhenUsingProxy() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setUri(URI.create('proxy://localhost:2878'));
		assertThat(properties.getWavefrontApiTokenType()).isEqualTo(Type.NO_TOKEN);
	}
	@Test
	void wavefrontApiTokenTypeWhenNotUsingProxy() {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setUri(URI.create('http://localhost:2878'));
		assertThat(properties.getWavefrontApiTokenType()).isEqualTo(Type.WAVEFRONT_API_TOKEN);
	}
	@ParameterizedTest
	@EnumSource(TokenType.class)
	void wavefrontApiTokenMapping(TokenType from) {
		WavefrontProperties properties = new WavefrontProperties();
		properties.setApiTokenType(from);
		Type expected = Type.valueOf(from.name());
		assertThat(properties.getWavefrontApiTokenType()).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.wavefront;
/**
class WavefrontPropertiesMetricsExportTests {
	@Test
	@SuppressWarnings('deprecation')
	void defaultValuesAreConsistent() {
		WavefrontProperties.Metrics.Export properties = new WavefrontProperties.Metrics.Export();
		WavefrontConfig config = WavefrontConfig.DEFAULT_DIRECT;
		assertThat(properties.getConnectTimeout()).isEqualTo(config.connectTimeout());
		assertThat(properties.getGlobalPrefix()).isEqualTo(config.globalPrefix());
		assertThat(properties.getReadTimeout()).isEqualTo(config.readTimeout());
		assertThat(properties.getStep()).isEqualTo(config.step());
		assertThat(properties.isEnabled()).isEqualTo(config.enabled());
		assertThat(properties.isReportMinuteDistribution()).isEqualTo(config.reportMinuteDistribution());
		assertThat(properties.isReportHourDistribution()).isEqualTo(config.reportHourDistribution());
		assertThat(properties.isReportDayDistribution()).isEqualTo(config.reportDayDistribution());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.wavefront;
/**
class WavefrontSenderConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(WavefrontSenderConfiguration.class));
	private final ApplicationContextRunner metricsDisabledContextRunner = this.contextRunner.withPropertyValues(
			'management.defaults.metrics.export.enabled=false', 'management.simple.metrics.export.enabled=true');
	@Test
	void shouldNotFailIfWavefrontIsMissing() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('com.wavefront'))
			.run(((context) -> assertThat(context).doesNotHaveBean(WavefrontSender.class)));
	}
	@Test
	void failsWithoutAnApiTokenWhenPublishingDirectly() {
		this.contextRunner.run((context) -> assertThat(context).hasFailed());
	}
	@Test
	void defaultWavefrontSenderSettingsAreConsistent() {
		this.contextRunner.withPropertyValues('management.wavefront.api-token=abcde').run((context) -> {
			WavefrontProperties properties = new WavefrontProperties();
			WavefrontSender sender = context.getBean(WavefrontSender.class);
			assertThat(sender)
				.extracting('metricsBuffer', as(InstanceOfAssertFactories.type(LinkedBlockingQueue.class)))
				.satisfies((queue) -> assertThat(queue.remainingCapacity() + queue.size())
					.isEqualTo(properties.getSender().getMaxQueueSize()));
			assertThat(sender).hasFieldOrPropertyWithValue('batchSize', properties.getSender().getBatchSize());
			assertThat(sender).hasFieldOrPropertyWithValue('messageSizeBytes',
					(int) properties.getSender().getMessageSize().toBytes());
		});
	}
	@Test
	void configureWavefrontSender() {
		this.contextRunner
			.withPropertyValues('management.wavefront.api-token=abcde', 'management.wavefront.sender.batch-size=50',
					'management.wavefront.sender.max-queue-size=100', 'management.wavefront.sender.message-size=1KB')
			.run((context) -> {
				WavefrontSender sender = context.getBean(WavefrontSender.class);
				assertThat(sender).hasFieldOrPropertyWithValue('batchSize', 50);
				assertThat(sender)
					.extracting('metricsBuffer', as(InstanceOfAssertFactories.type(LinkedBlockingQueue.class)))
					.satisfies((queue) -> assertThat(queue.remainingCapacity() + queue.size()).isEqualTo(100));
				assertThat(sender).hasFieldOrPropertyWithValue('messageSizeBytes', 1024);
			});
	}
	@Test
	void shouldNotSupplyWavefrontSenderIfMetricsAndGlobalTracingIsDisabled() {
		this.metricsDisabledContextRunner
			.withPropertyValues('management.tracing.enabled=false', 'management.wavefront.api-token=abcde')
			.run((context) -> assertThat(context).doesNotHaveBean(WavefrontSender.class));
	}
	@Test
	void shouldNotSupplyWavefrontSenderIfMetricsAndWavefrontTracingIsDisabled() {
		this.metricsDisabledContextRunner
			.withPropertyValues('management.wavefront.tracing.export.enabled=false',
					'management.wavefront.api-token=abcde')
			.run((context) -> assertThat(context).doesNotHaveBean(WavefrontSender.class));
	}
	@Test
	void shouldSupplyWavefrontSenderIfOnlyGlobalTracingIsDisabled() {
		this.contextRunner
			.withPropertyValues('management.tracing.enabled=false', 'management.wavefront.api-token=abcde')
			.run((context) -> assertThat(context).hasSingleBean(WavefrontSender.class));
	}
	@Test
	void shouldSupplyWavefrontSenderIfOnlyWavefrontTracingIsDisabled() {
		this.contextRunner
			.withPropertyValues('management.wavefront.tracing.export.enabled=false',
					'management.wavefront.api-token=abcde')
			.run((context) -> assertThat(context).hasSingleBean(WavefrontSender.class));
	}
	@Test
	void shouldSupplyWavefrontSenderIfOnlyMetricsAreDisabled() {
		this.metricsDisabledContextRunner.withPropertyValues('management.wavefront.api-token=abcde')
			.run((context) -> assertThat(context).hasSingleBean(WavefrontSender.class));
	}
	@Test
	void allowsWavefrontSenderToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomSenderConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(WavefrontSender.class).hasBean('customSender'));
	}
	@Test
	void shouldApplyTokenTypeWavefrontApiToken() {
		this.contextRunner
			.withPropertyValues('management.wavefront.api-token-type=WAVEFRONT_API_TOKEN',
					'management.wavefront.api-token=abcde')
			.run((context) -> {
				WavefrontSender sender = context.getBean(WavefrontSender.class);
				assertThat(sender).extracting('tokenService').isInstanceOf(WavefrontTokenService.class);
			});
	}
	@Test
	void shouldApplyTokenTypeCspApiToken() {
		this.contextRunner
			.withPropertyValues('management.wavefront.api-token-type=CSP_API_TOKEN',
					'management.wavefront.api-token=abcde')
			.run((context) -> {
				WavefrontSender sender = context.getBean(WavefrontSender.class);
				assertThat(sender).extracting('tokenService').isInstanceOf(CSPTokenService.class);
			});
	}
	@Test
	void shouldApplyTokenTypeCspClientCredentials() {
		this.contextRunner
			.withPropertyValues('management.wavefront.api-token-type=CSP_CLIENT_CREDENTIALS',
					'management.wavefront.api-token=clientid=cid,clientsecret=csec')
			.run((context) -> {
				WavefrontSender sender = context.getBean(WavefrontSender.class);
				assertThat(sender).extracting('tokenService').isInstanceOf(CSPTokenService.class);
			});
	}
	@Test
	void shouldApplyTokenTypeNoToken() {
		this.contextRunner.withPropertyValues('management.wavefront.api-token-type=NO_TOKEN').run((context) -> {
			WavefrontSender sender = context.getBean(WavefrontSender.class);
			assertThat(sender).extracting('tokenService').isInstanceOf(NoopProxyTokenService.class);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSenderConfiguration {
		@Bean
		WavefrontSender customSender() {
			return mock(WavefrontSender.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@ExtendWith(OutputCaptureExtension.class)
class WebClientObservationConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withBean(ObservationRegistry.class, TestObservationRegistry::create)
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class, WebClientAutoConfiguration.class,
				HttpClientObservationsAutoConfiguration.class));
	@Test
	void contributesCustomizerBean() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ObservationWebClientCustomizer.class));
	}
	@Test
	void webClientCreatedWithBuilderIsInstrumented() {
		this.contextRunner.run((context) -> {
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			WebClient.Builder builder = context.getBean(WebClient.Builder.class);
			validateWebClient(builder, registry);
		});
	}
	@Test
	void shouldUseCustomConventionIfAvailable() {
		this.contextRunner.withUserConfiguration(CustomConvention.class).run((context) -> {
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			WebClient.Builder builder = context.getBean(WebClient.Builder.class);
			WebClient webClient = mockWebClient(builder);
			TestObservationRegistryAssert.assertThat(registry).doesNotHaveAnyObservation();
			webClient.get()
				.uri('https://example.org/projects/{project}', 'spring-boot')
				.retrieve()
				.toBodilessEntity()
				.block(Duration.ofSeconds(30));
			TestObservationRegistryAssert.assertThat(registry)
				.hasObservationWithNameEqualTo('http.client.requests')
				.that()
				.hasLowCardinalityKeyValue('project', 'spring-boot');
		});
	}
	@Test
	void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput output) {
		this.contextRunner.withPropertyValues('management.metrics.web.client.max-uri-tags=2').run((context) -> {
			TestObservationRegistry registry = getInitializedRegistry(context);
			TestObservationRegistryAssert.assertThat(registry)
				.hasNumberOfObservationsWithNameEqualTo('http.client.requests', 3);
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.find('http.client.requests').timers()).hasSize(1);
			// MeterFilter.maximumAllowableTags() works with prefix matching.
			assertThat(meterRegistry.find('http.client.requests.active').longTaskTimers()).hasSize(1);
			assertThat(output).contains('Reached the maximum number of URI tags for "http.client.requests".')
				.contains('Are you using "uriVariables"?');
		});
	}
	@Test
	void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput output) {
		this.contextRunner.withPropertyValues('management.metrics.web.client.max-uri-tags=5').run((context) -> {
			TestObservationRegistry registry = getInitializedRegistry(context);
			TestObservationRegistryAssert.assertThat(registry)
				.hasNumberOfObservationsWithNameEqualTo('http.client.requests', 3);
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.find('http.client.requests').timers()).hasSize(3);
			assertThat(output).doesNotContain('Reached the maximum number of URI tags for "http.client.requests".')
				.doesNotContain('Are you using "uriVariables"?');
		});
	}
	private TestObservationRegistry getInitializedRegistry(AssertableApplicationContext context) {
		WebClient webClient = mockWebClient(context.getBean(WebClient.Builder.class));
		TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
		for (int i = 0; i < 3; i++) {
			webClient.get()
				.uri('https://example.org/projects/' + i)
				.retrieve()
				.toBodilessEntity()
				.block(Duration.ofSeconds(30));
		}
		return registry;
	}
	private void validateWebClient(WebClient.Builder builder, TestObservationRegistry registry) {
		WebClient webClient = mockWebClient(builder);
		TestObservationRegistryAssert.assertThat(registry).doesNotHaveAnyObservation();
		webClient.get()
			.uri('https://example.org/projects/{project}', 'spring-boot')
			.retrieve()
			.toBodilessEntity()
			.block(Duration.ofSeconds(30));
		TestObservationRegistryAssert.assertThat(registry)
			.hasObservationWithNameEqualTo('http.client.requests')
			.that()
			.hasLowCardinalityKeyValue('uri', '/projects/{project}');
	}
	private WebClient mockWebClient(WebClient.Builder builder) {
		ClientHttpConnector connector = mock(ClientHttpConnector.class);
		given(connector.connect(any(), any(), any())).willReturn(Mono.just(new MockClientHttpResponse(HttpStatus.OK)));
		return builder.clientConnector(connector).build();
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConventionConfig {
		@Bean
		CustomConvention customConvention() {
			return new CustomConvention();
		}
	}
	static class CustomConvention extends DefaultClientRequestObservationConvention {
		@Override
		public KeyValues getLowCardinalityKeyValues(ClientRequestObservationContext context) {
			return super.getLowCardinalityKeyValues(context).and('project', 'spring-boot');
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@ExtendWith(OutputCaptureExtension.class)
class RestTemplateObservationConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(ObservationRegistry.class, TestObservationRegistry::create)
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class,
				RestTemplateAutoConfiguration.class, HttpClientObservationsAutoConfiguration.class));
	@Test
	void contributesCustomizerBean() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ObservationRestTemplateCustomizer.class));
	}
	@Test
	void restTemplateCreatedWithBuilderIsInstrumented() {
		this.contextRunner.run((context) -> {
			RestTemplate restTemplate = buildRestTemplate(context);
			restTemplate.getForEntity('/projects/{project}', Void.class, 'spring-boot');
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			TestObservationRegistryAssert.assertThat(registry)
				.hasObservationWithNameEqualToIgnoringCase('http.client.requests');
		});
	}
	@Test
	void restTemplateCreatedWithBuilderUsesCustomConventionName() {
		final String observationName = 'test.metric.name';
		this.contextRunner.withPropertyValues('management.observations.http.client.requests.name=' + observationName)
			.run((context) -> {
				RestTemplate restTemplate = buildRestTemplate(context);
				restTemplate.getForEntity('/projects/{project}', Void.class, 'spring-boot');
				TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
				TestObservationRegistryAssert.assertThat(registry)
					.hasObservationWithNameEqualToIgnoringCase(observationName);
			});
	}
	@Test
	void restTemplateCreatedWithBuilderUsesCustomConvention() {
		this.contextRunner.withUserConfiguration(CustomConvention.class).run((context) -> {
			RestTemplate restTemplate = buildRestTemplate(context);
			restTemplate.getForEntity('/projects/{project}', Void.class, 'spring-boot');
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			TestObservationRegistryAssert.assertThat(registry)
				.hasObservationWithNameEqualTo('http.client.requests')
				.that()
				.hasLowCardinalityKeyValue('project', 'spring-boot');
		});
	}
	@Test
	void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput output) {
		this.contextRunner.with(MetricsRun.simple())
			.withPropertyValues('management.metrics.web.client.max-uri-tags=2')
			.run((context) -> {
				RestTemplate restTemplate = context.getBean(RestTemplateBuilder.class).build();
				MockRestServiceServer server = MockRestServiceServer.createServer(restTemplate);
				for (int i = 0; i < 3; i++) {
					server.expect(requestTo('/test/' + i)).andRespond(withStatus(HttpStatus.OK));
				}
				for (int i = 0; i < 3; i++) {
					restTemplate.getForObject('/test/' + i, String.class);
				}
				TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
				TestObservationRegistryAssert.assertThat(registry)
					.hasNumberOfObservationsWithNameEqualTo('http.client.requests', 3);
				MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
				assertThat(meterRegistry.find('http.client.requests').timers()).hasSize(2);
				assertThat(output).contains('Reached the maximum number of URI tags for "http.client.requests".')
					.contains('Are you using "uriVariables"?');
			});
	}
	@Test
	void backsOffWhenRestTemplateBuilderIsMissing() {
		new ApplicationContextRunner().with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class,
					HttpClientObservationsAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(ObservationRestTemplateCustomizer.class));
	}
	private RestTemplate buildRestTemplate(AssertableApplicationContext context) {
		RestTemplate restTemplate = context.getBean(RestTemplateBuilder.class).build();
		MockRestServiceServer server = MockRestServiceServer.createServer(restTemplate);
		server.expect(requestTo('/projects/spring-boot')).andRespond(withStatus(HttpStatus.OK));
		return restTemplate;
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConventionConfiguration {
		@Bean
		CustomConvention customConvention() {
			return new CustomConvention();
		}
	}
	static class CustomConvention extends DefaultClientRequestObservationConvention {
		@Override
		public KeyValues getLowCardinalityKeyValues(ClientRequestObservationContext context) {
			return super.getLowCardinalityKeyValues(context).and('project', 'spring-boot');
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@ExtendWith(OutputCaptureExtension.class)
@ClassPathExclusions('micrometer-core-*.jar')
class RestTemplateObservationConfigurationWithoutMetricsTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(ObservationRegistry.class, TestObservationRegistry::create)
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class,
				RestTemplateAutoConfiguration.class, HttpClientObservationsAutoConfiguration.class));
	@Test
	void restTemplateCreatedWithBuilderIsInstrumented() {
		this.contextRunner.run((context) -> {
			RestTemplate restTemplate = buildRestTemplate(context);
			restTemplate.getForEntity('/projects/{project}', Void.class, 'spring-boot');
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			TestObservationRegistryAssert.assertThat(registry)
				.hasObservationWithNameEqualToIgnoringCase('http.client.requests');
		});
	}
	private RestTemplate buildRestTemplate(AssertableApplicationContext context) {
		RestTemplate restTemplate = context.getBean(RestTemplateBuilder.class).build();
		MockRestServiceServer server = MockRestServiceServer.createServer(restTemplate);
		server.expect(requestTo('/projects/spring-boot')).andRespond(withStatus(HttpStatus.OK));
		return restTemplate;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@ExtendWith(OutputCaptureExtension.class)
@ClassPathExclusions('micrometer-core-*.jar')
class RestClientObservationConfigurationWithoutMetricsTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(ObservationRegistry.class, TestObservationRegistry::create)
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class, RestClientAutoConfiguration.class,
				HttpClientObservationsAutoConfiguration.class));
	@Test
	void restClientCreatedWithBuilderIsInstrumented() {
		this.contextRunner.run((context) -> {
			RestClient restClient = buildRestClient(context);
			restClient.get().uri('/projects/{project}', 'spring-boot').retrieve().toBodilessEntity();
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			TestObservationRegistryAssert.assertThat(registry)
				.hasObservationWithNameEqualToIgnoringCase('http.client.requests');
		});
	}
	private RestClient buildRestClient(AssertableApplicationContext context) {
		Builder builder = context.getBean(Builder.class);
		MockServerRestClientCustomizer customizer = new MockServerRestClientCustomizer();
		customizer.customize(builder);
		customizer.getServer().expect(requestTo('/projects/spring-boot')).andRespond(withStatus(HttpStatus.OK));
		return builder.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@ExtendWith(OutputCaptureExtension.class)
class RestClientObservationConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(ObservationRegistry.class, TestObservationRegistry::create)
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class, RestClientAutoConfiguration.class,
				HttpClientObservationsAutoConfiguration.class));
	@Test
	void contributesCustomizerBean() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ObservationRestClientCustomizer.class));
	}
	@Test
	void restClientCreatedWithBuilderIsInstrumented() {
		this.contextRunner.run((context) -> {
			RestClient restClient = buildRestClient(context);
			restClient.get().uri('/projects/{project}', 'spring-boot').retrieve().toBodilessEntity();
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			TestObservationRegistryAssert.assertThat(registry)
				.hasObservationWithNameEqualToIgnoringCase('http.client.requests');
		});
	}
	@Test
	void restClientCreatedWithBuilderUsesCustomConventionName() {
		final String observationName = 'test.metric.name';
		this.contextRunner.withPropertyValues('management.observations.http.client.requests.name=' + observationName)
			.run((context) -> {
				RestClient restClient = buildRestClient(context);
				restClient.get().uri('/projects/{project}', 'spring-boot').retrieve().toBodilessEntity();
				TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
				TestObservationRegistryAssert.assertThat(registry)
					.hasObservationWithNameEqualToIgnoringCase(observationName);
			});
	}
	@Test
	void restClientCreatedWithBuilderUsesCustomConvention() {
		this.contextRunner.withUserConfiguration(CustomConvention.class).run((context) -> {
			RestClient restClient = buildRestClient(context);
			restClient.get().uri('/projects/{project}', 'spring-boot').retrieve().toBodilessEntity();
			TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
			TestObservationRegistryAssert.assertThat(registry)
				.hasObservationWithNameEqualTo('http.client.requests')
				.that()
				.hasLowCardinalityKeyValue('project', 'spring-boot');
		});
	}
	@Test
	void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput output) {
		this.contextRunner.with(MetricsRun.simple())
			.withPropertyValues('management.metrics.web.client.max-uri-tags=2')
			.run((context) -> {
				RestClientWithMockServer restClientWithMockServer = buildRestClientAndMockServer(context);
				MockRestServiceServer server = restClientWithMockServer.mockServer();
				RestClient restClient = restClientWithMockServer.restClient();
				for (int i = 0; i < 3; i++) {
					server.expect(requestTo('/test/' + i)).andRespond(withStatus(HttpStatus.OK));
				}
				for (int i = 0; i < 3; i++) {
					restClient.get().uri('/test/' + i, String.class).retrieve().toBodilessEntity();
				}
				TestObservationRegistry registry = context.getBean(TestObservationRegistry.class);
				TestObservationRegistryAssert.assertThat(registry)
					.hasNumberOfObservationsWithNameEqualTo('http.client.requests', 3);
				MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
				assertThat(meterRegistry.find('http.client.requests').timers()).hasSize(2);
				assertThat(output).contains('Reached the maximum number of URI tags for "http.client.requests".')
					.contains('Are you using "uriVariables"?');
			});
	}
	@Test
	void backsOffWhenRestClientBuilderIsMissing() {
		new ApplicationContextRunner().with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class,
					HttpClientObservationsAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(ObservationRestClientCustomizer.class));
	}
	private RestClient buildRestClient(AssertableApplicationContext context) {
		RestClientWithMockServer restClientWithMockServer = buildRestClientAndMockServer(context);
		restClientWithMockServer.mockServer()
			.expect(requestTo('/projects/spring-boot'))
			.andRespond(withStatus(HttpStatus.OK));
		return restClientWithMockServer.restClient();
	}
	private RestClientWithMockServer buildRestClientAndMockServer(AssertableApplicationContext context) {
		Builder builder = context.getBean(Builder.class);
		MockServerRestClientCustomizer customizer = new MockServerRestClientCustomizer();
		customizer.customize(builder);
		return new RestClientWithMockServer(builder.build(), customizer.getServer());
	}
	private record RestClientWithMockServer(RestClient restClient, MockRestServiceServer mockServer) {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConventionConfiguration {
		@Bean
		CustomConvention customConvention() {
			return new CustomConvention();
		}
	}
	static class CustomConvention extends DefaultClientRequestObservationConvention {
		@Override
		public KeyValues getLowCardinalityKeyValues(ClientRequestObservationContext context) {
			return super.getLowCardinalityKeyValues(context).and('project', 'spring-boot');
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.servlet;
/**
@ExtendWith(OutputCaptureExtension.class)
class WebMvcObservationAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.with(MetricsRun.simple())
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class))
		.withConfiguration(AutoConfigurations.of(WebMvcObservationAutoConfiguration.class));
	@Test
	void backsOffWhenMeterRegistryIsMissing() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(WebMvcObservationAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(FilterRegistrationBean.class));
	}
	@Test
	void definesFilterWhenRegistryIsPresent() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(FilterRegistrationBean.class);
			assertThat(context.getBean(FilterRegistrationBean.class).getFilter())
				.isInstanceOf(ServerHttpObservationFilter.class);
		});
	}
	@Test
	void customConventionWhenPresent() {
		this.contextRunner.withUserConfiguration(CustomConventionConfiguration.class)
			.run((context) -> assertThat(context.getBean(FilterRegistrationBean.class).getFilter())
				.extracting('observationConvention')
				.isInstanceOf(CustomConvention.class));
	}
	@Test
	void filterRegistrationHasExpectedDispatcherTypesAndOrder() {
		this.contextRunner.run((context) -> {
			FilterRegistrationBean<?> registration = context.getBean(FilterRegistrationBean.class);
			assertThat(registration).hasFieldOrPropertyWithValue('dispatcherTypes',
					EnumSet.of(DispatcherType.REQUEST, DispatcherType.ASYNC));
			assertThat(registration.getOrder()).isEqualTo(Ordered.HIGHEST_PRECEDENCE + 1);
		});
	}
	@Test
	void filterRegistrationBacksOffWithAnotherServerHttpObservationFilterRegistration() {
		this.contextRunner.withUserConfiguration(TestServerHttpObservationFilterRegistrationConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(FilterRegistrationBean.class);
				assertThat(context.getBean(FilterRegistrationBean.class))
					.isSameAs(context.getBean('testServerHttpObservationFilter'));
			});
	}
	@Test
	void filterRegistrationBacksOffWithAnotherServerHttpObservationFilter() {
		this.contextRunner.withUserConfiguration(TestServerHttpObservationFilterConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(FilterRegistrationBean.class)
				.hasSingleBean(ServerHttpObservationFilter.class));
	}
	@Test
	void filterRegistrationDoesNotBackOffWithOtherFilterRegistration() {
		this.contextRunner.withUserConfiguration(TestFilterRegistrationConfiguration.class)
			.run((context) -> assertThat(context).hasBean('testFilter').hasBean('webMvcObservationFilter'));
	}
	@Test
	void filterRegistrationDoesNotBackOffWithOtherFilter() {
		this.contextRunner.withUserConfiguration(TestFilterConfiguration.class)
			.run((context) -> assertThat(context).hasBean('testFilter').hasBean('webMvcObservationFilter'));
	}
	@Test
	void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestController.class)
			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class, ObservationAutoConfiguration.class,
					WebMvcAutoConfiguration.class))
			.withPropertyValues('management.metrics.web.server.max-uri-tags=2')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context);
				assertThat(registry.get('http.server.requests').meters()).hasSizeLessThanOrEqualTo(2);
				assertThat(output).contains('Reached the maximum number of URI tags for "http.server.requests"');
			});
	}
	@Test
	void afterMaxUrisReachedFurtherUrisAreDeniedWhenUsingCustomObservationName(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestController.class)
			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class, ObservationAutoConfiguration.class,
					WebMvcAutoConfiguration.class))
			.withPropertyValues('management.metrics.web.server.max-uri-tags=2',
					'management.observations.http.server.requests.name=my.http.server.requests')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context);
				assertThat(registry.get('my.http.server.requests').meters()).hasSizeLessThanOrEqualTo(2);
				assertThat(output).contains('Reached the maximum number of URI tags for "my.http.server.requests"');
			});
	}
	@Test
	void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestController.class)
			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class, ObservationAutoConfiguration.class,
					WebMvcAutoConfiguration.class))
			.withPropertyValues('management.metrics.web.server.max-uri-tags=5')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context);
				assertThat(registry.get('http.server.requests').meters()).hasSize(3);
				assertThat(output).doesNotContain('Reached the maximum number of URI tags for "http.server.requests"');
			});
	}
	private MeterRegistry getInitializedMeterRegistry(AssertableWebApplicationContext context) {
		return getInitializedMeterRegistry(context, '/test0', '/test1', '/test2');
	}
	private MeterRegistry getInitializedMeterRegistry(AssertableWebApplicationContext context, String... urls) {
		assertThat(context).hasSingleBean(FilterRegistrationBean.class);
		Filter filter = context.getBean(FilterRegistrationBean.class).getFilter();
		assertThat(filter).isInstanceOf(ServerHttpObservationFilter.class);
		MockMvcTester mvc = MockMvcTester.from(context, (builder) -> builder.addFilters(filter).build());
		for (String url : urls) {
			assertThat(mvc.get().uri(url)).hasStatusOk();
		}
		return context.getBean(MeterRegistry.class);
	}
	@Configuration(proxyBeanMethods = false)
	static class TestServerHttpObservationFilterRegistrationConfiguration {
		@Bean
		@SuppressWarnings('unchecked')
		FilterRegistrationBean<ServerHttpObservationFilter> testServerHttpObservationFilter() {
			return mock(FilterRegistrationBean.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestServerHttpObservationFilterConfiguration {
		@Bean
		ServerHttpObservationFilter testServerHttpObservationFilter() {
			return new ServerHttpObservationFilter(TestObservationRegistry.create());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestFilterRegistrationConfiguration {
		@Bean
		@SuppressWarnings('unchecked')
		FilterRegistrationBean<Filter> testFilter() {
			return mock(FilterRegistrationBean.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestFilterConfiguration {
		@Bean
		Filter testFilter() {
			return mock(Filter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConventionConfiguration {
		@Bean
		CustomConvention customConvention() {
			return new CustomConvention();
		}
	}
	static class CustomConvention extends DefaultServerRequestObservationConvention {
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.reactive;
/**
@ExtendWith(OutputCaptureExtension.class)
class WebFluxObservationAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.with(MetricsRun.simple())
		.withConfiguration(
				AutoConfigurations.of(ObservationAutoConfiguration.class, WebFluxObservationAutoConfiguration.class));
	@Test
	void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestController.class)
			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class, ObservationAutoConfiguration.class,
					WebFluxAutoConfiguration.class))
			.withPropertyValues('management.metrics.web.server.max-uri-tags=2')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context);
				assertThat(registry.get('http.server.requests').meters()).hasSizeLessThanOrEqualTo(2);
				assertThat(output).contains('Reached the maximum number of URI tags for "http.server.requests"');
			});
	}
	@Test
	void afterMaxUrisReachedFurtherUrisAreDeniedWhenUsingCustomObservationName(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestController.class)
			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class, ObservationAutoConfiguration.class,
					WebFluxAutoConfiguration.class))
			.withPropertyValues('management.metrics.web.server.max-uri-tags=2',
					'management.observations.http.server.requests.name=my.http.server.requests')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context, 'my.http.server.requests');
				assertThat(registry.get('my.http.server.requests').meters()).hasSizeLessThanOrEqualTo(2);
				assertThat(output).contains('Reached the maximum number of URI tags for "my.http.server.requests"');
			});
	}
	@Test
	void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestController.class)
			.withConfiguration(AutoConfigurations.of(MetricsAutoConfiguration.class, ObservationAutoConfiguration.class,
					WebFluxAutoConfiguration.class))
			.withPropertyValues('management.metrics.web.server.max-uri-tags=5')
			.run((context) -> {
				MeterRegistry registry = getInitializedMeterRegistry(context);
				assertThat(registry.get('http.server.requests').meters()).hasSize(3);
				assertThat(output).doesNotContain('Reached the maximum number of URI tags for "http.server.requests"');
			});
	}
	@Test
	void shouldSupplyDefaultServerRequestObservationConvention() {
		this.contextRunner.withPropertyValues('management.observations.http.server.requests.name=some-other-name')
			.run((context) -> {
				assertThat(context).hasSingleBean(DefaultServerRequestObservationConvention.class);
				DefaultServerRequestObservationConvention bean = context
					.getBean(DefaultServerRequestObservationConvention.class);
				assertThat(bean.getName()).isEqualTo('some-other-name');
			});
	}
	@Test
	void shouldBackOffOnCustomServerRequestObservationConvention() {
		this.contextRunner
			.withBean('customServerRequestObservationConvention', ServerRequestObservationConvention.class,
					() -> mock(ServerRequestObservationConvention.class))
			.run((context) -> {
				assertThat(context).hasBean('customServerRequestObservationConvention');
				assertThat(context).hasSingleBean(ServerRequestObservationConvention.class);
			});
	}
	private MeterRegistry getInitializedMeterRegistry(AssertableReactiveWebApplicationContext context) {
		return getInitializedMeterRegistry(context, 'http.server.requests');
	}
	private MeterRegistry getInitializedMeterRegistry(AssertableReactiveWebApplicationContext context,
			String metricName) {
		MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
		meterRegistry.timer(metricName, 'uri', '/test0').record(Duration.of(500, ChronoUnit.SECONDS));
		meterRegistry.timer(metricName, 'uri', '/test1').record(Duration.of(500, ChronoUnit.SECONDS));
		meterRegistry.timer(metricName, 'uri', '/test2').record(Duration.of(500, ChronoUnit.SECONDS));
		return meterRegistry;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
class ObservationAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().with(MetricsRun.simple())
		.withClassLoader(new FilteredClassLoader('io.micrometer.tracing'))
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class));
	private final ApplicationContextRunner tracingContextRunner = new ApplicationContextRunner()
		.with(MetricsRun.simple())
		.withUserConfiguration(TracerConfiguration.class)
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class));
	@Test
	void beansShouldNotBeSuppliedWhenMicrometerObservationIsNotOnClassPath() {
		this.tracingContextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.observation'))
			.run((context) -> {
				assertThat(context).hasSingleBean(MeterRegistry.class);
				assertThat(context).doesNotHaveBean(ObservationRegistry.class);
				assertThat(context).doesNotHaveBean(ObservationHandler.class);
				assertThat(context).doesNotHaveBean(ObservedAspect.class);
				assertThat(context).doesNotHaveBean(ObservationHandlerGrouping.class);
			});
	}
	@Test
	void supplyObservationRegistryWhenMicrometerCoreAndTracingAreNotOnClassPath() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.core', 'io.micrometer.tracing'))
			.run((context) -> {
				ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
				Observation.start('test-observation', observationRegistry).stop();
				assertThat(context).doesNotHaveBean(ObservationHandler.class);
				assertThat(context).hasSingleBean(ObservedAspect.class);
				assertThat(context).doesNotHaveBean(ObservationHandlerGrouping.class);
			});
	}
	@Test
	void supplyMeterHandlerAndGroupingWhenMicrometerCoreIsOnClassPathButTracingIsNot() {
		this.contextRunner.run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('test-observation', observationRegistry).stop();
			assertThat(context).hasSingleBean(ObservationHandler.class);
			assertThat(context).hasSingleBean(DefaultMeterObservationHandler.class);
			assertThat(context).hasSingleBean(ObservedAspect.class);
			assertThat(context).hasSingleBean(ObservationHandlerGrouping.class);
			assertThat(context).hasBean('metricsObservationHandlerGrouping');
		});
	}
	@Test
	void supplyOnlyTracingObservationHandlerGroupingWhenMicrometerCoreIsNotOnClassPathButTracingIs() {
		this.tracingContextRunner.withClassLoader(new FilteredClassLoader('io.micrometer.core')).run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('test-observation', observationRegistry).stop();
			assertThat(context).doesNotHaveBean(ObservationHandler.class);
			assertThat(context).hasSingleBean(ObservedAspect.class);
			assertThat(context).hasSingleBean(ObservationHandlerGrouping.class);
			assertThat(context).hasBean('tracingObservationHandlerGrouping');
		});
	}
	@Test
	void supplyMeterHandlerAndGroupingWhenMicrometerCoreAndTracingAreOnClassPath() {
		this.tracingContextRunner.run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			// Intentionally not stopped since that will trigger additional logic in
			// TracingAwareMeterObservationHandler that we don"t test here
			Observation.start('test-observation', observationRegistry);
			assertThat(context).hasSingleBean(ObservationHandler.class);
			assertThat(context).hasSingleBean(ObservedAspect.class);
			assertThat(context).hasSingleBean(TracingAwareMeterObservationHandler.class);
			assertThat(context).hasSingleBean(ObservationHandlerGrouping.class);
			assertThat(context).hasBean('metricsAndTracingObservationHandlerGrouping');
		});
	}
	@Test
	void supplyMeterHandlerAndGroupingWhenMicrometerCoreAndTracingAreOnClassPathButThereIsNoTracer() {
		new ApplicationContextRunner().with(MetricsRun.simple())
			.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class))
			.run((context) -> {
				ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
				Observation.start('test-observation', observationRegistry).stop();
				assertThat(context).hasSingleBean(ObservationHandler.class);
				assertThat(context).hasSingleBean(DefaultMeterObservationHandler.class);
				assertThat(context).hasSingleBean(ObservedAspect.class);
				assertThat(context).hasSingleBean(ObservationHandlerGrouping.class);
				assertThat(context).hasBean('metricsAndTracingObservationHandlerGrouping');
			});
	}
	@Test
	void autoConfiguresDefaultMeterObservationHandler() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(DefaultMeterObservationHandler.class);
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('test-observation', observationRegistry).stop();
			// When a DefaultMeterObservationHandler is registered, every stopped
			// Observation leads to a timer
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.get('test-observation').timer().count()).isOne();
			assertThat(context).hasSingleBean(DefaultMeterObservationHandler.class);
			assertThat(context).hasSingleBean(ObservationHandler.class);
			assertThat(context).hasSingleBean(ObservedAspect.class);
		});
	}
	@Test
	void allowsDefaultMeterObservationHandlerToBeDisabled() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(MeterRegistry.class))
			.run((context) -> assertThat(context).doesNotHaveBean(ObservationHandler.class));
	}
	@Test
	void allowsObservedAspectToBeDisabled() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(Advice.class))
			.run((context) -> assertThat(context).doesNotHaveBean(ObservedAspect.class));
	}
	@Test
	void allowsObservedAspectToBeCustomized() {
		this.contextRunner.withUserConfiguration(CustomObservedAspectConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ObservedAspect.class)
				.getBean(ObservedAspect.class)
				.isSameAs(context.getBean('customObservedAspect')));
	}
	@Test
	void autoConfiguresObservationPredicates() {
		this.contextRunner.withUserConfiguration(ObservationPredicates.class).run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			// This is allowed by ObservationPredicates.customPredicate
			Observation.start('observation1', observationRegistry).stop();
			// This isn"t allowed by ObservationPredicates.customPredicate
			Observation.start('observation2', observationRegistry).stop();
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.get('observation1').timer().count()).isOne();
			assertThatExceptionOfType(MeterNotFoundException.class)
				.isThrownBy(() -> meterRegistry.get('observation2').timer());
		});
	}
	@Test
	void autoConfiguresObservationFilters() {
		this.contextRunner.withUserConfiguration(ObservationFilters.class).run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('filtered', observationRegistry).stop();
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.get('filtered').tag('filter', 'one').timer().count()).isOne();
		});
	}
	@Test
	void shouldSupplyPropertiesObservationFilterBean() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(PropertiesObservationFilterPredicate.class));
	}
	@Test
	void shouldApplyCommonKeyValuesToObservations() {
		this.contextRunner.withPropertyValues('management.observations.key-values.a=alpha').run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('keyvalues', observationRegistry).stop();
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.get('keyvalues').tag('a', 'alpha').timer().count()).isOne();
		});
	}
	@Test
	void autoConfiguresGlobalObservationConventions() {
		this.contextRunner.withUserConfiguration(CustomGlobalObservationConvention.class).run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Context micrometerContext = new Context();
			Observation.start('test-observation', () -> micrometerContext, observationRegistry).stop();
			assertThat(micrometerContext.getAllKeyValues()).containsExactly(KeyValue.of('key1', 'value1'));
		});
	}
	@Test
	void autoConfiguresObservationHandlers() {
		this.contextRunner.withUserConfiguration(ObservationHandlers.class).run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			List<ObservationHandler<?>> handlers = context.getBean(CalledHandlers.class).getCalledHandlers();
			Observation.start('test-observation', observationRegistry).stop();
			assertThat(context).doesNotHaveBean(DefaultMeterObservationHandler.class);
			assertThat(handlers).hasSize(2);
			// Multiple MeterObservationHandler are wrapped in
			// FirstMatchingCompositeObservationHandler, which calls only the first one
			assertThat(handlers.get(0)).isInstanceOf(CustomMeterObservationHandler.class);
			assertThat(((CustomMeterObservationHandler) handlers.get(0)).getName())
				.isEqualTo('customMeterObservationHandler1');
			// Regular handlers are registered last
			assertThat(handlers.get(1)).isInstanceOf(CustomObservationHandler.class);
			assertThat(context).doesNotHaveBean(DefaultMeterObservationHandler.class);
			assertThat(context).doesNotHaveBean(TracingAwareMeterObservationHandler.class);
		});
	}
	@Test
	void autoConfiguresObservationHandlerWithCustomContext() {
		this.contextRunner.withUserConfiguration(ObservationHandlerWithCustomContextConfiguration.class)
			.run((context) -> {
				ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
				List<ObservationHandler<?>> handlers = context.getBean(CalledHandlers.class).getCalledHandlers();
				CustomContext customContext = new CustomContext();
				Observation.start('test-observation', () -> customContext, observationRegistry).stop();
				assertThat(handlers).hasSize(1);
				assertThat(handlers.get(0)).isInstanceOf(ObservationHandlerWithCustomContext.class);
				assertThat(context).hasSingleBean(DefaultMeterObservationHandler.class);
				assertThat(context).doesNotHaveBean(TracingAwareMeterObservationHandler.class);
			});
	}
	@Test
	void autoConfiguresTracingAwareMeterObservationHandler() {
		this.tracingContextRunner.withUserConfiguration(CustomTracingObservationHandlers.class).run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			List<ObservationHandler<?>> handlers = context.getBean(CalledHandlers.class).getCalledHandlers();
			// Intentionally not stopped since that will trigger additional logic in
			// TracingAwareMeterObservationHandler that we don"t test here
			Observation.start('test-observation', observationRegistry);
			assertThat(handlers).hasSize(1);
			assertThat(handlers.get(0)).isInstanceOf(CustomTracingObservationHandler.class);
			assertThat(context).hasSingleBean(TracingAwareMeterObservationHandler.class);
			assertThat(context.getBeansOfType(ObservationHandler.class)).hasSize(2);
		});
	}
	@Test
	void autoConfiguresObservationHandlerWhenTracingIsActive() {
		this.tracingContextRunner.withUserConfiguration(ObservationHandlersTracing.class).run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			List<ObservationHandler<?>> handlers = context.getBean(CalledHandlers.class).getCalledHandlers();
			Observation.start('test-observation', observationRegistry).stop();
			assertThat(handlers).hasSize(3);
			// Multiple TracingObservationHandler are wrapped in
			// FirstMatchingCompositeObservationHandler, which calls only the first one
			assertThat(handlers.get(0)).isInstanceOf(CustomTracingObservationHandler.class);
			assertThat(((CustomTracingObservationHandler) handlers.get(0)).getName())
				.isEqualTo('customTracingHandler1');
			// Multiple MeterObservationHandler are wrapped in
			// FirstMatchingCompositeObservationHandler, which calls only the first one
			assertThat(handlers.get(1)).isInstanceOf(CustomMeterObservationHandler.class);
			assertThat(((CustomMeterObservationHandler) handlers.get(1)).getName())
				.isEqualTo('customMeterObservationHandler1');
			// Regular handlers are registered last
			assertThat(handlers.get(2)).isInstanceOf(CustomObservationHandler.class);
			assertThat(context).doesNotHaveBean(TracingAwareMeterObservationHandler.class);
			assertThat(context).doesNotHaveBean(DefaultMeterObservationHandler.class);
		});
	}
	@Test
	void shouldNotDisableSpringSecurityObservationsByDefault() {
		this.contextRunner.run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('spring.security.filterchains', observationRegistry).stop();
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThat(meterRegistry.get('spring.security.filterchains').timer().count()).isOne();
		});
	}
	@Test
	void shouldDisableSpringSecurityObservationsIfPropertyIsSet() {
		this.contextRunner.withPropertyValues('management.observations.enable.spring.security=false').run((context) -> {
			ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
			Observation.start('spring.security.filterchains', observationRegistry).stop();
			MeterRegistry meterRegistry = context.getBean(MeterRegistry.class);
			assertThatExceptionOfType(MeterNotFoundException.class)
				.isThrownBy(() -> meterRegistry.get('spring.security.filterchains').timer());
		});
	}
	@Test
	void shouldEnableLongTaskTimersByDefault() {
		this.contextRunner.run((context) -> {
			DefaultMeterObservationHandler handler = context.getBean(DefaultMeterObservationHandler.class);
			assertThat(handler).hasFieldOrPropertyWithValue('shouldCreateLongTaskTimer', true);
		});
	}
	@Test
	void shouldDisableLongTaskTimerIfPropertyIsSet() {
		this.contextRunner.withPropertyValues('management.observations.long-task-timer.enabled=false')
			.run((context) -> {
				DefaultMeterObservationHandler handler = context.getBean(DefaultMeterObservationHandler.class);
				assertThat(handler).hasFieldOrPropertyWithValue('shouldCreateLongTaskTimer', false);
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void shouldEnableLongTaskTimersForTracingByDefault() {
		this.tracingContextRunner.run((context) -> {
			TracingAwareMeterObservationHandler<Observation.Context> tracingHandler = context
				.getBean(TracingAwareMeterObservationHandler.class);
			Object delegate = ReflectionTestUtils.getField(tracingHandler, 'delegate');
			assertThat(delegate).hasFieldOrPropertyWithValue('shouldCreateLongTaskTimer', true);
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void shouldDisableLongTaskTimerForTracingIfPropertyIsSet() {
		this.tracingContextRunner.withPropertyValues('management.observations.long-task-timer.enabled=false')
			.run((context) -> {
				TracingAwareMeterObservationHandler<Observation.Context> tracingHandler = context
					.getBean(TracingAwareMeterObservationHandler.class);
				Object delegate = ReflectionTestUtils.getField(tracingHandler, 'delegate');
				assertThat(delegate).hasFieldOrPropertyWithValue('shouldCreateLongTaskTimer', false);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class ObservationPredicates {
		@Bean
		ObservationPredicate customPredicate() {
			return (s, context) -> s.equals('observation1');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ObservationFilters {
		@Bean
		@Order(1)
		ObservationFilter observationFilterOne() {
			return (context) -> context.addLowCardinalityKeyValue(KeyValue.of('filter', 'one'));
		}
		@Bean
		@Order(0)
		ObservationFilter observationFilterTwo() {
			return (context) -> context.addLowCardinalityKeyValue(KeyValue.of('filter', 'two'));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomObservedAspectConfiguration {
		@Bean
		ObservedAspect customObservedAspect(ObservationRegistry observationRegistry) {
			return new ObservedAspect(observationRegistry);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomGlobalObservationConvention {
		@Bean
		GlobalObservationConvention<?> customConvention() {
			return new GlobalObservationConvention<>() {
				@Override
				public boolean supportsContext(Context context) {
					return true;
				}
				@Override
				public KeyValues getLowCardinalityKeyValues(Context context) {
					return KeyValues.of('key1', 'value1');
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CalledHandlersConfiguration.class)
	static class ObservationHandlers {
		@Bean
		@Order(4)
		AllMatchingCompositeObservationHandler customAllMatchingCompositeObservationHandler() {
			return new AllMatchingCompositeObservationHandler();
		}
		@Bean
		@Order(3)
		FirstMatchingCompositeObservationHandler customFirstMatchingCompositeObservationHandler() {
			return new FirstMatchingCompositeObservationHandler();
		}
		@Bean
		@Order(2)
		ObservationHandler<Context> customObservationHandler(CalledHandlers calledHandlers) {
			return new CustomObservationHandler(calledHandlers);
		}
		@Bean
		@Order(1)
		MeterObservationHandler<Context> customMeterObservationHandler2(CalledHandlers calledHandlers) {
			return new CustomMeterObservationHandler('customMeterObservationHandler2', calledHandlers);
		}
		@Bean
		@Order(0)
		MeterObservationHandler<Context> customMeterObservationHandler1(CalledHandlers calledHandlers) {
			return new CustomMeterObservationHandler('customMeterObservationHandler1', calledHandlers);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CalledHandlersConfiguration.class)
	static class ObservationHandlerWithCustomContextConfiguration {
		@Bean
		ObservationHandlerWithCustomContext observationHandlerWithCustomContext(CalledHandlers calledHandlers) {
			return new ObservationHandlerWithCustomContext(calledHandlers);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TracerConfiguration {
		@Bean
		Tracer tracer() {
			return mock(Tracer.class); // simulating tracer configuration
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CalledHandlersConfiguration.class)
	static class CustomTracingObservationHandlers {
		@Bean
		CustomTracingObservationHandler customTracingHandler1(CalledHandlers calledHandlers) {
			return new CustomTracingObservationHandler('customTracingHandler1', calledHandlers);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CalledHandlersConfiguration.class)
	static class ObservationHandlersTracing {
		@Bean
		@Order(6)
		CustomTracingObservationHandler customTracingHandler2(CalledHandlers calledHandlers) {
			return new CustomTracingObservationHandler('customTracingHandler2', calledHandlers);
		}
		@Bean
		@Order(5)
		CustomTracingObservationHandler customTracingHandler1(CalledHandlers calledHandlers) {
			return new CustomTracingObservationHandler('customTracingHandler1', calledHandlers);
		}
		@Bean
		@Order(4)
		AllMatchingCompositeObservationHandler customAllMatchingCompositeObservationHandler() {
			return new AllMatchingCompositeObservationHandler();
		}
		@Bean
		@Order(3)
		FirstMatchingCompositeObservationHandler customFirstMatchingCompositeObservationHandler() {
			return new FirstMatchingCompositeObservationHandler();
		}
		@Bean
		@Order(2)
		ObservationHandler<Context> customObservationHandler(CalledHandlers calledHandlers) {
			return new CustomObservationHandler(calledHandlers);
		}
		@Bean
		@Order(1)
		MeterObservationHandler<Context> customMeterObservationHandler2(CalledHandlers calledHandlers) {
			return new CustomMeterObservationHandler('customMeterObservationHandler2', calledHandlers);
		}
		@Bean
		@Order(0)
		MeterObservationHandler<Context> customMeterObservationHandler1(CalledHandlers calledHandlers) {
			return new CustomMeterObservationHandler('customMeterObservationHandler1', calledHandlers);
		}
	}
	private static class CustomTracingObservationHandler implements TracingObservationHandler<Context> {
		private final Tracer tracer = mock(Tracer.class, Answers.RETURNS_MOCKS);
		private final String name;
		private final CalledHandlers calledHandlers;
		CustomTracingObservationHandler(String name, CalledHandlers calledHandlers) {
			this.name = name;
			this.calledHandlers = calledHandlers;
		}
		String getName() {
			return this.name;
		}
		@Override
		public Tracer getTracer() {
			return this.tracer;
		}
		@Override
		public void onStart(Context context) {
			this.calledHandlers.onCalled(this);
		}
		@Override
		public boolean supportsContext(Context context) {
			return true;
		}
	}
	private static class ObservationHandlerWithCustomContext implements ObservationHandler<CustomContext> {
		private final CalledHandlers calledHandlers;
		ObservationHandlerWithCustomContext(CalledHandlers calledHandlers) {
			this.calledHandlers = calledHandlers;
		}
		@Override
		public void onStart(CustomContext context) {
			this.calledHandlers.onCalled(this);
		}
		@Override
		public boolean supportsContext(Context context) {
			return context instanceof CustomContext;
		}
	}
	private static final class CustomContext extends Context {
	}
	private static final class CalledHandlers {
		private final List<ObservationHandler<?>> calledHandlers = new ArrayList<>();
		void onCalled(ObservationHandler<?> handler) {
			this.calledHandlers.add(handler);
		}
		List<ObservationHandler<?>> getCalledHandlers() {
			return this.calledHandlers;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CalledHandlersConfiguration {
		@Bean
		CalledHandlers calledHandlers() {
			return new CalledHandlers();
		}
	}
	private static class CustomObservationHandler implements ObservationHandler<Context> {
		private final CalledHandlers calledHandlers;
		CustomObservationHandler(CalledHandlers calledHandlers) {
			this.calledHandlers = calledHandlers;
		}
		@Override
		public void onStart(Context context) {
			this.calledHandlers.onCalled(this);
		}
		@Override
		public boolean supportsContext(Context context) {
			return true;
		}
	}
	private static class CustomMeterObservationHandler implements MeterObservationHandler<Context> {
		private final CalledHandlers calledHandlers;
		private final String name;
		CustomMeterObservationHandler(String name, CalledHandlers calledHandlers) {
			this.name = name;
			this.calledHandlers = calledHandlers;
		}
		String getName() {
			return this.name;
		}
		@Override
		public void onStart(Context context) {
			this.calledHandlers.onCalled(this);
		}
		@Override
		public boolean supportsContext(Context context) {
			return true;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.batch;
/**
class BatchObservationAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(TestObservationRegistry.class, TestObservationRegistry::create)
		.withConfiguration(AutoConfigurations.of(BatchObservationAutoConfiguration.class));
	@Test
	void backsOffWhenObservationRegistryIsMissing() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(BatchObservationAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(BatchObservabilityBeanPostProcessor.class));
	}
	@Test
	void beanIsPresentWhenSpringBatchIsPresent() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(BatchObservabilityBeanPostProcessor.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
class PropertiesObservationFilterPredicateTests {
	@Test
	void shouldDoNothingIfKeyValuesAreEmpty() {
		PropertiesObservationFilterPredicate filter = createFilter();
		Context mapped = mapContext(filter, 'a', 'alpha');
		assertThat(mapped.getLowCardinalityKeyValues()).containsExactly(KeyValue.of('a', 'alpha'));
	}
	@Test
	void shouldAddKeyValues() {
		PropertiesObservationFilterPredicate filter = createFilter('b', 'beta');
		Context mapped = mapContext(filter, 'a', 'alpha');
		assertThat(mapped.getLowCardinalityKeyValues()).containsExactly(KeyValue.of('a', 'alpha'),
				KeyValue.of('b', 'beta'));
	}
	@Test
	void shouldFilter() {
		PropertiesObservationFilterPredicate predicate = createPredicate('spring.security');
		Context context = new Context();
		assertThat(predicate.test('spring.security.filterchains', context)).isFalse();
		assertThat(predicate.test('spring.security', context)).isFalse();
		assertThat(predicate.test('spring.data', context)).isTrue();
		assertThat(predicate.test('spring', context)).isTrue();
	}
	@Test
	void filterShouldFallbackToAll() {
		PropertiesObservationFilterPredicate predicate = createPredicate('all');
		Context context = new Context();
		assertThat(predicate.test('spring.security.filterchains', context)).isFalse();
		assertThat(predicate.test('spring.security', context)).isFalse();
		assertThat(predicate.test('spring.data', context)).isFalse();
		assertThat(predicate.test('spring', context)).isFalse();
	}
	@Test
	void shouldNotFilterIfDisabledNamesIsEmpty() {
		PropertiesObservationFilterPredicate predicate = createPredicate();
		Context context = new Context();
		assertThat(predicate.test('spring.security.filterchains', context)).isTrue();
		assertThat(predicate.test('spring.security', context)).isTrue();
		assertThat(predicate.test('spring.data', context)).isTrue();
		assertThat(predicate.test('spring', context)).isTrue();
	}
	private static Context mapContext(PropertiesObservationFilterPredicate filter, String... initialKeyValues) {
		Context context = new Context();
		context.addLowCardinalityKeyValues(KeyValues.of(initialKeyValues));
		return filter.map(context);
	}
	private static PropertiesObservationFilterPredicate createFilter(String... keyValues) {
		ObservationProperties properties = new ObservationProperties();
		for (int i = 0; i < keyValues.length; i += 2) {
			properties.getKeyValues().put(keyValues[i], keyValues[i + 1]);
		}
		return new PropertiesObservationFilterPredicate(properties);
	}
	private static PropertiesObservationFilterPredicate createPredicate(String... disabledNames) {
		ObservationProperties properties = new ObservationProperties();
		for (String name : disabledNames) {
			properties.getEnable().put(name, false);
		}
		return new PropertiesObservationFilterPredicate(properties);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
class ObservationHandlerGroupingTests {
	@Test
	void shouldGroupCategoriesIntoFirstMatchingHandlerAndRespectCategoryOrder() {
		ObservationHandlerGrouping grouping = new ObservationHandlerGrouping(
				List.of(ObservationHandlerA.class, ObservationHandlerB.class));
		ObservationConfig config = new ObservationConfig();
		ObservationHandlerA handlerA1 = new ObservationHandlerA('a1');
		ObservationHandlerA handlerA2 = new ObservationHandlerA('a2');
		ObservationHandlerB handlerB1 = new ObservationHandlerB('b1');
		ObservationHandlerB handlerB2 = new ObservationHandlerB('b2');
		grouping.apply(List.of(handlerB1, handlerB2, handlerA1, handlerA2), config);
		List<ObservationHandler<?>> handlers = getObservationHandlers(config);
		assertThat(handlers).hasSize(2);
		// Category A is first
		assertThat(handlers.get(0)).isInstanceOf(FirstMatchingCompositeObservationHandler.class);
		FirstMatchingCompositeObservationHandler firstMatching0 = (FirstMatchingCompositeObservationHandler) handlers
			.get(0);
		assertThat(firstMatching0.getHandlers()).containsExactly(handlerA1, handlerA2);
		// Category B is second
		assertThat(handlers.get(1)).isInstanceOf(FirstMatchingCompositeObservationHandler.class);
		FirstMatchingCompositeObservationHandler firstMatching1 = (FirstMatchingCompositeObservationHandler) handlers
			.get(1);
		assertThat(firstMatching1.getHandlers()).containsExactly(handlerB1, handlerB2);
	}
	@Test
	void uncategorizedHandlersShouldBeOrderedAfterCategories() {
		ObservationHandlerGrouping grouping = new ObservationHandlerGrouping(ObservationHandlerA.class);
		ObservationConfig config = new ObservationConfig();
		ObservationHandlerA handlerA1 = new ObservationHandlerA('a1');
		ObservationHandlerA handlerA2 = new ObservationHandlerA('a2');
		ObservationHandlerB handlerB1 = new ObservationHandlerB('b1');
		grouping.apply(List.of(handlerB1, handlerA1, handlerA2), config);
		List<ObservationHandler<?>> handlers = getObservationHandlers(config);
		assertThat(handlers).hasSize(2);
		// Category A is first
		assertThat(handlers.get(0)).isInstanceOf(FirstMatchingCompositeObservationHandler.class);
		FirstMatchingCompositeObservationHandler firstMatching0 = (FirstMatchingCompositeObservationHandler) handlers
			.get(0);
		// Uncategorized handlers follow
		assertThat(firstMatching0.getHandlers()).containsExactly(handlerA1, handlerA2);
		assertThat(handlers.get(1)).isEqualTo(handlerB1);
	}
	@SuppressWarnings('unchecked')
	private static List<ObservationHandler<?>> getObservationHandlers(ObservationConfig config) {
		Method method = ReflectionUtils.findMethod(ObservationConfig.class, 'getObservationHandlers');
		ReflectionUtils.makeAccessible(method);
		return (List<ObservationHandler<?>>) ReflectionUtils.invokeMethod(method, config);
	}
	private static class NamedObservationHandler implements ObservationHandler<Observation.Context> {
		private final String name;
		NamedObservationHandler(String name) {
			this.name = name;
		}
		@Override
		public boolean supportsContext(Context context) {
			return true;
		}
		@Override
		public String toString() {
			return getClass().getSimpleName() + '{name="' + this.name + '"}';
		}
	}
	private static class ObservationHandlerA extends NamedObservationHandler {
		ObservationHandlerA(String name) {
			super(name);
		}
	}
	private static class ObservationHandlerB extends NamedObservationHandler {
		ObservationHandlerB(String name) {
			super(name);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
class ObservationRegistryConfigurerIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ObservationAutoConfiguration.class));
	@Test
	void customizersAreCalledInOrder() {
		this.contextRunner.withUserConfiguration(Customizers.class).run((context) -> {
			CalledCustomizers calledCustomizers = context.getBean(CalledCustomizers.class);
			Customizer1 customizer1 = context.getBean(Customizer1.class);
			Customizer2 customizer2 = context.getBean(Customizer2.class);
			assertThat(calledCustomizers.getCustomizers()).containsExactly(customizer1, customizer2);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class Customizers {
		@Bean
		CalledCustomizers calledCustomizers() {
			return new CalledCustomizers();
		}
		@Bean
		@Order(1)
		Customizer1 customizer1(CalledCustomizers calledCustomizers) {
			return new Customizer1(calledCustomizers);
		}
		@Bean
		@Order(2)
		Customizer2 customizer2(CalledCustomizers calledCustomizers) {
			return new Customizer2(calledCustomizers);
		}
	}
	private static final class CalledCustomizers {
		private final List<ObservationRegistryCustomizer<?>> customizers = new ArrayList<>();
		void onCalled(ObservationRegistryCustomizer<?> customizer) {
			this.customizers.add(customizer);
		}
		List<ObservationRegistryCustomizer<?>> getCustomizers() {
			return this.customizers;
		}
	}
	private static class Customizer1 implements ObservationRegistryCustomizer<ObservationRegistry> {
		private final CalledCustomizers calledCustomizers;
		Customizer1(CalledCustomizers calledCustomizers) {
			this.calledCustomizers = calledCustomizers;
		}
		@Override
		public void customize(ObservationRegistry registry) {
			this.calledCustomizers.onCalled(this);
		}
	}
	private static class Customizer2 implements ObservationRegistryCustomizer<ObservationRegistry> {
		private final CalledCustomizers calledCustomizers;
		Customizer2(CalledCustomizers calledCustomizers) {
			this.calledCustomizers = calledCustomizers;
		}
		@Override
		public void customize(ObservationRegistry registry) {
			this.calledCustomizers.onCalled(this);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.graphql;
/**
class GraphQlObservationAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(TestObservationRegistry.class, TestObservationRegistry::create)
		.withConfiguration(AutoConfigurations.of(GraphQlObservationAutoConfiguration.class));
	@Test
	void backsOffWhenObservationRegistryIsMissing() {
		new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(GraphQlObservationAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(GraphQlObservationInstrumentation.class));
	}
	@Test
	void definesInstrumentationWhenObservationRegistryIsPresent() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(GraphQlObservationInstrumentation.class));
	}
	@Test
	void instrumentationBacksOffIfAlreadyPresent() {
		this.contextRunner.withUserConfiguration(InstrumentationConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(GraphQlObservationInstrumentation.class)
				.hasBean('customInstrumentation'));
	}
	@Test
	void instrumentationUsesCustomConventionsIfAvailable() {
		this.contextRunner.withUserConfiguration(CustomConventionsConfiguration.class).run((context) -> {
			GraphQlObservationInstrumentation instrumentation = context
				.getBean(GraphQlObservationInstrumentation.class);
			assertThat(instrumentation).extracting('requestObservationConvention')
				.isInstanceOf(CustomExecutionRequestObservationConvention.class);
			assertThat(instrumentation).extracting('dataFetcherObservationConvention')
				.isInstanceOf(CustomDataFetcherObservationConvention.class);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class InstrumentationConfiguration {
		@Bean
		GraphQlObservationInstrumentation customInstrumentation(ObservationRegistry registry) {
			return new GraphQlObservationInstrumentation(registry);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConventionsConfiguration {
		@Bean
		CustomExecutionRequestObservationConvention customExecutionConvention() {
			return new CustomExecutionRequestObservationConvention();
		}
		@Bean
		CustomDataFetcherObservationConvention customDataFetcherConvention() {
			return new CustomDataFetcherObservationConvention();
		}
	}
	static class CustomExecutionRequestObservationConvention extends DefaultExecutionRequestObservationConvention {
	}
	static class CustomDataFetcherObservationConvention extends DefaultDataFetcherObservationConvention {
	}
	@Configuration(proxyBeanMethods = false)
	static class WebGraphQlConfiguration {
		@Bean
		WebGraphQlHandler webGraphQlHandler() {
			return mock(WebGraphQlHandler.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.r2dbc;
/**
class R2dbcObservationAutoConfigurationTests {
	private final ApplicationContextRunner runnerWithoutObservationRegistry = new ApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(R2dbcProxyAutoConfiguration.class, R2dbcObservationAutoConfiguration.class));
	private final ApplicationContextRunner runner = this.runnerWithoutObservationRegistry
		.withBean(ObservationRegistry.class, ObservationRegistry::create);
	@Test
	void shouldBeRegisteredInAutoConfigurationImports() {
		assertThat(ImportCandidates.load(AutoConfiguration.class, null).getCandidates())
			.contains(R2dbcObservationAutoConfiguration.class.getName());
	}
	@Test
	void shouldNotSupplyBeansIfObservationRegistryIsNotPresent() {
		this.runnerWithoutObservationRegistry
			.run((context) -> assertThat(context).doesNotHaveBean(ProxyConnectionFactoryCustomizer.class));
	}
	@Test
	void decoratorShouldReportObservations() {
		this.runner.run((context) -> {
			CapturingObservationHandler handler = registerCapturingObservationHandler(context);
			ConnectionFactoryDecorator decorator = context.getBean(ConnectionFactoryDecorator.class);
			assertThat(decorator).isNotNull();
			ConnectionFactory connectionFactory = ConnectionFactoryBuilder
				.withUrl('r2dbc:h2:mem:///' + UUID.randomUUID())
				.build();
			ConnectionFactory decorated = decorator.decorate(connectionFactory);
			Mono.from(decorated.create())
				.flatMap((c) -> Mono.from(c.createStatement('SELECT 1;').execute())
					.flatMap((ignore) -> Mono.from(c.close())))
				.block();
			assertThat(handler.awaitContext().getName()).as('context.getName()').isEqualTo('r2dbc.query');
		});
	}
	private static CapturingObservationHandler registerCapturingObservationHandler(
			AssertableApplicationContext context) {
		ObservationRegistry observationRegistry = context.getBean(ObservationRegistry.class);
		assertThat(observationRegistry).isNotNull();
		CapturingObservationHandler handler = new CapturingObservationHandler();
		observationRegistry.observationConfig().observationHandler(handler);
		return handler;
	}
	private static final class CapturingObservationHandler implements ObservationHandler<Context> {
		private final AtomicReference<Context> context = new AtomicReference<>();
		@Override
		public boolean supportsContext(Context context) {
			return true;
		}
		@Override
		public void onStart(Context context) {
			this.context.set(context);
		}
		Context awaitContext() {
			return Awaitility.await().untilAtomic(this.context, Matchers.notNullValue());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.r2dbc;
/**
class ConnectionFactoryHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ConnectionFactoryHealthContributorAutoConfiguration.class,
				HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(ConnectionFactoryHealthIndicator.class));
	}
	@Test
	void runWithNoConnectionFactoryShouldNotCreateIndicator() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(ConnectionFactoryHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withPropertyValues('management.health.r2dbc.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ConnectionFactoryHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.liquibase;
/**
class LiquibaseEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LiquibaseEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=liquibase')
			.withBean(SpringLiquibase.class, () -> mock(SpringLiquibase.class))
			.run((context) -> assertThat(context).hasSingleBean(LiquibaseEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withBean(SpringLiquibase.class, () -> mock(SpringLiquibase.class))
			.withPropertyValues('management.endpoint.liquibase.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(LiquibaseEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(LiquibaseEndpoint.class));
	}
	@Test
	void disablesCloseOfDataSourceWhenEndpointIsEnabled() {
		this.contextRunner.withUserConfiguration(DataSourceClosingLiquibaseConfiguration.class)
			.withPropertyValues('management.endpoints.web.exposure.include=liquibase')
			.run((context) -> {
				assertThat(context).hasSingleBean(LiquibaseEndpoint.class);
				assertThat(context.getBean(DataSourceClosingSpringLiquibase.class))
					.hasFieldOrPropertyWithValue('closeDataSourceOnceMigrated', false);
			});
	}
	@Test
	void doesNotDisableCloseOfDataSourceWhenEndpointIsDisabled() {
		this.contextRunner.withUserConfiguration(DataSourceClosingLiquibaseConfiguration.class)
			.withPropertyValues('management.endpoint.liquibase.enabled:false')
			.run((context) -> {
				assertThat(context).doesNotHaveBean(LiquibaseEndpoint.class);
				DataSourceClosingSpringLiquibase bean = context.getBean(DataSourceClosingSpringLiquibase.class);
				assertThat(bean).hasFieldOrPropertyWithValue('closeDataSourceOnceMigrated', true);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class DataSourceClosingLiquibaseConfiguration {
		@Bean
		SpringLiquibase liquibase() {
			return new DataSourceClosingSpringLiquibase() {
				private boolean propertiesSet = false;
				@Override
				public void setCloseDataSourceOnceMigrated(boolean closeDataSourceOnceMigrated) {
					if (this.propertiesSet) {
						throw new IllegalStateException(
								'setCloseDataSourceOnceMigrated invoked after afterPropertiesSet');
					}
					super.setCloseDataSourceOnceMigrated(closeDataSourceOnceMigrated);
				}
				@Override
				public void afterPropertiesSet() {
					this.propertiesSet = true;
				}
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.flyway;
/**
class FlywayEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(FlywayEndpointAutoConfiguration.class))
		.withBean(Flyway.class, () -> mock(Flyway.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=flyway')
			.run((context) -> assertThat(context).hasSingleBean(FlywayEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.flyway.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(FlywayEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(FlywayEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.sbom;
/**
class SbomEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SbomEndpointAutoConfiguration.class));
	@Test
	void runWhenWebExposedShouldHaveEndpointBeanAndWebExtension() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=sbom')
			.run((context) -> assertThat(context).hasSingleBean(SbomEndpoint.class)
				.hasSingleBean(SbomEndpointWebExtension.class));
	}
	@Test
	void runWhenCloudFoundryExposedShouldHaveEndpointBeanAndWebExtension() {
		this.contextRunner
			.withPropertyValues('management.endpoints.cloud-foundry.exposure.include=sbom',
					'spring.main.cloud-platform=cloud_foundry')
			.run((context) -> assertThat(context).hasSingleBean(SbomEndpoint.class)
				.hasSingleBean(SbomEndpointWebExtension.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(SbomEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.sbom.enabled:false')
			.withPropertyValues('management.endpoints.web.exposure.include=*')
			.run((context) -> assertThat(context).doesNotHaveBean(SbomEndpoint.class));
	}
	@Test
	void runWhenOnlyExposedOverJmxShouldHaveEndpointBeanWithoutWebExtension() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=info', 'spring.jmx.enabled=true',
					'management.endpoints.jmx.exposure.include=sbom')
			.run((context) -> assertThat(context).hasSingleBean(SbomEndpoint.class)
				.doesNotHaveBean(SbomEndpointWebExtension.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.management;
/**
class HeapDumpWebEndpointAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withPropertyValues('management.endpoints.web.exposure.include:*')
		.withUserConfiguration(HeapDumpWebEndpointAutoConfiguration.class);
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(HeapDumpWebEndpoint.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.endpoint.heapdump.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(HeapDumpWebEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.management;
/**
class ThreadDumpEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ThreadDumpEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=threaddump')
			.run((context) -> assertThat(context).hasSingleBean(ThreadDumpEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ThreadDumpEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=*')
			.withPropertyValues('management.endpoint.threaddump.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(ThreadDumpEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.ldap;
/**
class LdapHealthContributorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withBean(LdapOperations.class, () -> mock(LdapOperations.class))
		.withConfiguration(AutoConfigurations.of(LdapHealthContributorAutoConfiguration.class,
				HealthContributorAutoConfiguration.class));
	@Test
	void runShouldCreateIndicator() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(LdapHealthIndicator.class));
	}
	@Test
	void runWhenDisabledShouldNotCreateIndicator() {
		this.contextRunner.withPropertyValues('management.health.ldap.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(LdapHealthIndicator.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.env;
/**
class EnvironmentEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(EnvironmentEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=env')
			.withSystemProperties('dbPassword=123456', 'apiKey=123456')
			.run(validateSystemProperties('******', '******'));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.env.enabled:false')
			.run((context) -> assertThat(context).doesNotHaveBean(EnvironmentEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(EnvironmentEndpoint.class));
	}
	@Test
	void customSanitizingFunctionsAreAppliedInOrder() {
		this.contextRunner.withUserConfiguration(SanitizingFunctionConfiguration.class)
			.withPropertyValues('management.endpoint.env.show-values: WHEN_AUTHORIZED')
			.withPropertyValues('management.endpoints.web.exposure.include=env')
			.withSystemProperties('custom=123456', 'password=123456')
			.run((context) -> {
				assertThat(context).hasSingleBean(EnvironmentEndpoint.class);
				EnvironmentEndpoint endpoint = context.getBean(EnvironmentEndpoint.class);
				EnvironmentDescriptor env = endpoint.environment(null);
				Map<String, PropertyValueDescriptor> systemProperties = getSource('systemProperties', env)
					.getProperties();
				assertThat(systemProperties.get('custom').getValue()).isEqualTo('$$$111$$$');
				assertThat(systemProperties.get('password').getValue()).isEqualTo('$$$222$$$');
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void rolesCanBeConfiguredViaTheEnvironment() {
		this.contextRunner.withPropertyValues('management.endpoint.env.roles: test')
			.withPropertyValues('management.endpoints.web.exposure.include=env')
			.withSystemProperties('dbPassword=123456', 'apiKey=123456')
			.run((context) -> {
				assertThat(context).hasSingleBean(EnvironmentEndpointWebExtension.class);
				EnvironmentEndpointWebExtension endpoint = context.getBean(EnvironmentEndpointWebExtension.class);
				Set<String> roles = (Set<String>) ReflectionTestUtils.getField(endpoint, 'roles');
				assertThat(roles).contains('test');
			});
	}
	@Test
	void showValuesCanBeConfiguredViaTheEnvironment() {
		this.contextRunner.withPropertyValues('management.endpoint.env.show-values: WHEN_AUTHORIZED')
			.withPropertyValues('management.endpoints.web.exposure.include=env')
			.withSystemProperties('dbPassword=123456', 'apiKey=123456')
			.run((context) -> {
				assertThat(context).hasSingleBean(EnvironmentEndpoint.class);
				assertThat(context).hasSingleBean(EnvironmentEndpointWebExtension.class);
				EnvironmentEndpointWebExtension webExtension = context.getBean(EnvironmentEndpointWebExtension.class);
				EnvironmentEndpoint endpoint = context.getBean(EnvironmentEndpoint.class);
				assertThat(webExtension).extracting('showValues').isEqualTo(Show.WHEN_AUTHORIZED);
				assertThat(endpoint).extracting('showValues').isEqualTo(Show.WHEN_AUTHORIZED);
			});
	}
	@Test
	void runWhenOnlyExposedOverJmxShouldHaveEndpointBeanWithoutWebExtension() {
		this.contextRunner
			.withPropertyValues('management.endpoints.web.exposure.include=info', 'spring.jmx.enabled=true',
					'management.endpoints.jmx.exposure.include=env')
			.run((context) -> assertThat(context).hasSingleBean(EnvironmentEndpoint.class)
				.doesNotHaveBean(EnvironmentEndpointWebExtension.class));
	}
	private ContextConsumer<AssertableApplicationContext> validateSystemProperties(String dbPassword, String apiKey) {
		return (context) -> {
			assertThat(context).hasSingleBean(EnvironmentEndpoint.class);
			EnvironmentEndpoint endpoint = context.getBean(EnvironmentEndpoint.class);
			EnvironmentDescriptor env = endpoint.environment(null);
			Map<String, PropertyValueDescriptor> systemProperties = getSource('systemProperties', env).getProperties();
			assertThat(systemProperties.get('dbPassword').getValue()).isEqualTo(dbPassword);
			assertThat(systemProperties.get('apiKey').getValue()).isEqualTo(apiKey);
		};
	}
	private PropertySourceDescriptor getSource(String name, EnvironmentDescriptor descriptor) {
		return descriptor.getPropertySources()
			.stream()
			.filter((source) -> name.equals(source.getName()))
			.findFirst()
			.get();
	}
	@Configuration(proxyBeanMethods = false)
	static class SanitizingFunctionConfiguration {
		@Bean
		@Order(0)
		SanitizingFunction firstSanitizingFunction() {
			return (data) -> {
				if (data.getKey().contains('custom')) {
					return data.withValue('$$$111$$$');
				}
				return data;
			};
		}
		@Bean
		@Order(1)
		SanitizingFunction secondSanitizingFunction() {
			return (data) -> {
				if (data.getKey().contains('custom') || data.getKey().contains('password')) {
					return data.withValue('$$$222$$$');
				}
				return data;
			};
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.beans;
/**
class BeansEndpointAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(BeansEndpointAutoConfiguration.class));
	@Test
	void runShouldHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoints.web.exposure.include=beans')
			.run((context) -> assertThat(context).hasSingleBean(BeansEndpoint.class));
	}
	@Test
	void runWhenNotExposedShouldNotHaveEndpointBean() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(BeansEndpoint.class));
	}
	@Test
	void runWhenEnabledPropertyIsFalseShouldNotHaveEndpointBean() {
		this.contextRunner.withPropertyValues('management.endpoint.beans.enabled:false')
			.withPropertyValues('management.endpoints.web.exposure.include=*')
			.run((context) -> assertThat(context).doesNotHaveBean(BeansEndpoint.class));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.ssl;
/**
@ConfigurationProperties(prefix = 'management.health.ssl')
public class SslHealthIndicatorProperties {
	/**
	 * If an SSL Certificate will be invalid within the time span defined by this
	 * threshold, it should trigger a warning.
	 */
	private Duration certificateValidityWarningThreshold = Duration.ofDays(14);
	public Duration getCertificateValidityWarningThreshold() {
		return this.certificateValidityWarningThreshold;
	}
	public void setCertificateValidityWarningThreshold(Duration certificateValidityWarningThreshold) {
		this.certificateValidityWarningThreshold = certificateValidityWarningThreshold;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.ssl;
/**
@AutoConfiguration(before = HealthContributorAutoConfiguration.class)
@ConditionalOnEnabledHealthIndicator('ssl')
@EnableConfigurationProperties(SslHealthIndicatorProperties.class)
public class SslHealthContributorAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(name = 'sslHealthIndicator')
	SslHealthIndicator sslHealthIndicator(SslInfo sslInfo) {
		return new SslHealthIndicator(sslInfo);
	}
	@Bean
	@ConditionalOnMissingBean
	SslInfo sslInfo(SslBundles sslBundles, SslHealthIndicatorProperties sslHealthIndicatorProperties) {
		return new SslInfo(sslBundles, sslHealthIndicatorProperties.getCertificateValidityWarningThreshold());
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.ssl;
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public class OpenTelemetryAutoConfiguration {
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class OpenTelemetryPropagationConfigurations {
	/**
	 * Propagates traces but no baggage.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'management.tracing.baggage', name = 'enabled', havingValue = 'false')
	@EnableConfigurationProperties(TracingProperties.class)
	static class PropagationWithoutBaggage {
		@Bean
		@ConditionalOnEnabledTracing
		TextMapPropagator textMapPropagator(TracingProperties properties) {
			return CompositeTextMapPropagator.create(properties.getPropagation(), null);
		}
	}
	/**
	 * Propagates traces and baggage.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'management.tracing.baggage', name = 'enabled', matchIfMissing = true)
	@EnableConfigurationProperties(TracingProperties.class)
	static class PropagationWithBaggage {
		private final TracingProperties tracingProperties;
		PropagationWithBaggage(TracingProperties tracingProperties) {
			this.tracingProperties = tracingProperties;
		}
		@Bean
		@ConditionalOnEnabledTracing
		TextMapPropagator textMapPropagatorWithBaggage(OtelCurrentTraceContext otelCurrentTraceContext) {
			List<String> remoteFields = this.tracingProperties.getBaggage().getRemoteFields();
			List<String> tagFields = this.tracingProperties.getBaggage().getTagFields();
			BaggageTextMapPropagator baggagePropagator = new BaggageTextMapPropagator(remoteFields,
					new OtelBaggageManager(otelCurrentTraceContext, remoteFields, tagFields));
			return CompositeTextMapPropagator.create(this.tracingProperties.getPropagation(), baggagePropagator);
		}
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnProperty(prefix = 'management.tracing.baggage.correlation', name = 'enabled',
				matchIfMissing = true)
		Slf4JBaggageEventListener otelSlf4JBaggageEventListener() {
			return new Slf4JBaggageEventListener(this.tracingProperties.getBaggage().getCorrelation().getFields());
		}
	}
	/**
	 * Propagates neither traces nor baggage.
	 */
	@Configuration(proxyBeanMethods = false)
	static class NoPropagation {
		@Bean
		@ConditionalOnMissingBean
		TextMapPropagator noopTextMapPropagator() {
			return TextMapPropagator.noop();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class LocalBaggageFields {
	private final List<String> fields;
	LocalBaggageFields(List<String> fields) {
		Assert.notNull(fields, 'fields must not be null');
		this.fields = fields;
	}
	/**
	 * Returns the local fields as a list.
	 * @return the list
	 */
	List<String> asList() {
		return Collections.unmodifiableList(this.fields);
	}
	/**
	 * Extracts the local fields from the given propagation factory builder.
	 * @param builder the propagation factory builder to extract the local fields from
	 * @return the local fields
	 */
	static LocalBaggageFields extractFrom(BaggagePropagation.FactoryBuilder builder) {
		List<String> localFields = new ArrayList<>();
		for (BaggagePropagationConfig config : builder.configs()) {
			if (config instanceof SingleBaggageField field) {
				if (CollectionUtils.isEmpty(field.keyNames())) {
					localFields.add(field.field().name());
				}
			}
		}
		return new LocalBaggageFields(localFields);
	}
	/**
	 * Creates empty local fields.
	 * @return the empty local fields
	 */
	static LocalBaggageFields empty() {
		return new LocalBaggageFields(Collections.emptyList());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@AutoConfiguration(before = { MicrometerTracingAutoConfiguration.class, NoopTracerAutoConfiguration.class })
@ConditionalOnClass({ Tracer.class, BraveTracer.class })
@EnableConfigurationProperties(TracingProperties.class)
@Import({ BravePropagationConfigurations.PropagationWithoutBaggage.class,
		BravePropagationConfigurations.PropagationWithBaggage.class,
		BravePropagationConfigurations.NoPropagation.class })
public class BraveAutoConfiguration {
	/**
	 * Default value for application name if {@code spring.application.name} is not set.
	 */
	private static final String DEFAULT_APPLICATION_NAME = 'application';
	private final TracingProperties tracingProperties;
	BraveAutoConfiguration(TracingProperties tracingProperties) {
		this.tracingProperties = tracingProperties;
	}
	@Bean
	@ConditionalOnMissingBean
	@Order(Ordered.HIGHEST_PRECEDENCE)
	CompositeSpanHandler compositeSpanHandler(ObjectProvider<SpanExportingPredicate> predicates,
			ObjectProvider<SpanReporter> reporters, ObjectProvider<SpanFilter> filters) {
		return new CompositeSpanHandler(predicates.orderedStream().toList(), reporters.orderedStream().toList(),
				filters.orderedStream().toList());
	}
	@Bean
	@ConditionalOnMissingBean
	Tracing braveTracing(Environment environment, List<SpanHandler> spanHandlers,
			List<TracingCustomizer> tracingCustomizers, CurrentTraceContext currentTraceContext,
			Factory propagationFactory, Sampler sampler) {
		if (this.tracingProperties.getBrave().isSpanJoiningSupported()) {
			if (this.tracingProperties.getPropagation().getType() != null
					&& this.tracingProperties.getPropagation().getType().contains(PropagationType.W3C)) {
				throw new IncompatibleConfigurationException('management.tracing.propagation.type',
						'management.tracing.brave.span-joining-supported');
			}
			if (this.tracingProperties.getPropagation().getType() == null
					&& this.tracingProperties.getPropagation().getProduce().contains(PropagationType.W3C)) {
				throw new IncompatibleConfigurationException('management.tracing.propagation.produce',
						'management.tracing.brave.span-joining-supported');
			}
			if (this.tracingProperties.getPropagation().getType() == null
					&& this.tracingProperties.getPropagation().getConsume().contains(PropagationType.W3C)) {
				throw new IncompatibleConfigurationException('management.tracing.propagation.consume',
						'management.tracing.brave.span-joining-supported');
			}
		}
		String applicationName = environment.getProperty('spring.application.name', DEFAULT_APPLICATION_NAME);
		Builder builder = Tracing.newBuilder()
			.currentTraceContext(currentTraceContext)
			.traceId128Bit(true)
			.supportsJoin(this.tracingProperties.getBrave().isSpanJoiningSupported())
			.propagationFactory(propagationFactory)
			.sampler(sampler)
			.localServiceName(applicationName);
		spanHandlers.forEach(builder::addSpanHandler);
		for (TracingCustomizer tracingCustomizer : tracingCustomizers) {
			tracingCustomizer.customize(builder);
		}
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	brave.Tracer braveTracer(Tracing tracing) {
		return tracing.tracer();
	}
	@Bean
	@ConditionalOnMissingBean
	CurrentTraceContext braveCurrentTraceContext(List<CurrentTraceContext.ScopeDecorator> scopeDecorators,
			List<CurrentTraceContextCustomizer> currentTraceContextCustomizers) {
		ThreadLocalCurrentTraceContext.Builder builder = ThreadLocalCurrentTraceContext.newBuilder();
		scopeDecorators.forEach(builder::addScopeDecorator);
		for (CurrentTraceContextCustomizer currentTraceContextCustomizer : currentTraceContextCustomizers) {
			currentTraceContextCustomizer.customize(builder);
		}
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	Sampler braveSampler() {
		return Sampler.create(this.tracingProperties.getSampling().getProbability());
	}
	@Bean
	@ConditionalOnMissingBean(io.micrometer.tracing.Tracer.class)
	BraveTracer braveTracerBridge(brave.Tracer tracer, CurrentTraceContext currentTraceContext) {
		return new BraveTracer(tracer, new BraveCurrentTraceContext(currentTraceContext),
				new BraveBaggageManager(this.tracingProperties.getBaggage().getTagFields(),
						this.tracingProperties.getBaggage().getRemoteFields()));
	}
	@Bean
	@ConditionalOnMissingBean
	BravePropagator bravePropagator(Tracing tracing) {
		return new BravePropagator(tracing);
	}
	@Bean
	@ConditionalOnMissingBean(SpanCustomizer.class)
	CurrentSpanCustomizer currentSpanCustomizer(Tracing tracing) {
		return CurrentSpanCustomizer.create(tracing);
	}
	@Bean
	@ConditionalOnMissingBean(io.micrometer.tracing.SpanCustomizer.class)
	BraveSpanCustomizer braveSpanCustomizer(SpanCustomizer spanCustomizer) {
		return new BraveSpanCustomizer(spanCustomizer);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnEnabledTracingCondition.class)
public @interface ConditionalOnEnabledTracing {
	/**
	 * Name of the tracing exporter.
	 * @return the name of the tracing exporter
	 * @since 3.4.0
	 */
	String value() default '';
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@FunctionalInterface
public interface SdkTracerProviderBuilderCustomizer {
	/**
	 * Customize the given {@code builder}.
	 * @param builder the builder to customize
	 */
	void customize(SdkTracerProviderBuilder builder);
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class LogCorrelationEnvironmentPostProcessor implements EnvironmentPostProcessor {
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		if (ClassUtils.isPresent('io.micrometer.tracing.Tracer', application.getClassLoader())) {
			environment.getPropertySources().addLast(new LogCorrelationPropertySource(this, environment));
		}
	}
	/**
	 * Log correlation {@link PropertySource}.
	 */
	private static class LogCorrelationPropertySource extends EnumerablePropertySource<Object> {
		private static final String NAME = 'logCorrelation';
		private final Environment environment;
		LogCorrelationPropertySource(Object source, Environment environment) {
			super(NAME, source);
			this.environment = environment;
		}
		@Override
		public String[] getPropertyNames() {
			return new String[] { LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY };
		}
		@Override
		public Object getProperty(String name) {
			if (name.equals(LoggingSystem.EXPECT_CORRELATION_ID_PROPERTY)) {
				return this.environment.getProperty('management.tracing.enabled', Boolean.class, Boolean.TRUE);
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
public class OpenTelemetryEventPublisherBeansApplicationListener implements GenericApplicationListener {
	private static final boolean OTEL_CONTEXT_PRESENT = ClassUtils.isPresent('io.opentelemetry.context.ContextStorage',
			null);
	private static final boolean MICROMETER_OTEL_PRESENT = ClassUtils
		.isPresent('io.micrometer.tracing.otel.bridge.OtelTracer', null);
	private static final AtomicBoolean added = new AtomicBoolean();
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE;
	}
	@Override
	public boolean supportsEventType(ResolvableType eventType) {
		Class<?> type = eventType.getRawClass();
		return (type != null) && (ApplicationStartingEvent.class.isAssignableFrom(type)
				|| ContextRefreshedEvent.class.isAssignableFrom(type)
				|| ContextClosedEvent.class.isAssignableFrom(type));
	}
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (!isInstallable()) {
			return;
		}
		if (event instanceof ApplicationStartingEvent) {
			addWrapper();
		}
		if (event instanceof ContextRefreshedEvent contextRefreshedEvent) {
			ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();
			List<EventPublishingContextWrapper> publishers = applicationContext
				.getBeansOfType(EventPublisher.class, true, false)
				.values()
				.stream()
				.map(EventPublishingContextWrapper::new)
				.toList();
			Wrapper.instance.put(applicationContext, publishers);
		}
		if (event instanceof ContextClosedEvent contextClosedEvent) {
			Wrapper.instance.remove(contextClosedEvent.getApplicationContext());
		}
	}
	/**
	 * {@link ContextStorage#addWrapper(java.util.function.Function) Add} the
	 * {@link ContextStorage} wrapper to ensure that {@link EventPublisher
	 * EventPublishers} are propagated correctly.
	 */
	public static void addWrapper() {
		if (isInstallable() && added.compareAndSet(false, true)) {
			Wrapper.instance.addWrapper();
		}
	}
	private static boolean isInstallable() {
		return OTEL_CONTEXT_PRESENT && MICROMETER_OTEL_PRESENT;
	}
	/**
	 * Single instance class used to add the wrapper and manage the {@link EventPublisher}
	 * beans.
	 */
	static final class Wrapper {
		static final Wrapper instance = new Wrapper();
		private final MultiValueMap<ApplicationContext, EventPublishingContextWrapper> beans = new LinkedMultiValueMap<>();
		private volatile ContextStorage storageDelegate;
		private Wrapper() {
		}
		private void addWrapper() {
			ContextStorage.addWrapper(Storage::new);
		}
		void put(ApplicationContext applicationContext, List<EventPublishingContextWrapper> publishers) {
			synchronized (this) {
				this.beans.addAll(applicationContext, publishers);
				this.storageDelegate = null;
			}
		}
		void remove(ApplicationContext applicationContext) {
			synchronized (this) {
				this.beans.remove(applicationContext);
				this.storageDelegate = null;
			}
		}
		ContextStorage getStorageDelegate(ContextStorage parent) {
			ContextStorage delegate = this.storageDelegate;
			if (delegate == null) {
				synchronized (this) {
					delegate = this.storageDelegate;
					if (delegate == null) {
						delegate = parent;
						for (List<EventPublishingContextWrapper> publishers : this.beans.values()) {
							for (EventPublishingContextWrapper publisher : publishers) {
								delegate = publisher.apply(delegate);
							}
						}
						this.storageDelegate = delegate;
					}
				}
			}
			return delegate;
		}
		/**
		 * {@link ContextStorage} that delegates to the {@link EventPublisher} beans.
		 */
		class Storage implements ContextStorage {
			private final ContextStorage parent;
			Storage(ContextStorage parent) {
				this.parent = parent;
			}
			@Override
			public Scope attach(Context toAttach) {
				return getDelegate().attach(toAttach);
			}
			@Override
			public Context current() {
				return getDelegate().current();
			}
			@Override
			public Context root() {
				return getDelegate().root();
			}
			private ContextStorage getDelegate() {
				return getStorageDelegate(this.parent);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@AutoConfiguration(after = RestTemplateAutoConfiguration.class)
@ConditionalOnClass(Encoding.class)
@Import({ SenderConfiguration.class, BraveConfiguration.class, OpenTelemetryConfiguration.class })
@EnableConfigurationProperties(ZipkinProperties.class)
public class ZipkinAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(ZipkinConnectionDetails.class)
	PropertiesZipkinConnectionDetails zipkinConnectionDetails(ZipkinProperties properties) {
		return new PropertiesZipkinConnectionDetails(properties);
	}
	@Bean
	@ConditionalOnMissingBean
	Encoding encoding(ZipkinProperties properties) {
		return switch (properties.getEncoding()) {
			case JSON -> Encoding.JSON;
			case PROTO3 -> Encoding.PROTO3;
		};
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
class ZipkinWebClientSender extends HttpSender {
	private final WebClient webClient;
	private final Duration timeout;
	ZipkinWebClientSender(Encoding encoding, Factory endpointSupplierFactory, String endpoint, WebClient webClient,
			Duration timeout) {
		super(encoding, endpointSupplierFactory, endpoint);
		this.webClient = webClient;
		this.timeout = timeout;
	}
	@Override
	void postSpans(URI endpoint, MultiValueMap<String, String> headers, byte[] body) {
		this.webClient.post()
			.uri(endpoint)
			.headers((h) -> h.addAll(headers))
			.bodyValue(body)
			.retrieve()
			.toBodilessEntity()
			.timeout(this.timeout)
			.block();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@FunctionalInterface
@Deprecated(since = '3.3.0', forRemoval = true)
public interface ZipkinWebClientBuilderCustomizer {
	/**
	 * Customize the web client builder.
	 * @param webClientBuilder the {@code WebClient.Builder} to customize
	 */
	void customize(WebClient.Builder webClientBuilder);
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@FunctionalInterface
public interface ZipkinHttpClientBuilderCustomizer {
	/**
	 * Customize the http client builder.
	 * @param httpClient the http client builder to customize
	 */
	void customize(Builder httpClient);
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@ConfigurationProperties('management.zipkin.tracing')
public class ZipkinProperties {
	/**
	 * URL to the Zipkin API.
	 */
	private String endpoint = 'http://localhost:9411/api/v2/spans';
	/**
	 * How to encode the POST body to the Zipkin API.
	 */
	private Encoding encoding = Encoding.JSON;
	/**
	 * Connection timeout for requests to Zipkin.
	 */
	private Duration connectTimeout = Duration.ofSeconds(1);
	/**
	 * Read timeout for requests to Zipkin.
	 */
	private Duration readTimeout = Duration.ofSeconds(10);
	public String getEndpoint() {
		return this.endpoint;
	}
	public void setEndpoint(String endpoint) {
		this.endpoint = endpoint;
	}
	public Encoding getEncoding() {
		return this.encoding;
	}
	public void setEncoding(Encoding encoding) {
		this.encoding = encoding;
	}
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public Duration getReadTimeout() {
		return this.readTimeout;
	}
	public void setReadTimeout(Duration readTimeout) {
		this.readTimeout = readTimeout;
	}
	/**
	 * Zipkin message encoding.
	 */
	public enum Encoding {
		/**
		 * JSON.
		 */
		JSON,
		/**
		 * Protocol Buffers v3.
		 */
		PROTO3
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
class ZipkinRestTemplateSender extends HttpSender {
	private final RestTemplate restTemplate;
	ZipkinRestTemplateSender(Encoding encoding, Factory endpointSupplierFactory, String endpoint,
			RestTemplate restTemplate) {
		super(encoding, endpointSupplierFactory, endpoint);
		this.restTemplate = restTemplate;
	}
	@Override
	void postSpans(URI endpoint, MultiValueMap<String, String> headers, byte[] body) {
		HttpEntity<byte[]> request = new HttpEntity<>(body, headers);
		this.restTemplate.exchange(endpoint, HttpMethod.POST, request, Void.class);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
public interface ZipkinConnectionDetails extends ConnectionDetails {
	/**
	 * The endpoint for the span reporting.
	 * @return the endpoint
	 */
	String getSpanEndpoint();
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class PropertiesZipkinConnectionDetails implements ZipkinConnectionDetails {
	private final ZipkinProperties properties;
	PropertiesZipkinConnectionDetails(ZipkinProperties properties) {
		this.properties = properties;
	}
	@Override
	public String getSpanEndpoint() {
		return this.properties.getEndpoint();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class ZipkinConfigurations {
	@Configuration(proxyBeanMethods = false)
	@Import({ UrlConnectionSenderConfiguration.class, WebClientSenderConfiguration.class,
			RestTemplateSenderConfiguration.class, HttpClientSenderConfiguration.class })
	static class SenderConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(URLConnectionSender.class)
	@EnableConfigurationProperties(ZipkinProperties.class)
	static class UrlConnectionSenderConfiguration {
		@Bean
		@ConditionalOnMissingBean(BytesMessageSender.class)
		URLConnectionSender urlConnectionSender(ZipkinProperties properties, Encoding encoding,
				ObjectProvider<ZipkinConnectionDetails> connectionDetailsProvider,
				ObjectProvider<HttpEndpointSupplier.Factory> endpointSupplierFactoryProvider) {
			ZipkinConnectionDetails connectionDetails = connectionDetailsProvider
				.getIfAvailable(() -> new PropertiesZipkinConnectionDetails(properties));
			HttpEndpointSupplier.Factory endpointSupplierFactory = endpointSupplierFactoryProvider
				.getIfAvailable(HttpEndpointSuppliers::constantFactory);
			URLConnectionSender.Builder builder = URLConnectionSender.newBuilder();
			builder.connectTimeout((int) properties.getConnectTimeout().toMillis());
			builder.readTimeout((int) properties.getReadTimeout().toMillis());
			builder.endpointSupplierFactory(endpointSupplierFactory);
			builder.endpoint(connectionDetails.getSpanEndpoint());
			builder.encoding(encoding);
			return builder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(RestTemplate.class)
	@EnableConfigurationProperties(ZipkinProperties.class)
	static class RestTemplateSenderConfiguration {
		@Bean
		@ConditionalOnMissingBean(BytesMessageSender.class)
		@SuppressWarnings({ 'deprecation', 'removal' })
		ZipkinRestTemplateSender restTemplateSender(ZipkinProperties properties, Encoding encoding,
				ObjectProvider<ZipkinRestTemplateBuilderCustomizer> customizers,
				ObjectProvider<ZipkinConnectionDetails> connectionDetailsProvider,
				ObjectProvider<HttpEndpointSupplier.Factory> endpointSupplierFactoryProvider) {
			ZipkinConnectionDetails connectionDetails = connectionDetailsProvider
				.getIfAvailable(() -> new PropertiesZipkinConnectionDetails(properties));
			HttpEndpointSupplier.Factory endpointSupplierFactory = endpointSupplierFactoryProvider
				.getIfAvailable(HttpEndpointSuppliers::constantFactory);
			RestTemplateBuilder restTemplateBuilder = new RestTemplateBuilder()
				.setConnectTimeout(properties.getConnectTimeout())
				.setReadTimeout(properties.getReadTimeout());
			restTemplateBuilder = applyCustomizers(restTemplateBuilder, customizers);
			return new ZipkinRestTemplateSender(encoding, endpointSupplierFactory, connectionDetails.getSpanEndpoint(),
					restTemplateBuilder.build());
		}
		@SuppressWarnings({ 'deprecation', 'removal' })
		private RestTemplateBuilder applyCustomizers(RestTemplateBuilder restTemplateBuilder,
				ObjectProvider<ZipkinRestTemplateBuilderCustomizer> customizers) {
			Iterable<ZipkinRestTemplateBuilderCustomizer> orderedCustomizers = () -> customizers.orderedStream()
				.iterator();
			RestTemplateBuilder currentBuilder = restTemplateBuilder;
			for (ZipkinRestTemplateBuilderCustomizer customizer : orderedCustomizers) {
				currentBuilder = customizer.customize(currentBuilder);
			}
			return currentBuilder;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(WebClient.class)
	@EnableConfigurationProperties(ZipkinProperties.class)
	static class WebClientSenderConfiguration {
		@Bean
		@ConditionalOnMissingBean(BytesMessageSender.class)
		@SuppressWarnings({ 'deprecation', 'removal' })
		ZipkinWebClientSender webClientSender(ZipkinProperties properties, Encoding encoding,
				ObjectProvider<ZipkinWebClientBuilderCustomizer> customizers,
				ObjectProvider<ZipkinConnectionDetails> connectionDetailsProvider,
				ObjectProvider<HttpEndpointSupplier.Factory> endpointSupplierFactoryProvider) {
			ZipkinConnectionDetails connectionDetails = connectionDetailsProvider
				.getIfAvailable(() -> new PropertiesZipkinConnectionDetails(properties));
			HttpEndpointSupplier.Factory endpointSupplierFactory = endpointSupplierFactoryProvider
				.getIfAvailable(HttpEndpointSuppliers::constantFactory);
			WebClient.Builder builder = WebClient.builder();
			customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
			return new ZipkinWebClientSender(encoding, endpointSupplierFactory, connectionDetails.getSpanEndpoint(),
					builder.build(), properties.getConnectTimeout().plus(properties.getReadTimeout()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HttpClient.class)
	@EnableConfigurationProperties(ZipkinProperties.class)
	static class HttpClientSenderConfiguration {
		@Bean
		@ConditionalOnMissingBean(BytesMessageSender.class)
		ZipkinHttpClientSender httpClientSender(ZipkinProperties properties, Encoding encoding,
				ObjectProvider<ZipkinHttpClientBuilderCustomizer> customizers,
				ObjectProvider<ZipkinConnectionDetails> connectionDetailsProvider,
				ObjectProvider<HttpEndpointSupplier.Factory> endpointSupplierFactoryProvider) {
			ZipkinConnectionDetails connectionDetails = connectionDetailsProvider
				.getIfAvailable(() -> new PropertiesZipkinConnectionDetails(properties));
			HttpEndpointSupplier.Factory endpointSupplierFactory = endpointSupplierFactoryProvider
				.getIfAvailable(HttpEndpointSuppliers::constantFactory);
			Builder httpClientBuilder = HttpClient.newBuilder().connectTimeout(properties.getConnectTimeout());
			customizers.orderedStream().forEach((customizer) -> customizer.customize(httpClientBuilder));
			return new ZipkinHttpClientSender(encoding, endpointSupplierFactory, connectionDetails.getSpanEndpoint(),
					httpClientBuilder.build(), properties.getReadTimeout());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(AsyncZipkinSpanHandler.class)
	static class BraveConfiguration {
		@Bean
		@ConditionalOnMissingBean(value = MutableSpan.class, parameterizedContainer = BytesEncoder.class)
		BytesEncoder<MutableSpan> mutableSpanBytesEncoder(Encoding encoding,
				ObjectProvider<Tag<Throwable>> throwableTagProvider) {
			Tag<Throwable> throwableTag = throwableTagProvider.getIfAvailable(() -> Tags.ERROR);
			return MutableSpanBytesEncoder.create(encoding, throwableTag);
		}
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnBean(BytesMessageSender.class)
		@ConditionalOnEnabledTracing('zipkin')
		AsyncZipkinSpanHandler asyncZipkinSpanHandler(BytesMessageSender sender,
				BytesEncoder<MutableSpan> mutableSpanBytesEncoder) {
			return AsyncZipkinSpanHandler.newBuilder(sender).build(mutableSpanBytesEncoder);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ ZipkinSpanExporter.class, Span.class })
	static class OpenTelemetryConfiguration {
		@Bean
		@ConditionalOnMissingBean(value = Span.class, parameterizedContainer = BytesEncoder.class)
		BytesEncoder<Span> spanBytesEncoder(Encoding encoding) {
			return SpanBytesEncoder.forEncoding(encoding);
		}
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnBean(BytesMessageSender.class)
		@ConditionalOnEnabledTracing('zipkin')
		ZipkinSpanExporter zipkinSpanExporter(BytesMessageSender sender, BytesEncoder<Span> spanBytesEncoder) {
			return ZipkinSpanExporter.builder().setSender(sender).setEncoder(spanBytesEncoder).build();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
abstract class HttpSender extends BaseHttpSender<URI, byte[]> {
	/**
	 * Only use gzip compression on data which is bigger than this in bytes.
	 */
	private static final DataSize COMPRESSION_THRESHOLD = DataSize.ofKilobytes(1);
	HttpSender(Encoding encoding, Factory endpointSupplierFactory, String endpoint) {
		super(encoding, endpointSupplierFactory, endpoint);
	}
	@Override
	protected URI newEndpoint(String endpoint) {
		return URI.create(endpoint);
	}
	@Override
	protected byte[] newBody(List<byte[]> list) {
		return this.encoding.encode(list);
	}
	@Override
	protected void postSpans(URI endpoint, byte[] body) throws IOException {
		MultiValueMap<String, String> headers = getDefaultHeaders();
		if (needsCompression(body)) {
			body = compress(body);
			headers.add('Content-Encoding', 'gzip');
		}
		postSpans(endpoint, headers, body);
	}
	abstract void postSpans(URI endpoint, MultiValueMap<String, String> headers, byte[] body) throws IOException;
	MultiValueMap<String, String> getDefaultHeaders() {
		MultiValueMap<String, String> headers = new LinkedMultiValueMap<>();
		headers.add('b3', '0');
		headers.add('Content-Type', this.encoding.mediaType());
		return headers;
	}
	private boolean needsCompression(byte[] body) {
		return body.length > COMPRESSION_THRESHOLD.toBytes();
	}
	private byte[] compress(byte[] input) throws IOException {
		ByteArrayOutputStream result = new ByteArrayOutputStream();
		try (GZIPOutputStream gzip = new GZIPOutputStream(result)) {
			gzip.write(input);
		}
		return result.toByteArray();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
class ZipkinHttpClientSender extends HttpSender {
	private final HttpClient httpClient;
	private final Duration readTimeout;
	ZipkinHttpClientSender(Encoding encoding, Factory endpointSupplierFactory, String endpoint, HttpClient httpClient,
			Duration readTimeout) {
		super(encoding, endpointSupplierFactory, endpoint);
		this.httpClient = httpClient;
		this.readTimeout = readTimeout;
	}
	@Override
	void postSpans(URI endpoint, MultiValueMap<String, String> headers, byte[] body) throws IOException {
		Builder request = HttpRequest.newBuilder()
			.POST(BodyPublishers.ofByteArray(body))
			.uri(endpoint)
			.timeout(this.readTimeout);
		headers.forEach((name, values) -> values.forEach((value) -> request.header(name, value)));
		try {
			HttpResponse<Void> response = this.httpClient.send(request.build(), BodyHandlers.discarding());
			if (response.statusCode() / 100 != 2) {
				throw new IOException('Expected HTTP status 2xx, got %d'.formatted(response.statusCode()));
			}
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			throw new IOException('Got interrupted while sending spans', ex);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/**
@FunctionalInterface
@Deprecated(since = '3.3.0', forRemoval = true)
public interface ZipkinRestTemplateBuilderCustomizer {
	/**
	 * Customize the rest template builder.
	 * @param restTemplateBuilder the {@code RestTemplateBuilder} to customize
	 * @return the customized {@code RestTemplateBuilder}
	 */
	RestTemplateBuilder customize(RestTemplateBuilder restTemplateBuilder);
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.tracing.zipkin;
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@AutoConfiguration(before = { MicrometerTracingAutoConfiguration.class, NoopTracerAutoConfiguration.class })
@ConditionalOnClass({ OtelTracer.class, SdkTracerProvider.class, OpenTelemetry.class })
@EnableConfigurationProperties(TracingProperties.class)
@Import({ OpenTelemetryPropagationConfigurations.PropagationWithoutBaggage.class,
		OpenTelemetryPropagationConfigurations.PropagationWithBaggage.class,
		OpenTelemetryPropagationConfigurations.NoPropagation.class })
public class OpenTelemetryTracingAutoConfiguration {
	private static final Log logger = LogFactory.getLog(OpenTelemetryTracingAutoConfiguration.class);
	private final TracingProperties tracingProperties;
	OpenTelemetryTracingAutoConfiguration(TracingProperties tracingProperties) {
		this.tracingProperties = tracingProperties;
		if (!CollectionUtils.isEmpty(this.tracingProperties.getBaggage().getLocalFields())) {
			logger.warn('Local fields are not supported when using OpenTelemetry!');
		}
	}
	@Bean
	@ConditionalOnMissingBean
	SdkTracerProvider otelSdkTracerProvider(Resource resource, SpanProcessors spanProcessors, Sampler sampler,
			ObjectProvider<SdkTracerProviderBuilderCustomizer> customizers) {
		SdkTracerProviderBuilder builder = SdkTracerProvider.builder().setSampler(sampler).setResource(resource);
		spanProcessors.forEach(builder::addSpanProcessor);
		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	ContextPropagators otelContextPropagators(ObjectProvider<TextMapPropagator> textMapPropagators) {
		return ContextPropagators.create(TextMapPropagator.composite(textMapPropagators.orderedStream().toList()));
	}
	@Bean
	@ConditionalOnMissingBean
	Sampler otelSampler() {
		Sampler rootSampler = Sampler.traceIdRatioBased(this.tracingProperties.getSampling().getProbability());
		return Sampler.parentBased(rootSampler);
	}
	@Bean
	@ConditionalOnMissingBean
	SpanProcessors spanProcessors(ObjectProvider<SpanProcessor> spanProcessors) {
		return SpanProcessors.of(spanProcessors.orderedStream().toList());
	}
	@Bean
	BatchSpanProcessor otelSpanProcessor(SpanExporters spanExporters,
			ObjectProvider<SpanExportingPredicate> spanExportingPredicates, ObjectProvider<SpanReporter> spanReporters,
			ObjectProvider<SpanFilter> spanFilters, ObjectProvider<MeterProvider> meterProvider) {
		BatchSpanProcessorBuilder builder = BatchSpanProcessor
			.builder(new CompositeSpanExporter(spanExporters.list(), spanExportingPredicates.orderedStream().toList(),
					spanReporters.orderedStream().toList(), spanFilters.orderedStream().toList()));
		meterProvider.ifAvailable(builder::setMeterProvider);
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	SpanExporters spanExporters(ObjectProvider<SpanExporter> spanExporters) {
		return SpanExporters.of(spanExporters.orderedStream().toList());
	}
	@Bean
	@ConditionalOnMissingBean
	Tracer otelTracer(OpenTelemetry openTelemetry) {
		return openTelemetry.getTracer('org.springframework.boot', SpringBootVersion.getVersion());
	}
	@Bean
	@ConditionalOnMissingBean(io.micrometer.tracing.Tracer.class)
	OtelTracer micrometerOtelTracer(Tracer tracer, EventPublisher eventPublisher,
			OtelCurrentTraceContext otelCurrentTraceContext) {
		List<String> remoteFields = this.tracingProperties.getBaggage().getRemoteFields();
		List<String> tagFields = this.tracingProperties.getBaggage().getTagFields();
		return new OtelTracer(tracer, otelCurrentTraceContext, eventPublisher,
				new OtelBaggageManager(otelCurrentTraceContext, remoteFields, tagFields));
	}
	@Bean
	@ConditionalOnMissingBean
	OtelPropagator otelPropagator(ContextPropagators contextPropagators, Tracer tracer) {
		return new OtelPropagator(contextPropagators, tracer);
	}
	@Bean
	@ConditionalOnMissingBean
	EventPublisher otelTracerEventPublisher(List<EventListener> eventListeners) {
		return new OTelEventPublisher(eventListeners);
	}
	@Bean
	@ConditionalOnMissingBean
	OtelCurrentTraceContext otelCurrentTraceContext() {
		return new OtelCurrentTraceContext();
	}
	@Bean
	@ConditionalOnMissingBean
	Slf4JEventListener otelSlf4JEventListener() {
		return new Slf4JEventListener();
	}
	@Bean
	@ConditionalOnMissingBean(SpanCustomizer.class)
	OtelSpanCustomizer otelSpanCustomizer() {
		return new OtelSpanCustomizer();
	}
	static class OTelEventPublisher implements EventPublisher {
		private final List<EventListener> listeners;
		OTelEventPublisher(List<EventListener> listeners) {
			this.listeners = listeners;
		}
		@Override
		public void publishEvent(Object event) {
			for (EventListener listener : this.listeners) {
				listener.onEvent(event);
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@AutoConfiguration
@ConditionalOnClass(Tracer.class)
@ConditionalOnBean(Tracer.class)
public class MicrometerTracingAutoConfiguration {
	/**
	 * {@code @Order} value of {@link #defaultTracingObservationHandler(Tracer)}.
	 */
	public static final int DEFAULT_TRACING_OBSERVATION_HANDLER_ORDER = Ordered.LOWEST_PRECEDENCE - 1000;
	/**
	 * {@code @Order} value of
	 * {@link #propagatingReceiverTracingObservationHandler(Tracer, Propagator)}.
	 */
	public static final int RECEIVER_TRACING_OBSERVATION_HANDLER_ORDER = 1000;
	/**
	 * {@code @Order} value of
	 * {@link #propagatingSenderTracingObservationHandler(Tracer, Propagator)}.
	 */
	public static final int SENDER_TRACING_OBSERVATION_HANDLER_ORDER = 2000;
	@Bean
	@ConditionalOnMissingBean
	@Order(DEFAULT_TRACING_OBSERVATION_HANDLER_ORDER)
	public DefaultTracingObservationHandler defaultTracingObservationHandler(Tracer tracer) {
		return new DefaultTracingObservationHandler(tracer);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(Propagator.class)
	@Order(SENDER_TRACING_OBSERVATION_HANDLER_ORDER)
	public PropagatingSenderTracingObservationHandler<?> propagatingSenderTracingObservationHandler(Tracer tracer,
			Propagator propagator) {
		return new PropagatingSenderTracingObservationHandler<>(tracer, propagator);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(Propagator.class)
	@Order(RECEIVER_TRACING_OBSERVATION_HANDLER_ORDER)
	public PropagatingReceiverTracingObservationHandler<?> propagatingReceiverTracingObservationHandler(Tracer tracer,
			Propagator propagator) {
		return new PropagatingReceiverTracingObservationHandler<>(tracer, propagator);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Advice.class)
	@Conditional(ObservationAnnotationsEnabledCondition.class)
	static class SpanAspectConfiguration {
		@Bean
		@ConditionalOnMissingBean(NewSpanParser.class)
		DefaultNewSpanParser newSpanParser() {
			return new DefaultNewSpanParser();
		}
		@Bean
		@ConditionalOnMissingBean
		SpanTagAnnotationHandler spanTagAnnotationHandler(BeanFactory beanFactory) {
			ValueExpressionResolver valueExpressionResolver = new SpelTagValueExpressionResolver();
			return new SpanTagAnnotationHandler(beanFactory::getBean, (ignored) -> valueExpressionResolver);
		}
		@Bean
		@ConditionalOnMissingBean(MethodInvocationProcessor.class)
		ImperativeMethodInvocationProcessor imperativeMethodInvocationProcessor(NewSpanParser newSpanParser,
				Tracer tracer, SpanTagAnnotationHandler spanTagAnnotationHandler) {
			return new ImperativeMethodInvocationProcessor(newSpanParser, tracer, spanTagAnnotationHandler);
		}
		@Bean
		@ConditionalOnMissingBean
		SpanAspect spanAspect(MethodInvocationProcessor methodInvocationProcessor) {
			return new SpanAspect(methodInvocationProcessor);
		}
	}
	private static final class SpelTagValueExpressionResolver implements ValueExpressionResolver {
		@Override
		public String resolve(String expression, Object parameter) {
			try {
				SimpleEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
				ExpressionParser expressionParser = new SpelExpressionParser();
				Expression expressionToEvaluate = expressionParser.parseExpression(expression);
				return expressionToEvaluate.getValue(context, parameter, String.class);
			}
			catch (Exception ex) {
				throw new IllegalStateException('Unable to evaluate SpEL expression "%s"'.formatted(expression), ex);
			}
		}
	}
	static final class ObservationAnnotationsEnabledCondition extends AnyNestedCondition {
		ObservationAnnotationsEnabledCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty(prefix = 'micrometer.observations.annotations', name = 'enabled', havingValue = 'true')
		static class MicrometerObservationsEnabledCondition {
		}
		@ConditionalOnProperty(prefix = 'management.observations.annotations', name = 'enabled', havingValue = 'true')
		static class ManagementObservationsEnabledCondition {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.prometheus;
/**
@AutoConfiguration(before = PrometheusMetricsExportAutoConfiguration.class,
		after = MicrometerTracingAutoConfiguration.class)
@ConditionalOnBean(Tracer.class)
@ConditionalOnClass({ Tracer.class, SpanContext.class })
public class PrometheusExemplarsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	SpanContext spanContext(ObjectProvider<Tracer> tracerProvider) {
		return new LazyTracingSpanContext(tracerProvider);
	}
	/**
	 * Since the MeterRegistry can depend on the {@link Tracer} (Exemplars) and the
	 * {@link Tracer} can depend on the MeterRegistry (recording metrics), this
	 * {@link SpanContext} breaks the cycle by lazily loading the {@link Tracer}.
	 */
	static class LazyTracingSpanContext implements SpanContext {
		private final SingletonSupplier<Tracer> tracer;
		LazyTracingSpanContext(ObjectProvider<Tracer> tracerProvider) {
			this.tracer = SingletonSupplier.of(tracerProvider::getObject);
		}
		@Override
		public String getCurrentTraceId() {
			Span currentSpan = currentSpan();
			return (currentSpan != null) ? currentSpan.context().traceId() : null;
		}
		@Override
		public String getCurrentSpanId() {
			Span currentSpan = currentSpan();
			return (currentSpan != null) ? currentSpan.context().spanId() : null;
		}
		@Override
		public boolean isCurrentSpanSampled() {
			Span currentSpan = currentSpan();
			if (currentSpan == null) {
				return false;
			}
			Boolean sampled = currentSpan.context().sampled();
			return sampled != null && sampled;
		}
		@Override
		public void markCurrentSpanAsExemplar() {
		}
		private Span currentSpan() {
			return this.tracer.obtain().currentSpan();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.prometheus;
/**
@SuppressWarnings('removal')
@Deprecated(forRemoval = true, since = '3.3.0')
@AutoConfiguration(before = PrometheusSimpleclientMetricsExportAutoConfiguration.class,
		after = MicrometerTracingAutoConfiguration.class)
@ConditionalOnBean(Tracer.class)
@ConditionalOnClass({ Tracer.class, SpanContextSupplier.class })
public class PrometheusSimpleclientExemplarsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	SpanContextSupplier spanContextSupplier(ObjectProvider<Tracer> tracerProvider) {
		return new LazyTracingSpanContextSupplier(tracerProvider);
	}
	/**
	 * Since the MeterRegistry can depend on the {@link Tracer} (Exemplars) and the
	 * {@link Tracer} can depend on the MeterRegistry (recording metrics), this
	 * {@link SpanContextSupplier} breaks the cycle by lazily loading the {@link Tracer}.
	 */
	static class LazyTracingSpanContextSupplier implements SpanContextSupplier {
		private final SingletonSupplier<Tracer> tracer;
		LazyTracingSpanContextSupplier(ObjectProvider<Tracer> tracerProvider) {
			this.tracer = SingletonSupplier.of(tracerProvider::getObject);
		}
		@Override
		public String getTraceId() {
			Span currentSpan = currentSpan();
			return (currentSpan != null) ? currentSpan.context().traceId() : null;
		}
		@Override
		public String getSpanId() {
			Span currentSpan = currentSpan();
			return (currentSpan != null) ? currentSpan.context().spanId() : null;
		}
		@Override
		public boolean isSampled() {
			Span currentSpan = currentSpan();
			if (currentSpan == null) {
				return false;
			}
			Boolean sampled = currentSpan.context().sampled();
			return sampled != null && sampled;
		}
		private Span currentSpan() {
			return this.tracer.obtain().currentSpan();
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.tracing.prometheus;
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@ConfigurationProperties('management.tracing')
public class TracingProperties {
	/**
	 * Sampling configuration.
	 */
	private final Sampling sampling = new Sampling();
	/**
	 * Baggage configuration.
	 */
	private final Baggage baggage = new Baggage();
	/**
	 * Propagation configuration.
	 */
	private final Propagation propagation = new Propagation();
	/**
	 * Brave configuration.
	 */
	private final Brave brave = new Brave();
	public Sampling getSampling() {
		return this.sampling;
	}
	public Baggage getBaggage() {
		return this.baggage;
	}
	public Propagation getPropagation() {
		return this.propagation;
	}
	public Brave getBrave() {
		return this.brave;
	}
	public static class Sampling {
		/**
		 * Probability in the range from 0.0 to 1.0 that a trace will be sampled.
		 */
		private float probability = 0.10f;
		public float getProbability() {
			return this.probability;
		}
		public void setProbability(float probability) {
			this.probability = probability;
		}
	}
	public static class Baggage {
		/**
		 * Whether to enable Micrometer Tracing baggage propagation.
		 */
		private boolean enabled = true;
		/**
		 * Correlation configuration.
		 */
		private Correlation correlation = new Correlation();
		/**
		 * List of fields that are referenced the same in-process as it is on the wire.
		 * For example, the field 'x-vcap-request-id' would be set as-is including the
		 * prefix.
		 */
		private List<String> remoteFields = new ArrayList<>();
		/**
		 * List of fields that should be accessible within the JVM process but not
		 * propagated over the wire. Local fields are not supported with OpenTelemetry.
		 */
		private List<String> localFields = new ArrayList<>();
		/**
		 * List of fields that should automatically become tags.
		 */
		private List<String> tagFields = new ArrayList<>();
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public Correlation getCorrelation() {
			return this.correlation;
		}
		public void setCorrelation(Correlation correlation) {
			this.correlation = correlation;
		}
		public List<String> getRemoteFields() {
			return this.remoteFields;
		}
		public List<String> getLocalFields() {
			return this.localFields;
		}
		public List<String> getTagFields() {
			return this.tagFields;
		}
		public void setRemoteFields(List<String> remoteFields) {
			this.remoteFields = remoteFields;
		}
		public void setLocalFields(List<String> localFields) {
			this.localFields = localFields;
		}
		public void setTagFields(List<String> tagFields) {
			this.tagFields = tagFields;
		}
		public static class Correlation {
			/**
			 * Whether to enable correlation of the baggage context with logging contexts.
			 */
			private boolean enabled = true;
			/**
			 * List of fields that should be correlated with the logging context. That
			 * means that these fields would end up as key-value pairs in e.g. MDC.
			 */
			private List<String> fields = new ArrayList<>();
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
			public List<String> getFields() {
				return this.fields;
			}
			public void setFields(List<String> fields) {
				this.fields = fields;
			}
		}
	}
	public static class Propagation {
		/**
		 * Tracing context propagation types produced and consumed by the application.
		 * Setting this property overrides the more fine-grained propagation type
		 * properties.
		 */
		private List<PropagationType> type;
		/**
		 * Tracing context propagation types produced by the application.
		 */
		private List<PropagationType> produce = List.of(PropagationType.W3C);
		/**
		 * Tracing context propagation types consumed by the application.
		 */
		private List<PropagationType> consume = List.of(PropagationType.values());
		public void setType(List<PropagationType> type) {
			this.type = type;
		}
		public void setProduce(List<PropagationType> produce) {
			this.produce = produce;
		}
		public void setConsume(List<PropagationType> consume) {
			this.consume = consume;
		}
		public List<PropagationType> getType() {
			return this.type;
		}
		public List<PropagationType> getProduce() {
			return this.produce;
		}
		public List<PropagationType> getConsume() {
			return this.consume;
		}
		/**
		 * Returns the effective context propagation types produced by the application.
		 * This will be {@link #getType()} if set or {@link #getProduce()} otherwise.
		 * @return the effective context propagation types produced by the application
		 */
		List<PropagationType> getEffectiveProducedTypes() {
			return (this.type != null) ? this.type : this.produce;
		}
		/**
		 * Returns the effective context propagation types consumed by the application.
		 * This will be {@link #getType()} if set or {@link #getConsume()} otherwise.
		 * @return the effective context propagation types consumed by the application
		 */
		List<PropagationType> getEffectiveConsumedTypes() {
			return (this.type != null) ? this.type : this.consume;
		}
		/**
		 * Supported propagation types. The declared order of the values matter.
		 */
		public enum PropagationType {
			/**
			 * <a href='https://www.w3.org/TR/trace-context/'>W3C</a> propagation.
			 */
			W3C,
			/**
			 * <a href='https://github.com/openzipkin/b3-propagation#single-header'>B3
			 * single header</a> propagation.
			 */
			B3,
			/**
			 * <a href='https://github.com/openzipkin/b3-propagation#multiple-headers'>B3
			 * multiple headers</a> propagation.
			 */
			B3_MULTI
		}
	}
	public static class Brave {
		/**
		 * Whether the propagation type and tracing backend support sharing the span ID
		 * between client and server spans. Requires B3 propagation and a compatible
		 * backend.
		 */
		private boolean spanJoiningSupported = false;
		public boolean isSpanJoiningSupported() {
			return this.spanJoiningSupported;
		}
		public void setSpanJoiningSupported(boolean spanJoiningSupported) {
			this.spanJoiningSupported = spanJoiningSupported;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
public class OpenTelemetryEventPublisherBeansTestExecutionListener implements TestExecutionListener {
	@Override
	public void executionStarted(TestIdentifier testIdentifier) {
		OpenTelemetryEventPublisherBeansApplicationListener.addWrapper();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class CompositePropagationFactory extends Propagation.Factory {
	private final PropagationFactories injectors;
	private final PropagationFactories extractors;
	private final CompositePropagation propagation;
	CompositePropagationFactory(Collection<Factory> injectorFactories, Collection<Factory> extractorFactories) {
		this.injectors = new PropagationFactories(injectorFactories);
		this.extractors = new PropagationFactories(extractorFactories);
		this.propagation = new CompositePropagation(this.injectors, this.extractors);
	}
	Stream<Factory> getInjectors() {
		return this.injectors.stream();
	}
	@Override
	public boolean supportsJoin() {
		return this.injectors.supportsJoin() && this.extractors.supportsJoin();
	}
	@Override
	public boolean requires128BitTraceId() {
		return this.injectors.requires128BitTraceId() || this.extractors.requires128BitTraceId();
	}
	@Override
	public Propagation<String> get() {
		return this.propagation;
	}
	@Override
	public TraceContext decorate(TraceContext context) {
		return Stream.concat(this.injectors.stream(), this.extractors.stream())
			.map((factory) -> factory.decorate(context))
			.filter((decorated) -> decorated != context)
			.findFirst()
			.orElse(context);
	}
	/**
	 * Creates a new {@link CompositePropagationFactory} which doesn"t do any propagation.
	 * @return the {@link CompositePropagationFactory}
	 */
	static CompositePropagationFactory noop() {
		return new CompositePropagationFactory(Collections.emptyList(), Collections.emptyList());
	}
	/**
	 * Creates a new {@link CompositePropagationFactory}.
	 * @param properties the propagation properties
	 * @return the {@link CompositePropagationFactory}
	 */
	static CompositePropagationFactory create(TracingProperties.Propagation properties) {
		return create(properties, null, null);
	}
	/**
	 * Creates a new {@link CompositePropagationFactory}.
	 * @param properties the propagation properties
	 * @param baggageManager the baggage manager to use, or {@code null}
	 * @param localFields the local fields, or {@code null}
	 * @return the {@link CompositePropagationFactory}
	 */
	static CompositePropagationFactory create(TracingProperties.Propagation properties, BaggageManager baggageManager,
			LocalBaggageFields localFields) {
		PropagationFactoryMapper mapper = new PropagationFactoryMapper(baggageManager, localFields);
		List<Factory> injectors = properties.getEffectiveProducedTypes().stream().map(mapper::map).toList();
		List<Factory> extractors = properties.getEffectiveConsumedTypes().stream().map(mapper::map).toList();
		return new CompositePropagationFactory(injectors, extractors);
	}
	/**
	 * Mapper used to create a {@link brave.propagation.Propagation.Factory Propagation
	 * factory} from a {@link PropagationType}.
	 */
	private static class PropagationFactoryMapper {
		private final BaggageManager baggageManager;
		private final LocalBaggageFields localFields;
		PropagationFactoryMapper(BaggageManager baggageManager, LocalBaggageFields localFields) {
			this.baggageManager = baggageManager;
			this.localFields = (localFields != null) ? localFields : LocalBaggageFields.empty();
		}
		Propagation.Factory map(PropagationType type) {
			return switch (type) {
				case B3 -> b3Single();
				case B3_MULTI -> b3Multi();
				case W3C -> w3c();
			};
		}
		/**
		 * Creates a new B3 propagation factory using a single B3 header.
		 * @return the B3 propagation factory
		 */
		private Propagation.Factory b3Single() {
			return B3Propagation.newFactoryBuilder().injectFormat(B3Propagation.Format.SINGLE).build();
		}
		/**
		 * Creates a new B3 propagation factory using multiple B3 headers.
		 * @return the B3 propagation factory
		 */
		private Propagation.Factory b3Multi() {
			return B3Propagation.newFactoryBuilder().injectFormat(B3Propagation.Format.MULTI).build();
		}
		/**
		 * Creates a new W3C propagation factory.
		 * @return the W3C propagation factory
		 */
		private Propagation.Factory w3c() {
			if (this.baggageManager == null) {
				return new W3CPropagation();
			}
			return new W3CPropagation(this.baggageManager, this.localFields.asList());
		}
	}
	/**
	 * A collection of propagation factories.
	 */
	private static class PropagationFactories {
		private final List<Propagation.Factory> factories;
		PropagationFactories(Collection<Factory> factories) {
			this.factories = List.copyOf(factories);
		}
		boolean requires128BitTraceId() {
			return stream().anyMatch(Propagation.Factory::requires128BitTraceId);
		}
		boolean supportsJoin() {
			return stream().allMatch(Propagation.Factory::supportsJoin);
		}
		List<Propagation<String>> get() {
			return stream().map(Factory::get).toList();
		}
		Stream<Factory> stream() {
			return this.factories.stream();
		}
	}
	/**
	 * A composite {@link Propagation}.
	 */
	private static class CompositePropagation implements Propagation<String> {
		private final List<Propagation<String>> injectors;
		private final List<Propagation<String>> extractors;
		private final List<String> keys;
		CompositePropagation(PropagationFactories injectorFactories, PropagationFactories extractorFactories) {
			this.injectors = injectorFactories.get();
			this.extractors = extractorFactories.get();
			this.keys = Stream.concat(keys(this.injectors), keys(this.extractors)).distinct().toList();
		}
		private Stream<String> keys(List<Propagation<String>> propagations) {
			return propagations.stream().flatMap((propagation) -> propagation.keys().stream());
		}
		@Override
		public List<String> keys() {
			return this.keys;
		}
		@Override
		public <R> TraceContext.Injector<R> injector(Setter<R, String> setter) {
			return (traceContext, request) -> this.injectors.stream()
				.map((propagation) -> propagation.injector(setter))
				.forEach((injector) -> injector.inject(traceContext, request));
		}
		@Override
		public <R> TraceContext.Extractor<R> extractor(Getter<R, String> getter) {
			return (request) -> this.extractors.stream()
				.map((propagation) -> propagation.extractor(getter))
				.map((extractor) -> extractor.extract(request))
				.filter(Predicate.not(TraceContextOrSamplingFlags.EMPTY::equals))
				.findFirst()
				.orElse(TraceContextOrSamplingFlags.EMPTY);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class OnEnabledTracingCondition extends SpringBootCondition {
	private static final String GLOBAL_PROPERTY = 'management.tracing.enabled';
	private static final String EXPORTER_PROPERTY = 'management.%s.tracing.export.enabled';
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		String tracingExporter = getExporterName(metadata);
		if (StringUtils.hasLength(tracingExporter)) {
			Boolean exporterTracingEnabled = context.getEnvironment()
				.getProperty(EXPORTER_PROPERTY.formatted(tracingExporter), Boolean.class);
			if (exporterTracingEnabled != null) {
				return new ConditionOutcome(exporterTracingEnabled,
						ConditionMessage.forCondition(ConditionalOnEnabledTracing.class)
							.because(EXPORTER_PROPERTY.formatted(tracingExporter) + ' is ' + exporterTracingEnabled));
			}
		}
		Boolean globalTracingEnabled = context.getEnvironment().getProperty(GLOBAL_PROPERTY, Boolean.class);
		if (globalTracingEnabled != null) {
			return new ConditionOutcome(globalTracingEnabled,
					ConditionMessage.forCondition(ConditionalOnEnabledTracing.class)
						.because(GLOBAL_PROPERTY + ' is ' + globalTracingEnabled));
		}
		return ConditionOutcome.match(ConditionMessage.forCondition(ConditionalOnEnabledTracing.class)
			.because('tracing is enabled by default'));
	}
	private static String getExporterName(AnnotatedTypeMetadata metadata) {
		Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnEnabledTracing.class.getName());
		if (attributes == null) {
			return null;
		}
		return (String) attributes.get('value');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
@ConfigurationProperties('management.otlp.tracing')
public class OtlpTracingProperties {
	/**
	 * URL to the OTel collector"s HTTP API.
	 */
	private String endpoint;
	/**
	 * Call timeout for the OTel Collector to process an exported batch of data. This
	 * timeout spans the entire call: resolving DNS, connecting, writing the request body,
	 * server processing, and reading the response body. If the call requires redirects or
	 * retries all must complete within one timeout period.
	 */
	private Duration timeout = Duration.ofSeconds(10);
	/**
	 * Connect timeout for the OTel collector connection.
	 */
	private Duration connectTimeout = Duration.ofSeconds(10);
	/**
	 * Transport used to send the spans.
	 */
	private Transport transport = Transport.HTTP;
	/**
	 * Method used to compress the payload.
	 */
	private Compression compression = Compression.NONE;
	/**
	 * Custom HTTP headers you want to pass to the collector, for example auth headers.
	 */
	private Map<String, String> headers = new HashMap<>();
	public String getEndpoint() {
		return this.endpoint;
	}
	public void setEndpoint(String endpoint) {
		this.endpoint = endpoint;
	}
	public Duration getTimeout() {
		return this.timeout;
	}
	public void setTimeout(Duration timeout) {
		this.timeout = timeout;
	}
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public Transport getTransport() {
		return this.transport;
	}
	public void setTransport(Transport transport) {
		this.transport = transport;
	}
	public Compression getCompression() {
		return this.compression;
	}
	public void setCompression(Compression compression) {
		this.compression = compression;
	}
	public Map<String, String> getHeaders() {
		return this.headers;
	}
	public void setHeaders(Map<String, String> headers) {
		this.headers = headers;
	}
	public enum Compression {
		/**
		 * Gzip compression.
		 */
		GZIP,
		/**
		 * No compression.
		 */
		NONE
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public class OtlpAutoConfiguration {
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
public enum Transport {
	/**
	 * HTTP transport.
	 */
	HTTP,
	/**
	 * gRPC transport.
	 */
	GRPC
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
class OtlpTracingConfigurations {
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetails {
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnProperty(prefix = 'management.otlp.tracing', name = 'endpoint')
		OtlpTracingConnectionDetails otlpTracingConnectionDetails(OtlpTracingProperties properties) {
			return new PropertiesOtlpTracingConnectionDetails(properties);
		}
		/**
		 * Adapts {@link OtlpTracingProperties} to {@link OtlpTracingConnectionDetails}.
		 */
		static class PropertiesOtlpTracingConnectionDetails implements OtlpTracingConnectionDetails {
			private final OtlpTracingProperties properties;
			PropertiesOtlpTracingConnectionDetails(OtlpTracingProperties properties) {
				this.properties = properties;
			}
			@Override
			public String getUrl(Transport transport) {
				Assert.state(transport == this.properties.getTransport(),
						'Requested transport %s doesn"t match configured transport %s'.formatted(transport,
								this.properties.getTransport()));
				return this.properties.getEndpoint();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean({ OtlpGrpcSpanExporter.class, OtlpHttpSpanExporter.class })
	@ConditionalOnBean(OtlpTracingConnectionDetails.class)
	@ConditionalOnEnabledTracing('otlp')
	static class Exporters {
		@Bean
		@ConditionalOnProperty(prefix = 'management.otlp.tracing', name = 'transport', havingValue = 'http',
				matchIfMissing = true)
		OtlpHttpSpanExporter otlpHttpSpanExporter(OtlpTracingProperties properties,
				OtlpTracingConnectionDetails connectionDetails) {
			OtlpHttpSpanExporterBuilder builder = OtlpHttpSpanExporter.builder()
				.setEndpoint(connectionDetails.getUrl(Transport.HTTP))
				.setTimeout(properties.getTimeout())
				.setConnectTimeout(properties.getConnectTimeout())
				.setCompression(properties.getCompression().name().toLowerCase(Locale.ROOT));
			properties.getHeaders().forEach(builder::addHeader);
			return builder.build();
		}
		@Bean
		@ConditionalOnProperty(prefix = 'management.otlp.tracing', name = 'transport', havingValue = 'grpc')
		OtlpGrpcSpanExporter otlpGrpcSpanExporter(OtlpTracingProperties properties,
				OtlpTracingConnectionDetails connectionDetails) {
			OtlpGrpcSpanExporterBuilder builder = OtlpGrpcSpanExporter.builder()
				.setEndpoint(connectionDetails.getUrl(Transport.GRPC))
				.setTimeout(properties.getTimeout())
				.setConnectTimeout(properties.getConnectTimeout())
				.setCompression(properties.getCompression().name().toLowerCase(Locale.ROOT));
			properties.getHeaders().forEach(builder::addHeader);
			return builder.build();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
@AutoConfiguration
@ConditionalOnClass({ OtelTracer.class, SdkTracerProvider.class, OpenTelemetry.class, OtlpHttpSpanExporter.class })
@EnableConfigurationProperties(OtlpTracingProperties.class)
@Import({ OtlpTracingConfigurations.ConnectionDetails.class, OtlpTracingConfigurations.Exporters.class })
public class OtlpTracingAutoConfiguration {
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/*
package org.springframework.boot.actuate.autoconfigure.tracing.otlp;
/**
public interface OtlpTracingConnectionDetails extends ConnectionDetails {
	/**
	 * Address to where tracing will be published.
	 * @return the address to where tracing will be published
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of {@link #getUrl(Transport)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	default String getUrl() {
		return getUrl(Transport.HTTP);
	}
	/**
	 * Address to where tracing will be published.
	 * @param transport the transport to use
	 * @return the address to where tracing will be published
	 * @since 3.4.0
	 */
	String getUrl(Transport transport);
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@FunctionalInterface
public interface SpanExporters extends Iterable<SpanExporter> {
	/**
	 * Returns the list of {@link SpanExporter span exporters}.
	 * @return the list of span exporters
	 */
	List<SpanExporter> list();
	@Override
	default Iterator<SpanExporter> iterator() {
		return list().iterator();
	}
	@Override
	default Spliterator<SpanExporter> spliterator() {
		return list().spliterator();
	}
	/**
	 * Constructs a {@link SpanExporters} instance with the given {@link SpanExporter span
	 * exporters}.
	 * @param spanExporters the span exporters
	 * @return the constructed {@link SpanExporters} instance
	 */
	static SpanExporters of(SpanExporter... spanExporters) {
		return of(Arrays.asList(spanExporters));
	}
	/**
	 * Constructs a {@link SpanExporters} instance with the given list of
	 * {@link SpanExporter span exporters}.
	 * @param spanExporters the list of span exporters
	 * @return the constructed {@link SpanExporters} instance
	 */
	static SpanExporters of(Collection<? extends SpanExporter> spanExporters) {
		Assert.notNull(spanExporters, 'SpanExporters must not be null');
		List<SpanExporter> copy = List.copyOf(spanExporters);
		return () -> copy;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@AutoConfiguration(before = MicrometerTracingAutoConfiguration.class)
@ConditionalOnClass(Tracer.class)
@ConditionalOnMissingBean(Tracer.class)
public class NoopTracerAutoConfiguration {
	@Bean
	Tracer noopTracer() {
		return Tracer.NOOP;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
@FunctionalInterface
public interface SpanProcessors extends Iterable<SpanProcessor> {
	/**
	 * Returns the list of {@link SpanProcessor span processors}.
	 * @return the list of span processors
	 */
	List<SpanProcessor> list();
	@Override
	default Iterator<SpanProcessor> iterator() {
		return list().iterator();
	}
	@Override
	default Spliterator<SpanProcessor> spliterator() {
		return list().spliterator();
	}
	/**
	 * Constructs a {@link SpanProcessors} instance with the given {@link SpanProcessor
	 * span processors}.
	 * @param spanProcessors the span processors
	 * @return the constructed {@link SpanProcessors} instance
	 */
	static SpanProcessors of(SpanProcessor... spanProcessors) {
		return of(Arrays.asList(spanProcessors));
	}
	/**
	 * Constructs a {@link SpanProcessors} instance with the given list of
	 * {@link SpanProcessor span processors}.
	 * @param spanProcessors the list of span processors
	 * @return the constructed {@link SpanProcessors} instance
	 */
	static SpanProcessors of(Collection<? extends SpanProcessor> spanProcessors) {
		Assert.notNull(spanProcessors, 'SpanProcessors must not be null');
		List<SpanProcessor> copy = List.copyOf(spanProcessors);
		return () -> copy;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class CompositeTextMapPropagator implements TextMapPropagator {
	private final Collection<TextMapPropagator> injectors;
	private final Collection<TextMapPropagator> extractors;
	private final TextMapPropagator baggagePropagator;
	private final Set<String> fields;
	/**
	 * Creates a new {@link CompositeTextMapPropagator}.
	 * @param injectors the injectors
	 * @param mutuallyExclusiveExtractors the mutually exclusive extractors. They are
	 * applied in order, and as soon as an extractor extracts a context, the other
	 * extractors after it are no longer invoked
	 * @param baggagePropagator the baggage propagator to use, or {@code null}
	 */
	CompositeTextMapPropagator(Collection<TextMapPropagator> injectors,
			Collection<TextMapPropagator> mutuallyExclusiveExtractors, TextMapPropagator baggagePropagator) {
		this.injectors = injectors;
		this.extractors = mutuallyExclusiveExtractors;
		this.baggagePropagator = baggagePropagator;
		Set<String> fields = new LinkedHashSet<>();
		fields(this.injectors).forEach(fields::add);
		fields(this.extractors).forEach(fields::add);
		if (baggagePropagator != null) {
			fields.addAll(baggagePropagator.fields());
		}
		this.fields = Collections.unmodifiableSet(fields);
	}
	private Stream<String> fields(Collection<TextMapPropagator> propagators) {
		return propagators.stream().flatMap((propagator) -> propagator.fields().stream());
	}
	Collection<TextMapPropagator> getInjectors() {
		return this.injectors;
	}
	Collection<TextMapPropagator> getExtractors() {
		return this.extractors;
	}
	@Override
	public Collection<String> fields() {
		return this.fields;
	}
	@Override
	public <C> void inject(Context context, C carrier, TextMapSetter<C> setter) {
		if (context != null && setter != null) {
			this.injectors.forEach((injector) -> injector.inject(context, carrier, setter));
		}
	}
	@Override
	public <C> Context extract(Context context, C carrier, TextMapGetter<C> getter) {
		if (context == null) {
			return Context.root();
		}
		if (getter == null) {
			return context;
		}
		Context result = this.extractors.stream()
			.map((extractor) -> extractor.extract(context, carrier, getter))
			.filter((extracted) -> extracted != context)
			.findFirst()
			.orElse(context);
		if (this.baggagePropagator != null) {
			result = this.baggagePropagator.extract(result, carrier, getter);
		}
		return result;
	}
	/**
	 * Creates a new {@link CompositeTextMapPropagator}.
	 * @param properties the tracing properties
	 * @param baggagePropagator the baggage propagator to use, or {@code null}
	 * @return the {@link CompositeTextMapPropagator}
	 */
	static TextMapPropagator create(TracingProperties.Propagation properties, TextMapPropagator baggagePropagator) {
		TextMapPropagatorMapper mapper = new TextMapPropagatorMapper(baggagePropagator != null);
		List<TextMapPropagator> injectors = properties.getEffectiveProducedTypes()
			.stream()
			.map(mapper::map)
			.collect(Collectors.toCollection(ArrayList::new));
		if (baggagePropagator != null) {
			injectors.add(baggagePropagator);
		}
		List<TextMapPropagator> extractors = properties.getEffectiveConsumedTypes().stream().map(mapper::map).toList();
		return new CompositeTextMapPropagator(injectors, extractors, baggagePropagator);
	}
	/**
	 * Mapper used to create a {@link TextMapPropagator} from a {@link PropagationType}.
	 */
	private static class TextMapPropagatorMapper {
		private final boolean baggage;
		TextMapPropagatorMapper(boolean baggage) {
			this.baggage = baggage;
		}
		TextMapPropagator map(PropagationType type) {
			return switch (type) {
				case B3 -> b3Single();
				case B3_MULTI -> b3Multi();
				case W3C -> w3c();
			};
		}
		/**
		 * Creates a new B3 propagator using a single B3 header.
		 * @return the B3 propagator
		 */
		private TextMapPropagator b3Single() {
			return B3Propagator.injectingSingleHeader();
		}
		/**
		 * Creates a new B3 propagator using multiple B3 headers.
		 * @return the B3 propagator
		 */
		private TextMapPropagator b3Multi() {
			return B3Propagator.injectingMultiHeaders();
		}
		/**
		 * Creates a new W3C propagator.
		 * @return the W3C propagator
		 */
		private TextMapPropagator w3c() {
			return (!this.baggage) ? W3CTraceContextPropagator.getInstance() : TextMapPropagator
				.composite(W3CTraceContextPropagator.getInstance(), W3CBaggagePropagator.getInstance());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.wavefront;
/**
class MeterRegistrySpanMetrics implements SpanMetrics {
	private final Counter spansReceived;
	private final Counter spansDropped;
	private final Counter reportErrors;
	private final MeterRegistry meterRegistry;
	MeterRegistrySpanMetrics(MeterRegistry meterRegistry) {
		this.meterRegistry = meterRegistry;
		this.spansReceived = meterRegistry.counter('wavefront.reporter.spans.received');
		this.spansDropped = meterRegistry.counter('wavefront.reporter.spans.dropped');
		this.reportErrors = meterRegistry.counter('wavefront.reporter.errors');
	}
	@Override
	public void reportDropped() {
		this.spansDropped.increment();
	}
	@Override
	public void reportReceived() {
		this.spansReceived.increment();
	}
	@Override
	public void reportErrors() {
		this.reportErrors.increment();
	}
	@Override
	public void registerQueueSize(BlockingQueue<?> queue) {
		this.meterRegistry.gauge('wavefront.reporter.queue.size', queue, (q) -> (double) q.size());
	}
	@Override
	public void registerQueueRemainingCapacity(BlockingQueue<?> queue) {
		this.meterRegistry.gauge('wavefront.reporter.queue.remaining_capacity', queue, this::remainingCapacity);
	}
	private double remainingCapacity(BlockingQueue<?> queue) {
		return queue.remainingCapacity();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.tracing.wavefront;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class,
		WavefrontAutoConfiguration.class })
@ConditionalOnClass({ WavefrontSender.class, WavefrontSpanHandler.class })
@EnableConfigurationProperties(WavefrontProperties.class)
@Import(WavefrontSenderConfiguration.class)
public class WavefrontTracingAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(WavefrontSender.class)
	@ConditionalOnEnabledTracing('wavefront')
	WavefrontSpanHandler wavefrontSpanHandler(WavefrontProperties properties, WavefrontSender wavefrontSender,
			SpanMetrics spanMetrics, ApplicationTags applicationTags) {
		return new WavefrontSpanHandler(properties.getSender().getMaxQueueSize(), wavefrontSender, spanMetrics,
				properties.getSourceOrDefault(), applicationTags, properties.getTraceDerivedCustomTagKeys());
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(MeterRegistry.class)
	static class MeterRegistrySpanMetricsConfiguration {
		@Bean
		@ConditionalOnMissingBean
		MeterRegistrySpanMetrics meterRegistrySpanMetrics(MeterRegistry meterRegistry) {
			return new MeterRegistrySpanMetrics(meterRegistry);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(MeterRegistry.class)
	static class NoopSpanMetricsConfiguration {
		@Bean
		@ConditionalOnMissingBean
		SpanMetrics meterRegistrySpanMetrics() {
			return SpanMetrics.NOOP;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(SpanHandler.class)
	static class WavefrontBrave {
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnEnabledTracing('wavefront')
		WavefrontBraveSpanHandler wavefrontBraveSpanHandler(WavefrontSpanHandler wavefrontSpanHandler) {
			return new WavefrontBraveSpanHandler(wavefrontSpanHandler);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(SpanExporter.class)
	static class WavefrontOpenTelemetry {
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnEnabledTracing('wavefront')
		WavefrontOtelSpanExporter wavefrontOtelSpanExporter(WavefrontSpanHandler wavefrontSpanHandler) {
			return new WavefrontOtelSpanExporter(wavefrontSpanHandler);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.tracing.wavefront;
/*
/**
package org.springframework.boot.actuate.autoconfigure.tracing;
/*
package org.springframework.boot.actuate.autoconfigure.tracing;
/**
class BravePropagationConfigurations {
	/**
	 * Propagates traces but no baggage.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(value = 'management.tracing.baggage.enabled', havingValue = 'false')
	static class PropagationWithoutBaggage {
		@Bean
		@ConditionalOnMissingBean(Factory.class)
		@ConditionalOnEnabledTracing
		CompositePropagationFactory propagationFactory(TracingProperties properties) {
			return CompositePropagationFactory.create(properties.getPropagation());
		}
	}
	/**
	 * Propagates traces and baggage.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(value = 'management.tracing.baggage.enabled', matchIfMissing = true)
	@EnableConfigurationProperties(TracingProperties.class)
	static class PropagationWithBaggage {
		private final TracingProperties tracingProperties;
		PropagationWithBaggage(TracingProperties tracingProperties) {
			this.tracingProperties = tracingProperties;
		}
		@Bean
		@ConditionalOnMissingBean
		BaggagePropagation.FactoryBuilder propagationFactoryBuilder(
				ObjectProvider<BaggagePropagationCustomizer> baggagePropagationCustomizers) {
			// There"s a chicken-and-egg problem here: to create a builder, we need a
			// factory. But the CompositePropagationFactory needs data from the builder.
			// We create a throw-away builder with a throw-away factory, and then copy the
			// config to the real builder.
			FactoryBuilder throwAwayBuilder = BaggagePropagation.newFactoryBuilder(createThrowAwayFactory());
			baggagePropagationCustomizers.orderedStream()
				.forEach((customizer) -> customizer.customize(throwAwayBuilder));
			CompositePropagationFactory propagationFactory = CompositePropagationFactory.create(
					this.tracingProperties.getPropagation(),
					new BraveBaggageManager(this.tracingProperties.getBaggage().getTagFields(),
							this.tracingProperties.getBaggage().getRemoteFields()),
					LocalBaggageFields.extractFrom(throwAwayBuilder));
			FactoryBuilder builder = BaggagePropagation.newFactoryBuilder(propagationFactory);
			throwAwayBuilder.configs().forEach(builder::add);
			return builder;
		}
		private Factory createThrowAwayFactory() {
			return new Factory() {
				@Override
				public Propagation<String> get() {
					return null;
				}
			};
		}
		@Bean
		BaggagePropagationCustomizer remoteFieldsBaggagePropagationCustomizer() {
			return (builder) -> {
				List<String> remoteFields = this.tracingProperties.getBaggage().getRemoteFields();
				for (String fieldName : remoteFields) {
					builder.add(BaggagePropagationConfig.SingleBaggageField.remote(BaggageField.create(fieldName)));
				}
				List<String> localFields = this.tracingProperties.getBaggage().getLocalFields();
				for (String localFieldName : localFields) {
					builder.add(BaggagePropagationConfig.SingleBaggageField.local(BaggageField.create(localFieldName)));
				}
			};
		}
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnEnabledTracing
		Factory propagationFactory(BaggagePropagation.FactoryBuilder factoryBuilder) {
			return factoryBuilder.build();
		}
		@Bean
		@ConditionalOnMissingBean
		CorrelationScopeDecorator.Builder mdcCorrelationScopeDecoratorBuilder(
				ObjectProvider<CorrelationScopeCustomizer> correlationScopeCustomizers) {
			CorrelationScopeDecorator.Builder builder = MDCScopeDecorator.newBuilder();
			correlationScopeCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
			return builder;
		}
		@Bean
		@Order(0)
		@ConditionalOnProperty(prefix = 'management.tracing.baggage.correlation', name = 'enabled',
				matchIfMissing = true)
		CorrelationScopeCustomizer correlationFieldsCorrelationScopeCustomizer() {
			return (builder) -> {
				Correlation correlationProperties = this.tracingProperties.getBaggage().getCorrelation();
				for (String field : correlationProperties.getFields()) {
					BaggageField baggageField = BaggageField.create(field);
					SingleCorrelationField correlationField = SingleCorrelationField.newBuilder(baggageField)
						.flushOnUpdate()
						.build();
					builder.add(correlationField);
				}
			};
		}
		@Bean
		@ConditionalOnMissingBean(CorrelationScopeDecorator.class)
		ScopeDecorator correlationScopeDecorator(CorrelationScopeDecorator.Builder builder) {
			return builder.build();
		}
	}
	/**
	 * Propagates neither traces nor baggage.
	 */
	@Configuration(proxyBeanMethods = false)
	static class NoPropagation {
		@Bean
		@ConditionalOnMissingBean(Factory.class)
		CompositePropagationFactory noopPropagationFactory() {
			return CompositePropagationFactory.noop();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.scheduling;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(ScheduledTasksEndpoint.class)
public class ScheduledTasksEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ScheduledTasksEndpoint scheduledTasksEndpoint(ObjectProvider<ScheduledTaskHolder> holders) {
		return new ScheduledTasksEndpoint(holders.orderedStream().toList());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.scheduling;
/**
@AutoConfiguration(after = ObservationAutoConfiguration.class)
@ConditionalOnBean(ObservationRegistry.class)
@ConditionalOnClass(ThreadPoolTaskScheduler.class)
public class ScheduledTasksObservabilityAutoConfiguration {
	@Bean
	ObservabilitySchedulingConfigurer observabilitySchedulingConfigurer(ObservationRegistry observationRegistry) {
		return new ObservabilitySchedulingConfigurer(observationRegistry);
	}
	static final class ObservabilitySchedulingConfigurer implements SchedulingConfigurer {
		private final ObservationRegistry observationRegistry;
		ObservabilitySchedulingConfigurer(ObservationRegistry observationRegistry) {
			this.observationRegistry = observationRegistry;
		}
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			taskRegistrar.setObservationRegistry(this.observationRegistry);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.scheduling;
/*
package org.springframework.boot.actuate.autoconfigure.jdbc;
/**
@AutoConfiguration(after = DataSourceAutoConfiguration.class)
@ConditionalOnClass({ JdbcTemplate.class, AbstractRoutingDataSource.class })
@ConditionalOnBean(DataSource.class)
@ConditionalOnEnabledHealthIndicator('db')
@EnableConfigurationProperties(DataSourceHealthIndicatorProperties.class)
public class DataSourceHealthContributorAutoConfiguration implements InitializingBean {
	private final Collection<DataSourcePoolMetadataProvider> metadataProviders;
	private DataSourcePoolMetadataProvider poolMetadataProvider;
	public DataSourceHealthContributorAutoConfiguration(
			ObjectProvider<DataSourcePoolMetadataProvider> metadataProviders) {
		this.metadataProviders = metadataProviders.orderedStream().toList();
	}
	@Override
	public void afterPropertiesSet() {
		this.poolMetadataProvider = new CompositeDataSourcePoolMetadataProvider(this.metadataProviders);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'dbHealthIndicator', 'dbHealthContributor' })
	public HealthContributor dbHealthContributor(Map<String, DataSource> dataSources,
			DataSourceHealthIndicatorProperties dataSourceHealthIndicatorProperties) {
		if (dataSourceHealthIndicatorProperties.isIgnoreRoutingDataSources()) {
			Map<String, DataSource> filteredDatasources = dataSources.entrySet()
				.stream()
				.filter((e) -> !isRoutingDataSource(e.getValue()))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
			return createContributor(filteredDatasources);
		}
		return createContributor(dataSources);
	}
	private HealthContributor createContributor(Map<String, DataSource> beans) {
		Assert.notEmpty(beans, 'Beans must not be empty');
		if (beans.size() == 1) {
			return createContributor(beans.values().iterator().next());
		}
		return CompositeHealthContributor.fromMap(beans, this::createContributor);
	}
	private HealthContributor createContributor(DataSource source) {
		if (isRoutingDataSource(source)) {
			return new RoutingDataSourceHealthContributor(extractRoutingDataSource(source), this::createContributor);
		}
		return new DataSourceHealthIndicator(source, getValidationQuery(source));
	}
	private String getValidationQuery(DataSource source) {
		DataSourcePoolMetadata poolMetadata = this.poolMetadataProvider.getDataSourcePoolMetadata(source);
		return (poolMetadata != null) ? poolMetadata.getValidationQuery() : null;
	}
	private static boolean isRoutingDataSource(DataSource dataSource) {
		if (dataSource instanceof AbstractRoutingDataSource) {
			return true;
		}
		try {
			return dataSource.isWrapperFor(AbstractRoutingDataSource.class);
		}
		catch (SQLException ex) {
			return false;
		}
	}
	private static AbstractRoutingDataSource extractRoutingDataSource(DataSource dataSource) {
		if (dataSource instanceof AbstractRoutingDataSource routingDataSource) {
			return routingDataSource;
		}
		try {
			return dataSource.unwrap(AbstractRoutingDataSource.class);
		}
		catch (SQLException ex) {
			throw new IllegalStateException('Failed to unwrap AbstractRoutingDataSource from ' + dataSource, ex);
		}
	}
	/**
	 * {@link CompositeHealthContributor} used for {@link AbstractRoutingDataSource} beans
	 * where the overall health is composed of a {@link DataSourceHealthIndicator} for
	 * each routed datasource.
	 */
	static class RoutingDataSourceHealthContributor implements CompositeHealthContributor {
		private final CompositeHealthContributor delegate;
		private static final String UNNAMED_DATASOURCE_KEY = 'unnamed';
		RoutingDataSourceHealthContributor(AbstractRoutingDataSource routingDataSource,
				Function<DataSource, HealthContributor> contributorFunction) {
			Map<String, DataSource> routedDataSources = routingDataSource.getResolvedDataSources()
				.entrySet()
				.stream()
				.collect(Collectors.toMap((e) -> Objects.toString(e.getKey(), UNNAMED_DATASOURCE_KEY),
						Map.Entry::getValue));
			this.delegate = CompositeHealthContributor.fromMap(routedDataSources, contributorFunction);
		}
		@Override
		public HealthContributor getContributor(String name) {
			return this.delegate.getContributor(name);
		}
		@Override
		public Iterator<NamedContributor<HealthContributor>> iterator() {
			return this.delegate.iterator();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.jdbc;
/**
@ConfigurationProperties(prefix = 'management.health.db')
public class DataSourceHealthIndicatorProperties {
	/**
	 * Whether to ignore AbstractRoutingDataSources when creating database health
	 * indicators.
	 */
	private boolean ignoreRoutingDataSources = false;
	public boolean isIgnoreRoutingDataSources() {
		return this.ignoreRoutingDataSources;
	}
	public void setIgnoreRoutingDataSources(boolean ignoreRoutingDataSources) {
		this.ignoreRoutingDataSources = ignoreRoutingDataSources;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.jdbc;
/*
/**
package org.springframework.boot.actuate.autoconfigure.jms;
/*
package org.springframework.boot.actuate.autoconfigure.jms;
/**
@AutoConfiguration(after = { ActiveMQAutoConfiguration.class, ArtemisAutoConfiguration.class })
@ConditionalOnClass(ConnectionFactory.class)
@ConditionalOnBean(ConnectionFactory.class)
@ConditionalOnEnabledHealthIndicator('jms')
public class JmsHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<JmsHealthIndicator, ConnectionFactory> {
	public JmsHealthContributorAutoConfiguration() {
		super(JmsHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'jmsHealthIndicator', 'jmsHealthContributor' })
	public HealthContributor jmsHealthContributor(Map<String, ConnectionFactory> connectionFactories) {
		return createContributor(connectionFactories);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.context.properties;
/**
@ConfigurationProperties('management.endpoint.configprops')
public class ConfigurationPropertiesReportEndpointProperties {
	/**
	 * When to show unsanitized values.
	 */
	private Show showValues = Show.NEVER;
	/**
	 * Roles used to determine whether a user is authorized to be shown unsanitized
	 * values. When empty, all authenticated users are authorized.
	 */
	private final Set<String> roles = new HashSet<>();
	public Show getShowValues() {
		return this.showValues;
	}
	public void setShowValues(Show showValues) {
		this.showValues = showValues;
	}
	public Set<String> getRoles() {
		return this.roles;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.context.properties;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(ConfigurationPropertiesReportEndpoint.class)
@EnableConfigurationProperties(ConfigurationPropertiesReportEndpointProperties.class)
public class ConfigurationPropertiesReportEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ConfigurationPropertiesReportEndpoint configurationPropertiesReportEndpoint(
			ConfigurationPropertiesReportEndpointProperties properties,
			ObjectProvider<SanitizingFunction> sanitizingFunctions) {
		return new ConfigurationPropertiesReportEndpoint(sanitizingFunctions.orderedStream().toList(),
				properties.getShowValues());
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(ConfigurationPropertiesReportEndpoint.class)
	@ConditionalOnAvailableEndpoint(exposure = EndpointExposure.WEB)
	public ConfigurationPropertiesReportEndpointWebExtension configurationPropertiesReportEndpointWebExtension(
			ConfigurationPropertiesReportEndpoint configurationPropertiesReportEndpoint,
			ConfigurationPropertiesReportEndpointProperties properties) {
		return new ConfigurationPropertiesReportEndpointWebExtension(configurationPropertiesReportEndpoint,
				properties.getShowValues(), properties.getRoles());
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.context.properties;
/*
package org.springframework.boot.actuate.autoconfigure.context;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(ShutdownEndpoint.class)
public class ShutdownEndpointAutoConfiguration {
	@Bean(destroyMethod = '')
	@ConditionalOnMissingBean
	public ShutdownEndpoint shutdownEndpoint() {
		return new ShutdownEndpoint();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.context;
/*
package org.springframework.boot.actuate.autoconfigure.quartz;
/**
@AutoConfiguration(after = QuartzAutoConfiguration.class)
@ConditionalOnClass(Scheduler.class)
@ConditionalOnAvailableEndpoint(QuartzEndpoint.class)
@EnableConfigurationProperties(QuartzEndpointProperties.class)
public class QuartzEndpointAutoConfiguration {
	@Bean
	@ConditionalOnBean(Scheduler.class)
	@ConditionalOnMissingBean
	public QuartzEndpoint quartzEndpoint(Scheduler scheduler, ObjectProvider<SanitizingFunction> sanitizingFunctions) {
		return new QuartzEndpoint(scheduler, sanitizingFunctions.orderedStream().toList());
	}
	@Bean
	@ConditionalOnBean(QuartzEndpoint.class)
	@ConditionalOnMissingBean
	@ConditionalOnAvailableEndpoint(exposure = EndpointExposure.WEB)
	public QuartzEndpointWebExtension quartzEndpointWebExtension(QuartzEndpoint endpoint,
			QuartzEndpointProperties properties) {
		return new QuartzEndpointWebExtension(endpoint, properties.getShowValues(), properties.getRoles());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.quartz;
/**
@ConfigurationProperties('management.endpoint.quartz')
public class QuartzEndpointProperties {
	/**
	 * When to show unsanitized job or trigger values.
	 */
	private Show showValues = Show.NEVER;
	/**
	 * Roles used to determine whether a user is authorized to be shown unsanitized job or
	 * trigger values. When empty, all authenticated users are authorized.
	 */
	private final Set<String> roles = new HashSet<>();
	public Show getShowValues() {
		return this.showValues;
	}
	public void setShowValues(Show showValues) {
		this.showValues = showValues;
	}
	public Set<String> getRoles() {
		return this.roles;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.quartz;
/*
package org.springframework.boot.actuate.autoconfigure.cache;
/**
@AutoConfiguration(after = CacheAutoConfiguration.class)
@ConditionalOnClass(CacheManager.class)
@ConditionalOnAvailableEndpoint(CachesEndpoint.class)
public class CachesEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public CachesEndpoint cachesEndpoint(Map<String, CacheManager> cacheManagers) {
		return new CachesEndpoint(cacheManagers);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(CachesEndpoint.class)
	@ConditionalOnAvailableEndpoint(exposure = EndpointExposure.WEB)
	public CachesEndpointWebExtension cachesEndpointWebExtension(CachesEndpoint cachesEndpoint) {
		return new CachesEndpointWebExtension(cachesEndpoint);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.cache;
/*
package org.springframework.boot.actuate.autoconfigure.web.exchanges;
/**
@AutoConfiguration(after = HttpExchangesAutoConfiguration.class)
@ConditionalOnAvailableEndpoint(HttpExchangesEndpoint.class)
public class HttpExchangesEndpointAutoConfiguration {
	@Bean
	@ConditionalOnBean(HttpExchangeRepository.class)
	@ConditionalOnMissingBean
	public HttpExchangesEndpoint httpExchangesEndpoint(HttpExchangeRepository exchangeRepository) {
		return new HttpExchangesEndpoint(exchangeRepository);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.web.exchanges;
/*
package org.springframework.boot.actuate.autoconfigure.web.exchanges;
/**
@AutoConfiguration
@ConditionalOnWebApplication
@ConditionalOnProperty(prefix = 'management.httpexchanges.recording', name = 'enabled', matchIfMissing = true)
@ConditionalOnBean(HttpExchangeRepository.class)
@EnableConfigurationProperties(HttpExchangesProperties.class)
public class HttpExchangesAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	static class ServletHttpExchangesConfiguration {
		@Bean
		@ConditionalOnMissingBean
		HttpExchangesFilter httpExchangesFilter(HttpExchangeRepository repository, HttpExchangesProperties properties) {
			return new HttpExchangesFilter(repository, properties.getRecording().getInclude());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	static class ReactiveHttpExchangesConfiguration {
		@Bean
		@ConditionalOnMissingBean
		HttpExchangesWebFilter httpExchangesWebFilter(HttpExchangeRepository repository,
				HttpExchangesProperties properties) {
			return new HttpExchangesWebFilter(repository, properties.getRecording().getInclude());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.exchanges;
/**
@ConfigurationProperties(prefix = 'management.httpexchanges')
public class HttpExchangesProperties {
	private final Recording recording = new Recording();
	public Recording getRecording() {
		return this.recording;
	}
	/**
	 * Recording properties.
	 *
	 * @since 3.0.0
	 */
	public static class Recording {
		/**
		 * Items to be included in the exchange recording. Defaults to request headers
		 * (excluding Authorization and Cookie), response headers (excluding Set-Cookie),
		 * and time taken.
		 */
		private Set<Include> include = new HashSet<>(Include.defaultIncludes());
		public Set<Include> getInclude() {
			return this.include;
		}
		public void setInclude(Set<Include> include) {
			this.include = include;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface ManagementContextConfiguration {
	/**
	 * Specifies the type of management context that is required for this configuration to
	 * be applied.
	 * @return the required management context type
	 * @since 2.0.0
	 */
	ManagementContextType value() default ManagementContextType.ANY;
	/**
	 * Specify whether {@link Bean @Bean} methods should get proxied in order to enforce
	 * bean lifecycle behavior, e.g. to return shared singleton bean instances even in
	 * case of direct {@code @Bean} method calls in user code. This feature requires
	 * method interception, implemented through a runtime-generated CGLIB subclass which
	 * comes with limitations such as the configuration class and its methods not being
	 * allowed to declare {@code final}.
	 * <p>
	 * The default is {@code true}, allowing for "inter-bean references" within the
	 * configuration class as well as for external calls to this configuration"s
	 * {@code @Bean} methods, e.g. from another configuration class. If this is not needed
	 * since each of this particular configuration"s {@code @Bean} methods is
	 * self-contained and designed as a plain factory method for container use, switch
	 * this flag to {@code false} in order to avoid CGLIB subclass processing.
	 * <p>
	 * Turning off bean method interception effectively processes {@code @Bean} methods
	 * individually like when declared on non-{@code @Configuration} classes, a.k.a.
	 * '@Bean Lite Mode' (see {@link Bean @Bean"s javadoc}). It is therefore behaviorally
	 * equivalent to removing the {@code @Configuration} stereotype.
	 * @return whether to proxy {@code @Bean} methods
	 * @since 2.2
	 */
	@AliasFor(annotation = Configuration.class)
	boolean proxyBeanMethods() default true;
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@AutoConfiguration
@AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE)
@EnableConfigurationProperties({ WebEndpointProperties.class, ManagementServerProperties.class })
public class ManagementContextAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnManagementPort(ManagementPortType.SAME)
	static class SameManagementContextConfiguration implements SmartInitializingSingleton {
		private final Environment environment;
		SameManagementContextConfiguration(Environment environment) {
			this.environment = environment;
		}
		@Override
		public void afterSingletonsInstantiated() {
			verifySslConfiguration();
			verifyAddressConfiguration();
			if (this.environment instanceof ConfigurableEnvironment configurableEnvironment) {
				addLocalManagementPortPropertyAlias(configurableEnvironment);
			}
		}
		private void verifySslConfiguration() {
			Boolean enabled = this.environment.getProperty('management.server.ssl.enabled', Boolean.class, false);
			Assert.state(!enabled, 'Management-specific SSL cannot be configured as the management '
					+ 'server is not listening on a separate port');
		}
		private void verifyAddressConfiguration() {
			Object address = this.environment.getProperty('management.server.address');
			Assert.state(address == null, 'Management-specific server address cannot be configured as the management '
					+ 'server is not listening on a separate port');
		}
		/**
		 * Add an alias for "local.management.port" that actually resolves using
		 * "local.server.port".
		 * @param environment the environment
		 */
		private void addLocalManagementPortPropertyAlias(ConfigurableEnvironment environment) {
			environment.getPropertySources().addLast(new PropertySource<>('Management Server') {
				@Override
				public Object getProperty(String name) {
					if ('local.management.port'.equals(name)) {
						return environment.getProperty('local.server.port');
					}
					return null;
				}
			});
		}
		@Configuration(proxyBeanMethods = false)
		@EnableManagementContext(ManagementContextType.SAME)
		static class EnableSameManagementContextConfiguration {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnManagementPort(ManagementPortType.DIFFERENT)
	static class DifferentManagementContextConfiguration {
		@Bean
		static ChildManagementContextInitializer childManagementContextInitializer(
				ManagementContextFactory managementContextFactory, AbstractApplicationContext parentContext) {
			return new ChildManagementContextInitializer(managementContextFactory, parentContext);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnManagementPortCondition.class)
public @interface ConditionalOnManagementPort {
	/**
	 * The {@link ManagementPortType} to match.
	 * @return the port type
	 */
	ManagementPortType value();
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
class ChildManagementContextInitializer implements BeanRegistrationAotProcessor, SmartLifecycle {
	private final ManagementContextFactory managementContextFactory;
	private final AbstractApplicationContext parentContext;
	private final ApplicationContextInitializer<ConfigurableApplicationContext> applicationContextInitializer;
	private volatile ConfigurableApplicationContext managementContext;
	ChildManagementContextInitializer(ManagementContextFactory managementContextFactory,
			AbstractApplicationContext parentContext) {
		this(managementContextFactory, parentContext, null);
	}
	@SuppressWarnings('unchecked')
	private ChildManagementContextInitializer(ManagementContextFactory managementContextFactory,
			AbstractApplicationContext parentContext,
			ApplicationContextInitializer<? extends ConfigurableApplicationContext> applicationContextInitializer) {
		this.managementContextFactory = managementContextFactory;
		this.parentContext = parentContext;
		this.applicationContextInitializer = (ApplicationContextInitializer<ConfigurableApplicationContext>) applicationContextInitializer;
	}
	@Override
	public void start() {
		if (!(this.parentContext instanceof WebServerApplicationContext)) {
			return;
		}
		if (this.managementContext == null) {
			ConfigurableApplicationContext managementContext = createManagementContext();
			registerBeans(managementContext);
			managementContext.refresh();
			this.managementContext = managementContext;
		}
		else {
			this.managementContext.start();
		}
	}
	@Override
	public void stop() {
		if (this.managementContext != null) {
			if (this.parentContext.isClosed()) {
				this.managementContext.close();
			}
			else {
				this.managementContext.stop();
			}
		}
	}
	@Override
	public boolean isRunning() {
		return this.managementContext != null && this.managementContext.isRunning();
	}
	@Override
	public int getPhase() {
		return WebServerGracefulShutdownLifecycle.SMART_LIFECYCLE_PHASE - 512;
	}
	@Override
	public BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean) {
		Assert.isInstanceOf(ConfigurableApplicationContext.class, this.parentContext);
		BeanFactory parentBeanFactory = ((ConfigurableApplicationContext) this.parentContext).getBeanFactory();
		if (registeredBean.getBeanClass().equals(getClass())
				&& registeredBean.getBeanFactory().equals(parentBeanFactory)) {
			ConfigurableApplicationContext managementContext = createManagementContext();
			registerBeans(managementContext);
			return new AotContribution(managementContext);
		}
		return null;
	}
	@Override
	public boolean isBeanExcludedFromAotProcessing() {
		return false;
	}
	private void registerBeans(ConfigurableApplicationContext managementContext) {
		if (this.applicationContextInitializer != null) {
			this.applicationContextInitializer.initialize(managementContext);
			return;
		}
		Assert.isInstanceOf(AnnotationConfigRegistry.class, managementContext);
		AnnotationConfigRegistry registry = (AnnotationConfigRegistry) managementContext;
		this.managementContextFactory.registerWebServerFactoryBeans(this.parentContext, managementContext, registry);
		registry.register(EnableChildManagementContextConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
		if (isLazyInitialization()) {
			managementContext.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
		}
	}
	protected final ConfigurableApplicationContext createManagementContext() {
		ConfigurableApplicationContext managementContext = this.managementContextFactory
			.createManagementContext(this.parentContext);
		managementContext.setId(this.parentContext.getId() + ':management');
		if (managementContext instanceof ConfigurableWebServerApplicationContext webServerApplicationContext) {
			webServerApplicationContext.setServerNamespace('management');
		}
		if (managementContext instanceof DefaultResourceLoader resourceLoader) {
			resourceLoader.setClassLoader(this.parentContext.getClassLoader());
		}
		CloseManagementContextListener.addIfPossible(this.parentContext, managementContext);
		return managementContext;
	}
	private boolean isLazyInitialization() {
		List<BeanFactoryPostProcessor> postProcessors = this.parentContext.getBeanFactoryPostProcessors();
		return postProcessors.stream().anyMatch(LazyInitializationBeanFactoryPostProcessor.class::isInstance);
	}
	ChildManagementContextInitializer withApplicationContextInitializer(
			ApplicationContextInitializer<? extends ConfigurableApplicationContext> applicationContextInitializer) {
		return new ChildManagementContextInitializer(this.managementContextFactory, this.parentContext,
				applicationContextInitializer);
	}
	/**
	 * {@link BeanRegistrationAotContribution} for
	 * {@link ChildManagementContextInitializer}.
	 */
	private static class AotContribution implements BeanRegistrationAotContribution {
		private final GenericApplicationContext managementContext;
		AotContribution(ConfigurableApplicationContext managementContext) {
			Assert.isInstanceOf(GenericApplicationContext.class, managementContext);
			this.managementContext = (GenericApplicationContext) managementContext;
		}
		@Override
		public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {
			GenerationContext managementGenerationContext = generationContext.withName('Management');
			ClassName generatedInitializerClassName = new ApplicationContextAotGenerator()
				.processAheadOfTime(this.managementContext, managementGenerationContext);
			GeneratedMethod postProcessorMethod = beanRegistrationCode.getMethods()
				.add('addManagementInitializer',
						(method) -> method.addJavadoc('Use AOT management context initialization')
							.addModifiers(Modifier.PRIVATE, Modifier.STATIC)
							.addParameter(RegisteredBean.class, 'registeredBean')
							.addParameter(ChildManagementContextInitializer.class, 'instance')
							.returns(ChildManagementContextInitializer.class)
							.addStatement('return instance.withApplicationContextInitializer(new $L())',
									generatedInitializerClassName));
			beanRegistrationCode.addInstancePostProcessor(postProcessorMethod.toMethodReference());
		}
	}
	/**
	 * {@link ApplicationListener} to propagate the {@link ApplicationFailedEvent} from a
	 * parent to a child.
	 */
	private static class CloseManagementContextListener implements ApplicationListener<ApplicationEvent> {
		private final ApplicationContext parentContext;
		private final ConfigurableApplicationContext childContext;
		CloseManagementContextListener(ApplicationContext parentContext, ConfigurableApplicationContext childContext) {
			this.parentContext = parentContext;
			this.childContext = childContext;
		}
		@Override
		public void onApplicationEvent(ApplicationEvent event) {
			if (event instanceof ApplicationFailedEvent applicationFailedEvent) {
				onApplicationFailedEvent(applicationFailedEvent);
			}
		}
		private void onApplicationFailedEvent(ApplicationFailedEvent event) {
			propagateCloseIfNecessary(event.getApplicationContext());
		}
		private void propagateCloseIfNecessary(ApplicationContext applicationContext) {
			if (applicationContext == this.parentContext) {
				this.childContext.close();
			}
		}
		static void addIfPossible(ApplicationContext parentContext, ConfigurableApplicationContext childContext) {
			if (parentContext instanceof ConfigurableApplicationContext configurableApplicationContext) {
				add(configurableApplicationContext, childContext);
			}
		}
		private static void add(ConfigurableApplicationContext parentContext,
				ConfigurableApplicationContext childContext) {
			parentContext.addApplicationListener(new CloseManagementContextListener(parentContext, childContext));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(ManagementContextConfigurationImportSelector.class)
@interface EnableManagementContext {
	/**
	 * The management context type that should be enabled.
	 * @return the management context type
	 */
	ManagementContextType value();
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@Order(Ordered.LOWEST_PRECEDENCE)
class ManagementContextConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware {
	private ClassLoader classLoader;
	@Override
	public String[] selectImports(AnnotationMetadata metadata) {
		ManagementContextType contextType = (ManagementContextType) metadata
			.getAnnotationAttributes(EnableManagementContext.class.getName())
			.get('value');
		// Find all management context configuration classes, filtering duplicates
		List<ManagementConfiguration> configurations = getConfigurations();
		OrderComparator.sort(configurations);
		List<String> names = new ArrayList<>();
		for (ManagementConfiguration configuration : configurations) {
			if (configuration.getContextType() == ManagementContextType.ANY
					|| configuration.getContextType() == contextType) {
				names.add(configuration.getClassName());
			}
		}
		return StringUtils.toStringArray(names);
	}
	private List<ManagementConfiguration> getConfigurations() {
		SimpleMetadataReaderFactory readerFactory = new SimpleMetadataReaderFactory(this.classLoader);
		List<ManagementConfiguration> configurations = new ArrayList<>();
		for (String className : loadFactoryNames()) {
			addConfiguration(readerFactory, configurations, className);
		}
		return configurations;
	}
	private void addConfiguration(SimpleMetadataReaderFactory readerFactory,
			List<ManagementConfiguration> configurations, String className) {
		try {
			MetadataReader metadataReader = readerFactory.getMetadataReader(className);
			configurations.add(new ManagementConfiguration(metadataReader));
		}
		catch (IOException ex) {
			throw new RuntimeException('Failed to read annotation metadata for "' + className + '"', ex);
		}
	}
	protected List<String> loadFactoryNames() {
		return ImportCandidates.load(ManagementContextConfiguration.class, this.classLoader).getCandidates();
	}
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	/**
	 * A management configuration class which can be sorted according to {@code @Order}.
	 */
	private static final class ManagementConfiguration implements Ordered {
		private final String className;
		private final int order;
		private final ManagementContextType contextType;
		ManagementConfiguration(MetadataReader metadataReader) {
			AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
			this.order = readOrder(annotationMetadata);
			this.className = metadataReader.getClassMetadata().getClassName();
			this.contextType = readContextType(annotationMetadata);
		}
		private ManagementContextType readContextType(AnnotationMetadata annotationMetadata) {
			Map<String, Object> annotationAttributes = annotationMetadata
				.getAnnotationAttributes(ManagementContextConfiguration.class.getName());
			return (annotationAttributes != null) ? (ManagementContextType) annotationAttributes.get('value')
					: ManagementContextType.ANY;
		}
		private int readOrder(AnnotationMetadata annotationMetadata) {
			Map<String, Object> attributes = annotationMetadata.getAnnotationAttributes(Order.class.getName());
			Integer order = (attributes != null) ? (Integer) attributes.get('value') : null;
			return (order != null) ? order : Ordered.LOWEST_PRECEDENCE;
		}
		String getClassName() {
			return this.className;
		}
		@Override
		public int getOrder() {
			return this.order;
		}
		ManagementContextType getContextType() {
			return this.contextType;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@Configuration(proxyBeanMethods = false)
@EnableManagementContext(ManagementContextType.CHILD)
class EnableChildManagementContextConfiguration {
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.web.server;
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
class OnManagementPortCondition extends SpringBootCondition {
	private static final String CLASS_NAME_WEB_APPLICATION_CONTEXT = 'org.springframework.web.context.WebApplicationContext';
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('Management Port');
		if (!isWebApplicationContext(context)) {
			return ConditionOutcome.noMatch(message.because('non web application context'));
		}
		Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnManagementPort.class.getName());
		ManagementPortType requiredType = (ManagementPortType) attributes.get('value');
		ManagementPortType actualType = ManagementPortType.get(context.getEnvironment());
		if (actualType == requiredType) {
			return ConditionOutcome
				.match(message.because('actual port type (' + actualType + ') matched required type'));
		}
		return ConditionOutcome.noMatch(message
			.because('actual port type (' + actualType + ') did not match required type (' + requiredType + ')'));
	}
	private boolean isWebApplicationContext(ConditionContext context) {
		ResourceLoader resourceLoader = context.getResourceLoader();
		if (resourceLoader instanceof ConfigurableReactiveWebApplicationContext) {
			return true;
		}
		if (!ClassUtils.isPresent(CLASS_NAME_WEB_APPLICATION_CONTEXT, context.getClassLoader())) {
			return false;
		}
		return resourceLoader instanceof WebApplicationContext;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
@ConfigurationProperties(prefix = 'management.server', ignoreUnknownFields = true)
public class ManagementServerProperties {
	/**
	 * Management endpoint HTTP port (uses the same port as the application by default).
	 * Configure a different port to use management-specific SSL.
	 */
	private Integer port;
	/**
	 * Network address to which the management endpoints should bind. Requires a custom
	 * management.server.port.
	 */
	private InetAddress address;
	/**
	 * Management endpoint base path (for instance, "/management"). Requires a custom
	 * management.server.port.
	 */
	private String basePath = '';
	@NestedConfigurationProperty
	private Ssl ssl;
	/**
	 * Returns the management port or {@code null} if the
	 * {@link ServerProperties#getPort() server port} should be used.
	 * @return the port
	 * @see #setPort(Integer)
	 */
	public Integer getPort() {
		return this.port;
	}
	/**
	 * Sets the port of the management server, use {@code null} if the
	 * {@link ServerProperties#getPort() server port} should be used. Set to 0 to use a
	 * random port or set to -1 to disable.
	 * @param port the port
	 */
	public void setPort(Integer port) {
		this.port = port;
	}
	public InetAddress getAddress() {
		return this.address;
	}
	public void setAddress(InetAddress address) {
		this.address = address;
	}
	public String getBasePath() {
		return this.basePath;
	}
	public void setBasePath(String basePath) {
		this.basePath = cleanBasePath(basePath);
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public void setSsl(Ssl ssl) {
		this.ssl = ssl;
	}
	private String cleanBasePath(String basePath) {
		String candidate = null;
		if (StringUtils.hasLength(basePath)) {
			candidate = basePath.strip();
		}
		if (StringUtils.hasText(candidate)) {
			if (!candidate.startsWith('/')) {
				candidate = '/' + candidate;
			}
			if (candidate.endsWith('/')) {
				candidate = candidate.substring(0, candidate.length() - 1);
			}
		}
		return candidate;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
public enum ManagementPortType {
	/**
	 * The management port has been disabled.
	 */
	DISABLED,
	/**
	 * The management port is the same as the server port.
	 */
	SAME,
	/**
	 * The management port and server port are different.
	 */
	DIFFERENT;
	/**
	 * Look at the given environment to determine if the {@link ManagementPortType} is
	 * {@link #DISABLED}, {@link #SAME} or {@link #DIFFERENT}.
	 * @param environment the Spring environment
	 * @return {@link #DISABLED} if {@code management.server.port} is set to a negative
	 * value, {@link #SAME} if {@code management.server.port} is not specified or equal to
	 * {@code server.port} and {@link #DIFFERENT} otherwise.
	 * @since 2.1.4
	 */
	public static ManagementPortType get(Environment environment) {
		Integer managementPort = getPortProperty(environment, 'management.server.');
		if (managementPort != null && managementPort < 0) {
			return DISABLED;
		}
		Integer serverPort = getPortProperty(environment, 'server.');
		return ((managementPort == null || (serverPort == null && managementPort.equals(8080))
				|| (managementPort != 0 && managementPort.equals(serverPort))) ? SAME : DIFFERENT);
	}
	private static Integer getPortProperty(Environment environment, String prefix) {
		return environment.getProperty(prefix + 'port', Integer.class);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.server;
/**
public abstract class ManagementWebServerFactoryCustomizer<T extends ConfigurableWebServerFactory>
		implements WebServerFactoryCustomizer<T>, Ordered {
	private final ListableBeanFactory beanFactory;
	private final Class<? extends WebServerFactoryCustomizer<?>>[] customizerClasses;
	@SafeVarargs
	@SuppressWarnings('varargs')
	protected ManagementWebServerFactoryCustomizer(ListableBeanFactory beanFactory,
			Class<? extends WebServerFactoryCustomizer<?>>... customizerClasses) {
		this.beanFactory = beanFactory;
		this.customizerClasses = customizerClasses;
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public final void customize(T factory) {
		ManagementServerProperties managementServerProperties = BeanFactoryUtils
			.beanOfTypeIncludingAncestors(this.beanFactory, ManagementServerProperties.class);
		// Customize as per the parent context first (so e.g. the access logs go to
		// the same place)
		customizeSameAsParentContext(factory);
		// Then reset the error pages
		factory.setErrorPages(Collections.emptySet());
		// and add the management-specific bits
		ServerProperties serverProperties = BeanFactoryUtils.beanOfTypeIncludingAncestors(this.beanFactory,
				ServerProperties.class);
		customize(factory, managementServerProperties, serverProperties);
	}
	private void customizeSameAsParentContext(T factory) {
		List<WebServerFactoryCustomizer<?>> customizers = new ArrayList<>();
		for (Class<? extends WebServerFactoryCustomizer<?>> customizerClass : this.customizerClasses) {
			try {
				customizers.add(BeanFactoryUtils.beanOfTypeIncludingAncestors(this.beanFactory, customizerClass));
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Ignore
			}
		}
		invokeCustomizers(factory, customizers);
	}
	@SuppressWarnings('unchecked')
	private void invokeCustomizers(T factory, List<WebServerFactoryCustomizer<?>> customizers) {
		LambdaSafe.callbacks(WebServerFactoryCustomizer.class, customizers, factory)
			.invoke((customizer) -> customizer.customize(factory));
	}
	protected void customize(T factory, ManagementServerProperties managementServerProperties,
			ServerProperties serverProperties) {
		factory.setPort(managementServerProperties.getPort());
		Ssl ssl = managementServerProperties.getSsl();
		if (ssl != null) {
			factory.setSsl(ssl);
		}
		factory.setServerHeader(serverProperties.getServerHeader());
		factory.setAddress(managementServerProperties.getAddress());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.jersey;
/**
@Configuration(proxyBeanMethods = false)
class JerseyManagementContextConfiguration {
	@Bean
	ServletRegistrationBean<ServletContainer> jerseyServletRegistration(JerseyApplicationPath jerseyApplicationPath,
			ResourceConfig resourceConfig) {
		return new ServletRegistrationBean<>(new ServletContainer(resourceConfig),
				jerseyApplicationPath.getUrlMapping());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.jersey;
/**
@ManagementContextConfiguration(value = ManagementContextType.CHILD, proxyBeanMethods = false)
@Import(JerseyManagementContextConfiguration.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(ResourceConfig.class)
@ConditionalOnMissingClass('org.springframework.web.servlet.DispatcherServlet')
public class JerseyChildManagementContextConfiguration {
	@Bean
	public JerseyApplicationPath jerseyApplicationPath() {
		return () -> '/';
	}
	@Bean
	ResourceConfig resourceConfig(ObjectProvider<ManagementContextResourceConfigCustomizer> customizers) {
		ResourceConfig resourceConfig = new ResourceConfig();
		customizers.orderedStream().forEach((customizer) -> customizer.customize(resourceConfig));
		return resourceConfig;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.web.jersey;
/*
package org.springframework.boot.actuate.autoconfigure.web.jersey;
/**
@ManagementContextConfiguration(value = ManagementContextType.SAME, proxyBeanMethods = false)
@EnableConfigurationProperties(JerseyProperties.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(ResourceConfig.class)
@ConditionalOnMissingClass('org.springframework.web.servlet.DispatcherServlet')
public class JerseySameManagementContextConfiguration {
	@Bean
	ResourceConfigCustomizer managementResourceConfigCustomizerAdapter(
			ObjectProvider<ManagementContextResourceConfigCustomizer> customizers) {
		return (config) -> customizers.orderedStream().forEach((customizer) -> customizer.customize(config));
	}
	@Configuration(proxyBeanMethods = false)
	@Import(JerseyManagementContextConfiguration.class)
	@ConditionalOnMissingBean(ResourceConfig.class)
	static class JerseyInfrastructureConfiguration {
		@Bean
		@ConditionalOnMissingBean(JerseyApplicationPath.class)
		JerseyApplicationPath jerseyApplicationPath(JerseyProperties properties, ResourceConfig config) {
			return new DefaultJerseyApplicationPath(properties.getApplicationPath(), config);
		}
		@Bean
		ResourceConfig resourceConfig(ObjectProvider<ResourceConfigCustomizer> resourceConfigCustomizers) {
			ResourceConfig resourceConfig = new ResourceConfig();
			resourceConfigCustomizers.orderedStream().forEach((customizer) -> customizer.customize(resourceConfig));
			return resourceConfig;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.jersey;
/**
public interface ManagementContextResourceConfigCustomizer {
	/**
	 * Customize the resource config.
	 * @param config the {@link ResourceConfig} to customize
	 */
	void customize(ResourceConfig config);
}
/*
package org.springframework.boot.actuate.autoconfigure.web.mappings;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(MappingsEndpoint.class)
public class MappingsEndpointAutoConfiguration {
	@Bean
	public MappingsEndpoint mappingsEndpoint(ApplicationContext applicationContext,
			ObjectProvider<MappingDescriptionProvider> descriptionProviders) {
		return new MappingsEndpoint(descriptionProviders.orderedStream().toList(), applicationContext);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	static class ServletWebConfiguration {
		@Bean
		ServletsMappingDescriptionProvider servletMappingDescriptionProvider() {
			return new ServletsMappingDescriptionProvider();
		}
		@Bean
		FiltersMappingDescriptionProvider filterMappingDescriptionProvider() {
			return new FiltersMappingDescriptionProvider();
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(DispatcherServlet.class)
		@ConditionalOnBean(DispatcherServlet.class)
		static class SpringMvcConfiguration {
			@Bean
			DispatcherServletsMappingDescriptionProvider dispatcherServletMappingDescriptionProvider() {
				return new DispatcherServletsMappingDescriptionProvider();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	@ConditionalOnClass(DispatcherHandler.class)
	@ConditionalOnBean(DispatcherHandler.class)
	static class ReactiveWebConfiguration {
		@Bean
		DispatcherHandlersMappingDescriptionProvider dispatcherHandlerMappingDescriptionProvider() {
			return new DispatcherHandlersMappingDescriptionProvider();
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.web.mappings;
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
@FunctionalInterface
public interface ManagementServletContext {
	/**
	 * Return the servlet path of the management server.
	 * @return the servlet path
	 */
	String getServletPath();
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
class CompositeHandlerAdapter implements HandlerAdapter {
	private final ListableBeanFactory beanFactory;
	private List<HandlerAdapter> adapters;
	CompositeHandlerAdapter(ListableBeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}
	@Override
	public boolean supports(Object handler) {
		return getAdapter(handler).isPresent();
	}
	@Override
	public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		Optional<HandlerAdapter> adapter = getAdapter(handler);
		if (adapter.isPresent()) {
			return adapter.get().handle(request, response, handler);
		}
		return null;
	}
	@Override
	@Deprecated(since = '2.4.9', forRemoval = false)
	@SuppressWarnings('deprecation')
	public long getLastModified(HttpServletRequest request, Object handler) {
		Optional<HandlerAdapter> adapter = getAdapter(handler);
		return adapter.map((handlerAdapter) -> handlerAdapter.getLastModified(request, handler)).orElse(0L);
	}
	private Optional<HandlerAdapter> getAdapter(Object handler) {
		if (this.adapters == null) {
			this.adapters = extractAdapters();
		}
		return this.adapters.stream().filter((a) -> a.supports(handler)).findFirst();
	}
	private List<HandlerAdapter> extractAdapters() {
		List<HandlerAdapter> list = new ArrayList<>(this.beanFactory.getBeansOfType(HandlerAdapter.class).values());
		list.remove(this);
		AnnotationAwareOrderComparator.sort(list);
		return list;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
@ManagementContextConfiguration(value = ManagementContextType.CHILD, proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(DispatcherServlet.class)
@EnableWebMvc
class WebMvcEndpointChildContextConfiguration {
	/*
	 * The error controller is present but not mapped as an endpoint in this context
	 * because of the DispatcherServlet having had its HandlerMapping explicitly disabled.
	 * So we expose the same feature but only for machine endpoints.
	 */
	@Bean
	@ConditionalOnBean(ErrorAttributes.class)
	ManagementErrorEndpoint errorEndpoint(ErrorAttributes errorAttributes, ServerProperties serverProperties) {
		return new ManagementErrorEndpoint(errorAttributes, serverProperties.getError());
	}
	@Bean
	@ConditionalOnBean(ErrorAttributes.class)
	ManagementErrorPageCustomizer managementErrorPageCustomizer(ServerProperties serverProperties) {
		return new ManagementErrorPageCustomizer(serverProperties);
	}
	@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
	DispatcherServlet dispatcherServlet() {
		DispatcherServlet dispatcherServlet = new DispatcherServlet();
		// Ensure the parent configuration does not leak down to us
		dispatcherServlet.setDetectAllHandlerAdapters(false);
		dispatcherServlet.setDetectAllHandlerExceptionResolvers(false);
		dispatcherServlet.setDetectAllHandlerMappings(false);
		dispatcherServlet.setDetectAllViewResolvers(false);
		return dispatcherServlet;
	}
	@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
	DispatcherServletRegistrationBean dispatcherServletRegistrationBean(DispatcherServlet dispatcherServlet) {
		return new DispatcherServletRegistrationBean(dispatcherServlet, '/');
	}
	@Bean(name = DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)
	CompositeHandlerMapping compositeHandlerMapping() {
		return new CompositeHandlerMapping();
	}
	@Bean(name = DispatcherServlet.HANDLER_ADAPTER_BEAN_NAME)
	CompositeHandlerAdapter compositeHandlerAdapter(ListableBeanFactory beanFactory) {
		return new CompositeHandlerAdapter(beanFactory);
	}
	@Bean(name = DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME)
	CompositeHandlerExceptionResolver compositeHandlerExceptionResolver() {
		return new CompositeHandlerExceptionResolver();
	}
	@Bean
	@ConditionalOnMissingBean({ RequestContextListener.class, RequestContextFilter.class })
	RequestContextFilter requestContextFilter() {
		return new OrderedRequestContextFilter();
	}
	/**
	 * {@link WebServerFactoryCustomizer} to add an {@link ErrorPage} so that the
	 * {@link ManagementErrorEndpoint} can be used.
	 */
	static class ManagementErrorPageCustomizer
			implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory>, Ordered {
		private final ServerProperties properties;
		ManagementErrorPageCustomizer(ServerProperties properties) {
			this.properties = properties;
		}
		@Override
		public void customize(ConfigurableServletWebServerFactory factory) {
			factory.addErrorPages(new ErrorPage(this.properties.getError().getPath()));
		}
		@Override
		public int getOrder() {
			return 0;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
class CompositeHandlerMapping implements HandlerMapping {
	@Autowired
	private ListableBeanFactory beanFactory;
	private List<HandlerMapping> mappings;
	@Override
	public HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
		for (HandlerMapping mapping : getMappings()) {
			HandlerExecutionChain handler = mapping.getHandler(request);
			if (handler != null) {
				return handler;
			}
		}
		return null;
	}
	@Override
	public boolean usesPathPatterns() {
		for (HandlerMapping mapping : getMappings()) {
			if (mapping.usesPathPatterns()) {
				return true;
			}
		}
		return false;
	}
	private List<HandlerMapping> getMappings() {
		if (this.mappings == null) {
			this.mappings = extractMappings();
		}
		return this.mappings;
	}
	private List<HandlerMapping> extractMappings() {
		List<HandlerMapping> list = new ArrayList<>(this.beanFactory.getBeansOfType(HandlerMapping.class).values());
		list.remove(this);
		AnnotationAwareOrderComparator.sort(list);
		return list;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
@ManagementContextConfiguration(value = ManagementContextType.CHILD, proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
class ServletManagementChildContextConfiguration {
	@Bean
	ServletManagementWebServerFactoryCustomizer servletManagementWebServerFactoryCustomizer(
			ListableBeanFactory beanFactory) {
		return new ServletManagementWebServerFactoryCustomizer(beanFactory);
	}
	@Bean
	@ConditionalOnClass(name = 'io.undertow.Undertow')
	UndertowAccessLogCustomizer undertowManagementAccessLogCustomizer() {
		return new UndertowAccessLogCustomizer();
	}
	@Bean
	@ConditionalOnClass(name = 'org.apache.catalina.valves.AccessLogValve')
	TomcatAccessLogCustomizer tomcatManagementAccessLogCustomizer() {
		return new TomcatAccessLogCustomizer();
	}
	@Bean
	@ConditionalOnClass(name = 'org.eclipse.jetty.server.Server')
	JettyAccessLogCustomizer jettyManagementAccessLogCustomizer() {
		return new JettyAccessLogCustomizer();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })
	@ConditionalOnBean(name = BeanIds.SPRING_SECURITY_FILTER_CHAIN, search = SearchStrategy.ANCESTORS)
	static class ServletManagementContextSecurityConfiguration {
		@Bean
		Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {
			BeanFactory parent = beanFactory.getParentBeanFactory();
			return parent.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class);
		}
		@Bean
		@ConditionalOnBean(name = 'securityFilterChainRegistration', search = SearchStrategy.ANCESTORS)
		DelegatingFilterProxyRegistrationBean securityFilterChainRegistration(HierarchicalBeanFactory beanFactory) {
			return beanFactory.getParentBeanFactory()
				.getBean('securityFilterChainRegistration', DelegatingFilterProxyRegistrationBean.class);
		}
	}
	static class ServletManagementWebServerFactoryCustomizer
			extends ManagementWebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {
		ServletManagementWebServerFactoryCustomizer(ListableBeanFactory beanFactory) {
			super(beanFactory, ServletWebServerFactoryCustomizer.class, TomcatServletWebServerFactoryCustomizer.class,
					TomcatWebServerFactoryCustomizer.class, TomcatVirtualThreadsWebServerFactoryCustomizer.class,
					JettyWebServerFactoryCustomizer.class, JettyVirtualThreadsWebServerFactoryCustomizer.class,
					UndertowServletWebServerFactoryCustomizer.class, UndertowWebServerFactoryCustomizer.class);
		}
		@Override
		protected void customize(ConfigurableServletWebServerFactory webServerFactory,
				ManagementServerProperties managementServerProperties, ServerProperties serverProperties) {
			super.customize(webServerFactory, managementServerProperties, serverProperties);
			webServerFactory.setContextPath(getContextPath(managementServerProperties));
		}
		private String getContextPath(ManagementServerProperties managementServerProperties) {
			String basePath = managementServerProperties.getBasePath();
			return StringUtils.hasText(basePath) ? basePath : '';
		}
	}
	abstract static class AccessLogCustomizer implements Ordered {
		private static final String MANAGEMENT_PREFIX = 'management_';
		protected String customizePrefix(String prefix) {
			prefix = (prefix != null) ? prefix : '';
			if (prefix.startsWith(MANAGEMENT_PREFIX)) {
				return prefix;
			}
			return MANAGEMENT_PREFIX + prefix;
		}
		@Override
		public int getOrder() {
			return 1;
		}
	}
	static class TomcatAccessLogCustomizer extends AccessLogCustomizer
			implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {
		@Override
		public void customize(TomcatServletWebServerFactory factory) {
			AccessLogValve accessLogValve = findAccessLogValve(factory);
			if (accessLogValve == null) {
				return;
			}
			accessLogValve.setPrefix(customizePrefix(accessLogValve.getPrefix()));
		}
		private AccessLogValve findAccessLogValve(TomcatServletWebServerFactory factory) {
			for (Valve engineValve : factory.getEngineValves()) {
				if (engineValve instanceof AccessLogValve accessLogValve) {
					return accessLogValve;
				}
			}
			return null;
		}
	}
	static class UndertowAccessLogCustomizer extends AccessLogCustomizer
			implements WebServerFactoryCustomizer<UndertowServletWebServerFactory> {
		@Override
		public void customize(UndertowServletWebServerFactory factory) {
			factory.setAccessLogPrefix(customizePrefix(factory.getAccessLogPrefix()));
		}
	}
	static class JettyAccessLogCustomizer extends AccessLogCustomizer
			implements WebServerFactoryCustomizer<JettyServletWebServerFactory> {
		@Override
		public void customize(JettyServletWebServerFactory factory) {
			factory.addServerCustomizers(this::customizeServer);
		}
		private void customizeServer(Server server) {
			RequestLog requestLog = server.getRequestLog();
			if (requestLog instanceof CustomRequestLog customRequestLog) {
				customizeRequestLog(customRequestLog);
			}
		}
		private void customizeRequestLog(CustomRequestLog requestLog) {
			if (requestLog.getWriter() instanceof RequestLogWriter requestLogWriter) {
				customizeRequestLogWriter(requestLogWriter);
			}
		}
		private void customizeRequestLogWriter(RequestLogWriter writer) {
			String filename = writer.getFileName();
			if (StringUtils.hasLength(filename)) {
				File file = new File(filename);
				file = new File(file.getParentFile(), customizePrefix(file.getName()));
				writer.setFilename(file.getPath());
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
class CompositeHandlerExceptionResolver implements HandlerExceptionResolver {
	@Autowired
	private ListableBeanFactory beanFactory;
	private volatile List<HandlerExceptionResolver> resolvers;
	@Override
	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception ex) {
		for (HandlerExceptionResolver resolver : getResolvers()) {
			ModelAndView resolved = resolver.resolveException(request, response, handler, ex);
			if (resolved != null) {
				return resolved;
			}
		}
		return null;
	}
	private List<HandlerExceptionResolver> getResolvers() {
		List<HandlerExceptionResolver> resolvers = this.resolvers;
		if (resolvers == null) {
			resolvers = new ArrayList<>();
			collectResolverBeans(resolvers, this.beanFactory);
			resolvers.remove(this);
			AnnotationAwareOrderComparator.sort(resolvers);
			if (resolvers.isEmpty()) {
				resolvers.add(new DefaultErrorAttributes());
				resolvers.add(new DefaultHandlerExceptionResolver());
			}
			this.resolvers = resolvers;
		}
		return resolvers;
	}
	private void collectResolverBeans(List<HandlerExceptionResolver> resolvers, BeanFactory beanFactory) {
		if (beanFactory instanceof ListableBeanFactory listableBeanFactory) {
			resolvers.addAll(listableBeanFactory.getBeansOfType(HandlerExceptionResolver.class).values());
		}
		if (beanFactory instanceof HierarchicalBeanFactory hierarchicalBeanFactory) {
			collectResolverBeans(resolvers, hierarchicalBeanFactory.getParentBeanFactory());
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
@Controller
public class ManagementErrorEndpoint {
	private final ErrorAttributes errorAttributes;
	private final ErrorProperties errorProperties;
	public ManagementErrorEndpoint(ErrorAttributes errorAttributes, ErrorProperties errorProperties) {
		Assert.notNull(errorAttributes, 'ErrorAttributes must not be null');
		Assert.notNull(errorProperties, 'ErrorProperties must not be null');
		this.errorAttributes = errorAttributes;
		this.errorProperties = errorProperties;
	}
	@RequestMapping('${server.error.path:${error.path:/error}}')
	@ResponseBody
	public Map<String, Object> invoke(ServletWebRequest request) {
		return this.errorAttributes.getErrorAttributes(request, getErrorAttributeOptions(request));
	}
	private ErrorAttributeOptions getErrorAttributeOptions(ServletWebRequest request) {
		ErrorAttributeOptions options = ErrorAttributeOptions.defaults();
		if (this.errorProperties.isIncludeException()) {
			options = options.including(Include.EXCEPTION);
		}
		if (includeStackTrace(request)) {
			options = options.including(Include.STACK_TRACE);
		}
		if (includeMessage(request)) {
			options = options.including(Include.MESSAGE);
		}
		if (includeBindingErrors(request)) {
			options = options.including(Include.BINDING_ERRORS);
		}
		options = includePath(request) ? options.including(Include.PATH) : options.excluding(Include.PATH);
		return options;
	}
	private boolean includeStackTrace(ServletWebRequest request) {
		return switch (this.errorProperties.getIncludeStacktrace()) {
			case ALWAYS -> true;
			case ON_PARAM -> getBooleanParameter(request, 'trace');
			case NEVER -> false;
		};
	}
	private boolean includeMessage(ServletWebRequest request) {
		return switch (this.errorProperties.getIncludeMessage()) {
			case ALWAYS -> true;
			case ON_PARAM -> getBooleanParameter(request, 'message');
			case NEVER -> false;
		};
	}
	private boolean includeBindingErrors(ServletWebRequest request) {
		return switch (this.errorProperties.getIncludeBindingErrors()) {
			case ALWAYS -> true;
			case ON_PARAM -> getBooleanParameter(request, 'errors');
			case NEVER -> false;
		};
	}
	private boolean includePath(ServletWebRequest request) {
		return switch (this.errorProperties.getIncludePath()) {
			case ALWAYS -> true;
			case ON_PARAM -> getBooleanParameter(request, 'path');
			case NEVER -> false;
		};
	}
	protected boolean getBooleanParameter(ServletWebRequest request, String parameterName) {
		String parameter = request.getParameter(parameterName);
		if (parameter == null) {
			return false;
		}
		return !'false'.equalsIgnoreCase(parameter);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.servlet;
/**
@AutoConfiguration
@ConditionalOnClass(Servlet.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
public class ServletManagementContextAutoConfiguration {
	@Bean
	public static ManagementContextFactory servletWebChildContextFactory() {
		return new ManagementContextFactory(WebApplicationType.SERVLET, ServletWebServerFactory.class,
				ServletWebServerFactoryAutoConfiguration.class);
	}
	@Bean
	public ManagementServletContext managementServletContext(WebEndpointProperties properties) {
		return properties::getBasePath;
	}
	// Put Servlets and Filters in their own nested class so they don"t force early
	// instantiation of ManagementServerProperties.
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'management.server', name = 'add-application-context-header', havingValue = 'true')
	protected static class ApplicationContextFilterConfiguration {
		@Bean
		public ApplicationContextHeaderFilter applicationContextIdFilter(ApplicationContext context) {
			return new ApplicationContextHeaderFilter(context);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.web;
/*
package org.springframework.boot.actuate.autoconfigure.web;
/**
public enum ManagementContextType {
	/**
	 * The management context is the same as the main application context.
	 */
	SAME,
	/**
	 * The management context is a separate context that is a child of the main
	 * application context.
	 */
	CHILD,
	/**
	 * The management context can be either the same as the main application context or a
	 * child of the main application context.
	 */
	ANY
}
/*
package org.springframework.boot.actuate.autoconfigure.web.reactive;
/**
@EnableWebFlux
@ManagementContextConfiguration(value = ManagementContextType.CHILD, proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.REACTIVE)
public class ReactiveManagementChildContextConfiguration {
	@Bean
	public ReactiveManagementWebServerFactoryCustomizer reactiveManagementWebServerFactoryCustomizer(
			ListableBeanFactory beanFactory) {
		return new ReactiveManagementWebServerFactoryCustomizer(beanFactory);
	}
	@Bean
	public HttpHandler httpHandler(ApplicationContext applicationContext, ManagementServerProperties properties) {
		HttpHandler httpHandler = WebHttpHandlerBuilder.applicationContext(applicationContext).build();
		if (StringUtils.hasText(properties.getBasePath())) {
			Map<String, HttpHandler> handlersMap = Collections.singletonMap(properties.getBasePath(), httpHandler);
			return new ContextPathCompositeHandler(handlersMap);
		}
		return httpHandler;
	}
	static class ReactiveManagementWebServerFactoryCustomizer
			extends ManagementWebServerFactoryCustomizer<ConfigurableReactiveWebServerFactory> {
		ReactiveManagementWebServerFactoryCustomizer(ListableBeanFactory beanFactory) {
			super(beanFactory, ReactiveWebServerFactoryCustomizer.class, TomcatWebServerFactoryCustomizer.class,
					TomcatReactiveWebServerFactoryCustomizer.class,
					TomcatVirtualThreadsWebServerFactoryCustomizer.class, JettyWebServerFactoryCustomizer.class,
					JettyVirtualThreadsWebServerFactoryCustomizer.class, UndertowWebServerFactoryCustomizer.class,
					NettyWebServerFactoryCustomizer.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.web.reactive;
/**
@AutoConfiguration
@ConditionalOnClass(Flux.class)
@ConditionalOnWebApplication(type = Type.REACTIVE)
public class ReactiveManagementContextAutoConfiguration {
	@Bean
	public static ManagementContextFactory reactiveWebChildContextFactory() {
		return new ManagementContextFactory(WebApplicationType.REACTIVE, ReactiveWebServerFactory.class,
				ReactiveWebServerFactoryAutoConfiguration.class);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.web.reactive;
/*
package org.springframework.boot.actuate.autoconfigure.web;
/**
public final class ManagementContextFactory {
	private final WebApplicationType webApplicationType;
	private final Class<? extends WebServerFactory> webServerFactoryClass;
	private final Class<?>[] autoConfigurationClasses;
	public ManagementContextFactory(WebApplicationType webApplicationType,
			Class<? extends WebServerFactory> webServerFactoryClass, Class<?>... autoConfigurationClasses) {
		this.webApplicationType = webApplicationType;
		this.webServerFactoryClass = webServerFactoryClass;
		this.autoConfigurationClasses = autoConfigurationClasses;
	}
	public ConfigurableApplicationContext createManagementContext(ApplicationContext parentContext) {
		Environment parentEnvironment = parentContext.getEnvironment();
		ConfigurableEnvironment childEnvironment = ApplicationContextFactory.DEFAULT
			.createEnvironment(this.webApplicationType);
		if (parentEnvironment instanceof ConfigurableEnvironment configurableEnvironment) {
			childEnvironment.setConversionService((configurableEnvironment).getConversionService());
		}
		ConfigurableApplicationContext managementContext = ApplicationContextFactory.DEFAULT
			.create(this.webApplicationType);
		managementContext.setEnvironment(childEnvironment);
		managementContext.setParent(parentContext);
		return managementContext;
	}
	public void registerWebServerFactoryBeans(ApplicationContext parentContext,
			ConfigurableApplicationContext managementContext, AnnotationConfigRegistry registry) {
		registry.register(this.autoConfigurationClasses);
		registerWebServerFactoryFromParent(parentContext, managementContext);
	}
	private void registerWebServerFactoryFromParent(ApplicationContext parentContext,
			ConfigurableApplicationContext managementContext) {
		try {
			if (managementContext.getBeanFactory() instanceof BeanDefinitionRegistry registry) {
				registry.registerBeanDefinition('ManagementContextWebServerFactory',
						new RootBeanDefinition(determineWebServerFactoryClass(parentContext)));
			}
		}
		catch (NoSuchBeanDefinitionException ex) {
			// Ignore and assume auto-configuration
		}
	}
	private Class<?> determineWebServerFactoryClass(ApplicationContext parent) throws NoSuchBeanDefinitionException {
		Class<?> factoryClass = parent.getBean(this.webServerFactoryClass).getClass();
		if (cannotBeInstantiated(factoryClass)) {
			throw new FatalBeanException('ManagementContextWebServerFactory implementation ' + factoryClass.getName()
					+ ' cannot be instantiated. To allow a separate management port to be used, a top-level class '
					+ 'or static inner class should be used instead');
		}
		return factoryClass;
	}
	private boolean cannotBeInstantiated(Class<?> factoryClass) {
		return factoryClass.isLocalClass()
				|| (factoryClass.isMemberClass() && !Modifier.isStatic(factoryClass.getModifiers()))
				|| factoryClass.isAnonymousClass();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.integration;
/**
@AutoConfiguration(after = IntegrationAutoConfiguration.class)
@ConditionalOnClass(IntegrationGraphServer.class)
@ConditionalOnBean(IntegrationConfigurationBeanFactoryPostProcessor.class)
@ConditionalOnAvailableEndpoint(IntegrationGraphEndpoint.class)
public class IntegrationGraphEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public IntegrationGraphEndpoint integrationGraphEndpoint(IntegrationGraphServer integrationGraphServer) {
		return new IntegrationGraphEndpoint(integrationGraphServer);
	}
	@Bean
	@ConditionalOnMissingBean
	public IntegrationGraphServer integrationGraphServer() {
		return new IntegrationGraphServer();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.integration;
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@Configuration(proxyBeanMethods = false)
class HealthEndpointConfiguration {
	@Bean
	@ConditionalOnMissingBean
	StatusAggregator healthStatusAggregator(HealthEndpointProperties properties) {
		return new SimpleStatusAggregator(properties.getStatus().getOrder());
	}
	@Bean
	@ConditionalOnMissingBean
	HttpCodeStatusMapper healthHttpCodeStatusMapper(HealthEndpointProperties properties) {
		return new SimpleHttpCodeStatusMapper(properties.getStatus().getHttpMapping());
	}
	@Bean
	@ConditionalOnMissingBean(HealthEndpointGroups.class)
	AutoConfiguredHealthEndpointGroups healthEndpointGroups(ApplicationContext applicationContext,
			HealthEndpointProperties properties) {
		return new AutoConfiguredHealthEndpointGroups(applicationContext, properties);
	}
	@Bean
	@ConditionalOnMissingBean
	HealthContributorRegistry healthContributorRegistry(ApplicationContext applicationContext,
			HealthEndpointGroups groups, Map<String, HealthContributor> healthContributors,
			Map<String, ReactiveHealthContributor> reactiveHealthContributors) {
		if (ClassUtils.isPresent('reactor.core.publisher.Flux', applicationContext.getClassLoader())) {
			healthContributors.putAll(new AdaptedReactiveHealthContributors(reactiveHealthContributors).get());
		}
		return new AutoConfiguredHealthContributorRegistry(healthContributors, groups.getNames());
	}
	@Bean
	@ConditionalOnProperty(name = 'management.endpoint.health.validate-group-membership', havingValue = 'true',
			matchIfMissing = true)
	HealthEndpointGroupMembershipValidator healthEndpointGroupMembershipValidator(HealthEndpointProperties properties,
			HealthContributorRegistry healthContributorRegistry) {
		return new HealthEndpointGroupMembershipValidator(properties, healthContributorRegistry);
	}
	@Bean
	@ConditionalOnMissingBean
	HealthEndpoint healthEndpoint(HealthContributorRegistry registry, HealthEndpointGroups groups,
			HealthEndpointProperties properties) {
		return new HealthEndpoint(registry, groups, properties.getLogging().getSlowIndicatorThreshold());
	}
	@Bean
	static HealthEndpointGroupsBeanPostProcessor healthEndpointGroupsBeanPostProcessor(
			ObjectProvider<HealthEndpointGroupsPostProcessor> healthEndpointGroupsPostProcessors) {
		return new HealthEndpointGroupsBeanPostProcessor(healthEndpointGroupsPostProcessors);
	}
	/**
	 * {@link BeanPostProcessor} to invoke {@link HealthEndpointGroupsPostProcessor}
	 * beans.
	 */
	static class HealthEndpointGroupsBeanPostProcessor implements BeanPostProcessor {
		private final ObjectProvider<HealthEndpointGroupsPostProcessor> postProcessors;
		HealthEndpointGroupsBeanPostProcessor(ObjectProvider<HealthEndpointGroupsPostProcessor> postProcessors) {
			this.postProcessors = postProcessors;
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			if (bean instanceof HealthEndpointGroups groups) {
				return applyPostProcessors(groups);
			}
			return bean;
		}
		private Object applyPostProcessors(HealthEndpointGroups bean) {
			for (HealthEndpointGroupsPostProcessor postProcessor : this.postProcessors.orderedStream()
				.toArray(HealthEndpointGroupsPostProcessor[]::new)) {
				bean = postProcessor.postProcessHealthEndpointGroups(bean);
			}
			return bean;
		}
	}
	/**
	 * Adapter to expose {@link ReactiveHealthContributor} beans as
	 * {@link HealthContributor} instances.
	 */
	private static class AdaptedReactiveHealthContributors {
		private final Map<String, HealthContributor> adapted;
		AdaptedReactiveHealthContributors(Map<String, ReactiveHealthContributor> reactiveContributors) {
			Map<String, HealthContributor> adapted = new LinkedHashMap<>();
			reactiveContributors.forEach((name, contributor) -> adapted.put(name, adapt(contributor)));
			this.adapted = Collections.unmodifiableMap(adapted);
		}
		private HealthContributor adapt(ReactiveHealthContributor contributor) {
			if (contributor instanceof ReactiveHealthIndicator healthIndicator) {
				return adapt(healthIndicator);
			}
			if (contributor instanceof CompositeReactiveHealthContributor healthContributor) {
				return adapt(healthContributor);
			}
			throw new IllegalStateException('Unsupported ReactiveHealthContributor type ' + contributor.getClass());
		}
		private HealthIndicator adapt(ReactiveHealthIndicator indicator) {
			return new HealthIndicator() {
				@Override
				public Health getHealth(boolean includeDetails) {
					return indicator.getHealth(includeDetails).block();
				}
				@Override
				public Health health() {
					return indicator.health().block();
				}
			};
		}
		private CompositeHealthContributor adapt(CompositeReactiveHealthContributor composite) {
			return new CompositeHealthContributor() {
				@Override
				public Iterator<NamedContributor<HealthContributor>> iterator() {
					Iterator<NamedContributor<ReactiveHealthContributor>> iterator = composite.iterator();
					return new Iterator<>() {
						@Override
						public boolean hasNext() {
							return iterator.hasNext();
						}
						@Override
						public NamedContributor<HealthContributor> next() {
							NamedContributor<ReactiveHealthContributor> next = iterator.next();
							return NamedContributor.of(next.getName(), adapt(next.getContributor()));
						}
					};
				}
				@Override
				public HealthContributor getContributor(String name) {
					return adapt(composite.getContributor(name));
				}
			};
		}
		Map<String, HealthContributor> get() {
			return this.adapted;
		}
	}
	/**
	 * {@link SmartInitializingSingleton} that validates health endpoint group membership,
	 * throwing a {@link NoSuchHealthContributorException} if an included or excluded
	 * contributor does not exist.
	 */
	static class HealthEndpointGroupMembershipValidator implements SmartInitializingSingleton {
		private final HealthEndpointProperties properties;
		private final HealthContributorRegistry registry;
		HealthEndpointGroupMembershipValidator(HealthEndpointProperties properties,
				HealthContributorRegistry registry) {
			this.properties = properties;
			this.registry = registry;
		}
		@Override
		public void afterSingletonsInstantiated() {
			validateGroups();
		}
		private void validateGroups() {
			this.properties.getGroup().forEach((name, group) -> {
				validate(group.getInclude(), 'Included', name);
				validate(group.getExclude(), 'Excluded', name);
			});
		}
		private void validate(Set<String> names, String type, String group) {
			if (CollectionUtils.isEmpty(names)) {
				return;
			}
			for (String name : names) {
				if ('*'.equals(name)) {
					return;
				}
				String[] path = name.split('/');
				if (!contributorExists(path)) {
					throw new NoSuchHealthContributorException(type, name, group);
				}
			}
		}
		private boolean contributorExists(String[] path) {
			int pathOffset = 0;
			Object contributor = this.registry;
			while (pathOffset < path.length) {
				if (!(contributor instanceof NamedContributors)) {
					return false;
				}
				contributor = ((NamedContributors<?>) contributor).getContributor(path[pathOffset]);
				pathOffset++;
			}
			return (contributor != null);
		}
		/**
		 * Thrown when a contributor that does not exist is included in or excluded from a
		 * group.
		 */
		static class NoSuchHealthContributorException extends RuntimeException {
			NoSuchHealthContributorException(String type, String name, String group) {
				super(type + ' health contributor "' + name + '" in group "' + group + '" does not exist');
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class AutoConfiguredHealthEndpointGroup implements HealthEndpointGroup {
	private final Predicate<String> members;
	private final StatusAggregator statusAggregator;
	private final HttpCodeStatusMapper httpCodeStatusMapper;
	private final Show showComponents;
	private final Show showDetails;
	private final Collection<String> roles;
	private final AdditionalHealthEndpointPath additionalPath;
	/**
	 * Create a new {@link AutoConfiguredHealthEndpointGroup} instance.
	 * @param members a predicate used to test for group membership
	 * @param statusAggregator the status aggregator to use
	 * @param httpCodeStatusMapper the HTTP code status mapper to use
	 * @param showComponents the show components setting
	 * @param showDetails the show details setting
	 * @param roles the roles to match
	 * @param additionalPath the additional path to use for this group
	 */
	AutoConfiguredHealthEndpointGroup(Predicate<String> members, StatusAggregator statusAggregator,
			HttpCodeStatusMapper httpCodeStatusMapper, Show showComponents, Show showDetails, Collection<String> roles,
			AdditionalHealthEndpointPath additionalPath) {
		this.members = members;
		this.statusAggregator = statusAggregator;
		this.httpCodeStatusMapper = httpCodeStatusMapper;
		this.showComponents = showComponents;
		this.showDetails = showDetails;
		this.roles = roles;
		this.additionalPath = additionalPath;
	}
	@Override
	public boolean isMember(String name) {
		return this.members.test(name);
	}
	@Override
	public boolean showComponents(SecurityContext securityContext) {
		Show show = (this.showComponents != null) ? this.showComponents : this.showDetails;
		return show.isShown(securityContext, this.roles);
	}
	@Override
	public boolean showDetails(SecurityContext securityContext) {
		return this.showDetails.isShown(securityContext, this.roles);
	}
	@Override
	public StatusAggregator getStatusAggregator() {
		return this.statusAggregator;
	}
	@Override
	public HttpCodeStatusMapper getHttpCodeStatusMapper() {
		return this.httpCodeStatusMapper;
	}
	@Override
	public AdditionalHealthEndpointPath getAdditionalPath() {
		return this.additionalPath;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
public abstract class CompositeHealthContributorConfiguration<I extends HealthIndicator, B>
		extends AbstractCompositeHealthContributorConfiguration<HealthContributor, I, B> {
	/**
	 * Creates a {@code CompositeHealthContributorConfiguration} that will use the given
	 * {@code indicatorFactory} to create {@link HealthIndicator} instances.
	 * @param indicatorFactory the function to create health indicator instances
	 * @since 3.0.0
	 */
	public CompositeHealthContributorConfiguration(Function<B, I> indicatorFactory) {
		super(indicatorFactory);
	}
	@Override
	protected final HealthContributor createComposite(Map<String, B> beans) {
		return CompositeHealthContributor.fromMap(beans, this::createIndicator);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class AutoConfiguredHealthContributorRegistry extends DefaultHealthContributorRegistry {
	private final Collection<String> groupNames;
	AutoConfiguredHealthContributorRegistry(Map<String, HealthContributor> contributors,
			Collection<String> groupNames) {
		super(contributors);
		this.groupNames = groupNames;
		contributors.keySet().forEach(this::assertDoesNotClashWithGroup);
	}
	@Override
	public void registerContributor(String name, HealthContributor contributor) {
		assertDoesNotClashWithGroup(name);
		super.registerContributor(name, contributor);
	}
	private void assertDoesNotClashWithGroup(String name) {
		Assert.state(!this.groupNames.contains(name),
				() -> 'HealthContributor with name \'' + name + '\' clashes with group');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.REACTIVE)
@ConditionalOnAvailableEndpoint(endpoint = HealthEndpoint.class, exposure = EndpointExposure.WEB)
class HealthEndpointReactiveWebExtensionConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(HealthEndpoint.class)
	ReactiveHealthEndpointWebExtension reactiveHealthEndpointWebExtension(
			ReactiveHealthContributorRegistry reactiveHealthContributorRegistry, HealthEndpointGroups groups,
			HealthEndpointProperties properties) {
		return new ReactiveHealthEndpointWebExtension(reactiveHealthContributorRegistry, groups,
				properties.getLogging().getSlowIndicatorThreshold());
	}
	@Configuration(proxyBeanMethods = false)
	static class WebFluxAdditionalHealthEndpointPathsConfiguration {
		@Bean
		AdditionalHealthEndpointPathsWebFluxHandlerMapping healthEndpointWebFluxHandlerMapping(
				WebEndpointsSupplier webEndpointsSupplier, HealthEndpointGroups groups) {
			Collection<ExposableWebEndpoint> webEndpoints = webEndpointsSupplier.getEndpoints();
			ExposableWebEndpoint health = webEndpoints.stream()
				.filter((endpoint) -> endpoint.getEndpointId().equals(HealthEndpoint.ID))
				.findFirst()
				.orElse(null);
			return new AdditionalHealthEndpointPathsWebFluxHandlerMapping(new EndpointMapping(''), health,
					groups.getAllWithAdditionalPath(WebServerNamespace.SERVER));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnBean(HealthEndpoint.class)
@ConditionalOnAvailableEndpoint(endpoint = HealthEndpoint.class, exposure = EndpointExposure.WEB)
class HealthEndpointWebExtensionConfiguration {
	@Bean
	@ConditionalOnMissingBean
	HealthEndpointWebExtension healthEndpointWebExtension(HealthContributorRegistry healthContributorRegistry,
			HealthEndpointGroups groups, HealthEndpointProperties properties) {
		return new HealthEndpointWebExtension(healthContributorRegistry, groups,
				properties.getLogging().getSlowIndicatorThreshold());
	}
	private static ExposableWebEndpoint getHealthEndpoint(WebEndpointsSupplier webEndpointsSupplier) {
		Collection<ExposableWebEndpoint> webEndpoints = webEndpointsSupplier.getEndpoints();
		return webEndpoints.stream()
			.filter((endpoint) -> endpoint.getEndpointId().equals(HealthEndpoint.ID))
			.findFirst()
			.orElse(null);
	}
	@ConditionalOnBean(DispatcherServlet.class)
	static class MvcAdditionalHealthEndpointPathsConfiguration {
		@Bean
		AdditionalHealthEndpointPathsWebMvcHandlerMapping healthEndpointWebMvcHandlerMapping(
				WebEndpointsSupplier webEndpointsSupplier, HealthEndpointGroups groups) {
			ExposableWebEndpoint health = getHealthEndpoint(webEndpointsSupplier);
			return new AdditionalHealthEndpointPathsWebMvcHandlerMapping(health,
					groups.getAllWithAdditionalPath(WebServerNamespace.SERVER));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ResourceConfig.class)
	@ConditionalOnMissingClass('org.springframework.web.servlet.DispatcherServlet')
	static class JerseyAdditionalHealthEndpointPathsConfiguration {
		@Bean
		JerseyAdditionalHealthEndpointPathsResourcesRegistrar jerseyAdditionalHealthEndpointPathsResourcesRegistrar(
				WebEndpointsSupplier webEndpointsSupplier, HealthEndpointGroups healthEndpointGroups) {
			ExposableWebEndpoint health = getHealthEndpoint(webEndpointsSupplier);
			return new JerseyAdditionalHealthEndpointPathsResourcesRegistrar(health, healthEndpointGroups);
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnMissingBean(ResourceConfig.class)
		@EnableConfigurationProperties(JerseyProperties.class)
		static class JerseyInfrastructureConfiguration {
			@Bean
			@ConditionalOnMissingBean(JerseyApplicationPath.class)
			JerseyApplicationPath jerseyApplicationPath(JerseyProperties properties, ResourceConfig config) {
				return new DefaultJerseyApplicationPath(properties.getApplicationPath(), config);
			}
			@Bean
			ResourceConfig resourceConfig(ObjectProvider<ResourceConfigCustomizer> resourceConfigCustomizers) {
				ResourceConfig resourceConfig = new ResourceConfig();
				resourceConfigCustomizers.orderedStream().forEach((customizer) -> customizer.customize(resourceConfig));
				return resourceConfig;
			}
			@Bean
			ServletRegistrationBean<ServletContainer> jerseyServletRegistration(
					JerseyApplicationPath jerseyApplicationPath, ResourceConfig resourceConfig) {
				return new ServletRegistrationBean<>(new ServletContainer(resourceConfig),
						jerseyApplicationPath.getUrlMapping());
			}
		}
	}
	static class JerseyAdditionalHealthEndpointPathsResourcesRegistrar implements ResourceConfigCustomizer {
		private final ExposableWebEndpoint endpoint;
		private final HealthEndpointGroups groups;
		JerseyAdditionalHealthEndpointPathsResourcesRegistrar(ExposableWebEndpoint endpoint,
				HealthEndpointGroups groups) {
			this.endpoint = endpoint;
			this.groups = groups;
		}
		@Override
		public void customize(ResourceConfig config) {
			register(config);
		}
		private void register(ResourceConfig config) {
			EndpointMapping mapping = new EndpointMapping('');
			JerseyHealthEndpointAdditionalPathResourceFactory resourceFactory = new JerseyHealthEndpointAdditionalPathResourceFactory(
					WebServerNamespace.SERVER, this.groups);
			Collection<Resource> endpointResources = resourceFactory
				.createEndpointResources(mapping,
						(this.endpoint != null) ? Collections.singletonList(this.endpoint) : Collections.emptyList())
				.stream()
				.filter(Objects::nonNull)
				.toList();
			register(endpointResources, config);
		}
		private void register(Collection<Resource> resources, ResourceConfig config) {
			config.registerResources(new HashSet<>(resources));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(Flux.class)
@ConditionalOnBean(HealthEndpoint.class)
class ReactiveHealthEndpointConfiguration {
	@Bean
	@ConditionalOnMissingBean
	ReactiveHealthContributorRegistry reactiveHealthContributorRegistry(
			Map<String, HealthContributor> healthContributors,
			Map<String, ReactiveHealthContributor> reactiveHealthContributors, HealthEndpointGroups groups) {
		Map<String, ReactiveHealthContributor> allContributors = new LinkedHashMap<>(reactiveHealthContributors);
		healthContributors.forEach((name, contributor) -> allContributors.computeIfAbsent(name,
				(key) -> ReactiveHealthContributor.adapt(contributor)));
		return new AutoConfiguredReactiveHealthContributorRegistry(allContributors, groups.getNames());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnEnabledHealthIndicatorCondition.class)
public @interface ConditionalOnEnabledHealthIndicator {
	/**
	 * The name of the health indicator.
	 * @return the name of the health indicator
	 */
	String value();
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@AutoConfiguration
public class HealthContributorAutoConfiguration {
	@Bean
	@ConditionalOnEnabledHealthIndicator('ping')
	public PingHealthIndicator pingHealthContributor() {
		return new PingHealthIndicator();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@ConfigurationProperties('management.endpoint.health')
public class HealthEndpointProperties extends HealthProperties {
	/**
	 * When to show full health details.
	 */
	private Show showDetails = Show.NEVER;
	/**
	 * Health endpoint groups.
	 */
	private final Map<String, Group> group = new LinkedHashMap<>();
	private final Logging logging = new Logging();
	@Override
	public Show getShowDetails() {
		return this.showDetails;
	}
	public void setShowDetails(Show showDetails) {
		this.showDetails = showDetails;
	}
	public Map<String, Group> getGroup() {
		return this.group;
	}
	public Logging getLogging() {
		return this.logging;
	}
	/**
	 * A health endpoint group.
	 */
	public static class Group extends HealthProperties {
		public static final String SERVER_PREFIX = 'server:';
		public static final String MANAGEMENT_PREFIX = 'management:';
		/**
		 * Health indicator IDs that should be included or "*" for all.
		 */
		private Set<String> include;
		/**
		 * Health indicator IDs that should be excluded or "*" for all.
		 */
		private Set<String> exclude;
		/**
		 * When to show full health details. Defaults to the value of
		 * "management.endpoint.health.show-details".
		 */
		private Show showDetails;
		/**
		 * Additional path that this group can be made available on. The additional path
		 * must start with a valid prefix, either `server` or `management` to indicate if
		 * it will be available on the main port or the management port. For instance,
		 * `server:/healthz` will configure the group on the main port at `/healthz`.
		 */
		private String additionalPath;
		public Set<String> getInclude() {
			return this.include;
		}
		public void setInclude(Set<String> include) {
			this.include = include;
		}
		public Set<String> getExclude() {
			return this.exclude;
		}
		public void setExclude(Set<String> exclude) {
			this.exclude = exclude;
		}
		@Override
		public Show getShowDetails() {
			return this.showDetails;
		}
		public void setShowDetails(Show showDetails) {
			this.showDetails = showDetails;
		}
		public String getAdditionalPath() {
			return this.additionalPath;
		}
		public void setAdditionalPath(String additionalPath) {
			this.additionalPath = additionalPath;
		}
	}
	/**
	 * Health logging properties.
	 */
	public static class Logging {
		/**
		 * Threshold after which a warning will be logged for slow health indicators.
		 */
		private Duration slowIndicatorThreshold = Duration.ofSeconds(10);
		public Duration getSlowIndicatorThreshold() {
			return this.slowIndicatorThreshold;
		}
		public void setSlowIndicatorThreshold(Duration slowIndicatorThreshold) {
			this.slowIndicatorThreshold = slowIndicatorThreshold;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class NoSuchHealthContributorFailureAnalyzer extends AbstractFailureAnalyzer<NoSuchHealthContributorException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchHealthContributorException cause) {
		return new FailureAnalysis(cause.getMessage(), 'Update your application to correct the invalid configuration.\n'
				+ 'You can also set "management.endpoint.health.validate-group-membership" to false to disable the validation.',
				cause);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(HealthEndpoint.class)
@EnableConfigurationProperties(HealthEndpointProperties.class)
@Import({ HealthEndpointConfiguration.class, ReactiveHealthEndpointConfiguration.class,
		HealthEndpointWebExtensionConfiguration.class, HealthEndpointReactiveWebExtensionConfiguration.class })
public class HealthEndpointAutoConfiguration {
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
public abstract class HealthProperties {
	@NestedConfigurationProperty
	private final Status status = new Status();
	/**
	 * When to show components. If not specified the "show-details" setting will be used.
	 */
	private Show showComponents;
	/**
	 * Roles used to determine whether a user is authorized to be shown details. When
	 * empty, all authenticated users are authorized.
	 */
	private Set<String> roles = new HashSet<>();
	public Status getStatus() {
		return this.status;
	}
	public Show getShowComponents() {
		return this.showComponents;
	}
	public void setShowComponents(Show showComponents) {
		this.showComponents = showComponents;
	}
	public abstract Show getShowDetails();
	public Set<String> getRoles() {
		return this.roles;
	}
	public void setRoles(Set<String> roles) {
		this.roles = roles;
	}
	/**
	 * Status properties for the group.
	 */
	public static class Status {
		/**
		 * List of health statuses in order of severity.
		 */
		private List<String> order = new ArrayList<>();
		/**
		 * Mapping of health statuses to HTTP status codes. By default, registered health
		 * statuses map to sensible defaults (for example, UP maps to 200).
		 */
		private final Map<String, Integer> httpMapping = new HashMap<>();
		public List<String> getOrder() {
			return this.order;
		}
		public void setOrder(List<String> statusOrder) {
			if (!CollectionUtils.isEmpty(statusOrder)) {
				this.order = statusOrder;
			}
		}
		public Map<String, Integer> getHttpMapping() {
			return this.httpMapping;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
public abstract class AbstractCompositeHealthContributorConfiguration<C, I extends C, B> {
	private final Function<B, I> indicatorFactory;
	/**
	 * Creates a {@code AbstractCompositeHealthContributorConfiguration} that will use the
	 * given {@code indicatorFactory} to create health indicator instances.
	 * @param indicatorFactory the function to create health indicators
	 * @since 3.0.0
	 */
	protected AbstractCompositeHealthContributorConfiguration(Function<B, I> indicatorFactory) {
		this.indicatorFactory = indicatorFactory;
	}
	protected final C createContributor(Map<String, B> beans) {
		Assert.notEmpty(beans, 'Beans must not be empty');
		if (beans.size() == 1) {
			return createIndicator(beans.values().iterator().next());
		}
		return createComposite(beans);
	}
	protected abstract C createComposite(Map<String, B> beans);
	protected I createIndicator(B bean) {
		return this.indicatorFactory.apply(bean);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.health;
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
public abstract class CompositeReactiveHealthContributorConfiguration<I extends ReactiveHealthIndicator, B>
		extends AbstractCompositeHealthContributorConfiguration<ReactiveHealthContributor, I, B> {
	/**
	 * Creates a {@code CompositeReactiveHealthContributorConfiguration} that will use the
	 * given {@code indicatorFactory} to create {@link ReactiveHealthIndicator} instances.
	 * @param indicatorFactory the function to create health indicator instances
	 * @since 3.0.0
	 */
	public CompositeReactiveHealthContributorConfiguration(Function<B, I> indicatorFactory) {
		super(indicatorFactory);
	}
	@Override
	protected final ReactiveHealthContributor createComposite(Map<String, B> beans) {
		return CompositeReactiveHealthContributor.fromMap(beans, this::createIndicator);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class AutoConfiguredReactiveHealthContributorRegistry extends DefaultReactiveHealthContributorRegistry {
	private final Collection<String> groupNames;
	AutoConfiguredReactiveHealthContributorRegistry(Map<String, ReactiveHealthContributor> contributors,
			Collection<String> groupNames) {
		super(contributors);
		this.groupNames = groupNames;
		contributors.keySet().forEach(this::assertDoesNotClashWithGroup);
	}
	@Override
	public void registerContributor(String name, ReactiveHealthContributor contributor) {
		assertDoesNotClashWithGroup(name);
		super.registerContributor(name, contributor);
	}
	private void assertDoesNotClashWithGroup(String name) {
		Assert.state(!this.groupNames.contains(name),
				() -> 'ReactiveHealthContributor with name \'' + name + '\' clashes with group');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class OnEnabledHealthIndicatorCondition extends OnEndpointElementCondition {
	OnEnabledHealthIndicatorCondition() {
		super('management.health.', ConditionalOnEnabledHealthIndicator.class);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class AutoConfiguredHealthEndpointGroups implements HealthEndpointGroups, AdditionalPathsMapper {
	private static final Predicate<String> ALL = (name) -> true;
	private final HealthEndpointGroup primaryGroup;
	private final Map<String, HealthEndpointGroup> groups;
	/**
	 * Create a new {@link AutoConfiguredHealthEndpointGroups} instance.
	 * @param applicationContext the application context used to check for override beans
	 * @param properties the health endpoint properties
	 */
	AutoConfiguredHealthEndpointGroups(ApplicationContext applicationContext, HealthEndpointProperties properties) {
		ListableBeanFactory beanFactory = (applicationContext instanceof ConfigurableApplicationContext configurableContext)
				? configurableContext.getBeanFactory() : applicationContext;
		Show showComponents = properties.getShowComponents();
		Show showDetails = properties.getShowDetails();
		Set<String> roles = properties.getRoles();
		StatusAggregator statusAggregator = getNonQualifiedBean(beanFactory, StatusAggregator.class);
		if (statusAggregator == null) {
			statusAggregator = new SimpleStatusAggregator(properties.getStatus().getOrder());
		}
		HttpCodeStatusMapper httpCodeStatusMapper = getNonQualifiedBean(beanFactory, HttpCodeStatusMapper.class);
		if (httpCodeStatusMapper == null) {
			httpCodeStatusMapper = new SimpleHttpCodeStatusMapper(properties.getStatus().getHttpMapping());
		}
		this.primaryGroup = new AutoConfiguredHealthEndpointGroup(ALL, statusAggregator, httpCodeStatusMapper,
				showComponents, showDetails, roles, null);
		this.groups = createGroups(properties.getGroup(), beanFactory, statusAggregator, httpCodeStatusMapper,
				showComponents, showDetails, roles);
	}
	private Map<String, HealthEndpointGroup> createGroups(Map<String, Group> groupProperties, BeanFactory beanFactory,
			StatusAggregator defaultStatusAggregator, HttpCodeStatusMapper defaultHttpCodeStatusMapper,
			Show defaultShowComponents, Show defaultShowDetails, Set<String> defaultRoles) {
		Map<String, HealthEndpointGroup> groups = new LinkedHashMap<>();
		groupProperties.forEach((groupName, group) -> {
			Status status = group.getStatus();
			Show showComponents = (group.getShowComponents() != null) ? group.getShowComponents()
					: defaultShowComponents;
			Show showDetails = (group.getShowDetails() != null) ? group.getShowDetails() : defaultShowDetails;
			Set<String> roles = !CollectionUtils.isEmpty(group.getRoles()) ? group.getRoles() : defaultRoles;
			StatusAggregator statusAggregator = getQualifiedBean(beanFactory, StatusAggregator.class, groupName, () -> {
				if (!CollectionUtils.isEmpty(status.getOrder())) {
					return new SimpleStatusAggregator(status.getOrder());
				}
				return defaultStatusAggregator;
			});
			HttpCodeStatusMapper httpCodeStatusMapper = getQualifiedBean(beanFactory, HttpCodeStatusMapper.class,
					groupName, () -> {
						if (!CollectionUtils.isEmpty(status.getHttpMapping())) {
							return new SimpleHttpCodeStatusMapper(status.getHttpMapping());
						}
						return defaultHttpCodeStatusMapper;
					});
			Predicate<String> members = new IncludeExcludeGroupMemberPredicate(group.getInclude(), group.getExclude());
			AdditionalHealthEndpointPath additionalPath = (group.getAdditionalPath() != null)
					? AdditionalHealthEndpointPath.from(group.getAdditionalPath()) : null;
			groups.put(groupName, new AutoConfiguredHealthEndpointGroup(members, statusAggregator, httpCodeStatusMapper,
					showComponents, showDetails, roles, additionalPath));
		});
		return Collections.unmodifiableMap(groups);
	}
	private <T> T getNonQualifiedBean(ListableBeanFactory beanFactory, Class<T> type) {
		List<String> candidates = new ArrayList<>();
		for (String beanName : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) {
			String[] aliases = beanFactory.getAliases(beanName);
			if (!BeanFactoryAnnotationUtils.isQualifierMatch(
					(qualifier) -> !qualifier.equals(beanName) && !ObjectUtils.containsElement(aliases, qualifier),
					beanName, beanFactory)) {
				candidates.add(beanName);
			}
		}
		if (candidates.isEmpty()) {
			return null;
		}
		if (candidates.size() == 1) {
			return beanFactory.getBean(candidates.get(0), type);
		}
		return beanFactory.getBean(type);
	}
	private <T> T getQualifiedBean(BeanFactory beanFactory, Class<T> type, String qualifier, Supplier<T> fallback) {
		try {
			return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, type, qualifier);
		}
		catch (NoSuchBeanDefinitionException ex) {
			return fallback.get();
		}
	}
	@Override
	public HealthEndpointGroup getPrimary() {
		return this.primaryGroup;
	}
	@Override
	public Set<String> getNames() {
		return this.groups.keySet();
	}
	@Override
	public HealthEndpointGroup get(String name) {
		return this.groups.get(name);
	}
	@Override
	public List<String> getAdditionalPaths(EndpointId endpointId, WebServerNamespace webServerNamespace) {
		if (!HealthEndpoint.ID.equals(endpointId)) {
			return null;
		}
		return streamAllGroups().map(HealthEndpointGroup::getAdditionalPath)
			.filter(Objects::nonNull)
			.filter((additionalPath) -> additionalPath.hasNamespace(webServerNamespace))
			.map(AdditionalHealthEndpointPath::getValue)
			.toList();
	}
	private Stream<HealthEndpointGroup> streamAllGroups() {
		return Stream.concat(Stream.of(this.primaryGroup), this.groups.values().stream());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.health;
/**
class IncludeExcludeGroupMemberPredicate implements Predicate<String> {
	private final Set<String> include;
	private final Set<String> exclude;
	IncludeExcludeGroupMemberPredicate(Set<String> include, Set<String> exclude) {
		this.include = clean(include);
		this.exclude = clean(exclude);
	}
	@Override
	public boolean test(String name) {
		name = clean(name);
		return isIncluded(name) && !isExcluded(name);
	}
	private boolean isIncluded(String name) {
		return this.include.isEmpty() || this.include.contains('*') || isIncludedName(name);
	}
	private boolean isIncludedName(String name) {
		if (this.include.contains(name)) {
			return true;
		}
		if (name.contains('/')) {
			String parent = name.substring(0, name.lastIndexOf('/'));
			return isIncludedName(parent);
		}
		return false;
	}
	private boolean isExcluded(String name) {
		return this.exclude.contains('*') || isExcludedName(name);
	}
	private boolean isExcludedName(String name) {
		if (this.exclude.contains(name)) {
			return true;
		}
		if (name.contains('/')) {
			String parent = name.substring(0, name.lastIndexOf('/'));
			return isExcludedName(parent);
		}
		return false;
	}
	private Set<String> clean(Set<String> names) {
		if (names == null) {
			return Collections.emptySet();
		}
		Set<String> cleaned = names.stream().map(this::clean).collect(Collectors.toCollection(LinkedHashSet::new));
		return Collections.unmodifiableSet(cleaned);
	}
	private String clean(String name) {
		return (name != null) ? name.trim() : null;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class AutoConfiguredCompositeMeterRegistry extends CompositeMeterRegistry {
	AutoConfiguredCompositeMeterRegistry(Clock clock, List<MeterRegistry> registries) {
		super(clock, registries);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.statsd;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(StatsdMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('statsd')
@EnableConfigurationProperties(StatsdProperties.class)
public class StatsdMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public StatsdConfig statsdConfig(StatsdProperties statsdProperties) {
		return new StatsdPropertiesConfigAdapter(statsdProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	public StatsdMeterRegistry statsdMeterRegistry(StatsdConfig statsdConfig, Clock clock) {
		return new StatsdMeterRegistry(statsdConfig, clock);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.statsd;
/**
@ConfigurationProperties(prefix = 'management.statsd.metrics.export')
public class StatsdProperties {
	/**
	 * Whether exporting of metrics to StatsD is enabled.
	 */
	private boolean enabled = true;
	/**
	 * StatsD line protocol to use.
	 */
	private StatsdFlavor flavor = StatsdFlavor.DATADOG;
	/**
	 * Host of the StatsD server to receive exported metrics.
	 */
	private String host = 'localhost';
	/**
	 * Port of the StatsD server to receive exported metrics.
	 */
	private Integer port = 8125;
	/**
	 * Protocol of the StatsD server to receive exported metrics.
	 */
	private StatsdProtocol protocol = StatsdProtocol.UDP;
	/**
	 * Total length of a single payload should be kept within your network"s MTU.
	 */
	private Integer maxPacketLength = 1400;
	/**
	 * How often gauges will be polled. When a gauge is polled, its value is recalculated
	 * and if the value has changed (or publishUnchangedMeters is true), it is sent to the
	 * StatsD server.
	 */
	private Duration pollingFrequency = Duration.ofSeconds(10);
	/**
	 * Step size to use in computing windowed statistics like max. To get the most out of
	 * these statistics, align the step interval to be close to your scrape interval.
	 */
	private Duration step = Duration.ofMinutes(1);
	/**
	 * Whether to send unchanged meters to the StatsD server.
	 */
	private boolean publishUnchangedMeters = true;
	/**
	 * Whether measurements should be buffered before sending to the StatsD server.
	 */
	private boolean buffered = true;
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public StatsdFlavor getFlavor() {
		return this.flavor;
	}
	public void setFlavor(StatsdFlavor flavor) {
		this.flavor = flavor;
	}
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public Integer getPort() {
		return this.port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
	public StatsdProtocol getProtocol() {
		return this.protocol;
	}
	public void setProtocol(StatsdProtocol protocol) {
		this.protocol = protocol;
	}
	public Integer getMaxPacketLength() {
		return this.maxPacketLength;
	}
	public void setMaxPacketLength(Integer maxPacketLength) {
		this.maxPacketLength = maxPacketLength;
	}
	public Duration getPollingFrequency() {
		return this.pollingFrequency;
	}
	public void setPollingFrequency(Duration pollingFrequency) {
		this.pollingFrequency = pollingFrequency;
	}
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public boolean isPublishUnchangedMeters() {
		return this.publishUnchangedMeters;
	}
	public void setPublishUnchangedMeters(boolean publishUnchangedMeters) {
		this.publishUnchangedMeters = publishUnchangedMeters;
	}
	public boolean isBuffered() {
		return this.buffered;
	}
	public void setBuffered(boolean buffered) {
		this.buffered = buffered;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.statsd;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.statsd;
/**
public class StatsdPropertiesConfigAdapter extends PropertiesConfigAdapter<StatsdProperties> implements StatsdConfig {
	public StatsdPropertiesConfigAdapter(StatsdProperties properties) {
		super(properties);
	}
	@Override
	public String get(String s) {
		return null;
	}
	@Override
	public String prefix() {
		return 'management.statsd.metrics.export';
	}
	@Override
	public StatsdFlavor flavor() {
		return get(StatsdProperties::getFlavor, StatsdConfig.super::flavor);
	}
	@Override
	public boolean enabled() {
		return get(StatsdProperties::isEnabled, StatsdConfig.super::enabled);
	}
	@Override
	public String host() {
		return get(StatsdProperties::getHost, StatsdConfig.super::host);
	}
	@Override
	public int port() {
		return get(StatsdProperties::getPort, StatsdConfig.super::port);
	}
	@Override
	public StatsdProtocol protocol() {
		return get(StatsdProperties::getProtocol, StatsdConfig.super::protocol);
	}
	@Override
	public int maxPacketLength() {
		return get(StatsdProperties::getMaxPacketLength, StatsdConfig.super::maxPacketLength);
	}
	@Override
	public Duration pollingFrequency() {
		return get(StatsdProperties::getPollingFrequency, StatsdConfig.super::pollingFrequency);
	}
	@Override
	public Duration step() {
		return get(StatsdProperties::getStep, StatsdConfig.super::step);
	}
	@Override
	public boolean publishUnchangedMeters() {
		return get(StatsdProperties::isPublishUnchangedMeters, StatsdConfig.super::publishUnchangedMeters);
	}
	@Override
	public boolean buffered() {
		return get(StatsdProperties::isBuffered, StatsdConfig.super::buffered);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnMetricsExportEnabledCondition.class)
public @interface ConditionalOnEnabledMetricsExport {
	/**
	 * The name of the metrics exporter.
	 * @return the name of the metrics exporter
	 */
	String value();
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.jmx;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(JmxMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('jmx')
@EnableConfigurationProperties(JmxProperties.class)
public class JmxMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public JmxConfig jmxConfig(JmxProperties jmxProperties) {
		return new JmxPropertiesConfigAdapter(jmxProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	public JmxMeterRegistry jmxMeterRegistry(JmxConfig jmxConfig, Clock clock) {
		return new JmxMeterRegistry(jmxConfig, clock);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.jmx;
/**
class JmxPropertiesConfigAdapter extends PropertiesConfigAdapter<JmxProperties> implements JmxConfig {
	JmxPropertiesConfigAdapter(JmxProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.jmx.metrics.export';
	}
	@Override
	public String get(String key) {
		return null;
	}
	@Override
	public String domain() {
		return get(JmxProperties::getDomain, JmxConfig.super::domain);
	}
	@Override
	public Duration step() {
		return get(JmxProperties::getStep, JmxConfig.super::step);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.jmx;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.jmx;
/**
@ConfigurationProperties(prefix = 'management.jmx.metrics.export')
public class JmxProperties {
	/**
	 * Whether exporting of metrics to this backend is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Metrics JMX domain name.
	 */
	private String domain = 'metrics';
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofMinutes(1);
	public String getDomain() {
		return this.domain;
	}
	public void setDomain(String domain) {
		this.domain = domain;
	}
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.graphite;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(GraphiteMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('graphite')
@EnableConfigurationProperties(GraphiteProperties.class)
public class GraphiteMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public GraphiteConfig graphiteConfig(GraphiteProperties graphiteProperties) {
		return new GraphitePropertiesConfigAdapter(graphiteProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	public GraphiteMeterRegistry graphiteMeterRegistry(GraphiteConfig graphiteConfig, Clock clock) {
		return new GraphiteMeterRegistry(graphiteConfig, clock);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.graphite;
/**
@ConfigurationProperties(prefix = 'management.graphite.metrics.export')
public class GraphiteProperties {
	/**
	 * Whether exporting of metrics to Graphite is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofMinutes(1);
	/**
	 * Base time unit used to report rates.
	 */
	private TimeUnit rateUnits = TimeUnit.SECONDS;
	/**
	 * Base time unit used to report durations.
	 */
	private TimeUnit durationUnits = TimeUnit.MILLISECONDS;
	/**
	 * Host of the Graphite server to receive exported metrics.
	 */
	private String host = 'localhost';
	/**
	 * Port of the Graphite server to receive exported metrics.
	 */
	private Integer port = 2004;
	/**
	 * Protocol to use while shipping data to Graphite.
	 */
	private GraphiteProtocol protocol = GraphiteProtocol.PICKLED;
	/**
	 * Whether Graphite tags should be used, as opposed to a hierarchical naming
	 * convention. Enabled by default unless 'tagsAsPrefix' is set.
	 */
	private Boolean graphiteTagsEnabled;
	/**
	 * For the hierarchical naming convention, turn the specified tag keys into part of
	 * the metric prefix. Ignored if 'graphiteTagsEnabled' is true.
	 */
	private String[] tagsAsPrefix = new String[0];
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public TimeUnit getRateUnits() {
		return this.rateUnits;
	}
	public void setRateUnits(TimeUnit rateUnits) {
		this.rateUnits = rateUnits;
	}
	public TimeUnit getDurationUnits() {
		return this.durationUnits;
	}
	public void setDurationUnits(TimeUnit durationUnits) {
		this.durationUnits = durationUnits;
	}
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public Integer getPort() {
		return this.port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
	public GraphiteProtocol getProtocol() {
		return this.protocol;
	}
	public void setProtocol(GraphiteProtocol protocol) {
		this.protocol = protocol;
	}
	public Boolean getGraphiteTagsEnabled() {
		return (this.graphiteTagsEnabled != null) ? this.graphiteTagsEnabled : ObjectUtils.isEmpty(this.tagsAsPrefix);
	}
	public void setGraphiteTagsEnabled(Boolean graphiteTagsEnabled) {
		this.graphiteTagsEnabled = graphiteTagsEnabled;
	}
	public String[] getTagsAsPrefix() {
		return this.tagsAsPrefix;
	}
	public void setTagsAsPrefix(String[] tagsAsPrefix) {
		this.tagsAsPrefix = tagsAsPrefix;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.graphite;
/**
class GraphitePropertiesConfigAdapter extends PropertiesConfigAdapter<GraphiteProperties> implements GraphiteConfig {
	GraphitePropertiesConfigAdapter(GraphiteProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.graphite.metrics.export';
	}
	@Override
	public String get(String k) {
		return null;
	}
	@Override
	public boolean enabled() {
		return get(GraphiteProperties::isEnabled, GraphiteConfig.super::enabled);
	}
	@Override
	public Duration step() {
		return get(GraphiteProperties::getStep, GraphiteConfig.super::step);
	}
	@Override
	public TimeUnit rateUnits() {
		return get(GraphiteProperties::getRateUnits, GraphiteConfig.super::rateUnits);
	}
	@Override
	public TimeUnit durationUnits() {
		return get(GraphiteProperties::getDurationUnits, GraphiteConfig.super::durationUnits);
	}
	@Override
	public String host() {
		return get(GraphiteProperties::getHost, GraphiteConfig.super::host);
	}
	@Override
	public int port() {
		return get(GraphiteProperties::getPort, GraphiteConfig.super::port);
	}
	@Override
	public GraphiteProtocol protocol() {
		return get(GraphiteProperties::getProtocol, GraphiteConfig.super::protocol);
	}
	@Override
	public boolean graphiteTagsEnabled() {
		return get(GraphiteProperties::getGraphiteTagsEnabled, GraphiteConfig.super::graphiteTagsEnabled);
	}
	@Override
	public String[] tagsAsPrefix() {
		return get(GraphiteProperties::getTagsAsPrefix, GraphiteConfig.super::tagsAsPrefix);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.graphite;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.ganglia;
/**
class GangliaPropertiesConfigAdapter extends PropertiesConfigAdapter<GangliaProperties> implements GangliaConfig {
	GangliaPropertiesConfigAdapter(GangliaProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.ganglia.metrics.export';
	}
	@Override
	public String get(String k) {
		return null;
	}
	@Override
	public boolean enabled() {
		return get(GangliaProperties::isEnabled, GangliaConfig.super::enabled);
	}
	@Override
	public Duration step() {
		return get(GangliaProperties::getStep, GangliaConfig.super::step);
	}
	@Override
	public TimeUnit durationUnits() {
		return get(GangliaProperties::getDurationUnits, GangliaConfig.super::durationUnits);
	}
	@Override
	public GMetric.UDPAddressingMode addressingMode() {
		return get(GangliaProperties::getAddressingMode, GangliaConfig.super::addressingMode);
	}
	@Override
	public int ttl() {
		return get(GangliaProperties::getTimeToLive, GangliaConfig.super::ttl);
	}
	@Override
	public String host() {
		return get(GangliaProperties::getHost, GangliaConfig.super::host);
	}
	@Override
	public int port() {
		return get(GangliaProperties::getPort, GangliaConfig.super::port);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.ganglia;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(GangliaMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('ganglia')
@EnableConfigurationProperties(GangliaProperties.class)
public class GangliaMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public GangliaConfig gangliaConfig(GangliaProperties gangliaProperties) {
		return new GangliaPropertiesConfigAdapter(gangliaProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	public GangliaMeterRegistry gangliaMeterRegistry(GangliaConfig gangliaConfig, Clock clock) {
		return new GangliaMeterRegistry(gangliaConfig, clock);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.ganglia;
/**
@ConfigurationProperties(prefix = 'management.ganglia.metrics.export')
public class GangliaProperties {
	/**
	 * Whether exporting of metrics to Ganglia is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofMinutes(1);
	/**
	 * Base time unit used to report durations.
	 */
	private TimeUnit durationUnits = TimeUnit.MILLISECONDS;
	/**
	 * UDP addressing mode, either unicast or multicast.
	 */
	private GMetric.UDPAddressingMode addressingMode = GMetric.UDPAddressingMode.MULTICAST;
	/**
	 * Time to live for metrics on Ganglia. Set the multicast Time-To-Live to be one
	 * greater than the number of hops (routers) between the hosts.
	 */
	private Integer timeToLive = 1;
	/**
	 * Host of the Ganglia server to receive exported metrics.
	 */
	private String host = 'localhost';
	/**
	 * Port of the Ganglia server to receive exported metrics.
	 */
	private Integer port = 8649;
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public TimeUnit getDurationUnits() {
		return this.durationUnits;
	}
	public void setDurationUnits(TimeUnit durationUnits) {
		this.durationUnits = durationUnits;
	}
	public GMetric.UDPAddressingMode getAddressingMode() {
		return this.addressingMode;
	}
	public void setAddressingMode(GMetric.UDPAddressingMode addressingMode) {
		this.addressingMode = addressingMode;
	}
	public Integer getTimeToLive() {
		return this.timeToLive;
	}
	public void setTimeToLive(Integer timeToLive) {
		this.timeToLive = timeToLive;
	}
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public Integer getPort() {
		return this.port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.ganglia;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.elastic;
/**
@ConfigurationProperties(prefix = 'management.elastic.metrics.export')
public class ElasticProperties extends StepRegistryProperties {
	/**
	 * Host to export metrics to.
	 */
	private String host = 'http://localhost:9200';
	/**
	 * Index to export metrics to.
	 */
	private String index = 'micrometer-metrics';
	/**
	 * Index date format used for rolling indices. Appended to the index name.
	 */
	private String indexDateFormat = 'yyyy-MM';
	/**
	 * Prefix to separate the index name from the date format used for rolling indices.
	 */
	private String indexDateSeparator = '-';
	/**
	 * Name of the timestamp field.
	 */
	private String timestampFieldName = '@timestamp';
	/**
	 * Whether to create the index automatically if it does not exist.
	 */
	private boolean autoCreateIndex = true;
	/**
	 * Login user of the Elastic server. Mutually exclusive with api-key-credentials.
	 */
	private String userName;
	/**
	 * Login password of the Elastic server. Mutually exclusive with api-key-credentials.
	 */
	private String password;
	/**
	 * Ingest pipeline name. By default, events are not pre-processed.
	 */
	private String pipeline;
	/**
	 * Base64-encoded credentials string. Mutually exclusive with user-name and password.
	 */
	private String apiKeyCredentials;
	/**
	 * Whether to enable _source in the default index template when auto-creating the
	 * index.
	 */
	private boolean enableSource = false;
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public String getIndex() {
		return this.index;
	}
	public void setIndex(String index) {
		this.index = index;
	}
	public String getIndexDateFormat() {
		return this.indexDateFormat;
	}
	public void setIndexDateFormat(String indexDateFormat) {
		this.indexDateFormat = indexDateFormat;
	}
	public String getIndexDateSeparator() {
		return this.indexDateSeparator;
	}
	public void setIndexDateSeparator(String indexDateSeparator) {
		this.indexDateSeparator = indexDateSeparator;
	}
	public String getTimestampFieldName() {
		return this.timestampFieldName;
	}
	public void setTimestampFieldName(String timestampFieldName) {
		this.timestampFieldName = timestampFieldName;
	}
	public boolean isAutoCreateIndex() {
		return this.autoCreateIndex;
	}
	public void setAutoCreateIndex(boolean autoCreateIndex) {
		this.autoCreateIndex = autoCreateIndex;
	}
	public String getUserName() {
		return this.userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getPipeline() {
		return this.pipeline;
	}
	public void setPipeline(String pipeline) {
		this.pipeline = pipeline;
	}
	public String getApiKeyCredentials() {
		return this.apiKeyCredentials;
	}
	public void setApiKeyCredentials(String apiKeyCredentials) {
		this.apiKeyCredentials = apiKeyCredentials;
	}
	public boolean isEnableSource() {
		return this.enableSource;
	}
	public void setEnableSource(boolean enableSource) {
		this.enableSource = enableSource;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.elastic;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(ElasticMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('elastic')
@EnableConfigurationProperties(ElasticProperties.class)
public class ElasticMetricsExportAutoConfiguration {
	private final ElasticProperties properties;
	public ElasticMetricsExportAutoConfiguration(ElasticProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public ElasticConfig elasticConfig() {
		MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
			entries.put('api-key-credentials', this.properties.getApiKeyCredentials());
			entries.put('user-name', this.properties.getUserName());
		});
		MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
			entries.put('api-key-credentials', this.properties.getApiKeyCredentials());
			entries.put('password', this.properties.getPassword());
		});
		return new ElasticPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public ElasticMeterRegistry elasticMeterRegistry(ElasticConfig elasticConfig, Clock clock) {
		return ElasticMeterRegistry.builder(elasticConfig)
			.clock(clock)
			.httpClient(
					new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()))
			.build();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.elastic;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.elastic;
/**
class ElasticPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<ElasticProperties>
		implements ElasticConfig {
	ElasticPropertiesConfigAdapter(ElasticProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.elastic.metrics.export';
	}
	@Override
	public String host() {
		return get(ElasticProperties::getHost, ElasticConfig.super::host);
	}
	@Override
	public String index() {
		return get(ElasticProperties::getIndex, ElasticConfig.super::index);
	}
	@Override
	public String indexDateFormat() {
		return get(ElasticProperties::getIndexDateFormat, ElasticConfig.super::indexDateFormat);
	}
	@Override
	public String indexDateSeparator() {
		return get(ElasticProperties::getIndexDateSeparator, ElasticConfig.super::indexDateSeparator);
	}
	@Override
	public String timestampFieldName() {
		return get(ElasticProperties::getTimestampFieldName, ElasticConfig.super::timestampFieldName);
	}
	@Override
	public boolean autoCreateIndex() {
		return get(ElasticProperties::isAutoCreateIndex, ElasticConfig.super::autoCreateIndex);
	}
	@Override
	public String userName() {
		return get(ElasticProperties::getUserName, ElasticConfig.super::userName);
	}
	@Override
	public String password() {
		return get(ElasticProperties::getPassword, ElasticConfig.super::password);
	}
	@Override
	public String pipeline() {
		return get(ElasticProperties::getPipeline, ElasticConfig.super::pipeline);
	}
	@Override
	public String apiKeyCredentials() {
		return get(ElasticProperties::getApiKeyCredentials, ElasticConfig.super::apiKeyCredentials);
	}
	@Override
	public boolean enableSource() {
		return get(ElasticProperties::isEnableSource, ElasticConfig.super::enableSource);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class PushRegistryProperties {
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofMinutes(1);
	/**
	 * Whether exporting of metrics to this backend is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Connection timeout for requests to this backend.
	 */
	private Duration connectTimeout = Duration.ofSeconds(1);
	/**
	 * Read timeout for requests to this backend.
	 */
	private Duration readTimeout = Duration.ofSeconds(10);
	/**
	 * Number of measurements per request to use for this backend. If more measurements
	 * are found, then multiple requests will be made.
	 */
	private Integer batchSize = 10000;
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public Duration getReadTimeout() {
		return this.readTimeout;
	}
	public void setReadTimeout(Duration readTimeout) {
		this.readTimeout = readTimeout;
	}
	public Integer getBatchSize() {
		return this.batchSize;
	}
	public void setBatchSize(Integer batchSize) {
		this.batchSize = batchSize;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public class PropertiesConfigAdapter<T> {
	private final T properties;
	/**
	 * Create a new {@link PropertiesConfigAdapter} instance.
	 * @param properties the source properties
	 */
	public PropertiesConfigAdapter(T properties) {
		Assert.notNull(properties, 'Properties must not be null');
		this.properties = properties;
	}
	/**
	 * Get the value from the properties or use a fallback from the {@code defaults}.
	 * @param getter the getter for the properties
	 * @param fallback the fallback method, usually super interface method reference
	 * @param <V> the value type
	 * @return the property or fallback value
	 */
	protected final <V> V get(Function<T, V> getter, Supplier<V> fallback) {
		V value = getter.apply(this.properties);
		return (value != null) ? value : fallback.get();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class StepRegistryPropertiesConfigAdapter<T extends StepRegistryProperties>
		extends PushRegistryPropertiesConfigAdapter<T> {
	public StepRegistryPropertiesConfigAdapter(T properties) {
		super(properties);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class PushRegistryPropertiesConfigAdapter<T extends PushRegistryProperties>
		extends PropertiesConfigAdapter<T> implements PushRegistryConfig {
	public PushRegistryPropertiesConfigAdapter(T properties) {
		super(properties);
	}
	@Override
	public String get(String k) {
		return null;
	}
	@Override
	public Duration step() {
		return get(T::getStep, PushRegistryConfig.super::step);
	}
	@Override
	public boolean enabled() {
		return get(T::isEnabled, PushRegistryConfig.super::enabled);
	}
	@Override
	public int batchSize() {
		return get(T::getBatchSize, PushRegistryConfig.super::batchSize);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.properties;
/**
public abstract class StepRegistryProperties extends PushRegistryProperties {
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export;
/**
class OnMetricsExportEnabledCondition extends SpringBootCondition {
	private static final String PROPERTY_TEMPLATE = 'management.%s.metrics.export.enabled';
	private static final String DEFAULT_PROPERTY_NAME = 'management.defaults.metrics.export.enabled';
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		AnnotationAttributes annotationAttributes = AnnotationAttributes
			.fromMap(metadata.getAnnotationAttributes(ConditionalOnEnabledMetricsExport.class.getName()));
		String endpointName = annotationAttributes.getString('value');
		ConditionOutcome outcome = getProductOutcome(context, endpointName);
		if (outcome != null) {
			return outcome;
		}
		return getDefaultOutcome(context);
	}
	private ConditionOutcome getProductOutcome(ConditionContext context, String productName) {
		Environment environment = context.getEnvironment();
		String enabledProperty = PROPERTY_TEMPLATE.formatted(productName);
		if (environment.containsProperty(enabledProperty)) {
			boolean match = environment.getProperty(enabledProperty, Boolean.class, true);
			return new ConditionOutcome(match, ConditionMessage.forCondition(ConditionalOnEnabledMetricsExport.class)
				.because(enabledProperty + ' is ' + match));
		}
		return null;
	}
	/**
	 * Return the default outcome that should be used if property is not set. By default
	 * this method will use the {@link #DEFAULT_PROPERTY_NAME} property, matching if it is
	 * {@code true} or if it is not configured.
	 * @param context the condition context
	 * @return the default outcome
	 */
	private ConditionOutcome getDefaultOutcome(ConditionContext context) {
		boolean match = Boolean.parseBoolean(context.getEnvironment().getProperty(DEFAULT_PROPERTY_NAME, 'true'));
		return new ConditionOutcome(match, ConditionMessage.forCondition(ConditionalOnEnabledMetricsExport.class)
			.because(DEFAULT_PROPERTY_NAME + ' is considered ' + match));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
class PrometheusPropertiesConfigAdapter extends PropertiesConfigAdapter<PrometheusProperties>
		implements PrometheusConfig {
	PrometheusPropertiesConfigAdapter(PrometheusProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.prometheus.metrics.export';
	}
	@Override
	public String get(String key) {
		return null;
	}
	@Override
	public boolean descriptions() {
		return get(PrometheusProperties::isDescriptions, PrometheusConfig.super::descriptions);
	}
	@Override
	public Duration step() {
		return get(PrometheusProperties::getStep, PrometheusConfig.super::step);
	}
	@Override
	public Properties prometheusProperties() {
		return get(this::fromPropertiesMap, PrometheusConfig.super::prometheusProperties);
	}
	private Properties fromPropertiesMap(PrometheusProperties prometheusProperties) {
		Map<String, String> additionalProperties = prometheusProperties.getProperties();
		if (additionalProperties.isEmpty()) {
			return null;
		}
		Properties properties = PrometheusConfig.super.prometheusProperties();
		if (properties == null) {
			properties = new Properties();
		}
		properties.putAll(additionalProperties);
		return properties;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
@SuppressWarnings({ 'deprecation', 'removal' })
class PrometheusSimpleclientPropertiesConfigAdapter extends PropertiesConfigAdapter<PrometheusProperties>
		implements io.micrometer.prometheus.PrometheusConfig {
	PrometheusSimpleclientPropertiesConfigAdapter(PrometheusProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.prometheus.metrics.export';
	}
	@Override
	public String get(String key) {
		return null;
	}
	@Override
	public boolean descriptions() {
		return get(PrometheusProperties::isDescriptions, io.micrometer.prometheus.PrometheusConfig.super::descriptions);
	}
	@Override
	public io.micrometer.prometheus.HistogramFlavor histogramFlavor() {
		return get(PrometheusSimpleclientPropertiesConfigAdapter::mapToMicrometerHistogramFlavor,
				io.micrometer.prometheus.PrometheusConfig.super::histogramFlavor);
	}
	static io.micrometer.prometheus.HistogramFlavor mapToMicrometerHistogramFlavor(PrometheusProperties properties) {
		return switch (properties.getHistogramFlavor()) {
			case Prometheus -> io.micrometer.prometheus.HistogramFlavor.Prometheus;
			case VictoriaMetrics -> io.micrometer.prometheus.HistogramFlavor.VictoriaMetrics;
		};
	}
	@Override
	public Duration step() {
		return get(PrometheusProperties::getStep, io.micrometer.prometheus.PrometheusConfig.super::step);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(PrometheusMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('prometheus')
@EnableConfigurationProperties(PrometheusProperties.class)
public class PrometheusMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	PrometheusConfig prometheusConfig(PrometheusProperties prometheusProperties) {
		return new PrometheusPropertiesConfigAdapter(prometheusProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	PrometheusMeterRegistry prometheusMeterRegistry(PrometheusConfig prometheusConfig,
			PrometheusRegistry prometheusRegistry, Clock clock, ObjectProvider<SpanContext> spanContext) {
		return new PrometheusMeterRegistry(prometheusConfig, prometheusRegistry, clock, spanContext.getIfAvailable());
	}
	@Bean
	@ConditionalOnMissingBean
	PrometheusRegistry prometheusRegistry() {
		return new PrometheusRegistry();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnAvailableEndpoint(PrometheusScrapeEndpoint.class)
	static class PrometheusScrapeEndpointConfiguration {
		@SuppressWarnings('removal')
		@Bean
		@ConditionalOnMissingBean({ PrometheusScrapeEndpoint.class,
				org.springframework.boot.actuate.metrics.export.prometheus.PrometheusSimpleclientScrapeEndpoint.class })
		PrometheusScrapeEndpoint prometheusEndpoint(PrometheusRegistry prometheusRegistry,
				PrometheusConfig prometheusConfig) {
			return new PrometheusScrapeEndpoint(prometheusRegistry, prometheusConfig.prometheusProperties());
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = { MetricsAutoConfiguration.class, PrometheusMetricsExportAutoConfiguration.class })
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(io.micrometer.prometheus.PrometheusMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('prometheus')
@EnableConfigurationProperties(PrometheusProperties.class)
public class PrometheusSimpleclientMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	io.micrometer.prometheus.PrometheusConfig simpleclientPrometheusConfig(PrometheusProperties prometheusProperties) {
		return new PrometheusSimpleclientPropertiesConfigAdapter(prometheusProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	io.micrometer.prometheus.PrometheusMeterRegistry simpleclientPrometheusMeterRegistry(
			io.micrometer.prometheus.PrometheusConfig prometheusConfig, CollectorRegistry collectorRegistry,
			Clock clock, ObjectProvider<ExemplarSampler> exemplarSamplerProvider) {
		return new io.micrometer.prometheus.PrometheusMeterRegistry(prometheusConfig, collectorRegistry, clock,
				exemplarSamplerProvider.getIfAvailable());
	}
	@Bean
	@ConditionalOnMissingBean
	CollectorRegistry collectorRegistry() {
		return new CollectorRegistry(true);
	}
	@Bean
	@ConditionalOnMissingBean(ExemplarSampler.class)
	@ConditionalOnBean(SpanContextSupplier.class)
	DefaultExemplarSampler exemplarSampler(SpanContextSupplier spanContextSupplier) {
		return new DefaultExemplarSampler(spanContextSupplier);
	}
	@SuppressWarnings('removal')
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnAvailableEndpoint(PrometheusSimpleclientScrapeEndpoint.class)
	static class PrometheusScrapeEndpointConfiguration {
		@Bean
		@ConditionalOnMissingBean({ PrometheusSimpleclientScrapeEndpoint.class, PrometheusScrapeEndpoint.class })
		PrometheusSimpleclientScrapeEndpoint prometheusEndpoint(CollectorRegistry collectorRegistry) {
			return new PrometheusSimpleclientScrapeEndpoint(collectorRegistry);
		}
	}
	/**
	 * Configuration for <a href='https://github.com/prometheus/pushgateway'>Prometheus
	 * Pushgateway</a>.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(PushGateway.class)
	@ConditionalOnProperty(prefix = 'management.prometheus.metrics.export.pushgateway', name = 'enabled')
	static class PrometheusPushGatewayConfiguration {
		/**
		 * The fallback job name. We use "spring" since there"s a history of Prometheus
		 * spring integration defaulting to that name from when Prometheus integration
		 * didn"t exist in Spring itself.
		 */
		private static final String FALLBACK_JOB = 'spring';
		@Bean
		@ConditionalOnMissingBean
		PrometheusPushGatewayManager prometheusPushGatewayManager(CollectorRegistry collectorRegistry,
				PrometheusProperties prometheusProperties, Environment environment) throws MalformedURLException {
			PrometheusProperties.Pushgateway properties = prometheusProperties.getPushgateway();
			Duration pushRate = properties.getPushRate();
			String job = getJob(properties, environment);
			Map<String, String> groupingKey = properties.getGroupingKey();
			ShutdownOperation shutdownOperation = properties.getShutdownOperation();
			PushGateway pushGateway = initializePushGateway(properties.getBaseUrl());
			if (StringUtils.hasText(properties.getUsername())) {
				pushGateway.setConnectionFactory(
						new BasicAuthHttpConnectionFactory(properties.getUsername(), properties.getPassword()));
			}
			return new PrometheusPushGatewayManager(pushGateway, collectorRegistry, pushRate, job, groupingKey,
					shutdownOperation);
		}
		private PushGateway initializePushGateway(String url) throws MalformedURLException {
			return new PushGateway(new URL(url));
		}
		private String getJob(PrometheusProperties.Pushgateway properties, Environment environment) {
			String job = properties.getJob();
			job = (job != null) ? job : environment.getProperty('spring.application.name');
			return (job != null) ? job : FALLBACK_JOB;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.prometheus;
/**
@ConfigurationProperties(prefix = 'management.prometheus.metrics.export')
public class PrometheusProperties {
	/**
	 * Whether exporting of metrics to this backend is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Whether to enable publishing descriptions as part of the scrape payload to
	 * Prometheus. Turn this off to minimize the amount of data sent on each scrape.
	 */
	private boolean descriptions = true;
	/**
	 * Configuration options for using Prometheus Pushgateway, allowing metrics to be
	 * pushed when they cannot be scraped.
	 */
	private final Pushgateway pushgateway = new Pushgateway();
	/**
	 * Histogram type for backing DistributionSummary and Timer.
	 * @deprecated since 3.3.0 for removal in 3.5.0
	 */
	@Deprecated(since = '3.3.0', forRemoval = true)
	private HistogramFlavor histogramFlavor = HistogramFlavor.Prometheus;
	/**
	 * Additional properties to pass to the Prometheus client.
	 */
	private final Map<String, String> properties = new HashMap<>();
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofMinutes(1);
	public boolean isDescriptions() {
		return this.descriptions;
	}
	public void setDescriptions(boolean descriptions) {
		this.descriptions = descriptions;
	}
	@Deprecated(since = '3.3.0', forRemoval = true)
	@DeprecatedConfigurationProperty(since = '3.3.0',
			reason = 'No longer supported. Works only when using the Prometheus simpleclient.')
	public HistogramFlavor getHistogramFlavor() {
		return this.histogramFlavor;
	}
	public void setHistogramFlavor(HistogramFlavor histogramFlavor) {
		this.histogramFlavor = histogramFlavor;
	}
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public Pushgateway getPushgateway() {
		return this.pushgateway;
	}
	public Map<String, String> getProperties() {
		return this.properties;
	}
	/**
	 * Configuration options for push-based interaction with Prometheus.
	 */
	public static class Pushgateway {
		/**
		 * Enable publishing over a Prometheus Pushgateway.
		 */
		private Boolean enabled = false;
		/**
		 * Base URL for the Pushgateway.
		 */
		private String baseUrl = 'http://localhost:9091';
		/**
		 * Login user of the Prometheus Pushgateway.
		 */
		private String username;
		/**
		 * Login password of the Prometheus Pushgateway.
		 */
		private String password;
		/**
		 * Frequency with which to push metrics.
		 */
		private Duration pushRate = Duration.ofMinutes(1);
		/**
		 * Job identifier for this application instance.
		 */
		private String job;
		/**
		 * Grouping key for the pushed metrics.
		 */
		private Map<String, String> groupingKey = new HashMap<>();
		/**
		 * Operation that should be performed on shutdown.
		 */
		private ShutdownOperation shutdownOperation = ShutdownOperation.NONE;
		public Boolean getEnabled() {
			return this.enabled;
		}
		public void setEnabled(Boolean enabled) {
			this.enabled = enabled;
		}
		public String getBaseUrl() {
			return this.baseUrl;
		}
		public void setBaseUrl(String baseUrl) {
			this.baseUrl = baseUrl;
		}
		public String getUsername() {
			return this.username;
		}
		public void setUsername(String username) {
			this.username = username;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
		public Duration getPushRate() {
			return this.pushRate;
		}
		public void setPushRate(Duration pushRate) {
			this.pushRate = pushRate;
		}
		public String getJob() {
			return this.job;
		}
		public void setJob(String job) {
			this.job = job;
		}
		public Map<String, String> getGroupingKey() {
			return this.groupingKey;
		}
		public void setGroupingKey(Map<String, String> groupingKey) {
			this.groupingKey = groupingKey;
		}
		public ShutdownOperation getShutdownOperation() {
			return this.shutdownOperation;
		}
		public void setShutdownOperation(ShutdownOperation shutdownOperation) {
			this.shutdownOperation = shutdownOperation;
		}
	}
	/**
	 * Prometheus Histogram flavor.
	 *
	 * @deprecated since 3.3.0 for removal in 3.5.0
	 */
	@Deprecated(since = '3.3.0', forRemoval = true)
	public enum HistogramFlavor {
		Prometheus, VictoriaMetrics
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.dynatrace;
/**
class DynatracePropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<DynatraceProperties>
		implements DynatraceConfig {
	DynatracePropertiesConfigAdapter(DynatraceProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.dynatrace.metrics.export';
	}
	@Override
	public String apiToken() {
		return get(DynatraceProperties::getApiToken, DynatraceConfig.super::apiToken);
	}
	@Override
	public String deviceId() {
		return get(v1(V1::getDeviceId), DynatraceConfig.super::deviceId);
	}
	@Override
	public String technologyType() {
		return get(v1(V1::getTechnologyType), DynatraceConfig.super::technologyType);
	}
	@Override
	public String uri() {
		return get(DynatraceProperties::getUri, DynatraceConfig.super::uri);
	}
	@Override
	public String group() {
		return get(v1(V1::getGroup), DynatraceConfig.super::group);
	}
	@Override
	public DynatraceApiVersion apiVersion() {
		return get((properties) -> (properties.getV1().getDeviceId() != null) ? DynatraceApiVersion.V1
				: DynatraceApiVersion.V2, DynatraceConfig.super::apiVersion);
	}
	@Override
	public String metricKeyPrefix() {
		return get(v2(V2::getMetricKeyPrefix), DynatraceConfig.super::metricKeyPrefix);
	}
	@Override
	public Map<String, String> defaultDimensions() {
		return get(v2(V2::getDefaultDimensions), DynatraceConfig.super::defaultDimensions);
	}
	@Override
	public boolean enrichWithDynatraceMetadata() {
		return get(v2(V2::isEnrichWithDynatraceMetadata), DynatraceConfig.super::enrichWithDynatraceMetadata);
	}
	@Override
	public boolean useDynatraceSummaryInstruments() {
		return get(v2(V2::isUseDynatraceSummaryInstruments), DynatraceConfig.super::useDynatraceSummaryInstruments);
	}
	@Override
	public boolean exportMeterMetadata() {
		return get(v2(V2::isExportMeterMetadata), DynatraceConfig.super::exportMeterMetadata);
	}
	private <V> Function<DynatraceProperties, V> v1(Function<V1, V> getter) {
		return (properties) -> getter.apply(properties.getV1());
	}
	private <V> Function<DynatraceProperties, V> v2(Function<V2, V> getter) {
		return (properties) -> getter.apply(properties.getV2());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.dynatrace;
/**
@ConfigurationProperties(prefix = 'management.dynatrace.metrics.export')
public class DynatraceProperties extends StepRegistryProperties {
	private final V1 v1 = new V1();
	private final V2 v2 = new V2();
	/**
	 * Dynatrace authentication token.
	 */
	private String apiToken;
	/**
	 * URI to ship metrics to. Should be used for SaaS, self-managed instances or to
	 * en-route through an internal proxy.
	 */
	private String uri;
	public String getApiToken() {
		return this.apiToken;
	}
	public void setApiToken(String apiToken) {
		this.apiToken = apiToken;
	}
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
	public V1 getV1() {
		return this.v1;
	}
	public V2 getV2() {
		return this.v2;
	}
	public static class V1 {
		/**
		 * ID of the custom device that is exporting metrics to Dynatrace.
		 */
		private String deviceId;
		/**
		 * Group for exported metrics. Used to specify custom device group name in the
		 * Dynatrace UI.
		 */
		private String group;
		/**
		 * Technology type for exported metrics. Used to group metrics under a logical
		 * technology name in the Dynatrace UI.
		 */
		private String technologyType = 'java';
		public String getDeviceId() {
			return this.deviceId;
		}
		public void setDeviceId(String deviceId) {
			this.deviceId = deviceId;
		}
		public String getGroup() {
			return this.group;
		}
		public void setGroup(String group) {
			this.group = group;
		}
		public String getTechnologyType() {
			return this.technologyType;
		}
		public void setTechnologyType(String technologyType) {
			this.technologyType = technologyType;
		}
	}
	public static class V2 {
		/**
		 * Default dimensions that are added to all metrics in the form of key-value
		 * pairs. These are overwritten by Micrometer tags if they use the same key.
		 */
		private Map<String, String> defaultDimensions;
		/**
		 * Whether to enable Dynatrace metadata export.
		 */
		private boolean enrichWithDynatraceMetadata = true;
		/**
		 * Prefix string that is added to all exported metrics.
		 */
		private String metricKeyPrefix;
		/**
		 * Whether to fall back to the built-in micrometer instruments for Timer and
		 * DistributionSummary.
		 */
		private boolean useDynatraceSummaryInstruments = true;
		/**
		 * Whether to export meter metadata (unit and description) to the Dynatrace
		 * backend.
		 */
		private boolean exportMeterMetadata = true;
		public Map<String, String> getDefaultDimensions() {
			return this.defaultDimensions;
		}
		public void setDefaultDimensions(Map<String, String> defaultDimensions) {
			this.defaultDimensions = defaultDimensions;
		}
		public boolean isEnrichWithDynatraceMetadata() {
			return this.enrichWithDynatraceMetadata;
		}
		public void setEnrichWithDynatraceMetadata(Boolean enrichWithDynatraceMetadata) {
			this.enrichWithDynatraceMetadata = enrichWithDynatraceMetadata;
		}
		public String getMetricKeyPrefix() {
			return this.metricKeyPrefix;
		}
		public void setMetricKeyPrefix(String metricKeyPrefix) {
			this.metricKeyPrefix = metricKeyPrefix;
		}
		public boolean isUseDynatraceSummaryInstruments() {
			return this.useDynatraceSummaryInstruments;
		}
		public void setUseDynatraceSummaryInstruments(boolean useDynatraceSummaryInstruments) {
			this.useDynatraceSummaryInstruments = useDynatraceSummaryInstruments;
		}
		public boolean isExportMeterMetadata() {
			return this.exportMeterMetadata;
		}
		public void setExportMeterMetadata(boolean exportMeterMetadata) {
			this.exportMeterMetadata = exportMeterMetadata;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.dynatrace;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.dynatrace;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(DynatraceMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('dynatrace')
@EnableConfigurationProperties(DynatraceProperties.class)
public class DynatraceMetricsExportAutoConfiguration {
	private final DynatraceProperties properties;
	public DynatraceMetricsExportAutoConfiguration(DynatraceProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public DynatraceConfig dynatraceConfig() {
		return new DynatracePropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public DynatraceMeterRegistry dynatraceMeterRegistry(DynatraceConfig dynatraceConfig, Clock clock) {
		return DynatraceMeterRegistry.builder(dynatraceConfig)
			.clock(clock)
			.httpClient(
					new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()))
			.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/**
class OtlpMetricsPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<OtlpMetricsProperties>
		implements OtlpConfig {
	/**
	 * Default value for application name if {@code spring.application.name} is not set.
	 */
	private static final String DEFAULT_APPLICATION_NAME = 'unknown_service';
	private final OpenTelemetryProperties openTelemetryProperties;
	private final OtlpMetricsConnectionDetails connectionDetails;
	private final Environment environment;
	OtlpMetricsPropertiesConfigAdapter(OtlpMetricsProperties properties,
			OpenTelemetryProperties openTelemetryProperties, OtlpMetricsConnectionDetails connectionDetails,
			Environment environment) {
		super(properties);
		this.connectionDetails = connectionDetails;
		this.openTelemetryProperties = openTelemetryProperties;
		this.environment = environment;
	}
	@Override
	public String prefix() {
		return 'management.otlp.metrics.export';
	}
	@Override
	public String url() {
		return get((properties) -> this.connectionDetails.getUrl(), OtlpConfig.super::url);
	}
	@Override
	public AggregationTemporality aggregationTemporality() {
		return get(OtlpMetricsProperties::getAggregationTemporality, OtlpConfig.super::aggregationTemporality);
	}
	@Override
	@SuppressWarnings('removal')
	public Map<String, String> resourceAttributes() {
		Map<String, String> resourceAttributes = this.openTelemetryProperties.getResourceAttributes();
		Map<String, String> result = new HashMap<>((!CollectionUtils.isEmpty(resourceAttributes)) ? resourceAttributes
				: get(OtlpMetricsProperties::getResourceAttributes, OtlpConfig.super::resourceAttributes));
		result.computeIfAbsent('service.name', (key) -> getApplicationName());
		result.computeIfAbsent('service.group', (key) -> getApplicationGroup());
		return Collections.unmodifiableMap(result);
	}
	private String getApplicationName() {
		return this.environment.getProperty('spring.application.name', DEFAULT_APPLICATION_NAME);
	}
	private String getApplicationGroup() {
		String applicationGroup = this.environment.getProperty('spring.application.group');
		return (StringUtils.hasLength(applicationGroup)) ? applicationGroup : null;
	}
	@Override
	public Map<String, String> headers() {
		return get(OtlpMetricsProperties::getHeaders, OtlpConfig.super::headers);
	}
	@Override
	public HistogramFlavor histogramFlavor() {
		return get(OtlpMetricsProperties::getHistogramFlavor, OtlpConfig.super::histogramFlavor);
	}
	@Override
	public int maxScale() {
		return get(OtlpMetricsProperties::getMaxScale, OtlpConfig.super::maxScale);
	}
	@Override
	public int maxBucketCount() {
		return get(OtlpMetricsProperties::getMaxBucketCount, OtlpConfig.super::maxBucketCount);
	}
	@Override
	public TimeUnit baseTimeUnit() {
		return get(OtlpMetricsProperties::getBaseTimeUnit, OtlpConfig.super::baseTimeUnit);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(OtlpMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('otlp')
@EnableConfigurationProperties({ OtlpMetricsProperties.class, OpenTelemetryProperties.class })
public class OtlpMetricsExportAutoConfiguration {
	private final OtlpMetricsProperties properties;
	OtlpMetricsExportAutoConfiguration(OtlpMetricsProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	OtlpMetricsConnectionDetails otlpMetricsConnectionDetails() {
		return new PropertiesOtlpMetricsConnectionDetails(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	OtlpConfig otlpConfig(OpenTelemetryProperties openTelemetryProperties,
			OtlpMetricsConnectionDetails connectionDetails, Environment environment) {
		return new OtlpMetricsPropertiesConfigAdapter(this.properties, openTelemetryProperties, connectionDetails,
				environment);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.PLATFORM)
	public OtlpMeterRegistry otlpMeterRegistry(OtlpConfig otlpConfig, Clock clock) {
		return new OtlpMeterRegistry(otlpConfig, clock);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.VIRTUAL)
	public OtlpMeterRegistry otlpMeterRegistryVirtualThreads(OtlpConfig otlpConfig, Clock clock) {
		VirtualThreadTaskExecutor taskExecutor = new VirtualThreadTaskExecutor('otlp-meter-registry-');
		return new OtlpMeterRegistry(otlpConfig, clock, taskExecutor.getVirtualThreadFactory());
	}
	/**
	 * Adapts {@link OtlpMetricsProperties} to {@link OtlpMetricsConnectionDetails}.
	 */
	static class PropertiesOtlpMetricsConnectionDetails implements OtlpMetricsConnectionDetails {
		private final OtlpMetricsProperties properties;
		PropertiesOtlpMetricsConnectionDetails(OtlpMetricsProperties properties) {
			this.properties = properties;
		}
		@Override
		public String getUrl() {
			return this.properties.getUrl();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/**
@ConfigurationProperties(prefix = 'management.otlp.metrics.export')
public class OtlpMetricsProperties extends StepRegistryProperties {
	/**
	 * URI of the OTLP server.
	 */
	private String url = 'http://localhost:4318/v1/metrics';
	/**
	 * Aggregation temporality of sums. It defines the way additive values are expressed.
	 * This setting depends on the backend you use, some only support one temporality.
	 */
	private AggregationTemporality aggregationTemporality = AggregationTemporality.CUMULATIVE;
	/**
	 * Monitored resource"s attributes.
	 */
	private Map<String, String> resourceAttributes;
	/**
	 * Headers for the exported metrics.
	 */
	private Map<String, String> headers;
	/**
	 * Histogram type to be preferred when histogram publishing is enabled.
	 */
	private HistogramFlavor histogramFlavor = HistogramFlavor.EXPLICIT_BUCKET_HISTOGRAM;
	/**
	 * Max scale to use for exponential histograms, if configured.
	 */
	private int maxScale = 20;
	/**
	 * Maximum number of buckets to be used for exponential histograms, if configured.
	 * This has no effect on explicit bucket histograms.
	 */
	private int maxBucketCount = 160;
	/**
	 * Time unit for exported metrics.
	 */
	private TimeUnit baseTimeUnit = TimeUnit.MILLISECONDS;
	public String getUrl() {
		return this.url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public AggregationTemporality getAggregationTemporality() {
		return this.aggregationTemporality;
	}
	public void setAggregationTemporality(AggregationTemporality aggregationTemporality) {
		this.aggregationTemporality = aggregationTemporality;
	}
	@Deprecated(since = '3.2.0', forRemoval = true)
	@DeprecatedConfigurationProperty(replacement = 'management.opentelemetry.resource-attributes', since = '3.2.0')
	public Map<String, String> getResourceAttributes() {
		return this.resourceAttributes;
	}
	@Deprecated(since = '3.2.0', forRemoval = true)
	public void setResourceAttributes(Map<String, String> resourceAttributes) {
		this.resourceAttributes = resourceAttributes;
	}
	public Map<String, String> getHeaders() {
		return this.headers;
	}
	public void setHeaders(Map<String, String> headers) {
		this.headers = headers;
	}
	public HistogramFlavor getHistogramFlavor() {
		return this.histogramFlavor;
	}
	public void setHistogramFlavor(HistogramFlavor histogramFlavor) {
		this.histogramFlavor = histogramFlavor;
	}
	public int getMaxScale() {
		return this.maxScale;
	}
	public void setMaxScale(int maxScale) {
		this.maxScale = maxScale;
	}
	public int getMaxBucketCount() {
		return this.maxBucketCount;
	}
	public void setMaxBucketCount(int maxBucketCount) {
		this.maxBucketCount = maxBucketCount;
	}
	public TimeUnit getBaseTimeUnit() {
		return this.baseTimeUnit;
	}
	public void setBaseTimeUnit(TimeUnit baseTimeUnit) {
		this.baseTimeUnit = baseTimeUnit;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.otlp;
/**
public interface OtlpMetricsConnectionDetails extends ConnectionDetails {
	/**
	 * Address to where metrics will be published.
	 * @return the address to where metrics will be published
	 */
	String getUrl();
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.influx;
/**
class InfluxPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<InfluxProperties>
		implements InfluxConfig {
	InfluxPropertiesConfigAdapter(InfluxProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.influx.metrics.export';
	}
	@Override
	public String db() {
		return get(InfluxProperties::getDb, InfluxConfig.super::db);
	}
	@Override
	public InfluxConsistency consistency() {
		return get(InfluxProperties::getConsistency, InfluxConfig.super::consistency);
	}
	@Override
	public String userName() {
		return get(InfluxProperties::getUserName, InfluxConfig.super::userName);
	}
	@Override
	public String password() {
		return get(InfluxProperties::getPassword, InfluxConfig.super::password);
	}
	@Override
	public String retentionPolicy() {
		return get(InfluxProperties::getRetentionPolicy, InfluxConfig.super::retentionPolicy);
	}
	@Override
	public Integer retentionReplicationFactor() {
		return get(InfluxProperties::getRetentionReplicationFactor, InfluxConfig.super::retentionReplicationFactor);
	}
	@Override
	public String retentionDuration() {
		return get(InfluxProperties::getRetentionDuration, InfluxConfig.super::retentionDuration);
	}
	@Override
	public String retentionShardDuration() {
		return get(InfluxProperties::getRetentionShardDuration, InfluxConfig.super::retentionShardDuration);
	}
	@Override
	public String uri() {
		return get(InfluxProperties::getUri, InfluxConfig.super::uri);
	}
	@Override
	public boolean compressed() {
		return get(InfluxProperties::isCompressed, InfluxConfig.super::compressed);
	}
	@Override
	public boolean autoCreateDb() {
		return get(InfluxProperties::isAutoCreateDb, InfluxConfig.super::autoCreateDb);
	}
	@Override
	public InfluxApiVersion apiVersion() {
		return get(InfluxProperties::getApiVersion, InfluxConfig.super::apiVersion);
	}
	@Override
	public String org() {
		return get(InfluxProperties::getOrg, InfluxConfig.super::org);
	}
	@Override
	public String bucket() {
		return get(InfluxProperties::getBucket, InfluxConfig.super::bucket);
	}
	@Override
	public String token() {
		return get(InfluxProperties::getToken, InfluxConfig.super::token);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.influx;
/**
@ConfigurationProperties(prefix = 'management.influx.metrics.export')
public class InfluxProperties extends StepRegistryProperties {
	/**
	 * Database to send metrics to. InfluxDB v1 only.
	 */
	private String db = 'mydb';
	/**
	 * Write consistency for each point.
	 */
	private InfluxConsistency consistency = InfluxConsistency.ONE;
	/**
	 * Login user of the Influx server. InfluxDB v1 only.
	 */
	private String userName;
	/**
	 * Login password of the Influx server. InfluxDB v1 only.
	 */
	private String password;
	/**
	 * Retention policy to use (Influx writes to the DEFAULT retention policy if one is
	 * not specified). InfluxDB v1 only.
	 */
	private String retentionPolicy;
	/**
	 * Time period for which Influx should retain data in the current database. For
	 * instance 7d, check the influx documentation for more details on the duration
	 * format. InfluxDB v1 only.
	 */
	private String retentionDuration;
	/**
	 * How many copies of the data are stored in the cluster. Must be 1 for a single node
	 * instance. InfluxDB v1 only.
	 */
	private Integer retentionReplicationFactor;
	/**
	 * Time range covered by a shard group. For instance 2w, check the influx
	 * documentation for more details on the duration format. InfluxDB v1 only.
	 */
	private String retentionShardDuration;
	/**
	 * URI of the Influx server.
	 */
	private String uri = 'http://localhost:8086';
	/**
	 * Whether to enable GZIP compression of metrics batches published to Influx.
	 */
	private boolean compressed = true;
	/**
	 * Whether to create the Influx database if it does not exist before attempting to
	 * publish metrics to it. InfluxDB v1 only.
	 */
	private boolean autoCreateDb = true;
	/**
	 * API version of InfluxDB to use. Defaults to "v1" unless an org is configured. If an
	 * org is configured, defaults to "v2".
	 */
	private InfluxApiVersion apiVersion;
	/**
	 * Org to write metrics to. InfluxDB v2 only.
	 */
	private String org;
	/**
	 * Bucket for metrics. Use either the bucket name or ID. Defaults to the value of the
	 * db property if not set. InfluxDB v2 only.
	 */
	private String bucket;
	/**
	 * Authentication token to use with calls to the InfluxDB backend. For InfluxDB v1,
	 * the Bearer scheme is used. For v2, the Token scheme is used.
	 */
	private String token;
	public String getDb() {
		return this.db;
	}
	public void setDb(String db) {
		this.db = db;
	}
	public InfluxConsistency getConsistency() {
		return this.consistency;
	}
	public void setConsistency(InfluxConsistency consistency) {
		this.consistency = consistency;
	}
	public String getUserName() {
		return this.userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getRetentionPolicy() {
		return this.retentionPolicy;
	}
	public void setRetentionPolicy(String retentionPolicy) {
		this.retentionPolicy = retentionPolicy;
	}
	public String getRetentionDuration() {
		return this.retentionDuration;
	}
	public void setRetentionDuration(String retentionDuration) {
		this.retentionDuration = retentionDuration;
	}
	public Integer getRetentionReplicationFactor() {
		return this.retentionReplicationFactor;
	}
	public void setRetentionReplicationFactor(Integer retentionReplicationFactor) {
		this.retentionReplicationFactor = retentionReplicationFactor;
	}
	public String getRetentionShardDuration() {
		return this.retentionShardDuration;
	}
	public void setRetentionShardDuration(String retentionShardDuration) {
		this.retentionShardDuration = retentionShardDuration;
	}
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
	public boolean isCompressed() {
		return this.compressed;
	}
	public void setCompressed(boolean compressed) {
		this.compressed = compressed;
	}
	public boolean isAutoCreateDb() {
		return this.autoCreateDb;
	}
	public void setAutoCreateDb(boolean autoCreateDb) {
		this.autoCreateDb = autoCreateDb;
	}
	public InfluxApiVersion getApiVersion() {
		return this.apiVersion;
	}
	public void setApiVersion(InfluxApiVersion apiVersion) {
		this.apiVersion = apiVersion;
	}
	public String getOrg() {
		return this.org;
	}
	public void setOrg(String org) {
		this.org = org;
	}
	public String getBucket() {
		return this.bucket;
	}
	public void setBucket(String bucket) {
		this.bucket = bucket;
	}
	public String getToken() {
		return this.token;
	}
	public void setToken(String token) {
		this.token = token;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.influx;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.influx;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(InfluxMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('influx')
@EnableConfigurationProperties(InfluxProperties.class)
public class InfluxMetricsExportAutoConfiguration {
	private final InfluxProperties properties;
	public InfluxMetricsExportAutoConfiguration(InfluxProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public InfluxConfig influxConfig() {
		return new InfluxPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public InfluxMeterRegistry influxMeterRegistry(InfluxConfig influxConfig, Clock clock) {
		return InfluxMeterRegistry.builder(influxConfig)
			.clock(clock)
			.httpClient(
					new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()))
			.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.newrelic;
/**
@ConfigurationProperties(prefix = 'management.newrelic.metrics.export')
public class NewRelicProperties extends StepRegistryProperties {
	/**
	 * Whether to send the meter name as the event type instead of using the "event-type"
	 * configuration property value. Can be set to "true" if New Relic guidelines are not
	 * being followed or event types consistent with previous Spring Boot releases are
	 * required.
	 */
	private boolean meterNameEventTypeEnabled;
	/**
	 * The event type that should be published. This property will be ignored if
	 * "meter-name-event-type-enabled" is set to "true".
	 */
	private String eventType = 'SpringBootSample';
	/**
	 * Client provider type to use.
	 */
	private ClientProviderType clientProviderType = ClientProviderType.INSIGHTS_API;
	/**
	 * New Relic API key.
	 */
	private String apiKey;
	/**
	 * New Relic account ID.
	 */
	private String accountId;
	/**
	 * URI to ship metrics to.
	 */
	private String uri = 'https://insights-collector.newrelic.com';
	public boolean isMeterNameEventTypeEnabled() {
		return this.meterNameEventTypeEnabled;
	}
	public void setMeterNameEventTypeEnabled(boolean meterNameEventTypeEnabled) {
		this.meterNameEventTypeEnabled = meterNameEventTypeEnabled;
	}
	public String getEventType() {
		return this.eventType;
	}
	public void setEventType(String eventType) {
		this.eventType = eventType;
	}
	public ClientProviderType getClientProviderType() {
		return this.clientProviderType;
	}
	public void setClientProviderType(ClientProviderType clientProviderType) {
		this.clientProviderType = clientProviderType;
	}
	public String getApiKey() {
		return this.apiKey;
	}
	public void setApiKey(String apiKey) {
		this.apiKey = apiKey;
	}
	public String getAccountId() {
		return this.accountId;
	}
	public void setAccountId(String accountId) {
		this.accountId = accountId;
	}
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.newrelic;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(NewRelicMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('newrelic')
@EnableConfigurationProperties(NewRelicProperties.class)
public class NewRelicMetricsExportAutoConfiguration {
	private final NewRelicProperties properties;
	public NewRelicMetricsExportAutoConfiguration(NewRelicProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public NewRelicConfig newRelicConfig() {
		return new NewRelicPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public NewRelicClientProvider newRelicClientProvider(NewRelicConfig newRelicConfig) {
		if (newRelicConfig.clientProviderType() == ClientProviderType.INSIGHTS_AGENT) {
			return new NewRelicInsightsAgentClientProvider(newRelicConfig);
		}
		return new NewRelicInsightsApiClientProvider(newRelicConfig,
				new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()));
	}
	@Bean
	@ConditionalOnMissingBean
	public NewRelicMeterRegistry newRelicMeterRegistry(NewRelicConfig newRelicConfig, Clock clock,
			NewRelicClientProvider newRelicClientProvider) {
		return NewRelicMeterRegistry.builder(newRelicConfig)
			.clock(clock)
			.clientProvider(newRelicClientProvider)
			.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.newrelic;
/**
public class NewRelicPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<NewRelicProperties>
		implements NewRelicConfig {
	public NewRelicPropertiesConfigAdapter(NewRelicProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.newrelic.metrics.export';
	}
	@Override
	public boolean meterNameEventTypeEnabled() {
		return get(NewRelicProperties::isMeterNameEventTypeEnabled, NewRelicConfig.super::meterNameEventTypeEnabled);
	}
	@Override
	public String eventType() {
		return get(NewRelicProperties::getEventType, NewRelicConfig.super::eventType);
	}
	@Override
	public ClientProviderType clientProviderType() {
		return get(NewRelicProperties::getClientProviderType, NewRelicConfig.super::clientProviderType);
	}
	@Override
	public String apiKey() {
		return get(NewRelicProperties::getApiKey, NewRelicConfig.super::apiKey);
	}
	@Override
	public String accountId() {
		return get(NewRelicProperties::getAccountId, NewRelicConfig.super::accountId);
	}
	@Override
	public String uri() {
		return get(NewRelicProperties::getUri, NewRelicConfig.super::uri);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.newrelic;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.signalfx;
/**
public class SignalFxPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<SignalFxProperties>
		implements SignalFxConfig {
	public SignalFxPropertiesConfigAdapter(SignalFxProperties properties) {
		super(properties);
		accessToken(); // validate that an access token is set
	}
	@Override
	public String prefix() {
		return 'management.signalfx.metrics.export';
	}
	@Override
	public String accessToken() {
		return get(SignalFxProperties::getAccessToken, SignalFxConfig.super::accessToken);
	}
	@Override
	public String uri() {
		return get(SignalFxProperties::getUri, SignalFxConfig.super::uri);
	}
	@Override
	public String source() {
		return get(SignalFxProperties::getSource, SignalFxConfig.super::source);
	}
	@Override
	public boolean publishCumulativeHistogram() {
		return get(this::isPublishCumulativeHistogram, SignalFxConfig.super::publishCumulativeHistogram);
	}
	private boolean isPublishCumulativeHistogram(SignalFxProperties properties) {
		return HistogramType.CUMULATIVE == properties.getPublishedHistogramType();
	}
	@Override
	public boolean publishDeltaHistogram() {
		return get(this::isPublishDeltaHistogram, SignalFxConfig.super::publishDeltaHistogram);
	}
	private boolean isPublishDeltaHistogram(SignalFxProperties properties) {
		return HistogramType.DELTA == properties.getPublishedHistogramType();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.signalfx;
/**
@ConfigurationProperties(prefix = 'management.signalfx.metrics.export')
public class SignalFxProperties extends StepRegistryProperties {
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofSeconds(10);
	/**
	 * SignalFX access token.
	 */
	private String accessToken;
	/**
	 * URI to ship metrics to.
	 */
	private String uri = 'https://ingest.signalfx.com';
	/**
	 * Uniquely identifies the app instance that is publishing metrics to SignalFx.
	 * Defaults to the local host name.
	 */
	private String source;
	/**
	 * Type of histogram to publish.
	 */
	private HistogramType publishedHistogramType = HistogramType.DEFAULT;
	@Override
	public Duration getStep() {
		return this.step;
	}
	@Override
	public void setStep(Duration step) {
		this.step = step;
	}
	public String getAccessToken() {
		return this.accessToken;
	}
	public void setAccessToken(String accessToken) {
		this.accessToken = accessToken;
	}
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
	public String getSource() {
		return this.source;
	}
	public void setSource(String source) {
		this.source = source;
	}
	public HistogramType getPublishedHistogramType() {
		return this.publishedHistogramType;
	}
	public void setPublishedHistogramType(HistogramType publishedHistogramType) {
		this.publishedHistogramType = publishedHistogramType;
	}
	public enum HistogramType {
		/**
		 * Default, time-based histogram.
		 */
		DEFAULT,
		/**
		 * Cumulative histogram.
		 */
		CUMULATIVE,
		/**
		 * Delta histogram.
		 */
		DELTA
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.signalfx;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(SignalFxMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('signalfx')
@EnableConfigurationProperties(SignalFxProperties.class)
public class SignalFxMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public SignalFxConfig signalfxConfig(SignalFxProperties props) {
		return new SignalFxPropertiesConfigAdapter(props);
	}
	@Bean
	@ConditionalOnMissingBean
	public SignalFxMeterRegistry signalFxMeterRegistry(SignalFxConfig config, Clock clock) {
		return new SignalFxMeterRegistry(config, clock);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.signalfx;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.wavefront;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = { MetricsAutoConfiguration.class, WavefrontAutoConfiguration.class })
@ConditionalOnBean(Clock.class)
@ConditionalOnClass({ WavefrontMeterRegistry.class, WavefrontSender.class })
@ConditionalOnEnabledMetricsExport('wavefront')
@EnableConfigurationProperties(WavefrontProperties.class)
@Import(WavefrontSenderConfiguration.class)
public class WavefrontMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public WavefrontConfig wavefrontConfig(WavefrontProperties properties) {
		return new WavefrontPropertiesConfigAdapter(properties);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(WavefrontSender.class)
	public WavefrontMeterRegistry wavefrontMeterRegistry(WavefrontConfig wavefrontConfig, Clock clock,
			WavefrontSender wavefrontSender) {
		return WavefrontMeterRegistry.builder(wavefrontConfig).clock(clock).wavefrontSender(wavefrontSender).build();
	}
	@Bean
	@ConditionalOnBean(ApplicationTags.class)
	MeterRegistryCustomizer<WavefrontMeterRegistry> wavefrontApplicationTagsCustomizer(
			ApplicationTags wavefrontApplicationTags) {
		Tags commonTags = Tags.of(wavefrontApplicationTags.toPointTags().entrySet().stream().map(this::asTag).toList());
		return (registry) -> registry.config().commonTags(commonTags);
	}
	private Tag asTag(Map.Entry<String, String> entry) {
		return Tag.of(entry.getKey(), entry.getValue());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.wavefront;
/**
public class WavefrontPropertiesConfigAdapter
		extends PushRegistryPropertiesConfigAdapter<WavefrontProperties.Metrics.Export> implements WavefrontConfig {
	private final WavefrontProperties properties;
	public WavefrontPropertiesConfigAdapter(WavefrontProperties properties) {
		super(properties.getMetrics().getExport());
		this.properties = properties;
	}
	@Override
	public String prefix() {
		return 'management.wavefront.metrics.export';
	}
	@Override
	public String uri() {
		return this.properties.getEffectiveUri().toString();
	}
	@Override
	public String source() {
		return this.properties.getSourceOrDefault();
	}
	@Override
	public int batchSize() {
		return this.properties.getSender().getBatchSize();
	}
	@Override
	public String apiToken() {
		return this.properties.getApiTokenOrThrow();
	}
	@Override
	public String globalPrefix() {
		return get(Export::getGlobalPrefix, WavefrontConfig.super::globalPrefix);
	}
	@Override
	public boolean reportMinuteDistribution() {
		return get(Export::isReportMinuteDistribution, WavefrontConfig.super::reportMinuteDistribution);
	}
	@Override
	public boolean reportHourDistribution() {
		return get(Export::isReportHourDistribution, WavefrontConfig.super::reportHourDistribution);
	}
	@Override
	public boolean reportDayDistribution() {
		return get(Export::isReportDayDistribution, WavefrontConfig.super::reportDayDistribution);
	}
	@Override
	public Type apiTokenType() {
		return this.properties.getWavefrontApiTokenType();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.wavefront;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.atlas;
/**
class AtlasPropertiesConfigAdapter extends PropertiesConfigAdapter<AtlasProperties> implements AtlasConfig {
	AtlasPropertiesConfigAdapter(AtlasProperties properties) {
		super(properties);
	}
	@Override
	public String get(String key) {
		return null;
	}
	@Override
	public Duration step() {
		return get(AtlasProperties::getStep, AtlasConfig.super::step);
	}
	@Override
	public boolean enabled() {
		return get(AtlasProperties::isEnabled, AtlasConfig.super::enabled);
	}
	@Override
	public Duration connectTimeout() {
		return get(AtlasProperties::getConnectTimeout, AtlasConfig.super::connectTimeout);
	}
	@Override
	public Duration readTimeout() {
		return get(AtlasProperties::getReadTimeout, AtlasConfig.super::readTimeout);
	}
	@Override
	public int numThreads() {
		return get(AtlasProperties::getNumThreads, AtlasConfig.super::numThreads);
	}
	@Override
	public int batchSize() {
		return get(AtlasProperties::getBatchSize, AtlasConfig.super::batchSize);
	}
	@Override
	public String uri() {
		return get(AtlasProperties::getUri, AtlasConfig.super::uri);
	}
	@Override
	public Duration meterTTL() {
		return get(AtlasProperties::getMeterTimeToLive, AtlasConfig.super::meterTTL);
	}
	@Override
	public boolean lwcEnabled() {
		return get(AtlasProperties::isLwcEnabled, AtlasConfig.super::lwcEnabled);
	}
	@Override
	public Duration lwcStep() {
		return get(AtlasProperties::getLwcStep, AtlasConfig.super::lwcStep);
	}
	@Override
	public boolean lwcIgnorePublishStep() {
		return get(AtlasProperties::isLwcIgnorePublishStep, AtlasConfig.super::lwcIgnorePublishStep);
	}
	@Override
	public Duration configRefreshFrequency() {
		return get(AtlasProperties::getConfigRefreshFrequency, AtlasConfig.super::configRefreshFrequency);
	}
	@Override
	public Duration configTTL() {
		return get(AtlasProperties::getConfigTimeToLive, AtlasConfig.super::configTTL);
	}
	@Override
	public String configUri() {
		return get(AtlasProperties::getConfigUri, AtlasConfig.super::configUri);
	}
	@Override
	public String evalUri() {
		return get(AtlasProperties::getEvalUri, AtlasConfig.super::evalUri);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.atlas;
/**
@ConfigurationProperties(prefix = 'management.atlas.metrics.export')
public class AtlasProperties {
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofMinutes(1);
	/**
	 * Whether exporting of metrics to this backend is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Connection timeout for requests to this backend.
	 */
	private Duration connectTimeout = Duration.ofSeconds(1);
	/**
	 * Read timeout for requests to this backend.
	 */
	private Duration readTimeout = Duration.ofSeconds(10);
	/**
	 * Number of threads to use with the metrics publishing scheduler.
	 */
	private Integer numThreads = 4;
	/**
	 * Number of measurements per request to use for this backend. If more measurements
	 * are found, then multiple requests will be made.
	 */
	private Integer batchSize = 10000;
	/**
	 * URI of the Atlas server.
	 */
	private String uri = 'http://localhost:7101/api/v1/publish';
	/**
	 * Time to live for meters that do not have any activity. After this period the meter
	 * will be considered expired and will not get reported.
	 */
	private Duration meterTimeToLive = Duration.ofMinutes(15);
	/**
	 * Whether to enable streaming to Atlas LWC.
	 */
	private boolean lwcEnabled;
	/**
	 * Step size (reporting frequency) to use for streaming to Atlas LWC. This is the
	 * highest supported resolution for getting an on-demand stream of the data. It must
	 * be less than or equal to management.metrics.export.atlas.step and
	 * management.metrics.export.atlas.step should be an even multiple of this value.
	 */
	private Duration lwcStep = Duration.ofSeconds(5);
	/**
	 * Whether expressions with the same step size as Atlas publishing should be ignored
	 * for streaming. Used for cases where data being published to Atlas is also sent into
	 * streaming from the backend.
	 */
	private boolean lwcIgnorePublishStep = true;
	/**
	 * Frequency for refreshing config settings from the LWC service.
	 */
	private Duration configRefreshFrequency = Duration.ofSeconds(10);
	/**
	 * Time to live for subscriptions from the LWC service.
	 */
	private Duration configTimeToLive = Duration.ofSeconds(150);
	/**
	 * URI for the Atlas LWC endpoint to retrieve current subscriptions.
	 */
	private String configUri = 'http://localhost:7101/lwc/api/v1/expressions/local-dev';
	/**
	 * URI for the Atlas LWC endpoint to evaluate the data for a subscription.
	 */
	private String evalUri = 'http://localhost:7101/lwc/api/v1/evaluate';
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public Duration getReadTimeout() {
		return this.readTimeout;
	}
	public void setReadTimeout(Duration readTimeout) {
		this.readTimeout = readTimeout;
	}
	public Integer getNumThreads() {
		return this.numThreads;
	}
	public void setNumThreads(Integer numThreads) {
		this.numThreads = numThreads;
	}
	public Integer getBatchSize() {
		return this.batchSize;
	}
	public void setBatchSize(Integer batchSize) {
		this.batchSize = batchSize;
	}
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
	public Duration getMeterTimeToLive() {
		return this.meterTimeToLive;
	}
	public void setMeterTimeToLive(Duration meterTimeToLive) {
		this.meterTimeToLive = meterTimeToLive;
	}
	public boolean isLwcEnabled() {
		return this.lwcEnabled;
	}
	public void setLwcEnabled(boolean lwcEnabled) {
		this.lwcEnabled = lwcEnabled;
	}
	public Duration getLwcStep() {
		return this.lwcStep;
	}
	public void setLwcStep(Duration lwcStep) {
		this.lwcStep = lwcStep;
	}
	public boolean isLwcIgnorePublishStep() {
		return this.lwcIgnorePublishStep;
	}
	public void setLwcIgnorePublishStep(boolean lwcIgnorePublishStep) {
		this.lwcIgnorePublishStep = lwcIgnorePublishStep;
	}
	public Duration getConfigRefreshFrequency() {
		return this.configRefreshFrequency;
	}
	public void setConfigRefreshFrequency(Duration configRefreshFrequency) {
		this.configRefreshFrequency = configRefreshFrequency;
	}
	public Duration getConfigTimeToLive() {
		return this.configTimeToLive;
	}
	public void setConfigTimeToLive(Duration configTimeToLive) {
		this.configTimeToLive = configTimeToLive;
	}
	public String getConfigUri() {
		return this.configUri;
	}
	public void setConfigUri(String configUri) {
		this.configUri = configUri;
	}
	public String getEvalUri() {
		return this.evalUri;
	}
	public void setEvalUri(String evalUri) {
		this.evalUri = evalUri;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.atlas;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(AtlasMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('atlas')
@EnableConfigurationProperties(AtlasProperties.class)
public class AtlasMetricsExportAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public AtlasConfig atlasConfig(AtlasProperties atlasProperties) {
		return new AtlasPropertiesConfigAdapter(atlasProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	public AtlasMeterRegistry atlasMeterRegistry(AtlasConfig atlasConfig, Clock clock) {
		return new AtlasMeterRegistry(atlasConfig, clock);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.atlas;
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.stackdriver;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(StackdriverMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('stackdriver')
@EnableConfigurationProperties(StackdriverProperties.class)
public class StackdriverMetricsExportAutoConfiguration {
	private final StackdriverProperties properties;
	public StackdriverMetricsExportAutoConfiguration(StackdriverProperties stackdriverProperties) {
		this.properties = stackdriverProperties;
	}
	@Bean
	@ConditionalOnMissingBean
	public StackdriverConfig stackdriverConfig() {
		return new StackdriverPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public StackdriverMeterRegistry stackdriverMeterRegistry(StackdriverConfig stackdriverConfig, Clock clock) {
		return StackdriverMeterRegistry.builder(stackdriverConfig).clock(clock).build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.stackdriver;
/**
@ConfigurationProperties(prefix = 'management.stackdriver.metrics.export')
public class StackdriverProperties extends StepRegistryProperties {
	/**
	 * Identifier of the Google Cloud project to monitor.
	 */
	private String projectId;
	/**
	 * Monitored resource type.
	 */
	private String resourceType = 'global';
	/**
	 * Monitored resource"s labels.
	 */
	private Map<String, String> resourceLabels;
	/**
	 * Whether to use semantically correct metric types. When false, counter metrics are
	 * published as the GAUGE MetricKind. When true, counter metrics are published as the
	 * CUMULATIVE MetricKind.
	 */
	private boolean useSemanticMetricTypes = false;
	/**
	 * Prefix for metric type. Valid prefixes are described in the Google Cloud
	 * documentation (https://cloud.google.com/monitoring/custom-metrics#identifier).
	 */
	private String metricTypePrefix = 'custom.googleapis.com/';
	public String getProjectId() {
		return this.projectId;
	}
	public void setProjectId(String projectId) {
		this.projectId = projectId;
	}
	public String getResourceType() {
		return this.resourceType;
	}
	public void setResourceType(String resourceType) {
		this.resourceType = resourceType;
	}
	public Map<String, String> getResourceLabels() {
		return this.resourceLabels;
	}
	public void setResourceLabels(Map<String, String> resourceLabels) {
		this.resourceLabels = resourceLabels;
	}
	public boolean isUseSemanticMetricTypes() {
		return this.useSemanticMetricTypes;
	}
	public void setUseSemanticMetricTypes(boolean useSemanticMetricTypes) {
		this.useSemanticMetricTypes = useSemanticMetricTypes;
	}
	public String getMetricTypePrefix() {
		return this.metricTypePrefix;
	}
	public void setMetricTypePrefix(String metricTypePrefix) {
		this.metricTypePrefix = metricTypePrefix;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.stackdriver;
/**
public class StackdriverPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<StackdriverProperties>
		implements StackdriverConfig {
	public StackdriverPropertiesConfigAdapter(StackdriverProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.stackdriver.metrics.export';
	}
	@Override
	public String projectId() {
		return get(StackdriverProperties::getProjectId, StackdriverConfig.super::projectId);
	}
	@Override
	public String resourceType() {
		return get(StackdriverProperties::getResourceType, StackdriverConfig.super::resourceType);
	}
	@Override
	public Map<String, String> resourceLabels() {
		return get(StackdriverProperties::getResourceLabels, StackdriverConfig.super::resourceLabels);
	}
	@Override
	public boolean useSemanticMetricTypes() {
		return get(StackdriverProperties::isUseSemanticMetricTypes, StackdriverConfig.super::useSemanticMetricTypes);
	}
	@Override
	public String metricTypePrefix() {
		return get(StackdriverProperties::getMetricTypePrefix, StackdriverConfig.super::metricTypePrefix);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.stackdriver;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.humio;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(HumioMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('humio')
@EnableConfigurationProperties(HumioProperties.class)
public class HumioMetricsExportAutoConfiguration {
	private final HumioProperties properties;
	public HumioMetricsExportAutoConfiguration(HumioProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public HumioConfig humioConfig() {
		return new HumioPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public HumioMeterRegistry humioMeterRegistry(HumioConfig humioConfig, Clock clock) {
		return HumioMeterRegistry.builder(humioConfig)
			.clock(clock)
			.httpClient(
					new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()))
			.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.humio;
/**
class HumioPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<HumioProperties> implements HumioConfig {
	HumioPropertiesConfigAdapter(HumioProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.humio.metrics.export';
	}
	@Override
	public String get(String k) {
		return null;
	}
	@Override
	public String uri() {
		return get(HumioProperties::getUri, HumioConfig.super::uri);
	}
	@Override
	public Map<String, String> tags() {
		return get(HumioProperties::getTags, HumioConfig.super::tags);
	}
	@Override
	public String apiToken() {
		return get(HumioProperties::getApiToken, HumioConfig.super::apiToken);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.humio;
/**
@ConfigurationProperties(prefix = 'management.humio.metrics.export')
public class HumioProperties extends StepRegistryProperties {
	/**
	 * Humio API token.
	 */
	private String apiToken;
	/**
	 * Connection timeout for requests to this backend.
	 */
	private Duration connectTimeout = Duration.ofSeconds(5);
	/**
	 * Humio tags describing the data source in which metrics will be stored. Humio tags
	 * are a distinct concept from Micrometer"s tags. Micrometer"s tags are used to divide
	 * metrics along dimensional boundaries.
	 */
	private Map<String, String> tags = new HashMap<>();
	/**
	 * URI to ship metrics to. If you need to publish metrics to an internal proxy
	 * en-route to Humio, you can define the location of the proxy with this.
	 */
	private String uri = 'https://cloud.humio.com';
	public String getApiToken() {
		return this.apiToken;
	}
	public void setApiToken(String apiToken) {
		this.apiToken = apiToken;
	}
	@Override
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	@Override
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public Map<String, String> getTags() {
		return this.tags;
	}
	public void setTags(Map<String, String> tags) {
		this.tags = tags;
	}
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.humio;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.appoptics;
/**
@ConfigurationProperties(prefix = 'management.appoptics.metrics.export')
public class AppOpticsProperties extends StepRegistryProperties {
	/**
	 * URI to ship metrics to.
	 */
	private String uri = 'https://api.appoptics.com/v1/measurements';
	/**
	 * AppOptics API token.
	 */
	private String apiToken;
	/**
	 * Tag that will be mapped to '@host' when shipping metrics to AppOptics.
	 */
	private String hostTag = 'instance';
	/**
	 * Whether to ship a floored time, useful when sending measurements from multiple
	 * hosts to align them on a given time boundary.
	 */
	private boolean floorTimes;
	/**
	 * Number of measurements per request to use for this backend. If more measurements
	 * are found, then multiple requests will be made.
	 */
	private Integer batchSize = 500;
	/**
	 * Connection timeout for requests to this backend.
	 */
	private Duration connectTimeout = Duration.ofSeconds(5);
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
	public String getApiToken() {
		return this.apiToken;
	}
	public void setApiToken(String apiToken) {
		this.apiToken = apiToken;
	}
	public String getHostTag() {
		return this.hostTag;
	}
	public void setHostTag(String hostTag) {
		this.hostTag = hostTag;
	}
	public boolean isFloorTimes() {
		return this.floorTimes;
	}
	public void setFloorTimes(boolean floorTimes) {
		this.floorTimes = floorTimes;
	}
	@Override
	public Integer getBatchSize() {
		return this.batchSize;
	}
	@Override
	public void setBatchSize(Integer batchSize) {
		this.batchSize = batchSize;
	}
	@Override
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	@Override
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.appoptics;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.appoptics;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(AppOpticsMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('appoptics')
@EnableConfigurationProperties(AppOpticsProperties.class)
public class AppOpticsMetricsExportAutoConfiguration {
	private final AppOpticsProperties properties;
	public AppOpticsMetricsExportAutoConfiguration(AppOpticsProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public AppOpticsConfig appOpticsConfig() {
		return new AppOpticsPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public AppOpticsMeterRegistry appOpticsMeterRegistry(AppOpticsConfig config, Clock clock) {
		return AppOpticsMeterRegistry.builder(config)
			.clock(clock)
			.httpClient(
					new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()))
			.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.appoptics;
/**
class AppOpticsPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<AppOpticsProperties>
		implements AppOpticsConfig {
	AppOpticsPropertiesConfigAdapter(AppOpticsProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.appoptics.metrics.export';
	}
	@Override
	public String uri() {
		return get(AppOpticsProperties::getUri, AppOpticsConfig.super::uri);
	}
	@Override
	public String apiToken() {
		return get(AppOpticsProperties::getApiToken, AppOpticsConfig.super::apiToken);
	}
	@Override
	public String hostTag() {
		return get(AppOpticsProperties::getHostTag, AppOpticsConfig.super::hostTag);
	}
	@Override
	public boolean floorTimes() {
		return get(AppOpticsProperties::isFloorTimes, AppOpticsConfig.super::floorTimes);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.simple;
/**
public class SimplePropertiesConfigAdapter extends PropertiesConfigAdapter<SimpleProperties> implements SimpleConfig {
	public SimplePropertiesConfigAdapter(SimpleProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.simple.metrics.export';
	}
	@Override
	public String get(String k) {
		return null;
	}
	@Override
	public Duration step() {
		return get(SimpleProperties::getStep, SimpleConfig.super::step);
	}
	@Override
	public CountingMode mode() {
		return get(SimpleProperties::getMode, SimpleConfig.super::mode);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.simple;
/**
@AutoConfiguration(before = CompositeMeterRegistryAutoConfiguration.class, after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@EnableConfigurationProperties(SimpleProperties.class)
@ConditionalOnMissingBean(MeterRegistry.class)
@ConditionalOnEnabledMetricsExport('simple')
public class SimpleMetricsExportAutoConfiguration {
	@Bean
	public SimpleMeterRegistry simpleMeterRegistry(SimpleConfig config, Clock clock) {
		return new SimpleMeterRegistry(config, clock);
	}
	@Bean
	@ConditionalOnMissingBean
	public SimpleConfig simpleConfig(SimpleProperties simpleProperties) {
		return new SimplePropertiesConfigAdapter(simpleProperties);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.simple;
/**
@ConfigurationProperties(prefix = 'management.simple.metrics.export')
public class SimpleProperties {
	/**
	 * Whether exporting of metrics to this backend is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Step size (i.e. reporting frequency) to use.
	 */
	private Duration step = Duration.ofMinutes(1);
	/**
	 * Counting mode.
	 */
	private CountingMode mode = CountingMode.CUMULATIVE;
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public Duration getStep() {
		return this.step;
	}
	public void setStep(Duration step) {
		this.step = step;
	}
	public CountingMode getMode() {
		return this.mode;
	}
	public void setMode(CountingMode mode) {
		this.mode = mode;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.simple;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.datadog;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(DatadogMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('datadog')
@EnableConfigurationProperties(DatadogProperties.class)
public class DatadogMetricsExportAutoConfiguration {
	private final DatadogProperties properties;
	public DatadogMetricsExportAutoConfiguration(DatadogProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public DatadogConfig datadogConfig() {
		return new DatadogPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public DatadogMeterRegistry datadogMeterRegistry(DatadogConfig datadogConfig, Clock clock) {
		return DatadogMeterRegistry.builder(datadogConfig)
			.clock(clock)
			.httpClient(
					new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()))
			.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.datadog;
/**
@ConfigurationProperties(prefix = 'management.datadog.metrics.export')
public class DatadogProperties extends StepRegistryProperties {
	/**
	 * Datadog API key.
	 */
	private String apiKey;
	/**
	 * Datadog application key. Not strictly required, but improves the Datadog experience
	 * by sending meter descriptions, types, and base units to Datadog.
	 */
	private String applicationKey;
	/**
	 * Whether to publish descriptions metadata to Datadog. Turn this off to minimize the
	 * amount of metadata sent.
	 */
	private boolean descriptions = true;
	/**
	 * Tag that will be mapped to 'host' when shipping metrics to Datadog.
	 */
	private String hostTag = 'instance';
	/**
	 * URI to ship metrics to. Set this if you need to publish metrics to a Datadog site
	 * other than US, or to an internal proxy en-route to Datadog.
	 */
	private String uri = 'https://api.datadoghq.com';
	public String getApiKey() {
		return this.apiKey;
	}
	public void setApiKey(String apiKey) {
		this.apiKey = apiKey;
	}
	public String getApplicationKey() {
		return this.applicationKey;
	}
	public void setApplicationKey(String applicationKey) {
		this.applicationKey = applicationKey;
	}
	public boolean isDescriptions() {
		return this.descriptions;
	}
	public void setDescriptions(boolean descriptions) {
		this.descriptions = descriptions;
	}
	public String getHostTag() {
		return this.hostTag;
	}
	public void setHostTag(String hostTag) {
		this.hostTag = hostTag;
	}
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.datadog;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.datadog;
/**
class DatadogPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<DatadogProperties>
		implements DatadogConfig {
	DatadogPropertiesConfigAdapter(DatadogProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.datadog.metrics.export';
	}
	@Override
	public String apiKey() {
		return get(DatadogProperties::getApiKey, DatadogConfig.super::apiKey);
	}
	@Override
	public String applicationKey() {
		return get(DatadogProperties::getApplicationKey, DatadogConfig.super::applicationKey);
	}
	@Override
	public String hostTag() {
		return get(DatadogProperties::getHostTag, DatadogConfig.super::hostTag);
	}
	@Override
	public String uri() {
		return get(DatadogProperties::getUri, DatadogConfig.super::uri);
	}
	@Override
	public boolean descriptions() {
		return get(DatadogProperties::isDescriptions, DatadogConfig.super::descriptions);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.kairos;
/**
@AutoConfiguration(
		before = { CompositeMeterRegistryAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class },
		after = MetricsAutoConfiguration.class)
@ConditionalOnBean(Clock.class)
@ConditionalOnClass(KairosMeterRegistry.class)
@ConditionalOnEnabledMetricsExport('kairos')
@EnableConfigurationProperties(KairosProperties.class)
public class KairosMetricsExportAutoConfiguration {
	private final KairosProperties properties;
	public KairosMetricsExportAutoConfiguration(KairosProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public KairosConfig kairosConfig() {
		return new KairosPropertiesConfigAdapter(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public KairosMeterRegistry kairosMeterRegistry(KairosConfig kairosConfig, Clock clock) {
		return KairosMeterRegistry.builder(kairosConfig)
			.clock(clock)
			.httpClient(
					new HttpUrlConnectionSender(this.properties.getConnectTimeout(), this.properties.getReadTimeout()))
			.build();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.export.kairos;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.kairos;
/**
@ConfigurationProperties(prefix = 'management.kairos.metrics.export')
public class KairosProperties extends StepRegistryProperties {
	/**
	 * URI of the KairosDB server.
	 */
	private String uri = 'http://localhost:8080/api/v1/datapoints';
	/**
	 * Login user of the KairosDB server.
	 */
	private String userName;
	/**
	 * Login password of the KairosDB server.
	 */
	private String password;
	public String getUri() {
		return this.uri;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
	public String getUserName() {
		return this.userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.export.kairos;
/**
class KairosPropertiesConfigAdapter extends StepRegistryPropertiesConfigAdapter<KairosProperties>
		implements KairosConfig {
	KairosPropertiesConfigAdapter(KairosProperties properties) {
		super(properties);
	}
	@Override
	public String prefix() {
		return 'management.kairos.metrics.export';
	}
	@Override
	public String uri() {
		return get(KairosProperties::getUri, KairosConfig.super::uri);
	}
	@Override
	public String userName() {
		return get(KairosProperties::getUserName, KairosConfig.super::userName);
	}
	@Override
	public String password() {
		return get(KairosProperties::getPassword, KairosConfig.super::password);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.jdbc;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, DataSourceAutoConfiguration.class,
		SimpleMetricsExportAutoConfiguration.class })
@ConditionalOnClass({ DataSource.class, MeterRegistry.class })
@ConditionalOnBean({ DataSource.class, MeterRegistry.class })
public class DataSourcePoolMetricsAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(DataSourcePoolMetadataProvider.class)
	static class DataSourcePoolMetadataMetricsConfiguration {
		private static final String DATASOURCE_SUFFIX = 'dataSource';
		@Bean
		DataSourcePoolMetadataMeterBinder dataSourcePoolMetadataMeterBinder(Map<String, DataSource> dataSources,
				ObjectProvider<DataSourcePoolMetadataProvider> metadataProviders) {
			return new DataSourcePoolMetadataMeterBinder(dataSources, metadataProviders);
		}
		static class DataSourcePoolMetadataMeterBinder implements MeterBinder {
			private final Map<String, DataSource> dataSources;
			private final ObjectProvider<DataSourcePoolMetadataProvider> metadataProviders;
			DataSourcePoolMetadataMeterBinder(Map<String, DataSource> dataSources,
					ObjectProvider<DataSourcePoolMetadataProvider> metadataProviders) {
				this.dataSources = dataSources;
				this.metadataProviders = metadataProviders;
			}
			@Override
			public void bindTo(MeterRegistry registry) {
				List<DataSourcePoolMetadataProvider> metadataProvidersList = this.metadataProviders.stream().toList();
				this.dataSources.forEach((name, dataSource) -> bindDataSourceToRegistry(name, dataSource,
						metadataProvidersList, registry));
			}
			private void bindDataSourceToRegistry(String beanName, DataSource dataSource,
					Collection<DataSourcePoolMetadataProvider> metadataProviders, MeterRegistry registry) {
				String dataSourceName = getDataSourceName(beanName);
				new DataSourcePoolMetrics(dataSource, metadataProviders, dataSourceName, Collections.emptyList())
					.bindTo(registry);
			}
			/**
			 * Get the name of a DataSource based on its {@code beanName}.
			 * @param beanName the name of the data source bean
			 * @return a name for the given data source
			 */
			private String getDataSourceName(String beanName) {
				if (beanName.length() > DATASOURCE_SUFFIX.length()
						&& StringUtils.endsWithIgnoreCase(beanName, DATASOURCE_SUFFIX)) {
					return beanName.substring(0, beanName.length() - DATASOURCE_SUFFIX.length());
				}
				return beanName;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HikariDataSource.class)
	static class HikariDataSourceMetricsConfiguration {
		@Bean
		HikariDataSourceMeterBinder hikariDataSourceMeterBinder(ObjectProvider<DataSource> dataSources) {
			return new HikariDataSourceMeterBinder(dataSources);
		}
		static class HikariDataSourceMeterBinder implements MeterBinder {
			private static final Log logger = LogFactory.getLog(HikariDataSourceMeterBinder.class);
			private final ObjectProvider<DataSource> dataSources;
			HikariDataSourceMeterBinder(ObjectProvider<DataSource> dataSources) {
				this.dataSources = dataSources;
			}
			@Override
			public void bindTo(MeterRegistry registry) {
				for (DataSource dataSource : this.dataSources) {
					HikariDataSource hikariDataSource = DataSourceUnwrapper.unwrap(dataSource, HikariConfigMXBean.class,
							HikariDataSource.class);
					if (hikariDataSource != null) {
						bindMetricsRegistryToHikariDataSource(hikariDataSource, registry);
					}
				}
			}
			private void bindMetricsRegistryToHikariDataSource(HikariDataSource hikari, MeterRegistry registry) {
				if (hikari.getMetricRegistry() == null && hikari.getMetricsTrackerFactory() == null) {
					try {
						hikari.setMetricsTrackerFactory(new MicrometerMetricsTrackerFactory(registry));
					}
					catch (Exception ex) {
						logger.warn(LogMessage.format('Failed to bind Hikari metrics: %s', ex.getMessage()));
					}
				}
			}
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.jdbc;
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@FunctionalInterface
public interface MeterRegistryCustomizer<T extends MeterRegistry> {
	/**
	 * Customize the given {@code registry}.
	 * @param registry the registry to customize
	 */
	void customize(T registry);
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.task;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class,
		TaskExecutionAutoConfiguration.class, TaskSchedulingAutoConfiguration.class })
@ConditionalOnClass(ExecutorServiceMetrics.class)
@ConditionalOnBean({ Executor.class, MeterRegistry.class })
public class TaskExecutorMetricsAutoConfiguration {
	@Autowired
	public void bindTaskExecutorsToRegistry(Map<String, Executor> executors, MeterRegistry registry) {
		executors.forEach((beanName, executor) -> {
			if (executor instanceof ThreadPoolTaskExecutor threadPoolTaskExecutor) {
				monitor(registry, safeGetThreadPoolExecutor(threadPoolTaskExecutor), beanName);
			}
			else if (executor instanceof ThreadPoolTaskScheduler threadPoolTaskScheduler) {
				monitor(registry, safeGetThreadPoolExecutor(threadPoolTaskScheduler), beanName);
			}
		});
	}
	@Bean
	static LazyInitializationExcludeFilter eagerTaskExecutorMetrics() {
		return LazyInitializationExcludeFilter.forBeanTypes(TaskExecutorMetricsAutoConfiguration.class);
	}
	private void monitor(MeterRegistry registry, ThreadPoolExecutor threadPoolExecutor, String name) {
		if (threadPoolExecutor != null) {
			new ExecutorServiceMetrics(threadPoolExecutor, name, Collections.emptyList()).bindTo(registry);
		}
	}
	private ThreadPoolExecutor safeGetThreadPoolExecutor(ThreadPoolTaskExecutor taskExecutor) {
		try {
			return taskExecutor.getThreadPoolExecutor();
		}
		catch (IllegalStateException ex) {
			return null;
		}
	}
	private ThreadPoolExecutor safeGetThreadPoolExecutor(ThreadPoolTaskScheduler taskScheduler) {
		try {
			return taskScheduler.getScheduledThreadPoolExecutor();
		}
		catch (IllegalStateException ex) {
			return null;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.task;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.cache;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CacheAutoConfiguration.class })
@ConditionalOnBean(CacheManager.class)
@Import({ CacheMeterBinderProvidersConfiguration.class, CacheMetricsRegistrarConfiguration.class })
public class CacheMetricsAutoConfiguration {
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(MeterBinder.class)
class CacheMeterBinderProvidersConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Cache2kBuilder.class, SpringCache2kCache.class, Cache2kCacheMetrics.class })
	static class Cache2kCacheMeterBinderProviderConfiguration {
		@Bean
		Cache2kCacheMeterBinderProvider cache2kCacheMeterBinderProvider() {
			return new Cache2kCacheMeterBinderProvider();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ CaffeineCache.class, com.github.benmanes.caffeine.cache.Cache.class })
	static class CaffeineCacheMeterBinderProviderConfiguration {
		@Bean
		CaffeineCacheMeterBinderProvider caffeineCacheMeterBinderProvider() {
			return new CaffeineCacheMeterBinderProvider();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ HazelcastCache.class, Hazelcast.class })
	static class HazelcastCacheMeterBinderProviderConfiguration {
		@Bean
		HazelcastCacheMeterBinderProvider hazelcastCacheMeterBinderProvider() {
			return new HazelcastCacheMeterBinderProvider();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ JCacheCache.class, javax.cache.CacheManager.class })
	static class JCacheCacheMeterBinderProviderConfiguration {
		@Bean
		JCacheCacheMeterBinderProvider jCacheCacheMeterBinderProvider() {
			return new JCacheCacheMeterBinderProvider();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(RedisCache.class)
	static class RedisCacheMeterBinderProviderConfiguration {
		@Bean
		RedisCacheMeterBinderProvider redisCacheMeterBinderProvider() {
			return new RedisCacheMeterBinderProvider();
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.cache;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean({ CacheMeterBinderProvider.class, MeterRegistry.class })
class CacheMetricsRegistrarConfiguration {
	private static final String CACHE_MANAGER_SUFFIX = 'cacheManager';
	private final MeterRegistry registry;
	private final CacheMetricsRegistrar cacheMetricsRegistrar;
	private final Map<String, CacheManager> cacheManagers;
	CacheMetricsRegistrarConfiguration(MeterRegistry registry, Collection<CacheMeterBinderProvider<?>> binderProviders,
			Map<String, CacheManager> cacheManagers) {
		this.registry = registry;
		this.cacheManagers = cacheManagers;
		this.cacheMetricsRegistrar = new CacheMetricsRegistrar(this.registry, binderProviders);
		bindCachesToRegistry();
	}
	@Bean
	CacheMetricsRegistrar cacheMetricsRegistrar() {
		return this.cacheMetricsRegistrar;
	}
	private void bindCachesToRegistry() {
		this.cacheManagers.forEach(this::bindCacheManagerToRegistry);
	}
	private void bindCacheManagerToRegistry(String beanName, CacheManager cacheManager) {
		cacheManager.getCacheNames()
			.forEach((cacheName) -> bindCacheToRegistry(beanName, cacheManager.getCache(cacheName)));
	}
	private void bindCacheToRegistry(String beanName, Cache cache) {
		Tag cacheManagerTag = Tag.of('cache.manager', getCacheManagerName(beanName));
		this.cacheMetricsRegistrar.bindCacheToRegistry(cache, cacheManagerTag);
	}
	/**
	 * Get the name of a {@link CacheManager} based on its {@code beanName}.
	 * @param beanName the name of the {@link CacheManager} bean
	 * @return a name for the given cache manager
	 */
	private String getCacheManagerName(String beanName) {
		if (beanName.length() > CACHE_MANAGER_SUFFIX.length()
				&& StringUtils.endsWithIgnoreCase(beanName, CACHE_MANAGER_SUFFIX)) {
			return beanName.substring(0, beanName.length() - CACHE_MANAGER_SUFFIX.length());
		}
		return beanName;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.web.jetty;
/**
@AutoConfiguration(after = CompositeMeterRegistryAutoConfiguration.class)
@ConditionalOnWebApplication
@ConditionalOnClass({ JettyServerThreadPoolMetrics.class, Server.class })
@ConditionalOnBean(MeterRegistry.class)
public class JettyMetricsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean({ JettyServerThreadPoolMetrics.class, JettyServerThreadPoolMetricsBinder.class })
	public JettyServerThreadPoolMetricsBinder jettyServerThreadPoolMetricsBinder(MeterRegistry meterRegistry) {
		return new JettyServerThreadPoolMetricsBinder(meterRegistry);
	}
	@Bean
	@ConditionalOnMissingBean({ JettyConnectionMetrics.class, JettyConnectionMetricsBinder.class })
	public JettyConnectionMetricsBinder jettyConnectionMetricsBinder(MeterRegistry meterRegistry) {
		return new JettyConnectionMetricsBinder(meterRegistry);
	}
	@Bean
	@ConditionalOnMissingBean({ JettySslHandshakeMetrics.class, JettySslHandshakeMetricsBinder.class })
	@ConditionalOnProperty(name = 'server.ssl.enabled', havingValue = 'true')
	public JettySslHandshakeMetricsBinder jettySslHandshakeMetricsBinder(MeterRegistry meterRegistry) {
		return new JettySslHandshakeMetricsBinder(meterRegistry);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.web.jetty;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.web.tomcat;
/**
@AutoConfiguration(after = CompositeMeterRegistryAutoConfiguration.class)
@ConditionalOnWebApplication
@ConditionalOnClass({ TomcatMetrics.class, Manager.class })
public class TomcatMetricsAutoConfiguration {
	@Bean
	@ConditionalOnBean(MeterRegistry.class)
	@ConditionalOnMissingBean({ TomcatMetrics.class, TomcatMetricsBinder.class })
	public TomcatMetricsBinder tomcatMetricsBinder(MeterRegistry meterRegistry) {
		return new TomcatMetricsBinder(meterRegistry);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.web.tomcat;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.integration;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class },
		before = IntegrationAutoConfiguration.class)
class IntegrationMetricsAutoConfiguration {
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.integration;
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
public final class ServiceLevelObjectiveBoundary {
	private final MeterValue value;
	ServiceLevelObjectiveBoundary(MeterValue value) {
		this.value = value;
	}
	/**
	 * Return the underlying value of the SLO in form suitable to apply to the given meter
	 * type.
	 * @param meterType the meter type
	 * @return the value or {@code null} if the value cannot be applied
	 */
	public 